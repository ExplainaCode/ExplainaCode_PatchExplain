record_number,buggy_code,fixed_code
72001,"public SimpleScriptContext(){
  engineScope=new SimpleBindings();
  globalScope=null;
  reader=new InputStreamReader(System.in);
  writer=new PrintWriter(System.out,true);
  errorWriter=new PrintWriter(System.err,true);
}","/** 
 * Create a   {@code SimpleScriptContext}.
 */
public SimpleScriptContext(){
  engineScope=new SimpleBindings();
  globalScope=null;
  reader=new InputStreamReader(System.in);
  writer=new PrintWriter(System.out,true);
  errorWriter=new PrintWriter(System.err,true);
}"
72002,"/** 
 * <p>Returns an object representing the value of OUT parameter  {@code parameterName} and will convert from theSQL type of the parameter to the requested Java data type, if the conversion is supported. If the conversion is not supported  or null is specified for the type, a <code>SQLException</code> is thrown. <p> At a minimum, an implementation must support the conversions defined in Appendix B, Table B-3 and conversion of appropriate user defined SQL types to a Java type which implements  {@code SQLData}, or   {@code Struct}. Additional conversions may be supported and are vendor defined.
 * @param parameterName the name of the parameter
 * @param type Class representing the Java data type to convertthe designated parameter to.
 * @return an instance of {@code type} holding the OUT parametervalue
 * @throws SQLException if conversion is not supported, type is null oranother error occurs. The getCause() method of the exception may provide a more detailed exception, for example, if a conversion error occurs
 * @throws SQLFeatureNotSupportedException if the JDBC driver does not supportthis method
 * @since 1.7
 */
public <T>T getObject(String parameterName,Class<T> type) throws SQLException ;","/** 
 * <p>Returns an object representing the value of OUT parameter  {@code parameterName} and will convert from theSQL type of the parameter to the requested Java data type, if the conversion is supported. If the conversion is not supported  or null is specified for the type, a <code>SQLException</code> is thrown. <p> At a minimum, an implementation must support the conversions defined in Appendix B, Table B-3 and conversion of appropriate user defined SQL types to a Java type which implements  {@code SQLData}, or   {@code Struct}. Additional conversions may be supported and are vendor defined.
 * @param parameterName the name of the parameter
 * @param type Class representing the Java data type to convertthe designated parameter to.
 * @param < T > the type of the class modeled by this Class object
 * @return an instance of {@code type} holding the OUT parametervalue
 * @throws SQLException if conversion is not supported, type is null oranother error occurs. The getCause() method of the exception may provide a more detailed exception, for example, if a conversion error occurs
 * @throws SQLFeatureNotSupportedException if the JDBC driver does not supportthis method
 * @since 1.7
 */
public <T>T getObject(String parameterName,Class<T> type) throws SQLException ;"
72003,"/** 
 * Retrieves whether this database supports the given result set holdability.
 * @param holdability one of the following constants:<code>ResultSet.HOLD_CURSORS_OVER_COMMIT</code> or <code>ResultSet.CLOSE_CURSORS_AT_COMMIT<code>
 * @return <code>true</code> if so; <code>false</code> otherwise
 * @exception SQLException if a database access error occurs
 * @see Connection
 * @since 1.4
 */
boolean supportsResultSetHoldability(int holdability) throws SQLException ;","/** 
 * Retrieves whether this database supports the given result set holdability.
 * @param holdability one of the following constants:<code>ResultSet.HOLD_CURSORS_OVER_COMMIT</code> or <code>ResultSet.CLOSE_CURSORS_AT_COMMIT</code>
 * @return <code>true</code> if so; <code>false</code> otherwise
 * @exception SQLException if a database access error occurs
 * @see Connection
 * @since 1.4
 */
boolean supportsResultSetHoldability(int holdability) throws SQLException ;"
72004,"/** 
 * Return the parent Logger of all the Loggers used by this driver. This should be the Logger farthest from the root Logger that is still an ancestor of all of the Loggers used by this driver. Configuring this Logger will affect all of the log messages generated by the driver. In the worst case, this may be the root Logger.
 * @return the parent Logger for this driver
 * @throws SQLFeatureNotSupportedException if the driver does not use <code>java.util.logging<code>.
 * @since 1.7
 */
public Logger getParentLogger() throws SQLFeatureNotSupportedException ;","/** 
 * Return the parent Logger of all the Loggers used by this driver. This should be the Logger farthest from the root Logger that is still an ancestor of all of the Loggers used by this driver. Configuring this Logger will affect all of the log messages generated by the driver. In the worst case, this may be the root Logger.
 * @return the parent Logger for this driver
 * @throws SQLFeatureNotSupportedException if the driver does not use{@code java.util.logging}.
 * @since 1.7
 */
public Logger getParentLogger() throws SQLFeatureNotSupportedException ;"
72005,"/** 
 * Reports whether this driver is a genuine JDBC Compliant<sup><font size=-2>TM</font></sup> driver. A driver may only report <code>true</code> here if it passes the JDBC compliance tests; otherwise it is required to return <code>false</code>. <P> JDBC compliance requires full support for the JDBC API and full support for SQL 92 Entry Level.  It is expected that JDBC compliant drivers will be available for all the major commercial databases. <P> This method is not intended to encourage the development of non-JDBC compliant drivers, but is a recognition of the fact that some vendors are interested in using the JDBC API and framework for lightweight databases that do not support full database functionality, or for special databases such as document information retrieval where a SQL implementation may not be feasible.
 * @return <code>true</code> if this driver is JDBC Compliant; <code>false</code>otherwise
 */
boolean jdbcCompliant();","/** 
 * Reports whether this driver is a genuine JDBC Compliant&trade; driver. A driver may only report <code>true</code> here if it passes the JDBC compliance tests; otherwise it is required to return <code>false</code>. <P> JDBC compliance requires full support for the JDBC API and full support for SQL 92 Entry Level.  It is expected that JDBC compliant drivers will be available for all the major commercial databases. <P> This method is not intended to encourage the development of non-JDBC compliant drivers, but is a recognition of the fact that some vendors are interested in using the JDBC API and framework for lightweight databases that do not support full database functionality, or for special databases such as document information retrieval where a SQL implementation may not be feasible.
 * @return <code>true</code> if this driver is JDBC Compliant; <code>false</code>otherwise
 */
boolean jdbcCompliant();"
72006,"/** 
 * <p>Retrieves the value of the designated column in the current row of this <code>ResultSet</code> object and will convert from the SQL type of the column to the requested Java data type, if the conversion is supported. If the conversion is not supported  or null is specified for the type, a <code>SQLException</code> is thrown. <p> At a minimum, an implementation must support the conversions defined in Appendix B, Table B-3 and conversion of appropriate user defined SQL types to a Java type which implements   {@code SQLData}, or   {@code Struct}. Additional conversions may be supported and are vendor defined.
 * @param columnLabel the label for the column specified with the SQL AS clause.If the SQL AS clause was not specified, then the label is the name of the column
 * @param type Class representing the Java data type to convert the designatedcolumn to.
 * @return an instance of {@code type} holding the column value
 * @throws SQLException if conversion is not supported, type is null oranother error occurs. The getCause() method of the exception may provide a more detailed exception, for example, if a conversion error occurs
 * @throws SQLFeatureNotSupportedException if the JDBC driver does not supportthis method
 * @since 1.7
 */
public <T>T getObject(String columnLabel,Class<T> type) throws SQLException ;","/** 
 * <p>Retrieves the value of the designated column in the current row of this <code>ResultSet</code> object and will convert from the SQL type of the column to the requested Java data type, if the conversion is supported. If the conversion is not supported  or null is specified for the type, a <code>SQLException</code> is thrown. <p> At a minimum, an implementation must support the conversions defined in Appendix B, Table B-3 and conversion of appropriate user defined SQL types to a Java type which implements   {@code SQLData}, or   {@code Struct}. Additional conversions may be supported and are vendor defined.
 * @param columnLabel the label for the column specified with the SQL AS clause.If the SQL AS clause was not specified, then the label is the name of the column
 * @param type Class representing the Java data type to convert the designatedcolumn to.
 * @param < T > the type of the class modeled by this Class object
 * @return an instance of {@code type} holding the column value
 * @throws SQLException if conversion is not supported, type is null oranother error occurs. The getCause() method of the exception may provide a more detailed exception, for example, if a conversion error occurs
 * @throws SQLFeatureNotSupportedException if the JDBC driver does not supportthis method
 * @since 1.7
 */
public <T>T getObject(String columnLabel,Class<T> type) throws SQLException ;"
72007,"/** 
 * Reads the next attribute in the stream and returns it as an  {@code Object} in the Java programming language. Theactual type of the object returned is determined by the specified Java data type, and any customizations present in this stream's type map. <P>A type map is registered with the stream by the JDBC driver before the stream is passed to the application. <P>When the attribute at the head of the stream is an SQL  {@code NULL}the method returns   {@code null}. If the attribute is an SQL structured or distinct type, it determines the SQL type of the attribute at the head of the stream. If the stream's type map has an entry for that SQL type, the driver constructs an object of the appropriate class and calls the method  {@code SQLData.readSQL} on that object, which reads additional data from thestream, using the protocol described for that method. <p> The default implementation will throw  {@code SQLFeatureNotSupportedException}
 * @param type Class representing the Java data type to convert the attribute to.
 * @return the attribute at the head of the stream as an {@code Object} in theJava programming language; {@code null} if the attribute is SQL {@code NULL}
 * @exception SQLException if a database access error occurs
 * @exception SQLFeatureNotSupportedException if the JDBC driver does not supportthis method
 * @since 1.8
 */
default <T>T readObject(Class<T> type) throws SQLException {
  throw new SQLFeatureNotSupportedException();
}","/** 
 * Reads the next attribute in the stream and returns it as an  {@code Object} in the Java programming language. Theactual type of the object returned is determined by the specified Java data type, and any customizations present in this stream's type map. <P>A type map is registered with the stream by the JDBC driver before the stream is passed to the application. <P>When the attribute at the head of the stream is an SQL  {@code NULL}the method returns   {@code null}. If the attribute is an SQL structured or distinct type, it determines the SQL type of the attribute at the head of the stream. If the stream's type map has an entry for that SQL type, the driver constructs an object of the appropriate class and calls the method  {@code SQLData.readSQL} on that object, which reads additional data from thestream, using the protocol described for that method. <p> The default implementation will throw  {@code SQLFeatureNotSupportedException}
 * @param < T > the type of the class modeled by this Class object
 * @param type Class representing the Java data type to convert the attribute to.
 * @return the attribute at the head of the stream as an {@code Object} in theJava programming language; {@code null} if the attribute is SQL {@code NULL}
 * @exception SQLException if a database access error occurs
 * @exception SQLFeatureNotSupportedException if the JDBC driver does not supportthis method
 * @since 1.8
 */
default <T>T readObject(Class<T> type) throws SQLException {
  throw new SQLFeatureNotSupportedException();
}"
72008,"/** 
 * Returns a Result for setting the XML value designated by this SQLXML instance. <p> The systemID of the Result is implementation dependent. <p> The SQL XML object becomes not writeable when this method is called and may also become not readable depending on implementation. <p> Note that SAX is a callback architecture and the returned SAXResult has a content handler assigned that will receive the SAX events based on the contents of the XML.  Call the content handler with the contents of the XML document to assign the values. <pre> SAXResult saxResult = sqlxml.setResult(SAXResult.class); ContentHandler contentHandler = saxResult.getXMLReader().getContentHandler(); contentHandler.startDocument(); // set the XML elements and attributes into the result contentHandler.endDocument(); </pre>
 * @param resultClass The class of the result, or null.If resultClass is null, a vendor specific Result implementation will be returned. The following classes are supported at a minimum: <pre> javax.xml.transform.dom.DOMResult - returns a DOMResult javax.xml.transform.sax.SAXResult - returns a SAXResult javax.xml.transform.stax.StAXResult - returns a StAXResult javax.xml.transform.stream.StreamResult - returns a StreamResult </pre>
 * @return Returns a Result for setting the XML value.
 * @throws SQLException if there is an error processing the XML valueor if this feature is not supported. The getCause() method of the exception may provide a more detailed exception, for example, if an XML parser exception occurs. An exception is thrown if the state is not writable.
 * @exception SQLFeatureNotSupportedException if the JDBC driver does not supportthis method
 * @since 1.6
 */
<T extends Result>T setResult(Class<T> resultClass) throws SQLException ;","/** 
 * Returns a Result for setting the XML value designated by this SQLXML instance. <p> The systemID of the Result is implementation dependent. <p> The SQL XML object becomes not writeable when this method is called and may also become not readable depending on implementation. <p> Note that SAX is a callback architecture and the returned SAXResult has a content handler assigned that will receive the SAX events based on the contents of the XML.  Call the content handler with the contents of the XML document to assign the values. <pre> SAXResult saxResult = sqlxml.setResult(SAXResult.class); ContentHandler contentHandler = saxResult.getXMLReader().getContentHandler(); contentHandler.startDocument(); // set the XML elements and attributes into the result contentHandler.endDocument(); </pre>
 * @param < T > the type of the class modeled by this Class object
 * @param resultClass The class of the result, or null.If resultClass is null, a vendor specific Result implementation will be returned. The following classes are supported at a minimum: <pre> javax.xml.transform.dom.DOMResult - returns a DOMResult javax.xml.transform.sax.SAXResult - returns a SAXResult javax.xml.transform.stax.StAXResult - returns a StAXResult javax.xml.transform.stream.StreamResult - returns a StreamResult </pre>
 * @return Returns a Result for setting the XML value.
 * @throws SQLException if there is an error processing the XML valueor if this feature is not supported. The getCause() method of the exception may provide a more detailed exception, for example, if an XML parser exception occurs. An exception is thrown if the state is not writable.
 * @exception SQLFeatureNotSupportedException if the JDBC driver does not supportthis method
 * @since 1.6
 */
<T extends Result>T setResult(Class<T> resultClass) throws SQLException ;"
72009,"/** 
 * Returns a Source for reading the XML value designated by this SQLXML instance. Sources are used as inputs to XML parsers and XSLT transformers. <p> Sources for XML parsers will have namespace processing on by default. The systemID of the Source is implementation dependent. <p> The SQL XML object becomes not readable when this method is called and may also become not writable depending on implementation. <p> Note that SAX is a callback architecture, so a returned SAXSource should then be set with a content handler that will receive the SAX events from parsing.  The content handler will receive callbacks based on the contents of the XML. <pre> SAXSource saxSource = sqlxml.getSource(SAXSource.class); XMLReader xmlReader = saxSource.getXMLReader(); xmlReader.setContentHandler(myHandler); xmlReader.parse(saxSource.getInputSource()); </pre>
 * @param sourceClass The class of the source, or null.If the class is null, a vendor specifc Source implementation will be returned. The following classes are supported at a minimum: <pre> javax.xml.transform.dom.DOMSource - returns a DOMSource javax.xml.transform.sax.SAXSource - returns a SAXSource javax.xml.transform.stax.StAXSource - returns a StAXSource javax.xml.transform.stream.StreamSource - returns a StreamSource </pre>
 * @return a Source for reading the XML value.
 * @throws SQLException if there is an error processing the XML valueor if this feature is not supported. The getCause() method of the exception may provide a more detailed exception, for example, if an XML parser exception occurs. An exception is thrown if the state is not readable.
 * @exception SQLFeatureNotSupportedException if the JDBC driver does not supportthis method
 * @since 1.6
 */
<T extends Source>T getSource(Class<T> sourceClass) throws SQLException ;","/** 
 * Returns a Source for reading the XML value designated by this SQLXML instance. Sources are used as inputs to XML parsers and XSLT transformers. <p> Sources for XML parsers will have namespace processing on by default. The systemID of the Source is implementation dependent. <p> The SQL XML object becomes not readable when this method is called and may also become not writable depending on implementation. <p> Note that SAX is a callback architecture, so a returned SAXSource should then be set with a content handler that will receive the SAX events from parsing.  The content handler will receive callbacks based on the contents of the XML. <pre> SAXSource saxSource = sqlxml.getSource(SAXSource.class); XMLReader xmlReader = saxSource.getXMLReader(); xmlReader.setContentHandler(myHandler); xmlReader.parse(saxSource.getInputSource()); </pre>
 * @param < T > the type of the class modeled by this Class object
 * @param sourceClass The class of the source, or null.If the class is null, a vendor specifc Source implementation will be returned. The following classes are supported at a minimum: <pre> javax.xml.transform.dom.DOMSource - returns a DOMSource javax.xml.transform.sax.SAXSource - returns a SAXSource javax.xml.transform.stax.StAXSource - returns a StAXSource javax.xml.transform.stream.StreamSource - returns a StreamSource </pre>
 * @return a Source for reading the XML value.
 * @throws SQLException if there is an error processing the XML valueor if this feature is not supported. The getCause() method of the exception may provide a more detailed exception, for example, if an XML parser exception occurs. An exception is thrown if the state is not readable.
 * @exception SQLFeatureNotSupportedException if the JDBC driver does not supportthis method
 * @since 1.6
 */
<T extends Source>T getSource(Class<T> sourceClass) throws SQLException ;"
72010,"/** 
 * Returns an object that implements the given interface to allow access to non-standard methods, or standard methods not exposed by the proxy. If the receiver implements the interface then the result is the receiver or a proxy for the receiver. If the receiver is a wrapper and the wrapped object implements the interface then the result is the wrapped object or a proxy for the wrapped object. Otherwise return the the result of calling <code>unwrap</code> recursively on the wrapped object or a proxy for that result. If the receiver is not a wrapper and does not implement the interface, then an <code>SQLException</code> is thrown.
 * @param iface A Class defining an interface that the result must implement.
 * @return an object that implements the interface. May be a proxy for the actual implementing object.
 * @throws java.sql.SQLException If no object found that implements the interface
 * @since 1.6
 */
<T>T unwrap(java.lang.Class<T> iface) throws java.sql.SQLException ;","/** 
 * Returns an object that implements the given interface to allow access to non-standard methods, or standard methods not exposed by the proxy. If the receiver implements the interface then the result is the receiver or a proxy for the receiver. If the receiver is a wrapper and the wrapped object implements the interface then the result is the wrapped object or a proxy for the wrapped object. Otherwise return the the result of calling <code>unwrap</code> recursively on the wrapped object or a proxy for that result. If the receiver is not a wrapper and does not implement the interface, then an <code>SQLException</code> is thrown.
 * @param < T > the type of the class modeled by this Class object
 * @param iface A Class defining an interface that the result must implement.
 * @return an object that implements the interface. May be a proxy for the actual implementing object.
 * @throws java.sql.SQLException If no object found that implements the interface
 * @since 1.6
 */
<T>T unwrap(java.lang.Class<T> iface) throws java.sql.SQLException ;"
72011,"/** 
 * Return the parent Logger of all the Loggers used by this data source. This should be the Logger farthest from the root Logger that is still an ancestor of all of the Loggers used by this data source. Configuring this Logger will affect all of the log messages generated by the data source. In the worst case, this may be the root Logger.
 * @return the parent Logger for this data source
 * @throws SQLFeatureNotSupportedException if the data source does not use <code>java.util.logging<code>.
 * @since 1.7
 */
public Logger getParentLogger() throws SQLFeatureNotSupportedException ;","/** 
 * Return the parent Logger of all the Loggers used by this data source. This should be the Logger farthest from the root Logger that is still an ancestor of all of the Loggers used by this data source. Configuring this Logger will affect all of the log messages generated by the data source. In the worst case, this may be the root Logger.
 * @return the parent Logger for this data source
 * @throws SQLFeatureNotSupportedException if the data source does not use{@code java.util.logging}
 * @since 1.7
 */
public Logger getParentLogger() throws SQLFeatureNotSupportedException ;"
72012,"/** 
 * Notifies registered listeners that a RowSet object in the given RowSetEvent object has populated a number of additional rows. The <code>numRows</code> parameter ensures that this event will only be fired every <code>numRow</code>. <p> The source of the event can be retrieved with the method event.getSource.
 * @param event a <code>RowSetEvent</code> object that contains the<code>RowSet</code> object that is the source of the events
 * @param numRows when populating, the number of rows interval on which the<code>CachedRowSet</code> populated should fire; the default value is zero; cannot be less than <code>fetchSize</code> or zero
 */
public void rowSetPopulated(RowSetEvent event,int numRows) throws SQLException ;","/** 
 * Notifies registered listeners that a RowSet object in the given RowSetEvent object has populated a number of additional rows. The <code>numRows</code> parameter ensures that this event will only be fired every <code>numRow</code>. <p> The source of the event can be retrieved with the method event.getSource.
 * @param event a <code>RowSetEvent</code> object that contains the<code>RowSet</code> object that is the source of the events
 * @param numRows when populating, the number of rows interval on which the<code>CachedRowSet</code> populated should fire; the default value is zero; cannot be less than <code>fetchSize</code> or zero
 * @throws SQLException {@code numRows < 0 or numRows < getFetchSize() }
 */
public void rowSetPopulated(RowSetEvent event,int numRows) throws SQLException ;"
72013,"/** 
 * Propagates all row update, insert and delete changes to the data source backing this <code>CachedRowSet</code> object using the specified <code>Connection</code> object to establish a connection to the data source. <P> The other version of the <code>acceptChanges</code> method is not passed a connection because it uses the <code>Connection</code> object already defined within the <code>RowSet</code> object, which is the connection used for populating it initially. <P> This form of the method <code>acceptChanges</code> is similar to the form that takes no arguments; however, unlike the other form, this form can be used only when the underlying data source is a JDBC data source. The updated <code>Connection</code> properties must be used by the <code>SyncProvider</code> to reset the <code>RowSetWriter</code> configuration to ensure that the contents of the <code>CachedRowSet</code> object are synchronized correctly. <P> When the method <code>acceptChanges</code> executes successfully, in addition to writing changes to the data source, it makes the values in the current row be the values in the original row. <P> Depending on the synchronization level of the <code>SyncProvider</code> implementation being used, the writer will compare the original values with those in the data source to check for conflicts. When there is a conflict, the <code>RIOptimisticProvider</code> implementation, for example, throws a <code>SyncProviderException</code> and does not write anything to the data source. <P> An application may choose to catch the <code>SyncProviderException</code> object and retrieve the <code>SyncResolver</code> object it contains. The <code>SyncResolver</code> object lists the conflicts row by row and sets a lock on the data source to avoid further conflicts while the current conflicts are being resolved. Further, for each conflict, it provides methods for examining the conflict and setting the value that should be persisted in the data source. After all conflicts have been resolved, an application must call the <code>acceptChanges</code> method again to write resolved values to the data source.  If all of the values in the data source are already the values to be persisted, the method <code>acceptChanges</code> does nothing. <P> Some provider implementations may use locks to ensure that there are no conflicts.  In such cases, it is guaranteed that the writer will succeed in writing changes to the data source when the method <code>acceptChanges</code> is called.  This method may be called immediately after the methods <code>updateRow</code>, <code>insertRow</code>, or <code>deleteRow</code> have been called, but it is more efficient to call it only once after all changes have been made so that only one connection needs to be established. <P> Note: The <code>acceptChanges()</code> method will determine if the <code>COMMIT_ON_ACCEPT_CHANGES</code> is set to true or not. If it is set to true, all updates in the synchronization are committed to the data source. Otherwise, the application <b>must</b> explicity call the <code>commit</code> or <code>rollback</code> methods as appropriate.
 * @param con a standard JDBC <code>Connection</code> object
 * @throws SQLException if the cursor is on the insert row
 * @throws SyncProviderException if the underlyingsynchronization provider's writer fails to write the updates back to the data source
 * @see #acceptChanges()
 * @see javax.sql.RowSetWriter
 * @see javax.sql.rowset.spi.SyncFactory
 * @see javax.sql.rowset.spi.SyncProvider
 * @see javax.sql.rowset.spi.SyncProviderException
 * @see javax.sql.rowset.spi.SyncResolver
 */
public void acceptChanges(Connection con) throws SyncProviderException ;","/** 
 * Propagates all row update, insert and delete changes to the data source backing this <code>CachedRowSet</code> object using the specified <code>Connection</code> object to establish a connection to the data source. <P> The other version of the <code>acceptChanges</code> method is not passed a connection because it uses the <code>Connection</code> object already defined within the <code>RowSet</code> object, which is the connection used for populating it initially. <P> This form of the method <code>acceptChanges</code> is similar to the form that takes no arguments; however, unlike the other form, this form can be used only when the underlying data source is a JDBC data source. The updated <code>Connection</code> properties must be used by the <code>SyncProvider</code> to reset the <code>RowSetWriter</code> configuration to ensure that the contents of the <code>CachedRowSet</code> object are synchronized correctly. <P> When the method <code>acceptChanges</code> executes successfully, in addition to writing changes to the data source, it makes the values in the current row be the values in the original row. <P> Depending on the synchronization level of the <code>SyncProvider</code> implementation being used, the writer will compare the original values with those in the data source to check for conflicts. When there is a conflict, the <code>RIOptimisticProvider</code> implementation, for example, throws a <code>SyncProviderException</code> and does not write anything to the data source. <P> An application may choose to catch the <code>SyncProviderException</code> object and retrieve the <code>SyncResolver</code> object it contains. The <code>SyncResolver</code> object lists the conflicts row by row and sets a lock on the data source to avoid further conflicts while the current conflicts are being resolved. Further, for each conflict, it provides methods for examining the conflict and setting the value that should be persisted in the data source. After all conflicts have been resolved, an application must call the <code>acceptChanges</code> method again to write resolved values to the data source.  If all of the values in the data source are already the values to be persisted, the method <code>acceptChanges</code> does nothing. <P> Some provider implementations may use locks to ensure that there are no conflicts.  In such cases, it is guaranteed that the writer will succeed in writing changes to the data source when the method <code>acceptChanges</code> is called.  This method may be called immediately after the methods <code>updateRow</code>, <code>insertRow</code>, or <code>deleteRow</code> have been called, but it is more efficient to call it only once after all changes have been made so that only one connection needs to be established. <P> Note: The <code>acceptChanges()</code> method will determine if the <code>COMMIT_ON_ACCEPT_CHANGES</code> is set to true or not. If it is set to true, all updates in the synchronization are committed to the data source. Otherwise, the application <b>must</b> explicity call the <code>commit</code> or <code>rollback</code> methods as appropriate.
 * @param con a standard JDBC <code>Connection</code> object
 * @throws SyncProviderException if the underlyingsynchronization provider's writer fails to write the updates back to the data source
 * @see #acceptChanges()
 * @see javax.sql.RowSetWriter
 * @see javax.sql.rowset.spi.SyncFactory
 * @see javax.sql.rowset.spi.SyncProvider
 * @see javax.sql.rowset.spi.SyncProviderException
 * @see javax.sql.rowset.spi.SyncResolver
 */
public void acceptChanges(Connection con) throws SyncProviderException ;"
72014,"/** 
 * Creates a <code>CachedRowSet</code> object that is an empty copy of this <code>CachedRowSet</code> object.  The copy must not contain any contents but only represent the table structure of the original <code>CachedRowSet</code> object. In addition, primary or foreign key constraints set in the originating <code>CachedRowSet</code> object must be equally enforced in the new empty <code>CachedRowSet</code> object. In contrast to the <code>RowSet</code> object generated from a <code>createShared</code> method call, updates made to a copy of this <code>CachedRowSet</code> object with the <code>createCopySchema</code> method must not be visible to it. <P> Applications can form a <code>WebRowSet</code> object from the <code>CachedRowSet</code> object returned by this method in order to export the <code>RowSet</code> schema definition to XML for future use.
 * @throws SQLException if an error occurs in cloning the structure of this<code>CachedRowSet</code> object
 * @see #createShared
 * @see #createCopySchema
 * @see #createCopyNoConstraints
 * @see javax.sql.RowSetEvent
 * @see javax.sql.RowSetListener
 */
public CachedRowSet createCopySchema() throws SQLException ;","/** 
 * Creates a <code>CachedRowSet</code> object that is an empty copy of this <code>CachedRowSet</code> object.  The copy must not contain any contents but only represent the table structure of the original <code>CachedRowSet</code> object. In addition, primary or foreign key constraints set in the originating <code>CachedRowSet</code> object must be equally enforced in the new empty <code>CachedRowSet</code> object. In contrast to the <code>RowSet</code> object generated from a <code>createShared</code> method call, updates made to a copy of this <code>CachedRowSet</code> object with the <code>createCopySchema</code> method must not be visible to it. <P> Applications can form a <code>WebRowSet</code> object from the <code>CachedRowSet</code> object returned by this method in order to export the <code>RowSet</code> schema definition to XML for future use.
 * @return An empty copy of this {@code CachedRowSet} object
 * @throws SQLException if an error occurs in cloning the structure of this<code>CachedRowSet</code> object
 * @see #createShared
 * @see #createCopySchema
 * @see #createCopyNoConstraints
 * @see javax.sql.RowSetEvent
 * @see javax.sql.RowSetListener
 */
public CachedRowSet createCopySchema() throws SQLException ;"
72015,"/** 
 * Retrieves the ErrorManager for this Handler.
 * @exception SecurityException  if a security manager exists and ifthe caller does not have <tt>LoggingPermission(""control"")</tt>.
 */
public ErrorManager getErrorManager(){
  checkPermission();
  return errorManager;
}","/** 
 * Retrieves the ErrorManager for this Handler.
 * @return the ErrorManager for this Handler
 * @exception SecurityException  if a security manager exists and ifthe caller does not have <tt>LoggingPermission(""control"")</tt>.
 */
public ErrorManager getErrorManager(){
  checkPermission();
  return errorManager;
}"
72016,"/** 
 * Return the global LogManager object.
 */
public static LogManager getLogManager(){
  if (manager != null) {
    manager.readPrimordialConfiguration();
  }
  return manager;
}","/** 
 * Returns the global LogManager object.
 * @return the global LogManager object
 */
public static LogManager getLogManager(){
  if (manager != null) {
    manager.readPrimordialConfiguration();
  }
  return manager;
}"
72017,"/** 
 * Get the localization resource bundle name <p> This is the name for the ResourceBundle that should be used to localize the message string before formatting it. The result may be null if the message is not localizable.
 */
public String getResourceBundleName(){
  return resourceBundleName;
}","/** 
 * Get the localization resource bundle name <p> This is the name for the ResourceBundle that should be used to localize the message string before formatting it. The result may be null if the message is not localizable.
 * @return the localization resource bundle name
 */
public String getResourceBundleName(){
  return resourceBundleName;
}"
72018,"/** 
 * Get the localization resource bundle <p> This is the ResourceBundle that should be used to localize the message string before formatting it.  The result may be null if the message is not localizable, or if no suitable ResourceBundle is available.
 */
public ResourceBundle getResourceBundle(){
  return resourceBundle;
}","/** 
 * Get the localization resource bundle <p> This is the ResourceBundle that should be used to localize the message string before formatting it.  The result may be null if the message is not localizable, or if no suitable ResourceBundle is available.
 * @return the localization resource bundle
 */
public ResourceBundle getResourceBundle(){
  return resourceBundle;
}"
72019,"/** 
 * Set the sequence number. <p> Sequence numbers are normally assigned in the LogRecord constructor, so it should not normally be necessary to use this method.
 */
public void setSequenceNumber(long seq){
  sequenceNumber=seq;
}","/** 
 * Set the sequence number. <p> Sequence numbers are normally assigned in the LogRecord constructor, so it should not normally be necessary to use this method.
 * @param seq the sequence number
 */
public void setSequenceNumber(long seq){
  sequenceNumber=seq;
}"
72020,"/** 
 * Put the given key-value association into this preference node.  It is guaranteed that <tt>key</tt> and <tt>value</tt> are non-null and of legal length.  Also, it is guaranteed that this node has not been removed.  (The implementor needn't check for any of these things.) <p>This method is invoked with the lock on this node held.
 */
protected abstract void putSpi(String key,String value);","/** 
 * Put the given key-value association into this preference node.  It is guaranteed that <tt>key</tt> and <tt>value</tt> are non-null and of legal length.  Also, it is guaranteed that this node has not been removed.  (The implementor needn't check for any of these things.) <p>This method is invoked with the lock on this node held.
 * @param key the key
 * @param value the value
 */
protected abstract void putSpi(String key,String value);"
72021,"/** 
 * Remove the association (if any) for the specified key at this preference node.  It is guaranteed that <tt>key</tt> is non-null. Also, it is guaranteed that this node has not been removed. (The implementor needn't check for either of these things.) <p>This method is invoked with the lock on this node held.
 */
protected abstract void removeSpi(String key);","/** 
 * Remove the association (if any) for the specified key at this preference node.  It is guaranteed that <tt>key</tt> is non-null. Also, it is guaranteed that this node has not been removed. (The implementor needn't check for either of these things.) <p>This method is invoked with the lock on this node held.
 * @param key the key
 */
protected abstract void removeSpi(String key);"
72022,"/** 
 * Return the value associated with the specified key at this preference node, or <tt>null</tt> if there is no association for this key, or the association cannot be determined at this time.  It is guaranteed that <tt>key</tt> is non-null.  Also, it is guaranteed that this node has not been removed.  (The implementor needn't check for either of these things.) <p> Generally speaking, this method should not throw an exception under any circumstances.  If, however, if it does throw an exception, the exception will be intercepted and treated as a <tt>null</tt> return value. <p>This method is invoked with the lock on this node held.
 * @return the value associated with the specified key at this preferencenode, or <tt>null</tt> if there is no association for this key, or the association cannot be determined at this time.
 */
protected abstract String getSpi(String key);","/** 
 * Return the value associated with the specified key at this preference node, or <tt>null</tt> if there is no association for this key, or the association cannot be determined at this time.  It is guaranteed that <tt>key</tt> is non-null.  Also, it is guaranteed that this node has not been removed.  (The implementor needn't check for either of these things.) <p> Generally speaking, this method should not throw an exception under any circumstances.  If, however, if it does throw an exception, the exception will be intercepted and treated as a <tt>null</tt> return value. <p>This method is invoked with the lock on this node held.
 * @param key the key
 * @return the value associated with the specified key at this preferencenode, or <tt>null</tt> if there is no association for this key, or the association cannot be determined at this time.
 */
protected abstract String getSpi(String key);"
72023,"/** 
 * Returns the user root preference node corresponding to the calling user.  In a server, the returned value will typically depend on some implicit client-context.
 */
Preferences userRoot();","/** 
 * Returns the user root preference node corresponding to the calling user.  In a server, the returned value will typically depend on some implicit client-context.
 * @return the user root preference node corresponding to the callinguser
 */
Preferences userRoot();"
72024,"/** 
 * Returns the system root preference node.  (Multiple calls on this method will return the same object reference.)
 */
Preferences systemRoot();","/** 
 * Returns the system root preference node.  (Multiple calls on this method will return the same object reference.)
 * @return the system root preference node
 */
Preferences systemRoot();"
72025,"/** 
 * Returns a hash code for a   {@code boolean} value; compatible with{@code Boolean.hashCode()}.
 * @since 1.8
 * @return a hash code value for a {@code boolean} value.
 */
public static int hashCode(boolean value){
  return value ? 1231 : 1237;
}","/** 
 * Returns a hash code for a   {@code boolean} value; compatible with{@code Boolean.hashCode()}.
 * @param value the value to hash
 * @return a hash code value for a {@code boolean} value.
 * @since 1.8
 */
public static int hashCode(boolean value){
  return value ? 1231 : 1237;
}"
72026,"/** 
 * Returns a hash code for a   {@code byte} value; compatible with{@code Byte.hashCode()}.
 * @since 1.8
 * @return a hash code value for a {@code byte} value.
 */
public static int hashCode(byte value){
  return (int)value;
}","/** 
 * Returns a hash code for a   {@code byte} value; compatible with{@code Byte.hashCode()}.
 * @param value the value to hash
 * @return a hash code value for a {@code byte} value.
 * @since 1.8
 */
public static int hashCode(byte value){
  return (int)value;
}"
72027,"/** 
 * Casts this   {@code Class} object to represent a subclass of the classrepresented by the specified class object.  Checks that the cast is valid, and throws a  {@code ClassCastException} if it is not.  Ifthis method succeeds, it always returns a reference to this class object. <p>This method is useful when a client needs to ""narrow"" the type of a  {@code Class} object to pass it to an API that restricts the{@code Class} objects that it is willing to accept.  A cast wouldgenerate a compile-time warning, as the correctness of the cast could not be checked at runtime (because generic types are implemented by erasure).
 * @return this {@code Class} object, cast to represent a subclass ofthe specified class object.
 * @throws ClassCastException if this {@code Class} object does notrepresent a subclass of the specified class (here ""subclass"" includes the class itself).
 * @since 1.5
 */
@SuppressWarnings(""String_Node_Str"") public <U>Class<? extends U> asSubclass(Class<U> clazz){
  if (clazz.isAssignableFrom(this))   return (Class<? extends U>)this;
 else   throw new ClassCastException(this.toString());
}","/** 
 * Casts this   {@code Class} object to represent a subclass of the classrepresented by the specified class object.  Checks that the cast is valid, and throws a  {@code ClassCastException} if it is not.  Ifthis method succeeds, it always returns a reference to this class object. <p>This method is useful when a client needs to ""narrow"" the type of a  {@code Class} object to pass it to an API that restricts the{@code Class} objects that it is willing to accept.  A cast wouldgenerate a compile-time warning, as the correctness of the cast could not be checked at runtime (because generic types are implemented by erasure).
 * @param < U > the type to cast this class object to
 * @param clazz the class of the type to cast this class object to
 * @return this {@code Class} object, cast to represent a subclass ofthe specified class object.
 * @throws ClassCastException if this {@code Class} object does notrepresent a subclass of the specified class (here ""subclass"" includes the class itself).
 * @since 1.5
 */
@SuppressWarnings(""String_Node_Str"") public <U>Class<? extends U> asSubclass(Class<U> clazz){
  if (clazz.isAssignableFrom(this))   return (Class<? extends U>)this;
 else   throw new ClassCastException(this.toString());
}"
72028,"/** 
 * Returns an array of AnnotatedType objects that represent the use of types to specify superinterfaces of the entity represented by this Class. (The <em>use</em> of type Foo to specify a superinterface in '... implements Foo' is distinct from the <em>declaration</em> of type Foo.) If this Class represents a class, the return value is an array containing objects representing the uses of interface types to specify interfaces implemented by the class. The order of the objects in the array corresponds to the order of the interface types used in the 'implements' clause of the declaration of this Class. If this Class represents an interface, the return value is an array containing objects representing the uses of interface types to specify interfaces directly extended by the interface. The order of the objects in the array corresponds to the order of the interface types used in the 'extends' clause of the declaration of this Class. If this Class represents a class or interface whose declaration does not explicitly indicate any annotated superinterfaces, the return value is an array of length 0. If this Class represents either the Object class, an array type, a primitive type, or void, the return value is an array of length 0.
 * @since 1.8
 */
public AnnotatedType[] getAnnotatedInterfaces(){
  return TypeAnnotationParser.buildAnnotatedInterfaces(getRawTypeAnnotations(),getConstantPool(),this);
}","/** 
 * Returns an array of AnnotatedType objects that represent the use of types to specify superinterfaces of the entity represented by this Class. (The <em>use</em> of type Foo to specify a superinterface in '... implements Foo' is distinct from the <em>declaration</em> of type Foo.) If this Class represents a class, the return value is an array containing objects representing the uses of interface types to specify interfaces implemented by the class. The order of the objects in the array corresponds to the order of the interface types used in the 'implements' clause of the declaration of this Class. If this Class represents an interface, the return value is an array containing objects representing the uses of interface types to specify interfaces directly extended by the interface. The order of the objects in the array corresponds to the order of the interface types used in the 'extends' clause of the declaration of this Class. If this Class represents a class or interface whose declaration does not explicitly indicate any annotated superinterfaces, the return value is an array of length 0. If this Class represents either the Object class, an array type, a primitive type, or void, the return value is an array of length 0.
 * @return an array representing the superinterfaces
 * @since 1.8
 */
public AnnotatedType[] getAnnotatedInterfaces(){
  return TypeAnnotationParser.buildAnnotatedInterfaces(getRawTypeAnnotations(),getConstantPool(),this);
}"
72029,"/** 
 * Returns an AnnotatedType object that represents the use of a type to specify the superclass of the entity represented by this Class. (The <em>use</em> of type Foo to specify the superclass in '... extends Foo' is distinct from the <em>declaration</em> of type Foo.) If this Class represents a class type whose declaration does not explicitly indicate an annotated superclass, the return value is null. If this Class represents either the Object class, an interface type, an array type, a primitive type, or void, the return value is null.
 * @since 1.8
 */
public AnnotatedType getAnnotatedSuperclass(){
  return TypeAnnotationParser.buildAnnotatedSuperclass(getRawTypeAnnotations(),getConstantPool(),this);
}","/** 
 * Returns an AnnotatedType object that represents the use of a type to specify the superclass of the entity represented by this Class. (The <em>use</em> of type Foo to specify the superclass in '... extends Foo' is distinct from the <em>declaration</em> of type Foo.) If this Class represents a class type whose declaration does not explicitly indicate an annotated superclass, the return value is null. If this Class represents either the Object class, an interface type, an array type, a primitive type, or void, the return value is null.
 * @return an object representing the superclass
 * @since 1.8
 */
public AnnotatedType getAnnotatedSuperclass(){
  return TypeAnnotationParser.buildAnnotatedSuperclass(getRawTypeAnnotations(),getConstantPool(),this);
}"
72030,"/** 
 * Returns a hash code for a   {@code double} value; compatible with{@code Double.hashCode()}.
 * @since 1.8
 * @return a hash code value for a {@code double} value.
 */
public static int hashCode(double value){
  long bits=doubleToLongBits(value);
  return (int)(bits ^ (bits >>> 32));
}","/** 
 * Returns a hash code for a   {@code double} value; compatible with{@code Double.hashCode()}.
 * @param value the value to hash
 * @return a hash code value for a {@code double} value.
 * @since 1.8
 */
public static int hashCode(double value){
  long bits=doubleToLongBits(value);
  return (int)(bits ^ (bits >>> 32));
}"
72031,"/** 
 * Returns a hash code for a   {@code float} value; compatible with{@code Float.hashCode()}.
 * @since 1.8
 * @return a hash code value for a {@code float} value.
 */
public static int hashCode(float value){
  return floatToIntBits(value);
}","/** 
 * Returns a hash code for a   {@code float} value; compatible with{@code Float.hashCode()}.
 * @param value the value to hash
 * @return a hash code value for a {@code float} value.
 * @since 1.8
 */
public static int hashCode(float value){
  return floatToIntBits(value);
}"
72032,"/** 
 * Returns the value obtained by rotating the two's complement binary representation of the specified   {@code int} value left by thespecified number of bits.  (Bits shifted out of the left hand, or high-order, side reenter on the right, or low-order.) <p>Note that left rotation with a negative distance is equivalent to right rotation:  {@code rotateLeft(val, -distance) == rotateRight(val,distance)}.  Note also that rotation by any multiple of 32 is a no-op, so all but the last five bits of the rotation distance can be ignored, even if the distance is negative:   {@code rotateLeft(val,distance) == rotateLeft(val, distance & 0x1F)}.
 * @return the value obtained by rotating the two's complement binaryrepresentation of the specified  {@code int} value left by thespecified number of bits.
 * @since 1.5
 */
public static int rotateLeft(int i,int distance){
  return (i << distance) | (i >>> -distance);
}","/** 
 * Returns the value obtained by rotating the two's complement binary representation of the specified   {@code int} value left by thespecified number of bits.  (Bits shifted out of the left hand, or high-order, side reenter on the right, or low-order.) <p>Note that left rotation with a negative distance is equivalent to right rotation:  {@code rotateLeft(val, -distance) == rotateRight(val,distance)}.  Note also that rotation by any multiple of 32 is a no-op, so all but the last five bits of the rotation distance can be ignored, even if the distance is negative:   {@code rotateLeft(val,distance) == rotateLeft(val, distance & 0x1F)}.
 * @param i the value whose bits are to be rotated left
 * @param distance the number of bit positions to rotate left
 * @return the value obtained by rotating the two's complement binaryrepresentation of the specified  {@code int} value left by thespecified number of bits.
 * @since 1.5
 */
public static int rotateLeft(int i,int distance){
  return (i << distance) | (i >>> -distance);
}"
72033,"/** 
 * Returns a hash code for a   {@code int} value; compatible with{@code Integer.hashCode()}.
 * @since 1.8
 * @return a hash code value for a {@code int} value.
 */
public static int hashCode(int value){
  return value;
}","/** 
 * Returns a hash code for a   {@code int} value; compatible with{@code Integer.hashCode()}.
 * @param value the value to hash
 * @since 1.8
 * @return a hash code value for a {@code int} value.
 */
public static int hashCode(int value){
  return value;
}"
72034,"/** 
 * Returns an   {@code int} value with at most a single one-bit, in theposition of the lowest-order (""rightmost"") one-bit in the specified {@code int} value.  Returns zero if the specified value has noone-bits in its two's complement binary representation, that is, if it is equal to zero.
 * @return an {@code int} value with a single one-bit, in the positionof the lowest-order one-bit in the specified value, or zero if the specified value is itself equal to zero.
 * @since 1.5
 */
public static int lowestOneBit(int i){
  return i & -i;
}","/** 
 * Returns an   {@code int} value with at most a single one-bit, in theposition of the lowest-order (""rightmost"") one-bit in the specified {@code int} value.  Returns zero if the specified value has noone-bits in its two's complement binary representation, that is, if it is equal to zero.
 * @param i the value whose lowest one bit is to be computed
 * @return an {@code int} value with a single one-bit, in the positionof the lowest-order one-bit in the specified value, or zero if the specified value is itself equal to zero.
 * @since 1.5
 */
public static int lowestOneBit(int i){
  return i & -i;
}"
72035,"/** 
 * Returns the signum function of the specified   {@code int} value.  (Thereturn value is -1 if the specified value is negative; 0 if the specified value is zero; and 1 if the specified value is positive.)
 * @return the signum function of the specified {@code int} value.
 * @since 1.5
 */
public static int signum(int i){
  return (i >> 31) | (-i >>> 31);
}","/** 
 * Returns the signum function of the specified   {@code int} value.  (Thereturn value is -1 if the specified value is negative; 0 if the specified value is zero; and 1 if the specified value is positive.)
 * @param i the value whose signum is to be computed
 * @return the signum function of the specified {@code int} value.
 * @since 1.5
 */
public static int signum(int i){
  return (i >> 31) | (-i >>> 31);
}"
72036,"/** 
 * Returns the value obtained by rotating the two's complement binary representation of the specified   {@code int} value right by thespecified number of bits.  (Bits shifted out of the right hand, or low-order, side reenter on the left, or high-order.) <p>Note that right rotation with a negative distance is equivalent to left rotation:  {@code rotateRight(val, -distance) == rotateLeft(val,distance)}.  Note also that rotation by any multiple of 32 is a no-op, so all but the last five bits of the rotation distance can be ignored, even if the distance is negative:   {@code rotateRight(val,distance) == rotateRight(val, distance & 0x1F)}.
 * @return the value obtained by rotating the two's complement binaryrepresentation of the specified  {@code int} value right by thespecified number of bits.
 * @since 1.5
 */
public static int rotateRight(int i,int distance){
  return (i >>> distance) | (i << -distance);
}","/** 
 * Returns the value obtained by rotating the two's complement binary representation of the specified   {@code int} value right by thespecified number of bits.  (Bits shifted out of the right hand, or low-order, side reenter on the left, or high-order.) <p>Note that right rotation with a negative distance is equivalent to left rotation:  {@code rotateRight(val, -distance) == rotateLeft(val,distance)}.  Note also that rotation by any multiple of 32 is a no-op, so all but the last five bits of the rotation distance can be ignored, even if the distance is negative:   {@code rotateRight(val,distance) == rotateRight(val, distance & 0x1F)}.
 * @param i the value whose bits are to be rotated right
 * @param distance the number of bit positions to rotate right
 * @return the value obtained by rotating the two's complement binaryrepresentation of the specified  {@code int} value right by thespecified number of bits.
 * @since 1.5
 */
public static int rotateRight(int i,int distance){
  return (i >>> distance) | (i << -distance);
}"
72037,"/** 
 * Returns the value obtained by reversing the order of the bits in the two's complement binary representation of the specified   {@code int}value.
 * @return the value obtained by reversing order of the bits in thespecified  {@code int} value.
 * @since 1.5
 */
public static int reverse(int i){
  i=(i & 0x55555555) << 1 | (i >>> 1) & 0x55555555;
  i=(i & 0x33333333) << 2 | (i >>> 2) & 0x33333333;
  i=(i & 0x0f0f0f0f) << 4 | (i >>> 4) & 0x0f0f0f0f;
  i=(i << 24) | ((i & 0xff00) << 8) | ((i >>> 8) & 0xff00)| (i >>> 24);
  return i;
}","/** 
 * Returns the value obtained by reversing the order of the bits in the two's complement binary representation of the specified   {@code int}value.
 * @param i the value to be reversed
 * @return the value obtained by reversing order of the bits in thespecified  {@code int} value.
 * @since 1.5
 */
public static int reverse(int i){
  i=(i & 0x55555555) << 1 | (i >>> 1) & 0x55555555;
  i=(i & 0x33333333) << 2 | (i >>> 2) & 0x33333333;
  i=(i & 0x0f0f0f0f) << 4 | (i >>> 4) & 0x0f0f0f0f;
  i=(i << 24) | ((i & 0xff00) << 8) | ((i >>> 8) & 0xff00)| (i >>> 24);
  return i;
}"
72038,"/** 
 * Returns the number of zero bits preceding the highest-order (""leftmost"") one-bit in the two's complement binary representation of the specified   {@code int} value.  Returns 32 if thespecified value has no one-bits in its two's complement representation, in other words if it is equal to zero. <p>Note that this method is closely related to the logarithm base 2. For all positive  {@code int} values x:<ul> <li>floor(log<sub>2</sub>(x)) =  {@code 31 - numberOfLeadingZeros(x)}<li>ceil(log<sub>2</sub>(x)) =   {@code 32 - numberOfLeadingZeros(x - 1)}</ul>
 * @return the number of zero bits preceding the highest-order(""leftmost"") one-bit in the two's complement binary representation of the specified  {@code int} value, or 32 if the valueis equal to zero.
 * @since 1.5
 */
public static int numberOfLeadingZeros(int i){
  if (i == 0)   return 32;
  int n=1;
  if (i >>> 16 == 0) {
    n+=16;
    i<<=16;
  }
  if (i >>> 24 == 0) {
    n+=8;
    i<<=8;
  }
  if (i >>> 28 == 0) {
    n+=4;
    i<<=4;
  }
  if (i >>> 30 == 0) {
    n+=2;
    i<<=2;
  }
  n-=i >>> 31;
  return n;
}","/** 
 * Returns the number of zero bits preceding the highest-order (""leftmost"") one-bit in the two's complement binary representation of the specified   {@code int} value.  Returns 32 if thespecified value has no one-bits in its two's complement representation, in other words if it is equal to zero. <p>Note that this method is closely related to the logarithm base 2. For all positive  {@code int} values x:<ul> <li>floor(log<sub>2</sub>(x)) =  {@code 31 - numberOfLeadingZeros(x)}<li>ceil(log<sub>2</sub>(x)) =   {@code 32 - numberOfLeadingZeros(x - 1)}</ul>
 * @param i the value whose number of leading zeros is to be computed
 * @return the number of zero bits preceding the highest-order(""leftmost"") one-bit in the two's complement binary representation of the specified  {@code int} value, or 32 if the valueis equal to zero.
 * @since 1.5
 */
public static int numberOfLeadingZeros(int i){
  if (i == 0)   return 32;
  int n=1;
  if (i >>> 16 == 0) {
    n+=16;
    i<<=16;
  }
  if (i >>> 24 == 0) {
    n+=8;
    i<<=8;
  }
  if (i >>> 28 == 0) {
    n+=4;
    i<<=4;
  }
  if (i >>> 30 == 0) {
    n+=2;
    i<<=2;
  }
  n-=i >>> 31;
  return n;
}"
72039,"/** 
 * Returns the number of one-bits in the two's complement binary representation of the specified   {@code int} value.  This function issometimes referred to as the <i>population count</i>.
 * @return the number of one-bits in the two's complement binaryrepresentation of the specified  {@code int} value.
 * @since 1.5
 */
public static int bitCount(int i){
  i=i - ((i >>> 1) & 0x55555555);
  i=(i & 0x33333333) + ((i >>> 2) & 0x33333333);
  i=(i + (i >>> 4)) & 0x0f0f0f0f;
  i=i + (i >>> 8);
  i=i + (i >>> 16);
  return i & 0x3f;
}","/** 
 * Returns the number of one-bits in the two's complement binary representation of the specified   {@code int} value.  This function issometimes referred to as the <i>population count</i>.
 * @param i the value whose bits are to be counted
 * @return the number of one-bits in the two's complement binaryrepresentation of the specified  {@code int} value.
 * @since 1.5
 */
public static int bitCount(int i){
  i=i - ((i >>> 1) & 0x55555555);
  i=(i & 0x33333333) + ((i >>> 2) & 0x33333333);
  i=(i + (i >>> 4)) & 0x0f0f0f0f;
  i=i + (i >>> 8);
  i=i + (i >>> 16);
  return i & 0x3f;
}"
72040,"/** 
 * Returns an   {@code int} value with at most a single one-bit, in theposition of the highest-order (""leftmost"") one-bit in the specified {@code int} value.  Returns zero if the specified value has noone-bits in its two's complement binary representation, that is, if it is equal to zero.
 * @return an {@code int} value with a single one-bit, in the positionof the highest-order one-bit in the specified value, or zero if the specified value is itself equal to zero.
 * @since 1.5
 */
public static int highestOneBit(int i){
  i|=(i >> 1);
  i|=(i >> 2);
  i|=(i >> 4);
  i|=(i >> 8);
  i|=(i >> 16);
  return i - (i >>> 1);
}","/** 
 * Returns an   {@code int} value with at most a single one-bit, in theposition of the highest-order (""leftmost"") one-bit in the specified {@code int} value.  Returns zero if the specified value has noone-bits in its two's complement binary representation, that is, if it is equal to zero.
 * @param i the value whose highest one bit is to be computed
 * @return an {@code int} value with a single one-bit, in the positionof the highest-order one-bit in the specified value, or zero if the specified value is itself equal to zero.
 * @since 1.5
 */
public static int highestOneBit(int i){
  i|=(i >> 1);
  i|=(i >> 2);
  i|=(i >> 4);
  i|=(i >> 8);
  i|=(i >> 16);
  return i - (i >>> 1);
}"
72041,"/** 
 * Returns the number of zero bits following the lowest-order (""rightmost"") one-bit in the two's complement binary representation of the specified  {@code int} value.  Returns 32 if the specified value has noone-bits in its two's complement representation, in other words if it is equal to zero.
 * @return the number of zero bits following the lowest-order (""rightmost"")one-bit in the two's complement binary representation of the specified  {@code int} value, or 32 if the value is equalto zero.
 * @since 1.5
 */
public static int numberOfTrailingZeros(int i){
  int y;
  if (i == 0)   return 32;
  int n=31;
  y=i << 16;
  if (y != 0) {
    n=n - 16;
    i=y;
  }
  y=i << 8;
  if (y != 0) {
    n=n - 8;
    i=y;
  }
  y=i << 4;
  if (y != 0) {
    n=n - 4;
    i=y;
  }
  y=i << 2;
  if (y != 0) {
    n=n - 2;
    i=y;
  }
  return n - ((i << 1) >>> 31);
}","/** 
 * Returns the number of zero bits following the lowest-order (""rightmost"") one-bit in the two's complement binary representation of the specified  {@code int} value.  Returns 32 if the specified value has noone-bits in its two's complement representation, in other words if it is equal to zero.
 * @param i the value whose number of trailing zeros is to be computed
 * @return the number of zero bits following the lowest-order (""rightmost"")one-bit in the two's complement binary representation of the specified  {@code int} value, or 32 if the value is equalto zero.
 * @since 1.5
 */
public static int numberOfTrailingZeros(int i){
  int y;
  if (i == 0)   return 32;
  int n=31;
  y=i << 16;
  if (y != 0) {
    n=n - 16;
    i=y;
  }
  y=i << 8;
  if (y != 0) {
    n=n - 8;
    i=y;
  }
  y=i << 4;
  if (y != 0) {
    n=n - 4;
    i=y;
  }
  y=i << 2;
  if (y != 0) {
    n=n - 2;
    i=y;
  }
  return n - ((i << 1) >>> 31);
}"
72042,"/** 
 * Returns the value obtained by reversing the order of the bytes in the two's complement representation of the specified   {@code int} value.
 * @return the value obtained by reversing the bytes in the specified{@code int} value.
 * @since 1.5
 */
public static int reverseBytes(int i){
  return ((i >>> 24)) | ((i >> 8) & 0xFF00) | ((i << 8) & 0xFF0000)| ((i << 24));
}","/** 
 * Returns the value obtained by reversing the order of the bytes in the two's complement representation of the specified   {@code int} value.
 * @param i the value whose bytes are to be reversed
 * @return the value obtained by reversing the bytes in the specified{@code int} value.
 * @since 1.5
 */
public static int reverseBytes(int i){
  return ((i >>> 24)) | ((i >> 8) & 0xFF00) | ((i << 8) & 0xFF0000)| ((i << 24));
}"
72043,"/** 
 * Returns the value obtained by rotating the two's complement binary representation of the specified   {@code long} value left by thespecified number of bits.  (Bits shifted out of the left hand, or high-order, side reenter on the right, or low-order.) <p>Note that left rotation with a negative distance is equivalent to right rotation:  {@code rotateLeft(val, -distance) == rotateRight(val,distance)}.  Note also that rotation by any multiple of 64 is a no-op, so all but the last six bits of the rotation distance can be ignored, even if the distance is negative:   {@code rotateLeft(val,distance) == rotateLeft(val, distance & 0x3F)}.
 * @return the value obtained by rotating the two's complement binaryrepresentation of the specified  {@code long} value left by thespecified number of bits.
 * @since 1.5
 */
public static long rotateLeft(long i,int distance){
  return (i << distance) | (i >>> -distance);
}","/** 
 * Returns the value obtained by rotating the two's complement binary representation of the specified   {@code long} value left by thespecified number of bits.  (Bits shifted out of the left hand, or high-order, side reenter on the right, or low-order.) <p>Note that left rotation with a negative distance is equivalent to right rotation:  {@code rotateLeft(val, -distance) == rotateRight(val,distance)}.  Note also that rotation by any multiple of 64 is a no-op, so all but the last six bits of the rotation distance can be ignored, even if the distance is negative:   {@code rotateLeft(val,distance) == rotateLeft(val, distance & 0x3F)}.
 * @param i the value whose bits are to be rotated left
 * @param distance the number of bit positions to rotate left
 * @return the value obtained by rotating the two's complement binaryrepresentation of the specified  {@code long} value left by thespecified number of bits.
 * @since 1.5
 */
public static long rotateLeft(long i,int distance){
  return (i << distance) | (i >>> -distance);
}"
72044,"/** 
 * Returns a hash code for a   {@code long} value; compatible with{@code Long.hashCode()}.
 * @since 1.8
 * @return a hash code value for a {@code long} value.
 */
public static int hashCode(long value){
  return (int)(value ^ (value >>> 32));
}","/** 
 * Returns a hash code for a   {@code long} value; compatible with{@code Long.hashCode()}.
 * @param value the value to hash
 * @return a hash code value for a {@code long} value.
 * @since 1.8
 */
public static int hashCode(long value){
  return (int)(value ^ (value >>> 32));
}"
72045,"/** 
 * Returns a   {@code long} value with at most a single one-bit, in theposition of the lowest-order (""rightmost"") one-bit in the specified {@code long} value.  Returns zero if the specified value has noone-bits in its two's complement binary representation, that is, if it is equal to zero.
 * @return a {@code long} value with a single one-bit, in the positionof the lowest-order one-bit in the specified value, or zero if the specified value is itself equal to zero.
 * @since 1.5
 */
public static long lowestOneBit(long i){
  return i & -i;
}","/** 
 * Returns a   {@code long} value with at most a single one-bit, in theposition of the lowest-order (""rightmost"") one-bit in the specified {@code long} value.  Returns zero if the specified value has noone-bits in its two's complement binary representation, that is, if it is equal to zero.
 * @param i the value whose lowest one bit is to be computed
 * @return a {@code long} value with a single one-bit, in the positionof the lowest-order one-bit in the specified value, or zero if the specified value is itself equal to zero.
 * @since 1.5
 */
public static long lowestOneBit(long i){
  return i & -i;
}"
72046,"/** 
 * Returns the signum function of the specified   {@code long} value.  (Thereturn value is -1 if the specified value is negative; 0 if the specified value is zero; and 1 if the specified value is positive.)
 * @return the signum function of the specified {@code long} value.
 * @since 1.5
 */
public static int signum(long i){
  return (int)((i >> 63) | (-i >>> 63));
}","/** 
 * Returns the signum function of the specified   {@code long} value.  (Thereturn value is -1 if the specified value is negative; 0 if the specified value is zero; and 1 if the specified value is positive.)
 * @param i the value whose signum is to be computed
 * @return the signum function of the specified {@code long} value.
 * @since 1.5
 */
public static int signum(long i){
  return (int)((i >> 63) | (-i >>> 63));
}"
72047,"/** 
 * Returns the value obtained by rotating the two's complement binary representation of the specified   {@code long} value right by thespecified number of bits.  (Bits shifted out of the right hand, or low-order, side reenter on the left, or high-order.) <p>Note that right rotation with a negative distance is equivalent to left rotation:  {@code rotateRight(val, -distance) == rotateLeft(val,distance)}.  Note also that rotation by any multiple of 64 is a no-op, so all but the last six bits of the rotation distance can be ignored, even if the distance is negative:   {@code rotateRight(val,distance) == rotateRight(val, distance & 0x3F)}.
 * @return the value obtained by rotating the two's complement binaryrepresentation of the specified  {@code long} value right by thespecified number of bits.
 * @since 1.5
 */
public static long rotateRight(long i,int distance){
  return (i >>> distance) | (i << -distance);
}","/** 
 * Returns the value obtained by rotating the two's complement binary representation of the specified   {@code long} value right by thespecified number of bits.  (Bits shifted out of the right hand, or low-order, side reenter on the left, or high-order.) <p>Note that right rotation with a negative distance is equivalent to left rotation:  {@code rotateRight(val, -distance) == rotateLeft(val,distance)}.  Note also that rotation by any multiple of 64 is a no-op, so all but the last six bits of the rotation distance can be ignored, even if the distance is negative:   {@code rotateRight(val,distance) == rotateRight(val, distance & 0x3F)}.
 * @param i the value whose bits are to be rotated right
 * @param distance the number of bit positions to rotate right
 * @return the value obtained by rotating the two's complement binaryrepresentation of the specified  {@code long} value right by thespecified number of bits.
 * @since 1.5
 */
public static long rotateRight(long i,int distance){
  return (i >>> distance) | (i << -distance);
}"
72048,"/** 
 * Returns the value obtained by reversing the order of the bits in the two's complement binary representation of the specified   {@code long}value.
 * @return the value obtained by reversing order of the bits in thespecified  {@code long} value.
 * @since 1.5
 */
public static long reverse(long i){
  i=(i & 0x5555555555555555L) << 1 | (i >>> 1) & 0x5555555555555555L;
  i=(i & 0x3333333333333333L) << 2 | (i >>> 2) & 0x3333333333333333L;
  i=(i & 0x0f0f0f0f0f0f0f0fL) << 4 | (i >>> 4) & 0x0f0f0f0f0f0f0f0fL;
  i=(i & 0x00ff00ff00ff00ffL) << 8 | (i >>> 8) & 0x00ff00ff00ff00ffL;
  i=(i << 48) | ((i & 0xffff0000L) << 16) | ((i >>> 16) & 0xffff0000L)| (i >>> 48);
  return i;
}","/** 
 * Returns the value obtained by reversing the order of the bits in the two's complement binary representation of the specified   {@code long}value.
 * @param i the value to be reversed
 * @return the value obtained by reversing order of the bits in thespecified  {@code long} value.
 * @since 1.5
 */
public static long reverse(long i){
  i=(i & 0x5555555555555555L) << 1 | (i >>> 1) & 0x5555555555555555L;
  i=(i & 0x3333333333333333L) << 2 | (i >>> 2) & 0x3333333333333333L;
  i=(i & 0x0f0f0f0f0f0f0f0fL) << 4 | (i >>> 4) & 0x0f0f0f0f0f0f0f0fL;
  i=(i & 0x00ff00ff00ff00ffL) << 8 | (i >>> 8) & 0x00ff00ff00ff00ffL;
  i=(i << 48) | ((i & 0xffff0000L) << 16) | ((i >>> 16) & 0xffff0000L)| (i >>> 48);
  return i;
}"
72049,"/** 
 * Returns the number of zero bits preceding the highest-order (""leftmost"") one-bit in the two's complement binary representation of the specified   {@code long} value.  Returns 64 if thespecified value has no one-bits in its two's complement representation, in other words if it is equal to zero. <p>Note that this method is closely related to the logarithm base 2. For all positive  {@code long} values x:<ul> <li>floor(log<sub>2</sub>(x)) =  {@code 63 - numberOfLeadingZeros(x)}<li>ceil(log<sub>2</sub>(x)) =   {@code 64 - numberOfLeadingZeros(x - 1)}</ul>
 * @return the number of zero bits preceding the highest-order(""leftmost"") one-bit in the two's complement binary representation of the specified  {@code long} value, or 64 if the valueis equal to zero.
 * @since 1.5
 */
public static int numberOfLeadingZeros(long i){
  if (i == 0)   return 64;
  int n=1;
  int x=(int)(i >>> 32);
  if (x == 0) {
    n+=32;
    x=(int)i;
  }
  if (x >>> 16 == 0) {
    n+=16;
    x<<=16;
  }
  if (x >>> 24 == 0) {
    n+=8;
    x<<=8;
  }
  if (x >>> 28 == 0) {
    n+=4;
    x<<=4;
  }
  if (x >>> 30 == 0) {
    n+=2;
    x<<=2;
  }
  n-=x >>> 31;
  return n;
}","/** 
 * Returns the number of zero bits preceding the highest-order (""leftmost"") one-bit in the two's complement binary representation of the specified   {@code long} value.  Returns 64 if thespecified value has no one-bits in its two's complement representation, in other words if it is equal to zero. <p>Note that this method is closely related to the logarithm base 2. For all positive  {@code long} values x:<ul> <li>floor(log<sub>2</sub>(x)) =  {@code 63 - numberOfLeadingZeros(x)}<li>ceil(log<sub>2</sub>(x)) =   {@code 64 - numberOfLeadingZeros(x - 1)}</ul>
 * @param i the value whose number of leading zeros is to be computed
 * @return the number of zero bits preceding the highest-order(""leftmost"") one-bit in the two's complement binary representation of the specified  {@code long} value, or 64 if the valueis equal to zero.
 * @since 1.5
 */
public static int numberOfLeadingZeros(long i){
  if (i == 0)   return 64;
  int n=1;
  int x=(int)(i >>> 32);
  if (x == 0) {
    n+=32;
    x=(int)i;
  }
  if (x >>> 16 == 0) {
    n+=16;
    x<<=16;
  }
  if (x >>> 24 == 0) {
    n+=8;
    x<<=8;
  }
  if (x >>> 28 == 0) {
    n+=4;
    x<<=4;
  }
  if (x >>> 30 == 0) {
    n+=2;
    x<<=2;
  }
  n-=x >>> 31;
  return n;
}"
72050,"/** 
 * Returns the number of one-bits in the two's complement binary representation of the specified   {@code long} value.  This function issometimes referred to as the <i>population count</i>.
 * @return the number of one-bits in the two's complement binaryrepresentation of the specified  {@code long} value.
 * @since 1.5
 */
public static int bitCount(long i){
  i=i - ((i >>> 1) & 0x5555555555555555L);
  i=(i & 0x3333333333333333L) + ((i >>> 2) & 0x3333333333333333L);
  i=(i + (i >>> 4)) & 0x0f0f0f0f0f0f0f0fL;
  i=i + (i >>> 8);
  i=i + (i >>> 16);
  i=i + (i >>> 32);
  return (int)i & 0x7f;
}","/** 
 * Returns the number of one-bits in the two's complement binary representation of the specified   {@code long} value.  This function issometimes referred to as the <i>population count</i>.
 * @param i the value whose bits are to be counted
 * @return the number of one-bits in the two's complement binaryrepresentation of the specified  {@code long} value.
 * @since 1.5
 */
public static int bitCount(long i){
  i=i - ((i >>> 1) & 0x5555555555555555L);
  i=(i & 0x3333333333333333L) + ((i >>> 2) & 0x3333333333333333L);
  i=(i + (i >>> 4)) & 0x0f0f0f0f0f0f0f0fL;
  i=i + (i >>> 8);
  i=i + (i >>> 16);
  i=i + (i >>> 32);
  return (int)i & 0x7f;
}"
72051,"/** 
 * Returns a   {@code long} value with at most a single one-bit, in theposition of the highest-order (""leftmost"") one-bit in the specified {@code long} value.  Returns zero if the specified value has noone-bits in its two's complement binary representation, that is, if it is equal to zero.
 * @return a {@code long} value with a single one-bit, in the positionof the highest-order one-bit in the specified value, or zero if the specified value is itself equal to zero.
 * @since 1.5
 */
public static long highestOneBit(long i){
  i|=(i >> 1);
  i|=(i >> 2);
  i|=(i >> 4);
  i|=(i >> 8);
  i|=(i >> 16);
  i|=(i >> 32);
  return i - (i >>> 1);
}","/** 
 * Returns a   {@code long} value with at most a single one-bit, in theposition of the highest-order (""leftmost"") one-bit in the specified {@code long} value.  Returns zero if the specified value has noone-bits in its two's complement binary representation, that is, if it is equal to zero.
 * @param i the value whose highest one bit is to be computed
 * @return a {@code long} value with a single one-bit, in the positionof the highest-order one-bit in the specified value, or zero if the specified value is itself equal to zero.
 * @since 1.5
 */
public static long highestOneBit(long i){
  i|=(i >> 1);
  i|=(i >> 2);
  i|=(i >> 4);
  i|=(i >> 8);
  i|=(i >> 16);
  i|=(i >> 32);
  return i - (i >>> 1);
}"
72052,"/** 
 * Returns the number of zero bits following the lowest-order (""rightmost"") one-bit in the two's complement binary representation of the specified  {@code long} value.  Returns 64 if the specified value has noone-bits in its two's complement representation, in other words if it is equal to zero.
 * @return the number of zero bits following the lowest-order (""rightmost"")one-bit in the two's complement binary representation of the specified  {@code long} value, or 64 if the value is equalto zero.
 * @since 1.5
 */
public static int numberOfTrailingZeros(long i){
  int x, y;
  if (i == 0)   return 64;
  int n=63;
  y=(int)i;
  if (y != 0) {
    n=n - 32;
    x=y;
  }
 else   x=(int)(i >>> 32);
  y=x << 16;
  if (y != 0) {
    n=n - 16;
    x=y;
  }
  y=x << 8;
  if (y != 0) {
    n=n - 8;
    x=y;
  }
  y=x << 4;
  if (y != 0) {
    n=n - 4;
    x=y;
  }
  y=x << 2;
  if (y != 0) {
    n=n - 2;
    x=y;
  }
  return n - ((x << 1) >>> 31);
}","/** 
 * Returns the number of zero bits following the lowest-order (""rightmost"") one-bit in the two's complement binary representation of the specified  {@code long} value.  Returns 64 if the specified value has noone-bits in its two's complement representation, in other words if it is equal to zero.
 * @param i the value whose number of trailing zeros is to be computed
 * @return the number of zero bits following the lowest-order (""rightmost"")one-bit in the two's complement binary representation of the specified  {@code long} value, or 64 if the value is equalto zero.
 * @since 1.5
 */
public static int numberOfTrailingZeros(long i){
  int x, y;
  if (i == 0)   return 64;
  int n=63;
  y=(int)i;
  if (y != 0) {
    n=n - 32;
    x=y;
  }
 else   x=(int)(i >>> 32);
  y=x << 16;
  if (y != 0) {
    n=n - 16;
    x=y;
  }
  y=x << 8;
  if (y != 0) {
    n=n - 8;
    x=y;
  }
  y=x << 4;
  if (y != 0) {
    n=n - 4;
    x=y;
  }
  y=x << 2;
  if (y != 0) {
    n=n - 2;
    x=y;
  }
  return n - ((x << 1) >>> 31);
}"
72053,"/** 
 * Returns the value obtained by reversing the order of the bytes in the two's complement representation of the specified   {@code long} value.
 * @return the value obtained by reversing the bytes in the specified{@code long} value.
 * @since 1.5
 */
public static long reverseBytes(long i){
  i=(i & 0x00ff00ff00ff00ffL) << 8 | (i >>> 8) & 0x00ff00ff00ff00ffL;
  return (i << 48) | ((i & 0xffff0000L) << 16) | ((i >>> 16) & 0xffff0000L)| (i >>> 48);
}","/** 
 * Returns the value obtained by reversing the order of the bytes in the two's complement representation of the specified   {@code long} value.
 * @param i the value whose bytes are to be reversed
 * @return the value obtained by reversing the bytes in the specified{@code long} value.
 * @since 1.5
 */
public static long reverseBytes(long i){
  i=(i & 0x00ff00ff00ff00ffL) << 8 | (i >>> 8) & 0x00ff00ff00ff00ffL;
  return (i << 48) | ((i & 0xffff0000L) << 16) | ((i >>> 16) & 0xffff0000L)| (i >>> 48);
}"
72054,"/** 
 * Registers a new virtual-machine shutdown hook. <p> The Java virtual machine <i>shuts down</i> in response to two kinds of events: <ul> <p> <li> The program <i>exits</i> normally, when the last non-daemon thread exits or when the <tt>  {@link #exit exit}</tt> (equivalently, <tt>  {@link System#exit(int) System.exit}</tt>) method is invoked, or <p> <li> The virtual machine is <i>terminated</i> in response to a user interrupt, such as typing <tt>^C</tt>, or a system-wide event, such as user logoff or system shutdown. </ul> <p> A <i>shutdown hook</i> is simply an initialized but unstarted thread.  When the virtual machine begins its shutdown sequence it will start all registered shutdown hooks in some unspecified order and let them run concurrently.  When all the hooks have finished it will then run all uninvoked finalizers if finalization-on-exit has been enabled. Finally, the virtual machine will halt.  Note that daemon threads will continue to run during the shutdown sequence, as will non-daemon threads if shutdown was initiated by invoking the <tt>  {@link #exit exit}</tt> method. <p> Once the shutdown sequence has begun it can be stopped only by invoking the <tt>  {@link #halt halt}</tt> method, which forcibly terminates the virtual machine. <p> Once the shutdown sequence has begun it is impossible to register a new shutdown hook or de-register a previously-registered hook. Attempting either of these operations will cause an <tt>  {@link IllegalStateException}</tt> to be thrown. <p> Shutdown hooks run at a delicate time in the life cycle of a virtual machine and should therefore be coded defensively.  They should, in particular, be written to be thread-safe and to avoid deadlocks insofar as possible.  They should also not rely blindly upon services that may have registered their own shutdown hooks and therefore may themselves in the process of shutting down.  Attempts to use other thread-based services such as the AWT event-dispatch thread, for example, may lead to deadlocks. <p> Shutdown hooks should also finish their work quickly.  When a program invokes <tt>  {@link #exit exit}</tt> the expectation is that the virtual machine will promptly shut down and exit.  When the virtual machine is terminated due to user logoff or system shutdown the underlying operating system may only allow a fixed amount of time in which to shut down and exit.  It is therefore inadvisable to attempt any user interaction or to perform a long-running computation in a shutdown hook. <p> Uncaught exceptions are handled in shutdown hooks just as in any other thread, by invoking the <tt>  {@link ThreadGroup#uncaughtException uncaughtException}</tt> method of the thread's <tt>  {@link ThreadGroup}</tt> object.  The default implementation of this method prints the exception's stack trace to <tt>  {@link System#err}</tt> and terminates the thread; it does not cause the virtual machine to exit or halt. <p> In rare circumstances the virtual machine may <i>abort</i>, that is, stop running without shutting down cleanly.  This occurs when the virtual machine is terminated externally, for example with the <tt>SIGKILL</tt> signal on Unix or the <tt>TerminateProcess</tt> call on Microsoft Windows.  The virtual machine may also abort if a native method goes awry by, for example, corrupting internal data structures or attempting to access nonexistent memory.  If the virtual machine aborts then no guarantee can be made about whether or not any shutdown hooks will be run. <p>
 * @param hook An initialized but unstarted <tt> {@link Thread}</tt> object
 * @throws IllegalArgumentException If the specified hook has already been registered, or if it can be determined that the hook is already running or has already been run
 * @throws IllegalStateException If the virtual machine is already in the process of shutting down
 * @throws SecurityException If a security manager is present and it denies <tt> {@link RuntimePermission}(""shutdownHooks"")</tt>
 * @see #removeShutdownHook
 * @see #halt(int)
 * @see #exit(int)
 * @since 1.3
 */
public void addShutdownHook(Thread hook){
  SecurityManager sm=System.getSecurityManager();
  if (sm != null) {
    sm.checkPermission(new RuntimePermission(""String_Node_Str""));
  }
  ApplicationShutdownHooks.add(hook);
}","/** 
 * Registers a new virtual-machine shutdown hook. <p> The Java virtual machine <i>shuts down</i> in response to two kinds of events: <ul> <li> The program <i>exits</i> normally, when the last non-daemon thread exits or when the <tt>  {@link #exit exit}</tt> (equivalently,  {@link System#exit(int) System.exit}) method is invoked, or <li> The virtual machine is <i>terminated</i> in response to a user interrupt, such as typing <tt>^C</tt>, or a system-wide event, such as user logoff or system shutdown. </ul> <p> A <i>shutdown hook</i> is simply an initialized but unstarted thread.  When the virtual machine begins its shutdown sequence it will start all registered shutdown hooks in some unspecified order and let them run concurrently.  When all the hooks have finished it will then run all uninvoked finalizers if finalization-on-exit has been enabled. Finally, the virtual machine will halt.  Note that daemon threads will continue to run during the shutdown sequence, as will non-daemon threads if shutdown was initiated by invoking the <tt>  {@link #exit exit}</tt> method. <p> Once the shutdown sequence has begun it can be stopped only by invoking the <tt>  {@link #halt halt}</tt> method, which forcibly terminates the virtual machine. <p> Once the shutdown sequence has begun it is impossible to register a new shutdown hook or de-register a previously-registered hook. Attempting either of these operations will cause an <tt>  {@link IllegalStateException}</tt> to be thrown. <p> Shutdown hooks run at a delicate time in the life cycle of a virtual machine and should therefore be coded defensively.  They should, in particular, be written to be thread-safe and to avoid deadlocks insofar as possible.  They should also not rely blindly upon services that may have registered their own shutdown hooks and therefore may themselves in the process of shutting down.  Attempts to use other thread-based services such as the AWT event-dispatch thread, for example, may lead to deadlocks. <p> Shutdown hooks should also finish their work quickly.  When a program invokes <tt>  {@link #exit exit}</tt> the expectation is that the virtual machine will promptly shut down and exit.  When the virtual machine is terminated due to user logoff or system shutdown the underlying operating system may only allow a fixed amount of time in which to shut down and exit.  It is therefore inadvisable to attempt any user interaction or to perform a long-running computation in a shutdown hook. <p> Uncaught exceptions are handled in shutdown hooks just as in any other thread, by invoking the <tt>  {@link ThreadGroup#uncaughtException uncaughtException}</tt> method of the thread's <tt>  {@link ThreadGroup}</tt> object.  The default implementation of this method prints the exception's stack trace to <tt>  {@link System#err}</tt> and terminates the thread; it does not cause the virtual machine to exit or halt. <p> In rare circumstances the virtual machine may <i>abort</i>, that is, stop running without shutting down cleanly.  This occurs when the virtual machine is terminated externally, for example with the <tt>SIGKILL</tt> signal on Unix or the <tt>TerminateProcess</tt> call on Microsoft Windows.  The virtual machine may also abort if a native method goes awry by, for example, corrupting internal data structures or attempting to access nonexistent memory.  If the virtual machine aborts then no guarantee can be made about whether or not any shutdown hooks will be run. <p>
 * @param hook An initialized but unstarted <tt> {@link Thread}</tt> object
 * @throws IllegalArgumentException If the specified hook has already been registered, or if it can be determined that the hook is already running or has already been run
 * @throws IllegalStateException If the virtual machine is already in the process of shutting down
 * @throws SecurityException If a security manager is present and it denies <tt> {@link RuntimePermission}(""shutdownHooks"")</tt>
 * @see #removeShutdownHook
 * @see #halt(int)
 * @see #exit(int)
 * @since 1.3
 */
public void addShutdownHook(Thread hook){
  SecurityManager sm=System.getSecurityManager();
  if (sm != null) {
    sm.checkPermission(new RuntimePermission(""String_Node_Str""));
  }
  ApplicationShutdownHooks.add(hook);
}"
72055,"/** 
 * Returns a hash code for a   {@code short} value; compatible with{@code Short.hashCode()}.
 * @since 1.8
 * @return a hash code value for a {@code short} value.
 */
public static int hashCode(short value){
  return (int)value;
}","/** 
 * Returns a hash code for a   {@code short} value; compatible with{@code Short.hashCode()}.
 * @param value the value to hash
 * @return a hash code value for a {@code short} value.
 * @since 1.8
 */
public static int hashCode(short value){
  return (int)value;
}"
72056,"/** 
 * Returns the value obtained by reversing the order of the bytes in the two's complement representation of the specified   {@code short} value.
 * @return the value obtained by reversing (or, equivalently, swapping)the bytes in the specified  {@code short} value.
 * @since 1.5
 */
public static short reverseBytes(short i){
  return (short)(((i & 0xFF00) >> 8) | (i << 8));
}","/** 
 * Returns the value obtained by reversing the order of the bytes in the two's complement representation of the specified   {@code short} value.
 * @param i the value whose bytes are to be reversed
 * @return the value obtained by reversing (or, equivalently, swapping)the bytes in the specified  {@code short} value.
 * @since 1.5
 */
public static short reverseBytes(short i){
  return (short)(((i & 0xFF00) >> 8) | (i << 8));
}"
72057,"/** 
 * Returns the unbiased exponent used in the representation of a  {@code double}.  Special cases: <ul> <li>If the argument is NaN or infinite, then the result is  {@link Double#MAX_EXPONENT} + 1.<li>If the argument is zero or subnormal, then the result is {@link Double#MIN_EXPONENT} -1.</ul>
 * @param d a {@code double} value
 * @since 1.6
 */
public static int getExponent(double d){
  return Math.getExponent(d);
}","/** 
 * Returns the unbiased exponent used in the representation of a  {@code double}.  Special cases: <ul> <li>If the argument is NaN or infinite, then the result is  {@link Double#MAX_EXPONENT} + 1.<li>If the argument is zero or subnormal, then the result is {@link Double#MIN_EXPONENT} -1.</ul>
 * @param d a {@code double} value
 * @return the unbiased exponent of the argument
 * @since 1.6
 */
public static int getExponent(double d){
  return Math.getExponent(d);
}"
72058,"/** 
 * Return the kind of this tag. similar or synonymous tags.  For most tags, <code>kind()&nbsp;==&nbsp;name()</code>; the following table lists those cases where there is more than one tag of a given kind: <p> <table border=""1"" cellpadding=""4"" cellspacing=""0""> <tr><th><tt> kind()  </tt></th>  <th><tt> name()      </tt></th></tr> <tr><td><tt> @throws </tt></td>  <td><tt> @throws     </tt></td></tr> <tr><td><tt> @throws </tt></td>  <td><tt> @exception  </tt></td></tr> <tr><td><tt> @see    </tt></td>  <td><tt> @see        </tt></td></tr> <tr><td><tt> @see    </tt></td>  <td><tt> @link       </tt></td></tr> <tr><td><tt> @see    </tt></td>  <td><tt> @linkplain  </tt></td></tr> <tr><td><tt> @serial </tt></td>  <td><tt> @serial     </tt></td></tr> <tr><td><tt> @serial </tt></td>  <td><tt> @serialData </tt></td></tr> </table>
 */
String kind();","/** 
 * Return the kind of this tag. For most tags, <code>kind()&nbsp;==&nbsp;name()</code>; the following table lists those cases where there is more than one tag of a given kind: <p> <table border=""1"" cellpadding=""4"" cellspacing=""0"" summary=""related tags""> <tr><th>  {@code kind()  }</th>  <th>  {@code name()      }</th></tr> <tr><td>  {@code @throws }</td>  <td>  {@code @throws     }</td></tr> <tr><td>  {@code @throws }</td>  <td>  {@code @exception  }</td></tr> <tr><td>  {@code @see    }</td>  <td>  {@code @see        }</td></tr> <tr><td>  {@code @see    }</td>  <td>  {@code @link       }</td></tr> <tr><td>  {@code @see    }</td>  <td>  {@code @linkplain  }</td></tr> <tr><td>  {@code @serial }</td>  <td>  {@code @serial     }</td></tr> <tr><td>  {@code @serial }</td>  <td>  {@code @serialData }</td></tr> </table>
 * @return the kind of this tag.
 */
String kind();"
72059,"/** 
 * Return the name of this tag.  The name is the string starting with ""@"" that is used in a doc comment, such as <code>@return</code>.  For inline tags, such as <code>{&#064;link}</code>, the curly brackets are not part of the name, so in this example the name would be simply <code>@link</code>.
 */
String name();","/** 
 * Return the name of this tag.  The name is the string starting with ""@"" that is used in a doc comment, such as <code>@return</code>.  For inline tags, such as <code>{&#064;link}</code>, the curly brackets are not part of the name, so in this example the name would be simply <code>@link</code>.
 * @return the name of this tag
 */
String name();"
72060,"/** 
 * Return the containing   {@link Doc} of this Tag element.
 */
Doc holder();","/** 
 * Return the containing   {@link Doc} of this Tag element.
 * @return the containing {@link Doc} of this Tag element
 */
Doc holder();"
72061,"/** 
 * Return the text of this tag, that is, portion beyond tag name.
 */
String text();","/** 
 * Return the text of this tag, that is, the portion beyond tag name.
 * @return the text of this tag
 */
String text();"
72062,"BasicLookupHelper(Name name,Type site,List<Type> argtypes,List<Type> typeargtypes){
  super(name,site,argtypes,typeargtypes,MethodResolutionPhase.VARARITY);
}","BasicLookupHelper(Name name,Type site,List<Type> argtypes,List<Type> typeargtypes,MethodResolutionPhase maxPhase){
  super(name,site,argtypes,typeargtypes,maxPhase);
}"
72063,"/** 
 * Select the best method for a call site among two choices.
 * @param env              The current environment.
 * @param site             The original type from where theselection takes place.
 * @param argtypes         The invocation's value arguments,
 * @param typeargtypes     The invocation's type arguments,
 * @param sym              Proposed new best match.
 * @param bestSoFar        Previously found best match.
 * @param allowBoxing Allow boxing conversions of arguments.
 * @param useVarargs Box trailing arguments into an array for varargs.
 */
@SuppressWarnings(""String_Node_Str"") Symbol selectBest(Env<AttrContext> env,Type site,List<Type> argtypes,List<Type> typeargtypes,Symbol sym,Symbol bestSoFar,boolean allowBoxing,boolean useVarargs,boolean operator){
  if (sym.kind == ERR || !sym.isInheritedIn(site.tsym,types)) {
    return bestSoFar;
  }
 else   if (useVarargs && (sym.flags() & VARARGS) == 0) {
    return bestSoFar.kind >= ERRONEOUS ? new BadVarargsMethod((ResolveError)bestSoFar) : bestSoFar;
  }
  Assert.check(sym.kind < AMBIGUOUS);
  try {
    Type mt=rawInstantiate(env,site,sym,null,argtypes,typeargtypes,allowBoxing,useVarargs,types.noWarnings);
    if (!operator)     currentResolutionContext.addApplicableCandidate(sym,mt);
  }
 catch (  InapplicableMethodException ex) {
    if (!operator)     currentResolutionContext.addInapplicableCandidate(sym,ex.getDiagnostic());
switch (bestSoFar.kind) {
case ABSENT_MTH:
      return new InapplicableSymbolError(currentResolutionContext);
case WRONG_MTH:
    if (operator)     return bestSoFar;
  bestSoFar=new InapplicableSymbolsError(currentResolutionContext);
default :
return bestSoFar;
}
}
if (!isAccessible(env,site,sym)) {
return (bestSoFar.kind == ABSENT_MTH) ? new AccessError(env,site,sym) : bestSoFar;
}
return (bestSoFar.kind > AMBIGUOUS) ? sym : mostSpecific(argtypes,sym,bestSoFar,env,site,allowBoxing && operator,useVarargs);
}","/** 
 * Select the best method for a call site among two choices.
 * @param env              The current environment.
 * @param site             The original type from where theselection takes place.
 * @param argtypes         The invocation's value arguments,
 * @param typeargtypes     The invocation's type arguments,
 * @param sym              Proposed new best match.
 * @param bestSoFar        Previously found best match.
 * @param allowBoxing Allow boxing conversions of arguments.
 * @param useVarargs Box trailing arguments into an array for varargs.
 */
@SuppressWarnings(""String_Node_Str"") Symbol selectBest(Env<AttrContext> env,Type site,List<Type> argtypes,List<Type> typeargtypes,Symbol sym,Symbol bestSoFar,boolean allowBoxing,boolean useVarargs,boolean operator){
  if (sym.kind == ERR || !sym.isInheritedIn(site.tsym,types)) {
    return bestSoFar;
  }
 else   if (useVarargs && (sym.flags() & VARARGS) == 0) {
    return bestSoFar.kind >= ERRONEOUS ? new BadVarargsMethod((ResolveError)bestSoFar) : bestSoFar;
  }
  Assert.check(sym.kind < AMBIGUOUS);
  try {
    Type mt=rawInstantiate(env,site,sym,null,argtypes,typeargtypes,allowBoxing,useVarargs,types.noWarnings);
    if (!operator || verboseResolutionMode.contains(VerboseResolutionMode.PREDEF))     currentResolutionContext.addApplicableCandidate(sym,mt);
  }
 catch (  InapplicableMethodException ex) {
    if (!operator)     currentResolutionContext.addInapplicableCandidate(sym,ex.getDiagnostic());
switch (bestSoFar.kind) {
case ABSENT_MTH:
      return new InapplicableSymbolError(currentResolutionContext);
case WRONG_MTH:
    if (operator)     return bestSoFar;
  bestSoFar=new InapplicableSymbolsError(currentResolutionContext);
default :
return bestSoFar;
}
}
if (!isAccessible(env,site,sym)) {
return (bestSoFar.kind == ABSENT_MTH) ? new AccessError(env,site,sym) : bestSoFar;
}
return (bestSoFar.kind > AMBIGUOUS) ? sym : mostSpecific(argtypes,sym,bestSoFar,env,site,allowBoxing && operator,useVarargs);
}"
72064,"/** 
 * Resolve operator.
 * @param pos       The position to use for error reporting.
 * @param optag     The tag of the operation tree.
 * @param env       The environment current at the operation.
 * @param argtypes  The types of the operands.
 */
Symbol resolveOperator(DiagnosticPosition pos,JCTree.Tag optag,Env<AttrContext> env,List<Type> argtypes){
  MethodResolutionContext prevResolutionContext=currentResolutionContext;
  try {
    currentResolutionContext=new MethodResolutionContext();
    Name name=treeinfo.operatorName(optag);
    env.info.pendingResolutionPhase=currentResolutionContext.step=BASIC;
    Symbol sym=findMethod(env,syms.predefClass.type,name,argtypes,null,false,false,true);
    if (boxingEnabled && sym.kind >= WRONG_MTHS)     env.info.pendingResolutionPhase=currentResolutionContext.step=BOX;
    sym=findMethod(env,syms.predefClass.type,name,argtypes,null,true,false,true);
    return accessMethod(sym,pos,env.enclClass.sym.type,name,false,argtypes,null);
  }
  finally {
    currentResolutionContext=prevResolutionContext;
  }
}","/** 
 * Resolve operator.
 * @param pos       The position to use for error reporting.
 * @param optag     The tag of the operation tree.
 * @param env       The environment current at the operation.
 * @param argtypes  The types of the operands.
 */
Symbol resolveOperator(DiagnosticPosition pos,JCTree.Tag optag,Env<AttrContext> env,List<Type> argtypes){
  MethodResolutionContext prevResolutionContext=currentResolutionContext;
  try {
    currentResolutionContext=new MethodResolutionContext();
    Name name=treeinfo.operatorName(optag);
    return lookupMethod(env,pos,syms.predefClass,currentResolutionContext,new BasicLookupHelper(name,syms.predefClass.type,argtypes,null,BOX){
      @Override Symbol lookup(      Env<AttrContext> env,      MethodResolutionPhase phase){
        return findMethod(env,site,name,argtypes,typeargtypes,phase.isBoxingRequired(),phase.isVarargsRequired(),true);
      }
      @Override Symbol access(      Env<AttrContext> env,      DiagnosticPosition pos,      Symbol location,      Symbol sym){
        return accessMethod(sym,pos,env.enclClass.sym.type,name,false,argtypes,null);
      }
    }
);
  }
  finally {
    currentResolutionContext=prevResolutionContext;
  }
}"
72065,"String computeKey(Element e){
  StringBuilder buf=new StringBuilder();
  while (e != null) {
    buf.append(e.toString());
    e=e.getEnclosingElement();
  }
  buf.append(jfo.getName());
  return buf.toString();
}","String computeKey(Element e){
  StringBuilder buf=new StringBuilder();
  if (predefTranslationMap.containsKey(e.getSimpleName().toString())) {
    buf.append(""String_Node_Str"");
    String replacedName=predefTranslationMap.get(e.getSimpleName().toString());
    buf.append(e.toString().replace(e.getSimpleName().toString(),replacedName));
  }
 else   if (e.getSimpleName().toString().startsWith(""String_Node_Str"")) {
    buf.append(""String_Node_Str"");
    buf.append(e.toString());
  }
 else {
    while (e != null) {
      buf.append(e.toString());
      e=e.getEnclosingElement();
    }
    buf.append(jfo.getName());
  }
  return buf.toString();
}"
72066,"protected ResolveHarness(JavaFileObject jfo){
  this.jfo=jfo;
  this.diagProcessors=new DiagnosticProcessor[]{new VerboseResolutionNoteProcessor(),new VerboseDeferredInferenceNoteProcessor(),new ErrorProcessor()};
}","protected ResolveHarness(JavaFileObject jfo){
  this.jfo=jfo;
  this.diagProcessors=new DiagnosticProcessor[]{new VerboseResolutionNoteProcessor(),new VerboseDeferredInferenceNoteProcessor(),new ErrorProcessor()};
  predefTranslationMap.put(""String_Node_Str"",""String_Node_Str"");
  predefTranslationMap.put(""String_Node_Str"",""String_Node_Str"");
  predefTranslationMap.put(""String_Node_Str"",""String_Node_Str"");
  predefTranslationMap.put(""String_Node_Str"",""String_Node_Str"");
  predefTranslationMap.put(""String_Node_Str"",""String_Node_Str"");
  predefTranslationMap.put(""String_Node_Str"",""String_Node_Str"");
  predefTranslationMap.put(""String_Node_Str"",""String_Node_Str"");
  predefTranslationMap.put(""String_Node_Str"",""String_Node_Str"");
  predefTranslationMap.put(""String_Node_Str"",""String_Node_Str"");
  predefTranslationMap.put(""String_Node_Str"",""String_Node_Str"");
  predefTranslationMap.put(""String_Node_Str"",""String_Node_Str"");
  predefTranslationMap.put(""String_Node_Str"",""String_Node_Str"");
  predefTranslationMap.put(""String_Node_Str"",""String_Node_Str"");
  predefTranslationMap.put(""String_Node_Str"",""String_Node_Str"");
  predefTranslationMap.put(""String_Node_Str"",""String_Node_Str"");
  predefTranslationMap.put(""String_Node_Str"",""String_Node_Str"");
  predefTranslationMap.put(""String_Node_Str"",""String_Node_Str"");
  predefTranslationMap.put(""String_Node_Str"",""String_Node_Str"");
  predefTranslationMap.put(""String_Node_Str"",""String_Node_Str"");
  predefTranslationMap.put(""String_Node_Str"",""String_Node_Str"");
  predefTranslationMap.put(""String_Node_Str"",""String_Node_Str"");
  predefTranslationMap.put(""String_Node_Str"",""String_Node_Str"");
  predefTranslationMap.put(""String_Node_Str"",""String_Node_Str"");
  predefTranslationMap.put(""String_Node_Str"",""String_Node_Str"");
}"
72067,"/** 
 * Convenience method equivalent to   {@code v.scan(e, null)}.
 * @return the result of scanning {@code e}.
 */
public final R scan(Element e){
  return scan(e,null);
}","/** 
 * Convenience method equivalent to   {@code v.scan(e, null)}.
 * @param e the element to scan
 * @return the result of scanning {@code e}.
 */
public final R scan(Element e){
  return scan(e,null);
}"
72068,"/** 
 * Return a name with the same sequence of characters as the argument.
 * @param cs the character sequence to return as a name
 */
Name getName(CharSequence cs);","/** 
 * Return a name with the same sequence of characters as the argument.
 * @param cs the character sequence to return as a name
 * @return a name with the same sequence of characters as the argument
 */
Name getName(CharSequence cs);"
72069,"/** 
 * Returns the element corresponding to a type. The type may be a   {@code DeclaredType} or {@code TypeVariable}. Returns   {@code null} if the type is not one with acorresponding element.
 * @return the element corresponding to the given type
 */
Element asElement(TypeMirror t);","/** 
 * Returns the element corresponding to a type. The type may be a   {@code DeclaredType} or {@code TypeVariable}. Returns   {@code null} if the type is not one with acorresponding element.
 * @param t the type to map to an element
 * @return the element corresponding to the given type
 */
Element asElement(TypeMirror t);"
72070,"private static List<Archive> init(){
  List<Archive> result=new ArrayList<Archive>();
  String javaHome=System.getProperty(""String_Node_Str"");
  List<File> files=new ArrayList<File>();
  File jre=new File(javaHome,""String_Node_Str"");
  File lib=new File(javaHome,""String_Node_Str"");
  try {
    if (jre.exists() && jre.isDirectory()) {
      result.addAll(addJarFiles(new File(jre,""String_Node_Str"")));
      result.addAll(addJarFiles(lib));
    }
 else     if (lib.exists() && lib.isDirectory()) {
      File classes=new File(javaHome,""String_Node_Str"");
      if (classes.exists() && classes.isDirectory()) {
        result.add(new Archive(classes,ClassFileReader.newInstance(classes)));
      }
      result.addAll(addJarFiles(lib));
    }
 else {
      throw new RuntimeException(""String_Node_Str"" + javaHome + ""String_Node_Str"");
    }
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
  return result;
}","private static List<Archive> init(){
  List<Archive> result=new ArrayList<Archive>();
  String javaHome=System.getProperty(""String_Node_Str"");
  File jre=new File(javaHome,""String_Node_Str"");
  File lib=new File(javaHome,""String_Node_Str"");
  try {
    if (jre.exists() && jre.isDirectory()) {
      result.addAll(addJarFiles(new File(jre,""String_Node_Str"")));
      result.addAll(addJarFiles(lib));
    }
 else     if (lib.exists() && lib.isDirectory()) {
      File classes=new File(javaHome,""String_Node_Str"");
      if (classes.exists() && classes.isDirectory()) {
        result.add(new Archive(classes,ClassFileReader.newInstance(classes)));
      }
      result.addAll(addJarFiles(lib));
    }
 else {
      throw new RuntimeException(""String_Node_Str"" + javaHome + ""String_Node_Str"");
    }
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
  return result;
}"
72071,"/** 
 * Scan the arguments for -i -x -xf -if followed by the option -src, -sourcepath, -modulepath or -classpath and produce a map of all the files to referenced for that particular option. Store the found sources and the found modules in the supplied maps.
 */
private boolean findFiles(String[] args,String option,Set<String> suffixes,Map<String,Source> found_files,Map<String,Module> found_modules,Module current_module,boolean inLinksrc) throws ProblemException, ProblemException {
  Set<File> roots=new HashSet<File>();
  List<String> includes=new LinkedList<String>();
  List<String> excludes=new LinkedList<String>();
  List<String> excludefiles=new LinkedList<String>();
  List<String> includefiles=new LinkedList<String>();
  List<String> moduleinfo=new LinkedList<String>();
  moduleinfo.add(""String_Node_Str"");
  for (int i=0; i < args.length; ++i) {
    if (args[i].equals(""String_Node_Str"")) {
      if (i + 1 >= args.length) {
        throw new ProblemException(""String_Node_Str"");
      }
      String incl=args[i + 1];
      checkPattern(incl);
      includes.add(incl);
    }
    if (args[i].equals(""String_Node_Str"")) {
      if (i + 1 >= args.length) {
        throw new ProblemException(""String_Node_Str"");
      }
      String excl=args[i + 1];
      checkPattern(excl);
      excludes.add(excl);
    }
    if (args[i].equals(""String_Node_Str"")) {
      if (i + 1 >= args.length) {
        throw new ProblemException(""String_Node_Str"");
      }
      String exclf=args[i + 1];
      checkFilePattern(exclf);
      exclf=Util.normalizeDriveLetter(exclf);
      excludefiles.add(fixupSeparator(exclf));
    }
    if (args[i].equals(""String_Node_Str"")) {
      if (i + 1 >= args.length) {
        throw new ProblemException(""String_Node_Str"");
      }
      String inclf=args[i + 1];
      checkFilePattern(inclf);
      inclf=Util.normalizeDriveLetter(inclf);
      includefiles.add(fixupSeparator(inclf));
    }
    if (args[i].equals(option)) {
      if (i + 1 >= args.length) {
        throw new ProblemException(""String_Node_Str"" + option);
      }
      String[] root_dirs=args[i + 1].split(File.pathSeparator);
      for (      String r : root_dirs) {
        File root=new File(r);
        if (!root.isDirectory()) {
          throw new ProblemException(""String_Node_Str"" + r + ""String_Node_Str"");
        }
        try {
          root=root.getCanonicalFile();
        }
 catch (        IOException e) {
          throw new ProblemException(""String_Node_Str"" + e);
        }
        if (roots.contains(root)) {
          throw new ProblemException(""String_Node_Str"" + r + ""String_Node_Str""+ option);
        }
        if (roots.equals(bin_dir)) {
          throw new ProblemException(""String_Node_Str"" + r + ""String_Node_Str""+ option+ ""String_Node_Str"");
        }
        if (roots.equals(gensrc_dir)) {
          throw new ProblemException(""String_Node_Str"" + r + ""String_Node_Str""+ option+ ""String_Node_Str"");
        }
        if (roots.equals(header_dir)) {
          throw new ProblemException(""String_Node_Str"" + r + ""String_Node_Str""+ option+ ""String_Node_Str"");
        }
        roots.add(root);
        Source.scanRoot(root,suffixes,excludes,includes,excludefiles,includefiles,found_files,found_modules,current_module,findBooleanOption(args,""String_Node_Str""),false,inLinksrc);
      }
    }
    if (args[i].equals(""String_Node_Str"") || args[i].equals(""String_Node_Str"") || args[i].equals(""String_Node_Str"")|| args[i].equals(""String_Node_Str"")|| args[i].equals(""String_Node_Str"")) {
      includes=new LinkedList<String>();
      excludes=new LinkedList<String>();
      excludefiles=new LinkedList<String>();
      includefiles=new LinkedList<String>();
    }
  }
  return true;
}","/** 
 * Scan the arguments for -i -x -xf -if followed by the option -src, -sourcepath, -modulepath or -classpath and produce a map of all the files to referenced for that particular option. Store the found sources and the found modules in the supplied maps.
 */
private boolean findFiles(String[] args,String option,Set<String> suffixes,Map<String,Source> found_files,Map<String,Module> found_modules,Module current_module,boolean inLinksrc) throws ProblemException, ProblemException {
  Set<File> roots=new HashSet<File>();
  List<String> includes=new LinkedList<String>();
  List<String> excludes=new LinkedList<String>();
  List<String> excludefiles=new LinkedList<String>();
  List<String> includefiles=new LinkedList<String>();
  List<String> moduleinfo=new LinkedList<String>();
  moduleinfo.add(""String_Node_Str"");
  for (int i=0; i < args.length; ++i) {
    if (args[i].equals(""String_Node_Str"")) {
      if (i + 1 >= args.length) {
        throw new ProblemException(""String_Node_Str"");
      }
      String incl=args[i + 1];
      checkPattern(incl);
      includes.add(incl);
    }
    if (args[i].equals(""String_Node_Str"")) {
      if (i + 1 >= args.length) {
        throw new ProblemException(""String_Node_Str"");
      }
      String excl=args[i + 1];
      checkPattern(excl);
      excludes.add(excl);
    }
    if (args[i].equals(""String_Node_Str"")) {
      if (i + 1 >= args.length) {
        throw new ProblemException(""String_Node_Str"");
      }
      String exclf=args[i + 1];
      checkFilePattern(exclf);
      exclf=Util.normalizeDriveLetter(exclf);
      excludefiles.add(fixupSeparator(exclf));
    }
    if (args[i].equals(""String_Node_Str"")) {
      if (i + 1 >= args.length) {
        throw new ProblemException(""String_Node_Str"");
      }
      String inclf=args[i + 1];
      checkFilePattern(inclf);
      inclf=Util.normalizeDriveLetter(inclf);
      includefiles.add(fixupSeparator(inclf));
    }
    if (args[i].equals(option)) {
      if (i + 1 >= args.length) {
        throw new ProblemException(""String_Node_Str"" + option);
      }
      String[] root_dirs=args[i + 1].split(File.pathSeparator);
      for (      String r : root_dirs) {
        File root=new File(r);
        if (!root.isDirectory()) {
          throw new ProblemException(""String_Node_Str"" + r + ""String_Node_Str"");
        }
        try {
          root=root.getCanonicalFile();
        }
 catch (        IOException e) {
          throw new ProblemException(""String_Node_Str"" + e);
        }
        if (roots.contains(root)) {
          throw new ProblemException(""String_Node_Str"" + r + ""String_Node_Str""+ option);
        }
        if (root.equals(bin_dir)) {
          throw new ProblemException(""String_Node_Str"" + r + ""String_Node_Str""+ option+ ""String_Node_Str"");
        }
        if (root.equals(gensrc_dir)) {
          throw new ProblemException(""String_Node_Str"" + r + ""String_Node_Str""+ option+ ""String_Node_Str"");
        }
        if (root.equals(header_dir)) {
          throw new ProblemException(""String_Node_Str"" + r + ""String_Node_Str""+ option+ ""String_Node_Str"");
        }
        roots.add(root);
        Source.scanRoot(root,suffixes,excludes,includes,excludefiles,includefiles,found_files,found_modules,current_module,findBooleanOption(args,""String_Node_Str""),false,inLinksrc);
      }
    }
    if (args[i].equals(""String_Node_Str"") || args[i].equals(""String_Node_Str"") || args[i].equals(""String_Node_Str"")|| args[i].equals(""String_Node_Str"")|| args[i].equals(""String_Node_Str"")) {
      includes=new LinkedList<String>();
      excludes=new LinkedList<String>();
      excludefiles=new LinkedList<String>();
      includefiles=new LinkedList<String>();
    }
  }
  return true;
}"
72072,"public int go(String[] args,PrintStream out,PrintStream err){
  try {
    if (args.length == 0 || findJavaSourceFiles(args) || findAtFile(args) || null == Util.findServerSettings(args)) {
      printHelp();
      return 0;
    }
    Log.setLogLevel(findLogLevel(args),out,err);
    String server_settings=Util.findServerSettings(args);
    args=verifyImplicitOption(args);
    args=addSrcBeforeDirectories(args);
    checkSrcOption(args);
    bin_dir=findDirectoryOption(args,""String_Node_Str"",""String_Node_Str"",true,false,true);
    gensrc_dir=findDirectoryOption(args,""String_Node_Str"",""String_Node_Str"",false,false,true);
    header_dir=findDirectoryOption(args,""String_Node_Str"",""String_Node_Str"",false,false,true);
    makefile_source_list=findFileOption(args,""String_Node_Str"",""String_Node_Str"",false);
    javac_state=JavacState.load(args,bin_dir,gensrc_dir,header_dir,findBooleanOption(args,""String_Node_Str""),out,err);
    suffix_rules=javac_state.getJavaSuffixRule();
    findTranslateOptions(args,suffix_rules);
    if (suffix_rules.keySet().size() > 1 && gensrc_dir == null) {
      Log.error(""String_Node_Str"");
      return -1;
    }
    findCopyOptions(args,suffix_rules);
    Map<String,Module> modules=new HashMap<String,Module>();
    Module current_module=new Module(""String_Node_Str"",""String_Node_Str"");
    modules.put(""String_Node_Str"",current_module);
    Map<String,Source> sources=new HashMap<String,Source>();
    findFiles(args,""String_Node_Str"",suffix_rules.keySet(),sources,modules,current_module,false);
    if (sources.isEmpty()) {
      Log.error(""String_Node_Str"");
      return -1;
    }
    Map<String,Source> sources_to_link_to=new HashMap<String,Source>();
    rewriteOptions(args,""String_Node_Str"",""String_Node_Str"");
    findFiles(args,""String_Node_Str"",Util.set(""String_Node_Str""),sources_to_link_to,modules,current_module,true);
    Map<String,Source> classes_to_link_to=new HashMap<String,Source>();
    Map<String,Source> modules_to_link_to=new HashMap<String,Source>();
    javac_state.now().collectPackagesSourcesAndArtifacts(modules);
    javac_state.now().checkInternalState(""String_Node_Str"",false,sources);
    javac_state.now().checkInternalState(""String_Node_Str"",true,sources_to_link_to);
    javac_state.setVisibleSources(sources_to_link_to);
    javac_state.checkSourceStatus(false);
    javac_state.findAllArtifacts();
    if (!findBooleanOption(args,""String_Node_Str"")) {
      javac_state.removeUnidentifiedArtifacts();
    }
    javac_state.taintPackagesThatMissArtifacts();
    javac_state.deleteClassArtifactsInTaintedPackages();
    javac_state.performCopying(bin_dir,suffix_rules);
    javac_state.performTranslation(gensrc_dir,suffix_rules);
    Map<String,Source> generated_sources=new HashMap<String,Source>();
    Source.scanRoot(gensrc_dir,Util.set(""String_Node_Str""),null,null,null,null,generated_sources,modules,current_module,false,true,false);
    javac_state.now().collectPackagesSourcesAndArtifacts(modules);
    javac_state.checkSourceStatus(true);
    javac_state.compareWithMakefileList(makefile_source_list);
    boolean again;
    Set<String> recently_compiled=new HashSet<String>();
    boolean[] rc=new boolean[1];
    do {
      javac_state.deleteClassArtifactsInTaintedPackages();
      again=javac_state.performJavaCompilations(bin_dir,server_settings,args,recently_compiled,rc);
      if (!rc[0])       break;
    }
 while (again);
    if (rc[0]) {
      javac_state.save();
      javac_state.now().collectArtifacts(modules);
      javac_state.removeSuperfluousArtifacts(recently_compiled);
    }
    return rc[0] ? 0 : -1;
  }
 catch (  ProblemException e) {
    Log.error(e.getMessage());
    return -1;
  }
catch (  Exception e) {
    e.printStackTrace(err);
    return -1;
  }
}","public int go(String[] args,PrintStream out,PrintStream err){
  try {
    if (args.length == 0 || findJavaSourceFiles(args) || findAtFile(args) || null == Util.findServerSettings(args)) {
      printHelp();
      return 0;
    }
    Log.setLogLevel(findLogLevel(args),out,err);
    String server_settings=Util.findServerSettings(args);
    args=verifyImplicitOption(args);
    args=addSrcBeforeDirectories(args);
    checkSrcOption(args);
    bin_dir=findDirectoryOption(args,""String_Node_Str"",""String_Node_Str"",true,false,true);
    gensrc_dir=findDirectoryOption(args,""String_Node_Str"",""String_Node_Str"",false,false,true);
    header_dir=findDirectoryOption(args,""String_Node_Str"",""String_Node_Str"",false,false,true);
    makefile_source_list=findFileOption(args,""String_Node_Str"",""String_Node_Str"",false);
    javac_state=JavacState.load(args,bin_dir,gensrc_dir,header_dir,findBooleanOption(args,""String_Node_Str""),out,err);
    suffix_rules=javac_state.getJavaSuffixRule();
    findTranslateOptions(args,suffix_rules);
    if (suffix_rules.keySet().size() > 1 && gensrc_dir == null) {
      Log.error(""String_Node_Str"");
      return -1;
    }
    findCopyOptions(args,suffix_rules);
    Map<String,Module> modules=new HashMap<String,Module>();
    Module current_module=new Module(""String_Node_Str"",""String_Node_Str"");
    modules.put(""String_Node_Str"",current_module);
    Map<String,Source> sources=new HashMap<String,Source>();
    findFiles(args,""String_Node_Str"",suffix_rules.keySet(),sources,modules,current_module,false);
    if (sources.isEmpty()) {
      Log.error(""String_Node_Str"");
      return -1;
    }
    Map<String,Source> sources_to_link_to=new HashMap<String,Source>();
    rewriteOptions(args,""String_Node_Str"",""String_Node_Str"");
    findFiles(args,""String_Node_Str"",Util.set(""String_Node_Str""),sources_to_link_to,modules,current_module,true);
    javac_state.now().collectPackagesSourcesAndArtifacts(modules);
    javac_state.now().checkInternalState(""String_Node_Str"",false,sources);
    javac_state.now().checkInternalState(""String_Node_Str"",true,sources_to_link_to);
    javac_state.setVisibleSources(sources_to_link_to);
    javac_state.checkSourceStatus(false);
    javac_state.findAllArtifacts();
    if (!findBooleanOption(args,""String_Node_Str"")) {
      javac_state.removeUnidentifiedArtifacts();
    }
    javac_state.taintPackagesThatMissArtifacts();
    javac_state.deleteClassArtifactsInTaintedPackages();
    javac_state.performCopying(bin_dir,suffix_rules);
    javac_state.performTranslation(gensrc_dir,suffix_rules);
    Map<String,Source> generated_sources=new HashMap<String,Source>();
    Source.scanRoot(gensrc_dir,Util.set(""String_Node_Str""),null,null,null,null,generated_sources,modules,current_module,false,true,false);
    javac_state.now().collectPackagesSourcesAndArtifacts(modules);
    javac_state.checkSourceStatus(true);
    javac_state.compareWithMakefileList(makefile_source_list);
    boolean again;
    Set<String> recently_compiled=new HashSet<String>();
    boolean[] rc=new boolean[1];
    do {
      javac_state.deleteClassArtifactsInTaintedPackages();
      again=javac_state.performJavaCompilations(bin_dir,server_settings,args,recently_compiled,rc);
      if (!rc[0])       break;
    }
 while (again);
    if (rc[0]) {
      javac_state.save();
      javac_state.now().collectArtifacts(modules);
      javac_state.removeSuperfluousArtifacts(recently_compiled);
    }
    return rc[0] ? 0 : -1;
  }
 catch (  ProblemException e) {
    Log.error(e.getMessage());
    return -1;
  }
catch (  Exception e) {
    e.printStackTrace(err);
    return -1;
  }
}"
72073,"private void checkConfigPermission(){
  final SecurityManager sm=System.getSecurityManager();
  if (sm != null) {
    sm.checkPermission(new RuntimePermission(""String_Node_Str""));
  }
}","private static void checkConfigPermission(){
  final SecurityManager sm=System.getSecurityManager();
  if (sm != null) {
    sm.checkPermission(new RuntimePermission(""String_Node_Str""));
  }
}"
72074,"@Override protected void makeObject(final MethodEmitter m){
  final String className=SCRIPTFUNCTION_IMPL_OBJECT;
  m._new(className).dup();
  loadConstant(new RecompilableScriptFunctionData(functionNode,compiler.getCodeInstaller(),Compiler.binaryName(getClassName()),makeMap()));
  if (isLazy || functionNode.needsParentScope()) {
    m.loadScope();
  }
 else {
    m.loadNull();
  }
  m.invoke(constructorNoLookup(className,cparams));
}","@Override protected void makeObject(final MethodEmitter m){
  final String className=SCRIPTFUNCTION_IMPL_OBJECT;
  m._new(className).dup();
  loadConstant(new RecompilableScriptFunctionData(functionNode,compiler.getCodeInstaller(),Compiler.binaryName(getClassName()),makeMap()));
  if (isLazy || functionNode.needsParentScope()) {
    m.loadScope();
  }
 else {
    m.loadNull();
  }
  m.invoke(constructorNoLookup(className,RecompilableScriptFunctionData.class,ScriptObject.class));
}"
72075,"private void newFunctionObject(final FunctionNode functionNode){
  final boolean isLazy=functionNode.isLazy();
  final Class<?>[] cparams=new Class<?>[]{RecompilableScriptFunctionData.class,ScriptObject.class};
  new ObjectCreator(this,new ArrayList<String>(),new ArrayList<Symbol>(),false,false){
    @Override protected void makeObject(    final MethodEmitter m){
      final String className=SCRIPTFUNCTION_IMPL_OBJECT;
      m._new(className).dup();
      loadConstant(new RecompilableScriptFunctionData(functionNode,compiler.getCodeInstaller(),Compiler.binaryName(getClassName()),makeMap()));
      if (isLazy || functionNode.needsParentScope()) {
        m.loadScope();
      }
 else {
        m.loadNull();
      }
      m.invoke(constructorNoLookup(className,cparams));
    }
  }
.makeObject(method);
}","private void newFunctionObject(final FunctionNode functionNode){
  final boolean isLazy=functionNode.isLazy();
  new ObjectCreator(this,new ArrayList<String>(),new ArrayList<Symbol>(),false,false){
    @Override protected void makeObject(    final MethodEmitter m){
      final String className=SCRIPTFUNCTION_IMPL_OBJECT;
      m._new(className).dup();
      loadConstant(new RecompilableScriptFunctionData(functionNode,compiler.getCodeInstaller(),Compiler.binaryName(getClassName()),makeMap()));
      if (isLazy || functionNode.needsParentScope()) {
        m.loadScope();
      }
 else {
        m.loadNull();
      }
      m.invoke(constructorNoLookup(className,RecompilableScriptFunctionData.class,ScriptObject.class));
    }
  }
.makeObject(method);
}"
72076,"/** 
 * Check if this function's generated Java method needs a   {@code callee} parameter. Functions that need access totheir parent scope, functions that reference themselves, and non-strict functions that need an Arguments object (since it exposes  {@code arguments.callee} property) will need to have a callee parameter.We also conservatively need a callee if we have lazy children, i.e. nested function nodes that have not yet been evaluated. _They_ may need the callee and we don't know it
 * @return true if the function's generated Java method needs a {@code callee} parameter.
 */
public boolean needsCallee(){
  return hasLazyChildren() || needsParentScope() || needsSelfSymbol()|| (needsArguments() && !isStrictMode());
}","/** 
 * Check if this function's generated Java method needs a   {@code callee} parameter. Functions that need access totheir parent scope, functions that reference themselves, and non-strict functions that need an Arguments object (since it exposes  {@code arguments.callee} property) will need to have a callee parameter.
 * @return true if the function's generated Java method needs a {@code callee} parameter.
 */
public boolean needsCallee(){
  return needsParentScope() || needsSelfSymbol() || (needsArguments() && !isStrictMode());
}"
72077,"private void copyOptions(final ScriptObject options,final ScriptEnvironment scriptEnv){
  AccessController.doPrivileged(new PrivilegedAction<Void>(){
    public Void run(){
      for (      Field f : scriptEnv.getClass().getFields()) {
        try {
          options.set(f.getName(),f.get(scriptEnv),false);
        }
 catch (        final IllegalArgumentException|IllegalAccessException exp) {
          throw new RuntimeException(exp);
        }
      }
      return null;
    }
  }
);
}","private static void copyOptions(final ScriptObject options,final ScriptEnvironment scriptEnv){
  AccessController.doPrivileged(new PrivilegedAction<Void>(){
    @Override public Void run(){
      for (      Field f : scriptEnv.getClass().getFields()) {
        try {
          options.set(f.getName(),f.get(scriptEnv),false);
        }
 catch (        final IllegalArgumentException|IllegalAccessException exp) {
          throw new RuntimeException(exp);
        }
      }
      return null;
    }
  }
);
}"
72078,"public Void run(){
  for (  Field f : scriptEnv.getClass().getFields()) {
    try {
      options.set(f.getName(),f.get(scriptEnv),false);
    }
 catch (    final IllegalArgumentException|IllegalAccessException exp) {
      throw new RuntimeException(exp);
    }
  }
  return null;
}","@Override public Void run(){
  for (  Field f : scriptEnv.getClass().getFields()) {
    try {
      options.set(f.getName(),f.get(scriptEnv),false);
    }
 catch (    final IllegalArgumentException|IllegalAccessException exp) {
      throw new RuntimeException(exp);
    }
  }
  return null;
}"
72079,"private synchronized Class<?> compile(final Source source,final ErrorManager errMan,final boolean strict){
  errMan.reset();
  GlobalObject global=null;
  Class<?> script;
  if (env._class_cache_size > 0) {
    global=(GlobalObject)Context.getGlobalTrusted();
    script=global.findCachedClass(source);
    if (script != null) {
      return script;
    }
  }
  final FunctionNode functionNode=new Parser(env,source,errMan,strict).parse();
  if (errors.hasErrors() || env._parse_only) {
    return null;
  }
  if (env._print_ast) {
    getErr().println(new ASTWriter(functionNode));
  }
  if (env._print_parse) {
    getErr().println(new PrintVisitor(functionNode));
  }
  final URL url=source.getURL();
  final ScriptLoader loader=env._loader_per_compile ? createNewLoader() : scriptLoader;
  final CodeSource cs=url == null ? null : new CodeSource(url,(CodeSigner[])null);
  final CodeInstaller<ScriptEnvironment> installer=new ContextCodeInstaller(this,loader,cs);
  final Compiler compiler=new Compiler(installer,functionNode,strict);
  compiler.compile();
  script=compiler.install();
  if (global != null) {
    global.cacheClass(source,script);
  }
  return script;
}","private synchronized Class<?> compile(final Source source,final ErrorManager errMan,final boolean strict){
  errMan.reset();
  GlobalObject global=null;
  Class<?> script;
  if (env._class_cache_size > 0) {
    global=(GlobalObject)Context.getGlobalTrusted();
    script=global.findCachedClass(source);
    if (script != null) {
      Compiler.LOG.fine(""String_Node_Str"" + source + ""String_Node_Str"");
      return script;
    }
  }
  final FunctionNode functionNode=new Parser(env,source,errMan,strict).parse();
  if (errors.hasErrors() || env._parse_only) {
    return null;
  }
  if (env._print_ast) {
    getErr().println(new ASTWriter(functionNode));
  }
  if (env._print_parse) {
    getErr().println(new PrintVisitor(functionNode));
  }
  final URL url=source.getURL();
  final ScriptLoader loader=env._loader_per_compile ? createNewLoader() : scriptLoader;
  final CodeSource cs=url == null ? null : new CodeSource(url,(CodeSigner[])null);
  final CodeInstaller<ScriptEnvironment> installer=new ContextCodeInstaller(this,loader,cs);
  final Compiler compiler=new Compiler(installer,functionNode,strict);
  compiler.compile();
  script=compiler.install();
  if (global != null) {
    global.cacheClass(source,script);
  }
  return script;
}"
72080,"/** 
 * Install a class for use by the Nashorn runtime
 * @param name Binary name of class.
 * @param data Class data bytes.
 * @param cs CodeSource code source of the class bytes.
 * @return Installed class.
 */
synchronized Class<?> installClass(final String name,final byte[] data,final CodeSource cs){
  if (cs == null) {
    return defineClass(name,data,0,data.length,new ProtectionDomain(null,getPermissions(null)));
  }
 else {
    return defineClass(name,data,0,data.length,cs);
  }
}","/** 
 * Install a class for use by the Nashorn runtime
 * @param name Binary name of class.
 * @param data Class data bytes.
 * @param cs CodeSource code source of the class bytes.
 * @return Installed class.
 */
synchronized Class<?> installClass(final String name,final byte[] data,final CodeSource cs){
  if (cs == null) {
    return defineClass(name,data,0,data.length,new ProtectionDomain(null,getPermissions(null)));
  }
  return defineClass(name,data,0,data.length,cs);
}"
72081,"/** 
 * Returns a method handle representing a constructor that takes a single argument of the source type (which, really, should be one of   {@link ScriptObject},   {@link ScriptFunction}, or   {@link Object}, and returns an instance of the adapter for the target type. Used to implement the function autoconverters as well as the Nashorn's JSR-223 script engine's   {@code getInterface()} method.
 * @param sourceType the source type; should be either {@link ScriptObject},   {@link ScriptFunction}, or  {@link Object}. In case of   {@code Object}, it will return a method handle that dispatches to either the script object or function constructor at invocation based on the actual argument.
 * @param targetType the target type, for which adapter instances will be created
 * @return the constructor method handle.
 * @throws Exception if anything goes wrong
 */
public static MethodHandle getConstructor(final Class<?> sourceType,final Class<?> targetType) throws Exception {
  final StaticClass adapterClass=getAdapterClassFor(new Class<?>[]{targetType});
  return AccessController.doPrivileged(new PrivilegedExceptionAction<MethodHandle>(){
    public MethodHandle run() throws Exception {
      return MH.bindTo(Bootstrap.getLinkerServices().getGuardedInvocation(new LinkRequestImpl(NashornCallSiteDescriptor.get(""String_Node_Str"",MethodType.methodType(targetType,StaticClass.class,sourceType),0),false,adapterClass,null)).getInvocation(),adapterClass);
    }
  }
);
}","/** 
 * Returns a method handle representing a constructor that takes a single argument of the source type (which, really, should be one of   {@link ScriptObject},   {@link ScriptFunction}, or   {@link Object}, and returns an instance of the adapter for the target type. Used to implement the function autoconverters as well as the Nashorn's JSR-223 script engine's   {@code getInterface()} method.
 * @param sourceType the source type; should be either {@link ScriptObject},   {@link ScriptFunction}, or  {@link Object}. In case of   {@code Object}, it will return a method handle that dispatches to either the script object or function constructor at invocation based on the actual argument.
 * @param targetType the target type, for which adapter instances will be created
 * @return the constructor method handle.
 * @throws Exception if anything goes wrong
 */
public static MethodHandle getConstructor(final Class<?> sourceType,final Class<?> targetType) throws Exception {
  final StaticClass adapterClass=getAdapterClassFor(new Class<?>[]{targetType});
  return AccessController.doPrivileged(new PrivilegedExceptionAction<MethodHandle>(){
    @Override public MethodHandle run() throws Exception {
      return MH.bindTo(Bootstrap.getLinkerServices().getGuardedInvocation(new LinkRequestImpl(NashornCallSiteDescriptor.get(""String_Node_Str"",MethodType.methodType(targetType,StaticClass.class,sourceType),0),false,adapterClass,null)).getInvocation(),adapterClass);
    }
  }
);
}"
72082,"@Override public RegExpMatcher match(final String str){
  if (pattern == null) {
    return null;
  }
  RegExpMatcher matcher=this.matcher;
  if (matcher == null || matcher.getInput() != str) {
    matcher=new DefaultMatcher(str);
    this.matcher=matcher;
  }
  return matcher;
}","@Override public RegExpMatcher match(final String str){
  if (pattern == null) {
    return null;
  }
  RegExpMatcher currentMatcher=this.matcher;
  if (currentMatcher == null || matcher.getInput() != str) {
    currentMatcher=new DefaultMatcher(str);
    this.matcher=currentMatcher;
  }
  return currentMatcher;
}"
72083,"@Override public RegExpMatcher match(final String input){
  if (regex == null) {
    return null;
  }
  RegExpMatcher matcher=this.matcher;
  if (matcher == null || input != matcher.getInput()) {
    matcher=new JoniMatcher(input);
    this.matcher=matcher;
  }
  return matcher;
}","@Override public RegExpMatcher match(final String input){
  if (regex == null) {
    return null;
  }
  RegExpMatcher currentMatcher=this.matcher;
  if (currentMatcher == null || input != currentMatcher.getInput()) {
    currentMatcher=new JoniMatcher(input);
    this.matcher=currentMatcher;
  }
  return currentMatcher;
}"
72084,"/** 
 * Throw a regexp parser exception.
 * @param key the message key
 * @param str string argument
 * @throws jdk.nashorn.internal.runtime.ParserException
 */
protected static void throwParserException(final String key,final String str) throws ParserException {
  throw new ParserException(ECMAErrors.getMessage(""String_Node_Str"" + key,str));
}","/** 
 * Throw a regexp parser exception.
 * @param key the message key
 * @param str string argument
 * @throws jdk.nashorn.internal.runtime.ParserException unconditionally
 */
protected static void throwParserException(final String key,final String str) throws ParserException {
  throw new ParserException(ECMAErrors.getMessage(""String_Node_Str"" + key,str));
}"
72085,"/** 
 * Creates a Regular expression from the given   {@code pattern} and {@code flags} strings.
 * @param pattern RegExp pattern string
 * @param flags RegExp flags string
 * @throws ParserException if flags is invalid or pattern string has syntax error.
 */
protected RegExp compile(final String pattern,final String flags) throws ParserException {
  return new DefaultRegExp(pattern,flags);
}","/** 
 * Creates a Regular expression from the given   {@code pattern} and {@code flags} strings.
 * @param pattern RegExp pattern string
 * @param flags   RegExp flags string
 * @return new RegExp
 * @throws ParserException if flags is invalid or pattern string has syntax error.
 */
protected RegExp compile(final String pattern,final String flags) throws ParserException {
  return new DefaultRegExp(pattern,flags);
}"
72086,"/** 
 * Compile a regexp with the given   {@code source} and {@code flags}.
 * @param pattern RegExp pattern string
 * @param flags  flag string
 * @throws ParserException if invalid source or flags
 */
public static RegExp create(final String pattern,final String flags){
  return instance.compile(pattern,flags);
}","/** 
 * Compile a regexp with the given   {@code source} and {@code flags}.
 * @param pattern RegExp pattern string
 * @param flags   flag string
 * @return new RegExp
 * @throws ParserException if invalid source or flags
 */
public static RegExp create(final String pattern,final String flags){
  return instance.compile(pattern,flags);
}"
72087,"/** 
 * Get the group with the given index or the empty string if group index is not valid.
 * @param index the group index
 * @return the group or """"
 */
public Object getGroup(int index){
  return index >= 0 && index < groups.length ? groups[index] : ""String_Node_Str"";
}","/** 
 * Get the group with the given index or the empty string if group index is not valid.
 * @param groupIndex the group index
 * @return the group or """"
 */
public Object getGroup(final int groupIndex){
  return groupIndex >= 0 && groupIndex < groups.length ? groups[groupIndex] : ""String_Node_Str"";
}"
72088,"public static boolean isDynamicMethod(final Object obj){
  return obj instanceof DynamicMethod;
}","/** 
 * Returns true if the object is a Dynalink Java dynamic method.
 * @param obj the object we want to test for being a dynamic method
 * @return true if it is a dynamic method, false otherwise.
 */
public static boolean isDynamicMethod(final Object obj){
  return obj instanceof DynamicMethod;
}"
72089,"public static final Attribute readAttribute(DataInputStream file,ConstantPool constant_pool) throws IOException, ClassFormatException {
  ConstantUtf8 c;
  String name;
  int name_index;
  int length;
  byte tag=Constants.ATTR_UNKNOWN;
  name_index=(int)file.readUnsignedShort();
  c=(ConstantUtf8)constant_pool.getConstant(name_index,Constants.CONSTANT_Utf8);
  name=c.getBytes();
  length=file.readInt();
  for (byte i=0; i < Constants.KNOWN_ATTRIBUTES; i++) {
    if (name.equals(Constants.ATTRIBUTE_NAMES[i])) {
      tag=i;
      break;
    }
  }
switch (tag) {
case Constants.ATTR_UNKNOWN:
    AttributeReader r=(AttributeReader)readers.get(name);
  if (r != null)   return r.createAttribute(name_index,length,file,constant_pool);
 else   return new Unknown(name_index,length,file,constant_pool);
case Constants.ATTR_CONSTANT_VALUE:
return new ConstantValue(name_index,length,file,constant_pool);
case Constants.ATTR_SOURCE_FILE:
return new SourceFile(name_index,length,file,constant_pool);
case Constants.ATTR_CODE:
return new Code(name_index,length,file,constant_pool);
case Constants.ATTR_EXCEPTIONS:
return new ExceptionTable(name_index,length,file,constant_pool);
case Constants.ATTR_LINE_NUMBER_TABLE:
return new LineNumberTable(name_index,length,file,constant_pool);
case Constants.ATTR_LOCAL_VARIABLE_TABLE:
return new LocalVariableTable(name_index,length,file,constant_pool);
case Constants.ATTR_INNER_CLASSES:
return new InnerClasses(name_index,length,file,constant_pool);
case Constants.ATTR_SYNTHETIC:
return new Synthetic(name_index,length,file,constant_pool);
case Constants.ATTR_DEPRECATED:
return new Deprecated(name_index,length,file,constant_pool);
case Constants.ATTR_PMG:
return new PMGClass(name_index,length,file,constant_pool);
case Constants.ATTR_SIGNATURE:
return new Signature(name_index,length,file,constant_pool);
case Constants.ATTR_STACK_MAP:
return new StackMap(name_index,length,file,constant_pool);
default :
throw new IllegalStateException(""String_Node_Str"");
}
}","public static final Attribute readAttribute(DataInputStream file,ConstantPool constant_pool) throws IOException, ClassFormatException {
  ConstantUtf8 c;
  String name;
  int name_index;
  int length;
  byte tag=Constants.ATTR_UNKNOWN;
  name_index=(int)file.readUnsignedShort();
  c=(ConstantUtf8)constant_pool.getConstant(name_index,Constants.CONSTANT_Utf8);
  name=c.getBytes();
  length=file.readInt();
  for (byte i=0; i < Constants.KNOWN_ATTRIBUTES; i++) {
    if (name.equals(Constants.ATTRIBUTE_NAMES[i])) {
      tag=i;
      break;
    }
  }
switch (tag) {
case Constants.ATTR_UNKNOWN:
    AttributeReader r=(AttributeReader)readers.get(name);
  if (r != null)   return r.createAttribute(name_index,length,file,constant_pool);
 else   return new Unknown(name_index,length,file,constant_pool);
case Constants.ATTR_CONSTANT_VALUE:
return new ConstantValue(name_index,length,file,constant_pool);
case Constants.ATTR_SOURCE_FILE:
return new SourceFile(name_index,length,file,constant_pool);
case Constants.ATTR_CODE:
return new Code(name_index,length,file,constant_pool);
case Constants.ATTR_EXCEPTIONS:
return new ExceptionTable(name_index,length,file,constant_pool);
case Constants.ATTR_LINE_NUMBER_TABLE:
return new LineNumberTable(name_index,length,file,constant_pool);
case Constants.ATTR_LOCAL_VARIABLE_TABLE:
return new LocalVariableTable(name_index,length,file,constant_pool);
case Constants.ATTR_LOCAL_VARIABLE_TYPE_TABLE:
return new LocalVariableTypeTable(name_index,length,file,constant_pool);
case Constants.ATTR_INNER_CLASSES:
return new InnerClasses(name_index,length,file,constant_pool);
case Constants.ATTR_SYNTHETIC:
return new Synthetic(name_index,length,file,constant_pool);
case Constants.ATTR_DEPRECATED:
return new Deprecated(name_index,length,file,constant_pool);
case Constants.ATTR_PMG:
return new PMGClass(name_index,length,file,constant_pool);
case Constants.ATTR_SIGNATURE:
return new Signature(name_index,length,file,constant_pool);
case Constants.ATTR_STACK_MAP:
return new StackMap(name_index,length,file,constant_pool);
default :
throw new IllegalStateException(""String_Node_Str"");
}
}"
72090,"/** 
 * Instantiate from existing method.
 * @param m method
 * @param class_name class name containing this method
 * @param cp constant pool
 */
public MethodGen(Method m,String class_name,ConstantPoolGen cp){
  this(m.getAccessFlags(),Type.getReturnType(m.getSignature()),Type.getArgumentTypes(m.getSignature()),null,m.getName(),class_name,((m.getAccessFlags() & (Constants.ACC_ABSTRACT | Constants.ACC_NATIVE)) == 0) ? new InstructionList(m.getCode().getCode()) : null,cp);
  Attribute[] attributes=m.getAttributes();
  for (int i=0; i < attributes.length; i++) {
    Attribute a=attributes[i];
    if (a instanceof Code) {
      Code c=(Code)a;
      setMaxStack(c.getMaxStack());
      setMaxLocals(c.getMaxLocals());
      CodeException[] ces=c.getExceptionTable();
      if (ces != null) {
        for (int j=0; j < ces.length; j++) {
          CodeException ce=ces[j];
          int type=ce.getCatchType();
          ObjectType c_type=null;
          if (type > 0) {
            String cen=m.getConstantPool().getConstantString(type,Constants.CONSTANT_Class);
            c_type=new ObjectType(cen);
          }
          int end_pc=ce.getEndPC();
          int length=m.getCode().getCode().length;
          InstructionHandle end;
          if (length == end_pc) {
            end=il.getEnd();
          }
 else {
            end=il.findHandle(end_pc);
            end=end.getPrev();
          }
          addExceptionHandler(il.findHandle(ce.getStartPC()),end,il.findHandle(ce.getHandlerPC()),c_type);
        }
      }
      Attribute[] c_attributes=c.getAttributes();
      for (int j=0; j < c_attributes.length; j++) {
        a=c_attributes[j];
        if (a instanceof LineNumberTable) {
          LineNumber[] ln=((LineNumberTable)a).getLineNumberTable();
          for (int k=0; k < ln.length; k++) {
            LineNumber l=ln[k];
            addLineNumber(il.findHandle(l.getStartPC()),l.getLineNumber());
          }
        }
 else         if (a instanceof LocalVariableTable) {
          LocalVariable[] lv=((LocalVariableTable)a).getLocalVariableTable();
          removeLocalVariables();
          for (int k=0; k < lv.length; k++) {
            LocalVariable l=lv[k];
            InstructionHandle start=il.findHandle(l.getStartPC());
            InstructionHandle end=il.findHandle(l.getStartPC() + l.getLength());
            if (null == start) {
              start=il.getStart();
            }
            if (null == end) {
              end=il.getEnd();
            }
            addLocalVariable(l.getName(),Type.getType(l.getSignature()),l.getIndex(),start,end);
          }
        }
 else         addCodeAttribute(a);
      }
    }
 else     if (a instanceof ExceptionTable) {
      String[] names=((ExceptionTable)a).getExceptionNames();
      for (int j=0; j < names.length; j++)       addException(names[j]);
    }
 else     addAttribute(a);
  }
}","/** 
 * Instantiate from existing method.
 * @param m method
 * @param class_name class name containing this method
 * @param cp constant pool
 */
public MethodGen(Method m,String class_name,ConstantPoolGen cp){
  this(m.getAccessFlags(),Type.getReturnType(m.getSignature()),Type.getArgumentTypes(m.getSignature()),null,m.getName(),class_name,((m.getAccessFlags() & (Constants.ACC_ABSTRACT | Constants.ACC_NATIVE)) == 0) ? new InstructionList(m.getCode().getCode()) : null,cp);
  Attribute[] attributes=m.getAttributes();
  for (int i=0; i < attributes.length; i++) {
    Attribute a=attributes[i];
    if (a instanceof Code) {
      Code c=(Code)a;
      setMaxStack(c.getMaxStack());
      setMaxLocals(c.getMaxLocals());
      CodeException[] ces=c.getExceptionTable();
      if (ces != null) {
        for (int j=0; j < ces.length; j++) {
          CodeException ce=ces[j];
          int type=ce.getCatchType();
          ObjectType c_type=null;
          if (type > 0) {
            String cen=m.getConstantPool().getConstantString(type,Constants.CONSTANT_Class);
            c_type=new ObjectType(cen);
          }
          int end_pc=ce.getEndPC();
          int length=m.getCode().getCode().length;
          InstructionHandle end;
          if (length == end_pc) {
            end=il.getEnd();
          }
 else {
            end=il.findHandle(end_pc);
            end=end.getPrev();
          }
          addExceptionHandler(il.findHandle(ce.getStartPC()),end,il.findHandle(ce.getHandlerPC()),c_type);
        }
      }
      Attribute[] c_attributes=c.getAttributes();
      for (int j=0; j < c_attributes.length; j++) {
        a=c_attributes[j];
        if (a instanceof LineNumberTable) {
          LineNumber[] ln=((LineNumberTable)a).getLineNumberTable();
          for (int k=0; k < ln.length; k++) {
            LineNumber l=ln[k];
            addLineNumber(il.findHandle(l.getStartPC()),l.getLineNumber());
          }
        }
 else         if (a instanceof LocalVariableTable) {
          LocalVariable[] lv=((LocalVariableTable)a).getLocalVariableTable();
          removeLocalVariables();
          for (int k=0; k < lv.length; k++) {
            LocalVariable l=lv[k];
            InstructionHandle start=il.findHandle(l.getStartPC());
            InstructionHandle end=il.findHandle(l.getStartPC() + l.getLength());
            if (null == start) {
              start=il.getStart();
            }
            if (null == end) {
              end=il.getEnd();
            }
            addLocalVariable(l.getName(),Type.getType(l.getSignature()),l.getIndex(),start,end);
          }
        }
 else         if (a instanceof LocalVariableTypeTable) {
          LocalVariable[] lv=((LocalVariableTypeTable)a).getLocalVariableTypeTable();
          removeLocalVariables();
          for (int k=0; k < lv.length; k++) {
            LocalVariable l=lv[k];
            InstructionHandle start=il.findHandle(l.getStartPC());
            InstructionHandle end=il.findHandle(l.getStartPC() + l.getLength());
            if (null == start) {
              start=il.getStart();
            }
            if (null == end) {
              end=il.getEnd();
            }
            addLocalVariable(l.getName(),Type.getType(l.getSignature()),l.getIndex(),start,end);
          }
        }
 else         addCodeAttribute(a);
      }
    }
 else     if (a instanceof ExceptionTable) {
      String[] names=((ExceptionTable)a).getExceptionNames();
      for (int j=0; j < names.length; j++)       addException(names[j]);
    }
 else     addAttribute(a);
  }
}"
72091,"@Override public Symbol access(Name name,TypeSymbol location){
  return types.createErrorType(name,location,syms.errSymbol.type).tsym;
}","@Override protected Symbol access(Name name,TypeSymbol location){
  return ambiguousSyms.last();
}"
72092,"Symbol mostSpecific(List<Type> argtypes,Symbol m1,Symbol m2,Env<AttrContext> env,final Type site,boolean allowBoxing,boolean useVarargs){
switch (m2.kind) {
case MTH:
    if (m1 == m2)     return m1;
  boolean m1SignatureMoreSpecific=signatureMoreSpecific(argtypes,env,site,m1,m2,allowBoxing,useVarargs);
boolean m2SignatureMoreSpecific=signatureMoreSpecific(argtypes,env,site,m2,m1,allowBoxing,useVarargs);
if (m1SignatureMoreSpecific && m2SignatureMoreSpecific) {
Type mt1=types.memberType(site,m1);
Type mt2=types.memberType(site,m2);
if (!types.overrideEquivalent(mt1,mt2)) return ambiguityError(m1,m2);
if ((m1.flags() & BRIDGE) != (m2.flags() & BRIDGE)) return ((m1.flags() & BRIDGE) != 0) ? m2 : m1;
TypeSymbol m1Owner=(TypeSymbol)m1.owner;
TypeSymbol m2Owner=(TypeSymbol)m2.owner;
if (types.asSuper(m1Owner.type,m2Owner) != null && ((m1.owner.flags_field & INTERFACE) == 0 || (m2.owner.flags_field & INTERFACE) != 0) && m1.overrides(m2,m1Owner,types,false)) return m1;
if (types.asSuper(m2Owner.type,m1Owner) != null && ((m2.owner.flags_field & INTERFACE) == 0 || (m1.owner.flags_field & INTERFACE) != 0) && m2.overrides(m1,m2Owner,types,false)) return m2;
boolean m1Abstract=(m1.flags() & ABSTRACT) != 0;
boolean m2Abstract=(m2.flags() & ABSTRACT) != 0;
if (m1Abstract && !m2Abstract) return m2;
if (m2Abstract && !m1Abstract) return m1;
if (!m1Abstract && !m2Abstract) return ambiguityError(m1,m2);
if (!types.isSameTypes(m1.erasure(types).getParameterTypes(),m2.erasure(types).getParameterTypes())) return ambiguityError(m1,m2);
Type mst=mostSpecificReturnType(mt1,mt2);
if (mst == null) {
  return ambiguityError(m1,m2);
}
Symbol mostSpecific=mst == mt1 ? m1 : m2;
List<Type> allThrown=chk.intersect(mt1.getThrownTypes(),mt2.getThrownTypes());
Type newSig=types.createMethodTypeWithThrown(mostSpecific.type,allThrown);
MethodSymbol result=new MethodSymbol(mostSpecific.flags(),mostSpecific.name,newSig,mostSpecific.owner){
  @Override public MethodSymbol implementation(  TypeSymbol origin,  Types types,  boolean checkResult){
    if (origin == site.tsym)     return this;
 else     return super.implementation(origin,types,checkResult);
  }
}
;
return result;
}
if (m1SignatureMoreSpecific) return m1;
if (m2SignatureMoreSpecific) return m2;
return ambiguityError(m1,m2);
case AMBIGUOUS:
AmbiguityError e=(AmbiguityError)m2;
Symbol err1=mostSpecific(argtypes,m1,e.sym,env,site,allowBoxing,useVarargs);
Symbol err2=mostSpecific(argtypes,m1,e.sym2,env,site,allowBoxing,useVarargs);
if (err1 == err2) return err1;
if (err1 == e.sym && err2 == e.sym2) return m2;
if (err1 instanceof AmbiguityError && err2 instanceof AmbiguityError && ((AmbiguityError)err1).sym == ((AmbiguityError)err2).sym) return ambiguityError(m1,m2);
 else return ambiguityError(err1,err2);
default :
throw new AssertionError();
}
}","Symbol mostSpecific(List<Type> argtypes,Symbol m1,Symbol m2,Env<AttrContext> env,final Type site,boolean allowBoxing,boolean useVarargs){
switch (m2.kind) {
case MTH:
    if (m1 == m2)     return m1;
  boolean m1SignatureMoreSpecific=signatureMoreSpecific(argtypes,env,site,m1,m2,allowBoxing,useVarargs);
boolean m2SignatureMoreSpecific=signatureMoreSpecific(argtypes,env,site,m2,m1,allowBoxing,useVarargs);
if (m1SignatureMoreSpecific && m2SignatureMoreSpecific) {
Type mt1=types.memberType(site,m1);
Type mt2=types.memberType(site,m2);
if (!types.overrideEquivalent(mt1,mt2)) return ambiguityError(m1,m2);
if ((m1.flags() & BRIDGE) != (m2.flags() & BRIDGE)) return ((m1.flags() & BRIDGE) != 0) ? m2 : m1;
TypeSymbol m1Owner=(TypeSymbol)m1.owner;
TypeSymbol m2Owner=(TypeSymbol)m2.owner;
if (types.asSuper(m1Owner.type,m2Owner) != null && ((m1.owner.flags_field & INTERFACE) == 0 || (m2.owner.flags_field & INTERFACE) != 0) && m1.overrides(m2,m1Owner,types,false)) return m1;
if (types.asSuper(m2Owner.type,m1Owner) != null && ((m2.owner.flags_field & INTERFACE) == 0 || (m1.owner.flags_field & INTERFACE) != 0) && m2.overrides(m1,m2Owner,types,false)) return m2;
boolean m1Abstract=(m1.flags() & ABSTRACT) != 0;
boolean m2Abstract=(m2.flags() & ABSTRACT) != 0;
if (m1Abstract && !m2Abstract) return m2;
if (m2Abstract && !m1Abstract) return m1;
return ambiguityError(m1,m2);
}
if (m1SignatureMoreSpecific) return m1;
if (m2SignatureMoreSpecific) return m2;
return ambiguityError(m1,m2);
case AMBIGUOUS:
AmbiguityError e=(AmbiguityError)m2;
for (Symbol s : e.ambiguousSyms) {
if (mostSpecific(argtypes,m1,s,env,site,allowBoxing,useVarargs) != m1) {
return e.addAmbiguousSymbol(m1);
}
}
return m1;
default :
throw new AssertionError();
}
}"
72093,"AmbiguityError(Symbol sym1,Symbol sym2){
  super(AMBIGUOUS,sym1,""String_Node_Str"");
  this.sym2=sym2;
}","AmbiguityError(Symbol sym1,Symbol sym2){
  super(AMBIGUOUS,""String_Node_Str"");
  ambiguousSyms=flatten(sym2).appendList(flatten(sym1));
}"
72094,"@Override JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,DiagnosticPosition pos,Symbol location,Type site,Name name,List<Type> argtypes,List<Type> typeargtypes){
  AmbiguityError pair=this;
  while (true) {
    if (pair.sym.kind == AMBIGUOUS)     pair=(AmbiguityError)pair.sym;
 else     if (pair.sym2.kind == AMBIGUOUS)     pair=(AmbiguityError)pair.sym2;
 else     break;
  }
  Name sname=pair.sym.name;
  if (sname == names.init)   sname=pair.sym.owner.name;
  return diags.create(dkind,log.currentSource(),pos,""String_Node_Str"",sname,kindName(pair.sym),pair.sym,pair.sym.location(site,types),kindName(pair.sym2),pair.sym2,pair.sym2.location(site,types));
}","@Override JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,DiagnosticPosition pos,Symbol location,Type site,Name name,List<Type> argtypes,List<Type> typeargtypes){
  List<Symbol> diagSyms=ambiguousSyms.reverse();
  Symbol s1=diagSyms.head;
  Symbol s2=diagSyms.tail.head;
  Name sname=s1.name;
  if (sname == names.init)   sname=s1.owner.name;
  return diags.create(dkind,log.currentSource(),pos,""String_Node_Str"",sname,kindName(s1),s1,s1.location(site,types),kindName(s2),s2,s2.location(site,types));
}"
72095,"@Override public boolean exists(){
  return false;
}","@Override public boolean exists(){
  return true;
}"
72096,"/** 
 * Construct the SplitIndexWriter. Uses path to this file and relative path from this file.
 * @param path       Path to the file which is getting generated.
 * @param filename   Name of the file which is getting genrated.
 * @param relpath    Relative path from this file to the current directory.
 * @param indexbuilder Unicode based Index from {@link IndexBuilder}
 */
public SplitIndexWriter(ConfigurationImpl configuration,DocPath path,IndexBuilder indexbuilder,int prev,int next) throws IOException {
  super(configuration,path,indexbuilder);
  this.prev=prev;
  this.next=next;
}","/** 
 * Construct the SplitIndexWriter. Uses path to this file and relative path from this file.
 * @param path       Path to the file which is getting generated.
 * @param indexbuilder Unicode based Index from {@link IndexBuilder}
 */
public SplitIndexWriter(ConfigurationImpl configuration,DocPath path,IndexBuilder indexbuilder,int prev,int next) throws IOException {
  super(configuration,path,indexbuilder);
  this.prev=prev;
  this.next=next;
}"
72097,"/** 
 * Constructor.
 * @param path The directory path to be created for this fileor null if none to be created.
 * @param filename File Name to which the PrintWriter willdo the Output.
 * @exception IOException Exception raised by the FileWriter is passed onto next level.
 * @exception UnsupportedEncodingException Exception raised by theOutputStreamWriter is passed on to next level.
 */
public HtmlWriter(Configuration configuration,DocPath path) throws IOException, UnsupportedEncodingException {
  writer=Util.genWriter(configuration,path);
  this.configuration=configuration;
  this.memberDetailsListPrinted=false;
  packageTableHeader=new String[]{configuration.getText(""String_Node_Str""),configuration.getText(""String_Node_Str"")};
  useTableSummary=configuration.getText(""String_Node_Str"",configuration.getText(""String_Node_Str""));
  modifierTypeHeader=configuration.getText(""String_Node_Str"",configuration.getText(""String_Node_Str""),configuration.getText(""String_Node_Str""));
  overviewLabel=getResource(""String_Node_Str"");
  defaultPackageLabel=new RawHtml(DocletConstants.DEFAULT_PACKAGE_NAME);
  packageLabel=getResource(""String_Node_Str"");
  useLabel=getResource(""String_Node_Str"");
  prevLabel=getResource(""String_Node_Str"");
  nextLabel=getResource(""String_Node_Str"");
  prevclassLabel=getResource(""String_Node_Str"");
  nextclassLabel=getResource(""String_Node_Str"");
  summaryLabel=getResource(""String_Node_Str"");
  detailLabel=getResource(""String_Node_Str"");
  framesLabel=getResource(""String_Node_Str"");
  noframesLabel=getResource(""String_Node_Str"");
  treeLabel=getResource(""String_Node_Str"");
  classLabel=getResource(""String_Node_Str"");
  deprecatedLabel=getResource(""String_Node_Str"");
  deprecatedPhrase=getResource(""String_Node_Str"");
  allclassesLabel=getResource(""String_Node_Str"");
  indexLabel=getResource(""String_Node_Str"");
  helpLabel=getResource(""String_Node_Str"");
  seeLabel=getResource(""String_Node_Str"");
  descriptionLabel=getResource(""String_Node_Str"");
  prevpackageLabel=getResource(""String_Node_Str"");
  nextpackageLabel=getResource(""String_Node_Str"");
  packagesLabel=getResource(""String_Node_Str"");
  methodDetailsLabel=getResource(""String_Node_Str"");
  annotationTypeDetailsLabel=getResource(""String_Node_Str"");
  fieldDetailsLabel=getResource(""String_Node_Str"");
  constructorDetailsLabel=getResource(""String_Node_Str"");
  enumConstantsDetailsLabel=getResource(""String_Node_Str"");
  specifiedByLabel=getResource(""String_Node_Str"");
  overridesLabel=getResource(""String_Node_Str"");
  descfrmClassLabel=getResource(""String_Node_Str"");
  descfrmInterfaceLabel=getResource(""String_Node_Str"");
}","/** 
 * Constructor.
 * @param path The directory path to be created for this fileor null if none to be created.
 * @exception IOException Exception raised by the FileWriter is passed onto next level.
 * @exception UnsupportedEncodingException Exception raised by theOutputStreamWriter is passed on to next level.
 */
public HtmlWriter(Configuration configuration,DocPath path) throws IOException, UnsupportedEncodingException {
  writer=Util.genWriter(configuration,path);
  this.configuration=configuration;
  this.memberDetailsListPrinted=false;
  packageTableHeader=new String[]{configuration.getText(""String_Node_Str""),configuration.getText(""String_Node_Str"")};
  useTableSummary=configuration.getText(""String_Node_Str"",configuration.getText(""String_Node_Str""));
  modifierTypeHeader=configuration.getText(""String_Node_Str"",configuration.getText(""String_Node_Str""),configuration.getText(""String_Node_Str""));
  overviewLabel=getResource(""String_Node_Str"");
  defaultPackageLabel=new RawHtml(DocletConstants.DEFAULT_PACKAGE_NAME);
  packageLabel=getResource(""String_Node_Str"");
  useLabel=getResource(""String_Node_Str"");
  prevLabel=getResource(""String_Node_Str"");
  nextLabel=getResource(""String_Node_Str"");
  prevclassLabel=getResource(""String_Node_Str"");
  nextclassLabel=getResource(""String_Node_Str"");
  summaryLabel=getResource(""String_Node_Str"");
  detailLabel=getResource(""String_Node_Str"");
  framesLabel=getResource(""String_Node_Str"");
  noframesLabel=getResource(""String_Node_Str"");
  treeLabel=getResource(""String_Node_Str"");
  classLabel=getResource(""String_Node_Str"");
  deprecatedLabel=getResource(""String_Node_Str"");
  deprecatedPhrase=getResource(""String_Node_Str"");
  allclassesLabel=getResource(""String_Node_Str"");
  indexLabel=getResource(""String_Node_Str"");
  helpLabel=getResource(""String_Node_Str"");
  seeLabel=getResource(""String_Node_Str"");
  descriptionLabel=getResource(""String_Node_Str"");
  prevpackageLabel=getResource(""String_Node_Str"");
  nextpackageLabel=getResource(""String_Node_Str"");
  packagesLabel=getResource(""String_Node_Str"");
  methodDetailsLabel=getResource(""String_Node_Str"");
  annotationTypeDetailsLabel=getResource(""String_Node_Str"");
  fieldDetailsLabel=getResource(""String_Node_Str"");
  constructorDetailsLabel=getResource(""String_Node_Str"");
  enumConstantsDetailsLabel=getResource(""String_Node_Str"");
  specifiedByLabel=getResource(""String_Node_Str"");
  overridesLabel=getResource(""String_Node_Str"");
  descfrmClassLabel=getResource(""String_Node_Str"");
  descfrmInterfaceLabel=getResource(""String_Node_Str"");
}"
72098,"/** 
 * @inheritDoc 
 */
@Override public int hashCode(){
  return path.hashCode();
}","/** 
 * {@inheritDoc} 
 */
@Override public int hashCode(){
  return path.hashCode();
}"
72099,"/** 
 * @inheritDoc 
 */
@Override public boolean equals(Object other){
  return (other instanceof DocPath) && path.equals(((DocPath)other).path);
}","/** 
 * {@inheritDoc} 
 */
@Override public boolean equals(Object other){
  return (other instanceof DocPath) && path.equals(((DocPath)other).path);
}"
72100,"/** 
 * Find the specified directory in the source path.
 * @param name Name of the directory to be searched for in the source path.
 * @return File Return the directory if found else return null.
 */
public File getDirectory(DocPath p){
  for (int i=0; i < sourcePath.length; i++) {
    File directoryNeeded=new File(sourcePath[i],p.getPath());
    if (directoryNeeded.isDirectory()) {
      return directoryNeeded;
    }
  }
  return null;
}","/** 
 * Find the specified directory in the source path.
 * @param p Name of the directory to be searched for in the source path.
 * @return File Return the directory if found else return null.
 */
public File getDirectory(DocPath p){
  for (int i=0; i < sourcePath.length; i++) {
    File directoryNeeded=new File(sourcePath[i],p.getPath());
    if (directoryNeeded.isDirectory()) {
      return directoryNeeded;
    }
  }
  return null;
}"
72101,"/** 
 * Create the directory path for the file to be generated, construct FileOutputStream and OutputStreamWriter depending upon docencoding.
 * @param path The directory path to be created for this file.
 * @param filename File Name to which the PrintWriter will do the Output.
 * @param docencoding Encoding to be used for this file.
 * @exception IOException Exception raised by the FileWriter is passed onto next level.
 * @exception UnsupportedEncodingException Exception raised by theOutputStreamWriter is passed on to next level.
 * @return Writer Writer for the file getting generated.
 * @see java.io.FileOutputStream
 * @see java.io.OutputStreamWriter
 */
public static Writer genWriter(Configuration configuration,DocPath path) throws IOException, UnsupportedEncodingException {
  File file=path.resolveAgainst(configuration.destDirName);
  createDirectory(configuration,file.getParentFile());
  FileOutputStream fos=new FileOutputStream(file);
  if (configuration.docencoding == null) {
    return new BufferedWriter(new OutputStreamWriter(fos));
  }
 else {
    return new BufferedWriter(new OutputStreamWriter(fos,configuration.docencoding));
  }
}","/** 
 * Create the directory path for the file to be generated, construct FileOutputStream and OutputStreamWriter depending upon docencoding.
 * @param path The directory path to be created for this file.
 * @exception IOException Exception raised by the FileWriter is passed onto next level.
 * @exception UnsupportedEncodingException Exception raised by theOutputStreamWriter is passed on to next level.
 * @return Writer Writer for the file getting generated.
 * @see java.io.FileOutputStream
 * @see java.io.OutputStreamWriter
 */
public static Writer genWriter(Configuration configuration,DocPath path) throws IOException, UnsupportedEncodingException {
  File file=path.resolveAgainst(configuration.destDirName);
  createDirectory(configuration,file.getParentFile());
  FileOutputStream fos=new FileOutputStream(file);
  if (configuration.docencoding == null) {
    return new BufferedWriter(new OutputStreamWriter(fos));
  }
 else {
    return new BufferedWriter(new OutputStreamWriter(fos,configuration.docencoding));
  }
}"
72102,"/** 
 * Given a path string create all the directories in the path. For example, if the path string is ""java/applet"", the method will create directory ""java"" and then ""java/applet"" if they don't exist. The file separator string ""/"" is platform dependent system property.
 * @param path Directory path string.
 */
public static void createDirectory(Configuration configuration,File dir){
  if (dir == null) {
    return;
  }
  if (dir.exists()) {
    return;
  }
 else {
    if (dir.mkdirs()) {
      return;
    }
 else {
      configuration.message.error(""String_Node_Str"",dir.getPath());
      throw new DocletAbortException();
    }
  }
}","/** 
 * Given a path string create all the directories in the path. For example, if the path string is ""java/applet"", the method will create directory ""java"" and then ""java/applet"" if they don't exist. The file separator string ""/"" is platform dependent system property.
 * @param dir Directory path string.
 */
public static void createDirectory(Configuration configuration,File dir){
  if (dir == null) {
    return;
  }
  if (dir.exists()) {
    return;
  }
 else {
    if (dir.mkdirs()) {
      return;
    }
 else {
      configuration.message.error(""String_Node_Str"",dir.getPath());
      throw new DocletAbortException();
    }
  }
}"
72103,"/** 
 * Return the kind of this tag. similar or synonymous tags.  For most tags, <code>kind()&nbsp;==&nbsp;name()</code>; the following table lists those cases where there is more than one tag of a given kind: <p> <table border=""1"" cellpadding=""4"" cellspacing=""0""> <tr><th><tt> kind()  </th>  <th><tt> name()      </th></tr> <tr><td><tt> @throws </td>  <td><tt> @throws     </td></tr> <tr><td><tt> @throws </td>  <td><tt> @exception  </td></tr> <tr><td><tt> @see    </td>  <td><tt> @see        </td></tr> <tr><td><tt> @see    </td>  <td><tt> @link       </td></tr> <tr><td><tt> @see    </td>  <td><tt> @linkplain  </td></tr> <tr><td><tt> @serial </td>  <td><tt> @serial     </td></tr> <tr><td><tt> @serial </td>  <td><tt> @serialData </td></tr> </table>
 */
String kind();","/** 
 * Return the kind of this tag. similar or synonymous tags.  For most tags, <code>kind()&nbsp;==&nbsp;name()</code>; the following table lists those cases where there is more than one tag of a given kind: <p> <table border=""1"" cellpadding=""4"" cellspacing=""0""> <tr><th><tt> kind()  </tt></th>  <th><tt> name()      </tt></th></tr> <tr><td><tt> @throws </tt></td>  <td><tt> @throws     </tt></td></tr> <tr><td><tt> @throws </tt></td>  <td><tt> @exception  </tt></td></tr> <tr><td><tt> @see    </tt></td>  <td><tt> @see        </tt></td></tr> <tr><td><tt> @see    </tt></td>  <td><tt> @link       </tt></td></tr> <tr><td><tt> @see    </tt></td>  <td><tt> @linkplain  </tt></td></tr> <tr><td><tt> @serial </tt></td>  <td><tt> @serial     </tt></td></tr> <tr><td><tt> @serial </tt></td>  <td><tt> @serialData </tt></td></tr> </table>
 */
String kind();"
72104,"/** 
 * Get the ClassFile object for a specified class.
 * @param className the name of the class to be returned.
 * @return the ClassFile for the given class
 * @throws Dependencies #ClassFileNotFoundException if the classfile cannot be found
 */
public ClassFile getClassFile(String className) throws ClassFileNotFoundException ;","/** 
 * Get the ClassFile object for a specified class.
 * @param className the name of the class to be returned.
 * @return the ClassFile for the given class
 * @throws Dependencies.ClassFileNotFoundException if the classfile cannot befound
 */
public ClassFile getClassFile(String className) throws ClassFileNotFoundException ;"
72105,"/** 
 * See   {@link Kind#LOCAL_UBYTE}. 
 */
R visitLocalAndValue(Instruction instr,int index,int value,P p);","/** 
 * See   {@link Kind#LOCAL_BYTE}. 
 */
R visitLocalAndValue(Instruction instr,int index,int value,P p);"
72106,"/** 
 * Add all the parameters for the executable member.
 * @param member the member to write parameters for.
 * @param includeAnnotations true if annotation information needs to be added.
 * @param tree the content tree to which the parameters information will be added.
 */
protected void addParameters(ExecutableMemberDoc member,boolean includeAnnotations,Content htmltree){
  htmltree.addContent(""String_Node_Str"");
  Parameter[] params=member.parameters();
  String indent=makeSpace(writer.displayLength);
  if (configuration().linksource) {
    indent+=makeSpace(member.name().length());
  }
  int paramstart;
  for (paramstart=0; paramstart < params.length; paramstart++) {
    Parameter param=params[paramstart];
    if (!param.name().startsWith(""String_Node_Str"")) {
      if (includeAnnotations) {
        boolean foundAnnotations=writer.addAnnotationInfo(indent.length(),member,param,htmltree);
        if (foundAnnotations) {
          htmltree.addContent(DocletConstants.NL);
          htmltree.addContent(indent);
        }
      }
      addParam(member,param,(paramstart == params.length - 1) && member.isVarArgs(),htmltree);
      break;
    }
  }
  for (int i=paramstart + 1; i < params.length; i++) {
    htmltree.addContent(""String_Node_Str"");
    htmltree.addContent(DocletConstants.NL);
    htmltree.addContent(indent);
    if (includeAnnotations) {
      boolean foundAnnotations=writer.addAnnotationInfo(indent.length(),member,params[i],htmltree);
      if (foundAnnotations) {
        htmltree.addContent(DocletConstants.NL);
        htmltree.addContent(indent);
      }
    }
    addParam(member,params[i],(i == params.length - 1) && member.isVarArgs(),htmltree);
  }
  htmltree.addContent(""String_Node_Str"");
}","/** 
 * Add all the parameters for the executable member.
 * @param member the member to write parameters for.
 * @param includeAnnotations true if annotation information needs to be added.
 * @param htmltree the content tree to which the parameters information will be added.
 */
protected void addParameters(ExecutableMemberDoc member,boolean includeAnnotations,Content htmltree){
  htmltree.addContent(""String_Node_Str"");
  Parameter[] params=member.parameters();
  String indent=makeSpace(writer.displayLength);
  if (configuration().linksource) {
    indent+=makeSpace(member.name().length());
  }
  int paramstart;
  for (paramstart=0; paramstart < params.length; paramstart++) {
    Parameter param=params[paramstart];
    if (!param.name().startsWith(""String_Node_Str"")) {
      if (includeAnnotations) {
        boolean foundAnnotations=writer.addAnnotationInfo(indent.length(),member,param,htmltree);
        if (foundAnnotations) {
          htmltree.addContent(DocletConstants.NL);
          htmltree.addContent(indent);
        }
      }
      addParam(member,param,(paramstart == params.length - 1) && member.isVarArgs(),htmltree);
      break;
    }
  }
  for (int i=paramstart + 1; i < params.length; i++) {
    htmltree.addContent(""String_Node_Str"");
    htmltree.addContent(DocletConstants.NL);
    htmltree.addContent(indent);
    if (includeAnnotations) {
      boolean foundAnnotations=writer.addAnnotationInfo(indent.length(),member,params[i],htmltree);
      if (foundAnnotations) {
        htmltree.addContent(DocletConstants.NL);
        htmltree.addContent(indent);
      }
    }
    addParam(member,params[i],(i == params.length - 1) && member.isVarArgs(),htmltree);
  }
  htmltree.addContent(""String_Node_Str"");
}"
72107,"/** 
 * Add the inherited summary link for the member.
 * @param classDoc the classDoc that we should link to
 * @param member the member being linked to
 * @param linksTree the content tree to which the link will be added
 */
protected void addInheritedSummaryLink(ClassDoc cd,ProgramElementDoc member,Content linksTree){
  linksTree.addContent(new RawHtml(writer.getDocLink(LinkInfoImpl.CONTEXT_MEMBER,cd,(MemberDoc)member,member.name(),false)));
}","/** 
 * Add the inherited summary link for the member.
 * @param cd the classDoc that we should link to
 * @param member the member being linked to
 * @param linksTree the content tree to which the link will be added
 */
protected void addInheritedSummaryLink(ClassDoc cd,ProgramElementDoc member,Content linksTree){
  linksTree.addContent(new RawHtml(writer.getDocLink(LinkInfoImpl.CONTEXT_MEMBER,cd,(MemberDoc)member,member.name(),false)));
}"
72108,"/** 
 * Add the summary link for the member.
 * @param context the id of the context where the link will be printed
 * @param classDoc the classDoc that we should link to
 * @param member the member being linked to
 * @param tdSummary the content tree to which the link will be added
 */
protected void addSummaryLink(int context,ClassDoc cd,ProgramElementDoc member,Content tdSummary){
  ExecutableMemberDoc emd=(ExecutableMemberDoc)member;
  String name=emd.name();
  Content strong=HtmlTree.STRONG(new RawHtml(writer.getDocLink(context,cd,(MemberDoc)emd,name,false)));
  Content code=HtmlTree.CODE(strong);
  writer.displayLength=name.length();
  addParameters(emd,false,code);
  tdSummary.addContent(code);
}","/** 
 * Add the summary link for the member.
 * @param context the id of the context where the link will be printed
 * @param cd the classDoc that we should link to
 * @param member the member being linked to
 * @param tdSummary the content tree to which the link will be added
 */
protected void addSummaryLink(int context,ClassDoc cd,ProgramElementDoc member,Content tdSummary){
  ExecutableMemberDoc emd=(ExecutableMemberDoc)member;
  String name=emd.name();
  Content strong=HtmlTree.STRONG(new RawHtml(writer.getDocLink(context,cd,(MemberDoc)emd,name,false)));
  Content code=HtmlTree.CODE(strong);
  writer.displayLength=name.length();
  addParameters(emd,false,code);
  tdSummary.addContent(code);
}"
72109,"/** 
 * Add the comment for the given member.
 * @param member the member being documented.
 * @param contentTree the content tree to which the comment will be added.
 */
protected void addComment(ProgramElementDoc member,Content htmltree){
  if (member.inlineTags().length > 0) {
    writer.addInlineComment(member,htmltree);
  }
}","/** 
 * Add the comment for the given member.
 * @param member the member being documented.
 * @param htmltree the content tree to which the comment will be added.
 */
protected void addComment(ProgramElementDoc member,Content htmltree){
  if (member.inlineTags().length > 0) {
    writer.addInlineComment(member,htmltree);
  }
}"
72110,"/** 
 * Constructor. Initialises resource for the  {@link com.sun.tools.doclets.MessageRetriever}.
 */
private ConfigurationImpl(){
  standardmessage=new MessageRetriever(this,""String_Node_Str"");
}","/** 
 * Constructor. Initializes resource for the  {@link com.sun.tools.doclets.internal.toolkit.util.MessageRetriever MessageRetriever}.
 */
private ConfigurationImpl(){
  standardmessage=new MessageRetriever(this,""String_Node_Str"");
}"
72111,"/** 
 * Add the anchor.
 * @param builder the deprecated list builder
 * @param type the type of list being documented
 * @param contentTree the content tree to which the anchor will be added
 */
private void addAnchor(DeprecatedAPIListBuilder builder,int type,Content htmlTree){
  if (builder.hasDocumentation(type)) {
    htmlTree.addContent(getMarkerAnchor(ANCHORS[type]));
  }
}","/** 
 * Add the anchor.
 * @param builder the deprecated list builder
 * @param type the type of list being documented
 * @param htmlTree the content tree to which the anchor will be added
 */
private void addAnchor(DeprecatedAPIListBuilder builder,int type,Content htmlTree){
  if (builder.hasDocumentation(type)) {
    htmlTree.addContent(getMarkerAnchor(ANCHORS[type]));
  }
}"
72112,"/** 
 * Returns a package name label.
 * @param parsedName the package name
 * @return the package name content
 */
public Content getPackageLabel(String packageName){
  return new StringContent(packageName);
}","/** 
 * Returns a package name label.
 * @param packageName the package name
 * @return the package name content
 */
public Content getPackageLabel(String packageName){
  return new StringContent(packageName);
}"
72113,"/** 
 * Add the member header.
 * @param fieldsType the class document to be listed
 * @param fieldTypeStr the string for the filed type to be documented
 * @param fieldDimensions the dimensions of the field string to be added
 * @param firldName name of the field to be added
 * @param contentTree the content tree to which the member header will be added
 */
public void addMemberHeader(ClassDoc fieldType,String fieldTypeStr,String fieldDimensions,String fieldName,Content contentTree){
  Content nameContent=new RawHtml(fieldName);
  Content heading=HtmlTree.HEADING(HtmlConstants.MEMBER_HEADING,nameContent);
  contentTree.addContent(heading);
  Content pre=new HtmlTree(HtmlTag.PRE);
  if (fieldType == null) {
    pre.addContent(fieldTypeStr);
  }
 else {
    Content fieldContent=new RawHtml(writer.getLink(new LinkInfoImpl(LinkInfoImpl.CONTEXT_SERIAL_MEMBER,fieldType)));
    pre.addContent(fieldContent);
  }
  pre.addContent(fieldDimensions + ""String_Node_Str"");
  pre.addContent(fieldName);
  contentTree.addContent(pre);
}","/** 
 * Add the member header.
 * @param fieldType the class document to be listed
 * @param fieldTypeStr the string for the field type to be documented
 * @param fieldDimensions the dimensions of the field string to be added
 * @param fieldName name of the field to be added
 * @param contentTree the content tree to which the member header will be added
 */
public void addMemberHeader(ClassDoc fieldType,String fieldTypeStr,String fieldDimensions,String fieldName,Content contentTree){
  Content nameContent=new RawHtml(fieldName);
  Content heading=HtmlTree.HEADING(HtmlConstants.MEMBER_HEADING,nameContent);
  contentTree.addContent(heading);
  Content pre=new HtmlTree(HtmlTag.PRE);
  if (fieldType == null) {
    pre.addContent(fieldTypeStr);
  }
 else {
    Content fieldContent=new RawHtml(writer.getLink(new LinkInfoImpl(LinkInfoImpl.CONTEXT_SERIAL_MEMBER,fieldType)));
    pre.addContent(fieldContent);
  }
  pre.addContent(fieldDimensions + ""String_Node_Str"");
  pre.addContent(fieldName);
  contentTree.addContent(pre);
}"
72114,"/** 
 * Return path to the given file name in the given package. So if the name passed is ""Object.html"" and the name of the package is ""java.lang"", and if the relative path is ""../.."" then returned string will be ""../../java/lang/Object.html""
 * @param linkInfo the information about the link.
 * @param fileName the file name, to which path string is.
 */
private String pathString(LinkInfoImpl linkInfo){
  if (linkInfo.context == LinkInfoImpl.PACKAGE_FRAME) {
    return linkInfo.classDoc.name() + ""String_Node_Str"";
  }
  StringBuffer buf=new StringBuffer(m_writer.relativePath);
  buf.append(DirectoryManager.getPathToPackage(linkInfo.classDoc.containingPackage(),linkInfo.classDoc.name() + ""String_Node_Str""));
  return buf.toString();
}","/** 
 * Return path to the given file name in the given package. So if the name passed is ""Object.html"" and the name of the package is ""java.lang"", and if the relative path is ""../.."" then returned string will be ""../../java/lang/Object.html""
 * @param linkInfo the information about the link.
 */
private String pathString(LinkInfoImpl linkInfo){
  if (linkInfo.context == LinkInfoImpl.PACKAGE_FRAME) {
    return linkInfo.classDoc.name() + ""String_Node_Str"";
  }
  StringBuffer buf=new StringBuffer(m_writer.relativePath);
  buf.append(DirectoryManager.getPathToPackage(linkInfo.classDoc.containingPackage(),linkInfo.classDoc.name() + ""String_Node_Str""));
  return buf.toString();
}"
72115,"/** 
 * Adds the lower navigation bar and the bottom text (from the -bottom option) at the bottom of page.
 * @param the documentation tree to which the navigation bar footer will be added
 */
protected void addNavigationBarFooter(Content body){
  addNavLinks(false,body);
  addBottom(body);
}","/** 
 * Adds the lower navigation bar and the bottom text (from the -bottom option) at the bottom of page.
 * @param body the documentation tree to which the navigation bar footer will be added
 */
protected void addNavigationBarFooter(Content body){
  addNavLinks(false,body);
  addBottom(body);
}"
72116,"/** 
 * Constructor.
 * @param path The directory path to be created for this fileor null if none to be created.
 * @param filename File Name to which the PrintWriter willdo the Output.
 * @param docencoding Encoding to be used for this file.
 * @exception IOException Exception raised by the FileWriter is passed onto next level.
 * @exception UnSupportedEncodingException Exception raised by theOutputStreamWriter is passed on to next level.
 */
public HtmlWriter(Configuration configuration,String path,String filename,String docencoding) throws IOException, UnsupportedEncodingException {
  super(Util.genWriter(configuration,path,filename,docencoding));
  this.configuration=configuration;
  htmlFilename=filename;
  this.memberDetailsListPrinted=false;
  packageTableHeader=new String[]{configuration.getText(""String_Node_Str""),configuration.getText(""String_Node_Str"")};
  useTableSummary=configuration.getText(""String_Node_Str"",configuration.getText(""String_Node_Str""));
  modifierTypeHeader=configuration.getText(""String_Node_Str"",configuration.getText(""String_Node_Str""),configuration.getText(""String_Node_Str""));
  overviewLabel=getResource(""String_Node_Str"");
  defaultPackageLabel=new RawHtml(DocletConstants.DEFAULT_PACKAGE_NAME);
  packageLabel=getResource(""String_Node_Str"");
  useLabel=getResource(""String_Node_Str"");
  prevLabel=getResource(""String_Node_Str"");
  nextLabel=getResource(""String_Node_Str"");
  prevclassLabel=getResource(""String_Node_Str"");
  nextclassLabel=getResource(""String_Node_Str"");
  summaryLabel=getResource(""String_Node_Str"");
  detailLabel=getResource(""String_Node_Str"");
  framesLabel=getResource(""String_Node_Str"");
  noframesLabel=getResource(""String_Node_Str"");
  treeLabel=getResource(""String_Node_Str"");
  classLabel=getResource(""String_Node_Str"");
  deprecatedLabel=getResource(""String_Node_Str"");
  deprecatedPhrase=getResource(""String_Node_Str"");
  allclassesLabel=getResource(""String_Node_Str"");
  indexLabel=getResource(""String_Node_Str"");
  helpLabel=getResource(""String_Node_Str"");
  seeLabel=getResource(""String_Node_Str"");
  descriptionLabel=getResource(""String_Node_Str"");
  prevpackageLabel=getResource(""String_Node_Str"");
  nextpackageLabel=getResource(""String_Node_Str"");
  packagesLabel=getResource(""String_Node_Str"");
  methodDetailsLabel=getResource(""String_Node_Str"");
  annotationTypeDetailsLabel=getResource(""String_Node_Str"");
  fieldDetailsLabel=getResource(""String_Node_Str"");
  constructorDetailsLabel=getResource(""String_Node_Str"");
  enumConstantsDetailsLabel=getResource(""String_Node_Str"");
  specifiedByLabel=getResource(""String_Node_Str"");
  overridesLabel=getResource(""String_Node_Str"");
  descfrmClassLabel=getResource(""String_Node_Str"");
  descfrmInterfaceLabel=getResource(""String_Node_Str"");
}","/** 
 * Constructor.
 * @param path The directory path to be created for this fileor null if none to be created.
 * @param filename File Name to which the PrintWriter willdo the Output.
 * @param docencoding Encoding to be used for this file.
 * @exception IOException Exception raised by the FileWriter is passed onto next level.
 * @exception UnsupportedEncodingException Exception raised by theOutputStreamWriter is passed on to next level.
 */
public HtmlWriter(Configuration configuration,String path,String filename,String docencoding) throws IOException, UnsupportedEncodingException {
  super(Util.genWriter(configuration,path,filename,docencoding));
  this.configuration=configuration;
  htmlFilename=filename;
  this.memberDetailsListPrinted=false;
  packageTableHeader=new String[]{configuration.getText(""String_Node_Str""),configuration.getText(""String_Node_Str"")};
  useTableSummary=configuration.getText(""String_Node_Str"",configuration.getText(""String_Node_Str""));
  modifierTypeHeader=configuration.getText(""String_Node_Str"",configuration.getText(""String_Node_Str""),configuration.getText(""String_Node_Str""));
  overviewLabel=getResource(""String_Node_Str"");
  defaultPackageLabel=new RawHtml(DocletConstants.DEFAULT_PACKAGE_NAME);
  packageLabel=getResource(""String_Node_Str"");
  useLabel=getResource(""String_Node_Str"");
  prevLabel=getResource(""String_Node_Str"");
  nextLabel=getResource(""String_Node_Str"");
  prevclassLabel=getResource(""String_Node_Str"");
  nextclassLabel=getResource(""String_Node_Str"");
  summaryLabel=getResource(""String_Node_Str"");
  detailLabel=getResource(""String_Node_Str"");
  framesLabel=getResource(""String_Node_Str"");
  noframesLabel=getResource(""String_Node_Str"");
  treeLabel=getResource(""String_Node_Str"");
  classLabel=getResource(""String_Node_Str"");
  deprecatedLabel=getResource(""String_Node_Str"");
  deprecatedPhrase=getResource(""String_Node_Str"");
  allclassesLabel=getResource(""String_Node_Str"");
  indexLabel=getResource(""String_Node_Str"");
  helpLabel=getResource(""String_Node_Str"");
  seeLabel=getResource(""String_Node_Str"");
  descriptionLabel=getResource(""String_Node_Str"");
  prevpackageLabel=getResource(""String_Node_Str"");
  nextpackageLabel=getResource(""String_Node_Str"");
  packagesLabel=getResource(""String_Node_Str"");
  methodDetailsLabel=getResource(""String_Node_Str"");
  annotationTypeDetailsLabel=getResource(""String_Node_Str"");
  fieldDetailsLabel=getResource(""String_Node_Str"");
  constructorDetailsLabel=getResource(""String_Node_Str"");
  enumConstantsDetailsLabel=getResource(""String_Node_Str"");
  specifiedByLabel=getResource(""String_Node_Str"");
  overridesLabel=getResource(""String_Node_Str"");
  descfrmClassLabel=getResource(""String_Node_Str"");
  descfrmInterfaceLabel=getResource(""String_Node_Str"");
}"
72117,"/** 
 * Get the enum constants documentation tree header.
 * @param enumConstant the enum constant being documented
 * @param enumConstantDetailsTree the content tree representing enum constant details
 * @return content tree for the enum constant documentation header
 */
public Content getEnumConstantsTreeHeader(FieldDoc enumConstant,Content enumConstantsDetailsTree);","/** 
 * Get the enum constants documentation tree header.
 * @param enumConstant the enum constant being documented
 * @param enumConstantsDetailsTree the content tree representing enum constant details
 * @return content tree for the enum constant documentation header
 */
public Content getEnumConstantsTreeHeader(FieldDoc enumConstant,Content enumConstantsDetailsTree);"
72118,"/** 
 * Return the list of visible constant fields for the given classdoc.
 * @param cd the classdoc to examine.
 * @return the list of visible constant fields for the given classdoc.
 */
protected List<FieldDoc> members(){
  List<ProgramElementDoc> l=visibleMemberMapFields.getLeafClassMembers(configuration);
  l.addAll(visibleMemberMapEnumConst.getLeafClassMembers(configuration));
  Iterator<ProgramElementDoc> iter;
  if (l != null) {
    iter=l.iterator();
  }
 else {
    return null;
  }
  List<FieldDoc> inclList=new LinkedList<FieldDoc>();
  FieldDoc member;
  while (iter.hasNext()) {
    member=(FieldDoc)iter.next();
    if (member.constantValue() != null) {
      inclList.add(member);
    }
  }
  return inclList;
}","/** 
 * Return the list of visible constant fields for the given classdoc.
 * @return the list of visible constant fields for the given classdoc.
 */
protected List<FieldDoc> members(){
  List<ProgramElementDoc> l=visibleMemberMapFields.getLeafClassMembers(configuration);
  l.addAll(visibleMemberMapEnumConst.getLeafClassMembers(configuration));
  Iterator<ProgramElementDoc> iter;
  if (l != null) {
    iter=l.iterator();
  }
 else {
    return null;
  }
  List<FieldDoc> inclList=new LinkedList<FieldDoc>();
  FieldDoc member;
  while (iter.hasNext()) {
    member=(FieldDoc)iter.next();
    if (member.constantValue() != null) {
      inclList.add(member);
    }
  }
  return inclList;
}"
72119,"/** 
 * Returns a list of methods that will be documented for the given class. This information can be used for doclet specific documentation generation.
 * @param classDoc the {@link ClassDoc} we want to check.
 * @param type the type of members to return.
 * @return a list of methods that will be documented.
 * @see VisibleMemberMap
 */
public List<ProgramElementDoc> members(int type){
  return visibleMemberMaps[type].getLeafClassMembers(configuration);
}","/** 
 * Returns a list of methods that will be documented for the given class. This information can be used for doclet specific documentation generation.
 * @param type the type of members to return.
 * @return a list of methods that will be documented.
 * @see VisibleMemberMap
 */
public List<ProgramElementDoc> members(int type){
  return visibleMemberMaps[type].getLeafClassMembers(configuration);
}"
72120,"/** 
 * Given an array of <code>Tag</code>s representing this custom tag, return its string representation.  Print a warning for param tags that do not map to parameters.  Print a warning for param tags that are duplicated.
 * @param paramTags the array of <code>ParamTag</code>s to convert.
 * @param writer the TagletWriter that will write this tag.
 * @param alreadyDocumented the set of exceptions that have alreadybeen documented.
 * @param rankMap a {@link java.util.Map} which holds orderinginformation about the parameters.
 * @param nameMap a {@link java.util.Map} which holds a mappingof a rank of a parameter to its name.  This is used to ensure that the right name is used when parameter documentation is inherited.
 * @return the TagletOutput representation of this <code>Tag</code>.
 */
private TagletOutput processParamTags(boolean isNonTypeParams,ParamTag[] paramTags,Map<String,String> rankMap,TagletWriter writer,Set<String> alreadyDocumented){
  TagletOutput result=writer.getOutputInstance();
  if (paramTags.length > 0) {
    for (int i=0; i < paramTags.length; ++i) {
      ParamTag pt=paramTags[i];
      String paramName=isNonTypeParams ? pt.parameterName() : ""String_Node_Str"" + pt.parameterName() + ""String_Node_Str"";
      if (!rankMap.containsKey(pt.parameterName())) {
        writer.getMsgRetriever().warning(pt.position(),isNonTypeParams ? ""String_Node_Str"" : ""String_Node_Str"",paramName);
      }
      String rank=rankMap.get(pt.parameterName());
      if (rank != null && alreadyDocumented.contains(rank)) {
        writer.getMsgRetriever().warning(pt.position(),isNonTypeParams ? ""String_Node_Str"" : ""String_Node_Str"",paramName);
      }
      result.appendOutput(processParamTag(isNonTypeParams,writer,pt,pt.parameterName(),alreadyDocumented.size() == 0));
      alreadyDocumented.add(rank);
    }
  }
  return result;
}","/** 
 * Given an array of <code>Tag</code>s representing this custom tag, return its string representation.  Print a warning for param tags that do not map to parameters.  Print a warning for param tags that are duplicated.
 * @param paramTags the array of <code>ParamTag</code>s to convert.
 * @param writer the TagletWriter that will write this tag.
 * @param alreadyDocumented the set of exceptions that have alreadybeen documented.
 * @param rankMap a {@link java.util.Map} which holds orderinginformation about the parameters.
 * @param rankMap a {@link java.util.Map} which holds a mappingof a rank of a parameter to its name.  This is used to ensure that the right name is used when parameter documentation is inherited.
 * @return the TagletOutput representation of this <code>Tag</code>.
 */
private TagletOutput processParamTags(boolean isNonTypeParams,ParamTag[] paramTags,Map<String,String> rankMap,TagletWriter writer,Set<String> alreadyDocumented){
  TagletOutput result=writer.getOutputInstance();
  if (paramTags.length > 0) {
    for (int i=0; i < paramTags.length; ++i) {
      ParamTag pt=paramTags[i];
      String paramName=isNonTypeParams ? pt.parameterName() : ""String_Node_Str"" + pt.parameterName() + ""String_Node_Str"";
      if (!rankMap.containsKey(pt.parameterName())) {
        writer.getMsgRetriever().warning(pt.position(),isNonTypeParams ? ""String_Node_Str"" : ""String_Node_Str"",paramName);
      }
      String rank=rankMap.get(pt.parameterName());
      if (rank != null && alreadyDocumented.contains(rank)) {
        writer.getMsgRetriever().warning(pt.position(),isNonTypeParams ? ""String_Node_Str"" : ""String_Node_Str"",paramName);
      }
      result.appendOutput(processParamTag(isNonTypeParams,writer,pt,pt.parameterName(),alreadyDocumented.size() == 0));
      alreadyDocumented.add(rank);
    }
  }
  return result;
}"
72121,"/** 
 * Given an array of <code>ParamTag</code>s,return its string representation. Try to inherit the param tags that are missing.
 * @param doc               the doc that holds the param tags.
 * @param writer            the TagletWriter that will write this tag.
 * @param formalParameters  The array of parmeters (from type or executablemember) to check.
 * @return the TagletOutput representation of these <code>ParamTag</code>s.
 */
private TagletOutput getTagletOutput(boolean isNonTypeParams,Doc holder,TagletWriter writer,Object[] formalParameters,ParamTag[] paramTags){
  TagletOutput result=writer.getOutputInstance();
  Set<String> alreadyDocumented=new HashSet<String>();
  if (paramTags.length > 0) {
    result.appendOutput(processParamTags(isNonTypeParams,paramTags,getRankMap(formalParameters),writer,alreadyDocumented));
  }
  if (alreadyDocumented.size() != formalParameters.length) {
    result.appendOutput(getInheritedTagletOutput(isNonTypeParams,holder,writer,formalParameters,alreadyDocumented));
  }
  return result;
}","/** 
 * Given an array of <code>ParamTag</code>s,return its string representation. Try to inherit the param tags that are missing.
 * @param holder            the doc that holds the param tags.
 * @param writer            the TagletWriter that will write this tag.
 * @param formalParameters  The array of parmeters (from type or executablemember) to check.
 * @return the TagletOutput representation of these <code>ParamTag</code>s.
 */
private TagletOutput getTagletOutput(boolean isNonTypeParams,Doc holder,TagletWriter writer,Object[] formalParameters,ParamTag[] paramTags){
  TagletOutput result=writer.getOutputInstance();
  Set<String> alreadyDocumented=new HashSet<String>();
  if (paramTags.length > 0) {
    result.appendOutput(processParamTags(isNonTypeParams,paramTags,getRankMap(formalParameters),writer,alreadyDocumented));
  }
  if (alreadyDocumented.size() != formalParameters.length) {
    result.appendOutput(getInheritedTagletOutput(isNonTypeParams,holder,writer,formalParameters,alreadyDocumented));
  }
  return result;
}"
72122,"/** 
 * Given the name of the field, return the corresponding FieldDoc.
 * @param config the current configuration of the doclet.
 * @param tag the value tag.
 * @param name the name of the field to search for.  The name should be in<qualified class name>#<field name> format. If the class name is omitted, it is assumed that the field is in the current class.
 * @return the corresponding FieldDoc. If the name is null or empty string,return field that the value tag was used in.
 * @throws DocletAbortException if the value tag does not specify a name toa value field and it is not used within the comments of a valid field.
 */
private FieldDoc getFieldDoc(Configuration config,Tag tag,String name){
  if (name == null || name.length() == 0) {
    if (tag.holder() instanceof FieldDoc) {
      return (FieldDoc)tag.holder();
    }
 else {
      throw new DocletAbortException();
    }
  }
  StringTokenizer st=new StringTokenizer(name,""String_Node_Str"");
  String memberName=null;
  ClassDoc cd=null;
  if (st.countTokens() == 1) {
    Doc holder=tag.holder();
    if (holder instanceof MemberDoc) {
      cd=((MemberDoc)holder).containingClass();
    }
 else     if (holder instanceof ClassDoc) {
      cd=(ClassDoc)holder;
    }
    memberName=st.nextToken();
  }
 else {
    cd=config.root.classNamed(st.nextToken());
    memberName=st.nextToken();
  }
  if (cd == null) {
    return null;
  }
  FieldDoc[] fields=cd.fields();
  for (int i=0; i < fields.length; i++) {
    if (fields[i].name().equals(memberName)) {
      return fields[i];
    }
  }
  return null;
}","/** 
 * Given the name of the field, return the corresponding FieldDoc.
 * @param config the current configuration of the doclet.
 * @param tag the value tag.
 * @param name the name of the field to search for.  The name should be in{@code <qualified class name>#<field name>} format. If the class name is omitted,it is assumed that the field is in the current class.
 * @return the corresponding FieldDoc. If the name is null or empty string,return field that the value tag was used in.
 * @throws DocletAbortException if the value tag does not specify a name toa value field and it is not used within the comments of a valid field.
 */
private FieldDoc getFieldDoc(Configuration config,Tag tag,String name){
  if (name == null || name.length() == 0) {
    if (tag.holder() instanceof FieldDoc) {
      return (FieldDoc)tag.holder();
    }
 else {
      throw new DocletAbortException();
    }
  }
  StringTokenizer st=new StringTokenizer(name,""String_Node_Str"");
  String memberName=null;
  ClassDoc cd=null;
  if (st.countTokens() == 1) {
    Doc holder=tag.holder();
    if (holder instanceof MemberDoc) {
      cd=((MemberDoc)holder).containingClass();
    }
 else     if (holder instanceof ClassDoc) {
      cd=(ClassDoc)holder;
    }
    memberName=st.nextToken();
  }
 else {
    cd=config.root.classNamed(st.nextToken());
    memberName=st.nextToken();
  }
  if (cd == null) {
    return null;
  }
  FieldDoc[] fields=cd.fields();
  for (int i=0; i < fields.length; i++) {
    if (fields[i].name().equals(memberName)) {
      return fields[i];
    }
  }
  return null;
}"
72123,"/** 
 * Return the list of deprecated Doc objects of a given type.
 * @param the constant representing the type of list being returned.
 */
public List<Doc> getList(int type){
  return deprecatedLists.get(type);
}","/** 
 * Return the list of deprecated Doc objects of a given type.
 * @param type the constant representing the type of list being returned.
 */
public List<Doc> getList(int type){
  return deprecatedLists.get(type);
}"
72124,"/** 
 * Get the Extern Item object associated with this package name.
 * @param pkgname Package name.
 */
private Item findPackageItem(String pkgName){
  if (packageToItemMap == null) {
    return null;
  }
  return packageToItemMap.get(pkgName);
}","/** 
 * Get the Extern Item object associated with this package name.
 * @param pkgName Package name.
 */
private Item findPackageItem(String pkgName){
  if (packageToItemMap == null) {
    return null;
  }
  return packageToItemMap.get(pkgName);
}"
72125,"/** 
 * Constructor to build a Extern Item object and map it with the package name. If the same package name is found in the map, then the first mapped Item object or offline location will be retained.
 * @param packagename Package name found in the ""package-list"" file.
 * @param path        URL or Directory path from where the ""package-list""file is picked.
 * @param relative    True if path is URL, false if directory path.
 */
Item(String packageName,String path,boolean relative){
  this.packageName=packageName;
  this.path=path;
  this.relative=relative;
  if (packageToItemMap == null) {
    packageToItemMap=new HashMap<String,Item>();
  }
  if (!packageToItemMap.containsKey(packageName)) {
    packageToItemMap.put(packageName,this);
  }
}","/** 
 * Constructor to build a Extern Item object and map it with the package name. If the same package name is found in the map, then the first mapped Item object or offline location will be retained.
 * @param packageName Package name found in the ""package-list"" file.
 * @param path        URL or Directory path from where the ""package-list""file is picked.
 * @param relative    True if path is URL, false if directory path.
 */
Item(String packageName,String path,boolean relative){
  this.packageName=packageName;
  this.path=path;
  this.relative=relative;
  if (packageToItemMap == null) {
    packageToItemMap=new HashMap<String,Item>();
  }
  if (!packageToItemMap.containsKey(packageName)) {
    packageToItemMap.put(packageName,this);
  }
}"
72126,"/** 
 * Return the package private members inherited by the class.  Only return if parent is package private and not documented.
 * @param configuation the current configuration of the doclet.
 * @return the package private members inherited by the class.
 */
private List<ProgramElementDoc> getInheritedPackagePrivateMethods(Configuration configuration){
  List<ProgramElementDoc> results=new ArrayList<ProgramElementDoc>();
  for (Iterator<ClassDoc> iter=visibleClasses.iterator(); iter.hasNext(); ) {
    ClassDoc currentClass=iter.next();
    if (currentClass != classdoc && currentClass.isPackagePrivate() && !Util.isLinkable(currentClass,configuration)) {
      results.addAll(getMembersFor(currentClass));
    }
  }
  return results;
}","/** 
 * Return the package private members inherited by the class.  Only return if parent is package private and not documented.
 * @param configuration the current configuration of the doclet.
 * @return the package private members inherited by the class.
 */
private List<ProgramElementDoc> getInheritedPackagePrivateMethods(Configuration configuration){
  List<ProgramElementDoc> results=new ArrayList<ProgramElementDoc>();
  for (Iterator<ClassDoc> iter=visibleClasses.iterator(); iter.hasNext(); ) {
    ClassDoc currentClass=iter.next();
    if (currentClass != classdoc && currentClass.isPackagePrivate() && !Util.isLinkable(currentClass,configuration)) {
      results.addAll(getMembersFor(currentClass));
    }
  }
  return results;
}"
72127,"/** 
 * Return the visible members of the class being mapped.  Also append at the end of the list members that are inherited by inaccessible parents. We document these members in the child because the parent is not documented.
 * @param configuation the current configuration of the doclet.
 */
public List<ProgramElementDoc> getLeafClassMembers(Configuration configuration){
  List<ProgramElementDoc> result=getMembersFor(classdoc);
  result.addAll(getInheritedPackagePrivateMethods(configuration));
  return result;
}","/** 
 * Return the visible members of the class being mapped.  Also append at the end of the list members that are inherited by inaccessible parents. We document these members in the child because the parent is not documented.
 * @param configuration the current configuration of the doclet.
 */
public List<ProgramElementDoc> getLeafClassMembers(Configuration configuration){
  List<ProgramElementDoc> result=getMembersFor(classdoc);
  result.addAll(getInheritedPackagePrivateMethods(configuration));
  return result;
}"
72128,"/** 
 * Configure the set of diagnostic parts that should be displayed by the formatter.
 * @param options options to set
 */
public void setVisible(Set<DiagnosticPart> visibleParts);","/** 
 * Configure the set of diagnostic parts that should be displayed by the formatter.
 * @param visibleParts the parts to be set
 */
public void setVisible(Set<DiagnosticPart> visibleParts);"
72129,"/** 
 * Constructor used by service provider mechanism.  The recommended way to obtain an instance of this class is by using   {@link #create} or theservice provider mechanism.
 * @see javax.tools.JavaCompilerTool
 * @see javax.tools.ToolProvider
 * @see #create
 */
@Deprecated public JavacTool(){
}","/** 
 * Constructor used by service provider mechanism.  The recommended way to obtain an instance of this class is by using   {@link #create} or theservice provider mechanism.
 * @see javax.tools.JavaCompiler
 * @see javax.tools.ToolProvider
 * @see #create
 */
@Deprecated public JavacTool(){
}"
72130,"public Iterator<TypeSymbol> iterator(){
  return new Iterator<TypeSymbol>(){
    List<TypeSymbol> seen=List.nil();
    TypeSymbol currentSym=getSymbol(intype);
    public boolean hasNext(){
      return currentSym != null;
    }
    public TypeSymbol next(){
      TypeSymbol prevSym=currentSym;
      currentSym=getSymbol(types.supertype(currentSym.type));
      return prevSym;
    }
    public void remove(){
      throw new UnsupportedOperationException(""String_Node_Str"");
    }
    TypeSymbol getSymbol(    Type intype){
      if (intype.tag != CLASS && intype.tag != TYPEVAR) {
        return null;
      }
      while (intype.tag == TYPEVAR)       intype=intype.getUpperBound();
      if (seen.contains(intype.tsym)) {
        return null;
      }
      seen=seen.prepend(intype.tsym);
      return intype.tsym;
    }
  }
;
}","public Iterator<TypeSymbol> iterator(){
  return new Iterator<TypeSymbol>(){
    List<TypeSymbol> seen=List.nil();
    TypeSymbol currentSym=symbolFor(intype);
    TypeSymbol prevSym=null;
    public boolean hasNext(){
      if (currentSym == syms.noSymbol) {
        currentSym=symbolFor(types.supertype(prevSym.type));
      }
      return currentSym != null;
    }
    public TypeSymbol next(){
      prevSym=currentSym;
      currentSym=syms.noSymbol;
      Assert.check(prevSym != null || prevSym != syms.noSymbol);
      return prevSym;
    }
    public void remove(){
      throw new UnsupportedOperationException();
    }
    TypeSymbol symbolFor(    Type t){
      if (t.tag != CLASS && t.tag != TYPEVAR) {
        return null;
      }
      while (t.tag == TYPEVAR)       t=t.getUpperBound();
      if (seen.contains(t.tsym)) {
        return null;
      }
      seen=seen.prepend(t.tsym);
      return t.tsym;
    }
  }
;
}"
72131,"public boolean hasNext(){
  return currentSym != null;
}","public boolean hasNext(){
  if (currentSym == syms.noSymbol) {
    currentSym=symbolFor(types.supertype(prevSym.type));
  }
  return currentSym != null;
}"
72132,"public TypeSymbol next(){
  TypeSymbol prevSym=currentSym;
  currentSym=getSymbol(types.supertype(currentSym.type));
  return prevSym;
}","public TypeSymbol next(){
  prevSym=currentSym;
  currentSym=syms.noSymbol;
  Assert.check(prevSym != null || prevSym != syms.noSymbol);
  return prevSym;
}"
72133,"public void remove(){
  throw new UnsupportedOperationException(""String_Node_Str"");
}","public void remove(){
  throw new UnsupportedOperationException();
}"
72134,"/** 
 * Return an Iterable object to scan the superclasses of a given type. It's crucial that the scan is done lazily, as we don't want to accidentally access more supertypes than strictly needed (as this could trigger completion errors if some of the not-needed supertypes are missing/ill-formed).
 */
Iterable<TypeSymbol> superclasses(final Type intype){
  return new Iterable<TypeSymbol>(){
    public Iterator<TypeSymbol> iterator(){
      return new Iterator<TypeSymbol>(){
        List<TypeSymbol> seen=List.nil();
        TypeSymbol currentSym=getSymbol(intype);
        public boolean hasNext(){
          return currentSym != null;
        }
        public TypeSymbol next(){
          TypeSymbol prevSym=currentSym;
          currentSym=getSymbol(types.supertype(currentSym.type));
          return prevSym;
        }
        public void remove(){
          throw new UnsupportedOperationException(""String_Node_Str"");
        }
        TypeSymbol getSymbol(        Type intype){
          if (intype.tag != CLASS && intype.tag != TYPEVAR) {
            return null;
          }
          while (intype.tag == TYPEVAR)           intype=intype.getUpperBound();
          if (seen.contains(intype.tsym)) {
            return null;
          }
          seen=seen.prepend(intype.tsym);
          return intype.tsym;
        }
      }
;
    }
  }
;
}","/** 
 * Return an Iterable object to scan the superclasses of a given type. It's crucial that the scan is done lazily, as we don't want to accidentally access more supertypes than strictly needed (as this could trigger completion errors if some of the not-needed supertypes are missing/ill-formed).
 */
Iterable<TypeSymbol> superclasses(final Type intype){
  return new Iterable<TypeSymbol>(){
    public Iterator<TypeSymbol> iterator(){
      return new Iterator<TypeSymbol>(){
        List<TypeSymbol> seen=List.nil();
        TypeSymbol currentSym=symbolFor(intype);
        TypeSymbol prevSym=null;
        public boolean hasNext(){
          if (currentSym == syms.noSymbol) {
            currentSym=symbolFor(types.supertype(prevSym.type));
          }
          return currentSym != null;
        }
        public TypeSymbol next(){
          prevSym=currentSym;
          currentSym=syms.noSymbol;
          Assert.check(prevSym != null || prevSym != syms.noSymbol);
          return prevSym;
        }
        public void remove(){
          throw new UnsupportedOperationException();
        }
        TypeSymbol symbolFor(        Type t){
          if (t.tag != CLASS && t.tag != TYPEVAR) {
            return null;
          }
          while (t.tag == TYPEVAR)           t=t.getUpperBound();
          if (seen.contains(t.tsym)) {
            return null;
          }
          seen=seen.prepend(t.tsym);
          return t.tsym;
        }
      }
;
    }
  }
;
}"
72135,"private Symbol findMethod(Env<AttrContext> env,Type site,Name name,List<Type> argtypes,List<Type> typeargtypes,Type intype,Symbol bestSoFar,boolean allowBoxing,boolean useVarargs,boolean operator){
  boolean abstractOk=true;
  List<Type> itypes=List.nil();
  for (  TypeSymbol s : superclasses(intype)) {
    bestSoFar=lookupMethod(env,site,name,argtypes,typeargtypes,s.members(),bestSoFar,allowBoxing,useVarargs,operator,true);
    abstractOk&=excludeAbstractsFilter.accepts(s);
    if (abstractOk) {
      for (      Type itype : types.interfaces(s.type)) {
        itypes=types.union(types.closure(itype),itypes);
      }
    }
    if (name == names.init)     break;
  }
  Symbol concrete=bestSoFar.kind < ERR && (bestSoFar.flags() & ABSTRACT) == 0 ? bestSoFar : methodNotFound;
  if (name != names.init) {
    for (    Type itype : itypes) {
      if (!itype.isInterface())       continue;
      bestSoFar=lookupMethod(env,site,name,argtypes,typeargtypes,itype.tsym.members(),bestSoFar,allowBoxing,useVarargs,operator,true);
      if (concrete != bestSoFar && concrete.kind < ERR && bestSoFar.kind < ERR && types.isSubSignature(concrete.type,bestSoFar.type)) {
        bestSoFar=concrete;
      }
    }
  }
  return bestSoFar;
}","private Symbol findMethod(Env<AttrContext> env,Type site,Name name,List<Type> argtypes,List<Type> typeargtypes,Type intype,Symbol bestSoFar,boolean allowBoxing,boolean useVarargs,boolean operator){
  boolean abstractOk=true;
  List<Type> itypes=List.nil();
  for (  TypeSymbol s : superclasses(intype)) {
    bestSoFar=lookupMethod(env,site,name,argtypes,typeargtypes,s.members(),bestSoFar,allowBoxing,useVarargs,operator,true);
    abstractOk&=(s.flags() & (ABSTRACT | INTERFACE | ENUM)) != 0;
    if (abstractOk) {
      for (      Type itype : types.interfaces(s.type)) {
        itypes=types.union(types.closure(itype),itypes);
      }
    }
    if (name == names.init)     break;
  }
  Symbol concrete=bestSoFar.kind < ERR && (bestSoFar.flags() & ABSTRACT) == 0 ? bestSoFar : methodNotFound;
  if (name != names.init) {
    for (    Type itype : itypes) {
      if (!itype.isInterface())       continue;
      bestSoFar=lookupMethod(env,site,name,argtypes,typeargtypes,itype.tsym.members(),bestSoFar,allowBoxing,useVarargs,operator,true);
      if (concrete != bestSoFar && concrete.kind < ERR && bestSoFar.kind < ERR && types.isSubSignature(concrete.type,bestSoFar.type)) {
        bestSoFar=concrete;
      }
    }
  }
  return bestSoFar;
}"
72136,"public boolean accepts(Name n){
  return n == names.init;
}","public boolean accepts(Name n){
  return n == n.table.names.init;
}"
72137,"public MethodHandle(int refKind,Symbol refSym,Names names){
  this.refKind=refKind;
  this.refSym=refSym;
  this.names=names;
  checkConsistent();
}","public MethodHandle(int refKind,Symbol refSym){
  this.refKind=refKind;
  this.refSym=refSym;
  checkConsistent();
}"
72138,"public Names(Context context){
  Options options=Options.instance(context);
  table=createTable(options);
  asterisk=fromString(""String_Node_Str"");
  comma=fromString(""String_Node_Str"");
  empty=fromString(""String_Node_Str"");
  hyphen=fromString(""String_Node_Str"");
  one=fromString(""String_Node_Str"");
  period=fromString(""String_Node_Str"");
  semicolon=fromString(""String_Node_Str"");
  slash=fromString(""String_Node_Str"");
  slashequals=fromString(""String_Node_Str"");
  _class=fromString(""String_Node_Str"");
  _default=fromString(""String_Node_Str"");
  _super=fromString(""String_Node_Str"");
  _this=fromString(""String_Node_Str"");
  _name=fromString(""String_Node_Str"");
  addSuppressed=fromString(""String_Node_Str"");
  any=fromString(""String_Node_Str"");
  append=fromString(""String_Node_Str"");
  clinit=fromString(""String_Node_Str"");
  clone=fromString(""String_Node_Str"");
  close=fromString(""String_Node_Str"");
  compareTo=fromString(""String_Node_Str"");
  desiredAssertionStatus=fromString(""String_Node_Str"");
  equals=fromString(""String_Node_Str"");
  error=fromString(""String_Node_Str"");
  family=fromString(""String_Node_Str"");
  finalize=fromString(""String_Node_Str"");
  forName=fromString(""String_Node_Str"");
  getClass=fromString(""String_Node_Str"");
  getClassLoader=fromString(""String_Node_Str"");
  getComponentType=fromString(""String_Node_Str"");
  getDeclaringClass=fromString(""String_Node_Str"");
  getMessage=fromString(""String_Node_Str"");
  hasNext=fromString(""String_Node_Str"");
  hashCode=fromString(""String_Node_Str"");
  init=fromString(""String_Node_Str"");
  initCause=fromString(""String_Node_Str"");
  iterator=fromString(""String_Node_Str"");
  length=fromString(""String_Node_Str"");
  next=fromString(""String_Node_Str"");
  ordinal=fromString(""String_Node_Str"");
  serialVersionUID=fromString(""String_Node_Str"");
  toString=fromString(""String_Node_Str"");
  value=fromString(""String_Node_Str"");
  valueOf=fromString(""String_Node_Str"");
  values=fromString(""String_Node_Str"");
  java_io_Serializable=fromString(""String_Node_Str"");
  java_lang_AutoCloseable=fromString(""String_Node_Str"");
  java_lang_Class=fromString(""String_Node_Str"");
  java_lang_Cloneable=fromString(""String_Node_Str"");
  java_lang_Enum=fromString(""String_Node_Str"");
  java_lang_Object=fromString(""String_Node_Str"");
  java_lang_invoke_MethodHandle=fromString(""String_Node_Str"");
  Array=fromString(""String_Node_Str"");
  Bound=fromString(""String_Node_Str"");
  Method=fromString(""String_Node_Str"");
  java_lang=fromString(""String_Node_Str"");
  Annotation=fromString(""String_Node_Str"");
  AnnotationDefault=fromString(""String_Node_Str"");
  Bridge=fromString(""String_Node_Str"");
  CharacterRangeTable=fromString(""String_Node_Str"");
  Code=fromString(""String_Node_Str"");
  CompilationID=fromString(""String_Node_Str"");
  ConstantValue=fromString(""String_Node_Str"");
  Deprecated=fromString(""String_Node_Str"");
  EnclosingMethod=fromString(""String_Node_Str"");
  Enum=fromString(""String_Node_Str"");
  Exceptions=fromString(""String_Node_Str"");
  InnerClasses=fromString(""String_Node_Str"");
  LineNumberTable=fromString(""String_Node_Str"");
  LocalVariableTable=fromString(""String_Node_Str"");
  LocalVariableTypeTable=fromString(""String_Node_Str"");
  RuntimeInvisibleAnnotations=fromString(""String_Node_Str"");
  RuntimeInvisibleParameterAnnotations=fromString(""String_Node_Str"");
  RuntimeInvisibleTypeAnnotations=fromString(""String_Node_Str"");
  RuntimeVisibleAnnotations=fromString(""String_Node_Str"");
  RuntimeVisibleParameterAnnotations=fromString(""String_Node_Str"");
  RuntimeVisibleTypeAnnotations=fromString(""String_Node_Str"");
  Signature=fromString(""String_Node_Str"");
  SourceFile=fromString(""String_Node_Str"");
  SourceID=fromString(""String_Node_Str"");
  StackMap=fromString(""String_Node_Str"");
  StackMapTable=fromString(""String_Node_Str"");
  Synthetic=fromString(""String_Node_Str"");
  Value=fromString(""String_Node_Str"");
  Varargs=fromString(""String_Node_Str"");
  ANNOTATION_TYPE=fromString(""String_Node_Str"");
  CONSTRUCTOR=fromString(""String_Node_Str"");
  FIELD=fromString(""String_Node_Str"");
  LOCAL_VARIABLE=fromString(""String_Node_Str"");
  METHOD=fromString(""String_Node_Str"");
  PACKAGE=fromString(""String_Node_Str"");
  PARAMETER=fromString(""String_Node_Str"");
  TYPE=fromString(""String_Node_Str"");
  TYPE_PARAMETER=fromString(""String_Node_Str"");
  TYPE_USE=fromString(""String_Node_Str"");
  CLASS=fromString(""String_Node_Str"");
  RUNTIME=fromString(""String_Node_Str"");
  SOURCE=fromString(""String_Node_Str"");
  T=fromString(""String_Node_Str"");
  deprecated=fromString(""String_Node_Str"");
  ex=fromString(""String_Node_Str"");
  package_info=fromString(""String_Node_Str"");
  BootstrapMethods=fromString(""String_Node_Str"");
}","public Names(Context context){
  Options options=Options.instance(context);
  table=createTable(options);
  asterisk=fromString(""String_Node_Str"");
  comma=fromString(""String_Node_Str"");
  empty=fromString(""String_Node_Str"");
  hyphen=fromString(""String_Node_Str"");
  one=fromString(""String_Node_Str"");
  period=fromString(""String_Node_Str"");
  semicolon=fromString(""String_Node_Str"");
  slash=fromString(""String_Node_Str"");
  slashequals=fromString(""String_Node_Str"");
  _class=fromString(""String_Node_Str"");
  _default=fromString(""String_Node_Str"");
  _super=fromString(""String_Node_Str"");
  _this=fromString(""String_Node_Str"");
  _name=fromString(""String_Node_Str"");
  addSuppressed=fromString(""String_Node_Str"");
  any=fromString(""String_Node_Str"");
  append=fromString(""String_Node_Str"");
  clinit=fromString(""String_Node_Str"");
  clone=fromString(""String_Node_Str"");
  close=fromString(""String_Node_Str"");
  compareTo=fromString(""String_Node_Str"");
  desiredAssertionStatus=fromString(""String_Node_Str"");
  equals=fromString(""String_Node_Str"");
  error=fromString(""String_Node_Str"");
  family=fromString(""String_Node_Str"");
  finalize=fromString(""String_Node_Str"");
  forName=fromString(""String_Node_Str"");
  getClass=fromString(""String_Node_Str"");
  getClassLoader=fromString(""String_Node_Str"");
  getComponentType=fromString(""String_Node_Str"");
  getDeclaringClass=fromString(""String_Node_Str"");
  getMessage=fromString(""String_Node_Str"");
  hasNext=fromString(""String_Node_Str"");
  hashCode=fromString(""String_Node_Str"");
  init=fromString(""String_Node_Str"");
  initCause=fromString(""String_Node_Str"");
  iterator=fromString(""String_Node_Str"");
  length=fromString(""String_Node_Str"");
  next=fromString(""String_Node_Str"");
  ordinal=fromString(""String_Node_Str"");
  serialVersionUID=fromString(""String_Node_Str"");
  toString=fromString(""String_Node_Str"");
  value=fromString(""String_Node_Str"");
  valueOf=fromString(""String_Node_Str"");
  values=fromString(""String_Node_Str"");
  java_io_Serializable=fromString(""String_Node_Str"");
  java_lang_AutoCloseable=fromString(""String_Node_Str"");
  java_lang_Class=fromString(""String_Node_Str"");
  java_lang_Cloneable=fromString(""String_Node_Str"");
  java_lang_Enum=fromString(""String_Node_Str"");
  java_lang_Object=fromString(""String_Node_Str"");
  java_lang_invoke_MethodHandle=fromString(""String_Node_Str"");
  Array=fromString(""String_Node_Str"");
  Bound=fromString(""String_Node_Str"");
  Method=fromString(""String_Node_Str"");
  java_lang=fromString(""String_Node_Str"");
  Annotation=fromString(""String_Node_Str"");
  AnnotationDefault=fromString(""String_Node_Str"");
  BootstrapMethods=fromString(""String_Node_Str"");
  Bridge=fromString(""String_Node_Str"");
  CharacterRangeTable=fromString(""String_Node_Str"");
  Code=fromString(""String_Node_Str"");
  CompilationID=fromString(""String_Node_Str"");
  ConstantValue=fromString(""String_Node_Str"");
  Deprecated=fromString(""String_Node_Str"");
  EnclosingMethod=fromString(""String_Node_Str"");
  Enum=fromString(""String_Node_Str"");
  Exceptions=fromString(""String_Node_Str"");
  InnerClasses=fromString(""String_Node_Str"");
  LineNumberTable=fromString(""String_Node_Str"");
  LocalVariableTable=fromString(""String_Node_Str"");
  LocalVariableTypeTable=fromString(""String_Node_Str"");
  RuntimeInvisibleAnnotations=fromString(""String_Node_Str"");
  RuntimeInvisibleParameterAnnotations=fromString(""String_Node_Str"");
  RuntimeInvisibleTypeAnnotations=fromString(""String_Node_Str"");
  RuntimeVisibleAnnotations=fromString(""String_Node_Str"");
  RuntimeVisibleParameterAnnotations=fromString(""String_Node_Str"");
  RuntimeVisibleTypeAnnotations=fromString(""String_Node_Str"");
  Signature=fromString(""String_Node_Str"");
  SourceFile=fromString(""String_Node_Str"");
  SourceID=fromString(""String_Node_Str"");
  StackMap=fromString(""String_Node_Str"");
  StackMapTable=fromString(""String_Node_Str"");
  Synthetic=fromString(""String_Node_Str"");
  Value=fromString(""String_Node_Str"");
  Varargs=fromString(""String_Node_Str"");
  ANNOTATION_TYPE=fromString(""String_Node_Str"");
  CONSTRUCTOR=fromString(""String_Node_Str"");
  FIELD=fromString(""String_Node_Str"");
  LOCAL_VARIABLE=fromString(""String_Node_Str"");
  METHOD=fromString(""String_Node_Str"");
  PACKAGE=fromString(""String_Node_Str"");
  PARAMETER=fromString(""String_Node_Str"");
  TYPE=fromString(""String_Node_Str"");
  TYPE_PARAMETER=fromString(""String_Node_Str"");
  TYPE_USE=fromString(""String_Node_Str"");
  CLASS=fromString(""String_Node_Str"");
  RUNTIME=fromString(""String_Node_Str"");
  SOURCE=fromString(""String_Node_Str"");
  T=fromString(""String_Node_Str"");
  deprecated=fromString(""String_Node_Str"");
  ex=fromString(""String_Node_Str"");
  package_info=fromString(""String_Node_Str"");
}"
72139,"/** 
 * Return the first sentence of the comment as an array of tags. Includes inline tags (i.e. {&#64link <i>reference</i>} tags)  but not block tags. Each section of plain text is represented as a   {@link Tag}of   {@linkplain Tag#kind() kind} ""Text"".Inline tags are represented as a  {@link SeeTag} of kind ""@see""and name ""@link"". <p> If the locale is English language, the first sentence is determined by the rules described in the Java Language Specification (first version): &quot;This sentence ends at the first period that is followed by a blank, tab, or line terminator or at the first tagline.&quot;, in addition a line will be terminated by block HTML tags: &lt;p&gt;  &lt;/p&gt;  &lt;h1&gt; &lt;h2&gt;  &lt;h3&gt; &lt;h4&gt;  &lt;h5&gt;  &lt;h6&gt; &lt;hr&gt;  &lt;pre&gt;  or &lt;/pre&gt;. If the locale is not English, the sentence end will be determined by {@link BreakIterator#getSentenceInstance(Locale)}.
 * @return an array of {@link Tag}s representing the first sentence of the comment
 */
Tag[] firstSentenceTags();","/** 
 * Return the first sentence of the comment as an array of tags. Includes inline tags (i.e. {&#64;link <i>reference</i>} tags)  but not block tags. Each section of plain text is represented as a   {@link Tag}of   {@linkplain Tag#kind() kind} ""Text"".Inline tags are represented as a  {@link SeeTag} of kind ""@see""and name ""@link"". <p> If the locale is English language, the first sentence is determined by the rules described in the Java Language Specification (first version): &quot;This sentence ends at the first period that is followed by a blank, tab, or line terminator or at the first tagline.&quot;, in addition a line will be terminated by block HTML tags: &lt;p&gt;  &lt;/p&gt;  &lt;h1&gt; &lt;h2&gt;  &lt;h3&gt; &lt;h4&gt;  &lt;h5&gt;  &lt;h6&gt; &lt;hr&gt;  &lt;pre&gt;  or &lt;/pre&gt;. If the locale is not English, the sentence end will be determined by {@link BreakIterator#getSentenceInstance(Locale)}.
 * @return an array of {@link Tag}s representing the first sentence of the comment
 */
Tag[] firstSentenceTags();"
72140,"/** 
 * Return comment as an array of tags. Includes inline tags (i.e. {&#64link <i>reference</i>} tags)  but not block tags. Each section of plain text is represented as a   {@link Tag}of   {@linkplain Tag#kind() kind} ""Text"".Inline tags are represented as a  {@link SeeTag} of kind ""@see""and name ""@link"".
 * @return an array of {@link Tag}s representing the comment
 */
Tag[] inlineTags();","/** 
 * Return comment as an array of tags. Includes inline tags (i.e. {&#64;link <i>reference</i>} tags)  but not block tags. Each section of plain text is represented as a   {@link Tag}of   {@linkplain Tag#kind() kind} ""Text"".Inline tags are represented as a  {@link SeeTag} of kind ""@see""and name ""@link"".
 * @return an array of {@link Tag}s representing the comment
 */
Tag[] inlineTags();"
72141,"/** 
 * Return the param tags in this method, excluding the type parameter tags.
 * @return an array of ParamTag containing all <code>&#64param</code> tagscorresponding to the parameters of this method.
 */
ParamTag[] paramTags();","/** 
 * Return the param tags in this method, excluding the type parameter tags.
 * @return an array of ParamTag containing all <code>&#64;param</code> tagscorresponding to the parameters of this method.
 */
ParamTag[] paramTags();"
72142,"/** 
 * Return the type parameter tags in this method.
 * @return an array of ParamTag containing all <code>&#64param</code> tagscorresponding to the type parameters of this method.
 * @since 1.5
 */
ParamTag[] typeParamTags();","/** 
 * Return the type parameter tags in this method.
 * @return an array of ParamTag containing all <code>&#64;param</code> tagscorresponding to the type parameters of this method.
 * @since 1.5
 */
ParamTag[] typeParamTags();"
72143,"/** 
 * Return the throws tags in this method.
 * @return an array of ThrowTag containing all <code>&#64exception</code>and <code>&#64throws</code> tags.
 */
ThrowsTag[] throwsTags();","/** 
 * Return the throws tags in this method.
 * @return an array of ThrowTag containing all <code>&#64;exception</code>and <code>&#64;throws</code> tags.
 */
ThrowsTag[] throwsTags();"
72144,"/** 
 * Return the first sentence of the comment as an array of tags. Includes inline tags (i.e. {&#64link <i>reference</i>} tags)  but not block tags. Each section of plain text is represented as a   {@link Tag}of kind ""Text"". Inline tags are represented as a   {@link SeeTag} of kind ""@link"".If the locale is English language, the first sentence is determined by the rules described in the Java Language Specification (first version): &quot;This sentence ends at the first period that is followed by a blank, tab, or line terminator or at the first tagline.&quot;, in addition a line will be terminated by paragraph and section terminating HTML tags: &lt;p&gt;  &lt;/p&gt;  &lt;h1&gt; &lt;h2&gt;  &lt;h3&gt; &lt;h4&gt;  &lt;h5&gt;  &lt;h6&gt; &lt;hr&gt;  &lt;pre&gt;  or &lt;/pre&gt;. If the locale is not English, the sentence end will be determined by {@link BreakIterator#getSentenceInstance(Locale)}.
 * @return an array of {@link Tag} objects representing thefirst sentence of the comment
 */
Tag[] firstSentenceTags();","/** 
 * Return the first sentence of the comment as an array of tags. Includes inline tags (i.e. {&#64;link <i>reference</i>} tags)  but not block tags. Each section of plain text is represented as a   {@link Tag}of kind ""Text"". Inline tags are represented as a   {@link SeeTag} of kind ""@link"".If the locale is English language, the first sentence is determined by the rules described in the Java Language Specification (first version): &quot;This sentence ends at the first period that is followed by a blank, tab, or line terminator or at the first tagline.&quot;, in addition a line will be terminated by paragraph and section terminating HTML tags: &lt;p&gt;  &lt;/p&gt;  &lt;h1&gt; &lt;h2&gt;  &lt;h3&gt; &lt;h4&gt;  &lt;h5&gt;  &lt;h6&gt; &lt;hr&gt;  &lt;pre&gt;  or &lt;/pre&gt;. If the locale is not English, the sentence end will be determined by {@link BreakIterator#getSentenceInstance(Locale)}.
 * @return an array of {@link Tag} objects representing thefirst sentence of the comment
 */
Tag[] firstSentenceTags();"
72145,"/** 
 * Find the start position of a line.
 * @param line line number (beginning at 1)
 * @return     position of first character in line
 * @throws IndexOutOfBoundsException if <tt>lineNumber < 1</tt> if <tt>lineNumber > no. of lines</tt>
 */
long getStartPosition(long line);","/** 
 * Find the start position of a line.
 * @param line line number (beginning at 1)
 * @return     position of first character in line
 * @throws IndexOutOfBoundsException if  {@code lineNumber < 1}if   {@code lineNumber > no. of lines}
 */
long getStartPosition(long line);"
72146,"/** 
 * Print the heading in Html &lt;H2> format.
 * @param str The Header string.
 */
public void printIndexHeading(String str){
  h2();
  print(str);
  h2End();
}","/** 
 * Print the heading in Html   {@literal <H2>} format.
 * @param str The Header string.
 */
public void printIndexHeading(String str){
  h2();
  print(str);
  h2End();
}"
72147,"/** 
 * Suppose a piece of documentation has a relative link.  When you copy that documetation to another place such as the index or class-use page, that relative link will no longer work.  We should redirect those links so that they will work again. <p> Here is the algorithm used to fix the link: <p> &lt;relative link&gt; => docRoot + &lt;relative path to file&gt; + &lt;relative link&gt; <p> For example, suppose com.sun.javadoc.RootDoc has this link: &lt;a href=""package-summary.html""&gt;The package Page&lt;/a&gt; <p> If this link appeared in the index, we would redirect the link like this: &lt;a href=""./com/sun/javadoc/package-summary.html""&gt;The package Page&lt;/a&gt;
 * @param doc the Doc object whose documentation is being written.
 * @param text the text being written.
 * @return the text, with all the relative links redirected to work.
 */
private String redirectRelativeLinks(Doc doc,String text){
  if (doc == null || shouldNotRedirectRelativeLinks()) {
    return text;
  }
  String redirectPathFromRoot;
  if (doc instanceof ClassDoc) {
    redirectPathFromRoot=DirectoryManager.getDirectoryPath(((ClassDoc)doc).containingPackage());
  }
 else   if (doc instanceof MemberDoc) {
    redirectPathFromRoot=DirectoryManager.getDirectoryPath(((MemberDoc)doc).containingPackage());
  }
 else   if (doc instanceof PackageDoc) {
    redirectPathFromRoot=DirectoryManager.getDirectoryPath((PackageDoc)doc);
  }
 else {
    return text;
  }
  if (!redirectPathFromRoot.endsWith(DirectoryManager.URL_FILE_SEPARATOR)) {
    redirectPathFromRoot+=DirectoryManager.URL_FILE_SEPARATOR;
  }
  int end, begin=text.toLowerCase().indexOf(""String_Node_Str"");
  if (begin >= 0) {
    StringBuffer textBuff=new StringBuffer(text);
    while (begin >= 0) {
      if (textBuff.length() > begin + 2 && !Character.isWhitespace(textBuff.charAt(begin + 2))) {
        begin=textBuff.toString().toLowerCase().indexOf(""String_Node_Str"",begin + 1);
        continue;
      }
      begin=textBuff.indexOf(""String_Node_Str"",begin) + 1;
      end=textBuff.indexOf(""String_Node_Str"",begin + 1);
      if (begin == 0) {
        configuration.root.printWarning(doc.position(),configuration.getText(""String_Node_Str"",text));
        break;
      }
      if (end == -1) {
        break;
      }
      if (textBuff.substring(begin,end).indexOf(""String_Node_Str"") != -1) {
        begin=textBuff.indexOf(""String_Node_Str"",begin) + 1;
        end=textBuff.indexOf(""String_Node_Str"",begin + 1);
        if (begin == 0 || end == -1) {
          break;
        }
      }
      String relativeLink=textBuff.substring(begin,end);
      if (!(relativeLink.toLowerCase().startsWith(""String_Node_Str"") || relativeLink.toLowerCase().startsWith(""String_Node_Str"") || relativeLink.toLowerCase().startsWith(""String_Node_Str"")|| relativeLink.toLowerCase().startsWith(""String_Node_Str""))) {
        relativeLink=""String_Node_Str"" + (new DocRootTaglet()).getName() + ""String_Node_Str""+ redirectPathFromRoot+ relativeLink;
        textBuff.replace(begin,end,relativeLink);
      }
      begin=textBuff.toString().toLowerCase().indexOf(""String_Node_Str"",begin + 1);
    }
    return textBuff.toString();
  }
  return text;
}","/** 
 * Suppose a piece of documentation has a relative link.  When you copy that documetation to another place such as the index or class-use page, that relative link will no longer work.  We should redirect those links so that they will work again. <p> Here is the algorithm used to fix the link: <p>  {@literal <relative link> => docRoot + <relative path to file> + <relative link> }<p> For example, suppose com.sun.javadoc.RootDoc has this link:  {@literal <a href=""package-summary.html"">The package Page</a> }<p> If this link appeared in the index, we would redirect the link like this:  {@literal <a href=""./com/sun/javadoc/package-summary.html"">The package Page</a>}
 * @param doc the Doc object whose documentation is being written.
 * @param text the text being written.
 * @return the text, with all the relative links redirected to work.
 */
private String redirectRelativeLinks(Doc doc,String text){
  if (doc == null || shouldNotRedirectRelativeLinks()) {
    return text;
  }
  String redirectPathFromRoot;
  if (doc instanceof ClassDoc) {
    redirectPathFromRoot=DirectoryManager.getDirectoryPath(((ClassDoc)doc).containingPackage());
  }
 else   if (doc instanceof MemberDoc) {
    redirectPathFromRoot=DirectoryManager.getDirectoryPath(((MemberDoc)doc).containingPackage());
  }
 else   if (doc instanceof PackageDoc) {
    redirectPathFromRoot=DirectoryManager.getDirectoryPath((PackageDoc)doc);
  }
 else {
    return text;
  }
  if (!redirectPathFromRoot.endsWith(DirectoryManager.URL_FILE_SEPARATOR)) {
    redirectPathFromRoot+=DirectoryManager.URL_FILE_SEPARATOR;
  }
  int end, begin=text.toLowerCase().indexOf(""String_Node_Str"");
  if (begin >= 0) {
    StringBuffer textBuff=new StringBuffer(text);
    while (begin >= 0) {
      if (textBuff.length() > begin + 2 && !Character.isWhitespace(textBuff.charAt(begin + 2))) {
        begin=textBuff.toString().toLowerCase().indexOf(""String_Node_Str"",begin + 1);
        continue;
      }
      begin=textBuff.indexOf(""String_Node_Str"",begin) + 1;
      end=textBuff.indexOf(""String_Node_Str"",begin + 1);
      if (begin == 0) {
        configuration.root.printWarning(doc.position(),configuration.getText(""String_Node_Str"",text));
        break;
      }
      if (end == -1) {
        break;
      }
      if (textBuff.substring(begin,end).indexOf(""String_Node_Str"") != -1) {
        begin=textBuff.indexOf(""String_Node_Str"",begin) + 1;
        end=textBuff.indexOf(""String_Node_Str"",begin + 1);
        if (begin == 0 || end == -1) {
          break;
        }
      }
      String relativeLink=textBuff.substring(begin,end);
      if (!(relativeLink.toLowerCase().startsWith(""String_Node_Str"") || relativeLink.toLowerCase().startsWith(""String_Node_Str"") || relativeLink.toLowerCase().startsWith(""String_Node_Str"")|| relativeLink.toLowerCase().startsWith(""String_Node_Str""))) {
        relativeLink=""String_Node_Str"" + (new DocRootTaglet()).getName() + ""String_Node_Str""+ redirectPathFromRoot+ relativeLink;
        textBuff.replace(begin,end,relativeLink);
      }
      begin=textBuff.toString().toLowerCase().indexOf(""String_Node_Str"",begin + 1);
    }
    return textBuff.toString();
  }
  return text;
}"
72148,"/** 
 * Handles the &lt;ClassDoc> tag.
 * @param node the XML element that specifies which components to document
 * @param contentTree the content tree to which the documentation will be added
 */
public void buildClassDoc(XMLNode node,Content contentTree) throws Exception {
  String key;
  if (isInterface) {
    key=""String_Node_Str"";
  }
 else   if (isEnum) {
    key=""String_Node_Str"";
  }
 else {
    key=""String_Node_Str"";
  }
  contentTree=writer.getHeader(configuration.getText(key) + ""String_Node_Str"" + classDoc.name());
  Content classContentTree=writer.getClassContentHeader();
  buildChildren(node,classContentTree);
  contentTree.addContent(classContentTree);
  writer.addFooter(contentTree);
  writer.printDocument(contentTree);
  writer.close();
  copyDocFiles();
}","/** 
 * Handles the   {@literal <ClassDoc>} tag.
 * @param node the XML element that specifies which components to document
 * @param contentTree the content tree to which the documentation will be added
 */
public void buildClassDoc(XMLNode node,Content contentTree) throws Exception {
  String key;
  if (isInterface) {
    key=""String_Node_Str"";
  }
 else   if (isEnum) {
    key=""String_Node_Str"";
  }
 else {
    key=""String_Node_Str"";
  }
  contentTree=writer.getHeader(configuration.getText(key) + ""String_Node_Str"" + classDoc.name());
  Content classContentTree=writer.getClassContentHeader();
  buildChildren(node,classContentTree);
  contentTree.addContent(classContentTree);
  writer.addFooter(contentTree);
  writer.printDocument(contentTree);
  writer.close();
  copyDocFiles();
}"
72149,"/** 
 * Enter a binary operation, as above but with two opcodes, which get encoded as (opcode1 << ByteCodeTags.preShift) + opcode2.
 * @param opcode1     First opcode.
 * @param opcode2     Second opcode.
 */
private void enterBinop(String name,Type left,Type right,Type res,int opcode1,int opcode2){
  enterBinop(name,left,right,res,(opcode1 << ByteCodes.preShift) | opcode2);
}","/** 
 * Enter a binary operation, as above but with two opcodes, which get encoded as  {@code (opcode1 << ByteCodeTags.preShift) + opcode2 }.
 * @param opcode1     First opcode.
 * @param opcode2     Second opcode.
 */
private void enterBinop(String name,Type left,Type right,Type res,int opcode1,int opcode2){
  enterBinop(name,left,right,res,(opcode1 << ByteCodes.preShift) | opcode2);
}"
72150,"/** 
 * A statement of the form <pre> for ( T v : arrayexpr ) stmt; </pre> (where arrayexpr is of an array type) gets translated to <pre> for ( { arraytype #arr = arrayexpr; int #len = array.length; int #i = 0; }; #i < #len; i$++ ) { T v = arr$[#i]; stmt; } </pre> where #arr, #len, and #i are freshly named synthetic local variables.
 */
private void visitArrayForeachLoop(JCEnhancedForLoop tree){
  make_at(tree.expr.pos());
  VarSymbol arraycache=new VarSymbol(0,names.fromString(""String_Node_Str"" + target.syntheticNameChar()),tree.expr.type,currentMethodSym);
  JCStatement arraycachedef=make.VarDef(arraycache,tree.expr);
  VarSymbol lencache=new VarSymbol(0,names.fromString(""String_Node_Str"" + target.syntheticNameChar()),syms.intType,currentMethodSym);
  JCStatement lencachedef=make.VarDef(lencache,make.Select(make.Ident(arraycache),syms.lengthVar));
  VarSymbol index=new VarSymbol(0,names.fromString(""String_Node_Str"" + target.syntheticNameChar()),syms.intType,currentMethodSym);
  JCVariableDecl indexdef=make.VarDef(index,make.Literal(INT,0));
  indexdef.init.type=indexdef.type=syms.intType.constType(0);
  List<JCStatement> loopinit=List.of(arraycachedef,lencachedef,indexdef);
  JCBinary cond=makeBinary(LT,make.Ident(index),make.Ident(lencache));
  JCExpressionStatement step=make.Exec(makeUnary(PREINC,make.Ident(index)));
  Type elemtype=types.elemtype(tree.expr.type);
  JCExpression loopvarinit=make.Indexed(make.Ident(arraycache),make.Ident(index)).setType(elemtype);
  JCVariableDecl loopvardef=(JCVariableDecl)make.VarDef(tree.var.mods,tree.var.name,tree.var.vartype,loopvarinit).setType(tree.var.type);
  loopvardef.sym=tree.var.sym;
  JCBlock body=make.Block(0,List.of(loopvardef,tree.body));
  result=translate(make.ForLoop(loopinit,cond,List.of(step),body));
  patchTargets(body,tree,result);
}","/** 
 * A statement of the form <pre> for ( T v : arrayexpr ) stmt; </pre> (where arrayexpr is of an array type) gets translated to <pre>  {@code}for (  arraytype #arr = arrayexpr; int #len = array.length; int #i = 0; }; #i < #len; i$++ ) { T v = arr$[#i]; stmt; } }</pre> where #arr, #len, and #i are freshly named synthetic local variables.
 */
private void visitArrayForeachLoop(JCEnhancedForLoop tree){
  make_at(tree.expr.pos());
  VarSymbol arraycache=new VarSymbol(0,names.fromString(""String_Node_Str"" + target.syntheticNameChar()),tree.expr.type,currentMethodSym);
  JCStatement arraycachedef=make.VarDef(arraycache,tree.expr);
  VarSymbol lencache=new VarSymbol(0,names.fromString(""String_Node_Str"" + target.syntheticNameChar()),syms.intType,currentMethodSym);
  JCStatement lencachedef=make.VarDef(lencache,make.Select(make.Ident(arraycache),syms.lengthVar));
  VarSymbol index=new VarSymbol(0,names.fromString(""String_Node_Str"" + target.syntheticNameChar()),syms.intType,currentMethodSym);
  JCVariableDecl indexdef=make.VarDef(index,make.Literal(INT,0));
  indexdef.init.type=indexdef.type=syms.intType.constType(0);
  List<JCStatement> loopinit=List.of(arraycachedef,lencachedef,indexdef);
  JCBinary cond=makeBinary(LT,make.Ident(index),make.Ident(lencache));
  JCExpressionStatement step=make.Exec(makeUnary(PREINC,make.Ident(index)));
  Type elemtype=types.elemtype(tree.expr.type);
  JCExpression loopvarinit=make.Indexed(make.Ident(arraycache),make.Ident(index)).setType(elemtype);
  JCVariableDecl loopvardef=(JCVariableDecl)make.VarDef(tree.var.mods,tree.var.name,tree.var.vartype,loopvarinit).setType(tree.var.type);
  loopvardef.sym=tree.var.sym;
  JCBlock body=make.Block(0,List.of(loopvardef,tree.body));
  result=translate(make.ForLoop(loopinit,cond,List.of(step),body));
  patchTargets(body,tree,result);
}"
72151,"/** 
 * Construct a tree that represents the closest outer instance <C.this> such that the given symbol is a member of C.
 * @param pos           The source code position to be used for the tree.
 * @param sym           The accessed symbol.
 * @param preciseMatch  should we accept a type that is a subtype ofsym's owner, even if it doesn't contain sym due to hiding, overriding, or non-inheritance due to protection?
 */
JCExpression makeOwnerThis(DiagnosticPosition pos,Symbol sym,boolean preciseMatch){
  Symbol c=sym.owner;
  if (preciseMatch ? sym.isMemberOf(currentClass,types) : currentClass.isSubClass(sym.owner,types)) {
    return make.at(pos).This(c.erasure(types));
  }
 else {
    return makeOwnerThisN(pos,sym,preciseMatch);
  }
}","/** 
 * Construct a tree that represents the closest outer instance  {@code C.this} such that the given symbol is a member of C.
 * @param pos           The source code position to be used for the tree.
 * @param sym           The accessed symbol.
 * @param preciseMatch  should we accept a type that is a subtype ofsym's owner, even if it doesn't contain sym due to hiding, overriding, or non-inheritance due to protection?
 */
JCExpression makeOwnerThis(DiagnosticPosition pos,Symbol sym,boolean preciseMatch){
  Symbol c=sym.owner;
  if (preciseMatch ? sym.isMemberOf(currentClass,types) : currentClass.isSubClass(sym.owner,types)) {
    return make.at(pos).This(c.erasure(types));
  }
 else {
    return makeOwnerThisN(pos,sym,preciseMatch);
  }
}"
72152,"/** 
 * Construct a tree that represents the outer instance <C.this>. Never pick the current `this'.
 * @param pos           The source code position to be used for the tree.
 * @param c             The qualifier class.
 */
JCExpression makeOuterThis(DiagnosticPosition pos,TypeSymbol c){
  List<VarSymbol> ots=outerThisStack;
  if (ots.isEmpty()) {
    log.error(pos,""String_Node_Str"",c);
    Assert.error();
    return makeNull();
  }
  VarSymbol ot=ots.head;
  JCExpression tree=access(make.at(pos).Ident(ot));
  TypeSymbol otc=ot.type.tsym;
  while (otc != c) {
    do {
      ots=ots.tail;
      if (ots.isEmpty()) {
        log.error(pos,""String_Node_Str"",c);
        Assert.error();
        return tree;
      }
      ot=ots.head;
    }
 while (ot.owner != otc);
    if (otc.owner.kind != PCK && !otc.hasOuterInstance()) {
      chk.earlyRefError(pos,c);
      Assert.error();
      return makeNull();
    }
    tree=access(make.at(pos).Select(tree,ot));
    otc=ot.type.tsym;
  }
  return tree;
}","/** 
 * Construct a tree that represents the outer instance  {@code C.this}. Never pick the current `this'.
 * @param pos           The source code position to be used for the tree.
 * @param c             The qualifier class.
 */
JCExpression makeOuterThis(DiagnosticPosition pos,TypeSymbol c){
  List<VarSymbol> ots=outerThisStack;
  if (ots.isEmpty()) {
    log.error(pos,""String_Node_Str"",c);
    Assert.error();
    return makeNull();
  }
  VarSymbol ot=ots.head;
  JCExpression tree=access(make.at(pos).Ident(ot));
  TypeSymbol otc=ot.type.tsym;
  while (otc != c) {
    do {
      ots=ots.tail;
      if (ots.isEmpty()) {
        log.error(pos,""String_Node_Str"",c);
        Assert.error();
        return tree;
      }
      ot=ots.head;
    }
 while (ot.owner != otc);
    if (otc.owner.kind != PCK && !otc.hasOuterInstance()) {
      chk.earlyRefError(pos,c);
      Assert.error();
      return makeNull();
    }
    tree=access(make.at(pos).Select(tree,ot));
    otc=ot.type.tsym;
  }
  return tree;
}"
72153,"/** 
 * Return tree simulating the assignment <this.this$n = this$n>.
 */
JCStatement initOuterThis(int pos){
  VarSymbol rhs=outerThisStack.head;
  Assert.check(rhs.owner.kind == MTH);
  VarSymbol lhs=outerThisStack.tail.head;
  Assert.check(rhs.owner.owner == lhs.owner);
  make.at(pos);
  return make.Exec(make.Assign(make.Select(make.This(lhs.owner.erasure(types)),lhs),make.Ident(rhs)).setType(lhs.erasure(types)));
}","/** 
 * Return tree simulating the assignment   {@code this.this$n = this$n}.
 */
JCStatement initOuterThis(int pos){
  VarSymbol rhs=outerThisStack.head;
  Assert.check(rhs.owner.kind == MTH);
  VarSymbol lhs=outerThisStack.tail.head;
  Assert.check(rhs.owner.owner == lhs.owner);
  make.at(pos);
  return make.Exec(make.Assign(make.Select(make.This(lhs.owner.erasure(types)),lhs),make.Ident(rhs)).setType(lhs.erasure(types)));
}"
72154,"/** 
 * Construct a tree simulating the expression <C.this>.
 * @param pos           The source code position to be used for the tree.
 * @param c             The qualifier class.
 */
JCExpression makeThis(DiagnosticPosition pos,TypeSymbol c){
  if (currentClass == c) {
    return make.at(pos).This(c.erasure(types));
  }
 else {
    return makeOuterThis(pos,c);
  }
}","/** 
 * Construct a tree simulating the expression   {@code C.this}.
 * @param pos           The source code position to be used for the tree.
 * @param c             The qualifier class.
 */
JCExpression makeThis(DiagnosticPosition pos,TypeSymbol c){
  if (currentClass == c) {
    return make.at(pos).This(c.erasure(types));
  }
 else {
    return makeOuterThis(pos,c);
  }
}"
72155,"/** 
 * A statement of the form <pre> for ( T v : coll ) stmt ; </pre> (where coll implements Iterable<? extends T>) gets translated to <pre> for ( Iterator<? extends T> #i = coll.iterator(); #i.hasNext(); ) { T v = (T) #i.next(); stmt; } </pre> where #i is a freshly named synthetic local variable.
 */
private void visitIterableForeachLoop(JCEnhancedForLoop tree){
  make_at(tree.expr.pos());
  Type iteratorTarget=syms.objectType;
  Type iterableType=types.asSuper(types.upperBound(tree.expr.type),syms.iterableType.tsym);
  if (iterableType.getTypeArguments().nonEmpty())   iteratorTarget=types.erasure(iterableType.getTypeArguments().head);
  Type eType=tree.expr.type;
  tree.expr.type=types.erasure(eType);
  if (eType.tag == TYPEVAR && eType.getUpperBound().isCompound())   tree.expr=make.TypeCast(types.erasure(iterableType),tree.expr);
  Symbol iterator=lookupMethod(tree.expr.pos(),names.iterator,types.erasure(syms.iterableType),List.<Type>nil());
  VarSymbol itvar=new VarSymbol(0,names.fromString(""String_Node_Str"" + target.syntheticNameChar()),types.erasure(iterator.type.getReturnType()),currentMethodSym);
  JCStatement init=make.VarDef(itvar,make.App(make.Select(tree.expr,iterator)));
  Symbol hasNext=lookupMethod(tree.expr.pos(),names.hasNext,itvar.type,List.<Type>nil());
  JCMethodInvocation cond=make.App(make.Select(make.Ident(itvar),hasNext));
  Symbol next=lookupMethod(tree.expr.pos(),names.next,itvar.type,List.<Type>nil());
  JCExpression vardefinit=make.App(make.Select(make.Ident(itvar),next));
  if (tree.var.type.isPrimitive())   vardefinit=make.TypeCast(types.upperBound(iteratorTarget),vardefinit);
 else   vardefinit=make.TypeCast(tree.var.type,vardefinit);
  JCVariableDecl indexDef=(JCVariableDecl)make.VarDef(tree.var.mods,tree.var.name,tree.var.vartype,vardefinit).setType(tree.var.type);
  indexDef.sym=tree.var.sym;
  JCBlock body=make.Block(0,List.of(indexDef,tree.body));
  body.endpos=TreeInfo.endPos(tree.body);
  result=translate(make.ForLoop(List.of(init),cond,List.<JCExpressionStatement>nil(),body));
  patchTargets(body,tree,result);
}","/** 
 * A statement of the form <pre> for ( T v : coll ) stmt ; </pre> (where coll implements   {@code Iterable<? extends T>}) gets translated to <pre>  {@code}for ( Iterator<? extends T> #i = coll.iterator(); #i.hasNext(); )  T v = (T) #i.next(); stmt; } }</pre> where #i is a freshly named synthetic local variable.
 */
private void visitIterableForeachLoop(JCEnhancedForLoop tree){
  make_at(tree.expr.pos());
  Type iteratorTarget=syms.objectType;
  Type iterableType=types.asSuper(types.upperBound(tree.expr.type),syms.iterableType.tsym);
  if (iterableType.getTypeArguments().nonEmpty())   iteratorTarget=types.erasure(iterableType.getTypeArguments().head);
  Type eType=tree.expr.type;
  tree.expr.type=types.erasure(eType);
  if (eType.tag == TYPEVAR && eType.getUpperBound().isCompound())   tree.expr=make.TypeCast(types.erasure(iterableType),tree.expr);
  Symbol iterator=lookupMethod(tree.expr.pos(),names.iterator,types.erasure(syms.iterableType),List.<Type>nil());
  VarSymbol itvar=new VarSymbol(0,names.fromString(""String_Node_Str"" + target.syntheticNameChar()),types.erasure(iterator.type.getReturnType()),currentMethodSym);
  JCStatement init=make.VarDef(itvar,make.App(make.Select(tree.expr,iterator)));
  Symbol hasNext=lookupMethod(tree.expr.pos(),names.hasNext,itvar.type,List.<Type>nil());
  JCMethodInvocation cond=make.App(make.Select(make.Ident(itvar),hasNext));
  Symbol next=lookupMethod(tree.expr.pos(),names.next,itvar.type,List.<Type>nil());
  JCExpression vardefinit=make.App(make.Select(make.Ident(itvar),next));
  if (tree.var.type.isPrimitive())   vardefinit=make.TypeCast(types.upperBound(iteratorTarget),vardefinit);
 else   vardefinit=make.TypeCast(tree.var.type,vardefinit);
  JCVariableDecl indexDef=(JCVariableDecl)make.VarDef(tree.var.mods,tree.var.name,tree.var.vartype,vardefinit).setType(tree.var.type);
  indexDef.sym=tree.var.sym;
  JCBlock body=make.Block(0,List.of(indexDef,tree.body));
  body.endpos=TreeInfo.endPos(tree.body);
  result=translate(make.ForLoop(List.of(init),cond,List.<JCExpressionStatement>nil(),body));
  patchTargets(body,tree,result);
}"
72156,"/** 
 * Return tree simulating the assignment <this.name = name>, where name is the name of a free variable.
 */
JCStatement initField(int pos,Name name){
  Scope.Entry e=proxies.lookup(name);
  Symbol rhs=e.sym;
  Assert.check(rhs.owner.kind == MTH);
  Symbol lhs=e.next().sym;
  Assert.check(rhs.owner.owner == lhs.owner);
  make.at(pos);
  return make.Exec(make.Assign(make.Select(make.This(lhs.owner.erasure(types)),lhs),make.Ident(rhs)).setType(lhs.erasure(types)));
}","/** 
 * Return tree simulating the assignment   {@code this.name = name}, where name is the name of a free variable.
 */
JCStatement initField(int pos,Name name){
  Scope.Entry e=proxies.lookup(name);
  Symbol rhs=e.sym;
  Assert.check(rhs.owner.kind == MTH);
  Symbol lhs=e.next().sym;
  Assert.check(rhs.owner.owner == lhs.owner);
  make.at(pos);
  return make.Exec(make.Assign(make.Select(make.This(lhs.owner.erasure(types)),lhs),make.Ident(rhs)).setType(lhs.erasure(types)));
}"
72157,"/** 
 * A name designates an operator if it consists of a non-empty sequence of operator symbols +-~!/*%&|^<>=
 */
boolean isOperator(Name name){
  int i=0;
  while (i < name.getByteLength() && ""String_Node_Str"".indexOf(name.getByteAt(i)) >= 0)   i++;
  return i > 0 && i == name.getByteLength();
}","/** 
 * A name designates an operator if it consists of a non-empty sequence of operator symbols   {@literal +-~!/*%&|^<>= }
 */
boolean isOperator(Name name){
  int i=0;
  while (i < name.getByteLength() && ""String_Node_Str"".indexOf(name.getByteAt(i)) >= 0)   i++;
  return i > 0 && i == name.getByteLength();
}"
72158,"/** 
 * This method scans all the constructor symbol in a given class scope - assuming that the original scope contains a constructor of the kind: Foo(X x, Y y), where X,Y are class type-variables declared in Foo, a method check is executed against the modified constructor type: <X,Y>Foo<X,Y>(X x, Y y). This is crucial in order to enable diamond inference. The inferred return type of the synthetic constructor IS the inferred type for the diamond operator.
 */
private Symbol findDiamond(Env<AttrContext> env,Type site,List<Type> argtypes,List<Type> typeargtypes,boolean allowBoxing,boolean useVarargs){
  Symbol bestSoFar=methodNotFound;
  for (Scope.Entry e=site.tsym.members().lookup(names.init); e.scope != null; e=e.next()) {
    if (e.sym.kind == MTH && (e.sym.flags_field & SYNTHETIC) == 0) {
      List<Type> oldParams=e.sym.type.tag == FORALL ? ((ForAll)e.sym.type).tvars : List.<Type>nil();
      Type constrType=new ForAll(site.tsym.type.getTypeArguments().appendList(oldParams),types.createMethodTypeWithReturn(e.sym.type.asMethodType(),site));
      bestSoFar=selectBest(env,site,argtypes,typeargtypes,new MethodSymbol(e.sym.flags(),names.init,constrType,site.tsym),bestSoFar,allowBoxing,useVarargs,false);
    }
  }
  return bestSoFar;
}","/** 
 * This method scans all the constructor symbol in a given class scope - assuming that the original scope contains a constructor of the kind:  {@code Foo(X x, Y y)}, where X,Y are class type-variables declared in Foo, a method check is executed against the modified constructor type:  {@code <X,Y>Foo<X,Y>(X x, Y y)}. This is crucial in order to enable diamond inference. The inferred return type of the synthetic constructor IS the inferred type for the diamond operator.
 */
private Symbol findDiamond(Env<AttrContext> env,Type site,List<Type> argtypes,List<Type> typeargtypes,boolean allowBoxing,boolean useVarargs){
  Symbol bestSoFar=methodNotFound;
  for (Scope.Entry e=site.tsym.members().lookup(names.init); e.scope != null; e=e.next()) {
    if (e.sym.kind == MTH && (e.sym.flags_field & SYNTHETIC) == 0) {
      List<Type> oldParams=e.sym.type.tag == FORALL ? ((ForAll)e.sym.type).tvars : List.<Type>nil();
      Type constrType=new ForAll(site.tsym.type.getTypeArguments().appendList(oldParams),types.createMethodTypeWithReturn(e.sym.type.asMethodType(),site));
      bestSoFar=selectBest(env,site,argtypes,typeargtypes,new MethodSymbol(e.sym.flags(),names.init,constrType,site.tsym),bestSoFar,allowBoxing,useVarargs,false);
    }
  }
  return bestSoFar;
}"
72159,"/** 
 * Source file positions in CRT are integers in the format: line-number << LINESHIFT + column-number
 */
private int encodePosition(int pos,Position.LineMap lineMap,Log log){
  int line=lineMap.getLineNumber(pos);
  int col=lineMap.getColumnNumber(pos);
  int new_pos=Position.encodePosition(line,col);
  if (crtDebug) {
    System.out.println(""String_Node_Str"" + line + ""String_Node_Str""+ col+ ""String_Node_Str""+ new_pos);
  }
  if (new_pos == Position.NOPOS)   log.warning(pos,""String_Node_Str"",line);
  return new_pos;
}","/** 
 * Source file positions in CRT are integers in the format:  {@literal line-number << LINESHIFT + column-number }
 */
private int encodePosition(int pos,Position.LineMap lineMap,Log log){
  int line=lineMap.getLineNumber(pos);
  int col=lineMap.getColumnNumber(pos);
  int new_pos=Position.encodePosition(line,col);
  if (crtDebug) {
    System.out.println(""String_Node_Str"" + line + ""String_Node_Str""+ col+ ""String_Node_Str""+ new_pos);
  }
  if (new_pos == Position.NOPOS)   log.warning(pos,""String_Node_Str"",line);
  return new_pos;
}"
72160,"public synchronized int getNumDeactivated() throws RemoteException {
  return (num_deactivated);
}","public synchronized int getNumDeactivated() throws RemoteException {
  return num_deactivated;
}"
72161,"public static void main(String[] args){
  Registry registry;
  System.err.println(""String_Node_Str"");
  TestLibrary.suggestSecurityManager(""String_Node_Str"");
  RMID rmid=null;
  try {
    RMID.removeLog();
    rmid=RMID.createRMID();
    rmid.start();
    final Properties p=new Properties();
    p.put(""String_Node_Str"",TestParams.defaultGroupPolicy);
    p.put(""String_Node_Str"",TestParams.defaultSecurityManager);
    Thread t=new Thread(){
      public void run(){
        try {
          System.err.println(""String_Node_Str"");
          ActivationGroupDesc groupDesc=new ActivationGroupDesc(p,null);
          ActivationSystem system=ActivationGroup.getSystem();
          ActivationGroupID groupID=system.registerGroup(groupDesc);
          ActivateMe[] obj=new ActivateMe[NUM_OBJECTS];
          for (int i=0; i < NUM_OBJECTS; i++) {
            System.err.println(""String_Node_Str"" + i);
            ActivationDesc desc=new ActivationDesc(groupID,""String_Node_Str"",null,null);
            System.err.println(""String_Node_Str"" + i);
            obj[i]=(ActivateMe)Activatable.register(desc);
            System.err.println(""String_Node_Str"" + i);
            obj[i].ping();
          }
          lastResortExitObj=obj[0];
          System.err.println(""String_Node_Str"");
          system.unregisterGroup(groupID);
          try {
            System.err.println(""String_Node_Str"");
            system.getActivationGroupDesc(groupID);
            error=""String_Node_Str"";
          }
 catch (          UnknownGroupException e) {
            System.err.println(""String_Node_Str"" + ""String_Node_Str"");
          }
          for (int i=0; i < NUM_OBJECTS; i++) {
            System.err.println(""String_Node_Str"" + i);
            obj[i].shutdown();
            obj[i]=null;
          }
          lastResortExitObj=null;
        }
 catch (        Exception e) {
          exception=e;
        }
        done=true;
      }
    }
;
    t.start();
    t.join(120000);
    if (exception != null) {
      TestLibrary.bomb(""String_Node_Str"",exception);
    }
 else     if (error != null) {
      TestLibrary.bomb(error,null);
    }
 else     if (!done) {
      TestLibrary.bomb(""String_Node_Str"",null);
    }
 else {
      System.err.println(""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    TestLibrary.bomb(""String_Node_Str"",e);
  }
 finally {
    if (lastResortExitObj != null) {
      try {
        lastResortExitObj.justGoAway();
      }
 catch (      Exception munch) {
      }
    }
    try {
      registry=TestLibrary.createRegistryOnUnusedPort();
      registryPort=TestLibrary.getRegistryPort(registry);
      Callback robj=new Callback();
      registry.bind(""String_Node_Str"",robj);
      int maxwait=30;
      int nd=robj.getNumDeactivated();
      while ((nd < NUM_OBJECTS) && (maxwait > 0)) {
        System.err.println(""String_Node_Str"" + nd);
        try {
          Thread.sleep(1000);
        }
 catch (        InterruptedException ie) {
        }
        maxwait--;
        nd=robj.getNumDeactivated();
      }
    }
 catch (    Exception ce) {
      System.err.println(""String_Node_Str"" + ce);
      ce.printStackTrace();
    }
    ActivationLibrary.rmidCleanup(rmid);
  }
}","public static void main(String[] args) throws RemoteException {
  System.err.println(""String_Node_Str"");
  TestLibrary.suggestSecurityManager(""String_Node_Str"");
  RMID rmid=null;
  Registry registry=TestLibrary.createRegistryOnUnusedPort();
  registryPort=TestLibrary.getRegistryPort(registry);
  Callback robj=new Callback();
  registry.rebind(""String_Node_Str"",robj);
  try {
    RMID.removeLog();
    rmid=RMID.createRMID();
    rmid.start();
    final Properties p=new Properties();
    p.put(""String_Node_Str"",TestParams.defaultGroupPolicy);
    p.put(""String_Node_Str"",TestParams.defaultSecurityManager);
    p.put(""String_Node_Str"",Integer.toString(registryPort));
    Thread t=new Thread(){
      public void run(){
        try {
          System.err.println(""String_Node_Str"");
          ActivationGroupDesc groupDesc=new ActivationGroupDesc(p,null);
          ActivationSystem system=ActivationGroup.getSystem();
          ActivationGroupID groupID=system.registerGroup(groupDesc);
          ActivateMe[] obj=new ActivateMe[NUM_OBJECTS];
          for (int i=0; i < NUM_OBJECTS; i++) {
            System.err.println(""String_Node_Str"" + i);
            ActivationDesc desc=new ActivationDesc(groupID,""String_Node_Str"",null,null);
            System.err.println(""String_Node_Str"" + i);
            obj[i]=(ActivateMe)Activatable.register(desc);
            System.err.println(""String_Node_Str"" + i);
            obj[i].ping();
          }
          lastResortExitObj=obj[0];
          System.err.println(""String_Node_Str"");
          system.unregisterGroup(groupID);
          try {
            System.err.println(""String_Node_Str"");
            system.getActivationGroupDesc(groupID);
            error=""String_Node_Str"";
          }
 catch (          UnknownGroupException e) {
            System.err.println(""String_Node_Str"" + ""String_Node_Str"");
          }
          for (int i=0; i < NUM_OBJECTS; i++) {
            System.err.println(""String_Node_Str"" + i);
            obj[i].shutdown();
            obj[i]=null;
          }
          lastResortExitObj=null;
        }
 catch (        Exception e) {
          exception=e;
        }
        done=true;
      }
    }
;
    t.start();
    t.join(120000);
    if (exception != null) {
      TestLibrary.bomb(""String_Node_Str"",exception);
    }
 else     if (error != null) {
      TestLibrary.bomb(error,null);
    }
 else     if (!done) {
      TestLibrary.bomb(""String_Node_Str"",null);
    }
 else {
      System.err.println(""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    TestLibrary.bomb(""String_Node_Str"",e);
  }
 finally {
    if (lastResortExitObj != null) {
      try {
        lastResortExitObj.justGoAway();
      }
 catch (      Exception munch) {
      }
    }
    try {
      int maxwait=30;
      int nd=robj.getNumDeactivated();
      while ((nd < NUM_OBJECTS) && (maxwait > 0)) {
        System.err.println(""String_Node_Str"" + nd);
        try {
          Thread.sleep(1000);
        }
 catch (        InterruptedException ie) {
        }
        maxwait--;
        nd=robj.getNumDeactivated();
      }
    }
 catch (    Exception ce) {
      System.err.println(""String_Node_Str"" + ce);
      ce.printStackTrace();
    }
    ActivationLibrary.rmidCleanup(rmid);
  }
}"
72162,"public void inc() throws RemoteException {
  incNumDeactivated();
}","public synchronized void inc() throws RemoteException {
  num_deactivated++;
}"
72163,"public String[] bases(String repId){
  String[] results=null;
  if (bases == null)   bases=new Hashtable();
 else   results=(String[])bases.get(repId);
  if (results == null && connectedCodeBase()) {
    results=delegate.bases(repId);
    if (results != null)     bases.put(repId,results);
  }
  return results;
}","public synchronized String[] bases(String repId){
  String[] results=null;
  if (bases == null)   bases=new Hashtable();
 else   results=(String[])bases.get(repId);
  if (results == null && connectedCodeBase()) {
    results=delegate.bases(repId);
    if (results != null)     bases.put(repId,results);
  }
  return results;
}"
72164,"public FullValueDescription[] metas(String[] repIds){
  FullValueDescription[] results=new FullValueDescription[repIds.length];
  for (int i=0; i < results.length; i++)   results[i]=meta(repIds[i]);
  return results;
}","public synchronized FullValueDescription[] metas(String[] repIds){
  FullValueDescription[] results=new FullValueDescription[repIds.length];
  for (int i=0; i < results.length; i++)   results[i]=meta(repIds[i]);
  return results;
}"
72165,"private boolean connectedCodeBase(){
  if (delegate != null)   return true;
  if (conn.getCodeBaseIOR() == null) {
    if (conn.getBroker().transportDebugFlag)     conn.dprint(""String_Node_Str"" + conn);
    return false;
  }
synchronized (this) {
    if (delegate != null)     return true;
    delegate=(CodeBase)CachedCodeBase.iorToCodeBaseObjMap.get(conn.getCodeBaseIOR());
    if (delegate != null)     return true;
    delegate=CodeBaseHelper.narrow(getObjectFromIOR());
    CachedCodeBase.iorToCodeBaseObjMap.put(conn.getCodeBaseIOR(),delegate);
  }
  return true;
}","private synchronized boolean connectedCodeBase(){
  if (delegate != null)   return true;
  if (conn.getCodeBaseIOR() == null) {
    if (conn.getBroker().transportDebugFlag)     conn.dprint(""String_Node_Str"" + conn);
    return false;
  }
synchronized (iorMapLock) {
    if (delegate != null)     return true;
    delegate=CachedCodeBase.iorMap.get(conn.getCodeBaseIOR());
    if (delegate != null)     return true;
    delegate=CodeBaseHelper.narrow(getObjectFromIOR());
    CachedCodeBase.iorMap.put(conn.getCodeBaseIOR(),delegate);
  }
  return true;
}"
72166,"public FullValueDescription meta(String repId){
  FullValueDescription result=null;
  if (fvds == null)   fvds=new Hashtable();
 else   result=(FullValueDescription)fvds.get(repId);
  if (result == null && connectedCodeBase()) {
    result=delegate.meta(repId);
    if (result != null)     fvds.put(repId,result);
  }
  return result;
}","public synchronized FullValueDescription meta(String repId){
  FullValueDescription result=null;
  if (fvds == null)   fvds=new Hashtable();
 else   result=(FullValueDescription)fvds.get(repId);
  if (result == null && connectedCodeBase()) {
    result=delegate.meta(repId);
    if (result != null)     fvds.put(repId,result);
  }
  return result;
}"
72167,"public String implementation(String repId){
  String urlResult=null;
  if (implementations == null)   implementations=new Hashtable();
 else   urlResult=(String)implementations.get(repId);
  if (urlResult == null && connectedCodeBase()) {
    urlResult=delegate.implementation(repId);
    if (urlResult != null)     implementations.put(repId,urlResult);
  }
  return urlResult;
}","public synchronized String implementation(String repId){
  String urlResult=null;
  if (implementations == null)   implementations=new Hashtable();
 else   urlResult=(String)implementations.get(repId);
  if (urlResult == null && connectedCodeBase()) {
    urlResult=delegate.implementation(repId);
    if (urlResult != null)     implementations.put(repId,urlResult);
  }
  return urlResult;
}"
72168,"public String[] implementations(String[] repIds){
  String[] urlResults=new String[repIds.length];
  for (int i=0; i < urlResults.length; i++)   urlResults[i]=implementation(repIds[i]);
  return urlResults;
}","public synchronized String[] implementations(String[] repIds){
  String[] urlResults=new String[repIds.length];
  for (int i=0; i < urlResults.length; i++)   urlResults[i]=implementation(repIds[i]);
  return urlResults;
}"
72169,"private static void executeCommandForPid(String pid,String command) throws AttachNotSupportedException, IOException, UnsupportedEncodingException {
  VirtualMachine vm=VirtualMachine.attach(pid);
  HotSpotVirtualMachine hvm=(HotSpotVirtualMachine)vm;
  try (InputStream in=hvm.executeJCmd(command)){
    byte b[]=new byte[256];
    int n;
    do {
      n=in.read(b);
      if (n > 0) {
        String s=new String(b,0,n,""String_Node_Str"");
        System.out.print(s);
      }
    }
 while (n > 0);
  }
   vm.detach();
}","private static void executeCommandForPid(String pid,String command) throws AttachNotSupportedException, IOException, UnsupportedEncodingException {
  VirtualMachine vm=VirtualMachine.attach(pid);
  HotSpotVirtualMachine hvm=(HotSpotVirtualMachine)vm;
  String lines[]=command.split(""String_Node_Str"");
  for (  String line : lines) {
    try (InputStream in=hvm.executeJCmd(line)){
      byte b[]=new byte[256];
      int n;
      do {
        n=in.read(b);
        if (n > 0) {
          String s=new String(b,0,n,""String_Node_Str"");
          System.out.print(s);
        }
      }
 while (n > 0);
    }
   }
  vm.detach();
}"
72170,"protected void close(){
  if (fd != null || fd1 != null) {
    datagramSocketClose();
    fd=null;
    fd1=null;
  }
}","protected void close(){
  if (fd != null || fd1 != null) {
    datagramSocketClose();
    ResourceManager.afterUdpClose();
    fd=null;
    fd1=null;
  }
}"
72171,"public Log make(){
  return Bark.instance(context);
}","public Log make(Context c){
  return Bark.instance(c);
}"
72172,"/** 
 * Preregisters factories to create and use a Bark object for use as both a Log and a Bark.
 */
public static void preRegister(final Context context){
  context.put(barkKey,new Context.Factory<Bark>(){
    public Bark make(){
      return new Bark(context);
    }
  }
);
  context.put(Log.logKey,new Context.Factory<Log>(){
    public Log make(){
      return Bark.instance(context);
    }
  }
);
}","/** 
 * Preregisters factories to create and use a Bark object for use as both a Log and a Bark.
 */
public static void preRegister(Context context){
  context.put(barkKey,new Context.Factory<Bark>(){
    public Bark make(    Context c){
      return new Bark(c);
    }
  }
);
  context.put(Log.logKey,new Context.Factory<Log>(){
    public Log make(    Context c){
      return Bark.instance(c);
    }
  }
);
}"
72173,"/** 
 * Register that a compilation is about to start.
 */
void beginContext(final Context context){
  if (compilationInProgress)   throw new IllegalStateException(""String_Node_Str"");
  compilationInProgress=true;
  final JavaFileManager givenFileManager=context.get(JavaFileManager.class);
  context.put(JavaFileManager.class,(JavaFileManager)null);
  context.put(JavaFileManager.class,new Context.Factory<JavaFileManager>(){
    public JavaFileManager make(){
      if (givenFileManager != null) {
        context.put(JavaFileManager.class,givenFileManager);
        return givenFileManager;
      }
 else {
        return new JavacFileManager(context,true,null);
      }
    }
  }
);
}","/** 
 * Register that a compilation is about to start.
 */
void beginContext(Context context){
  if (compilationInProgress)   throw new IllegalStateException(""String_Node_Str"");
  compilationInProgress=true;
  final JavaFileManager givenFileManager=context.get(JavaFileManager.class);
  context.put(JavaFileManager.class,(JavaFileManager)null);
  context.put(JavaFileManager.class,new Context.Factory<JavaFileManager>(){
    public JavaFileManager make(    Context c){
      if (givenFileManager != null) {
        c.put(JavaFileManager.class,givenFileManager);
        return givenFileManager;
      }
 else {
        return new JavacFileManager(c,true,null);
      }
    }
  }
);
}"
72174,"public JavaFileManager make(){
  if (givenFileManager != null) {
    context.put(JavaFileManager.class,givenFileManager);
    return givenFileManager;
  }
 else {
    return new JavacFileManager(context,true,null);
  }
}","public JavaFileManager make(Context c){
  if (givenFileManager != null) {
    c.put(JavaFileManager.class,givenFileManager);
    return givenFileManager;
  }
 else {
    return new JavacFileManager(c,true,null);
  }
}"
72175,"public FSInfo make(){
  FSInfo instance=new CacheFSInfo();
  context.put(FSInfo.class,instance);
  return instance;
}","public FSInfo make(Context c){
  FSInfo instance=new CacheFSInfo();
  c.put(FSInfo.class,instance);
  return instance;
}"
72176,"/** 
 * Register a Context.Factory to create a singleton CacheFSInfo.
 */
public static void preRegister(final Context context){
  context.put(FSInfo.class,new Context.Factory<FSInfo>(){
    public FSInfo make(){
      FSInfo instance=new CacheFSInfo();
      context.put(FSInfo.class,instance);
      return instance;
    }
  }
);
}","/** 
 * Register a Context.Factory to create a CacheFSInfo.
 */
public static void preRegister(Context context){
  context.put(FSInfo.class,new Context.Factory<FSInfo>(){
    public FSInfo make(    Context c){
      FSInfo instance=new CacheFSInfo();
      c.put(FSInfo.class,instance);
      return instance;
    }
  }
);
}"
72177,"/** 
 * Register a Context.Factory to create a JavacFileManager.
 */
public static void preRegister(final Context context){
  context.put(JavaFileManager.class,new Context.Factory<JavaFileManager>(){
    public JavaFileManager make(){
      return new JavacFileManager(context,true,null);
    }
  }
);
}","/** 
 * Register a Context.Factory to create a JavacFileManager.
 */
public static void preRegister(Context context){
  context.put(JavaFileManager.class,new Context.Factory<JavaFileManager>(){
    public JavaFileManager make(    Context c){
      return new JavacFileManager(c,true,null);
    }
  }
);
}"
72178,"public JavaFileManager make(){
  return new JavacFileManager(context,true,null);
}","public JavaFileManager make(Context c){
  return new JavacFileManager(c,true,null);
}"
72179,"/** 
 * Construct a new compiler using a shared context.
 */
public JavaCompiler(final Context context){
  this.context=context;
  context.put(compilerKey,this);
  if (context.get(JavaFileManager.class) == null)   JavacFileManager.preRegister(context);
  names=Names.instance(context);
  log=Log.instance(context);
  diagFactory=JCDiagnostic.Factory.instance(context);
  reader=ClassReader.instance(context);
  make=TreeMaker.instance(context);
  writer=ClassWriter.instance(context);
  enter=Enter.instance(context);
  todo=Todo.instance(context);
  fileManager=context.get(JavaFileManager.class);
  parserFactory=ParserFactory.instance(context);
  try {
    syms=Symtab.instance(context);
  }
 catch (  CompletionFailure ex) {
    log.error(""String_Node_Str"",ex.sym,ex.getDetailValue());
    if (ex instanceof ClassReader.BadClassFile)     throw new Abort();
  }
  source=Source.instance(context);
  attr=Attr.instance(context);
  chk=Check.instance(context);
  gen=Gen.instance(context);
  flow=Flow.instance(context);
  transTypes=TransTypes.instance(context);
  lower=Lower.instance(context);
  annotate=Annotate.instance(context);
  types=Types.instance(context);
  taskListener=context.get(TaskListener.class);
  reader.sourceCompleter=this;
  Options options=Options.instance(context);
  verbose=options.isSet(VERBOSE);
  sourceOutput=options.isSet(PRINTSOURCE);
  stubOutput=options.isSet(""String_Node_Str"");
  relax=options.isSet(""String_Node_Str"");
  printFlat=options.isSet(""String_Node_Str"");
  attrParseOnly=options.isSet(""String_Node_Str"");
  encoding=options.get(ENCODING);
  lineDebugInfo=options.isUnset(G_CUSTOM) || options.isSet(G_CUSTOM,""String_Node_Str"");
  genEndPos=options.isSet(XJCOV) || context.get(DiagnosticListener.class) != null;
  devVerbose=options.isSet(""String_Node_Str"");
  processPcks=options.isSet(""String_Node_Str"");
  werror=options.isSet(WERROR);
  if (source.compareTo(Source.DEFAULT) < 0) {
    if (options.isUnset(XLINT_CUSTOM,""String_Node_Str"" + LintCategory.OPTIONS.option)) {
      if (fileManager instanceof BaseFileManager) {
        if (((BaseFileManager)fileManager).isDefaultBootClassPath())         log.warning(LintCategory.OPTIONS,""String_Node_Str"",source.name);
      }
    }
  }
  verboseCompilePolicy=options.isSet(""String_Node_Str"");
  if (attrParseOnly)   compilePolicy=CompilePolicy.ATTR_ONLY;
 else   compilePolicy=CompilePolicy.decode(options.get(""String_Node_Str""));
  implicitSourcePolicy=ImplicitSourcePolicy.decode(options.get(""String_Node_Str""));
  completionFailureName=options.isSet(""String_Node_Str"") ? names.fromString(options.get(""String_Node_Str"")) : null;
  shouldStopPolicy=options.isSet(""String_Node_Str"") ? CompileState.valueOf(options.get(""String_Node_Str"")) : null;
  if (options.isUnset(""String_Node_Str""))   log.setDiagnosticFormatter(RichDiagnosticFormatter.instance(context));
}","/** 
 * Construct a new compiler using a shared context.
 */
public JavaCompiler(Context context){
  this.context=context;
  context.put(compilerKey,this);
  if (context.get(JavaFileManager.class) == null)   JavacFileManager.preRegister(context);
  names=Names.instance(context);
  log=Log.instance(context);
  diagFactory=JCDiagnostic.Factory.instance(context);
  reader=ClassReader.instance(context);
  make=TreeMaker.instance(context);
  writer=ClassWriter.instance(context);
  enter=Enter.instance(context);
  todo=Todo.instance(context);
  fileManager=context.get(JavaFileManager.class);
  parserFactory=ParserFactory.instance(context);
  try {
    syms=Symtab.instance(context);
  }
 catch (  CompletionFailure ex) {
    log.error(""String_Node_Str"",ex.sym,ex.getDetailValue());
    if (ex instanceof ClassReader.BadClassFile)     throw new Abort();
  }
  source=Source.instance(context);
  attr=Attr.instance(context);
  chk=Check.instance(context);
  gen=Gen.instance(context);
  flow=Flow.instance(context);
  transTypes=TransTypes.instance(context);
  lower=Lower.instance(context);
  annotate=Annotate.instance(context);
  types=Types.instance(context);
  taskListener=context.get(TaskListener.class);
  reader.sourceCompleter=this;
  Options options=Options.instance(context);
  verbose=options.isSet(VERBOSE);
  sourceOutput=options.isSet(PRINTSOURCE);
  stubOutput=options.isSet(""String_Node_Str"");
  relax=options.isSet(""String_Node_Str"");
  printFlat=options.isSet(""String_Node_Str"");
  attrParseOnly=options.isSet(""String_Node_Str"");
  encoding=options.get(ENCODING);
  lineDebugInfo=options.isUnset(G_CUSTOM) || options.isSet(G_CUSTOM,""String_Node_Str"");
  genEndPos=options.isSet(XJCOV) || context.get(DiagnosticListener.class) != null;
  devVerbose=options.isSet(""String_Node_Str"");
  processPcks=options.isSet(""String_Node_Str"");
  werror=options.isSet(WERROR);
  if (source.compareTo(Source.DEFAULT) < 0) {
    if (options.isUnset(XLINT_CUSTOM,""String_Node_Str"" + LintCategory.OPTIONS.option)) {
      if (fileManager instanceof BaseFileManager) {
        if (((BaseFileManager)fileManager).isDefaultBootClassPath())         log.warning(LintCategory.OPTIONS,""String_Node_Str"",source.name);
      }
    }
  }
  verboseCompilePolicy=options.isSet(""String_Node_Str"");
  if (attrParseOnly)   compilePolicy=CompilePolicy.ATTR_ONLY;
 else   compilePolicy=CompilePolicy.decode(options.get(""String_Node_Str""));
  implicitSourcePolicy=ImplicitSourcePolicy.decode(options.get(""String_Node_Str""));
  completionFailureName=options.isSet(""String_Node_Str"") ? names.fromString(options.get(""String_Node_Str"")) : null;
  shouldStopPolicy=options.isSet(""String_Node_Str"") ? CompileState.valueOf(options.get(""String_Node_Str"")) : null;
  if (options.isUnset(""String_Node_Str""))   log.setDiagnosticFormatter(RichDiagnosticFormatter.instance(context));
}"
72180,"/** 
 * Get the context for the next round of processing. Important values are propogated from round to round; other values are implicitly reset.
 */
private Context nextContext(){
  Context next=new Context();
  Options options=Options.instance(context);
  Assert.checkNonNull(options);
  next.put(Options.optionsKey,options);
  PrintWriter out=context.get(Log.outKey);
  Assert.checkNonNull(out);
  next.put(Log.outKey,out);
  final boolean shareNames=true;
  if (shareNames) {
    Names names=Names.instance(context);
    Assert.checkNonNull(names);
    next.put(Names.namesKey,names);
  }
  DiagnosticListener<?> dl=context.get(DiagnosticListener.class);
  if (dl != null)   next.put(DiagnosticListener.class,dl);
  TaskListener tl=context.get(TaskListener.class);
  if (tl != null)   next.put(TaskListener.class,tl);
  FSInfo fsInfo=context.get(FSInfo.class);
  if (fsInfo != null)   next.put(FSInfo.class,fsInfo);
  JavaFileManager jfm=context.get(JavaFileManager.class);
  Assert.checkNonNull(jfm);
  next.put(JavaFileManager.class,jfm);
  if (jfm instanceof JavacFileManager) {
    ((JavacFileManager)jfm).setContext(next);
  }
  Names names=Names.instance(context);
  Assert.checkNonNull(names);
  next.put(Names.namesKey,names);
  Keywords keywords=Keywords.instance(context);
  Assert.checkNonNull(keywords);
  next.put(Keywords.keywordsKey,keywords);
  JavaCompiler oldCompiler=JavaCompiler.instance(context);
  JavaCompiler nextCompiler=JavaCompiler.instance(next);
  nextCompiler.initRound(oldCompiler);
  filer.newRound(next);
  messager.newRound(next);
  elementUtils.setContext(next);
  typeUtils.setContext(next);
  JavacTaskImpl task=context.get(JavacTaskImpl.class);
  if (task != null) {
    next.put(JavacTaskImpl.class,task);
    task.updateContext(next);
  }
  JavacTrees trees=context.get(JavacTrees.class);
  if (trees != null) {
    next.put(JavacTrees.class,trees);
    trees.updateContext(next);
  }
  context.clear();
  return next;
}","/** 
 * Get the context for the next round of processing. Important values are propogated from round to round; other values are implicitly reset.
 */
private Context nextContext(){
  Context next=new Context(context);
  Options options=Options.instance(context);
  Assert.checkNonNull(options);
  next.put(Options.optionsKey,options);
  PrintWriter out=context.get(Log.outKey);
  Assert.checkNonNull(out);
  next.put(Log.outKey,out);
  final boolean shareNames=true;
  if (shareNames) {
    Names names=Names.instance(context);
    Assert.checkNonNull(names);
    next.put(Names.namesKey,names);
  }
  DiagnosticListener<?> dl=context.get(DiagnosticListener.class);
  if (dl != null)   next.put(DiagnosticListener.class,dl);
  TaskListener tl=context.get(TaskListener.class);
  if (tl != null)   next.put(TaskListener.class,tl);
  FSInfo fsInfo=context.get(FSInfo.class);
  if (fsInfo != null)   next.put(FSInfo.class,fsInfo);
  JavaFileManager jfm=context.get(JavaFileManager.class);
  Assert.checkNonNull(jfm);
  next.put(JavaFileManager.class,jfm);
  if (jfm instanceof JavacFileManager) {
    ((JavacFileManager)jfm).setContext(next);
  }
  Names names=Names.instance(context);
  Assert.checkNonNull(names);
  next.put(Names.namesKey,names);
  Keywords keywords=Keywords.instance(context);
  Assert.checkNonNull(keywords);
  next.put(Keywords.keywordsKey,keywords);
  JavaCompiler oldCompiler=JavaCompiler.instance(context);
  JavaCompiler nextCompiler=JavaCompiler.instance(next);
  nextCompiler.initRound(oldCompiler);
  filer.newRound(next);
  messager.newRound(next);
  elementUtils.setContext(next);
  typeUtils.setContext(next);
  JavacTaskImpl task=context.get(JavacTaskImpl.class);
  if (task != null) {
    next.put(JavacTaskImpl.class,task);
    task.updateContext(next);
  }
  JavacTrees trees=context.get(JavacTrees.class);
  if (trees != null) {
    next.put(JavacTrees.class,trees);
    trees.updateContext(next);
  }
  context.clear();
  return next;
}"
72181,"public Context(){
}","public Context(Context prev){
  kt.putAll(prev.kt);
  ft.putAll(prev.ft);
  ht.putAll(prev.ft);
}"
72182,"public void clear(){
  ht=null;
  kt=null;
}","public void clear(){
  ht=null;
  kt=null;
  ft=null;
}"
72183,T make();,T make(Context c);
72184,"public ClassReader make(){
  return new JavadocClassReader(context);
}","public ClassReader make(Context c){
  return new JavadocClassReader(c);
}"
72185,"public static void preRegister(final Context context){
  context.put(classReaderKey,new Context.Factory<ClassReader>(){
    public ClassReader make(){
      return new JavadocClassReader(context);
    }
  }
);
}","public static void preRegister(Context context){
  context.put(classReaderKey,new Context.Factory<ClassReader>(){
    public ClassReader make(    Context c){
      return new JavadocClassReader(c);
    }
  }
);
}"
72186,"public Enter make(){
  return new JavadocEnter(context);
}","public Enter make(Context c){
  return new JavadocEnter(c);
}"
72187,"public static void preRegister(final Context context){
  context.put(enterKey,new Context.Factory<Enter>(){
    public Enter make(){
      return new JavadocEnter(context);
    }
  }
);
}","public static void preRegister(Context context){
  context.put(enterKey,new Context.Factory<Enter>(){
    public Enter make(    Context c){
      return new JavadocEnter(c);
    }
  }
);
}"
72188,"public MemberEnter make(){
  return new JavadocMemberEnter(context);
}","public MemberEnter make(Context c){
  return new JavadocMemberEnter(c);
}"
72189,"public static void preRegister(final Context context){
  context.put(memberEnterKey,new Context.Factory<MemberEnter>(){
    public MemberEnter make(){
      return new JavadocMemberEnter(context);
    }
  }
);
}","public static void preRegister(Context context){
  context.put(memberEnterKey,new Context.Factory<MemberEnter>(){
    public MemberEnter make(    Context c){
      return new JavadocMemberEnter(c);
    }
  }
);
}"
72190,"public Todo make(){
  return new JavadocTodo(context);
}","public Todo make(Context c){
  return new JavadocTodo(c);
}"
72191,"public static void preRegister(final Context context){
  context.put(todoKey,new Context.Factory<Todo>(){
    public Todo make(){
      return new JavadocTodo(context);
    }
  }
);
}","public static void preRegister(Context context){
  context.put(todoKey,new Context.Factory<Todo>(){
    public Todo make(    Context c){
      return new JavadocTodo(c);
    }
  }
);
}"
72192,"public Log make(){
  return new Messager(context,programName,errWriter,warnWriter,noticeWriter);
}","public Log make(Context c){
  return new Messager(c,programName,errWriter,warnWriter,noticeWriter);
}"
72193,"public static void preRegister(final Context context,final String programName,final PrintWriter errWriter,final PrintWriter warnWriter,final PrintWriter noticeWriter){
  context.put(logKey,new Context.Factory<Log>(){
    public Log make(){
      return new Messager(context,programName,errWriter,warnWriter,noticeWriter);
    }
  }
);
}","public static void preRegister(Context context,final String programName,final PrintWriter errWriter,final PrintWriter warnWriter,final PrintWriter noticeWriter){
  context.put(logKey,new Context.Factory<Log>(){
    public Log make(    Context c){
      return new Messager(c,programName,errWriter,warnWriter,noticeWriter);
    }
  }
);
}"
72194,"public JavacMessages make(){
  return new ArgTypeMessages(c){
    @Override public String getLocalizedString(    Locale l,    String key,    Object... args){
      return getKeyArgsString(key,args);
    }
  }
;
}","public JavacMessages make(Context c){
  return new ArgTypeMessages(c){
    @Override public String getLocalizedString(    Locale l,    String key,    Object... args){
      return getKeyArgsString(key,args);
    }
  }
;
}"
72195,"static void preRegister(final Context c){
  c.put(JavacMessages.messagesKey,new Context.Factory<JavacMessages>(){
    public JavacMessages make(){
      return new ArgTypeMessages(c){
        @Override public String getLocalizedString(        Locale l,        String key,        Object... args){
          return getKeyArgsString(key,args);
        }
      }
;
    }
  }
);
}","static void preRegister(Context context){
  context.put(JavacMessages.messagesKey,new Context.Factory<JavacMessages>(){
    public JavacMessages make(    Context c){
      return new ArgTypeMessages(c){
        @Override public String getLocalizedString(        Locale l,        String key,        Object... args){
          return getKeyArgsString(key,args);
        }
      }
;
    }
  }
);
}"
72196,"public JavacMessages make(){
  return new MessageTracker(c){
    @Override public String getLocalizedString(    Locale l,    String key,    Object... args){
      keys.add(key);
      return super.getLocalizedString(l,key,args);
    }
  }
;
}","public JavacMessages make(Context c){
  return new MessageTracker(c){
    @Override public String getLocalizedString(    Locale l,    String key,    Object... args){
      keys.add(key);
      return super.getLocalizedString(l,key,args);
    }
  }
;
}"
72197,"static void preRegister(final Context c,final Set<String> keys){
  if (keys != null) {
    c.put(JavacMessages.messagesKey,new Context.Factory<JavacMessages>(){
      public JavacMessages make(){
        return new MessageTracker(c){
          @Override public String getLocalizedString(          Locale l,          String key,          Object... args){
            keys.add(key);
            return super.getLocalizedString(l,key,args);
          }
        }
;
      }
    }
);
  }
}","static void preRegister(Context c,final Set<String> keys){
  if (keys != null) {
    c.put(JavacMessages.messagesKey,new Context.Factory<JavacMessages>(){
      public JavacMessages make(      Context c){
        return new MessageTracker(c){
          @Override public String getLocalizedString(          Locale l,          String key,          Object... args){
            keys.add(key);
            return super.getLocalizedString(l,key,args);
          }
        }
;
      }
    }
);
  }
}"
72198,"public Entry next(){
  Entry e=super.shadowed;
  while (e.scope != null && (e.sym.name != sym.name || e.sym.owner != e.scope.owner))   e=e.shadowed;
  return e;
}","public Entry next(){
  Entry e=super.shadowed;
  while (isBogus())   e=e.shadowed;
  return e;
}"
72199,"protected Scope(Symbol owner,ScopeCounter scopeCounter){
  this(null,owner,new Entry[INITIAL_SIZE],scopeCounter);
  for (int i=0; i < INITIAL_SIZE; i++)   table[i]=sentinel;
}","protected Scope(Symbol owner,ScopeCounter scopeCounter){
  this(null,owner,new Entry[INITIAL_SIZE],scopeCounter);
}"
72200,"protected Scope(Symbol owner,ScopeCounter scopeCounter){
  this(null,owner,new Entry[INITIAL_SIZE],scopeCounter);
}","protected Scope(Symbol owner,ScopeCounter scopeCounter){
  this(null,owner,new Entry[INITIAL_SIZE],scopeCounter);
  for (int i=0; i < INITIAL_SIZE; i++)   table[i]=sentinel;
}"
72201,"@Override public void write(int b) throws IOException {
  size++;
}","@Override public void write(int b){
  size++;
}"
72202,"public int byteLength(){
class SizeOutputStream extends OutputStream {
    @Override public void write(    int b) throws IOException {
      size++;
    }
    int size;
  }
  SizeOutputStream sizeOut=new SizeOutputStream();
  DataOutputStream out=new DataOutputStream(sizeOut);
  try {
    out.writeUTF(value);
  }
 catch (  IOException ignore) {
  }
  return 1 + sizeOut.size;
}","public int byteLength(){
class SizeOutputStream extends OutputStream {
    @Override public void write(    int b){
      size++;
    }
    int size;
  }
  SizeOutputStream sizeOut=new SizeOutputStream();
  DataOutputStream out=new DataOutputStream(sizeOut);
  try {
    out.writeUTF(value);
  }
 catch (  IOException ignore) {
  }
  return 1 + sizeOut.size;
}"
72203,"/** 
 * Constructor
 * @param context      Context for this javadoc instance.
 */
private DocEnv(Context context){
  context.put(docEnvKey,this);
  messager=Messager.instance0(context);
  syms=Symtab.instance(context);
  reader=JavadocClassReader.instance0(context);
  enter=JavadocEnter.instance0(context);
  attr=Attr.instance(context);
  names=Names.instance(context);
  externalizableSym=reader.enterClass(names.fromString(""String_Node_Str""));
  chk=Check.instance(context);
  types=Types.instance(context);
  fileManager=context.get(JavaFileManager.class);
  this.doclocale=new DocLocale(this,""String_Node_Str"",breakiterator);
}","/** 
 * Constructor
 * @param context      Context for this javadoc instance.
 */
private DocEnv(Context context){
  context.put(docEnvKey,this);
  messager=Messager.instance0(context);
  syms=Symtab.instance(context);
  reader=JavadocClassReader.instance0(context);
  enter=JavadocEnter.instance0(context);
  names=Names.instance(context);
  externalizableSym=reader.enterClass(names.fromString(""String_Node_Str""));
  chk=Check.instance(context);
  types=Types.instance(context);
  fileManager=context.get(JavaFileManager.class);
  this.doclocale=new DocLocale(this,""String_Node_Str"",breakiterator);
}"
72204,"/** 
 * Default class enter visitor method: do nothing.
 */
public void visitTree(JCTree tree){
  result=null;
}","/** 
 * Default class enter visitor method: do nothing.
 */
@Override public void visitTree(JCTree tree){
  result=null;
}"
72205,"public void visitClassDef(JCClassDecl tree){
  Symbol owner=env.info.scope.owner;
  Scope enclScope=enterScope(env);
  ClassSymbol c;
  if (owner.kind == PCK) {
    PackageSymbol packge=(PackageSymbol)owner;
    for (Symbol q=packge; q != null && q.kind == PCK; q=q.owner)     q.flags_field|=EXISTS;
    c=reader.enterClass(tree.name,packge);
    packge.members().enterIfAbsent(c);
    if ((tree.mods.flags & PUBLIC) != 0 && !classNameMatchesFileName(c,env)) {
      log.error(tree.pos(),""String_Node_Str"",tree.name);
    }
  }
 else {
    if (!tree.name.isEmpty() && !chk.checkUniqueClassName(tree.pos(),tree.name,enclScope)) {
      result=null;
      return;
    }
    if (owner.kind == TYP) {
      c=reader.enterClass(tree.name,(TypeSymbol)owner);
      if ((owner.flags_field & INTERFACE) != 0) {
        tree.mods.flags|=PUBLIC | STATIC;
      }
    }
 else {
      c=reader.defineClass(tree.name,owner);
      c.flatname=chk.localClassName(c);
      if (!c.name.isEmpty())       chk.checkTransparentClass(tree.pos(),c,env.info.scope);
    }
  }
  tree.sym=c;
  if (chk.compiled.get(c.flatname) != null) {
    duplicateClass(tree.pos(),c);
    result=types.createErrorType(tree.name,(TypeSymbol)owner,Type.noType);
    tree.sym=(ClassSymbol)result.tsym;
    return;
  }
  chk.compiled.put(c.flatname,c);
  enclScope.enter(c);
  Env<AttrContext> localEnv=classEnv(tree,env);
  typeEnvs.put(c,localEnv);
  c.completer=memberEnter;
  c.flags_field=chk.checkFlags(tree.pos(),tree.mods.flags,c,tree);
  c.sourcefile=env.toplevel.sourcefile;
  c.members_field=new Scope(c);
  ClassType ct=(ClassType)c.type;
  if (owner.kind != PCK && (c.flags_field & STATIC) == 0) {
    Symbol owner1=owner;
    while ((owner1.kind & (VAR | MTH)) != 0 && (owner1.flags_field & STATIC) == 0) {
      owner1=owner1.owner;
    }
    if (owner1.kind == TYP) {
      ct.setEnclosingType(owner1.type);
    }
  }
  ct.typarams_field=classEnter(tree.typarams,localEnv);
  if (!c.isLocal() && uncompleted != null)   uncompleted.append(c);
  classEnter(tree.defs,localEnv);
  result=c.type;
}","@Override public void visitClassDef(JCClassDecl tree){
  Symbol owner=env.info.scope.owner;
  Scope enclScope=enterScope(env);
  ClassSymbol c;
  if (owner.kind == PCK) {
    PackageSymbol packge=(PackageSymbol)owner;
    for (Symbol q=packge; q != null && q.kind == PCK; q=q.owner)     q.flags_field|=EXISTS;
    c=reader.enterClass(tree.name,packge);
    packge.members().enterIfAbsent(c);
    if ((tree.mods.flags & PUBLIC) != 0 && !classNameMatchesFileName(c,env)) {
      log.error(tree.pos(),""String_Node_Str"",tree.name);
    }
  }
 else {
    if (!tree.name.isEmpty() && !chk.checkUniqueClassName(tree.pos(),tree.name,enclScope)) {
      result=null;
      return;
    }
    if (owner.kind == TYP) {
      c=reader.enterClass(tree.name,(TypeSymbol)owner);
      if ((owner.flags_field & INTERFACE) != 0) {
        tree.mods.flags|=PUBLIC | STATIC;
      }
    }
 else {
      c=reader.defineClass(tree.name,owner);
      c.flatname=chk.localClassName(c);
      if (!c.name.isEmpty())       chk.checkTransparentClass(tree.pos(),c,env.info.scope);
    }
  }
  tree.sym=c;
  if (chk.compiled.get(c.flatname) != null) {
    duplicateClass(tree.pos(),c);
    result=types.createErrorType(tree.name,(TypeSymbol)owner,Type.noType);
    tree.sym=(ClassSymbol)result.tsym;
    return;
  }
  chk.compiled.put(c.flatname,c);
  enclScope.enter(c);
  Env<AttrContext> localEnv=classEnv(tree,env);
  typeEnvs.put(c,localEnv);
  c.completer=memberEnter;
  c.flags_field=chk.checkFlags(tree.pos(),tree.mods.flags,c,tree);
  c.sourcefile=env.toplevel.sourcefile;
  c.members_field=new Scope(c);
  ClassType ct=(ClassType)c.type;
  if (owner.kind != PCK && (c.flags_field & STATIC) == 0) {
    Symbol owner1=owner;
    while ((owner1.kind & (VAR | MTH)) != 0 && (owner1.flags_field & STATIC) == 0) {
      owner1=owner1.owner;
    }
    if (owner1.kind == TYP) {
      ct.setEnclosingType(owner1.type);
    }
  }
  ct.typarams_field=classEnter(tree.typarams,localEnv);
  if (!c.isLocal() && uncompleted != null)   uncompleted.append(c);
  classEnter(tree.defs,localEnv);
  result=c.type;
}"
72206,"public void visitTopLevel(JCCompilationUnit tree){
  JavaFileObject prev=log.useSource(tree.sourcefile);
  boolean addEnv=false;
  boolean isPkgInfo=tree.sourcefile.isNameCompatible(""String_Node_Str"",JavaFileObject.Kind.SOURCE);
  if (tree.pid != null) {
    tree.packge=reader.enterPackage(TreeInfo.fullName(tree.pid));
    if (tree.packageAnnotations.nonEmpty()) {
      if (isPkgInfo) {
        addEnv=true;
      }
 else {
        log.error(tree.packageAnnotations.head.pos(),""String_Node_Str"");
      }
    }
  }
 else {
    tree.packge=syms.unnamedPackage;
  }
  tree.packge.complete();
  Env<AttrContext> env=topLevelEnv(tree);
  if (isPkgInfo) {
    Env<AttrContext> env0=typeEnvs.get(tree.packge);
    if (env0 == null) {
      typeEnvs.put(tree.packge,env);
    }
 else {
      JCCompilationUnit tree0=env0.toplevel;
      if (!fileManager.isSameFile(tree.sourcefile,tree0.sourcefile)) {
        log.warning(tree.pid != null ? tree.pid.pos() : null,""String_Node_Str"",tree.packge);
        if (addEnv || (tree0.packageAnnotations.isEmpty() && tree.docComments != null && tree.docComments.get(tree) != null)) {
          typeEnvs.put(tree.packge,env);
        }
      }
    }
    for (Symbol q=tree.packge; q != null && q.kind == PCK; q=q.owner)     q.flags_field|=EXISTS;
    Name name=names.package_info;
    ClassSymbol c=reader.enterClass(name,tree.packge);
    c.flatname=names.fromString(tree.packge + ""String_Node_Str"" + name);
    c.sourcefile=tree.sourcefile;
    c.completer=null;
    c.members_field=new Scope(c);
    tree.packge.package_info=c;
  }
  classEnter(tree.defs,env);
  if (addEnv) {
    todo.append(env);
  }
  log.useSource(prev);
  result=null;
}","@Override public void visitTopLevel(JCCompilationUnit tree){
  JavaFileObject prev=log.useSource(tree.sourcefile);
  boolean addEnv=false;
  boolean isPkgInfo=tree.sourcefile.isNameCompatible(""String_Node_Str"",JavaFileObject.Kind.SOURCE);
  if (tree.pid != null) {
    tree.packge=reader.enterPackage(TreeInfo.fullName(tree.pid));
    if (tree.packageAnnotations.nonEmpty()) {
      if (isPkgInfo) {
        addEnv=true;
      }
 else {
        log.error(tree.packageAnnotations.head.pos(),""String_Node_Str"");
      }
    }
  }
 else {
    tree.packge=syms.unnamedPackage;
  }
  tree.packge.complete();
  Env<AttrContext> topEnv=topLevelEnv(tree);
  if (isPkgInfo) {
    Env<AttrContext> env0=typeEnvs.get(tree.packge);
    if (env0 == null) {
      typeEnvs.put(tree.packge,topEnv);
    }
 else {
      JCCompilationUnit tree0=env0.toplevel;
      if (!fileManager.isSameFile(tree.sourcefile,tree0.sourcefile)) {
        log.warning(tree.pid != null ? tree.pid.pos() : null,""String_Node_Str"",tree.packge);
        if (addEnv || (tree0.packageAnnotations.isEmpty() && tree.docComments != null && tree.docComments.get(tree) != null)) {
          typeEnvs.put(tree.packge,topEnv);
        }
      }
    }
    for (Symbol q=tree.packge; q != null && q.kind == PCK; q=q.owner)     q.flags_field|=EXISTS;
    Name name=names.package_info;
    ClassSymbol c=reader.enterClass(name,tree.packge);
    c.flatname=names.fromString(tree.packge + ""String_Node_Str"" + name);
    c.sourcefile=tree.sourcefile;
    c.completer=null;
    c.members_field=new Scope(c);
    tree.packge.package_info=c;
  }
  classEnter(tree.defs,topEnv);
  if (addEnv) {
    todo.append(topEnv);
  }
  log.useSource(prev);
  result=null;
}"
72207,"/** 
 * Class enter visitor method for type parameters. Enter a symbol for type parameter in local scope, after checking that it is unique.
 */
public void visitTypeParameter(JCTypeParameter tree){
  TypeVar a=(tree.type != null) ? (TypeVar)tree.type : new TypeVar(tree.name,env.info.scope.owner,syms.botType);
  tree.type=a;
  if (chk.checkUnique(tree.pos(),a.tsym,env.info.scope)) {
    env.info.scope.enter(a.tsym);
  }
  result=a;
}","/** 
 * Class enter visitor method for type parameters. Enter a symbol for type parameter in local scope, after checking that it is unique.
 */
@Override public void visitTypeParameter(JCTypeParameter tree){
  TypeVar a=(tree.type != null) ? (TypeVar)tree.type : new TypeVar(tree.name,env.info.scope.owner,syms.botType);
  tree.type=a;
  if (chk.checkUnique(tree.pos(),a.tsym,env.info.scope)) {
    env.info.scope.enter(a.tsym);
  }
  result=a;
}"
72208,"/** 
 * Main method: enter one class from a list of toplevel trees and place the rest on uncompleted for later processing.
 * @param trees      The list of trees to be processed.
 * @param c          The class symbol to be processed.
 */
public void complete(List<JCCompilationUnit> trees,ClassSymbol c){
  annotate.enterStart();
  ListBuffer<ClassSymbol> prevUncompleted=uncompleted;
  if (memberEnter.completionEnabled)   uncompleted=new ListBuffer<ClassSymbol>();
  try {
    classEnter(trees,null);
    if (memberEnter.completionEnabled) {
      while (uncompleted.nonEmpty()) {
        ClassSymbol clazz=uncompleted.next();
        if (c == null || c == clazz || prevUncompleted == null)         clazz.complete();
 else         prevUncompleted.append(clazz);
      }
      for (      JCCompilationUnit tree : trees) {
        if (tree.starImportScope.elems == null) {
          JavaFileObject prev=log.useSource(tree.sourcefile);
          Env<AttrContext> env=typeEnvs.get(tree);
          if (env == null)           env=topLevelEnv(tree);
          memberEnter.memberEnter(tree,env);
          log.useSource(prev);
        }
      }
    }
  }
  finally {
    uncompleted=prevUncompleted;
    annotate.enterDone();
  }
}","/** 
 * Main method: enter one class from a list of toplevel trees and place the rest on uncompleted for later processing.
 * @param trees      The list of trees to be processed.
 * @param c          The class symbol to be processed.
 */
public void complete(List<JCCompilationUnit> trees,ClassSymbol c){
  annotate.enterStart();
  ListBuffer<ClassSymbol> prevUncompleted=uncompleted;
  if (memberEnter.completionEnabled)   uncompleted=new ListBuffer<ClassSymbol>();
  try {
    classEnter(trees,null);
    if (memberEnter.completionEnabled) {
      while (uncompleted.nonEmpty()) {
        ClassSymbol clazz=uncompleted.next();
        if (c == null || c == clazz || prevUncompleted == null)         clazz.complete();
 else         prevUncompleted.append(clazz);
      }
      for (      JCCompilationUnit tree : trees) {
        if (tree.starImportScope.elems == null) {
          JavaFileObject prev=log.useSource(tree.sourcefile);
          Env<AttrContext> topEnv=topLevelEnv(tree);
          memberEnter.memberEnter(tree,topEnv);
          log.useSource(prev);
        }
      }
    }
  }
  finally {
    uncompleted=prevUncompleted;
    annotate.enterDone();
  }
}"
72209,"public void visitNewArray(JCNewArray tree){
  tree.elemtype=translate(tree.elemtype,null);
  translate(tree.dims,syms.intType);
  tree.elems=translate(tree.elems,(tree.type == null) ? null : erasure(types.elemtype(tree.type)));
  tree.type=erasure(tree.type);
  result=tree;
}","public void visitNewArray(JCNewArray tree){
  tree.elemtype=translate(tree.elemtype,null);
  translate(tree.dims,syms.intType);
  if (tree.type != null) {
    tree.elems=translate(tree.elems,erasure(types.elemtype(tree.type)));
    tree.type=erasure(tree.type);
  }
 else {
    tree.elems=translate(tree.elems,null);
  }
  result=tree;
}"
72210,"/** 
 * A KindName representing a given symbol
 */
public static KindName kindName(Symbol sym){
switch (sym.getKind()) {
case PACKAGE:
    return KindName.PACKAGE;
case ENUM:
case ANNOTATION_TYPE:
case INTERFACE:
case CLASS:
  return KindName.CLASS;
case TYPE_PARAMETER:
return KindName.TYPEVAR;
case ENUM_CONSTANT:
case FIELD:
case PARAMETER:
case LOCAL_VARIABLE:
case EXCEPTION_PARAMETER:
return KindName.VAR;
case METHOD:
case CONSTRUCTOR:
case STATIC_INIT:
case INSTANCE_INIT:
return KindName.METHOD;
default :
if (sym.kind == VAL) return KindName.VAL;
 else throw new AssertionError(""String_Node_Str"" + sym.getKind());
}
}","/** 
 * A KindName representing a given symbol
 */
public static KindName kindName(Symbol sym){
switch (sym.getKind()) {
case PACKAGE:
    return KindName.PACKAGE;
case ENUM:
  return KindName.ENUM;
case ANNOTATION_TYPE:
case CLASS:
return KindName.CLASS;
case INTERFACE:
return KindName.INTERFACE;
case TYPE_PARAMETER:
return KindName.TYPEVAR;
case ENUM_CONSTANT:
case FIELD:
case PARAMETER:
case LOCAL_VARIABLE:
case EXCEPTION_PARAMETER:
return KindName.VAR;
case CONSTRUCTOR:
return KindName.CONSTRUCTOR;
case METHOD:
case STATIC_INIT:
case INSTANCE_INIT:
return KindName.METHOD;
default :
if (sym.kind == VAL) return KindName.VAL;
 else throw new AssertionError(""String_Node_Str"" + sym.getKind());
}
}"
72211,"/** 
 * The number of errors reported so far.
 */
public int errorCount(){
  if (delegateCompiler != null && delegateCompiler != this)   return delegateCompiler.errorCount();
 else   return log.nerrors;
}","/** 
 * The number of errors reported so far.
 */
public int errorCount(){
  if (delegateCompiler != null && delegateCompiler != this)   return delegateCompiler.errorCount();
 else {
    if (werror && log.nerrors == 0 && log.nwarnings > 0) {
      log.error(""String_Node_Str"");
    }
  }
  return log.nerrors;
}"
72212,"/** 
 * Construct a new compiler using a shared context.
 */
public JavaCompiler(final Context context){
  this.context=context;
  context.put(compilerKey,this);
  if (context.get(JavaFileManager.class) == null)   JavacFileManager.preRegister(context);
  names=Names.instance(context);
  log=Log.instance(context);
  diagFactory=JCDiagnostic.Factory.instance(context);
  reader=ClassReader.instance(context);
  make=TreeMaker.instance(context);
  writer=ClassWriter.instance(context);
  enter=Enter.instance(context);
  todo=Todo.instance(context);
  fileManager=context.get(JavaFileManager.class);
  parserFactory=ParserFactory.instance(context);
  try {
    syms=Symtab.instance(context);
  }
 catch (  CompletionFailure ex) {
    log.error(""String_Node_Str"",ex.sym,ex.getDetailValue());
    if (ex instanceof ClassReader.BadClassFile)     throw new Abort();
  }
  source=Source.instance(context);
  attr=Attr.instance(context);
  chk=Check.instance(context);
  gen=Gen.instance(context);
  flow=Flow.instance(context);
  transTypes=TransTypes.instance(context);
  lower=Lower.instance(context);
  annotate=Annotate.instance(context);
  types=Types.instance(context);
  taskListener=context.get(TaskListener.class);
  reader.sourceCompleter=this;
  Options options=Options.instance(context);
  verbose=options.get(""String_Node_Str"") != null;
  sourceOutput=options.get(""String_Node_Str"") != null;
  stubOutput=options.get(""String_Node_Str"") != null;
  relax=options.get(""String_Node_Str"") != null;
  printFlat=options.get(""String_Node_Str"") != null;
  attrParseOnly=options.get(""String_Node_Str"") != null;
  encoding=options.get(""String_Node_Str"");
  lineDebugInfo=options.get(""String_Node_Str"") == null || options.get(""String_Node_Str"") != null;
  genEndPos=options.get(""String_Node_Str"") != null || context.get(DiagnosticListener.class) != null;
  devVerbose=options.get(""String_Node_Str"") != null;
  processPcks=options.get(""String_Node_Str"") != null;
  verboseCompilePolicy=options.get(""String_Node_Str"") != null;
  if (attrParseOnly)   compilePolicy=CompilePolicy.ATTR_ONLY;
 else   compilePolicy=CompilePolicy.decode(options.get(""String_Node_Str""));
  implicitSourcePolicy=ImplicitSourcePolicy.decode(options.get(""String_Node_Str""));
  completionFailureName=(options.get(""String_Node_Str"") != null) ? names.fromString(options.get(""String_Node_Str"")) : null;
}","/** 
 * Construct a new compiler using a shared context.
 */
public JavaCompiler(final Context context){
  this.context=context;
  context.put(compilerKey,this);
  if (context.get(JavaFileManager.class) == null)   JavacFileManager.preRegister(context);
  names=Names.instance(context);
  log=Log.instance(context);
  diagFactory=JCDiagnostic.Factory.instance(context);
  reader=ClassReader.instance(context);
  make=TreeMaker.instance(context);
  writer=ClassWriter.instance(context);
  enter=Enter.instance(context);
  todo=Todo.instance(context);
  fileManager=context.get(JavaFileManager.class);
  parserFactory=ParserFactory.instance(context);
  try {
    syms=Symtab.instance(context);
  }
 catch (  CompletionFailure ex) {
    log.error(""String_Node_Str"",ex.sym,ex.getDetailValue());
    if (ex instanceof ClassReader.BadClassFile)     throw new Abort();
  }
  source=Source.instance(context);
  attr=Attr.instance(context);
  chk=Check.instance(context);
  gen=Gen.instance(context);
  flow=Flow.instance(context);
  transTypes=TransTypes.instance(context);
  lower=Lower.instance(context);
  annotate=Annotate.instance(context);
  types=Types.instance(context);
  taskListener=context.get(TaskListener.class);
  reader.sourceCompleter=this;
  Options options=Options.instance(context);
  verbose=options.get(""String_Node_Str"") != null;
  sourceOutput=options.get(""String_Node_Str"") != null;
  stubOutput=options.get(""String_Node_Str"") != null;
  relax=options.get(""String_Node_Str"") != null;
  printFlat=options.get(""String_Node_Str"") != null;
  attrParseOnly=options.get(""String_Node_Str"") != null;
  encoding=options.get(""String_Node_Str"");
  lineDebugInfo=options.get(""String_Node_Str"") == null || options.get(""String_Node_Str"") != null;
  genEndPos=options.get(""String_Node_Str"") != null || context.get(DiagnosticListener.class) != null;
  devVerbose=options.get(""String_Node_Str"") != null;
  processPcks=options.get(""String_Node_Str"") != null;
  werror=options.get(""String_Node_Str"") != null;
  verboseCompilePolicy=options.get(""String_Node_Str"") != null;
  if (attrParseOnly)   compilePolicy=CompilePolicy.ATTR_ONLY;
 else   compilePolicy=CompilePolicy.decode(options.get(""String_Node_Str""));
  implicitSourcePolicy=ImplicitSourcePolicy.decode(options.get(""String_Node_Str""));
  completionFailureName=(options.get(""String_Node_Str"") != null) ? names.fromString(options.get(""String_Node_Str"")) : null;
}"
72213,"/** 
 * Programmatic interface for main function.
 * @param args    The command line parameters.
 */
public int compile(String[] args,Context context,List<JavaFileObject> fileObjects,Iterable<? extends Processor> processors){
  if (options == null)   options=Options.instance(context);
  filenames=new ListBuffer<File>();
  classnames=new ListBuffer<String>();
  JavaCompiler comp=null;
  try {
    if (args.length == 0 && fileObjects.isEmpty()) {
      help();
      return EXIT_CMDERR;
    }
    List<File> files;
    try {
      files=processArgs(CommandLine.parse(args));
      if (files == null) {
        return EXIT_CMDERR;
      }
 else       if (files.isEmpty() && fileObjects.isEmpty() && classnames.isEmpty()) {
        if (options.get(""String_Node_Str"") != null || options.get(""String_Node_Str"") != null || options.get(""String_Node_Str"") != null || options.get(""String_Node_Str"") != null)         return EXIT_OK;
        error(""String_Node_Str"");
        return EXIT_CMDERR;
      }
    }
 catch (    java.io.FileNotFoundException e) {
      Log.printLines(out,ownName + ""String_Node_Str"" + getLocalizedString(""String_Node_Str"",e.getMessage()));
      return EXIT_SYSERR;
    }
    boolean forceStdOut=options.get(""String_Node_Str"") != null;
    if (forceStdOut) {
      out.flush();
      out=new PrintWriter(System.out,true);
    }
    context.put(Log.outKey,out);
    boolean batchMode=(options.get(""String_Node_Str"") == null && System.getProperty(""String_Node_Str"") == null);
    if (batchMode)     CacheFSInfo.preRegister(context);
    fileManager=context.get(JavaFileManager.class);
    comp=JavaCompiler.instance(context);
    if (comp == null)     return EXIT_SYSERR;
    Log log=Log.instance(context);
    if (!files.isEmpty()) {
      comp=JavaCompiler.instance(context);
      List<JavaFileObject> otherFiles=List.nil();
      JavacFileManager dfm=(JavacFileManager)fileManager;
      for (      JavaFileObject fo : dfm.getJavaFileObjectsFromFiles(files))       otherFiles=otherFiles.prepend(fo);
      for (      JavaFileObject fo : otherFiles)       fileObjects=fileObjects.prepend(fo);
    }
    comp.compile(fileObjects,classnames.toList(),processors);
    if (log.expectDiagKeys != null) {
      if (log.expectDiagKeys.size() == 0) {
        Log.printLines(log.noticeWriter,""String_Node_Str"");
        return EXIT_OK;
      }
 else {
        Log.printLines(log.noticeWriter,""String_Node_Str"" + log.expectDiagKeys);
        return EXIT_ERROR;
      }
    }
    if (comp.errorCount() != 0 || options.get(""String_Node_Str"") != null && comp.warningCount() != 0)     return EXIT_ERROR;
  }
 catch (  IOException ex) {
    ioMessage(ex);
    return EXIT_SYSERR;
  }
catch (  OutOfMemoryError ex) {
    resourceMessage(ex);
    return EXIT_SYSERR;
  }
catch (  StackOverflowError ex) {
    resourceMessage(ex);
    return EXIT_SYSERR;
  }
catch (  FatalError ex) {
    feMessage(ex);
    return EXIT_SYSERR;
  }
catch (  AnnotationProcessingError ex) {
    apMessage(ex);
    return EXIT_SYSERR;
  }
catch (  ClientCodeException ex) {
    throw new RuntimeException(ex.getCause());
  }
catch (  PropagatedException ex) {
    throw ex.getCause();
  }
catch (  Throwable ex) {
    if (comp == null || comp.errorCount() == 0 || options == null || options.get(""String_Node_Str"") != null)     bugMessage(ex);
    return EXIT_ABNORMAL;
  }
 finally {
    if (comp != null)     comp.close();
    filenames=null;
    options=null;
  }
  return EXIT_OK;
}","/** 
 * Programmatic interface for main function.
 * @param args    The command line parameters.
 */
public int compile(String[] args,Context context,List<JavaFileObject> fileObjects,Iterable<? extends Processor> processors){
  if (options == null)   options=Options.instance(context);
  filenames=new ListBuffer<File>();
  classnames=new ListBuffer<String>();
  JavaCompiler comp=null;
  try {
    if (args.length == 0 && fileObjects.isEmpty()) {
      help();
      return EXIT_CMDERR;
    }
    List<File> files;
    try {
      files=processArgs(CommandLine.parse(args));
      if (files == null) {
        return EXIT_CMDERR;
      }
 else       if (files.isEmpty() && fileObjects.isEmpty() && classnames.isEmpty()) {
        if (options.get(""String_Node_Str"") != null || options.get(""String_Node_Str"") != null || options.get(""String_Node_Str"") != null || options.get(""String_Node_Str"") != null)         return EXIT_OK;
        error(""String_Node_Str"");
        return EXIT_CMDERR;
      }
    }
 catch (    java.io.FileNotFoundException e) {
      Log.printLines(out,ownName + ""String_Node_Str"" + getLocalizedString(""String_Node_Str"",e.getMessage()));
      return EXIT_SYSERR;
    }
    boolean forceStdOut=options.get(""String_Node_Str"") != null;
    if (forceStdOut) {
      out.flush();
      out=new PrintWriter(System.out,true);
    }
    context.put(Log.outKey,out);
    boolean batchMode=(options.get(""String_Node_Str"") == null && System.getProperty(""String_Node_Str"") == null);
    if (batchMode)     CacheFSInfo.preRegister(context);
    fileManager=context.get(JavaFileManager.class);
    comp=JavaCompiler.instance(context);
    if (comp == null)     return EXIT_SYSERR;
    Log log=Log.instance(context);
    if (!files.isEmpty()) {
      comp=JavaCompiler.instance(context);
      List<JavaFileObject> otherFiles=List.nil();
      JavacFileManager dfm=(JavacFileManager)fileManager;
      for (      JavaFileObject fo : dfm.getJavaFileObjectsFromFiles(files))       otherFiles=otherFiles.prepend(fo);
      for (      JavaFileObject fo : otherFiles)       fileObjects=fileObjects.prepend(fo);
    }
    comp.compile(fileObjects,classnames.toList(),processors);
    if (log.expectDiagKeys != null) {
      if (log.expectDiagKeys.size() == 0) {
        Log.printLines(log.noticeWriter,""String_Node_Str"");
        return EXIT_OK;
      }
 else {
        Log.printLines(log.noticeWriter,""String_Node_Str"" + log.expectDiagKeys);
        return EXIT_ERROR;
      }
    }
    if (comp.errorCount() != 0)     return EXIT_ERROR;
  }
 catch (  IOException ex) {
    ioMessage(ex);
    return EXIT_SYSERR;
  }
catch (  OutOfMemoryError ex) {
    resourceMessage(ex);
    return EXIT_SYSERR;
  }
catch (  StackOverflowError ex) {
    resourceMessage(ex);
    return EXIT_SYSERR;
  }
catch (  FatalError ex) {
    feMessage(ex);
    return EXIT_SYSERR;
  }
catch (  AnnotationProcessingError ex) {
    apMessage(ex);
    return EXIT_SYSERR;
  }
catch (  ClientCodeException ex) {
    throw new RuntimeException(ex.getCause());
  }
catch (  PropagatedException ex) {
    throw ex.getCause();
  }
catch (  Throwable ex) {
    if (comp == null || comp.errorCount() == 0 || options == null || options.get(""String_Node_Str"") != null)     bugMessage(ex);
    return EXIT_ABNORMAL;
  }
 finally {
    if (comp != null)     comp.close();
    filenames=null;
    options=null;
  }
  return EXIT_OK;
}"
72214,"/** 
 * Get all the recognized options.
 * @param helper an {@code OptionHelper} to help when processing options
 * @return an array of options
 */
public static Option[] getAll(final OptionHelper helper){
  return new Option[]{new Option(G,""String_Node_Str""),new Option(G_NONE,""String_Node_Str""){
    @Override public boolean process(    Options options,    String option){
      options.put(""String_Node_Str"",""String_Node_Str"");
      return false;
    }
  }
,new Option(G_CUSTOM,""String_Node_Str"",Option.ChoiceKind.ANYOF,""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),new XOption(XLINT,""String_Node_Str""),new XOption(XLINT_CUSTOM,""String_Node_Str"",Option.ChoiceKind.ANYOF,getXLintChoices()),new Option(NOWARN,""String_Node_Str""){
    @Override public boolean process(    Options options,    String option){
      options.put(""String_Node_Str"",option);
      return false;
    }
  }
,new Option(VERBOSE,""String_Node_Str""),new Option(DEPRECATION,""String_Node_Str""){
    @Override public boolean process(    Options options,    String option){
      options.put(""String_Node_Str"",option);
      return false;
    }
  }
,new Option(CLASSPATH,""String_Node_Str"",""String_Node_Str""),new Option(CP,""String_Node_Str"",""String_Node_Str""){
    @Override public boolean process(    Options options,    String option,    String arg){
      return super.process(options,""String_Node_Str"",arg);
    }
  }
,new Option(SOURCEPATH,""String_Node_Str"",""String_Node_Str""),new Option(BOOTCLASSPATH,""String_Node_Str"",""String_Node_Str""){
    @Override public boolean process(    Options options,    String option,    String arg){
      options.remove(""String_Node_Str"");
      options.remove(""String_Node_Str"");
      return super.process(options,option,arg);
    }
  }
,new XOption(XBOOTCLASSPATH_PREPEND,""String_Node_Str"",""String_Node_Str""),new XOption(XBOOTCLASSPATH_APPEND,""String_Node_Str"",""String_Node_Str""),new XOption(XBOOTCLASSPATH,""String_Node_Str"",""String_Node_Str""){
    @Override public boolean process(    Options options,    String option,    String arg){
      options.remove(""String_Node_Str"");
      options.remove(""String_Node_Str"");
      return super.process(options,""String_Node_Str"",arg);
    }
  }
,new Option(EXTDIRS,""String_Node_Str"",""String_Node_Str""),new XOption(DJAVA_EXT_DIRS,""String_Node_Str"",""String_Node_Str""){
    @Override public boolean process(    Options options,    String option,    String arg){
      return super.process(options,""String_Node_Str"",arg);
    }
  }
,new Option(ENDORSEDDIRS,""String_Node_Str"",""String_Node_Str""),new XOption(DJAVA_ENDORSED_DIRS,""String_Node_Str"",""String_Node_Str""){
    @Override public boolean process(    Options options,    String option,    String arg){
      return super.process(options,""String_Node_Str"",arg);
    }
  }
,new Option(PROC,""String_Node_Str"",Option.ChoiceKind.ONEOF,""String_Node_Str"",""String_Node_Str""),new Option(PROCESSOR,""String_Node_Str"",""String_Node_Str""),new Option(PROCESSORPATH,""String_Node_Str"",""String_Node_Str""),new Option(D,""String_Node_Str"",""String_Node_Str""),new Option(S,""String_Node_Str"",""String_Node_Str""),new Option(IMPLICIT,""String_Node_Str"",Option.ChoiceKind.ONEOF,""String_Node_Str"",""String_Node_Str""),new Option(ENCODING,""String_Node_Str"",""String_Node_Str""),new Option(SOURCE,""String_Node_Str"",""String_Node_Str""){
    @Override public boolean process(    Options options,    String option,    String operand){
      Source source=Source.lookup(operand);
      if (source == null) {
        helper.error(""String_Node_Str"",operand);
        return true;
      }
      return super.process(options,option,operand);
    }
  }
,new Option(TARGET,""String_Node_Str"",""String_Node_Str""){
    @Override public boolean process(    Options options,    String option,    String operand){
      Target target=Target.lookup(operand);
      if (target == null) {
        helper.error(""String_Node_Str"",operand);
        return true;
      }
      return super.process(options,option,operand);
    }
  }
,new Option(VERSION,""String_Node_Str""){
    @Override public boolean process(    Options options,    String option){
      helper.printVersion();
      return super.process(options,option);
    }
  }
,new HiddenOption(FULLVERSION){
    @Override public boolean process(    Options options,    String option){
      helper.printFullVersion();
      return super.process(options,option);
    }
  }
,new Option(HELP,""String_Node_Str""){
    @Override public boolean process(    Options options,    String option){
      helper.printHelp();
      return super.process(options,option);
    }
  }
,new Option(A,""String_Node_Str"",""String_Node_Str""){
    @Override String helpSynopsis(){
      hasSuffix=true;
      return super.helpSynopsis();
    }
    @Override public boolean matches(    String arg){
      return arg.startsWith(""String_Node_Str"");
    }
    @Override public boolean hasArg(){
      return false;
    }
    @Override public boolean process(    Options options,    String option){
      int argLength=option.length();
      if (argLength == 2) {
        helper.error(""String_Node_Str"");
        return true;
      }
      int sepIndex=option.indexOf('=');
      String key=option.substring(2,(sepIndex != -1 ? sepIndex : argLength));
      if (!JavacProcessingEnvironment.isValidOptionName(key)) {
        helper.error(""String_Node_Str"",option);
        return true;
      }
      return process(options,option,option);
    }
  }
,new Option(X,""String_Node_Str""){
    @Override public boolean process(    Options options,    String option){
      helper.printXhelp();
      return super.process(options,option);
    }
  }
,new Option(J,""String_Node_Str"",""String_Node_Str""){
    @Override String helpSynopsis(){
      hasSuffix=true;
      return super.helpSynopsis();
    }
    @Override public boolean process(    Options options,    String option){
      throw new AssertionError(""String_Node_Str"");
    }
  }
,new HiddenOption(MOREINFO){
    @Override public boolean process(    Options options,    String option){
      Type.moreInfo=true;
      return super.process(options,option);
    }
  }
,new HiddenOption(WERROR),new HiddenOption(COMPLEXINFERENCE),new HiddenOption(PROMPT),new HiddenOption(DOE),new HiddenOption(PRINTSOURCE),new HiddenOption(WARNUNCHECKED){
    @Override public boolean process(    Options options,    String option){
      options.put(""String_Node_Str"",option);
      return false;
    }
  }
,new XOption(XMAXERRS,""String_Node_Str"",""String_Node_Str""),new XOption(XMAXWARNS,""String_Node_Str"",""String_Node_Str""),new XOption(XSTDOUT,""String_Node_Str"",""String_Node_Str""){
    @Override public boolean process(    Options options,    String option,    String arg){
      try {
        helper.setOut(new PrintWriter(new FileWriter(arg),true));
      }
 catch (      java.io.IOException e) {
        helper.error(""String_Node_Str"",arg,e);
        return true;
      }
      return super.process(options,option,arg);
    }
  }
,new XOption(XPRINT,""String_Node_Str""),new XOption(XPRINTROUNDS,""String_Node_Str""),new XOption(XPRINTPROCESSORINFO,""String_Node_Str""),new XOption(XPREFER,""String_Node_Str"",Option.ChoiceKind.ONEOF,""String_Node_Str"",""String_Node_Str""),new HiddenOption(O),new HiddenOption(XJCOV),new HiddenOption(XD){
    String s;
    @Override public boolean matches(    String s){
      this.s=s;
      return s.startsWith(name.optionName);
    }
    @Override public boolean process(    Options options,    String option){
      s=s.substring(name.optionName.length());
      int eq=s.indexOf('=');
      String key=(eq < 0) ? s : s.substring(0,eq);
      String value=(eq < 0) ? s : s.substring(eq + 1);
      options.put(key,value);
      return false;
    }
  }
,new HiddenOption(SOURCEFILE){
    String s;
    @Override public boolean matches(    String s){
      this.s=s;
      return s.endsWith(""String_Node_Str"") || SourceVersion.isName(s);
    }
    @Override public boolean process(    Options options,    String option){
      if (s.endsWith(""String_Node_Str"")) {
        File f=new File(s);
        if (!f.exists()) {
          helper.error(""String_Node_Str"",f);
          return true;
        }
        if (!f.isFile()) {
          helper.error(""String_Node_Str"",f);
          return true;
        }
        helper.addFile(f);
      }
 else       helper.addClassName(s);
      return false;
    }
  }
};
}","/** 
 * Get all the recognized options.
 * @param helper an {@code OptionHelper} to help when processing options
 * @return an array of options
 */
public static Option[] getAll(final OptionHelper helper){
  return new Option[]{new Option(G,""String_Node_Str""),new Option(G_NONE,""String_Node_Str""){
    @Override public boolean process(    Options options,    String option){
      options.put(""String_Node_Str"",""String_Node_Str"");
      return false;
    }
  }
,new Option(G_CUSTOM,""String_Node_Str"",Option.ChoiceKind.ANYOF,""String_Node_Str"",""String_Node_Str"",""String_Node_Str""),new XOption(XLINT,""String_Node_Str""),new XOption(XLINT_CUSTOM,""String_Node_Str"",Option.ChoiceKind.ANYOF,getXLintChoices()),new Option(NOWARN,""String_Node_Str""){
    @Override public boolean process(    Options options,    String option){
      options.put(""String_Node_Str"",option);
      return false;
    }
  }
,new Option(VERBOSE,""String_Node_Str""),new Option(DEPRECATION,""String_Node_Str""){
    @Override public boolean process(    Options options,    String option){
      options.put(""String_Node_Str"",option);
      return false;
    }
  }
,new Option(CLASSPATH,""String_Node_Str"",""String_Node_Str""),new Option(CP,""String_Node_Str"",""String_Node_Str""){
    @Override public boolean process(    Options options,    String option,    String arg){
      return super.process(options,""String_Node_Str"",arg);
    }
  }
,new Option(SOURCEPATH,""String_Node_Str"",""String_Node_Str""),new Option(BOOTCLASSPATH,""String_Node_Str"",""String_Node_Str""){
    @Override public boolean process(    Options options,    String option,    String arg){
      options.remove(""String_Node_Str"");
      options.remove(""String_Node_Str"");
      return super.process(options,option,arg);
    }
  }
,new XOption(XBOOTCLASSPATH_PREPEND,""String_Node_Str"",""String_Node_Str""),new XOption(XBOOTCLASSPATH_APPEND,""String_Node_Str"",""String_Node_Str""),new XOption(XBOOTCLASSPATH,""String_Node_Str"",""String_Node_Str""){
    @Override public boolean process(    Options options,    String option,    String arg){
      options.remove(""String_Node_Str"");
      options.remove(""String_Node_Str"");
      return super.process(options,""String_Node_Str"",arg);
    }
  }
,new Option(EXTDIRS,""String_Node_Str"",""String_Node_Str""),new XOption(DJAVA_EXT_DIRS,""String_Node_Str"",""String_Node_Str""){
    @Override public boolean process(    Options options,    String option,    String arg){
      return super.process(options,""String_Node_Str"",arg);
    }
  }
,new Option(ENDORSEDDIRS,""String_Node_Str"",""String_Node_Str""),new XOption(DJAVA_ENDORSED_DIRS,""String_Node_Str"",""String_Node_Str""){
    @Override public boolean process(    Options options,    String option,    String arg){
      return super.process(options,""String_Node_Str"",arg);
    }
  }
,new Option(PROC,""String_Node_Str"",Option.ChoiceKind.ONEOF,""String_Node_Str"",""String_Node_Str""),new Option(PROCESSOR,""String_Node_Str"",""String_Node_Str""),new Option(PROCESSORPATH,""String_Node_Str"",""String_Node_Str""),new Option(D,""String_Node_Str"",""String_Node_Str""),new Option(S,""String_Node_Str"",""String_Node_Str""),new Option(IMPLICIT,""String_Node_Str"",Option.ChoiceKind.ONEOF,""String_Node_Str"",""String_Node_Str""),new Option(ENCODING,""String_Node_Str"",""String_Node_Str""),new Option(SOURCE,""String_Node_Str"",""String_Node_Str""){
    @Override public boolean process(    Options options,    String option,    String operand){
      Source source=Source.lookup(operand);
      if (source == null) {
        helper.error(""String_Node_Str"",operand);
        return true;
      }
      return super.process(options,option,operand);
    }
  }
,new Option(TARGET,""String_Node_Str"",""String_Node_Str""){
    @Override public boolean process(    Options options,    String option,    String operand){
      Target target=Target.lookup(operand);
      if (target == null) {
        helper.error(""String_Node_Str"",operand);
        return true;
      }
      return super.process(options,option,operand);
    }
  }
,new Option(VERSION,""String_Node_Str""){
    @Override public boolean process(    Options options,    String option){
      helper.printVersion();
      return super.process(options,option);
    }
  }
,new HiddenOption(FULLVERSION){
    @Override public boolean process(    Options options,    String option){
      helper.printFullVersion();
      return super.process(options,option);
    }
  }
,new Option(HELP,""String_Node_Str""){
    @Override public boolean process(    Options options,    String option){
      helper.printHelp();
      return super.process(options,option);
    }
  }
,new Option(A,""String_Node_Str"",""String_Node_Str""){
    @Override String helpSynopsis(){
      hasSuffix=true;
      return super.helpSynopsis();
    }
    @Override public boolean matches(    String arg){
      return arg.startsWith(""String_Node_Str"");
    }
    @Override public boolean hasArg(){
      return false;
    }
    @Override public boolean process(    Options options,    String option){
      int argLength=option.length();
      if (argLength == 2) {
        helper.error(""String_Node_Str"");
        return true;
      }
      int sepIndex=option.indexOf('=');
      String key=option.substring(2,(sepIndex != -1 ? sepIndex : argLength));
      if (!JavacProcessingEnvironment.isValidOptionName(key)) {
        helper.error(""String_Node_Str"",option);
        return true;
      }
      return process(options,option,option);
    }
  }
,new Option(X,""String_Node_Str""){
    @Override public boolean process(    Options options,    String option){
      helper.printXhelp();
      return super.process(options,option);
    }
  }
,new Option(J,""String_Node_Str"",""String_Node_Str""){
    @Override String helpSynopsis(){
      hasSuffix=true;
      return super.helpSynopsis();
    }
    @Override public boolean process(    Options options,    String option){
      throw new AssertionError(""String_Node_Str"");
    }
  }
,new HiddenOption(MOREINFO){
    @Override public boolean process(    Options options,    String option){
      Type.moreInfo=true;
      return super.process(options,option);
    }
  }
,new Option(WERROR,""String_Node_Str""),new HiddenOption(COMPLEXINFERENCE),new HiddenOption(PROMPT),new HiddenOption(DOE),new HiddenOption(PRINTSOURCE),new HiddenOption(WARNUNCHECKED){
    @Override public boolean process(    Options options,    String option){
      options.put(""String_Node_Str"",option);
      return false;
    }
  }
,new XOption(XMAXERRS,""String_Node_Str"",""String_Node_Str""),new XOption(XMAXWARNS,""String_Node_Str"",""String_Node_Str""),new XOption(XSTDOUT,""String_Node_Str"",""String_Node_Str""){
    @Override public boolean process(    Options options,    String option,    String arg){
      try {
        helper.setOut(new PrintWriter(new FileWriter(arg),true));
      }
 catch (      java.io.IOException e) {
        helper.error(""String_Node_Str"",arg,e);
        return true;
      }
      return super.process(options,option,arg);
    }
  }
,new XOption(XPRINT,""String_Node_Str""),new XOption(XPRINTROUNDS,""String_Node_Str""),new XOption(XPRINTPROCESSORINFO,""String_Node_Str""),new XOption(XPREFER,""String_Node_Str"",Option.ChoiceKind.ONEOF,""String_Node_Str"",""String_Node_Str""),new HiddenOption(O),new HiddenOption(XJCOV),new HiddenOption(XD){
    String s;
    @Override public boolean matches(    String s){
      this.s=s;
      return s.startsWith(name.optionName);
    }
    @Override public boolean process(    Options options,    String option){
      s=s.substring(name.optionName.length());
      int eq=s.indexOf('=');
      String key=(eq < 0) ? s : s.substring(0,eq);
      String value=(eq < 0) ? s : s.substring(eq + 1);
      options.put(key,value);
      return false;
    }
  }
,new HiddenOption(SOURCEFILE){
    String s;
    @Override public boolean matches(    String s){
      this.s=s;
      return s.endsWith(""String_Node_Str"") || SourceVersion.isName(s);
    }
    @Override public boolean process(    Options options,    String option){
      if (s.endsWith(""String_Node_Str"")) {
        File f=new File(s);
        if (!f.exists()) {
          helper.error(""String_Node_Str"",f);
          return true;
        }
        if (!f.isFile()) {
          helper.error(""String_Node_Str"",f);
          return true;
        }
        helper.addFile(f);
      }
 else       helper.addClassName(s);
      return false;
    }
  }
};
}"
72215,"/** 
 * Initializes an APRep object.
 * @param encoding a single DER-encoded value.
 * @exception Asn1Exception if an error occurs while decoding an ASN1 encoded data.
 * @exception IOException if an I/O error occurs while reading encoded data.
 * @exception KrbApErrException if the value read from the DER-encoded datastream does not match the pre-defined value.
 */
private void init(DerValue encoding) throws Asn1Exception, KrbApErrException, IOException {
  if (((encoding.getTag() & (byte)(0x1F)) != Krb5.KRB_AP_REP) || (encoding.isApplication() != true) || (encoding.isConstructed() != true))   throw new Asn1Exception(Krb5.ASN1_BAD_ID);
  DerValue der=encoding.getData().getDerValue();
  if (der.getTag() != DerValue.tag_Sequence)   throw new Asn1Exception(Krb5.ASN1_BAD_ID);
  DerValue subDer=der.getData().getDerValue();
  if ((subDer.getTag() & (byte)0x1F) != (byte)0x00)   throw new Asn1Exception(Krb5.ASN1_BAD_ID);
  pvno=subDer.getData().getBigInteger().intValue();
  if (pvno != Krb5.PVNO)   throw new KrbApErrException(Krb5.KRB_AP_ERR_BADVERSION);
  subDer=der.getData().getDerValue();
  if ((subDer.getTag() & (byte)0x1F) != (byte)0x01)   throw new Asn1Exception(Krb5.ASN1_BAD_ID);
  msgType=subDer.getData().getBigInteger().intValue();
  if (msgType != Krb5.KRB_AP_REP)   throw new KrbApErrException(Krb5.KRB_AP_ERR_MSG_TYPE);
  encPart=EncryptedData.parse(der.getData(),(byte)0x02,false);
  if (der.getData().available() > 0)   throw new Asn1Exception(Krb5.ASN1_BAD_ID);
}","/** 
 * Initializes an APRep object.
 * @param encoding a single DER-encoded value.
 * @exception Asn1Exception if an error occurs while decoding an ASN1 encoded data.
 * @exception IOException if an I/O error occurs while reading encoded data.
 * @exception KrbApErrException if the value read from the DER-encoded datastream does not match the pre-defined value.
 */
private void init(DerValue encoding) throws Asn1Exception, KrbApErrException, IOException {
  if (((encoding.getTag() & (byte)(0x1F)) != Krb5.KRB_AP_REP) || (encoding.isApplication() != true) || (encoding.isConstructed() != true)) {
    throw new Asn1Exception(Krb5.ASN1_BAD_ID);
  }
  DerValue der=encoding.getData().getDerValue();
  if (der.getTag() != DerValue.tag_Sequence) {
    throw new Asn1Exception(Krb5.ASN1_BAD_ID);
  }
  DerValue subDer=der.getData().getDerValue();
  if ((subDer.getTag() & (byte)0x1F) != (byte)0x00) {
    throw new Asn1Exception(Krb5.ASN1_BAD_ID);
  }
  pvno=subDer.getData().getBigInteger().intValue();
  if (pvno != Krb5.PVNO) {
    throw new KrbApErrException(Krb5.KRB_AP_ERR_BADVERSION);
  }
  subDer=der.getData().getDerValue();
  if ((subDer.getTag() & (byte)0x1F) != (byte)0x01) {
    throw new Asn1Exception(Krb5.ASN1_BAD_ID);
  }
  msgType=subDer.getData().getBigInteger().intValue();
  if (msgType != Krb5.KRB_AP_REP) {
    throw new KrbApErrException(Krb5.KRB_AP_ERR_MSG_TYPE);
  }
  encPart=EncryptedData.parse(der.getData(),(byte)0x02,false);
  if (der.getData().available() > 0) {
    throw new Asn1Exception(Krb5.ASN1_BAD_ID);
  }
}"
72216,"private void startWatchThread(){
  if (watch != null) {
    final String name=""String_Node_Str"" + id();
    watchThread=new Thread(new Runnable(){
      @Override public void run(){
        while (true) {
          try {
            StoreWatchKey key=(StoreWatchKey)watch.poll(6,TimeUnit.SECONDS);
            if (key == null)             continue;
            Object attachment=key.getAttachment();
            List<WatchEvent<?>> events=key.pollEvents();
            if (events != null) {
              for (              WatchEvent<?> event : events) {
                if (attachment != null && attachment instanceof EventHandler) {
                  ((EventHandler)attachment).handle(key,event);
                }
              }
            }
            key.reset();
          }
 catch (          ClosedWatchServiceException e) {
            LOG.warn(e.getMessage(),e);
            break;
          }
catch (          InterruptedException e) {
            LOG.warn(e.getMessage(),e);
            break;
          }
catch (          Exception e) {
            LOG.error(e.getMessage(),e);
          }
        }
        LOG.info(""String_Node_Str"",name);
      }
    }
,name);
    watchThread.setDaemon(true);
    watchThread.start();
    LOG.info(""String_Node_Str"",watchThread.getName());
  }
}","private void startWatchThread(){
  if (watch != null) {
    final String name=""String_Node_Str"" + id();
    watchThread=new Thread(new Runnable(){
      @Override public void run(){
        while (true) {
          try {
            StoreWatchKey key=(StoreWatchKey)watch.poll(6,TimeUnit.SECONDS);
            if (key == null)             continue;
            Object attachment=key.getAttachment();
            List<WatchEvent<?>> events=key.pollEvents();
            if (events != null) {
              for (              WatchEvent<?> event : events) {
                if (attachment != null && attachment instanceof EventHandler) {
                  ((EventHandler)attachment).handle(key,event);
                }
              }
            }
            key.reset();
          }
 catch (          ClosedWatchServiceException e) {
            LOG.warn(e.getMessage(),e);
            break;
          }
catch (          InterruptedException e) {
            break;
          }
catch (          Exception e) {
            LOG.error(e.getMessage(),e);
          }
        }
        watchLatch.countDown();
        LOG.info(""String_Node_Str"",name);
      }
    }
,name);
    watchThread.setDaemon(true);
    watchThread.start();
    LOG.info(""String_Node_Str"",watchThread.getName());
  }
}"
72217,"@Override public void run(){
  while (true) {
    try {
      StoreWatchKey key=(StoreWatchKey)watch.poll(6,TimeUnit.SECONDS);
      if (key == null)       continue;
      Object attachment=key.getAttachment();
      List<WatchEvent<?>> events=key.pollEvents();
      if (events != null) {
        for (        WatchEvent<?> event : events) {
          if (attachment != null && attachment instanceof EventHandler) {
            ((EventHandler)attachment).handle(key,event);
          }
        }
      }
      key.reset();
    }
 catch (    ClosedWatchServiceException e) {
      LOG.warn(e.getMessage(),e);
      break;
    }
catch (    InterruptedException e) {
      LOG.warn(e.getMessage(),e);
      break;
    }
catch (    Exception e) {
      LOG.error(e.getMessage(),e);
    }
  }
  LOG.info(""String_Node_Str"",name);
}","@Override public void run(){
  while (true) {
    try {
      StoreWatchKey key=(StoreWatchKey)watch.poll(6,TimeUnit.SECONDS);
      if (key == null)       continue;
      Object attachment=key.getAttachment();
      List<WatchEvent<?>> events=key.pollEvents();
      if (events != null) {
        for (        WatchEvent<?> event : events) {
          if (attachment != null && attachment instanceof EventHandler) {
            ((EventHandler)attachment).handle(key,event);
          }
        }
      }
      key.reset();
    }
 catch (    ClosedWatchServiceException e) {
      LOG.warn(e.getMessage(),e);
      break;
    }
catch (    InterruptedException e) {
      break;
    }
catch (    Exception e) {
      LOG.error(e.getMessage(),e);
    }
  }
  watchLatch.countDown();
  LOG.info(""String_Node_Str"",name);
}"
72218,"@Override public void close() throws IOException {
  if (dimit != null)   dimit.close();
  if (watch != null) {
    watch.close();
    watchThread.interrupt();
  }
  if (storeSystem != null)   storeSystem.close();
}","@Override public void close() throws IOException {
  if (dimit != null)   dimit.close();
  if (watch != null) {
    watch.close();
    watchThread.interrupt();
    try {
      watchLatch.await(10,TimeUnit.MICROSECONDS);
    }
 catch (    InterruptedException e) {
    }
  }
  if (storeSystem != null)   storeSystem.close();
}"
72219,"public void updateLimiter(){
  if (limiter == null) {
    limiter=RateLimiter.create(channel.getTps());
  }
 else {
    limiter.setRate(channel.getTps());
  }
}","public void updateLimiter(){
  if (limiter == null) {
    limiter=RateLimiter.create(channel.tps());
  }
 else {
    limiter.setRate(channel.tps());
  }
}"
72220,"public void setChannel(ChannelWrapper<V> channel){
  this.channel=channel;
  updateLimiter();
}","public void setChannel(ChannelWrapper<V> channel){
  this.channel=channel;
}"
72221,"public static final ChannelGroupWrapper init(Dimiter dimiter,String cid) throws IOException {
  DimitStoreSystem dss=dimiter.getStoreSystem();
  DimitPath dimitPath=dss.getPath(StoreConst.PATH_CONF,dimiter.getDimit().conf().getId());
  ChannelGroupWrapper group=new ChannelGroupWrapper(dimiter);
  group.conf=dimitPath.newPath(cid).<ChannelGroupConf>toStore();
  if (group.conf == null)   return null;
  long ct=System.currentTimeMillis();
  ChannelGroup store=ChannelGroup.newBuilder().setId(IDUtil.storeID(MagicFlag.CHANNEL_GROUP)).setCid(cid).setCt(ct).setMt(ct).setV(Const.V).build();
  group.store=store;
  return group;
}","public static final ChannelGroupWrapper init(Dimiter dimiter,String cid) throws IOException {
  DimitStoreSystem dss=dimiter.getStoreSystem();
  DimitPath dimitPath=dss.getPath(StoreConst.PATH_CONF,dimiter.getDimit().conf().getId());
  ChannelGroupWrapper group=new ChannelGroupWrapper(dimiter);
  group.conf=dimitPath.newPath(cid).<ChannelGroupConf>toStore(ChannelGroupConf.class);
  if (group.conf == null)   return null;
  long ct=System.currentTimeMillis();
  ChannelGroup store=ChannelGroup.newBuilder().setId(IDUtil.storeID(MagicFlag.CHANNEL_GROUP)).setCid(cid).setCt(ct).setMt(ct).setV(Const.V).build();
  group.store=store;
  return group;
}"
72222,"/** 
 * @param gid ChannelGroupConf's id
 * @param cid ChannelConf's id
 * @throws IOException
 */
public <T>void newChannel(String cid,ChannelType type,ChannelCallable<T> callable) throws IOException {
  ChannelWrapper<T> channel=ChannelWrapper.<T>init(dimiter,this.conf().getId(),cid,type,callable);
  if (channel == null)   throw new IOException(""String_Node_Str"" + cid);
  channel().add(channel);
}","/** 
 * @param gid ChannelGroupConf's id
 * @param cid ChannelConf's id
 * @return
 * @throws IOException
 */
public <T>ChannelWrapper<T> newChannel(String cid,ChannelType type,ChannelCallable<T> callable) throws IOException {
  ChannelWrapper<T> channel=ChannelWrapper.<T>init(dimiter,conf().getId(),cid,type,callable);
  if (channel == null)   throw new IOException(""String_Node_Str"" + cid);
  channel().add(channel);
  return channel;
}"
72223,"public static <T>ChannelWrapper<T> init(Dimiter dimiter,String gid,String cid,ChannelType type,ChannelCallable<T> callable) throws IOException {
  DimitStoreSystem dss=dimiter.getStoreSystem();
  DimitPath groupPath=dss.getPath(StoreConst.PATH_CONF,dimiter.getDimit().conf().getId(),gid);
  ChannelWrapper<T> channel=new ChannelWrapper<T>(dimiter,callable);
  channel.conf=groupPath.newPath(cid).<ChannelConf>toStore();
  if (channel.conf == null)   return null;
  DimitPath channelPath=dss.getPath(StoreConst.PATH_STORE,channel.conf.getId(),String.valueOf(type.getNumber()),channel.store.getId());
  List<DimitPath> children=channelPath.getParent().children();
  int childrenSize=children.size() + 1;
  long ct=System.currentTimeMillis();
  float tps=channel.conf.getTps();
  Channel store=Channel.newBuilder().setId(IDUtil.storeID(MagicFlag.CHANNEL)).setCid(cid).setCt(ct).setMt(ct).setTps(tps / childrenSize).setType(type).setV(Const.V).build();
  channel.store=store;
  channelPath=dss.<Channel>io().write(channelPath,store,StoreAttribute.EPHEMERAL);
  LOG.info(""String_Node_Str"",channelPath);
  if (type == ChannelType.SEND) {
    WatchKey key=channelPath.getParent().register(dimiter.watch(),new Kind<?>[]{StoreEventKind.CHILDREN},channel);
    channel.addWatchKey(key);
    key=groupPath.newPath(cid).register(dimiter.watch(),new Kind<?>[]{StoreEventKind.UPDATE},channel);
    channel.addWatchKey(key);
  }
  return channel;
}","public static <T>ChannelWrapper<T> init(Dimiter dimiter,String gid,String cid,ChannelType type,ChannelCallable<T> callable) throws IOException {
  DimitStoreSystem dss=dimiter.getStoreSystem();
  DimitPath groupPath=dss.getPath(StoreConst.PATH_CONF,dimiter.getDimit().conf().getId(),gid);
  ChannelWrapper<T> channel=new ChannelWrapper<T>(dimiter,callable);
  channel.conf=groupPath.newPath(cid).<ChannelConf>toStore(ChannelConf.class);
  if (channel.conf == null)   return null;
  DimitPath channelParentPath=dss.getPath(StoreConst.PATH_STORE,channel.conf.getId(),String.valueOf(type.getNumber()));
  List<DimitPath> children=channelParentPath.children();
  int childrenSize=children.size() + 1;
  long ct=System.currentTimeMillis();
  float tps=channel.conf.getTps();
  Channel store=Channel.newBuilder().setId(IDUtil.storeID(MagicFlag.CHANNEL)).setCid(cid).setCt(ct).setMt(ct).setTps(tps / childrenSize).setType(type).setV(Const.V).build();
  channel.store=store;
  DimitPath channelPath=channelParentPath.newPath(store.getId());
  channelPath=dss.<Channel>io().write(channelPath,store,StoreAttribute.EPHEMERAL);
  LOG.info(""String_Node_Str"",channelPath);
  if (type == ChannelType.SEND) {
    WatchKey key=channelPath.getParent().register(dimiter.watch(),new Kind<?>[]{StoreEventKind.CHILDREN},channel);
    channel.addWatchKey(key);
    key=groupPath.newPath(cid).register(dimiter.watch(),new Kind<?>[]{StoreEventKind.UPDATE},channel);
    channel.addWatchKey(key);
  }
  callable.updateLimiter();
  return channel;
}"
72224,"public boolean isValid(){
  return priority() >= 1;
}","public boolean isValid(){
  if (conf.getStatus().equals(ChannelStatus.CLOSED) || conf.getStatus().equals(ChannelStatus.INVALID))   return false;
  return tps() >= 1 && priority() >= 1;
}"
72225,"private ChannelConf newChannelConf(Dimiter dimiter,String gid,String cid) throws IOException {
  DimitStoreSystem dss=dimiter.getStoreSystem();
  DimitPath groupPath=dss.getPath(StoreConst.PATH_CONF,dimiter.getDimit().conf().getId(),gid);
  return groupPath.newPath(cid).<ChannelConf>toStore();
}","private ChannelConf newChannelConf(Dimiter dimiter,String gid,String cid) throws IOException {
  DimitStoreSystem dss=dimiter.getStoreSystem();
  DimitPath groupPath=dss.getPath(StoreConst.PATH_CONF,dimiter.getDimit().conf().getId(),gid);
  return groupPath.newPath(cid).<ChannelConf>toStore(ChannelConf.class);
}"
72226,"public int priority(){
  return (int)store.getTps();
}","public int priority(){
  return conf.getPriority();
}"
72227,"public static DimitWrapper init(Dimiter dimiter,String cid) throws IOException {
  DimitStoreSystem dss=dimiter.getStoreSystem();
  DimitPath pathConf=dss.getPath(StoreConst.PATH_CONF);
  DimitWrapper dimit=new DimitWrapper(dimiter);
  dimit.conf=pathConf.newPath(cid).<DimitConf>toStore();
  if (dimit.conf == null)   return null;
  long ct=System.currentTimeMillis();
  String[] pidHost=DimiterUtil.pidAndHost();
  Dimit store=Dimit.newBuilder().setId(IDUtil.storeID(MagicFlag.DIMIT)).setCid(cid).setCt(ct).setMt(ct).setHost(pidHost[1]).setIpv4(""String_Node_Str"").setIpv6(""String_Node_Str"").setName(dimit.conf.getName()).setPid(pidHost[0]).setRole(DimitRole.PARTNER).setV(Const.V).setStatus(DimitStatus.ONLINE).build();
  dimit.store=store;
  DimitPath dimitPath=dss.getPath(StoreConst.PATH_STORE,dimit.conf.getId(),dimit.store.getId());
  dimitPath=dss.<Dimit>io().write(dimitPath,store,StoreAttribute.EPHEMERAL);
  LOG.info(""String_Node_Str"",dimitPath);
  return dimit;
}","public static DimitWrapper init(Dimiter dimiter,String cid) throws IOException {
  DimitStoreSystem dss=dimiter.getStoreSystem();
  DimitPath pathConf=dss.getPath(StoreConst.PATH_CONF);
  DimitWrapper dimit=new DimitWrapper(dimiter);
  dimit.conf=pathConf.newPath(cid).<DimitConf>toStore(DimitConf.class);
  if (dimit.conf == null)   return null;
  long ct=System.currentTimeMillis();
  String[] pidHost=DimiterUtil.pidAndHost();
  Dimit store=Dimit.newBuilder().setId(IDUtil.storeID(MagicFlag.DIMIT)).setCid(cid).setCt(ct).setMt(ct).setHost(pidHost[1]).setIpv4(""String_Node_Str"").setIpv6(""String_Node_Str"").setName(dimit.conf.getName()).setPid(pidHost[0]).setRole(DimitRole.PARTNER).setV(Const.V).setStatus(DimitStatus.ONLINE).build();
  dimit.store=store;
  DimitPath dimitPath=dss.getPath(StoreConst.PATH_STORE,dimit.conf.getId(),dimit.store.getId());
  dimitPath=dss.<Dimit>io().write(dimitPath,store,StoreAttribute.EPHEMERAL);
  LOG.info(""String_Node_Str"",dimitPath);
  return dimit;
}"
72228,"/** 
 * @param cid ChannelGroupConf's id
 */
public void newChannelGroup(String cid) throws IOException {
  ChannelGroupWrapper group=ChannelGroupWrapper.init(this.dimiter,cid);
  if (group == null) {
    throw new IOException(""String_Node_Str"" + cid);
  }
  group().add(group);
}","/** 
 * @param cid ChannelGroupConf's id
 * @return
 */
public ChannelGroupWrapper newChannelGroup(String cid) throws IOException {
  ChannelGroupWrapper group=ChannelGroupWrapper.init(this.dimiter,cid);
  if (group == null) {
    throw new IOException(""String_Node_Str"" + cid);
  }
  group().add(group);
  return group;
}"
72229,"@Override public int compare(ChannelWrapper<?> o1,ChannelWrapper<?> o2){
  return o1.priority() - o2.priority();
}","@Override public int compare(ChannelWrapper<?> o1,ChannelWrapper<?> o2){
  int p=o1.priority() - o2.priority();
  if (p == 0) {
    p=(int)(o1.tps() - o2.tps());
  }
  return p == 0 ? o1.id().compareTo(o2.id()) : p;
}"
72230,"public String request(int sid,String msg){
  int playerIndex=0;
  for (int i=0; i < playerNum; i++) {
    if (allPlayers[i].SID == sid) {
      playerIndex=i;
      break;
    }
  }
  String result=""String_Node_Str"";
switch (gameState) {
case INIT:
    if (playerState[playerIndex] == 0) {
      result=GodHelper.toInit(allUserInfo,""String_Node_Str"",playerIndex,heroList);
      playerState[playerIndex]+=1;
    }
 else     if (playerState[playerIndex] == 1) {
      heroChoose(sid,msg);
      gameState=GameState.MAINGAME;
      playerState[playerIndex]=0;
      result=GodHelper.toChooseHero(""String_Node_Str"",heroChoices,teamResult);
    }
  break;
case MAINGAME:
switch (phaseState) {
case PREPARE:
  if (playerState[playerIndex] == 0) {
    wait_count=0;
    if (allPlayers[playerIndex].handCardsNum + 4 <= allPlayers[playerIndex].healthPoint)     GambleChecker.cardDistribute(cardHeap,allPlayers[playerIndex],4);
 else     GambleChecker.cardDistribute(cardHeap,allPlayers[playerIndex],allPlayers[playerIndex].healthPoint - allPlayers[playerIndex].handCardsNum);
    int[] playerHandCard=new int[allPlayers[playerIndex].handCardsNum];
    seenCardJudge(playerIndex,playerHandCard);
    for (int i=0; i < playerNum; i++) {
      if (map.distance[allPlayers[playerIndex].preLoc][allPlayers[i].preLoc] < allPlayers[playerIndex].range)       availableFireTarget[i]=1;
    }
    int[] availableMoveDirection=map.units[allPlayers[playerIndex].preLoc].availableDir();
    result=GodHelper.toCardDistribute(""String_Node_Str"",playerHandCard,availableFireTarget,availableMoveDirection);
    playerState[playerIndex]+=1;
  }
 else   if (playerState[playerIndex] == 1) {
    MsgChooseDecision dec=GodHelper.getChooseDecision(msg);
    if (dec.decision() == -1)     allPlayers[playerIndex].stratDecision=GambleChecker.DEPOSIT;
 else {
      allPlayers[playerIndex].stratDecision=allPlayers[playerIndex].handCards[dec.decision()];
      GambleChecker.cardToHeap(cardHeap,allPlayers[playerIndex].handCards[dec.decision()]);
      allPlayers[playerIndex].handCards[dec.decision()]=GambleChecker.NOTHING;
      GambleChecker.cardSort(allPlayers[playerIndex].handCards);
      allPlayers[playerIndex].handCardsNum-=1;
    }
    decisionChoices[playerIndex]=allPlayers[playerIndex].stratDecision;
    featureChoose(msg,allPlayers[playerIndex],playerIndex);
    int[] playerHandCard=new int[allPlayers[playerIndex].handCardsNum];
    for (int i=0; i < allPlayers[playerIndex].handCardsNum; i++)     playerHandCard[i]=allPlayers[playerIndex].handCards[i];
    if (allPlayers[playerIndex].isSeenCard)     result=GodHelper.toChooseDecision(""String_Node_Str"",playerHandCard);
 else     result=GodHelper.toChooseDecision(""String_Node_Str"",playerHandCard);
    playerState[playerIndex]+=1;
  }
 else   if (playerState[playerIndex] == 2) {
    seenCard(playerIndex,msg,allPlayers[playerIndex]);
    if (allPlayers[playerIndex].isSeenCard)     result=GodHelper.toSeenCard(""String_Node_Str"",decisionChoices,seenCardChoices);
 else     result=GodHelper.toSeenCard(""String_Node_Str"",decisionChoices,seenCardChoices);
    playerState[playerIndex]=0;
    phaseState=PhaseState.GAMBLE;
  }
break;
case GAMBLE:
if (playerState[playerIndex] == 0) {
gambleChoose(msg,allPlayers[playerIndex],playerIndex);
playerState[playerIndex]+=1;
int[] playerHandCard=new int[allPlayers[playerIndex].handCardsNum];
for (int i=0; i < allPlayers[playerIndex].handCardsNum; i++) playerHandCard[i]=allPlayers[playerIndex].handCards[i];
result=GodHelper.toChooseGamble(""String_Node_Str"",playerHandCard);
}
 else if (playerState[playerIndex] == 1) {
winJudge();
for (int i=0; i < playerNum; i++) {
  if (allPlayers[i].isWin)   playerWinList[i]=1;
}
playerState[playerIndex]=0;
phaseState=PhaseState.ACTION;
result=GodHelper.toWinJudge(""String_Node_Str"",gambleChoices,cardNumList,playerWinList,fireList);
}
break;
case ACTION:
if (playerState[playerIndex] == 0) {
String state;
if (humanWin) {
state=""String_Node_Str"";
playerState[playerIndex]=0;
gameState=GameState.END;
}
 else if (zombieWin) {
state=""String_Node_Str"";
playerState[playerIndex]=0;
gameState=GameState.END;
}
 else {
state=""String_Node_Str"";
playerState[playerIndex]+=1;
}
result=GodHelper.toAccount(state,energyList,healthPointList,locationList,elementList,teamList);
}
 else if (playerState[playerIndex] == 1) {
desertAccount(playerIndex,msg);
int[] playerHandCard=new int[allPlayers[playerIndex].handCardsNum];
for (int i=0; i < allPlayers[playerIndex].handCardsNum; i++) playerHandCard[i]=allPlayers[playerIndex].handCards[i];
result=GodHelper.toDesertAccount(""String_Node_Str"",allPlayers[playerIndex].energy,playerHandCard);
waitAllPlayers(playerIndex);
}
break;
}
break;
case END:
for (int i=0; i < playerNum; i++) playerSID[i]=allPlayers[i].SID;
SessionController.endGame(playerSID,scoreList);
result=GodHelper.toGameOver(""String_Node_Str"",scoreList);
break;
}
if (result.equals(""String_Node_Str"")) {
System.out.printf(""String_Node_Str"",sid,msg,gameState.toString());
}
return result;
}","public String request(int sid,String msg){
  int playerIndex=0;
  for (int i=0; i < playerNum; i++) {
    if (allPlayers[i].SID == sid) {
      playerIndex=i;
      break;
    }
  }
  String result=""String_Node_Str"";
switch (gameState) {
case INIT:
    if (playerState[playerIndex] == 0) {
      result=GodHelper.toInit(allUserInfo,""String_Node_Str"",playerIndex,heroList);
      playerState[playerIndex]+=1;
    }
 else     if (playerState[playerIndex] == 1) {
      heroChoose(sid,msg);
      gameState=GameState.MAINGAME;
      playerState[playerIndex]=0;
      result=GodHelper.toChooseHero(""String_Node_Str"",heroChoices,teamResult);
    }
  break;
case MAINGAME:
switch (phaseState) {
case PREPARE:
  if (playerState[playerIndex] == 0) {
    wait_count=0;
    if (allPlayers[playerIndex].handCardsNum + 4 <= allPlayers[playerIndex].healthPoint)     GambleChecker.cardDistribute(cardHeap,allPlayers[playerIndex],4);
 else     GambleChecker.cardDistribute(cardHeap,allPlayers[playerIndex],allPlayers[playerIndex].healthPoint - allPlayers[playerIndex].handCardsNum);
    int[] playerHandCard=new int[allPlayers[playerIndex].handCardsNum];
    seenCardJudge(playerIndex,playerHandCard);
    for (int i=0; i < playerNum; i++) {
      if (map.distance[allPlayers[playerIndex].preLoc][allPlayers[i].preLoc] < allPlayers[playerIndex].range)       availableFireTarget[i]=1;
    }
    int[] availableMoveDirection=map.units[allPlayers[playerIndex].preLoc].availableDir();
    result=GodHelper.toCardDistribute(""String_Node_Str"",playerHandCard,availableFireTarget,availableMoveDirection);
    playerState[playerIndex]+=1;
  }
 else   if (playerState[playerIndex] == 1) {
    MsgChooseDecision dec=GodHelper.getChooseDecision(msg);
    if (dec.decision() == -1)     allPlayers[playerIndex].stratDecision=GambleChecker.DEPOSIT;
 else {
      allPlayers[playerIndex].stratDecision=allPlayers[playerIndex].handCards[dec.decision()];
      GambleChecker.cardToHeap(cardHeap,allPlayers[playerIndex].handCards[dec.decision()]);
      allPlayers[playerIndex].handCards[dec.decision()]=GambleChecker.NOTHING;
      GambleChecker.cardSort(allPlayers[playerIndex].handCards);
      allPlayers[playerIndex].handCardsNum-=1;
    }
    decisionChoices[playerIndex]=allPlayers[playerIndex].stratDecision;
    featureChoose(msg,allPlayers[playerIndex],playerIndex);
    int[] playerHandCard=new int[allPlayers[playerIndex].handCardsNum];
    for (int i=0; i < allPlayers[playerIndex].handCardsNum; i++)     playerHandCard[i]=allPlayers[playerIndex].handCards[i];
    if (allPlayers[playerIndex].isSeenCard)     result=GodHelper.toChooseDecision(""String_Node_Str"",playerHandCard);
 else     result=GodHelper.toChooseDecision(""String_Node_Str"",playerHandCard);
    playerState[playerIndex]+=1;
  }
 else   if (playerState[playerIndex] == 2) {
    seenCard(playerIndex,msg,allPlayers[playerIndex]);
    if (allPlayers[playerIndex].isSeenCard)     result=GodHelper.toSeenCard(""String_Node_Str"",decisionChoices,seenCardChoices);
 else     result=GodHelper.toSeenCard(""String_Node_Str"",decisionChoices,seenCardChoices);
    playerState[playerIndex]=0;
    phaseState=PhaseState.GAMBLE;
  }
break;
case GAMBLE:
if (playerState[playerIndex] == 0) {
gambleChoose(msg,allPlayers[playerIndex],playerIndex);
playerState[playerIndex]+=1;
int[] playerHandCard=new int[allPlayers[playerIndex].handCardsNum];
for (int i=0; i < allPlayers[playerIndex].handCardsNum; i++) playerHandCard[i]=allPlayers[playerIndex].handCards[i];
result=GodHelper.toChooseGamble(""String_Node_Str"",playerHandCard);
}
 else if (playerState[playerIndex] == 1) {
winJudge();
for (int i=0; i < playerNum; i++) {
  if (allPlayers[i].isWin)   playerWinList[i]=1;
}
playerState[playerIndex]=0;
phaseState=PhaseState.ACTION;
result=GodHelper.toWinJudge(""String_Node_Str"",gambleChoices,cardNumList,playerWinList,fireList);
}
break;
case ACTION:
if (playerState[playerIndex] == 0) {
String state;
if (humanWin) {
state=""String_Node_Str"";
playerState[playerIndex]=0;
gameState=GameState.END;
}
 else if (zombieWin) {
state=""String_Node_Str"";
playerState[playerIndex]=0;
gameState=GameState.END;
}
 else {
state=""String_Node_Str"";
playerState[playerIndex]+=1;
}
result=GodHelper.toAccount(state,energyList,healthPointList,locationList,elementList,teamList);
}
 else if (playerState[playerIndex] == 1) {
desertAccount(playerIndex,msg);
int[] playerHandCard=new int[allPlayers[playerIndex].handCardsNum];
for (int i=0; i < allPlayers[playerIndex].handCardsNum; i++) playerHandCard[i]=allPlayers[playerIndex].handCards[i];
result=GodHelper.toDesertAccount(""String_Node_Str"",allPlayers[playerIndex].energy,playerHandCard);
waitAllPlayers(playerIndex);
}
break;
}
break;
case END:
int[] playerSID=new int[playerNum];
for (int i=0; i < playerNum; i++) playerSID[i]=allPlayers[i].SID;
SessionController.endGame(playerSID,scoreList);
result=GodHelper.toGameOver(""String_Node_Str"",scoreList);
break;
}
if (result.equals(""String_Node_Str"")) {
System.out.printf(""String_Node_Str"",sid,msg,gameState.toString());
}
return result;
}"
72231,"public void initialPlayer(int[] playerSID){
  playerNum=playerSID.length;
  allPlayers=new Player[playerNum];
  allUserInfo=new UserInfo[playerNum];
  playerState=new int[playerNum];
  map=new Map(""String_Node_Str"");
  heroChoices=new String[playerNum];
  teamResult=new int[playerNum];
  decisionChoices=new int[playerNum];
  seenCardChoices=new int[playerNum];
  cardHeap=new int[40 * playerNum];
  gambleChoices=new int[playerNum];
  cardNumList=new int[playerNum];
  playerWinList=new int[playerNum];
  energyList=new int[playerNum];
  healthPointList=new int[playerNum];
  locationList=new int[playerNum];
  elementList=new int[playerNum];
  teamList=new int[playerNum];
  availableFireTarget=new int[playerNum];
  scoreList=new int[playerNum];
  fireList=new int[playerNum];
  playerSID=new int[playerNum];
  for (int i=0; i < playerNum; i++) {
    allPlayers[i]=new Player();
    allPlayers[i].SID=playerSID[i];
    allPlayers[i].handCardsNum=0;
    allPlayers[i].healthPoint=6;
    allPlayers[i].mot=4;
    allPlayers[i].energy=0;
    allPlayers[i].handCards=new int[allPlayers[i].healthPoint + 4];
    allPlayers[i].fireTarget=-1;
    allPlayers[i].moveDirection=-1;
    playerState[i]=0;
    scoreList[i]=100;
    fireList[i]=-1;
    if (allPlayers[i].SID < 12) {
      allPlayers[i].user_info=GodHelper.ghostUser();
    }
 else {
      Option<UserModel.User> user=UserController.getProfile(playerSID[i]);
      if (user.isEmpty())       allPlayers[i].user_info=GodHelper.ghostUser();
 else       allPlayers[i].user_info=user.get();
    }
    allUserInfo[i]=new UserInfo(i,allPlayers[i].user_info.nickname());
  }
}","public void initialPlayer(int[] playerSID){
  playerNum=playerSID.length;
  allPlayers=new Player[playerNum];
  allUserInfo=new UserInfo[playerNum];
  playerState=new int[playerNum];
  map=new Map(""String_Node_Str"");
  heroChoices=new String[playerNum];
  teamResult=new int[playerNum];
  decisionChoices=new int[playerNum];
  seenCardChoices=new int[playerNum];
  cardHeap=new int[40 * playerNum];
  gambleChoices=new int[playerNum];
  cardNumList=new int[playerNum];
  playerWinList=new int[playerNum];
  energyList=new int[playerNum];
  healthPointList=new int[playerNum];
  locationList=new int[playerNum];
  elementList=new int[playerNum];
  teamList=new int[playerNum];
  availableFireTarget=new int[playerNum];
  scoreList=new int[playerNum];
  fireList=new int[playerNum];
  for (int i=0; i < playerNum; i++) {
    allPlayers[i]=new Player();
    allPlayers[i].SID=playerSID[i];
    allPlayers[i].handCardsNum=0;
    allPlayers[i].healthPoint=6;
    allPlayers[i].mot=4;
    allPlayers[i].energy=0;
    allPlayers[i].handCards=new int[allPlayers[i].healthPoint + 4];
    allPlayers[i].fireTarget=-1;
    allPlayers[i].moveDirection=-1;
    playerState[i]=0;
    scoreList[i]=100;
    fireList[i]=-1;
    if (allPlayers[i].SID < 12) {
      allPlayers[i].user_info=GodHelper.ghostUser();
    }
 else {
      Option<UserModel.User> user=UserController.getProfile(playerSID[i]);
      if (user.isEmpty())       allPlayers[i].user_info=GodHelper.ghostUser();
 else       allPlayers[i].user_info=user.get();
    }
    allUserInfo[i]=new UserInfo(i,allPlayers[i].user_info.nickname());
  }
}"
72232,"private void moveAccount(){
  for (int i=0; i < playerNum; i++) {
    if (allPlayers[i].moveDirection == -1)     continue;
    if (decisionChoices[i] == GambleChecker.MOVE) {
      allPlayers[i].preLoc=MapChecker.tryMove(map,allPlayers[i].preLoc,allPlayers[i].moveDirection,allPlayers[i].energyConsume);
    }
    locationList[i]=allPlayers[i].preLoc;
  }
}","private void moveAccount(){
  for (int i=0; i < playerNum; i++) {
    if (allPlayers[i].moveDirection == -1)     continue;
    if (decisionChoices[i] == GambleChecker.MOVE) {
      allPlayers[i].preLoc=MapChecker.tryMove(map,allPlayers[i].preLoc,allPlayers[i].moveDirection,allPlayers[i].energyConsume);
    }
  }
  for (int i=0; i < playerNum; i++)   locationList[i]=allPlayers[i].preLoc;
}"
72233,"private void fireAccount(){
  if (accountNum == 0) {
    for (int i=0; i < playerNum; i++) {
      if (allPlayers[i].stratDecision == GambleChecker.FIRE) {
        if (allPlayers[i].fireTarget == -1)         break;
        PlayerChecker.fire(map,allPlayers[i],allPlayers[allPlayers[i].fireTarget]);
      }
      healthPointList[i]=allPlayers[i].healthPoint;
    }
  }
  accountNum+=1;
}","private void fireAccount(){
  if (accountNum == 0) {
    for (int i=0; i < playerNum; i++) {
      if (allPlayers[i].fireTarget == -1)       continue;
      if (allPlayers[i].stratDecision == GambleChecker.FIRE) {
        PlayerChecker.fire(map,allPlayers[i],allPlayers[allPlayers[i].fireTarget]);
      }
    }
    for (int i=0; i < playerNum; i++)     healthPointList[i]=allPlayers[i].healthPoint;
  }
  accountNum+=1;
}"
72234,"public String request(int sid,String msg){
  int playerIndex=0;
  for (int i=0; i < playerNum; i++) {
    if (allPlayers[i].SID == sid) {
      playerIndex=i;
      break;
    }
  }
  String result=""String_Node_Str"";
switch (gameState) {
case INIT:
    if (playerState[playerIndex] == 0) {
      result=GodHelper.toInit(allUserInfo,""String_Node_Str"",playerIndex,heroList);
      playerState[playerIndex]+=1;
    }
 else     if (playerState[playerIndex] == 1) {
      heroChoose(sid,msg);
      gameState=GameState.MAINGAME;
      playerState[playerIndex]=0;
      result=GodHelper.toChooseHero(""String_Node_Str"",heroChoices,teamResult);
    }
  break;
case MAINGAME:
switch (phaseState) {
case PREPARE:
  if (playerState[playerIndex] == 0) {
    GambleChecker.cardDistribute(cardHeap,allPlayers[playerIndex],4);
    int[] playerHandCard=new int[allPlayers[playerIndex].handCardsNum];
    seenCardJudge(playerIndex,playerHandCard);
    for (int i=0; i < playerNum; i++) {
      if (map.distance[allPlayers[playerIndex].preLoc][allPlayers[i].preLoc] < allPlayers[playerIndex].range)       availableFireTarget[i]=1;
    }
    toDirection(playerIndex);
    result=GodHelper.toCardDistribute(""String_Node_Str"",playerHandCard,availableFireTarget,availableMoveDirection);
    playerState[playerIndex]+=1;
  }
 else   if (playerState[playerIndex] == 1) {
    MsgChooseDecision dec=GodHelper.getChooseDecision(msg);
    if (dec.decision() == -1)     allPlayers[playerIndex].stratDecision=GambleChecker.DEPOSIT;
 else {
      allPlayers[playerIndex].stratDecision=allPlayers[playerIndex].handCards[dec.decision()];
      GambleChecker.cardToHeap(cardHeap,dec.decision());
      allPlayers[playerIndex].handCards[dec.decision()]=GambleChecker.NOTHING;
      GambleChecker.cardSort(allPlayers[playerIndex].handCards);
      allPlayers[playerIndex].handCardsNum-=1;
    }
    decisionChoices[playerIndex]=allPlayers[playerIndex].stratDecision;
    featureChoose(msg,allPlayers[playerIndex],playerIndex);
    int[] playerHandCard=new int[allPlayers[playerIndex].handCardsNum];
    for (int i=0; i < allPlayers[playerIndex].handCardsNum; i++)     playerHandCard[i]=allPlayers[playerIndex].handCards[i];
    if (allPlayers[playerIndex].isSeenCard)     result=GodHelper.toChooseDecision(""String_Node_Str"",playerHandCard);
 else     result=GodHelper.toChooseDecision(""String_Node_Str"",playerHandCard);
    playerState[playerIndex]+=1;
  }
 else   if (playerState[playerIndex] == 2) {
    seenCard(playerIndex,msg,allPlayers[playerIndex]);
    if (allPlayers[playerIndex].isSeenCard)     result=GodHelper.toSeenCard(""String_Node_Str"",decisionChoices,seenCardChoices);
 else     result=GodHelper.toSeenCard(""String_Node_Str"",decisionChoices,seenCardChoices);
    playerState[playerIndex]=0;
    phaseState=PhaseState.GAMBLE;
  }
break;
case GAMBLE:
if (playerState[playerIndex] == 0) {
gambleChoose(msg,allPlayers[playerIndex],playerIndex);
playerState[playerIndex]+=1;
int[] playerHandCard=new int[allPlayers[playerIndex].handCardsNum];
for (int i=0; i < allPlayers[playerIndex].handCardsNum; i++) playerHandCard[i]=allPlayers[playerIndex].handCards[i];
result=GodHelper.toChooseGamble(""String_Node_Str"",playerHandCard);
}
 else if (playerState[playerIndex] == 1) {
winJudge();
for (int i=0; i < playerNum; i++) {
  if (allPlayers[i].isWin)   playerWinList[i]=1;
}
playerState[playerIndex]=0;
phaseState=PhaseState.ACTION;
result=GodHelper.toWinJudge(""String_Node_Str"",gambleChoices,cardNumList,playerWinList,fireList);
}
break;
case ACTION:
if (playerState[playerIndex] == 0) {
depositAccount();
result=GodHelper.toDepositAccount(""String_Node_Str"",energyList);
playerState[playerIndex]+=1;
}
 else if (playerState[playerIndex] == 1) {
skillsAccount();
result=GodHelper.toSkillsAccount(""String_Node_Str"");
playerState[playerIndex]+=1;
}
 else if (playerState[playerIndex] == 2) {
fireAccount();
result=GodHelper.toFireAccount(""String_Node_Str"",healthPointList);
playerState[playerIndex]+=1;
}
 else if (playerState[playerIndex] == 3) {
moveAccount();
result=GodHelper.toMoveAccount(""String_Node_Str"",locationList);
playerState[playerIndex]+=1;
}
 else if (playerState[playerIndex] == 4) {
elemAccount();
result=GodHelper.toElemAccount(""String_Node_Str"",elementList);
playerState[playerIndex]+=1;
}
 else if (playerState[playerIndex] == 5) {
humanVictory();
if (humanWin) {
result=GodHelper.toHumanVictory(""String_Node_Str"");
playerState[playerIndex]=0;
gameState=GameState.END;
}
 else {
result=GodHelper.toHumanVictory(""String_Node_Str"");
playerState[playerIndex]+=1;
}
}
 else if (playerState[playerIndex] == 6) {
infectionAccount();
if (zombieWin) {
result=GodHelper.toInfectionAccount(""String_Node_Str"",teamList);
playerState[playerIndex]=0;
gameState=GameState.END;
}
 else {
result=GodHelper.toInfectionAccount(""String_Node_Str"",teamList);
playerState[playerIndex]+=1;
}
}
 else if (playerState[playerIndex] == 7) {
desertAccount(playerIndex,msg);
int[] playerHandCard=new int[allPlayers[playerIndex].handCardsNum];
for (int i=0; i < allPlayers[playerIndex].handCardsNum; i++) playerHandCard[i]=allPlayers[playerIndex].handCards[i];
result=GodHelper.toDesertAccount(""String_Node_Str"",allPlayers[playerIndex].energy,playerHandCard);
playerState[playerIndex]+=1;
}
 else if (playerState[playerIndex] == 8) {
waitAllPlayers(playerIndex);
phaseState=PhaseState.PREPARE;
}
break;
}
break;
case END:
result=GodHelper.toGameOver(""String_Node_Str"",scoreList);
break;
}
if (result.equals(""String_Node_Str"")) {
System.out.printf(""String_Node_Str"",sid,msg,gameState.toString());
}
return result;
}","public String request(int sid,String msg){
  int playerIndex=0;
  for (int i=0; i < playerNum; i++) {
    if (allPlayers[i].SID == sid) {
      playerIndex=i;
      break;
    }
  }
  String result=""String_Node_Str"";
switch (gameState) {
case INIT:
    if (playerState[playerIndex] == 0) {
      result=GodHelper.toInit(allUserInfo,""String_Node_Str"",playerIndex,heroList);
      playerState[playerIndex]+=1;
    }
 else     if (playerState[playerIndex] == 1) {
      heroChoose(sid,msg);
      gameState=GameState.MAINGAME;
      playerState[playerIndex]=0;
      result=GodHelper.toChooseHero(""String_Node_Str"",heroChoices,teamResult);
    }
  break;
case MAINGAME:
switch (phaseState) {
case PREPARE:
  if (playerState[playerIndex] == 0) {
    wait_count=0;
    GambleChecker.cardDistribute(cardHeap,allPlayers[playerIndex],4);
    int[] playerHandCard=new int[allPlayers[playerIndex].handCardsNum];
    seenCardJudge(playerIndex,playerHandCard);
    for (int i=0; i < playerNum; i++) {
      if (map.distance[allPlayers[playerIndex].preLoc][allPlayers[i].preLoc] < allPlayers[playerIndex].range)       availableFireTarget[i]=1;
    }
    toDirection(playerIndex);
    result=GodHelper.toCardDistribute(""String_Node_Str"",playerHandCard,availableFireTarget,availableMoveDirection);
    playerState[playerIndex]+=1;
  }
 else   if (playerState[playerIndex] == 1) {
    MsgChooseDecision dec=GodHelper.getChooseDecision(msg);
    if (dec.decision() == -1)     allPlayers[playerIndex].stratDecision=GambleChecker.DEPOSIT;
 else {
      allPlayers[playerIndex].stratDecision=allPlayers[playerIndex].handCards[dec.decision()];
      GambleChecker.cardToHeap(cardHeap,dec.decision());
      allPlayers[playerIndex].handCards[dec.decision()]=GambleChecker.NOTHING;
      GambleChecker.cardSort(allPlayers[playerIndex].handCards);
      allPlayers[playerIndex].handCardsNum-=1;
    }
    decisionChoices[playerIndex]=allPlayers[playerIndex].stratDecision;
    featureChoose(msg,allPlayers[playerIndex],playerIndex);
    int[] playerHandCard=new int[allPlayers[playerIndex].handCardsNum];
    for (int i=0; i < allPlayers[playerIndex].handCardsNum; i++)     playerHandCard[i]=allPlayers[playerIndex].handCards[i];
    if (allPlayers[playerIndex].isSeenCard)     result=GodHelper.toChooseDecision(""String_Node_Str"",playerHandCard);
 else     result=GodHelper.toChooseDecision(""String_Node_Str"",playerHandCard);
    playerState[playerIndex]+=1;
  }
 else   if (playerState[playerIndex] == 2) {
    seenCard(playerIndex,msg,allPlayers[playerIndex]);
    if (allPlayers[playerIndex].isSeenCard)     result=GodHelper.toSeenCard(""String_Node_Str"",decisionChoices,seenCardChoices);
 else     result=GodHelper.toSeenCard(""String_Node_Str"",decisionChoices,seenCardChoices);
    playerState[playerIndex]=0;
    phaseState=PhaseState.GAMBLE;
  }
break;
case GAMBLE:
if (playerState[playerIndex] == 0) {
gambleChoose(msg,allPlayers[playerIndex],playerIndex);
playerState[playerIndex]+=1;
int[] playerHandCard=new int[allPlayers[playerIndex].handCardsNum];
for (int i=0; i < allPlayers[playerIndex].handCardsNum; i++) playerHandCard[i]=allPlayers[playerIndex].handCards[i];
result=GodHelper.toChooseGamble(""String_Node_Str"",playerHandCard);
}
 else if (playerState[playerIndex] == 1) {
winJudge();
for (int i=0; i < playerNum; i++) {
  if (allPlayers[i].isWin)   playerWinList[i]=1;
}
playerState[playerIndex]=0;
phaseState=PhaseState.ACTION;
result=GodHelper.toWinJudge(""String_Node_Str"",gambleChoices,cardNumList,playerWinList,fireList);
}
break;
case ACTION:
if (playerState[playerIndex] == 0) {
depositAccount();
result=GodHelper.toDepositAccount(""String_Node_Str"",energyList);
playerState[playerIndex]+=1;
}
 else if (playerState[playerIndex] == 1) {
skillsAccount();
result=GodHelper.toSkillsAccount(""String_Node_Str"");
playerState[playerIndex]+=1;
}
 else if (playerState[playerIndex] == 2) {
fireAccount();
result=GodHelper.toFireAccount(""String_Node_Str"",healthPointList);
playerState[playerIndex]+=1;
}
 else if (playerState[playerIndex] == 3) {
moveAccount();
result=GodHelper.toMoveAccount(""String_Node_Str"",locationList);
playerState[playerIndex]+=1;
}
 else if (playerState[playerIndex] == 4) {
elemAccount();
result=GodHelper.toElemAccount(""String_Node_Str"",elementList);
playerState[playerIndex]+=1;
}
 else if (playerState[playerIndex] == 5) {
humanVictory();
if (humanWin) {
result=GodHelper.toHumanVictory(""String_Node_Str"");
playerState[playerIndex]=0;
gameState=GameState.END;
}
 else {
result=GodHelper.toHumanVictory(""String_Node_Str"");
playerState[playerIndex]+=1;
}
}
 else if (playerState[playerIndex] == 6) {
infectionAccount();
if (zombieWin) {
result=GodHelper.toInfectionAccount(""String_Node_Str"",teamList);
playerState[playerIndex]=0;
gameState=GameState.END;
}
 else {
result=GodHelper.toInfectionAccount(""String_Node_Str"",teamList);
playerState[playerIndex]+=1;
}
}
 else if (playerState[playerIndex] == 7) {
desertAccount(playerIndex,msg);
int[] playerHandCard=new int[allPlayers[playerIndex].handCardsNum];
for (int i=0; i < allPlayers[playerIndex].handCardsNum; i++) playerHandCard[i]=allPlayers[playerIndex].handCards[i];
result=GodHelper.toDesertAccount(""String_Node_Str"",allPlayers[playerIndex].energy,playerHandCard);
waitAllPlayers(playerIndex);
}
break;
}
break;
case END:
result=GodHelper.toGameOver(""String_Node_Str"",scoreList);
break;
}
if (result.equals(""String_Node_Str"")) {
System.out.printf(""String_Node_Str"",sid,msg,gameState.toString());
}
return result;
}"
72235,"private void waitAllPlayers(int playerIndex){
synchronized (this) {
    wait_count+=1;
    if (wait_count < playerNum) {
      while (wait_count < playerNum) {
        try {
          this.wait();
        }
 catch (        Exception ex) {
          ex.printStackTrace();
        }
      }
    }
 else {
      playerState[playerIndex]=0;
      seen_card_count=0;
      gamble_count=0;
      desert_count=0;
      for (int i=0; i < playerNum; i++) {
        allPlayers[i].stratDecision=GambleChecker.DEPOSIT;
        allPlayers[i].fireTarget=-1;
        allPlayers[i].moveDirection=-1;
        availableFireTarget[i]=-1;
        availableMoveDirection[i]=-1;
        decisionChoices[i]=GambleChecker.DEPOSIT;
        seenCardChoices[i]=0;
        gambleChoices[i]=GambleChecker.PAPER;
        cardNumList[i]=0;
        playerWinList[i]=0;
        fireList[i]=-1;
      }
      this.notifyAll();
    }
  }
}","private void waitAllPlayers(int playerIndex){
synchronized (this) {
    playerState[playerIndex]=0;
    wait_count+=1;
    if (wait_count < playerNum) {
      while (wait_count < playerNum) {
        try {
          this.wait();
        }
 catch (        Exception ex) {
          ex.printStackTrace();
        }
      }
    }
 else {
      phaseState=PhaseState.PREPARE;
      seen_card_count=0;
      gamble_count=0;
      desert_count=0;
      for (int i=0; i < playerNum; i++) {
        allPlayers[i].stratDecision=GambleChecker.DEPOSIT;
        allPlayers[i].fireTarget=-1;
        allPlayers[i].moveDirection=-1;
        availableFireTarget[i]=-1;
        availableMoveDirection[i]=-1;
        decisionChoices[i]=GambleChecker.DEPOSIT;
        seenCardChoices[i]=0;
        gambleChoices[i]=GambleChecker.PAPER;
        cardNumList[i]=0;
        playerWinList[i]=0;
        fireList[i]=-1;
      }
      this.notifyAll();
    }
  }
}"
72236,"private void moveAccount(){
  if (accountNum == 0) {
    for (int i=0; i < playerNum; i++) {
      if (decisionChoices[i] == GambleChecker.MOVE) {
        if (allPlayers[i].moveDirection == -1)         break;
        allPlayers[i].preLoc=MapChecker.tryMove(map,allPlayers[i].preLoc,allPlayers[i].moveDirection,allPlayers[i].energyConsume);
      }
      locationList[i]=allPlayers[i].preLoc;
    }
  }
  accountNum+=1;
}","private void moveAccount(){
  if (accountNum == 0) {
    for (int i=0; i < playerNum; i++) {
      if (allPlayers[i].moveDirection == -1)       continue;
      if (decisionChoices[i] == GambleChecker.MOVE) {
        allPlayers[i].preLoc=MapChecker.tryMove(map,allPlayers[i].preLoc,allPlayers[i].moveDirection,allPlayers[i].energyConsume);
      }
      locationList[i]=allPlayers[i].preLoc;
    }
  }
  accountNum+=1;
}"
72237,"public String request(int sid,String msg){
  int playerIndex=0;
  for (int i=0; i < playerNum; i++) {
    if (allPlayers[i].SID == sid) {
      playerIndex=i;
      break;
    }
  }
  String result=""String_Node_Str"";
switch (gameState) {
case INIT:
    if (playerState[playerIndex] == 0) {
      result=GodHelper.toInit(allUserInfo,""String_Node_Str"",playerIndex,heroList);
      playerState[playerIndex]+=1;
    }
 else     if (playerState[playerIndex] == 1) {
      heroChoose(sid,msg);
      gameState=GameState.MAINGAME;
      playerState[playerIndex]=0;
      result=GodHelper.toChooseHero(""String_Node_Str"",heroChoices,teamResult);
    }
  break;
case MAINGAME:
switch (phaseState) {
case PREPARE:
  if (playerState[playerIndex] == 0) {
    wait_count=0;
    GambleChecker.cardDistribute(cardHeap,allPlayers[playerIndex],4);
    int[] playerHandCard=new int[allPlayers[playerIndex].handCardsNum];
    seenCardJudge(playerIndex,playerHandCard);
    for (int i=0; i < playerNum; i++) {
      if (map.distance[allPlayers[playerIndex].preLoc][allPlayers[i].preLoc] < allPlayers[playerIndex].range)       availableFireTarget[i]=1;
    }
    toDirection(playerIndex);
    result=GodHelper.toCardDistribute(""String_Node_Str"",playerHandCard,availableFireTarget,availableMoveDirection);
    playerState[playerIndex]+=1;
  }
 else   if (playerState[playerIndex] == 1) {
    MsgChooseDecision dec=GodHelper.getChooseDecision(msg);
    if (dec.decision() == -1)     allPlayers[playerIndex].stratDecision=GambleChecker.DEPOSIT;
 else {
      allPlayers[playerIndex].stratDecision=allPlayers[playerIndex].handCards[dec.decision()];
      GambleChecker.cardToHeap(cardHeap,dec.decision());
      allPlayers[playerIndex].handCards[dec.decision()]=GambleChecker.NOTHING;
      GambleChecker.cardSort(allPlayers[playerIndex].handCards);
      allPlayers[playerIndex].handCardsNum-=1;
    }
    decisionChoices[playerIndex]=allPlayers[playerIndex].stratDecision;
    featureChoose(msg,allPlayers[playerIndex],playerIndex);
    int[] playerHandCard=new int[allPlayers[playerIndex].handCardsNum];
    for (int i=0; i < allPlayers[playerIndex].handCardsNum; i++)     playerHandCard[i]=allPlayers[playerIndex].handCards[i];
    if (allPlayers[playerIndex].isSeenCard)     result=GodHelper.toChooseDecision(""String_Node_Str"",playerHandCard);
 else     result=GodHelper.toChooseDecision(""String_Node_Str"",playerHandCard);
    playerState[playerIndex]+=1;
  }
 else   if (playerState[playerIndex] == 2) {
    seenCard(playerIndex,msg,allPlayers[playerIndex]);
    if (allPlayers[playerIndex].isSeenCard)     result=GodHelper.toSeenCard(""String_Node_Str"",decisionChoices,seenCardChoices);
 else     result=GodHelper.toSeenCard(""String_Node_Str"",decisionChoices,seenCardChoices);
    playerState[playerIndex]=0;
    phaseState=PhaseState.GAMBLE;
  }
break;
case GAMBLE:
if (playerState[playerIndex] == 0) {
gambleChoose(msg,allPlayers[playerIndex],playerIndex);
playerState[playerIndex]+=1;
int[] playerHandCard=new int[allPlayers[playerIndex].handCardsNum];
for (int i=0; i < allPlayers[playerIndex].handCardsNum; i++) playerHandCard[i]=allPlayers[playerIndex].handCards[i];
result=GodHelper.toChooseGamble(""String_Node_Str"",playerHandCard);
}
 else if (playerState[playerIndex] == 1) {
winJudge();
for (int i=0; i < playerNum; i++) {
  if (allPlayers[i].isWin)   playerWinList[i]=1;
}
playerState[playerIndex]=0;
phaseState=PhaseState.ACTION;
result=GodHelper.toWinJudge(""String_Node_Str"",gambleChoices,cardNumList,playerWinList,fireList);
}
break;
case ACTION:
if (playerState[playerIndex] == 0) {
depositAccount();
result=GodHelper.toDepositAccount(""String_Node_Str"",energyList);
playerState[playerIndex]+=1;
}
 else if (playerState[playerIndex] == 1) {
skillsAccount();
result=GodHelper.toSkillsAccount(""String_Node_Str"");
playerState[playerIndex]+=1;
}
 else if (playerState[playerIndex] == 2) {
fireAccount();
result=GodHelper.toFireAccount(""String_Node_Str"",healthPointList);
playerState[playerIndex]+=1;
}
 else if (playerState[playerIndex] == 3) {
moveAccount();
result=GodHelper.toMoveAccount(""String_Node_Str"",locationList);
playerState[playerIndex]+=1;
}
 else if (playerState[playerIndex] == 4) {
elemAccount();
result=GodHelper.toElemAccount(""String_Node_Str"",elementList);
playerState[playerIndex]+=1;
}
 else if (playerState[playerIndex] == 5) {
humanVictory();
if (humanWin) {
result=GodHelper.toHumanVictory(""String_Node_Str"");
playerState[playerIndex]=0;
gameState=GameState.END;
}
 else {
result=GodHelper.toHumanVictory(""String_Node_Str"");
playerState[playerIndex]+=1;
}
}
 else if (playerState[playerIndex] == 6) {
infectionAccount();
if (zombieWin) {
result=GodHelper.toInfectionAccount(""String_Node_Str"",teamList);
playerState[playerIndex]=0;
gameState=GameState.END;
}
 else {
result=GodHelper.toInfectionAccount(""String_Node_Str"",teamList);
playerState[playerIndex]+=1;
}
}
 else if (playerState[playerIndex] == 7) {
desertAccount(playerIndex,msg);
int[] playerHandCard=new int[allPlayers[playerIndex].handCardsNum];
for (int i=0; i < allPlayers[playerIndex].handCardsNum; i++) playerHandCard[i]=allPlayers[playerIndex].handCards[i];
result=GodHelper.toDesertAccount(""String_Node_Str"",allPlayers[playerIndex].energy,playerHandCard);
waitAllPlayers(playerIndex);
}
break;
}
break;
case END:
result=GodHelper.toGameOver(""String_Node_Str"",scoreList);
break;
}
if (result.equals(""String_Node_Str"")) {
System.out.printf(""String_Node_Str"",sid,msg,gameState.toString());
}
return result;
}","public String request(int sid,String msg){
  int playerIndex=0;
  for (int i=0; i < playerNum; i++) {
    if (allPlayers[i].SID == sid) {
      playerIndex=i;
      break;
    }
  }
  String result=""String_Node_Str"";
switch (gameState) {
case INIT:
    if (playerState[playerIndex] == 0) {
      result=GodHelper.toInit(allUserInfo,""String_Node_Str"",playerIndex,heroList);
      playerState[playerIndex]+=1;
    }
 else     if (playerState[playerIndex] == 1) {
      heroChoose(sid,msg);
      gameState=GameState.MAINGAME;
      playerState[playerIndex]=0;
      result=GodHelper.toChooseHero(""String_Node_Str"",heroChoices,teamResult);
    }
  break;
case MAINGAME:
switch (phaseState) {
case PREPARE:
  if (playerState[playerIndex] == 0) {
    wait_count=0;
    GambleChecker.cardDistribute(cardHeap,allPlayers[playerIndex],4);
    int[] playerHandCard=new int[allPlayers[playerIndex].handCardsNum];
    seenCardJudge(playerIndex,playerHandCard);
    for (int i=0; i < playerNum; i++) {
      if (map.distance[allPlayers[playerIndex].preLoc][allPlayers[i].preLoc] < allPlayers[playerIndex].range)       availableFireTarget[i]=1;
    }
    toDirection(playerIndex);
    result=GodHelper.toCardDistribute(""String_Node_Str"",playerHandCard,availableFireTarget,availableMoveDirection);
    playerState[playerIndex]+=1;
  }
 else   if (playerState[playerIndex] == 1) {
    MsgChooseDecision dec=GodHelper.getChooseDecision(msg);
    if (dec.decision() == -1)     allPlayers[playerIndex].stratDecision=GambleChecker.DEPOSIT;
 else {
      allPlayers[playerIndex].stratDecision=allPlayers[playerIndex].handCards[dec.decision()];
      GambleChecker.cardToHeap(cardHeap,dec.decision());
      allPlayers[playerIndex].handCards[dec.decision()]=GambleChecker.NOTHING;
      GambleChecker.cardSort(allPlayers[playerIndex].handCards);
      allPlayers[playerIndex].handCardsNum-=1;
    }
    decisionChoices[playerIndex]=allPlayers[playerIndex].stratDecision;
    featureChoose(msg,allPlayers[playerIndex],playerIndex);
    int[] playerHandCard=new int[allPlayers[playerIndex].handCardsNum];
    for (int i=0; i < allPlayers[playerIndex].handCardsNum; i++)     playerHandCard[i]=allPlayers[playerIndex].handCards[i];
    if (allPlayers[playerIndex].isSeenCard)     result=GodHelper.toChooseDecision(""String_Node_Str"",playerHandCard);
 else     result=GodHelper.toChooseDecision(""String_Node_Str"",playerHandCard);
    playerState[playerIndex]+=1;
  }
 else   if (playerState[playerIndex] == 2) {
    seenCard(playerIndex,msg,allPlayers[playerIndex]);
    if (allPlayers[playerIndex].isSeenCard)     result=GodHelper.toSeenCard(""String_Node_Str"",decisionChoices,seenCardChoices);
 else     result=GodHelper.toSeenCard(""String_Node_Str"",decisionChoices,seenCardChoices);
    playerState[playerIndex]=0;
    phaseState=PhaseState.GAMBLE;
  }
break;
case GAMBLE:
if (playerState[playerIndex] == 0) {
gambleChoose(msg,allPlayers[playerIndex],playerIndex);
playerState[playerIndex]+=1;
int[] playerHandCard=new int[allPlayers[playerIndex].handCardsNum];
for (int i=0; i < allPlayers[playerIndex].handCardsNum; i++) playerHandCard[i]=allPlayers[playerIndex].handCards[i];
result=GodHelper.toChooseGamble(""String_Node_Str"",playerHandCard);
}
 else if (playerState[playerIndex] == 1) {
winJudge();
for (int i=0; i < playerNum; i++) {
  if (allPlayers[i].isWin)   playerWinList[i]=1;
}
playerState[playerIndex]=0;
phaseState=PhaseState.ACTION;
result=GodHelper.toWinJudge(""String_Node_Str"",gambleChoices,cardNumList,playerWinList,fireList);
}
break;
case ACTION:
if (playerState[playerIndex] == 0) {
depositAccount();
result=GodHelper.toDepositAccount(""String_Node_Str"",energyList);
playerState[playerIndex]+=1;
}
 else if (playerState[playerIndex] == 1) {
if (accountNum == playerNum) accountNum=0;
skillsAccount();
result=GodHelper.toSkillsAccount(""String_Node_Str"");
playerState[playerIndex]+=1;
}
 else if (playerState[playerIndex] == 2) {
if (accountNum == playerNum) accountNum=0;
fireAccount();
result=GodHelper.toFireAccount(""String_Node_Str"",healthPointList);
playerState[playerIndex]+=1;
}
 else if (playerState[playerIndex] == 3) {
if (accountNum == playerNum) accountNum=0;
moveAccount();
result=GodHelper.toMoveAccount(""String_Node_Str"",locationList);
playerState[playerIndex]+=1;
}
 else if (playerState[playerIndex] == 4) {
if (accountNum == 4) accountNum=0;
elemAccount();
result=GodHelper.toElemAccount(""String_Node_Str"",elementList);
playerState[playerIndex]+=1;
}
 else if (playerState[playerIndex] == 5) {
humanVictory();
if (humanWin) {
result=GodHelper.toHumanVictory(""String_Node_Str"");
playerState[playerIndex]=0;
gameState=GameState.END;
}
 else {
result=GodHelper.toHumanVictory(""String_Node_Str"");
playerState[playerIndex]+=1;
}
}
 else if (playerState[playerIndex] == 6) {
infectionAccount();
if (zombieWin) {
result=GodHelper.toInfectionAccount(""String_Node_Str"",teamList);
playerState[playerIndex]=0;
gameState=GameState.END;
}
 else {
result=GodHelper.toInfectionAccount(""String_Node_Str"",teamList);
playerState[playerIndex]+=1;
}
}
 else if (playerState[playerIndex] == 7) {
desertAccount(playerIndex,msg);
int[] playerHandCard=new int[allPlayers[playerIndex].handCardsNum];
for (int i=0; i < allPlayers[playerIndex].handCardsNum; i++) playerHandCard[i]=allPlayers[playerIndex].handCards[i];
result=GodHelper.toDesertAccount(""String_Node_Str"",allPlayers[playerIndex].energy,playerHandCard);
waitAllPlayers(playerIndex);
}
break;
}
break;
case END:
result=GodHelper.toGameOver(""String_Node_Str"",scoreList);
break;
}
if (result.equals(""String_Node_Str"")) {
System.out.printf(""String_Node_Str"",sid,msg,gameState.toString());
}
return result;
}"
72238,"private void fireAccount(){
  for (int i=0; i < playerNum; i++) {
    if (allPlayers[i].stratDecision == GambleChecker.FIRE) {
      if (allPlayers[i].fireTarget == -1)       break;
      PlayerChecker.fire(map,allPlayers[i],allPlayers[allPlayers[i].fireTarget]);
    }
    healthPointList[i]=allPlayers[i].healthPoint;
  }
}","private void fireAccount(){
  if (accountNum == 0) {
    for (int i=0; i < playerNum; i++) {
      if (allPlayers[i].stratDecision == GambleChecker.FIRE) {
        if (allPlayers[i].fireTarget == -1)         break;
        PlayerChecker.fire(map,allPlayers[i],allPlayers[allPlayers[i].fireTarget]);
      }
      healthPointList[i]=allPlayers[i].healthPoint;
    }
  }
  accountNum+=1;
}"
72239,"private void depositAccount(){
  for (int i=0; i < playerNum; i++) {
    PlayerChecker.energyConsume(allPlayers[i],allPlayers[i].energyConsume);
    if (allPlayers[i].isWin)     PlayerChecker.energyAcq(allPlayers[i],allPlayers[i].gambleNum);
    energyList[i]=allPlayers[i].energy;
  }
}","private void depositAccount(){
  if (accountNum == 0) {
    for (int i=0; i < playerNum; i++) {
      PlayerChecker.energyConsume(allPlayers[i],allPlayers[i].energyConsume);
      if (allPlayers[i].isWin)       PlayerChecker.energyAcq(allPlayers[i],allPlayers[i].gambleNum);
      energyList[i]=allPlayers[i].energy;
    }
  }
  accountNum+=1;
}"
72240,"private void moveAccount(){
  for (int i=0; i < playerNum; i++) {
    if (decisionChoices[i] == GambleChecker.MOVE) {
      if (allPlayers[i].moveDirection == -1)       break;
      allPlayers[i].preLoc=MapChecker.tryMove(map,allPlayers[i].preLoc,allPlayers[i].moveDirection,allPlayers[i].energyConsume);
    }
    locationList[i]=allPlayers[i].preLoc;
  }
}","private void moveAccount(){
  if (accountNum == 0) {
    for (int i=0; i < playerNum; i++) {
      if (decisionChoices[i] == GambleChecker.MOVE) {
        if (allPlayers[i].moveDirection == -1)         break;
        allPlayers[i].preLoc=MapChecker.tryMove(map,allPlayers[i].preLoc,allPlayers[i].moveDirection,allPlayers[i].energyConsume);
      }
      locationList[i]=allPlayers[i].preLoc;
    }
  }
  accountNum+=1;
}"
72241,"private void elemAccount(){
  int elemNum=0;
  for (int i=0; i < playerNum; i++) {
    if (map.units[allPlayers[i].preLoc].status == 2) {
      allPlayers[i].hasElem=true;
      elementList[i]=1;
      for (int j=0; j < playerNum; j++) {
        if (elementList[j] == 1)         elemNum+=1;
      }
    }
  }
}","private void elemAccount(){
  int elemNum=0;
  if (accountNum == 0) {
    for (int i=0; i < playerNum; i++) {
      if (map.units[allPlayers[i].preLoc].status == 2) {
        allPlayers[i].hasElem=true;
        elementList[i]=1;
        for (int j=0; j < playerNum; j++) {
          if (elementList[j] == 1)           elemNum+=1;
        }
      }
    }
  }
  accountNum+=1;
}"
72242,"private void infectionAccount(){
  for (int i=0; i < playerNum; i++) {
    for (int j=0; j < playerNum; j++) {
      PlayerChecker.infection(map,allPlayers[i],allPlayers[j]);
      if (PlayerChecker.infection(map,allPlayers[i],allPlayers[j]))       scoreList[i]+=25;
    }
  }
  for (int i=0; i < playerNum; i++)   teamList[i]=allPlayers[i].team;
  Boolean flag=true;
  for (int i=0; i < playerNum; i++) {
    if (allPlayers[i].team == Player.HUMAN)     flag=false;
  }
  if (flag)   zombieWin=true;
}","private void infectionAccount(){
  for (int i=0; i < playerNum; i++) {
    for (int j=0; j < playerNum; j++) {
      PlayerChecker.infection(map,allPlayers[i],allPlayers[j]);
    }
  }
  for (int i=0; i < playerNum; i++)   teamList[i]=allPlayers[i].team;
  Boolean flag=true;
  for (int i=0; i < playerNum; i++) {
    if (allPlayers[i].team == Player.HUMAN)     flag=false;
  }
  if (flag)   zombieWin=true;
}"
72243,"private void winJudge(){
synchronized (this) {
    gamble_count+=1;
    if (gamble_count < playerNum) {
      while (gamble_count < playerNum) {
        try {
          this.wait();
        }
 catch (        Exception ex) {
          ex.printStackTrace();
        }
      }
    }
 else {
      GambleChecker.winJudge(playerNum,allPlayers);
      for (int i=0; i < playerNum; i++) {
        if (allPlayers[i].isWin)         scoreList[i]+=5;
 else         scoreList[i]-=5;
      }
      this.notifyAll();
    }
  }
}","private void winJudge(){
synchronized (this) {
    gamble_count+=1;
    if (gamble_count < playerNum) {
      while (gamble_count < playerNum) {
        try {
          this.wait();
        }
 catch (        Exception ex) {
          ex.printStackTrace();
        }
      }
    }
 else {
      GambleChecker.winJudge(playerNum,allPlayers);
      this.notifyAll();
    }
  }
}"
72244,"public void initialPlayer(int[] playerSID){
  playerNum=playerSID.length;
  allPlayers=new Player[playerNum];
  allUserInfo=new UserInfo[playerNum];
  playerState=new int[playerNum];
  map=new Map(""String_Node_Str"");
  heroChoices=new String[playerNum];
  teamResult=new int[playerNum];
  decisionChoices=new int[playerNum];
  seenCardChoices=new int[playerNum];
  cardHeap=new int[40 * playerNum];
  gambleChoices=new int[playerNum];
  cardNumList=new int[playerNum];
  playerWinList=new int[playerNum];
  energyList=new int[playerNum];
  healthPointList=new int[playerNum];
  locationList=new int[playerNum];
  elementList=new int[playerNum];
  teamList=new int[playerNum];
  availableFireTarget=new int[playerNum];
  scoreList=new int[playerNum];
  availableMoveDirection=new int[8];
  fireList=new int[playerNum];
  for (int i=0; i < playerNum; i++) {
    allPlayers[i]=new Player();
    allPlayers[i].SID=playerSID[i];
    allPlayers[i].handCardsNum=0;
    allPlayers[i].healthPoint=6;
    allPlayers[i].mot=4;
    allPlayers[i].handCards=new int[allPlayers[i].healthPoint + 4];
    allPlayers[i].fireTarget=-1;
    allPlayers[i].moveDirection=-1;
    playerState[i]=0;
    scoreList[i]=100;
    fireList[i]=-1;
    Option<UserModel.User> user=UserController.getProfile(playerSID[i]);
    if (user.isEmpty())     allPlayers[i].user_info=GodHelper.ghostUser();
 else     allPlayers[i].user_info=user.get();
    allUserInfo[i]=new UserInfo(i,allPlayers[i].user_info.nickname());
  }
}","public void initialPlayer(int[] playerSID){
  playerNum=playerSID.length;
  allPlayers=new Player[playerNum];
  allUserInfo=new UserInfo[playerNum];
  playerState=new int[playerNum];
  map=new Map(""String_Node_Str"");
  heroChoices=new String[playerNum];
  teamResult=new int[playerNum];
  decisionChoices=new int[playerNum];
  seenCardChoices=new int[playerNum];
  cardHeap=new int[40 * playerNum];
  gambleChoices=new int[playerNum];
  cardNumList=new int[playerNum];
  playerWinList=new int[playerNum];
  energyList=new int[playerNum];
  healthPointList=new int[playerNum];
  locationList=new int[playerNum];
  elementList=new int[playerNum];
  teamList=new int[playerNum];
  availableFireTarget=new int[playerNum];
  scoreList=new int[playerNum];
  availableMoveDirection=new int[8];
  fireList=new int[playerNum];
  for (int i=0; i < playerNum; i++) {
    allPlayers[i]=new Player();
    allPlayers[i].SID=playerSID[i];
    allPlayers[i].handCardsNum=0;
    allPlayers[i].healthPoint=6;
    allPlayers[i].mot=4;
    allPlayers[i].energy=0;
    allPlayers[i].handCards=new int[allPlayers[i].healthPoint + 4];
    allPlayers[i].fireTarget=-1;
    allPlayers[i].moveDirection=-1;
    playerState[i]=0;
    scoreList[i]=100;
    fireList[i]=-1;
    Option<UserModel.User> user=UserController.getProfile(playerSID[i]);
    if (user.isEmpty())     allPlayers[i].user_info=GodHelper.ghostUser();
 else     allPlayers[i].user_info=user.get();
    allUserInfo[i]=new UserInfo(i,allPlayers[i].user_info.nickname());
  }
}"
72245,"private void fireAccount(){
  for (int i=0; i < playerNum; i++) {
    if (allPlayers[i].stratDecision == GambleChecker.FIRE)     PlayerChecker.fire(map,allPlayers[i],allPlayers[allPlayers[i].fireTarget]);
    healthPointList[i]=allPlayers[i].healthPoint;
  }
}","private void fireAccount(){
  for (int i=0; i < playerNum; i++) {
    if (allPlayers[i].stratDecision == GambleChecker.FIRE) {
      if (allPlayers[i].fireTarget == -1)       break;
      PlayerChecker.fire(map,allPlayers[i],allPlayers[allPlayers[i].fireTarget]);
    }
    healthPointList[i]=allPlayers[i].healthPoint;
  }
}"
72246,"private void elemAccount(){
  int elemNum=0;
  for (int i=0; i < playerNum; i++) {
    if (map.units[allPlayers[i].preLoc].status == 2) {
      allPlayers[i].hasElem=true;
      elementList[i]=1;
      for (int j=0; j < playerNum; j++) {
        if (elementList[j] == 1)         elemNum+=1;
      }
      scoreList[i]+=elemNum * 25;
    }
  }
}","private void elemAccount(){
  int elemNum=0;
  for (int i=0; i < playerNum; i++) {
    if (map.units[allPlayers[i].preLoc].status == 2) {
      allPlayers[i].hasElem=true;
      elementList[i]=1;
      for (int j=0; j < playerNum; j++) {
        if (elementList[j] == 1)         elemNum+=1;
      }
    }
  }
}"
72247,"private void moveAccount(){
  for (int i=0; i < playerNum; i++) {
    if (decisionChoices[i] == GambleChecker.MOVE)     allPlayers[i].preLoc=MapChecker.tryMove(map,allPlayers[i].preLoc,allPlayers[i].moveDirection,allPlayers[i].energyConsume);
    locationList[i]=allPlayers[i].preLoc;
  }
}","private void moveAccount(){
  for (int i=0; i < playerNum; i++) {
    if (decisionChoices[i] == GambleChecker.MOVE) {
      if (allPlayers[i].moveDirection == -1)       break;
      allPlayers[i].preLoc=MapChecker.tryMove(map,allPlayers[i].preLoc,allPlayers[i].moveDirection,allPlayers[i].energyConsume);
    }
    locationList[i]=allPlayers[i].preLoc;
  }
}"
72248,"private void toDirection(int playerIndex){
  if (allPlayers[playerIndex].preLoc == 0) {
    availableMoveDirection[0]=0;
    availableMoveDirection[1]=0;
    availableMoveDirection[2]=0;
    availableMoveDirection[3]=0;
    availableMoveDirection[4]=0;
    availableMoveDirection[5]=0;
    availableMoveDirection[6]=0;
    availableMoveDirection[7]=1;
  }
 else   if (allPlayers[playerIndex].preLoc == 1) {
    availableMoveDirection[0]=0;
    availableMoveDirection[1]=1;
    availableMoveDirection[2]=0;
    availableMoveDirection[3]=0;
    availableMoveDirection[4]=0;
    availableMoveDirection[5]=0;
    availableMoveDirection[6]=0;
    availableMoveDirection[7]=0;
  }
 else   if (allPlayers[playerIndex].preLoc == 6) {
    availableMoveDirection[0]=0;
    availableMoveDirection[1]=0;
    availableMoveDirection[2]=0;
    availableMoveDirection[3]=1;
    availableMoveDirection[4]=0;
    availableMoveDirection[5]=1;
    availableMoveDirection[6]=0;
    availableMoveDirection[7]=0;
  }
 else   if (allPlayers[playerIndex].preLoc == 7) {
    availableMoveDirection[0]=1;
    availableMoveDirection[1]=0;
    availableMoveDirection[2]=0;
    availableMoveDirection[3]=1;
    availableMoveDirection[4]=0;
    availableMoveDirection[5]=0;
    availableMoveDirection[6]=0;
    availableMoveDirection[7]=1;
  }
 else   if (allPlayers[playerIndex].preLoc == 8) {
    availableMoveDirection[0]=0;
    availableMoveDirection[1]=1;
    availableMoveDirection[2]=0;
    availableMoveDirection[3]=0;
    availableMoveDirection[4]=1;
    availableMoveDirection[5]=0;
    availableMoveDirection[6]=0;
    availableMoveDirection[7]=0;
  }
 else   if (allPlayers[playerIndex].preLoc == 23) {
    availableMoveDirection[0]=0;
    availableMoveDirection[1]=1;
    availableMoveDirection[2]=0;
    availableMoveDirection[3]=0;
    availableMoveDirection[4]=0;
    availableMoveDirection[5]=0;
    availableMoveDirection[6]=0;
    availableMoveDirection[7]=1;
  }
 else   if (allPlayers[playerIndex].preLoc == 11) {
    availableMoveDirection[0]=0;
    availableMoveDirection[1]=0;
    availableMoveDirection[2]=0;
    availableMoveDirection[3]=0;
    availableMoveDirection[4]=0;
    availableMoveDirection[5]=1;
    availableMoveDirection[6]=0;
    availableMoveDirection[7]=1;
  }
 else   if (allPlayers[playerIndex].preLoc == 12) {
    availableMoveDirection[0]=0;
    availableMoveDirection[1]=1;
    availableMoveDirection[2]=0;
    availableMoveDirection[3]=1;
    availableMoveDirection[4]=0;
    availableMoveDirection[5]=0;
    availableMoveDirection[6]=0;
    availableMoveDirection[7]=0;
  }
 else   if (allPlayers[playerIndex].preLoc == 14) {
    availableMoveDirection[0]=0;
    availableMoveDirection[1]=0;
    availableMoveDirection[2]=0;
    availableMoveDirection[3]=1;
    availableMoveDirection[4]=0;
    availableMoveDirection[5]=1;
    availableMoveDirection[6]=0;
    availableMoveDirection[7]=0;
  }
 else   if (allPlayers[playerIndex].preLoc == 15) {
    availableMoveDirection[0]=0;
    availableMoveDirection[1]=0;
    availableMoveDirection[2]=0;
    availableMoveDirection[3]=1;
    availableMoveDirection[4]=0;
    availableMoveDirection[5]=0;
    availableMoveDirection[6]=0;
    availableMoveDirection[7]=1;
  }
 else   if (allPlayers[playerIndex].preLoc == 16) {
    availableMoveDirection[0]=0;
    availableMoveDirection[1]=0;
    availableMoveDirection[2]=0;
    availableMoveDirection[3]=1;
    availableMoveDirection[4]=0;
    availableMoveDirection[5]=0;
    availableMoveDirection[6]=0;
    availableMoveDirection[7]=1;
  }
 else   if (allPlayers[playerIndex].preLoc == 17) {
    availableMoveDirection[0]=0;
    availableMoveDirection[1]=0;
    availableMoveDirection[2]=0;
    availableMoveDirection[3]=0;
    availableMoveDirection[4]=0;
    availableMoveDirection[5]=1;
    availableMoveDirection[6]=0;
    availableMoveDirection[7]=1;
  }
 else   if (allPlayers[playerIndex].preLoc == 24) {
    availableMoveDirection[0]=0;
    availableMoveDirection[1]=0;
    availableMoveDirection[2]=0;
    availableMoveDirection[3]=1;
    availableMoveDirection[4]=0;
    availableMoveDirection[5]=0;
    availableMoveDirection[6]=0;
    availableMoveDirection[7]=1;
  }
 else {
    availableMoveDirection[0]=0;
    availableMoveDirection[1]=1;
    availableMoveDirection[2]=0;
    availableMoveDirection[3]=0;
    availableMoveDirection[4]=0;
    availableMoveDirection[5]=1;
    availableMoveDirection[6]=0;
    availableMoveDirection[7]=0;
  }
}","private void toDirection(int playerIndex){
  if (allPlayers[playerIndex].preLoc == 0) {
    availableMoveDirection[0]=0;
    availableMoveDirection[1]=0;
    availableMoveDirection[2]=0;
    availableMoveDirection[3]=0;
    availableMoveDirection[4]=0;
    availableMoveDirection[5]=0;
    availableMoveDirection[6]=0;
    availableMoveDirection[7]=1;
  }
 else   if (allPlayers[playerIndex].preLoc == 1) {
    availableMoveDirection[0]=0;
    availableMoveDirection[1]=1;
    availableMoveDirection[2]=0;
    availableMoveDirection[3]=0;
    availableMoveDirection[4]=0;
    availableMoveDirection[5]=0;
    availableMoveDirection[6]=0;
    availableMoveDirection[7]=0;
  }
 else   if (allPlayers[playerIndex].preLoc == 6) {
    availableMoveDirection[0]=0;
    availableMoveDirection[1]=0;
    availableMoveDirection[2]=0;
    availableMoveDirection[3]=1;
    availableMoveDirection[4]=0;
    availableMoveDirection[5]=1;
    availableMoveDirection[6]=0;
    availableMoveDirection[7]=0;
  }
 else   if (allPlayers[playerIndex].preLoc == 7) {
    availableMoveDirection[0]=1;
    availableMoveDirection[1]=0;
    availableMoveDirection[2]=0;
    availableMoveDirection[3]=1;
    availableMoveDirection[4]=0;
    availableMoveDirection[5]=0;
    availableMoveDirection[6]=0;
    availableMoveDirection[7]=1;
  }
 else   if (allPlayers[playerIndex].preLoc == 8) {
    availableMoveDirection[0]=0;
    availableMoveDirection[1]=1;
    availableMoveDirection[2]=0;
    availableMoveDirection[3]=0;
    availableMoveDirection[4]=1;
    availableMoveDirection[5]=0;
    availableMoveDirection[6]=0;
    availableMoveDirection[7]=0;
  }
 else   if (allPlayers[playerIndex].preLoc == 11) {
    availableMoveDirection[0]=0;
    availableMoveDirection[1]=0;
    availableMoveDirection[2]=0;
    availableMoveDirection[3]=0;
    availableMoveDirection[4]=0;
    availableMoveDirection[5]=1;
    availableMoveDirection[6]=0;
    availableMoveDirection[7]=1;
  }
 else   if (allPlayers[playerIndex].preLoc == 12) {
    availableMoveDirection[0]=0;
    availableMoveDirection[1]=1;
    availableMoveDirection[2]=0;
    availableMoveDirection[3]=1;
    availableMoveDirection[4]=0;
    availableMoveDirection[5]=0;
    availableMoveDirection[6]=0;
    availableMoveDirection[7]=0;
  }
 else   if (allPlayers[playerIndex].preLoc == 14) {
    availableMoveDirection[0]=0;
    availableMoveDirection[1]=0;
    availableMoveDirection[2]=0;
    availableMoveDirection[3]=1;
    availableMoveDirection[4]=0;
    availableMoveDirection[5]=1;
    availableMoveDirection[6]=0;
    availableMoveDirection[7]=0;
  }
 else   if (allPlayers[playerIndex].preLoc == 15) {
    availableMoveDirection[0]=0;
    availableMoveDirection[1]=0;
    availableMoveDirection[2]=0;
    availableMoveDirection[3]=1;
    availableMoveDirection[4]=0;
    availableMoveDirection[5]=0;
    availableMoveDirection[6]=0;
    availableMoveDirection[7]=1;
  }
 else   if (allPlayers[playerIndex].preLoc == 16) {
    availableMoveDirection[0]=0;
    availableMoveDirection[1]=0;
    availableMoveDirection[2]=0;
    availableMoveDirection[3]=1;
    availableMoveDirection[4]=0;
    availableMoveDirection[5]=0;
    availableMoveDirection[6]=0;
    availableMoveDirection[7]=1;
  }
 else   if (allPlayers[playerIndex].preLoc == 17) {
    availableMoveDirection[0]=0;
    availableMoveDirection[1]=0;
    availableMoveDirection[2]=0;
    availableMoveDirection[3]=0;
    availableMoveDirection[4]=0;
    availableMoveDirection[5]=1;
    availableMoveDirection[6]=0;
    availableMoveDirection[7]=1;
  }
 else   if (allPlayers[playerIndex].preLoc == 23) {
    availableMoveDirection[0]=0;
    availableMoveDirection[1]=1;
    availableMoveDirection[2]=0;
    availableMoveDirection[3]=0;
    availableMoveDirection[4]=0;
    availableMoveDirection[5]=0;
    availableMoveDirection[6]=0;
    availableMoveDirection[7]=1;
  }
 else   if (allPlayers[playerIndex].preLoc == 24) {
    availableMoveDirection[0]=0;
    availableMoveDirection[1]=0;
    availableMoveDirection[2]=0;
    availableMoveDirection[3]=1;
    availableMoveDirection[4]=0;
    availableMoveDirection[5]=0;
    availableMoveDirection[6]=0;
    availableMoveDirection[7]=1;
  }
 else {
    availableMoveDirection[0]=0;
    availableMoveDirection[1]=1;
    availableMoveDirection[2]=0;
    availableMoveDirection[3]=0;
    availableMoveDirection[4]=0;
    availableMoveDirection[5]=1;
    availableMoveDirection[6]=0;
    availableMoveDirection[7]=0;
  }
}"
72249,"private int toLoc(int playerIndex,int direction){
  if (allPlayers[playerIndex].preLoc == 7) {
    if (direction == 7)     return 6;
 else     if (direction == 0)     return 8;
 else     return 24;
  }
 else   if (allPlayers[playerIndex].preLoc == 16) {
    if (direction == 7)     return 15;
 else     return 17;
  }
 else   if (allPlayers[playerIndex].preLoc == 24) {
    if (direction == 7)     return 7;
 else     return 23;
  }
 else   if (allPlayers[playerIndex].preLoc == 23) {
    if (direction == 7)     return 24;
 else     return 22;
  }
 else   if (allPlayers[playerIndex].preLoc == 8) {
    if (direction == 4)     return 7;
 else     return 9;
  }
 else   if (allPlayers[playerIndex].preLoc == 11) {
    if (direction == 7)     return 12;
 else     return 10;
  }
 else   if (allPlayers[playerIndex].preLoc == 12) {
    if (direction == 1)     return 13;
 else     return 11;
  }
 else   if (allPlayers[playerIndex].preLoc == 14) {
    if (direction == 5)     return 13;
 else     return 15;
  }
 else   if (allPlayers[playerIndex].preLoc == 15) {
    if (direction == 7)     return 14;
 else     return 16;
  }
 else   if (allPlayers[playerIndex].preLoc == 16) {
    if (direction == 7)     return 15;
 else     return 17;
  }
 else   if (allPlayers[playerIndex].preLoc == 17) {
    if (direction == 7)     return 16;
 else     return 18;
  }
 else   if (allPlayers[playerIndex].preLoc == 1) {
    if (direction == 3)     return 0;
 else     return 2;
  }
 else   if (allPlayers[playerIndex].preLoc == 0) {
    return 1;
  }
 else {
    if (direction == 1)     return allPlayers[playerIndex].preLoc++;
 else     return allPlayers[playerIndex].preLoc--;
  }
}","private int toLoc(int playerIndex,int direction){
  if (allPlayers[playerIndex].preLoc == 0) {
    return 1;
  }
 else   if (allPlayers[playerIndex].preLoc == 1) {
    if (direction == 3)     return 0;
 else     return 2;
  }
  if (allPlayers[playerIndex].preLoc == 7) {
    if (direction == 7)     return 6;
 else     if (direction == 0)     return 8;
 else     return 24;
  }
 else   if (allPlayers[playerIndex].preLoc == 8) {
    if (direction == 4)     return 7;
 else     return 9;
  }
 else   if (allPlayers[playerIndex].preLoc == 11) {
    if (direction == 7)     return 12;
 else     return 10;
  }
 else   if (allPlayers[playerIndex].preLoc == 12) {
    if (direction == 1)     return 13;
 else     return 11;
  }
 else   if (allPlayers[playerIndex].preLoc == 14) {
    if (direction == 5)     return 13;
 else     return 15;
  }
 else   if (allPlayers[playerIndex].preLoc == 15) {
    if (direction == 7)     return 14;
 else     return 16;
  }
 else   if (allPlayers[playerIndex].preLoc == 16) {
    if (direction == 7)     return 15;
 else     return 17;
  }
 else   if (allPlayers[playerIndex].preLoc == 17) {
    if (direction == 7)     return 16;
 else     return 18;
  }
 else   if (allPlayers[playerIndex].preLoc == 23) {
    if (direction == 7)     return 24;
 else     return 22;
  }
 else   if (allPlayers[playerIndex].preLoc == 24) {
    if (direction == 7)     return 7;
 else     return 23;
  }
 else {
    if (direction == 1)     return allPlayers[playerIndex].preLoc++;
 else     return allPlayers[playerIndex].preLoc--;
  }
}"
72250,"public String request(int sid,String msg){
  int playerIndex=0;
  for (int i=0; i < playerNum; i++) {
    if (allPlayers[i].SID == sid) {
      playerIndex=i;
      break;
    }
  }
  String result=""String_Node_Str"";
switch (gameState) {
case INIT:
    if (playerState[playerIndex] == 0) {
      result=GodHelper.toInit(allUserInfo,""String_Node_Str"",playerIndex,heroList);
      playerState[playerIndex]+=1;
    }
 else     if (playerState[playerIndex] == 1) {
      heroChoose(sid,msg);
      gameState=GameState.MAINGAME;
      playerState[playerIndex]=0;
      result=GodHelper.toChooseHero(""String_Node_Str"",heroChoices,teamResult);
    }
  break;
case MAINGAME:
switch (phaseState) {
case PREPARE:
  if (playerState[playerIndex] == 0) {
    GambleChecker.cardDistribute(cardHeap,allPlayers[playerIndex],4);
    int[] playerHandCard=new int[allPlayers[playerIndex].handCardsNum];
    seenCardJudge(playerIndex,playerHandCard);
    for (int i=0; i < playerNum; i++) {
      if (MapChecker.distance(map.units[allPlayers[playerIndex].preLoc],map.units[allPlayers[i].preLoc]) < allPlayers[playerIndex].range)       availableFireTarget[i]=1;
    }
    toDirection(playerIndex);
    result=GodHelper.toCardDistribute(""String_Node_Str"",playerHandCard,availableFireTarget,availableMoveDirection);
    playerState[playerIndex]+=1;
  }
 else   if (playerState[playerIndex] == 1) {
    MsgChooseDecision dec=GodHelper.getChooseDecision(msg);
    if (dec.decision() == -1)     allPlayers[playerIndex].stratDecision=GambleChecker.DEPOSIT;
 else {
      allPlayers[playerIndex].stratDecision=allPlayers[playerIndex].handCards[dec.decision()];
      GambleChecker.cardToHeap(cardHeap,dec.decision());
      allPlayers[playerIndex].handCards[dec.decision()]=GambleChecker.NOTHING;
      GambleChecker.cardSort(allPlayers[playerIndex].handCards);
      allPlayers[playerIndex].handCardsNum-=1;
    }
    decisionChoices[playerIndex]=allPlayers[playerIndex].stratDecision;
    featureChoose(msg,allPlayers[playerIndex],playerIndex);
    int[] playerHandCard=new int[allPlayers[playerIndex].handCardsNum];
    for (int i=0; i < allPlayers[playerIndex].handCardsNum; i++)     playerHandCard[i]=allPlayers[playerIndex].handCards[i];
    if (allPlayers[playerIndex].isSeenCard)     result=GodHelper.toChooseDecision(""String_Node_Str"",playerHandCard);
 else     result=GodHelper.toChooseDecision(""String_Node_Str"",playerHandCard);
    playerState[playerIndex]+=1;
  }
 else   if (playerState[playerIndex] == 2) {
    seenCard(playerIndex,msg,allPlayers[playerIndex]);
    if (allPlayers[playerIndex].isSeenCard)     result=GodHelper.toSeenCard(""String_Node_Str"",decisionChoices,seenCardChoices);
 else     result=GodHelper.toSeenCard(""String_Node_Str"",decisionChoices,seenCardChoices);
    playerState[playerIndex]=0;
    phaseState=PhaseState.GAMBLE;
  }
break;
case GAMBLE:
if (playerState[playerIndex] == 0) {
gambleChoose(msg,allPlayers[playerIndex],playerIndex);
playerState[playerIndex]+=1;
int[] playerHandCard=new int[allPlayers[playerIndex].handCardsNum];
for (int i=0; i < allPlayers[playerIndex].handCardsNum; i++) playerHandCard[i]=allPlayers[playerIndex].handCards[i];
result=GodHelper.toChooseGamble(""String_Node_Str"",playerHandCard);
}
 else if (playerState[playerIndex] == 1) {
winJudge();
for (int i=0; i < playerNum; i++) {
  if (allPlayers[i].isWin)   playerWinList[i]=1;
}
playerState[playerIndex]=0;
phaseState=PhaseState.ACTION;
result=GodHelper.toWinJudge(""String_Node_Str"",gambleChoices,cardNumList,playerWinList,fireList);
}
break;
case ACTION:
if (playerState[playerIndex] == 0) {
depositAccount();
result=GodHelper.toDepositAccount(""String_Node_Str"",energyList);
playerState[playerIndex]+=1;
}
 else if (playerState[playerIndex] == 1) {
skillsAccount();
result=GodHelper.toSkillsAccount(""String_Node_Str"");
playerState[playerIndex]+=1;
}
 else if (playerState[playerIndex] == 2) {
fireAccount();
result=GodHelper.toFireAccount(""String_Node_Str"",healthPointList);
playerState[playerIndex]+=1;
}
 else if (playerState[playerIndex] == 3) {
moveAccount();
result=GodHelper.toMoveAccount(""String_Node_Str"",locationList);
playerState[playerIndex]+=1;
}
 else if (playerState[playerIndex] == 4) {
elemAccount();
result=GodHelper.toElemAccount(""String_Node_Str"",elementList);
playerState[playerIndex]+=1;
}
 else if (playerState[playerIndex] == 5) {
humanVictory();
if (humanWin) {
result=GodHelper.toHumanVictory(""String_Node_Str"");
playerState[playerIndex]=0;
gameState=GameState.END;
}
 else {
result=GodHelper.toHumanVictory(""String_Node_Str"");
playerState[playerIndex]+=1;
}
}
 else if (playerState[playerIndex] == 6) {
infectionAccount();
if (zombieWin) {
result=GodHelper.toInfectionAccount(""String_Node_Str"",teamList);
playerState[playerIndex]=0;
gameState=GameState.END;
}
 else {
result=GodHelper.toInfectionAccount(""String_Node_Str"",teamList);
playerState[playerIndex]+=1;
}
}
 else if (playerState[playerIndex] == 7) {
desertAccount(playerIndex,msg);
int[] playerHandCard=new int[allPlayers[playerIndex].handCardsNum];
for (int i=0; i < allPlayers[playerIndex].handCardsNum; i++) playerHandCard[i]=allPlayers[playerIndex].handCards[i];
result=GodHelper.toDesertAccount(""String_Node_Str"",allPlayers[playerIndex].energy,playerHandCard);
phaseState=PhaseState.PREPARE;
playerState[playerIndex]=0;
seen_card_count=0;
gamble_count=0;
desert_count=0;
for (int i=0; i < playerNum; i++) {
allPlayers[i].stratDecision=GambleChecker.DEPOSIT;
allPlayers[i].fireTarget=-1;
allPlayers[i].moveDirection=-1;
availableFireTarget[i]=-1;
availableMoveDirection[i]=-1;
decisionChoices[i]=GambleChecker.DEPOSIT;
seenCardChoices[i]=0;
gambleChoices[i]=GambleChecker.PAPER;
cardNumList[i]=0;
playerWinList[i]=0;
fireList[i]=-1;
}
}
break;
}
break;
case END:
result=GodHelper.toGameOver(""String_Node_Str"",scoreList);
break;
}
if (result.equals(""String_Node_Str"")) {
System.out.printf(""String_Node_Str"",sid,msg,gameState.toString());
}
return result;
}","public String request(int sid,String msg){
  int playerIndex=0;
  for (int i=0; i < playerNum; i++) {
    if (allPlayers[i].SID == sid) {
      playerIndex=i;
      break;
    }
  }
  String result=""String_Node_Str"";
switch (gameState) {
case INIT:
    if (playerState[playerIndex] == 0) {
      result=GodHelper.toInit(allUserInfo,""String_Node_Str"",playerIndex,heroList);
      playerState[playerIndex]+=1;
    }
 else     if (playerState[playerIndex] == 1) {
      heroChoose(sid,msg);
      gameState=GameState.MAINGAME;
      playerState[playerIndex]=0;
      result=GodHelper.toChooseHero(""String_Node_Str"",heroChoices,teamResult);
    }
  break;
case MAINGAME:
switch (phaseState) {
case PREPARE:
  if (playerState[playerIndex] == 0) {
    GambleChecker.cardDistribute(cardHeap,allPlayers[playerIndex],4);
    int[] playerHandCard=new int[allPlayers[playerIndex].handCardsNum];
    seenCardJudge(playerIndex,playerHandCard);
    for (int i=0; i < playerNum; i++) {
      if (map.distance[allPlayers[playerIndex].preLoc][allPlayers[i].preLoc] < allPlayers[playerIndex].range)       availableFireTarget[i]=1;
    }
    toDirection(playerIndex);
    result=GodHelper.toCardDistribute(""String_Node_Str"",playerHandCard,availableFireTarget,availableMoveDirection);
    playerState[playerIndex]+=1;
  }
 else   if (playerState[playerIndex] == 1) {
    MsgChooseDecision dec=GodHelper.getChooseDecision(msg);
    if (dec.decision() == -1)     allPlayers[playerIndex].stratDecision=GambleChecker.DEPOSIT;
 else {
      allPlayers[playerIndex].stratDecision=allPlayers[playerIndex].handCards[dec.decision()];
      GambleChecker.cardToHeap(cardHeap,dec.decision());
      allPlayers[playerIndex].handCards[dec.decision()]=GambleChecker.NOTHING;
      GambleChecker.cardSort(allPlayers[playerIndex].handCards);
      allPlayers[playerIndex].handCardsNum-=1;
    }
    decisionChoices[playerIndex]=allPlayers[playerIndex].stratDecision;
    featureChoose(msg,allPlayers[playerIndex],playerIndex);
    int[] playerHandCard=new int[allPlayers[playerIndex].handCardsNum];
    for (int i=0; i < allPlayers[playerIndex].handCardsNum; i++)     playerHandCard[i]=allPlayers[playerIndex].handCards[i];
    if (allPlayers[playerIndex].isSeenCard)     result=GodHelper.toChooseDecision(""String_Node_Str"",playerHandCard);
 else     result=GodHelper.toChooseDecision(""String_Node_Str"",playerHandCard);
    playerState[playerIndex]+=1;
  }
 else   if (playerState[playerIndex] == 2) {
    seenCard(playerIndex,msg,allPlayers[playerIndex]);
    if (allPlayers[playerIndex].isSeenCard)     result=GodHelper.toSeenCard(""String_Node_Str"",decisionChoices,seenCardChoices);
 else     result=GodHelper.toSeenCard(""String_Node_Str"",decisionChoices,seenCardChoices);
    playerState[playerIndex]=0;
    phaseState=PhaseState.GAMBLE;
  }
break;
case GAMBLE:
if (playerState[playerIndex] == 0) {
gambleChoose(msg,allPlayers[playerIndex],playerIndex);
playerState[playerIndex]+=1;
int[] playerHandCard=new int[allPlayers[playerIndex].handCardsNum];
for (int i=0; i < allPlayers[playerIndex].handCardsNum; i++) playerHandCard[i]=allPlayers[playerIndex].handCards[i];
result=GodHelper.toChooseGamble(""String_Node_Str"",playerHandCard);
}
 else if (playerState[playerIndex] == 1) {
winJudge();
for (int i=0; i < playerNum; i++) {
  if (allPlayers[i].isWin)   playerWinList[i]=1;
}
playerState[playerIndex]=0;
phaseState=PhaseState.ACTION;
result=GodHelper.toWinJudge(""String_Node_Str"",gambleChoices,cardNumList,playerWinList,fireList);
}
break;
case ACTION:
if (playerState[playerIndex] == 0) {
depositAccount();
result=GodHelper.toDepositAccount(""String_Node_Str"",energyList);
playerState[playerIndex]+=1;
}
 else if (playerState[playerIndex] == 1) {
skillsAccount();
result=GodHelper.toSkillsAccount(""String_Node_Str"");
playerState[playerIndex]+=1;
}
 else if (playerState[playerIndex] == 2) {
fireAccount();
result=GodHelper.toFireAccount(""String_Node_Str"",healthPointList);
playerState[playerIndex]+=1;
}
 else if (playerState[playerIndex] == 3) {
moveAccount();
result=GodHelper.toMoveAccount(""String_Node_Str"",locationList);
playerState[playerIndex]+=1;
}
 else if (playerState[playerIndex] == 4) {
elemAccount();
result=GodHelper.toElemAccount(""String_Node_Str"",elementList);
playerState[playerIndex]+=1;
}
 else if (playerState[playerIndex] == 5) {
humanVictory();
if (humanWin) {
result=GodHelper.toHumanVictory(""String_Node_Str"");
playerState[playerIndex]=0;
gameState=GameState.END;
}
 else {
result=GodHelper.toHumanVictory(""String_Node_Str"");
playerState[playerIndex]+=1;
}
}
 else if (playerState[playerIndex] == 6) {
infectionAccount();
if (zombieWin) {
result=GodHelper.toInfectionAccount(""String_Node_Str"",teamList);
playerState[playerIndex]=0;
gameState=GameState.END;
}
 else {
result=GodHelper.toInfectionAccount(""String_Node_Str"",teamList);
playerState[playerIndex]+=1;
}
}
 else if (playerState[playerIndex] == 7) {
desertAccount(playerIndex,msg);
int[] playerHandCard=new int[allPlayers[playerIndex].handCardsNum];
for (int i=0; i < allPlayers[playerIndex].handCardsNum; i++) playerHandCard[i]=allPlayers[playerIndex].handCards[i];
result=GodHelper.toDesertAccount(""String_Node_Str"",allPlayers[playerIndex].energy,playerHandCard);
phaseState=PhaseState.PREPARE;
playerState[playerIndex]=0;
seen_card_count=0;
gamble_count=0;
desert_count=0;
for (int i=0; i < playerNum; i++) {
allPlayers[i].stratDecision=GambleChecker.DEPOSIT;
allPlayers[i].fireTarget=-1;
allPlayers[i].moveDirection=-1;
availableFireTarget[i]=-1;
availableMoveDirection[i]=-1;
decisionChoices[i]=GambleChecker.DEPOSIT;
seenCardChoices[i]=0;
gambleChoices[i]=GambleChecker.PAPER;
cardNumList[i]=0;
playerWinList[i]=0;
fireList[i]=-1;
}
}
break;
}
break;
case END:
result=GodHelper.toGameOver(""String_Node_Str"",scoreList);
break;
}
if (result.equals(""String_Node_Str"")) {
System.out.printf(""String_Node_Str"",sid,msg,gameState.toString());
}
return result;
}"
72251,"Map(String filename){
  try {
    FileInputStream fileInput=new FileInputStream(filename);
    ObjectInputStream ois=new ObjectInputStream(fileInput);
    int number=ois.readInt();
    fighter_init=ois.readInt();
    poisoner_init=ois.readInt();
    fighter_evacuate=ois.readInt();
    units=new MapUnit[number];
    for (int i=0; fileInput.available() > 0; i++) {
      try {
        units[i]=(MapUnit)ois.readObject();
      }
 catch (      ClassNotFoundException e) {
        e.printStackTrace();
      }
    }
  }
 catch (  IOException i) {
    i.printStackTrace();
  }
}","Map(String filename){
  try {
    FileInputStream fileInput=new FileInputStream(filename);
    ObjectInputStream ois=new ObjectInputStream(fileInput);
    int number=ois.readInt();
    fighter_init=ois.readInt();
    poisoner_init=ois.readInt();
    fighter_evacuate=ois.readInt();
    units=new MapUnit[number];
    for (int i=0; fileInput.available() > 0; i++) {
      try {
        units[i]=(MapUnit)ois.readObject();
      }
 catch (      ClassNotFoundException e) {
        e.printStackTrace();
      }
    }
    distance=new int[number][number];
    floyd();
  }
 catch (  IOException i) {
    i.printStackTrace();
  }
}"
72252,"static void fire(Map map,Player playerPos,Player playerPas){
  distance=MapChecker.distance(map.units[playerPas.preLoc],map.units[playerPos.preLoc]);
  if (playerPos.range >= distance) {
    if (playerPas.healthPoint - playerPos.energyConsume > 4)     playerPas.healthPoint-=playerPos.energyConsume;
 else     playerPas.healthPoint=4;
  }
}","static void fire(Map map,Player playerPos,Player playerPas){
  distance=map.distance[playerPas.preLoc][playerPos.preLoc];
  if (playerPos.range >= distance) {
    if (playerPas.healthPoint - playerPos.energyConsume > 4)     playerPas.healthPoint-=playerPos.energyConsume;
 else     playerPas.healthPoint=4;
  }
}"
72253,"public static int tryMove(Map m,int i_current,int i_next,int energy){
}","static int tryMove(Map m,int i_current,int i_next,int energy){
}"
72254,"static void map1_test(){
  Map X=new Map(""String_Node_Str"");
  assert(X.units[7].edge[2].adjedg == 22);
  assert(X.units[10].rank == 3);
  assert(MapChecker.outDistance(X.units[3],X.units[8]) == -1);
}","static void map1_test(){
  Map X=new Map(""String_Node_Str"");
  assert(X.units[7].edge[2].adjedg == 22);
  assert(X.units[10].rank == 3);
}"
72255,"public void initialPlayer(int[] playerSID){
  playerNum=playerSID.length;
  allPlayers=new Player[playerNum];
  allUserInfo=new UserInfo[playerNum];
  playerState=new int[playerNum];
  map=new Map(""String_Node_Str"");
  heroChoices=new String[playerNum];
  teamResult=new int[playerNum];
  decisionChoices=new int[playerNum];
  seenCardChoices=new int[playerNum];
  cardHeap=new int[40 * playerNum];
  gambleChoices=new int[playerNum];
  cardNumList=new int[playerNum];
  playerWinList=new int[playerNum];
  energyList=new int[playerNum];
  healthPointList=new int[playerNum];
  locationList=new int[playerNum];
  elementList=new int[playerNum];
  teamList=new int[playerNum];
  availableFireTarget=new int[playerNum];
  scoreList=new int[playerNum];
  availableMoveDirection=new int[8];
  fireList=new int[playerNum];
  for (int i=0; i < playerNum; i++) {
    allPlayers[i]=new Player();
    allPlayers[i].SID=playerSID[i];
    allPlayers[i].handCardsNum=0;
    allPlayers[i].healthPoint=6;
    allPlayers[i].mot=4;
    allPlayers[i].handCards=new int[allPlayers[i].healthPoint + 4];
    playerState[i]=0;
    scoreList[i]=100;
    fireList[i]=-1;
    Option<UserModel.User> user=UserController.getProfile(playerSID[i]);
    if (user.isEmpty())     allPlayers[i].user_info=GodHelper.ghostUser();
 else     allPlayers[i].user_info=user.get();
    allUserInfo[i]=new UserInfo(i,allPlayers[i].user_info.nickname());
  }
}","public void initialPlayer(int[] playerSID){
  playerNum=playerSID.length;
  allPlayers=new Player[playerNum];
  allUserInfo=new UserInfo[playerNum];
  playerState=new int[playerNum];
  map=new Map(""String_Node_Str"");
  heroChoices=new String[playerNum];
  teamResult=new int[playerNum];
  decisionChoices=new int[playerNum];
  seenCardChoices=new int[playerNum];
  cardHeap=new int[40 * playerNum];
  gambleChoices=new int[playerNum];
  cardNumList=new int[playerNum];
  playerWinList=new int[playerNum];
  energyList=new int[playerNum];
  healthPointList=new int[playerNum];
  locationList=new int[playerNum];
  elementList=new int[playerNum];
  teamList=new int[playerNum];
  availableFireTarget=new int[playerNum];
  scoreList=new int[playerNum];
  availableMoveDirection=new int[8];
  fireList=new int[playerNum];
  for (int i=0; i < playerNum; i++) {
    allPlayers[i]=new Player();
    allPlayers[i].SID=playerSID[i];
    allPlayers[i].handCardsNum=0;
    allPlayers[i].healthPoint=6;
    allPlayers[i].mot=4;
    allPlayers[i].handCards=new int[allPlayers[i].healthPoint + 4];
    allPlayers[i].fireTarget=-1;
    allPlayers[i].moveDirection=-1;
    playerState[i]=0;
    scoreList[i]=100;
    fireList[i]=-1;
    Option<UserModel.User> user=UserController.getProfile(playerSID[i]);
    if (user.isEmpty())     allPlayers[i].user_info=GodHelper.ghostUser();
 else     allPlayers[i].user_info=user.get();
    allUserInfo[i]=new UserInfo(i,allPlayers[i].user_info.nickname());
  }
}"
72256,"public String request(int sid,String msg){
  int playerIndex=0;
  for (int i=0; i < playerNum; i++) {
    if (allPlayers[i].SID == sid) {
      playerIndex=i;
      break;
    }
  }
  String result=""String_Node_Str"";
switch (gameState) {
case INIT:
    if (playerState[playerIndex] == 0) {
      result=GodHelper.toInit(allUserInfo,""String_Node_Str"",playerIndex,heroList);
      playerState[playerIndex]+=1;
    }
 else     if (playerState[playerIndex] == 1) {
      heroChoose(sid,msg);
      gameState=GameState.MAINGAME;
      playerState[playerIndex]=0;
      result=GodHelper.toChooseHero(""String_Node_Str"",heroChoices,teamResult);
    }
  break;
case MAINGAME:
switch (phaseState) {
case PREPARE:
  if (playerState[playerIndex] == 0) {
    GambleChecker.cardDistribute(cardHeap,allPlayers[playerIndex],4);
    int[] playerHandCard=new int[allPlayers[playerIndex].handCardsNum];
    seenCardJudge(playerIndex,playerHandCard);
    for (int i=0; i < playerNum; i++) {
      if (MapChecker.distance(map.units[allPlayers[playerIndex].preLoc],map.units[allPlayers[i].preLoc]) < allPlayers[playerIndex].range)       availableFireTarget[i]=1;
    }
    toDirection(playerIndex);
    result=GodHelper.toCardDistribute(""String_Node_Str"",playerHandCard,availableFireTarget,availableMoveDirection);
    playerState[playerIndex]+=1;
  }
 else   if (playerState[playerIndex] == 1) {
    MsgChooseDecision dec=GodHelper.getChooseDecision(msg);
    if (dec.decision() == -1)     allPlayers[playerIndex].stratDecision=GambleChecker.DEPOSIT;
 else {
      allPlayers[playerIndex].stratDecision=allPlayers[playerIndex].handCards[dec.decision()];
      GambleChecker.cardToHeap(cardHeap,dec.decision());
      allPlayers[playerIndex].handCards[dec.decision()]=GambleChecker.NOTHING;
      GambleChecker.cardSort(allPlayers[playerIndex].handCards);
      allPlayers[playerIndex].handCardsNum-=1;
    }
    decisionChoices[playerIndex]=allPlayers[playerIndex].stratDecision;
    featureChoose(msg,allPlayers[playerIndex],playerIndex);
    int[] playerHandCard=new int[allPlayers[playerIndex].handCardsNum];
    for (int i=0; i < allPlayers[playerIndex].handCardsNum; i++)     playerHandCard[i]=allPlayers[playerIndex].handCards[i];
    if (allPlayers[playerIndex].isSeenCard)     result=GodHelper.toChooseDecision(""String_Node_Str"",playerHandCard);
 else     result=GodHelper.toChooseDecision(""String_Node_Str"",playerHandCard);
    playerState[playerIndex]+=1;
  }
 else   if (playerState[playerIndex] == 2) {
    seenCard(playerIndex,msg,allPlayers[playerIndex]);
    if (allPlayers[playerIndex].isSeenCard)     result=GodHelper.toSeenCard(""String_Node_Str"",decisionChoices,seenCardChoices);
 else     result=GodHelper.toSeenCard(""String_Node_Str"",decisionChoices,seenCardChoices);
    playerState[playerIndex]=0;
    phaseState=PhaseState.GAMBLE;
  }
break;
case GAMBLE:
if (playerState[playerIndex] == 0) {
gambleChoose(msg,allPlayers[playerIndex],playerIndex);
playerState[playerIndex]+=1;
int[] playerHandCard=new int[allPlayers[playerIndex].handCardsNum];
for (int i=0; i < allPlayers[playerIndex].handCardsNum; i++) playerHandCard[i]=allPlayers[playerIndex].handCards[i];
result=GodHelper.toChooseGamble(""String_Node_Str"",playerHandCard);
}
 else if (playerState[playerIndex] == 1) {
winJudge();
for (int i=0; i < playerNum; i++) {
  if (allPlayers[i].isWin)   playerWinList[i]=1;
}
playerState[playerIndex]=0;
phaseState=PhaseState.ACTION;
result=GodHelper.toWinJudge(""String_Node_Str"",gambleChoices,cardNumList,playerWinList,fireList);
}
break;
case ACTION:
if (playerState[playerIndex] == 0) {
depositAccount();
result=GodHelper.toDepositAccount(""String_Node_Str"",energyList);
playerState[playerIndex]+=1;
}
 else if (playerState[playerIndex] == 1) {
skillsAccount();
result=GodHelper.toSkillsAccount(""String_Node_Str"");
playerState[playerIndex]+=1;
}
 else if (playerState[playerIndex] == 2) {
fireAccount();
result=GodHelper.toFireAccount(""String_Node_Str"",healthPointList);
playerState[playerIndex]+=1;
}
 else if (playerState[playerIndex] == 3) {
moveAccount();
result=GodHelper.toMoveAccount(""String_Node_Str"",locationList);
playerState[playerIndex]+=1;
}
 else if (playerState[playerIndex] == 4) {
elemAccount();
result=GodHelper.toElemAccount(""String_Node_Str"",elementList);
playerState[playerIndex]+=1;
}
 else if (playerState[playerIndex] == 5) {
humanVictory();
if (humanWin) {
result=GodHelper.toHumanVictory(""String_Node_Str"");
playerState[playerIndex]=0;
gameState=GameState.END;
}
 else {
result=GodHelper.toHumanVictory(""String_Node_Str"");
playerState[playerIndex]+=1;
}
}
 else if (playerState[playerIndex] == 6) {
infectionAccount();
if (zombieWin) {
result=GodHelper.toInfectionAccount(""String_Node_Str"",teamList);
playerState[playerIndex]=0;
gameState=GameState.END;
}
 else {
result=GodHelper.toInfectionAccount(""String_Node_Str"",teamList);
playerState[playerIndex]+=1;
}
}
 else if (playerState[playerIndex] == 7) {
desertAccount(playerIndex,msg);
int[] playerHandCard=new int[allPlayers[playerIndex].handCardsNum];
for (int i=0; i < allPlayers[playerIndex].handCardsNum; i++) playerHandCard[i]=allPlayers[playerIndex].handCards[i];
result=GodHelper.toDesertAccount(""String_Node_Str"",allPlayers[playerIndex].energy,playerHandCard);
phaseState=PhaseState.PREPARE;
playerState[playerIndex]=0;
seen_card_count=0;
gamble_count=0;
desert_count=0;
for (int i=0; i < playerNum; i++) {
allPlayers[i].stratDecision=GambleChecker.DEPOSIT;
availableFireTarget[i]=0;
decisionChoices[i]=GambleChecker.DEPOSIT;
seenCardChoices[i]=0;
gambleChoices[i]=GambleChecker.PAPER;
cardNumList[i]=0;
playerWinList[i]=0;
fireList[i]=-1;
}
}
break;
}
break;
case END:
result=GodHelper.toGameOver(""String_Node_Str"",scoreList);
break;
}
if (result.equals(""String_Node_Str"")) {
System.out.printf(""String_Node_Str"",sid,msg,gameState.toString());
}
return result;
}","public String request(int sid,String msg){
  int playerIndex=0;
  for (int i=0; i < playerNum; i++) {
    if (allPlayers[i].SID == sid) {
      playerIndex=i;
      break;
    }
  }
  String result=""String_Node_Str"";
switch (gameState) {
case INIT:
    if (playerState[playerIndex] == 0) {
      result=GodHelper.toInit(allUserInfo,""String_Node_Str"",playerIndex,heroList);
      playerState[playerIndex]+=1;
    }
 else     if (playerState[playerIndex] == 1) {
      heroChoose(sid,msg);
      gameState=GameState.MAINGAME;
      playerState[playerIndex]=0;
      result=GodHelper.toChooseHero(""String_Node_Str"",heroChoices,teamResult);
    }
  break;
case MAINGAME:
switch (phaseState) {
case PREPARE:
  if (playerState[playerIndex] == 0) {
    GambleChecker.cardDistribute(cardHeap,allPlayers[playerIndex],4);
    int[] playerHandCard=new int[allPlayers[playerIndex].handCardsNum];
    seenCardJudge(playerIndex,playerHandCard);
    for (int i=0; i < playerNum; i++) {
      if (MapChecker.distance(map.units[allPlayers[playerIndex].preLoc],map.units[allPlayers[i].preLoc]) < allPlayers[playerIndex].range)       availableFireTarget[i]=1;
    }
    toDirection(playerIndex);
    result=GodHelper.toCardDistribute(""String_Node_Str"",playerHandCard,availableFireTarget,availableMoveDirection);
    playerState[playerIndex]+=1;
  }
 else   if (playerState[playerIndex] == 1) {
    MsgChooseDecision dec=GodHelper.getChooseDecision(msg);
    if (dec.decision() == -1)     allPlayers[playerIndex].stratDecision=GambleChecker.DEPOSIT;
 else {
      allPlayers[playerIndex].stratDecision=allPlayers[playerIndex].handCards[dec.decision()];
      GambleChecker.cardToHeap(cardHeap,dec.decision());
      allPlayers[playerIndex].handCards[dec.decision()]=GambleChecker.NOTHING;
      GambleChecker.cardSort(allPlayers[playerIndex].handCards);
      allPlayers[playerIndex].handCardsNum-=1;
    }
    decisionChoices[playerIndex]=allPlayers[playerIndex].stratDecision;
    featureChoose(msg,allPlayers[playerIndex],playerIndex);
    int[] playerHandCard=new int[allPlayers[playerIndex].handCardsNum];
    for (int i=0; i < allPlayers[playerIndex].handCardsNum; i++)     playerHandCard[i]=allPlayers[playerIndex].handCards[i];
    if (allPlayers[playerIndex].isSeenCard)     result=GodHelper.toChooseDecision(""String_Node_Str"",playerHandCard);
 else     result=GodHelper.toChooseDecision(""String_Node_Str"",playerHandCard);
    playerState[playerIndex]+=1;
  }
 else   if (playerState[playerIndex] == 2) {
    seenCard(playerIndex,msg,allPlayers[playerIndex]);
    if (allPlayers[playerIndex].isSeenCard)     result=GodHelper.toSeenCard(""String_Node_Str"",decisionChoices,seenCardChoices);
 else     result=GodHelper.toSeenCard(""String_Node_Str"",decisionChoices,seenCardChoices);
    playerState[playerIndex]=0;
    phaseState=PhaseState.GAMBLE;
  }
break;
case GAMBLE:
if (playerState[playerIndex] == 0) {
gambleChoose(msg,allPlayers[playerIndex],playerIndex);
playerState[playerIndex]+=1;
int[] playerHandCard=new int[allPlayers[playerIndex].handCardsNum];
for (int i=0; i < allPlayers[playerIndex].handCardsNum; i++) playerHandCard[i]=allPlayers[playerIndex].handCards[i];
result=GodHelper.toChooseGamble(""String_Node_Str"",playerHandCard);
}
 else if (playerState[playerIndex] == 1) {
winJudge();
for (int i=0; i < playerNum; i++) {
  if (allPlayers[i].isWin)   playerWinList[i]=1;
}
playerState[playerIndex]=0;
phaseState=PhaseState.ACTION;
result=GodHelper.toWinJudge(""String_Node_Str"",gambleChoices,cardNumList,playerWinList,fireList);
}
break;
case ACTION:
if (playerState[playerIndex] == 0) {
depositAccount();
result=GodHelper.toDepositAccount(""String_Node_Str"",energyList);
playerState[playerIndex]+=1;
}
 else if (playerState[playerIndex] == 1) {
skillsAccount();
result=GodHelper.toSkillsAccount(""String_Node_Str"");
playerState[playerIndex]+=1;
}
 else if (playerState[playerIndex] == 2) {
fireAccount();
result=GodHelper.toFireAccount(""String_Node_Str"",healthPointList);
playerState[playerIndex]+=1;
}
 else if (playerState[playerIndex] == 3) {
moveAccount();
result=GodHelper.toMoveAccount(""String_Node_Str"",locationList);
playerState[playerIndex]+=1;
}
 else if (playerState[playerIndex] == 4) {
elemAccount();
result=GodHelper.toElemAccount(""String_Node_Str"",elementList);
playerState[playerIndex]+=1;
}
 else if (playerState[playerIndex] == 5) {
humanVictory();
if (humanWin) {
result=GodHelper.toHumanVictory(""String_Node_Str"");
playerState[playerIndex]=0;
gameState=GameState.END;
}
 else {
result=GodHelper.toHumanVictory(""String_Node_Str"");
playerState[playerIndex]+=1;
}
}
 else if (playerState[playerIndex] == 6) {
infectionAccount();
if (zombieWin) {
result=GodHelper.toInfectionAccount(""String_Node_Str"",teamList);
playerState[playerIndex]=0;
gameState=GameState.END;
}
 else {
result=GodHelper.toInfectionAccount(""String_Node_Str"",teamList);
playerState[playerIndex]+=1;
}
}
 else if (playerState[playerIndex] == 7) {
desertAccount(playerIndex,msg);
int[] playerHandCard=new int[allPlayers[playerIndex].handCardsNum];
for (int i=0; i < allPlayers[playerIndex].handCardsNum; i++) playerHandCard[i]=allPlayers[playerIndex].handCards[i];
result=GodHelper.toDesertAccount(""String_Node_Str"",allPlayers[playerIndex].energy,playerHandCard);
phaseState=PhaseState.PREPARE;
playerState[playerIndex]=0;
seen_card_count=0;
gamble_count=0;
desert_count=0;
for (int i=0; i < playerNum; i++) {
allPlayers[i].stratDecision=GambleChecker.DEPOSIT;
allPlayers[i].fireTarget=-1;
allPlayers[i].moveDirection=-1;
availableFireTarget[i]=-1;
availableMoveDirection[i]=-1;
decisionChoices[i]=GambleChecker.DEPOSIT;
seenCardChoices[i]=0;
gambleChoices[i]=GambleChecker.PAPER;
cardNumList[i]=0;
playerWinList[i]=0;
fireList[i]=-1;
}
}
break;
}
break;
case END:
result=GodHelper.toGameOver(""String_Node_Str"",scoreList);
break;
}
if (result.equals(""String_Node_Str"")) {
System.out.printf(""String_Node_Str"",sid,msg,gameState.toString());
}
return result;
}"
72257,"private void teamDivide(){
  int zombie=(int)(Math.random() * playerNum);
  allPlayers[zombie].team=Player.ZOMBIE;
  teamResult[zombie]=Player.ZOMBIE;
  for (int i=0; i < allPlayers.length; i++) {
    if (i != zombie) {
      allPlayers[i].team=Player.HUMAN;
      teamResult[i]=Player.HUMAN;
    }
  }
}","private void teamDivide(){
  int zombie=(int)(Math.random() * playerNum);
  allPlayers[zombie].team=Player.ZOMBIE;
  allPlayers[zombie].energy=0;
  allPlayers[zombie].hasElem=false;
  allPlayers[zombie].firePow=0;
  allPlayers[zombie].range=0;
  teamResult[zombie]=Player.ZOMBIE;
  for (int i=0; i < allPlayers.length; i++) {
    if (i != zombie) {
      allPlayers[i].team=Player.HUMAN;
      teamResult[i]=Player.HUMAN;
    }
  }
}"
72258,"static Boolean infection(Map map,Player playerPos,Player playerPas){
  if (playerPos.preLoc == playerPas.preLoc) {
    if (map.units[playerPos.preLoc].status == 1) {
      if (playerPos.team == Player.ZOMBIE & playerPas.team == Player.HUMAN) {
        playerPas.team=Player.ZOMBIE;
        playerPas.energy=0;
        playerPas.hasElem=false;
        playerPas.firePow=0;
        playerPas.range=0;
        playerPas.healthPoint=0;
        return true;
      }
    }
  }
  return false;
}","static Boolean infection(Map map,Player playerPos,Player playerPas){
  if (playerPos.preLoc == playerPas.preLoc) {
    if (map.units[playerPos.preLoc].status == 1) {
      if (playerPos.team == Player.ZOMBIE & playerPas.team == Player.HUMAN) {
        playerPas.team=Player.ZOMBIE;
        playerPas.energy=0;
        playerPas.hasElem=false;
        playerPas.firePow=0;
        playerPas.range=0;
        return true;
      }
    }
  }
  return false;
}"
72259,"static void winJudge(int playerNum,Player[] players){
  for (int i=0; i < playerNum; i++) {
    for (int j=0; j < playerNum; j++) {
      if (i == j)       continue;
      if (players[i].team == players[j].team)       continue;
      players[i].isWin=win(players[i],players[j]);
      if (players[i].isWin) {
        if (players[i].energy + players[i].gambleNum < players[i].healthPoint)         players[i].energy+=players[i].gambleNum;
 else         players[i].energy=players[i].healthPoint;
        break;
      }
    }
  }
}","static void winJudge(int playerNum,Player[] players){
  for (int i=0; i < playerNum; i++) {
    for (int j=0; j < playerNum; j++) {
      if (i == j)       continue;
      if (players[i].team == players[j].team)       continue;
      players[i].isWin=win(players[i],players[j]);
    }
  }
}"
72260,"public String request(int sid,String msg){
  int playerIndex=0;
  for (int i=0; i < playerNum; i++) {
    if (allPlayers[i].SID == sid) {
      playerIndex=i;
      break;
    }
  }
  String result=""String_Node_Str"";
switch (gameState) {
case INIT:
    if (playerState[playerIndex] == 0) {
      result=GodHelper.toInit(allUserInfo,""String_Node_Str"",heroList);
      playerState[playerIndex]+=1;
    }
 else     if (playerState[playerIndex] == 1) {
      heroChoose(sid,msg);
      gameState=GameState.MAINGAME;
      playerState[playerIndex]=0;
      result=GodHelper.toChooseHero(""String_Node_Str"",heroChoices,teamResult);
    }
  break;
case MAINGAME:
switch (phaseState) {
case PREPARE:
  if (playerState[playerIndex] == 0) {
    GambleChecker.cardDistribute(cardHeap,allPlayers[playerIndex],4);
    int[] playerHandCard=new int[allPlayers[playerIndex].handCardsNum];
    boolean isSeenCard=true;
    for (int i=0; i < allPlayers[playerIndex].handCardsNum; i++) {
      playerHandCard[i]=allPlayers[playerIndex].handCards[i];
      if ((allPlayers[playerIndex].handCards[i] == 1) | (allPlayers[playerIndex].handCards[i] == 2) | (allPlayers[playerIndex].handCards[i] == 3))       isSeenCard=false;
    }
    if (isSeenCard)     allPlayers[playerIndex].isSeenCard=true;
    result=GodHelper.toCardDistribute(""String_Node_Str"",playerHandCard);
    playerState[playerIndex]+=1;
  }
 else   if (playerState[playerIndex] == 1) {
    MsgChooseDecision dec=GodHelper.getChooseDecision(msg);
    if (dec.decision() == -1)     allPlayers[playerIndex].stratDecision=GambleChecker.DEPOSIT;
 else {
      allPlayers[playerIndex].stratDecision=allPlayers[playerIndex].handCards[dec.decision()];
      GambleChecker.cardToHeap(cardHeap,dec.decision());
      allPlayers[playerIndex].handCards[dec.decision()]=GambleChecker.NOTHING;
      GambleChecker.cardSort(allPlayers[playerIndex].handCards);
      allPlayers[playerIndex].handCardsNum-=1;
    }
    decisionChoices[playerIndex]=allPlayers[playerIndex].stratDecision;
    int[] playerHandCard=new int[allPlayers[playerIndex].handCardsNum];
    for (int i=0; i < allPlayers[playerIndex].handCardsNum; i++)     playerHandCard[i]=allPlayers[playerIndex].handCards[i];
    result=GodHelper.toChooseDecision(""String_Node_Str"",playerHandCard);
    playerState[playerIndex]+=1;
  }
 else   if (playerState[playerIndex] == 2) {
    featureChoose(msg,allPlayers[playerIndex]);
    playerState[playerIndex]+=1;
    result=GodHelper.toDecisionFeature(""String_Node_Str"");
  }
 else   if (playerState[playerIndex] == 3) {
    seenCard(playerIndex,msg,allPlayers[playerIndex]);
    result=GodHelper.toSeenCard(""String_Node_Str"",decisionChoices,seenCardChoices);
    phaseState=PhaseState.GAMBLE;
    playerState[playerIndex]=0;
  }
break;
case GAMBLE:
if (playerState[playerIndex] == 0) {
gambleChoose(msg,allPlayers[playerIndex],playerIndex);
playerState[playerIndex]+=1;
int[] playerHandCard=new int[allPlayers[playerIndex].handCardsNum];
for (int i=0; i < allPlayers[playerIndex].handCardsNum; i++) playerHandCard[i]=allPlayers[playerIndex].handCards[i];
result=GodHelper.toChooseGamble(""String_Node_Str"",playerHandCard);
}
if (playerState[playerIndex] == 1) {
winJudge();
for (int i=0; i < playerNum; i++) {
if (allPlayers[i].isWin) playerWinList[i]=1;
}
result=GodHelper.toWinJudge(""String_Node_Str"",gambleChoices,cardNumList,playerWinList);
}
break;
case ACTION:
break;
}
break;
}
if (result.equals(""String_Node_Str"")) {
System.out.printf(""String_Node_Str"",sid,msg,gameState.toString());
}
return result;
}","public String request(int sid,String msg){
  int playerIndex=0;
  for (int i=0; i < playerNum; i++) {
    if (allPlayers[i].SID == sid) {
      playerIndex=i;
      break;
    }
  }
  String result=""String_Node_Str"";
switch (gameState) {
case INIT:
    if (playerState[playerIndex] == 0) {
      result=GodHelper.toInit(allUserInfo,""String_Node_Str"",heroList);
      playerState[playerIndex]+=1;
    }
 else     if (playerState[playerIndex] == 1) {
      heroChoose(sid,msg);
      gameState=GameState.MAINGAME;
      playerState[playerIndex]=0;
      result=GodHelper.toChooseHero(""String_Node_Str"",heroChoices,teamResult);
    }
  break;
case MAINGAME:
switch (phaseState) {
case PREPARE:
  if (playerState[playerIndex] == 0) {
    GambleChecker.cardDistribute(cardHeap,allPlayers[playerIndex],4);
    int[] playerHandCard=new int[allPlayers[playerIndex].handCardsNum];
    boolean isSeenCard=true;
    for (int i=0; i < allPlayers[playerIndex].handCardsNum; i++) {
      playerHandCard[i]=allPlayers[playerIndex].handCards[i];
      if ((allPlayers[playerIndex].handCards[i] == 1) | (allPlayers[playerIndex].handCards[i] == 2) | (allPlayers[playerIndex].handCards[i] == 3))       isSeenCard=false;
    }
    if (isSeenCard)     allPlayers[playerIndex].isSeenCard=true;
    result=GodHelper.toCardDistribute(""String_Node_Str"",playerHandCard);
    playerState[playerIndex]+=1;
  }
 else   if (playerState[playerIndex] == 1) {
    MsgChooseDecision dec=GodHelper.getChooseDecision(msg);
    if (dec.decision() == -1)     allPlayers[playerIndex].stratDecision=GambleChecker.DEPOSIT;
 else {
      allPlayers[playerIndex].stratDecision=allPlayers[playerIndex].handCards[dec.decision()];
      GambleChecker.cardToHeap(cardHeap,dec.decision());
      allPlayers[playerIndex].handCards[dec.decision()]=GambleChecker.NOTHING;
      GambleChecker.cardSort(allPlayers[playerIndex].handCards);
      allPlayers[playerIndex].handCardsNum-=1;
    }
    decisionChoices[playerIndex]=allPlayers[playerIndex].stratDecision;
    int[] playerHandCard=new int[allPlayers[playerIndex].handCardsNum];
    for (int i=0; i < allPlayers[playerIndex].handCardsNum; i++)     playerHandCard[i]=allPlayers[playerIndex].handCards[i];
    result=GodHelper.toChooseDecision(""String_Node_Str"",playerHandCard);
    playerState[playerIndex]+=1;
  }
 else   if (playerState[playerIndex] == 2) {
    featureChoose(msg,allPlayers[playerIndex]);
    playerState[playerIndex]+=1;
    result=GodHelper.toDecisionFeature(""String_Node_Str"");
  }
 else   if (playerState[playerIndex] == 3) {
    seenCard(playerIndex,msg,allPlayers[playerIndex]);
    result=GodHelper.toSeenCard(""String_Node_Str"",decisionChoices,seenCardChoices);
    phaseState=PhaseState.GAMBLE;
    playerState[playerIndex]=0;
  }
break;
case GAMBLE:
if (playerState[playerIndex] == 0) {
gambleChoose(msg,allPlayers[playerIndex],playerIndex);
playerState[playerIndex]+=1;
int[] playerHandCard=new int[allPlayers[playerIndex].handCardsNum];
for (int i=0; i < allPlayers[playerIndex].handCardsNum; i++) playerHandCard[i]=allPlayers[playerIndex].handCards[i];
result=GodHelper.toChooseGamble(""String_Node_Str"",playerHandCard);
}
if (playerState[playerIndex] == 1) {
winJudge();
for (int i=0; i < playerNum; i++) {
if (allPlayers[i].isWin) playerWinList[i]=1;
}
playerState[playerIndex]=0;
phaseState=PhaseState.ACTION;
result=GodHelper.toWinJudge(""String_Node_Str"",gambleChoices,cardNumList,playerWinList);
}
break;
case ACTION:
break;
}
break;
}
if (result.equals(""String_Node_Str"")) {
System.out.printf(""String_Node_Str"",sid,msg,gameState.toString());
}
return result;
}"
72261,"private void featureChoose(String msg,Player playerMain){
  MsgDecisionFeature decisionFeature=GodHelper.getDecisionFeature(msg);
  int decision=playerMain.stratDecision;
  if (decision == GambleChecker.MOVE)   playerMain.moveDirection=decisionFeature.moveDirection();
 else   if (decision == GambleChecker.FIRE)   playerMain.fireTarget=decisionFeature.fireTarget();
}","private void featureChoose(String msg,Player playerMain){
  MsgDecisionFeature decisionFeature=GodHelper.getDecisionFeature(msg);
  int decision=playerMain.stratDecision;
  if (decision == GambleChecker.MOVE) {
    playerMain.moveDirection=decisionFeature.moveDirection();
    playerMain.energyConsume=Math.min(playerMain.energy,playerMain.mot);
  }
 else   if (decision == GambleChecker.FIRE) {
    playerMain.fireTarget=decisionFeature.fireTarget();
    playerMain.energyConsume=Math.min(playerMain.energy,playerMain.firePow);
  }
 else   if (decision == GambleChecker.DEPOSIT) {
    playerMain.energyConsume=0;
  }
}"
72262,"private void mapInit(){
  for (int i=0; i < playerNum; i++) {
    if (allPlayers[i].team == Player.HUMAN)     allPlayers[i].preLoc=map.units[4];
 else     if (allPlayers[i].team == Player.ZOMBIE)     allPlayers[i].preLoc=map.units[0];
  }
}","private void mapInit(){
  for (int i=0; i < playerNum; i++) {
    if (allPlayers[i].team == Player.HUMAN)     allPlayers[i].preLoc=map.fighter_init;
 else     if (allPlayers[i].team == Player.ZOMBIE)     allPlayers[i].preLoc=map.poisoner_init;
  }
}"
72263,"private void seenCard(int playerIndex,String msg,Player playerMain){
  MsgSeenCard msgSeenCard=GodHelper.getSeenCard(msg);
synchronized (this) {
    seen_card_count+=1;
    if ((playerMain.isSeenCard) | (msgSeenCard.seenCard() != 0)) {
      playerMain.gamble=msgSeenCard.seenCard();
      playerMain.isSeenCard=true;
      seenCardChoices[playerIndex]=1;
    }
    if (seen_card_count < playerNum) {
      while (seen_card_count < playerNum) {
        try {
          this.wait();
        }
 catch (        Exception ex) {
          ex.printStackTrace();
        }
      }
    }
 else {
      this.notifyAll();
    }
  }
}","private void seenCard(int playerIndex,String msg,Player playerMain){
  MsgSeenCard msgSeenCard=GodHelper.getSeenCard(msg);
synchronized (this) {
    seen_card_count+=1;
    if ((playerMain.isSeenCard) | (msgSeenCard.seenCard() != 0)) {
      playerMain.gamble=msgSeenCard.seenCard();
      playerMain.isSeenCard=true;
      seenCardChoices[playerIndex]=msgSeenCard.seenCard();
    }
    if (seen_card_count < playerNum) {
      while (seen_card_count < playerNum) {
        try {
          this.wait();
        }
 catch (        Exception ex) {
          ex.printStackTrace();
        }
      }
    }
 else {
      this.notifyAll();
    }
  }
}"
72264,"void infection(Player playerPos,Player playerPas){
  if (playerPos.preLoc == playerPas.preLoc) {
    if (playerPos.preLoc.status == 1) {
      if (playerPos.team == Player.ZOMBIE & playerPas.team == Player.HUMAN) {
        playerPas.team=Player.ZOMBIE;
        playerPas.energy=0;
        playerPas.hasElem=false;
        playerPas.firePow=0;
        playerPas.range=0;
        playerPas.healthPoint=0;
      }
    }
  }
}","static Boolean infection(Map map,Player playerPos,Player playerPas){
  if (playerPos.preLoc == playerPas.preLoc) {
    if (map.units[playerPos.preLoc].status == 1) {
      if (playerPos.team == Player.ZOMBIE & playerPas.team == Player.HUMAN) {
        playerPas.team=Player.ZOMBIE;
        playerPas.energy=0;
        playerPas.hasElem=false;
        playerPas.firePow=0;
        playerPas.range=0;
        playerPas.healthPoint=0;
        return true;
      }
    }
  }
  return false;
}"
72265,"static void energyAcq(Player playerMain,int energyVal){
  if (playerMain.energy < playerMain.healthPoint)   playerMain.energy+=energyVal;
}","static void energyAcq(Player playerMain,int energyVal){
  playerMain.energy+=energyVal;
}"
72266,"static void fire(Player playerPos,Player playerPas,MapEdge direction){
  distance=myMap.outDistance(playerPas.preLoc,playerPos.preLoc);
  if (playerPos.range >= distance) {
    playerPas.healthPoint-=playerPos.firePow;
  }
}","static void fire(Map map,Player playerPos,Player playerPas){
  distance=MapChecker.outDistance(map.units[playerPas.preLoc],map.units[playerPos.preLoc]);
  if (playerPos.range >= distance) {
    if (playerPas.healthPoint - playerPos.energyConsume > 4)     playerPas.healthPoint-=playerPos.energyConsume;
 else     playerPas.healthPoint=4;
  }
}"
72267,"public String request(int sid,String msg){
  int playerIndex=0;
  for (int i=0; i < playerNum; i++) {
    if (allPlayers[i].SID == sid) {
      playerIndex=i;
      break;
    }
  }
  String result=""String_Node_Str"";
switch (gameState) {
case INIT:
    if (playerState[playerIndex] == 0) {
      result=GodHelper.toInit(allUserInfo,""String_Node_Str"",heroList);
      playerState[playerIndex]+=1;
    }
 else     if (playerState[playerIndex] == 1) {
      heroChoose(sid,msg);
      gameState=GameState.MAINGAME;
      playerState[playerIndex]=0;
      result=GodHelper.toChooseHero(""String_Node_Str"",heroChoices,teamResult);
    }
  break;
case MAINGAME:
switch (phaseState) {
case PREPARE:
  if (playerState[playerIndex] == 0) {
    GambleChecker.cardDistribute(cardHeap,allPlayers[playerIndex],4);
    int[] playerHandCard=new int[allPlayers[playerIndex].handCardsNum];
    boolean isSeenCard=true;
    for (int i=0; i < allPlayers[playerIndex].handCardsNum; i++) {
      playerHandCard[i]=allPlayers[playerIndex].handCards[i];
      if ((allPlayers[playerIndex].handCards[i] == 1) || (allPlayers[playerIndex].handCards[i] == 2) || (allPlayers[playerIndex].handCards[i] == 3))       isSeenCard=false;
    }
    if (isSeenCard)     allPlayers[playerIndex].isSeenCard=true;
    result=GodHelper.toCardDistribute(""String_Node_Str"",playerHandCard);
    playerState[playerIndex]+=1;
  }
 else   if (playerState[playerIndex] == 1) {
    MsgChooseDecision dec=GodHelper.getChooseDecision(msg);
    allPlayers[playerIndex].stratDecision=allPlayers[playerIndex].handCards[dec.decision()];
    GambleChecker.cardToHeap(cardHeap,dec.decision());
    allPlayers[playerIndex].handCards[dec.decision()]=GambleChecker.NOTHING;
    GambleChecker.cardSort(allPlayers[playerIndex].handCards);
    allPlayers[playerIndex].handCardsNum-=1;
    result=GodHelper.toChooseDecision(""String_Node_Str"");
    playerState[playerIndex]+=1;
  }
 else   if (playerState[playerIndex] == 2) {
    featureChoose(sid,msg,allPlayers[playerIndex]);
    playerState[playerIndex]+=1;
    result=GodHelper.toDecisionFeature(""String_Node_Str"");
  }
 else   if (playerState[playerIndex] == 3) {
    seenCard(sid,msg,allPlayers[playerIndex]);
    result=GodHelper.toSeenCard(""String_Node_Str"");
    phaseState=PhaseState.GAMBLE;
    playerState[playerIndex]=0;
  }
break;
case GAMBLE:
if (playerState[playerIndex] == 0) break;
case ACTION:
break;
}
break;
}
if (result.equals(""String_Node_Str"")) {
System.out.printf(""String_Node_Str"",sid,msg,gameState.toString());
}
return result;
}","public String request(int sid,String msg){
  int playerIndex=0;
  for (int i=0; i < playerNum; i++) {
    if (allPlayers[i].SID == sid) {
      playerIndex=i;
      break;
    }
  }
  String result=""String_Node_Str"";
switch (gameState) {
case INIT:
    if (playerState[playerIndex] == 0) {
      result=GodHelper.toInit(allUserInfo,""String_Node_Str"",heroList);
      playerState[playerIndex]+=1;
    }
 else     if (playerState[playerIndex] == 1) {
      heroChoose(sid,msg);
      gameState=GameState.MAINGAME;
      playerState[playerIndex]=0;
      result=GodHelper.toChooseHero(""String_Node_Str"",heroChoices,teamResult);
    }
  break;
case MAINGAME:
switch (phaseState) {
case PREPARE:
  if (playerState[playerIndex] == 0) {
    GambleChecker.cardDistribute(cardHeap,allPlayers[playerIndex],4);
    int[] playerHandCard=new int[allPlayers[playerIndex].handCardsNum];
    boolean isSeenCard=true;
    for (int i=0; i < allPlayers[playerIndex].handCardsNum; i++) {
      playerHandCard[i]=allPlayers[playerIndex].handCards[i];
      if ((allPlayers[playerIndex].handCards[i] == 1) | (allPlayers[playerIndex].handCards[i] == 2) | (allPlayers[playerIndex].handCards[i] == 3))       isSeenCard=false;
    }
    if (isSeenCard)     allPlayers[playerIndex].isSeenCard=true;
    result=GodHelper.toCardDistribute(""String_Node_Str"",playerHandCard);
    playerState[playerIndex]+=1;
  }
 else   if (playerState[playerIndex] == 1) {
    MsgChooseDecision dec=GodHelper.getChooseDecision(msg);
    if (dec.decision() == -1)     allPlayers[playerIndex].stratDecision=GambleChecker.DEPOSIT;
 else {
      allPlayers[playerIndex].stratDecision=allPlayers[playerIndex].handCards[dec.decision()];
      GambleChecker.cardToHeap(cardHeap,dec.decision());
      allPlayers[playerIndex].handCards[dec.decision()]=GambleChecker.NOTHING;
      GambleChecker.cardSort(allPlayers[playerIndex].handCards);
      allPlayers[playerIndex].handCardsNum-=1;
    }
    result=GodHelper.toChooseDecision(""String_Node_Str"");
    playerState[playerIndex]+=1;
  }
 else   if (playerState[playerIndex] == 2) {
    featureChoose(sid,msg,allPlayers[playerIndex]);
    playerState[playerIndex]+=1;
    result=GodHelper.toDecisionFeature(""String_Node_Str"");
  }
 else   if (playerState[playerIndex] == 3) {
    seenCard(sid,msg,allPlayers[playerIndex]);
    result=GodHelper.toSeenCard(""String_Node_Str"",decisionChoices,seenCardChoices);
    phaseState=PhaseState.GAMBLE;
    playerState[playerIndex]=0;
  }
break;
case GAMBLE:
if (playerState[playerIndex] == 0) {
if (allPlayers[playerIndex].isSeenCard) {
  playerState[playerIndex]+=1;
}
}
break;
case ACTION:
break;
}
break;
}
if (result.equals(""String_Node_Str"")) {
System.out.printf(""String_Node_Str"",sid,msg,gameState.toString());
}
return result;
}"
72268,"public void initialPlayer(int[] playerSID){
  playerNum=playerSID.length;
  allPlayers=new Player[playerNum];
  allUserInfo=new UserInfo[playerNum];
  playerState=new int[playerNum];
  map=new Map(""String_Node_Str"");
  heroChoices=new String[playerNum];
  teamResult=new int[playerNum];
  cardHeap=new int[40 * playerNum];
  for (int i=0; i < playerNum; i++) {
    allPlayers[i]=new Player();
    allPlayers[i].SID=playerSID[i];
    allPlayers[i].handCardsNum=0;
    allPlayers[i].handCards=new int[allPlayers[i].healthPoint + 4];
    allPlayers[i].cardsDesertNum=0;
    allPlayers[i].cardsDesertList=new int[4];
    playerState[i]=0;
    Option<UserModel.User> user=UserController.getProfile(playerSID[i]);
    if (user.isEmpty())     allPlayers[i].user_info=GodHelper.ghostUser();
 else     allPlayers[i].user_info=user.get();
    allUserInfo[i]=new UserInfo(i,allPlayers[i].user_info.nickname());
  }
}","public void initialPlayer(int[] playerSID){
  playerNum=playerSID.length;
  allPlayers=new Player[playerNum];
  allUserInfo=new UserInfo[playerNum];
  playerState=new int[playerNum];
  map=new Map(""String_Node_Str"");
  heroChoices=new String[playerNum];
  teamResult=new int[playerNum];
  decisionChoices=new int[playerNum];
  seenCardChoices=new int[playerNum];
  cardHeap=new int[40 * playerNum];
  for (int i=0; i < playerNum; i++) {
    allPlayers[i]=new Player();
    allPlayers[i].SID=playerSID[i];
    allPlayers[i].handCardsNum=0;
    allPlayers[i].handCards=new int[allPlayers[i].healthPoint + 4];
    allPlayers[i].cardsDesertNum=0;
    allPlayers[i].cardsDesertList=new int[4];
    playerState[i]=0;
    Option<UserModel.User> user=UserController.getProfile(playerSID[i]);
    if (user.isEmpty())     allPlayers[i].user_info=GodHelper.ghostUser();
 else     allPlayers[i].user_info=user.get();
    allUserInfo[i]=new UserInfo(i,allPlayers[i].user_info.nickname());
  }
}"
72269,"static int[] cardHeapInit(int[] cardHeap,int playerNum){
  int i, j;
  cardHeap=new int[40 * playerNum];
  for (i=0; i < 8 * playerNum; i++) {
    cardHeap[i]=FIRE;
  }
  j=i;
  for (; i < j + 12 * playerNum; i++) {
    cardHeap[i]=MOVE;
  }
  j=i;
  for (; i < j + 8 * playerNum; i++) {
    cardHeap[i]=SKILLS;
  }
  j=i;
  for (; i < j + 4 * playerNum; i++) {
    cardHeap[i]=PAPER;
  }
  j=i;
  for (; i < j + 4 * playerNum; i++) {
    cardHeap[i]=SCISSORS;
  }
  j=i;
  for (; i < j + 4 * playerNum; i++) {
    cardHeap[i]=STONE;
  }
  return cardHeap;
}","static int[] cardHeapInit(int[] cardHeap,int playerNum){
  int i, j;
  for (i=0; i < 8 * playerNum; i++) {
    cardHeap[i]=FIRE;
  }
  j=i;
  for (; i < j + 12 * playerNum; i++) {
    cardHeap[i]=MOVE;
  }
  j=i;
  for (; i < j + 8 * playerNum; i++) {
    cardHeap[i]=SKILLS;
  }
  j=i;
  for (; i < j + 4 * playerNum; i++) {
    cardHeap[i]=PAPER;
  }
  j=i;
  for (; i < j + 4 * playerNum; i++) {
    cardHeap[i]=SCISSORS;
  }
  j=i;
  for (; i < j + 4 * playerNum; i++) {
    cardHeap[i]=STONE;
  }
  return cardHeap;
}"
72270,"public String request(int sid,String msg){
  int playerIndex=0;
  for (int i=0; i < playerNum; i++) {
    if (allPlayers[i].SID == sid) {
      playerIndex=i;
      break;
    }
  }
  String result=""String_Node_Str"";
switch (gameState) {
case INIT:
    if (playerState[playerIndex] == 0) {
      result=GodHelper.toInit(allUserInfo,""String_Node_Str"",heroList);
      playerState[playerIndex]+=1;
    }
 else     if (playerState[playerIndex] == 1) {
      heroChoose(sid,msg);
      gameState=GameState.MAINGAME;
      playerState[playerIndex]=0;
      result=GodHelper.toChooseHero(""String_Node_Str"",heroChoices,teamResult);
    }
  break;
case MAINGAME:
switch (phaseState) {
case PREPARE:
  if (playerState[playerIndex] == 0) {
    GambleChecker.cardDistribute(cardHeap,allPlayers[playerIndex],4);
    int[] playerHandCard=new int[allPlayers[playerIndex].handCardsNum];
    boolean isSeenCard=true;
    for (int i=0; i < allPlayers[playerIndex].handCardsNum; i++) {
      playerHandCard[i]=allPlayers[playerIndex].handCards[i];
      if ((allPlayers[playerIndex].handCards[i] == 1) | (allPlayers[playerIndex].handCards[i] == 2) | (allPlayers[playerIndex].handCards[i] == 3))       isSeenCard=false;
    }
    if (isSeenCard)     allPlayers[playerIndex].isSeenCard=true;
    result=GodHelper.toCardDistribute(""String_Node_Str"",playerHandCard);
    playerState[playerIndex]+=1;
  }
 else   if (playerState[playerIndex] == 1) {
    MsgChooseDecision dec=GodHelper.getChooseDecision(msg);
    allPlayers[playerIndex].stratDecision=allPlayers[playerIndex].handCards[dec.decision()];
    GambleChecker.cardToHeap(cardHeap,dec.decision());
    allPlayers[playerIndex].handCards[dec.decision()]=GambleChecker.NOTHING;
    GambleChecker.cardSort(allPlayers[playerIndex].handCards);
    allPlayers[playerIndex].handCardsNum-=1;
    result=GodHelper.toChooseDecision(""String_Node_Str"");
    playerState[playerIndex]+=1;
  }
 else   if (playerState[playerIndex] == 2) {
    featureChoose(sid,msg,allPlayers[playerIndex]);
    playerState[playerIndex]+=1;
    result=GodHelper.toDecisionFeature(""String_Node_Str"");
  }
 else   if (playerState[playerIndex] == 3) {
    if ((allPlayers[playerIndex].isSeenCard) | (GodHelper.getSeenCard(msg).seenCard() != 0)) {
      allPlayers[playerIndex].gamble=GodHelper.getSeenCard(msg).seenCard();
      allPlayers[playerIndex].isSeenCard=true;
    }
    result=GodHelper.toSeenCard(""String_Node_Str"");
    phaseState=PhaseState.GAMBLE;
    playerState[playerIndex]=0;
  }
break;
case GAMBLE:
if (playerState[playerIndex] == 0) {
}
break;
case ACTION:
break;
}
break;
}
if (result.equals(""String_Node_Str"")) {
System.out.printf(""String_Node_Str"",sid,msg,gameState.toString());
}
return result;
}","public String request(int sid,String msg){
  int playerIndex=0;
  for (int i=0; i < playerNum; i++) {
    if (allPlayers[i].SID == sid) {
      playerIndex=i;
      break;
    }
  }
  String result=""String_Node_Str"";
switch (gameState) {
case INIT:
    if (playerState[playerIndex] == 0) {
      result=GodHelper.toInit(allUserInfo,""String_Node_Str"",heroList);
      playerState[playerIndex]+=1;
    }
 else     if (playerState[playerIndex] == 1) {
      heroChoose(sid,msg);
      gameState=GameState.MAINGAME;
      playerState[playerIndex]=0;
      result=GodHelper.toChooseHero(""String_Node_Str"",heroChoices,teamResult);
    }
  break;
case MAINGAME:
switch (phaseState) {
case PREPARE:
  if (playerState[playerIndex] == 0) {
    GambleChecker.cardDistribute(cardHeap,allPlayers[playerIndex],4);
    int[] playerHandCard=new int[allPlayers[playerIndex].handCardsNum];
    boolean isSeenCard=true;
    for (int i=0; i < allPlayers[playerIndex].handCardsNum; i++) {
      playerHandCard[i]=allPlayers[playerIndex].handCards[i];
      if ((allPlayers[playerIndex].handCards[i] == 1) | (allPlayers[playerIndex].handCards[i] == 2) | (allPlayers[playerIndex].handCards[i] == 3))       isSeenCard=false;
    }
    if (isSeenCard)     allPlayers[playerIndex].isSeenCard=true;
    result=GodHelper.toCardDistribute(""String_Node_Str"",playerHandCard);
    playerState[playerIndex]+=1;
  }
 else   if (playerState[playerIndex] == 1) {
    MsgChooseDecision dec=GodHelper.getChooseDecision(msg);
    allPlayers[playerIndex].stratDecision=allPlayers[playerIndex].handCards[dec.decision()];
    GambleChecker.cardToHeap(cardHeap,dec.decision());
    allPlayers[playerIndex].handCards[dec.decision()]=GambleChecker.NOTHING;
    GambleChecker.cardSort(allPlayers[playerIndex].handCards);
    allPlayers[playerIndex].handCardsNum-=1;
    result=GodHelper.toChooseDecision(""String_Node_Str"");
    playerState[playerIndex]+=1;
  }
 else   if (playerState[playerIndex] == 2) {
    featureChoose(sid,msg,allPlayers[playerIndex]);
    playerState[playerIndex]+=1;
    result=GodHelper.toDecisionFeature(""String_Node_Str"");
  }
 else   if (playerState[playerIndex] == 3) {
    seenCard(sid,msg,allPlayers[playerIndex]);
    result=GodHelper.toSeenCard(""String_Node_Str"");
    phaseState=PhaseState.GAMBLE;
    playerState[playerIndex]=0;
  }
break;
case GAMBLE:
if (playerState[playerIndex] == 0) break;
case ACTION:
break;
}
break;
}
if (result.equals(""String_Node_Str"")) {
System.out.printf(""String_Node_Str"",sid,msg,gameState.toString());
}
return result;
}"
72271,"private void featureChoose(int sid,String msg,Player playerMain){
  int decision=playerMain.stratDecision;
  if (decision == GambleChecker.MOVE)   playerMain.moveDirection=GodHelper.getDecisionFeature(msg).moveDirection();
 else   if (decision == GambleChecker.FIRE)   playerMain.fireTarget=GodHelper.getDecisionFeature(msg).fireTarget();
synchronized (this) {
    feat_choice_count+=1;
    if (feat_choice_count < playerNum) {
      while (feat_choice_count < playerNum) {
        try {
          this.wait();
        }
 catch (        Exception ex) {
          ex.printStackTrace();
        }
      }
    }
 else {
      this.notifyAll();
    }
  }
}","private void featureChoose(int sid,String msg,Player playerMain){
  int decision=playerMain.stratDecision;
  if (decision == GambleChecker.MOVE)   playerMain.moveDirection=GodHelper.getDecisionFeature(msg).moveDirection();
 else   if (decision == GambleChecker.FIRE)   playerMain.fireTarget=GodHelper.getDecisionFeature(msg).fireTarget();
}"
72272,"public String request(int sid,String msg){
  int playerIndex=0;
  for (int i=0; i < playerNum; i++) {
    if (allPlayers[i].SID == sid) {
      playerIndex=i;
      break;
    }
  }
  String result=""String_Node_Str"";
switch (gameState) {
case INIT:
    if (playerState[playerIndex] == 0) {
      result=GodHelper.toInit(allUserInfo,""String_Node_Str"",heroList);
      playerState[playerIndex]+=1;
    }
 else     if (playerState[playerIndex] == 1) {
      heroChoose(sid,msg);
      gameState=GameState.MAINGAME;
      playerState[playerIndex]=0;
      result=GodHelper.toChooseHero(""String_Node_Str"",heroChoices,teamResult);
    }
  break;
case MAINGAME:
switch (phaseState) {
case PREPARE:
  if (playerState[playerIndex] == 0) {
    GambleChecker.cardDistribute(cardHeap,allPlayers[playerIndex],4);
    int[] playerHandCard=new int[allPlayers[playerIndex].handCardsNum];
    result=GodHelper.toCardDistribute(""String_Node_Str"",playerHandCard);
    playerState[playerIndex]+=1;
  }
 else   if (playerState[playerIndex] == 1) {
    MsgChooseDecision dec=GodHelper.getChooseDecision(msg);
    allPlayers[playerIndex].stratDecision=allPlayers[playerIndex].handCards[dec.decision()];
    GambleChecker.cardToHeap(cardHeap,dec.decision());
    allPlayers[playerIndex].handCards[dec.decision()]=GambleChecker.NOTHING;
    GambleChecker.cardSort(allPlayers[playerIndex].handCards);
    allPlayers[playerIndex].handCardsNum-=1;
    result=GodHelper.toChooseDecision(""String_Node_Str"");
    playerState[playerIndex]+=1;
  }
 else   if (playerState[playerIndex] == 2) {
    featureChoose(sid,msg,allPlayers[playerIndex]);
    phaseState=PhaseState.GAMBLE;
    playerState[playerIndex]=0;
  }
break;
case GAMBLE:
break;
case ACTION:
break;
}
break;
}
if (result.equals(""String_Node_Str"")) {
System.out.printf(""String_Node_Str"",sid,msg,gameState.toString());
}
return result;
}","public String request(int sid,String msg){
  int playerIndex=0;
  for (int i=0; i < playerNum; i++) {
    if (allPlayers[i].SID == sid) {
      playerIndex=i;
      break;
    }
  }
  String result=""String_Node_Str"";
switch (gameState) {
case INIT:
    if (playerState[playerIndex] == 0) {
      result=GodHelper.toInit(allUserInfo,""String_Node_Str"",heroList);
      playerState[playerIndex]+=1;
    }
 else     if (playerState[playerIndex] == 1) {
      heroChoose(sid,msg);
      gameState=GameState.MAINGAME;
      playerState[playerIndex]=0;
      result=GodHelper.toChooseHero(""String_Node_Str"",heroChoices,teamResult);
    }
  break;
case MAINGAME:
switch (phaseState) {
case PREPARE:
  if (playerState[playerIndex] == 0) {
    GambleChecker.cardDistribute(cardHeap,allPlayers[playerIndex],4);
    int[] playerHandCard=new int[allPlayers[playerIndex].handCardsNum];
    boolean isSeenCard=true;
    for (int i=0; i < allPlayers[playerIndex].handCardsNum; i++) {
      playerHandCard[i]=allPlayers[playerIndex].handCards[i];
      if ((allPlayers[playerIndex].handCards[i] == 1) | (allPlayers[playerIndex].handCards[i] == 2) | (allPlayers[playerIndex].handCards[i] == 3))       isSeenCard=false;
    }
    if (isSeenCard)     allPlayers[playerIndex].isSeenCard=true;
    result=GodHelper.toCardDistribute(""String_Node_Str"",playerHandCard);
    playerState[playerIndex]+=1;
  }
 else   if (playerState[playerIndex] == 1) {
    MsgChooseDecision dec=GodHelper.getChooseDecision(msg);
    allPlayers[playerIndex].stratDecision=allPlayers[playerIndex].handCards[dec.decision()];
    GambleChecker.cardToHeap(cardHeap,dec.decision());
    allPlayers[playerIndex].handCards[dec.decision()]=GambleChecker.NOTHING;
    GambleChecker.cardSort(allPlayers[playerIndex].handCards);
    allPlayers[playerIndex].handCardsNum-=1;
    result=GodHelper.toChooseDecision(""String_Node_Str"");
    playerState[playerIndex]+=1;
  }
 else   if (playerState[playerIndex] == 2) {
    featureChoose(sid,msg,allPlayers[playerIndex]);
    playerState[playerIndex]+=1;
    result=GodHelper.toDecisionFeature(""String_Node_Str"");
  }
 else   if (playerState[playerIndex] == 3) {
    phaseState=PhaseState.GAMBLE;
    playerState[playerIndex]=0;
  }
break;
case GAMBLE:
break;
case ACTION:
break;
}
break;
}
if (result.equals(""String_Node_Str"")) {
System.out.printf(""String_Node_Str"",sid,msg,gameState.toString());
}
return result;
}"
72273,"public String request(int sid,String msg){
  int playerIndex=0;
  for (int i=0; i < playerNum; i++) {
    if (allPlayers[i].SID == sid) {
      playerIndex=i;
      break;
    }
  }
  String result=""String_Node_Str"";
switch (gameState) {
case INIT:
    if (playerState[playerIndex] == 0) {
      result=GodHelper.toInit(allUserInfo,""String_Node_Str"",heroList);
      playerState[playerIndex]+=1;
    }
 else     if (playerState[playerIndex] == 1) {
      heroChoose(sid,msg);
      gameState=GameState.MAPINIT;
      playerState[playerIndex]=0;
      result=GodHelper.toChooseHero(""String_Node_Str"",heroChoices,teamResult);
    }
  break;
case MAPINIT:
break;
case MAINGAME:
switch (phaseState) {
case PREPARE:
if (playerState[playerIndex] == 0) {
  gc.cardDistribute(cardHeap,allPlayers[playerIndex],4);
  playerHandCard=new int[allPlayers[playerIndex].handCardsNum];
  result=GodHelper.toCardDistribute(""String_Node_Str"",playerHandCard);
  playerState[playerIndex]+=1;
}
 else if (playerState[playerIndex] == 1) {
  allPlayers[playerIndex].gamble=GodHelper.getChooseDecision(msg).decision();
  allPlayers[playerIndex].gambleNum=GodHelper.getChooseDecision(msg).cardNum();
  result=GodHelper.toChooseDecision(""String_Node_Str"");
  playerState[playerIndex]+=1;
}
 else if (playerState[playerIndex] == 2) {
  phaseState=PhaseState.GAMBLE;
}
break;
case GAMBLE:
break;
case ACTION:
break;
}
break;
}
if (result.equals(""String_Node_Str"")) {
System.out.printf(""String_Node_Str"",sid,msg,gameState.toString());
}
return result;
}","public String request(int sid,String msg){
  int playerIndex=0;
  for (int i=0; i < playerNum; i++) {
    if (allPlayers[i].SID == sid) {
      playerIndex=i;
      break;
    }
  }
  String result=""String_Node_Str"";
switch (gameState) {
case INIT:
    if (playerState[playerIndex] == 0) {
      result=GodHelper.toInit(allUserInfo,""String_Node_Str"",heroList);
      playerState[playerIndex]+=1;
    }
 else     if (playerState[playerIndex] == 1) {
      heroChoose(sid,msg);
      gameState=GameState.MAPINIT;
      playerState[playerIndex]=0;
      result=GodHelper.toChooseHero(""String_Node_Str"",heroChoices,teamResult);
    }
  break;
case MAPINIT:
break;
case MAINGAME:
switch (phaseState) {
case PREPARE:
if (playerState[playerIndex] == 0) {
  gc.cardDistribute(cardHeap,allPlayers[playerIndex],4);
  playerHandCard=new int[allPlayers[playerIndex].handCardsNum];
  result=GodHelper.toCardDistribute(""String_Node_Str"",playerHandCard);
  playerState[playerIndex]+=1;
}
 else if (playerState[playerIndex] == 1) {
  allPlayers[playerIndex].gamble=GodHelper.getChooseDecision(msg).decision();
  allPlayers[playerIndex].gambleNum=GodHelper.getChooseDecision(msg).cardNum();
  result=GodHelper.toChooseDecision(""String_Node_Str"");
  playerState[playerIndex]+=1;
}
 else if (playerState[playerIndex] == 2) {
  featureChoose(sid,msg);
  phaseState=PhaseState.GAMBLE;
  playerState[playerIndex]=0;
}
break;
case GAMBLE:
break;
case ACTION:
break;
}
break;
}
if (result.equals(""String_Node_Str"")) {
System.out.printf(""String_Node_Str"",sid,msg,gameState.toString());
}
return result;
}"
72274,"private void featureChoose(){
synchronized (this) {
    feat_choice_count+=1;
    if (feat_choice_count < playerNum) {
      while (feat_choice_count < playerNum) {
        try {
          this.wait();
        }
 catch (        Exception ex) {
          ex.printStackTrace();
        }
      }
    }
 else {
      this.notifyAll();
    }
  }
}","private void featureChoose(int sid,String msg){
synchronized (this) {
    feat_choice_count+=1;
    if (feat_choice_count < playerNum) {
      while (feat_choice_count < playerNum) {
        try {
          this.wait();
        }
 catch (        Exception ex) {
          ex.printStackTrace();
        }
      }
    }
 else {
      this.notifyAll();
    }
  }
}"
72275,"void cardDistribute(int[] cardHeap,Player playerMain,int cardNum){
  int distributedCardNum=0;
  for (int i=0; i < cardHeap.length; i++) {
    if (cardHeap[i] != NOTHING) {
      cardToPlayer(cardHeap[i],playerMain);
      cardHeap[i]=NOTHING;
      distributedCardNum++;
    }
    if (distributedCardNum == cardNum) {
      cardSort(playerMain.handCards);
      break;
    }
  }
}","static void cardDistribute(int[] cardHeap,Player playerMain,int cardNum){
  int distributedCardNum=0;
  for (int i=0; i < cardHeap.length; i++) {
    if (cardHeap[i] != NOTHING) {
      cardToPlayer(cardHeap[i],playerMain);
      cardHeap[i]=NOTHING;
      distributedCardNum++;
    }
    if (distributedCardNum == cardNum) {
      cardSort(playerMain.handCards);
      break;
    }
  }
}"
72276,"void cardToPlayer(int card,Player playerMain){
  for (int i=0; i < playerMain.handCards.length; i++) {
    if (playerMain.handCards[i] == NOTHING) {
      playerMain.handCards[i]=card;
      playerMain.handCardsNum++;
      break;
    }
  }
}","static void cardToPlayer(int card,Player playerMain){
  for (int i=0; i < playerMain.handCards.length; i++) {
    if (playerMain.handCards[i] == NOTHING) {
      playerMain.handCards[i]=card;
      playerMain.handCardsNum++;
      break;
    }
  }
}"
72277,"void cardToHeap(int[] cardHeap,int card){
  int i=(int)(Math.random() * cardHeap.length);
  while (cardHeap[i] != NOTHING)   i=(i + 1) % cardHeap.length;
  cardHeap[i]=card;
}","static void cardToHeap(int[] cardHeap,int card){
  int i=(int)(Math.random() * cardHeap.length);
  while (cardHeap[i] != NOTHING)   i=(i + 1) % cardHeap.length;
  cardHeap[i]=card;
}"
72278,"int[] cardHeapStir(int[] cardHeap){
  for (int i=0; i < cardHeap.length; i++) {
    int tmp=(int)(Math.random() * cardHeap.length);
    int tmpCard=cardHeap[i];
    cardHeap[i]=cardHeap[tmp];
    cardHeap[tmp]=tmpCard;
  }
  return cardHeap;
}","static int[] cardHeapStir(int[] cardHeap){
  for (int i=0; i < cardHeap.length; i++) {
    int tmp=(int)(Math.random() * cardHeap.length);
    int tmpCard=cardHeap[i];
    cardHeap[i]=cardHeap[tmp];
    cardHeap[tmp]=tmpCard;
  }
  return cardHeap;
}"
72279,"int[] cardHeapInit(int[] cardHeap,int playerNum){
  int i, j;
  cardHeap=new int[40 * playerNum];
  for (i=0; i < 8 * playerNum; i++) {
    cardHeap[i]=FIRE;
  }
  j=i;
  for (; i < j + 12 * playerNum; i++) {
    cardHeap[i]=MOVE;
  }
  j=i;
  for (; i < j + 8 * playerNum; i++) {
    cardHeap[i]=SKILLS;
  }
  j=i;
  for (; i < j + 4 * playerNum; i++) {
    cardHeap[i]=PAPER;
  }
  j=i;
  for (; i < j + 4 * playerNum; i++) {
    cardHeap[i]=SCISSORS;
  }
  j=i;
  for (; i < j + 4 * playerNum; i++) {
    cardHeap[i]=STONE;
  }
  return cardHeap;
}","static int[] cardHeapInit(int[] cardHeap,int playerNum){
  int i, j;
  cardHeap=new int[40 * playerNum];
  for (i=0; i < 8 * playerNum; i++) {
    cardHeap[i]=FIRE;
  }
  j=i;
  for (; i < j + 12 * playerNum; i++) {
    cardHeap[i]=MOVE;
  }
  j=i;
  for (; i < j + 8 * playerNum; i++) {
    cardHeap[i]=SKILLS;
  }
  j=i;
  for (; i < j + 4 * playerNum; i++) {
    cardHeap[i]=PAPER;
  }
  j=i;
  for (; i < j + 4 * playerNum; i++) {
    cardHeap[i]=SCISSORS;
  }
  j=i;
  for (; i < j + 4 * playerNum; i++) {
    cardHeap[i]=STONE;
  }
  return cardHeap;
}"
72280,"void cardDesert(Player playerMain,int[] cardHeap){
  if (playerMain.handCardsNum > playerMain.healthPoint) {
    playerMain.cardsDesertNum=playerMain.handCardsNum - playerMain.healthPoint;
    for (int i=0; i < playerMain.cardsDesertNum; i++) {
      if (playerMain.cardsDesertList[i] != -1) {
        cardToHeap(cardHeap,playerMain.handCards[playerMain.cardsDesertList[i]]);
        playerMain.handCards[playerMain.cardsDesertList[i]]=NOTHING;
        playerMain.handCardsNum--;
      }
    }
    cardSort(playerMain.handCards);
  }
}","static void cardDesert(Player playerMain,int[] cardHeap){
  if (playerMain.handCardsNum > playerMain.healthPoint) {
    playerMain.cardsDesertNum=playerMain.handCardsNum - playerMain.healthPoint;
    for (int i=0; i < playerMain.cardsDesertNum; i++) {
      if (playerMain.cardsDesertList[i] != -1) {
        cardToHeap(cardHeap,playerMain.handCards[playerMain.cardsDesertList[i]]);
        playerMain.handCards[playerMain.cardsDesertList[i]]=NOTHING;
        playerMain.handCardsNum--;
      }
    }
    cardSort(playerMain.handCards);
  }
}"
72281,"void cardSort(int[] cardHeap){
  for (int i=0; i < cardHeap.length; i++) {
    for (int j=i; j < cardHeap.length; j++) {
      if (cardHeap[i] < cardHeap[j]) {
        int tmp=cardHeap[i];
        cardHeap[i]=cardHeap[j];
        cardHeap[j]=tmp;
      }
    }
  }
}","static void cardSort(int[] cardHeap){
  for (int i=0; i < cardHeap.length; i++) {
    for (int j=i; j < cardHeap.length; j++) {
      if (cardHeap[i] < cardHeap[j]) {
        int tmp=cardHeap[i];
        cardHeap[i]=cardHeap[j];
        cardHeap[j]=tmp;
      }
    }
  }
}"
72282,"private void heroChoose(int sid,String msg){
  int playerIndex;
  String heroChoice;
  MsgChooseHero choose=GodHelper.getChooseHero(msg);
synchronized (this) {
    choice_count+=1;
    for (playerIndex=0; playerIndex < playerNum; playerIndex++) {
      if (allPlayers[playerIndex].SID == sid) {
        allPlayers[playerIndex].chara=choose.hero();
        heroChoices[playerIndex]=choose.hero();
      }
    }
    if (choice_count < playerNum) {
      while (choice_count < playerNum) {
        try {
          this.wait();
        }
 catch (        Exception ex) {
          ex.printStackTrace();
        }
      }
    }
 else {
      teamDivide();
      gc.cardHeapInit(cardHeap,playerNum);
      gc.cardHeapStir(cardHeap);
      this.notifyAll();
    }
  }
}","private void heroChoose(int sid,String msg){
  int playerIndex;
  String heroChoice;
  MsgChooseHero choose=GodHelper.getChooseHero(msg);
synchronized (this) {
    choice_count+=1;
    for (playerIndex=0; playerIndex < playerNum; playerIndex++) {
      if (allPlayers[playerIndex].SID == sid) {
        allPlayers[playerIndex].chara=choose.hero();
        heroChoices[playerIndex]=choose.hero();
      }
    }
    if (choice_count < playerNum) {
      while (choice_count < playerNum) {
        try {
          this.wait();
        }
 catch (        Exception ex) {
          ex.printStackTrace();
        }
      }
    }
 else {
      teamDivide();
      GambleChecker.cardHeapInit(cardHeap,playerNum);
      GambleChecker.cardHeapStir(cardHeap);
      this.notifyAll();
    }
  }
}"
72283,"public String request(int sid,String msg){
  int playerIndex=0;
  for (int i=0; i < playerNum; i++) {
    if (allPlayers[i].SID == sid) {
      playerIndex=i;
      break;
    }
  }
  String result=""String_Node_Str"";
switch (gameState) {
case INIT:
    if (playerState[playerIndex] == 0) {
      result=GodHelper.toInit(allUserInfo,""String_Node_Str"",heroList);
      playerState[playerIndex]+=1;
    }
 else     if (playerState[playerIndex] == 1) {
      heroChoose(sid,msg);
      gameState=GameState.MAPINIT;
      playerState[playerIndex]=0;
      result=GodHelper.toChooseHero(""String_Node_Str"",heroChoices,teamResult);
    }
  break;
case MAPINIT:
break;
case MAINGAME:
switch (phaseState) {
case PREPARE:
if (playerState[playerIndex] == 0) {
  gc.cardDistribute(cardHeap,allPlayers[playerIndex],4);
  playerHandCard=new int[allPlayers[playerIndex].handCardsNum];
  result=GodHelper.toCardDistribute(""String_Node_Str"",playerHandCard);
  playerState[playerIndex]+=1;
}
 else if (playerState[playerIndex] == 1) {
  allPlayers[playerIndex].gamble=GodHelper.getChooseDecision(msg).decision();
  allPlayers[playerIndex].gambleNum=GodHelper.getChooseDecision(msg).cardNum();
  result=GodHelper.toChooseDecision(""String_Node_Str"");
  playerState[playerIndex]+=1;
}
 else if (playerState[playerIndex] == 2) {
  featureChoose(sid,msg);
  phaseState=PhaseState.GAMBLE;
  playerState[playerIndex]=0;
}
break;
case GAMBLE:
break;
case ACTION:
break;
}
break;
}
if (result.equals(""String_Node_Str"")) {
System.out.printf(""String_Node_Str"",sid,msg,gameState.toString());
}
return result;
}","public String request(int sid,String msg){
  int playerIndex=0;
  for (int i=0; i < playerNum; i++) {
    if (allPlayers[i].SID == sid) {
      playerIndex=i;
      break;
    }
  }
  String result=""String_Node_Str"";
switch (gameState) {
case INIT:
    if (playerState[playerIndex] == 0) {
      result=GodHelper.toInit(allUserInfo,""String_Node_Str"",heroList);
      playerState[playerIndex]+=1;
    }
 else     if (playerState[playerIndex] == 1) {
      heroChoose(sid,msg);
      gameState=GameState.MAINGAME;
      playerState[playerIndex]=0;
      result=GodHelper.toChooseHero(""String_Node_Str"",heroChoices,teamResult);
    }
  break;
case MAINGAME:
switch (phaseState) {
case PREPARE:
  if (playerState[playerIndex] == 0) {
    GambleChecker.cardDistribute(cardHeap,allPlayers[playerIndex],4);
    playerHandCard=new int[allPlayers[playerIndex].handCardsNum];
    result=GodHelper.toCardDistribute(""String_Node_Str"",playerHandCard);
    playerState[playerIndex]+=1;
  }
 else   if (playerState[playerIndex] == 1) {
    MsgChooseDecision des=GodHelper.getChooseDecision(msg);
    allPlayers[playerIndex].gamble=des.decision();
    allPlayers[playerIndex].gambleNum=des.cardNum();
    result=GodHelper.toChooseDecision(""String_Node_Str"");
    playerState[playerIndex]+=1;
  }
 else   if (playerState[playerIndex] == 2) {
    featureChoose(sid,msg);
    phaseState=PhaseState.GAMBLE;
    playerState[playerIndex]=0;
  }
break;
case GAMBLE:
break;
case ACTION:
break;
}
break;
}
if (result.equals(""String_Node_Str"")) {
System.out.printf(""String_Node_Str"",sid,msg,gameState.toString());
}
return result;
}"
72284,"public void initialPlayer(int[] playerSID){
  playerNum=playerSID.length;
  allPlayers=new Player[playerNum];
  allUserInfo=new UserInfo[playerNum];
  playerState=new int[playerNum];
  heroChoices=new String[playerNum];
  teamResult=new int[playerNum];
  for (int i=0; i < playerNum; i++) {
    allPlayers[i]=new Player();
    allPlayers[i].SID=playerSID[i];
    allPlayers[i].handCardsNum=0;
    allPlayers[i].handCards=new int[40 * playerNum];
    allPlayers[i].cardsDesertNum=0;
    allPlayers[i].cardsDesertList=new int[40 * playerNum];
    playerState[i]=0;
    Option<UserModel.User> user=UserController.getProfile(playerSID[i]);
    if (user.isEmpty())     allPlayers[i].user_info=GodHelper.ghostUser();
 else     allPlayers[i].user_info=user.get();
    allUserInfo[i]=new UserInfo(i,allPlayers[i].user_info.nickname());
  }
}","public void initialPlayer(int[] playerSID){
  playerNum=playerSID.length;
  allPlayers=new Player[playerNum];
  allUserInfo=new UserInfo[playerNum];
  playerState=new int[playerNum];
  heroChoices=new String[playerNum];
  teamResult=new int[playerNum];
  cardHeap=new int[playerNum];
  for (int i=0; i < playerNum; i++) {
    allPlayers[i]=new Player();
    allPlayers[i].SID=playerSID[i];
    allPlayers[i].handCardsNum=0;
    allPlayers[i].handCards=new int[40 * playerNum];
    allPlayers[i].cardsDesertNum=0;
    allPlayers[i].cardsDesertList=new int[40 * playerNum];
    playerState[i]=0;
    Option<UserModel.User> user=UserController.getProfile(playerSID[i]);
    if (user.isEmpty())     allPlayers[i].user_info=GodHelper.ghostUser();
 else     allPlayers[i].user_info=user.get();
    allUserInfo[i]=new UserInfo(i,allPlayers[i].user_info.nickname());
  }
}"
72285,"public void initialPlayer(int[] playerSID){
  int playerNum=playerSID.length;
  allPlayers=new Player[playerNum];
  allUserInfo=new UserInfo[playerNum];
  heroChoices=new String[playerNum];
  teamResult=new int[playerNum];
  allPlayers=new Player[playerNum];
  allUserInfo=new UserInfo[playerNum];
  for (int i=0; i < playerNum; i++) {
    allPlayers[i]=new Player();
    allPlayers[i].SID=playerSID[i];
    allUserInfo[i]=new UserInfo(i,allPlayers[i].nickName);
  }
}","public void initialPlayer(int[] playerSID){
  playerNum=playerSID.length;
  allPlayers=new Player[playerNum];
  allUserInfo=new UserInfo[playerNum];
  heroChoices=new String[playerNum];
  teamResult=new int[playerNum];
  allPlayers=new Player[playerNum];
  allUserInfo=new UserInfo[playerNum];
  for (int i=0; i < playerNum; i++) {
    allPlayers[i]=new Player();
    allPlayers[i].SID=playerSID[i];
    Option<UserModel.User> user=UserController.getProfile(playerSID[i]);
    if (user.isEmpty())     allPlayers[i].user_info=GodHelper.ghostUser();
 else     allPlayers[i].user_info=user.get();
    allUserInfo[i]=new UserInfo(i,allPlayers[i].user_info.nickname());
  }
}"
72286,"private void teamDivide(Player[] allPlayer){
  int zombie=(int)(Math.random() * allPlayer.length);
  allPlayer[zombie].team=Player.ZOMBIE;
  teamResult[zombie]=Player.ZOMBIE;
  for (int i=0; i < allPlayer.length; i++) {
    if (i != zombie) {
      allPlayer[i].team=Player.HUMAN;
      teamResult[i]=Player.HUMAN;
    }
  }
  ;
}","private void teamDivide(Player[] allPlayer){
  int zombie=(int)(Math.random() * allPlayer.length);
  allPlayer[zombie].team=Player.ZOMBIE;
  teamResult[zombie]=Player.ZOMBIE;
  for (int i=0; i < allPlayer.length; i++) {
    if (i != zombie) {
      allPlayer[i].team=Player.HUMAN;
      teamResult[i]=Player.HUMAN;
    }
  }
}"
72287,"private void heroChoose(int sid,String msg){
  int playerIndex;
  String heroChoice;
  MsgChooseHero choose=GodHelper.getChooseHero(msg);
synchronized (this) {
    choice_count+=1;
    for (playerIndex=0; playerIndex < playerNum; playerIndex++) {
      if (allPlayers[playerIndex].SID == sid) {
        allPlayers[playerIndex].chara=choose.hero();
        heroChoices[playerIndex]=choose.hero();
      }
    }
    if (choice_count < playerNum) {
      while (choice_count < playerNum) {
        try {
          this.wait();
        }
 catch (        Exception ex) {
          ex.printStackTrace();
        }
      }
    }
 else {
      this.notifyAll();
    }
  }
}","private void heroChoose(int sid,String msg){
  int playerIndex;
  String heroChoice;
  MsgChooseHero choose=GodHelper.getChooseHero(msg);
synchronized (this) {
    choice_count+=1;
    for (playerIndex=0; playerIndex < playerNum; playerIndex++) {
      if (allPlayers[playerIndex].SID == sid) {
        allPlayers[playerIndex].chara=choose.hero();
        heroChoices[playerIndex]=choose.hero();
      }
    }
    if (choice_count < playerNum) {
      while (choice_count < playerNum) {
        try {
          this.wait();
        }
 catch (        Exception ex) {
          ex.printStackTrace();
        }
      }
    }
 else {
      teamDivide();
      this.notifyAll();
    }
  }
}"
72288,"public String request(int sid,String msg){
}","public String request(int sid,String msg){
  int playerIndex=0;
  for (int i=0; i < playerNum; i++) {
    if (allPlayers[i].SID == sid) {
      playerIndex=i;
      break;
    }
  }
  String result=""String_Node_Str"";
switch (gameState) {
case INIT:
    if (playerState[playerIndex] == 0) {
      result=GodHelper.toInit(allUserInfo,""String_Node_Str"",heroList);
      playerState[playerIndex]=1;
    }
 else     if (playerState[playerIndex] == 1) {
      heroChoose(sid,msg);
      gameState=GameState.MAPINIT;
      playerState[playerIndex]=0;
      result=GodHelper.toChooseHero(""String_Node_Str"",heroChoices,teamResult);
    }
  break;
case MAPINIT:
break;
}
if (result.equals(""String_Node_Str"")) {
System.out.printf(""String_Node_Str"",sid,msg,gameState.toString());
}
return result;
}"
72289,"private void teamDivide(Player[] allPlayer){
  int zombie=(int)(Math.random() * allPlayer.length);
  allPlayer[zombie].team=Player.ZOMBIE;
  teamResult[zombie]=Player.ZOMBIE;
  for (int i=0; i < allPlayer.length; i++) {
    if (i != zombie) {
      allPlayer[i].team=Player.HUMAN;
      teamResult[i]=Player.HUMAN;
    }
  }
}","private void teamDivide(){
  int zombie=(int)(Math.random() * playerNum);
  allPlayers[zombie].team=Player.ZOMBIE;
  teamResult[zombie]=Player.ZOMBIE;
  for (int i=0; i < allPlayers.length; i++) {
    if (i != zombie) {
      allPlayers[i].team=Player.HUMAN;
      teamResult[i]=Player.HUMAN;
    }
  }
}"
72290,"@Then(""String_Node_Str"") public void there_should_be_result_for(int count,String searchTerm,String sadf){
  int actual=searchResultsPage.resultsLink(searchTerm).size();
  assertEquals(count,actual,""String_Node_Str"");
}","@Then(""String_Node_Str"") public void there_should_be_result_for(int count,String searchTerm){
  int actual=searchResultsPage.resultsLink(searchTerm).size();
  assertEquals(actual,count,""String_Node_Str"");
}"
72291,"private void fullBuildTemporaryHTMLFilesAndShowAfter(){
  String htmlInternalPreview=null;
  String htmlExternalBrowser=null;
  try {
    safeAsyncExec(() -> AsciiDoctorEditorUtil.removeScriptErrors(AsciiDoctorEditor.this));
    File editorFile=getEditorFile();
    String content=null;
    File fileToConvertIntoHTML=null;
    if (editorFile == null) {
      String asciiDoc=getDocumentText();
      fileToConvertIntoHTML=resolveFileToConvertToHTMLAndConvertBeforeWhenNecessary(asciiDoc);
    }
 else {
      fileToConvertIntoHTML=resolveFileToConvertToHTMLAndConvertBeforeWhenNecessary(editorFile);
    }
    if (fileToConvertIntoHTML == null) {
      return;
    }
    asciidoctorWrapper.convertToHTML(fileToConvertIntoHTML);
    content=readFileCreatedByAsciiDoctor(fileToConvertIntoHTML);
    int refreshAutomaticallyInSeconds=AsciiDoctorEditorPreferences.getInstance().getAutoRefreshInSecondsForExternalBrowser();
    htmlInternalPreview=asciidoctorWrapper.buildHTMLWithCSS(content,0);
    htmlExternalBrowser=asciidoctorWrapper.buildHTMLWithCSS(content,refreshAutomaticallyInSeconds);
    try {
      AsciiDocStringUtils.writeTextToUTF8File(htmlInternalPreview,temporaryInternalPreviewFile);
      AsciiDocStringUtils.writeTextToUTF8File(htmlExternalBrowser,temporaryExternalPreviewFile);
    }
 catch (    IOException e1) {
      AsciiDoctorEditorUtil.logError(""String_Node_Str"",e1);
    }
  }
 catch (  Throwable e) {
    StringBuilder htmlSb=new StringBuilder();
    htmlSb.append(""String_Node_Str"");
    if (e.getClass().getName().startsWith(""String_Node_Str"")) {
      htmlSb.append(""String_Node_Str"");
    }
 else {
      htmlSb.append(""String_Node_Str"");
    }
    htmlSb.append(""String_Node_Str"");
    safeAsyncExec(() -> {
      String errorMessage=e.getClass().getSimpleName() + ""String_Node_Str"" + SimpleExceptionUtils.getRootMessage(e);
      AsciiDoctorErrorBuilder builder=new AsciiDoctorErrorBuilder();
      AsciiDoctorError error=builder.build(errorMessage);
      browserAccess.safeBrowserSetText(htmlSb.toString());
      AsciiDoctorEditorUtil.addScriptError(AsciiDoctorEditor.this,-1,error,IMarker.SEVERITY_ERROR);
      AsciiDoctorEditorUtil.logError(""String_Node_Str"" + e.getMessage(),e);
    }
);
  }
}","private void fullBuildTemporaryHTMLFilesAndShowAfter(){
  String htmlInternalPreview=null;
  String htmlExternalBrowser=null;
  try {
    safeAsyncExec(() -> AsciiDoctorEditorUtil.removeScriptErrors(AsciiDoctorEditor.this));
    File editorFileOrNull=getEditorFileOrNull();
    String content=null;
    File fileToConvertIntoHTML=null;
    if (editorFileOrNull == null) {
      String asciiDoc=getDocumentText();
      fileToConvertIntoHTML=resolveFileToConvertToHTMLAndConvertBeforeWhenNecessary(asciiDoc);
    }
 else {
      fileToConvertIntoHTML=resolveFileToConvertToHTMLAndConvertBeforeWhenNecessary(editorFileOrNull);
    }
    if (fileToConvertIntoHTML == null) {
      return;
    }
    asciidoctorWrapper.convertToHTML(fileToConvertIntoHTML);
    content=readFileCreatedByAsciiDoctor(fileToConvertIntoHTML);
    int refreshAutomaticallyInSeconds=AsciiDoctorEditorPreferences.getInstance().getAutoRefreshInSecondsForExternalBrowser();
    htmlInternalPreview=asciidoctorWrapper.buildHTMLWithCSS(content,0);
    htmlExternalBrowser=asciidoctorWrapper.buildHTMLWithCSS(content,refreshAutomaticallyInSeconds);
    try {
      AsciiDocStringUtils.writeTextToUTF8File(htmlInternalPreview,temporaryInternalPreviewFile);
      AsciiDocStringUtils.writeTextToUTF8File(htmlExternalBrowser,temporaryExternalPreviewFile);
    }
 catch (    IOException e1) {
      AsciiDoctorEditorUtil.logError(""String_Node_Str"",e1);
    }
  }
 catch (  Throwable e) {
    StringBuilder htmlSb=new StringBuilder();
    htmlSb.append(""String_Node_Str"");
    if (e.getClass().getName().startsWith(""String_Node_Str"")) {
      htmlSb.append(""String_Node_Str"");
    }
 else {
      htmlSb.append(""String_Node_Str"");
    }
    htmlSb.append(""String_Node_Str"");
    safeAsyncExec(() -> {
      String errorMessage=e.getClass().getSimpleName() + ""String_Node_Str"" + SimpleExceptionUtils.getRootMessage(e);
      AsciiDoctorErrorBuilder builder=new AsciiDoctorErrorBuilder();
      AsciiDoctorError error=builder.build(errorMessage);
      browserAccess.safeBrowserSetText(htmlSb.toString());
      AsciiDoctorEditorUtil.addScriptError(AsciiDoctorEditor.this,-1,error,IMarker.SEVERITY_ERROR);
      AsciiDoctorEditorUtil.logError(""String_Node_Str"" + e.getMessage(),e);
    }
);
  }
}"
72292,"protected void initPreview(SashForm sashForm){
  temporaryInternalPreviewFile=asciidoctorWrapper.getTempFileFor(getEditorFile(),TemporaryFileType.INTERNAL_PREVIEW);
  temporaryExternalPreviewFile=asciidoctorWrapper.getTempFileFor(getEditorFile(),TemporaryFileType.EXTERNAL_PREVIEW);
  browserAccess.ensureBrowser(new BrowserContentInitializer(){
    @Override public void initialize(    Browser browser){
    }
  }
);
  showRebuildingInPreviewAndTriggerFullHTMLRebuildAsJob();
  PreviewLayout layout=getLayoutMode();
  if (layout.isExternal()) {
    setPreviewVisible(false);
  }
 else {
    setPreviewVisible(true);
    setVerticalSplit(layout.isVertical());
  }
}","protected void initPreview(SashForm sashForm){
  File editorFileOrNull=getEditorFileOrNull();
  if (editorFileOrNull == null) {
    setErrorMessage(""String_Node_Str"");
    return;
  }
  temporaryInternalPreviewFile=asciidoctorWrapper.getTempFileFor(editorFileOrNull,TemporaryFileType.INTERNAL_PREVIEW);
  temporaryExternalPreviewFile=asciidoctorWrapper.getTempFileFor(editorFileOrNull,TemporaryFileType.EXTERNAL_PREVIEW);
  browserAccess.ensureBrowser(new BrowserContentInitializer(){
    @Override public void initialize(    Browser browser){
    }
  }
);
  showRebuildingInPreviewAndTriggerFullHTMLRebuildAsJob();
  PreviewLayout layout=getLayoutMode();
  if (layout.isExternal()) {
    setPreviewVisible(false);
  }
 else {
    setPreviewVisible(true);
    setVerticalSplit(layout.isVertical());
  }
}"
72293,"public void openInclude(String fileName){
  IWorkbenchPage activePage=getActivePage();
  File file=new File(getEditorFile().getParentFile(),fileName);
  if (!file.exists()) {
    MessageDialog.openWarning(getActiveWorkbenchShell(),""String_Node_Str"",""String_Node_Str"" + fileName);
    return;
  }
  try {
    IDE.openEditor(activePage,file.toURI(),AsciiDoctorEditor.EDITOR_ID,true);
    return;
  }
 catch (  PartInitException e) {
    AsciiDoctorEditorUtil.logError(""String_Node_Str"",e);
  }
}","public void openInclude(String fileName){
  IWorkbenchPage activePage=getActivePage();
  File editorFileOrNull=getEditorFileOrNull();
  if (editorFileOrNull == null) {
    MessageDialog.openWarning(getActiveWorkbenchShell(),""String_Node_Str"",""String_Node_Str"" + fileName);
    return;
  }
  File file=new File(editorFileOrNull.getParentFile(),fileName);
  if (!file.exists()) {
    MessageDialog.openWarning(getActiveWorkbenchShell(),""String_Node_Str"",""String_Node_Str"" + fileName);
    return;
  }
  try {
    IDE.openEditor(activePage,file.toURI(),AsciiDoctorEditor.EDITOR_ID,true);
    return;
  }
 catch (  PartInitException e) {
    AsciiDoctorEditorUtil.logError(""String_Node_Str"",e);
  }
}"
72294,"private Map<String,Object> getDefaultOptions(File baseDir,String sourceImagesDir){
  Attributes attrs;
  File targetImagesDir=null;
  if (tempFolder == null) {
    initTempFolderOrFail();
  }
  targetImagesDir=new File(tempFolder.toFile(),""String_Node_Str"");
  targetImagesDir.deleteOnExit();
  copyImagesToOutputFolder(sourceImagesDir,targetImagesDir);
  AttributesBuilder attrBuilder=AttributesBuilder.attributes().showTitle(true).sourceHighlighter(""String_Node_Str"").attribute(""String_Node_Str"",createAbsolutePath(targetImagesDir.toPath())).attribute(""String_Node_Str"",""String_Node_Str"").attribute(""String_Node_Str"",""String_Node_Str"").attribute(""String_Node_Str"",""String_Node_Str"").attribute(""String_Node_Str"",""String_Node_Str"").attribute(""String_Node_Str"");
  Map<String,Object> cachedAttributes=getCachedAttributes(baseDir);
  for (  String key : cachedAttributes.keySet()) {
    Object value=cachedAttributes.get(key);
    if (value != null && value.toString().isEmpty()) {
      if (""String_Node_Str"".equals(key)) {
        continue;
      }
      attrBuilder.attribute(key,value);
    }
  }
  if (isTocVisible()) {
    attrBuilder.attribute(""String_Node_Str"",""String_Node_Str"");
    int tocLevels=AsciiDoctorEditorPreferences.getInstance().getIntegerPreference(AsciiDoctorEditorPreferenceConstants.P_EDITOR_TOC_LEVELS);
    if (tocLevels != 0) {
      attrBuilder.attribute(""String_Node_Str"",""String_Node_Str"" + tocLevels);
    }
  }
  if (targetImagesDir != null) {
    attrBuilder.imagesDir(targetImagesDir.getAbsolutePath());
  }
  attrs=attrBuilder.get();
  if (tempFolder != null) {
    System.out.println(""String_Node_Str"" + tempFolder);
    attrs.setAttribute(""String_Node_Str"",createAbsolutePath(tempFolder));
  }
  File destionationFolder=null;
  if (tempFolder != null) {
    destionationFolder=tempFolder.toFile();
  }
 else {
    destionationFolder=baseDir;
  }
  OptionsBuilder opts=OptionsBuilder.options().toDir(destionationFolder).safe(SafeMode.UNSAFE).backend(""String_Node_Str"").headerFooter(tocVisible).attributes(attrs).option(""String_Node_Str"",""String_Node_Str"").baseDir(baseDir);
  return opts.asMap();
}","private Map<String,Object> getDefaultOptions(File asciidocFile,File baseDir,String sourceImagesDir){
  Attributes attrs;
  File targetImagesDir=null;
  if (tempFolder == null) {
    initTempFolderOrFail();
  }
  targetImagesDir=new File(tempFolder.toFile(),""String_Node_Str"");
  targetImagesDir.deleteOnExit();
  copyImagesToOutputFolder(sourceImagesDir,targetImagesDir);
  AttributesBuilder attrBuilder=AttributesBuilder.attributes().showTitle(true).sourceHighlighter(""String_Node_Str"").attribute(""String_Node_Str"",createAbsolutePath(targetImagesDir.toPath())).attribute(""String_Node_Str"",""String_Node_Str"").attribute(""String_Node_Str"",""String_Node_Str"").attribute(""String_Node_Str"",""String_Node_Str"").attribute(""String_Node_Str"",""String_Node_Str"").attribute(""String_Node_Str"");
  Map<String,Object> cachedAttributes=getCachedAttributes(baseDir);
  for (  String key : cachedAttributes.keySet()) {
    Object value=cachedAttributes.get(key);
    if (value != null && value.toString().isEmpty()) {
      if (""String_Node_Str"".equals(key)) {
        continue;
      }
      attrBuilder.attribute(key,value);
    }
  }
  if (isTocVisible()) {
    attrBuilder.attribute(""String_Node_Str"",""String_Node_Str"");
    int tocLevels=AsciiDoctorEditorPreferences.getInstance().getIntegerPreference(AsciiDoctorEditorPreferenceConstants.P_EDITOR_TOC_LEVELS);
    if (tocLevels != 0) {
      attrBuilder.attribute(""String_Node_Str"",""String_Node_Str"" + tocLevels);
    }
  }
  if (targetImagesDir != null) {
    attrBuilder.imagesDir(targetImagesDir.getAbsolutePath());
  }
  attrs=attrBuilder.get();
  if (tempFolder != null) {
    System.out.println(""String_Node_Str"" + tempFolder);
    attrs.setAttribute(""String_Node_Str"",createAbsolutePath(tempFolder));
  }
  File destionationFolder=null;
  if (tempFolder != null) {
    destionationFolder=tempFolder.toFile();
  }
 else {
    destionationFolder=baseDir;
  }
  OptionsBuilder opts=OptionsBuilder.options().toDir(destionationFolder).safe(SafeMode.UNSAFE).backend(""String_Node_Str"").headerFooter(tocVisible).attributes(attrs).option(""String_Node_Str"",""String_Node_Str"").baseDir(asciidocFile != null ? asciidocFile.getParentFile() : baseDir);
  return opts.asMap();
}"
72295,"/** 
 * This method should normally only be used when we have no file access - e.g. in compare modes etc.
 * @param asciiDoc
 * @return html string
 * @throws Exception 
 */
public String convertToHTML(String asciiDoc) throws Exception {
  File baseFile=new File(""String_Node_Str"");
  String imagesPath=asciiDoc.indexOf(""String_Node_Str"") == -1 ? baseFile.getAbsolutePath() : null;
  try {
    return getAsciiDoctor().convert(asciiDoc,getDefaultOptions(baseFile,imagesPath));
  }
 catch (  Exception e) {
    logAdapter.logError(""String_Node_Str"",e);
    throw e;
  }
}","/** 
 * This method should normally only be used when we have no file access - e.g. in compare modes etc.
 * @param asciiDoc
 * @return html string
 * @throws Exception 
 */
public String convertToHTML(String asciiDoc) throws Exception {
  File baseFile=new File(""String_Node_Str"");
  String imagesPath=asciiDoc.indexOf(""String_Node_Str"") == -1 ? baseFile.getAbsolutePath() : null;
  try {
    return getAsciiDoctor().convert(asciiDoc,getDefaultOptions(null,baseFile,imagesPath));
  }
 catch (  Exception e) {
    logAdapter.logError(""String_Node_Str"",e);
    throw e;
  }
}"
72296,"@Override public IHyperlinkDetector[] getHyperlinkDetectors(ISourceViewer sourceViewer){
  if (sourceViewer == null)   return null;
  return new IHyperlinkDetector[]{new URLHyperlinkDetector(),new AsciiDoctorEditorHyperlinkDetector(adaptable)};
}","@Override public IHyperlinkDetector[] getHyperlinkDetectors(ISourceViewer sourceViewer){
  if (sourceViewer == null) {
    return null;
  }
  return new IHyperlinkDetector[]{new AsciiDoctorURLHyperlinkDetector(),new AsciiDoctorEditorLinkTextHyperlinkDetector(adaptable)};
}"
72297,"public AsciiDoctorDocumentPartitionScanner(){
  IToken boldText=createToken(TEXT_BOLD);
  IToken hyperlink=createToken(HYPERLINK);
  IToken comment=createToken(COMMENT);
  IToken textBlock=createToken(TEXT_BLOCK);
  IToken knownVariables=createToken(KNOWN_VARIABLES);
  IToken variables=createToken(VARIABLES);
  IToken includeKeyword=createToken(INCLUDE_KEYWORD);
  IToken asciidoctorCommand=createToken(ASCIIDOCTOR_COMMAND);
  IToken headline=createToken(HEADLINE);
  List<IPredicateRule> rules=new ArrayList<>();
  rules.add(new AsciiDoctorVariableRule(variables));
  rules.add(new SingleLineRule(""String_Node_Str"",""String_Node_Str"",hyperlink,(char)-1,true));
  rules.add(new SingleLineRule(""String_Node_Str"",""String_Node_Str"",hyperlink,(char)-1,true));
  aLineStartsWith(""String_Node_Str"",rules,headline);
  aLineStartsWith(""String_Node_Str"",rules,headline);
  aLineStartsWith(""String_Node_Str"",rules,headline);
  aLineStartsWith(""String_Node_Str"",rules,headline);
  aLineStartsWith(""String_Node_Str"",rules,headline);
  aLineStartsWith(""String_Node_Str"",rules,headline);
  aLineStartsWith(""String_Node_Str"",rules,asciidoctorCommand);
  aLineStartsWith(""String_Node_Str"",rules,asciidoctorCommand,true);
  aLineStartsWith(""String_Node_Str"",rules,asciidoctorCommand,true);
  aLineStartsWith(""String_Node_Str"",rules,asciidoctorCommand,true);
  aLineStartsWith(""String_Node_Str"",rules,asciidoctorCommand,true);
  aLineStartsWith(""String_Node_Str"",rules,asciidoctorCommand,true);
  rules.add(new AsciiDoctorLineStartsWithRule(""String_Node_Str"",""String_Node_Str"",false,asciidoctorCommand));
  rules.add(new AsciiDoctorLineStartsWithRule(""String_Node_Str"",""String_Node_Str"",false,asciidoctorCommand));
  rules.add(new AsciiDoctorLineStartsWithRule(""String_Node_Str"",""String_Node_Str"",true,comment));
  rules.add(new AsciiDoctorLineStartsWithRule(""String_Node_Str"",null,false,comment));
  rules.add(new AsciiDoctorStringRule(""String_Node_Str"",""String_Node_Str"",textBlock));
  rules.add(new AsciiDoctorLineStartsWithRule(""String_Node_Str"",""String_Node_Str"",true,textBlock));
  rules.add(new SingleLineRule(""String_Node_Str"",""String_Node_Str"",boldText,(char)-1,true));
  rules.add(new SingleLineRule(""String_Node_Str"",""String_Node_Str"",boldText,(char)-1,true));
  buildLineStartsWithRule(rules,asciidoctorCommand,""String_Node_Str"",AsciiDoctorCommandKeyWords.values());
  buildLineStartsWithRule(rules,includeKeyword,""String_Node_Str"",AsciiDoctorIncludeKeywords.values());
  buildLineStartsWithRule(rules,knownVariables,""String_Node_Str"",AsciiDoctorSpecialAttributesKeyWords.values());
  setPredicateRules(rules.toArray(new IPredicateRule[rules.size()]));
}","public AsciiDoctorDocumentPartitionScanner(){
  IToken boldText=createToken(TEXT_BOLD);
  IToken hyperlink=createToken(HYPERLINK);
  IToken comment=createToken(COMMENT);
  IToken textBlock=createToken(TEXT_BLOCK);
  IToken knownVariables=createToken(KNOWN_VARIABLES);
  IToken variables=createToken(VARIABLES);
  IToken includeKeyword=createToken(INCLUDE_KEYWORD);
  IToken asciidoctorCommand=createToken(ASCIIDOCTOR_COMMAND);
  IToken headline=createToken(HEADLINE);
  List<IPredicateRule> rules=new ArrayList<>();
  rules.add(new AsciiDoctorVariableRule(variables));
  rules.add(new AsciiDoctorURLHyperlinkRule(hyperlink));
  aLineStartsWith(""String_Node_Str"",rules,headline);
  aLineStartsWith(""String_Node_Str"",rules,headline);
  aLineStartsWith(""String_Node_Str"",rules,headline);
  aLineStartsWith(""String_Node_Str"",rules,headline);
  aLineStartsWith(""String_Node_Str"",rules,headline);
  aLineStartsWith(""String_Node_Str"",rules,headline);
  aLineStartsWith(""String_Node_Str"",rules,asciidoctorCommand);
  aLineStartsWith(""String_Node_Str"",rules,asciidoctorCommand,true);
  aLineStartsWith(""String_Node_Str"",rules,asciidoctorCommand,true);
  aLineStartsWith(""String_Node_Str"",rules,asciidoctorCommand,true);
  aLineStartsWith(""String_Node_Str"",rules,asciidoctorCommand,true);
  aLineStartsWith(""String_Node_Str"",rules,asciidoctorCommand,true);
  rules.add(new AsciiDoctorLineStartsWithRule(""String_Node_Str"",""String_Node_Str"",false,asciidoctorCommand));
  rules.add(new AsciiDoctorLineStartsWithRule(""String_Node_Str"",""String_Node_Str"",false,asciidoctorCommand));
  rules.add(new AsciiDoctorLineStartsWithRule(""String_Node_Str"",""String_Node_Str"",true,comment));
  rules.add(new AsciiDoctorLineStartsWithRule(""String_Node_Str"",null,false,comment));
  rules.add(new AsciiDoctorStringRule(""String_Node_Str"",""String_Node_Str"",textBlock));
  rules.add(new AsciiDoctorLineStartsWithRule(""String_Node_Str"",""String_Node_Str"",true,textBlock));
  rules.add(new SingleLineRule(""String_Node_Str"",""String_Node_Str"",boldText,(char)-1,true));
  rules.add(new SingleLineRule(""String_Node_Str"",""String_Node_Str"",boldText,(char)-1,true));
  buildLineStartsWithRule(rules,asciidoctorCommand,""String_Node_Str"",AsciiDoctorCommandKeyWords.values());
  buildLineStartsWithRule(rules,includeKeyword,""String_Node_Str"",AsciiDoctorIncludeKeywords.values());
  buildLineStartsWithRule(rules,knownVariables,""String_Node_Str"",AsciiDoctorSpecialAttributesKeyWords.values());
  setPredicateRules(rules.toArray(new IPredicateRule[rules.size()]));
}"
72298,"@Override public void onMethodCall(MethodCall call,Result result){
switch (call.method) {
case SCHEDULE_NOTIFICATION_METHOD_NAME:
    if (call.arguments != null && call.arguments instanceof List) {
      AlarmScheduler.scheduleNotification((List<Object>)call.arguments,getActiveContext());
    }
  break;
case UNSCHEDULE_NOTIFICATION_METHOD_NAME:
AlarmScheduler.unscheduleNotifications(getActiveContext());
break;
case SET_NOTIFICATION_ICON_METHOD_NAME:
if (call.arguments != null && call.arguments instanceof List) {
setNotificationIcon((List<Object>)call.arguments);
}
break;
default :
result.notImplemented();
}
}","@Override public void onMethodCall(MethodCall call,Result result){
  AlarmScheduler.initialize(getActiveContext());
switch (call.method) {
case SCHEDULE_NOTIFICATION_METHOD_NAME:
    if (call.arguments != null && call.arguments instanceof List) {
      AlarmScheduler.scheduleNotification((List<Object>)call.arguments,getActiveContext());
    }
  break;
case UNSCHEDULE_NOTIFICATION_METHOD_NAME:
AlarmScheduler.unscheduleNotifications(getActiveContext());
break;
case SET_NOTIFICATION_ICON_METHOD_NAME:
if (call.arguments != null && call.arguments instanceof List) {
setNotificationIcon((List<Object>)call.arguments);
}
break;
default :
result.notImplemented();
}
}"
72299,"/** 
 * Clear the preferences.
 * @param context The context.
 */
public static void clear(Context context){
  SharedPreferences.Editor editor=getPreferences(context).edit();
  editor.clear();
  editor.apply();
}","/** 
 * Clear the preferences.
 * @param context The context.
 */
public static void clear(Context context){
  SharedPreferences.Editor editor=getPreferences(context).edit();
  int icon=getIcon(context);
  editor.clear();
  editor.putInt(ICON_KEY,icon);
  editor.apply();
}"
72300,"@Override public void onReceive(Context context,Intent intent){
  if (intent.getAction().equals(""String_Node_Str"")) {
    AlarmScheduler.rescheduleNotifications(context);
  }
}","@Override public void onReceive(Context context,Intent intent){
  if (intent.getAction().equals(""String_Node_Str"")) {
    AlarmScheduler.initialize(context);
    AlarmScheduler.rescheduleNotifications(context);
  }
}"
72301,"/** 
 * Schedule a notification.
 * @param title Notification title.
 * @param date Date to schedule.
 * @param repeatAt Days to repeat the alarm.
 * @param context The context.
 */
private static void scheduleNotification(String title,Date date,List<Integer> repeatAt,Context context){
  sAlarmManager=(AlarmManager)context.getSystemService(Context.ALARM_SERVICE);
  if (repeatAt.size() > 0) {
    scheduleRepeatNotification(date,title,repeatAt,context);
  }
 else {
    scheduleOneShotNotification(date,title,context);
  }
}","/** 
 * Schedule a notification.
 * @param title Notification title.
 * @param date Date to schedule.
 * @param repeatAt Days to repeat the alarm.
 * @param context The context.
 */
private static void scheduleNotification(String title,Date date,List<Integer> repeatAt,Context context){
  if (repeatAt.size() > 0) {
    scheduleRepeatNotification(date,title,repeatAt,context);
  }
 else {
    scheduleOneShotNotification(date,title,context);
  }
}"
72302,"/** 
 * Schedule one shot notification.
 * @param when Date to schedule.
 * @param title Notification title.
 */
private void scheduleOneShotNotification(Date when,String title){
  if (when != null) {
    Date now=new Date();
    Date scheduleDate;
    if (when.getTime() > now.getTime()) {
      scheduleDate=when;
    }
 else {
      Calendar calendar=Calendar.getInstance();
      calendar.setTime(when);
      calendar.add(Calendar.DATE,1);
      scheduleDate=calendar.getTime();
    }
    Log.i(LOG_TAG,""String_Node_Str"" + scheduleDate);
    mAlarmManager.set(AlarmManager.RTC_WAKEUP,scheduleDate.getTime(),getNotificationIntent(title));
  }
}","/** 
 * Schedule one shot notification.
 * @param when Date to schedule.
 * @param title Notification title.
 */
private void scheduleOneShotNotification(Date when,String title){
  if (when != null) {
    Date now=new Date();
    Date scheduleDate;
    if (when.getTime() > now.getTime()) {
      scheduleDate=when;
    }
 else {
      Calendar calendar=Calendar.getInstance();
      calendar.setTime(when);
      calendar.add(Calendar.DATE,1);
      scheduleDate=calendar.getTime();
    }
    Log.i(LOG_TAG,""String_Node_Str"" + scheduleDate);
    mAlarmManager.set(AlarmManager.RTC_WAKEUP,scheduleDate.getTime(),getNotificationIntent(title,0));
  }
}"
72303,"/** 
 * Get the notification intent.
 * @param title Notification title
 * @return Notification Intent.
 */
private PendingIntent getNotificationIntent(String title){
  Intent intent=new Intent(getActiveContext(),AlarmReceiver.class);
  intent.putExtra(IntentConstants.TITLE_PARAM,title);
  return PendingIntent.getBroadcast(getActiveContext(),0,intent,0);
}","/** 
 * Get the notification intent.
 * @param title Notification title
 * @param requestCode Notification request code.
 * @return Notification Intent.
 */
private PendingIntent getNotificationIntent(String title,int requestCode){
  Intent intent=new Intent(getActiveContext(),AlarmReceiver.class);
  intent.putExtra(IntentConstants.TITLE_PARAM,title);
  return PendingIntent.getBroadcast(getActiveContext(),requestCode,intent,0);
}"
72304,"/** 
 * Unschedule notifications.
 */
private void unscheduleNotifications(){
  Log.i(LOG_TAG,""String_Node_Str"");
  Intent intent=new Intent(getActiveContext(),AlarmReceiver.class);
  PendingIntent pendingIntent=PendingIntent.getBroadcast(getActiveContext(),0,intent,0);
  pendingIntent.cancel();
  mAlarmManager.cancel(pendingIntent);
}","/** 
 * Unschedule notifications.
 */
private void unscheduleNotifications(){
  Log.i(LOG_TAG,""String_Node_Str"");
  for (int day=0; day <= 7; day++) {
    Intent intent=new Intent(getActiveContext(),AlarmReceiver.class);
    PendingIntent pendingIntent=PendingIntent.getBroadcast(getActiveContext(),day,intent,0);
    pendingIntent.cancel();
    mAlarmManager.cancel(pendingIntent);
  }
}"
72305,"/** 
 * Schedule repeat notification.
 * @param when Date to schedule.
 * @param title Notification title.
 * @param repeatAt Days to repeat notification.
 */
private void scheduleRepeatNotification(Date when,String title,List<Integer> repeatAt){
  Calendar calendar=Calendar.getInstance();
  PendingIntent notificationIntent=getNotificationIntent(title);
  for (  int day : repeatAt) {
    calendar.setTime(when);
    calendar.set(Calendar.SECOND,0);
    calendar.set(Calendar.DAY_OF_WEEK,day + 1);
    Date scheduleDate=calendar.getTime();
    Log.i(LOG_TAG,""String_Node_Str"" + scheduleDate);
    mAlarmManager.setInexactRepeating(AlarmManager.RTC_WAKEUP,scheduleDate.getTime(),AlarmManager.INTERVAL_DAY * 7,notificationIntent);
  }
}","/** 
 * Schedule repeat notification.
 * @param when Date to schedule.
 * @param title Notification title.
 * @param repeatAt Days to repeat notification.
 */
private void scheduleRepeatNotification(Date when,String title,List<Integer> repeatAt){
  Calendar calendar=Calendar.getInstance();
  for (  int day : repeatAt) {
    calendar.setTime(when);
    calendar.set(Calendar.SECOND,0);
    calendar.set(Calendar.DAY_OF_WEEK,day + 1);
    Date scheduleDate=calendar.getTime();
    Log.i(LOG_TAG,""String_Node_Str"" + scheduleDate);
    mAlarmManager.setInexactRepeating(AlarmManager.RTC_WAKEUP,scheduleDate.getTime(),AlarmManager.INTERVAL_DAY * 7,getNotificationIntent(title,day));
  }
}"
72306,"@Override protected void channelRead0(ChannelHandlerContext ctx,BasePackage msg) throws Exception {
  try {
switch (msg.getMsgType()) {
case BasePackage.HEART_BEAT:
      log.debug(""String_Node_Str"" + ctx.channel().id().asShortText());
    ctx.channel().writeAndFlush(msg);
  break;
case BasePackage.INITIAL_REQUEST:
log.debug(""String_Node_Str"" + ctx.channel().id().asShortText());
synchronized (this) {
InitialRequestPackage requestMsg=(InitialRequestPackage)msg;
if (CollectionUtils.isEmpty(requestMsg.getContextNames())) {
  ctx.close();
  break;
}
log.info(String.format(""String_Node_Str"",requestMsg.getClientName(),StringUtils.join(requestMsg.getContextNames(),""String_Node_Str"")));
if (clientSession == null) {
  clientSession=new ClientSession(requestMsg.getClientName(),ctx.channel());
}
 else {
  clientSession.setClientChannel(ctx.channel());
}
requestMsg.getContextNames().stream().forEach((contextName) -> {
  if (!oneNetServer.getContexts().containsKey(contextName)) {
    ctx.channel().writeAndFlush(new MessagePackage(String.format(""String_Node_Str"",contextName)));
  }
 else {
    OneNetServerContextConfig config=oneNetServer.getContexts().get(contextName).getOneNetServerContextConfig();
    ctx.channel().writeAndFlush(new InitialResponsePackage(contextName,config.isZip(),config.isAes(),config.getKBps()));
    oneNetServer.getOneNetTcpConnectionManager().registerClientSession(contextName,clientSession);
  }
}
);
}
break;
case BasePackage.INVALID_SESSION:
log.debug(""String_Node_Str"" + ctx.channel().id().asShortText());
OneNetServerContext oneNetServerContext=oneNetServer.getContexts().get(msg.getContextName());
if (oneNetServerContext != null) {
oneNetServerContext.close(msg.getSessionId());
}
break;
case BasePackage.DATA:
log.debug(""String_Node_Str"" + ctx.channel().id().asShortText());
oneNetServerContext=oneNetServer.getContexts().get(msg.getContextName());
if (oneNetServerContext == null) {
return;
}
;
OneNetSession oneNetSession=oneNetServerContext.getOneNetSessions().get(msg.getSessionId());
if (oneNetSession != null) {
DataPackage dataPackage=(DataPackage)msg;
byte[] outputData=dataPackage.getRawData();
oneNetSession.getInternetChannel().writeAndFlush(outputData);
}
 else {
if (oneNetSession.getClientSession() != null && oneNetSession.getClientSession().getClientChannel() != null) {
oneNetSession.getClientSession().getClientChannel().writeAndFlush(new InvalidSessionPackage(msg.getContextName(),msg.getSessionId()));
log.info(""String_Node_Str"" + msg.getSessionId());
}
}
}
}
 catch (Exception ex) {
ex.printStackTrace();
}
}","@Override protected void channelRead0(ChannelHandlerContext ctx,BasePackage msg) throws Exception {
  try {
switch (msg.getMsgType()) {
case BasePackage.HEART_BEAT:
      log.debug(""String_Node_Str"" + ctx.channel().id().asShortText());
    ctx.channel().writeAndFlush(msg);
  this.clientSession.setLastHeartBeatTime(new Date());
break;
case BasePackage.INITIAL_REQUEST:
log.debug(""String_Node_Str"" + ctx.channel().id().asShortText());
synchronized (this) {
InitialRequestPackage requestMsg=(InitialRequestPackage)msg;
if (CollectionUtils.isEmpty(requestMsg.getContextNames())) {
ctx.close();
break;
}
log.info(String.format(""String_Node_Str"",requestMsg.getClientName(),StringUtils.join(requestMsg.getContextNames(),""String_Node_Str"")));
clientSession=new ClientSession(requestMsg.getClientName(),ctx.channel(),new Date());
requestMsg.getContextNames().stream().forEach((contextName) -> {
if (!oneNetServer.getContexts().containsKey(contextName)) {
  ctx.channel().writeAndFlush(new MessagePackage(String.format(""String_Node_Str"",contextName)));
}
 else {
  OneNetServerContextConfig config=oneNetServer.getContexts().get(contextName).getOneNetServerContextConfig();
  ctx.channel().writeAndFlush(new InitialResponsePackage(contextName,config.isZip(),config.isAes(),config.getKBps()));
  oneNetServer.getOneNetTcpConnectionManager().registerClientSession(contextName,requestMsg.getClientName(),clientSession);
}
}
);
}
break;
case BasePackage.INVALID_SESSION:
log.debug(""String_Node_Str"" + ctx.channel().id().asShortText());
OneNetServerContext oneNetServerContext=oneNetServer.getContexts().get(msg.getContextName());
if (oneNetServerContext != null) {
oneNetServerContext.close(msg.getSessionId());
}
break;
case BasePackage.DATA:
log.debug(""String_Node_Str"" + ctx.channel().id().asShortText());
oneNetServerContext=oneNetServer.getContexts().get(msg.getContextName());
if (oneNetServerContext == null) {
return;
}
;
OneNetSession oneNetSession=oneNetServerContext.getOneNetSessions().get(msg.getSessionId());
if (oneNetSession != null) {
DataPackage dataPackage=(DataPackage)msg;
byte[] outputData=dataPackage.getRawData();
oneNetSession.getInternetChannel().writeAndFlush(outputData);
}
 else {
if (oneNetSession.getClientSession() != null && oneNetSession.getClientSession().getClientChannel() != null) {
oneNetSession.getClientSession().getClientChannel().writeAndFlush(new InvalidSessionPackage(msg.getContextName(),msg.getSessionId()));
log.info(""String_Node_Str"" + msg.getSessionId());
}
}
}
}
 catch (Exception ex) {
ex.printStackTrace();
}
}"
72307,"public void registerClientSession(String name,ClientSession clientSession){
  List<ClientSession> sessions=this.getContextNameSessionMap().getOrDefault(name,new LinkedList<>());
  if (!sessions.contains(clientSession)) {
    sessions.add(clientSession);
  }
  this.getContextNameSessionMap().putIfAbsent(name,sessions);
}","public void registerClientSession(String contextName,String clientName,ClientSession clientSession){
  HashMap<String,ClientSession> clientSessionMap=this.getContextNameSessionMap().getOrDefault(contextName,new HashMap<>());
  if (clientSessionMap.containsKey(clientName)) {
    ClientSession oldSession=clientSessionMap.replace(clientName,clientSession);
    oldSession.close();
  }
 else {
    clientSessionMap.putIfAbsent(clientName,clientSession);
  }
  this.getContextNameSessionMap().putIfAbsent(contextName,clientSessionMap);
}"
72308,"@Override public ClientSession getAvailableSession(String contextName){
  if (!this.getContextNameSessionMap().containsKey(contextName)) {
    return null;
  }
  List<ClientSession> sessions=getContextNameSessionMap().get(contextName);
  return getSession(sessions);
}","@Override public ClientSession getAvailableSession(String contextName){
  if (!this.getContextNameSessionMap().containsKey(contextName)) {
    return null;
  }
  Map sessionsMap=getContextNameSessionMap().get(contextName);
  return getSession(new ArrayList<>(sessionsMap.values()));
}"
72309,"public boolean isActive(){
  return clientChannel != null && clientChannel.isOpen();
}","public boolean isActive(){
  Calendar ruleTime=Calendar.getInstance();
  ruleTime.add(Calendar.SECOND,-5);
  return lastHeartBeatTime.compareTo(ruleTime.getTime()) > 0;
}"
72310,"public static Channel createChannel(final String ip,final int port,ChannelInitializer channelInitializer){
  ChannelFuture channelFuture=null;
  try {
    channelFuture=bootstrap.handler(channelInitializer).connect(ip,port).sync();
    return channelFuture.channel();
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
  return null;
}","public static Channel createChannel(final String ip,final int port,ChannelInitializer channelInitializer){
  ChannelFuture channelFuture=null;
  try {
    channelFuture=bootstrap.handler(channelInitializer).connect(ip,port);
    if (channelFuture.await(200,TimeUnit.MILLISECONDS)) {
      return channelFuture.channel();
    }
 else {
      log.error(String.format(""String_Node_Str"",ip,port));
      return null;
    }
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
  return null;
}"
72311,"private GenericObjectPoolConfig getGenericObjectPoolConfig(){
  GenericObjectPoolConfig poolConfig=new GenericObjectPoolConfig();
  if (oneNetClientContextConfig.getPoolConfig() != null) {
    BeanUtils.copyProperties(oneNetClientContextConfig.getPoolConfig(),poolConfig);
  }
  return poolConfig;
}","private GenericObjectPoolConfig getGenericObjectPoolConfig(){
  GenericObjectPoolConfig poolConfig=new GenericObjectPoolConfig();
  if (oneNetClientContextConfig.getPoolConfig() != null) {
    BeanUtils.copyProperties(oneNetClientContextConfig.getPoolConfig(),poolConfig);
  }
  poolConfig.setLifo(false);
  return poolConfig;
}"
72312,"public void returnChannel(Channel channel){
  if (!oneNetClientContextConfig.isLocalPool()) {
    channel.close();
  }
 else {
    log.debug(""String_Node_Str"" + localPool.getNumActive() + ""String_Node_Str""+ localPool.getNumIdle());
    try {
      if (channel.isActive()) {
        localPool.returnObject(channel);
      }
 else {
        removeFromPool(channel);
      }
    }
 catch (    Exception e) {
      log.info(e.getMessage() + localPool.getNumActive() + ""String_Node_Str""+ localPool.getNumIdle());
    }
    log.debug(""String_Node_Str"" + localPool.getNumActive() + ""String_Node_Str""+ localPool.getNumIdle());
  }
}","public void returnChannel(Channel channel){
  if (!oneNetClientContextConfig.isLocalPool()) {
    channel.close();
  }
 else {
    try {
      localPool.returnObject(channel);
    }
 catch (    Exception e) {
      log.info(e.getMessage() + localPool.getNumActive() + ""String_Node_Str""+ localPool.getNumIdle());
    }
  }
}"
72313,"public void removeFromPool(Channel channel){
  try {
    localPool.invalidateObject(channel);
  }
 catch (  Exception e) {
    log.info(e.getMessage() + localPool.getNumActive() + ""String_Node_Str""+ localPool.getNumIdle());
  }
}","public void removeFromPool(Channel channel){
  if (!oneNetClientContextConfig.isLocalPool()) {
    channel.close();
  }
 else {
    try {
      localPool.invalidateObject(channel);
    }
 catch (    Exception e) {
      log.info(e.getMessage() + localPool.getNumActive() + ""String_Node_Str""+ localPool.getNumIdle());
    }
  }
}"
72314,"@Override public boolean evict(EvictionConfig config,PooledObject<Channel> underTest,int idleCount){
  if (super.evict(config,underTest,idleCount)) {
    log.debug(""String_Node_Str"");
    return true;
  }
  if (!underTest.getObject().isActive()) {
    log.debug(""String_Node_Str"");
    return true;
  }
  log.debug(""String_Node_Str"");
  return false;
}","@Override public boolean evict(EvictionConfig config,PooledObject<Channel> underTest,int idleCount){
  if (super.evict(config,underTest,idleCount)) {
    log.debug(""String_Node_Str"");
    return true;
  }
  if (!underTest.getObject().isOpen()) {
    log.debug(""String_Node_Str"");
    return true;
  }
  log.debug(""String_Node_Str"");
  return false;
}"
72315,"@Override public boolean validateObject(PooledObject<Channel> p){
  if (!p.getObject().isActive()) {
    log.debug(String.format(""String_Node_Str"",System.currentTimeMillis() - p.getCreateTime()));
    return false;
  }
  return true;
}","@Override public boolean validateObject(PooledObject<Channel> p){
  if (!p.getObject().isOpen()) {
    log.debug(String.format(""String_Node_Str"",System.currentTimeMillis() - p.getCreateTime()));
    return false;
  }
  return true;
}"
72316,"@Override public void channelInactive(ChannelHandlerContext ctx) throws Exception {
  this.oneNetClientContext.close(clientSession);
  super.channelInactive(ctx);
}","@Override public void channelInactive(ChannelHandlerContext ctx) throws Exception {
  this.oneNetClientContext.closeDirectly(clientSession);
  super.channelInactive(ctx);
}"
72317,"@Override public void exceptionCaught(ChannelHandlerContext ctx,Throwable cause){
  this.oneNetClientContext.close(clientSession);
  ctx.close();
}","@Override public void exceptionCaught(ChannelHandlerContext ctx,Throwable cause){
  if (cause instanceof WriteTimeoutException) {
  }
  this.oneNetClientContext.closeDirectly(clientSession);
  ctx.close();
}"
72318,"@Override protected void channelRead0(ChannelHandlerContext ctx,BasePackage msg){
switch (msg.getMsgType()) {
case BasePackage.HEART_BEAT:
    serverSession.setLastHeartbeatTime(new Date());
  break;
case BasePackage.INITIAL_RESPONSE:
serverSession.updateContextSettings((InitialResponsePackage)msg);
break;
case BasePackage.INVALID_SESSION:
String oneNetName=msg.getContextName();
Long sessionId=msg.getSessionId();
if (StringUtils.isNotEmpty(oneNetName) && sessionId != null) {
OneNetClientContext context=serverSession.getOneNetClientContextMap().get(oneNetName);
context.close(sessionId);
}
break;
case BasePackage.DATA:
if (StringUtils.isNotEmpty(msg.getContextName()) && msg.getSessionId() != null) {
OneNetClientContext context=serverSession.getOneNetClientContextMap().get(msg.getContextName());
if (context == null) {
ctx.channel().writeAndFlush(new InvalidSessionPackage(msg.getContextName(),msg.getSessionId()));
return;
}
ClientSession clientSession=context.getSessionMap().get(msg.getSessionId());
if (clientSession != null) {
clientSession.getLocalChannel().writeAndFlush(((DataPackage)msg).getRawData());
}
 else {
CompletableFuture.runAsync(() -> {
ClientSession newSession=context.getCurrentSession(serverSession,msg.getSessionId());
if (newSession == null) {
log.info(""String_Node_Str"");
ctx.channel().writeAndFlush(new InvalidSessionPackage(msg.getContextName(),msg.getSessionId()));
}
 else {
newSession.getLocalChannel().writeAndFlush(((DataPackage)msg).getRawData());
}
}
,executor);
}
}
break;
default :
throw new RuntimeException(""String_Node_Str"");
}
}","@Override protected void channelRead0(ChannelHandlerContext ctx,BasePackage msg){
switch (msg.getMsgType()) {
case BasePackage.HEART_BEAT:
    serverSession.setLastHeartbeatTime(new Date());
  break;
case BasePackage.INITIAL_RESPONSE:
serverSession.updateContextSettings((InitialResponsePackage)msg);
break;
case BasePackage.INVALID_SESSION:
String oneNetName=msg.getContextName();
Long sessionId=msg.getSessionId();
if (StringUtils.isNotEmpty(oneNetName) && sessionId != null) {
OneNetClientContext context=serverSession.getOneNetClientContextMap().get(oneNetName);
context.close(sessionId);
}
break;
case BasePackage.DATA:
if (StringUtils.isNotEmpty(msg.getContextName()) && msg.getSessionId() != null) {
OneNetClientContext context=serverSession.getOneNetClientContextMap().get(msg.getContextName());
if (context == null) {
ctx.channel().writeAndFlush(new InvalidSessionPackage(msg.getContextName(),msg.getSessionId()));
return;
}
ClientSession clientSession=context.getSessionMap().get(msg.getSessionId());
if (clientSession != null) {
clientSession.getLocalChannel().writeAndFlush(((DataPackage)msg).getRawData());
}
 else {
CompletableFuture.runAsync(() -> {
ClientSession newSession=context.getCurrentSession(serverSession,msg.getSessionId());
if (newSession == null) {
log.info(""String_Node_Str"");
ctx.channel().writeAndFlush(new InvalidSessionPackage(msg.getContextName(),msg.getSessionId()));
}
 else {
newSession.getLocalChannel().writeAndFlush(((DataPackage)msg).getRawData());
}
}
);
}
}
break;
default :
throw new RuntimeException(""String_Node_Str"");
}
}"
72319,"@Override protected void initChannel(SocketChannel ch) throws Exception {
  ChannelPipeline p=ch.pipeline();
  int bytesPreSecond=0;
  if (clientSession != null) {
    bytesPreSecond=oneNetClientContext.getKBps() * OneNetCommonConstants.KByte;
  }
  p.addLast(CHANNEL_TRAFFIC_HANDLER,new ChannelTrafficShapingHandler(bytesPreSecond,bytesPreSecond)).addLast(LOCAL_RESPONSE_HANDLER,new LocalInboudHandler(oneNetClientContext,clientSession)).addLast(new ByteArrayEncoder());
}","@Override protected void initChannel(SocketChannel ch) throws Exception {
  ChannelPipeline p=ch.pipeline();
  int bytesPreSecond=0;
  if (clientSession != null) {
    bytesPreSecond=oneNetClientContext.getKBps() * OneNetCommonConstants.KByte;
  }
  p.addLast(new WriteTimeoutHandler(5)).addLast(CHANNEL_TRAFFIC_HANDLER,new ChannelTrafficShapingHandler(bytesPreSecond,bytesPreSecond)).addLast(LOCAL_RESPONSE_HANDLER,new LocalInboudHandler(oneNetClientContext,clientSession)).addLast(new ByteArrayEncoder());
}"
72320,"@Override protected void initChannel(SocketChannel ch) throws Exception {
  ch.pipeline().addLast(new OneNetMsgEncoder()).addLast(new OneNetMsgDecoder()).addLast(new OneNetInboundHandler(serverSession));
}","@Override protected void initChannel(SocketChannel ch) throws Exception {
  ch.pipeline().addLast(new WriteTimeoutHandler(5)).addLast(new OneNetMsgEncoder()).addLast(new OneNetMsgDecoder()).addLast(new OneNetInboundHandler(serverSession));
}"
72321,"public void close(){
  if (this.getServerSession().getServerChannel().isActive()) {
    serverSession.getServerChannel().writeAndFlush(new InvalidSessionPackage(this.getContextName(),sessionId));
  }
}","public void close(){
  if (this.getServerSession().getServerChannel().isOpen()) {
    serverSession.getServerChannel().writeAndFlush(new InvalidSessionPackage(this.getContextName(),sessionId));
  }
}"
72322,"public void invalidAllClientSessions(){
  oneNetClientContextMap.values().stream().forEach((oneNetClientContext -> oneNetClientContext.closeAll()));
}","public void invalidAllClientSessions(){
  this.lastHeartbeatTime=null;
  oneNetClientContextMap.values().stream().forEach((oneNetClientContext -> oneNetClientContext.closeAll()));
}"
72323,"/** 
 * Customized system debug message for   {@link #HlaManager}.
 * @param reason The reason to print
 */
private void _hlaDebugSys(String reason){
  String dbgHeader=""String_Node_Str"" + _federateName + ""String_Node_Str""+ _federationName+ ""String_Node_Str"";
  _hlaDebugSys(dbgHeader + reason);
}","/** 
 * Customized system debug message for   {@link #HlaManager}.
 * @param reason The reason to print
 */
private void _hlaDebugSys(String reason){
  String dbgHeader=""String_Node_Str"" + _federateName + ""String_Node_Str""+ _federationName+ ""String_Node_Str"";
  System.out.println(dbgHeader + reason);
}"
72324,"/** 
 * Customized debug message for   {@link #HlaManager}.
 * @param reason The reason to print
 */
private void _hlaDebug(String reason){
  String dbgHeader=""String_Node_Str"" + _federateName + ""String_Node_Str""+ _federationName+ ""String_Node_Str"";
  _hlaDebug(dbgHeader + reason);
}","/** 
 * Customized debug message for   {@link #HlaManager}.
 * @param reason The reason to print
 */
private void _hlaDebug(String reason){
  String dbgHeader=""String_Node_Str"" + _federateName + ""String_Node_Str""+ _federationName+ ""String_Node_Str"";
  _debug(dbgHeader + reason);
}"
72325,"/** 
 * Manage the correct termination of the   {@link HlaManager}. Call the HLA services to: unsubscribe to HLA attributes, unpublish HLA attributes, resign a Federation and destroy a Federation if the current Federate is the last participant.
 * @exception IllegalActionException If the parent class throws itof if a CERTI exception is raised then displayed it to the user.
 */
@Override public void wrapup() throws IllegalActionException {
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  super.wrapup();
  if (_enableHlaReporter) {
    if (_debugging) {
      _debug(_hlaReporter.displayAnalysisValues());
    }
    _hlaReporter.calculateRuntime();
    _hlaReporter.writeNumberOfHLACalls();
    _hlaReporter.writeDelays();
    _hlaReporter.writeUAVsInformation();
    _hlaReporter.writeRAVsInformation();
    _hlaReporter.writeTimes();
  }
  for (  Object[] obj : _hlaAttributesToSubscribeTo.values()) {
    try {
      _rtia.unsubscribeObjectClass(_getClassHandleFromTab(obj));
    }
 catch (    RTIexception e) {
      throw new IllegalActionException(this,e,""String_Node_Str"" + e.getMessage());
    }
    if (_debugging) {
      _debug(""String_Node_Str"" + _getPortFromTab(obj).getContainer().getFullName() + ""String_Node_Str""+ _getClassHandleFromTab(obj)+ ""String_Node_Str"");
    }
  }
  for (  Object[] obj : _hlaAttributesToPublish.values()) {
    try {
      _rtia.unpublishObjectClass(_getClassHandleFromTab(obj));
    }
 catch (    RTIexception e) {
      throw new IllegalActionException(this,e,""String_Node_Str"" + e.getMessage());
    }
    if (_debugging) {
      _debug(""String_Node_Str"" + _getPortFromTab(obj).getContainer().getFullName() + ""String_Node_Str""+ _getClassHandleFromTab(obj)+ ""String_Node_Str"");
    }
  }
  try {
    if (_rtia != null) {
      _rtia.resignFederationExecution(ResignAction.DELETE_OBJECTS_AND_RELEASE_ATTRIBUTES);
    }
  }
 catch (  RTIexception e) {
    throw new IllegalActionException(this,e,""String_Node_Str"" + e.getMessage());
  }
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  System.out.println(""String_Node_Str"");
  boolean canDestroyRtig=false;
  while (!canDestroyRtig) {
    try {
      _rtia.destroyFederationExecution(_federationName);
    }
 catch (    FederatesCurrentlyJoined e) {
      if (_debugging) {
        _debug(""String_Node_Str"");
      }
      System.out.println(""String_Node_Str"");
    }
catch (    FederationExecutionDoesNotExist e) {
      if (_debugging) {
        _debug(""String_Node_Str"");
      }
      canDestroyRtig=true;
      System.out.println(""String_Node_Str"" + canDestroyRtig);
    }
catch (    RTIinternalError e) {
      throw new IllegalActionException(this,e,""String_Node_Str"" + e.getMessage());
    }
catch (    ConcurrentAccessAttempted e) {
      throw new IllegalActionException(this,e,""String_Node_Str"" + e.getMessage());
    }
    if (_debugging) {
      _debug(""String_Node_Str"" + ""String_Node_Str"");
    }
    canDestroyRtig=true;
    System.out.println(""String_Node_Str"" + canDestroyRtig);
  }
  if (_certiRtig != null) {
    _certiRtig.terminateProcess();
    if (_debugging) {
      _debug(""String_Node_Str"" + ""String_Node_Str"");
    }
    System.out.println(""String_Node_Str"" + ""String_Node_Str"");
  }
  _hlaAttributesToPublish.clear();
  _hlaAttributesToSubscribeTo.clear();
  _fromFederationEvents.clear();
  _objectIdToClassHandle.clear();
  _registerObjectInstanceMap.clear();
  _discoverObjectInstanceMap.clear();
  _usedJokerFilterMap.clear();
  _hlaReporter=null;
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
}","/** 
 * Manage the correct termination of the   {@link HlaManager}. Call the HLA services to: unsubscribe to HLA attributes, unpublish HLA attributes, resign a Federation and destroy a Federation if the current Federate is the last participant.
 * @exception IllegalActionException If the parent class throws itof if a CERTI exception is raised then displayed it to the user.
 */
@Override public void wrapup() throws IllegalActionException {
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  super.wrapup();
  if (_enableHlaReporter) {
    if (_debugging) {
      _debug(_hlaReporter.displayAnalysisValues());
    }
    _hlaReporter.calculateRuntime();
    _hlaReporter.writeNumberOfHLACalls();
    _hlaReporter.writeDelays();
    _hlaReporter.writeUAVsInformation();
    _hlaReporter.writeRAVsInformation();
    _hlaReporter.writeTimes();
  }
  for (  Object[] obj : _hlaAttributesToSubscribeTo.values()) {
    try {
      _rtia.unsubscribeObjectClass(_getClassHandleFromTab(obj));
    }
 catch (    RTIexception e) {
      throw new IllegalActionException(this,e,""String_Node_Str"" + e.getMessage());
    }
    if (_debugging) {
      _debug(""String_Node_Str"" + _getPortFromTab(obj).getContainer().getFullName() + ""String_Node_Str""+ _getClassHandleFromTab(obj)+ ""String_Node_Str"");
    }
  }
  for (  Object[] obj : _hlaAttributesToPublish.values()) {
    try {
      _rtia.unpublishObjectClass(_getClassHandleFromTab(obj));
    }
 catch (    RTIexception e) {
      throw new IllegalActionException(this,e,""String_Node_Str"" + e.getMessage());
    }
    if (_debugging) {
      _debug(""String_Node_Str"" + _getPortFromTab(obj).getContainer().getFullName() + ""String_Node_Str""+ _getClassHandleFromTab(obj)+ ""String_Node_Str"");
    }
  }
  try {
    if (_rtia != null) {
      _rtia.resignFederationExecution(ResignAction.DELETE_OBJECTS_AND_RELEASE_ATTRIBUTES);
    }
  }
 catch (  RTIexception e) {
    throw new IllegalActionException(this,e,""String_Node_Str"" + e.getMessage());
  }
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  System.out.println(""String_Node_Str"" + _federateName + ""String_Node_Str""+ _federationName+ ""String_Node_Str""+ ""String_Node_Str"");
  boolean canDestroyRtig=false;
  while (!canDestroyRtig) {
    try {
      _rtia.destroyFederationExecution(_federationName);
      canDestroyRtig=true;
      if (_debugging) {
        _debug(""String_Node_Str"" + ""String_Node_Str"");
      }
      System.out.println(""String_Node_Str"" + _federateName + ""String_Node_Str""+ _federationName+ ""String_Node_Str""+ ""String_Node_Str""+ canDestroyRtig);
    }
 catch (    FederatesCurrentlyJoined e) {
      if (_debugging) {
        _debug(""String_Node_Str"");
      }
      System.out.println(""String_Node_Str"" + _federateName + ""String_Node_Str""+ _federationName+ ""String_Node_Str""+ ""String_Node_Str"");
    }
catch (    FederationExecutionDoesNotExist e) {
      if (_debugging) {
        _debug(""String_Node_Str"");
      }
      canDestroyRtig=true;
      System.out.println(""String_Node_Str"" + _federateName + ""String_Node_Str""+ _federationName+ ""String_Node_Str""+ ""String_Node_Str""+ canDestroyRtig);
    }
catch (    RTIinternalError e) {
      throw new IllegalActionException(this,e,""String_Node_Str"" + e.getMessage());
    }
catch (    ConcurrentAccessAttempted e) {
      throw new IllegalActionException(this,e,""String_Node_Str"" + e.getMessage());
    }
  }
  if (_certiRtig != null) {
    if (_debugging) {
      _debug(""String_Node_Str"" + ""String_Node_Str"");
    }
    System.out.println(""String_Node_Str"" + _federateName + ""String_Node_Str""+ _federationName+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    _certiRtig.terminateProcess();
  }
  _hlaAttributesToPublish.clear();
  _hlaAttributesToSubscribeTo.clear();
  _fromFederationEvents.clear();
  _objectIdToClassHandle.clear();
  _registerObjectInstanceMap.clear();
  _discoverObjectInstanceMap.clear();
  _usedJokerFilterMap.clear();
  _hlaReporter=null;
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
}"
72326,"/** 
 * Create a new parameter if it does not already exist. The options argument can specify a ""type"", a ""description"", ""visibility"", and/or a ""value"". If a type is given, set the type as specified. Otherwise, leave the type unspecified so that it will be inferred from the value. If a description is given, then create, append to, or modify the DocAttribute named ""documentation"" contained by this actor to include documentation of this output. If a value is given, then set the default value of the parameter if it does not already have a value.
 * @param name The name of the parameter.
 * @param options The options, or null to accept the defaults.
 * @return The previous value of this parameter, if it has one, andnull otherwise.
 * @exception IllegalActionException If no name is given.
 * @exception NameDuplicationException If the name is a reserved word, or if an attributealready exists with the name and is not a parameter.
 */
public Token parameter(String name,Map<String,Object> options) throws IllegalActionException, NameDuplicationException {
  if (name == null) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  Attribute parameter=getAttribute(name);
  if (parameter == null) {
    parameter=new Parameter(this,name);
  }
 else {
    if (parameter == script) {
      throw new NameDuplicationException(this,""String_Node_Str"" + name);
    }
 else     if (!(parameter instanceof Parameter)) {
      throw new NameDuplicationException(this,""String_Node_Str"" + name);
    }
  }
  Token result=null;
  if (options != null) {
    Type ptType=null;
    Object type=options.get(""String_Node_Str"");
    if (type instanceof String) {
      ptType=_typeAccessorToPtolemy((String)type,parameter);
    }
 else     if (type != null) {
      throw new IllegalActionException(this,""String_Node_Str"" + type);
    }
    if (ptType != null) {
      ((Parameter)parameter).setTypeEquals(ptType);
    }
    _setOptionsForSelect(parameter,options);
    Object value=options.get(""String_Node_Str"");
    if (value != null && !parameter.isOverridden()) {
      Object token;
      try {
        token=((Invocable)_engine).invokeFunction(""String_Node_Str"",value);
      }
 catch (      Exception e) {
        throw new IllegalActionException(this,e,""String_Node_Str"" + value);
      }
      if (token instanceof Token) {
        ((Parameter)parameter).setToken((Token)token);
      }
 else {
        throw new IllegalActionException(this,""String_Node_Str"" + value);
      }
      parameter.setDerivedLevel(1);
    }
    if (parameter.isOverridden()) {
      result=((Parameter)parameter).getToken();
    }
    Object visibility=options.get(""String_Node_Str"");
    if (visibility instanceof String) {
      String generic=((String)visibility).trim().toLowerCase();
switch (generic) {
case ""String_Node_Str"":
        if (parameter instanceof Variable) {
          ((Variable)parameter).setVisibility(Settable.NONE);
        }
      break;
case ""String_Node_Str"":
    if (parameter instanceof Variable) {
      ((Variable)parameter).setVisibility(Settable.EXPERT);
    }
  break;
case ""String_Node_Str"":
if (parameter instanceof Variable) {
  ((Variable)parameter).setVisibility(Settable.NOT_EDITABLE);
}
break;
default :
if (parameter instanceof Variable) {
((Variable)parameter).setVisibility(Settable.FULL);
}
}
}
Object description=options.get(""String_Node_Str"");
if (description != null) {
_setPortDescription(parameter,description.toString());
}
}
if (_proxies.get(parameter) == null) {
PortOrParameterProxy proxy=new PortOrParameterProxy(parameter);
_proxies.put(parameter,proxy);
_proxiesByName.put(parameter.getName(),proxy);
}
return result;
}","/** 
 * Create a new parameter if it does not already exist. The options argument can specify a ""type"", a ""description"", ""visibility"", and/or a ""value"". If a type is given, set the type as specified. Otherwise, leave the type unspecified so that it will be inferred from the value. If a description is given, then create, append to, or modify the DocAttribute named ""documentation"" contained by this actor to include documentation of this output. If a value is given, then set the default value of the parameter if it does not already have a value.
 * @param name The name of the parameter.
 * @param options The options, or null to accept the defaults.
 * @return The previous value of this parameter, if it has one, andnull otherwise.
 * @exception IllegalActionException If no name is given.
 * @exception NameDuplicationException If the name is a reserved word, or if an attributealready exists with the name and is not a parameter.
 */
public Token parameter(String name,Map<String,Object> options) throws IllegalActionException, NameDuplicationException {
  if (name == null) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  Attribute parameter=getAttribute(name);
  if (parameter == null) {
    parameter=new Parameter(this,name);
  }
 else {
    if (parameter == script) {
      throw new NameDuplicationException(this,""String_Node_Str"" + name);
    }
 else     if (!(parameter instanceof Parameter)) {
      throw new NameDuplicationException(this,""String_Node_Str"" + name);
    }
  }
  Token result=null;
  if (options != null) {
    Type ptType=null;
    Object type=options.get(""String_Node_Str"");
    if (type instanceof String) {
      ptType=_typeAccessorToPtolemy((String)type,parameter);
    }
 else     if (type != null) {
      throw new IllegalActionException(this,""String_Node_Str"" + type);
    }
    if (ptType != null) {
      ((Parameter)parameter).setTypeEquals(ptType);
    }
    _setOptionsForSelect(parameter,options);
    Object value=options.get(""String_Node_Str"");
    if (value != null && !parameter.isOverridden() && parameter.getDerivedLevel() == Integer.MAX_VALUE) {
      Object token;
      try {
        token=((Invocable)_engine).invokeFunction(""String_Node_Str"",value);
      }
 catch (      Exception e) {
        throw new IllegalActionException(this,e,""String_Node_Str"" + value);
      }
      if (token instanceof Token) {
        ((Parameter)parameter).setToken((Token)token);
      }
 else {
        throw new IllegalActionException(this,""String_Node_Str"" + value);
      }
      parameter.setDerivedLevel(1);
    }
    if (parameter.isOverridden()) {
      result=((Parameter)parameter).getToken();
    }
    Object visibility=options.get(""String_Node_Str"");
    if (visibility instanceof String) {
      String generic=((String)visibility).trim().toLowerCase();
switch (generic) {
case ""String_Node_Str"":
        if (parameter instanceof Variable) {
          ((Variable)parameter).setVisibility(Settable.NONE);
        }
      break;
case ""String_Node_Str"":
    if (parameter instanceof Variable) {
      ((Variable)parameter).setVisibility(Settable.EXPERT);
    }
  break;
case ""String_Node_Str"":
if (parameter instanceof Variable) {
  ((Variable)parameter).setVisibility(Settable.NOT_EDITABLE);
}
break;
default :
if (parameter instanceof Variable) {
((Variable)parameter).setVisibility(Settable.FULL);
}
}
}
Object description=options.get(""String_Node_Str"");
if (description != null) {
_setPortDescription(parameter,description.toString());
}
}
if (_proxies.get(parameter) == null) {
PortOrParameterProxy proxy=new PortOrParameterProxy(parameter);
_proxies.put(parameter,proxy);
_proxiesByName.put(parameter.getName(),proxy);
}
return result;
}"
72327,"/** 
 * Invoke the specified function after the specified amount of time.  Unlike the public method, this method uses the specified id.  The time will be added to the current time of the director, and fireAt() request will be made of the director. If the director cannot fulfill the request, this method will throw an exception. Note that if you want real-time behavior, then the director's synchronizeToRealTime parameter needs to be set to true.
 * @param function The function to invoke.
 * @param milliseconds The number of milliseconds in the future to invoke it.
 * @param id The id for the callback function.
 * @return A unique ID for this callback.
 * @exception IllegalActionException If the director cannot respect the request.
 */
private synchronized void _setTimeout(final Runnable function,long milliseconds,Integer id) throws IllegalActionException {
  Director director=getDirector();
  Time currentTime=director.getModelTime();
  if (currentTime == null) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  Attribute sync=director.getAttribute(""String_Node_Str"");
  if (sync instanceof Parameter) {
    Token token=((Parameter)sync).getToken();
    if (token instanceof BooleanToken && !((BooleanToken)token).booleanValue()) {
      try {
        MessageHandler.warning(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
      }
 catch (      CancelException e) {
        throw new IllegalActionException(this,""String_Node_Str"");
      }
    }
  }
  final Time callbackTime=currentTime.add(milliseconds * 0.001);
  Time responseTime=director.fireAt(this,callbackTime);
  if (!responseTime.equals(callbackTime)) {
    throw new IllegalActionException(this,""String_Node_Str"" + callbackTime + ""String_Node_Str""+ responseTime+ ""String_Node_Str"");
  }
  _pendingTimeoutFunctions.put(id,function);
  Queue<Integer> ids=_pendingTimeoutIDs.get(callbackTime);
  if (ids == null) {
    ids=new LinkedList<Integer>();
    _pendingTimeoutIDs.put(callbackTime,ids);
  }
  ids.add(id);
}","/** 
 * Invoke the specified function after the specified amount of time.  Unlike the public method, this method uses the specified id.  The time will be added to the current time of the director, and fireAt() request will be made of the director. If the director cannot fulfill the request, this method will throw an exception. Note that if you want real-time behavior, then the director's synchronizeToRealTime parameter needs to be set to true.
 * @param function The function to invoke.
 * @param milliseconds The number of milliseconds in the future to invoke it.
 * @param id The id for the callback function.
 * @return A unique ID for this callback.
 * @exception IllegalActionException If the director cannot respect the request.
 */
private synchronized void _setTimeout(final Runnable function,long milliseconds,Integer id) throws IllegalActionException {
  Director director=getDirector();
  Time currentTime=director.getModelTime();
  if (currentTime == null) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  Attribute sync=director.getAttribute(""String_Node_Str"");
  if (sync instanceof Parameter) {
    Token token=((Parameter)sync).getToken();
    if (token instanceof BooleanToken && !((BooleanToken)token).booleanValue()) {
      if (!_timeWarningIssued) {
        _timeWarningIssued=true;
        try {
          MessageHandler.warning(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
        }
 catch (        CancelException e) {
          throw new IllegalActionException(this,""String_Node_Str"");
        }
      }
    }
  }
  final Time callbackTime=currentTime.add(milliseconds * 0.001);
  Time responseTime=director.fireAt(this,callbackTime);
  if (!responseTime.equals(callbackTime)) {
    throw new IllegalActionException(this,""String_Node_Str"" + callbackTime + ""String_Node_Str""+ responseTime+ ""String_Node_Str"");
  }
  _pendingTimeoutFunctions.put(id,function);
  Queue<Integer> ids=_pendingTimeoutIDs.get(callbackTime);
  if (ids == null) {
    ids=new LinkedList<Integer>();
    _pendingTimeoutIDs.put(callbackTime,ids);
  }
  ids.add(id);
}"
72328,"/** 
 * Evaluate the specified method.  The object on which the method is evaluated should be the first argument.
 * @param methodName The method name.
 * @param argTypes An array of argument types.
 * @param argValues An array of argument values.
 * @return The value of returned by the specified method.
 * @exception IllegalActionException If an evaluation error occurs.
 */
protected ptolemy.data.Token _methodCall(String methodName,Type[] argTypes,Object[] argValues) throws IllegalActionException {
  CachedMethod method=CachedMethod.findMethod(methodName,argTypes,CachedMethod.METHOD);
  if (method.isValid()) {
    if (_trace != null) {
      _trace(""String_Node_Str"" + method.methodDescription());
      _trace(""String_Node_Str"" + method);
    }
    ptolemy.data.Token result=method.invoke(argValues);
    return result;
  }
  if (argValues[0] instanceof ObjectToken) {
    ObjectToken objectToken=(ObjectToken)argValues[0];
    Object object=objectToken.getValue();
    if (object != null) {
      if (object instanceof NamedObj) {
        Object result=((NamedObj)object).getAttribute(methodName);
        if (result == null && object instanceof Entity) {
          result=((Entity)object).getPort(methodName);
        }
        if (result == null && object instanceof CompositeEntity) {
          result=((CompositeEntity)object).getEntity(methodName);
          if (result == null) {
            result=((CompositeEntity)object).getRelation(methodName);
          }
        }
        if (result == null) {
          List attributes=((NamedObj)object).attributeList(ContainmentExtender.class);
          Iterator attrIterator=attributes.iterator();
          while (result == null && attrIterator.hasNext()) {
            ContainmentExtender extender=(ContainmentExtender)attrIterator.next();
            result=extender.getContainedObject(methodName);
          }
        }
        if (result != null) {
          if (result instanceof Variable) {
            return ((Variable)result).getToken();
          }
 else {
            return new ObjectToken(result,result.getClass());
          }
        }
      }
    }
    Class<?> valueClass=object == null ? objectToken.getValueClass() : object.getClass();
    Set<Class<?>> classes=new HashSet<Class<?>>();
    classes.add(valueClass);
    while (!classes.isEmpty()) {
      Iterator<Class<?>> iterator=classes.iterator();
      valueClass=iterator.next();
      iterator.remove();
      if (!Modifier.isPublic(valueClass.getModifiers())) {
        for (        Class<?> interf : valueClass.getInterfaces()) {
          classes.add(interf);
        }
        Class<?> superclass=valueClass.getSuperclass();
        if (superclass != null) {
          classes.add(superclass);
        }
      }
 else {
        ptolemy.data.Token result=_invokeMethod(valueClass,object,methodName,argTypes,argValues);
        if (result != null) {
          return result;
        }
      }
    }
    if (object == null) {
      throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + methodName + ""String_Node_Str""+ ""String_Node_Str"");
    }
  }
  throw new IllegalActionException(""String_Node_Str"" + method.toString());
}","/** 
 * Evaluate the specified method.  The object on which the method is evaluated should be the first argument.
 * @param methodName The method name.
 * @param argTypes An array of argument types.
 * @param argValues An array of argument values.
 * @return The value of returned by the specified method.
 * @exception IllegalActionException If an evaluation error occurs.
 */
protected ptolemy.data.Token _methodCall(String methodName,Type[] argTypes,Object[] argValues) throws IllegalActionException {
  CachedMethod method=CachedMethod.findMethod(methodName,argTypes,CachedMethod.METHOD);
  if (method.isValid()) {
    if (_trace != null) {
      _trace(""String_Node_Str"" + method.methodDescription());
      _trace(""String_Node_Str"" + method);
    }
    ptolemy.data.Token result=method.invoke(argValues);
    return result;
  }
  if (argValues[0] instanceof ObjectToken) {
    ObjectToken objectToken=(ObjectToken)argValues[0];
    Object object=objectToken.getValue();
    if (object != null) {
      if (object instanceof NamedObj) {
        Object result=((NamedObj)object).getAttribute(methodName);
        if (result == null && object instanceof Entity) {
          result=((Entity)object).getPort(methodName);
        }
        if (result == null && object instanceof CompositeEntity) {
          result=((CompositeEntity)object).getEntity(methodName);
          if (result == null) {
            result=((CompositeEntity)object).getRelation(methodName);
          }
        }
        if (result == null) {
          List attributes=((NamedObj)object).attributeList(ContainmentExtender.class);
          Iterator attrIterator=attributes.iterator();
          while (result == null && attrIterator.hasNext()) {
            ContainmentExtender extender=(ContainmentExtender)attrIterator.next();
            result=extender.getContainedObject(methodName);
          }
        }
        if (result != null) {
          if (result instanceof Variable) {
            ptolemy.data.Token token=((Variable)result).getToken();
            if (token instanceof MatrixToken) {
              if (argValues.length < 2 || !(argValues[1] instanceof IntToken)) {
                return token;
              }
              int row=((IntToken)(argValues[1])).intValue();
              int column=0;
              if (argValues.length >= 3 && !(argValues[2] instanceof IntToken)) {
                column=((IntToken)(argValues[2])).intValue();
              }
              return ((MatrixToken)token).getElementAsToken(row,column);
            }
            if (token instanceof ArrayToken) {
              if (argValues.length < 2 || !(argValues[1] instanceof IntToken)) {
                return token;
              }
              int index=((IntToken)(argValues[1])).intValue();
              return ((ArrayToken)token).getElement(index);
            }
            return token;
          }
 else {
            return new ObjectToken(result,result.getClass());
          }
        }
      }
    }
    Class<?> valueClass=object == null ? objectToken.getValueClass() : object.getClass();
    Set<Class<?>> classes=new HashSet<Class<?>>();
    classes.add(valueClass);
    while (!classes.isEmpty()) {
      Iterator<Class<?>> iterator=classes.iterator();
      valueClass=iterator.next();
      iterator.remove();
      if (!Modifier.isPublic(valueClass.getModifiers())) {
        for (        Class<?> interf : valueClass.getInterfaces()) {
          classes.add(interf);
        }
        Class<?> superclass=valueClass.getSuperclass();
        if (superclass != null) {
          classes.add(superclass);
        }
      }
 else {
        ptolemy.data.Token result=_invokeMethod(valueClass,object,methodName,argTypes,argValues);
        if (result != null) {
          return result;
        }
      }
    }
    if (object == null) {
      throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + methodName + ""String_Node_Str""+ ""String_Node_Str"");
    }
  }
  throw new IllegalActionException(""String_Node_Str"" + method.toString());
}"
72329,"/** 
 * Infer the type of the specified method.  The type of the object on which the method is evaluated should be the first argument.
 * @param methodName The method name.
 * @param argTypes An array of argument types.
 * @exception IllegalActionException If an evaluation error occurs.
 * @see ParseTreeEvaluator#_methodCall(String,Type[],Object[])
 */
protected Type _methodCall(String methodName,Type[] argTypes) throws IllegalActionException {
  CachedMethod cachedMethod=CachedMethod.findMethod(methodName,argTypes,CachedMethod.METHOD);
  if (cachedMethod.isValid()) {
    Type type=cachedMethod.getReturnType();
    return type;
  }
  if (argTypes[0] instanceof ObjectType) {
    Object object=((ObjectType)argTypes[0]).getValue();
    if (object != null) {
      if (object instanceof NamedObj) {
        Object result=((NamedObj)object).getAttribute(methodName);
        if (result == null && object instanceof Entity) {
          result=((Entity)object).getPort(methodName);
        }
        if (result == null && object instanceof CompositeEntity) {
          result=((CompositeEntity)object).getEntity(methodName);
          if (result == null) {
            result=((CompositeEntity)object).getRelation(methodName);
          }
        }
        if (result == null) {
          List attributes=((NamedObj)object).attributeList(ContainmentExtender.class);
          Iterator attrIterator=attributes.iterator();
          while (result == null && attrIterator.hasNext()) {
            ContainmentExtender extender=(ContainmentExtender)attrIterator.next();
            result=extender.getContainedObject(methodName);
          }
        }
        if (result != null) {
          if (result instanceof Variable) {
            return ((Variable)result).getType();
          }
 else {
            return new ObjectType(result,result.getClass());
          }
        }
      }
    }
    Class<?> valueClass=((ObjectType)argTypes[0]).getValueClass();
    if (valueClass == null) {
      valueClass=Object.class;
    }
    Set<Class<?>> classes=new HashSet<Class<?>>();
    classes.add(valueClass);
    while (!classes.isEmpty()) {
      Iterator<Class<?>> iterator=classes.iterator();
      valueClass=iterator.next();
      iterator.remove();
      if (!Modifier.isPublic(valueClass.getModifiers())) {
        for (        Class<?> interf : valueClass.getInterfaces()) {
          classes.add(interf);
        }
        Class<?> superclass=valueClass.getSuperclass();
        if (superclass != null) {
          classes.add(superclass);
        }
      }
 else {
        Type result=_getMethodReturnType(valueClass,methodName,argTypes);
        if (result != null) {
          return result;
        }
      }
    }
  }
  StringBuffer buffer=new StringBuffer();
  for (int i=1; i < argTypes.length; i++) {
    if (i == 1) {
      buffer.append(argTypes[i].toString());
    }
 else {
      buffer.append(""String_Node_Str"" + argTypes[i].toString());
    }
  }
  throw new IllegalActionException(""String_Node_Str"" + argTypes[0] + ""String_Node_Str""+ methodName+ ""String_Node_Str""+ buffer+ ""String_Node_Str"");
}","/** 
 * Infer the type of the specified method.  The type of the object on which the method is evaluated should be the first argument.
 * @param methodName The method name.
 * @param argTypes An array of argument types.
 * @exception IllegalActionException If an evaluation error occurs.
 * @see ParseTreeEvaluator#_methodCall(String,Type[],Object[])
 */
protected Type _methodCall(String methodName,Type[] argTypes) throws IllegalActionException {
  CachedMethod cachedMethod=CachedMethod.findMethod(methodName,argTypes,CachedMethod.METHOD);
  if (cachedMethod.isValid()) {
    Type type=cachedMethod.getReturnType();
    return type;
  }
  if (argTypes[0] instanceof ObjectType) {
    Object object=((ObjectType)argTypes[0]).getValue();
    if (object != null) {
      if (object instanceof NamedObj) {
        Object result=((NamedObj)object).getAttribute(methodName);
        if (result == null && object instanceof Entity) {
          result=((Entity)object).getPort(methodName);
        }
        if (result == null && object instanceof CompositeEntity) {
          result=((CompositeEntity)object).getEntity(methodName);
          if (result == null) {
            result=((CompositeEntity)object).getRelation(methodName);
          }
        }
        if (result == null) {
          List attributes=((NamedObj)object).attributeList(ContainmentExtender.class);
          Iterator attrIterator=attributes.iterator();
          while (result == null && attrIterator.hasNext()) {
            ContainmentExtender extender=(ContainmentExtender)attrIterator.next();
            result=extender.getContainedObject(methodName);
          }
        }
        if (result != null) {
          if (result instanceof Variable) {
            Type type=((Variable)result).getType();
            if (type instanceof MatrixType) {
              return ((MatrixType)type).getElementType();
            }
            if (type instanceof ArrayType) {
              return ((ArrayType)type).getElementType();
            }
            return type;
          }
 else {
            return new ObjectType(result,result.getClass());
          }
        }
      }
    }
    Class<?> valueClass=((ObjectType)argTypes[0]).getValueClass();
    if (valueClass == null) {
      valueClass=Object.class;
    }
    Set<Class<?>> classes=new HashSet<Class<?>>();
    classes.add(valueClass);
    while (!classes.isEmpty()) {
      Iterator<Class<?>> iterator=classes.iterator();
      valueClass=iterator.next();
      iterator.remove();
      if (!Modifier.isPublic(valueClass.getModifiers())) {
        for (        Class<?> interf : valueClass.getInterfaces()) {
          classes.add(interf);
        }
        Class<?> superclass=valueClass.getSuperclass();
        if (superclass != null) {
          classes.add(superclass);
        }
      }
 else {
        Type result=_getMethodReturnType(valueClass,methodName,argTypes);
        if (result != null) {
          return result;
        }
      }
    }
  }
  StringBuffer buffer=new StringBuffer();
  for (int i=1; i < argTypes.length; i++) {
    if (i == 1) {
      buffer.append(argTypes[i].toString());
    }
 else {
      buffer.append(""String_Node_Str"" + argTypes[i].toString());
    }
  }
  throw new IllegalActionException(""String_Node_Str"" + argTypes[0] + ""String_Node_Str""+ methodName+ ""String_Node_Str""+ buffer+ ""String_Node_Str"");
}"
72330,"/** 
 * Given an array of derivatives that specifies an input value and its derivatives, set the ""input model.""
 * @param derivatives The input to this integrator, which represents thederivative of the state and possibly higher-order derivatives.
 * @param currentTime The current time.
 * @exception IllegalActionException If the solver throws an exception whentriggering a rate event.
 */
private void _setInputModel(double[] derivatives,Time currentTime) throws IllegalActionException {
  ModelPolynomial inputModel=_qssSolver.getInputVariableModel(0);
  inputModel.coeffs[0]=derivatives[0];
  if (_maximumInputOrder > 0) {
    int factorial=1;
    for (int i=1; i <= _maximumInputOrder; i++) {
      if (derivatives.length <= i) {
        inputModel.coeffs[i]=0.0;
      }
 else {
        inputModel.coeffs[i]=derivatives[i] / factorial;
        factorial=factorial * i;
      }
    }
  }
  inputModel.tModel=currentTime;
  try {
    _qssSolver.triggerRateEvent();
  }
 catch (  Exception e) {
    throw new IllegalActionException(this,e,e.getMessage());
  }
}","/** 
 * Given an array of derivatives that specifies an input value and its derivatives, set the ""input model.""
 * @param derivatives The input to this integrator, which represents thederivative of the state and possibly higher-order derivatives.
 * @param currentTime The current time.
 * @exception IllegalActionException If the solver throws an exception whentriggering a rate event.
 */
private void _setInputModel(double[] derivatives,Time currentTime) throws IllegalActionException {
  ModelPolynomial inputModel=_qssSolver.getInputVariableModel(0);
  inputModel.coeffs[0]=derivatives != null && derivatives.length > 0 ? derivatives[0] : 0;
  if (_maximumInputOrder > 0) {
    int factorial=1;
    for (int i=1; i <= _maximumInputOrder; i++) {
      if (derivatives == null || derivatives.length <= i) {
        inputModel.coeffs[i]=0.0;
      }
 else {
        inputModel.coeffs[i]=derivatives[i] / factorial;
        factorial=factorial * i;
      }
    }
  }
  inputModel.tModel=currentTime;
  try {
    _qssSolver.triggerRateEvent();
  }
 catch (  Exception e) {
    throw new IllegalActionException(this,e,e.getMessage());
  }
}"
72331,"/** 
 * Create a client-side socket on behalf of the specified JavaScript SocketClient object. After this is called, the specified socketClient will emit the following events: * open: Emitted when the connection has been established with the server. This will not be passed any arguments. * data: Emitted when data is received on the socket. The received data will be an argument to the event. * close: Emitted when a socket is closed. This will not be passed any arguments. * error: Emitted when an error occurs. This will be passed an error message.
 * @param socketClient The JavaScript SocketClient instance.
 * @param port The remote port to connect to.
 * @param host The remote host to connect to.
 * @param options The options (see the socket.js JavaScript module).
 */
public void openClientSocket(final ScriptObjectMirror socketClient,final int port,final String host,Map<String,Object> options){
  if ((Boolean)options.get(""String_Node_Str"")) {
    if (!MessageHandler.yesNoQuestion(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"")) {
      return;
    }
  }
  final NetClientOptions clientOptions=new NetClientOptions().setConnectTimeout((Integer)options.get(""String_Node_Str"")).setIdleTimeout((Integer)options.get(""String_Node_Str"")).setReceiveBufferSize((Integer)options.get(""String_Node_Str"")).setReconnectAttempts((Integer)options.get(""String_Node_Str"")).setReconnectInterval((Integer)options.get(""String_Node_Str"")).setSendBufferSize((Integer)options.get(""String_Node_Str"")).setSsl((Boolean)options.get(""String_Node_Str"")).setTcpKeepAlive((Boolean)options.get(""String_Node_Str"")).setTcpNoDelay((Boolean)options.get(""String_Node_Str"")).setTrustAll((Boolean)options.get(""String_Node_Str""));
  if (clientOptions.isSsl() && !clientOptions.isTrustAll()) {
    PemTrustOptions pemTrustOptions=new PemTrustOptions();
    String caCertPath=(String)options.get(""String_Node_Str"");
    File caCertFile=FileUtilities.nameToFile(caCertPath,null);
    if (caCertFile == null) {
      _error(socketClient,""String_Node_Str"");
      return;
    }
    try {
      pemTrustOptions.addCertPath(caCertFile.getCanonicalPath());
      clientOptions.setPemTrustOptions(pemTrustOptions);
    }
 catch (    IOException e) {
      _error(socketClient,""String_Node_Str"" + caCertFile);
      return;
    }
  }
  String pfxKeyCertPath=(String)options.get(""String_Node_Str"");
  File pfxKeyCertFile=FileUtilities.nameToFile(pfxKeyCertPath,null);
  if (pfxKeyCertFile != null) {
    PfxOptions pfxOptions=new PfxOptions();
    try {
      pfxOptions.setPath(pfxKeyCertFile.getCanonicalPath());
    }
 catch (    IOException e) {
      _error(socketClient,""String_Node_Str"" + pfxKeyCertFile);
      return;
    }
    String pfxKeyCertPassword=(String)options.get(""String_Node_Str"");
    pfxOptions.setPassword(pfxKeyCertPassword);
    clientOptions.setPfxKeyCertOptions(pfxOptions);
  }
  submit(() -> {
    NetClient client=_vertx.createNetClient(clientOptions);
    client.connect(port,host,response -> {
      if (response.succeeded()) {
        NetSocket socket=response.result();
synchronized (_actor) {
          socketClient.callMember(""String_Node_Str"",socket,client);
        }
      }
 else {
        String message=""String_Node_Str"";
        Throwable cause=response.cause();
        while (cause != null) {
          message=message + ""String_Node_Str"" + cause.getMessage();
          cause=cause.getCause();
        }
        String errorMessage=""String_Node_Str"" + message;
        _error(socketClient,errorMessage,cause);
      }
    }
);
  }
);
}","/** 
 * Create a client-side socket on behalf of the specified JavaScript SocketClient object. After this is called, the specified socketClient will emit the following events: * open: Emitted when the connection has been established with the server. This will not be passed any arguments. * data: Emitted when data is received on the socket. The received data will be an argument to the event. * close: Emitted when a socket is closed. This will not be passed any arguments. * error: Emitted when an error occurs. This will be passed an error message.
 * @param socketClient The JavaScript SocketClient instance.
 * @param port The remote port to connect to.
 * @param host The remote host to connect to.
 * @param options The options (see the socket.js JavaScript module).
 */
public void openClientSocket(final ScriptObjectMirror socketClient,final int port,final String host,Map<String,Object> options){
  if ((Boolean)options.get(""String_Node_Str"")) {
    if (!MessageHandler.yesNoQuestion(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"")) {
      return;
    }
  }
  final NetClientOptions clientOptions=new NetClientOptions().setConnectTimeout((Integer)options.get(""String_Node_Str"")).setIdleTimeout((Integer)options.get(""String_Node_Str"")).setReceiveBufferSize((Integer)options.get(""String_Node_Str"")).setReconnectAttempts((Integer)options.get(""String_Node_Str"")).setReconnectInterval((Integer)options.get(""String_Node_Str"")).setSendBufferSize((Integer)options.get(""String_Node_Str"")).setSsl((Boolean)options.get(""String_Node_Str"")).setTcpKeepAlive((Boolean)options.get(""String_Node_Str"")).setTcpNoDelay((Boolean)options.get(""String_Node_Str"")).setTrustAll((Boolean)options.get(""String_Node_Str""));
  if (clientOptions.isSsl() && !clientOptions.isTrustAll()) {
    PemTrustOptions pemTrustOptions=new PemTrustOptions();
    String caCertPath=(String)options.get(""String_Node_Str"");
    File caCertFile=FileUtilities.nameToFile(caCertPath,null);
    if (caCertFile == null) {
      _error(socketClient,""String_Node_Str"");
      return;
    }
    try {
      pemTrustOptions.addCertPath(caCertFile.getCanonicalPath());
      clientOptions.setPemTrustOptions(pemTrustOptions);
    }
 catch (    IOException e) {
      _error(socketClient,""String_Node_Str"" + caCertFile);
      return;
    }
  }
  String pfxKeyCertPath=(String)options.get(""String_Node_Str"");
  File pfxKeyCertFile=FileUtilities.nameToFile(pfxKeyCertPath,null);
  if (pfxKeyCertFile != null) {
    PfxOptions pfxOptions=new PfxOptions();
    try {
      pfxOptions.setPath(pfxKeyCertFile.getCanonicalPath());
    }
 catch (    IOException e) {
      _error(socketClient,""String_Node_Str"" + pfxKeyCertFile);
      return;
    }
    String pfxKeyCertPassword=(String)options.get(""String_Node_Str"");
    pfxOptions.setPassword(pfxKeyCertPassword);
    clientOptions.setPfxKeyCertOptions(pfxOptions);
  }
  submit(() -> {
    NetClient client=_vertx.createNetClient(clientOptions);
    client.connect(port,host,response -> {
      if (response.succeeded()) {
        NetSocket socket=response.result();
synchronized (_actor) {
          socketClient.callMember(""String_Node_Str"",socket,client);
        }
      }
 else {
        StringBuffer message=new StringBuffer();
        Throwable cause=response.cause();
        Throwable initialCause=cause;
        while (cause != null) {
          message.append(""String_Node_Str"" + cause.getMessage());
          cause=cause.getCause();
        }
        String errorMessage=""String_Node_Str"" + message;
        _error(socketClient,errorMessage,initialCause);
      }
    }
);
  }
);
}"
72332,"private void _createOrShowWindow(String title){
  if (textArea == null) {
    Effigy containerEffigy=Configuration.findEffigy(_actor.toplevel());
    try {
      if (containerEffigy == null) {
        throw new IllegalActionException(""String_Node_Str"" + _actor.toplevel().getFullName() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      }
      TextEffigy textEffigy=TextEffigy.newTextEffigy(containerEffigy,""String_Node_Str"");
      textEffigy.identifier.setExpression(_actor.getFullName());
      _tableau=new DisplayWindowTableau(_actor,textEffigy,title);
      _frame=_tableau.frame.get();
      JScrollPane pane=((TextEditor)_frame).getScrollPane();
      if (pane != null) {
        pane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
      }
      textArea=((TextEditor)_frame).text;
      textArea.setRows(10);
      textArea.setColumns(40);
      _actor.setFrame(_frame);
      _frame.pack();
    }
 catch (    Exception ex) {
      MessageHandler.error(""String_Node_Str"",ex);
    }
  }
 else {
    textArea.setText(""String_Node_Str"");
  }
  if (_frame != null) {
    _frame.setVisible(true);
    _frame.toFront();
  }
}","private void _createOrShowWindow(String title){
  if (textArea == null) {
    Effigy containerEffigy=Configuration.findEffigy(_actor.toplevel());
    try {
      if (containerEffigy == null) {
        throw new IllegalActionException(""String_Node_Str"" + _actor.toplevel().getFullName() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      }
      TextEffigy textEffigy=TextEffigy.newTextEffigy(containerEffigy,""String_Node_Str"");
      textEffigy.identifier.setExpression(_actor.getFullName());
      _tableau=new DisplayWindowTableau(_actor,textEffigy,title);
      _frame=_tableau.frame.get();
      if (_frame != null) {
        JScrollPane pane=((TextEditor)_frame).getScrollPane();
        if (pane != null) {
          pane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
        }
        textArea=((TextEditor)_frame).text;
        textArea.setRows(10);
        textArea.setColumns(40);
        _actor.setFrame(_frame);
        _frame.pack();
      }
    }
 catch (    Exception ex) {
      MessageHandler.error(""String_Node_Str"",ex);
    }
  }
 else {
    textArea.setText(""String_Node_Str"");
  }
  if (_frame != null) {
    _frame.setVisible(true);
    _frame.toFront();
  }
}"
72333,"/** 
 * Open the camera. This starts a sequence of notifications that call webcamImageObtained() and trigger emission of the ""image"" event for the corresponding JavaScript object.
 */
public void open(){
  if (_webcam != null) {
    String cameraName=_webcam.getName();
    if (_openCameras != null) {
      WeakReference<JavaScript> actor=_openCameras.get(cameraName);
      if (actor != null && actor.get() != null) {
        _actor.error(""String_Node_Str"" + cameraName + ""String_Node_Str""+ actor.get().getFullName()+ ""String_Node_Str""+ _actor.getFullName());
        return;
      }
 else       if (actor != null) {
        _openCameras.remove(cameraName);
      }
    }
 else {
      _openCameras=new HashMap<String,WeakReference<JavaScript>>();
    }
    _webcam.open(true);
    _openCameras.put(cameraName,new WeakReference(_actor));
  }
}","/** 
 * Open the camera. This starts a sequence of notifications that call webcamImageObtained() and trigger emission of the ""image"" event for the corresponding JavaScript object.
 */
public void open(){
  if (_webcam != null) {
    String cameraName=_webcam.getName();
    if (_openCameras != null) {
      WeakReference<JavaScript> actor=_openCameras.get(cameraName);
      if (actor != null && actor.get() != null) {
        _actor.error(""String_Node_Str"" + (cameraName == null ? ""String_Node_Str"" : cameraName) + ""String_Node_Str""+ actor.get().getFullName()+ ""String_Node_Str""+ _actor.getFullName());
        return;
      }
 else       if (actor != null) {
        _openCameras.remove(cameraName);
      }
    }
 else {
      _openCameras=new HashMap<String,WeakReference<JavaScript>>();
    }
    _webcam.open(true);
    _openCameras.put(cameraName,new WeakReference(_actor));
  }
}"
72334,"/** 
 * Invoke the specified function after the specified amount of time. The time will be added to the current time of the director, and fireAt() request will be made of the director. If the director cannot fulfill the request, this method will throw an exception. Note that if you want real-time behavior, then the director's synchronizeToRealTime parameter needs to be set to true.
 * @param function The function to invoke.
 * @param milliseconds The number of milliseconds in the future to invoke it.
 * @return A unique ID for this callback.
 * @exception IllegalActionException If the director cannot respect the request.
 * @see #clearTimeout(Object)
 */
@Override public synchronized Object setTimeout(final Runnable function,final int milliseconds) throws IllegalActionException {
  final Integer id=Integer.valueOf(_timeoutCount++);
  _setTimeout(function,milliseconds,id);
  return Integer.valueOf(id);
}","/** 
 * Invoke the specified function after the specified amount of time. The time will be added to the current time of the director, and fireAt() request will be made of the director. If the director cannot fulfill the request, this method will throw an exception. Note that if you want real-time behavior, then the director's synchronizeToRealTime parameter needs to be set to true.
 * @param function The function to invoke.
 * @param milliseconds The number of milliseconds in the future to invoke it.
 * @return A unique ID for this callback.
 * @exception IllegalActionException If the director cannot respect the request.
 * @see #clearTimeout(Object)
 */
@Override public synchronized Object setTimeout(final Runnable function,final int milliseconds) throws IllegalActionException {
  final Integer id=Integer.valueOf(_timeoutCount++);
  _setTimeout(function,milliseconds,id);
  return id;
}"
72335,"@SuppressWarnings(""String_Node_Str"") @Override public void run(){
  Map<String,Object> urlSpec=(Map<String,Object>)_options.get(""String_Node_Str"");
  HttpClient client=null;
  boolean useProxy=false;
  Object proxyHostObject=_options.get(""String_Node_Str"");
  Object proxyPortObject=_options.get(""String_Node_Str"");
  if (proxyHostObject != null && proxyPortObject != null) {
    useProxy=true;
    String proxyHostSpec=proxyHostObject.toString().trim();
    int proxyPortSpec=(int)proxyPortObject;
    client=_vertx.createHttpClient(new HttpClientOptions().setKeepAlive((boolean)_options.get(""String_Node_Str"")).setConnectTimeout((Integer)_options.get(""String_Node_Str"")).setSsl(urlSpec.get(""String_Node_Str"").toString().equalsIgnoreCase(""String_Node_Str"")).setProxyOptions(new ProxyOptions().setType(ProxyType.HTTP).setHost(proxyHostSpec).setPort(proxyPortSpec)));
  }
 else {
    client=_vertx.createHttpClient(new HttpClientOptions().setDefaultHost((String)urlSpec.get(""String_Node_Str"")).setDefaultPort((int)urlSpec.get(""String_Node_Str"")).setKeepAlive((boolean)_options.get(""String_Node_Str"")).setConnectTimeout((Integer)_options.get(""String_Node_Str"")).setSsl(urlSpec.get(""String_Node_Str"").toString().equalsIgnoreCase(""String_Node_Str"")));
  }
  String query=""String_Node_Str"";
  Object queryObject=urlSpec.get(""String_Node_Str"");
  if (queryObject != null) {
    String querySpec=queryObject.toString().trim();
    if (!querySpec.equals(""String_Node_Str"") && !querySpec.startsWith(""String_Node_Str"")) {
      query=""String_Node_Str"" + querySpec;
    }
  }
  String uri=urlSpec.get(""String_Node_Str"") + query;
  Object complete=_options.get(""String_Node_Str"");
  boolean outputCompleteResponseOnly=true;
  if (complete instanceof Boolean && !(Boolean)complete) {
    outputCompleteResponseOnly=false;
  }
  HttpMethod httpMethod=HttpMethod.valueOf(((String)_options.get(""String_Node_Str"")).trim().toUpperCase());
  HttpClientRequest request=null;
  if (useProxy) {
    request=client.requestAbs(httpMethod,(String)urlSpec.get(""String_Node_Str"") + ""String_Node_Str"" + (String)urlSpec.get(""String_Node_Str"")+ uri,new HttpClientResponseHandler(_requestObj,client,outputCompleteResponseOnly,_requestNumber));
  }
 else {
    request=client.request(httpMethod,uri,new HttpClientResponseHandler(_requestObj,client,outputCompleteResponseOnly,_requestNumber));
  }
  request.setTimeout((Integer)_options.get(""String_Node_Str""));
  request.exceptionHandler(new HttpClientExceptionHandler(_requestObj,client,_requestNumber));
  Map<String,Object> headers=(Map<String,Object>)_options.get(""String_Node_Str"");
  boolean isImage=false;
  String imageType=""String_Node_Str"";
  if (!headers.isEmpty()) {
    for (    Entry<String,Object> entry : headers.entrySet()) {
      String key=entry.getKey();
      Object value=entry.getValue();
      if (key.equalsIgnoreCase(""String_Node_Str"") && ((String)value).startsWith(""String_Node_Str"")) {
        isImage=true;
        imageType=((String)value).substring(6);
        if (!imageType.equalsIgnoreCase(""String_Node_Str"") && !imageType.equalsIgnoreCase(""String_Node_Str"") && !imageType.equalsIgnoreCase(""String_Node_Str"")&& !imageType.equalsIgnoreCase(""String_Node_Str"")) {
          _error(_requestObj,""String_Node_Str"" + imageType + ""String_Node_Str""+ ""String_Node_Str"");
          imageType=""String_Node_Str"";
        }
      }
      if (value instanceof String) {
        request.putHeader((String)key,(String)value);
      }
 else       if (value instanceof Integer) {
        request.putHeader((String)key,((Integer)value).toString());
      }
 else       if (value instanceof Iterable) {
        request.putHeader((String)key,(Iterable<String>)value);
      }
    }
  }
  if (isImage) {
    AWTImageToken token=(AWTImageToken)_options.get(""String_Node_Str"");
    Image image=token.getValue();
    BufferedImage bufferedImage;
    if (image instanceof BufferedImage) {
      bufferedImage=(BufferedImage)image;
    }
 else {
      bufferedImage=new BufferedImage(image.getWidth(null),image.getHeight(null),BufferedImage.TYPE_INT_ARGB);
      Graphics2D bGr=bufferedImage.createGraphics();
      bGr.drawImage(image,0,0,null);
      bGr.dispose();
    }
    final ByteArrayOutputStream os=new ByteArrayOutputStream();
    try {
      ImageIO.write(bufferedImage,imageType,os);
      os.close();
      byte[] bytes=os.toByteArray();
      request.sendHead();
      request.setChunked(true);
      for (int i=0; i < bytes.length; i=i + 4000) {
        request.write(Buffer.buffer(Base64.getEncoder().encodeToString(Arrays.copyOfRange(bytes,i,i + 4000))));
      }
    }
 catch (    final IOException ioe) {
      String message=""String_Node_Str"";
      _error(_requestObj,message);
    }
  }
 else {
    Object bodyObject=_options.get(""String_Node_Str"");
    if (bodyObject != null) {
      String body=bodyObject.toString();
      if (body != null) {
        request.putHeader(""String_Node_Str"",Integer.toString(body.length()));
        request.write(body);
      }
    }
  }
  request.end();
}","@SuppressWarnings(""String_Node_Str"") @Override public void run(){
  Map<String,Object> urlSpec=(Map<String,Object>)_options.get(""String_Node_Str"");
  HttpClient client=null;
  boolean useProxy=false;
  Object proxyHostObject=_options.get(""String_Node_Str"");
  Object proxyPortObject=_options.get(""String_Node_Str"");
  if (proxyHostObject != null && proxyPortObject != null) {
    useProxy=true;
    String proxyHostSpec=proxyHostObject.toString().trim();
    int proxyPortSpec=(int)proxyPortObject;
    client=_vertx.createHttpClient(new HttpClientOptions().setKeepAlive((boolean)_options.get(""String_Node_Str"")).setConnectTimeout((Integer)_options.get(""String_Node_Str"")).setSsl(urlSpec.get(""String_Node_Str"").toString().equalsIgnoreCase(""String_Node_Str"")).setProxyOptions(new ProxyOptions().setType(ProxyType.HTTP).setHost(proxyHostSpec).setPort(proxyPortSpec)));
  }
 else {
    client=_vertx.createHttpClient(new HttpClientOptions().setDefaultHost((String)urlSpec.get(""String_Node_Str"")).setDefaultPort((int)urlSpec.get(""String_Node_Str"")).setKeepAlive((boolean)_options.get(""String_Node_Str"")).setConnectTimeout((Integer)_options.get(""String_Node_Str"")).setSsl(urlSpec.get(""String_Node_Str"").toString().equalsIgnoreCase(""String_Node_Str"")));
  }
  String query=""String_Node_Str"";
  Object queryObject=urlSpec.get(""String_Node_Str"");
  if (queryObject != null) {
    String querySpec=queryObject.toString().trim();
    if (!querySpec.equals(""String_Node_Str"") && !querySpec.startsWith(""String_Node_Str"")) {
      query=""String_Node_Str"" + querySpec;
    }
  }
  String uri=urlSpec.get(""String_Node_Str"") + query;
  Object complete=_options.get(""String_Node_Str"");
  boolean outputCompleteResponseOnly=true;
  if (complete instanceof Boolean && !(Boolean)complete) {
    outputCompleteResponseOnly=false;
  }
  HttpMethod httpMethod=HttpMethod.valueOf(((String)_options.get(""String_Node_Str"")).trim().toUpperCase());
  HttpClientRequest request=null;
  if (useProxy) {
    request=client.requestAbs(httpMethod,(String)urlSpec.get(""String_Node_Str"") + ""String_Node_Str"" + (String)urlSpec.get(""String_Node_Str"")+ uri,new HttpClientResponseHandler(_requestObj,client,outputCompleteResponseOnly,_requestNumber));
  }
 else {
    request=client.request(httpMethod,uri,new HttpClientResponseHandler(_requestObj,client,outputCompleteResponseOnly,_requestNumber));
  }
  request.setTimeout((Integer)_options.get(""String_Node_Str""));
  request.exceptionHandler(new HttpClientExceptionHandler(_requestObj,client,_requestNumber));
  Map<String,Object> headers=(Map<String,Object>)_options.get(""String_Node_Str"");
  boolean isImage=false;
  String imageType=""String_Node_Str"";
  if (!headers.isEmpty()) {
    for (    Entry<String,Object> entry : headers.entrySet()) {
      String key=entry.getKey();
      Object value=entry.getValue();
      if (key.equalsIgnoreCase(""String_Node_Str"") && ((String)value).startsWith(""String_Node_Str"")) {
        isImage=true;
        imageType=((String)value).substring(6);
        if (!imageType.equalsIgnoreCase(""String_Node_Str"") && !imageType.equalsIgnoreCase(""String_Node_Str"") && !imageType.equalsIgnoreCase(""String_Node_Str"")&& !imageType.equalsIgnoreCase(""String_Node_Str"")) {
          _error(_requestObj,""String_Node_Str"" + imageType + ""String_Node_Str""+ ""String_Node_Str"");
          imageType=""String_Node_Str"";
        }
      }
      if (value instanceof String) {
        request.putHeader((String)key,(String)value);
      }
 else       if (value instanceof Integer) {
        request.putHeader((String)key,((Integer)value).toString());
      }
 else       if (value instanceof Iterable) {
        request.putHeader((String)key,(Iterable<String>)value);
      }
    }
  }
  if (isImage) {
    AWTImageToken token=(AWTImageToken)_options.get(""String_Node_Str"");
    Image image=token.getValue();
    BufferedImage bufferedImage;
    if (image instanceof BufferedImage) {
      bufferedImage=(BufferedImage)image;
    }
 else {
      bufferedImage=new BufferedImage(image.getWidth(null),image.getHeight(null),BufferedImage.TYPE_INT_ARGB);
      Graphics2D bGr=bufferedImage.createGraphics();
      bGr.drawImage(image,0,0,null);
      bGr.dispose();
    }
    final ByteArrayOutputStream os=new ByteArrayOutputStream();
    try {
      ImageIO.write(bufferedImage,imageType,os);
      os.close();
      byte[] bytes=os.toByteArray();
      request.sendHead();
      request.setChunked(true);
      String encoded=Base64.getEncoder().encodeToString(bytes);
      for (int i=0; i < encoded.length(); i=i + 4000) {
        int end=i + 4000 < encoded.length() ? i + 4000 : encoded.length();
        request.write(Buffer.buffer(encoded.substring(i,end)));
      }
    }
 catch (    final IOException ioe) {
      String message=""String_Node_Str"";
      _error(_requestObj,message);
    }
  }
 else {
    Object bodyObject=_options.get(""String_Node_Str"");
    if (bodyObject != null) {
      String body=bodyObject.toString();
      if (body != null) {
        request.putHeader(""String_Node_Str"",Integer.toString(body.length()));
        request.write(body);
      }
    }
  }
  request.end();
}"
72336,"public AWTImageToken convertImageBody(String body){
  int comma=body.indexOf(""String_Node_Str"");
  if (comma > -1) {
    body=body.substring(comma + 1,body.length());
  }
  try {
    byte[] bytes=new BigInteger(body,64).toByteArray();
    BufferedImage image=ImageIO.read(new ByteArrayInputStream(bytes));
    AWTImageToken token=new AWTImageToken(image);
    return token;
  }
 catch (  IOException e) {
    _error(""String_Node_Str"" + e.toString());
    AWTImageToken imageToken=new AWTImageToken(null);
    return imageToken;
  }
}","public AWTImageToken convertImageBody(String body){
  int comma=body.indexOf(""String_Node_Str"");
  if (comma > -1) {
    body=body.substring(comma + 1,body.length());
  }
  try {
    byte[] bytes=Base64.getDecoder().decode(body);
    BufferedImage image=ImageIO.read(new ByteArrayInputStream(bytes));
    AWTImageToken token=new AWTImageToken(image);
    return token;
  }
 catch (  Throwable throwable) {
    System.out.println(""String_Node_Str"" + throwable);
    throwable.printStackTrace();
    _error(_actor + ""String_Node_Str"" + throwable.toString());
    AWTImageToken imageToken=new AWTImageToken(null);
    return imageToken;
  }
}"
72337,"/** 
 * Update the HLA attribute <i>attributeName</i> with the containment of the token <i>in</i>. The updated attribute is sent to the HLA/CERTI Federation.
 * @param hp The HLA publisher actor (HLA attribute) to update.
 * @param in The updated value of the HLA attribute to update.
 * @param senderName the name of the federate that sent the attribute.
 * @exception IllegalActionException If a CERTI exception is raised thendisplayed it to the user.
 */
public void updateHlaAttribute(HlaPublisher hp,Token in,String senderName) throws IllegalActionException {
  SuperdenseTime currentSuperdenseTime=_getModelSuperdenseTime();
  Time currentTime=new Time(_director,currentSuperdenseTime.timestamp().getDoubleValue());
  int microstep=currentSuperdenseTime.index();
  Object[] tObj=_hlaAttributesToPublish.get(hp.getName());
  byte[] valAttribute=MessageProcessing.encodeHlaValue(hp,in);
  if (_debugging) {
    _debug(""String_Node_Str"" + _printTimes(currentTime) + ""String_Node_Str""+ _federateAmbassador.logicalTimeHLA+ ""String_Node_Str""+ ""String_Node_Str"");
  }
  SuppliedAttributes suppAttributes=null;
  try {
    suppAttributes=RtiFactoryFactory.getRtiFactory().createSuppliedAttributes();
  }
 catch (  RTIinternalError e) {
    throw new IllegalActionException(this,e,""String_Node_Str"");
  }
  suppAttributes.add(_getAttributeHandleFromTab(tObj),valAttribute);
  byte[] tag=EncodingHelpers.encodeString(_getPortFromTab(tObj).getContainer().getName());
  Time uavTimeStamp=null;
  if (_eventBased) {
    uavTimeStamp=currentTime.add(_hlaLookAHead);
  }
 else {
    CertiLogicalTime certiCurrentTime=(CertiLogicalTime)_federateAmbassador.logicalTimeHLA;
    Time hlaCurrentTime=_convertToPtolemyTime(certiCurrentTime);
    if (hlaCurrentTime.add(_hlaLookAHead).compareTo(currentTime) > 0) {
      uavTimeStamp=hlaCurrentTime.add(_hlaLookAHead);
    }
 else {
      uavTimeStamp=currentTime;
    }
  }
  CertiLogicalTime ct=_convertToCertiLogicalTime(uavTimeStamp);
  if (_debugging) {
    _debug(""String_Node_Str"" + _getPortFromTab(tObj).getContainer().getName() + ""String_Node_Str""+ ct.getTime()+ ""String_Node_Str""+ in.toString()+ ""String_Node_Str"");
  }
  try {
    int id=_registeredObject.get(_federateName + ""String_Node_Str"" + senderName);
    int indexOfAttribute=0;
    String attributeName=_getPortFromTab(tObj).getContainer().getName();
    for (int i=0; i < _numberOfAttributesToPublish; i++) {
      if (attributeName.equals(_nameOfTheAttributesToPublish[i])) {
        indexOfAttribute=i;
        break;
      }
    }
    String pUAVTimeStamp=ct.getTime() + ""String_Node_Str"";
    ;
    String preUAVTimeStamp=""String_Node_Str"" + _printTimes(currentTime) + ""String_Node_Str""+ microstep+ ""String_Node_Str"";
    _storeTimes(""String_Node_Str"" + _getPortFromTab(tObj).getContainer().getName());
    if (_numberOfUAVs > 0 && (_preUAVsTimes.length() - _preUAVsTimes.lastIndexOf(preUAVTimeStamp)) == preUAVTimeStamp.length() && (_pUAVsTimes.length() - _pUAVsTimes.lastIndexOf(pUAVTimeStamp)) == pUAVTimeStamp.length()) {
      _UAVsValues[indexOfAttribute].replace(_UAVsValues[indexOfAttribute].length() - 2,_UAVsValues[indexOfAttribute].length(),in.toString() + ""String_Node_Str"");
    }
 else {
      _preUAVsTimes.append(preUAVTimeStamp);
      _pUAVsTimes.append(pUAVTimeStamp);
      for (int i=0; i < _numberOfAttributesToPublish; i++) {
        if (i == indexOfAttribute) {
          _UAVsValues[i].append(in.toString() + ""String_Node_Str"");
        }
 else {
          _UAVsValues[i].append(""String_Node_Str"");
        }
      }
    }
    _rtia.updateAttributeValues(id,suppAttributes,tag,ct);
    _numberOfUAVs++;
  }
 catch (  Exception e) {
    throw new IllegalActionException(this,e,e.getMessage());
  }
}","/** 
 * Update the HLA attribute <i>attributeName</i> with the containment of the token <i>in</i>. The updated attribute is sent to the HLA/CERTI Federation.
 * @param hp The HLA publisher actor (HLA attribute) to update.
 * @param in The updated value of the HLA attribute to update.
 * @param senderName the name of the federate that sent the attribute.
 * @exception IllegalActionException If a CERTI exception is raised thendisplayed it to the user.
 */
public void updateHlaAttribute(HlaPublisher hp,Token in,String senderName) throws IllegalActionException {
  SuperdenseTime currentSuperdenseTime=_getModelSuperdenseTime();
  Time currentTime=new Time(_director,currentSuperdenseTime.timestamp().getDoubleValue());
  int microstep=currentSuperdenseTime.index();
  Object[] tObj=_hlaAttributesToPublish.get(hp.getName());
  byte[] valAttribute=MessageProcessing.encodeHlaValue(hp,in);
  if (_debugging) {
    _debug(""String_Node_Str"" + _printTimes(currentTime) + ""String_Node_Str""+ _federateAmbassador.logicalTimeHLA+ ""String_Node_Str""+ ""String_Node_Str"");
  }
  SuppliedAttributes suppAttributes=null;
  try {
    suppAttributes=RtiFactoryFactory.getRtiFactory().createSuppliedAttributes();
  }
 catch (  RTIinternalError e) {
    throw new IllegalActionException(this,e,""String_Node_Str"");
  }
  suppAttributes.add(_getAttributeHandleFromTab(tObj),valAttribute);
  byte[] tag=EncodingHelpers.encodeString(_getPortFromTab(tObj).getContainer().getName());
  Time uavTimeStamp=null;
  if (_eventBased) {
    uavTimeStamp=currentTime.add(_hlaLookAHead);
  }
 else {
    CertiLogicalTime certiCurrentTime=(CertiLogicalTime)_federateAmbassador.logicalTimeHLA;
    Time hlaCurrentTime=_convertToPtolemyTime(certiCurrentTime);
    if (hlaCurrentTime.add(_hlaLookAHead).compareTo(currentTime) > 0) {
      uavTimeStamp=hlaCurrentTime.add(_hlaLookAHead);
    }
 else {
      uavTimeStamp=currentTime;
    }
  }
  CertiLogicalTime ct=_convertToCertiLogicalTime(uavTimeStamp);
  if (_debugging) {
    _debug(""String_Node_Str"" + _getPortFromTab(tObj).getContainer().getName() + ""String_Node_Str""+ ct.getTime()+ ""String_Node_Str""+ in.toString()+ ""String_Node_Str"");
  }
  try {
    int id=_registeredObject.get(_federateName + ""String_Node_Str"" + senderName);
    int indexOfAttribute=0;
    String attributeName=_getPortFromTab(tObj).getContainer().getName();
    for (int i=0; i < _numberOfAttributesToPublish; i++) {
      if (attributeName.equals(_nameOfTheAttributesToPublish[i])) {
        indexOfAttribute=i;
        break;
      }
    }
    String pUAVTimeStamp=ct.getTime() + ""String_Node_Str"";
    ;
    String preUAVTimeStamp=""String_Node_Str"" + _printTimes(currentTime) + ""String_Node_Str""+ microstep+ ""String_Node_Str"";
    _storeTimes(""String_Node_Str"" + _getPortFromTab(tObj).getContainer().getName());
    if (_numberOfUAVs > 0 && (_preUAVsTimes.length() - _preUAVsTimes.lastIndexOf(preUAVTimeStamp)) == preUAVTimeStamp.length() && (_pUAVsTimes.length() - _pUAVsTimes.lastIndexOf(pUAVTimeStamp)) == pUAVTimeStamp.length()) {
      _UAVsValues[indexOfAttribute].replace(_UAVsValues[indexOfAttribute].length() - 2,_UAVsValues[indexOfAttribute].length(),in.toString() + ""String_Node_Str"");
    }
 else {
      _preUAVsTimes.append(preUAVTimeStamp);
      _pUAVsTimes.append(pUAVTimeStamp);
      for (int i=0; i < _numberOfAttributesToPublish; i++) {
        if (i == indexOfAttribute) {
          _UAVsValues[i].append(in.toString() + ""String_Node_Str"");
        }
 else {
          _UAVsValues[i].append(""String_Node_Str"");
        }
      }
    }
    _rtia.updateAttributeValues(id,suppAttributes,tag,ct);
    _numberOfUAVs++;
  }
 catch (  RuntimeException e) {
    throw e;
  }
catch (  Exception e) {
    throw new IllegalActionException(this,e,e.getMessage());
  }
}"
72338,"/** 
 * Change a parameter in the .xml, making it vary within an interval defined by the parameters start and end. Run a ptolemy simulation for each step between the interval.
 * @param waitingTime The time the system will wait to close all the windows of a federation, after its execution has finished.This parameter is intended to give the user the ability to choose how long he will have to look at the simulation's results. If the variable is given a negative value, the user will be asked repetedly if he had time to look at the models and they will only close when he answers ""yes"".
 * @param vergil An instance of vergil.
 * @param modelPath The path to the model you want to run.
 * @param propertyLine The xml line of the parameter that we want to change.
 * @param start The value of the parameter.
 * @param end The end value of the parameter.
 * @param step The increment of the parameter value.
 * @param solver Which RKSolver to use
 * @exception IllegalActionException If there is a problem reading a file.
 */
public static void changeParameter(int waitingTime,AutomaticSimulation vergil,String[] modelPath,String propertyLine,float start,float end,float step,int solver) throws IllegalActionException {
  int numberOfFederates=modelPath.length;
  File[] file=new File[numberOfFederates];
  String[][] data=new String[numberOfFederates][3];
  String s=""String_Node_Str"" + step;
  s=s.substring(s.indexOf(""String_Node_Str""));
  int numberOfDecimalDigits=s.length();
  for (int i=0; i < numberOfFederates; i++) {
    file[i]=new File(modelPath[i]);
    ArrayList<String> content;
    try {
      content=convertFileToString(file[i]);
    }
 catch (    IOException ex) {
      throw new IllegalActionException(null,ex,""String_Node_Str"" + file[i]);
    }
    String[] info=_findPropertyLine(content,propertyLine);
    data[i][0]=info[0];
    data[i][1]=info[1];
    data[i][2]=info[2];
  }
  int numberOfInteractions=Math.round(((end - start) / step) + 1);
  for (int i=0; i < numberOfInteractions; i++) {
    float x=start + i * step;
    x=(float)(Math.round(x * Math.pow(10,numberOfDecimalDigits)) / Math.pow(10,numberOfDecimalDigits));
    final CompositeEntity[] model=new CompositeEntity[numberOfFederates];
    for (int j=0; j < numberOfFederates; j++) {
      System.out.println(""String_Node_Str"" + j + ""String_Node_Str"");
      String line=data[j][1] + x + ""String_Node_Str"";
      _writeInFile(file[j],data[j][0] + ""String_Node_Str"" + line+ ""String_Node_Str""+ data[j][2]);
      model[j]=_openModel(modelPath[j]);
    }
    runAllModels(vergil);
    if (waitingTime < 0) {
      Scanner input=new Scanner(System.in,""String_Node_Str"");
      while (true) {
        System.out.println(""String_Node_Str"");
        String answer=input.next();
        if (answer.equalsIgnoreCase(""String_Node_Str""))         input.close();
        break;
      }
      _sleep(2000);
    }
 else     if (waitingTime > 0) {
      _sleep(waitingTime);
    }
    for (int j=0; j < numberOfFederates; j++) {
      _closeModel(model[j]);
    }
    _killRTIG();
  }
  try {
    Configuration.closeAllTableaux();
  }
 catch (  IllegalActionException e) {
    e.printStackTrace();
  }
}","/** 
 * Change a parameter in the .xml, making it vary within an interval defined by the parameters start and end. Run a ptolemy simulation for each step between the interval.
 * @param waitingTime The time the system will wait to close all the windows of a federation, after its execution has finished.This parameter is intended to give the user the ability to choose how long he will have to look at the simulation's results. If the variable is given a negative value, the user will be asked repetedly if he had time to look at the models and they will only close when he answers ""yes"".
 * @param vergil An instance of vergil.
 * @param modelPath The path to the model you want to run.
 * @param propertyLine The xml line of the parameter that we want to change.
 * @param start The value of the parameter.
 * @param end The end value of the parameter.
 * @param step The increment of the parameter value.
 * @param solver Which RKSolver to use
 * @exception IllegalActionException If there is a problem reading a file.
 */
public static void changeParameter(int waitingTime,AutomaticSimulation vergil,String[] modelPath,String propertyLine,float start,float end,float step,int solver) throws IllegalActionException {
  int numberOfFederates=modelPath.length;
  File[] file=new File[numberOfFederates];
  String[][] data=new String[numberOfFederates][3];
  String s=""String_Node_Str"" + step;
  s=s.substring(s.indexOf(""String_Node_Str""));
  int numberOfDecimalDigits=s.length();
  for (int i=0; i < numberOfFederates; i++) {
    file[i]=new File(modelPath[i]);
    ArrayList<String> content;
    try {
      content=convertFileToString(file[i]);
    }
 catch (    IOException ex) {
      throw new IllegalActionException(null,ex,""String_Node_Str"" + file[i]);
    }
    String[] info=_findPropertyLine(content,propertyLine);
    data[i][0]=info[0];
    data[i][1]=info[1];
    data[i][2]=info[2];
  }
  int numberOfInteractions=Math.round(((end - start) / step) + 1);
  for (int i=0; i < numberOfInteractions; i++) {
    float x=start + i * step;
    x=(float)(Math.round(x * Math.pow(10,numberOfDecimalDigits)) / Math.pow(10,numberOfDecimalDigits));
    final CompositeEntity[] model=new CompositeEntity[numberOfFederates];
    for (int j=0; j < numberOfFederates; j++) {
      System.out.println(""String_Node_Str"" + j + ""String_Node_Str"");
      String line=data[j][1] + x + ""String_Node_Str"";
      _writeInFile(file[j],data[j][0] + ""String_Node_Str"" + line+ ""String_Node_Str""+ data[j][2]);
      model[j]=_openModel(modelPath[j]);
    }
    runAllModels(vergil);
    if (waitingTime < 0) {
      Scanner input=new Scanner(System.in,""String_Node_Str"");
      while (true) {
        System.out.println(""String_Node_Str"");
        String answer=input.next();
        if (answer.equalsIgnoreCase(""String_Node_Str"")) {
          input.close();
          break;
        }
      }
      _sleep(2000);
    }
 else     if (waitingTime > 0) {
      _sleep(waitingTime);
    }
    for (int j=0; j < numberOfFederates; j++) {
      _closeModel(model[j]);
    }
    _killRTIG();
  }
  try {
    Configuration.closeAllTableaux();
  }
 catch (  IllegalActionException e) {
    e.printStackTrace();
  }
}"
72339,"/** 
 * Change a parameter in the .xml, making it vary within an interval defined by the parameters start and end. Run a ptolemy simulation for each step between the interval.
 * @param waitingTime The time the system will wait to close all the windows of a federation, after its execution has finished.This parameter is intended to give the user the ability to choose how long he will have to look at the simulation's results. If the variable is given a negative value, the user will be asked repetedly if he had time to look at the models and they will only close when he answers ""yes"".
 * @param vergil An instance of vergil.
 * @param modelPath The path to the model you want to run.
 * @param propertyLines The xml line of the parameter that we want to change.
 * @param values The values the new property will assume.
 * @param solver The Runge-Kutta solver order number.
 * @exception IllegalActionException If there is a problem reading a file.
 */
public static void changeParameters(int waitingTime,AutomaticSimulation vergil,String[] modelPath,String[] propertyLines,double[][] values,int solver) throws IllegalActionException {
  if (propertyLines.length != values.length) {
    System.out.println(""String_Node_Str"");
    return;
  }
  int numberOfFederates=modelPath.length;
  int numberOfParameters=propertyLines.length;
  File[] file=new File[numberOfFederates];
  String[][][] data=new String[numberOfFederates][numberOfParameters + 1][2];
  for (int i=0; i < numberOfFederates; i++) {
    file[i]=new File(modelPath[i]);
    ArrayList<String> content;
    try {
      content=convertFileToString(file[i]);
    }
 catch (    IOException ex) {
      throw new IllegalActionException(null,ex,""String_Node_Str"" + file[i]);
    }
    content=_changeRKSolver(content,solver);
    content=_changeRKSolver(content,solver);
    data[i]=_findPropertyLines(content,propertyLines);
  }
  int numberOfInteractions=values[0].length;
  for (int i=0; i < numberOfInteractions; i++) {
    final CompositeEntity[] model=new CompositeEntity[numberOfFederates];
    for (int j=0; j < numberOfFederates; j++) {
      StringBuffer info=new StringBuffer();
      for (int y=0; y < numberOfParameters; y++) {
        info.append(""String_Node_Str"" + data[j][y][0] + ""String_Node_Str""+ data[j][y][1]+ values[y][i]+ ""String_Node_Str"");
      }
      System.out.println(""String_Node_Str"" + j + ""String_Node_Str"");
      _writeInFile(file[j],info.substring(1) + ""String_Node_Str"" + data[j][numberOfParameters][0]);
      model[j]=_openModel(modelPath[j]);
    }
    runAllModels(vergil);
    if (waitingTime < 0) {
      Scanner input=new Scanner(System.in,""String_Node_Str"");
      while (true) {
        System.out.println(""String_Node_Str"");
        String answer=input.next();
        if (answer.equalsIgnoreCase(""String_Node_Str""))         input.close();
        break;
      }
      _sleep(2000);
    }
 else     if (waitingTime > 0) {
      _sleep(waitingTime);
    }
    for (int j=0; j < numberOfFederates; j++) {
      _closeModel(model[j]);
    }
    _killRTIG();
  }
  try {
    Configuration.closeAllTableaux();
  }
 catch (  IllegalActionException e) {
    e.printStackTrace();
  }
}","/** 
 * Change a parameter in the .xml, making it vary within an interval defined by the parameters start and end. Run a ptolemy simulation for each step between the interval.
 * @param waitingTime The time the system will wait to close all the windows of a federation, after its execution has finished.This parameter is intended to give the user the ability to choose how long he will have to look at the simulation's results. If the variable is given a negative value, the user will be asked repetedly if he had time to look at the models and they will only close when he answers ""yes"".
 * @param vergil An instance of vergil.
 * @param modelPath The path to the model you want to run.
 * @param propertyLines The xml line of the parameter that we want to change.
 * @param values The values the new property will assume.
 * @param solver The Runge-Kutta solver order number.
 * @exception IllegalActionException If there is a problem reading a file.
 */
public static void changeParameters(int waitingTime,AutomaticSimulation vergil,String[] modelPath,String[] propertyLines,double[][] values,int solver) throws IllegalActionException {
  if (propertyLines.length != values.length) {
    System.out.println(""String_Node_Str"");
    return;
  }
  int numberOfFederates=modelPath.length;
  int numberOfParameters=propertyLines.length;
  File[] file=new File[numberOfFederates];
  String[][][] data=new String[numberOfFederates][numberOfParameters + 1][2];
  for (int i=0; i < numberOfFederates; i++) {
    file[i]=new File(modelPath[i]);
    ArrayList<String> content;
    try {
      content=convertFileToString(file[i]);
    }
 catch (    IOException ex) {
      throw new IllegalActionException(null,ex,""String_Node_Str"" + file[i]);
    }
    content=_changeRKSolver(content,solver);
    content=_changeRKSolver(content,solver);
    data[i]=_findPropertyLines(content,propertyLines);
  }
  int numberOfInteractions=values[0].length;
  for (int i=0; i < numberOfInteractions; i++) {
    final CompositeEntity[] model=new CompositeEntity[numberOfFederates];
    for (int j=0; j < numberOfFederates; j++) {
      StringBuffer info=new StringBuffer();
      for (int y=0; y < numberOfParameters; y++) {
        info.append(""String_Node_Str"" + data[j][y][0] + ""String_Node_Str""+ data[j][y][1]+ values[y][i]+ ""String_Node_Str"");
      }
      System.out.println(""String_Node_Str"" + j + ""String_Node_Str"");
      _writeInFile(file[j],info.substring(1) + ""String_Node_Str"" + data[j][numberOfParameters][0]);
      model[j]=_openModel(modelPath[j]);
    }
    runAllModels(vergil);
    if (waitingTime < 0) {
      Scanner input=new Scanner(System.in,""String_Node_Str"");
      while (true) {
        System.out.println(""String_Node_Str"");
        String answer=input.next();
        if (answer.equalsIgnoreCase(""String_Node_Str"")) {
          input.close();
          break;
        }
      }
      _sleep(2000);
    }
 else     if (waitingTime > 0) {
      _sleep(waitingTime);
    }
    for (int j=0; j < numberOfFederates; j++) {
      _closeModel(model[j]);
    }
    _killRTIG();
  }
  try {
    Configuration.closeAllTableaux();
  }
 catch (  IllegalActionException e) {
    e.printStackTrace();
  }
}"
72340,"/** 
 * Write some information in a file.
 * @param file The file were the information is going to be written.
 * @param data The information that is going to be written.
 */
private static void _writeInFile(File file,String data){
  BufferedWriter writer=null;
  try {
    writer=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file),""String_Node_Str""));
    writer.write(data);
    writer.flush();
  }
 catch (  IOException e) {
    System.out.println(""String_Node_Str"");
  }
 finally {
    if (writer != null) {
      try {
        writer.close();
      }
 catch (      IOException e) {
        System.out.println(""String_Node_Str"");
      }
    }
  }
}","/** 
 * Write some information in a file.
 * @param file The file were the information is going to be written.
 * @param data The information that is going to be written.
 */
private static void _writeInFile(File file,String data){
  BufferedWriter writer=null;
  try {
    writer=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file,true),""String_Node_Str""));
    writer.write(data);
    writer.flush();
  }
 catch (  IOException e) {
    System.out.println(""String_Node_Str"");
  }
 finally {
    if (writer != null) {
      try {
        writer.close();
      }
 catch (      IOException e) {
        System.out.println(""String_Node_Str"");
      }
    }
  }
}"
72341,"/** 
 * Write a report containing(in a .csv file   {@link #_csvFile}), among other informations, the number of ticks, the delay between a NER or a TAR and its respective TAG, the number of UAVs and RAVs.
 */
public void writeDelays(){
  String fullName=federateName.toString();
  String nameOfTheFile=fullName.substring(fullName.indexOf('{') + 1,fullName.lastIndexOf('.'));
  nameOfTheFile=nameOfTheFile.substring(1,nameOfTheFile.lastIndexOf('.')) + ""String_Node_Str"";
  String nameOfTheFederate=fullName.substring(fullName.indexOf('""'));
  String info=""String_Node_Str"" + nameOfTheFederate + ""String_Node_Str""+ nameOfTheFile+ ""String_Node_Str""+ _hlaTimeUnitValue+ ""String_Node_Str""+ _hlaLookAHead+ ""String_Node_Str""+ _runtime+ ""String_Node_Str"";
  if (_timeStepped) {
    info=info + ""String_Node_Str"" + _hlaTimeStep+ ""String_Node_Str""+ _numberOfTARs+ ""String_Node_Str"";
  }
 else   if (_eventBased) {
    info=info + ""String_Node_Str"" + _numberOfNERs+ ""String_Node_Str"";
  }
  info=info + ""String_Node_Str"" + _numberOfUAVs+ ""String_Node_Str""+ _numberOfRAVs+ ""String_Node_Str""+ _numberOfTAGs;
  String numberOfTicks=""String_Node_Str"";
  String delay=""String_Node_Str"";
  double averageNumberOfTicks=0;
  double averageDelay=0;
  StringBuffer header=new StringBuffer(""String_Node_Str"");
  String delayPerTick=""String_Node_Str"";
  for (int i=0; i < _numberOfTAGs; i++) {
    if (i < 10) {
      header.append((i + 1) + ""String_Node_Str"");
      numberOfTicks=numberOfTicks + _numberOfTicks.get(i) + ""String_Node_Str"";
      delay=delay + _TAGDelay.get(i) + ""String_Node_Str"";
      if (_numberOfTicks.get(i) > 0) {
        delayPerTick=delayPerTick + (_TAGDelay.get(i) / _numberOfTicks.get(i)) + ""String_Node_Str"";
      }
 else {
        delayPerTick=delayPerTick + ""String_Node_Str"";
      }
    }
    averageNumberOfTicks=averageNumberOfTicks + _numberOfTicks.get(i);
    averageDelay=averageDelay + _TAGDelay.get(i);
  }
  header.append(""String_Node_Str"");
  int totalNumberOfHLACalls=_numberOfOtherTicks + (int)averageNumberOfTicks + _numberOfTARs+ _numberOfNERs+ _numberOfRAVs+ _numberOfUAVs+ _numberOfTAGs;
  numberOfTicks=numberOfTicks + averageNumberOfTicks + ""String_Node_Str"";
  delay=delay + averageDelay + ""String_Node_Str"";
  delayPerTick=delayPerTick + ""String_Node_Str"";
  header.append(""String_Node_Str"");
  if (_timeStepped) {
    _reportFile=_createTextFile(nameOfTheFederate.substring(1,nameOfTheFederate.length() - 1) + ""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"");
    writeInTextFile(_reportFile,_date + ""String_Node_Str"" + _hlaTimeStep+ ""String_Node_Str""+ _hlaLookAHead+ ""String_Node_Str""+ _runtime+ ""String_Node_Str""+ totalNumberOfHLACalls+ ""String_Node_Str""+ _numberOfTARs+ ""String_Node_Str""+ _numberOfTAGs+ ""String_Node_Str""+ _numberOfRAVs+ ""String_Node_Str""+ _numberOfUAVs+ ""String_Node_Str""+ _numberOfTicks2+ ""String_Node_Str""+ averageDelay);
  }
 else {
    _reportFile=_createTextFile(nameOfTheFederate.substring(1,nameOfTheFederate.length() - 1) + ""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"");
    writeInTextFile(_reportFile,_date + ""String_Node_Str"" + _hlaLookAHead+ ""String_Node_Str""+ _runtime+ ""String_Node_Str""+ totalNumberOfHLACalls+ ""String_Node_Str""+ _numberOfNERs+ ""String_Node_Str""+ _numberOfTAGs+ ""String_Node_Str""+ _numberOfRAVs+ ""String_Node_Str""+ _numberOfUAVs+ ""String_Node_Str""+ _numberOfTicks2+ ""String_Node_Str""+ averageDelay);
  }
  averageNumberOfTicks=averageNumberOfTicks / _numberOfTAGs;
  averageDelay=averageDelay / _numberOfTAGs;
  delayPerTick=delayPerTick + (averageDelay / averageNumberOfTicks) + ""String_Node_Str"";
  numberOfTicks=numberOfTicks + averageNumberOfTicks + ""String_Node_Str"";
  delay=delay + averageDelay + ""String_Node_Str"";
  writeInTextFile(_csvFile,info + header + delay+ numberOfTicks+ delayPerTick+ ""String_Node_Str""+ _numberOfOtherTicks+ ""String_Node_Str""+ totalNumberOfHLACalls);
}","/** 
 * Write a report containing(in a .csv file   {@link #_csvFile}), among other informations, the number of ticks, the delay between a NER or a TAR and its respective TAG, the number of UAVs and RAVs.
 */
public void writeDelays(){
  String fullName=federateName.toString();
  String nameOfTheFile=fullName.substring(fullName.indexOf('{') + 1,fullName.lastIndexOf('.'));
  nameOfTheFile=nameOfTheFile.substring(1,nameOfTheFile.lastIndexOf('.')) + ""String_Node_Str"";
  String nameOfTheFederate=fullName.substring(fullName.indexOf('""'));
  String info=""String_Node_Str"" + nameOfTheFederate + ""String_Node_Str""+ nameOfTheFile+ ""String_Node_Str""+ _hlaTimeUnitValue+ ""String_Node_Str""+ _hlaLookAHead+ ""String_Node_Str""+ _runtime+ ""String_Node_Str"";
  if (_timeStepped) {
    info=info + ""String_Node_Str"" + _hlaTimeStep+ ""String_Node_Str""+ _numberOfTARs+ ""String_Node_Str"";
  }
 else   if (_eventBased) {
    info=info + ""String_Node_Str"" + _numberOfNERs+ ""String_Node_Str"";
  }
  info=info + ""String_Node_Str"" + _numberOfUAVs+ ""String_Node_Str""+ _numberOfRAVs+ ""String_Node_Str""+ _numberOfTAGs;
  String numberOfTicks=""String_Node_Str"";
  String delay=""String_Node_Str"";
  double averageNumberOfTicks=0;
  double averageDelay=0;
  StringBuffer header=new StringBuffer(""String_Node_Str"");
  StringBuffer bufferDelayPerTick=new StringBuffer();
  bufferDelayPerTick.append(""String_Node_Str"");
  for (int i=0; i < _numberOfTAGs; i++) {
    if (i < 10) {
      header.append((i + 1) + ""String_Node_Str"");
      numberOfTicks=numberOfTicks + _numberOfTicks.get(i) + ""String_Node_Str"";
      delay=delay + _TAGDelay.get(i) + ""String_Node_Str"";
      if (_numberOfTicks.get(i) > 0) {
        bufferDelayPerTick.append((_TAGDelay.get(i) / _numberOfTicks.get(i)) + ""String_Node_Str"");
      }
 else {
        bufferDelayPerTick.append(""String_Node_Str"");
      }
    }
    averageNumberOfTicks=averageNumberOfTicks + _numberOfTicks.get(i);
    averageDelay=averageDelay + _TAGDelay.get(i);
  }
  header.append(""String_Node_Str"");
  int totalNumberOfHLACalls=_numberOfOtherTicks + (int)averageNumberOfTicks + _numberOfTARs+ _numberOfNERs+ _numberOfRAVs+ _numberOfUAVs+ _numberOfTAGs;
  numberOfTicks=numberOfTicks + averageNumberOfTicks + ""String_Node_Str"";
  delay=delay + averageDelay + ""String_Node_Str"";
  bufferDelayPerTick.append(""String_Node_Str"");
  header.append(""String_Node_Str"");
  if (_timeStepped) {
    _reportFile=_createTextFile(nameOfTheFederate.substring(1,nameOfTheFederate.length() - 1) + ""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"");
    writeInTextFile(_reportFile,_date + ""String_Node_Str"" + _hlaTimeStep+ ""String_Node_Str""+ _hlaLookAHead+ ""String_Node_Str""+ _runtime+ ""String_Node_Str""+ totalNumberOfHLACalls+ ""String_Node_Str""+ _numberOfTARs+ ""String_Node_Str""+ _numberOfTAGs+ ""String_Node_Str""+ _numberOfRAVs+ ""String_Node_Str""+ _numberOfUAVs+ ""String_Node_Str""+ _numberOfTicks2+ ""String_Node_Str""+ averageDelay);
  }
 else {
    _reportFile=_createTextFile(nameOfTheFederate.substring(1,nameOfTheFederate.length() - 1) + ""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"");
    writeInTextFile(_reportFile,_date + ""String_Node_Str"" + _hlaLookAHead+ ""String_Node_Str""+ _runtime+ ""String_Node_Str""+ totalNumberOfHLACalls+ ""String_Node_Str""+ _numberOfNERs+ ""String_Node_Str""+ _numberOfTAGs+ ""String_Node_Str""+ _numberOfRAVs+ ""String_Node_Str""+ _numberOfUAVs+ ""String_Node_Str""+ _numberOfTicks2+ ""String_Node_Str""+ averageDelay);
  }
  averageNumberOfTicks=averageNumberOfTicks / _numberOfTAGs;
  averageDelay=averageDelay / _numberOfTAGs;
  bufferDelayPerTick.append((averageDelay / averageNumberOfTicks) + ""String_Node_Str"");
  String delayPerTick=bufferDelayPerTick.toString();
  numberOfTicks=numberOfTicks + averageNumberOfTicks + ""String_Node_Str"";
  delay=delay + averageDelay + ""String_Node_Str"";
  writeInTextFile(_csvFile,info + header + delay+ numberOfTicks+ delayPerTick+ ""String_Node_Str""+ _numberOfOtherTicks+ ""String_Node_Str""+ totalNumberOfHLACalls);
}"
72342,"/** 
 * Write information in a txt file.
 * @param data The information you want to write.
 * @param file The file in which you want to write.
 * @return Return true if the information was successfully written in the file.
 */
public boolean writeInTextFile(File file,String data){
  boolean noExceptionOccured=true;
  BufferedWriter writer=null;
  try {
    writer=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file),""String_Node_Str""));
    writer.write(data);
    writer.newLine();
    writer.flush();
  }
 catch (  IOException e) {
    noExceptionOccured=false;
  }
 finally {
    if (writer != null) {
      try {
        writer.close();
      }
 catch (      IOException e) {
        System.out.println(""String_Node_Str"");
      }
    }
  }
  return noExceptionOccured;
}","/** 
 * Write information in a txt file.
 * @param data The information you want to write.
 * @param file The file in which you want to write.
 * @return Return true if the information was successfully written in the file.
 */
public boolean writeInTextFile(File file,String data){
  boolean noExceptionOccured=true;
  BufferedWriter writer=null;
  try {
    writer=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file,true),""String_Node_Str""));
    writer.write(data);
    writer.newLine();
    writer.flush();
  }
 catch (  IOException e) {
    noExceptionOccured=false;
  }
 finally {
    if (writer != null) {
      try {
        writer.close();
      }
 catch (      IOException e) {
        System.out.println(""String_Node_Str"");
      }
    }
  }
  return noExceptionOccured;
}"
72343,"/** 
 * Create a camera with the specified name. The name is required to be one of those returned by   {@link #cameras()}, or else a exception will be thrown.  If   {@link #cameras()}returns no cameras, then the dummy camera is used.
 * @param name The name of the camera.
 * @param actor The actor associated with this camera.
 * @param currentObj The JavaScript object that this is helping.
 * @exception IOException If the camera does not exist.
 */
public CameraHelper(Object actor,ScriptObjectMirror currentObj,String name) throws IOException {
  super(actor,currentObj);
  if (name == null || name.trim().equals(""String_Node_Str"")) {
    _webcam=Webcam.getDefault();
  }
 else {
    if (_webcams == null) {
      cameras();
    }
    if (_webcams != null) {
      _webcam=_webcams.get(name);
    }
  }
  if (_webcam == null) {
    System.out.println(""String_Node_Str"");
    Webcam.setDriver(new WebcamDummyDriver(1));
    _webcam=Webcam.getDefault();
  }
  if (_webcam == null) {
    throw new IOException(""String_Node_Str"" + name + ""String_Node_Str"");
  }
  _webcam.addWebcamListener(this);
}","/** 
 * Create a camera with the specified name. The name is required to be one of those returned by   {@link #cameras()}, or else a exception will be thrown.  If   {@link #cameras()}returns no cameras, then the dummy camera is used.
 * @param name The name of the camera.
 * @param actor The actor associated with this camera.
 * @param currentObj The JavaScript object that this is helping.
 * @exception IOException If the camera does not exist.
 */
public CameraHelper(Object actor,ScriptObjectMirror currentObj,String name) throws IOException {
  super(actor,currentObj);
  if (name == null || name.trim().equals(""String_Node_Str"")) {
    _webcam=Webcam.getDefault();
  }
 else {
    if (_webcams == null) {
      cameras();
    }
    if (_webcams != null) {
      _webcam=_webcams.get(name);
      if (_webcam == null) {
        System.out.println(""String_Node_Str"" + name);
        System.out.println(""String_Node_Str"");
        _webcam=Webcam.getDefault();
      }
    }
  }
  if (_webcam == null) {
    System.out.println(""String_Node_Str"");
    Webcam.setDriver(new WebcamDummyDriver(1));
    _webcam=Webcam.getDefault();
  }
  if (_webcam == null) {
    throw new IOException(""String_Node_Str"" + name + ""String_Node_Str"");
  }
  _webcam.addWebcamListener(this);
}"
72344,"@Override public boolean equals(Object originatedEvent){
  if (!super.equals(originatedEvent)) {
    return false;
  }
 else {
    OriginatedEvent event=(OriginatedEvent)originatedEvent;
    if (objectID == event.objectID) {
      return true;
    }
 else {
      return false;
    }
  }
}","@Override public boolean equals(Object obj){
  if (this == obj)   return true;
  if (!super.equals(obj))   return false;
  if (getClass() != obj.getClass())   return false;
  OriginatedEvent other=(OriginatedEvent)obj;
  if (objectID != other.objectID)   return false;
  return true;
}"
72345,"/** 
 * Manage the correct termination of the   {@link HlaManager}. Call the HLA services to: unsubscribe to HLA attributes, unpublish HLA attributes, resign a Federation and destroy a Federation if the current Federate is the last participant.
 * @exception IllegalActionException If the parent class throws itof if a CERTI exception is raised then displayed it to the user.
 */
@Override public void wrapup() throws IllegalActionException {
  super.wrapup();
  if (_debugListeners != null && _debugListeners.size() > 0) {
    for (    Object listener : _debugListeners) {
      _certiRtig.removeDebugListener((DebugListener)listener);
    }
  }
  _strucuralInformation.clear();
  _registeredObject.clear();
  _debug(""String_Node_Str"" + ""String_Node_Str"" + _numberOfTARs + ""String_Node_Str""+ _numberOfNERs+ ""String_Node_Str""+ _numberOfTAGs);
  calculateRuntime();
  writeNumberOfHLACalls();
  writeDelays();
  writeUAVsInformations();
  writeRAVsInformations();
  writeTimes();
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  for (  Object[] obj : _hlaAttributesSubscribedTo.values()) {
    try {
      _rtia.unsubscribeObjectClass(_getClassHandleFromTab(obj));
    }
 catch (    RTIexception e) {
      throw new IllegalActionException(this,e,e.getMessage());
    }
catch (    ArrayIndexOutOfBoundsException e2) {
      throw new IllegalActionException(this,e2,""String_Node_Str"" + ""String_Node_Str"" + obj + ""String_Node_Str""+ obj.length+ ""String_Node_Str"");
    }
    if (_debugging) {
      _debug(""String_Node_Str"" + _getPortFromTab(obj).getContainer().getName() + ""String_Node_Str""+ _getClassHandleFromTab(obj)+ ""String_Node_Str"");
    }
  }
  for (  Object[] obj : _hlaAttributesToPublish.values()) {
    try {
      _rtia.unpublishObjectClass(_getClassHandleFromTab(obj));
    }
 catch (    RTIexception e) {
      throw new IllegalActionException(this,e,e.getMessage());
    }
catch (    ArrayIndexOutOfBoundsException e2) {
      throw new IllegalActionException(this,e2,""String_Node_Str"" + ""String_Node_Str"" + obj + ""String_Node_Str""+ obj.length+ ""String_Node_Str"");
    }
    if (_debugging) {
      _debug(""String_Node_Str"" + _getPortFromTab(obj).getContainer().getName() + ""String_Node_Str""+ _getClassHandleFromTab(obj)+ ""String_Node_Str"");
    }
  }
  try {
    _rtia.resignFederationExecution(ResignAction.DELETE_OBJECTS_AND_RELEASE_ATTRIBUTES);
  }
 catch (  RTIexception e) {
    throw new IllegalActionException(this,e,e.getMessage());
  }
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  boolean canDestroyRtig=false;
  while (!canDestroyRtig) {
    try {
      _rtia.destroyFederationExecution(_federationName);
    }
 catch (    FederatesCurrentlyJoined e) {
      if (_debugging) {
        _debug(""String_Node_Str"");
      }
    }
catch (    FederationExecutionDoesNotExist e) {
      if (_debugging) {
        _debug(""String_Node_Str"");
      }
      canDestroyRtig=true;
    }
catch (    RTIinternalError e) {
      throw new IllegalActionException(this,e,""String_Node_Str"");
    }
catch (    ConcurrentAccessAttempted e) {
      throw new IllegalActionException(this,e,""String_Node_Str"");
    }
    if (_debugging) {
      _debug(""String_Node_Str"" + ""String_Node_Str"");
    }
    canDestroyRtig=true;
  }
  if (_certiRtig != null) {
    _certiRtig.terminateProcess();
    if (_debugging) {
      _debug(""String_Node_Str"" + ""String_Node_Str"");
    }
  }
  _hlaAttributesToPublish.clear();
  _hlaAttributesSubscribedTo.clear();
  _fromFederationEvents.clear();
  _objectIdToClassHandle.clear();
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
}","/** 
 * Manage the correct termination of the   {@link HlaManager}. Call the HLA services to: unsubscribe to HLA attributes, unpublish HLA attributes, resign a Federation and destroy a Federation if the current Federate is the last participant.
 * @exception IllegalActionException If the parent class throws itof if a CERTI exception is raised then displayed it to the user.
 */
@Override public void wrapup() throws IllegalActionException {
  super.wrapup();
  if (_debugListeners != null && _debugListeners.size() > 0) {
    for (    Object listener : _debugListeners) {
      _certiRtig.removeDebugListener((DebugListener)listener);
    }
  }
  _strucuralInformation.clear();
  _registeredObject.clear();
  _debug(""String_Node_Str"" + ""String_Node_Str"" + _numberOfTARs + ""String_Node_Str""+ _numberOfNERs+ ""String_Node_Str""+ _numberOfTAGs);
  calculateRuntime();
  writeNumberOfHLACalls();
  writeDelays();
  writeUAVsInformations();
  writeRAVsInformations();
  writeTimes();
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  for (  Object[] obj : _hlaAttributesSubscribedTo.values()) {
    try {
      _rtia.unsubscribeObjectClass(_getClassHandleFromTab(obj));
    }
 catch (    RTIexception e) {
      throw new IllegalActionException(this,e,e.getMessage());
    }
catch (    ArrayIndexOutOfBoundsException e2) {
      throw new IllegalActionException(this,e2,""String_Node_Str"" + ""String_Node_Str"" + Arrays.toString(obj) + ""String_Node_Str""+ obj.length+ ""String_Node_Str"");
    }
    if (_debugging) {
      _debug(""String_Node_Str"" + _getPortFromTab(obj).getContainer().getName() + ""String_Node_Str""+ _getClassHandleFromTab(obj)+ ""String_Node_Str"");
    }
  }
  for (  Object[] obj : _hlaAttributesToPublish.values()) {
    try {
      _rtia.unpublishObjectClass(_getClassHandleFromTab(obj));
    }
 catch (    RTIexception e) {
      throw new IllegalActionException(this,e,e.getMessage());
    }
catch (    ArrayIndexOutOfBoundsException e2) {
      throw new IllegalActionException(this,e2,""String_Node_Str"" + ""String_Node_Str"" + Arrays.toString(obj) + ""String_Node_Str""+ obj.length+ ""String_Node_Str"");
    }
    if (_debugging) {
      _debug(""String_Node_Str"" + _getPortFromTab(obj).getContainer().getName() + ""String_Node_Str""+ _getClassHandleFromTab(obj)+ ""String_Node_Str"");
    }
  }
  try {
    _rtia.resignFederationExecution(ResignAction.DELETE_OBJECTS_AND_RELEASE_ATTRIBUTES);
  }
 catch (  RTIexception e) {
    throw new IllegalActionException(this,e,e.getMessage());
  }
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  boolean canDestroyRtig=false;
  while (!canDestroyRtig) {
    try {
      _rtia.destroyFederationExecution(_federationName);
    }
 catch (    FederatesCurrentlyJoined e) {
      if (_debugging) {
        _debug(""String_Node_Str"");
      }
    }
catch (    FederationExecutionDoesNotExist e) {
      if (_debugging) {
        _debug(""String_Node_Str"");
      }
      canDestroyRtig=true;
    }
catch (    RTIinternalError e) {
      throw new IllegalActionException(this,e,""String_Node_Str"");
    }
catch (    ConcurrentAccessAttempted e) {
      throw new IllegalActionException(this,e,""String_Node_Str"");
    }
    if (_debugging) {
      _debug(""String_Node_Str"" + ""String_Node_Str"");
    }
    canDestroyRtig=true;
  }
  if (_certiRtig != null) {
    _certiRtig.terminateProcess();
    if (_debugging) {
      _debug(""String_Node_Str"" + ""String_Node_Str"");
    }
  }
  _hlaAttributesToPublish.clear();
  _hlaAttributesSubscribedTo.clear();
  _fromFederationEvents.clear();
  _objectIdToClassHandle.clear();
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
}"
72346,"/** 
 * Return the node binary that is in the path or, if node is not found in the path, return the node binary in $PTII/vendors/node.
 * @param binaryName Either ""node"" or ""npm"".
 * @return The node binary
 */
private static String _nodeOrNpmBinary(String binaryName) throws IOException {
  if (!binaryName.equals(""String_Node_Str"") && !binaryName.equals(""String_Node_Str"")) {
    throw new IOException(""String_Node_Str"" + ""String_Node_Str"" + binaryName + ""String_Node_Str"");
  }
  String commandExtension=null;
  String executableExtension=""String_Node_Str"";
  String osName=StringUtilities.getProperty(""String_Node_Str"");
  String osArch=StringUtilities.getProperty(""String_Node_Str"");
  if (osName != null && osName.startsWith(""String_Node_Str"")) {
    commandExtension=""String_Node_Str"";
    executableExtension=""String_Node_Str"";
  }
  if (FileUtilities.inPath(binaryName + executableExtension)) {
    System.out.println(""String_Node_Str"" + binaryName + executableExtension);
    return binaryName + executableExtension;
  }
  if (commandExtension != null) {
    if (FileUtilities.inPath(binaryName + commandExtension)) {
      System.out.println(""String_Node_Str"" + binaryName + commandExtension);
      return binaryName + commandExtension;
    }
  }
  String nodeVersion=""String_Node_Str"";
  String nodeBinary=""String_Node_Str"";
  String npmBinary=""String_Node_Str"";
  if (osName != null) {
    if (osName.startsWith(""String_Node_Str"")) {
      if (osArch.indexOf(32) != -1) {
        nodeBinary=nodeVersion + ""String_Node_Str"";
        npmBinary=nodeVersion + ""String_Node_Str"";
      }
 else {
        nodeBinary=nodeVersion + ""String_Node_Str"";
        npmBinary=nodeVersion + ""String_Node_Str"";
      }
    }
 else     if (osName.startsWith(""String_Node_Str"")) {
      nodeBinary=nodeVersion + ""String_Node_Str"";
      npmBinary=nodeVersion + ""String_Node_Str"";
    }
 else     if (osName.startsWith(""String_Node_Str"")) {
      if (osArch.indexOf(32) != -1) {
        nodeBinary=nodeVersion + ""String_Node_Str"";
        npmBinary=nodeVersion + ""String_Node_Str"";
      }
 else {
        nodeBinary=nodeVersion + ""String_Node_Str"";
        npmBinary=nodeVersion + ""String_Node_Str"";
      }
      nodeBinary=nodeBinary.replace('/',File.separatorChar);
      npmBinary=nodeBinary.replace('/',File.separatorChar);
    }
  }
  String binary=npmBinary;
  if (binaryName.equals(""String_Node_Str"")) {
    binary=nodeBinary;
  }
  File binaryFile=FileUtilities.nameToFile(binary,null);
  if (binaryFile.canExecute()) {
    System.out.println(""String_Node_Str"" + binary);
    return binaryFile.getAbsolutePath();
  }
  return binaryName;
}","/** 
 * Return the node binary that is in the path or, if node is not found in the path, return the node binary in $PTII/vendors/node.
 * @param binaryName Either ""node"" or ""npm"".
 * @return The node binary
 */
private static String _nodeOrNpmBinary(String binaryName) throws IOException {
  if (!binaryName.equals(""String_Node_Str"") && !binaryName.equals(""String_Node_Str"")) {
    throw new IOException(""String_Node_Str"" + ""String_Node_Str"" + binaryName + ""String_Node_Str"");
  }
  String commandExtension=null;
  String executableExtension=""String_Node_Str"";
  String osName=StringUtilities.getProperty(""String_Node_Str"");
  String osArch=StringUtilities.getProperty(""String_Node_Str"");
  if (osName != null && osName.startsWith(""String_Node_Str"")) {
    commandExtension=""String_Node_Str"";
    executableExtension=""String_Node_Str"";
  }
  if (FileUtilities.inPath(binaryName + executableExtension)) {
    System.out.println(""String_Node_Str"" + binaryName + executableExtension);
    return binaryName + executableExtension;
  }
  if (commandExtension != null) {
    if (FileUtilities.inPath(binaryName + commandExtension)) {
      System.out.println(""String_Node_Str"" + binaryName + commandExtension);
      return binaryName + commandExtension;
    }
  }
  String nodeVersion=""String_Node_Str"";
  String nodeBinary=""String_Node_Str"";
  String npmBinary=""String_Node_Str"";
  if (osName != null) {
    if (osName.startsWith(""String_Node_Str"")) {
      if (osArch.indexOf(32) != -1) {
        nodeBinary=nodeVersion + ""String_Node_Str"";
        npmBinary=nodeVersion + ""String_Node_Str"";
      }
 else {
        nodeBinary=nodeVersion + ""String_Node_Str"";
        npmBinary=nodeVersion + ""String_Node_Str"";
      }
    }
 else     if (osName.startsWith(""String_Node_Str"")) {
      nodeBinary=nodeVersion + ""String_Node_Str"";
      npmBinary=nodeVersion + ""String_Node_Str"";
    }
 else     if (osName.startsWith(""String_Node_Str"")) {
      if (osArch.indexOf(32) != -1) {
        nodeBinary=nodeVersion + ""String_Node_Str"";
        npmBinary=nodeVersion + ""String_Node_Str"";
      }
 else {
        nodeBinary=nodeVersion + ""String_Node_Str"";
        npmBinary=nodeVersion + ""String_Node_Str"";
      }
      nodeBinary=nodeBinary.replace('/',File.separatorChar);
      npmBinary=npmBinary.replace('/',File.separatorChar);
    }
  }
  String binary=npmBinary;
  if (binaryName.equals(""String_Node_Str"")) {
    binary=nodeBinary;
  }
  File binaryFile=FileUtilities.nameToFile(binary,null);
  if (binaryFile.canExecute()) {
    System.out.println(""String_Node_Str"" + binary);
    return binaryFile.getAbsolutePath();
  }
  return binaryName;
}"
72347,"/** 
 * Build the ptdoc files.
 * @return 0 if ant and node were found and ant returned 0.   
 */
private static int _ptDoc() throws IOException {
  if (_doNotUpdateOrRunJSDoc()) {
    if (!_printedPtNoNetMessage) {
      _printedPtNoNetMessage=true;
      System.out.println(""String_Node_Str"");
    }
    return 3;
  }
  File accessorsRepoWebDirectory=new File(JSAccessor._accessorDirectory(),""String_Node_Str"");
  if (accessorsRepoWebDirectory.isDirectory()) {
    MessageHandler.status(""String_Node_Str"");
    String antPath=""String_Node_Str"";
    try {
      StringBufferExec antExec=new StringBufferExec(true);
      antExec.setWorkingDirectory(accessorsRepoWebDirectory);
      List execCommands=new LinkedList<String>();
      antPath=StringUtilities.getProperty(""String_Node_Str"");
      String defaultAnt=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"";
      if (antPath.length() == 0) {
        antPath=""String_Node_Str"";
      }
 else {
        File antExecutableFile=new File(antPath);
        if (!antExecutableFile.isFile()) {
          System.out.println(""String_Node_Str"" + antPath + ""String_Node_Str""+ defaultAnt);
          antPath=""String_Node_Str"";
        }
      }
      String osName=StringUtilities.getProperty(""String_Node_Str"");
      String osArch=StringUtilities.getProperty(""String_Node_Str"");
      String commandExtension=""String_Node_Str"";
      String executableExtension=""String_Node_Str"";
      if (osName != null && osName.startsWith(""String_Node_Str"")) {
        commandExtension=""String_Node_Str"";
        executableExtension=""String_Node_Str"";
      }
      if (!FileUtilities.inPath(""String_Node_Str"" + executableExtension)) {
        System.out.println(""String_Node_Str"" + executableExtension + ""String_Node_Str"");
        File ptIIAntFile=null;
        String defaultAntPath=""String_Node_Str"";
        if (osName != null && osName.startsWith(""String_Node_Str"")) {
          defaultAntPath=""String_Node_Str"";
        }
        defaultAnt=""String_Node_Str"" + defaultAntPath + ""String_Node_Str"";
        try {
          ptIIAntFile=FileUtilities.nameToFile(defaultAntPath,null);
          if (ptIIAntFile.exists()) {
            antPath=ptIIAntFile.getCanonicalPath();
          }
 else {
            System.out.println(""String_Node_Str"");
          }
        }
 catch (        IOException ex) {
          defaultAnt+=""String_Node_Str"" + ex;
        }
        if (!ptIIAntFile.exists()) {
          System.out.println(defaultAnt);
          MessageHandler.status(defaultAnt);
          return -1;
        }
 else {
          System.out.println(""String_Node_Str"" + antPath);
        }
      }
 else {
        System.out.println(""String_Node_Str"" + System.getenv(""String_Node_Str""));
      }
      if (!FileUtilities.inPath(""String_Node_Str"" + executableExtension) || !FileUtilities.inPath(""String_Node_Str"" + commandExtension)) {
        String nodeBinary=JSAccessor.nodeBinary();
        File nodeBinaryFile=FileUtilities.nameToFile(nodeBinary,null);
        if (!nodeBinaryFile.canExecute()) {
          System.out.println(""String_Node_Str"" + nodeBinaryFile + ""String_Node_Str"");
          MessageHandler.status(""String_Node_Str"");
          return -2;
        }
        String npmBinary=JSAccessor.npmBinary();
        File npmBinaryFile=FileUtilities.nameToFile(npmBinary,null);
        if (!npmBinaryFile.canExecute()) {
          System.out.println(""String_Node_Str"" + npmBinaryFile + ""String_Node_Str"");
          MessageHandler.status(""String_Node_Str"");
          return -2;
        }
        System.out.println(""String_Node_Str"" + nodeBinaryFile.getParent() + ""String_Node_Str"");
        antExec.appendToPath(nodeBinaryFile.getParent());
      }
      System.out.println(""String_Node_Str"" + antPath + ""String_Node_Str"");
      execCommands.add(antPath + ""String_Node_Str"");
      antExec.setCommands(execCommands);
      antExec.setWaitForLastSubprocess(true);
      antExec.start();
      if (antExec.getLastSubprocessReturnCode() == 0) {
        MessageHandler.status(""String_Node_Str"");
      }
 else {
        MessageHandler.status(""String_Node_Str"");
        System.err.println(""String_Node_Str"" + antPath + ""String_Node_Str""+ accessorsRepoWebDirectory+ ""String_Node_Str""+ ""String_Node_Str""+ antExec.buffer);
      }
      return antExec.getLastSubprocessReturnCode();
    }
 catch (    Throwable throwable) {
      MessageHandler.status(""String_Node_Str"");
      System.err.println(""String_Node_Str"" + antPath + ""String_Node_Str""+ accessorsRepoWebDirectory+ ""String_Node_Str""+ ""String_Node_Str""+ throwable);
      throwable.printStackTrace();
    }
  }
  return -3;
}","/** 
 * Build the ptdoc files.
 * @return 0 if ant and node were found and ant returned 0.   
 */
private static int _ptDoc() throws IOException {
  if (_doNotUpdateOrRunJSDoc()) {
    if (!_printedPtNoNetMessage) {
      _printedPtNoNetMessage=true;
      System.out.println(""String_Node_Str"");
    }
    return 3;
  }
  File accessorsRepoWebDirectory=new File(JSAccessor._accessorDirectory(),""String_Node_Str"");
  if (accessorsRepoWebDirectory.isDirectory()) {
    MessageHandler.status(""String_Node_Str"");
    String antPath=""String_Node_Str"";
    try {
      StringBufferExec antExec=new StringBufferExec(true);
      antExec.setWorkingDirectory(accessorsRepoWebDirectory);
      List execCommands=new LinkedList<String>();
      antPath=StringUtilities.getProperty(""String_Node_Str"");
      String defaultAnt=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"";
      if (antPath.length() == 0) {
        antPath=""String_Node_Str"";
      }
 else {
        File antExecutableFile=new File(antPath);
        if (!antExecutableFile.isFile()) {
          System.out.println(""String_Node_Str"" + antPath + ""String_Node_Str""+ defaultAnt);
          antPath=""String_Node_Str"";
        }
      }
      String osName=StringUtilities.getProperty(""String_Node_Str"");
      String commandExtension=""String_Node_Str"";
      String executableExtension=""String_Node_Str"";
      if (osName != null && osName.startsWith(""String_Node_Str"")) {
        commandExtension=""String_Node_Str"";
        executableExtension=""String_Node_Str"";
      }
      if (!FileUtilities.inPath(""String_Node_Str"" + executableExtension)) {
        System.out.println(""String_Node_Str"" + executableExtension + ""String_Node_Str"");
        File ptIIAntFile=null;
        String defaultAntPath=""String_Node_Str"";
        if (osName != null && osName.startsWith(""String_Node_Str"")) {
          defaultAntPath=""String_Node_Str"";
        }
        defaultAnt=""String_Node_Str"" + defaultAntPath + ""String_Node_Str"";
        try {
          ptIIAntFile=FileUtilities.nameToFile(defaultAntPath,null);
          if (ptIIAntFile.exists()) {
            antPath=ptIIAntFile.getCanonicalPath();
          }
 else {
            System.out.println(""String_Node_Str"");
          }
        }
 catch (        IOException ex) {
          defaultAnt+=""String_Node_Str"" + ex;
        }
        if (!ptIIAntFile.exists()) {
          System.out.println(defaultAnt);
          MessageHandler.status(defaultAnt);
          return -1;
        }
 else {
          System.out.println(""String_Node_Str"" + antPath);
        }
      }
 else {
        System.out.println(""String_Node_Str"" + System.getenv(""String_Node_Str""));
      }
      if (!FileUtilities.inPath(""String_Node_Str"" + executableExtension) || !FileUtilities.inPath(""String_Node_Str"" + commandExtension)) {
        String nodeBinary=JSAccessor.nodeBinary();
        File nodeBinaryFile=FileUtilities.nameToFile(nodeBinary,null);
        if (!nodeBinaryFile.canExecute()) {
          System.out.println(""String_Node_Str"" + nodeBinaryFile + ""String_Node_Str"");
          MessageHandler.status(""String_Node_Str"");
          return -2;
        }
        String npmBinary=JSAccessor.npmBinary();
        File npmBinaryFile=FileUtilities.nameToFile(npmBinary,null);
        if (!npmBinaryFile.canExecute()) {
          System.out.println(""String_Node_Str"" + npmBinaryFile + ""String_Node_Str"");
          MessageHandler.status(""String_Node_Str"");
          return -2;
        }
        System.out.println(""String_Node_Str"" + nodeBinaryFile.getParent() + ""String_Node_Str"");
        antExec.appendToPath(nodeBinaryFile.getParent());
      }
      System.out.println(""String_Node_Str"" + antPath + ""String_Node_Str"");
      execCommands.add(antPath + ""String_Node_Str"");
      antExec.setCommands(execCommands);
      antExec.setWaitForLastSubprocess(true);
      antExec.start();
      if (antExec.getLastSubprocessReturnCode() == 0) {
        MessageHandler.status(""String_Node_Str"");
      }
 else {
        MessageHandler.status(""String_Node_Str"");
        System.err.println(""String_Node_Str"" + antPath + ""String_Node_Str""+ accessorsRepoWebDirectory+ ""String_Node_Str""+ ""String_Node_Str""+ antExec.buffer);
      }
      return antExec.getLastSubprocessReturnCode();
    }
 catch (    Throwable throwable) {
      MessageHandler.status(""String_Node_Str"");
      System.err.println(""String_Node_Str"" + antPath + ""String_Node_Str""+ accessorsRepoWebDirectory+ ""String_Node_Str""+ ""String_Node_Str""+ throwable);
      throwable.printStackTrace();
    }
  }
  return -3;
}"
72348,"/** 
 * If an input is available and either it equals zero or it has crossed zero from the most recently seen input, then output 0.0; otherwise, if an input available and that input is a   {@link SmoothToken} with non-zeroderivatives, then predict the time at which a zero crossing will occur and request a refiring at that time; Otherwise, if no input is available and current time matches the time of a previous refiring request, then produce the output 0.0.
 * @exception IllegalActionException If sending an output fails.
 */
@Override public void fire() throws IllegalActionException {
  super.fire();
  Time currentTime=getDirector().getModelTime();
  if (_debugging) {
    _debug(""String_Node_Str"" + currentTime);
  }
  DoubleToken inputToken=null;
  if (input.hasNewToken(0)) {
    inputToken=(DoubleToken)input.get(0);
    if (_debugging) {
      _debug(""String_Node_Str"" + inputToken);
    }
  }
  if (inputToken == null && currentTime.equals(_lastFireAtTime)) {
    if (_previousInput != null) {
      SmoothToken projectedToNow=((SmoothToken)_previousInput).extrapolate(currentTime);
      inputToken=new SmoothToken(0.0,currentTime,projectedToNow.derivativeValues());
      if (_debugging) {
        _debug(""String_Node_Str"" + inputToken);
      }
    }
  }
  if (inputToken instanceof SmoothToken) {
    double inputValue=inputToken.doubleValue();
    if (_previousInput != null) {
      double previousValue=_previousInput.doubleValue();
      boolean inputIsRising=inputValue >= 0.0 && previousValue < 0.0;
      boolean inputIsFalling=inputValue <= 0.0 && previousValue > 0.0;
      if (_detectFallingCrossing && inputIsFalling || _detectRisingCrossing && inputIsRising) {
        output.send(0,value.getToken());
        if (_debugging) {
          _debug(""String_Node_Str"");
        }
      }
    }
    Time future=null;
    double[] derivatives=((SmoothToken)inputToken).derivativeValues();
    if (derivatives != null) {
      if (derivatives.length == 1 || (derivatives.length == 2 && derivatives[1] == 0.0) || (derivatives.length > 2 && derivatives[1] == 0.0 && derivatives[2] == 0.0)) {
        if (_detectRisingCrossing && inputValue < 0.0 && derivatives[0] > 0.0 || _detectFallingCrossing && inputValue > 0.0 && derivatives[0] < 0.0) {
          future=currentTime.add(-inputValue / derivatives[0]);
        }
      }
 else       if (derivatives.length == 2 || (derivatives.length > 2 && derivatives[2] == 0.0)) {
        double delta=PolynomialRoot.findMinimumPositiveRoot2(derivatives[1] / 2.0,derivatives[0],inputValue);
        if (delta >= _errorTolerance && delta != Double.POSITIVE_INFINITY) {
          future=currentTime.add(delta);
        }
      }
 else       if (derivatives.length >= 3) {
        double delta=PolynomialRoot.findMinimumPositiveRoot3(derivatives[2] / 6.0,derivatives[1] / 2.0,derivatives[0],inputValue,_errorTolerance,0.0);
        if (delta >= _errorTolerance && delta != Double.POSITIVE_INFINITY) {
          future=currentTime.add(delta);
        }
      }
    }
    if (future != null) {
      if (_lastFireAtTime == null || Math.abs(future.subtractToDouble(_lastFireAtTime)) >= _errorTolerance) {
        if (_lastFireAtTime != null) {
          if (_debugging) {
            _debug(""String_Node_Str"" + _lastFireAtTime);
          }
          ((DEDirector)getDirector()).cancelFireAt(this,_lastFireAtTime);
        }
        getDirector().fireAt(this,future);
        _lastFireAtTime=future;
      }
    }
 else {
      if (_lastFireAtTime != null) {
        if (_debugging) {
          _debug(""String_Node_Str"" + _lastFireAtTime);
        }
        ((DEDirector)getDirector()).cancelFireAt(this,_lastFireAtTime);
        _lastFireAtTime=null;
      }
    }
  }
 else {
    if (_lastFireAtTime != null) {
      if (_debugging) {
        _debug(""String_Node_Str"" + _lastFireAtTime);
      }
      ((DEDirector)getDirector()).cancelFireAt(this,_lastFireAtTime);
    }
    _lastFireAtTime=null;
  }
  _previousInput=(SmoothToken)inputToken;
}","/** 
 * If an input is available and either it equals zero or it has crossed zero from the most recently seen input, then output 0.0; otherwise, if an input available and that input is a   {@link SmoothToken} with non-zeroderivatives, then predict the time at which a zero crossing will occur and request a refiring at that time; Otherwise, if no input is available and current time matches the time of a previous refiring request, then produce the output 0.0.
 * @exception IllegalActionException If sending an output fails.
 */
@Override public void fire() throws IllegalActionException {
  super.fire();
  Time currentTime=getDirector().getModelTime();
  if (_debugging) {
    _debug(""String_Node_Str"" + currentTime);
  }
  DoubleToken inputToken=null;
  if (input.hasNewToken(0)) {
    inputToken=(DoubleToken)input.get(0);
    if (_debugging) {
      _debug(""String_Node_Str"" + inputToken);
    }
  }
  if (inputToken == null && currentTime.equals(_lastFireAtTime)) {
    if (_previousInput != null) {
      SmoothToken projectedToNow=((SmoothToken)_previousInput).extrapolate(currentTime);
      inputToken=new SmoothToken(0.0,currentTime,projectedToNow.derivativeValues());
      if (_debugging) {
        _debug(""String_Node_Str"" + inputToken);
      }
    }
  }
  if (inputToken instanceof SmoothToken) {
    final double targetValue=_level;
    final double inputValue=inputToken.doubleValue();
    if (_previousInput != null) {
      double previousValue=_previousInput.doubleValue();
      boolean inputIsRising=inputValue >= targetValue && previousValue < targetValue;
      boolean inputIsFalling=inputValue <= targetValue && previousValue > targetValue;
      if (_detectFallingCrossing && inputIsFalling || _detectRisingCrossing && inputIsRising) {
        output.send(0,value.getToken());
        if (_debugging) {
          _debug(""String_Node_Str"");
        }
      }
    }
    Time future=null;
    double[] derivatives=((SmoothToken)inputToken).derivativeValues();
    if (derivatives != null) {
      if (derivatives.length == 1 || (derivatives.length == 2 && derivatives[1] == 0.0) || (derivatives.length > 2 && derivatives[1] == 0.0 && derivatives[2] == 0.0)) {
        if (_detectRisingCrossing && inputValue < targetValue && derivatives[0] > 0.0 || _detectFallingCrossing && inputValue > targetValue && derivatives[0] < 0.0) {
          future=currentTime.add((targetValue - inputValue) / derivatives[0]);
        }
      }
 else       if (derivatives.length == 2 || (derivatives.length > 2 && derivatives[2] == 0.0)) {
        double delta=PolynomialRoot.findMinimumPositiveRoot2(derivatives[1] / 2.0,derivatives[0],inputValue - targetValue);
        if (delta >= _errorTolerance && delta != Double.POSITIVE_INFINITY) {
          future=currentTime.add(delta);
        }
      }
 else       if (derivatives.length >= 3) {
        double delta=PolynomialRoot.findMinimumPositiveRoot3(derivatives[2] / 6.0,derivatives[1] / 2.0,derivatives[0],inputValue - targetValue,_errorTolerance,0.0);
        if (delta >= _errorTolerance && delta != Double.POSITIVE_INFINITY) {
          future=currentTime.add(delta);
        }
      }
    }
    if (future != null) {
      if (_lastFireAtTime == null || Math.abs(future.subtractToDouble(_lastFireAtTime)) >= _errorTolerance) {
        if (_lastFireAtTime != null) {
          if (_debugging) {
            _debug(""String_Node_Str"" + _lastFireAtTime);
          }
          ((DEDirector)getDirector()).cancelFireAt(this,_lastFireAtTime);
        }
        getDirector().fireAt(this,future);
        _lastFireAtTime=future;
      }
    }
 else {
      if (_lastFireAtTime != null) {
        if (_debugging) {
          _debug(""String_Node_Str"" + _lastFireAtTime);
        }
        ((DEDirector)getDirector()).cancelFireAt(this,_lastFireAtTime);
        _lastFireAtTime=null;
      }
    }
  }
 else {
    if (_lastFireAtTime != null) {
      if (_debugging) {
        _debug(""String_Node_Str"" + _lastFireAtTime);
      }
      ((DEDirector)getDirector()).cancelFireAt(this,_lastFireAtTime);
    }
    _lastFireAtTime=null;
  }
  _previousInput=(SmoothToken)inputToken;
}"
72349,"/** 
 * Return the difference between two strings.
 * @param aString The first string to be compared.
 * @param bString The secondString to be compared
 * @return A string describing the difference between the twostrings in a format similar to the Unix diff command.
 */
public static String diff(String aString,String bString){
  String systemEol=System.getProperty(""String_Node_Str"");
  String eol=""String_Node_Str"";
  String[] aStringSplit=aString.split(eol);
  String[] bStringSplit=bString.split(eol);
  int aNumberOfLines=aStringSplit.length;
  int bNumberOfLines=bStringSplit.length;
  int[][] lcs=new int[aNumberOfLines][bNumberOfLines];
  for (int aIndex=1; aIndex < aNumberOfLines; aIndex++) {
    for (int bIndex=1; bIndex < bNumberOfLines; bIndex++) {
      if (aStringSplit[aIndex].equals(bStringSplit[bIndex])) {
        lcs[aIndex][bIndex]=lcs[aIndex - 1][bIndex - 1] + 1;
      }
 else {
        lcs[aIndex][bIndex]=Math.max(lcs[aIndex][bIndex - 1],lcs[aIndex - 1][bIndex]);
      }
    }
  }
  StringBuffer result=new StringBuffer();
  int aIndex=0;
  int bIndex=0;
  while (aIndex < aNumberOfLines && bIndex < bNumberOfLines) {
    if (aStringSplit[aIndex].equals(bStringSplit[bIndex])) {
      aIndex++;
      bIndex++;
    }
 else     if (lcs[aIndex + 1][bIndex] < lcs[aIndex][bIndex + 1]) {
      result.append(""String_Node_Str"" + bStringSplit[bIndex++] + systemEol);
    }
 else {
      result.append(""String_Node_Str"" + aStringSplit[aIndex++] + systemEol);
    }
  }
  while (aIndex < aNumberOfLines || bIndex < bNumberOfLines) {
    if (aIndex == aNumberOfLines) {
      result.append(""String_Node_Str"" + bStringSplit[bIndex++] + systemEol);
    }
 else     if (bIndex == bNumberOfLines) {
      result.append(""String_Node_Str"" + aStringSplit[aIndex++] + systemEol);
    }
  }
  return result.toString();
}","/** 
 * Return the difference between two strings.
 * @param aString The first string to be compared.
 * @param bString The secondString to be compared
 * @return A string describing the difference between the twostrings in a format similar to the Unix diff command.
 */
public static String diff(String aString,String bString){
  String systemEol=System.getProperty(""String_Node_Str"");
  String eol=""String_Node_Str"";
  String[] aStringSplit=aString.split(eol);
  String[] bStringSplit=bString.split(eol);
  int aNumberOfLines=aStringSplit.length;
  int bNumberOfLines=bStringSplit.length;
  int[][] lcs=new int[aNumberOfLines + 1][bNumberOfLines + 1];
  for (int aIndex=1; aIndex < aNumberOfLines; aIndex++) {
    for (int bIndex=1; bIndex < bNumberOfLines; bIndex++) {
      if (aStringSplit[aIndex].equals(bStringSplit[bIndex])) {
        lcs[aIndex][bIndex]=lcs[aIndex - 1][bIndex - 1] + 1;
      }
 else {
        lcs[aIndex][bIndex]=Math.max(lcs[aIndex][bIndex - 1],lcs[aIndex - 1][bIndex]);
      }
    }
  }
  StringBuffer result=new StringBuffer();
  int aIndex=0;
  int bIndex=0;
  while (aIndex < aNumberOfLines && bIndex < bNumberOfLines) {
    if (aStringSplit[aIndex].equals(bStringSplit[bIndex])) {
      aIndex++;
      bIndex++;
    }
 else     if (lcs[aIndex + 1][bIndex] < lcs[aIndex][bIndex + 1]) {
      result.append(""String_Node_Str"" + bStringSplit[bIndex++] + systemEol);
    }
 else {
      result.append(""String_Node_Str"" + aStringSplit[aIndex++] + systemEol);
    }
  }
  while (aIndex < aNumberOfLines || bIndex < bNumberOfLines) {
    if (aIndex == aNumberOfLines) {
      result.append(""String_Node_Str"" + bStringSplit[bIndex++] + systemEol);
    }
 else     if (bIndex == bNumberOfLines) {
      result.append(""String_Node_Str"" + aStringSplit[aIndex++] + systemEol);
    }
  }
  return result.toString();
}"
72350,"/** 
 * Return the difference between two strings.
 * @param aString The first string to be compared.
 * @param bString The secondString to be compared
 * @return A string describing the difference between the twostrings in a format similar to the Unix diff command.
 */
public static String diff(String aString,String bString){
  String systemEol=System.getProperty(""String_Node_Str"");
  String eol=""String_Node_Str"";
  String[] aStringSplit=aString.split(eol);
  String[] bStringSplit=bString.split(eol);
  int aNumberOfLines=aStringSplit.length;
  int bNumberOfLines=bStringSplit.length;
  int[][] lcs=new int[aNumberOfLines + 1][bNumberOfLines + 1];
  for (int i=aNumberOfLines - 1; i >= 0; i--) {
    for (int j=bNumberOfLines - 1; j >= 0; j--) {
      if (aStringSplit[i].equals(bStringSplit[j])) {
        lcs[i][j]=lcs[i + 1][j + 1] + 1;
      }
 else {
        lcs[i][j]=Math.max(lcs[i + 1][j],lcs[i][j + 1]);
      }
    }
  }
  StringBuffer result=new StringBuffer();
  int i=0, j=0;
  while (i < aNumberOfLines && j < bNumberOfLines) {
    if (aStringSplit[i].equals(bStringSplit[j])) {
      i++;
      j++;
    }
 else     if (lcs[i + 1][j] >= lcs[i][j + 1]) {
      result.append(""String_Node_Str"" + aStringSplit[i++] + systemEol);
    }
 else {
      result.append(""String_Node_Str"" + bStringSplit[j++] + systemEol);
    }
  }
  while (i < aNumberOfLines || j < bNumberOfLines) {
    if (i == aNumberOfLines) {
      result.append(""String_Node_Str"" + aStringSplit[j++] + systemEol);
    }
 else     if (j == bNumberOfLines) {
      result.append(""String_Node_Str"" + bStringSplit[i++] + systemEol);
    }
  }
  return result.toString();
}","/** 
 * Return the difference between two strings.
 * @param aString The first string to be compared.
 * @param bString The secondString to be compared
 * @return A string describing the difference between the twostrings in a format similar to the Unix diff command.
 */
public static String diff(String aString,String bString){
  String systemEol=System.getProperty(""String_Node_Str"");
  String eol=""String_Node_Str"";
  String[] aStringSplit=aString.split(eol);
  String[] bStringSplit=bString.split(eol);
  int aNumberOfLines=aStringSplit.length;
  int bNumberOfLines=bStringSplit.length;
  int[][] lcs=new int[aNumberOfLines + 1][bNumberOfLines + 1];
  for (int i=aNumberOfLines - 1; i >= 0; i--) {
    for (int j=bNumberOfLines - 1; j >= 0; j--) {
      if (aStringSplit[i].equals(bStringSplit[j])) {
        lcs[i][j]=lcs[i + 1][j + 1] + 1;
      }
 else {
        lcs[i][j]=Math.max(lcs[i + 1][j],lcs[i][j + 1]);
      }
    }
  }
  StringBuffer result=new StringBuffer();
  int i=0, j=0;
  while (i < aNumberOfLines && j < bNumberOfLines) {
    if (aStringSplit[i].equals(bStringSplit[j])) {
      i++;
      j++;
    }
 else     if (lcs[i + 1][j] >= lcs[i][j + 1]) {
      result.append(""String_Node_Str"" + aStringSplit[i++] + systemEol);
    }
 else {
      result.append(""String_Node_Str"" + bStringSplit[j++] + systemEol);
    }
  }
  while (i < aNumberOfLines || j < bNumberOfLines) {
    if (i == aNumberOfLines) {
      result.append(""String_Node_Str"" + bStringSplit[j++] + systemEol);
    }
 else     if (j == bNumberOfLines) {
      result.append(""String_Node_Str"" + aStringSplit[i++] + systemEol);
    }
  }
  return result.toString();
}"
72351,"/** 
 * Discover all devices that reply to a ping on the class-C local area network connected to the given IP address A class-C network has a netmask of /24, or 255.255.255.0. Returns a string representation of a JSON array of devices.  Note that returning the JSONArray directly does not work properly - for some reason, the JSONArray of device objects is not converted into a Javascript array of device objects.
 * @param IPAddress The IP address whose subnet should be scanned.  E.g.,for IP address 192.168.5.7, scan 192.168.5.0 to 192.168.5.255.
 * @param discoveryMethod The discovery method to be used, e.g. nmap.
 * @return A String containing a JSON representation of devices found.
 */
public String discoverDevices(String IPAddress,String discoveryMethod){
  if (_debugging) {
    System.out.println(""String_Node_Str"" + IPAddress + ""String_Node_Str"");
  }
  _ipMap.clear();
  _hostIP=IPAddress;
  String baseIP;
  if (IPAddress.lastIndexOf(""String_Node_Str"") > 0) {
    baseIP=IPAddress.substring(0,IPAddress.lastIndexOf(""String_Node_Str""));
    if (discoveryMethod.equalsIgnoreCase(""String_Node_Str"")) {
      if (_debugging) {
        System.out.println(""String_Node_Str"");
      }
      _nmap(baseIP);
    }
 else {
      if (System.getProperty(""String_Node_Str"").substring(0,3).equalsIgnoreCase(""String_Node_Str"")) {
        _processes=new ArrayList();
        for (int i=0; i <= 255; i++) {
          try {
            Process process=Runtime.getRuntime().exec(_pingWindowsCommand + baseIP + ""String_Node_Str""+ i);
            _processes.add(process);
          }
 catch (          IOException e) {
            System.err.println(""String_Node_Str"" + baseIP + ""String_Node_Str""+ i);
          }
        }
        for (int i=0; i < _processes.size(); i++) {
          _readPingWindows(_processes.get(i),baseIP + ""String_Node_Str"" + i);
        }
        for (int i=0; i < _processes.size(); i++) {
          try {
            _processes.get(i).waitFor();
          }
 catch (          InterruptedException e) {
          }
        }
        _arpWindows();
      }
 else {
        if (_debugging) {
          System.out.println(""String_Node_Str"" + baseIP);
        }
        _processes=new ArrayList();
        for (int i=0; i <= 255; i++) {
          try {
            Process process=Runtime.getRuntime().exec(_pingLinuxCommand + baseIP + ""String_Node_Str""+ i);
            _processes.add(process);
          }
 catch (          IOException e) {
            System.err.println(""String_Node_Str"" + baseIP + ""String_Node_Str""+ i);
          }
        }
        for (int i=0; i < _processes.size(); i++) {
          _readPingLinux(_processes.get(i),baseIP + ""String_Node_Str"" + i);
        }
        for (int i=0; i < _processes.size(); i++) {
          try {
            _processes.get(i).waitFor();
          }
 catch (          InterruptedException e) {
          }
        }
        _arpLinux();
      }
    }
  }
 else {
    System.err.println(""String_Node_Str"" + IPAddress + ""String_Node_Str""+ IPAddress+ ""String_Node_Str"");
  }
  JSONArray jArray=new JSONArray();
  if (_ipMap.size() > 0) {
    for (    Entry<String,JSONObject> entry : _ipMap.entrySet()) {
      jArray.put(entry.getKey());
    }
    return jArray.toString();
  }
 else {
    System.err.println(""String_Node_Str"" + IPAddress + ""String_Node_Str""+ ""String_Node_Str"");
    return jArray.toString();
  }
}","/** 
 * Discover all devices that reply to a ping on the class-C local area network connected to the given IP address A class-C network has a netmask of /24, or 255.255.255.0. Returns a string representation of a JSON array of devices.  Note that returning the JSONArray directly does not work properly - for some reason, the JSONArray of device objects is not converted into a Javascript array of device objects.
 * @param IPAddress The IP address whose subnet should be scanned.  E.g.,for IP address 192.168.5.7, scan 192.168.5.0 to 192.168.5.255.
 * @param discoveryMethod The discovery method to be used, e.g. nmap.
 * @return A String containing a JSON representation of devices found.
 */
public String discoverDevices(String IPAddress,String discoveryMethod){
  if (_debugging) {
    System.out.println(""String_Node_Str"" + IPAddress + ""String_Node_Str"");
  }
  _ipMap.clear();
  _hostIP=IPAddress;
  String baseIP;
  if (IPAddress.lastIndexOf(""String_Node_Str"") > 0) {
    baseIP=IPAddress.substring(0,IPAddress.lastIndexOf(""String_Node_Str""));
    if (discoveryMethod.equalsIgnoreCase(""String_Node_Str"")) {
      if (_debugging) {
        System.out.println(""String_Node_Str"");
      }
      _nmap(baseIP);
    }
 else {
      if (System.getProperty(""String_Node_Str"").substring(0,3).equalsIgnoreCase(""String_Node_Str"")) {
        _processes=new ArrayList();
        for (int i=0; i <= 255; i++) {
          try {
            Process process=Runtime.getRuntime().exec(_pingWindowsCommand + baseIP + ""String_Node_Str""+ i);
            _processes.add(process);
          }
 catch (          IOException e) {
            System.err.println(""String_Node_Str"" + baseIP + ""String_Node_Str""+ i);
          }
        }
        for (int i=0; i < _processes.size(); i++) {
          _readPingWindows(_processes.get(i),baseIP + ""String_Node_Str"" + i);
        }
        for (int i=0; i < _processes.size(); i++) {
          try {
            _processes.get(i).waitFor();
          }
 catch (          InterruptedException e) {
          }
        }
        _arpWindows();
      }
 else {
        if (_debugging) {
          System.out.println(""String_Node_Str"" + baseIP);
        }
        _processes=new ArrayList();
        for (int i=0; i <= 255; i++) {
          try {
            Process process=Runtime.getRuntime().exec(_pingLinuxCommand + baseIP + ""String_Node_Str""+ i);
            _processes.add(process);
          }
 catch (          IOException e) {
            System.err.println(""String_Node_Str"" + baseIP + ""String_Node_Str""+ i);
          }
        }
        for (int i=0; i < _processes.size(); i++) {
          _readPingLinux(_processes.get(i),baseIP + ""String_Node_Str"" + i);
        }
        for (int i=0; i < _processes.size(); i++) {
          try {
            _processes.get(i).waitFor();
          }
 catch (          InterruptedException e) {
          }
        }
        _arpLinux();
      }
    }
  }
 else {
    System.err.println(""String_Node_Str"" + IPAddress + ""String_Node_Str""+ IPAddress+ ""String_Node_Str"");
  }
  JSONArray jArray=new JSONArray();
  if (_ipMap.size() > 0) {
    for (    Entry<String,JSONObject> entry : _ipMap.entrySet()) {
      jArray.put(entry.getValue());
    }
    return jArray.toString();
  }
 else {
    System.err.println(""String_Node_Str"" + IPAddress + ""String_Node_Str""+ ""String_Node_Str"");
    return jArray.toString();
  }
}"
72352,"/** 
 * Dequeue the events that have the smallest tag from the event queue. Return their destination actor. Advance the model tag to their tag. If the timestamp of the smallest tag is greater than the stop time then return null. If there are no events in the event queue, and the stopWhenQueueIsEmpty parameter is set to true, then return null. Both cases will have the effect of stopping the simulation. <p> If the stopWhenQueueIsEmpty parameter is false and the queue is empty, then stall the current thread by calling wait() on the _eventQueue until there are new events available.  If the synchronizeToRealTime parameter is true, then this method may suspend the calling thread by using Object.wait(long) to let elapsed real time catch up with the current model time.</p>
 * @return The next actor to be fired, which can be null.
 * @exception IllegalActionException If event queue is not ready, oran event is missed, or time is set backwards.
 */
protected Actor _getNextActorToFire() throws IllegalActionException {
  if (_eventQueue == null) {
    throw new IllegalActionException(""String_Node_Str"");
  }
  Actor actorToFire=null;
  DEEvent lastFoundEvent=null;
  DEEvent nextEvent=null;
  while (!_stopRequested) {
    if (_stopWhenQueueIsEmpty) {
      if (_eventQueue.isEmpty()) {
        break;
      }
    }
    if (isEmbedded()) {
      if (_eventQueue.isEmpty()) {
        break;
      }
      nextEvent=_eventQueue.get();
      if (nextEvent.timeStamp().compareTo(getModelTime()) < 0) {
        throw new IllegalActionException(""String_Node_Str"" + nextEvent.timeStamp() + ""String_Node_Str""+ nextEvent.microstep()+ ""String_Node_Str""+ getModelTime()+ ""String_Node_Str""+ _microstep+ ""String_Node_Str"");
      }
      boolean microstepMatches=true;
      Nameable container=getContainer();
      if (container instanceof CompositeActor) {
        Director executiveDirector=((CompositeActor)container).getExecutiveDirector();
        if (executiveDirector instanceof SuperdenseTimeDirector && !_isTopLevel()) {
          microstepMatches=nextEvent.microstep() <= _microstep;
        }
      }
      int comparison=nextEvent.timeStamp().compareTo(getModelTime());
      if (comparison > 0 || comparison == 0 && !microstepMatches) {
        nextEvent=null;
        break;
      }
    }
 else {
      if (_eventQueue.isEmpty()) {
        if (actorToFire != null || getModelTime().equals(getModelStopTime())) {
          break;
        }
      }
synchronized (_eventQueueLock) {
        while (_eventQueue.isEmpty() && !_stopRequested && !_stopFireRequested) {
          if (_debugging) {
            _debug(""String_Node_Str"");
          }
          try {
            workspace().wait(_eventQueueLock);
          }
 catch (          InterruptedException e) {
            break;
          }
        }
        if (_eventQueue.isEmpty()) {
          return null;
        }
        nextEvent=_eventQueue.get();
      }
    }
    if (actorToFire == null) {
      Time currentTime;
      int depth=0;
      try {
synchronized (_eventQueueLock) {
          lastFoundEvent=_eventQueue.get();
          currentTime=_consultTimeRegulators(lastFoundEvent.timeStamp());
          if (_synchronizeToRealTime) {
            Manager manager=((CompositeActor)getContainer()).getManager();
            while (!_stopRequested && !_stopFireRequested) {
              lastFoundEvent=_eventQueue.get();
              currentTime=lastFoundEvent.timeStamp();
              long elapsedTime=elapsedTimeSinceStart();
              double elapsedTimeInSeconds=elapsedTime / 1000.0;
              ptolemy.actor.util.Time elapsed=new ptolemy.actor.util.Time(this,elapsedTimeInSeconds);
              if (currentTime.compareTo(elapsed) <= 0) {
                break;
              }
              long timeToWait=(long)(currentTime.subtract(elapsed).getDoubleValue() * 1000.0);
              if (timeToWait > 0) {
                if (_debugging) {
                  _debug(""String_Node_Str"" + timeToWait);
                }
                try {
                  depth=_workspace.releaseReadPermission();
                  setDeferringChangeRequests(false);
                  manager.setWaitingThread(Thread.currentThread());
                  _eventQueueLock.wait(timeToWait);
                }
 catch (                InterruptedException ex) {
                }
 finally {
                  setDeferringChangeRequests(true);
                  manager.setWaitingThread(null);
                }
              }
            }
            if (_stopRequested || _stopFireRequested) {
              return null;
            }
          }
        }
      }
  finally {
        if (depth > 0) {
          _workspace.reacquireReadPermission(depth);
        }
      }
synchronized (_eventQueueLock) {
        lastFoundEvent=_eventQueue.take();
        currentTime=lastFoundEvent.timeStamp();
        actorToFire=lastFoundEvent.actor();
        if (_disabledActors != null && _disabledActors.contains(actorToFire)) {
          if (_debugging) {
            _debug(""String_Node_Str"",((Nameable)actorToFire).getFullName());
          }
          actorToFire=null;
          continue;
        }
        setModelTime(currentTime);
        _microstep=lastFoundEvent.microstep();
        if (_debugging) {
          _debug(""String_Node_Str"" + currentTime + ""String_Node_Str""+ _microstep+ ""String_Node_Str"");
        }
        if (currentTime.compareTo(getModelStopTime()) > 0) {
          if (_debugging) {
            _debug(""String_Node_Str"");
          }
          _exceedStopTime=true;
          return null;
        }
      }
    }
 else {
      if (nextEvent.hasTheSameTagAs(lastFoundEvent) && nextEvent.actor() == actorToFire) {
synchronized (_eventQueueLock) {
          _eventQueue.take();
        }
      }
 else {
        break;
      }
    }
    if (actorToFire != null && _aspectsPresent) {
      if (_actorsFinished.contains(actorToFire)) {
        _actorsFinished.remove(actorToFire);
      }
 else       if (!_schedule((NamedObj)actorToFire,getModelTime())) {
        _nextScheduleTime.get(_aspectForActor.get(actorToFire)).add(getModelTime());
        if (_actorsInExecution == null) {
          _actorsInExecution=new HashMap();
        }
        List<DEEvent> events=_actorsInExecution.get(actorToFire);
        if (events == null) {
          events=new ArrayList<DEEvent>();
        }
        events.add(lastFoundEvent);
        _actorsInExecution.put(actorToFire,events);
        actorToFire=null;
      }
    }
  }
  return actorToFire;
}","/** 
 * Dequeue the events that have the smallest tag from the event queue. Return their destination actor. Advance the model tag to their tag. If the timestamp of the smallest tag is greater than the stop time then return null. If there are no events in the event queue, and the stopWhenQueueIsEmpty parameter is set to true, then return null. Both cases will have the effect of stopping the simulation. <p> If the stopWhenQueueIsEmpty parameter is false and the queue is empty, then stall the current thread by calling wait() on the _eventQueue until there are new events available.  If the synchronizeToRealTime parameter is true, then this method may suspend the calling thread by using Object.wait(long) to let elapsed real time catch up with the current model time.</p>
 * @return The next actor to be fired, which can be null.
 * @exception IllegalActionException If event queue is not ready, oran event is missed, or time is set backwards.
 */
protected Actor _getNextActorToFire() throws IllegalActionException {
  if (_eventQueue == null) {
    throw new IllegalActionException(""String_Node_Str"");
  }
  Actor actorToFire=null;
  DEEvent lastFoundEvent=null;
  DEEvent nextEvent=null;
  while (!_stopRequested) {
    if (_stopWhenQueueIsEmpty) {
      if (_eventQueue.isEmpty()) {
        break;
      }
    }
    if (isEmbedded()) {
      if (_eventQueue.isEmpty()) {
        break;
      }
      nextEvent=_eventQueue.get();
      if (nextEvent.timeStamp().compareTo(getModelTime()) < 0) {
        throw new IllegalActionException(""String_Node_Str"" + nextEvent.timeStamp() + ""String_Node_Str""+ nextEvent.microstep()+ ""String_Node_Str""+ getModelTime()+ ""String_Node_Str""+ _microstep+ ""String_Node_Str"");
      }
      boolean microstepMatches=true;
      Nameable container=getContainer();
      if (container instanceof CompositeActor) {
        Director executiveDirector=((CompositeActor)container).getExecutiveDirector();
        if (executiveDirector instanceof SuperdenseTimeDirector && !_isTopLevel()) {
          microstepMatches=nextEvent.microstep() <= _microstep;
        }
      }
      int comparison=nextEvent.timeStamp().compareTo(getModelTime());
      if (comparison > 0 || comparison == 0 && !microstepMatches) {
        nextEvent=null;
        break;
      }
    }
 else {
      if (_eventQueue.isEmpty()) {
        if (actorToFire != null || getModelTime().equals(getModelStopTime())) {
          break;
        }
      }
synchronized (_eventQueueLock) {
        while (_eventQueue.isEmpty() && !_stopRequested && !_stopFireRequested) {
          if (_debugging) {
            _debug(""String_Node_Str"");
          }
          try {
            workspace().wait(_eventQueueLock);
          }
 catch (          InterruptedException e) {
            break;
          }
        }
        if (_eventQueue.isEmpty()) {
          return null;
        }
        nextEvent=_eventQueue.get();
      }
    }
    if (actorToFire == null) {
      Time currentTime;
      int depth=0;
      try {
synchronized (_eventQueueLock) {
          lastFoundEvent=_eventQueue.get();
          currentTime=_consultTimeRegulators(lastFoundEvent.timeStamp());
          if (_synchronizeToRealTime) {
            Manager manager=((CompositeActor)getContainer()).getManager();
            while (!_stopRequested && !_stopFireRequested) {
              lastFoundEvent=_eventQueue.get();
              currentTime=lastFoundEvent.timeStamp();
              if (currentTime.compareTo(getModelStopTime()) > 0) {
                break;
              }
              long elapsedTime=elapsedTimeSinceStart();
              double elapsedTimeInSeconds=elapsedTime / 1000.0;
              ptolemy.actor.util.Time elapsed=new ptolemy.actor.util.Time(this,elapsedTimeInSeconds);
              if (currentTime.compareTo(elapsed) <= 0) {
                break;
              }
              long timeToWait=(long)(currentTime.subtract(elapsed).getDoubleValue() * 1000.0);
              if (timeToWait > 0) {
                if (_debugging) {
                  _debug(""String_Node_Str"" + timeToWait);
                }
                try {
                  depth=_workspace.releaseReadPermission();
                  setDeferringChangeRequests(false);
                  manager.setWaitingThread(Thread.currentThread());
                  _eventQueueLock.wait(timeToWait);
                }
 catch (                InterruptedException ex) {
                }
 finally {
                  setDeferringChangeRequests(true);
                  manager.setWaitingThread(null);
                }
              }
            }
            if (_stopRequested || _stopFireRequested) {
              return null;
            }
          }
        }
      }
  finally {
        if (depth > 0) {
          _workspace.reacquireReadPermission(depth);
        }
      }
synchronized (_eventQueueLock) {
        lastFoundEvent=_eventQueue.take();
        currentTime=lastFoundEvent.timeStamp();
        actorToFire=lastFoundEvent.actor();
        if (_disabledActors != null && _disabledActors.contains(actorToFire)) {
          if (_debugging) {
            _debug(""String_Node_Str"",((Nameable)actorToFire).getFullName());
          }
          actorToFire=null;
          continue;
        }
        setModelTime(currentTime);
        _microstep=lastFoundEvent.microstep();
        if (_debugging) {
          _debug(""String_Node_Str"" + currentTime + ""String_Node_Str""+ _microstep+ ""String_Node_Str"");
        }
        if (currentTime.compareTo(getModelStopTime()) > 0) {
          if (_debugging) {
            _debug(""String_Node_Str"");
          }
          _exceedStopTime=true;
          return null;
        }
      }
    }
 else {
      if (nextEvent.hasTheSameTagAs(lastFoundEvent) && nextEvent.actor() == actorToFire) {
synchronized (_eventQueueLock) {
          _eventQueue.take();
        }
      }
 else {
        break;
      }
    }
    if (actorToFire != null && _aspectsPresent) {
      if (_actorsFinished.contains(actorToFire)) {
        _actorsFinished.remove(actorToFire);
      }
 else       if (!_schedule((NamedObj)actorToFire,getModelTime())) {
        _nextScheduleTime.get(_aspectForActor.get(actorToFire)).add(getModelTime());
        if (_actorsInExecution == null) {
          _actorsInExecution=new HashMap();
        }
        List<DEEvent> events=_actorsInExecution.get(actorToFire);
        if (events == null) {
          events=new ArrayList<DEEvent>();
        }
        events.add(lastFoundEvent);
        _actorsInExecution.put(actorToFire,events);
        actorToFire=null;
      }
    }
  }
  return actorToFire;
}"
72353,"/** 
 * Callback (TAG) delivered by the RTI (CERTI) to notify that the Federate is authorized to advance its time to <i>theTime</i>. This time is the same or smaller than the time specified when calling the nextEventRequest() or the timeAdvanceRequest() services.
 */
@Override public void timeAdvanceGrant(LogicalTime theTime) throws InvalidFederationTime, TimeAdvanceWasNotInProgress, FederateInternalError {
  double time=((CertiLogicalTime)theTime).getTime();
  time=_hlaTimeUnitValue * time;
  logicalTimeHLA=new CertiLogicalTime(time);
  _TAGDelay.add((System.nanoTime() - _timeOfTheLastAdvanceRequest) / Math.pow(10,9));
  _timeOfTheLastAdvanceRequest=0;
  timeAdvanceGrant=true;
  _numberOfTAGs++;
  _numberOfTicks.add(0);
  if (_debugging) {
    _debug(""String_Node_Str"" + logicalTimeHLA.toString() + ""String_Node_Str"");
  }
}","/** 
 * Callback (TAG) delivered by the RTI (CERTI) to notify that the Federate is authorized to advance its time to <i>theTime</i>. This time is the same or smaller than the time specified when calling the nextEventRequest() or the timeAdvanceRequest() services.
 */
@Override public void timeAdvanceGrant(LogicalTime theTime) throws InvalidFederationTime, TimeAdvanceWasNotInProgress, FederateInternalError {
  double time=((CertiLogicalTime)theTime).getTime();
  logicalTimeHLA=new CertiLogicalTime(time);
  _TAGDelay.add((System.nanoTime() - _timeOfTheLastAdvanceRequest) / Math.pow(10,9));
  _timeOfTheLastAdvanceRequest=0;
  timeAdvanceGrant=true;
  _numberOfTAGs++;
  _numberOfTicks.add(0);
  if (_debugging) {
    _debug(""String_Node_Str"" + logicalTimeHLA.toString() + ""String_Node_Str"");
  }
}"
72354,"/** 
 * Get hlaNextPointInTime in HLA to advance to when TAR is used. hlaNextPointInTime = hlaCurrentTime + Ts.
 * @return next point in time to advance to.
 * @exception IllegalActionException if hlaTimeStep is NULL.
 */
private Time _getHlaNextPointInTime() throws IllegalActionException {
  Double time=_getHlaCurrentTime().add(_hlaTimeStep).getDoubleValue();
  return _convertToPtolemyTime(new CertiLogicalTime(time));
}","/** 
 * Get hlaNextPointInTime in HLA to advance to when TAR is used. hlaNextPointInTime = hlaCurrentTime + Ts.
 * @return next point in time to advance to.
 * @exception IllegalActionException if hlaTimeStep is NULL.
 */
private Time _getHlaNextPointInTime() throws IllegalActionException {
  return _getHlaCurrentTime().add(_hlaTimeStep);
}"
72355,"private static void _generateCredentials(File directory,String subdirectory) throws IOException {
  if (directory.isFile()) {
    throw new IOException(directory + _badFileMessage);
  }
  final StringBufferExec exec=new StringBufferExec(true);
  List execCommands=new LinkedList<String>();
  String commands=""String_Node_Str"";
  System.out.println(""String_Node_Str"" + directory + ""String_Node_Str""+ subdirectory);
  File subdirectoryDirectory=new File(directory,subdirectory);
}","private static void _generateCredentials(File directory,String subdirectory) throws IOException {
  if (directory.isFile()) {
    throw new IOException(directory + _badFileMessage);
  }
  System.out.println(""String_Node_Str"" + directory + ""String_Node_Str""+ subdirectory);
}"
72356,"/** 
 * Discover all devices that reply to a ping on the class-C local area network connected to the given IP address A class-C network has a netmask of /24, or 255.255.255.0. Returns a string representation of a JSON array of devices.  Note that returning the JSONArray directly does not work properly - for some reason, the JSONArray of device objects is not converted into a Javascript array of device objects.
 * @param IPAddress The IP address whose subnet should be scanned.  E.g.,for IP address 192.168.5.7, scan 192.168.5.0 to 192.168.5.255.
 * @param discoveryMethod The discovery method to be used, e.g. nmap.
 * @return A String containing a JSON representation of devices found.
 */
public String discoverDevices(String IPAddress,String discoveryMethod){
  if (_debugging) {
    System.out.println(""String_Node_Str"" + IPAddress + ""String_Node_Str"");
  }
  _ipMap.clear();
  _hostIP=IPAddress;
  String baseIP;
  if (IPAddress.lastIndexOf(""String_Node_Str"") > 0) {
    baseIP=IPAddress.substring(0,IPAddress.lastIndexOf(""String_Node_Str""));
    if (discoveryMethod.equalsIgnoreCase(""String_Node_Str"")) {
      if (_debugging) {
        System.out.println(""String_Node_Str"");
      }
      _nmap(baseIP);
    }
 else {
      if (System.getProperty(""String_Node_Str"").substring(0,3).equalsIgnoreCase(""String_Node_Str"")) {
        _processes=new ArrayList();
        for (int i=0; i <= 255; i++) {
          try {
            Process process=Runtime.getRuntime().exec(_pingWindowsCommand + baseIP + ""String_Node_Str""+ i);
            _processes.add(process);
          }
 catch (          IOException e) {
            System.err.println(""String_Node_Str"" + baseIP + ""String_Node_Str""+ i);
          }
        }
        for (int i=0; i < _processes.size(); i++) {
          _readPingWindows(_processes.get(i),baseIP + ""String_Node_Str"" + i);
        }
        for (int i=0; i < _processes.size(); i++) {
          try {
            _processes.get(i).waitFor();
          }
 catch (          InterruptedException e) {
          }
        }
        _arpWindows();
      }
 else {
        if (_debugging) {
          System.out.println(""String_Node_Str"" + baseIP);
        }
        _processes=new ArrayList();
        for (int i=0; i <= 255; i++) {
          try {
            Process process=Runtime.getRuntime().exec(_pingLinuxCommand + baseIP + ""String_Node_Str""+ i);
            _processes.add(process);
          }
 catch (          IOException e) {
            System.err.println(""String_Node_Str"" + baseIP + ""String_Node_Str""+ i);
          }
        }
        for (int i=0; i < _processes.size(); i++) {
          _readPingLinux(_processes.get(i),baseIP + ""String_Node_Str"" + i);
        }
        for (int i=0; i < _processes.size(); i++) {
          try {
            _processes.get(i).waitFor();
          }
 catch (          InterruptedException e) {
          }
        }
        _arpLinux();
      }
    }
  }
 else {
    System.err.println(""String_Node_Str"" + IPAddress + ""String_Node_Str""+ IPAddress+ ""String_Node_Str"");
  }
  JSONArray jArray=new JSONArray();
  if (_ipMap.size() > 0) {
    for (    String key : _ipMap.keySet()) {
      jArray.put(_ipMap.get(key));
    }
    return jArray.toString();
  }
 else {
    System.err.println(""String_Node_Str"" + IPAddress + ""String_Node_Str""+ ""String_Node_Str"");
    return jArray.toString();
  }
}","/** 
 * Discover all devices that reply to a ping on the class-C local area network connected to the given IP address A class-C network has a netmask of /24, or 255.255.255.0. Returns a string representation of a JSON array of devices.  Note that returning the JSONArray directly does not work properly - for some reason, the JSONArray of device objects is not converted into a Javascript array of device objects.
 * @param IPAddress The IP address whose subnet should be scanned.  E.g.,for IP address 192.168.5.7, scan 192.168.5.0 to 192.168.5.255.
 * @param discoveryMethod The discovery method to be used, e.g. nmap.
 * @return A String containing a JSON representation of devices found.
 */
public String discoverDevices(String IPAddress,String discoveryMethod){
  if (_debugging) {
    System.out.println(""String_Node_Str"" + IPAddress + ""String_Node_Str"");
  }
  _ipMap.clear();
  _hostIP=IPAddress;
  String baseIP;
  if (IPAddress.lastIndexOf(""String_Node_Str"") > 0) {
    baseIP=IPAddress.substring(0,IPAddress.lastIndexOf(""String_Node_Str""));
    if (discoveryMethod.equalsIgnoreCase(""String_Node_Str"")) {
      if (_debugging) {
        System.out.println(""String_Node_Str"");
      }
      _nmap(baseIP);
    }
 else {
      if (System.getProperty(""String_Node_Str"").substring(0,3).equalsIgnoreCase(""String_Node_Str"")) {
        _processes=new ArrayList();
        for (int i=0; i <= 255; i++) {
          try {
            Process process=Runtime.getRuntime().exec(_pingWindowsCommand + baseIP + ""String_Node_Str""+ i);
            _processes.add(process);
          }
 catch (          IOException e) {
            System.err.println(""String_Node_Str"" + baseIP + ""String_Node_Str""+ i);
          }
        }
        for (int i=0; i < _processes.size(); i++) {
          _readPingWindows(_processes.get(i),baseIP + ""String_Node_Str"" + i);
        }
        for (int i=0; i < _processes.size(); i++) {
          try {
            _processes.get(i).waitFor();
          }
 catch (          InterruptedException e) {
          }
        }
        _arpWindows();
      }
 else {
        if (_debugging) {
          System.out.println(""String_Node_Str"" + baseIP);
        }
        _processes=new ArrayList();
        for (int i=0; i <= 255; i++) {
          try {
            Process process=Runtime.getRuntime().exec(_pingLinuxCommand + baseIP + ""String_Node_Str""+ i);
            _processes.add(process);
          }
 catch (          IOException e) {
            System.err.println(""String_Node_Str"" + baseIP + ""String_Node_Str""+ i);
          }
        }
        for (int i=0; i < _processes.size(); i++) {
          _readPingLinux(_processes.get(i),baseIP + ""String_Node_Str"" + i);
        }
        for (int i=0; i < _processes.size(); i++) {
          try {
            _processes.get(i).waitFor();
          }
 catch (          InterruptedException e) {
          }
        }
        _arpLinux();
      }
    }
  }
 else {
    System.err.println(""String_Node_Str"" + IPAddress + ""String_Node_Str""+ IPAddress+ ""String_Node_Str"");
  }
  JSONArray jArray=new JSONArray();
  if (_ipMap.size() > 0) {
    for (    Entry<String,JSONObject> entry : _ipMap.entrySet()) {
      jArray.put(entry.getKey());
    }
    return jArray.toString();
  }
 else {
    System.err.println(""String_Node_Str"" + IPAddress + ""String_Node_Str""+ ""String_Node_Str"");
    return jArray.toString();
  }
}"
72357,"/** 
 * Execute the arp command on a Windows platform.  The arp command finds MAC addresses for devices on the local area network. The arp command should follow a ping sweep to get the most up-to-date information and to screen out devices that are not accessible at the moment (which may be cached in the arp cache).
 */
private void _arpWindows(){
  if (_ipMap.size() == 0) {
    System.err.println(""String_Node_Str"" + _pingWindowsCommand + ""String_Node_Str"");
  }
  try {
    Process process=Runtime.getRuntime().exec(_arpCommand);
    BufferedReader stdOut=null;
    try {
      stdOut=new BufferedReader(new InputStreamReader(process.getInputStream(),""String_Node_Str""));
      String line;
      int index;
      JSONObject object;
      while ((line=stdOut.readLine()) != null) {
        for (        String key : _ipMap.keySet()) {
          object=_ipMap.get(key);
          index=line.indexOf(object.getString(""String_Node_Str""));
          if (index != -1) {
            if (index != 2) {
              object.put(""String_Node_Str"",""String_Node_Str"");
            }
 else {
              object.put(""String_Node_Str"",line.substring(index + 22,index + 39));
            }
            _ipMap.put(key,object);
          }
        }
      }
    }
  finally {
      if (stdOut != null) {
        stdOut.close();
      }
    }
  }
 catch (  IOException e) {
    System.err.println(""String_Node_Str"" + _arpCommand);
  }
catch (  JSONException e2) {
    System.err.println(""String_Node_Str"");
  }
}","/** 
 * Execute the arp command on a Windows platform.  The arp command finds MAC addresses for devices on the local area network. The arp command should follow a ping sweep to get the most up-to-date information and to screen out devices that are not accessible at the moment (which may be cached in the arp cache).
 */
private void _arpWindows(){
  if (_ipMap.size() == 0) {
    System.err.println(""String_Node_Str"" + _pingWindowsCommand + ""String_Node_Str"");
  }
  try {
    Process process=Runtime.getRuntime().exec(_arpCommand);
    BufferedReader stdOut=null;
    try {
      stdOut=new BufferedReader(new InputStreamReader(process.getInputStream(),""String_Node_Str""));
      String line;
      int index;
      JSONObject object;
      while ((line=stdOut.readLine()) != null) {
        for (        Entry<String,JSONObject> entry : _ipMap.entrySet()) {
          object=entry.getValue();
          index=line.indexOf(object.getString(""String_Node_Str""));
          if (index != -1) {
            if (index != 2) {
              object.put(""String_Node_Str"",""String_Node_Str"");
            }
 else {
              object.put(""String_Node_Str"",line.substring(index + 22,index + 39));
            }
            _ipMap.put(entry.getKey(),object);
          }
        }
      }
    }
  finally {
      if (stdOut != null) {
        stdOut.close();
      }
    }
  }
 catch (  IOException e) {
    System.err.println(""String_Node_Str"" + _arpCommand);
  }
catch (  JSONException e2) {
    System.err.println(""String_Node_Str"");
  }
}"
72358,"/** 
 * Execute the arp command on a Linux platform.  The arp command finds names and MAC addresses for devices on the local area network. The arp command should follow a ping sweep to get the most up-to-date information and to screen out devices that are not accessible at the moment (which may be cached in the arp cache).
 */
private void _arpLinux(){
  if (_ipMap.size() == 0) {
    System.err.println(""String_Node_Str"" + _pingLinuxCommand + ""String_Node_Str"");
  }
  try {
    Process process=Runtime.getRuntime().exec(_arpCommand);
    BufferedReader stdOut=null;
    try {
      stdOut=new BufferedReader(new InputStreamReader(process.getInputStream(),""String_Node_Str""));
      String line;
      while ((line=stdOut.readLine()) != null) {
        if (_debugging) {
          System.out.println(""String_Node_Str"" + line + ""String_Node_Str"");
        }
        StringTokenizer tokenizer=new StringTokenizer(line,""String_Node_Str"");
        String token, name, ip;
        if (tokenizer.countTokens() >= 4) {
          name=(String)tokenizer.nextElement();
          token=(String)tokenizer.nextElement();
          ip=token.substring(1,token.length() - 1);
          if (_debugging) {
            System.out.println(""String_Node_Str"" + name + ""String_Node_Str""+ token+ ""String_Node_Str""+ ip);
          }
          JSONObject object;
          for (          String key : _ipMap.keySet()) {
            object=_ipMap.get(key);
            if (object.get(""String_Node_Str"").toString().equalsIgnoreCase(ip)) {
              token=(String)tokenizer.nextElement();
              token=(String)tokenizer.nextElement();
              object.put(""String_Node_Str"",name);
              object.put(""String_Node_Str"",token);
              _ipMap.put(key,object);
            }
          }
        }
      }
    }
  finally {
      if (stdOut != null) {
        stdOut.close();
      }
    }
  }
 catch (  IOException e) {
    System.err.println(""String_Node_Str"" + _arpCommand);
  }
catch (  JSONException e2) {
    System.err.println(""String_Node_Str"");
  }
}","/** 
 * Execute the arp command on a Linux platform.  The arp command finds names and MAC addresses for devices on the local area network. The arp command should follow a ping sweep to get the most up-to-date information and to screen out devices that are not accessible at the moment (which may be cached in the arp cache).
 */
private void _arpLinux(){
  if (_ipMap.size() == 0) {
    System.err.println(""String_Node_Str"" + _pingLinuxCommand + ""String_Node_Str"");
  }
  try {
    Process process=Runtime.getRuntime().exec(_arpCommand);
    BufferedReader stdOut=null;
    try {
      stdOut=new BufferedReader(new InputStreamReader(process.getInputStream(),""String_Node_Str""));
      String line;
      while ((line=stdOut.readLine()) != null) {
        if (_debugging) {
          System.out.println(""String_Node_Str"" + line + ""String_Node_Str"");
        }
        StringTokenizer tokenizer=new StringTokenizer(line,""String_Node_Str"");
        String token, name, ip;
        if (tokenizer.countTokens() >= 4) {
          name=(String)tokenizer.nextElement();
          token=(String)tokenizer.nextElement();
          ip=token.substring(1,token.length() - 1);
          if (_debugging) {
            System.out.println(""String_Node_Str"" + name + ""String_Node_Str""+ token+ ""String_Node_Str""+ ip);
          }
          JSONObject object;
          for (          Entry<String,JSONObject> entry : _ipMap.entrySet()) {
            object=entry.getValue();
            if (object.get(""String_Node_Str"").toString().equalsIgnoreCase(ip)) {
              token=(String)tokenizer.nextElement();
              token=(String)tokenizer.nextElement();
              object.put(""String_Node_Str"",name);
              object.put(""String_Node_Str"",token);
              _ipMap.put(entry.getKey(),object);
            }
          }
        }
      }
    }
  finally {
      if (stdOut != null) {
        stdOut.close();
      }
    }
  }
 catch (  IOException e) {
    System.err.println(""String_Node_Str"" + _arpCommand);
  }
catch (  JSONException e2) {
    System.err.println(""String_Node_Str"");
  }
}"
72359,"/** 
 * Read results of a ping on a Linux or Mac platform. If a device is found, add a JSON object containing the device IP address and name to _ipMap.
 * @param process  The process that is executing the ping.
 * @param testIP  The IP address to base the sweep on.
 */
private void _readPingLinux(Process process,String testIP){
  JSONObject device=null;
  try {
    BufferedReader stdOut=null;
    try {
      stdOut=new BufferedReader(new InputStreamReader(process.getInputStream()));
      String line;
      while ((line=stdOut.readLine()) != null) {
        if (_debugging) {
          System.out.println(""String_Node_Str"" + testIP + ""String_Node_Str""+ line);
        }
        int found=line.indexOf(""String_Node_Str"");
        if (found < 0) {
          found=line.indexOf(""String_Node_Str"");
          if (found < 0) {
            found=line.indexOf(""String_Node_Str"");
            if (found < 0) {
              found=line.indexOf(""String_Node_Str"");
            }
          }
        }
        if (found > 0) {
          if (_debugging) {
            System.out.println(""String_Node_Str"" + testIP);
          }
          try {
            if (testIP.equalsIgnoreCase(_hostIP)) {
              device=new JSONObject(""String_Node_Str"" + testIP + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
            }
 else {
              device=new JSONObject(""String_Node_Str"" + testIP + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
            }
          }
 catch (          JSONException e) {
            System.err.println(""String_Node_Str"" + ""String_Node_Str"" + testIP);
          }
        }
      }
    }
  finally {
      if (stdOut != null) {
        stdOut.close();
      }
    }
  }
 catch (  IOException e) {
    System.err.println(""String_Node_Str"" + testIP);
  }
  if (device != null) {
    _ipMap.put(testIP,device);
  }
}","/** 
 * Read results of a ping on a Linux or Mac platform. If a device is found, add a JSON object containing the device IP address and name to _ipMap.
 * @param process  The process that is executing the ping.
 * @param testIP  The IP address to base the sweep on.
 */
private void _readPingLinux(Process process,String testIP){
  JSONObject device=null;
  try {
    BufferedReader stdOut=null;
    try {
      stdOut=new BufferedReader(new InputStreamReader(process.getInputStream(),StandardCharsets.UTF_8));
      String line;
      while ((line=stdOut.readLine()) != null) {
        if (_debugging) {
          System.out.println(""String_Node_Str"" + testIP + ""String_Node_Str""+ line);
        }
        int found=line.indexOf(""String_Node_Str"");
        if (found < 0) {
          found=line.indexOf(""String_Node_Str"");
          if (found < 0) {
            found=line.indexOf(""String_Node_Str"");
            if (found < 0) {
              found=line.indexOf(""String_Node_Str"");
            }
          }
        }
        if (found > 0) {
          if (_debugging) {
            System.out.println(""String_Node_Str"" + testIP);
          }
          try {
            if (testIP.equalsIgnoreCase(_hostIP)) {
              device=new JSONObject(""String_Node_Str"" + testIP + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
            }
 else {
              device=new JSONObject(""String_Node_Str"" + testIP + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
            }
          }
 catch (          JSONException e) {
            System.err.println(""String_Node_Str"" + ""String_Node_Str"" + testIP);
          }
        }
      }
    }
  finally {
      if (stdOut != null) {
        stdOut.close();
      }
    }
  }
 catch (  IOException e) {
    System.err.println(""String_Node_Str"" + testIP);
  }
  if (device != null) {
    _ipMap.put(testIP,device);
  }
}"
72360,"/** 
 * Take a key and return its value from the local storage if the key exists, otherwise, return null.
 * @param key The key for the value to be returned.
 * @return The string value associated with the key.
 * @exception MqttPersistenceException
 * @see #setItem(String,String)
 */
public String getItem(String key) throws MqttPersistenceException {
  if (_mqttLocalStorage.containsKey(key)) {
    MqttPersistentData message=(MqttPersistentData)_mqttLocalStorage.get(key);
    return new String(message.getHeaderBytes());
  }
 else {
    return null;
  }
}","/** 
 * Take a key and return its value from the local storage if the key exists, otherwise, return null.
 * @param key The key for the value to be returned.
 * @return The string value associated with the key.
 * @exception MqttPersistenceException
 * @see #setItem(String,String)
 */
public String getItem(String key) throws MqttPersistenceException {
  if (_mqttLocalStorage.containsKey(key)) {
    MqttPersistentData message=(MqttPersistentData)_mqttLocalStorage.get(key);
    return new String(message.getHeaderBytes(),StandardCharsets.UTF_8);
  }
 else {
    return null;
  }
}"
72361,"/** 
 * Take a key-value pair and stores the pair into the local storage.
 * @param key The key to be stored.
 * @param value The string value associated with the key.
 * @exception MqttPersistenceException
 * @exception IOException
 * @see #getItem(String)
 */
public void setItem(String key,String value) throws MqttPersistenceException, IOException {
  byte[] bytes=value.getBytes();
  MqttPersistentData message=new MqttPersistentData(value,new byte[0],0,0,bytes,0,bytes.length);
  _mqttLocalStorage.put(key,message);
}","/** 
 * Take a key-value pair and stores the pair into the local storage.
 * @param key The key to be stored.
 * @param value The string value associated with the key.
 * @exception MqttPersistenceException
 * @exception IOException
 * @see #getItem(String)
 */
public void setItem(String key,String value) throws MqttPersistenceException, IOException {
  byte[] bytes=value.getBytes(StandardCharsets.UTF_8);
  MqttPersistentData message=new MqttPersistentData(value,new byte[0],0,0,bytes,0,bytes.length);
  _mqttLocalStorage.put(key,message);
}"
72362,"/** 
 * Start connection between the client and the broker server.
 * @exception MqttSecurityException
 * @exception MqttException
 */
public void start() throws MqttSecurityException, MqttException {
  _mqttClient.connect(_connOpts,null,new IMqttActionListener(){
    @Override public void onSuccess(    IMqttToken arg0){
      _currentObj.callMember(""String_Node_Str"",""String_Node_Str"");
    }
    @Override public void onFailure(    IMqttToken arg0,    Throwable arg1){
      _error(_currentObj,""String_Node_Str"");
    }
  }
);
  _mqttClient.setCallback(new MqttCallback(){
    @Override public void messageArrived(    String topic,    MqttMessage message) throws Exception {
      Object messageObject;
      if (_rawBytes) {
        messageObject=_toJSArray(message.getPayload());
      }
 else {
        messageObject=new String(message.getPayload());
      }
      _currentObj.callMember(""String_Node_Str"",""String_Node_Str"",topic,messageObject);
    }
    @Override public void deliveryComplete(    IMqttDeliveryToken arg0){
      _currentObj.callMember(""String_Node_Str"",""String_Node_Str"");
    }
    @Override public void connectionLost(    Throwable arg0){
      _currentObj.callMember(""String_Node_Str"",""String_Node_Str"");
    }
  }
);
}","/** 
 * Start connection between the client and the broker server.
 * @exception MqttSecurityException
 * @exception MqttException
 */
public void start() throws MqttSecurityException, MqttException {
  _mqttClient.connect(_connOpts,null,new IMqttActionListener(){
    @Override public void onSuccess(    IMqttToken arg0){
      _currentObj.callMember(""String_Node_Str"",""String_Node_Str"");
    }
    @Override public void onFailure(    IMqttToken arg0,    Throwable arg1){
      _error(_currentObj,""String_Node_Str"");
    }
  }
);
  _mqttClient.setCallback(new MqttCallback(){
    @Override public void messageArrived(    String topic,    MqttMessage message) throws Exception {
      Object messageObject;
      if (_rawBytes) {
        messageObject=_toJSArray(message.getPayload());
      }
 else {
        messageObject=new String(message.getPayload(),StandardCharsets.UTF_8);
      }
      _currentObj.callMember(""String_Node_Str"",""String_Node_Str"",topic,messageObject);
    }
    @Override public void deliveryComplete(    IMqttDeliveryToken arg0){
      _currentObj.callMember(""String_Node_Str"",""String_Node_Str"");
    }
    @Override public void connectionLost(    Throwable arg0){
      _currentObj.callMember(""String_Node_Str"",""String_Node_Str"");
    }
  }
);
}"
72363,"@Override public void messageArrived(String topic,MqttMessage message) throws Exception {
  Object messageObject;
  if (_rawBytes) {
    messageObject=_toJSArray(message.getPayload());
  }
 else {
    messageObject=new String(message.getPayload());
  }
  _currentObj.callMember(""String_Node_Str"",""String_Node_Str"",topic,messageObject);
}","@Override public void messageArrived(String topic,MqttMessage message) throws Exception {
  Object messageObject;
  if (_rawBytes) {
    messageObject=_toJSArray(message.getPayload());
  }
 else {
    messageObject=new String(message.getPayload(),StandardCharsets.UTF_8);
  }
  _currentObj.callMember(""String_Node_Str"",""String_Node_Str"",topic,messageObject);
}"
72364,"/** 
 * Publish an MQTT message to subscribers listening to the topic.
 * @param topic The topic to which to publish.
 * @param message The message sent to subscribers.
 * @param qos The QoS level of the message. (0: At most once, 1: At least once, 2: Exactly once)
 * @param retain Whether the sever should hold on the message after it has been delivered tocurrent subscribers so that a newly incoming subscriber can receive the message later.
 * @exception MqttException If the publish fails.
 * @exception IllegalActionException
 */
public void publish(String topic,Object message,Integer qos,boolean retain) throws MqttException, IllegalActionException {
  byte[] payload;
  if (_rawBytes) {
    payload=_toJavaBytes(message);
  }
 else {
    payload=((String)message).getBytes();
  }
  MqttMessage mqttMessage=new MqttMessage(payload);
  mqttMessage.setQos(qos);
  mqttMessage.setRetained(retain);
  _mqttClient.publish(topic,mqttMessage);
}","/** 
 * Publish an MQTT message to subscribers listening to the topic.
 * @param topic The topic to which to publish.
 * @param message The message sent to subscribers.
 * @param qos The QoS level of the message. (0: At most once, 1: At least once, 2: Exactly once)
 * @param retain Whether the sever should hold on the message after it has been delivered tocurrent subscribers so that a newly incoming subscriber can receive the message later.
 * @exception MqttException If the publish fails.
 * @exception IllegalActionException
 */
public void publish(String topic,Object message,Integer qos,boolean retain) throws MqttException, IllegalActionException {
  byte[] payload;
  if (_rawBytes) {
    payload=_toJavaBytes(message);
  }
 else {
    payload=((String)message).getBytes(StandardCharsets.UTF_8);
  }
  MqttMessage mqttMessage=new MqttMessage(payload);
  mqttMessage.setQos(qos);
  mqttMessage.setRetained(retain);
  _mqttClient.publish(topic,mqttMessage);
}"
72365,"/** 
 * Builds and starts the command in a process.
 * @return Returns true, if the process has started and the pipesare initialized.
 */
private boolean startProcess(){
  processBuilder=new ProcessBuilder(""String_Node_Str"",""String_Node_Str"",command);
  processBuilder.redirectErrorStream(true);
  processBuilder.redirectOutput(Redirect.PIPE);
  processBuilder.redirectInput(Redirect.PIPE);
  try {
    process=processBuilder.start();
  }
 catch (  IOException e) {
    e.printStackTrace();
    return false;
  }
  out=new BufferedWriter(new OutputStreamWriter(process.getOutputStream()));
  in=new BufferedReader(new InputStreamReader(process.getInputStream()));
  return true;
}","/** 
 * Builds and starts the command in a process.
 * @return Returns true, if the process has started and the pipesare initialized.
 */
private boolean startProcess(){
  processBuilder=new ProcessBuilder(""String_Node_Str"",""String_Node_Str"",command);
  processBuilder.redirectErrorStream(true);
  processBuilder.redirectOutput(Redirect.PIPE);
  processBuilder.redirectInput(Redirect.PIPE);
  try {
    process=processBuilder.start();
  }
 catch (  IOException e) {
    e.printStackTrace();
    return false;
  }
  out=new BufferedWriter(new OutputStreamWriter(process.getOutputStream()));
  in=new BufferedReader(new InputStreamReader(process.getInputStream(),StandardCharsets.UTF_8));
  return true;
}"
72366,"/** 
 * Generate ""Hello XBee World!"" on a XBee radio connected to a serial port. <p>To send data, the two radios need to be in api mode.  See <a href=""https://docs.digi.com/display/XBJLIB/Building+your+first+XBee+Java+application#in_browser"" target=""_top"">https://docs.digi.com/display/XBJLIB/Building+your+first+XBee+Java+application</a>.</p> <p>To list the ports, use:</p> <pre> java -classpath ${PTII}:${PTII}/lib/nrjavaserial-3.11.0.devel.jar:${PTII}/lib/xbjlib-1.1.0.nrjavaserial.jar:${PTII}/lib/slf4j-api-1.7.13.jar:${PTII}/lib/slf4j-nop-1.7.13.jar ptolemy.actor.lib.jjs.modules.xbee.test.XBeeHello </pre> <p>To send data on a port, append the port name:</p> <pre> java -classpath ${PTII}:${PTII}/lib/nrjavaserial-3.11.0.devel.jar:${PTII}/lib/xbjlib-1.1.0.nrjavaserial.jar:${PTII}/lib/slf4j-api-1.7.13.jar:${PTII}/lib/slf4j-nop-1.7.13.jar ptolemy.actor.lib.jjs.modules.xbee.test.XBeeHello /dev/xxyy </pre> <p>To send data on a port and get debugging:</p> <ul> <li> Set <code>-Dorg.slf4j.simpleLogger.defaultLogLevel=trace</code>. See <a href=""http://www.slf4j.org/apidocs/org/slf4j/impl/SimpleLogger.html#in_browser"" target=""_top"">http://www.slf4j.org/apidocs/org/slf4j/impl/SimpleLogger.html</a> for details.</li> <li> use slf4j-simple*.jar instead of slf4j-nop*.jar</li> <li> append the port name</li> </ul> <p>For example:</p> <pre> java -Dorg.slf4j.simpleLogger.defaultLogLevel=trace -classpath ${PTII}:${PTII}/lib/nrjavaserial-3.11.0.devel.jar:${PTII}/lib/xbjlib-1.1.0.nrjavaserial.jar:${PTII}/lib/slf4j-api-1.7.13.jar:${PTII}/lib/slf4j-simple-1.7.13.jar ptolemy.actor.lib.jjs.modules.xbee.test.XBeeHello /dev/tty.usbserial-DA01QZI2 </pre>
 */
public static void main(String[] args){
  if (args.length != 1) {
    System.err.println(""String_Node_Str"");
    System.err.println(""String_Node_Str"");
    Enumeration ports=CommPortIdentifier.getPortIdentifiers();
    while (ports.hasMoreElements()) {
      CommPortIdentifier identifier=(CommPortIdentifier)ports.nextElement();
      System.err.println(identifier.getName());
    }
    StringUtilities.exit(1);
  }
  int baudRate=9600;
  XBeeDevice xBeeDevice=new XBeeDevice(args[0],baudRate);
  String dataToSend=""String_Node_Str"";
  byte[] dataToSendBytes=dataToSend.getBytes();
  try {
    xBeeDevice.open();
    System.out.println(""String_Node_Str"" + dataToSend + ""String_Node_Str"");
    xBeeDevice.sendBroadcastData(dataToSendBytes);
    System.out.println(""String_Node_Str"");
  }
 catch (  Throwable throwable) {
    throwable.printStackTrace();
    StringUtilities.exit(1);
  }
 finally {
    xBeeDevice.close();
  }
}","/** 
 * Generate ""Hello XBee World!"" on a XBee radio connected to a serial port. <p>To send data, the two radios need to be in api mode.  See <a href=""https://docs.digi.com/display/XBJLIB/Building+your+first+XBee+Java+application#in_browser"" target=""_top"">https://docs.digi.com/display/XBJLIB/Building+your+first+XBee+Java+application</a>.</p> <p>To list the ports, use:</p> <pre> java -classpath ${PTII}:${PTII}/lib/nrjavaserial-3.11.0.devel.jar:${PTII}/lib/xbjlib-1.1.0.nrjavaserial.jar:${PTII}/lib/slf4j-api-1.7.13.jar:${PTII}/lib/slf4j-nop-1.7.13.jar ptolemy.actor.lib.jjs.modules.xbee.test.XBeeHello </pre> <p>To send data on a port, append the port name:</p> <pre> java -classpath ${PTII}:${PTII}/lib/nrjavaserial-3.11.0.devel.jar:${PTII}/lib/xbjlib-1.1.0.nrjavaserial.jar:${PTII}/lib/slf4j-api-1.7.13.jar:${PTII}/lib/slf4j-nop-1.7.13.jar ptolemy.actor.lib.jjs.modules.xbee.test.XBeeHello /dev/xxyy </pre> <p>To send data on a port and get debugging:</p> <ul> <li> Set <code>-Dorg.slf4j.simpleLogger.defaultLogLevel=trace</code>. See <a href=""http://www.slf4j.org/apidocs/org/slf4j/impl/SimpleLogger.html#in_browser"" target=""_top"">http://www.slf4j.org/apidocs/org/slf4j/impl/SimpleLogger.html</a> for details.</li> <li> use slf4j-simple*.jar instead of slf4j-nop*.jar</li> <li> append the port name</li> </ul> <p>For example:</p> <pre> java -Dorg.slf4j.simpleLogger.defaultLogLevel=trace -classpath ${PTII}:${PTII}/lib/nrjavaserial-3.11.0.devel.jar:${PTII}/lib/xbjlib-1.1.0.nrjavaserial.jar:${PTII}/lib/slf4j-api-1.7.13.jar:${PTII}/lib/slf4j-simple-1.7.13.jar ptolemy.actor.lib.jjs.modules.xbee.test.XBeeHello /dev/tty.usbserial-DA01QZI2 </pre>
 */
public static void main(String[] args){
  if (args.length != 1) {
    System.err.println(""String_Node_Str"");
    System.err.println(""String_Node_Str"");
    Enumeration ports=CommPortIdentifier.getPortIdentifiers();
    while (ports.hasMoreElements()) {
      CommPortIdentifier identifier=(CommPortIdentifier)ports.nextElement();
      System.err.println(identifier.getName());
    }
    StringUtilities.exit(1);
  }
  int baudRate=9600;
  XBeeDevice xBeeDevice=new XBeeDevice(args[0],baudRate);
  String dataToSend=""String_Node_Str"";
  byte[] dataToSendBytes=dataToSend.getBytes(StandardCharsets.UTF_8);
  try {
    xBeeDevice.open();
    System.out.println(""String_Node_Str"" + dataToSend + ""String_Node_Str"");
    xBeeDevice.sendBroadcastData(dataToSendBytes);
    System.out.println(""String_Node_Str"");
  }
 catch (  Throwable throwable) {
    throwable.printStackTrace();
    StringUtilities.exit(1);
  }
 finally {
    xBeeDevice.close();
  }
}"
72367,"/** 
 * Unsubscribe the associated JavaScript object as a subscriber to the specified address on the event bus.
 * @param address The address on the bus to unsubscribe to, or null tounsubscribe to all addresses.
 * @see #subscribe(String)
 */
public void unsubscribe(final String address){
  if (_subscriptions != null) {
    if (address == null) {
      for (      String toUnsubscribe : _subscriptions.keySet()) {
        MessageConsumer<String> messageConsumer=_subscriptions.get(toUnsubscribe);
        messageConsumer.unregister();
      }
      _subscriptions.clear();
    }
 else {
      MessageConsumer<String> messageConsumer=_subscriptions.get(address);
      if (messageConsumer != null) {
        messageConsumer.unregister();
        _subscriptions.remove(address);
      }
    }
  }
}","/** 
 * Unsubscribe the associated JavaScript object as a subscriber to the specified address on the event bus.
 * @param address The address on the bus to unsubscribe to, or null tounsubscribe to all addresses.
 * @see #subscribe(String)
 */
public void unsubscribe(final String address){
  if (_subscriptions != null) {
    if (address == null) {
      for (      Entry<String,MessageConsumer<String>> entry : _subscriptions.entrySet()) {
        MessageConsumer<String> messageConsumer=entry.getValue();
        messageConsumer.unregister();
      }
      _subscriptions.clear();
    }
 else {
      MessageConsumer<String> messageConsumer=_subscriptions.get(address);
      if (messageConsumer != null) {
        messageConsumer.unregister();
        _subscriptions.remove(address);
      }
    }
  }
}"
72368,"@SuppressWarnings(""String_Node_Str"") @Override public void run(){
  Map<String,Object> urlSpec=(Map<String,Object>)_options.get(""String_Node_Str"");
  HttpClient client=_vertx.createHttpClient(new HttpClientOptions().setDefaultHost((String)urlSpec.get(""String_Node_Str"")).setDefaultPort((int)urlSpec.get(""String_Node_Str"")).setKeepAlive((boolean)_options.get(""String_Node_Str"")).setConnectTimeout((Integer)_options.get(""String_Node_Str"")).setSsl(urlSpec.get(""String_Node_Str"").toString().equalsIgnoreCase(""String_Node_Str"")));
  String query=""String_Node_Str"";
  Object queryObject=urlSpec.get(""String_Node_Str"");
  if (queryObject != null) {
    String querySpec=queryObject.toString().trim();
    if (!querySpec.equals(""String_Node_Str"") && !querySpec.startsWith(""String_Node_Str"")) {
      query=""String_Node_Str"" + querySpec;
    }
  }
  String uri=urlSpec.get(""String_Node_Str"") + query;
  Object complete=_options.get(""String_Node_Str"");
  boolean outputCompleteResponseOnly=true;
  if (complete instanceof Boolean && !(Boolean)complete) {
    outputCompleteResponseOnly=false;
  }
  HttpMethod httpMethod=HttpMethod.valueOf(((String)_options.get(""String_Node_Str"")).trim().toUpperCase());
  HttpClientRequest request=client.request(httpMethod,uri,new HttpClientResponseHandler(_requestObj,client,outputCompleteResponseOnly,_requestNumber));
  request.setTimeout((Integer)_options.get(""String_Node_Str""));
  request.exceptionHandler(new HttpClientExceptionHandler(_requestObj,client,_requestNumber));
  Map<String,Object> headers=(Map<String,Object>)_options.get(""String_Node_Str"");
  boolean isImage=false;
  String imageType=""String_Node_Str"";
  if (!headers.isEmpty()) {
    for (    String key : headers.keySet()) {
      Object value=headers.get(key);
      if (key.equalsIgnoreCase(""String_Node_Str"") && ((String)value).startsWith(""String_Node_Str"")) {
        isImage=true;
        imageType=((String)value).substring(6);
      }
      if (value instanceof String) {
        request.putHeader((String)key,(String)value);
      }
 else       if (value instanceof Integer) {
        request.putHeader((String)key,((Integer)value).toString());
      }
 else       if (value instanceof Iterable) {
        request.putHeader((String)key,(Iterable<String>)value);
      }
    }
  }
  if (isImage) {
    AWTImageToken token=(AWTImageToken)_options.get(""String_Node_Str"");
    Image image=token.getValue();
    BufferedImage bufferedImage;
    if (image instanceof BufferedImage) {
      bufferedImage=(BufferedImage)image;
    }
 else {
      bufferedImage=new BufferedImage(image.getWidth(null),image.getHeight(null),BufferedImage.TYPE_INT_ARGB);
      Graphics2D bGr=bufferedImage.createGraphics();
      bGr.drawImage(image,0,0,null);
      bGr.dispose();
    }
    ByteArrayOutputStream os=new ByteArrayOutputStream();
    try {
      ImageIO.write(bufferedImage,imageType,os);
      request.putHeader(""String_Node_Str"",Integer.toString(os.toByteArray().length));
      request.write(Buffer.buffer(os.toByteArray()));
    }
 catch (    IOException e) {
      String message=""String_Node_Str"" + e.toString();
      _error(_requestObj,message);
    }
  }
 else {
    Object bodyObject=_options.get(""String_Node_Str"");
    if (bodyObject != null) {
      String body=bodyObject.toString();
      if (body != null) {
        request.putHeader(""String_Node_Str"",Integer.toString(body.length()));
        request.write(body);
      }
    }
  }
  request.end();
}","@SuppressWarnings(""String_Node_Str"") @Override public void run(){
  Map<String,Object> urlSpec=(Map<String,Object>)_options.get(""String_Node_Str"");
  HttpClient client=_vertx.createHttpClient(new HttpClientOptions().setDefaultHost((String)urlSpec.get(""String_Node_Str"")).setDefaultPort((int)urlSpec.get(""String_Node_Str"")).setKeepAlive((boolean)_options.get(""String_Node_Str"")).setConnectTimeout((Integer)_options.get(""String_Node_Str"")).setSsl(urlSpec.get(""String_Node_Str"").toString().equalsIgnoreCase(""String_Node_Str"")));
  String query=""String_Node_Str"";
  Object queryObject=urlSpec.get(""String_Node_Str"");
  if (queryObject != null) {
    String querySpec=queryObject.toString().trim();
    if (!querySpec.equals(""String_Node_Str"") && !querySpec.startsWith(""String_Node_Str"")) {
      query=""String_Node_Str"" + querySpec;
    }
  }
  String uri=urlSpec.get(""String_Node_Str"") + query;
  Object complete=_options.get(""String_Node_Str"");
  boolean outputCompleteResponseOnly=true;
  if (complete instanceof Boolean && !(Boolean)complete) {
    outputCompleteResponseOnly=false;
  }
  HttpMethod httpMethod=HttpMethod.valueOf(((String)_options.get(""String_Node_Str"")).trim().toUpperCase());
  HttpClientRequest request=client.request(httpMethod,uri,new HttpClientResponseHandler(_requestObj,client,outputCompleteResponseOnly,_requestNumber));
  request.setTimeout((Integer)_options.get(""String_Node_Str""));
  request.exceptionHandler(new HttpClientExceptionHandler(_requestObj,client,_requestNumber));
  Map<String,Object> headers=(Map<String,Object>)_options.get(""String_Node_Str"");
  boolean isImage=false;
  String imageType=""String_Node_Str"";
  if (!headers.isEmpty()) {
    for (    Entry<String,Object> entry : headers.entrySet()) {
      String key=entry.getKey();
      Object value=entry.getValue();
      if (key.equalsIgnoreCase(""String_Node_Str"") && ((String)value).startsWith(""String_Node_Str"")) {
        isImage=true;
        imageType=((String)value).substring(6);
      }
      if (value instanceof String) {
        request.putHeader((String)key,(String)value);
      }
 else       if (value instanceof Integer) {
        request.putHeader((String)key,((Integer)value).toString());
      }
 else       if (value instanceof Iterable) {
        request.putHeader((String)key,(Iterable<String>)value);
      }
    }
  }
  if (isImage) {
    AWTImageToken token=(AWTImageToken)_options.get(""String_Node_Str"");
    Image image=token.getValue();
    BufferedImage bufferedImage;
    if (image instanceof BufferedImage) {
      bufferedImage=(BufferedImage)image;
    }
 else {
      bufferedImage=new BufferedImage(image.getWidth(null),image.getHeight(null),BufferedImage.TYPE_INT_ARGB);
      Graphics2D bGr=bufferedImage.createGraphics();
      bGr.drawImage(image,0,0,null);
      bGr.dispose();
    }
    ByteArrayOutputStream os=new ByteArrayOutputStream();
    try {
      ImageIO.write(bufferedImage,imageType,os);
      request.putHeader(""String_Node_Str"",Integer.toString(os.toByteArray().length));
      request.write(Buffer.buffer(os.toByteArray()));
    }
 catch (    IOException e) {
      String message=""String_Node_Str"" + e.toString();
      _error(_requestObj,message);
    }
  }
 else {
    Object bodyObject=_options.get(""String_Node_Str"");
    if (bodyObject != null) {
      String body=bodyObject.toString();
      if (body != null) {
        request.putHeader(""String_Node_Str"",Integer.toString(body.length()));
        request.write(body);
      }
    }
  }
  request.end();
}"
72369,"/** 
 * Create a new input port if it does not already exist. The options argument can specify a ""type"", a ""description"", and/or a ""value"". If a type is given, and neither the port nor its corresponding parameter contain a TypeAttribute, then set the type as specified. Otherwise, leave the type unspecified so that it will be inferred. If a description is given, then create, append to, or modify the DocAttribute named ""documentation"" contained by this actor to include documentation of this output. If a value is given, then create a PortParameter instead of an ordinary port and set its default value, unless it already has a value that overrides the default. In that case, the prior value will be returned. Otherwise, null will be returned. If a Parameter already exists with the same name, then convert it to a PortParameter and preserve and return its value. The options can also include a field ""visibility"" with one of the values ""none"", ""expert"", ""noteditable"" or ""full"" (the default). This is a hint to restrict visibility that a user has of the port.
 * @param name The name of the port.
 * @param options The options, or null to accept the defaults.To give options, this argument must implement the Map interface.
 * @return The previous value of this input, if it has one, andnull otherwise.
 * @exception IllegalActionException If no name is given.
 * @exception NameDuplicationException If the name is a reserved word.
 */
public Token input(String name,Map<String,Object> options) throws IllegalActionException, NameDuplicationException {
  if (name == null) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  TypedIOPort port=(TypedIOPort)getPort(name);
  PortParameter parameter=null;
  Object token=null;
  Token previousValue=null;
  String previousExpression=""String_Node_Str"";
  boolean deletedPriorParameter=false;
  if (port == null) {
    Attribute previous=getAttribute(name);
    if (previous instanceof Parameter) {
      previousValue=((Parameter)previous).getToken();
      if (previousValue instanceof StringToken && ((StringToken)previousValue).stringValue().trim().equals(""String_Node_Str"")) {
        previousValue=null;
      }
      previous.setContainer(null);
      deletedPriorParameter=true;
    }
    if (options == null) {
      if (previousValue == null) {
        port=(TypedIOPort)newPort(name);
      }
 else {
        parameter=new PortParameter(this,name);
        port=parameter.getPort();
      }
    }
 else {
      Object value=((Map<String,Object>)options).get(""String_Node_Str"");
      if (value == null && previousValue == null) {
        port=(TypedIOPort)newPort(name);
      }
 else {
        parameter=new PortParameter(this,name);
        port=parameter.getPort();
      }
    }
  }
 else {
    if (port == script.getPort() || port == error) {
      throw new NameDuplicationException(this,""String_Node_Str"" + name);
    }
    if (port instanceof ParameterPort) {
      parameter=((ParameterPort)port).getParameter();
      ((PortParameter)parameter).initialize();
      previousValue=parameter.getToken();
      previousExpression=parameter.getExpression();
    }
 else {
      if (options != null) {
        Object value=((Map<String,Object>)options).get(""String_Node_Str"");
        if (value != null) {
          port.setContainer(null);
          parameter=new PortParameter(this,name);
          port=parameter.getPort();
        }
      }
    }
  }
  if (options instanceof Map) {
    if (port.attributeList(TypeAttribute.class).isEmpty() && (parameter == null || parameter.attributeList(TypeAttribute.class).isEmpty())) {
      Object type=((Map<String,Object>)options).get(""String_Node_Str"");
      if (type instanceof String) {
        Type ptType=_typeAccessorToPtolemy((String)type,port);
        port.setTypeEquals(ptType);
        if (parameter != null) {
          parameter.setTypeEquals(ptType);
        }
      }
 else       if (type != null) {
        throw new IllegalActionException(this,""String_Node_Str"" + type);
      }
    }
    _setOptionsForSelect(port,options);
    Object description=((Map<String,Object>)options).get(""String_Node_Str"");
    if (description != null) {
      _setPortDescription(port,description.toString());
    }
    Object value=((Map<String,Object>)options).get(""String_Node_Str"");
    if (value != null) {
      try {
        token=((Invocable)_engine).invokeFunction(""String_Node_Str"",value);
      }
 catch (      Exception e) {
        throw new IllegalActionException(this,e,""String_Node_Str"" + value);
      }
      if (!(token instanceof Token)) {
        throw new IllegalActionException(this,""String_Node_Str"" + value);
      }
    }
    _setPortVisibility(options,port,parameter);
  }
  Token result=null;
  if (parameter != null) {
    if (token != null && !parameter.isOverridden()) {
      if (parameter.getAttribute(""String_Node_Str"") != null && !(token instanceof StringToken)) {
        String json=TokenToJSON.constructJSON((Token)token);
        token=new StringToken(json);
      }
      parameter.setToken((Token)token);
      parameter.setDerivedLevel(1);
    }
    if (parameter.isOverridden()) {
      result=previousValue;
    }
    if (deletedPriorParameter && previousValue != null) {
      parameter.setExpression(previousExpression);
    }
  }
  port.setInput(true);
  return result;
}","/** 
 * Create a new input port if it does not already exist. The options argument can specify a ""type"", a ""description"", and/or a ""value"". If a type is given, and neither the port nor its corresponding parameter contain a TypeAttribute, then set the type as specified. Otherwise, leave the type unspecified so that it will be inferred. If a description is given, then create, append to, or modify the DocAttribute named ""documentation"" contained by this actor to include documentation of this output. If a value is given, then create a PortParameter instead of an ordinary port and set its default value, unless it already has a value that overrides the default. In that case, the prior value will be returned. Otherwise, null will be returned. If a Parameter already exists with the same name, then convert it to a PortParameter and preserve and return its value. The options can also include a field ""visibility"" with one of the values ""none"", ""expert"", ""noteditable"" or ""full"" (the default). This is a hint to restrict visibility that a user has of the port.
 * @param name The name of the port.
 * @param options The options, or null to accept the defaults.To give options, this argument must implement the Map interface.
 * @return The previous value of this input, if it has one, andnull otherwise.
 * @exception IllegalActionException If no name is given.
 * @exception NameDuplicationException If the name is a reserved word.
 */
public Token input(String name,Map<String,Object> options) throws IllegalActionException, NameDuplicationException {
  if (name == null) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  TypedIOPort port=(TypedIOPort)getPort(name);
  PortParameter parameter=null;
  Object token=null;
  Token previousValue=null;
  String previousExpression=""String_Node_Str"";
  boolean deletedPriorParameter=false;
  if (port == null) {
    Attribute previous=getAttribute(name);
    if (previous instanceof Parameter) {
      previousValue=((Parameter)previous).getToken();
      if (previousValue instanceof StringToken && ((StringToken)previousValue).stringValue().trim().equals(""String_Node_Str"")) {
        previousValue=null;
      }
      previous.setContainer(null);
      deletedPriorParameter=true;
    }
    if (options == null) {
      if (previousValue == null) {
        port=(TypedIOPort)newPort(name);
      }
 else {
        parameter=new PortParameter(this,name);
        port=parameter.getPort();
      }
    }
 else {
      Object value=((Map<String,Object>)options).get(""String_Node_Str"");
      if (value == null && previousValue == null) {
        port=(TypedIOPort)newPort(name);
      }
 else {
        parameter=new PortParameter(this,name);
        port=parameter.getPort();
      }
    }
  }
 else {
    if (port == script.getPort() || port == error) {
      throw new NameDuplicationException(this,""String_Node_Str"" + name);
    }
    if (port instanceof ParameterPort) {
      parameter=((ParameterPort)port).getParameter();
      ((PortParameter)parameter).initialize();
      previousValue=parameter.getToken();
      previousExpression=parameter.getExpression();
    }
 else {
      if (options != null) {
        Object value=((Map<String,Object>)options).get(""String_Node_Str"");
        if (value != null) {
          port.setContainer(null);
          parameter=new PortParameter(this,name);
          port=parameter.getPort();
        }
      }
    }
  }
  if (options != null) {
    if (port.attributeList(TypeAttribute.class).isEmpty() && (parameter == null || parameter.attributeList(TypeAttribute.class).isEmpty())) {
      Object type=((Map<String,Object>)options).get(""String_Node_Str"");
      if (type instanceof String) {
        Type ptType=_typeAccessorToPtolemy((String)type,port);
        port.setTypeEquals(ptType);
        if (parameter != null) {
          parameter.setTypeEquals(ptType);
        }
      }
 else       if (type != null) {
        throw new IllegalActionException(this,""String_Node_Str"" + type);
      }
    }
    _setOptionsForSelect(port,options);
    Object description=((Map<String,Object>)options).get(""String_Node_Str"");
    if (description != null) {
      _setPortDescription(port,description.toString());
    }
    Object value=((Map<String,Object>)options).get(""String_Node_Str"");
    if (value != null) {
      try {
        token=((Invocable)_engine).invokeFunction(""String_Node_Str"",value);
      }
 catch (      Exception e) {
        throw new IllegalActionException(this,e,""String_Node_Str"" + value);
      }
      if (!(token instanceof Token)) {
        throw new IllegalActionException(this,""String_Node_Str"" + value);
      }
    }
    _setPortVisibility(options,port,parameter);
  }
  Token result=null;
  if (parameter != null) {
    if (token != null && !parameter.isOverridden()) {
      if (parameter.getAttribute(""String_Node_Str"") != null && !(token instanceof StringToken)) {
        String json=TokenToJSON.constructJSON((Token)token);
        token=new StringToken(json);
      }
      parameter.setToken((Token)token);
      parameter.setDerivedLevel(1);
    }
    if (parameter.isOverridden()) {
      result=previousValue;
    }
    if (deletedPriorParameter && previousValue != null) {
      parameter.setExpression(previousExpression);
    }
  }
  port.setInput(true);
  return result;
}"
72370,"/** 
 * Invoke the specified function after the specified amount of time and again at multiples of that time. The time will be added to the current time of the director, and fireAt() request will be made of the director. If the director cannot fulfill the request, this method will throw an exception. Note that if you want real-time behavior, then the director's synchronizeToRealTime parameter needs to be set to true.
 * @param function The function to invoke.
 * @param milliseconds The number of milliseconds in the future to invoke it.
 * @return A unique ID for this callback.
 * @exception IllegalActionException If the director cannot respect the request.
 * @see #clearTimeout(Object)
 */
@Override public synchronized Object setInterval(final Runnable function,final int milliseconds) throws IllegalActionException {
  final Integer id=Integer.valueOf(_timeoutCount++);
  final Runnable reschedulingFunction=new Runnable(){
    @Override public void run(){
      _runThenReschedule(function,milliseconds,id);
    }
  }
;
  _setTimeout(reschedulingFunction,milliseconds,id);
  return new Integer(id);
}","/** 
 * Invoke the specified function after the specified amount of time and again at multiples of that time. The time will be added to the current time of the director, and fireAt() request will be made of the director. If the director cannot fulfill the request, this method will throw an exception. Note that if you want real-time behavior, then the director's synchronizeToRealTime parameter needs to be set to true.
 * @param function The function to invoke.
 * @param milliseconds The number of milliseconds in the future to invoke it.
 * @return A unique ID for this callback.
 * @exception IllegalActionException If the director cannot respect the request.
 * @see #clearTimeout(Object)
 */
@Override public synchronized Object setInterval(final Runnable function,final int milliseconds) throws IllegalActionException {
  final Integer id=Integer.valueOf(_timeoutCount++);
  final Runnable reschedulingFunction=new Runnable(){
    @Override public void run(){
      _runThenReschedule(function,milliseconds,id);
    }
  }
;
  _setTimeout(reschedulingFunction,milliseconds,id);
  return Integer.valueOf(id);
}"
72371,"/** 
 * Invoke the specified function after the specified amount of time. The time will be added to the current time of the director, and fireAt() request will be made of the director. If the director cannot fulfill the request, this method will throw an exception. Note that if you want real-time behavior, then the director's synchronizeToRealTime parameter needs to be set to true.
 * @param function The function to invoke.
 * @param milliseconds The number of milliseconds in the future to invoke it.
 * @return A unique ID for this callback.
 * @exception IllegalActionException If the director cannot respect the request.
 * @see #clearTimeout(Object)
 */
@Override public synchronized Object setTimeout(final Runnable function,final int milliseconds) throws IllegalActionException {
  final Integer id=Integer.valueOf(_timeoutCount++);
  _setTimeout(function,milliseconds,id);
  return new Integer(id);
}","/** 
 * Invoke the specified function after the specified amount of time. The time will be added to the current time of the director, and fireAt() request will be made of the director. If the director cannot fulfill the request, this method will throw an exception. Note that if you want real-time behavior, then the director's synchronizeToRealTime parameter needs to be set to true.
 * @param function The function to invoke.
 * @param milliseconds The number of milliseconds in the future to invoke it.
 * @return A unique ID for this callback.
 * @exception IllegalActionException If the director cannot respect the request.
 * @see #clearTimeout(Object)
 */
@Override public synchronized Object setTimeout(final Runnable function,final int milliseconds) throws IllegalActionException {
  final Integer id=Integer.valueOf(_timeoutCount++);
  _setTimeout(function,milliseconds,id);
  return Integer.valueOf(id);
}"
72372,"/** 
 * Convert the buffer to a message depending on the specified receive type and emit a 'message' event.
 * @param buffer The buffer containing the message.
 */
protected void _emitMessage(Buffer buffer){
  if (_receiveType == DATA_TYPE.STRING) {
    _currentObj.callMember(""String_Node_Str"",""String_Node_Str"",buffer.getString(0,buffer.length()));
  }
 else   if (_receiveType == DATA_TYPE.IMAGE) {
    try {
      byte[] bytes=buffer.getBytes();
      ByteArrayBackedInputStream byteStream=new ByteArrayBackedInputStream(bytes);
      BufferedImage image=ImageIO.read(byteStream);
      if (image != null && image.getHeight() > 0 && image.getWidth() > 0) {
        ImageToken token=new AWTImageToken(image);
        _currentObj.callMember(""String_Node_Str"",""String_Node_Str"",token);
      }
 else {
        _error(_currentObj,""String_Node_Str"");
      }
    }
 catch (    IOException e) {
      _error(_currentObj,""String_Node_Str"" + e.toString());
    }
  }
 else {
    int size=_sizeOfType(_receiveType);
    if (size == 0) {
      _error(_currentObj,""String_Node_Str"" + _receiveType + ""String_Node_Str"");
    }
 else {
      int length=buffer.length();
      int numberOfElements=length / size;
      if (numberOfElements == 1) {
        _currentObj.callMember(""String_Node_Str"",""String_Node_Str"",_extractFromBuffer(buffer,_receiveType,0));
      }
 else       if (numberOfElements > 1) {
        Object[] result=new Object[numberOfElements];
        int position=0;
        for (int i=0; i < result.length; i++) {
          result[i]=_extractFromBuffer(buffer,_receiveType,position);
          position+=size;
        }
        try {
          _currentObj.callMember(""String_Node_Str"",""String_Node_Str"",_actor.toJSArray(result));
        }
 catch (        Exception e) {
          _error(_currentObj,""String_Node_Str"" + e);
          _currentObj.callMember(""String_Node_Str"",""String_Node_Str"",result);
        }
      }
 else       if (numberOfElements <= 0) {
        _error(_currentObj,""String_Node_Str"" + _receiveType + ""String_Node_Str""+ buffer.length());
      }
    }
  }
}","/** 
 * Convert the buffer to a message depending on the specified receive type and emit a 'message' event.
 * @param buffer The buffer containing the message.
 */
protected void _emitMessage(Buffer buffer){
  if (_receiveType == DATA_TYPE.STRING) {
    _currentObj.callMember(""String_Node_Str"",""String_Node_Str"",buffer.getString(0,buffer.length()));
  }
 else   if (_receiveType == DATA_TYPE.IMAGE) {
    try {
      byte[] bytes=buffer.getBytes();
      ByteArrayBackedInputStream byteStream=new ByteArrayBackedInputStream(bytes);
      BufferedImage image=ImageIO.read(byteStream);
      if (image != null && image.getHeight() > 0 && image.getWidth() > 0) {
        ImageToken token=new AWTImageToken(image);
        _currentObj.callMember(""String_Node_Str"",""String_Node_Str"",token);
      }
 else {
        _error(_currentObj,""String_Node_Str"");
      }
    }
 catch (    IOException e) {
      _error(_currentObj,""String_Node_Str"" + e.toString());
    }
  }
 else {
    int size=_sizeOfType(_receiveType);
    if (size == 0) {
      _error(_currentObj,""String_Node_Str"" + _receiveType + ""String_Node_Str"");
    }
 else {
      int length=buffer.length();
      int numberOfElements=length / size;
      if (numberOfElements == 1) {
        _currentObj.callMember(""String_Node_Str"",""String_Node_Str"",_extractFromBuffer(buffer,_receiveType,0));
      }
 else       if (numberOfElements > 1) {
        Object[] result=new Object[numberOfElements];
        int position=0;
        for (int i=0; i < result.length; i++) {
          result[i]=_extractFromBuffer(buffer,_receiveType,position);
          position+=size;
        }
        try {
          _currentObj.callMember(""String_Node_Str"",""String_Node_Str"",_actor.toJSArray(result));
        }
 catch (        Exception e) {
          _error(_currentObj,""String_Node_Str"" + e);
          _currentObj.callMember(""String_Node_Str"",""String_Node_Str"",result);
        }
      }
 else {
        _error(_currentObj,""String_Node_Str"" + _receiveType + ""String_Node_Str""+ buffer.length());
      }
    }
  }
}"
72373,"@Override public void dataReceived(XBeeMessage message){
  if (_receiveType == DATA_TYPE.STRING) {
    _currentObj.callMember(""String_Node_Str"",""String_Node_Str"",message.getDataString());
  }
 else {
    Buffer buffer=Buffer.buffer(message.getData());
    int size=_sizeOfType(_receiveType);
    int length=buffer.length();
    int numberOfElements=0;
    if (size > 0) {
      numberOfElements=length / size;
    }
    if (numberOfElements == 1) {
      _currentObj.callMember(""String_Node_Str"",""String_Node_Str"",_extractFromBuffer(buffer,_receiveType,0));
    }
 else     if (numberOfElements > 1) {
      Object[] result=new Object[numberOfElements];
      int position=0;
      for (int i=0; i < result.length; i++) {
        result[i]=_extractFromBuffer(buffer,_receiveType,position);
        position+=size;
      }
      try {
        _currentObj.callMember(""String_Node_Str"",""String_Node_Str"",_actor.toJSArray(result));
      }
 catch (      Exception e) {
        _error(""String_Node_Str"" + e);
        _currentObj.callMember(""String_Node_Str"",""String_Node_Str"",result);
      }
    }
 else     if (numberOfElements <= 0) {
      _error(""String_Node_Str"" + _receiveType + ""String_Node_Str""+ size+ ""String_Node_Str""+ buffer.length());
    }
  }
}","@Override public void dataReceived(XBeeMessage message){
  if (_receiveType == DATA_TYPE.STRING) {
    _currentObj.callMember(""String_Node_Str"",""String_Node_Str"",message.getDataString());
  }
 else {
    Buffer buffer=Buffer.buffer(message.getData());
    int size=_sizeOfType(_receiveType);
    int length=buffer.length();
    int numberOfElements=0;
    if (size > 0) {
      numberOfElements=length / size;
    }
    if (numberOfElements == 1) {
      _currentObj.callMember(""String_Node_Str"",""String_Node_Str"",_extractFromBuffer(buffer,_receiveType,0));
    }
 else     if (numberOfElements > 1) {
      Object[] result=new Object[numberOfElements];
      int position=0;
      for (int i=0; i < result.length; i++) {
        result[i]=_extractFromBuffer(buffer,_receiveType,position);
        position+=size;
      }
      try {
        _currentObj.callMember(""String_Node_Str"",""String_Node_Str"",_actor.toJSArray(result));
      }
 catch (      Exception e) {
        _error(""String_Node_Str"" + e);
        _currentObj.callMember(""String_Node_Str"",""String_Node_Str"",result);
      }
    }
 else {
      _error(""String_Node_Str"" + _receiveType + ""String_Node_Str""+ size+ ""String_Node_Str""+ buffer.length());
    }
  }
}"
72374,"/** 
 * Write the RAV information. 
 */
public void writeRAVsInformations(){
  if (_numberOfRAVs > 0) {
    StringBuffer header=new StringBuffer(""String_Node_Str"");
    int count=_RAVsValues[0].toString().split(""String_Node_Str"").length;
    for (int i=0; i < count; i++) {
      header.append(""String_Node_Str"" + i + ""String_Node_Str"");
    }
    StringBuffer info=new StringBuffer(_date.toString() + ""String_Node_Str"" + header+ ""String_Node_Str""+ _hlaLookAHead+ ""String_Node_Str""+ _hlaTimeStep+ ""String_Node_Str""+ _stopTime+ ""String_Node_Str""+ ""String_Node_Str""+ _pRAVsTimes+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ _folRAVsTimes+ ""String_Node_Str"");
    for (int i=0; i < _numberOfAttributesSubscribedTo; i++) {
      info.append(""String_Node_Str"" + _nameOfTheAttributesSubscribedTo[i] + ""String_Node_Str""+ _RAVsValues[i]+ ""String_Node_Str"");
    }
    _RAVsValuesFile=_createTextFile(""String_Node_Str"" + getDisplayName() + ""String_Node_Str"");
    writeInTextFile(_RAVsValuesFile,String.valueOf(info));
  }
}","/** 
 * Write the RAV information. 
 */
public void writeRAVsInformations(){
  if (_numberOfRAVs > 0) {
    StringBuffer header=new StringBuffer(""String_Node_Str"");
    int count=_RAVsValues[0].toString().split(""String_Node_Str"").length;
    for (int i=0; i < count; i++) {
      header.append(""String_Node_Str"" + i + ""String_Node_Str"");
    }
    StringBuffer info=new StringBuffer(_date.toString() + ""String_Node_Str"" + header+ ""String_Node_Str""+ _hlaLookAHead+ ""String_Node_Str""+ _hlaTimeStep+ ""String_Node_Str""+ _stopTime+ ""String_Node_Str""+ ""String_Node_Str""+ _pRAVsTimes+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ _folRAVsTimes+ ""String_Node_Str"");
    for (int i=0; i < _numberOfAttributesSubscribedTo; i++) {
      info.append(""String_Node_Str"" + _nameOfTheAttributesSubscribedTo[i] + ""String_Node_Str""+ _RAVsValues[i]+ ""String_Node_Str"");
    }
    _RAVsValuesFile=_createTextFile(""String_Node_Str"" + _federateName + ""String_Node_Str"");
    writeInTextFile(_RAVsValuesFile,String.valueOf(info));
  }
}"
72375,"/** 
 * Write the UAV information. 
 */
public void writeUAVsInformations(){
  if (_numberOfUAVs > 0) {
    StringBuffer header=new StringBuffer(""String_Node_Str"");
    int count=String.valueOf(_UAVsValues[0]).split(""String_Node_Str"").length;
    for (int i=0; i < count; i++) {
      header.append(""String_Node_Str"" + i + ""String_Node_Str"");
    }
    StringBuffer info=new StringBuffer(_date.toString() + ""String_Node_Str"" + header+ ""String_Node_Str""+ _hlaLookAHead+ ""String_Node_Str""+ _hlaTimeStep+ ""String_Node_Str""+ _stopTime+ ""String_Node_Str""+ ""String_Node_Str""+ _preUAVsTimes+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ _pUAVsTimes+ ""String_Node_Str"");
    for (int i=0; i < _numberOfAttributesToPublish; i++) {
      info.append(""String_Node_Str"" + _nameOfTheAttributesToPublish[i] + ""String_Node_Str""+ _UAVsValues[i]+ ""String_Node_Str"");
    }
    _UAVsValuesFile=_createTextFile(""String_Node_Str"" + getDisplayName() + ""String_Node_Str"");
    writeInTextFile(_UAVsValuesFile,String.valueOf(info));
  }
}","/** 
 * Write the UAV information. 
 */
public void writeUAVsInformations(){
  if (_numberOfUAVs > 0) {
    StringBuffer header=new StringBuffer(""String_Node_Str"");
    int count=String.valueOf(_UAVsValues[0]).split(""String_Node_Str"").length;
    for (int i=0; i < count; i++) {
      header.append(""String_Node_Str"" + i + ""String_Node_Str"");
    }
    StringBuffer info=new StringBuffer(_date.toString() + ""String_Node_Str"" + header+ ""String_Node_Str""+ _hlaLookAHead+ ""String_Node_Str""+ _hlaTimeStep+ ""String_Node_Str""+ _stopTime+ ""String_Node_Str""+ ""String_Node_Str""+ _preUAVsTimes+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ _pUAVsTimes+ ""String_Node_Str"");
    for (int i=0; i < _numberOfAttributesToPublish; i++) {
      info.append(""String_Node_Str"" + _nameOfTheAttributesToPublish[i] + ""String_Node_Str""+ _UAVsValues[i]+ ""String_Node_Str"");
    }
    _UAVsValuesFile=_createTextFile(""String_Node_Str"" + _federateName + ""String_Node_Str"");
    writeInTextFile(_UAVsValuesFile,String.valueOf(info));
  }
}"
72376,"/** 
 * Write information in a txt file.
 * @param data The information you want to write.
 * @param file The file in which you want to write.
 * @return Return true if the information was successfully written in the file.
 */
public boolean writeInTextFile(File file,String data){
  boolean noExceptionOccured=true;
  BufferedWriter writer=null;
  try {
    writer=new BufferedWriter(new FileWriter(file));
    writer.write(data);
    writer.newLine();
    writer.flush();
  }
 catch (  Exception e) {
    noExceptionOccured=false;
  }
 finally {
    if (writer != null) {
      try {
        writer.close();
      }
 catch (      IOException e) {
        System.out.println(""String_Node_Str"");
      }
    }
  }
  return noExceptionOccured;
}","/** 
 * Write information in a txt file.
 * @param data The information you want to write.
 * @param file The file in which you want to write.
 * @return Return true if the information was successfully written in the file.
 */
public boolean writeInTextFile(File file,String data){
  boolean noExceptionOccured=true;
  BufferedWriter writer=null;
  try {
    writer=new BufferedWriter(new FileWriter(file,true));
    writer.write(data);
    writer.newLine();
    writer.flush();
  }
 catch (  Exception e) {
    noExceptionOccured=false;
  }
 finally {
    if (writer != null) {
      try {
        writer.close();
      }
 catch (      IOException e) {
        System.out.println(""String_Node_Str"");
      }
    }
  }
  return noExceptionOccured;
}"
72377,"/** 
 * Get the MAC (Media Access Control) address of the first non-loopback, non-multicast address.
 * @return the MAC address
 * @exception SocketException If thrown while finding the address.
 */
public String getMacAddress() throws SocketException {
  InetAddress address=_getUsefulAddress();
  NetworkInterface networkInterface=NetworkInterface.getByInetAddress(address);
  byte[] macAddress=networkInterface.getHardwareAddress();
  StringBuffer buffer=new StringBuffer();
  for (int i=0; i < macAddress.length; i++) {
    buffer.append(String.format(""String_Node_Str"",macAddress[i],(i < macAddress.length - 1) ? ""String_Node_Str"" : ""String_Node_Str""));
  }
  return macAddress.toString();
}","/** 
 * Get the MAC (Media Access Control) address of the first non-loopback, non-multicast address.
 * @return the MAC address
 * @exception SocketException If thrown while finding the address.
 */
public String getMacAddress() throws SocketException {
  InetAddress address=_getUsefulAddress();
  NetworkInterface networkInterface=NetworkInterface.getByInetAddress(address);
  byte[] macAddress=networkInterface.getHardwareAddress();
  StringBuffer buffer=new StringBuffer();
  for (int i=0; i < macAddress.length; i++) {
    buffer.append(String.format(""String_Node_Str"",macAddress[i],(i < macAddress.length - 1) ? ""String_Node_Str"" : ""String_Node_Str""));
  }
  return buffer.toString();
}"
72378,"/** 
 * Execute the nmap command.  Nmap finds IP addresses, names and MAC addresses on the local area network.  The nmap program requires separate installation on Mac and Windows; please see: https://nmap.org/
 * @param baseIP The IP address of the host minus the subnet portion.
 */
private void _nmap(String baseIP){
  try {
    String command=_nmapCommand + baseIP + ""String_Node_Str"";
    if (_debugging) {
      System.out.println(""String_Node_Str"" + command);
    }
    Process process=Runtime.getRuntime().exec(command);
    BufferedReader stdOut=null;
    try {
      stdOut=new BufferedReader(new InputStreamReader(process.getInputStream()));
      String line;
      while ((line=stdOut.readLine()) != null) {
        if (line.startsWith(""String_Node_Str"")) {
          _readDeviceNmap(line,stdOut);
        }
      }
    }
  finally {
      if (stdOut != null) {
        stdOut.close();
      }
    }
  }
 catch (  IOException e) {
    System.err.println(""String_Node_Str"" + _nmapCommand);
  }
}","/** 
 * Execute the nmap command.  Nmap finds IP addresses, names and MAC addresses on the local area network.  The nmap program requires separate installation on Mac and Windows; please see: https://nmap.org/
 * @param baseIP The IP address of the host minus the subnet portion.
 */
private void _nmap(String baseIP){
  try {
    String command=_nmapCommand + baseIP + ""String_Node_Str"";
    if (_debugging) {
      System.out.println(""String_Node_Str"" + command);
    }
    Process process=Runtime.getRuntime().exec(command);
    BufferedReader stdOut=null;
    try {
      stdOut=new BufferedReader(new InputStreamReader(process.getInputStream(),""String_Node_Str""));
      String line;
      while ((line=stdOut.readLine()) != null) {
        if (line.startsWith(""String_Node_Str"")) {
          _readDeviceNmap(line,stdOut);
        }
      }
    }
  finally {
      if (stdOut != null) {
        stdOut.close();
      }
    }
  }
 catch (  IOException e) {
    System.err.println(""String_Node_Str"" + _nmapCommand);
  }
}"
72379,"/** 
 * Execute the arp command on a Windows platform.  The arp command finds MAC addresses for devices on the local area network. The arp command should follow a ping sweep to get the most up-to-date information and to screen out devices that are not accessible at the moment (which may be cached in the arp cache).
 */
private void _arpWindows(){
  if (_ipMap.size() == 0) {
    System.err.println(""String_Node_Str"" + _pingWindowsCommand + ""String_Node_Str"");
  }
  try {
    Process process=Runtime.getRuntime().exec(_arpCommand);
    BufferedReader stdOut=null;
    try {
      stdOut=new BufferedReader(new InputStreamReader(process.getInputStream()));
      String line;
      int index;
      JSONObject object;
      while ((line=stdOut.readLine()) != null) {
        for (        String key : _ipMap.keySet()) {
          object=_ipMap.get(key);
          index=line.indexOf(object.getString(""String_Node_Str""));
          if (index != -1) {
            if (index != 2) {
              object.put(""String_Node_Str"",""String_Node_Str"");
            }
 else {
              object.put(""String_Node_Str"",line.substring(index + 22,index + 39));
            }
            _ipMap.put(key,object);
          }
        }
      }
    }
  finally {
      if (stdOut != null) {
        stdOut.close();
      }
    }
  }
 catch (  IOException e) {
    System.err.println(""String_Node_Str"" + _arpCommand);
  }
catch (  JSONException e2) {
    System.err.println(""String_Node_Str"");
  }
}","/** 
 * Execute the arp command on a Windows platform.  The arp command finds MAC addresses for devices on the local area network. The arp command should follow a ping sweep to get the most up-to-date information and to screen out devices that are not accessible at the moment (which may be cached in the arp cache).
 */
private void _arpWindows(){
  if (_ipMap.size() == 0) {
    System.err.println(""String_Node_Str"" + _pingWindowsCommand + ""String_Node_Str"");
  }
  try {
    Process process=Runtime.getRuntime().exec(_arpCommand);
    BufferedReader stdOut=null;
    try {
      stdOut=new BufferedReader(new InputStreamReader(process.getInputStream(),""String_Node_Str""));
      String line;
      int index;
      JSONObject object;
      while ((line=stdOut.readLine()) != null) {
        for (        String key : _ipMap.keySet()) {
          object=_ipMap.get(key);
          index=line.indexOf(object.getString(""String_Node_Str""));
          if (index != -1) {
            if (index != 2) {
              object.put(""String_Node_Str"",""String_Node_Str"");
            }
 else {
              object.put(""String_Node_Str"",line.substring(index + 22,index + 39));
            }
            _ipMap.put(key,object);
          }
        }
      }
    }
  finally {
      if (stdOut != null) {
        stdOut.close();
      }
    }
  }
 catch (  IOException e) {
    System.err.println(""String_Node_Str"" + _arpCommand);
  }
catch (  JSONException e2) {
    System.err.println(""String_Node_Str"");
  }
}"
72380,"/** 
 * Execute the arp command on a Linux platform.  The arp command finds names and MAC addresses for devices on the local area network. The arp command should follow a ping sweep to get the most up-to-date information and to screen out devices that are not accessible at the moment (which may be cached in the arp cache).
 */
private void _arpLinux(){
  if (_ipMap.size() == 0) {
    System.err.println(""String_Node_Str"" + _pingLinuxCommand + ""String_Node_Str"");
  }
  try {
    Process process=Runtime.getRuntime().exec(_arpCommand);
    BufferedReader stdOut=null;
    try {
      stdOut=new BufferedReader(new InputStreamReader(process.getInputStream()));
      String line;
      while ((line=stdOut.readLine()) != null) {
        if (_debugging) {
          System.out.println(""String_Node_Str"" + line + ""String_Node_Str"");
        }
        StringTokenizer tokenizer=new StringTokenizer(line,""String_Node_Str"");
        String token, name, ip;
        if (tokenizer.countTokens() >= 4) {
          name=(String)tokenizer.nextElement();
          token=(String)tokenizer.nextElement();
          ip=token.substring(1,token.length() - 1);
          if (_debugging) {
            System.out.println(""String_Node_Str"" + name + ""String_Node_Str""+ token+ ""String_Node_Str""+ ip);
          }
          JSONObject object;
          for (          String key : _ipMap.keySet()) {
            object=_ipMap.get(key);
            if (object.get(""String_Node_Str"").toString().equalsIgnoreCase(ip)) {
              token=(String)tokenizer.nextElement();
              token=(String)tokenizer.nextElement();
              object.put(""String_Node_Str"",name);
              object.put(""String_Node_Str"",token);
              _ipMap.put(key,object);
            }
          }
        }
      }
    }
  finally {
      if (stdOut != null) {
        stdOut.close();
      }
    }
  }
 catch (  IOException e) {
    System.err.println(""String_Node_Str"" + _arpCommand);
  }
catch (  JSONException e2) {
    System.err.println(""String_Node_Str"");
  }
}","/** 
 * Execute the arp command on a Linux platform.  The arp command finds names and MAC addresses for devices on the local area network. The arp command should follow a ping sweep to get the most up-to-date information and to screen out devices that are not accessible at the moment (which may be cached in the arp cache).
 */
private void _arpLinux(){
  if (_ipMap.size() == 0) {
    System.err.println(""String_Node_Str"" + _pingLinuxCommand + ""String_Node_Str"");
  }
  try {
    Process process=Runtime.getRuntime().exec(_arpCommand);
    BufferedReader stdOut=null;
    try {
      stdOut=new BufferedReader(new InputStreamReader(process.getInputStream(),""String_Node_Str""));
      String line;
      while ((line=stdOut.readLine()) != null) {
        if (_debugging) {
          System.out.println(""String_Node_Str"" + line + ""String_Node_Str"");
        }
        StringTokenizer tokenizer=new StringTokenizer(line,""String_Node_Str"");
        String token, name, ip;
        if (tokenizer.countTokens() >= 4) {
          name=(String)tokenizer.nextElement();
          token=(String)tokenizer.nextElement();
          ip=token.substring(1,token.length() - 1);
          if (_debugging) {
            System.out.println(""String_Node_Str"" + name + ""String_Node_Str""+ token+ ""String_Node_Str""+ ip);
          }
          JSONObject object;
          for (          String key : _ipMap.keySet()) {
            object=_ipMap.get(key);
            if (object.get(""String_Node_Str"").toString().equalsIgnoreCase(ip)) {
              token=(String)tokenizer.nextElement();
              token=(String)tokenizer.nextElement();
              object.put(""String_Node_Str"",name);
              object.put(""String_Node_Str"",token);
              _ipMap.put(key,object);
            }
          }
        }
      }
    }
  finally {
      if (stdOut != null) {
        stdOut.close();
      }
    }
  }
 catch (  IOException e) {
    System.err.println(""String_Node_Str"" + _arpCommand);
  }
catch (  JSONException e2) {
    System.err.println(""String_Node_Str"");
  }
}"
72381,"/** 
 * Read results of a ping on a Windows platform.  If a device is found, add a JSON object containing the device IP address and name to _ipMap.
 * @param process  The process that is executing the ping.
 * @param testIP  The IP address to base the sweep on.
 */
private void _readPingWindows(Process process,String testIP){
  JSONObject device=null;
  BufferedReader stdOut=null;
  try {
    stdOut=new BufferedReader(new InputStreamReader(process.getInputStream()));
    StringBuffer data=new StringBuffer();
    String line;
    while ((line=stdOut.readLine()) != null) {
      data.append(line);
    }
    if (data.length() > 0) {
      int found=data.indexOf(""String_Node_Str"");
      if (found != -1) {
        int bracket=data.indexOf(""String_Node_Str"");
        String name=data.substring(8,bracket - 1);
        if (_debugging) {
          System.out.println(""String_Node_Str"" + name + ""String_Node_Str""+ testIP);
        }
        try {
          device=new JSONObject(""String_Node_Str"" + testIP + ""String_Node_Str""+ ""String_Node_Str""+ name+ ""String_Node_Str"");
        }
 catch (        JSONException e) {
          System.err.println(""String_Node_Str"" + name + ""String_Node_Str""+ ""String_Node_Str"");
        }
      }
    }
    process.destroy();
  }
 catch (  IOException ex) {
    System.err.println(""String_Node_Str"" + testIP + ""String_Node_Str""+ ex);
  }
 finally {
    if (stdOut != null) {
      try {
        stdOut.close();
      }
 catch (      IOException ex2) {
        System.err.println(""String_Node_Str"" + testIP + ""String_Node_Str""+ ex2);
      }
    }
  }
  if (device != null) {
    _ipMap.put(testIP,device);
  }
}","/** 
 * Read results of a ping on a Windows platform.  If a device is found, add a JSON object containing the device IP address and name to _ipMap.
 * @param process  The process that is executing the ping.
 * @param testIP  The IP address to base the sweep on.
 */
private void _readPingWindows(Process process,String testIP){
  JSONObject device=null;
  BufferedReader stdOut=null;
  try {
    stdOut=new BufferedReader(new InputStreamReader(process.getInputStream(),""String_Node_Str""));
    StringBuffer data=new StringBuffer();
    String line;
    while ((line=stdOut.readLine()) != null) {
      data.append(line);
    }
    if (data.length() > 0) {
      int found=data.indexOf(""String_Node_Str"");
      if (found != -1) {
        int bracket=data.indexOf(""String_Node_Str"");
        String name=data.substring(8,bracket - 1);
        if (_debugging) {
          System.out.println(""String_Node_Str"" + name + ""String_Node_Str""+ testIP);
        }
        try {
          device=new JSONObject(""String_Node_Str"" + testIP + ""String_Node_Str""+ ""String_Node_Str""+ name+ ""String_Node_Str"");
        }
 catch (        JSONException e) {
          System.err.println(""String_Node_Str"" + name + ""String_Node_Str""+ ""String_Node_Str"");
        }
      }
    }
    process.destroy();
  }
 catch (  IOException ex) {
    System.err.println(""String_Node_Str"" + testIP + ""String_Node_Str""+ ex);
  }
 finally {
    if (stdOut != null) {
      try {
        stdOut.close();
      }
 catch (      IOException ex2) {
        System.err.println(""String_Node_Str"" + testIP + ""String_Node_Str""+ ex2);
      }
    }
  }
  if (device != null) {
    _ipMap.put(testIP,device);
  }
}"
72382,"/** 
 * Find some property line in a file.
 * @param file The file that is going to be searched.
 * @param propertyLine The line that is going be be found.
 * @return An array with 3 strings in the respective order: the data before the propertyLine,the propertyLine with the indentation it possesses in the file, and the data after it. it
 */
private static String[] _findPropertyLine(ArrayList<String> file,String propertyLine){
  boolean lineFound=false;
  String dataBefore=""String_Node_Str"";
  String dataAfter=""String_Node_Str"";
  String line=""String_Node_Str"";
  for (  String content : file) {
    if (!content.isEmpty() || !(content.equals(""String_Node_Str"")) || !(content.equals(""String_Node_Str""))) {
      if (content.contains(propertyLine) && !lineFound) {
        line=content.substring(0,content.length() - 2);
        line=line.substring(line.lastIndexOf(""String_Node_Str"") + 1);
        try {
          Double.valueOf(line);
          line=content.substring(0,content.indexOf(line));
          lineFound=true;
          System.out.println(true);
        }
 catch (        Exception e) {
          if (dataBefore.isEmpty()) {
            dataBefore=content;
          }
 else {
            dataBefore=dataBefore + ""String_Node_Str"" + content;
          }
        }
      }
 else       if (!lineFound) {
        if (dataBefore.isEmpty()) {
          dataBefore=content;
        }
 else {
          dataBefore=dataBefore + ""String_Node_Str"" + content;
        }
      }
 else {
        if (dataAfter.isEmpty()) {
          dataAfter=content;
        }
 else {
          dataAfter=dataAfter + ""String_Node_Str"" + content;
        }
      }
    }
  }
  String[] data={dataBefore,line,dataAfter};
  if (line.equals(""String_Node_Str"")) {
    System.out.println(""String_Node_Str"");
    System.exit(0);
    return null;
  }
  return data;
}","/** 
 * Find some property line in a file.
 * @param file The file that is going to be searched.
 * @param propertyLine The line that is going be be found.
 * @return An array with 3 strings in the respective order: the data before the propertyLine,the propertyLine with the indentation it possesses in the file, and the data after it. it
 */
private static String[] _findPropertyLine(ArrayList<String> file,String propertyLine){
  boolean lineFound=false;
  String dataBefore=""String_Node_Str"";
  String dataAfter=""String_Node_Str"";
  String line=""String_Node_Str"";
  for (  String content : file) {
    if (!content.isEmpty() || !(content.equals(""String_Node_Str"")) || !(content.equals(""String_Node_Str""))) {
      if (content.contains(propertyLine) && !lineFound) {
        line=content.substring(0,content.length() - 2);
        line=line.substring(line.lastIndexOf(""String_Node_Str"") + 1);
        try {
          line=content.substring(0,content.indexOf(line));
          lineFound=true;
          System.out.println(true);
        }
 catch (        Exception e) {
          if (dataBefore.isEmpty()) {
            dataBefore=content;
          }
 else {
            dataBefore=dataBefore + ""String_Node_Str"" + content;
          }
        }
      }
 else       if (!lineFound) {
        if (dataBefore.isEmpty()) {
          dataBefore=content;
        }
 else {
          dataBefore=dataBefore + ""String_Node_Str"" + content;
        }
      }
 else {
        if (dataAfter.isEmpty()) {
          dataAfter=content;
        }
 else {
          dataAfter=dataAfter + ""String_Node_Str"" + content;
        }
      }
    }
  }
  String[] data={dataBefore,line,dataAfter};
  if (line.equals(""String_Node_Str"")) {
    System.out.println(""String_Node_Str"");
    System.exit(0);
    return null;
  }
  return data;
}"
72383,"/** 
 * Write some information in a file.
 * @param file The file were the information is going to be written.
 * @param data The information that is going to be written.
 */
private static void _writeInFile(File file,String data){
  try {
    BufferedWriter writer=new BufferedWriter(new FileWriter(file));
    writer.write(data);
    writer.flush();
    writer.close();
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"");
  }
}","/** 
 * Write some information in a file.
 * @param file The file were the information is going to be written.
 * @param data The information that is going to be written.
 */
private static void _writeInFile(File file,String data){
  try {
    FileWriter fWriter=new FileWriter(file);
    BufferedWriter writer=new BufferedWriter(fWriter);
    writer.write(data);
    writer.flush();
    writer.close();
    fWriter.close();
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"");
  }
}"
72384,"/** 
 * Find some property lines in a file.
 * @param file The file that is going to be searched.
 * @param propertyLines The line that is going be be found.
 * @return A two-dimensional array with the length of the @param propertyLines increased by 1 and 2 columns. The first onerepresents the information written on the file after the one property line and before the next one. The second column represents the property lines with the same indentation as they were found on the file. The second column of the last line contains nothing but """", as there's no property left to be written.
 */
private static String[][] _findPropertyLines(ArrayList<String> file,String[] propertyLines){
  int numberOfLines=file.size();
  int numberOfProperties=propertyLines.length;
  String[][] result=new String[numberOfProperties + 1][2];
  int linesFound=0;
  String content=""String_Node_Str"";
  result[0][0]=""String_Node_Str"";
  for (int i=0; i < numberOfLines; i++) {
    content=file.get(i);
    if (linesFound < numberOfProperties) {
      if (content.contains(propertyLines[linesFound])) {
        String line=content.substring(0,content.length() - 2);
        line=line.substring(line.lastIndexOf(""String_Node_Str"") + 1);
        try {
          Double.valueOf(line);
          result[linesFound][1]=content.substring(0,content.indexOf(line));
          linesFound++;
          result[linesFound][0]=""String_Node_Str"";
        }
 catch (        Exception e) {
          if (!result[linesFound][0].equals(""String_Node_Str"")) {
            content=""String_Node_Str"" + content;
          }
          result[linesFound][0]=result[linesFound][0] + content;
        }
      }
 else {
        if (!result[linesFound][0].equals(""String_Node_Str"")) {
          content=""String_Node_Str"" + content;
        }
        result[linesFound][0]=result[linesFound][0] + content;
      }
    }
 else {
      if (!result[linesFound][0].equals(""String_Node_Str"")) {
        content=""String_Node_Str"" + content;
      }
      result[linesFound][0]=result[linesFound][0] + content;
    }
  }
  result[linesFound][1]=""String_Node_Str"";
  if (result[numberOfProperties][0] == null || result[numberOfProperties][0].equals(""String_Node_Str"")) {
    System.out.println(""String_Node_Str"");
    System.exit(0);
  }
  return result;
}","/** 
 * Find some property lines in a file.
 * @param file The file that is going to be searched.
 * @param propertyLines The line that is going be be found.
 * @return A two-dimensional array with the length of the @param propertyLines increased by 1 and 2 columns. The first onerepresents the information written on the file after the one property line and before the next one. The second column represents the property lines with the same indentation as they were found on the file. The second column of the last line contains nothing but """", as there's no property left to be written.
 */
private static String[][] _findPropertyLines(ArrayList<String> file,String[] propertyLines){
  int numberOfLines=file.size();
  int numberOfProperties=propertyLines.length;
  String[][] result=new String[numberOfProperties + 1][2];
  int linesFound=0;
  String content=""String_Node_Str"";
  result[0][0]=""String_Node_Str"";
  for (int i=0; i < numberOfLines; i++) {
    content=file.get(i);
    if (linesFound < numberOfProperties) {
      if (content.contains(propertyLines[linesFound])) {
        String line=content.substring(0,content.length() - 2);
        line=line.substring(line.lastIndexOf(""String_Node_Str"") + 1);
        try {
          result[linesFound][1]=content.substring(0,content.indexOf(line));
          linesFound++;
          result[linesFound][0]=""String_Node_Str"";
        }
 catch (        Exception e) {
          if (!result[linesFound][0].equals(""String_Node_Str"")) {
            content=""String_Node_Str"" + content;
          }
          result[linesFound][0]=result[linesFound][0] + content;
        }
      }
 else {
        if (!result[linesFound][0].equals(""String_Node_Str"")) {
          content=""String_Node_Str"" + content;
        }
        result[linesFound][0]=result[linesFound][0] + content;
      }
    }
 else {
      if (!result[linesFound][0].equals(""String_Node_Str"")) {
        content=""String_Node_Str"" + content;
      }
      result[linesFound][0]=result[linesFound][0] + content;
    }
  }
  result[linesFound][1]=""String_Node_Str"";
  if (result[numberOfProperties][0] == null || result[numberOfProperties][0].equals(""String_Node_Str"")) {
    System.out.println(""String_Node_Str"");
    System.exit(0);
  }
  return result;
}"
72385,"/** 
 * Find a parameter value from a file.
 * @param file The file to be read
 * @param propertyLine The property line to be found
 * @param type The type of the data. 0 for String, 1 for int, 2 for float.
 * @return The parameter value.
 */
public static String findParameterValue(File file,String propertyLine,int type) throws IllegalActionException {
  try {
    ArrayList<String> fileContent=convertFileToString(file);
    String value=""String_Node_Str"";
    for (    String s : fileContent) {
      if (s.contains(propertyLine)) {
        try {
          value=s.substring(s.lastIndexOf(""String_Node_Str"") + 7,s.lastIndexOf(""String_Node_Str""));
          if (type == 1) {
            Integer.parseInt(value);
          }
 else           if (type == 2) {
            Float.parseFloat(value);
          }
          break;
        }
 catch (        Exception e) {
          value=""String_Node_Str"";
        }
      }
    }
    return value;
  }
 catch (  IOException ex) {
    throw new IllegalActionException(null,ex,""String_Node_Str"" + file + ""String_Node_Str""+ propertyLine);
  }
}","/** 
 * Find a parameter value from a file.
 * @param file The file to be read
 * @param propertyLine The property line to be found
 * @return The parameter value.
 */
public static String findParameterValue(File file,String propertyLine) throws IllegalActionException {
  try {
    ArrayList<String> fileContent=convertFileToString(file);
    String value=""String_Node_Str"";
    for (    String s : fileContent) {
      if (s.contains(propertyLine)) {
        try {
          value=s.substring(s.lastIndexOf(""String_Node_Str"") + 7,s.lastIndexOf(""String_Node_Str""));
        }
 catch (        Exception e) {
          value=""String_Node_Str"";
        }
      }
    }
    return value;
  }
 catch (  IOException ex) {
    throw new IllegalActionException(null,ex,""String_Node_Str"" + file + ""String_Node_Str""+ propertyLine);
  }
}"
72386,"/** 
 * Associate the object file with a file in the computer, creating it, if it doesn't already exist.
 * @param name the name to of the file
 */
private File _createTextFile(String name,String header){
  if (_testsFolder != null) {
    name=_testsFolder + ""String_Node_Str"" + name;
    if (name.equals(null) || name.length() < 3) {
      System.out.println(""String_Node_Str"");
      return null;
    }
 else {
      if (!(name.endsWith(""String_Node_Str"") || name.endsWith(""String_Node_Str""))) {
        name=name.concat(""String_Node_Str"");
      }
      try {
        File file=new File(name);
        boolean verify=false;
        if (!file.exists()) {
          verify=file.createNewFile();
          writeInTextFile(file,header);
        }
 else {
          verify=true;
        }
        if (!verify) {
          throw new Exception();
        }
        System.out.println(name);
        return file;
      }
 catch (      Exception e) {
        System.out.println(""String_Node_Str"");
        return null;
      }
    }
  }
 else {
    return null;
  }
}","/** 
 * Associate the object file with a file in the computer, creating it, if it doesn't already exist.
 * @param name the name to of the file
 */
private File _createTextFile(String name,String header){
  if (_testsFolder != null) {
    name=_testsFolder + ""String_Node_Str"" + name;
    if (name == null || name.length() < 3) {
      System.out.println(""String_Node_Str"");
      return null;
    }
 else {
      if (!(name.endsWith(""String_Node_Str"") || name.endsWith(""String_Node_Str""))) {
        name=name.concat(""String_Node_Str"");
      }
      try {
        File file=new File(name);
        boolean verify=false;
        if (!file.exists()) {
          verify=file.createNewFile();
          writeInTextFile(file,header);
        }
 else {
          verify=true;
        }
        if (!verify) {
          throw new Exception();
        }
        System.out.println(name);
        return file;
      }
 catch (      Exception e) {
        System.out.println(""String_Node_Str"");
        return null;
      }
    }
  }
 else {
    return null;
  }
}"
72387,"/** 
 * RTI service for event-based federate (NER or NERA) is used for proposing a time to advance to.
 * @param proposedTime time stamp of lastFoundEvent
 * @return
 */
private Time _eventsBasedTimeAdvance(Time proposedTime) throws IllegalActionException, InvalidFederationTime, FederationTimeAlreadyPassed, TimeAdvanceAlreadyInProgress, FederateNotExecutionMember, SaveInProgress, EnableTimeRegulationPending, EnableTimeConstrainedPending, RestoreInProgress, RTIinternalError, ConcurrentAccessAttempted, SpecifiedSaveLabelDoesNotExist {
  CertiLogicalTime certiProposedTime=_convertToCertiLogicalTime(proposedTime);
  String proposedTimeInString=_printTimes(proposedTime);
  proposedTime=new Time(_director,Double.parseDouble(proposedTimeInString));
  _storeTimes(""String_Node_Str"" + proposedTimeInString + ""String_Node_Str"");
  if (_hlaLookAHead > 0) {
    if (_debugging) {
      _debug(""String_Node_Str"" + proposedTimeInString + ""String_Node_Str""+ proposedTimeInString+ ""String_Node_Str""+ ""String_Node_Str""+ certiProposedTime.getTime()+ ""String_Node_Str"");
    }
    _rtia.nextEventRequest(certiProposedTime);
    _numberOfNERs++;
    _timeOfTheLastAdvanceRequest=System.nanoTime();
  }
 else {
    if (_debugging) {
      _debug(""String_Node_Str"" + proposedTimeInString + ""String_Node_Str""+ proposedTimeInString+ ""String_Node_Str""+ ""String_Node_Str""+ certiProposedTime.getTime()+ ""String_Node_Str"");
    }
    _rtia.nextEventRequestAvailable(certiProposedTime);
    _numberOfNERs++;
    _timeOfTheLastAdvanceRequest=System.nanoTime();
    _federateAmbassador.timeAdvanceGrant=false;
    while (!(_federateAmbassador.timeAdvanceGrant)) {
      if (_debugging) {
        _debug(""String_Node_Str"" + proposedTimeInString + ""String_Node_Str""+ proposedTimeInString+ ""String_Node_Str""+ ""String_Node_Str""+ certiProposedTime.getTime()+ ""String_Node_Str"");
      }
      _rtia.tick2();
      _numberOfTicks2++;
      _numberOfTicks.set(_numberOfTAGs,_numberOfTicks.get(_numberOfTAGs) + 1);
      ;
    }
    if (_debugging) {
      if (_debugging) {
        _debug(""String_Node_Str"" + proposedTimeInString + ""String_Node_Str""+ proposedTimeInString+ ""String_Node_Str""+ ""String_Node_Str""+ certiProposedTime.getTime()+ ""String_Node_Str"");
      }
    }
    _rtia.nextEventRequest(certiProposedTime);
    _numberOfNERs++;
    _timeOfTheLastAdvanceRequest=System.nanoTime();
  }
  _federateAmbassador.timeAdvanceGrant=false;
  int cntTick=0;
  while (!(_federateAmbassador.timeAdvanceGrant)) {
    if (_debugging) {
      _debug(""String_Node_Str"" + proposedTimeInString + ""String_Node_Str""+ proposedTimeInString+ ""String_Node_Str""+ ""String_Node_Str""+ certiProposedTime.getTime()+ ""String_Node_Str"");
    }
    _rtia.tick2();
    _numberOfTicks2++;
    cntTick++;
  }
  _numberOfTicks.set(_numberOfTAGs,_numberOfTicks.get(_numberOfTAGs) + cntTick);
  if (_debugging) {
    _debug(""String_Node_Str"" + proposedTimeInString + ""String_Node_Str""+ proposedTimeInString+ ""String_Node_Str"");
  }
  if (cntTick != 1) {
    _putReflectedAttributesOnHlaSubscribers();
    try {
      CertiLogicalTime hlaTimeGranted=(CertiLogicalTime)_federateAmbassador.logicalTimeHLA;
      Time breakpoint=_convertToPtolemyTime(hlaTimeGranted);
      if (_debugging) {
        _debug(""String_Node_Str"" + proposedTimeInString + ""String_Node_Str""+ proposedTimeInString+ ""String_Node_Str""+ hlaTimeGranted+ ""String_Node_Str""+ _printTimes(breakpoint));
      }
      proposedTime=breakpoint;
    }
 catch (    IllegalActionException e) {
      throw new IllegalActionException(this,e,""String_Node_Str"");
    }
  }
  return proposedTime;
}","/** 
 * RTI service for event-based federate (NER or NERA) is used for proposing a time to advance to.
 * @param proposedTime time stamp of lastFoundEvent
 * @return
 */
private Time _eventsBasedTimeAdvance(Time proposedTime) throws IllegalActionException, InvalidFederationTime, FederationTimeAlreadyPassed, TimeAdvanceAlreadyInProgress, FederateNotExecutionMember, SaveInProgress, EnableTimeRegulationPending, EnableTimeConstrainedPending, RestoreInProgress, RTIinternalError, ConcurrentAccessAttempted, SpecifiedSaveLabelDoesNotExist {
  CertiLogicalTime certiProposedTime=_convertToCertiLogicalTime(proposedTime);
  String proposedTimeInString=_printTimes(proposedTime);
  proposedTime=new Time(_director,Double.parseDouble(proposedTimeInString));
  _storeTimes(""String_Node_Str"" + proposedTimeInString + ""String_Node_Str"");
  if (_hlaLookAHead > 0) {
    if (_debugging) {
      _debug(""String_Node_Str"" + proposedTimeInString + ""String_Node_Str""+ proposedTimeInString+ ""String_Node_Str""+ ""String_Node_Str""+ certiProposedTime.getTime()+ ""String_Node_Str"");
    }
    _rtia.nextEventRequest(certiProposedTime);
    _numberOfNERs++;
    _timeOfTheLastAdvanceRequest=System.nanoTime();
  }
 else {
    if (_debugging) {
      _debug(""String_Node_Str"" + proposedTimeInString + ""String_Node_Str""+ proposedTimeInString+ ""String_Node_Str""+ ""String_Node_Str""+ certiProposedTime.getTime()+ ""String_Node_Str"");
    }
    _rtia.nextEventRequestAvailable(certiProposedTime);
    _numberOfNERs++;
    _timeOfTheLastAdvanceRequest=System.nanoTime();
    _federateAmbassador.timeAdvanceGrant=false;
    while (!(_federateAmbassador.timeAdvanceGrant)) {
      if (_debugging) {
        _debug(""String_Node_Str"" + proposedTimeInString + ""String_Node_Str""+ proposedTimeInString+ ""String_Node_Str""+ ""String_Node_Str""+ certiProposedTime.getTime()+ ""String_Node_Str"");
      }
      _rtia.tick2();
      _numberOfTicks2++;
      _numberOfTicks.set(_numberOfTAGs,_numberOfTicks.get(_numberOfTAGs) + 1);
      ;
    }
    if (_debugging) {
      _debug(""String_Node_Str"" + proposedTimeInString + ""String_Node_Str""+ proposedTimeInString+ ""String_Node_Str""+ ""String_Node_Str""+ certiProposedTime.getTime()+ ""String_Node_Str"");
    }
    _rtia.nextEventRequest(certiProposedTime);
    _numberOfNERs++;
    _timeOfTheLastAdvanceRequest=System.nanoTime();
  }
  _federateAmbassador.timeAdvanceGrant=false;
  int cntTick=0;
  while (!(_federateAmbassador.timeAdvanceGrant)) {
    if (_debugging) {
      _debug(""String_Node_Str"" + proposedTimeInString + ""String_Node_Str""+ proposedTimeInString+ ""String_Node_Str""+ ""String_Node_Str""+ certiProposedTime.getTime()+ ""String_Node_Str"");
    }
    _rtia.tick2();
    _numberOfTicks2++;
    cntTick++;
  }
  _numberOfTicks.set(_numberOfTAGs,_numberOfTicks.get(_numberOfTAGs) + cntTick);
  if (_debugging) {
    _debug(""String_Node_Str"" + proposedTimeInString + ""String_Node_Str""+ proposedTimeInString+ ""String_Node_Str"");
  }
  if (cntTick != 1) {
    _putReflectedAttributesOnHlaSubscribers();
    try {
      CertiLogicalTime hlaTimeGranted=(CertiLogicalTime)_federateAmbassador.logicalTimeHLA;
      Time breakpoint=_convertToPtolemyTime(hlaTimeGranted);
      if (_debugging) {
        _debug(""String_Node_Str"" + proposedTimeInString + ""String_Node_Str""+ proposedTimeInString+ ""String_Node_Str""+ hlaTimeGranted+ ""String_Node_Str""+ _printTimes(breakpoint));
      }
      proposedTime=breakpoint;
    }
 catch (    IllegalActionException e) {
      throw new IllegalActionException(this,e,""String_Node_Str"");
    }
  }
  return proposedTime;
}"
72388,"/** 
 * Callback delivered by the RTI (CERTI) to discover attribute instance of HLA attribute that the Federate is subscribed to.
 */
@Override public void discoverObjectInstance(int objectHandle_,int classHandle_,String objectName_) throws CouldNotDiscover, ObjectClassNotKnown, FederateInternalError {
  final int classHandle=classHandle_;
  final String objectName=objectName_;
  final int objectHandle=objectHandle_;
  _objectIdToClassHandle.put(objectHandle,classHandle);
  final CompositeActor classToInstantiate=(CompositeActor)_strucuralInformation.get(classHandle).classToInstantiate;
  _noObjectDicovered=false;
  ChangeRequest request=new ChangeRequest(this,""String_Node_Str"" + objectName,true){
    @Override protected void _execute() throws IllegalActionException {
      CompositeActor container=(CompositeActor)classToInstantiate.getContainer();
      CompositeActor newActor=null;
      try {
        Instantiable instance=null;
        StructuralInformation info=_strucuralInformation.get(classHandle);
        LinkedList<ComponentEntity> actors=info.freeActors;
        if (actors.size() == 0) {
          instance=classToInstantiate.instantiate(container,objectName);
          newActor=(CompositeActor)instance;
          LinkedList<IOPort> outputPortList=(LinkedList<IOPort>)newActor.outputPortList();
          container.notifyConnectivityChange();
          for (          IOPort out : outputPortList) {
            ComponentRelation r=null;
            HashSet<IOPort> ports=info.getPortReceiver(out.getName());
            if (ports == null) {
              continue;
            }
            for (            IOPort recv : ports) {
              if (r == null) {
                r=container.connect(out,recv,objectName + ""String_Node_Str"" + out.getName());
              }
 else {
                recv.link(r);
              }
            }
          }
          if (_debugging) {
            _debug(""String_Node_Str"" + objectName);
          }
        }
 else {
          instance=actors.poll();
          newActor=(CompositeActor)instance;
          newActor.setDisplayName(objectName);
          if (_debugging) {
            _debug(instance.getName() + ""String_Node_Str"" + objectName);
          }
        }
{
          Attribute name=newActor.getAttribute(""String_Node_Str"");
          if (name != null) {
            Parameter p=(Parameter)name;
            p.setTypeEquals(BaseType.STRING);
            p.setExpression(""String_Node_Str"" + objectName + ""String_Node_Str"");
          }
        }
        List<HlaSubscriber> subscribers=newActor.entityList(HlaSubscriber.class);
        for (int i=0; i < subscribers.size(); ++i) {
          HlaSubscriber sub=subscribers.get(i);
          sub.objectName.setExpression(""String_Node_Str"" + objectName + ""String_Node_Str"");
          ;
          sub.setObjectHandle(objectHandle);
          _hlaAttributesSubscribedTo.put(sub.getIdentity(),new Object[]{sub.output,sub.output.getType(),""String_Node_Str"",classHandle,sub.getAttributeHandle()});
          _fromFederationEvents.put(sub.getIdentity(),new LinkedList<TimedEvent>());
        }
      }
 catch (      NameDuplicationException|CloneNotSupportedException ex) {
        ex.printStackTrace();
      }
    }
  }
;
  request.setPersistent(false);
  requestChange(request);
  if (_debugging) {
    String toLog=""String_Node_Str"" + ""String_Node_Str"" + objectName + ""String_Node_Str""+ ""String_Node_Str""+ objectHandle+ ""String_Node_Str""+ classHandle+ ""String_Node_Str"";
    _debug(toLog);
  }
}","/** 
 * Callback delivered by the RTI (CERTI) to discover attribute instance of HLA attribute that the Federate is subscribed to.
 */
@Override public void discoverObjectInstance(int objectHandle_,int classHandle_,String objectName_) throws CouldNotDiscover, ObjectClassNotKnown, FederateInternalError {
  final int classHandle=classHandle_;
  final String objectName=objectName_;
  final int objectHandle=objectHandle_;
  _objectIdToClassHandle.put(objectHandle,classHandle);
  final CompositeActor classToInstantiate=(CompositeActor)_strucuralInformation.get(classHandle).classToInstantiate;
  _noObjectDicovered=false;
  ChangeRequest request=new ChangeRequest(this,""String_Node_Str"" + objectName,true){
    @Override protected void _execute() throws IllegalActionException {
      CompositeActor container=(CompositeActor)classToInstantiate.getContainer();
      CompositeActor newActor=null;
      try {
        Instantiable instance=null;
        StructuralInformation info=_strucuralInformation.get(classHandle);
        LinkedList<ComponentEntity> actors=info.freeActors;
        if (actors.size() == 0) {
          instance=classToInstantiate.instantiate(container,objectName);
          newActor=(CompositeActor)instance;
          LinkedList<IOPort> outputPortList=(LinkedList<IOPort>)newActor.outputPortList();
          container.notifyConnectivityChange();
          for (          IOPort out : outputPortList) {
            ComponentRelation r=null;
            HashSet<IOPort> ports=info.getPortReceiver(out.getName());
            if (ports == null) {
              continue;
            }
            for (            IOPort recv : ports) {
              if (r == null) {
                r=container.connect(out,recv,objectName + ""String_Node_Str"" + out.getName());
              }
 else {
                recv.link(r);
              }
            }
          }
          if (_debugging) {
            _debug(""String_Node_Str"" + objectName);
          }
        }
 else {
          instance=actors.poll();
          if (instance == null) {
            throw new IllegalActionException(""String_Node_Str"");
          }
 else {
            newActor=(CompositeActor)instance;
            newActor.setDisplayName(objectName);
            if (_debugging) {
              _debug(instance.getName() + ""String_Node_Str"" + objectName);
            }
          }
        }
{
          Attribute name=newActor.getAttribute(""String_Node_Str"");
          if (name != null) {
            Parameter p=(Parameter)name;
            p.setTypeEquals(BaseType.STRING);
            p.setExpression(""String_Node_Str"" + objectName + ""String_Node_Str"");
          }
        }
        List<HlaSubscriber> subscribers=newActor.entityList(HlaSubscriber.class);
        for (int i=0; i < subscribers.size(); ++i) {
          HlaSubscriber sub=subscribers.get(i);
          sub.objectName.setExpression(""String_Node_Str"" + objectName + ""String_Node_Str"");
          ;
          sub.setObjectHandle(objectHandle);
          _hlaAttributesSubscribedTo.put(sub.getIdentity(),new Object[]{sub.output,sub.output.getType(),""String_Node_Str"",classHandle,sub.getAttributeHandle()});
          _fromFederationEvents.put(sub.getIdentity(),new LinkedList<TimedEvent>());
        }
      }
 catch (      NameDuplicationException|CloneNotSupportedException ex) {
        ex.printStackTrace();
      }
    }
  }
;
  request.setPersistent(false);
  requestChange(request);
  if (_debugging) {
    String toLog=""String_Node_Str"" + ""String_Node_Str"" + objectName + ""String_Node_Str""+ ""String_Node_Str""+ objectHandle+ ""String_Node_Str""+ classHandle+ ""String_Node_Str"";
    _debug(toLog);
  }
}"
72389,"/** 
 * Write the number of HLA calls of each federate, along with informations about the time step and the runtime, in a file. The name and location of this file are specified in the initialization of the variable file.
 */
public void writeNumberOfHLACalls(){
  try {
    String fullName=federateName.toString();
    String nameOfTheFile=fullName.substring(fullName.indexOf('{') + 1,fullName.lastIndexOf('.'));
    String RKSolver=""String_Node_Str"";
    nameOfTheFile=nameOfTheFile.substring(1,nameOfTheFile.lastIndexOf('.')) + ""String_Node_Str"";
    String path=fedFile.asFile().getPath();
    path=path.substring(0,path.lastIndexOf(""String_Node_Str"") + 1);
    File file=new File(path + nameOfTheFile);
    StringBuffer info=new StringBuffer(""String_Node_Str"" + getDisplayName() + ""String_Node_Str""+ nameOfTheFile);
    RKSolver=AutomaticSimulation.findParameterValue(file,RKSolver,0);
    info.append(""String_Node_Str"" + RKSolver);
    info.append(""String_Node_Str"" + ""String_Node_Str"" + _stopTime + ""String_Node_Str""+ _hlaTimeUnitValue+ ""String_Node_Str""+ _hlaLookAHead);
    if (_isCreator) {
      info=new StringBuffer(""String_Node_Str"" + info);
    }
    if (_timeStepped) {
      info.append(""String_Node_Str"" + _hlaTimeStep + ""String_Node_Str""+ ""String_Node_Str""+ _numberOfTARs);
    }
 else     if (_eventBased) {
      info.append(""String_Node_Str"" + _numberOfNERs);
    }
    info.append(""String_Node_Str"" + _numberOfUAVs + ""String_Node_Str""+ _numberOfTAGs+ ""String_Node_Str""+ _numberOfRAVs+ ""String_Node_Str""+ ""String_Node_Str""+ _runtime+ ""String_Node_Str"");
    writeInTextFile(_file,info.toString());
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"");
  }
}","/** 
 * Write the number of HLA calls of each federate, along with informations about the time step and the runtime, in a file. The name and location of this file are specified in the initialization of the variable file.
 */
public void writeNumberOfHLACalls(){
  try {
    String fullName=federateName.toString();
    String nameOfTheFile=fullName.substring(fullName.indexOf('{') + 1,fullName.lastIndexOf('.'));
    String RKSolver=""String_Node_Str"";
    nameOfTheFile=nameOfTheFile.substring(1,nameOfTheFile.lastIndexOf('.')) + ""String_Node_Str"";
    String path=fedFile.asFile().getPath();
    path=path.substring(0,path.lastIndexOf(""String_Node_Str"") + 1);
    File file=new File(path + nameOfTheFile);
    StringBuffer info=new StringBuffer(""String_Node_Str"" + getDisplayName() + ""String_Node_Str""+ nameOfTheFile);
    RKSolver=AutomaticSimulation.findParameterValue(file,RKSolver);
    info.append(""String_Node_Str"" + RKSolver);
    info.append(""String_Node_Str"" + ""String_Node_Str"" + _stopTime + ""String_Node_Str""+ _hlaTimeUnitValue+ ""String_Node_Str""+ _hlaLookAHead);
    if (_isCreator) {
      info=new StringBuffer(""String_Node_Str"" + info);
    }
    if (_timeStepped) {
      info.append(""String_Node_Str"" + _hlaTimeStep + ""String_Node_Str""+ ""String_Node_Str""+ _numberOfTARs);
    }
 else     if (_eventBased) {
      info.append(""String_Node_Str"" + _numberOfNERs);
    }
    info.append(""String_Node_Str"" + _numberOfUAVs + ""String_Node_Str""+ _numberOfTAGs+ ""String_Node_Str""+ _numberOfRAVs+ ""String_Node_Str""+ ""String_Node_Str""+ _runtime+ ""String_Node_Str"");
    writeInTextFile(_file,info.toString());
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"");
  }
}"
72390,"/** 
 * Write information in a txt file.
 * @param data The information you want to write.
 * @param file The file in which you want to write.
 * @return Return true if the information was successfully written in the file.
 */
public boolean writeInTextFile(File file,String data){
  try {
    BufferedWriter writer=new BufferedWriter(new FileWriter(file,true));
    writer.write(data);
    writer.newLine();
    writer.flush();
    writer.close();
    return true;
  }
 catch (  Exception e) {
    return false;
  }
}","/** 
 * Write information in a txt file.
 * @param data The information you want to write.
 * @param file The file in which you want to write.
 * @return Return true if the information was successfully written in the file.
 */
public boolean writeInTextFile(File file,String data){
  try {
    FileWriter fWriter=new FileWriter(file);
    BufferedWriter writer=new BufferedWriter(fWriter);
    writer.write(data);
    writer.newLine();
    writer.flush();
    writer.close();
    fWriter.close();
    return true;
  }
 catch (  Exception e) {
    return false;
  }
}"
72391,"@Override protected void _execute() throws IllegalActionException {
  CompositeActor container=(CompositeActor)classToInstantiate.getContainer();
  CompositeActor newActor=null;
  try {
    Instantiable instance=null;
    StructuralInformation info=_strucuralInformation.get(classHandle);
    LinkedList<ComponentEntity> actors=info.freeActors;
    if (actors.size() == 0) {
      instance=classToInstantiate.instantiate(container,objectName);
      newActor=(CompositeActor)instance;
      LinkedList<IOPort> outputPortList=(LinkedList<IOPort>)newActor.outputPortList();
      container.notifyConnectivityChange();
      for (      IOPort out : outputPortList) {
        ComponentRelation r=null;
        HashSet<IOPort> ports=info.getPortReceiver(out.getName());
        if (ports == null) {
          continue;
        }
        for (        IOPort recv : ports) {
          if (r == null) {
            r=container.connect(out,recv,objectName + ""String_Node_Str"" + out.getName());
          }
 else {
            recv.link(r);
          }
        }
      }
      if (_debugging) {
        _debug(""String_Node_Str"" + objectName);
      }
    }
 else {
      instance=actors.poll();
      newActor=(CompositeActor)instance;
      newActor.setDisplayName(objectName);
      if (_debugging) {
        _debug(instance.getName() + ""String_Node_Str"" + objectName);
      }
    }
{
      Attribute name=newActor.getAttribute(""String_Node_Str"");
      if (name != null) {
        Parameter p=(Parameter)name;
        p.setTypeEquals(BaseType.STRING);
        p.setExpression(""String_Node_Str"" + objectName + ""String_Node_Str"");
      }
    }
    List<HlaSubscriber> subscribers=newActor.entityList(HlaSubscriber.class);
    for (int i=0; i < subscribers.size(); ++i) {
      HlaSubscriber sub=subscribers.get(i);
      sub.objectName.setExpression(""String_Node_Str"" + objectName + ""String_Node_Str"");
      ;
      sub.setObjectHandle(objectHandle);
      _hlaAttributesSubscribedTo.put(sub.getIdentity(),new Object[]{sub.output,sub.output.getType(),""String_Node_Str"",classHandle,sub.getAttributeHandle()});
      _fromFederationEvents.put(sub.getIdentity(),new LinkedList<TimedEvent>());
    }
  }
 catch (  NameDuplicationException|CloneNotSupportedException ex) {
    ex.printStackTrace();
  }
}","@Override protected void _execute() throws IllegalActionException {
  CompositeActor container=(CompositeActor)classToInstantiate.getContainer();
  CompositeActor newActor=null;
  try {
    Instantiable instance=null;
    StructuralInformation info=_strucuralInformation.get(classHandle);
    LinkedList<ComponentEntity> actors=info.freeActors;
    if (actors.size() == 0) {
      instance=classToInstantiate.instantiate(container,objectName);
      newActor=(CompositeActor)instance;
      LinkedList<IOPort> outputPortList=(LinkedList<IOPort>)newActor.outputPortList();
      container.notifyConnectivityChange();
      for (      IOPort out : outputPortList) {
        ComponentRelation r=null;
        HashSet<IOPort> ports=info.getPortReceiver(out.getName());
        if (ports == null) {
          continue;
        }
        for (        IOPort recv : ports) {
          if (r == null) {
            r=container.connect(out,recv,objectName + ""String_Node_Str"" + out.getName());
          }
 else {
            recv.link(r);
          }
        }
      }
      if (_debugging) {
        _debug(""String_Node_Str"" + objectName);
      }
    }
 else {
      instance=actors.poll();
      if (instance == null) {
        throw new IllegalActionException(""String_Node_Str"");
      }
 else {
        newActor=(CompositeActor)instance;
        newActor.setDisplayName(objectName);
        if (_debugging) {
          _debug(instance.getName() + ""String_Node_Str"" + objectName);
        }
      }
    }
{
      Attribute name=newActor.getAttribute(""String_Node_Str"");
      if (name != null) {
        Parameter p=(Parameter)name;
        p.setTypeEquals(BaseType.STRING);
        p.setExpression(""String_Node_Str"" + objectName + ""String_Node_Str"");
      }
    }
    List<HlaSubscriber> subscribers=newActor.entityList(HlaSubscriber.class);
    for (int i=0; i < subscribers.size(); ++i) {
      HlaSubscriber sub=subscribers.get(i);
      sub.objectName.setExpression(""String_Node_Str"" + objectName + ""String_Node_Str"");
      ;
      sub.setObjectHandle(objectHandle);
      _hlaAttributesSubscribedTo.put(sub.getIdentity(),new Object[]{sub.output,sub.output.getType(),""String_Node_Str"",classHandle,sub.getAttributeHandle()});
      _fromFederationEvents.put(sub.getIdentity(),new LinkedList<TimedEvent>());
    }
  }
 catch (  NameDuplicationException|CloneNotSupportedException ex) {
    ex.printStackTrace();
  }
}"
72392,"/** 
 * Each tokens, received in the input port, are transmitted to the  {@link HlaManager} for a publication to the HLA/CERTI Federation.
 */
@Override public void fire() throws IllegalActionException {
  for (int i=0; i < input.getWidth(); ++i) {
    if (input.hasToken(i)) {
      Token in=input.get(i);
      _hlaManager.updateHlaAttribute(this,in,input.sourcePortList().get(i).getContainer().getName());
      if (_debugging) {
        _debug(this.getDisplayName() + ""String_Node_Str"" + in.toString()+ ""String_Node_Str""+ this.getName()+ ""String_Node_Str""+ _hlaManager.getDisplayName()+ ""String_Node_Str"");
      }
    }
  }
}","/** 
 * Each tokens, received in the input port, are transmitted to the  {@link HlaManager} for a publication to the HLA/CERTI Federation.
 */
@Override public void fire() throws IllegalActionException {
  super.fire();
  for (int i=0; i < input.getWidth(); ++i) {
    if (input.hasToken(i)) {
      Token in=input.get(i);
      _hlaManager.updateHlaAttribute(this,in,input.sourcePortList().get(i).getContainer().getName());
      if (_debugging) {
        _debug(this.getDisplayName() + ""String_Node_Str"" + in.toString()+ ""String_Node_Str""+ this.getName()+ ""String_Node_Str""+ _hlaManager.getDisplayName()+ ""String_Node_Str"");
      }
    }
  }
}"
72393,"/** 
 * Check if there is one and only one   {@link HlaManager} deployed in thePtolemy model.
 * @exception IllegalActionException If there is zero or more than one{@link HlaManager} per Ptolemy model.
 */
@Override public void initialize() throws IllegalActionException {
  super.initialize();
  CompositeActor ca=(CompositeActor)this.getContainer();
  List<HlaManager> hlaManagers=null;
  while (ca != null) {
    hlaManagers=ca.attributeList(HlaManager.class);
    if (hlaManagers.size() < 1) {
      ca=(CompositeActor)ca.getContainer();
    }
 else {
      break;
    }
  }
  if (hlaManagers.size() > 1) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
 else   if (hlaManagers.size() < 1) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
}","/** 
 * Check if there is one and only one   {@link HlaManager} deployed in thePtolemy model.
 * @exception IllegalActionException If there is zero or more than one{@link HlaManager} per Ptolemy model.
 */
@Override public void initialize() throws IllegalActionException {
  super.initialize();
  CompositeActor ca=(CompositeActor)this.getContainer();
  List<HlaManager> hlaManagers=null;
  while (ca != null) {
    hlaManagers=ca.attributeList(HlaManager.class);
    if (hlaManagers.size() < 1) {
      ca=(CompositeActor)ca.getContainer();
    }
 else {
      break;
    }
  }
  if (hlaManagers == null || hlaManagers.size() < 1) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
 else {
    if (hlaManagers.size() > 1)     throw new IllegalActionException(this,""String_Node_Str"");
  }
}"
72394,"/** 
 * Construct a handler for connections established. This constructor must be called in the verticle thread, not in the director thread.
 * @param eventEmitter The JavaScript object that will emit socketevents.
 * @param socket The Vertx socket object.
 * @param sendType The send type.
 * @param receiveType The receive type.
 * @param rawBytes If true, send and received raw bytes, with nomessage framing. If false, then prepend each sent item with a length, and for received items, assume received data is prepended with a length and emit received data only when a complete message has arrived.
 * @param emitBatchDataAsAvailable Whether to emit all data available when the TCP streamis received and when rawBytes is true. This parameter is intended for socket.js module and this SocketHelper. Thus, this parameter will not be exposed to TCP socket accessors. Set this true only when the TCP stream is going to be handled by upper layer protocols to avoid non-deterministic behavior.
 */
public SocketWrapper(ScriptObjectMirror eventEmitter,Object socket,String sendType,String receiveType,boolean rawBytes,boolean emitBatchDataAsAvailable){
  _eventEmitter=eventEmitter;
  _rawBytes=rawBytes;
  _emitBatchDataAsAvailable=emitBatchDataAsAvailable;
  _socket=(NetSocket)socket;
  try {
    _sendType=Enum.valueOf(DATA_TYPE.class,sendType.trim().toUpperCase());
  }
 catch (  Exception ex) {
    if (getImageTypes().contains(sendType)) {
      _sendImageType=sendType;
      _sendType=DATA_TYPE.IMAGE;
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"" + sendType);
    }
  }
  try {
    _receiveType=Enum.valueOf(DATA_TYPE.class,receiveType.trim().toUpperCase());
  }
 catch (  Exception ex) {
    throw new IllegalArgumentException(""String_Node_Str"" + receiveType);
  }
  _socket.closeHandler((Void) -> {
synchronized (SocketWrapper.this) {
      if (_closed) {
        return;
      }
      _eventEmitter.callMember(""String_Node_Str"",""String_Node_Str"");
      _eventEmitter.callMember(""String_Node_Str"");
      _closed=true;
    }
  }
);
  _socket.drainHandler((Void) -> {
synchronized (SocketWrapper.this) {
      SocketWrapper.this.notifyAll();
    }
  }
);
  _socket.exceptionHandler(throwable -> {
    _error(_eventEmitter,throwable.toString());
  }
);
  _socket.handler(buffer -> {
    _processBuffer(buffer);
  }
);
}","/** 
 * Construct a handler for connections established. This constructor must be called in the verticle thread, not in the director thread.
 * @param eventEmitter The JavaScript object that will emit socketevents.
 * @param socket The Vertx socket object.
 * @param sendType The send type.
 * @param receiveType The receive type.
 * @param rawBytes If true, send and received raw bytes, with nomessage framing. If false, then prepend each sent item with a length, and for received items, assume received data is prepended with a length and emit received data only when a complete message has arrived.
 * @param emitBatchDataAsAvailable Whether to emit all data available when the TCP streamis received and when rawBytes is true. This parameter is intended for socket.js module and this SocketHelper. Thus, this parameter will not be exposed to TCP socket accessors. Set this true only when the TCP stream is going to be handled by upper layer protocols to avoid non-deterministic behavior.
 */
public SocketWrapper(ScriptObjectMirror eventEmitter,Object socket,String sendType,String receiveType,boolean rawBytes,boolean emitBatchDataAsAvailable){
  _eventEmitter=eventEmitter;
  _rawBytes=rawBytes;
  _emitBatchDataAsAvailable=emitBatchDataAsAvailable;
  _socket=(NetSocket)socket;
  try {
    _sendType=Enum.valueOf(DATA_TYPE.class,sendType.trim().toUpperCase());
  }
 catch (  Exception ex) {
    if (getImageTypes().contains(sendType)) {
      _sendImageType=sendType;
      _sendType=DATA_TYPE.IMAGE;
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"" + sendType);
    }
  }
  try {
    _receiveType=Enum.valueOf(DATA_TYPE.class,receiveType.trim().toUpperCase());
  }
 catch (  Exception ex) {
    throw new IllegalArgumentException(""String_Node_Str"" + receiveType);
  }
  _socket.closeHandler((Void) -> {
    _issueResponse(() -> {
synchronized (SocketWrapper.this) {
        if (_closed) {
          return;
        }
        _eventEmitter.callMember(""String_Node_Str"",""String_Node_Str"");
        _eventEmitter.callMember(""String_Node_Str"");
        _closed=true;
      }
    }
);
  }
);
  _socket.drainHandler((Void) -> {
synchronized (SocketWrapper.this) {
      SocketWrapper.this.notifyAll();
    }
  }
);
  _socket.exceptionHandler(throwable -> {
    _error(_eventEmitter,throwable.toString());
  }
);
  _socket.handler(buffer -> {
    _processBuffer(buffer);
  }
);
}"
72395,"/** 
 * Override the base class to not delegate to the container.
 * @return True if change requests are being deferred.
 * @see #setDeferringChangeRequests(boolean)
 * @see Changeable
 */
@Override public boolean isDeferringChangeRequests(){
  return _deferChangeRequests;
}","/** 
 * Override the base class to not delegate up the hierarchy and to indicate only whether this composite is locally deferring change requests. Note that even if this returns false, change requests may be deferred because the container is deferring change requests.
 * @return True if change requests are being deferred.
 * @see #setDeferringChangeRequests(boolean)
 * @see Changeable
 */
@Override public boolean isDeferringChangeRequests(){
  return _deferChangeRequests;
}"
72396,"/** 
 * Override the base class to not delegate up the hierarchy.
 * @param change The requested change.
 * @see #executeChangeRequests()
 * @see #setDeferringChangeRequests(boolean)
 * @see Changeable
 */
@Override public void requestChange(ChangeRequest change){
  List<ChangeRequest> copy=null;
synchronized (_changeLock) {
    if (_changeRequests == null) {
      _changeRequests=new LinkedList<ChangeRequest>();
    }
    _changeRequests.add(change);
    if (!_deferChangeRequests) {
      copy=_copyChangeRequestList();
    }
  }
  if (copy != null) {
    _executeChangeRequests(copy);
  }
}","/** 
 * Override the base class to delegate up the hierarchy only if this composite is not deferring change requests, but the the container is. Otherwise, if this composite is deferring change requests, the defer the change, regardless of what the container is doing. Otherwise, execute the change.
 * @param change The requested change.
 * @see #executeChangeRequests()
 * @see #setDeferringChangeRequests(boolean)
 * @see Changeable
 */
@Override public void requestChange(ChangeRequest change){
  NamedObj container=getContainer();
  if (container != null && !_deferChangeRequests && container.isDeferringChangeRequests()) {
    super.requestChange(change);
    return;
  }
  List<ChangeRequest> copy=null;
synchronized (_changeLock) {
    if (_changeRequests == null) {
      _changeRequests=new LinkedList<ChangeRequest>();
    }
    _changeRequests.add(change);
    if (!_deferChangeRequests) {
      copy=_copyChangeRequestList();
    }
  }
  if (copy != null) {
    _executeChangeRequests(copy);
  }
}"
72397,"/** 
 * Return an array of records representing the most recently detected tags from an invocation of   {@link #filter(BufferedImage,BufferedImage)}, or null if there has been no such invocation or if no tags were detected. Each record includes the following fields: <ul> <li> id: The ID of the detected tag. <li> center: An array with two doubles giving the center of the tag in pixel coordinates. <li> perimeter: An array with four arrays, each of which gives the x and y coordinates of a corner of the AprilTag, listed in a counter-clockwise direction. </ul>
 * @throws IllegalActionException If the array cannot be constructed.
 */
public ArrayToken tags() throws IllegalActionException {
  if (_tags == null || _tags.size() == 0) {
    return null;
  }
  Token[] tags=new RecordToken[_tags.size()];
  int i=0;
  for (  TagDetection tag : _tags) {
    Map<String,Token> fieldMap=new HashMap<String,Token>();
    fieldMap.put(""String_Node_Str"",new IntToken(tag.id));
    DoubleToken[] center=new DoubleToken[2];
    center[0]=new DoubleToken(tag.cxy[0]);
    center[1]=new DoubleToken(tag.cxy[1]);
    fieldMap.put(""String_Node_Str"",new ArrayToken(center));
    DoubleToken[] corner=new DoubleToken[2];
    ArrayToken[] perimeter=new ArrayToken[4];
    for (int k=0; k < 4; k++) {
      corner[0]=new DoubleToken(tag.p[k][0]);
      corner[1]=new DoubleToken(tag.p[k][1]);
      perimeter[k]=new ArrayToken(corner);
    }
    fieldMap.put(""String_Node_Str"",new ArrayToken(perimeter));
    tags[i++]=new RecordToken(fieldMap);
  }
  return new ArrayToken(tags);
}","/** 
 * Return an array of records representing the most recently detected tags from an invocation of   {@link #filter(BufferedImage,BufferedImage)}, or null if there has been no such invocation or if no tags were detected. Each record includes the following fields: <ul> <li> id: The ID of the detected tag. <li> center: An array with two doubles giving the center of the tag in pixel coordinates. <li> perimeter: An array with four arrays, each of which gives the x and y coordinates of a corner of the AprilTag, listed in a counter-clockwise direction. </ul>
 * @exception IllegalActionException If the array cannot be constructed.
 */
public ArrayToken tags() throws IllegalActionException {
  if (_tags == null || _tags.size() == 0) {
    return null;
  }
  Token[] tags=new RecordToken[_tags.size()];
  int i=0;
  for (  TagDetection tag : _tags) {
    Map<String,Token> fieldMap=new HashMap<String,Token>();
    fieldMap.put(""String_Node_Str"",new IntToken(tag.id));
    DoubleToken[] center=new DoubleToken[2];
    center[0]=new DoubleToken(tag.cxy[0]);
    center[1]=new DoubleToken(tag.cxy[1]);
    fieldMap.put(""String_Node_Str"",new ArrayToken(center));
    DoubleToken[] corner=new DoubleToken[2];
    ArrayToken[] perimeter=new ArrayToken[4];
    for (int k=0; k < 4; k++) {
      corner[0]=new DoubleToken(tag.p[k][0]);
      corner[1]=new DoubleToken(tag.p[k][1]);
      perimeter[k]=new ArrayToken(corner);
    }
    fieldMap.put(""String_Node_Str"",new ArrayToken(perimeter));
    tags[i++]=new RecordToken(fieldMap);
  }
  return new ArrayToken(tags);
}"
72398,"/** 
 * Run all the models opened in different threads, waiting for the initialization of the current one to start executing a following one.
 * @throws KernelException
 */
private void _runModels() throws KernelException {
  Iterator<NamedObj> models=super.models().iterator();
  NamedObj model=null;
  Manager manager;
  _wait=false;
  while (models.hasNext()) {
    if (!_wait) {
      model=(NamedObj)models.next();
      if (model instanceof CompositeActor) {
        CompositeActor actor=(CompositeActor)model;
        if (_statistics) {
          System.out.println(""String_Node_Str"" + model.getFullName());
          System.out.println(((CompositeEntity)model).statistics(null));
        }
        manager=actor.getManager();
        if (manager == null) {
          manager=new Manager(actor.workspace(),""String_Node_Str"");
          actor.setManager(manager);
        }
        manager.addExecutionListener(this);
        this.setActiveCount(this.getActiveCount() + 1);
        _wait=true;
        manager.startRun();
        System.out.println(""String_Node_Str"" + model.getDisplayName() + ""String_Node_Str"");
      }
    }
 else {
      System.out.println(""String_Node_Str"" + model.getDisplayName() + ""String_Node_Str"");
      _sleep(50);
    }
  }
}","/** 
 * Run all the models opened in different threads, waiting for the initialization of the current one to start executing a following one.
 * @exception KernelException
 */
private void _runModels() throws KernelException {
  Iterator<NamedObj> models=super.models().iterator();
  NamedObj model=null;
  Manager manager;
  _wait=false;
  while (models.hasNext()) {
    if (!_wait) {
      model=(NamedObj)models.next();
      if (model instanceof CompositeActor) {
        CompositeActor actor=(CompositeActor)model;
        if (_statistics) {
          System.out.println(""String_Node_Str"" + model.getFullName());
          System.out.println(((CompositeEntity)model).statistics(null));
        }
        manager=actor.getManager();
        if (manager == null) {
          manager=new Manager(actor.workspace(),""String_Node_Str"");
          actor.setManager(manager);
        }
        manager.addExecutionListener(this);
        this.setActiveCount(this.getActiveCount() + 1);
        _wait=true;
        manager.startRun();
        System.out.println(""String_Node_Str"" + model.getDisplayName() + ""String_Node_Str"");
      }
    }
 else {
      System.out.println(""String_Node_Str"" + model.getDisplayName() + ""String_Node_Str"");
      _sleep(50);
    }
  }
}"
72399,"/** 
 * Get hlaNextPointInTime in HLA to advance to when TAR is used. hlaNextPointInTime = hlaCurrentTime + Ts.
 * @return next point in time to advance to.
 * @throws IllegalActionException if hlaTimeStep is NULL.
 */
private Time _getHlaNextPointInTime() throws IllegalActionException {
  Double time=_getHlaCurrentTime().add(_hlaTimeStep).getDoubleValue();
  time=_roundDoubles(time);
  return _convertToPtolemyTime(new CertiLogicalTime(time));
}","/** 
 * Get hlaNextPointInTime in HLA to advance to when TAR is used. hlaNextPointInTime = hlaCurrentTime + Ts.
 * @return next point in time to advance to.
 * @exception IllegalActionException if hlaTimeStep is NULL.
 */
private Time _getHlaNextPointInTime() throws IllegalActionException {
  Double time=_getHlaCurrentTime().add(_hlaTimeStep).getDoubleValue();
  time=_roundDoubles(time);
  return _convertToPtolemyTime(new CertiLogicalTime(time));
}"
72400,"/** 
 * Make a conversion from certi logical time to ptolemy time
 * @param ct certi logical time
 * @return ptolemy time
 * @throws IllegalActionException
 */
private Time _convertToPtolemyTime(CertiLogicalTime ct) throws IllegalActionException {
  return new Time(_director,_roundDoubles(ct.getTime() / _hlaTimeUnitValue));
}","/** 
 * Make a conversion from certi logical time to ptolemy time
 * @param ct certi logical time
 * @return ptolemy time
 * @exception IllegalActionException
 */
private Time _convertToPtolemyTime(CertiLogicalTime ct) throws IllegalActionException {
  return new Time(_director,_roundDoubles(ct.getTime() / _hlaTimeUnitValue));
}"
72401,"/** 
 * Initialize Federate's timing properties provided by the user.
 * @param startTime The start time of the Federate logical clock.
 * @param timeStep The time step of the Federate.
 * @param lookAHead The contract value used by HLA/CERTI to synchronizethe Federates and to order TSO events.
 * @throws IllegalActionException
 */
public void initializeTimeValues(Double startTime,Double lookAHead) throws IllegalActionException {
  if (lookAHead <= 0) {
    throw new IllegalActionException(null,null,null,""String_Node_Str"");
  }
  logicalTimeHLA=new CertiLogicalTime(startTime);
  effectiveLookAHead=new CertiLogicalTimeInterval(lookAHead * _hlaTimeUnitValue);
  if (_debugging) {
    _debug(""String_Node_Str"" + effectiveLookAHead.toString());
  }
  timeAdvanceGrant=false;
}","/** 
 * Initialize Federate's timing properties provided by the user.
 * @param startTime The start time of the Federate logical clock.
 * @param timeStep The time step of the Federate.
 * @param lookAHead The contract value used by HLA/CERTI to synchronizethe Federates and to order TSO events.
 * @exception IllegalActionException
 */
public void initializeTimeValues(Double startTime,Double lookAHead) throws IllegalActionException {
  if (lookAHead <= 0) {
    throw new IllegalActionException(null,null,null,""String_Node_Str"");
  }
  logicalTimeHLA=new CertiLogicalTime(startTime);
  effectiveLookAHead=new CertiLogicalTimeInterval(lookAHead * _hlaTimeUnitValue);
  if (_debugging) {
    _debug(""String_Node_Str"" + effectiveLookAHead.toString());
  }
  timeAdvanceGrant=false;
}"
72402,"/** 
 * Will enable all time regulating aspect for the federate. After this call the federate as stated to the RTI if it time regulating and/or time regulator and has enable asynchronous delivery for RO messages
 * @throws IllegalActionException
 */
private void _initializeTimeAspects() throws IllegalActionException {
  _federateAmbassador.initializeTimeValues(0.0,_hlaLookAHead);
  if (_isTimeConstrained) {
    try {
      _rtia.enableTimeConstrained();
    }
 catch (    RTIexception e) {
      throw new IllegalActionException(this,e,e.getMessage());
    }
  }
  if (_isTimeRegulator) {
    try {
      _rtia.enableTimeRegulation(_federateAmbassador.logicalTimeHLA,_federateAmbassador.effectiveLookAHead);
    }
 catch (    RTIexception e) {
      throw new IllegalActionException(this,e,e.getMessage());
    }
  }
  if (_isTimeRegulator && _isTimeConstrained) {
    while (!(_federateAmbassador.timeConstrained)) {
      try {
        _rtia.tick2();
        _numberOfTicks2++;
        if (_timeOfTheLastAdvanceRequest > 0) {
          _numberOfTicks.set(_numberOfTAGs,_numberOfTicks.get(_numberOfTAGs) + 1);
        }
 else {
          _numberOfOtherTicks++;
        }
      }
 catch (      RTIexception e) {
        throw new IllegalActionException(this,e,e.getMessage());
      }
    }
    while (!(_federateAmbassador.timeRegulator)) {
      try {
        _rtia.tick2();
        _numberOfTicks2++;
        if (_timeOfTheLastAdvanceRequest > 0) {
          _numberOfTicks.set(_numberOfTAGs,_numberOfTicks.get(_numberOfTAGs) + 1);
        }
 else {
          _numberOfOtherTicks++;
        }
      }
 catch (      RTIexception e) {
        throw new IllegalActionException(this,e,e.getMessage());
      }
    }
    if (_debugging) {
      _debug(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + _federateAmbassador.timeConstrained + ""String_Node_Str""+ _federateAmbassador.timeRegulator);
    }
    try {
      _rtia.enableAsynchronousDelivery();
    }
 catch (    RTIexception e) {
      throw new IllegalActionException(this,e,e.getMessage());
    }
  }
}","/** 
 * Will enable all time regulating aspect for the federate. After this call the federate as stated to the RTI if it time regulating and/or time regulator and has enable asynchronous delivery for RO messages
 * @exception IllegalActionException
 */
private void _initializeTimeAspects() throws IllegalActionException {
  _federateAmbassador.initializeTimeValues(0.0,_hlaLookAHead);
  if (_isTimeConstrained) {
    try {
      _rtia.enableTimeConstrained();
    }
 catch (    RTIexception e) {
      throw new IllegalActionException(this,e,e.getMessage());
    }
  }
  if (_isTimeRegulator) {
    try {
      _rtia.enableTimeRegulation(_federateAmbassador.logicalTimeHLA,_federateAmbassador.effectiveLookAHead);
    }
 catch (    RTIexception e) {
      throw new IllegalActionException(this,e,e.getMessage());
    }
  }
  if (_isTimeRegulator && _isTimeConstrained) {
    while (!(_federateAmbassador.timeConstrained)) {
      try {
        _rtia.tick2();
        _numberOfTicks2++;
        if (_timeOfTheLastAdvanceRequest > 0) {
          _numberOfTicks.set(_numberOfTAGs,_numberOfTicks.get(_numberOfTAGs) + 1);
        }
 else {
          _numberOfOtherTicks++;
        }
      }
 catch (      RTIexception e) {
        throw new IllegalActionException(this,e,e.getMessage());
      }
    }
    while (!(_federateAmbassador.timeRegulator)) {
      try {
        _rtia.tick2();
        _numberOfTicks2++;
        if (_timeOfTheLastAdvanceRequest > 0) {
          _numberOfTicks.set(_numberOfTAGs,_numberOfTicks.get(_numberOfTAGs) + 1);
        }
 else {
          _numberOfOtherTicks++;
        }
      }
 catch (      RTIexception e) {
        throw new IllegalActionException(this,e,e.getMessage());
      }
    }
    if (_debugging) {
      _debug(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + _federateAmbassador.timeConstrained + ""String_Node_Str""+ _federateAmbassador.timeRegulator);
    }
    try {
      _rtia.enableAsynchronousDelivery();
    }
 catch (    RTIexception e) {
      throw new IllegalActionException(this,e,e.getMessage());
    }
  }
}"
72403,"/** 
 * Indicate if the HLA publisher actor uses the CERTI message buffer API.
 * @return true if the HLA publisher actor uses the CERTI message and false ifit doesn't.
 * @throws IllegalActionException
 */
public boolean useCertiMessageBuffer() throws IllegalActionException {
  return _useCertiMessageBuffer;
}","/** 
 * Indicate if the HLA publisher actor uses the CERTI message buffer API.
 * @return true if the HLA publisher actor uses the CERTI message and false ifit doesn't.
 * @exception IllegalActionException
 */
public boolean useCertiMessageBuffer() throws IllegalActionException {
  return _useCertiMessageBuffer;
}"
72404,"/** 
 * Indicate if the HLA subscriber actor uses the CERTI message buffer API.
 * @return true if the HLA publisher actor uses the CERTI message and false ifit doesn't.
 * @throws IllegalActionException
 */
public boolean useCertiMessageBuffer() throws IllegalActionException {
  return _useCertiMessageBuffer;
}","/** 
 * Indicate if the HLA subscriber actor uses the CERTI message buffer API.
 * @return true if the HLA publisher actor uses the CERTI message and false ifit doesn't.
 * @exception IllegalActionException
 */
public boolean useCertiMessageBuffer() throws IllegalActionException {
  return _useCertiMessageBuffer;
}"
72405,"/** 
 * Pick k random cluster centers given the range of input data. This implementation uses the Random Partition method for initialization, that is, it assigns a cluster at random to each data point, and computes initial cluster centers.
 * @throws IllegalActionException
 */
private void _initializeClusterCenters() throws IllegalActionException {
  Random clusterIndex=new Random();
  _clusterAssignment=new int[_trainingData.length];
  for (int k=0; k < _trainingData.length; k++) {
    _clusterAssignment[k]=clusterIndex.nextInt(_numClusters);
  }
  _updateClusterCenters();
}","/** 
 * Pick k random cluster centers given the range of input data. This implementation uses the Random Partition method for initialization, that is, it assigns a cluster at random to each data point, and computes initial cluster centers.
 * @exception IllegalActionException
 */
private void _initializeClusterCenters() throws IllegalActionException {
  Random clusterIndex=new Random();
  _clusterAssignment=new int[_trainingData.length];
  for (int k=0; k < _trainingData.length; k++) {
    _clusterAssignment[k]=clusterIndex.nextInt(_numClusters);
  }
  _updateClusterCenters();
}"
72406,"/** 
 * Compute the new cluster centers, that is, the centroid of the data points that belong to this cluster. For the Euclidean distance measure, this is simply the average of the points in the cluster.
 * @throws IllegalActionException
 */
private void _updateClusterCenters() throws IllegalActionException {
  _clusterCenters.clear();
switch (_distanceMeasure) {
case EUCLIDEAN:
    double[][] newClusterCenters=new double[_numClusters][_featureLength];
  int[] samplesInCluster=new int[_numClusters];
for (int i=0; i < _trainingData.length; i++) {
  for (int j=0; j < _featureLength; j++) {
    newClusterCenters[_clusterAssignment[i]][j]+=_trainingData[i][j];
  }
  samplesInCluster[_clusterAssignment[i]]++;
}
for (int i=0; i < _numClusters; i++) {
for (int j=0; j < _featureLength; j++) {
  if (samplesInCluster[i] > 0) {
    newClusterCenters[i][j]/=samplesInCluster[i];
  }
}
}
for (int i=0; i < _numClusters; i++) {
if (_featureLength > 1) {
_clusterCenters.add(newClusterCenters[i]);
}
 else {
_clusterCenters.add(newClusterCenters[i][0]);
}
}
break;
default :
throw new IllegalActionException(this,""String_Node_Str"");
}
}","/** 
 * Compute the new cluster centers, that is, the centroid of the data points that belong to this cluster. For the Euclidean distance measure, this is simply the average of the points in the cluster.
 * @exception IllegalActionException
 */
private void _updateClusterCenters() throws IllegalActionException {
  _clusterCenters.clear();
switch (_distanceMeasure) {
case EUCLIDEAN:
    double[][] newClusterCenters=new double[_numClusters][_featureLength];
  int[] samplesInCluster=new int[_numClusters];
for (int i=0; i < _trainingData.length; i++) {
  for (int j=0; j < _featureLength; j++) {
    newClusterCenters[_clusterAssignment[i]][j]+=_trainingData[i][j];
  }
  samplesInCluster[_clusterAssignment[i]]++;
}
for (int i=0; i < _numClusters; i++) {
for (int j=0; j < _featureLength; j++) {
  if (samplesInCluster[i] > 0) {
    newClusterCenters[i][j]/=samplesInCluster[i];
  }
}
}
for (int i=0; i < _numClusters; i++) {
if (_featureLength > 1) {
_clusterCenters.add(newClusterCenters[i]);
}
 else {
_clusterCenters.add(newClusterCenters[i][0]);
}
}
break;
default :
throw new IllegalActionException(this,""String_Node_Str"");
}
}"
72407,"/** 
 * <<<<<<< .mine Do FFTs on all channels for this block and save to the array
 * @param startIndex Chunk Index
 * @throws IllegalActionException ======= Convert to Equivalent Rectangular Bandwidth (ERB) scale from Hz.
 * @param frequencyInHz Frequency in Hz
 * @return frequency in ERB scale>>>>>>> .r73083
 */
private void doBlockFFT(int startIndex) throws IllegalActionException {
  ExecutorService executor=Executors.newFixedThreadPool(_numChannels);
  for (int i=0; i < _numChannels; i++) {
    executor.execute(new FFTWorker(i,startIndex));
  }
  executor.shutdown();
  try {
    executor.awaitTermination(1,TimeUnit.SECONDS);
  }
 catch (  InterruptedException e) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
}","/** 
 * <<<<<<< .mine Do FFTs on all channels for this block and save to the array
 * @param startIndex Chunk Index
 * @exception IllegalActionException ======= Convert to Equivalent Rectangular Bandwidth (ERB) scale from Hz.
 * @param frequencyInHz Frequency in Hz
 * @return frequency in ERB scale>>>>>>> .r73083
 */
private void doBlockFFT(int startIndex) throws IllegalActionException {
  ExecutorService executor=Executors.newFixedThreadPool(_numChannels);
  for (int i=0; i < _numChannels; i++) {
    executor.execute(new FFTWorker(i,startIndex));
  }
  executor.shutdown();
  try {
    executor.awaitTermination(1,TimeUnit.SECONDS);
  }
 catch (  InterruptedException e) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
}"
72408,"/** 
 * Multithreaded FIR Gammatone filtering.
 * @param input
 * @return
 * @throws IllegalActionException
 */
private void multithreadedFeatureExtraction() throws IllegalActionException {
  ExecutorService executor=Executors.newFixedThreadPool(_numChannels);
  for (int i=0; i < _numChannels; i++) {
    executor.execute(new GammatoneFilter(i));
  }
  executor.shutdown();
  try {
    executor.awaitTermination(1,TimeUnit.SECONDS);
  }
 catch (  InterruptedException e) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
}","/** 
 * Multithreaded FIR Gammatone filtering.
 * @param input
 * @return
 * @exception IllegalActionException
 */
private void multithreadedFeatureExtraction() throws IllegalActionException {
  ExecutorService executor=Executors.newFixedThreadPool(_numChannels);
  for (int i=0; i < _numChannels; i++) {
    executor.execute(new GammatoneFilter(i));
  }
  executor.shutdown();
  try {
    executor.awaitTermination(1,TimeUnit.SECONDS);
  }
 catch (  InterruptedException e) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
}"
72409,"/** 
 * <<<<<<< .mine Do FFTs on all channels for this block and save to the array
 * @param startIndex Chunk Index
 * @throws IllegalActionException ======= Convert to Equivalent Rectangular Bandwidth (ERB) scale from Hz.
 * @param frequencyInHz Frequency in Hz
 * @return frequency in ERB scale>>>>>>> .r73083
 */
private void doBlockFFT(int startIndex) throws IllegalActionException {
  ExecutorService executor=Executors.newFixedThreadPool(_numChannels);
  for (int i=0; i < _numChannels; i++) {
    executor.execute(new FFTWorker(i,startIndex));
  }
  executor.shutdown();
  try {
    executor.awaitTermination(1,TimeUnit.SECONDS);
  }
 catch (  InterruptedException e) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
}","/** 
 * <<<<<<< .mine Do FFTs on all channels for this block and save to the array
 * @param startIndex Chunk Index
 * @exception IllegalActionException ======= Convert to Equivalent Rectangular Bandwidth (ERB) scale from Hz.
 * @param frequencyInHz Frequency in Hz
 * @return frequency in ERB scale>>>>>>> .r73083
 */
private void doBlockFFT(int startIndex) throws IllegalActionException {
  ExecutorService executor=Executors.newFixedThreadPool(_numChannels);
  for (int i=0; i < _numChannels; i++) {
    executor.execute(new FFTWorker(i,startIndex));
  }
  executor.shutdown();
  try {
    executor.awaitTermination(1,TimeUnit.SECONDS);
  }
 catch (  InterruptedException e) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
}"
72410,"/** 
 * Multithreaded FIR Gammatone filtering.
 * @param input
 * @return
 * @throws IllegalActionException
 */
private void multithreadedFeatureExtraction() throws IllegalActionException {
  ExecutorService executor=Executors.newFixedThreadPool(_numChannels);
  for (int i=0; i < _numChannels; i++) {
    executor.execute(new GammatoneFilter(i));
  }
  executor.shutdown();
  try {
    executor.awaitTermination(1,TimeUnit.SECONDS);
  }
 catch (  InterruptedException e) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
}","/** 
 * Multithreaded FIR Gammatone filtering.
 * @param input
 * @return
 * @exception IllegalActionException
 */
private void multithreadedFeatureExtraction() throws IllegalActionException {
  ExecutorService executor=Executors.newFixedThreadPool(_numChannels);
  for (int i=0; i < _numChannels; i++) {
    executor.execute(new GammatoneFilter(i));
  }
  executor.shutdown();
  try {
    executor.awaitTermination(1,TimeUnit.SECONDS);
  }
 catch (  InterruptedException e) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
}"
72411,"/** 
 * Return the Parameter that is part of a state space model.
 * @param parameterName Name of parameter
 * @return Parameter object
 * @throws IllegalActionException
 */
protected abstract Parameter getUserDefinedParameter(String parameterName) throws IllegalActionException ;","/** 
 * Return the Parameter that is part of a state space model.
 * @param parameterName Name of parameter
 * @return Parameter object
 * @exception IllegalActionException
 */
protected abstract Parameter getUserDefinedParameter(String parameterName) throws IllegalActionException ;"
72412,"/** 
 * Return the expression for a user-defined parameter.
 * @param parameterName Name of parameter
 * @return parameter expression
 * @throws IllegalActionException
 */
protected String getUserDefinedParameterExpression(String parameterName) throws IllegalActionException {
  Parameter param=getUserDefinedParameter(parameterName);
  if (param != null) {
    return param.getExpression();
  }
 else {
    throw new IllegalActionException(""String_Node_Str"" + parameterName + ""String_Node_Str"");
  }
}","/** 
 * Return the expression for a user-defined parameter.
 * @param parameterName Name of parameter
 * @return parameter expression
 * @exception IllegalActionException
 */
protected String getUserDefinedParameterExpression(String parameterName) throws IllegalActionException {
  Parameter param=getUserDefinedParameter(parameterName);
  if (param != null) {
    return param.getExpression();
  }
 else {
    throw new IllegalActionException(""String_Node_Str"" + parameterName + ""String_Node_Str"");
  }
}"
72413,"/** 
 * Verify the signature for given input data and public key of the signer.
 * @param data The input data to be verified.
 * @param signature The signature to be verified.
 * @param publicKey The public key to be used for signature verification.
 * @param signAlgorithm The name of the algorithm to be used for signature verification.
 * @return Whether the signature is valid.
 * @throws IllegalArgumentException
 */
public boolean verifySignature(Object data,Object signature,PublicKey publicKey,String signAlgorithm) throws IllegalArgumentException {
  Signature verifier;
  try {
    verifier=Signature.getInstance(signAlgorithm);
    verifier.initVerify(publicKey);
    verifier.update(_toJavaBytes(data));
    return verifier.verify(_toJavaBytes(signature));
  }
 catch (  NoSuchAlgorithmException|InvalidKeyException|SignatureException|IllegalActionException e) {
    throw new IllegalArgumentException(""String_Node_Str"" + e.getMessage());
  }
}","/** 
 * Verify the signature for given input data and public key of the signer.
 * @param data The input data to be verified.
 * @param signature The signature to be verified.
 * @param publicKey The public key to be used for signature verification.
 * @param signAlgorithm The name of the algorithm to be used for signature verification.
 * @return Whether the signature is valid.
 * @throws IllegalArgumentException
 */
public boolean verifySignature(Object data,Object signature,PublicKey publicKey,String signAlgorithm) throws IllegalArgumentException {
  Signature verifier;
  try {
    verifier=Signature.getInstance(signAlgorithm);
    verifier.initVerify(publicKey);
    verifier.update(_toJavaBytes(data));
    return verifier.verify(_toJavaBytes(signature));
  }
 catch (  NoSuchAlgorithmException|InvalidKeyException|SignatureException|IllegalActionException e) {
    throw new IllegalArgumentException(""String_Node_Str"",e);
  }
}"
72414,"/** 
 * Perform asymmetric cryptography operation (encrypt or decrypt) and return the result.
 * @param operationMode Whether to encrypt or decrypt. (Cipher.ENCRYPT_MODE or Cipher.DECRYPT_MODE)
 * @param input The input data (clear text or cipher text) to be operated.
 * @param key The asymmetric cipher key to be used.
 * @param cipherAlgorithm The name of the symmetric cipher algorithm to be used. (Examples: RSA/ECB/PKCS1PADDING)
 * @return The cryptography operation result
 * @throws IllegalActionException If the cryptography operation fails.
 */
private Object _performAsymmetricCrypto(int operationMode,Object input,Key key,String cipherAlgorithm) throws IllegalActionException {
  Cipher cipher=null;
  try {
    cipher=Cipher.getInstance(cipherAlgorithm);
  }
 catch (  NoSuchAlgorithmException|NoSuchPaddingException e) {
    throw new IllegalArgumentException(""String_Node_Str"" + input + ""String_Node_Str""+ e.getMessage());
  }
  try {
    cipher.init(operationMode,key);
  }
 catch (  InvalidKeyException e) {
    throw new IllegalArgumentException(""String_Node_Str"" + input + ""String_Node_Str""+ e.getMessage());
  }
  ByteArrayOutputStream byteArrayOutputStream=new ByteArrayOutputStream();
  try {
    byteArrayOutputStream.write(cipher.doFinal(_toJavaBytes(input)));
  }
 catch (  IllegalBlockSizeException|BadPaddingException|IOException e) {
    throw new IllegalArgumentException(""String_Node_Str"" + input + ""String_Node_Str""+ e.getMessage());
  }
  return _toJSArray(byteArrayOutputStream.toByteArray());
}","/** 
 * Perform asymmetric cryptography operation (encrypt or decrypt) and return the result.
 * @param operationMode Whether to encrypt or decrypt. (Cipher.ENCRYPT_MODE or Cipher.DECRYPT_MODE)
 * @param input The input data (clear text or cipher text) to be operated.
 * @param key The asymmetric cipher key to be used.
 * @param cipherAlgorithm The name of the symmetric cipher algorithm to be used. (Examples: RSA/ECB/PKCS1PADDING)
 * @return The cryptography operation result
 * @throws IllegalActionException If the cryptography operation fails.
 */
private Object _performAsymmetricCrypto(int operationMode,Object input,Key key,String cipherAlgorithm) throws IllegalActionException {
  Cipher cipher=null;
  try {
    cipher=Cipher.getInstance(cipherAlgorithm);
  }
 catch (  NoSuchAlgorithmException|NoSuchPaddingException e) {
    throw new IllegalArgumentException(""String_Node_Str"" + input,e);
  }
  try {
    cipher.init(operationMode,key);
  }
 catch (  InvalidKeyException e) {
    throw new IllegalArgumentException(""String_Node_Str"" + input,e);
  }
  ByteArrayOutputStream byteArrayOutputStream=new ByteArrayOutputStream();
  try {
    byteArrayOutputStream.write(cipher.doFinal(_toJavaBytes(input)));
  }
 catch (  IllegalBlockSizeException|BadPaddingException|IOException e) {
    throw new IllegalArgumentException(""String_Node_Str"" + input,e);
  }
  return _toJSArray(byteArrayOutputStream.toByteArray());
}"
72415,"/** 
 * Load and return a public key from a X.509 certificate file in PEM format.
 * @param filePath The path for the file that stores a X.509 certificate.
 * @return PublicKey object loaded from the certificate.
 * @throws IllegalActionException If there is a problem with loading the public key.
 */
public PublicKey loadPublicKey(String filePath) throws IllegalActionException {
  try {
    CertificateFactory certFactory=CertificateFactory.getInstance(""String_Node_Str"");
    File file=FileUtilities.nameToFile(filePath,null);
    FileInputStream inStream=new FileInputStream(file);
    X509Certificate cert=(X509Certificate)certFactory.generateCertificate(inStream);
    return cert.getPublicKey();
  }
 catch (  CertificateException|FileNotFoundException e) {
    throw new IllegalArgumentException(""String_Node_Str"" + filePath + ""String_Node_Str""+ e.getMessage());
  }
}","/** 
 * Load and return a public key from a X.509 certificate file in PEM format.
 * @param filePath The path for the file that stores a X.509 certificate.
 * @return PublicKey object loaded from the certificate.
 * @throws IllegalActionException If there is a problem with loading the public key.
 */
public PublicKey loadPublicKey(String filePath) throws IllegalActionException {
  FileInputStream inStream=null;
  try {
    CertificateFactory certFactory=CertificateFactory.getInstance(""String_Node_Str"");
    File file=FileUtilities.nameToFile(filePath,null);
    inStream=new FileInputStream(file);
    X509Certificate cert=(X509Certificate)certFactory.generateCertificate(inStream);
    return cert.getPublicKey();
  }
 catch (  CertificateException|FileNotFoundException e) {
    throw new IllegalArgumentException(""String_Node_Str"" + filePath,e);
  }
 finally {
    if (inStream != null) {
      try {
        inStream.close();
      }
 catch (      IOException ex) {
        throw new IllegalActionException(null,ex,""String_Node_Str"" + filePath);
      }
    }
  }
}"
72416,"/** 
 * Initialize and return a Java Cipher object for the specified operation mode, cipher algorithm, cipher key and initialization vector (if applicable) in the prefix of the cipher text.
 * @param operationMode Whether to encrypt or decrypt. (Cipher.ENCRYPT_MODE or Cipher.DECRYPT_MODE)
 * @param cipherAlgorithm The name of the symmetric cipher algorithm to be used. (examples: AES-128-CBC, DES-ECB)
 * @param cipherKey The secret key for the cipher.
 * @param cipherText The cipher text that includes the initialization vector (IV). Should be nullif the operation mode is encrypt or the cipher algorithm does not use IV. 
 * @return An initialized Java Cipher object.
 * @throws IllegalArgumentException If the Java Cipher object cannot be initialized.
 */
private Cipher _getCipher(int operationMode,String cipherAlgorithm,byte[] cipherKey,byte[] cipherText) throws IllegalArgumentException {
  String[] tokens=cipherAlgorithm.split(""String_Node_Str"");
  if (tokens.length < 1) {
    throw new IllegalArgumentException(""String_Node_Str"" + cipherAlgorithm);
  }
  int keySize=0;
  int blockSize=0;
  int ivSize=0;
  String cipherName=""String_Node_Str"";
  String cipherMode=""String_Node_Str"";
  if (tokens[0].equals(""String_Node_Str"")) {
    cipherName=tokens[0];
    blockSize=16;
    if (tokens.length != 3) {
      throw new IllegalArgumentException(""String_Node_Str"" + cipherAlgorithm);
    }
    if (tokens[1].equals(""String_Node_Str"")) {
      keySize=16;
    }
 else     if (tokens[1].equals(""String_Node_Str"")) {
      keySize=24;
    }
 else     if (tokens[1].equals(""String_Node_Str"")) {
      keySize=32;
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"" + cipherAlgorithm);
    }
    if (tokens[2].equals(""String_Node_Str"")) {
      cipherMode=tokens[2];
    }
 else     if (tokens[2].equals(""String_Node_Str"") || tokens[2].equals(""String_Node_Str"")) {
      cipherMode=tokens[2];
      ivSize=blockSize;
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"" + cipherAlgorithm);
    }
  }
 else   if (tokens[0].equals(""String_Node_Str"")) {
    cipherName=tokens[0];
    keySize=8;
    blockSize=8;
    if (tokens.length != 2) {
      throw new IllegalArgumentException(""String_Node_Str"" + cipherAlgorithm);
    }
    if (tokens[1].equals(""String_Node_Str"")) {
      cipherMode=tokens[1];
    }
 else     if (tokens[1].equals(""String_Node_Str"")) {
      cipherMode=tokens[1];
      ivSize=blockSize;
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"" + cipherAlgorithm);
    }
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + cipherAlgorithm);
  }
  Cipher cipher;
  try {
    cipher=Cipher.getInstance(cipherName + ""String_Node_Str"" + cipherMode+ ""String_Node_Str"");
  }
 catch (  NoSuchAlgorithmException|NoSuchPaddingException e) {
    throw new IllegalArgumentException(""String_Node_Str"" + cipherAlgorithm + ""String_Node_Str""+ e.getMessage());
  }
  IvParameterSpec ivSpec=null;
  byte[] initVector=null;
  if (ivSize > 0) {
    if (cipherText == null) {
      initVector=_getRandomBytes(ivSize);
    }
 else {
      initVector=Arrays.copyOfRange(cipherText,0,ivSize);
    }
    ivSpec=new IvParameterSpec(initVector);
  }
  if (cipherKey.length != keySize) {
    throw new IllegalArgumentException(""String_Node_Str"" + cipherAlgorithm);
  }
  SecretKeySpec secretKeySpec=new SecretKeySpec(cipherKey,cipherName);
  try {
    if (ivSpec != null) {
      cipher.init(operationMode,secretKeySpec,ivSpec);
    }
 else {
      cipher.init(operationMode,secretKeySpec);
    }
  }
 catch (  InvalidKeyException|InvalidAlgorithmParameterException e) {
    throw new IllegalArgumentException(""String_Node_Str"" + cipherAlgorithm + ""String_Node_Str""+ e.getMessage());
  }
  return cipher;
}","/** 
 * Initialize and return a Java Cipher object for the specified operation mode, cipher algorithm, cipher key and initialization vector (if applicable) in the prefix of the cipher text.
 * @param operationMode Whether to encrypt or decrypt. (Cipher.ENCRYPT_MODE or Cipher.DECRYPT_MODE)
 * @param cipherAlgorithm The name of the symmetric cipher algorithm to be used. (examples: AES-128-CBC, DES-ECB)
 * @param cipherKey The secret key for the cipher.
 * @param cipherText The cipher text that includes the initialization vector (IV). Should be nullif the operation mode is encrypt or the cipher algorithm does not use IV. 
 * @return An initialized Java Cipher object.
 * @throws IllegalArgumentException If the Java Cipher object cannot be initialized.
 */
private Cipher _getCipher(int operationMode,String cipherAlgorithm,byte[] cipherKey,byte[] cipherText) throws IllegalArgumentException {
  String[] tokens=cipherAlgorithm.split(""String_Node_Str"");
  if (tokens.length < 1) {
    throw new IllegalArgumentException(""String_Node_Str"" + cipherAlgorithm);
  }
  int keySize=0;
  int blockSize=0;
  int ivSize=0;
  String cipherName=""String_Node_Str"";
  String cipherMode=""String_Node_Str"";
  if (tokens[0].equals(""String_Node_Str"")) {
    cipherName=tokens[0];
    blockSize=16;
    if (tokens.length != 3) {
      throw new IllegalArgumentException(""String_Node_Str"" + cipherAlgorithm);
    }
    if (tokens[1].equals(""String_Node_Str"")) {
      keySize=16;
    }
 else     if (tokens[1].equals(""String_Node_Str"")) {
      keySize=24;
    }
 else     if (tokens[1].equals(""String_Node_Str"")) {
      keySize=32;
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"" + cipherAlgorithm);
    }
    if (tokens[2].equals(""String_Node_Str"")) {
      cipherMode=tokens[2];
    }
 else     if (tokens[2].equals(""String_Node_Str"") || tokens[2].equals(""String_Node_Str"")) {
      cipherMode=tokens[2];
      ivSize=blockSize;
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"" + cipherAlgorithm);
    }
  }
 else   if (tokens[0].equals(""String_Node_Str"")) {
    cipherName=tokens[0];
    keySize=8;
    blockSize=8;
    if (tokens.length != 2) {
      throw new IllegalArgumentException(""String_Node_Str"" + cipherAlgorithm);
    }
    if (tokens[1].equals(""String_Node_Str"")) {
      cipherMode=tokens[1];
    }
 else     if (tokens[1].equals(""String_Node_Str"")) {
      cipherMode=tokens[1];
      ivSize=blockSize;
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"" + cipherAlgorithm);
    }
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + cipherAlgorithm);
  }
  Cipher cipher;
  try {
    cipher=Cipher.getInstance(cipherName + ""String_Node_Str"" + cipherMode+ ""String_Node_Str"");
  }
 catch (  NoSuchAlgorithmException|NoSuchPaddingException e) {
    throw new IllegalArgumentException(""String_Node_Str"" + cipherAlgorithm,e);
  }
  IvParameterSpec ivSpec=null;
  byte[] initVector=null;
  if (ivSize > 0) {
    if (cipherText == null) {
      initVector=_getRandomBytes(ivSize);
    }
 else {
      initVector=Arrays.copyOfRange(cipherText,0,ivSize);
    }
    ivSpec=new IvParameterSpec(initVector);
  }
  if (cipherKey.length != keySize) {
    throw new IllegalArgumentException(""String_Node_Str"" + cipherAlgorithm);
  }
  SecretKeySpec secretKeySpec=new SecretKeySpec(cipherKey,cipherName);
  try {
    if (ivSpec != null) {
      cipher.init(operationMode,secretKeySpec,ivSpec);
    }
 else {
      cipher.init(operationMode,secretKeySpec);
    }
  }
 catch (  InvalidKeyException|InvalidAlgorithmParameterException e) {
    throw new IllegalArgumentException(""String_Node_Str"" + cipherAlgorithm,e);
  }
  return cipher;
}"
72417,"/** 
 * Load and return a private key from a RSA private key file in DER format.
 * @param filePath The path for the file that stores a RSA private key in DER format.
 * @return PrivateKey object loaded from the file.
 * @throws IllegalActionException If there is a problem with loading the private key.
 */
public PrivateKey loadPrivateKey(String filePath) throws IllegalActionException {
  if (!filePath.endsWith(""String_Node_Str"")) {
    throw new IllegalArgumentException(""String_Node_Str"" + filePath);
  }
  PKCS8EncodedKeySpec keySpec=new PKCS8EncodedKeySpec(_readBinaryFile(filePath));
  KeyFactory keyFactory;
  try {
    keyFactory=KeyFactory.getInstance(""String_Node_Str"");
    return keyFactory.generatePrivate(keySpec);
  }
 catch (  NoSuchAlgorithmException|InvalidKeySpecException e) {
    throw new IllegalArgumentException(""String_Node_Str"" + filePath + ""String_Node_Str""+ e.getMessage());
  }
}","/** 
 * Load and return a private key from a RSA private key file in DER format.
 * @param filePath The path for the file that stores a RSA private key in DER format.
 * @return PrivateKey object loaded from the file.
 * @throws IllegalActionException If there is a problem with loading the private key.
 */
public PrivateKey loadPrivateKey(String filePath) throws IllegalActionException {
  if (!filePath.endsWith(""String_Node_Str"")) {
    throw new IllegalArgumentException(""String_Node_Str"" + filePath);
  }
  PKCS8EncodedKeySpec keySpec=new PKCS8EncodedKeySpec(_readBinaryFile(filePath));
  KeyFactory keyFactory;
  try {
    keyFactory=KeyFactory.getInstance(""String_Node_Str"");
    return keyFactory.generatePrivate(keySpec);
  }
 catch (  NoSuchAlgorithmException|InvalidKeySpecException e) {
    throw new IllegalArgumentException(""String_Node_Str"" + filePath,e);
  }
}"
72418,"/** 
 * Return the expected hash length for the given hash algorithm.
 * @param hashAlgorithm The name of the hash algorithm.
 * @return The hash length for the hash algorithm.
 * @throws IllegalActionException If the specified hash algorithm is not available.
 */
public int getHashLength(String hashAlgorithm) throws IllegalActionException {
  try {
    MessageDigest messageDigest=MessageDigest.getInstance(hashAlgorithm);
    return messageDigest.getDigestLength();
  }
 catch (  NoSuchAlgorithmException e) {
    throw new IllegalActionException(""String_Node_Str"" + e.getMessage());
  }
}","/** 
 * Return the expected hash length for the given hash algorithm.
 * @param hashAlgorithm The name of the hash algorithm.
 * @return The hash length for the hash algorithm.
 * @throws IllegalActionException If the specified hash algorithm is not available.
 */
public int getHashLength(String hashAlgorithm) throws IllegalActionException {
  try {
    MessageDigest messageDigest=MessageDigest.getInstance(hashAlgorithm);
    return messageDigest.getDigestLength();
  }
 catch (  NoSuchAlgorithmException e) {
    throw new IllegalActionException(null,e,""String_Node_Str"");
  }
}"
72419,"/** 
 * Sign the given input data with a private key and return the signature.
 * @param input The input data to be signed in a JavaScript object.
 * @param privateKey The public key of the entity that will decrypt the message.
 * @param signAlgorithm The name of the algorithm to be used for signing.
 * @return Signature calculated from the input data.
 * @throws IllegalActionException
 */
public Object signWithPrivateKey(Object input,PrivateKey privateKey,String signAlgorithm) throws IllegalActionException {
  try {
    Signature signer=Signature.getInstance(signAlgorithm);
    signer.initSign(privateKey);
    signer.update(_toJavaBytes(input));
    return _toJSArray(signer.sign());
  }
 catch (  NoSuchAlgorithmException|InvalidKeyException|SignatureException e) {
    throw new IllegalArgumentException(""String_Node_Str"" + e.getMessage());
  }
}","/** 
 * Sign the given input data with a private key and return the signature.
 * @param input The input data to be signed in a JavaScript object.
 * @param privateKey The public key of the entity that will decrypt the message.
 * @param signAlgorithm The name of the algorithm to be used for signing.
 * @return Signature calculated from the input data.
 * @throws IllegalActionException
 */
public Object signWithPrivateKey(Object input,PrivateKey privateKey,String signAlgorithm) throws IllegalActionException {
  try {
    Signature signer=Signature.getInstance(signAlgorithm);
    signer.initSign(privateKey);
    signer.update(_toJavaBytes(input));
    return _toJSArray(signer.sign());
  }
 catch (  NoSuchAlgorithmException|InvalidKeyException|SignatureException e) {
    throw new IllegalArgumentException(""String_Node_Str"",e);
  }
}"
72420,"/** 
 * Calculate HMAC (key-Hashed Message Authentication Code) for the given input and key.
 * @param input The input in the JavaScript object to be HMAC hashed.
 * @param key The key to be used for HMAC calculation.
 * @param hmacAlgorithm The name of the HMAC algorithm.
 * @return The resulting HMAC. 
 * @throws IllegalActionException If the HMAC calculation fails.
 */
public Object hmac(Object input,Object key,String hmacAlgorithm) throws IllegalActionException {
  try {
    SecretKeySpec hmacKey=new SecretKeySpec(_toJavaBytes(key),hmacAlgorithm);
    Mac hmac=Mac.getInstance(hmacAlgorithm);
    hmac.init(hmacKey);
    return _toJSArray(hmac.doFinal(_toJavaBytes(input)));
  }
 catch (  NoSuchAlgorithmException|InvalidKeyException e) {
    throw new IllegalActionException(""String_Node_Str"" + e.getMessage());
  }
}","/** 
 * Calculate HMAC (key-Hashed Message Authentication Code) for the given input and key.
 * @param input The input in the JavaScript object to be HMAC hashed.
 * @param key The key to be used for HMAC calculation.
 * @param hmacAlgorithm The name of the HMAC algorithm.
 * @return The resulting HMAC. 
 * @throws IllegalActionException If the HMAC calculation fails.
 */
public Object hmac(Object input,Object key,String hmacAlgorithm) throws IllegalActionException {
  try {
    SecretKeySpec hmacKey=new SecretKeySpec(_toJavaBytes(key),hmacAlgorithm);
    Mac hmac=Mac.getInstance(hmacAlgorithm);
    hmac.init(hmacKey);
    return _toJSArray(hmac.doFinal(_toJavaBytes(input)));
  }
 catch (  NoSuchAlgorithmException|InvalidKeyException e) {
    throw new IllegalActionException(null,e,""String_Node_Str"");
  }
}"
72421,"/** 
 * Decrypt the input with a symmetric cipher and return the decrypted result.
 * @param input The cipher text to be decrypted.
 * @param key The secret key for the cipher.
 * @param cipherAlgorithm The name of the symmetric cipher algorithm to be used for decryption. (examples: AES-128-CBC, DES-ECB)
 * @return The encrypted result in JavaScript byte array.
 * @throws IllegalActionException If the decryption fails.
 */
public Object symmetricDecrypt(Object input,Object key,String cipherAlgorithm) throws IllegalActionException {
  byte[] cipherText=_toJavaBytes(input);
  Cipher cipher=_getCipher(Cipher.DECRYPT_MODE,cipherAlgorithm,_toJavaBytes(key),cipherText);
  ByteArrayOutputStream byteArrayOutputStream=new ByteArrayOutputStream();
  int ivSize=0;
  if (cipher.getIV() != null) {
    ivSize=cipher.getIV().length;
  }
  try {
    byteArrayOutputStream.write(cipher.doFinal(cipherText,ivSize,cipherText.length - ivSize));
  }
 catch (  IllegalBlockSizeException|BadPaddingException|IOException e) {
    throw new IllegalArgumentException(""String_Node_Str"" + input + ""String_Node_Str""+ e.getMessage());
  }
  return _toJSArray(byteArrayOutputStream.toByteArray());
}","/** 
 * Decrypt the input with a symmetric cipher and return the decrypted result.
 * @param input The cipher text to be decrypted.
 * @param key The secret key for the cipher.
 * @param cipherAlgorithm The name of the symmetric cipher algorithm to be used for decryption. (examples: AES-128-CBC, DES-ECB)
 * @return The encrypted result in JavaScript byte array.
 * @throws IllegalActionException If the decryption fails.
 */
public Object symmetricDecrypt(Object input,Object key,String cipherAlgorithm) throws IllegalActionException {
  byte[] cipherText=_toJavaBytes(input);
  Cipher cipher=_getCipher(Cipher.DECRYPT_MODE,cipherAlgorithm,_toJavaBytes(key),cipherText);
  ByteArrayOutputStream byteArrayOutputStream=new ByteArrayOutputStream();
  int ivSize=0;
  if (cipher.getIV() != null) {
    ivSize=cipher.getIV().length;
  }
  try {
    byteArrayOutputStream.write(cipher.doFinal(cipherText,ivSize,cipherText.length - ivSize));
  }
 catch (  IllegalBlockSizeException|BadPaddingException|IOException e) {
    throw new IllegalArgumentException(""String_Node_Str"" + input,e);
  }
  return _toJSArray(byteArrayOutputStream.toByteArray());
}"
72422,"/** 
 * Hash the input with a given hash algorithm and return the hashed result.
 * @param input The input in the JavaScript object to be hashed.
 * @param hashAlgorithm The name of the hash algorithm to be used. (Examples: MD5, SHA-1, SHA-256)
 * @return The hash digested for the given input.
 * @throws IllegalActionException If the specified hash algorithm is not available.
 */
public Object hash(Object input,String hashAlgorithm) throws IllegalActionException {
  try {
    MessageDigest messageDigest=MessageDigest.getInstance(hashAlgorithm);
    return _toJSArray(messageDigest.digest(_toJavaBytes(input)));
  }
 catch (  NoSuchAlgorithmException e) {
    throw new IllegalActionException(""String_Node_Str"" + e.getMessage());
  }
}","/** 
 * Hash the input with a given hash algorithm and return the hashed result.
 * @param input The input in the JavaScript object to be hashed.
 * @param hashAlgorithm The name of the hash algorithm to be used. (Examples: MD5, SHA-1, SHA-256)
 * @return The hash digested for the given input.
 * @throws IllegalActionException If the specified hash algorithm is not available.
 */
public Object hash(Object input,String hashAlgorithm) throws IllegalActionException {
  try {
    MessageDigest messageDigest=MessageDigest.getInstance(hashAlgorithm);
    return _toJSArray(messageDigest.digest(_toJavaBytes(input)));
  }
 catch (  NoSuchAlgorithmException e) {
    throw new IllegalActionException(null,e,""String_Node_Str"");
  }
}"
72423,"/** 
 * Encrypt the input with a symmetric cipher and return the encrypted result.
 * @param input The clear text message to be encrypted.
 * @param key The secret key for the cipher.
 * @param cipherAlgorithm The name of the symmetric cipher algorithm to be used for encryption. (examples: AES-128-CBC, DES-ECB)
 * @return The encrypted result in JavaScript byte array.
 * @throws IllegalActionException If the encryption fails.
 */
public Object symmetricEncrypt(Object input,Object key,String cipherAlgorithm) throws IllegalActionException {
  Cipher cipher=_getCipher(Cipher.ENCRYPT_MODE,cipherAlgorithm,_toJavaBytes(key),null);
  ByteArrayOutputStream byteArrayOutputStream=new ByteArrayOutputStream();
  try {
    byte[] initVector=cipher.getIV();
    if (initVector != null) {
      byteArrayOutputStream.write(initVector);
    }
    byteArrayOutputStream.write(cipher.doFinal(_toJavaBytes(input)));
  }
 catch (  IllegalBlockSizeException|BadPaddingException|IOException e) {
    throw new IllegalArgumentException(""String_Node_Str"" + input + ""String_Node_Str""+ e.getMessage());
  }
  return _toJSArray(byteArrayOutputStream.toByteArray());
}","/** 
 * Encrypt the input with a symmetric cipher and return the encrypted result.
 * @param input The clear text message to be encrypted.
 * @param key The secret key for the cipher.
 * @param cipherAlgorithm The name of the symmetric cipher algorithm to be used for encryption. (examples: AES-128-CBC, DES-ECB)
 * @return The encrypted result in JavaScript byte array.
 * @throws IllegalActionException If the encryption fails.
 */
public Object symmetricEncrypt(Object input,Object key,String cipherAlgorithm) throws IllegalActionException {
  Cipher cipher=_getCipher(Cipher.ENCRYPT_MODE,cipherAlgorithm,_toJavaBytes(key),null);
  ByteArrayOutputStream byteArrayOutputStream=new ByteArrayOutputStream();
  try {
    byte[] initVector=cipher.getIV();
    if (initVector != null) {
      byteArrayOutputStream.write(initVector);
    }
    byteArrayOutputStream.write(cipher.doFinal(_toJavaBytes(input)));
  }
 catch (  IllegalBlockSizeException|BadPaddingException|IOException e) {
    throw new IllegalArgumentException(""String_Node_Str"" + input,e);
  }
  return _toJSArray(byteArrayOutputStream.toByteArray());
}"
72424,"/** 
 * Prefire method when the enclosing director is not an instance of this same class.
 * @return True if it is OK to fire.
 */
private boolean _prefireWithEnclosingNonContinuousDirector() throws IllegalActionException {
  CompositeActor container=(CompositeActor)getContainer();
  Director executiveDirector=((Actor)container).getExecutiveDirector();
  Time currentTime=getModelTime();
  Time outTime=localClock.getLocalTimeForCurrentEnvironmentTime();
  int localTimeExceedsOutsideTime=currentTime.compareTo(outTime);
  Time modifiedTime=_consultTimeRegulators(currentTime);
  int modifiedTimeExceedsLocalTime=modifiedTime.compareTo(currentTime);
  if (localTimeExceedsOutsideTime > 0 || modifiedTimeExceedsLocalTime < 0) {
    if (!_commitIsPending) {
      throw new IllegalActionException(this,""String_Node_Str"" + container.getFullName() + ""String_Node_Str""+ ""String_Node_Str""+ outTime+ ""String_Node_Str""+ currentTime);
    }
    if (modifiedTimeExceedsLocalTime < 0 && modifiedTime.compareTo(outTime) < 0) {
      throw new IllegalActionException(this,""String_Node_Str"" + modifiedTime + ""String_Node_Str""+ outTime);
    }
    _currentStepSize=outTime.subtract(_iterationBeginTime).getDoubleValue();
    if (_currentStepSize < 0.0) {
      throw new IllegalActionException(this,""String_Node_Str"" + _iterationBeginTime + ""String_Node_Str""+ outTime+ ""String_Node_Str"");
    }
    rollBackToCommittedState();
    _commitIsPending=false;
    if (_currentStepSize != 0.0) {
      _redoingSolverIteration=true;
    }
  }
 else   if (localTimeExceedsOutsideTime == 0 && _commitIsPending) {
    _currentStepSize=0.0;
    return true;
  }
 else   if (localTimeExceedsOutsideTime < 0) {
    if (_commitIsPending) {
      _commitIsPending=false;
      rollBackToCommittedState();
    }
    if (_debugging) {
      _debug(""String_Node_Str"" + currentTime + ""String_Node_Str"");
    }
    _currentStepSize=0.0;
  }
 else {
    Time environmentNextIterationTime=localClock.getLocalTimeForEnvironmentTime(executiveDirector.getModelNextIterationTime());
    Time localTargetTime=_iterationBeginTime.add(_currentStepSize);
    if (environmentNextIterationTime.compareTo(localTargetTime) < 0) {
      _currentStepSize=environmentNextIterationTime.subtract(currentTime).getDoubleValue();
      if (_debugging) {
        _debug(""String_Node_Str"" + _currentStepSize);
      }
    }
  }
  if (!_breakpoints.isEmpty()) {
    SuperdenseTime nextBreakpoint=(SuperdenseTime)_breakpoints.first();
    Time breakpointTime=nextBreakpoint.timestamp();
    localTimeExceedsOutsideTime=breakpointTime.compareTo(currentTime);
    if (localTimeExceedsOutsideTime < 0) {
      throw new IllegalActionException(this,""String_Node_Str"" + breakpointTime + ""String_Node_Str""+ currentTime);
    }
    if (localTimeExceedsOutsideTime == 0 && nextBreakpoint.index() <= _index) {
      if (_debugging) {
        _debug(""String_Node_Str"" + nextBreakpoint + ""String_Node_Str"");
      }
      _breakpoints.removeFirst();
    }
  }
  _synchronizeToRealTime();
  _postfireReturns=true;
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  return true;
}","/** 
 * Prefire method when the enclosing director is not an instance of this same class.
 * @return True if it is OK to fire.
 */
private boolean _prefireWithEnclosingNonContinuousDirector() throws IllegalActionException {
  CompositeActor container=(CompositeActor)getContainer();
  Director executiveDirector=((Actor)container).getExecutiveDirector();
  Time currentTime=getModelTime();
  Time outTime=localClock.getLocalTimeForCurrentEnvironmentTime();
  int localTimeExceedsOutsideTime=currentTime.compareTo(outTime);
  Time modifiedTime=_consultTimeRegulators(currentTime);
  int modifiedTimeExceedsLocalTime=modifiedTime.compareTo(currentTime);
  if (localTimeExceedsOutsideTime > 0 || modifiedTimeExceedsLocalTime < 0) {
    if (!_commitIsPending) {
      throw new IllegalActionException(this,""String_Node_Str"" + container.getFullName() + ""String_Node_Str""+ ""String_Node_Str""+ outTime+ ""String_Node_Str""+ currentTime);
    }
    if (modifiedTimeExceedsLocalTime < 0 && modifiedTime.compareTo(outTime) < 0) {
      throw new IllegalActionException(this,""String_Node_Str"" + modifiedTime + ""String_Node_Str""+ outTime);
    }
    _currentStepSize=outTime.subtract(_iterationBeginTime).getDoubleValue();
    if (_currentStepSize < 0.0) {
      throw new IllegalActionException(this,""String_Node_Str"" + _iterationBeginTime + ""String_Node_Str""+ outTime+ ""String_Node_Str"");
    }
    rollBackToCommittedState();
    _commitIsPending=false;
    if (_currentStepSize != 0.0) {
      _redoingSolverIteration=true;
    }
  }
 else   if (localTimeExceedsOutsideTime == 0 && _commitIsPending) {
    _currentStepSize=0.0;
    return true;
  }
 else   if (localTimeExceedsOutsideTime < 0) {
    if (_commitIsPending) {
      _commitIsPending=false;
      rollBackToCommittedState();
    }
    this.localClock.setLocalTime(localClock.getLocalTimeForCurrentEnvironmentTime());
    if (_debugging) {
      _debug(""String_Node_Str"" + currentTime + ""String_Node_Str"");
    }
    _currentStepSize=0.0;
  }
 else {
    Time environmentNextIterationTime=localClock.getLocalTimeForEnvironmentTime(executiveDirector.getModelNextIterationTime());
    Time localTargetTime=_iterationBeginTime.add(_currentStepSize);
    if (environmentNextIterationTime.compareTo(localTargetTime) < 0) {
      _currentStepSize=environmentNextIterationTime.subtract(currentTime).getDoubleValue();
      if (_debugging) {
        _debug(""String_Node_Str"" + _currentStepSize);
      }
    }
  }
  if (!_breakpoints.isEmpty()) {
    SuperdenseTime nextBreakpoint=(SuperdenseTime)_breakpoints.first();
    Time breakpointTime=nextBreakpoint.timestamp();
    localTimeExceedsOutsideTime=breakpointTime.compareTo(currentTime);
    if (localTimeExceedsOutsideTime < 0) {
      throw new IllegalActionException(this,""String_Node_Str"" + breakpointTime + ""String_Node_Str""+ currentTime);
    }
    if (localTimeExceedsOutsideTime == 0 && nextBreakpoint.index() <= _index) {
      if (_debugging) {
        _debug(""String_Node_Str"" + nextBreakpoint + ""String_Node_Str"");
      }
      _breakpoints.removeFirst();
    }
  }
  _synchronizeToRealTime();
  _postfireReturns=true;
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  return true;
}"
72425,"/** 
 * Change a parameter in the .xml, making it vary within an interval defined by the parameters start and end. Run a ptolemy simulation for each step between the interval. 
 * @param waitingTime The time the system will wait to close all the windows of a federation, after its execution has finished. This parameter is intended to give the user the ability to choose how long he will have to look at the simulation's results.  If the variable is given a negative value, the user will be asked repetedly if he had time to look at the models and they will  only close when he answers ""yes"".
 * @param vergil An instance of vergil.
 * @param modelPath The path to the model you want to run.
 * @param propertyLine The xml line of the parameter that we want to change. 
 * @param values The values the new property will assume.
 */
public static void changeParameters(int waitingTime,AutomaticSimulation vergil,String[] modelPath,String[] propertyLines,double[][] values){
  if (propertyLines.length != values.length) {
    System.out.println(""String_Node_Str"");
    return;
  }
  int numberOfFederates=modelPath.length;
  int numberOfParameters=propertyLines.length;
  File[] file=new File[numberOfFederates];
  String[][][] data=new String[numberOfFederates][numberOfParameters + 1][2];
  for (int i=0; i < numberOfFederates; i++) {
    file[i]=new File(modelPath[i]);
    data[i]=_findPropertyLines(file[i],propertyLines);
  }
  int numberOfInteractions=values[0].length;
  for (int i=0; i < numberOfInteractions; i++) {
    final CompositeEntity[] model=new CompositeEntity[numberOfFederates];
    for (int j=0; j < numberOfFederates; j++) {
      String info=""String_Node_Str"";
      for (int y=0; y < numberOfParameters; y++) {
        info=info + ""String_Node_Str"" + data[j][y][0]+ ""String_Node_Str""+ data[j][y][1]+ values[y][i]+ ""String_Node_Str"";
      }
      info=info.substring(1);
      info=info + ""String_Node_Str"" + data[j][numberOfParameters][0];
      System.out.println(""String_Node_Str"" + j + ""String_Node_Str"");
      _writeInFile(file[j],info);
      model[j]=_openModel(modelPath[j]);
    }
    runAllModels(vergil);
    if (waitingTime < 0) {
      while (true) {
        Scanner input=new Scanner(System.in);
        System.out.println(""String_Node_Str"");
        String answer=input.next();
        if (answer.equalsIgnoreCase(""String_Node_Str""))         break;
      }
      _sleep(2000);
    }
 else     if (waitingTime > 0) {
      _sleep(waitingTime);
    }
    for (int j=0; j < numberOfFederates; j++) {
      _closeModel(model[j]);
    }
    _killRTIG();
  }
  try {
    Configuration.closeAllTableaux();
  }
 catch (  IllegalActionException e) {
    e.printStackTrace();
  }
}","/** 
 * Change a parameter in the .xml, making it vary within an interval defined by the parameters start and end. Run a ptolemy simulation for each step between the interval. 
 * @param waitingTime The time the system will wait to close all the windows of a federation, after its execution has finished. This parameter is intended to give the user the ability to choose how long he will have to look at the simulation's results.  If the variable is given a negative value, the user will be asked repetedly if he had time to look at the models and they will  only close when he answers ""yes"".
 * @param vergil An instance of vergil.
 * @param modelPath The path to the model you want to run.
 * @param propertyLine The xml line of the parameter that we want to change. 
 * @param values The values the new property will assume.
 */
public static void changeParameters(int waitingTime,AutomaticSimulation vergil,String[] modelPath,String[] propertyLines,double[][] values){
  if (propertyLines.length != values.length) {
    System.out.println(""String_Node_Str"");
    return;
  }
  int numberOfFederates=modelPath.length;
  int numberOfParameters=propertyLines.length;
  File[] file=new File[numberOfFederates];
  String[][][] data=new String[numberOfFederates][numberOfParameters + 1][2];
  for (int i=0; i < numberOfFederates; i++) {
    file[i]=new File(modelPath[i]);
    data[i]=_findPropertyLines(file[i],propertyLines);
  }
  int numberOfInteractions=values[0].length;
  for (int i=0; i < numberOfInteractions; i++) {
    final CompositeEntity[] model=new CompositeEntity[numberOfFederates];
    for (int j=0; j < numberOfFederates; j++) {
      StringBuffer info=new StringBuffer();
      for (int y=0; y < numberOfParameters; y++) {
        info.append(""String_Node_Str"" + data[j][y][0] + ""String_Node_Str""+ data[j][y][1]+ values[y][i]+ ""String_Node_Str"");
      }
      System.out.println(""String_Node_Str"" + j + ""String_Node_Str"");
      _writeInFile(file[j],info.substring(1) + ""String_Node_Str"" + data[j][numberOfParameters][0]);
      model[j]=_openModel(modelPath[j]);
    }
    runAllModels(vergil);
    if (waitingTime < 0) {
      while (true) {
        Scanner input=new Scanner(System.in);
        System.out.println(""String_Node_Str"");
        String answer=input.next();
        if (answer.equalsIgnoreCase(""String_Node_Str""))         break;
      }
      _sleep(2000);
    }
 else     if (waitingTime > 0) {
      _sleep(waitingTime);
    }
    for (int j=0; j < numberOfFederates; j++) {
      _closeModel(model[j]);
    }
    _killRTIG();
  }
  try {
    Configuration.closeAllTableaux();
  }
 catch (  IllegalActionException e) {
    e.printStackTrace();
  }
}"
72426,"/** 
 * Propose a time to advance to. This method is the one implementing the TimeRegulator interface and using the HLA/CERTI Time Management services (if required). Following HLA and CERTI recommendations, if the Time Management is required then we have the following behavior: Case 1: If lookahead = 0 -a) if time-stepped Federate, then the timeAdvanceRequestAvailable() (TARA) service is used; -b) if event-based Federate, then the nextEventRequestAvailable() (NERA) service is used Case 2: If lookahead &gt; 0 -c) if time-stepped Federate, then timeAdvanceRequest() (TAR) is used; -d) if event-based Federate, then the nextEventRequest() (NER) is used; Otherwise the proposedTime is returned. NOTE: For the Ptolemy II - HLA/CERTI cooperation the default (and correct) behavior is the case 1 and CERTI has to be compiled with the option ""CERTI_USE_NULL_PRIME_MESSAGE_PROTOCOL"".
 * @param proposedTime The proposed time.
 * @return The proposed time or a smaller time.
 * @exception IllegalActionException If this attribute is notcontained by an Actor.
 */
@Override public Time proposeTime(Time proposedTime) throws IllegalActionException {
  if (_debugging) {
    _debug(this.getDisplayName() + ""String_Node_Str"");
  }
  Time currentTime=_getModelTime();
  proposedTime=new Time(_director,_getDoubleOfTime(proposedTime));
  if (proposedTime.compareTo(_stopTime) == 1) {
    if (_debugging) {
      _debug(this.getDisplayName() + ""String_Node_Str"" + ""String_Node_Str"");
    }
    return _stopTime;
  }
  if (_rtia == null) {
    if (_debugging) {
      _debug(this.getDisplayName() + ""String_Node_Str"" + ""String_Node_Str"");
    }
    return proposedTime;
  }
  if (currentTime.equals(proposedTime)) {
    if (_debugging) {
      _debug(this.getDisplayName() + ""String_Node_Str"" + ""String_Node_Str""+ _getDoubleOfTime(currentTime)+ ""String_Node_Str"");
    }
    try {
      _rtia.tick();
      if (_timeOfTheLastAdvanceRequest > 0) {
        _numberOfTicks.set(_numberOfTAGs,_numberOfTicks.get(_numberOfTAGs) + 1);
      }
 else {
        _numberOfOtherTicks++;
      }
    }
 catch (    ConcurrentAccessAttempted e) {
      throw new IllegalActionException(this,e,""String_Node_Str"");
    }
catch (    RTIinternalError e) {
      throw new IllegalActionException(this,e,""String_Node_Str"");
    }
    return currentTime;
  }
  if (_isTimeRegulator && _isTimeConstrained) {
synchronized (this) {
      try {
        if (_eventBased) {
          return _eventsBasedTimeAdvance(proposedTime);
        }
 else {
          return _timeSteppedBasedTimeAdvance(proposedTime);
        }
      }
 catch (      InvalidFederationTime e) {
        throw new IllegalActionException(this,e,""String_Node_Str"");
      }
catch (      FederationTimeAlreadyPassed e) {
        throw new IllegalActionException(this,e,""String_Node_Str"");
      }
catch (      TimeAdvanceAlreadyInProgress e) {
        throw new IllegalActionException(this,e,""String_Node_Str"");
      }
catch (      EnableTimeRegulationPending e) {
        throw new IllegalActionException(this,e,""String_Node_Str"");
      }
catch (      EnableTimeConstrainedPending e) {
        throw new IllegalActionException(this,e,""String_Node_Str"");
      }
catch (      FederateNotExecutionMember e) {
        throw new IllegalActionException(this,e,""String_Node_Str"");
      }
catch (      SaveInProgress e) {
        throw new IllegalActionException(this,e,""String_Node_Str"");
      }
catch (      RestoreInProgress e) {
        throw new IllegalActionException(this,e,""String_Node_Str"");
      }
catch (      RTIinternalError e) {
        throw new IllegalActionException(this,e,""String_Node_Str"");
      }
catch (      ConcurrentAccessAttempted e) {
        throw new IllegalActionException(this,e,""String_Node_Str"");
      }
catch (      NoSuchElementException e) {
        if (_debugging) {
          _debug(this.getDisplayName() + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
        }
        return proposedTime;
      }
catch (      SpecifiedSaveLabelDoesNotExist ex) {
        Logger.getLogger(HlaManager.class.getName()).log(Level.SEVERE,null,ex);
      }
    }
  }
  return null;
}","/** 
 * Propose a time to advance to. This method is the one implementing the TimeRegulator interface and using the HLA/CERTI Time Management services (if required). Following HLA and CERTI recommendations, if the Time Management is required then we have the following behavior: Case 1: If lookahead = 0 -a) if time-stepped Federate, then the timeAdvanceRequestAvailable() (TARA) service is used; -b) if event-based Federate, then the nextEventRequestAvailable() (NERA) service is used Case 2: If lookahead &gt; 0 -c) if time-stepped Federate, then timeAdvanceRequest() (TAR) is used; -d) if event-based Federate, then the nextEventRequest() (NER) is used; Otherwise the proposedTime is returned. NOTE: For the Ptolemy II - HLA/CERTI cooperation the default (and correct) behavior is the case 1 and CERTI has to be compiled with the option ""CERTI_USE_NULL_PRIME_MESSAGE_PROTOCOL"".
 * @param proposedTime The proposed time.
 * @return The proposed time or a smaller time.
 * @exception IllegalActionException If this attribute is notcontained by an Actor.
 */
@Override public Time proposeTime(Time proposedTime) throws IllegalActionException {
  if (_debugging) {
    _debug(this.getDisplayName() + ""String_Node_Str"");
  }
  Time currentTime=_getModelTime();
  proposedTime=new Time(_director,_getDoubleOfTime(proposedTime));
  if (proposedTime.compareTo(_stopTime) > 0) {
    if (_debugging) {
      _debug(this.getDisplayName() + ""String_Node_Str"" + ""String_Node_Str"");
    }
    return _stopTime;
  }
  if (_rtia == null) {
    if (_debugging) {
      _debug(this.getDisplayName() + ""String_Node_Str"" + ""String_Node_Str"");
    }
    return proposedTime;
  }
  if (currentTime.equals(proposedTime)) {
    if (_debugging) {
      _debug(this.getDisplayName() + ""String_Node_Str"" + ""String_Node_Str""+ _getDoubleOfTime(currentTime)+ ""String_Node_Str"");
    }
    try {
      _rtia.tick();
      if (_timeOfTheLastAdvanceRequest > 0) {
        _numberOfTicks.set(_numberOfTAGs,_numberOfTicks.get(_numberOfTAGs) + 1);
      }
 else {
        _numberOfOtherTicks++;
      }
    }
 catch (    ConcurrentAccessAttempted e) {
      throw new IllegalActionException(this,e,""String_Node_Str"");
    }
catch (    RTIinternalError e) {
      throw new IllegalActionException(this,e,""String_Node_Str"");
    }
    return currentTime;
  }
  if (_isTimeRegulator && _isTimeConstrained) {
synchronized (this) {
      try {
        if (_eventBased) {
          return _eventsBasedTimeAdvance(proposedTime);
        }
 else {
          return _timeSteppedBasedTimeAdvance(proposedTime);
        }
      }
 catch (      InvalidFederationTime e) {
        throw new IllegalActionException(this,e,""String_Node_Str"");
      }
catch (      FederationTimeAlreadyPassed e) {
        throw new IllegalActionException(this,e,""String_Node_Str"");
      }
catch (      TimeAdvanceAlreadyInProgress e) {
        throw new IllegalActionException(this,e,""String_Node_Str"");
      }
catch (      EnableTimeRegulationPending e) {
        throw new IllegalActionException(this,e,""String_Node_Str"");
      }
catch (      EnableTimeConstrainedPending e) {
        throw new IllegalActionException(this,e,""String_Node_Str"");
      }
catch (      FederateNotExecutionMember e) {
        throw new IllegalActionException(this,e,""String_Node_Str"");
      }
catch (      SaveInProgress e) {
        throw new IllegalActionException(this,e,""String_Node_Str"");
      }
catch (      RestoreInProgress e) {
        throw new IllegalActionException(this,e,""String_Node_Str"");
      }
catch (      RTIinternalError e) {
        throw new IllegalActionException(this,e,""String_Node_Str"");
      }
catch (      ConcurrentAccessAttempted e) {
        throw new IllegalActionException(this,e,""String_Node_Str"");
      }
catch (      NoSuchElementException e) {
        if (_debugging) {
          _debug(this.getDisplayName() + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
        }
        return proposedTime;
      }
catch (      SpecifiedSaveLabelDoesNotExist ex) {
        Logger.getLogger(HlaManager.class.getName()).log(Level.SEVERE,null,ex);
      }
    }
  }
  return null;
}"
72427,"public void writeRAVsInformations(){
  if (_numberOfRAVs > 0) {
    String header=""String_Node_Str"";
    int count=_RAVsValues.split(""String_Node_Str"").length;
    for (int i=0; i < count; i++) {
      header=header + ""String_Node_Str"" + i+ ""String_Node_Str"";
    }
    _RAVsValuesFile=_createTextFile(""String_Node_Str"" + getDisplayName() + ""String_Node_Str"");
    _pRAVsTimes=""String_Node_Str"" + _pRAVsTimes + ""String_Node_Str"";
    _folRAVsTimes=""String_Node_Str"" + ""String_Node_Str"" + _folRAVsTimes + ""String_Node_Str"";
    writeInTextFile(_RAVsValuesFile,_date.toString() + ""String_Node_Str"" + header+ ""String_Node_Str""+ _hlaLookAHead+ ""String_Node_Str""+ _hlaTimeStep+ ""String_Node_Str""+ _stopTime+ ""String_Node_Str""+ _pRAVsTimes+ _folRAVsTimes+ ""String_Node_Str""+ _RAVsValues+ ""String_Node_Str"");
  }
}","public void writeRAVsInformations(){
  if (_numberOfRAVs > 0) {
    StringBuffer header=new StringBuffer(""String_Node_Str"");
    int count=_RAVsValues.split(""String_Node_Str"").length;
    for (int i=0; i < count; i++) {
      header.append(""String_Node_Str"" + i + ""String_Node_Str"");
    }
    _RAVsValuesFile=_createTextFile(""String_Node_Str"" + getDisplayName() + ""String_Node_Str"");
    _pRAVsTimes=""String_Node_Str"" + _pRAVsTimes + ""String_Node_Str"";
    _folRAVsTimes=""String_Node_Str"" + ""String_Node_Str"" + _folRAVsTimes + ""String_Node_Str"";
    writeInTextFile(_RAVsValuesFile,_date.toString() + ""String_Node_Str"" + header.toString()+ ""String_Node_Str""+ _hlaLookAHead+ ""String_Node_Str""+ _hlaTimeStep+ ""String_Node_Str""+ _stopTime+ ""String_Node_Str""+ _pRAVsTimes+ _folRAVsTimes+ ""String_Node_Str""+ _RAVsValues+ ""String_Node_Str"");
  }
}"
72428,"/** 
 * Write a report containing(in a .csv file   {@link #_csvFile}), among other informations,  the number of ticks, the delay between a NER or a TAR and its respective TAG, the number of UAVs and RAVs.
 */
public void writeDelays(){
  try {
    String fullName=federateName.toString();
    String nameOfTheFile=fullName.substring(fullName.indexOf('{') + 1,fullName.lastIndexOf('.'));
    nameOfTheFile=nameOfTheFile.substring(1,nameOfTheFile.lastIndexOf('.')) + ""String_Node_Str"";
    String nameOfTheFederate=fullName.substring(fullName.indexOf('""'));
    String info=""String_Node_Str"" + nameOfTheFederate + ""String_Node_Str""+ nameOfTheFile+ ""String_Node_Str""+ _hlaTimeUnitValue+ ""String_Node_Str""+ _hlaLookAHead+ ""String_Node_Str""+ _runtime+ ""String_Node_Str"";
    if (_timeStepped) {
      info=info + ""String_Node_Str"" + _hlaTimeStep+ ""String_Node_Str""+ _numberOfTARs+ ""String_Node_Str"";
    }
 else     if (_eventBased) {
      info=info + ""String_Node_Str"" + _numberOfNERs+ ""String_Node_Str"";
    }
    info=info + ""String_Node_Str"" + _numberOfUAVs+ ""String_Node_Str""+ _numberOfRAVs+ ""String_Node_Str""+ _numberOfTAGs;
    String numberOfTicks=""String_Node_Str"";
    String delay=""String_Node_Str"";
    double averageNumberOfTicks=0;
    double averageDelay=0;
    String header=""String_Node_Str"";
    String delayPerTick=""String_Node_Str"";
    for (int i=0; i < _numberOfTAGs; i++) {
      if (i < 10) {
        header=header + (i + 1) + ""String_Node_Str"";
        numberOfTicks=numberOfTicks + _numberOfTicks.get(i) + ""String_Node_Str"";
        delay=delay + _TAGDelay.get(i) + ""String_Node_Str"";
        if (_numberOfTicks.get(i) > 0) {
          delayPerTick=delayPerTick + (_TAGDelay.get(i) / _numberOfTicks.get(i)) + ""String_Node_Str"";
        }
 else {
          delayPerTick=delayPerTick + ""String_Node_Str"";
        }
      }
      averageNumberOfTicks=averageNumberOfTicks + _numberOfTicks.get(i);
      averageDelay=averageDelay + _TAGDelay.get(i);
    }
    header=header + ""String_Node_Str"";
    int totalNumberOfHLACalls=_numberOfOtherTicks + (int)averageNumberOfTicks + _numberOfTARs+ _numberOfNERs+ _numberOfRAVs+ _numberOfUAVs+ _numberOfTAGs;
    numberOfTicks=numberOfTicks + averageNumberOfTicks + ""String_Node_Str"";
    delay=delay + averageDelay + ""String_Node_Str"";
    delayPerTick=delayPerTick + ""String_Node_Str"";
    header=header + ""String_Node_Str"";
    _reportFile=_createTextFile(nameOfTheFederate.substring(1,nameOfTheFederate.length() - 1) + ""String_Node_Str"",""String_Node_Str"");
    writeInTextFile(_reportFile,_hlaTimeStep + ""String_Node_Str"" + _hlaLookAHead+ ""String_Node_Str""+ _runtime+ ""String_Node_Str""+ totalNumberOfHLACalls+ ""String_Node_Str""+ _numberOfTARs+ ""String_Node_Str""+ _numberOfTAGs+ ""String_Node_Str""+ _numberOfRAVs+ ""String_Node_Str""+ _numberOfUAVs+ ""String_Node_Str""+ _numberOfTicks2+ ""String_Node_Str""+ averageDelay);
    averageNumberOfTicks=averageNumberOfTicks / _numberOfTAGs;
    averageDelay=averageDelay / _numberOfTAGs;
    delayPerTick=delayPerTick + (averageDelay / averageNumberOfTicks) + ""String_Node_Str"";
    numberOfTicks=numberOfTicks + averageNumberOfTicks + ""String_Node_Str"";
    delay=delay + averageDelay + ""String_Node_Str"";
    writeInTextFile(_csvFile,info + header + delay+ numberOfTicks+ delayPerTick+ ""String_Node_Str""+ _numberOfOtherTicks+ ""String_Node_Str""+ totalNumberOfHLACalls);
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"");
  }
}","/** 
 * Write a report containing(in a .csv file   {@link #_csvFile}), among other informations,  the number of ticks, the delay between a NER or a TAR and its respective TAG, the number of UAVs and RAVs.
 */
public void writeDelays(){
  try {
    String fullName=federateName.toString();
    String nameOfTheFile=fullName.substring(fullName.indexOf('{') + 1,fullName.lastIndexOf('.'));
    nameOfTheFile=nameOfTheFile.substring(1,nameOfTheFile.lastIndexOf('.')) + ""String_Node_Str"";
    String nameOfTheFederate=fullName.substring(fullName.indexOf('""'));
    String info=""String_Node_Str"" + nameOfTheFederate + ""String_Node_Str""+ nameOfTheFile+ ""String_Node_Str""+ _hlaTimeUnitValue+ ""String_Node_Str""+ _hlaLookAHead+ ""String_Node_Str""+ _runtime+ ""String_Node_Str"";
    if (_timeStepped) {
      info=info + ""String_Node_Str"" + _hlaTimeStep+ ""String_Node_Str""+ _numberOfTARs+ ""String_Node_Str"";
    }
 else     if (_eventBased) {
      info=info + ""String_Node_Str"" + _numberOfNERs+ ""String_Node_Str"";
    }
    info=info + ""String_Node_Str"" + _numberOfUAVs+ ""String_Node_Str""+ _numberOfRAVs+ ""String_Node_Str""+ _numberOfTAGs;
    String numberOfTicks=""String_Node_Str"";
    String delay=""String_Node_Str"";
    double averageNumberOfTicks=0;
    double averageDelay=0;
    StringBuffer header=new StringBuffer(""String_Node_Str"");
    String delayPerTick=""String_Node_Str"";
    for (int i=0; i < _numberOfTAGs; i++) {
      if (i < 10) {
        header.append((i + 1) + ""String_Node_Str"");
        numberOfTicks=numberOfTicks + _numberOfTicks.get(i) + ""String_Node_Str"";
        delay=delay + _TAGDelay.get(i) + ""String_Node_Str"";
        if (_numberOfTicks.get(i) > 0) {
          delayPerTick=delayPerTick + (_TAGDelay.get(i) / _numberOfTicks.get(i)) + ""String_Node_Str"";
        }
 else {
          delayPerTick=delayPerTick + ""String_Node_Str"";
        }
      }
      averageNumberOfTicks=averageNumberOfTicks + _numberOfTicks.get(i);
      averageDelay=averageDelay + _TAGDelay.get(i);
    }
    header.append(""String_Node_Str"");
    int totalNumberOfHLACalls=_numberOfOtherTicks + (int)averageNumberOfTicks + _numberOfTARs+ _numberOfNERs+ _numberOfRAVs+ _numberOfUAVs+ _numberOfTAGs;
    numberOfTicks=numberOfTicks + averageNumberOfTicks + ""String_Node_Str"";
    delay=delay + averageDelay + ""String_Node_Str"";
    delayPerTick=delayPerTick + ""String_Node_Str"";
    header.append(""String_Node_Str"");
    _reportFile=_createTextFile(nameOfTheFederate.substring(1,nameOfTheFederate.length() - 1) + ""String_Node_Str"",""String_Node_Str"");
    writeInTextFile(_reportFile,_hlaTimeStep + ""String_Node_Str"" + _hlaLookAHead+ ""String_Node_Str""+ _runtime+ ""String_Node_Str""+ totalNumberOfHLACalls+ ""String_Node_Str""+ _numberOfTARs+ ""String_Node_Str""+ _numberOfTAGs+ ""String_Node_Str""+ _numberOfRAVs+ ""String_Node_Str""+ _numberOfUAVs+ ""String_Node_Str""+ _numberOfTicks2+ ""String_Node_Str""+ averageDelay);
    averageNumberOfTicks=averageNumberOfTicks / _numberOfTAGs;
    averageDelay=averageDelay / _numberOfTAGs;
    delayPerTick=delayPerTick + (averageDelay / averageNumberOfTicks) + ""String_Node_Str"";
    numberOfTicks=numberOfTicks + averageNumberOfTicks + ""String_Node_Str"";
    delay=delay + averageDelay + ""String_Node_Str"";
    writeInTextFile(_csvFile,info + header + delay+ numberOfTicks+ delayPerTick+ ""String_Node_Str""+ _numberOfOtherTicks+ ""String_Node_Str""+ totalNumberOfHLACalls);
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"");
  }
}"
72429,"/** 
 * Verify the existence of a folder, if it doesn't exist, the function tries  to create it.
 * @param folderName The name of the folder that will be created.
 * @return The full address of the folder in a string.
 */
private String _createFolder(String folderName){
  String homeDirectory=System.getProperty(""String_Node_Str"");
  folderName=homeDirectory + ""String_Node_Str"" + folderName;
  File folder=new File(folderName);
  if (!folder.exists()) {
    try {
      folder.mkdir();
      System.out.println(""String_Node_Str"" + folderName + ""String_Node_Str"");
      return folderName;
    }
 catch (    SecurityException se) {
      System.out.println(""String_Node_Str"" + folderName + ""String_Node_Str"");
      return null;
    }
  }
 else {
    return folderName;
  }
}","/** 
 * Verify the existence of a folder, if it doesn't exist, the function tries  to create it.
 * @param folderName The name of the folder that will be created.
 * @return The full address of the folder in a string.
 * @exception IOException If the folder cannot be created.
 */
private String _createFolder(String folderName) throws IOException {
  String homeDirectory=System.getProperty(""String_Node_Str"");
  folderName=homeDirectory + ""String_Node_Str"" + folderName;
  File folder=new File(folderName);
  if (!folder.exists()) {
    try {
      if (!folder.mkdir()) {
        throw new IOException(""String_Node_Str"" + folder + ""String_Node_Str"");
      }
 else {
        System.out.println(""String_Node_Str"" + folderName + ""String_Node_Str"");
      }
      return folderName;
    }
 catch (    SecurityException se) {
      throw new IOException(""String_Node_Str"" + folderName + ""String_Node_Str"");
    }
  }
 else {
    return folderName;
  }
}"
72430,"public void writeUAVsInformations(){
  if (_numberOfUAVs > 0) {
    String header=""String_Node_Str"";
    int count=_UAVsValues.split(""String_Node_Str"").length;
    for (int i=0; i < count; i++) {
      header=header + ""String_Node_Str"" + i+ ""String_Node_Str"";
    }
    _UAVsValuesFile=_createTextFile(""String_Node_Str"" + getDisplayName() + ""String_Node_Str"");
    _pUAVsTimes=""String_Node_Str"" + ""String_Node_Str"" + _pUAVsTimes + ""String_Node_Str"";
    _preUAVsTimes=""String_Node_Str"" + _preUAVsTimes + ""String_Node_Str"";
    writeInTextFile(_UAVsValuesFile,_date.toString() + ""String_Node_Str"" + header+ ""String_Node_Str""+ _hlaLookAHead+ ""String_Node_Str""+ _hlaTimeStep+ ""String_Node_Str""+ _stopTime+ ""String_Node_Str""+ _preUAVsTimes+ _pUAVsTimes+ ""String_Node_Str""+ _UAVsValues+ ""String_Node_Str"");
  }
}","public void writeUAVsInformations(){
  if (_numberOfUAVs > 0) {
    StringBuffer header=new StringBuffer(""String_Node_Str"");
    int count=_UAVsValues.split(""String_Node_Str"").length;
    for (int i=0; i < count; i++) {
      header.append(""String_Node_Str"" + i + ""String_Node_Str"");
    }
    _UAVsValuesFile=_createTextFile(""String_Node_Str"" + getDisplayName() + ""String_Node_Str"");
    _pUAVsTimes=""String_Node_Str"" + ""String_Node_Str"" + _pUAVsTimes + ""String_Node_Str"";
    _preUAVsTimes=""String_Node_Str"" + _preUAVsTimes + ""String_Node_Str"";
    writeInTextFile(_UAVsValuesFile,_date.toString() + ""String_Node_Str"" + header+ ""String_Node_Str""+ _hlaLookAHead+ ""String_Node_Str""+ _hlaTimeStep+ ""String_Node_Str""+ _stopTime+ ""String_Node_Str""+ _preUAVsTimes+ _pUAVsTimes+ ""String_Node_Str""+ _UAVsValues+ ""String_Node_Str"");
  }
}"
72431,"/** 
 * Construct a HlaManager with a name and a container. The container argument must not be null, or a NullPointerException will be thrown. This actor will use the workspace of the container for synchronization and version counts. If the name argument is null, then the name is set to the empty string. Increment the version of the workspace.
 * @param container Container of this attribute.
 * @param name Name of this attribute.
 * @exception IllegalActionException If the container is incompatiblewith this actor.
 * @exception NameDuplicationException If the name coincides withan actor already in the container.
 */
public HlaManager(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  _testsFolder=_createFolder(""String_Node_Str"");
  _file=_createTextFile(""String_Node_Str"");
  _csvFile=_createTextFile(""String_Node_Str"");
  _noObjectDicovered=true;
  _rtia=null;
  _federateAmbassador=null;
  _registeredObject=new HashMap<String,Integer>();
  _hlaAttributesToPublish=new HashMap<String,Object[]>();
  _hlaAttributesSubscribedTo=new HashMap<String,Object[]>();
  _fromFederationEvents=new HashMap<String,LinkedList<TimedEvent>>();
  _objectIdToClassHandle=new HashMap<Integer,Integer>();
  _strucuralInformation=new HashMap<Integer,StructuralInformation>();
  _hlaTimeStep=null;
  _hlaLookAHead=null;
  federateName=new Parameter(this,""String_Node_Str"");
  federateName.setDisplayName(""String_Node_Str"");
  federateName.setTypeEquals(BaseType.STRING);
  federateName.setExpression(""String_Node_Str"");
  attributeChanged(federateName);
  federationName=new Parameter(this,""String_Node_Str"");
  federationName.setDisplayName(""String_Node_Str"");
  federationName.setTypeEquals(BaseType.STRING);
  federationName.setExpression(""String_Node_Str"");
  attributeChanged(federationName);
  fedFile=new FileParameter(this,""String_Node_Str"");
  fedFile.setDisplayName(""String_Node_Str"");
  new Parameter(fedFile,""String_Node_Str"",BooleanToken.TRUE);
  new Parameter(fedFile,""String_Node_Str"",BooleanToken.FALSE);
  fedFile.setExpression(""String_Node_Str"");
  timeManagementService=new ChoiceParameter(this,""String_Node_Str"",ETimeManagementService.class);
  timeManagementService.setDisplayName(""String_Node_Str"");
  attributeChanged(timeManagementService);
  hlaTimeStep=new Parameter(this,""String_Node_Str"");
  hlaTimeStep.setDisplayName(""String_Node_Str"");
  hlaTimeStep.setExpression(""String_Node_Str"");
  hlaTimeStep.setTypeEquals(BaseType.DOUBLE);
  attributeChanged(hlaTimeStep);
  isTimeConstrained=new Parameter(this,""String_Node_Str"");
  isTimeConstrained.setTypeEquals(BaseType.BOOLEAN);
  isTimeConstrained.setExpression(""String_Node_Str"");
  isTimeConstrained.setDisplayName(""String_Node_Str"");
  isTimeConstrained.setVisibility(Settable.NOT_EDITABLE);
  attributeChanged(isTimeConstrained);
  isTimeRegulator=new Parameter(this,""String_Node_Str"");
  isTimeRegulator.setTypeEquals(BaseType.BOOLEAN);
  isTimeRegulator.setExpression(""String_Node_Str"");
  isTimeRegulator.setDisplayName(""String_Node_Str"");
  isTimeRegulator.setVisibility(Settable.NOT_EDITABLE);
  attributeChanged(isTimeRegulator);
  hlaLookAHead=new Parameter(this,""String_Node_Str"");
  hlaLookAHead.setDisplayName(""String_Node_Str"");
  hlaLookAHead.setExpression(""String_Node_Str"");
  hlaLookAHead.setTypeEquals(BaseType.DOUBLE);
  attributeChanged(hlaLookAHead);
  requireSynchronization=new Parameter(this,""String_Node_Str"");
  requireSynchronization.setTypeEquals(BaseType.BOOLEAN);
  requireSynchronization.setExpression(""String_Node_Str"");
  requireSynchronization.setDisplayName(""String_Node_Str"");
  attributeChanged(requireSynchronization);
  synchronizationPointName=new Parameter(this,""String_Node_Str"");
  synchronizationPointName.setDisplayName(""String_Node_Str"");
  synchronizationPointName.setTypeEquals(BaseType.STRING);
  synchronizationPointName.setExpression(""String_Node_Str"");
  attributeChanged(synchronizationPointName);
  isCreator=new Parameter(this,""String_Node_Str"");
  isCreator.setTypeEquals(BaseType.BOOLEAN);
  isCreator.setExpression(""String_Node_Str"");
  isCreator.setDisplayName(""String_Node_Str"");
  attributeChanged(isCreator);
  hlaTimeUnit=new Parameter(this,""String_Node_Str"");
  hlaTimeUnit.setTypeEquals(BaseType.DOUBLE);
  hlaTimeUnit.setExpression(""String_Node_Str"");
  hlaTimeUnit.setDisplayName(""String_Node_Str"");
  attributeChanged(hlaTimeUnit);
}","/** 
 * Construct a HlaManager with a name and a container. The container argument must not be null, or a NullPointerException will be thrown. This actor will use the workspace of the container for synchronization and version counts. If the name argument is null, then the name is set to the empty string. Increment the version of the workspace.
 * @param container Container of this attribute.
 * @param name Name of this attribute.
 * @exception IllegalActionException If the container is incompatiblewith this actor.
 * @exception NameDuplicationException If the name coincides withan actor already in the container.
 */
public HlaManager(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  try {
    _testsFolder=_createFolder(""String_Node_Str"");
  }
 catch (  IOException ex) {
    throw new IllegalActionException(this,ex,""String_Node_Str"");
  }
  _file=_createTextFile(""String_Node_Str"");
  _csvFile=_createTextFile(""String_Node_Str"");
  _noObjectDicovered=true;
  _rtia=null;
  _federateAmbassador=null;
  _registeredObject=new HashMap<String,Integer>();
  _hlaAttributesToPublish=new HashMap<String,Object[]>();
  _hlaAttributesSubscribedTo=new HashMap<String,Object[]>();
  _fromFederationEvents=new HashMap<String,LinkedList<TimedEvent>>();
  _objectIdToClassHandle=new HashMap<Integer,Integer>();
  _strucuralInformation=new HashMap<Integer,StructuralInformation>();
  _hlaTimeStep=null;
  _hlaLookAHead=null;
  federateName=new Parameter(this,""String_Node_Str"");
  federateName.setDisplayName(""String_Node_Str"");
  federateName.setTypeEquals(BaseType.STRING);
  federateName.setExpression(""String_Node_Str"");
  attributeChanged(federateName);
  federationName=new Parameter(this,""String_Node_Str"");
  federationName.setDisplayName(""String_Node_Str"");
  federationName.setTypeEquals(BaseType.STRING);
  federationName.setExpression(""String_Node_Str"");
  attributeChanged(federationName);
  fedFile=new FileParameter(this,""String_Node_Str"");
  fedFile.setDisplayName(""String_Node_Str"");
  new Parameter(fedFile,""String_Node_Str"",BooleanToken.TRUE);
  new Parameter(fedFile,""String_Node_Str"",BooleanToken.FALSE);
  fedFile.setExpression(""String_Node_Str"");
  timeManagementService=new ChoiceParameter(this,""String_Node_Str"",ETimeManagementService.class);
  timeManagementService.setDisplayName(""String_Node_Str"");
  attributeChanged(timeManagementService);
  hlaTimeStep=new Parameter(this,""String_Node_Str"");
  hlaTimeStep.setDisplayName(""String_Node_Str"");
  hlaTimeStep.setExpression(""String_Node_Str"");
  hlaTimeStep.setTypeEquals(BaseType.DOUBLE);
  attributeChanged(hlaTimeStep);
  isTimeConstrained=new Parameter(this,""String_Node_Str"");
  isTimeConstrained.setTypeEquals(BaseType.BOOLEAN);
  isTimeConstrained.setExpression(""String_Node_Str"");
  isTimeConstrained.setDisplayName(""String_Node_Str"");
  isTimeConstrained.setVisibility(Settable.NOT_EDITABLE);
  attributeChanged(isTimeConstrained);
  isTimeRegulator=new Parameter(this,""String_Node_Str"");
  isTimeRegulator.setTypeEquals(BaseType.BOOLEAN);
  isTimeRegulator.setExpression(""String_Node_Str"");
  isTimeRegulator.setDisplayName(""String_Node_Str"");
  isTimeRegulator.setVisibility(Settable.NOT_EDITABLE);
  attributeChanged(isTimeRegulator);
  hlaLookAHead=new Parameter(this,""String_Node_Str"");
  hlaLookAHead.setDisplayName(""String_Node_Str"");
  hlaLookAHead.setExpression(""String_Node_Str"");
  hlaLookAHead.setTypeEquals(BaseType.DOUBLE);
  attributeChanged(hlaLookAHead);
  requireSynchronization=new Parameter(this,""String_Node_Str"");
  requireSynchronization.setTypeEquals(BaseType.BOOLEAN);
  requireSynchronization.setExpression(""String_Node_Str"");
  requireSynchronization.setDisplayName(""String_Node_Str"");
  attributeChanged(requireSynchronization);
  synchronizationPointName=new Parameter(this,""String_Node_Str"");
  synchronizationPointName.setDisplayName(""String_Node_Str"");
  synchronizationPointName.setTypeEquals(BaseType.STRING);
  synchronizationPointName.setExpression(""String_Node_Str"");
  attributeChanged(synchronizationPointName);
  isCreator=new Parameter(this,""String_Node_Str"");
  isCreator.setTypeEquals(BaseType.BOOLEAN);
  isCreator.setExpression(""String_Node_Str"");
  isCreator.setDisplayName(""String_Node_Str"");
  attributeChanged(isCreator);
  hlaTimeUnit=new Parameter(this,""String_Node_Str"");
  hlaTimeUnit.setTypeEquals(BaseType.DOUBLE);
  hlaTimeUnit.setExpression(""String_Node_Str"");
  hlaTimeUnit.setDisplayName(""String_Node_Str"");
  attributeChanged(hlaTimeUnit);
}"
72432,"/** 
 * Get the next data.
 * @param timeout The timeout in milliseconds.
 * @return The next data.
 */
public String getNextData(int timeout){
  HashMap<String,Object> gdp_event=GDP_GCL.get_next_event(_gcl,timeout);
  System.out.println(""String_Node_Str"" + timeout + ""String_Node_Str""+ gdp_event);
  return _datumToData(gdp_event.get(""String_Node_Str""));
}","/** 
 * Get the next data.
 * @param timeout The timeout in milliseconds.
 * @return The next data.
 */
public String getNextData(int timeout){
  HashMap<String,Object> gdp_event=GDP_GCL.get_next_event(_gcl,timeout);
  System.out.println(""String_Node_Str"" + timeout + ""String_Node_Str""+ gdp_event);
  return _datumToData((HashMap<String,Object>)gdp_event.get(""String_Node_Str""));
}"
72433,"/** 
 * Terminate the process and close any associated streams.
 * @exception IllegalActionException If the closing stdin of the subprocessthrew an IOException.
 */
public void terminateProcess() throws IllegalActionException {
  if (_process != null) {
    System.out.println(""String_Node_Str"" + _hlaManager.getFullName() + ""String_Node_Str"");
    System.out.println(""String_Node_Str"" + _hlaManager.getTotalNumberOfHLACalls() + ""String_Node_Str""+ _hlaManager.getNumberOfTARs()+ ""String_Node_Str""+ _hlaManager.getNumberOfNERs()+ ""String_Node_Str""+ _hlaManager.getNumberOfTAGs()+ ""String_Node_Str""+ HlaManager.calculateRuntime());
    try {
      _process.getOutputStream().close();
      _hlaManager.setNumberOfNERs(0);
      _hlaManager.setNumberOfTARs(0);
      _hlaManager.setTotalNumberOfHLACalls(0);
      _hlaManager.setNumberOfTAGs(0);
    }
 catch (    IOException io) {
      throw new IllegalActionException(_hlaManager,io,""String_Node_Str"" + ""String_Node_Str"");
    }
    if (_process != null) {
      _process.destroy();
      _process=null;
    }
  }
}","/** 
 * Terminate the process and close any associated streams.
 * @exception IllegalActionException If the closing stdin of the subprocessthrew an IOException.
 */
public void terminateProcess() throws IllegalActionException {
  if (_process != null) {
    System.out.println(""String_Node_Str"" + _hlaManager.getFullName() + ""String_Node_Str"");
    try {
      _process.getOutputStream().close();
    }
 catch (    IOException io) {
      throw new IllegalActionException(_hlaManager,io,""String_Node_Str"" + ""String_Node_Str"");
    }
    if (_process != null) {
      _process.destroy();
      _process=null;
    }
  }
}"
72434,"/** 
 * Terminate the process and close any associated streams.
 * @exception IllegalActionException If the closing stdin of the subprocessthrew an IOException.
 */
public void terminateProcess() throws IllegalActionException {
  if (_process != null) {
    System.out.println(""String_Node_Str"" + _hlaManager.getFullName() + ""String_Node_Str"");
    System.out.println(""String_Node_Str"" + _hlaManager.getTotalNumberOfHLACalls() + ""String_Node_Str""+ _hlaManager.getTar()+ ""String_Node_Str""+ _hlaManager.getNer()+ ""String_Node_Str""+ _hlaManager.getTag()+ ""String_Node_Str""+ HlaManager.calculateRuntime());
    try {
      _process.getOutputStream().close();
      _hlaManager.setNer(0);
      _hlaManager.setTar(0);
      _hlaManager.setTotalNumberOfHLACalls(0);
      _hlaManager.setTag(0);
    }
 catch (    IOException io) {
      throw new IllegalActionException(_hlaManager,io,""String_Node_Str"" + ""String_Node_Str"");
    }
    if (_process != null) {
      _process.destroy();
      _process=null;
    }
  }
}","/** 
 * Terminate the process and close any associated streams.
 * @exception IllegalActionException If the closing stdin of the subprocessthrew an IOException.
 */
public void terminateProcess() throws IllegalActionException {
  if (_process != null) {
    System.out.println(""String_Node_Str"" + _hlaManager.getFullName() + ""String_Node_Str"");
    System.out.println(""String_Node_Str"" + _hlaManager.getTotalNumberOfHLACalls() + ""String_Node_Str""+ _hlaManager.getNumberOfTARs()+ ""String_Node_Str""+ _hlaManager.getNumberOfNERs()+ ""String_Node_Str""+ _hlaManager.getNumberOfTAGs()+ ""String_Node_Str""+ HlaManager.calculateRuntime());
    try {
      _process.getOutputStream().close();
      _hlaManager.setNumberOfNERs(0);
      _hlaManager.setNumberOfTARs(0);
      _hlaManager.setTotalNumberOfHLACalls(0);
      _hlaManager.setNumberOfTAGs(0);
    }
 catch (    IOException io) {
      throw new IllegalActionException(_hlaManager,io,""String_Node_Str"" + ""String_Node_Str"");
    }
    if (_process != null) {
      _process.destroy();
      _process=null;
    }
  }
}"
72435,"/** 
 * Write the number of HLA calls of each federate, along with informations about the time step and the runtime, in a file. The name and location of this file are specified in the initialization of the  variable file.
 */
public void writeNumberOfHLACalls(){
  try {
    Date date=new Date();
    String fullName=federateName.toString();
    String stopTime=_director.getModelStopTime().toString();
    String nameOfTheFederate=fullName.substring(fullName.indexOf('""'),fullName.length());
    String nameOfTheFile=fullName.substring(fullName.indexOf('{') + 1,fullName.lastIndexOf('.') - 1);
    nameOfTheFile=nameOfTheFile.substring(1,nameOfTheFile.lastIndexOf('.') - 1) + ""String_Node_Str"";
    String info=""String_Node_Str"" + nameOfTheFederate + ""String_Node_Str""+ nameOfTheFile+ ""String_Node_Str""+ ""String_Node_Str""+ stopTime+ ""String_Node_Str"";
    if (_timeStepped) {
      info=info + ""String_Node_Str"" + _hlaTimeStep+ ""String_Node_Str""+ ""String_Node_Str""+ _numberOfTARs;
    }
 else     if (_eventBased) {
      info=info + ""String_Node_Str"" + _numberOfNERs;
    }
    info=info + ""String_Node_Str"" + ""String_Node_Str""+ _numberOfTAGs+ ""String_Node_Str""+ ""String_Node_Str""+ calculateRuntime()+ ""String_Node_Str"";
    info=date.toString() + ""String_Node_Str"" + info;
    file.write(info);
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"");
  }
}","/** 
 * Write the number of HLA calls of each federate, along with informations about the time step and the runtime, in a file. The name and location of this file are specified in the initialization of the  variable file.
 */
public void writeNumberOfHLACalls(){
  try {
    Date date=new Date();
    String fullName=federateName.toString();
    String stopTime=_director.getModelStopTime().toString();
    String nameOfTheFederate=fullName.substring(fullName.indexOf('""'));
    String nameOfTheFile=fullName.substring(fullName.indexOf('{') + 1,fullName.lastIndexOf('.'));
    nameOfTheFile=nameOfTheFile.substring(1,nameOfTheFile.lastIndexOf('.')) + ""String_Node_Str"";
    String info=""String_Node_Str"" + nameOfTheFederate + ""String_Node_Str""+ nameOfTheFile+ ""String_Node_Str""+ ""String_Node_Str""+ stopTime+ ""String_Node_Str"";
    if (_timeStepped) {
      info=info + ""String_Node_Str"" + _hlaTimeStep+ ""String_Node_Str""+ ""String_Node_Str""+ _numberOfTARs;
    }
 else     if (_eventBased) {
      info=info + ""String_Node_Str"" + _numberOfNERs;
    }
    info=info + ""String_Node_Str"" + ""String_Node_Str""+ _numberOfTAGs+ ""String_Node_Str""+ ""String_Node_Str""+ calculateRuntime()+ ""String_Node_Str"";
    info=date.toString() + ""String_Node_Str"" + info;
    _writeInTextFile(info);
    System.out.println(info);
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"");
  }
}"
72436,"/** 
 * Construct a HlaManager with a name and a container. The container argument must not be null, or a NullPointerException will be thrown. This actor will use the workspace of the container for synchronization and version counts. If the name argument is null, then the name is set to the empty string. Increment the version of the workspace.
 * @param container Container of this attribute.
 * @param name Name of this attribute.
 * @exception IllegalActionException If the container is incompatiblewith this actor.
 * @exception NameDuplicationException If the name coincides withan actor already in the container.
 */
public HlaManager(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  _numberOfNERs=0;
  _numberOfTARs=0;
  _numberOfTAGs=0;
  file=new TxtFile(""String_Node_Str"");
  _noObjectDicovered=true;
  _rtia=null;
  _federateAmbassador=null;
  _registeredObject=new HashMap<String,Integer>();
  _hlaAttributesToPublish=new HashMap<String,Object[]>();
  _hlaAttributesSubscribedTo=new HashMap<String,Object[]>();
  _fromFederationEvents=new HashMap<String,LinkedList<TimedEvent>>();
  _objectIdToClassHandle=new HashMap<Integer,Integer>();
  _strucuralInformation=new HashMap<Integer,StructuralInformation>();
  _hlaTimeStep=null;
  _hlaLookAHead=null;
  federateName=new Parameter(this,""String_Node_Str"");
  federateName.setDisplayName(""String_Node_Str"");
  federateName.setTypeEquals(BaseType.STRING);
  federateName.setExpression(""String_Node_Str"");
  attributeChanged(federateName);
  federationName=new Parameter(this,""String_Node_Str"");
  federationName.setDisplayName(""String_Node_Str"");
  federationName.setTypeEquals(BaseType.STRING);
  federationName.setExpression(""String_Node_Str"");
  attributeChanged(federationName);
  fedFile=new FileParameter(this,""String_Node_Str"");
  fedFile.setDisplayName(""String_Node_Str"");
  new Parameter(fedFile,""String_Node_Str"",BooleanToken.TRUE);
  new Parameter(fedFile,""String_Node_Str"",BooleanToken.FALSE);
  fedFile.setExpression(""String_Node_Str"");
  timeManagementService=new ChoiceParameter(this,""String_Node_Str"",ETimeManagementService.class);
  timeManagementService.setDisplayName(""String_Node_Str"");
  attributeChanged(timeManagementService);
  hlaTimeStep=new Parameter(this,""String_Node_Str"");
  hlaTimeStep.setDisplayName(""String_Node_Str"");
  hlaTimeStep.setExpression(""String_Node_Str"");
  hlaTimeStep.setTypeEquals(BaseType.DOUBLE);
  attributeChanged(hlaTimeStep);
  isTimeConstrained=new Parameter(this,""String_Node_Str"");
  isTimeConstrained.setTypeEquals(BaseType.BOOLEAN);
  isTimeConstrained.setExpression(""String_Node_Str"");
  isTimeConstrained.setDisplayName(""String_Node_Str"");
  isTimeConstrained.setVisibility(Settable.NOT_EDITABLE);
  attributeChanged(isTimeConstrained);
  isTimeRegulator=new Parameter(this,""String_Node_Str"");
  isTimeRegulator.setTypeEquals(BaseType.BOOLEAN);
  isTimeRegulator.setExpression(""String_Node_Str"");
  isTimeRegulator.setDisplayName(""String_Node_Str"");
  isTimeRegulator.setVisibility(Settable.NOT_EDITABLE);
  attributeChanged(isTimeRegulator);
  hlaLookAHead=new Parameter(this,""String_Node_Str"");
  hlaLookAHead.setDisplayName(""String_Node_Str"");
  hlaLookAHead.setExpression(""String_Node_Str"");
  hlaLookAHead.setTypeEquals(BaseType.DOUBLE);
  attributeChanged(hlaLookAHead);
  requireSynchronization=new Parameter(this,""String_Node_Str"");
  requireSynchronization.setTypeEquals(BaseType.BOOLEAN);
  requireSynchronization.setExpression(""String_Node_Str"");
  requireSynchronization.setDisplayName(""String_Node_Str"");
  attributeChanged(requireSynchronization);
  synchronizationPointName=new Parameter(this,""String_Node_Str"");
  synchronizationPointName.setDisplayName(""String_Node_Str"");
  synchronizationPointName.setTypeEquals(BaseType.STRING);
  synchronizationPointName.setExpression(""String_Node_Str"");
  attributeChanged(synchronizationPointName);
  isCreator=new Parameter(this,""String_Node_Str"");
  isCreator.setTypeEquals(BaseType.BOOLEAN);
  isCreator.setExpression(""String_Node_Str"");
  isCreator.setDisplayName(""String_Node_Str"");
  attributeChanged(isCreator);
  hlaTimeUnit=new Parameter(this,""String_Node_Str"");
  hlaTimeUnit.setTypeEquals(BaseType.DOUBLE);
  hlaTimeUnit.setExpression(""String_Node_Str"");
  hlaTimeUnit.setDisplayName(""String_Node_Str"");
  attributeChanged(hlaTimeUnit);
}","/** 
 * Construct a HlaManager with a name and a container. The container argument must not be null, or a NullPointerException will be thrown. This actor will use the workspace of the container for synchronization and version counts. If the name argument is null, then the name is set to the empty string. Increment the version of the workspace.
 * @param container Container of this attribute.
 * @param name Name of this attribute.
 * @exception IllegalActionException If the container is incompatiblewith this actor.
 * @exception NameDuplicationException If the name coincides withan actor already in the container.
 */
public HlaManager(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  _numberOfNERs=0;
  _numberOfTARs=0;
  _numberOfTAGs=0;
  _file=_createTextFile(""String_Node_Str"");
  _noObjectDicovered=true;
  _rtia=null;
  _federateAmbassador=null;
  _registeredObject=new HashMap<String,Integer>();
  _hlaAttributesToPublish=new HashMap<String,Object[]>();
  _hlaAttributesSubscribedTo=new HashMap<String,Object[]>();
  _fromFederationEvents=new HashMap<String,LinkedList<TimedEvent>>();
  _objectIdToClassHandle=new HashMap<Integer,Integer>();
  _strucuralInformation=new HashMap<Integer,StructuralInformation>();
  _hlaTimeStep=null;
  _hlaLookAHead=null;
  federateName=new Parameter(this,""String_Node_Str"");
  federateName.setDisplayName(""String_Node_Str"");
  federateName.setTypeEquals(BaseType.STRING);
  federateName.setExpression(""String_Node_Str"");
  attributeChanged(federateName);
  federationName=new Parameter(this,""String_Node_Str"");
  federationName.setDisplayName(""String_Node_Str"");
  federationName.setTypeEquals(BaseType.STRING);
  federationName.setExpression(""String_Node_Str"");
  attributeChanged(federationName);
  fedFile=new FileParameter(this,""String_Node_Str"");
  fedFile.setDisplayName(""String_Node_Str"");
  new Parameter(fedFile,""String_Node_Str"",BooleanToken.TRUE);
  new Parameter(fedFile,""String_Node_Str"",BooleanToken.FALSE);
  fedFile.setExpression(""String_Node_Str"");
  timeManagementService=new ChoiceParameter(this,""String_Node_Str"",ETimeManagementService.class);
  timeManagementService.setDisplayName(""String_Node_Str"");
  attributeChanged(timeManagementService);
  hlaTimeStep=new Parameter(this,""String_Node_Str"");
  hlaTimeStep.setDisplayName(""String_Node_Str"");
  hlaTimeStep.setExpression(""String_Node_Str"");
  hlaTimeStep.setTypeEquals(BaseType.DOUBLE);
  attributeChanged(hlaTimeStep);
  isTimeConstrained=new Parameter(this,""String_Node_Str"");
  isTimeConstrained.setTypeEquals(BaseType.BOOLEAN);
  isTimeConstrained.setExpression(""String_Node_Str"");
  isTimeConstrained.setDisplayName(""String_Node_Str"");
  isTimeConstrained.setVisibility(Settable.NOT_EDITABLE);
  attributeChanged(isTimeConstrained);
  isTimeRegulator=new Parameter(this,""String_Node_Str"");
  isTimeRegulator.setTypeEquals(BaseType.BOOLEAN);
  isTimeRegulator.setExpression(""String_Node_Str"");
  isTimeRegulator.setDisplayName(""String_Node_Str"");
  isTimeRegulator.setVisibility(Settable.NOT_EDITABLE);
  attributeChanged(isTimeRegulator);
  hlaLookAHead=new Parameter(this,""String_Node_Str"");
  hlaLookAHead.setDisplayName(""String_Node_Str"");
  hlaLookAHead.setExpression(""String_Node_Str"");
  hlaLookAHead.setTypeEquals(BaseType.DOUBLE);
  attributeChanged(hlaLookAHead);
  requireSynchronization=new Parameter(this,""String_Node_Str"");
  requireSynchronization.setTypeEquals(BaseType.BOOLEAN);
  requireSynchronization.setExpression(""String_Node_Str"");
  requireSynchronization.setDisplayName(""String_Node_Str"");
  attributeChanged(requireSynchronization);
  synchronizationPointName=new Parameter(this,""String_Node_Str"");
  synchronizationPointName.setDisplayName(""String_Node_Str"");
  synchronizationPointName.setTypeEquals(BaseType.STRING);
  synchronizationPointName.setExpression(""String_Node_Str"");
  attributeChanged(synchronizationPointName);
  isCreator=new Parameter(this,""String_Node_Str"");
  isCreator.setTypeEquals(BaseType.BOOLEAN);
  isCreator.setExpression(""String_Node_Str"");
  isCreator.setDisplayName(""String_Node_Str"");
  attributeChanged(isCreator);
  hlaTimeUnit=new Parameter(this,""String_Node_Str"");
  hlaTimeUnit.setTypeEquals(BaseType.DOUBLE);
  hlaTimeUnit.setExpression(""String_Node_Str"");
  hlaTimeUnit.setDisplayName(""String_Node_Str"");
  attributeChanged(hlaTimeUnit);
}"
72437,"/** 
 * Override the toString of enum class.
 * @return string associated for every enumerate
 */
@Override public String toString(){
switch (this) {
case NextEventRequest:
    return ""String_Node_Str"";
case TimeAdvancementRequest:
  return ""String_Node_Str"";
default :
throw new IllegalArgumentException();
}
}","/** 
 * Override the toString of enum class.
 * @return The string associated for every enumerate.
 */
@Override public String toString(){
switch (this) {
case NextEventRequest:
    return ""String_Node_Str"";
case TimeAdvancementRequest:
  return ""String_Node_Str"";
default :
throw new IllegalArgumentException();
}
}"
72438,"/** 
 * Terminate the process and close any associated streams.
 * @exception IllegalActionException If the closing stdin of the subprocessthrew an IOException.
 */
public void terminateProcess() throws IllegalActionException {
  if (_process != null) {
    System.out.println(""String_Node_Str"" + _hlaManager.getFullName() + ""String_Node_Str"");
    System.out.println(""String_Node_Str"" + _hlaManager.getTotalNbCalls() + ""String_Node_Str""+ _hlaManager.getTar()+ ""String_Node_Str""+ _hlaManager.getNer()+ ""String_Node_Str""+ _hlaManager.getTag());
    try {
      _process.getOutputStream().close();
      _hlaManager.writeNbCalls();
      _hlaManager.setNer(0);
      _hlaManager.setTar(0);
      _hlaManager.setTotalNbCalls(0);
      _hlaManager.setTag(0);
    }
 catch (    IOException io) {
      throw new IllegalActionException(_hlaManager,io,""String_Node_Str"" + ""String_Node_Str"");
    }
    if (_process != null) {
      _process.destroy();
      _process=null;
    }
  }
}","/** 
 * Terminate the process and close any associated streams.
 * @exception IllegalActionException If the closing stdin of the subprocessthrew an IOException.
 */
public void terminateProcess() throws IllegalActionException {
  if (_process != null) {
    System.out.println(""String_Node_Str"" + _hlaManager.getFullName() + ""String_Node_Str"");
    System.out.println(""String_Node_Str"" + _hlaManager.getTotalNbCalls() + ""String_Node_Str""+ _hlaManager.getTar()+ ""String_Node_Str""+ _hlaManager.getNer()+ ""String_Node_Str""+ _hlaManager.getTag()+ ""String_Node_Str""+ HlaManager.calculateRuntime());
    try {
      _process.getOutputStream().close();
      _hlaManager.setNer(0);
      _hlaManager.setTar(0);
      _hlaManager.setTotalNbCalls(0);
      _hlaManager.setTag(0);
    }
 catch (    IOException io) {
      throw new IllegalActionException(_hlaManager,io,""String_Node_Str"" + ""String_Node_Str"");
    }
    if (_process != null) {
      _process.destroy();
      _process=null;
    }
  }
}"
72439,"/** 
 * Execute a command, set _process to point to the subprocess and set up _errorGobbler and _outputGobbler to read data.
 * @exception IllegalActionException If the execution of the Runtime.exec()failed or if the RTIG subprocess it not running.
 */
public void exec() throws IllegalActionException {
  System.out.println(""String_Node_Str"" + _hlaManager.getFullName() + ""String_Node_Str""+ ""String_Node_Str""+ java.util.Arrays.toString(_commandArray)+ ""String_Node_Str""+ java.util.Arrays.toString(_environmentArray)+ ""String_Node_Str""+ _directoryAsFile);
  try {
    _process=_runtime.exec(_commandArray,_environmentArray,_directoryAsFile);
  }
 catch (  IOException e) {
    throw new IllegalActionException(_hlaManager,e,""String_Node_Str"");
  }
  _outputGobbler=new _StreamReaderThread(_process.getInputStream(),""String_Node_Str"" + _streamReaderThreadCount++,_hlaManager);
  _errorGobbler=new _StreamReaderThread(_process.getErrorStream(),""String_Node_Str"" + _streamReaderThreadCount++,_hlaManager);
  _errorGobbler.start();
  _outputGobbler.start();
  if (_streamReaderThreadCount > 1000) {
    _streamReaderThreadCount=0;
  }
}","/** 
 * Execute a command, set _process to point to the subprocess and set up _errorGobbler and _outputGobbler to read data.
 * @exception IllegalActionException If the execution of the Runtime.exec()failed or if the RTIG subprocess it not running.
 */
public void exec() throws IllegalActionException {
  HlaManager.setStartTime();
  System.out.println(""String_Node_Str"" + _hlaManager.getFullName() + ""String_Node_Str""+ ""String_Node_Str""+ java.util.Arrays.toString(_commandArray)+ ""String_Node_Str""+ java.util.Arrays.toString(_environmentArray)+ ""String_Node_Str""+ _directoryAsFile);
  try {
    _process=_runtime.exec(_commandArray,_environmentArray,_directoryAsFile);
  }
 catch (  IOException e) {
    throw new IllegalActionException(_hlaManager,e,""String_Node_Str"");
  }
  _outputGobbler=new _StreamReaderThread(_process.getInputStream(),""String_Node_Str"" + _streamReaderThreadCount++,_hlaManager);
  _errorGobbler=new _StreamReaderThread(_process.getErrorStream(),""String_Node_Str"" + _streamReaderThreadCount++,_hlaManager);
  _errorGobbler.start();
  _outputGobbler.start();
  if (_streamReaderThreadCount > 1000) {
    _streamReaderThreadCount=0;
  }
}"
72440,"public void writeNbCalls(){
  try {
    String stopTime=_director.getModelStopTime().toString();
    String info=this.getFullName() + ""String_Node_Str"" + ""String_Node_Str""+ stopTime+ ""String_Node_Str""+ ""String_Node_Str""+ _tar+ ""String_Node_Str""+ ""String_Node_Str""+ _ner+ ""String_Node_Str""+ ""String_Node_Str""+ _tag+ ""String_Node_Str"";
    file.write(info);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","public void writeNbCalls(){
  try {
    String stopTime=_director.getModelStopTime().toString();
    String info=this.getFullName() + ""String_Node_Str"" + ""String_Node_Str""+ stopTime+ ""String_Node_Str""+ ""String_Node_Str""+ _tar+ ""String_Node_Str""+ ""String_Node_Str""+ _ner+ ""String_Node_Str""+ ""String_Node_Str""+ _tag+ ""String_Node_Str""+ ""String_Node_Str""+ calculateRuntime()+ ""String_Node_Str"";
    file.write(info);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}"
72441,"public void setStopTime(String stopTime){
  this.stopTime=stopTime;
}","public void setStopTime(String stopTime){
  this._stopTime=stopTime;
}"
72442,"/** 
 * Manage the correct termination of the   {@link HlaManager}. Call the HLA services to: unsubscribe to HLA attributes, unpublish HLA attributes, resign a Federation and destroy a Federation if the current Federate is the last participant.
 * @exception IllegalActionException If the parent class throws itof if a CERTI exception is raised then displayed it to the user.
 */
@Override public void wrapup() throws IllegalActionException {
  super.wrapup();
  _strucuralInformation.clear();
  _registeredObject.clear();
  _debug(""String_Node_Str"" + ""String_Node_Str"" + _tar + ""String_Node_Str""+ _ner+ ""String_Node_Str""+ _tag);
  if (_debugging) {
    _debug(this.getDisplayName() + ""String_Node_Str"");
  }
  for (  Object[] obj : _hlaAttributesSubscribedTo.values()) {
    try {
      _rtia.unsubscribeObjectClass(_getClassHandleFromTab(obj));
    }
 catch (    RTIexception e) {
      throw new IllegalActionException(this,e,e.getMessage());
    }
    if (_debugging) {
      _debug(this.getDisplayName() + ""String_Node_Str"" + _getPortFromTab(obj).getContainer().getName()+ ""String_Node_Str""+ _getClassHandleFromTab(obj)+ ""String_Node_Str"");
    }
  }
  for (  Object[] obj : _hlaAttributesToPublish.values()) {
    try {
      _rtia.unpublishObjectClass(_getClassHandleFromTab(obj));
    }
 catch (    RTIexception e) {
      throw new IllegalActionException(this,e,e.getMessage());
    }
    if (_debugging) {
      _debug(this.getDisplayName() + ""String_Node_Str"" + _getPortFromTab(obj).getContainer().getName()+ ""String_Node_Str""+ _getClassHandleFromTab(obj)+ ""String_Node_Str"");
    }
  }
  try {
    _rtia.resignFederationExecution(ResignAction.DELETE_OBJECTS_AND_RELEASE_ATTRIBUTES);
  }
 catch (  RTIexception e) {
    throw new IllegalActionException(this,e,e.getMessage());
  }
  if (_debugging) {
    _debug(this.getDisplayName() + ""String_Node_Str"");
  }
  boolean canDestroyRtig=false;
  while (!canDestroyRtig) {
    try {
      _rtia.destroyFederationExecution(_federationName);
    }
 catch (    FederatesCurrentlyJoined e) {
      if (_debugging) {
        _debug(this.getDisplayName() + ""String_Node_Str"");
      }
    }
catch (    FederationExecutionDoesNotExist e) {
      if (_debugging) {
        _debug(this.getDisplayName() + ""String_Node_Str"");
      }
      canDestroyRtig=true;
    }
catch (    RTIinternalError e) {
      throw new IllegalActionException(this,e,""String_Node_Str"");
    }
catch (    ConcurrentAccessAttempted e) {
      throw new IllegalActionException(this,e,""String_Node_Str"");
    }
    if (_debugging) {
      _debug(this.getDisplayName() + ""String_Node_Str"" + ""String_Node_Str"");
    }
    canDestroyRtig=true;
  }
  if (_certiRtig != null) {
    _certiRtig.terminateProcess();
    if (_debugging) {
      _debug(this.getDisplayName() + ""String_Node_Str"" + ""String_Node_Str"");
    }
  }
  _hlaAttributesToPublish.clear();
  _hlaAttributesSubscribedTo.clear();
  _fromFederationEvents.clear();
  _objectIdToClassHandle.clear();
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
}","/** 
 * Manage the correct termination of the   {@link HlaManager}. Call the HLA services to: unsubscribe to HLA attributes, unpublish HLA attributes, resign a Federation and destroy a Federation if the current Federate is the last participant.
 * @exception IllegalActionException If the parent class throws itof if a CERTI exception is raised then displayed it to the user.
 */
@Override public void wrapup() throws IllegalActionException {
  super.wrapup();
  _strucuralInformation.clear();
  _registeredObject.clear();
  _debug(""String_Node_Str"" + ""String_Node_Str"" + _tar + ""String_Node_Str""+ _ner+ ""String_Node_Str""+ _tag);
  writeNbCalls();
  if (_debugging) {
    _debug(this.getDisplayName() + ""String_Node_Str"");
  }
  for (  Object[] obj : _hlaAttributesSubscribedTo.values()) {
    try {
      _rtia.unsubscribeObjectClass(_getClassHandleFromTab(obj));
    }
 catch (    RTIexception e) {
      throw new IllegalActionException(this,e,e.getMessage());
    }
    if (_debugging) {
      _debug(this.getDisplayName() + ""String_Node_Str"" + _getPortFromTab(obj).getContainer().getName()+ ""String_Node_Str""+ _getClassHandleFromTab(obj)+ ""String_Node_Str"");
    }
  }
  for (  Object[] obj : _hlaAttributesToPublish.values()) {
    try {
      _rtia.unpublishObjectClass(_getClassHandleFromTab(obj));
    }
 catch (    RTIexception e) {
      throw new IllegalActionException(this,e,e.getMessage());
    }
    if (_debugging) {
      _debug(this.getDisplayName() + ""String_Node_Str"" + _getPortFromTab(obj).getContainer().getName()+ ""String_Node_Str""+ _getClassHandleFromTab(obj)+ ""String_Node_Str"");
    }
  }
  try {
    _rtia.resignFederationExecution(ResignAction.DELETE_OBJECTS_AND_RELEASE_ATTRIBUTES);
  }
 catch (  RTIexception e) {
    throw new IllegalActionException(this,e,e.getMessage());
  }
  if (_debugging) {
    _debug(this.getDisplayName() + ""String_Node_Str"");
  }
  boolean canDestroyRtig=false;
  while (!canDestroyRtig) {
    try {
      _rtia.destroyFederationExecution(_federationName);
    }
 catch (    FederatesCurrentlyJoined e) {
      if (_debugging) {
        _debug(this.getDisplayName() + ""String_Node_Str"");
      }
    }
catch (    FederationExecutionDoesNotExist e) {
      if (_debugging) {
        _debug(this.getDisplayName() + ""String_Node_Str"");
      }
      canDestroyRtig=true;
    }
catch (    RTIinternalError e) {
      throw new IllegalActionException(this,e,""String_Node_Str"");
    }
catch (    ConcurrentAccessAttempted e) {
      throw new IllegalActionException(this,e,""String_Node_Str"");
    }
    if (_debugging) {
      _debug(this.getDisplayName() + ""String_Node_Str"" + ""String_Node_Str"");
    }
    canDestroyRtig=true;
  }
  if (_certiRtig != null) {
    _certiRtig.terminateProcess();
    if (_debugging) {
      _debug(this.getDisplayName() + ""String_Node_Str"" + ""String_Node_Str"");
    }
  }
  _hlaAttributesToPublish.clear();
  _hlaAttributesSubscribedTo.clear();
  _fromFederationEvents.clear();
  _objectIdToClassHandle.clear();
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
}"
72443,"/** 
 * @return the tar
 */
public int getTar(){
  return _tar;
}","/** 
 * @return the number of time advance requests that this federate has made
 */
public int getTar(){
  return _tar;
}"
72444,"/** 
 * @return the tag
 */
public int getTag(){
  return _tag;
}","/** 
 * @return the number of time advance grants that this federate has received
 */
public int getTag(){
  return _tag;
}"
72445,"/** 
 * @return the ner
 */
public int getNer(){
  return _ner;
}","/** 
 * @return the number of next event requests that this federate has made
 */
public int getNer(){
  return _ner;
}"
72446,"public String getStopTime(){
  return stopTime;
}","public String getStopTime(){
  return _stopTime;
}"
72447,"/** 
 * Destroy the plotter.  This method is usually called by PlotApplet.destroy().  It does various cleanups to reduce memory usage.
 */
@Override public void destroy(){
  clear(true);
  setAutomaticRescale(false);
  setTimedRepaint(false);
  if (_printButton != null) {
    ActionListener[] listeners=_printButton.getActionListeners();
    for (    ActionListener listener : listeners) {
      _printButton.removeActionListener(listener);
    }
    _printButton=null;
  }
  if (_resetButton != null) {
    ActionListener[] listeners=_resetButton.getActionListeners();
    for (    ActionListener listener : listeners) {
      _resetButton.removeActionListener(listener);
    }
    _resetButton=null;
  }
  if (_eqAxButton != null) {
    ActionListener[] listeners=_formatButton.getActionListeners();
    for (    ActionListener listener : listeners) {
      _formatButton.removeActionListener(listener);
    }
    _eqAxButton=null;
  }
  if (_formatButton != null) {
    ActionListener[] listeners=_formatButton.getActionListeners();
    for (    ActionListener listener : listeners) {
      _formatButton.removeActionListener(listener);
    }
    _formatButton=null;
  }
  if (_fillButton != null) {
    ActionListener[] listeners=_fillButton.getActionListeners();
    for (    ActionListener listener : listeners) {
      _fillButton.removeActionListener(listener);
    }
    _fillButton=null;
  }
  removeAll();
}","/** 
 * Destroy the plotter.  This method is usually called by PlotApplet.destroy().  It does various cleanups to reduce memory usage.
 */
@Override public void destroy(){
  clear(true);
  setAutomaticRescale(false);
  setTimedRepaint(false);
  if (_printButton != null) {
    ActionListener[] listeners=_printButton.getActionListeners();
    for (    ActionListener listener : listeners) {
      _printButton.removeActionListener(listener);
    }
    _printButton=null;
  }
  if (_resetButton != null) {
    ActionListener[] listeners=_resetButton.getActionListeners();
    for (    ActionListener listener : listeners) {
      _resetButton.removeActionListener(listener);
    }
    _resetButton=null;
  }
  if (_eqAxButton != null) {
    ActionListener[] listeners=_formatButton.getActionListeners();
    for (    ActionListener listener : listeners) {
      _eqAxButton.removeActionListener(listener);
    }
    _eqAxButton=null;
  }
  if (_formatButton != null) {
    ActionListener[] listeners=_formatButton.getActionListeners();
    for (    ActionListener listener : listeners) {
      _formatButton.removeActionListener(listener);
    }
    _formatButton=null;
  }
  if (_fillButton != null) {
    ActionListener[] listeners=_fillButton.getActionListeners();
    for (    ActionListener listener : listeners) {
      _fillButton.removeActionListener(listener);
    }
    _fillButton=null;
  }
  removeAll();
}"
72448,"/** 
 * Create a server that can accept socket connection requests on behalf of the specified JavaScript SocketServer object. After this is called, the specified JavaScript SocketServer object will emit the following events: <ul> <li> listening: Emitted when the server is listening. This will be passed the port number that the server is listening on (this is useful if the port is specified to be 0). <li> connection: Emitted when a new connection is established after a request from (possibly remote) client. This will be passed an instance of the JavaScript Socket class that is defined in the socket.js module. That instance has a send() and close() function that can be used to send data or to close the socket. It is also an event emitter that emits 'close', 'data', and 'error' events. <li> error: If this server fails to start listening. An error message will be passed to any event handler. </ul>
 * @param socketServer The JavaScript SocketServer instance.
 * @param options The options (see the socket.js JavaScript module).
 */
public void openServer(final ScriptObjectMirror socketServer,final Map<String,Object> options){
  ClientAuth auth=ClientAuth.NONE;
  String authSpec=(String)options.get(""String_Node_Str"");
  if (authSpec.toLowerCase().trim().equals(""String_Node_Str"")) {
    auth=ClientAuth.REQUEST;
  }
 else   if (authSpec.toLowerCase().trim().equals(""String_Node_Str"")) {
    auth=ClientAuth.REQUIRED;
  }
  final NetServerOptions serverOptions=new NetServerOptions().setClientAuth(auth).setHost((String)options.get(""String_Node_Str"")).setIdleTimeout((Integer)options.get(""String_Node_Str"")).setTcpKeepAlive((Boolean)options.get(""String_Node_Str"")).setPort((Integer)options.get(""String_Node_Str"")).setReceiveBufferSize((Integer)options.get(""String_Node_Str"")).setSendBufferSize((Integer)options.get(""String_Node_Str"")).setSsl((Boolean)options.get(""String_Node_Str"")).setTcpNoDelay((Boolean)options.get(""String_Node_Str""));
  if (serverOptions.isSsl()) {
    PfxOptions pfxOptions=new PfxOptions();
    String pfxKeyCertPath=(String)options.get(""String_Node_Str"");
    File pfxKeyCertFile=FileUtilities.nameToFile(pfxKeyCertPath,null);
    if (pfxKeyCertFile == null) {
      _error(socketServer,""String_Node_Str"");
      return;
    }
    try {
      pfxOptions.setPath(pfxKeyCertFile.getCanonicalPath());
    }
 catch (    IOException e) {
      _error(socketServer,""String_Node_Str"" + pfxKeyCertFile);
      return;
    }
    String pfxKeyCertPassword=(String)options.get(""String_Node_Str"");
    pfxOptions.setPassword(pfxKeyCertPassword);
    serverOptions.setPfxKeyCertOptions(pfxOptions);
    if (serverOptions.getClientAuth() != ClientAuth.NONE) {
      PemTrustOptions pemTrustOptions=new PemTrustOptions();
      String caCertPath=(String)options.get(""String_Node_Str"");
      File caCertFile=FileUtilities.nameToFile(caCertPath,null);
      if (caCertFile == null) {
        _error(socketServer,""String_Node_Str"");
        return;
      }
      try {
        pemTrustOptions.addCertPath(caCertFile.getCanonicalPath());
        serverOptions.setPemTrustOptions(pemTrustOptions);
      }
 catch (      IOException e) {
        _error(socketServer,""String_Node_Str"" + caCertFile);
        return;
      }
    }
  }
  submit(() -> {
    final NetServer server=_vertx.createNetServer(serverOptions);
    _issueResponse(() -> {
      socketServer.callMember(""String_Node_Str"",server);
    }
);
    server.connectHandler(socket -> {
      _issueResponse(() -> {
        socketServer.callMember(""String_Node_Str"",socket);
      }
);
    }
);
    try {
      server.listen(result -> {
        _issueResponse(() -> {
          if (result.succeeded()) {
            socketServer.callMember(""String_Node_Str"",""String_Node_Str"",server.actualPort());
          }
 else {
            _error(""String_Node_Str"" + result);
          }
        }
);
      }
);
    }
 catch (    Throwable ex) {
      _error(socketServer,""String_Node_Str"" + ex);
    }
  }
);
}","/** 
 * Create a server that can accept socket connection requests on behalf of the specified JavaScript SocketServer object. After this is called, the specified JavaScript SocketServer object will emit the following events: <ul> <li> listening: Emitted when the server is listening. This will be passed the port number that the server is listening on (this is useful if the port is specified to be 0). <li> connection: Emitted when a new connection is established after a request from (possibly remote) client. This will be passed an instance of the JavaScript Socket class that is defined in the socket.js module. That instance has a send() and close() function that can be used to send data or to close the socket. It is also an event emitter that emits 'close', 'data', and 'error' events. <li> error: If this server fails to start listening. An error message will be passed to any event handler. </ul>
 * @param socketServer The JavaScript SocketServer instance.
 * @param options The options (see the socket.js JavaScript module).
 */
public void openServer(final ScriptObjectMirror socketServer,final Map<String,Object> options){
  ClientAuth auth=ClientAuth.NONE;
  String authSpec=(String)options.get(""String_Node_Str"");
  if (authSpec.toLowerCase().trim().equals(""String_Node_Str"")) {
    auth=ClientAuth.REQUEST;
  }
 else   if (authSpec.toLowerCase().trim().equals(""String_Node_Str"")) {
    auth=ClientAuth.REQUIRED;
  }
  final NetServerOptions serverOptions=new NetServerOptions().setClientAuth(auth).setHost((String)options.get(""String_Node_Str"")).setIdleTimeout((Integer)options.get(""String_Node_Str"")).setTcpKeepAlive((Boolean)options.get(""String_Node_Str"")).setPort((Integer)options.get(""String_Node_Str"")).setReceiveBufferSize((Integer)options.get(""String_Node_Str"")).setSendBufferSize((Integer)options.get(""String_Node_Str"")).setSsl((Boolean)options.get(""String_Node_Str"")).setTcpNoDelay((Boolean)options.get(""String_Node_Str""));
  if (serverOptions.isSsl()) {
    PfxOptions pfxOptions=new PfxOptions();
    String pfxKeyCertPath=(String)options.get(""String_Node_Str"");
    File pfxKeyCertFile=FileUtilities.nameToFile(pfxKeyCertPath,null);
    if (pfxKeyCertFile == null) {
      _error(socketServer,""String_Node_Str"");
      return;
    }
    try {
      pfxOptions.setPath(pfxKeyCertFile.getCanonicalPath());
    }
 catch (    IOException e) {
      _error(socketServer,""String_Node_Str"" + pfxKeyCertFile);
      return;
    }
    String pfxKeyCertPassword=(String)options.get(""String_Node_Str"");
    pfxOptions.setPassword(pfxKeyCertPassword);
    serverOptions.setPfxKeyCertOptions(pfxOptions);
    if (serverOptions.getClientAuth() != ClientAuth.NONE) {
      PemTrustOptions pemTrustOptions=new PemTrustOptions();
      String caCertPath=(String)options.get(""String_Node_Str"");
      File caCertFile=FileUtilities.nameToFile(caCertPath,null);
      if (caCertFile == null) {
        _error(socketServer,""String_Node_Str"");
        return;
      }
      try {
        pemTrustOptions.addCertPath(caCertFile.getCanonicalPath());
        serverOptions.setPemTrustOptions(pemTrustOptions);
      }
 catch (      IOException e) {
        _error(socketServer,""String_Node_Str"" + caCertFile);
        return;
      }
    }
  }
  submit(() -> {
    final NetServer server=_vertx.createNetServer(serverOptions);
    _issueResponse(() -> {
      socketServer.callMember(""String_Node_Str"",server);
    }
);
    server.connectHandler(socket -> {
      socketServer.callMember(""String_Node_Str"",socket);
    }
);
    try {
      server.listen(result -> {
        _issueResponse(() -> {
          if (result.succeeded()) {
            socketServer.callMember(""String_Node_Str"",""String_Node_Str"",server.actualPort());
          }
 else {
            _error(""String_Node_Str"" + result);
          }
        }
);
      }
);
    }
 catch (    Throwable ex) {
      _error(socketServer,""String_Node_Str"" + ex);
    }
  }
);
}"
72449,"/** 
 * Consume the inputs and produce the outputs of the FFT filter.
 * @exception IllegalActionException If a runtime type error occurs.
 */
@Override public void fire() throws IllegalActionException {
  super.fire();
  if (input.hasToken(0)) {
    Token observationArray=input.get(0);
    _classificationLength=((ArrayToken)observationArray).length();
    if (((ArrayToken)observationArray).getElementType().isCompatible(BaseType.DOUBLE)) {
      _observations=new double[_classificationLength][1];
      for (int i=0; i < _classificationLength; i++) {
        _observations[i][0]=((DoubleToken)((ArrayToken)observationArray).getElement(i)).doubleValue();
      }
    }
 else {
      int obsDim=((ArrayToken)((ArrayToken)observationArray).getElement(0)).length();
      _observations=new double[_classificationLength][obsDim];
      for (int i=0; i < _classificationLength; i++) {
        for (int j=0; j < obsDim; j++) {
          _observations[i][j]=((DoubleToken)((ArrayToken)((ArrayToken)observationArray).getElement(i)).getElement(j)).doubleValue();
        }
      }
    }
  }
 else {
    _observations=null;
  }
}","/** 
 * Consume the inputs and produce the outputs of the FFT filter.
 * @exception IllegalActionException If a runtime type error occurs.
 */
@Override public void fire() throws IllegalActionException {
  super.fire();
  if (input.hasToken(0)) {
    Token observationArray=input.get(0);
    _classificationLength=((ArrayToken)observationArray).length();
    if (((ArrayToken)observationArray).getElementType().isCompatible(BaseType.DOUBLE)) {
      _observations=new double[_classificationLength][1];
      for (int i=0; i < _classificationLength; i++) {
        _observations[i][0]=((DoubleToken)((ArrayToken)observationArray).getElement(i)).doubleValue();
      }
    }
 else     if (((ArrayToken)observationArray).getElementType().isCompatible(BaseType.INT)) {
      _observations=new double[_classificationLength][1];
      for (int i=0; i < _classificationLength; i++) {
        _observations[i][0]=((IntToken)((ArrayToken)observationArray).getElement(i)).intValue();
      }
    }
 else {
      int obsDim=((ArrayToken)((ArrayToken)observationArray).getElement(0)).length();
      _observations=new double[_classificationLength][obsDim];
      for (int i=0; i < _classificationLength; i++) {
        for (int j=0; j < obsDim; j++) {
          _observations[i][j]=((DoubleToken)((ArrayToken)((ArrayToken)observationArray).getElement(i)).getElement(j)).doubleValue();
        }
      }
    }
  }
 else {
    _observations=null;
  }
}"
72450,"@Override public void fire() throws IllegalActionException {
  super.fire();
  if (input.hasToken(0)) {
    Token observationArray=input.get(0);
    int _observationLength=((ArrayToken)observationArray).length();
    if (_observationLength <= 0) {
      throw new IllegalActionException(this,""String_Node_Str"" + _observationLength + ""String_Node_Str"");
    }
    if (((ArrayToken)observationArray).getElementType().equals(BaseType.DOUBLE)) {
      _observations=new double[_observationLength][1];
      for (int i=0; i < _observationLength; i++) {
        _observations[i][0]=((DoubleToken)((ArrayToken)observationArray).getElement(i)).doubleValue();
      }
    }
 else {
      int observationDimension=((ArrayToken)((ArrayToken)observationArray).getElement(0)).length();
      _observations=new double[_observationLength][observationDimension];
      for (int i=0; i < _observationLength; i++) {
        for (int j=0; j < observationDimension; j++) {
          _observations[i][j]=((DoubleToken)((ArrayToken)((ArrayToken)observationArray).getElement(i)).getElement(j)).doubleValue();
        }
      }
    }
  }
}","@Override public void fire() throws IllegalActionException {
  super.fire();
  if (input.hasToken(0)) {
    Token observationArray=input.get(0);
    int _observationLength=((ArrayToken)observationArray).length();
    _obsDimension=1;
    if (_observationLength <= 0) {
      throw new IllegalActionException(this,""String_Node_Str"" + _observationLength + ""String_Node_Str"");
    }
    if (((ArrayToken)observationArray).getElementType().equals(BaseType.DOUBLE)) {
      _observations=new double[_observationLength][1];
      for (int i=0; i < _observationLength; i++) {
        _observations[i][0]=((DoubleToken)((ArrayToken)observationArray).getElement(i)).doubleValue();
      }
    }
 else     if (((ArrayToken)observationArray).getElementType().equals(BaseType.INT)) {
      _observations=new double[_observationLength][1];
      for (int i=0; i < _observationLength; i++) {
        _observations[i][0]=((IntToken)((ArrayToken)observationArray).getElement(i)).intValue();
      }
    }
 else {
      int observationDimension=((ArrayToken)((ArrayToken)observationArray).getElement(0)).length();
      _obsDimension=observationDimension;
      _observations=new double[_observationLength][_obsDimension];
      for (int i=0; i < _observationLength; i++) {
        for (int j=0; j < observationDimension; j++) {
          _observations[i][j]=((DoubleToken)((ArrayToken)((ArrayToken)observationArray).getElement(i)).getElement(j)).doubleValue();
        }
      }
    }
  }
}"
72451,"/** 
 * Read one token from each input channel and compare against the value specified in <i>correctValues</i>.  If the token count is larger than the length of <i>correctValues</i>, then return immediately, indicating that the inputs correctly matched the values in <i>correctValues</i> and that the test succeeded.
 * @exception IllegalActionException If an input does not matchthe required value or if the width of the input is not 1.
 */
@Override public boolean postfire() throws IllegalActionException {
  if (!super.postfire()) {
    return false;
  }
  if (input.getWidth() != 1) {
    throw new IllegalActionException(this,""String_Node_Str"" + input.getWidth() + ""String_Node_Str"");
  }
  boolean training=((BooleanToken)trainingMode.getToken()).booleanValue();
  if (training) {
    if (_trainingTokens == null) {
      _trainingTokens=new ArrayList();
    }
    if (input.hasToken(0)) {
      _trainingTokens.add(input.get(0));
    }
    return true;
  }
  if (_numberOfInputTokensSeen >= ((ArrayToken)correctValues.getToken()).length()) {
    if (input.hasToken(0)) {
      input.get(0);
    }
    return true;
  }
  if (input.hasToken(0)) {
    Token token=input.get(0);
    _numberOfInputTokensSeen++;
    Token referenceToken=null;
    if (((BooleanToken)requireOrderedValues.getToken()).booleanValue()) {
      referenceToken=((ArrayToken)correctValues.getToken()).getElement(_numberOfInputTokensSeen);
      if (!_isClose(token,referenceToken,_tolerance)) {
        throw new IllegalActionException(this,""String_Node_Str"" + _iteration + ""String_Node_Str""+ ""String_Node_Str""+ token+ ""String_Node_Str""+ referenceToken);
      }
    }
 else {
      boolean sawMatch=false;
      for (int i=0; i < ((ArrayToken)correctValues.getToken()).length(); i++) {
        if (!_matchedValues[i]) {
          referenceToken=((ArrayToken)correctValues.getToken()).getElement(i);
          if (_isClose(token,referenceToken,_tolerance)) {
            _matchedValues[i]=true;
            sawMatch=true;
            break;
          }
        }
      }
      if (!sawMatch) {
        throw new IllegalActionException(this,""String_Node_Str"" + _iteration + ""String_Node_Str""+ ""String_Node_Str""+ token+ ""String_Node_Str""+ ""String_Node_Str"");
      }
    }
  }
  _iteration++;
  return true;
}","/** 
 * Read one token from each input channel and compare against the value specified in <i>correctValues</i>.  If the token count is larger than the length of <i>correctValues</i>, then return immediately, indicating that the inputs correctly matched the values in <i>correctValues</i> and that the test succeeded.
 * @exception IllegalActionException If an input does not matchthe required value or if the width of the input is not 1.
 */
@Override public boolean postfire() throws IllegalActionException {
  if (!super.postfire()) {
    return false;
  }
  if (input.getWidth() != 1) {
    throw new IllegalActionException(this,""String_Node_Str"" + input.getWidth() + ""String_Node_Str"");
  }
  boolean training=((BooleanToken)trainingMode.getToken()).booleanValue();
  if (training) {
    if (_trainingTokens == null) {
      _trainingTokens=new ArrayList();
    }
    if (input.hasToken(0)) {
      _trainingTokens.add(input.get(0));
    }
    return true;
  }
  if (_numberOfInputTokensSeen >= ((ArrayToken)correctValues.getToken()).length()) {
    if (input.hasToken(0)) {
      input.get(0);
    }
    return true;
  }
  if (input.hasToken(0)) {
    Token token=input.get(0);
    Token referenceToken=null;
    if (((BooleanToken)requireOrderedValues.getToken()).booleanValue()) {
      referenceToken=((ArrayToken)correctValues.getToken()).getElement(_numberOfInputTokensSeen);
      if (!_isClose(token,referenceToken,_tolerance)) {
        throw new IllegalActionException(this,""String_Node_Str"" + _iteration + ""String_Node_Str""+ ""String_Node_Str""+ token+ ""String_Node_Str""+ referenceToken);
      }
    }
 else {
      boolean sawMatch=false;
      for (int i=0; i < ((ArrayToken)correctValues.getToken()).length(); i++) {
        if (!_matchedValues[i]) {
          referenceToken=((ArrayToken)correctValues.getToken()).getElement(i);
          if (_isClose(token,referenceToken,_tolerance)) {
            _matchedValues[i]=true;
            sawMatch=true;
            break;
          }
        }
      }
      if (!sawMatch) {
        throw new IllegalActionException(this,""String_Node_Str"" + _iteration + ""String_Node_Str""+ ""String_Node_Str""+ token+ ""String_Node_Str""+ ""String_Node_Str"");
      }
    }
    _numberOfInputTokensSeen++;
  }
  _iteration++;
  return true;
}"
72452,"/** 
 * Construct a director in the given container with the given name. The container argument must not be null, or a NullPointerException will be thrown. If the name argument is null, then the name is set to the empty string. Increment the version number of the workspace.
 * @param container Container of this director.
 * @param name Name of this director.
 * @exception IllegalActionException If the name has a period in it, orthe director is not compatible with the specified container.
 * @exception NameDuplicationException If the container is not aCompositeActor and the name collides with an entity in the container.
 */
public FMIMADirector(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
}","public FMIMADirector(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  _isFirstFire=true;
}"
72453,"/** 
 * Fire actors according to events in the event queue. The actual selecting which events to process is done in _fire(). _fire() will return whether the previous firing was successful. According to this information, it is decided whether _fire() should be called again in order to keep processing events. After each actor firing, book keeping procedures are called, to keep track of the current state of the scheduler. The model time of the next events are also checked to see if we have produced an event of smaller timestamp.
 * @see #_fire
 * @exception IllegalActionException If we couldn't process an eventor if an event of smaller timestamp is found within the event queue.
 */
@Override public void fire() throws IllegalActionException {
}","@Override public void fire() throws IllegalActionException {
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  if (getModelTime().getDoubleValue() > getStopTime()) {
    stop();
  }
  super.fire();
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  Time proposedFmiTime=getModelTime().add(1E-8);
  Nameable container=getContainer();
  Iterator<?> actors=((CompositeActor)container).deepEntityList().iterator();
  while (actors.hasNext()) {
    Actor actor=(Actor)actors.next();
    if (actor instanceof TimeRegulator) {
      Time modifiedTime=((TimeRegulator)actor).proposeTime(proposedFmiTime);
      if (proposedFmiTime.compareTo(modifiedTime) > 0) {
        proposedFmiTime=modifiedTime;
      }
      if (_debugging) {
        _debug(""String_Node_Str"" + actor.getFullName() + ""String_Node_Str""+ modifiedTime.getLongValue()+ ""String_Node_Str""+ getModelTime());
      }
    }
  }
  if (_debugging) {
    _debug(""String_Node_Str"" + proposedFmiTime);
  }
}"
72454,"/** 
 * Close the UDP socket with a given port number.
 * @param port The port number.
 */
public void bind(int port){
  _socket.listen(""String_Node_Str"",port,new AsyncResultHandler<DatagramSocket>(){
    public void handle(    AsyncResult<DatagramSocket> asyncResult){
      if (asyncResult.succeeded()) {
        _socket.dataHandler(new Handler<DatagramPacket>(){
          public void handle(          DatagramPacket packet){
            _currentObj.callMember(""String_Node_Str"",packet.data().toString());
          }
        }
);
      }
 else {
        System.out.println(""String_Node_Str"" + asyncResult.cause());
      }
    }
  }
);
}","/** 
 * Close the UDP socket with a given port number.
 * @param port The port number.
 */
public void bind(int port){
  _socket.listen(port,""String_Node_Str"",new AsyncResultHandler<DatagramSocket>(){
    public void handle(    AsyncResult<DatagramSocket> asyncResult){
      if (asyncResult.succeeded()) {
        _socket.handler(new Handler<DatagramPacket>(){
          public void handle(          DatagramPacket packet){
            _currentObj.callMember(""String_Node_Str"",packet.data().toString());
          }
        }
);
      }
 else {
        System.out.println(""String_Node_Str"" + asyncResult.cause());
      }
    }
  }
);
}"
72455,"private UDPSocketHelper(ScriptObjectMirror currentObj){
  super(currentObj);
  _currentObj=currentObj;
  _socket=_vertx.createDatagramSocket(InternetProtocolFamily.IPv4);
}","private UDPSocketHelper(ScriptObjectMirror currentObj){
  super(currentObj);
  _currentObj=currentObj;
  _socket=_vertx.createDatagramSocket();
}"
72456,"/** 
 * Send a UDP message.
 * @param data An array of bytes to be sent.  Currently Ignored.
 * @param offset The offset. Current Ignored.
 * @param length The length of the message. Currently Ignored.
 * @param port The port.  Currently Ignored.
 * @param hostname The hostname.  Currently Ignored.
 */
public void send(byte[] data,int offset,int length,int port,String hostname){
  Buffer buffer=new Buffer(""String_Node_Str"");
  _socket.send(buffer,""String_Node_Str"",1234,new AsyncResultHandler<DatagramSocket>(){
    public void handle(    AsyncResult<DatagramSocket> asyncResult){
      System.out.println(""String_Node_Str"" + asyncResult.succeeded());
    }
  }
);
}","/** 
 * Send a UDP message.
 * @param data An array of bytes to be sent.  Currently Ignored.
 * @param offset The offset. Current Ignored.
 * @param length The length of the message. Currently Ignored.
 * @param port The port.  Currently Ignored.
 * @param hostname The hostname.  Currently Ignored.
 */
public void send(byte[] data,int offset,int length,int port,String hostname){
  Buffer buffer=Buffer.buffer(""String_Node_Str"");
  _socket.send(buffer,1234,""String_Node_Str"",new Handler<AsyncResult<DatagramSocket>>(){
    public void handle(    AsyncResult<DatagramSocket> asyncResult){
      System.out.println(""String_Node_Str"" + asyncResult.succeeded());
    }
  }
);
}"
72457,"/** 
 * Register subscriber handler at vertx bus.
 * @param address The address on the bus that should be suscribed to.
 */
public void registerHandler(String address){
  JsonObject message=new JsonObject().put(""String_Node_Str"",""String_Node_Str"").put(""String_Node_Str"",address);
  _webSocket.writeTextFrame(message.encode());
}","/** 
 * Register subscriber handler at vertx bus.
 * @param address The address on the bus that should be suscribed to.
 */
public void registerHandler(String address){
  JsonObject message=new JsonObject().put(""String_Node_Str"",""String_Node_Str"").put(""String_Node_Str"",address);
  _webSocket.writeFinalTextFrame(message.encode());
}"
72458,"/** 
 * Establish a connection to the event bus, if not already connected.
 */
public void connect(){
  if (!_wsIsOpen) {
    try {
      _httpClient.connectWebsocket(""String_Node_Str"",new Handler<WebSocket>(){
        @Override public void handle(        WebSocket websocket){
          _wsIsOpen=true;
          _webSocket=websocket;
          _currentObj.callMember(""String_Node_Str"",""String_Node_Str"");
          _webSocket.dataHandler(new DataHandler());
          _webSocket.endHandler(new EndHandler());
          _webSocket.exceptionHandler(new ExceptionHandler());
          _periodicPing=_vertx.setPeriodic(5000,new Handler<Long>(){
            @Override public void handle(            Long timerID){
              JsonObject json=new JsonObject().put(""String_Node_Str"",""String_Node_Str"");
              try {
                _sendTextFrame(json);
              }
 catch (              IllegalActionException e) {
                _currentObj.callMember(""String_Node_Str"",""String_Node_Str"");
              }
            }
          }
);
        }
      }
);
    }
 catch (    Exception e) {
      _currentObj.callMember(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
      System.out.println(e);
    }
  }
}","/** 
 * Establish a connection to the event bus, if not already connected.
 */
public void connect(){
  if (!_wsIsOpen) {
    try {
      _httpClient.websocket(""String_Node_Str"",new Handler<WebSocket>(){
        @Override public void handle(        WebSocket websocket){
          _wsIsOpen=true;
          _webSocket=websocket;
          _currentObj.callMember(""String_Node_Str"",""String_Node_Str"");
          _webSocket.handler(new DataHandler());
          _webSocket.endHandler(new EndHandler());
          _webSocket.exceptionHandler(new ExceptionHandler());
          _periodicPing=_vertx.setPeriodic(5000,new Handler<Long>(){
            @Override public void handle(            Long timerID){
              JsonObject json=new JsonObject().put(""String_Node_Str"",""String_Node_Str"");
              try {
                _sendTextFrame(json);
              }
 catch (              IllegalActionException e) {
                _currentObj.callMember(""String_Node_Str"",""String_Node_Str"");
              }
            }
          }
);
        }
      }
);
    }
 catch (    Exception e) {
      _currentObj.callMember(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
      System.out.println(e);
    }
  }
}"
72459,"/** 
 * Private constructor for WebSocketHelper for a server-side web socket.
 * @param currentObj The JavaScript instance of Socket that this helps.
 * @param serverWebSocket The server-side web socket, provided by the web socket server.
 * @param receiveType The type to assume for incoming messages.
 * @param sendType The type for outgoing messages.
 * @param maxFrameSize The maximum frame size for a received message.
 */
private WebSocketHelper(ScriptObjectMirror currentObj,WebSocketBase serverWebSocket,String receiveType,String sendType,int maxFrameSize){
  super(currentObj);
  _webSocket=serverWebSocket;
  _wsIsOpen=true;
  _maxFrameSize=maxFrameSize;
  _webSocket.dataHandler(new DataHandler());
  _webSocket.endHandler(new EndHandler());
  _webSocket.exceptionHandler(new WebSocketExceptionHandler());
  _webSocket.closeHandler(new WebSocketCloseHandler());
  _receiveType=receiveType;
  _sendType=sendType;
}","/** 
 * Private constructor for WebSocketHelper for a server-side web socket.
 * @param currentObj The JavaScript instance of Socket that this helps.
 * @param serverWebSocket The server-side web socket, provided by the web socket server.
 * @param receiveType The type to assume for incoming messages.
 * @param sendType The type for outgoing messages.
 * @param maxFrameSize The maximum frame size for a received message.
 */
private WebSocketHelper(ScriptObjectMirror currentObj,WebSocketBase serverWebSocket,String receiveType,String sendType,int maxFrameSize){
  super(currentObj);
  _webSocket=serverWebSocket;
  _wsIsOpen=true;
  _maxFrameSize=maxFrameSize;
  _webSocket.handler(new DataHandler());
  _webSocket.endHandler(new EndHandler());
  _webSocket.exceptionHandler(new WebSocketExceptionHandler());
  _webSocket.closeHandler(new WebSocketCloseHandler());
  _receiveType=receiveType;
  _sendType=sendType;
}"
72460,"/** 
 * Send the specified message over the websocket.
 * @param message The message.
 */
protected void _sendMessageOverSocket(Object message){
  if (message instanceof String) {
    message=new Buffer((String)message);
  }
  if (!(message instanceof Buffer)) {
    _currentObj.callMember(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + message.getClass() + ""String_Node_Str"");
    return;
  }
  _webSocket.write((Buffer)message);
  if (_webSocket.writeQueueFull()) {
    _webSocket.pause();
    _webSocket.drainHandler(new VoidHandler(){
      public void handle(){
        _webSocket.resume();
      }
    }
);
  }
}","/** 
 * Send the specified message over the websocket.
 * @param message The message.
 */
protected void _sendMessageOverSocket(Object message){
  if (message instanceof String) {
    message=Buffer.buffer((String)message);
  }
  if (!(message instanceof Buffer)) {
    _currentObj.callMember(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + message.getClass() + ""String_Node_Str"");
    return;
  }
  _webSocket.write((Buffer)message);
  if (_webSocket.writeQueueFull()) {
    _webSocket.pause();
    _webSocket.drainHandler(new VoidHandler(){
      public void handle(){
        _webSocket.resume();
      }
    }
);
  }
}"
72461,"/** 
 * Connect to a web socket on the specified host.
 * @param host The host IP or name.
 * @param port The port.
 * @param client The HttpClient object.
 */
private void _connectWebsocket(String host,int port,HttpClient client){
  String address=""String_Node_Str"" + host + ""String_Node_Str""+ port;
  client.connectWebsocket(address,new Handler<WebSocket>(){
    @Override public void handle(    WebSocket websocket){
synchronized (_actor) {
        if (_numberOfTries < 0) {
          websocket.close();
          return;
        }
        if (!_actor.isExecuting()) {
          websocket.close();
          return;
        }
        _wsIsOpen=true;
        _webSocket=websocket;
        _webSocket.dataHandler(new DataHandler());
        _webSocket.endHandler(new EndHandler());
        _webSocket.exceptionHandler(new WebSocketExceptionHandler());
        _webSocket.closeHandler(new WebSocketCloseHandler());
        _currentObj.callMember(""String_Node_Str"",""String_Node_Str"");
        _currentObj.callMember(""String_Node_Str"",""String_Node_Str"");
        if (_pendingOutputs != null && _pendingOutputs.size() > 0) {
          for (          Object message : _pendingOutputs) {
            _sendMessageOverSocket(message);
          }
          _pendingOutputs.clear();
        }
      }
    }
  }
);
}","/** 
 * Connect to a web socket on the specified host.
 * @param host The host IP or name.
 * @param port The port.
 * @param client The HttpClient object.
 */
private void _connectWebsocket(String host,int port,HttpClient client){
  client.websocket(port,host,""String_Node_Str"",new Handler<WebSocket>(){
    @Override public void handle(    WebSocket websocket){
synchronized (_actor) {
        if (_numberOfTries < 0) {
          websocket.close();
          return;
        }
        if (!_actor.isExecuting()) {
          websocket.close();
          return;
        }
        _wsIsOpen=true;
        _webSocket=websocket;
        _webSocket.handler(new DataHandler());
        _webSocket.endHandler(new EndHandler());
        _webSocket.exceptionHandler(new WebSocketExceptionHandler());
        _webSocket.closeHandler(new WebSocketCloseHandler());
        _currentObj.callMember(""String_Node_Str"",""String_Node_Str"");
        _currentObj.callMember(""String_Node_Str"",""String_Node_Str"");
        if (_pendingOutputs != null && _pendingOutputs.size() > 0) {
          for (          Object message : _pendingOutputs) {
            _sendMessageOverSocket(message);
          }
          _pendingOutputs.clear();
        }
      }
    }
  }
);
}"
72462,"/** 
 * Send data through the web socket.
 * @param msg A message to be sent.
 * @exception IllegalActionException If establishing the connection to the web socket haspermanently failed.
 */
public void send(Object msg) throws IllegalActionException {
synchronized (_actor) {
    if (_wsFailed != null) {
      throw new IllegalActionException(_actor,_wsFailed,""String_Node_Str"" + _numberOfTries + ""String_Node_Str"");
    }
    if (!(msg instanceof String)) {
      if (msg instanceof ImageToken) {
        Image image=((ImageToken)msg).asAWTImage();
        if (!(image instanceof BufferedImage)) {
          throw new IllegalActionException(_actor,""String_Node_Str"" + image.getClass());
        }
        if (!_sendType.startsWith(""String_Node_Str"")) {
          throw new IllegalActionException(_actor,""String_Node_Str"" + _sendType);
        }
        String imageType=_sendType.substring(6);
        ByteArrayOutputStream stream=new ByteArrayOutputStream();
        try {
          ImageIO.write((BufferedImage)image,imageType,stream);
        }
 catch (        IOException e) {
          throw new IllegalActionException(_actor,e,""String_Node_Str"");
        }
        msg=new Buffer(stream.toByteArray());
      }
    }
    if (isOpen()) {
      _sendMessageOverSocket(msg);
    }
 else     if (!_discardMessagesBeforeOpen) {
      if (_pendingOutputs == null) {
        _pendingOutputs=new LinkedList();
      }
      _pendingOutputs.add(msg);
      if (_throttleFactor > 0) {
        try {
          Thread.sleep(_throttleFactor * _pendingOutputs.size());
        }
 catch (        InterruptedException e) {
        }
      }
    }
 else {
      _actor.log(""String_Node_Str"" + msg);
    }
  }
}","/** 
 * Send data through the web socket.
 * @param msg A message to be sent.
 * @exception IllegalActionException If establishing the connection to the web socket haspermanently failed.
 */
public void send(Object msg) throws IllegalActionException {
synchronized (_actor) {
    if (_wsFailed != null) {
      throw new IllegalActionException(_actor,_wsFailed,""String_Node_Str"" + _numberOfTries + ""String_Node_Str"");
    }
    if (!(msg instanceof String)) {
      if (msg instanceof ImageToken) {
        Image image=((ImageToken)msg).asAWTImage();
        if (!(image instanceof BufferedImage)) {
          throw new IllegalActionException(_actor,""String_Node_Str"" + image.getClass());
        }
        if (!_sendType.startsWith(""String_Node_Str"")) {
          throw new IllegalActionException(_actor,""String_Node_Str"" + _sendType);
        }
        String imageType=_sendType.substring(6);
        ByteArrayOutputStream stream=new ByteArrayOutputStream();
        try {
          ImageIO.write((BufferedImage)image,imageType,stream);
        }
 catch (        IOException e) {
          throw new IllegalActionException(_actor,e,""String_Node_Str"");
        }
        msg=Buffer.buffer(stream.toByteArray());
      }
    }
    if (isOpen()) {
      _sendMessageOverSocket(msg);
    }
 else     if (!_discardMessagesBeforeOpen) {
      if (_pendingOutputs == null) {
        _pendingOutputs=new LinkedList();
      }
      _pendingOutputs.add(msg);
      if (_throttleFactor > 0) {
        try {
          Thread.sleep(_throttleFactor * _pendingOutputs.size());
        }
 catch (        InterruptedException e) {
        }
      }
    }
 else {
      _actor.log(""String_Node_Str"" + msg);
    }
  }
}"
72463,"/** 
 * Return the difference between two strings.
 * @param aString The first string to be compared.
 * @param bString The secondString to be compared
 * @return A string describing the difference between the twostrings in a format similar to the Unix diff command.
 */
public static String diff(String aString,String bString){
  String eol=System.getProperty(""String_Node_Str"");
  String[] aStringSplit=aString.split(eol);
  String[] bStringSplit=bString.split(eol);
  int aNumberOfLines=aStringSplit.length;
  int bNumberOfLines=bStringSplit.length;
  int[][] lcs=new int[aNumberOfLines + 1][bNumberOfLines + 1];
  for (int i=aNumberOfLines - 1; i >= 0; i--) {
    for (int j=bNumberOfLines - 1; j >= 0; j--) {
      if (aStringSplit[i].equals(bStringSplit[j])) {
        lcs[i][j]=lcs[i + 1][j + 1] + 1;
      }
 else {
        lcs[i][j]=Math.max(lcs[i + 1][j],lcs[i][j + 1]);
      }
    }
  }
  StringBuffer result=new StringBuffer();
  int i=0, j=0;
  while (i < aNumberOfLines && j < bNumberOfLines) {
    if (aStringSplit[i].equals(bStringSplit[j])) {
      i++;
      j++;
    }
 else     if (lcs[i + 1][j] >= lcs[i][j + 1]) {
      result.append(""String_Node_Str"" + aStringSplit[i++] + eol);
    }
 else {
      result.append(""String_Node_Str"" + bStringSplit[j++] + eol);
    }
  }
  while (i < aNumberOfLines || j < bNumberOfLines) {
    if (i == aNumberOfLines) {
      result.append(""String_Node_Str"" + aStringSplit[j++] + eol);
    }
 else     if (j == bNumberOfLines) {
      result.append(""String_Node_Str"" + bStringSplit[i++] + eol);
    }
  }
  return result.toString();
}","/** 
 * Return the difference between two strings.
 * @param aString The first string to be compared.
 * @param bString The secondString to be compared
 * @return A string describing the difference between the twostrings in a format similar to the Unix diff command.
 */
public static String diff(String aString,String bString){
  String systemEol=System.getProperty(""String_Node_Str"");
  String eol=""String_Node_Str"";
  String[] aStringSplit=aString.split(eol);
  String[] bStringSplit=bString.split(eol);
  int aNumberOfLines=aStringSplit.length;
  int bNumberOfLines=bStringSplit.length;
  int[][] lcs=new int[aNumberOfLines + 1][bNumberOfLines + 1];
  for (int i=aNumberOfLines - 1; i >= 0; i--) {
    for (int j=bNumberOfLines - 1; j >= 0; j--) {
      if (aStringSplit[i].equals(bStringSplit[j])) {
        lcs[i][j]=lcs[i + 1][j + 1] + 1;
      }
 else {
        lcs[i][j]=Math.max(lcs[i + 1][j],lcs[i][j + 1]);
      }
    }
  }
  StringBuffer result=new StringBuffer();
  int i=0, j=0;
  while (i < aNumberOfLines && j < bNumberOfLines) {
    if (aStringSplit[i].equals(bStringSplit[j])) {
      i++;
      j++;
    }
 else     if (lcs[i + 1][j] >= lcs[i][j + 1]) {
      result.append(""String_Node_Str"" + aStringSplit[i++] + systemEol);
    }
 else {
      result.append(""String_Node_Str"" + bStringSplit[j++] + systemEol);
    }
  }
  while (i < aNumberOfLines || j < bNumberOfLines) {
    if (i == aNumberOfLines) {
      result.append(""String_Node_Str"" + aStringSplit[j++] + systemEol);
    }
 else     if (j == bNumberOfLines) {
      result.append(""String_Node_Str"" + bStringSplit[i++] + systemEol);
    }
  }
  return result.toString();
}"
72464,"/** 
 * Traverse a composite KNode containing corresponding KIELER nodes, ports and edges for the Ptolemy model and apply all layout information contained by it back to the Ptolemy model. Do most changes to the Ptolemy model via MoMLChangeRequests. Set location attributes for all visible Ptolemy nodes. Optionally route edges by inserting   {@link LayoutHint} attributes.
 * @param parentNode The KIELER graph object containing all layout informationto apply to the Ptolemy model
 * @exception IllegalActionException if routing of edges fails.
 */
private void _applyLayout(KNode parentNode) throws IllegalActionException {
  ApplyLayoutRequest layoutRequest=new ApplyLayoutRequest(_compositeEntity);
  for (  KNode knode : parentNode.getChildren()) {
    KShapeLayout nodeLayout=knode.getData(KShapeLayout.class);
    KVector nodePos=nodeLayout.createVector();
    Object divaNode=_kieler2ptolemyDivaNodes.get(knode);
    if (divaNode instanceof Location) {
      Locatable location=(Location)divaNode;
      KimlUtil.toAbsolute(nodePos,parentNode);
      _kNode2Ptolemy(nodePos,divaNode,location);
      double[] snapToGridNodePoint=SnapConstraint.constrainPoint(nodePos.x,nodePos.y);
      layoutRequest.addLocation(location,snapToGridNodePoint[0],snapToGridNodePoint[1]);
    }
  }
  GraphModel graphModel=getLayoutTarget().getGraphModel();
  if (graphModel instanceof ActorGraphModel) {
    for (    Pair<KEdge,Link> entry : _edgeList) {
      _applyEdgeLayoutBendPointAnnotation(entry.getFirst(),entry.getSecond(),layoutRequest);
    }
  }
 else   if (graphModel instanceof FSMGraphModel) {
    for (    Pair<KEdge,Link> entry : _edgeList) {
      if (parentNode.getData(KLayoutData.class).getProperty(Parameters.SPLINES)) {
        _applyEdgeLayoutBendPointAnnotation(entry.getFirst(),entry.getSecond(),layoutRequest);
      }
 else {
        _applyEdgeLayoutCurve(entry.getFirst(),entry.getSecond(),layoutRequest);
      }
    }
  }
  _compositeEntity.requestChange(layoutRequest);
}","/** 
 * Traverse a composite KNode containing corresponding KIELER nodes, ports and edges for the Ptolemy model and apply all layout information contained by it back to the Ptolemy model. Do most changes to the Ptolemy model via MoMLChangeRequests. Set location attributes for all visible Ptolemy nodes. Optionally route edges by inserting   {@link LayoutHint} attributes.
 * @param parentNode The KIELER graph object containing all layout informationto apply to the Ptolemy model
 * @param layoutRequest the common layout request for the current layout run
 * @exception IllegalActionException if routing of edges fails.
 */
private void _applyLayout(KNode parentNode,ApplyLayoutRequest layoutRequest) throws IllegalActionException {
  for (  KNode knode : parentNode.getChildren()) {
    KShapeLayout nodeLayout=knode.getData(KShapeLayout.class);
    KVector nodePos=nodeLayout.createVector();
    Object divaNode=_kieler2ptolemyDivaNodes.get(knode);
    if (divaNode instanceof Location) {
      Locatable location=(Location)divaNode;
      KimlUtil.toAbsolute(nodePos,parentNode);
      _kNode2Ptolemy(nodePos,divaNode,location);
      double[] snapToGridNodePoint=SnapConstraint.constrainPoint(nodePos.x,nodePos.y);
      layoutRequest.addLocation(location,snapToGridNodePoint[0],snapToGridNodePoint[1]);
    }
  }
  GraphModel graphModel=getLayoutTarget().getGraphModel();
  if (graphModel instanceof ActorGraphModel) {
    for (    Pair<KEdge,Link> entry : _edgeList) {
      _applyEdgeLayoutBendPointAnnotation(entry.getFirst(),entry.getSecond(),layoutRequest);
    }
  }
 else   if (graphModel instanceof FSMGraphModel) {
    for (    Pair<KEdge,Link> entry : _edgeList) {
      if (parentNode.getData(KLayoutData.class).getProperty(Parameters.SPLINES)) {
        _applyEdgeLayoutBendPointAnnotation(entry.getFirst(),entry.getSecond(),layoutRequest);
      }
 else {
        _applyEdgeLayoutCurve(entry.getFirst(),entry.getSecond(),layoutRequest);
      }
    }
  }
}"
72465,"/** 
 * Recusively applies   {@link #_applyLayout(KNode)} to any {@link KNode} that has further children.
 * @param parentNode The KIELER graph object containing all layout informationto apply to the Ptolemy model
 * @exception IllegalActionException if routing of edges fails.
 */
private void _recursivelyApplyLayout(KNode parentNode) throws IllegalActionException {
  if (!parentNode.getChildren().isEmpty()) {
    _applyLayout(parentNode);
    for (    KNode child : parentNode.getChildren()) {
      if (!child.getChildren().isEmpty()) {
        _recursivelyApplyLayout(child);
      }
    }
  }
}","/** 
 * Recusively applies   {@link #_applyLayout(KNode)} to any {@link KNode} that has further children.
 * @param parentNode The KIELER graph object containing all layout informationto apply to the Ptolemy model
 * @param layoutRequest the common layout request for the current layout run
 * @exception IllegalActionException if routing of edges fails.
 */
private void _recursivelyApplyLayout(KNode parentNode,ApplyLayoutRequest layoutRequest) throws IllegalActionException {
  if (!parentNode.getChildren().isEmpty()) {
    _applyLayout(parentNode,layoutRequest);
    for (    KNode child : parentNode.getChildren()) {
      if (!child.getChildren().isEmpty()) {
        _recursivelyApplyLayout(child,layoutRequest);
      }
    }
  }
}"
72466,"/** 
 * Layout the given composite. Main entry point for the layout action. Create a KIELER KGraph data structure corresponding to the Ptolemy model, instantiate a KIELER layout algorithm (AbstractLayoutProvider) and run its doLayout() method on the KGraph. The KGraph is augmented with layout information (position and sizes of objects and bend points for connections). This information is then reapplied to the ptolemy model by stating MoMLChangeRequests with location attributes for nodes. Connection bend points are applied using   {@link LayoutHint}s.
 * @param composite the container of the diagram in terms of a GraphModel.
 */
@Override public void layout(Object composite){
  KielerLayoutConnector.setLayoutInProgress(true);
  KielerLayoutArcConnector.setLayoutInProgress(true);
  long overallTime=System.currentTimeMillis();
  _report(""String_Node_Str"");
  long graphOverhead=overallTime;
  _graphModel=getLayoutTarget().getGraphModel();
  KNode parentNode=KimlUtil.createInitializedNode();
  KShapeLayout parentLayout=parentNode.getData(KShapeLayout.class);
  if (_top != null) {
    Dimension contentSize=_top.getContentSize();
    parentLayout.setWidth(contentSize.width);
    parentLayout.setHeight(contentSize.height);
  }
  KNode mainModelNode=parentNode;
  KShapeLayout mainModelLayout=parentLayout;
  if (_graphModel instanceof FSMGraphModel) {
    mainModelNode=_createFsmSkeleton(parentNode);
    mainModelLayout=mainModelNode.getData(KShapeLayout.class);
  }
  try {
    Parameters parameters=new Parameters(_compositeEntity);
    parameters.configureLayout(mainModelLayout,getLayoutTarget().getGraphModel());
    _createGraph(composite,mainModelNode);
    graphOverhead=System.currentTimeMillis() - graphOverhead;
    InstancePool<AbstractLayoutProvider> layouterPool=_getLayouterPool();
    AbstractLayoutProvider layoutProvider=layouterPool.fetch();
    IKielerProgressMonitor progressMonitor=new BasicProgressMonitor();
    _recursivelyLayout(parentNode,layoutProvider,progressMonitor);
    if (DEBUG) {
      KimlUtil.persistDataElements(parentNode);
      KielerGraphUtil._writeToFile(parentNode);
    }
    KVector offset=KielerGraphUtil._getUpperLeftCorner(parentNode);
    parentLayout.setXpos(parentLayout.getXpos() - (float)offset.x);
    parentLayout.setYpos(parentLayout.getYpos() - (float)offset.y);
    long momlRequestOverhead=System.currentTimeMillis();
    _recursivelyApplyLayout(parentNode);
    momlRequestOverhead=System.currentTimeMillis() - momlRequestOverhead;
    overallTime=System.currentTimeMillis() - overallTime;
    _report(""String_Node_Str"" + overallTime + ""String_Node_Str""+ graphOverhead+ ""String_Node_Str""+ Math.round(progressMonitor.getExecutionTime() * 1000)+ ""String_Node_Str""+ momlRequestOverhead+ ""String_Node_Str"");
    layouterPool.release(layoutProvider);
  }
 catch (  IllegalActionException exception) {
    throw new InternalErrorException(exception);
  }
  KielerLayoutConnector.setLayoutInProgress(false);
  KielerLayoutArcConnector.setLayoutInProgress(false);
}","/** 
 * Layout the given composite. Main entry point for the layout action. Create a KIELER KGraph data structure corresponding to the Ptolemy model, instantiate a KIELER layout algorithm (AbstractLayoutProvider) and run its doLayout() method on the KGraph. The KGraph is augmented with layout information (position and sizes of objects and bend points for connections). This information is then reapplied to the ptolemy model by stating MoMLChangeRequests with location attributes for nodes. Connection bend points are applied using   {@link LayoutHint}s.
 * @param composite the container of the diagram in terms of a GraphModel.
 */
@Override public void layout(Object composite){
  KielerLayoutConnector.setLayoutInProgress(true);
  KielerLayoutArcConnector.setLayoutInProgress(true);
  long overallTime=System.currentTimeMillis();
  _report(""String_Node_Str"");
  long graphOverhead=overallTime;
  _graphModel=getLayoutTarget().getGraphModel();
  KNode parentNode=KimlUtil.createInitializedNode();
  KShapeLayout parentLayout=parentNode.getData(KShapeLayout.class);
  if (_top != null) {
    Dimension contentSize=_top.getContentSize();
    parentLayout.setWidth(contentSize.width);
    parentLayout.setHeight(contentSize.height);
  }
  KNode mainModelNode=parentNode;
  KShapeLayout mainModelLayout=parentLayout;
  if (_graphModel instanceof FSMGraphModel) {
    mainModelNode=_createFsmSkeleton(parentNode);
    mainModelLayout=mainModelNode.getData(KShapeLayout.class);
  }
  try {
    Parameters parameters=new Parameters(_compositeEntity);
    parameters.configureLayout(mainModelLayout,getLayoutTarget().getGraphModel());
    _createGraph(composite,mainModelNode);
    graphOverhead=System.currentTimeMillis() - graphOverhead;
    InstancePool<AbstractLayoutProvider> layouterPool=_getLayouterPool();
    AbstractLayoutProvider layoutProvider=layouterPool.fetch();
    IKielerProgressMonitor progressMonitor=new BasicProgressMonitor();
    _recursivelyLayout(parentNode,layoutProvider,progressMonitor);
    if (DEBUG) {
      KimlUtil.persistDataElements(parentNode);
      KielerGraphUtil._writeToFile(parentNode);
    }
    KVector offset=KielerGraphUtil._getUpperLeftCorner(parentNode);
    parentLayout.setXpos(parentLayout.getXpos() - (float)offset.x);
    parentLayout.setYpos(parentLayout.getYpos() - (float)offset.y);
    long momlRequestOverhead=System.currentTimeMillis();
    ApplyLayoutRequest layoutRequest=new ApplyLayoutRequest(_compositeEntity);
    _recursivelyApplyLayout(parentNode,layoutRequest);
    _compositeEntity.requestChange(layoutRequest);
    momlRequestOverhead=System.currentTimeMillis() - momlRequestOverhead;
    overallTime=System.currentTimeMillis() - overallTime;
    _report(""String_Node_Str"" + overallTime + ""String_Node_Str""+ graphOverhead+ ""String_Node_Str""+ Math.round(progressMonitor.getExecutionTime() * 1000)+ ""String_Node_Str""+ momlRequestOverhead+ ""String_Node_Str"");
    layouterPool.release(layoutProvider);
  }
 catch (  IllegalActionException exception) {
    throw new InternalErrorException(exception);
  }
  KielerLayoutConnector.setLayoutInProgress(false);
  KielerLayoutArcConnector.setLayoutInProgress(false);
}"
72467,"/** 
 * If the specified effigy is a TextEffigy and it already contains a tableau named ""textTableau"", then return that tableau; otherwise, create a new instance of TextEditorTableau in the specified effigy, and name it ""textTableau"" and return that tableau. If the specified effigy is not an instance of TextEffigy, but contains an instance of TextEffigy, then open a tableau for that effigy.  If it is a PtolemyEffigy, then create a text effigy with the MoML representation of the model. Finally, if is not a TextEffigy or a PtolemyEffigy, and it does not contain a TextEffigy, then attempt to open its URL and display its date by creating a text effigy, which will then be contained by the specified effigy. If all of this fails, then do not create a tableau and return null. It is the responsibility of callers of this method to check the return value and call show().
 * @param effigy The effigy.
 * @return A text editor tableau, or null if one cannot befound or created.
 * @exception Exception If the factory should be able to create atableau for the effigy, but something goes wrong.
 */
@Override public Tableau createTableau(Effigy effigy) throws Exception {
  if (effigy instanceof TextEffigy) {
    TextEditorTableau tableau=(TextEditorTableau)effigy.getEntity(""String_Node_Str"");
    if (tableau == null) {
      TextEditor editor=null;
      String style=syntaxStyle.getExpression();
      if (style == null || style.trim().equals(""String_Node_Str"")) {
        style=((TextEffigy)effigy).getSyntaxStyle();
      }
      if (style != null && !style.trim().equals(""String_Node_Str"")) {
        try {
          Class editorClass=Class.forName(""String_Node_Str"");
          Constructor constructor=editorClass.getConstructor(new Class[]{String.class,Document.class});
          editor=(TextEditor)constructor.newInstance(new Object[]{""String_Node_Str"",((TextEffigy)effigy).getDocument()});
        }
 catch (        Throwable ex) {
          System.out.println(""String_Node_Str"" + ex.getMessage());
        }
      }
      tableau=(TextEditorTableau)_tableauConstructor.newInstance(new Object[]{effigy,""String_Node_Str"",editor});
    }
    URL url=effigy.uri.getURL();
    if (url != null) {
      effigy.identifier.setExpression(url.toExternalForm());
    }
    tableau.setEditable(effigy.isModifiable());
    return tableau;
  }
 else {
    Iterator effigies=effigy.entityList(TextEffigy.class).iterator();
    while (effigies.hasNext()) {
      TextEffigy textEffigy=(TextEffigy)effigies.next();
      if (textEffigy.getName().equals(""String_Node_Str"")) {
        return createTableau(textEffigy);
      }
    }
    URL url=effigy.uri.getURL();
    TextEffigy textEffigy;
    if (effigy instanceof PtolemyEffigy) {
      String moml=((PtolemyEffigy)effigy).getModel().exportMoML();
      textEffigy=(TextEffigy)_newTextEffigyText.invoke(null,new Object[]{effigy,moml,""String_Node_Str""});
      textEffigy.setModifiable(false);
      textEffigy.setName(""String_Node_Str"");
    }
 else {
      textEffigy=(TextEffigy)_newTextEffigyURL.invoke(null,new Object[]{effigy,url,url});
      textEffigy.setName(""String_Node_Str"");
    }
    TextEditorTableau textTableau=(TextEditorTableau)createTableau(textEffigy);
    if (url != null) {
      textEffigy.identifier.setExpression(url.toExternalForm());
    }
    return textTableau;
  }
}","/** 
 * If the specified effigy is a TextEffigy and it already contains a tableau named ""textTableau"", then return that tableau; otherwise, create a new instance of TextEditorTableau in the specified effigy, and name it ""textTableau"" and return that tableau. If the specified effigy is not an instance of TextEffigy, but contains an instance of TextEffigy, then open a tableau for that effigy.  If it is a PtolemyEffigy, then create a text effigy with the MoML representation of the model. Finally, if is not a TextEffigy or a PtolemyEffigy, and it does not contain a TextEffigy, then attempt to open its URL and display its date by creating a text effigy, which will then be contained by the specified effigy. If all of this fails, then do not create a tableau and return null. It is the responsibility of callers of this method to check the return value and call show().
 * @param effigy The effigy.
 * @return A text editor tableau, or null if one cannot befound or created.
 * @exception Exception If the factory should be able to create atableau for the effigy, but something goes wrong.
 */
@Override public Tableau createTableau(Effigy effigy) throws Exception {
  if (effigy instanceof TextEffigy) {
    TextEditorTableau tableau=(TextEditorTableau)effigy.getEntity(""String_Node_Str"");
    if (tableau == null) {
      TextEditor editor=null;
      String style=syntaxStyle.getExpression();
      if (style == null || style.trim().equals(""String_Node_Str"")) {
        style=((TextEffigy)effigy).getSyntaxStyle();
      }
      if (style != null && !style.trim().equals(""String_Node_Str"")) {
        try {
          Class editorClass=Class.forName(""String_Node_Str"");
          Constructor constructor=editorClass.getConstructor(new Class[]{String.class,Document.class});
          editor=(TextEditor)constructor.newInstance(new Object[]{""String_Node_Str"",((TextEffigy)effigy).getDocument()});
        }
 catch (        Throwable ex) {
          System.out.println(""String_Node_Str"" + ex.getMessage());
        }
      }
      tableau=(TextEditorTableau)_tableauConstructor.newInstance(new Object[]{effigy,""String_Node_Str"",editor});
    }
    URL url=effigy.uri.getURL();
    if (url != null) {
      effigy.identifier.setExpression(url.toExternalForm());
    }
    tableau.setEditable(effigy.isModifiable());
    return tableau;
  }
 else {
    Iterator effigies=effigy.entityList(TextEffigy.class).iterator();
    while (effigies.hasNext()) {
      TextEffigy textEffigy=(TextEffigy)effigies.next();
      if (textEffigy.getName().equals(""String_Node_Str"")) {
        return createTableau(textEffigy);
      }
    }
    URL url=effigy.uri.getURL();
    TextEffigy textEffigy;
    if (effigy instanceof PtolemyEffigy) {
      String moml=((PtolemyEffigy)effigy).getModel().exportMoML();
      textEffigy=(TextEffigy)_newTextEffigyText.invoke(null,new Object[]{effigy,moml,""String_Node_Str""});
      textEffigy.setName(""String_Node_Str"");
    }
 else {
      textEffigy=(TextEffigy)_newTextEffigyURL.invoke(null,new Object[]{effigy,url,url});
      textEffigy.setName(""String_Node_Str"");
    }
    TextEditorTableau textTableau=(TextEditorTableau)createTableau(textEffigy);
    if (url != null) {
      textEffigy.identifier.setExpression(url.toExternalForm());
    }
    return textTableau;
  }
}"
72468,"/** 
 * If the argument is any parameter other than <i>stateVariableNames</i> <i>t</i>, or any parameter matching an input port, then request reinitialization.
 * @param attribute The attribute that changed.
 * @exception IllegalActionException If the numerator and thedenominator matrix is not a row vector.
 */
@Override public void attributeChanged(Attribute attribute) throws IllegalActionException {
  _upToDate=false;
  if (attribute instanceof Parameter && attribute != t) {
    TypedIOPort port=(TypedIOPort)getPort(attribute.getName());
    if (port == null || !port.isInput()) {
      _requestInitialization();
    }
  }
}","/** 
 * If the argument is any parameter other than <i>stateVariableNames</i> <i>t</i>, or any parameter matching an input port, then request reinitialization.
 * @param attribute The attribute that changed.
 * @exception IllegalActionException If the numerator and thedenominator matrix is not a row vector.
 */
@Override public void attributeChanged(Attribute attribute) throws IllegalActionException {
  super.attributeChanged(attribute);
  _upToDate=false;
  if (attribute instanceof Parameter && attribute != t) {
    TypedIOPort port=(TypedIOPort)getPort(attribute.getName());
    if (port == null || !port.isInput()) {
      _requestInitialization();
    }
  }
}"
72469,"private void _setSigmaPoints(SigmaPoint[] points,double[] mean_state,double[][] covariance_matrix) throws IllegalActionException {
  double[][] sqrt_covariance_matrix=new double[covariance_matrix.length][covariance_matrix[0].length];
  choleskyDecomposition(covariance_matrix,sqrt_covariance_matrix);
  points[0].setValue(mean_state);
  double weight=Math.sqrt(_kai + _stateSpaceSize);
  for (int i=1; i < points.length; i++) {
    int col_id=(i - 1) / 2;
    double weight_sign=weight;
    if ((i - 1) % 2 == 1)     weight_sign=-weight;
    for (int p_it=0; p_it < _stateSpaceSize; p_it++) {
      points[i]._x_hat[p_it]=points[0]._x_hat[p_it] + weight_sign * sqrt_covariance_matrix[p_it][col_id];
    }
  }
}","private void _setSigmaPoints(SigmaPoint[] points,double[] mean_state,double[][] covariance_matrix) throws IllegalActionException {
  double[][] sqrt_covariance_matrix=new double[covariance_matrix.length][covariance_matrix[0].length];
  choleskyDecomposition(covariance_matrix,sqrt_covariance_matrix);
  points[0].setValue(mean_state);
  double weight=Math.sqrt(_kai + _stateSpaceSize);
  for (int i=1; i < points.length; i+=2) {
    int col_id=(i - 1) / 2;
    for (int p_it=0; p_it < _stateSpaceSize; p_it++) {
      points[i]._x_hat[p_it]=points[0]._x_hat[p_it] + weight * sqrt_covariance_matrix[p_it][col_id];
      points[i + 1]._x_hat[p_it]=points[0]._x_hat[p_it] - weight * sqrt_covariance_matrix[p_it][col_id];
    }
  }
}"
72470,"/** 
 * Return the origin of the figure in the enclosing transform context.  This overrides the base class to return the center of the shape, if the figure is centered, or the origin of the shape if the figure is not centered.
 * @return The origin of the figure.
 */
@Override public Point2D getOrigin(){
  if (_centered) {
    return super.getOrigin();
  }
 else {
    Point2D point=new Point2D.Double(0,0);
    _transform.transform(point,point);
    return point;
  }
}","/** 
 * Return the origin of the figure in the enclosing transform context.  This overrides the base class to return the center of the shape, if the figure is centered, or the origin of the shape if the figure is not centered.
 * @return The origin of the figure.
 */
@Override public Point2D getOrigin(){
  if (_centered) {
    Point2D point=super.getOrigin();
    _transform.transform(point,point);
    return point;
  }
 else {
    Point2D point=new Point2D.Double(0,0);
    _transform.transform(point,point);
    return point;
  }
}"
72471,"/** 
 * Specify whether the figure should be centered on its origin. By default, it is.
 * @param centered False to make the origin of the figure, asreturned by getOrigin(), be the upper left corner.
 * @see #getOrigin()
 */
public void setCentered(boolean centered){
  if (_centered=centered) {
    return;
  }
  repaint();
  Point2D point=getOrigin();
  _centered=centered;
  CanvasUtilities.translateTo(this,point.getX(),point.getY());
}","/** 
 * Specify whether the figure should be centered on its origin. By default, it is.
 * @param centered False to make the origin of the figure, asreturned by getOrigin(), be the upper left corner.
 * @see #getOrigin()
 */
public void setCentered(boolean centered){
  if (_centered == centered) {
    return;
  }
  repaint();
  Point2D point=getOrigin();
  _centered=centered;
  CanvasUtilities.translateTo(this,point.getX(),point.getY());
  repaint();
}"
72472,"/** 
 * Read a Configuration from the URL given by the specified string. The URL may absolute, or relative to the Ptolemy II tree root, or in the classpath.  To convert a String to a URL suitable for use by this method, call specToURL(String). <p>If there is an _applicationInitializer parameter, then instantiate the class named by that parameter.  The _applicationInitializer parameter contains a string that names a class to be initialized. <p>If the configuration has already been read in, then the old configuration will be deleted.  Note that this may exit the application.
 * @param specificationURL A string describing a URL.
 * @return A configuration.
 * @exception Exception If the configuration cannot be opened, orif the contents of the URL is not a configuration.
 */
public static Configuration readConfiguration(URL specificationURL) throws Exception {
  if (_initialSpecificationURI == null) {
    _initialSpecificationURI=specificationURL.toURI();
  }
  MoMLParser parser=new MoMLParser();
  parser.reset();
  Configuration configuration=null;
  Exception cause=null;
  try {
    configuration=(Configuration)parser.parse(specificationURL,specificationURL);
  }
 catch (  Exception ex) {
    cause=ex;
    ex.printStackTrace();
  }
  if (configuration == null) {
    NullPointerException exception=new NullPointerException(""String_Node_Str"" + specificationURL);
    if (cause != null) {
      exception.initCause(cause);
    }
    throw exception;
  }
  ComponentEntity directory=configuration.getDirectory();
  if (directory != null) {
    PtolemyEffigy effigy=null;
    try {
      effigy=new PtolemyEffigy((ModelDirectory)directory,configuration.getName());
    }
 catch (    NameDuplicationException ex) {
      PtolemyEffigy oldEffigy=(PtolemyEffigy)((ModelDirectory)directory).getEntity(configuration.getName());
      oldEffigy.setContainer(null);
      effigy=new PtolemyEffigy((ModelDirectory)directory,configuration.getName());
    }
    effigy.setModel(configuration);
    effigy.identifier.setExpression(specificationURL.toExternalForm());
  }
  StringParameter applicationInitializerParameter=(StringParameter)configuration.getAttribute(""String_Node_Str"",Parameter.class);
  if (applicationInitializerParameter != null) {
    String applicationInitializerClassName=applicationInitializerParameter.stringValue();
    try {
      Class applicationInitializer=Class.forName(applicationInitializerClassName);
      applicationInitializer.newInstance();
    }
 catch (    Throwable throwable) {
      throw new Exception(""String_Node_Str"" + ""String_Node_Str"" + applicationInitializerClassName + ""String_Node_Str""+ specificationURL+ ""String_Node_Str"",throwable);
    }
  }
  return configuration;
}","/** 
 * Read a Configuration from the URL given by the specified string. The URL may absolute, or relative to the Ptolemy II tree root, or in the classpath.  To convert a String to a URL suitable for use by this method, call specToURL(String). <p>If there is an _applicationInitializer parameter, then instantiate the class named by that parameter.  The _applicationInitializer parameter contains a string that names a class to be initialized. <p>If the configuration has already been read in, then the old configuration will be deleted.  Note that this may exit the application.
 * @param specificationURL A string describing a URL.
 * @return A configuration.
 * @exception Exception If the configuration cannot be opened, orif the contents of the URL is not a configuration.
 */
public static Configuration readConfiguration(URL specificationURL) throws Exception {
  if (_initialSpecificationURI == null) {
    _initialSpecificationURI=specificationURL.toURI();
  }
  MoMLParser parser=new MoMLParser();
  parser.reset();
  Configuration configuration=null;
  Exception cause=null;
  try {
    configuration=(Configuration)parser.parse(specificationURL,specificationURL);
  }
 catch (  Exception ex) {
    cause=ex;
    ex.printStackTrace();
  }
  if (configuration == null) {
    NullPointerException exception=new NullPointerException(""String_Node_Str"" + specificationURL);
    if (cause != null) {
      exception.initCause(cause);
    }
    throw exception;
  }
  ComponentEntity directory=configuration.getDirectory();
  if (directory != null) {
    PtolemyEffigy effigy=null;
    try {
      effigy=new PtolemyEffigy((ModelDirectory)directory,configuration.getName());
      effigy.setSystemEffigy(true);
    }
 catch (    NameDuplicationException ex) {
      PtolemyEffigy oldEffigy=(PtolemyEffigy)((ModelDirectory)directory).getEntity(configuration.getName());
      oldEffigy.setContainer(null);
      effigy=new PtolemyEffigy((ModelDirectory)directory,configuration.getName());
    }
    effigy.setModel(configuration);
    effigy.identifier.setExpression(specificationURL.toExternalForm());
  }
  StringParameter applicationInitializerParameter=(StringParameter)configuration.getAttribute(""String_Node_Str"",Parameter.class);
  if (applicationInitializerParameter != null) {
    String applicationInitializerClassName=applicationInitializerParameter.stringValue();
    try {
      Class applicationInitializer=Class.forName(applicationInitializerClassName);
      applicationInitializer.newInstance();
    }
 catch (    Throwable throwable) {
      throw new Exception(""String_Node_Str"" + ""String_Node_Str"" + applicationInitializerClassName + ""String_Node_Str""+ specificationURL+ ""String_Node_Str"",throwable);
    }
  }
  return configuration;
}"
72473,"/** 
 * Create a new parameter if it does not already exist. The options argument can specify a ""type"", a ""description"", and/or a ""value"". If a type is given, set the type as specified. Otherwise, leave the type unspecified so that it will be inferred from the value. If a description is given, then create, append to, or modify the DocAttribute named ""documentation"" contained by this actor to include documentation of this output. If a value is given, then set the default value of the parameter if it does not already have a value.
 * @param name The name of the parameter.
 * @param options The options, or null to accept the defaults.
 * @exception IllegalActionException If no name is given.
 * @exception NameDuplicationException If the name is a reserved word, or if an attributealready exists with the name and is not a parameter.
 */
public void parameter(String name,Map options) throws IllegalActionException, NameDuplicationException {
  if (name == null) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  Attribute parameter=getAttribute(name);
  if (parameter == null) {
    parameter=new Parameter(this,name);
  }
 else {
    if (parameter == script) {
      throw new NameDuplicationException(this,""String_Node_Str"" + name);
    }
 else     if (!(parameter instanceof Parameter)) {
      throw new NameDuplicationException(this,""String_Node_Str"" + name);
    }
  }
  if (options != null) {
    Type ptType=null;
    Object type=options.get(""String_Node_Str"");
    if (type instanceof String) {
      ptType=_typeAccessorToPtolemy((String)type,parameter);
    }
 else     if (type != null) {
      throw new IllegalActionException(this,""String_Node_Str"" + type);
    }
    if (ptType != null) {
      ((Parameter)parameter).setTypeEquals(ptType);
      _setOptionsForSelect(parameter,options);
    }
    if (((Parameter)parameter).getToken() == null || ((ptType == BaseType.STRING) && parameter instanceof StringParameter && (((StringParameter)parameter).stringValue().equals(""String_Node_Str"")))) {
      Object value=options.get(""String_Node_Str"");
      if (value != null) {
        Object token;
        try {
          token=((Invocable)_engine).invokeFunction(""String_Node_Str"",value);
        }
 catch (        Exception e) {
          throw new IllegalActionException(this,e,""String_Node_Str"" + value);
        }
        if (token instanceof Token) {
          ((Parameter)parameter).setToken((Token)token);
        }
 else {
          throw new IllegalActionException(this,""String_Node_Str"" + value);
        }
      }
    }
    Object description=options.get(""String_Node_Str"");
    if (description != null) {
      _setPortDescription(parameter,description.toString());
    }
  }
  if (_proxies.get(parameter) == null) {
    PortOrParameterProxy proxy=new PortOrParameterProxy(parameter);
    _proxies.put(parameter,proxy);
    _proxiesByName.put(parameter.getName(),proxy);
  }
}","/** 
 * Create a new parameter if it does not already exist. The options argument can specify a ""type"", a ""description"", and/or a ""value"". If a type is given, set the type as specified. Otherwise, leave the type unspecified so that it will be inferred from the value. If a description is given, then create, append to, or modify the DocAttribute named ""documentation"" contained by this actor to include documentation of this output. If a value is given, then set the default value of the parameter if it does not already have a value.
 * @param name The name of the parameter.
 * @param options The options, or null to accept the defaults.
 * @exception IllegalActionException If no name is given.
 * @exception NameDuplicationException If the name is a reserved word, or if an attributealready exists with the name and is not a parameter.
 */
public void parameter(String name,Map options) throws IllegalActionException, NameDuplicationException {
  if (name == null) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  Attribute parameter=getAttribute(name);
  if (parameter == null) {
    parameter=new Parameter(this,name);
  }
 else {
    if (parameter == script) {
      throw new NameDuplicationException(this,""String_Node_Str"" + name);
    }
 else     if (!(parameter instanceof Parameter)) {
      throw new NameDuplicationException(this,""String_Node_Str"" + name);
    }
  }
  if (options != null) {
    Type ptType=null;
    Object type=options.get(""String_Node_Str"");
    if (type instanceof String) {
      ptType=_typeAccessorToPtolemy((String)type,parameter);
    }
 else     if (type != null) {
      throw new IllegalActionException(this,""String_Node_Str"" + type);
    }
    if (ptType != null) {
      ((Parameter)parameter).setTypeEquals(ptType);
      _setOptionsForSelect(parameter,options);
    }
    Token previousValue=((Parameter)parameter).getToken();
    if (previousValue == null || ((ptType == BaseType.STRING) && ((Parameter)parameter).isStringMode() && (((StringToken)previousValue).stringValue().equals(""String_Node_Str"")))) {
      Object value=options.get(""String_Node_Str"");
      if (value != null) {
        Object token;
        try {
          token=((Invocable)_engine).invokeFunction(""String_Node_Str"",value);
        }
 catch (        Exception e) {
          throw new IllegalActionException(this,e,""String_Node_Str"" + value);
        }
        if (token instanceof Token) {
          ((Parameter)parameter).setToken((Token)token);
        }
 else {
          throw new IllegalActionException(this,""String_Node_Str"" + value);
        }
      }
    }
    Object description=options.get(""String_Node_Str"");
    if (description != null) {
      _setPortDescription(parameter,description.toString());
    }
  }
  if (_proxies.get(parameter) == null) {
    PortOrParameterProxy proxy=new PortOrParameterProxy(parameter);
    _proxies.put(parameter,proxy);
    _proxiesByName.put(parameter.getName(),proxy);
  }
}"
72474,"/** 
 * Create an edit menu.
 */
protected void _addMenus(){
  _editMenu=new JMenu(""String_Node_Str"");
  _editMenu.setMnemonic(KeyEvent.VK_E);
  _menubar.add(_editMenu);
  GUIUtilities.addMenuItem(_editMenu,new UndoAction());
  GUIUtilities.addMenuItem(_editMenu,new RedoAction());
  _editMenu.addSeparator();
  GUIUtilities.addMenuItem(_editMenu,new CutAction());
  GUIUtilities.addMenuItem(_editMenu,new CopyAction());
  GUIUtilities.addMenuItem(_editMenu,new PasteAction());
  _editMenu.addSeparator();
  GUIUtilities.addMenuItem(_editMenu,_findAction);
}","/** 
 * Create an edit menu.
 */
protected void _addMenus(){
  super._addMenus();
  _editMenu=new JMenu(""String_Node_Str"");
  _editMenu.setMnemonic(KeyEvent.VK_E);
  _menubar.add(_editMenu);
  GUIUtilities.addMenuItem(_editMenu,new UndoAction());
  GUIUtilities.addMenuItem(_editMenu,new RedoAction());
  _editMenu.addSeparator();
  GUIUtilities.addMenuItem(_editMenu,new CutAction());
  GUIUtilities.addMenuItem(_editMenu,new CopyAction());
  GUIUtilities.addMenuItem(_editMenu,new PasteAction());
  _editMenu.addSeparator();
  GUIUtilities.addMenuItem(_editMenu,_findAction);
}"
72475,"/** 
 * Create a simple one-line text display, a non-editable value that is set externally using the setDisplay() method.
 * @param name The name used to identify the entry (when calling get).
 * @param label The label to attach to the entry.
 * @param theValue Default string to display.
 * @param background The background color, or null to use defaults.
 * @param foreground The foreground color, or null to use defaults.
 * @return The text area that displays the value.
 */
public JTextArea addDisplay(String name,String label,String theValue,Color background,Color foreground){
  JLabel lbl=_constructLabel(label);
  lbl.setBackground(_background);
  JTextArea displayField=new JTextArea(theValue,1,10);
  displayField.setEditable(false);
  if (background == null) {
    background=_background;
  }
  if (foreground == null) {
    foreground=Color.BLACK;
  }
  displayField.setBackground(background);
  _addPair(name,lbl,displayField,displayField);
  return displayField;
}","/** 
 * Create a simple one-line text display, a non-editable value that is set externally using the setDisplay() method.
 * @param name The name used to identify the entry (when calling get).
 * @param label The label to attach to the entry.
 * @param theValue Default string to display.
 * @param background The background color, or null to use defaults.
 * @param foreground The foreground color, or null to use defaults.
 * @return The text area that displays the value.
 */
public JTextArea addDisplay(String name,String label,String theValue,Color background,Color foreground){
  JLabel lbl=_constructLabel(label);
  lbl.setBackground(_background);
  JTextArea displayField=new JTextArea(theValue,1,10);
  displayField.setEditable(false);
  if (background == null) {
    background=_background;
  }
  displayField.setBackground(background);
  _addPair(name,lbl,displayField,displayField);
  return displayField;
}"
72476,"/** 
 * Remember the edit and update the action state.
 * @param event The event that occurred.
 */
@Override public void undoableEditHappened(UndoableEditEvent event){
  if (_compoundEdit == null) {
    _undo.addEdit(event.getEdit());
    _undoAction._updateUndoState();
    _redoAction._updateRedoState();
  }
 else {
    _compoundEdit.addEdit(event.getEdit());
  }
}","/** 
 * Remember the edit and update the action state.
 * @param event The event that occurred.
 */
@Override public synchronized void undoableEditHappened(UndoableEditEvent event){
  if (_compoundEdit == null) {
    _undo.addEdit(event.getEdit());
    _undoAction._updateUndoState();
    _redoAction._updateRedoState();
  }
 else {
    _compoundEdit.addEdit(event.getEdit());
  }
}"
72477,"/** 
 * Invoke the specified function, then schedule another call to this same method after the specified number of milliseconds, using the specified id for the timeout function.
 * @param function The function to repeatedly invoke.
 * @param milliseconds The number of milliseconds in a period.
 * @param id The id to use for the timeout function.
 */
private void _runThenReschedule(final Runnable function,final int milliseconds,final Integer id){
  function.run();
  if (_pendingTimeoutFunctions.get(id) == null) {
    return;
  }
  final Runnable reschedulingFunction=new Runnable(){
    @Override public void run(){
      _runThenReschedule(function,milliseconds,id);
    }
  }
;
  try {
    _setTimeout(reschedulingFunction,milliseconds,id);
  }
 catch (  IllegalActionException e) {
    throw new InternalErrorException(this,e,""String_Node_Str"");
  }
}","/** 
 * Invoke the specified function, then schedule another call to this same method after the specified number of milliseconds, using the specified id for the timeout function.
 * @param function The function to repeatedly invoke.
 * @param milliseconds The number of milliseconds in a period.
 * @param id The id to use for the timeout function.
 */
private synchronized void _runThenReschedule(final Runnable function,final int milliseconds,final Integer id){
  function.run();
  if (_pendingTimeoutFunctions.get(id) == null) {
    return;
  }
  final Runnable reschedulingFunction=new Runnable(){
    @Override public void run(){
      _runThenReschedule(function,milliseconds,id);
    }
  }
;
  try {
    _setTimeout(reschedulingFunction,milliseconds,id);
  }
 catch (  IllegalActionException e) {
    throw new InternalErrorException(this,e,""String_Node_Str"");
  }
}"
72478,"/** 
 * Invoke any input handlers that have been added if there are new inputs.
 * @see #addInputHandler(Runnable)
 */
public void invokeHandlers(){
  if (_inputHandlers != null && _hasNewInput) {
    for (    Runnable function : _inputHandlers) {
      if (function != null) {
        function.run();
        if (_debugging) {
          _debug(""String_Node_Str"" + _port.getName());
        }
      }
    }
  }
}","/** 
 * Invoke any input handlers that have been added if there are new inputs.
 * @see #addInputHandler(Runnable)
 */
public void invokeHandlers(){
synchronized (JavaScript.this) {
    if (_inputHandlers != null && _hasNewInput) {
      for (      Runnable function : _inputHandlers) {
        if (function != null) {
          function.run();
          if (_debugging) {
            _debug(""String_Node_Str"" + _port.getName());
          }
        }
      }
    }
  }
}"
72479,"/** 
 * Produce any pending outputs specified by send() since the last firing, invoke any timer tasks that match the current time, and invoke the fire function. Specifically: <ol> <li> First, if there is a new token on the script input port, then evaluate the script specified on that port. Any previously defined methods such as fire() will be replaced if the new script has a replacement, and preserved otherwise.  If the new script has an initialize() method, that method will not be invoked until the next time this actor is initialized.</li> <li> Next, send any outputs that have been queued to be sent by calling send() from outside any firing of this JavaScript actor.</li> <li> Next, read all available inputs, recording their values for subsequent calls to get().</li> <li> Next, invoke any pending timer tasks whose timing matches the current time.</li> <li> After updating all the inputs, for each input port that had a new token on any channel and for which there is a handler function bound to that port via the addInputHandler() method, invoke that function.  Such a function will be invoked in the following order: First, invoke the functions for each PortParameter, in the order in which the PortParameters were created.  Then invoke the functions for the ordinary input ports.</li> <li> Next, if the current script has a fire() function, then invoke it.</li> </ol>
 * @exception IllegalActionException If calling send() or super.fire()throws it.
 */
@Override public void fire() throws IllegalActionException {
  super.fire();
  if (_debugging) {
    _engine.put(""String_Node_Str"",true);
  }
 else {
    _engine.put(""String_Node_Str"",false);
  }
  ParameterPort scriptPort=script.getPort();
  if (scriptPort.getWidth() > 0 && scriptPort.hasToken(0)) {
    script.update();
    String scriptValue=((StringToken)script.getToken()).stringValue();
    try {
      _engine.eval(scriptValue);
      _exports=_engine.eval(""String_Node_Str"");
    }
 catch (    ScriptException ex) {
      if (error.getWidth() > 0) {
        error.send(0,new StringToken(ex.getMessage()));
      }
 else {
        throw new IllegalActionException(this,ex,""String_Node_Str"");
      }
    }
    if (_debugging) {
      _debug(""String_Node_Str"" + scriptValue);
    }
  }
synchronized (this) {
    if (_outputTokens != null) {
      for (      IOPort port : _outputTokens.keySet()) {
        HashMap<Integer,List<Token>> tokens=_outputTokens.get(port);
        for (        Map.Entry<Integer,List<Token>> entry : tokens.entrySet()) {
          List<Token> queue=entry.getValue();
          if (queue != null) {
            for (            Token token : queue) {
              port.send(entry.getKey(),token);
              if (_debugging) {
                _debug(""String_Node_Str"" + port.getName() + ""String_Node_Str""+ token);
              }
            }
          }
        }
      }
      _outputTokens.clear();
    }
  }
  boolean foundNewInput=false;
  for (  PortParameter portParameter : attributeList(PortParameter.class)) {
    if (portParameter == script) {
      continue;
    }
    PortOrParameterProxy proxy=_proxies.get(portParameter.getPort());
    if (portParameter.update()) {
      proxy._hasNewInput(true);
      foundNewInput=true;
      if (_debugging) {
        _debug(""String_Node_Str"" + portParameter.getName() + ""String_Node_Str""+ portParameter.getToken());
      }
    }
 else     if (proxy._localInputTokens != null && proxy._localInputTokens.size() > 0) {
      portParameter.setCurrentValue(proxy._localInputTokens.remove(0));
      proxy._hasNewInput(true);
      foundNewInput=true;
    }
 else {
      proxy._hasNewInput(false);
    }
  }
  _inputTokens.clear();
  for (  IOPort input : inputPortList()) {
    if (input == script.getPort()) {
      continue;
    }
    if (input instanceof ParameterPort) {
      continue;
    }
    HashMap<Integer,Token> tokens=new HashMap<Integer,Token>();
    boolean hasInput=false;
    PortOrParameterProxy proxy=_proxies.get(input);
    for (int i=0; i < input.getWidth(); i++) {
      if (input.hasToken(i)) {
        hasInput=true;
        tokens.put(i,input.get(i));
        if (_debugging) {
          _debug(""String_Node_Str"" + input.getName() + ""String_Node_Str""+ tokens.get(i));
        }
      }
 else {
        if (proxy._localInputTokens != null && proxy._localInputTokens.size() > 0) {
          tokens.put(i,proxy._localInputTokens.remove(0));
          hasInput=true;
        }
      }
    }
    if (input.getWidth() == 0 && proxy._localInputTokens != null && proxy._localInputTokens.size() > 0) {
      tokens.put(0,proxy._localInputTokens.remove(0));
      hasInput=true;
    }
    _inputTokens.put(input,tokens);
    if (hasInput) {
      proxy._hasNewInput(true);
      foundNewInput=true;
    }
 else {
      proxy._hasNewInput(false);
    }
  }
synchronized (this) {
    _inFire=true;
    try {
      if (_pendingTimeoutIDs != null) {
        Time currentTime=getDirector().getModelTime();
        List<Integer> ids=_pendingTimeoutIDs.get(currentTime);
        if (ids != null) {
          List<Integer> copy=new LinkedList<Integer>(ids);
          if (ids != null) {
            for (            Integer id : copy) {
              Runnable function=_pendingTimeoutFunctions.get(id);
              if (function != null) {
                _pendingTimeoutFunctions.remove(id);
                function.run();
                if (_debugging) {
                  _debug(""String_Node_Str"");
                }
              }
            }
            _pendingTimeoutIDs.remove(currentTime);
          }
        }
      }
      for (      IOPort input : inputPortList()) {
        if (input == script.getPort()) {
          continue;
        }
        _proxies.get(input).invokeHandlers();
      }
      if (foundNewInput && _genericInputHandlers != null && _genericInputHandlers.size() > 0) {
        for (        Runnable function : _genericInputHandlers) {
          if (function != null) {
            function.run();
            if (_debugging) {
              _debug(""String_Node_Str"");
            }
          }
        }
      }
      _invokeMethodInContext(""String_Node_Str"");
      if (_debugging) {
        _debug(""String_Node_Str"");
      }
    }
  finally {
      _inFire=false;
    }
  }
}","/** 
 * Produce any pending outputs specified by send() since the last firing, invoke any timer tasks that match the current time, and invoke the fire function. Specifically: <ol> <li> First, if there is a new token on the script input port, then evaluate the script specified on that port. Any previously defined methods such as fire() will be replaced if the new script has a replacement, and preserved otherwise.  If the new script has an initialize() method, that method will not be invoked until the next time this actor is initialized.</li> <li> Next, send any outputs that have been queued to be sent by calling send() from outside any firing of this JavaScript actor.</li> <li> Next, read all available inputs, recording their values for subsequent calls to get().</li> <li> Next, invoke any pending timer tasks whose timing matches the current time.</li> <li> After updating all the inputs, for each input port that had a new token on any channel and for which there is a handler function bound to that port via the addInputHandler() method, invoke that function.  Such a function will be invoked in the following order: First, invoke the functions for each PortParameter, in the order in which the PortParameters were created.  Then invoke the functions for the ordinary input ports.</li> <li> Next, if the current script has a fire() function, then invoke it.</li> </ol>
 * @exception IllegalActionException If calling send() or super.fire()throws it.
 */
@Override public void fire() throws IllegalActionException {
  super.fire();
  if (_debugging) {
    _engine.put(""String_Node_Str"",true);
  }
 else {
    _engine.put(""String_Node_Str"",false);
  }
  ParameterPort scriptPort=script.getPort();
  if (scriptPort.getWidth() > 0 && scriptPort.hasToken(0)) {
    script.update();
    String scriptValue=((StringToken)script.getToken()).stringValue();
    try {
      _engine.eval(scriptValue);
      _exports=_engine.eval(""String_Node_Str"");
    }
 catch (    ScriptException ex) {
      if (error.getWidth() > 0) {
        error.send(0,new StringToken(ex.getMessage()));
      }
 else {
        throw new IllegalActionException(this,ex,""String_Node_Str"");
      }
    }
    if (_debugging) {
      _debug(""String_Node_Str"" + scriptValue);
    }
  }
synchronized (this) {
    if (_outputTokens != null) {
      for (      IOPort port : _outputTokens.keySet()) {
        HashMap<Integer,List<Token>> tokens=_outputTokens.get(port);
        for (        Map.Entry<Integer,List<Token>> entry : tokens.entrySet()) {
          List<Token> queue=entry.getValue();
          if (queue != null) {
            for (            Token token : queue) {
              port.send(entry.getKey(),token);
              if (_debugging) {
                _debug(""String_Node_Str"" + port.getName() + ""String_Node_Str""+ token);
              }
            }
          }
        }
      }
      _outputTokens.clear();
    }
  }
  boolean foundNewInput=false;
  for (  PortParameter portParameter : attributeList(PortParameter.class)) {
    if (portParameter == script) {
      continue;
    }
    PortOrParameterProxy proxy=_proxies.get(portParameter.getPort());
    if (portParameter.update()) {
      proxy._hasNewInput(true);
      foundNewInput=true;
      if (_debugging) {
        _debug(""String_Node_Str"" + portParameter.getName() + ""String_Node_Str""+ portParameter.getToken());
      }
    }
 else     if (proxy._localInputTokens != null && proxy._localInputTokens.size() > 0) {
      portParameter.setCurrentValue(proxy._localInputTokens.remove(0));
      proxy._hasNewInput(true);
      foundNewInput=true;
    }
 else {
      proxy._hasNewInput(false);
    }
  }
  _inputTokens.clear();
  for (  IOPort input : inputPortList()) {
    if (input == script.getPort()) {
      continue;
    }
    if (input instanceof ParameterPort) {
      continue;
    }
    HashMap<Integer,Token> tokens=new HashMap<Integer,Token>();
    boolean hasInput=false;
    PortOrParameterProxy proxy=_proxies.get(input);
    for (int i=0; i < input.getWidth(); i++) {
      if (input.hasToken(i)) {
        hasInput=true;
        tokens.put(i,input.get(i));
        if (_debugging) {
          _debug(""String_Node_Str"" + input.getName() + ""String_Node_Str""+ tokens.get(i));
        }
      }
 else {
        if (proxy._localInputTokens != null && proxy._localInputTokens.size() > 0) {
          tokens.put(i,proxy._localInputTokens.remove(0));
          hasInput=true;
        }
      }
    }
    if (input.getWidth() == 0 && proxy._localInputTokens != null && proxy._localInputTokens.size() > 0) {
      tokens.put(0,proxy._localInputTokens.remove(0));
      hasInput=true;
    }
    _inputTokens.put(input,tokens);
    if (hasInput) {
      proxy._hasNewInput(true);
      foundNewInput=true;
    }
 else {
      proxy._hasNewInput(false);
    }
  }
synchronized (this) {
    _inFire=true;
    try {
      if (_pendingTimeoutIDs != null) {
        Time currentTime=getDirector().getModelTime();
        List<Integer> ids=_pendingTimeoutIDs.get(currentTime);
        if (ids != null) {
          List<Integer> copy=new LinkedList<Integer>(ids);
          if (ids != null) {
            for (            Integer id : copy) {
              Runnable function=_pendingTimeoutFunctions.get(id);
              if (function != null) {
                function.run();
                if (_debugging) {
                  _debug(""String_Node_Str"");
                }
              }
            }
            _pendingTimeoutIDs.remove(currentTime);
          }
        }
      }
      for (      IOPort input : inputPortList()) {
        if (input == script.getPort()) {
          continue;
        }
        _proxies.get(input).invokeHandlers();
      }
      if (foundNewInput && _genericInputHandlers != null && _genericInputHandlers.size() > 0) {
        for (        Runnable function : _genericInputHandlers) {
          if (function != null) {
            function.run();
            if (_debugging) {
              _debug(""String_Node_Str"");
            }
          }
        }
      }
      _invokeMethodInContext(""String_Node_Str"");
      if (_debugging) {
        _debug(""String_Node_Str"");
      }
    }
  finally {
      _inFire=false;
    }
  }
}"
72480,"/** 
 * Invoke the specified function, then schedule another call to this same method after the specified number of milliseconds, using the specified id for the timeout function.
 * @param function The function to repeatedly invoke.
 * @param milliseconds The number of milliseconds in a period.
 * @param id The id to use for the timeout function.
 */
private void _runThenReschedule(final Runnable function,final int milliseconds,final Integer id){
  function.run();
  final Runnable reschedulingFunction=new Runnable(){
    @Override public void run(){
      _runThenReschedule(function,milliseconds,id);
    }
  }
;
  try {
    _setTimeout(reschedulingFunction,milliseconds,id);
  }
 catch (  IllegalActionException e) {
    throw new InternalErrorException(this,e,""String_Node_Str"");
  }
}","/** 
 * Invoke the specified function, then schedule another call to this same method after the specified number of milliseconds, using the specified id for the timeout function.
 * @param function The function to repeatedly invoke.
 * @param milliseconds The number of milliseconds in a period.
 * @param id The id to use for the timeout function.
 */
private void _runThenReschedule(final Runnable function,final int milliseconds,final Integer id){
  function.run();
  if (_pendingTimeoutFunctions.get(id) == null) {
    return;
  }
  final Runnable reschedulingFunction=new Runnable(){
    @Override public void run(){
      _runThenReschedule(function,milliseconds,id);
    }
  }
;
  try {
    _setTimeout(reschedulingFunction,milliseconds,id);
  }
 catch (  IllegalActionException e) {
    throw new InternalErrorException(this,e,""String_Node_Str"");
  }
}"
72481,"/** 
 * Instantiate the slave FMU component.
 * @exception IllegalActionException If it cannot be instantiated.
 */
@Override public void preinitialize() throws IllegalActionException {
  if (_fmiModelDescription == null) {
    throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
  }
  super.preinitialize();
  if (_debugging) {
    _debugToStdOut(""String_Node_Str"");
  }
  _numberOfSteps=0;
  _numberOfStateEvents=0;
  _numberOfStepEvents=0;
  _numberOfTimeEvents=0;
  _useQSS=false;
  Director director=getDirector();
  if ((director instanceof QSSDirector)) {
    _useQSS=true;
    _outputQuantum=((QSSDirector)getDirector()).getRelativeQuantum();
    if (_outputQuantum == 0.0) {
      throw new IllegalActionException(this,""String_Node_Str"");
    }
  }
  if (_useRawJNI()) {
    String buildLibrary=""String_Node_Str"";
    String installLibrary=""String_Node_Str"";
    try {
      if (_debugging) {
        _debugToStdOut(""String_Node_Str"" + buildLibrary);
      }
      UtilityFunctions.loadLibrary(buildLibrary);
    }
 catch (    Throwable buildThrowable) {
      try {
        if (_debugging) {
          _debugToStdOut(""String_Node_Str"" + buildLibrary + ""String_Node_Str""+ buildThrowable+ ""String_Node_Str""+ installLibrary);
        }
        UtilityFunctions.loadLibrary(installLibrary);
      }
 catch (      Throwable installThrowable) {
        throw new IllegalActionException(this,installThrowable,""String_Node_Str"" + installLibrary + ""String_Node_Str""+ buildLibrary+ ""String_Node_Str""+ buildThrowable);
      }
    }
  }
 else {
    try {
      _nativeLibrary=_fmiModelDescription.getNativeLibrary();
    }
 catch (    IOException e1) {
      throw new IllegalActionException(this,e1,""String_Node_Str"");
    }
    if (_nativeLibrary == null) {
      throw new IllegalActionException(this,""String_Node_Str"");
    }
    _checkFmiCommon();
  }
  try {
    if (_fmiModelDescription.modelExchange) {
      try {
        if (_fmiVersion < 2.0 || !_completedIntegratorStepNotNeeded()) {
          _fmiCompletedIntegratorStepFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        }
      }
 catch (      Throwable throwable) {
        throw new IllegalActionException(this,throwable,""String_Node_Str"" + _fmuFileName + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      }
      if (_fmiVersion < 2.0) {
        try {
          _fmiFreeModelInstanceFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        }
 catch (        UnsatisfiedLinkError ex) {
          throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
        }
      }
 else {
        try {
          _fmiFreeInstanceFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        }
 catch (        UnsatisfiedLinkError ex) {
          throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
        }
      }
      _fmiGetContinuousStatesFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      _fmiSetContinuousStates=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      _fmiGetDerivativesFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      try {
        _fmiGetEventIndicatorsFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
 catch (      UnsatisfiedLinkError ex) {
        _fmiGetEventIndicatorsFunction=null;
      }
      if (_fmiVersion < 1.5) {
        _fmiInitializeFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiInstantiateModelFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
 else       if (_fmiVersion >= 1.5 && _fmiVersion < 2.0) {
        throw new IllegalActionException(this,""String_Node_Str"" + _fmiVersion);
      }
 else {
        _fmiEnterContinuousTimeModeFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiEnterEventModeFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiEnterInitializationModeFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiExitInitializationModeFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiInstantiateFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiNewDiscreteStatesFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
      _fmiSetTimeFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      _fmiTerminateFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      if (_fmiVersion >= 2.0) {
        try {
          _fmiSetupExperimentFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        }
 catch (        UnsatisfiedLinkError ex) {
          throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
        }
      }
      if (_fmiModelDescription.providesDirectionalDerivative) {
        _fmiGetDirectionalDerivativeFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
      _checkFmiModelExchange();
    }
 else {
      try {
        _fmiDoStepFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
 catch (      Throwable throwable) {
        throw new IllegalActionException(this,throwable,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"" + modelExchange.getExpression() + ""String_Node_Str""+ _fmiModelDescription.modelExchange);
      }
      if (_fmiVersion < 2.0) {
        try {
          _fmiFreeSlaveInstanceFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        }
 catch (        UnsatisfiedLinkError ex) {
          throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
        }
      }
 else {
        _fmiEnterInitializationModeFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiExitInitializationModeFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        try {
          _fmiFreeInstanceFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        }
 catch (        UnsatisfiedLinkError ex) {
          throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
        }
      }
      if (_fmiVersion < 2.0) {
        _fmiInitializeSlaveFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiInstantiateSlaveFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        if (_fmiVersion >= 1.5) {
          _fmiInstantiateFunction=_fmiInstantiateSlaveFunction;
        }
      }
 else {
        _fmiInstantiateFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
      if (_fmiVersion < 2.0) {
        _fmiTerminateSlaveFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
 else {
        _fmiTerminateFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
      try {
        _fmiGetRealStatusFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
 catch (      UnsatisfiedLinkError ex) {
        _fmiGetRealStatusFunction=null;
      }
      if (_fmiModelDescription.canGetAndSetFMUstate) {
        _fmiFreeFMUstateFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiGetFMUstateFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiSetFMUstate=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
 else {
        _fmiFreeFMUstateFunction=null;
        _fmiGetFMUstateFunction=null;
        _fmiSetFMUstate=null;
      }
      if (_fmiVersion >= 2.0) {
        try {
          _fmiSetupExperimentFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        }
 catch (        UnsatisfiedLinkError ex) {
          throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
        }
      }
      if (_fmiModelDescription.providesDirectionalDerivative) {
        _fmiGetDirectionalDerivativeFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
      _checkFmiCoSimulation();
    }
  }
 catch (  IOException ex) {
    throw new IllegalActionException(this,ex,""String_Node_Str"");
  }
  String modelIdentifier=_fmiModelDescription.modelIdentifier;
  String mimeType=""String_Node_Str"";
  double timeout=1000;
  byte toBeVisible=0;
  int toBeVisibleFMI2=0;
  if (((BooleanToken)visible.getToken()).booleanValue()) {
    toBeVisible=1;
    toBeVisibleFMI2=1;
  }
  byte loggingOn=_debugging ? (byte)1 : (byte)0;
  int loggingOnFMI2=_debugging ? 1 : 0;
  byte interactive=0;
  if (!_useRawJNI()) {
    if (_fmiVersion < 1.5) {
      _callbacks=new FMICallbackFunctions.ByValue(new FMULibrary.FMULogger(_fmiModelDescription),new FMULibrary.FMUAllocateMemory(),new FMULibrary.FMUFreeMemory(),new FMULibrary.FMUStepFinished());
      if (_fmiModelDescription.modelExchange) {
        if (_debugging) {
          _debugToStdOut(""String_Node_Str"" + modelIdentifier + ""String_Node_Str"");
        }
        _fmiComponent=(Pointer)_fmiInstantiateModelFunction.invoke(Pointer.class,new Object[]{getFullName(),_fmiModelDescription.guid,_callbacks,loggingOn});
      }
 else {
        if (_debugging) {
          _debugToStdOut(""String_Node_Str"" + modelIdentifier + ""String_Node_Str"");
        }
        _fmiComponent=(Pointer)_fmiInstantiateSlaveFunction.invoke(Pointer.class,new Object[]{getFullName(),_fmiModelDescription.guid,_fmiModelDescription.fmuResourceLocation,mimeType,timeout,toBeVisible,interactive,_callbacks,loggingOn});
      }
    }
 else {
      Pointer fmiEnvironment=_fmiModelDescription.getFMUAllocateMemory().apply(new NativeSizeT(1),new NativeSizeT(Pointer.SIZE));
      _callbacks20=new FMI20CallbackFunctions(new FMULibrary.FMULogger(_fmiModelDescription),_fmiModelDescription.getFMUAllocateMemory(),new FMULibrary.FMUFreeMemory(),new FMULibrary.FMUStepFinished(),fmiEnvironment);
      if (_debugging) {
        _debugToStdOut(""String_Node_Str"" + modelIdentifier + ""String_Node_Str"");
      }
      int fmiType=1;
      if (_fmiModelDescription.modelExchange) {
        fmiType=0;
      }
      if (_fmiVersion < 1.5) {
        if (_fmiModelDescription.modelExchange) {
          throw new IllegalActionException(this,""String_Node_Str"" + _fmiVersion);
        }
 else {
          _fmiComponent=(Pointer)_fmiInstantiateSlaveFunction.invoke(Pointer.class,new Object[]{getFullName(),_fmiModelDescription.guid,_fmiModelDescription.fmuResourceLocation,_callbacks,toBeVisible,loggingOn});
        }
      }
 else       if (_fmiVersion > 1.0 && _fmiVersion < 2.0) {
        _fmiComponent=(Pointer)_fmiInstantiateSlaveFunction.invoke(Pointer.class,new Object[]{getFullName(),_fmiModelDescription.guid,_fmiModelDescription.fmuResourceLocation,_callbacks20,toBeVisibleFMI2,loggingOnFMI2});
      }
 else       if (_fmiVersion >= 2.0) {
        _fmiComponent=(Pointer)_fmiInstantiateFunction.invoke(Pointer.class,new Object[]{getFullName(),fmiType,_fmiModelDescription.guid,_fmiModelDescription.fmuResourceLocation,_callbacks20,toBeVisibleFMI2,loggingOnFMI2});
      }
      if (_debugging) {
        _debugToStdOut(""String_Node_Str"");
      }
    }
    if (_fmiComponent == null || _fmiComponent.equals(Pointer.NULL)) {
      throw new IllegalActionException(this,""String_Node_Str"");
    }
  }
 else {
    final Time currentTime=director.getModelTime();
    final Time startTime=director.getModelStartTime();
    final Time stopTime=director.getModelStopTime();
    final double relativeTolerance=1e-4;
    String fmuLibPath=null;
    try {
      fmuLibPath=_fmiModelDescription.getNativeLibraryPath();
    }
 catch (    IOException ex) {
      throw new IllegalActionException(this,ex,""String_Node_Str"");
    }
    double[] derivatives=new double[_fmiModelDescription.numberOfContinuousStates];
    _fmiJNIComponent=runNativeFMU(0,0,modelIdentifier,fmuLibPath,_fmiModelDescription.fmuResourceLocation,startTime.getDoubleValue(),stopTime.getDoubleValue(),currentTime.getDoubleValue(),0,relativeTolerance,toBeVisible,loggingOn,_fmiModelDescription.guid,derivatives,null,null,null,null,null,null,0,null,null,null,null,null);
  }
}","/** 
 * Instantiate the slave FMU component.
 * @exception IllegalActionException If it cannot be instantiated.
 */
@Override public void preinitialize() throws IllegalActionException {
  if (_fmiModelDescription == null) {
    throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
  }
  super.preinitialize();
  if (_debugging) {
    _debugToStdOut(""String_Node_Str"");
  }
  _numberOfSteps=0;
  _numberOfStateEvents=0;
  _numberOfStepEvents=0;
  _numberOfTimeEvents=0;
  _useQSS=false;
  Director director=getDirector();
  if ((director instanceof QSSDirector)) {
    _useQSS=true;
    _outputQuantum=Math.max(((QSSDirector)getDirector()).getRelativeQuantum(),((QSSDirector)getDirector()).getAbsoluteQuantum());
  }
  if (_useRawJNI()) {
    String buildLibrary=""String_Node_Str"";
    String installLibrary=""String_Node_Str"";
    try {
      if (_debugging) {
        _debugToStdOut(""String_Node_Str"" + buildLibrary);
      }
      UtilityFunctions.loadLibrary(buildLibrary);
    }
 catch (    Throwable buildThrowable) {
      try {
        if (_debugging) {
          _debugToStdOut(""String_Node_Str"" + buildLibrary + ""String_Node_Str""+ buildThrowable+ ""String_Node_Str""+ installLibrary);
        }
        UtilityFunctions.loadLibrary(installLibrary);
      }
 catch (      Throwable installThrowable) {
        throw new IllegalActionException(this,installThrowable,""String_Node_Str"" + installLibrary + ""String_Node_Str""+ buildLibrary+ ""String_Node_Str""+ buildThrowable);
      }
    }
  }
 else {
    try {
      _nativeLibrary=_fmiModelDescription.getNativeLibrary();
    }
 catch (    IOException e1) {
      throw new IllegalActionException(this,e1,""String_Node_Str"");
    }
    if (_nativeLibrary == null) {
      throw new IllegalActionException(this,""String_Node_Str"");
    }
    _checkFmiCommon();
  }
  try {
    if (_fmiModelDescription.modelExchange) {
      try {
        if (_fmiVersion < 2.0 || !_completedIntegratorStepNotNeeded()) {
          _fmiCompletedIntegratorStepFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        }
      }
 catch (      Throwable throwable) {
        throw new IllegalActionException(this,throwable,""String_Node_Str"" + _fmuFileName + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      }
      if (_fmiVersion < 2.0) {
        try {
          _fmiFreeModelInstanceFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        }
 catch (        UnsatisfiedLinkError ex) {
          throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
        }
      }
 else {
        try {
          _fmiFreeInstanceFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        }
 catch (        UnsatisfiedLinkError ex) {
          throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
        }
      }
      _fmiGetContinuousStatesFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      _fmiSetContinuousStates=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      _fmiGetDerivativesFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      try {
        _fmiGetEventIndicatorsFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
 catch (      UnsatisfiedLinkError ex) {
        _fmiGetEventIndicatorsFunction=null;
      }
      if (_fmiVersion < 1.5) {
        _fmiInitializeFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiInstantiateModelFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
 else       if (_fmiVersion >= 1.5 && _fmiVersion < 2.0) {
        throw new IllegalActionException(this,""String_Node_Str"" + _fmiVersion);
      }
 else {
        _fmiEnterContinuousTimeModeFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiEnterEventModeFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiEnterInitializationModeFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiExitInitializationModeFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiInstantiateFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiNewDiscreteStatesFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
      _fmiSetTimeFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      _fmiTerminateFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      if (_fmiVersion >= 2.0) {
        try {
          _fmiSetupExperimentFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        }
 catch (        UnsatisfiedLinkError ex) {
          throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
        }
      }
      if (_fmiModelDescription.providesDirectionalDerivative) {
        _fmiGetDirectionalDerivativeFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
      _checkFmiModelExchange();
    }
 else {
      try {
        _fmiDoStepFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
 catch (      Throwable throwable) {
        throw new IllegalActionException(this,throwable,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"" + modelExchange.getExpression() + ""String_Node_Str""+ _fmiModelDescription.modelExchange);
      }
      if (_fmiVersion < 2.0) {
        try {
          _fmiFreeSlaveInstanceFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        }
 catch (        UnsatisfiedLinkError ex) {
          throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
        }
      }
 else {
        _fmiEnterInitializationModeFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiExitInitializationModeFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        try {
          _fmiFreeInstanceFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        }
 catch (        UnsatisfiedLinkError ex) {
          throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
        }
      }
      if (_fmiVersion < 2.0) {
        _fmiInitializeSlaveFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiInstantiateSlaveFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        if (_fmiVersion >= 1.5) {
          _fmiInstantiateFunction=_fmiInstantiateSlaveFunction;
        }
      }
 else {
        _fmiInstantiateFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
      if (_fmiVersion < 2.0) {
        _fmiTerminateSlaveFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
 else {
        _fmiTerminateFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
      try {
        _fmiGetRealStatusFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
 catch (      UnsatisfiedLinkError ex) {
        _fmiGetRealStatusFunction=null;
      }
      if (_fmiModelDescription.canGetAndSetFMUstate) {
        _fmiFreeFMUstateFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiGetFMUstateFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiSetFMUstate=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
 else {
        _fmiFreeFMUstateFunction=null;
        _fmiGetFMUstateFunction=null;
        _fmiSetFMUstate=null;
      }
      if (_fmiVersion >= 2.0) {
        try {
          _fmiSetupExperimentFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        }
 catch (        UnsatisfiedLinkError ex) {
          throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
        }
      }
      if (_fmiModelDescription.providesDirectionalDerivative) {
        _fmiGetDirectionalDerivativeFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
      _checkFmiCoSimulation();
    }
  }
 catch (  IOException ex) {
    throw new IllegalActionException(this,ex,""String_Node_Str"");
  }
  String modelIdentifier=_fmiModelDescription.modelIdentifier;
  String mimeType=""String_Node_Str"";
  double timeout=1000;
  byte toBeVisible=0;
  int toBeVisibleFMI2=0;
  if (((BooleanToken)visible.getToken()).booleanValue()) {
    toBeVisible=1;
    toBeVisibleFMI2=1;
  }
  byte loggingOn=_debugging ? (byte)1 : (byte)0;
  int loggingOnFMI2=_debugging ? 1 : 0;
  byte interactive=0;
  if (!_useRawJNI()) {
    if (_fmiVersion < 1.5) {
      _callbacks=new FMICallbackFunctions.ByValue(new FMULibrary.FMULogger(_fmiModelDescription),new FMULibrary.FMUAllocateMemory(),new FMULibrary.FMUFreeMemory(),new FMULibrary.FMUStepFinished());
      if (_fmiModelDescription.modelExchange) {
        if (_debugging) {
          _debugToStdOut(""String_Node_Str"" + modelIdentifier + ""String_Node_Str"");
        }
        _fmiComponent=(Pointer)_fmiInstantiateModelFunction.invoke(Pointer.class,new Object[]{getFullName(),_fmiModelDescription.guid,_callbacks,loggingOn});
      }
 else {
        if (_debugging) {
          _debugToStdOut(""String_Node_Str"" + modelIdentifier + ""String_Node_Str"");
        }
        _fmiComponent=(Pointer)_fmiInstantiateSlaveFunction.invoke(Pointer.class,new Object[]{getFullName(),_fmiModelDescription.guid,_fmiModelDescription.fmuResourceLocation,mimeType,timeout,toBeVisible,interactive,_callbacks,loggingOn});
      }
    }
 else {
      Pointer fmiEnvironment=_fmiModelDescription.getFMUAllocateMemory().apply(new NativeSizeT(1),new NativeSizeT(Pointer.SIZE));
      _callbacks20=new FMI20CallbackFunctions(new FMULibrary.FMULogger(_fmiModelDescription),_fmiModelDescription.getFMUAllocateMemory(),new FMULibrary.FMUFreeMemory(),new FMULibrary.FMUStepFinished(),fmiEnvironment);
      if (_debugging) {
        _debugToStdOut(""String_Node_Str"" + modelIdentifier + ""String_Node_Str"");
      }
      int fmiType=1;
      if (_fmiModelDescription.modelExchange) {
        fmiType=0;
      }
      if (_fmiVersion < 1.5) {
        if (_fmiModelDescription.modelExchange) {
          throw new IllegalActionException(this,""String_Node_Str"" + _fmiVersion);
        }
 else {
          _fmiComponent=(Pointer)_fmiInstantiateSlaveFunction.invoke(Pointer.class,new Object[]{getFullName(),_fmiModelDescription.guid,_fmiModelDescription.fmuResourceLocation,_callbacks,toBeVisible,loggingOn});
        }
      }
 else       if (_fmiVersion > 1.0 && _fmiVersion < 2.0) {
        _fmiComponent=(Pointer)_fmiInstantiateSlaveFunction.invoke(Pointer.class,new Object[]{getFullName(),_fmiModelDescription.guid,_fmiModelDescription.fmuResourceLocation,_callbacks20,toBeVisibleFMI2,loggingOnFMI2});
      }
 else       if (_fmiVersion >= 2.0) {
        _fmiComponent=(Pointer)_fmiInstantiateFunction.invoke(Pointer.class,new Object[]{getFullName(),fmiType,_fmiModelDescription.guid,_fmiModelDescription.fmuResourceLocation,_callbacks20,toBeVisibleFMI2,loggingOnFMI2});
      }
      if (_debugging) {
        _debugToStdOut(""String_Node_Str"");
      }
    }
    if (_fmiComponent == null || _fmiComponent.equals(Pointer.NULL)) {
      throw new IllegalActionException(this,""String_Node_Str"");
    }
  }
 else {
    final Time currentTime=director.getModelTime();
    final Time startTime=director.getModelStartTime();
    final Time stopTime=director.getModelStopTime();
    final double relativeTolerance=1e-4;
    String fmuLibPath=null;
    try {
      fmuLibPath=_fmiModelDescription.getNativeLibraryPath();
    }
 catch (    IOException ex) {
      throw new IllegalActionException(this,ex,""String_Node_Str"");
    }
    double[] derivatives=new double[_fmiModelDescription.numberOfContinuousStates];
    _fmiJNIComponent=runNativeFMU(0,0,modelIdentifier,fmuLibPath,_fmiModelDescription.fmuResourceLocation,startTime.getDoubleValue(),stopTime.getDoubleValue(),currentTime.getDoubleValue(),0,relativeTolerance,toBeVisible,loggingOn,_fmiModelDescription.guid,derivatives,null,null,null,null,null,null,0,null,null,null,null,null);
  }
}"
72482,"/** 
 * Send output and state model to the port.
 * @param val The values to be sent.
 * @param prt The port where values will be sent.
 * @param index The index of an output or continuous state.
 * @param isState The flag to indicate if continuous state.
 */
private void _sendModelToPort(final double[] val,final TypedIOPort prt,Time time,int index,boolean isState) throws NoRoomException, IllegalActionException {
  double outputQuantum=_internalRelativeQuantum / _quantumScaleFactor;
  if (isState) {
    double lastqSta=_fmiModelDescription.continuousStates.get(index).lastDoubleOutput;
    final int modVarIdx=_modelVariableIndexesOfInputsAndContinuousStates.get(_fmiModelDescription.continuousStates.get(index).name);
    double epsilon=0;
    if (_firstRound) {
      _sendModelToConnectedPort(val,prt,time);
      prt.send(0,new SmoothToken(val,time));
      _fmiModelDescription.continuousStates.get(index).lastDoubleOutput=val[0];
      epsilon=_qssSolver.findQuantum(index) / _quantumScaleFactor;
      _updateModelVariableAttribute(modVarIdx,true);
    }
 else {
      if (Math.abs(val[0] - lastqSta) <= Math.abs(epsilon)) {
        _updateModelVariableAttribute(modVarIdx,false);
        return;
      }
 else {
        _sendModelToConnectedPort(val,prt,time);
        _updateModelVariableAttribute(modVarIdx,true);
        _fmiModelDescription.continuousStates.get(index).lastDoubleOutput=val[0];
        epsilon=_qssSolver.findQuantum(index) / _quantumScaleFactor;
      }
    }
  }
 else {
    double epsilon=0;
    double lastDblOut=_outputs.get(index).lastDoubleOutput;
    if (_firstRound) {
      _sendModelToConnectedPort(val,prt,time);
      _outputs.get(index).lastDoubleOutput=val[0];
      epsilon=Math.abs(outputQuantum * _outputs.get(index).lastDoubleOutput);
    }
 else {
      if (Math.abs(val[0] - lastDblOut) <= Math.abs(epsilon)) {
        return;
      }
 else {
        if (_cancelSendModelToPort(index))         return;
        _sendModelToConnectedPort(val,prt,time);
        _outputs.get(index).lastDoubleOutput=val[0];
        epsilon=Math.abs(outputQuantum * _outputs.get(index).lastDoubleOutput);
      }
    }
  }
}","/** 
 * Send output and state model to the port.
 * @param val The values to be sent.
 * @param prt The port where values will be sent.
 * @param index The index of an output or continuous state.
 * @param isState The flag to indicate if continuous state.
 */
private void _sendModelToPort(final double[] val,final TypedIOPort prt,Time time,int index,boolean isState) throws NoRoomException, IllegalActionException {
  if (isState) {
    double lastqSta=_fmiModelDescription.continuousStates.get(index).lastDoubleOutput;
    final int modVarIdx=_modelVariableIndexesOfInputsAndContinuousStates.get(_fmiModelDescription.continuousStates.get(index).name);
    double epsilon=0;
    if (_firstRound) {
      _sendModelToConnectedPort(val,prt,time);
      prt.send(0,new SmoothToken(val,time));
      _fmiModelDescription.continuousStates.get(index).lastDoubleOutput=val[0];
      epsilon=_qssSolver.findQuantum(index) / _quantumScaleFactor;
      _updateModelVariableAttribute(modVarIdx,true);
    }
 else {
      if (Math.abs(val[0] - lastqSta) <= Math.abs(epsilon)) {
        _updateModelVariableAttribute(modVarIdx,false);
        return;
      }
 else {
        _sendModelToConnectedPort(val,prt,time);
        _updateModelVariableAttribute(modVarIdx,true);
        _fmiModelDescription.continuousStates.get(index).lastDoubleOutput=val[0];
        epsilon=_qssSolver.findQuantum(index) / _quantumScaleFactor;
      }
    }
  }
 else {
    double epsilon=0;
    double lastDblOut=_outputs.get(index).lastDoubleOutput;
    if (_firstRound) {
      _sendModelToConnectedPort(val,prt,time);
      _outputs.get(index).lastDoubleOutput=val[0];
      epsilon=Math.abs(_outputQuantum * _outputs.get(index).lastDoubleOutput);
    }
 else {
      if (Math.abs(val[0] - lastDblOut) <= Math.abs(epsilon)) {
        return;
      }
 else {
        if (_cancelSendModelToPort(index))         return;
        _sendModelToConnectedPort(val,prt,time);
        _outputs.get(index).lastDoubleOutput=val[0];
        epsilon=Math.abs(_outputQuantum * _outputs.get(index).lastDoubleOutput);
      }
    }
  }
}"
72483,"/** 
 * Initialize this FMU wrapper. <p>According to ""System Design, Modeling, and Simulation Using Ptolemy II"", version 1.02, section 12.3.1 ""Execution Control"": ""The initialize action of the setup phase initializes parameters, resets local state, and sends out any initial messages.""</p>
 * @exception IllegalActionException If the slave FMU cannot be initialized.
 */
public void initialize() throws IllegalActionException {
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  if (_initializables != null) {
    for (    Initializable initializable : _initializables) {
      initializable.initialize();
    }
  }
  if (_debugging) {
    _debugToStdOut(String.format(""String_Node_Str"",System.identityHashCode(this)));
  }
  int fmiFlag;
  _firstRound=true;
  _quantumScaleFactor=_director.getQuantumScaleFactor();
  _internalRelativeQuantum=_director.getRelativeQuantum() * _quantumScaleFactor;
  if (_internalRelativeQuantum == 0.0) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  if (!_useRawJNI()) {
    if (((BooleanToken)initFMUParameters.getToken()).booleanValue() && !_useRawJNI()) {
      _initializeFMUParameters();
    }
    _fmiInitialize();
    _checkStateEvents();
    int newDiscreteStatesNeeded=1;
    int terminateSimulation=0;
    int nominalsOfContinuousStatesChanged=0;
    int valuesOfContinuousStatesChanged=0;
    int nextEventTimeDefined=0;
    double nextEventTime=0;
    _eventInfo=new FMI20EventInfo(newDiscreteStatesNeeded,terminateSimulation,nominalsOfContinuousStatesChanged,valuesOfContinuousStatesChanged,nextEventTimeDefined,nextEventTime);
    if (_fmiNewDiscreteStatesFunction == null) {
      throw new InternalErrorException(this,null,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + modelExchange + ""String_Node_Str""+ _fmiModelDescription.modelExchange);
    }
    fmiFlag=((Integer)_fmiNewDiscreteStatesFunction.invoke(Integer.class,new Object[]{_fmiComponent,_eventInfo})).intValue();
    if (fmiFlag != FMILibrary.FMIStatus.fmiOK) {
      throw new IllegalActionException(this,""String_Node_Str"" + _fmiStatusDescription(fmiFlag));
    }
    if (_eventInfo.newDiscreteStatesNeeded != 0) {
      new Exception(""String_Node_Str"").printStackTrace();
    }
    if (_eventInfo.terminateSimulation != 0) {
      getDirector().finish();
    }
    fmiFlag=((Integer)_fmiEnterContinuousTimeModeFunction.invokeInt(new Object[]{_fmiComponent})).intValue();
    if (fmiFlag != FMILibrary.FMIStatus.fmiOK) {
      throw new IllegalActionException(this,""String_Node_Str"" + _fmiStatusDescription(fmiFlag));
    }
  }
 else {
    final String modelIdentifier=_fmiModelDescription.modelIdentifier;
    byte toBeVisible=0;
    if (((BooleanToken)visible.getToken()).booleanValue()) {
      toBeVisible=1;
    }
    byte loggingOn=_debugging ? (byte)1 : (byte)0;
    String fmuLibPath=null;
    try {
      fmuLibPath=_fmiModelDescription.getNativeLibraryPath();
    }
 catch (    IOException ex) {
      throw new IllegalActionException(this,ex,""String_Node_Str"");
    }
    final Time currentTime=_director.getModelTime();
    final Time startTime=_director.getModelStartTime();
    final Time stopTime=_director.getModelStopTime();
    final double timeValue=currentTime.getDoubleValue();
    double[] derivatives=new double[_fmiModelDescription.numberOfContinuousStates];
    _fmiComponentJNI=_fmiInstantiatesJNI(modelIdentifier,fmuLibPath,_fmiModelDescription.fmuResourceLocation,startTime.getDoubleValue(),stopTime.getDoubleValue(),timeValue,0,_internalRelativeQuantum,toBeVisible,loggingOn,_fmiModelDescription.guid,derivatives);
    if (((BooleanToken)initFMUParameters.getToken()).booleanValue() && !_useRawJNI()) {
      _initializeFMUParameters();
    }
    _fmiInitializeJNI(timeValue);
    _fmiNewDiscreteStatesJNI(timeValue);
    _fmiEnterContinuousModeJNI(timeValue);
  }
  _createQSSSolver();
  _director.fireAtCurrentTime(this);
  return;
}","/** 
 * Initialize this FMU wrapper. <p>According to ""System Design, Modeling, and Simulation Using Ptolemy II"", version 1.02, section 12.3.1 ""Execution Control"": ""The initialize action of the setup phase initializes parameters, resets local state, and sends out any initial messages.""</p>
 * @exception IllegalActionException If the slave FMU cannot be initialized.
 */
public void initialize() throws IllegalActionException {
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  if (_initializables != null) {
    for (    Initializable initializable : _initializables) {
      initializable.initialize();
    }
  }
  if (_debugging) {
    _debugToStdOut(String.format(""String_Node_Str"",System.identityHashCode(this)));
  }
  int fmiFlag;
  _firstRound=true;
  _quantumScaleFactor=_director.getQuantumScaleFactor();
  _internalRelativeQuantum=_director.getRelativeQuantum() * _quantumScaleFactor;
  if (!_useRawJNI()) {
    if (((BooleanToken)initFMUParameters.getToken()).booleanValue() && !_useRawJNI()) {
      _initializeFMUParameters();
    }
    _fmiInitialize();
    _checkStateEvents();
    int newDiscreteStatesNeeded=1;
    int terminateSimulation=0;
    int nominalsOfContinuousStatesChanged=0;
    int valuesOfContinuousStatesChanged=0;
    int nextEventTimeDefined=0;
    double nextEventTime=0;
    _eventInfo=new FMI20EventInfo(newDiscreteStatesNeeded,terminateSimulation,nominalsOfContinuousStatesChanged,valuesOfContinuousStatesChanged,nextEventTimeDefined,nextEventTime);
    if (_fmiNewDiscreteStatesFunction == null) {
      throw new InternalErrorException(this,null,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + modelExchange + ""String_Node_Str""+ _fmiModelDescription.modelExchange);
    }
    fmiFlag=((Integer)_fmiNewDiscreteStatesFunction.invoke(Integer.class,new Object[]{_fmiComponent,_eventInfo})).intValue();
    if (fmiFlag != FMILibrary.FMIStatus.fmiOK) {
      throw new IllegalActionException(this,""String_Node_Str"" + _fmiStatusDescription(fmiFlag));
    }
    if (_eventInfo.newDiscreteStatesNeeded != 0) {
      new Exception(""String_Node_Str"").printStackTrace();
    }
    if (_eventInfo.terminateSimulation != 0) {
      getDirector().finish();
    }
    fmiFlag=((Integer)_fmiEnterContinuousTimeModeFunction.invokeInt(new Object[]{_fmiComponent})).intValue();
    if (fmiFlag != FMILibrary.FMIStatus.fmiOK) {
      throw new IllegalActionException(this,""String_Node_Str"" + _fmiStatusDescription(fmiFlag));
    }
  }
 else {
    final String modelIdentifier=_fmiModelDescription.modelIdentifier;
    byte toBeVisible=0;
    if (((BooleanToken)visible.getToken()).booleanValue()) {
      toBeVisible=1;
    }
    byte loggingOn=_debugging ? (byte)1 : (byte)0;
    String fmuLibPath=null;
    try {
      fmuLibPath=_fmiModelDescription.getNativeLibraryPath();
    }
 catch (    IOException ex) {
      throw new IllegalActionException(this,ex,""String_Node_Str"");
    }
    final Time currentTime=_director.getModelTime();
    final Time startTime=_director.getModelStartTime();
    final Time stopTime=_director.getModelStopTime();
    final double timeValue=currentTime.getDoubleValue();
    double[] derivatives=new double[_fmiModelDescription.numberOfContinuousStates];
    _fmiComponentJNI=_fmiInstantiatesJNI(modelIdentifier,fmuLibPath,_fmiModelDescription.fmuResourceLocation,startTime.getDoubleValue(),stopTime.getDoubleValue(),timeValue,0,_internalRelativeQuantum,toBeVisible,loggingOn,_fmiModelDescription.guid,derivatives);
    if (((BooleanToken)initFMUParameters.getToken()).booleanValue() && !_useRawJNI()) {
      _initializeFMUParameters();
    }
    _fmiInitializeJNI(timeValue);
    _fmiNewDiscreteStatesJNI(timeValue);
    _fmiEnterContinuousModeJNI(timeValue);
  }
  _createQSSSolver();
  _director.fireAtCurrentTime(this);
  return;
}"
72484,"/** 
 * Consume the inputs and produce the outputs of the FFT filter.
 * @exception IllegalActionException If a runtime type error occurs.
 */
@Override public void fire() throws IllegalActionException {
  super.fire();
  mean.update();
  standardDeviation.update();
  transitionMatrix.update();
  prior.update();
  _nStates=((ArrayToken)mean.getToken()).length();
  _priors=new double[_nStates];
  _transitionMatrixEstimate=new double[_nStates][_nStates];
  for (int i=0; i < _nStates; i++) {
    _priors[i]=((DoubleToken)((ArrayToken)prior.getToken()).getElement(i)).doubleValue();
    for (int j=0; j < _nStates; j++) {
      _transitionMatrixEstimate[i][j]=((DoubleToken)((MatrixToken)transitionMatrix.getToken()).getElementAsToken(i,j)).doubleValue();
    }
  }
  int obsDim=1;
  if (((ArrayToken)mean.getToken()).getElementType().isCompatible(BaseType.DOUBLE)) {
    _mu=new double[_nStates][obsDim];
    _sigma=new double[_nStates][obsDim][obsDim];
    for (int i=0; i < _nStates; i++) {
      _sigma[i][0][0]=((DoubleToken)((ArrayToken)standardDeviation.getToken()).getElement(i)).doubleValue();
      _mu[i][0]=((DoubleToken)((ArrayToken)mean.getToken()).getElement(i)).doubleValue();
    }
  }
 else {
    obsDim=((ArrayToken)((ArrayToken)mean.getToken()).getElement(0)).length();
    _mu=new double[_nStates][obsDim];
    _sigma=new double[_nStates][obsDim][obsDim];
    for (int i=0; i < _nStates; i++) {
      _sigma[i]=((DoubleMatrixToken)((ArrayToken)standardDeviation.getToken()).getElement(i)).doubleMatrix();
      for (int j=0; j < obsDim; j++) {
        _mu[i][j]=((DoubleToken)((ArrayToken)((ArrayToken)mean.getToken()).getElement(i)).getElement(j)).doubleValue();
      }
    }
  }
  if ((_nStates != _sigma.length) || (_nStates != _transitionMatrixEstimate.length)) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  if (_observations != null) {
    int[] classifyStates=new int[_observations.length];
    classifyStates=classifyHMM(_observations,_priors,_transitionMatrixEstimate);
    IntToken[] _outTokenArray=new IntToken[classifyStates.length];
    for (int i=0; i < classifyStates.length; i++) {
      _outTokenArray[i]=new IntToken(classifyStates[i]);
    }
    output.broadcast(new ArrayToken(BaseType.INT,_outTokenArray));
    likelihood.send(0,new DoubleToken(_likelihood));
  }
}","/** 
 * Consume the inputs and produce the outputs of the FFT filter.
 * @exception IllegalActionException If a runtime type error occurs.
 */
@Override public void fire() throws IllegalActionException {
  super.fire();
  mean.update();
  covariance.update();
  transitionMatrix.update();
  prior.update();
  _nStates=((ArrayToken)mean.getToken()).length();
  _priors=new double[_nStates];
  _transitionMatrixEstimate=new double[_nStates][_nStates];
  for (int i=0; i < _nStates; i++) {
    _priors[i]=((DoubleToken)((ArrayToken)prior.getToken()).getElement(i)).doubleValue();
    for (int j=0; j < _nStates; j++) {
      _transitionMatrixEstimate[i][j]=((DoubleToken)((MatrixToken)transitionMatrix.getToken()).getElementAsToken(i,j)).doubleValue();
    }
  }
  int obsDim=1;
  if (((ArrayToken)mean.getToken()).getElementType().isCompatible(BaseType.DOUBLE)) {
    _mu=new double[_nStates][obsDim];
    _sigma=new double[_nStates][obsDim][obsDim];
    for (int i=0; i < _nStates; i++) {
      _sigma[i][0][0]=((DoubleToken)((ArrayToken)covariance.getToken()).getElement(i)).doubleValue();
      _mu[i][0]=((DoubleToken)((ArrayToken)mean.getToken()).getElement(i)).doubleValue();
    }
  }
 else {
    obsDim=((ArrayToken)((ArrayToken)mean.getToken()).getElement(0)).length();
    _mu=new double[_nStates][obsDim];
    _sigma=new double[_nStates][obsDim][obsDim];
    for (int i=0; i < _nStates; i++) {
      _sigma[i]=((DoubleMatrixToken)((ArrayToken)covariance.getToken()).getElement(i)).doubleMatrix();
      for (int j=0; j < obsDim; j++) {
        _mu[i][j]=((DoubleToken)((ArrayToken)((ArrayToken)mean.getToken()).getElement(i)).getElement(j)).doubleValue();
      }
    }
  }
  if ((_nStates != _sigma.length) || (_nStates != _transitionMatrixEstimate.length)) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  if (_observations != null) {
    int[] classifyStates=new int[_observations.length];
    classifyStates=classifyHMM(_observations,_priors,_transitionMatrixEstimate);
    IntToken[] _outTokenArray=new IntToken[classifyStates.length];
    for (int i=0; i < classifyStates.length; i++) {
      _outTokenArray[i]=new IntToken(classifyStates[i]);
    }
    output.broadcast(new ArrayToken(BaseType.INT,_outTokenArray));
    likelihood.send(0,new DoubleToken(_likelihood));
  }
}"
72485,"/** 
 * Construct an actor with the given container and name.
 * @param container The container.
 * @param name The name of this actor
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public HMMGaussianClassifier(CompositeEntity container,String name) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  mean=new PortParameter(this,""String_Node_Str"");
  mean.setExpression(""String_Node_Str"");
  StringAttribute cardinality=new StringAttribute(mean.getPort(),""String_Node_Str"");
  cardinality.setExpression(""String_Node_Str"");
  standardDeviation=new PortParameter(this,""String_Node_Str"");
  standardDeviation.setExpression(""String_Node_Str"");
  cardinality=new StringAttribute(standardDeviation.getPort(),""String_Node_Str"");
  cardinality.setExpression(""String_Node_Str"");
  _nStates=((ArrayToken)mean.getToken()).length();
}","/** 
 * Construct an actor with the given container and name.
 * @param container The container.
 * @param name The name of this actor
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public HMMGaussianClassifier(CompositeEntity container,String name) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  mean=new PortParameter(this,""String_Node_Str"");
  mean.setExpression(""String_Node_Str"");
  StringAttribute cardinality=new StringAttribute(mean.getPort(),""String_Node_Str"");
  cardinality.setExpression(""String_Node_Str"");
  covariance=new PortParameter(this,""String_Node_Str"");
  covariance.setExpression(""String_Node_Str"");
  cardinality=new StringAttribute(covariance.getPort(),""String_Node_Str"");
  cardinality.setExpression(""String_Node_Str"");
  _nStates=((ArrayToken)mean.getToken()).length();
}"
72486,"/** 
 * This method is called when a time advancement phase is performed. Every updated HLA attributes received by callbacks (from the RTI) during the time advancement phase is saved as   {@link TimedEvent} and stored in aqueue. Then, every  {@link TimedEvent}s are moved from this queue to the output port of their corresponding   {@link HLASubscriber} actors
 * @throws IllegalActionException If the parent class throws it.
 */
private void _putReflectedAttributesOnHlaSubscribers() throws IllegalActionException {
  TimedEvent event;
  Iterator<Entry<String,LinkedList<TimedEvent>>> it=_fromFederationEvents.entrySet().iterator();
  while (it.hasNext()) {
    Map.Entry<String,LinkedList<TimedEvent>> elt=it.next();
    LinkedList<TimedEvent> events=elt.getValue();
    while (events.size() > 0) {
      event=events.get(0);
      String identity=elt.getKey();
      TypedIOPort tiop=_getPortFromTab(_hlaAttributesSubscribedTo.get(identity));
      HlaSubscriber hs=(HlaSubscriber)tiop.getContainer();
      hs.putReflectedHlaAttribute(event);
      if (_debugging) {
        _debug(this.getDisplayName() + ""String_Node_Str"" + ""String_Node_Str""+ event.toString()+ ""String_Node_Str""+ hs.getDisplayName());
      }
      events.removeFirst();
    }
  }
}","/** 
 * This method is called when a time advancement phase is performed. Every updated HLA attributes received by callbacks (from the RTI) during the time advancement phase is saved as   {@link TimedEvent} and stored in aqueue. Then, every  {@link TimedEvent}s are moved from this queue to the output port of their corresponding   {@link HLASubscriber} actors
 * @exception IllegalActionException If the parent class throws it.
 */
private void _putReflectedAttributesOnHlaSubscribers() throws IllegalActionException {
  TimedEvent event;
  Iterator<Entry<String,LinkedList<TimedEvent>>> it=_fromFederationEvents.entrySet().iterator();
  while (it.hasNext()) {
    Map.Entry<String,LinkedList<TimedEvent>> elt=it.next();
    LinkedList<TimedEvent> events=elt.getValue();
    while (events.size() > 0) {
      event=events.get(0);
      String identity=elt.getKey();
      TypedIOPort tiop=_getPortFromTab(_hlaAttributesSubscribedTo.get(identity));
      HlaSubscriber hs=(HlaSubscriber)tiop.getContainer();
      hs.putReflectedHlaAttribute(event);
      if (_debugging) {
        _debug(this.getDisplayName() + ""String_Node_Str"" + ""String_Node_Str""+ event.toString()+ ""String_Node_Str""+ hs.getDisplayName());
      }
      events.removeFirst();
    }
  }
}"
72487,"/** 
 * The method   {@link #_populatedHlaValueTables()} populates the tablescontaining information of HLA attributes required to publish and to subscribe value attributes in a HLA Federation.
 * @throws IllegalActionException If a HLA attribute is declared twice.
 */
private void _populateHlaAttributeTables() throws IllegalActionException {
  CompositeActor ca=(CompositeActor)this.getContainer();
  _hlaAttributesToPublish.clear();
  List<HlaPublisher> _hlaPublishers=ca.entityList(HlaPublisher.class);
  for (  HlaPublisher hp : _hlaPublishers) {
    if (_hlaAttributesToPublish.get(hp.getName()) != null) {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
    }
    TypedIOPort tiop=hp.inputPortList().get(0);
    _hlaAttributesToPublish.put(hp.getName(),new Object[]{tiop,tiop.getType(),((StringToken)((Parameter)hp.getAttribute(""String_Node_Str"")).getToken()).stringValue()});
  }
  _hlaAttributesSubscribedTo.clear();
}","/** 
 * The method   {@link #_populatedHlaValueTables()} populates the tablescontaining information of HLA attributes required to publish and to subscribe value attributes in a HLA Federation.
 * @exception IllegalActionException If a HLA attribute is declared twice.
 */
private void _populateHlaAttributeTables() throws IllegalActionException {
  CompositeActor ca=(CompositeActor)this.getContainer();
  _hlaAttributesToPublish.clear();
  List<HlaPublisher> _hlaPublishers=ca.entityList(HlaPublisher.class);
  for (  HlaPublisher hp : _hlaPublishers) {
    if (_hlaAttributesToPublish.get(hp.getName()) != null) {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
    }
    TypedIOPort tiop=hp.inputPortList().get(0);
    _hlaAttributesToPublish.put(hp.getName(),new Object[]{tiop,tiop.getType(),((StringToken)((Parameter)hp.getAttribute(""String_Node_Str"")).getToken()).stringValue()});
  }
  _hlaAttributesSubscribedTo.clear();
}"
72488,"/** 
 * Manage the correct termination of the   {@link HlaManager}. Call the HLA services to: unsubscribe to HLA attributes, unpublish HLA attributes, resign a Federation and destroy a Federation if the current Federate is the last participant.
 * @throws IllegalActionException If the parent class throws itof if a CERTI exception is raised then displayed it to the user.
 */
@Override public void wrapup() throws IllegalActionException {
  super.wrapup();
  _strucuralInformation.clear();
  _registeredObject.clear();
  if (_debugging) {
    _debug(this.getDisplayName() + ""String_Node_Str"");
  }
  for (  Object[] obj : _hlaAttributesSubscribedTo.values()) {
    try {
      _rtia.unsubscribeObjectClass(_getClassHandleFromTab(obj));
    }
 catch (    RTIexception e) {
      throw new IllegalActionException(this,e,e.getMessage());
    }
    if (_debugging) {
      _debug(this.getDisplayName() + ""String_Node_Str"" + _getPortFromTab(obj).getContainer().getName()+ ""String_Node_Str""+ _getClassHandleFromTab(obj)+ ""String_Node_Str"");
    }
  }
  for (  Object[] obj : _hlaAttributesToPublish.values()) {
    try {
      _rtia.unpublishObjectClass(_getClassHandleFromTab(obj));
    }
 catch (    RTIexception e) {
      throw new IllegalActionException(this,e,e.getMessage());
    }
    if (_debugging) {
      _debug(this.getDisplayName() + ""String_Node_Str"" + _getPortFromTab(obj).getContainer().getName()+ ""String_Node_Str""+ _getClassHandleFromTab(obj)+ ""String_Node_Str"");
    }
  }
  try {
    _rtia.resignFederationExecution(ResignAction.DELETE_OBJECTS_AND_RELEASE_ATTRIBUTES);
  }
 catch (  RTIexception e) {
    throw new IllegalActionException(this,e,e.getMessage());
  }
  if (_debugging) {
    _debug(this.getDisplayName() + ""String_Node_Str"");
  }
  boolean canDestroyRtig=false;
  while (!canDestroyRtig) {
    try {
      _rtia.destroyFederationExecution(_federationName);
    }
 catch (    FederatesCurrentlyJoined e) {
      if (_debugging) {
        _debug(this.getDisplayName() + ""String_Node_Str"");
      }
    }
catch (    FederationExecutionDoesNotExist e) {
      if (_debugging) {
        _debug(this.getDisplayName() + ""String_Node_Str"");
      }
      canDestroyRtig=true;
    }
catch (    RTIinternalError e) {
      throw new IllegalActionException(this,e,""String_Node_Str"");
    }
catch (    ConcurrentAccessAttempted e) {
      throw new IllegalActionException(this,e,""String_Node_Str"");
    }
    if (_debugging) {
      _debug(this.getDisplayName() + ""String_Node_Str"" + ""String_Node_Str"");
    }
    canDestroyRtig=true;
  }
  if (_certiRtig != null) {
    _certiRtig.terminateProcess();
    if (_debugging) {
      _debug(this.getDisplayName() + ""String_Node_Str"" + ""String_Node_Str"");
    }
  }
  _hlaAttributesToPublish.clear();
  _hlaAttributesSubscribedTo.clear();
  _fromFederationEvents.clear();
  _objectIdToClassHandle.clear();
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
}","/** 
 * Manage the correct termination of the   {@link HlaManager}. Call the HLA services to: unsubscribe to HLA attributes, unpublish HLA attributes, resign a Federation and destroy a Federation if the current Federate is the last participant.
 * @exception IllegalActionException If the parent class throws itof if a CERTI exception is raised then displayed it to the user.
 */
@Override public void wrapup() throws IllegalActionException {
  super.wrapup();
  _strucuralInformation.clear();
  _registeredObject.clear();
  if (_debugging) {
    _debug(this.getDisplayName() + ""String_Node_Str"");
  }
  for (  Object[] obj : _hlaAttributesSubscribedTo.values()) {
    try {
      _rtia.unsubscribeObjectClass(_getClassHandleFromTab(obj));
    }
 catch (    RTIexception e) {
      throw new IllegalActionException(this,e,e.getMessage());
    }
    if (_debugging) {
      _debug(this.getDisplayName() + ""String_Node_Str"" + _getPortFromTab(obj).getContainer().getName()+ ""String_Node_Str""+ _getClassHandleFromTab(obj)+ ""String_Node_Str"");
    }
  }
  for (  Object[] obj : _hlaAttributesToPublish.values()) {
    try {
      _rtia.unpublishObjectClass(_getClassHandleFromTab(obj));
    }
 catch (    RTIexception e) {
      throw new IllegalActionException(this,e,e.getMessage());
    }
    if (_debugging) {
      _debug(this.getDisplayName() + ""String_Node_Str"" + _getPortFromTab(obj).getContainer().getName()+ ""String_Node_Str""+ _getClassHandleFromTab(obj)+ ""String_Node_Str"");
    }
  }
  try {
    _rtia.resignFederationExecution(ResignAction.DELETE_OBJECTS_AND_RELEASE_ATTRIBUTES);
  }
 catch (  RTIexception e) {
    throw new IllegalActionException(this,e,e.getMessage());
  }
  if (_debugging) {
    _debug(this.getDisplayName() + ""String_Node_Str"");
  }
  boolean canDestroyRtig=false;
  while (!canDestroyRtig) {
    try {
      _rtia.destroyFederationExecution(_federationName);
    }
 catch (    FederatesCurrentlyJoined e) {
      if (_debugging) {
        _debug(this.getDisplayName() + ""String_Node_Str"");
      }
    }
catch (    FederationExecutionDoesNotExist e) {
      if (_debugging) {
        _debug(this.getDisplayName() + ""String_Node_Str"");
      }
      canDestroyRtig=true;
    }
catch (    RTIinternalError e) {
      throw new IllegalActionException(this,e,""String_Node_Str"");
    }
catch (    ConcurrentAccessAttempted e) {
      throw new IllegalActionException(this,e,""String_Node_Str"");
    }
    if (_debugging) {
      _debug(this.getDisplayName() + ""String_Node_Str"" + ""String_Node_Str"");
    }
    canDestroyRtig=true;
  }
  if (_certiRtig != null) {
    _certiRtig.terminateProcess();
    if (_debugging) {
      _debug(this.getDisplayName() + ""String_Node_Str"" + ""String_Node_Str"");
    }
  }
  _hlaAttributesToPublish.clear();
  _hlaAttributesSubscribedTo.clear();
  _fromFederationEvents.clear();
  _objectIdToClassHandle.clear();
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
}"
72489,"/** 
 * Update the HLA attribute <i>attributeName</i> with the containment of the token <i>in</i>. The updated attribute is sent to the HLA/CERTI Federation.
 * @param hp The HLA publisher actor (HLA attribute) to update.
 * @param in The updated value of the HLA attribute to update.
 * @throws IllegalActionException If a CERTI exception is raised thendisplayed it to the user.
 */
void updateHlaAttribute(HlaPublisher hp,Token in,String senderName) throws IllegalActionException {
  Time currentTime=_director.getModelTime();
  Object[] tObj=_hlaAttributesToPublish.get(hp.getName());
  byte[] valAttribute=MessageProcessing.encodeHlaValue(hp,in);
  if (_debugging) {
    if (hp.useCertiMessageBuffer()) {
      _debug(this.getDisplayName() + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ _director.getModelTime().getDoubleValue());
    }
  }
  SuppliedAttributes suppAttributes=null;
  try {
    suppAttributes=RtiFactoryFactory.getRtiFactory().createSuppliedAttributes();
  }
 catch (  RTIinternalError e) {
    throw new IllegalActionException(this,e,""String_Node_Str"");
  }
  suppAttributes.add(_getAttributeHandleFromTab(tObj),valAttribute);
  byte[] tag=EncodingHelpers.encodeString(_getPortFromTab(tObj).getContainer().getName());
  double messageModelTime=currentTime.getDoubleValue() + _hlaLookAHead;
  CertiLogicalTime ct=new CertiLogicalTime(messageModelTime * _hlaTimeUnitValue);
  if (_debugging) {
    _debug(this.getDisplayName() + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ currentTime.getDoubleValue()+ ""String_Node_Str""+ _getPortFromTab(tObj).getContainer().getName()+ ""String_Node_Str""+ ct.getTime()+ ""String_Node_Str""+ in.toString()+ ""String_Node_Str"");
  }
  try {
    int id=_registeredObject.get(_federateName + ""String_Node_Str"" + senderName);
    _rtia.updateAttributeValues(id,suppAttributes,tag,ct);
  }
 catch (  Exception e) {
    throw new IllegalActionException(this,e,e.getMessage());
  }
}","/** 
 * Update the HLA attribute <i>attributeName</i> with the containment of the token <i>in</i>. The updated attribute is sent to the HLA/CERTI Federation.
 * @param hp The HLA publisher actor (HLA attribute) to update.
 * @param in The updated value of the HLA attribute to update.
 * @exception IllegalActionException If a CERTI exception is raised thendisplayed it to the user.
 */
void updateHlaAttribute(HlaPublisher hp,Token in,String senderName) throws IllegalActionException {
  Time currentTime=_director.getModelTime();
  Object[] tObj=_hlaAttributesToPublish.get(hp.getName());
  byte[] valAttribute=MessageProcessing.encodeHlaValue(hp,in);
  if (_debugging) {
    if (hp.useCertiMessageBuffer()) {
      _debug(this.getDisplayName() + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ _director.getModelTime().getDoubleValue());
    }
  }
  SuppliedAttributes suppAttributes=null;
  try {
    suppAttributes=RtiFactoryFactory.getRtiFactory().createSuppliedAttributes();
  }
 catch (  RTIinternalError e) {
    throw new IllegalActionException(this,e,""String_Node_Str"");
  }
  suppAttributes.add(_getAttributeHandleFromTab(tObj),valAttribute);
  byte[] tag=EncodingHelpers.encodeString(_getPortFromTab(tObj).getContainer().getName());
  double messageModelTime=currentTime.getDoubleValue() + _hlaLookAHead;
  CertiLogicalTime ct=new CertiLogicalTime(messageModelTime * _hlaTimeUnitValue);
  if (_debugging) {
    _debug(this.getDisplayName() + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ currentTime.getDoubleValue()+ ""String_Node_Str""+ _getPortFromTab(tObj).getContainer().getName()+ ""String_Node_Str""+ ct.getTime()+ ""String_Node_Str""+ in.toString()+ ""String_Node_Str"");
  }
  try {
    int id=_registeredObject.get(_federateName + ""String_Node_Str"" + senderName);
    _rtia.updateAttributeValues(id,suppAttributes,tag,ct);
  }
 catch (  Exception e) {
    throw new IllegalActionException(this,e,e.getMessage());
  }
}"
72490,"/** 
 * Initialize the   {@link PtolemyFederateAmbassadorInner} which handlesthe communication from RTI -> to RTIA -> to FEDERATE. The <i>rtia</i> manages the interaction with the external communicant process RTIA. This method called the Declaration Management services provide by HLA/CERTI to publish/subscribe to HLA attributes in a HLA Federation.
 * @param rtia
 * @throws NameNotFound
 * @throws ObjectClassNotDefined
 * @throws FederateNotExecutionMember
 * @throws RTIinternalError
 * @throws AttributeNotDefined
 * @throws SaveInProgress
 * @throws RestoreInProgress
 * @throws ConcurrentAccessAttempted All those exceptions are from the HLA/CERTI implementation.
 */
public void initialize(RTIambassador rtia) throws NameNotFound, ObjectClassNotDefined, FederateNotExecutionMember, RTIinternalError, AttributeNotDefined, SaveInProgress, RestoreInProgress, ConcurrentAccessAttempted {
  this.timeAdvanceGrant=false;
  this.timeConstrained=false;
  this.timeRegulator=false;
  this.synchronizationSuccess=false;
  this.synchronizationFailed=false;
  this.inPause=false;
  setUpHlaPublisher(rtia);
  setUpSubscription(rtia);
}","/** 
 * Initialize the   {@link PtolemyFederateAmbassadorInner} which handlesthe communication from RTI -> to RTIA -> to FEDERATE. The <i>rtia</i> manages the interaction with the external communicant process RTIA. This method called the Declaration Management services provide by HLA/CERTI to publish/subscribe to HLA attributes in a HLA Federation.
 * @param rtia
 * @exception NameNotFound
 * @exception ObjectClassNotDefined
 * @exception FederateNotExecutionMember
 * @exception RTIinternalError
 * @exception AttributeNotDefined
 * @exception SaveInProgress
 * @exception RestoreInProgress
 * @exception ConcurrentAccessAttempted All those exceptions are from the HLA/CERTI implementation.
 */
public void initialize(RTIambassador rtia) throws NameNotFound, ObjectClassNotDefined, FederateNotExecutionMember, RTIinternalError, AttributeNotDefined, SaveInProgress, RestoreInProgress, ConcurrentAccessAttempted {
  this.timeAdvanceGrant=false;
  this.timeConstrained=false;
  this.timeRegulator=false;
  this.synchronizationSuccess=false;
  this.synchronizationFailed=false;
  this.inPause=false;
  setUpHlaPublisher(rtia);
  setUpSubscription(rtia);
}"
72491,"/** 
 * This generic method should call the   {@link EncodingHelpers} API providedby CERTI to handle type decoding operations for HLA value attribute that has been reflected.
 * @param hs The targeted HLA subcriber actor.
 * @param type The type to decode the token.
 * @param buffer The encoded value to decode.
 * @return The decoded value as an object.
 * @throws IllegalActionException If the token is not handled or thedecoding has failed.
 */
static public Object decodeHlaValue(HlaSubscriber hs,Type type,byte[] buffer) throws IllegalActionException {
  if (hs.useCertiMessageBuffer()) {
    ByteArrayInputStream bis=new ByteArrayInputStream(buffer);
    ByteArrayOutputStream bos=new ByteArrayOutputStream();
    MessageBuffer msgBuffer=new MessageBuffer(bis,bos);
    try {
      msgBuffer.receiveData();
    }
 catch (    Exception e) {
      throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + e.getMessage());
    }
    if (type.equals(BaseType.BOOLEAN)) {
      return msgBuffer.readBoolean();
    }
 else     if (type.equals(BaseType.UNSIGNED_BYTE)) {
      return msgBuffer.readByte();
    }
 else     if (type.equals(BaseType.DOUBLE)) {
      return msgBuffer.readDouble();
    }
 else     if (type.equals(BaseType.FLOAT)) {
      return msgBuffer.readFloat();
    }
 else     if (type.equals(BaseType.INT)) {
      return msgBuffer.readInt();
    }
 else     if (type.equals(BaseType.LONG)) {
      return msgBuffer.readLong();
    }
 else     if (type.equals(BaseType.SHORT)) {
      return msgBuffer.readShort();
    }
 else     if (type.equals(BaseType.STRING)) {
      return msgBuffer.readString();
    }
 else {
      throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    }
  }
  if (type.equals(BaseType.BOOLEAN)) {
    return EncodingHelpers.decodeBoolean(buffer);
  }
 else   if (type.equals(BaseType.UNSIGNED_BYTE)) {
    return EncodingHelpers.decodeByte(buffer);
  }
 else   if (type.equals(BaseType.DOUBLE)) {
    return EncodingHelpers.decodeDouble(buffer);
  }
 else   if (type.equals(BaseType.FLOAT)) {
    return EncodingHelpers.decodeFloat(buffer);
  }
 else   if (type.equals(BaseType.INT)) {
    return EncodingHelpers.decodeInt(buffer);
  }
 else   if (type.equals(BaseType.LONG)) {
    return EncodingHelpers.decodeLong(buffer);
  }
 else   if (type.equals(BaseType.SHORT)) {
    return EncodingHelpers.decodeShort(buffer);
  }
 else   if (type.equals(BaseType.STRING)) {
    return EncodingHelpers.decodeString(buffer);
  }
 else {
    throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
  }
}","/** 
 * This generic method should call the   {@link EncodingHelpers} API providedby CERTI to handle type decoding operations for HLA value attribute that has been reflected.
 * @param hs The targeted HLA subcriber actor.
 * @param type The type to decode the token.
 * @param buffer The encoded value to decode.
 * @return The decoded value as an object.
 * @exception IllegalActionException If the token is not handled or thedecoding has failed.
 */
static public Object decodeHlaValue(HlaSubscriber hs,Type type,byte[] buffer) throws IllegalActionException {
  if (hs.useCertiMessageBuffer()) {
    ByteArrayInputStream bis=new ByteArrayInputStream(buffer);
    ByteArrayOutputStream bos=new ByteArrayOutputStream();
    MessageBuffer msgBuffer=new MessageBuffer(bis,bos);
    try {
      msgBuffer.receiveData();
    }
 catch (    Exception e) {
      throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + e.getMessage());
    }
    if (type.equals(BaseType.BOOLEAN)) {
      return msgBuffer.readBoolean();
    }
 else     if (type.equals(BaseType.UNSIGNED_BYTE)) {
      return msgBuffer.readByte();
    }
 else     if (type.equals(BaseType.DOUBLE)) {
      return msgBuffer.readDouble();
    }
 else     if (type.equals(BaseType.FLOAT)) {
      return msgBuffer.readFloat();
    }
 else     if (type.equals(BaseType.INT)) {
      return msgBuffer.readInt();
    }
 else     if (type.equals(BaseType.LONG)) {
      return msgBuffer.readLong();
    }
 else     if (type.equals(BaseType.SHORT)) {
      return msgBuffer.readShort();
    }
 else     if (type.equals(BaseType.STRING)) {
      return msgBuffer.readString();
    }
 else {
      throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    }
  }
  if (type.equals(BaseType.BOOLEAN)) {
    return EncodingHelpers.decodeBoolean(buffer);
  }
 else   if (type.equals(BaseType.UNSIGNED_BYTE)) {
    return EncodingHelpers.decodeByte(buffer);
  }
 else   if (type.equals(BaseType.DOUBLE)) {
    return EncodingHelpers.decodeDouble(buffer);
  }
 else   if (type.equals(BaseType.FLOAT)) {
    return EncodingHelpers.decodeFloat(buffer);
  }
 else   if (type.equals(BaseType.INT)) {
    return EncodingHelpers.decodeInt(buffer);
  }
 else   if (type.equals(BaseType.LONG)) {
    return EncodingHelpers.decodeLong(buffer);
  }
 else   if (type.equals(BaseType.SHORT)) {
    return EncodingHelpers.decodeShort(buffer);
  }
 else   if (type.equals(BaseType.STRING)) {
    return EncodingHelpers.decodeString(buffer);
  }
 else {
    throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
  }
}"
72492,"/** 
 * This generic method call the   {@link EncodingHelpers} API or the{@link MessageBuffer} API provided by CERTI to handle data encodingoperation for updated value of HLA attribute that will be published to the federation.
 * @param hp The HLA publisher actor which sends the HLA attribute value.
 * @param tok The token to encode, i.e. the HLA attribute value to encode.
 * @return The encoded value as an array of byte.
 * @throws IllegalActionException If the token is not handled or theencoding has failed.
 */
public static byte[] encodeHlaValue(HlaPublisher hp,Token tok) throws IllegalActionException {
  byte[] encodedValue=null;
  Token t=null;
  double recordTimestamp=-1.0;
  int recordMicrostep=-1;
  double sourceTimestamp=-1.0;
  t=tok;
  BaseType type=(BaseType)t.getType();
  if (hp.useCertiMessageBuffer()) {
    ByteArrayOutputStream bos=new ByteArrayOutputStream();
    MessageBuffer msgBuffer=new MessageBuffer(null,bos);
    if (type.equals(BaseType.BOOLEAN)) {
      msgBuffer.write(((BooleanToken)t).booleanValue());
    }
 else     if (type.equals(BaseType.UNSIGNED_BYTE)) {
      msgBuffer.write(((UnsignedByteToken)t).byteValue());
    }
 else     if (type.equals(BaseType.DOUBLE)) {
      msgBuffer.write(((DoubleToken)t).doubleValue());
    }
 else     if (type.equals(BaseType.FLOAT)) {
      msgBuffer.write(((FloatToken)t).floatValue());
    }
 else     if (type.equals(BaseType.INT)) {
      msgBuffer.write(((IntToken)t).intValue());
    }
 else     if (type.equals(BaseType.LONG)) {
      msgBuffer.write(((LongToken)t).longValue());
    }
 else     if (type.equals(BaseType.SHORT)) {
      msgBuffer.write(((ShortToken)t).shortValue());
    }
 else     if (type.equals(BaseType.STRING)) {
      msgBuffer.write(((StringToken)t).stringValue());
    }
 else {
      throw new IllegalActionException(""String_Node_Str"" + t + ""String_Node_Str"");
    }
    try {
      msgBuffer.send();
    }
 catch (    IOException e) {
      throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + e.getMessage());
    }
    encodedValue=bos.toByteArray();
    return encodedValue;
  }
  if (type.equals(BaseType.BOOLEAN)) {
    encodedValue=EncodingHelpers.encodeBoolean(((BooleanToken)t).booleanValue());
  }
 else   if (type.equals(BaseType.UNSIGNED_BYTE)) {
    encodedValue=EncodingHelpers.encodeByte(((UnsignedByteToken)t).byteValue());
  }
 else   if (type.equals(BaseType.DOUBLE)) {
    encodedValue=EncodingHelpers.encodeDouble(((DoubleToken)t).doubleValue());
  }
 else   if (type.equals(BaseType.FLOAT)) {
    encodedValue=EncodingHelpers.encodeFloat(((FloatToken)t).floatValue());
  }
 else   if (type.equals(BaseType.INT)) {
    encodedValue=EncodingHelpers.encodeInt(((IntToken)t).intValue());
  }
 else   if (type.equals(BaseType.LONG)) {
    encodedValue=EncodingHelpers.encodeLong(((LongToken)t).longValue());
  }
 else   if (type.equals(BaseType.SHORT)) {
    encodedValue=EncodingHelpers.encodeShort(((ShortToken)t).shortValue());
  }
 else   if (type.equals(BaseType.STRING)) {
    encodedValue=EncodingHelpers.encodeString(((StringToken)t).stringValue());
  }
 else {
    throw new IllegalActionException(""String_Node_Str"" + t + ""String_Node_Str"");
  }
  return encodedValue;
}","/** 
 * This generic method call the   {@link EncodingHelpers} API or the{@link MessageBuffer} API provided by CERTI to handle data encodingoperation for updated value of HLA attribute that will be published to the federation.
 * @param hp The HLA publisher actor which sends the HLA attribute value.
 * @param tok The token to encode, i.e. the HLA attribute value to encode.
 * @return The encoded value as an array of byte.
 * @exception IllegalActionException If the token is not handled or theencoding has failed.
 */
public static byte[] encodeHlaValue(HlaPublisher hp,Token tok) throws IllegalActionException {
  byte[] encodedValue=null;
  Token t=null;
  double recordTimestamp=-1.0;
  int recordMicrostep=-1;
  double sourceTimestamp=-1.0;
  t=tok;
  BaseType type=(BaseType)t.getType();
  if (hp.useCertiMessageBuffer()) {
    ByteArrayOutputStream bos=new ByteArrayOutputStream();
    MessageBuffer msgBuffer=new MessageBuffer(null,bos);
    if (type.equals(BaseType.BOOLEAN)) {
      msgBuffer.write(((BooleanToken)t).booleanValue());
    }
 else     if (type.equals(BaseType.UNSIGNED_BYTE)) {
      msgBuffer.write(((UnsignedByteToken)t).byteValue());
    }
 else     if (type.equals(BaseType.DOUBLE)) {
      msgBuffer.write(((DoubleToken)t).doubleValue());
    }
 else     if (type.equals(BaseType.FLOAT)) {
      msgBuffer.write(((FloatToken)t).floatValue());
    }
 else     if (type.equals(BaseType.INT)) {
      msgBuffer.write(((IntToken)t).intValue());
    }
 else     if (type.equals(BaseType.LONG)) {
      msgBuffer.write(((LongToken)t).longValue());
    }
 else     if (type.equals(BaseType.SHORT)) {
      msgBuffer.write(((ShortToken)t).shortValue());
    }
 else     if (type.equals(BaseType.STRING)) {
      msgBuffer.write(((StringToken)t).stringValue());
    }
 else {
      throw new IllegalActionException(""String_Node_Str"" + t + ""String_Node_Str"");
    }
    try {
      msgBuffer.send();
    }
 catch (    IOException e) {
      throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + e.getMessage());
    }
    encodedValue=bos.toByteArray();
    return encodedValue;
  }
  if (type.equals(BaseType.BOOLEAN)) {
    encodedValue=EncodingHelpers.encodeBoolean(((BooleanToken)t).booleanValue());
  }
 else   if (type.equals(BaseType.UNSIGNED_BYTE)) {
    encodedValue=EncodingHelpers.encodeByte(((UnsignedByteToken)t).byteValue());
  }
 else   if (type.equals(BaseType.DOUBLE)) {
    encodedValue=EncodingHelpers.encodeDouble(((DoubleToken)t).doubleValue());
  }
 else   if (type.equals(BaseType.FLOAT)) {
    encodedValue=EncodingHelpers.encodeFloat(((FloatToken)t).floatValue());
  }
 else   if (type.equals(BaseType.INT)) {
    encodedValue=EncodingHelpers.encodeInt(((IntToken)t).intValue());
  }
 else   if (type.equals(BaseType.LONG)) {
    encodedValue=EncodingHelpers.encodeLong(((LongToken)t).longValue());
  }
 else   if (type.equals(BaseType.SHORT)) {
    encodedValue=EncodingHelpers.encodeShort(((ShortToken)t).shortValue());
  }
 else   if (type.equals(BaseType.STRING)) {
    encodedValue=EncodingHelpers.encodeString(((StringToken)t).stringValue());
  }
 else {
    throw new IllegalActionException(""String_Node_Str"" + t + ""String_Node_Str"");
  }
  return encodedValue;
}"
72493,"/** 
 * Alpha-beta recursion
 * @param y input sequence
 * @param prior prior guess vectors
 * @param A transition probability matrix
 * @return An array of assigned labels to observations
 * @throws IllegalActionException
 */
protected final int[] classifyHMM(double[][] y,double[] prior,double[][] A) throws IllegalActionException {
  int nStates=_nStates;
  double[][] alphas=new double[y.length][nStates];
  double[][] gamma=new double[y.length][nStates];
  double[] alphaNormalizers=new double[y.length];
  double alphaSum=0;
  for (int t=0; t < y.length; t++) {
    alphaSum=0;
    for (int i=0; i < nStates; i++) {
      alphas[t][i]=0;
      if (t == 0) {
        alphas[t][i]=prior[i] * emissionProbability(y[t],i);
      }
 else {
        for (int qt=0; qt < nStates; qt++) {
          alphas[t][i]+=A[qt][i] * emissionProbability(y[t],i) * alphas[t - 1][qt];
        }
      }
      alphaSum+=alphas[t][i];
    }
    for (int i=0; i < nStates; i++) {
      alphas[t][i]/=alphaSum;
      alphaNormalizers[t]=alphaSum;
    }
  }
  for (int t=y.length - 1; t >= 0; t--) {
    for (int qt=0; qt < nStates; qt++) {
      if (t == y.length - 1) {
        gamma[t][qt]=alphas[t][qt];
      }
 else {
        gamma[t][qt]=0;
        for (int qtp=0; qtp < nStates; qtp++) {
          double alphasum=0;
          for (int j=0; j < nStates; j++) {
            alphasum+=alphas[t][j] * A[j][qtp];
          }
          gamma[t][qt]+=(alphas[t][qt] * A[qt][qtp] * gamma[t + 1][qtp]) / alphasum;
        }
      }
    }
  }
  int[] clusterAssignments=new int[y.length];
  for (int t=0; t < y.length; t++) {
    int maxState=0;
    for (int j=1; j < nStates; j++) {
      if (gamma[t][j] > gamma[t][maxState]) {
        maxState=j;
      }
    }
    clusterAssignments[t]=maxState;
  }
  double logLikelihood=0.0;
  for (int t=0; t < _observations.length - 1; t++) {
    logLikelihood+=emissionProbability(y[t],clusterAssignments[t]);
    logLikelihood+=A[clusterAssignments[t]][clusterAssignments[t + 1]];
  }
  logLikelihood+=emissionProbability(y[_observations.length - 1],clusterAssignments[_observations.length - 1]);
  _likelihood=logLikelihood;
  return clusterAssignments;
}","/** 
 * Alpha-beta recursion
 * @param y input sequence
 * @param prior prior guess vectors
 * @param A transition probability matrix
 * @return An array of assigned labels to observations
 * @exception IllegalActionException
 */
protected final int[] classifyHMM(double[][] y,double[] prior,double[][] A) throws IllegalActionException {
  int nStates=_nStates;
  double[][] alphas=new double[y.length][nStates];
  double[][] gamma=new double[y.length][nStates];
  double[] alphaNormalizers=new double[y.length];
  double alphaSum=0;
  for (int t=0; t < y.length; t++) {
    alphaSum=0;
    for (int i=0; i < nStates; i++) {
      alphas[t][i]=0;
      if (t == 0) {
        alphas[t][i]=prior[i] * emissionProbability(y[t],i);
      }
 else {
        for (int qt=0; qt < nStates; qt++) {
          alphas[t][i]+=A[qt][i] * emissionProbability(y[t],i) * alphas[t - 1][qt];
        }
      }
      alphaSum+=alphas[t][i];
    }
    for (int i=0; i < nStates; i++) {
      alphas[t][i]/=alphaSum;
      alphaNormalizers[t]=alphaSum;
    }
  }
  for (int t=y.length - 1; t >= 0; t--) {
    for (int qt=0; qt < nStates; qt++) {
      if (t == y.length - 1) {
        gamma[t][qt]=alphas[t][qt];
      }
 else {
        gamma[t][qt]=0;
        for (int qtp=0; qtp < nStates; qtp++) {
          double alphasum=0;
          for (int j=0; j < nStates; j++) {
            alphasum+=alphas[t][j] * A[j][qtp];
          }
          gamma[t][qt]+=(alphas[t][qt] * A[qt][qtp] * gamma[t + 1][qtp]) / alphasum;
        }
      }
    }
  }
  int[] clusterAssignments=new int[y.length];
  for (int t=0; t < y.length; t++) {
    int maxState=0;
    for (int j=1; j < nStates; j++) {
      if (gamma[t][j] > gamma[t][maxState]) {
        maxState=j;
      }
    }
    clusterAssignments[t]=maxState;
  }
  double logLikelihood=0.0;
  for (int t=0; t < _observations.length - 1; t++) {
    logLikelihood+=emissionProbability(y[t],clusterAssignments[t]);
    logLikelihood+=A[clusterAssignments[t]][clusterAssignments[t + 1]];
  }
  logLikelihood+=emissionProbability(y[_observations.length - 1],clusterAssignments[_observations.length - 1]);
  _likelihood=logLikelihood;
  return clusterAssignments;
}"
72494,"/** 
 * Abstract class defining the emission probability computation of the latent variable.
 * @throws IllegalActionException
 */
protected abstract double emissionProbability(double[] y,int hiddenState) throws IllegalActionException ;","/** 
 * Abstract class defining the emission probability computation of the latent variable.
 * @exception IllegalActionException
 */
protected abstract double emissionProbability(double[] y,int hiddenState) throws IllegalActionException ;"
72495,"/** 
 * One step EM iteration
 * @throws IllegalActionException
 */
protected abstract void _iterateEM() throws IllegalActionException ;","/** 
 * One step EM iteration
 * @exception IllegalActionException
 */
protected abstract void _iterateEM() throws IllegalActionException ;"
72496,"/** 
 * Java implementation of the Baum-Welch algorithm (Alpha-Beta Recursion) for parameter estimation and cluster assignment. This method uses normalized alpha values for computing the conditional probabilities of input sequences, to ensure numerical stability. Set nCategories to zero for continuous distribution types
 * @param y input observation stream
 * @param A transition probability matrix guess
 * @param prior prior state distribution guess
 * @param nCategories number of categories in the multinomial distribution, where applies
 * @return a HashMap containing the updated estimates of all model parameters
 * @throws IllegalActionException
 */
protected HashMap HMMAlphaBetaRecursion(double[][] y,double[][] A,double[] prior,int nCategories) throws IllegalActionException {
  boolean multinomial=nCategories > 0;
  int nStates=_nStates;
  int nObservations=y.length;
  int obsDimension=_obsDimension;
  double[][] alphas=new double[nObservations][nStates];
  double[][] gamma=new double[nObservations][nStates];
  double[][][] xi=new double[nObservations - 1][nStates][nStates];
  double[][] A_hat=new double[nStates][nStates];
  double[][] mu_hat=new double[nStates][obsDimension];
  double[][][] s_hat=new double[nStates][obsDimension][obsDimension];
  double[] pi_hat=new double[nStates];
  double[][] eta_hat=new double[nStates][nCategories];
  double[] alphaNormalizers=new double[nObservations];
  double alphaSum=0;
  for (int t=0; t < y.length; t++) {
    alphaSum=0;
    for (int i=0; i < nStates; i++) {
      alphas[t][i]=0;
      if (t == 0) {
        alphas[t][i]=prior[i] * emissionProbability(y[t],i);
      }
 else {
        for (int qt=0; qt < nStates; qt++) {
          alphas[t][i]+=A[qt][i] * emissionProbability(y[t],i) * alphas[t - 1][qt];
        }
      }
      alphaSum+=alphas[t][i];
    }
    for (int i=0; i < nStates; i++) {
      alphas[t][i]/=alphaSum;
      alphaNormalizers[t]=alphaSum;
    }
  }
  for (int t=y.length - 1; t >= 0; t--) {
    for (int qt=0; qt < nStates; qt++) {
      if (t == y.length - 1) {
        gamma[t][qt]=alphas[t][qt];
      }
 else {
        gamma[t][qt]=0;
        for (int qtp=0; qtp < nStates; qtp++) {
          double alphasum=0;
          for (int j=0; j < nStates; j++) {
            alphasum+=alphas[t][j] * A[j][qtp];
          }
          gamma[t][qt]+=(alphas[t][qt] * A[qt][qtp] * gamma[t + 1][qtp]) / alphasum;
        }
      }
    }
  }
  for (int next=0; next < nStates; next++) {
    for (int now=0; now < nStates; now++) {
      for (int t=0; t < (y.length - 1); t++) {
        if (alphas[t + 1][next] == 0) {
          xi[t][now][next]=0;
        }
 else {
          xi[t][now][next]=alphas[t][now] * emissionProbability(y[t + 1],next) * gamma[t + 1][next]* A[now][next] / alphas[t + 1][next];
        }
        A_hat[now][next]+=xi[t][now][next];
      }
    }
    for (int a=0; a < y[0].length; a++) {
      mu_hat[next][a]=0;
      for (int b=0; b < y[0].length; b++) {
        s_hat[next][a][b]=0;
      }
    }
  }
  double[] rowsum=new double[nStates];
  double[] gammasum=new double[nStates];
  for (int i=0; i < nStates; i++) {
    rowsum[i]=0;
    for (int j=0; j < nStates; j++) {
      rowsum[i]+=A_hat[i][j];
    }
    for (int j=0; j < nStates; j++) {
      A_hat[i][j]/=rowsum[i];
    }
    gammasum[i]=0.0;
  }
  for (int j=0; j < nStates; j++) {
    gammasum[j]=0.0;
    for (int t=0; t < y.length; t++) {
      gammasum[j]+=gamma[t][j];
      for (int i=0; i < y[0].length; i++) {
        mu_hat[j][i]+=gamma[t][j] * y[t][i];
      }
    }
    for (int i=0; i < y[0].length; i++) {
      mu_hat[j][i]=mu_hat[j][i] / gammasum[j];
    }
    for (int t=0; t < y.length; t++) {
      for (int a=0; a < y[0].length; a++) {
        for (int b=0; b < y[0].length; b++) {
          s_hat[j][a][b]+=gamma[t][j] * (y[t][a] - mu_hat[j][a]) * (y[t][b] - mu_hat[j][b]);
        }
      }
    }
    for (int a=0; a < y[0].length; a++) {
      for (int b=0; b < y[0].length; b++) {
        s_hat[j][a][b]=(s_hat[j][a][b] / gammasum[j]);
      }
    }
    pi_hat[j]=gamma[0][j];
  }
  if (multinomial) {
    for (int i=0; i < nStates; i++) {
      for (int j=0; j < nCategories; j++) {
        for (int t=0; t < y.length; t++) {
          eta_hat[i][j]+=gamma[t][i] * ((y[t][0] == j) ? 1 : 0);
        }
        eta_hat[i][j]/=gammasum[i];
      }
    }
  }
  int[] clusterAssignments=new int[y.length];
  for (int t=0; t < y.length; t++) {
    int maxState=0;
    for (int j=1; j < nStates; j++) {
      if (gamma[t][j] > gamma[t][maxState]) {
        maxState=j;
      }
    }
    clusterAssignments[t]=maxState;
  }
  double logLikelihood=0.0;
  for (int t=0; t < _observations.length - 1; t++) {
    logLikelihood+=emissionProbability(y[t],clusterAssignments[t]);
    logLikelihood+=A_hat[clusterAssignments[t]][clusterAssignments[t + 1]];
  }
  logLikelihood+=emissionProbability(y[_observations.length - 1],clusterAssignments[_observations.length - 1]);
  HashMap estimates=new HashMap();
  estimates.put(""String_Node_Str"",mu_hat);
  estimates.put(""String_Node_Str"",s_hat);
  estimates.put(""String_Node_Str"",gamma);
  estimates.put(""String_Node_Str"",A_hat);
  estimates.put(""String_Node_Str"",pi_hat);
  estimates.put(""String_Node_Str"",eta_hat);
  estimates.put(""String_Node_Str"",logLikelihood);
  return estimates;
}","/** 
 * Java implementation of the Baum-Welch algorithm (Alpha-Beta Recursion) for parameter estimation and cluster assignment. This method uses normalized alpha values for computing the conditional probabilities of input sequences, to ensure numerical stability. Set nCategories to zero for continuous distribution types
 * @param y input observation stream
 * @param A transition probability matrix guess
 * @param prior prior state distribution guess
 * @param nCategories number of categories in the multinomial distribution, where applies
 * @return a HashMap containing the updated estimates of all model parameters
 * @exception IllegalActionException
 */
protected HashMap HMMAlphaBetaRecursion(double[][] y,double[][] A,double[] prior,int nCategories) throws IllegalActionException {
  boolean multinomial=nCategories > 0;
  int nStates=_nStates;
  int nObservations=y.length;
  int obsDimension=_obsDimension;
  double[][] alphas=new double[nObservations][nStates];
  double[][] gamma=new double[nObservations][nStates];
  double[][][] xi=new double[nObservations - 1][nStates][nStates];
  double[][] A_hat=new double[nStates][nStates];
  double[][] mu_hat=new double[nStates][obsDimension];
  double[][][] s_hat=new double[nStates][obsDimension][obsDimension];
  double[] pi_hat=new double[nStates];
  double[][] eta_hat=new double[nStates][nCategories];
  double[] alphaNormalizers=new double[nObservations];
  double alphaSum=0;
  for (int t=0; t < y.length; t++) {
    alphaSum=0;
    for (int i=0; i < nStates; i++) {
      alphas[t][i]=0;
      if (t == 0) {
        alphas[t][i]=prior[i] * emissionProbability(y[t],i);
      }
 else {
        for (int qt=0; qt < nStates; qt++) {
          alphas[t][i]+=A[qt][i] * emissionProbability(y[t],i) * alphas[t - 1][qt];
        }
      }
      alphaSum+=alphas[t][i];
    }
    for (int i=0; i < nStates; i++) {
      alphas[t][i]/=alphaSum;
      alphaNormalizers[t]=alphaSum;
    }
  }
  for (int t=y.length - 1; t >= 0; t--) {
    for (int qt=0; qt < nStates; qt++) {
      if (t == y.length - 1) {
        gamma[t][qt]=alphas[t][qt];
      }
 else {
        gamma[t][qt]=0;
        for (int qtp=0; qtp < nStates; qtp++) {
          double alphasum=0;
          for (int j=0; j < nStates; j++) {
            alphasum+=alphas[t][j] * A[j][qtp];
          }
          gamma[t][qt]+=(alphas[t][qt] * A[qt][qtp] * gamma[t + 1][qtp]) / alphasum;
        }
      }
    }
  }
  for (int next=0; next < nStates; next++) {
    for (int now=0; now < nStates; now++) {
      for (int t=0; t < (y.length - 1); t++) {
        if (alphas[t + 1][next] == 0) {
          xi[t][now][next]=0;
        }
 else {
          xi[t][now][next]=alphas[t][now] * emissionProbability(y[t + 1],next) * gamma[t + 1][next]* A[now][next] / alphas[t + 1][next];
        }
        A_hat[now][next]+=xi[t][now][next];
      }
    }
    for (int a=0; a < y[0].length; a++) {
      mu_hat[next][a]=0;
      for (int b=0; b < y[0].length; b++) {
        s_hat[next][a][b]=0;
      }
    }
  }
  double[] rowsum=new double[nStates];
  double[] gammasum=new double[nStates];
  for (int i=0; i < nStates; i++) {
    rowsum[i]=0;
    for (int j=0; j < nStates; j++) {
      rowsum[i]+=A_hat[i][j];
    }
    for (int j=0; j < nStates; j++) {
      A_hat[i][j]/=rowsum[i];
    }
    gammasum[i]=0.0;
  }
  for (int j=0; j < nStates; j++) {
    gammasum[j]=0.0;
    for (int t=0; t < y.length; t++) {
      gammasum[j]+=gamma[t][j];
      for (int i=0; i < y[0].length; i++) {
        mu_hat[j][i]+=gamma[t][j] * y[t][i];
      }
    }
    for (int i=0; i < y[0].length; i++) {
      mu_hat[j][i]=mu_hat[j][i] / gammasum[j];
    }
    for (int t=0; t < y.length; t++) {
      for (int a=0; a < y[0].length; a++) {
        for (int b=0; b < y[0].length; b++) {
          s_hat[j][a][b]+=gamma[t][j] * (y[t][a] - mu_hat[j][a]) * (y[t][b] - mu_hat[j][b]);
        }
      }
    }
    for (int a=0; a < y[0].length; a++) {
      for (int b=0; b < y[0].length; b++) {
        s_hat[j][a][b]=(s_hat[j][a][b] / gammasum[j]);
      }
    }
    pi_hat[j]=gamma[0][j];
  }
  if (multinomial) {
    for (int i=0; i < nStates; i++) {
      for (int j=0; j < nCategories; j++) {
        for (int t=0; t < y.length; t++) {
          eta_hat[i][j]+=gamma[t][i] * ((y[t][0] == j) ? 1 : 0);
        }
        eta_hat[i][j]/=gammasum[i];
      }
    }
  }
  int[] clusterAssignments=new int[y.length];
  for (int t=0; t < y.length; t++) {
    int maxState=0;
    for (int j=1; j < nStates; j++) {
      if (gamma[t][j] > gamma[t][maxState]) {
        maxState=j;
      }
    }
    clusterAssignments[t]=maxState;
  }
  double logLikelihood=0.0;
  for (int t=0; t < _observations.length - 1; t++) {
    logLikelihood+=emissionProbability(y[t],clusterAssignments[t]);
    logLikelihood+=A_hat[clusterAssignments[t]][clusterAssignments[t + 1]];
  }
  logLikelihood+=emissionProbability(y[_observations.length - 1],clusterAssignments[_observations.length - 1]);
  HashMap estimates=new HashMap();
  estimates.put(""String_Node_Str"",mu_hat);
  estimates.put(""String_Node_Str"",s_hat);
  estimates.put(""String_Node_Str"",gamma);
  estimates.put(""String_Node_Str"",A_hat);
  estimates.put(""String_Node_Str"",pi_hat);
  estimates.put(""String_Node_Str"",eta_hat);
  estimates.put(""String_Node_Str"",logLikelihood);
  return estimates;
}"
72497,"/** 
 * Computes the emission probability. Implemented by the child class.
 * @param y input observation
 * @param hiddenState index of hidden state
 * @return P(Y=y | X=hiddenState)
 * @throws IllegalActionException
 */
protected abstract double emissionProbability(double[] y,int hiddenState) throws IllegalActionException ;","/** 
 * Computes the emission probability. Implemented by the child class.
 * @param y input observation
 * @param hiddenState index of hidden state
 * @return P(Y=y | X=hiddenState)
 * @exception IllegalActionException
 */
protected abstract double emissionProbability(double[] y,int hiddenState) throws IllegalActionException ;"
72498,"/** 
 * Sample next state given current state.
 * @return Next state index.
 * @throws IllegalActionException
 */
protected abstract int _propagateState() throws IllegalActionException ;","/** 
 * Sample next state given current state.
 * @return Next state index.
 * @exception IllegalActionException
 */
protected abstract int _propagateState() throws IllegalActionException ;"
72499,"/** 
 * Constructs a HSMMTimeAwareGenerator object.
 * @param container  a CompositeEntity object
 * @param name       a String ...
 * @throws NameDuplicationException ...
 * @throws IllegalActionException ...
 */
public HSMMTimeAwareGenerator(CompositeEntity container,String name) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  At=new PortParameter(this,""String_Node_Str"");
  At.setExpression(""String_Node_Str"");
  samplingPeriod=new Parameter(this,""String_Node_Str"");
  samplingPeriod.setExpression(""String_Node_Str"");
}","/** 
 * Constructs a HSMMTimeAwareGenerator object.
 * @param container  a CompositeEntity object
 * @param name       a String ...
 * @exception NameDuplicationException ...
 * @exception IllegalActionException ...
 */
public HSMMTimeAwareGenerator(CompositeEntity container,String name) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  At=new PortParameter(this,""String_Node_Str"");
  At.setExpression(""String_Node_Str"");
  samplingPeriod=new Parameter(this,""String_Node_Str"");
  samplingPeriod.setExpression(""String_Node_Str"");
}"
72500,"/** 
 * Send the learned matrix to the output.
 * @throws NoRoomException
 * @throws IllegalActionException
 */
public void _sendEmpiricalMatrix() throws NoRoomException, IllegalActionException {
  Token[] Atokens=new Token[NUM_CATEGORIES];
  for (int i=0; i < NUM_CATEGORIES; i++) {
    Atokens[i]=new DoubleMatrixToken(At[i]);
  }
  empiricalStartTimes.send(0,new ArrayToken(Atokens));
}","/** 
 * Send the learned matrix to the output.
 * @exception NoRoomException
 * @exception IllegalActionException
 */
public void _sendEmpiricalMatrix() throws NoRoomException, IllegalActionException {
  Token[] Atokens=new Token[NUM_CATEGORIES];
  for (int i=0; i < NUM_CATEGORIES; i++) {
    Atokens[i]=new DoubleMatrixToken(At[i]);
  }
  empiricalStartTimes.send(0,new ArrayToken(Atokens));
}"
72501,"/** 
 * Display the specified tokens. If the display is not a MatrixPane, or the tokens are not instances of MatrixToken, do nothing.
 * @exception IllegalActionException If the tokens are notinstances of ImageToken.
 */
@Override public void append(List list) throws IllegalActionException {
  Iterator tokens=list.iterator();
  while (tokens.hasNext()) {
    Object token=tokens.next();
    if (token instanceof ImageToken) {
      display((ImageToken)token);
    }
  }
}","/** 
 * Display the specified tokens. If the tokens are not instances of ImageToken, do nothing.
 * @exception IllegalActionException If the tokens are notinstances of ImageToken.
 */
@Override public void append(List list) throws IllegalActionException {
  Iterator tokens=list.iterator();
  while (tokens.hasNext()) {
    Object token=tokens.next();
    if (token instanceof ImageToken) {
      display((ImageToken)token);
    }
  }
}"
72502,"/** 
 * Private constructor to open an HTTP client.
 * @param currentObj The JavaScript instance of Socket that this helps.
 * @param address The URL of the WebSocket host with an optional port number(e.g. 'ws://localhost:8000'). If no port number is given, 80 is used.
 */
private HttpClientHelper(ScriptObjectMirror currentObj,Map<String,Object> options){
  super(currentObj);
  HttpClient client=_vertx.createHttpClient();
  client.setHost((String)options.get(""String_Node_Str""));
  client.setPort((int)options.get(""String_Node_Str""));
  client.exceptionHandler(new HttpClientExceptionHandler());
  if ((boolean)options.get(""String_Node_Str"")) {
    client.setKeepAlive(true);
  }
  String query=""String_Node_Str"";
  Object queryObject=options.get(""String_Node_Str"");
  if (queryObject != null) {
    String querySpec=queryObject.toString().trim();
    if (!querySpec.equals(""String_Node_Str"") && !querySpec.startsWith(""String_Node_Str"")) {
      query=""String_Node_Str"" + querySpec;
    }
  }
  String uri=options.get(""String_Node_Str"") + ""String_Node_Str"" + options.get(""String_Node_Str"")+ ""String_Node_Str""+ options.get(""String_Node_Str"")+ options.get(""String_Node_Str"")+ query;
  _request=client.request((String)options.get(""String_Node_Str""),uri,new HttpClientResponseHandler());
  Map headers=(Map)options.get(""String_Node_Str"");
  if (!headers.isEmpty()) {
    for (    Object key : headers.keySet()) {
      Object value=headers.get(key);
      if (value instanceof String) {
        _request.putHeader((String)key,(String)value);
      }
 else       if (value instanceof Iterable) {
        _request.putHeader((String)key,(Iterable<String>)value);
      }
    }
  }
}","/** 
 * Private constructor to open an HTTP client.
 * @param currentObj The JavaScript instance of Socket that this helps.
 * @param address The URL of the WebSocket host with an optional port number(e.g. 'ws://localhost:8000'). If no port number is given, 80 is used.
 */
private HttpClientHelper(ScriptObjectMirror currentObj,Map<String,Object> options){
  super(currentObj);
  HttpClient client=_vertx.createHttpClient();
  client.setHost((String)options.get(""String_Node_Str""));
  client.setPort((int)options.get(""String_Node_Str""));
  client.exceptionHandler(new HttpClientExceptionHandler());
  if ((boolean)options.get(""String_Node_Str"")) {
    client.setKeepAlive(true);
  }
  String query=""String_Node_Str"";
  Object queryObject=options.get(""String_Node_Str"");
  if (queryObject != null) {
    String querySpec=queryObject.toString().trim();
    if (!querySpec.equals(""String_Node_Str"") && !querySpec.startsWith(""String_Node_Str"")) {
      query=""String_Node_Str"" + querySpec;
    }
  }
  String uri=options.get(""String_Node_Str"") + query;
  _request=client.request((String)options.get(""String_Node_Str""),uri,new HttpClientResponseHandler());
  Map headers=(Map)options.get(""String_Node_Str"");
  if (!headers.isEmpty()) {
    for (    Object key : headers.keySet()) {
      Object value=headers.get(key);
      if (value instanceof String) {
        _request.putHeader((String)key,(String)value);
      }
 else       if (value instanceof Iterable) {
        _request.putHeader((String)key,(Iterable<String>)value);
      }
    }
  }
}"
72503,"@Override public void handle(Buffer body){
synchronized (_actor) {
    _currentObj.callMember(""String_Node_Str"",_response,body.toString());
  }
}","public void handle(Buffer body){
  if (isText) {
    _currentObj.callMember(""String_Node_Str"",response,body.toString());
  }
 else   if (contentType.startsWith(""String_Node_Str"")) {
    InputStream stream=new ByteArrayInputStream(body.getBytes());
    try {
      Image image=ImageIO.read(stream);
      Token token=new AWTImageToken(image);
      _currentObj.callMember(""String_Node_Str"",response,token);
    }
 catch (    IOException e) {
      _currentObj.callMember(""String_Node_Str"",response,body.getBytes());
    }
  }
 else {
    _currentObj.callMember(""String_Node_Str"",response,body.getBytes());
  }
}"
72504,"/** 
 * Write a MoML description of this object, unless this object is not persistent. MoML is an XML modeling markup language. In this class, the object is identified by the ""property"" element, with ""name"" and ""class"" (XML) attributes. The body of the element, between the ""&lt;property&gt;"" and ""&lt;/property&gt;"", is written using the _exportMoMLContents() protected method, so that derived classes can override that method alone to alter only how the contents of this object are described. The text that is written is indented according to the specified depth, with each line (including the last one) terminated with a newline.
 * @param output The output stream to write to.
 * @param depth The depth in the hierarchy, to determine indenting.
 * @param name The name to use instead of the current name.
 * @exception IOException If an I/O error occurs.
 * @see #isPersistent()
 */
@Override public void exportMoML(Writer output,int depth,String name) throws IOException {
  if (_isMoMLSuppressed(depth)) {
    return;
  }
  String value=_currentExpression;
  if (value == null) {
    ptolemy.data.Token token=null;
    try {
      token=getToken();
    }
 catch (    IllegalActionException ex) {
    }
    if (token != null) {
      if (isStringMode()) {
        value=((StringToken)token).stringValue();
      }
 else {
        value=token.toString();
      }
    }
  }
  String valueTerm=""String_Node_Str"";
  if (value != null) {
    valueTerm=""String_Node_Str"" + StringUtilities.escapeForXML(value) + ""String_Node_Str"";
  }
  name=StringUtilities.escapeForXML(name);
  output.write(_getIndentPrefix(depth) + ""String_Node_Str"" + _elementName+ ""String_Node_Str""+ name+ ""String_Node_Str""+ getClassName()+ ""String_Node_Str""+ valueTerm+ ""String_Node_Str"");
  _exportMoMLContents(output,depth + 1);
  output.write(_getIndentPrefix(depth) + ""String_Node_Str"" + _elementName+ ""String_Node_Str"");
}","/** 
 * Write a MoML description of this object, unless this object is not persistent. MoML is an XML modeling markup language. In this class, the object is identified by the ""property"" element, with ""name"" and ""class"" (XML) attributes. The body of the element, between the ""&lt;property&gt;"" and ""&lt;/property&gt;"", is written using the _exportMoMLContents() protected method, so that derived classes can override that method alone to alter only how the contents of this object are described. The text that is written is indented according to the specified depth, with each line (including the last one) terminated with a newline.
 * @param output The output stream to write to.
 * @param depth The depth in the hierarchy, to determine indenting.
 * @param name The name to use instead of the current name.
 * @exception IOException If an I/O error occurs.
 * @see #isPersistent()
 */
@Override public void exportMoML(Writer output,int depth,String name) throws IOException {
  if (_isMoMLSuppressed(depth)) {
    return;
  }
  String value=_getCurrentExpression();
  if (value == null) {
    ptolemy.data.Token token=null;
    try {
      token=getToken();
    }
 catch (    IllegalActionException ex) {
    }
    if (token != null) {
      if (isStringMode()) {
        value=((StringToken)token).stringValue();
      }
 else {
        value=token.toString();
      }
    }
  }
  String valueTerm=""String_Node_Str"";
  if (value != null) {
    valueTerm=""String_Node_Str"" + StringUtilities.escapeForXML(value) + ""String_Node_Str"";
  }
  name=StringUtilities.escapeForXML(name);
  output.write(_getIndentPrefix(depth) + ""String_Node_Str"" + _elementName+ ""String_Node_Str""+ name+ ""String_Node_Str""+ getClassName()+ ""String_Node_Str""+ valueTerm+ ""String_Node_Str"");
  _exportMoMLContents(output,depth + 1);
  output.write(_getIndentPrefix(depth) + ""String_Node_Str"" + _elementName+ ""String_Node_Str"");
}"
72505,"@Override public void fire() throws IllegalActionException {
  super.fire();
  StringBuffer content=new StringBuffer(""String_Node_Str"");
  try {
    Parser htmlParser=Parser.htmlParser();
    htmlParser.setTrackErrors(1);
    BufferedReader reader=null;
    StringBuffer lineBuffer=new StringBuffer();
    try {
      reader=template.openForReading();
      String newlineValue=((StringToken)newline.getToken()).stringValue();
      while (true) {
        String line=reader.readLine();
        if (line == null) {
          break;
        }
        lineBuffer=lineBuffer.append(line);
        lineBuffer=lineBuffer.append(newlineValue);
      }
    }
 catch (    Throwable throwable) {
      throw new IllegalActionException(this,throwable,""String_Node_Str"" + template.getValueAsString() + ""String_Node_Str"");
    }
 finally {
      if (template != null) {
        template.close();
      }
    }
    _document=htmlParser.parseInput(lineBuffer.toString(),""String_Node_Str"");
    List<ParseError> errors=htmlParser.getErrors();
    if (errors != null && !errors.isEmpty()) {
      StringBuffer messages=new StringBuffer();
      for (      ParseError error : errors) {
        messages.append(error.toString());
      }
      throw new IllegalActionException(this,""String_Node_Str"" + template.getValueAsString() + ""String_Node_Str""+ messages);
    }
    _document.title(htmlTitle.stringValue().trim());
    List<TypedIOPort> portList=inputPortList();
    for (    TypedIOPort port : portList) {
      String id=port.getName();
      Elements elements=_document.select(""String_Node_Str"" + id);
      if (elements == null || elements.isEmpty()) {
        throw new IllegalActionException(this,""String_Node_Str"" + id + ""String_Node_Str"");
      }
      if (elements.size() > 1) {
        throw new IllegalActionException(this,""String_Node_Str"" + id + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      }
      for (int i=port.getWidth() - 1; i >= 0; i--) {
        Token token=port.get(i);
        StringBuffer htmlText=new StringBuffer();
        if (token instanceof ArrayToken) {
          ArrayToken array=(ArrayToken)token;
          Token[] lines=array.arrayValue();
          for (          Token line : lines) {
            htmlText.append(((StringToken)line).stringValue() + ""String_Node_Str"");
          }
        }
 else {
          htmlText.append(((StringToken)token).stringValue() + ""String_Node_Str"");
        }
        String testFragment=""String_Node_Str"" + htmlText.toString() + ""String_Node_Str"";
        htmlParser.parseInput(testFragment,""String_Node_Str"");
        errors=htmlParser.getErrors();
        if (errors != null && !errors.isEmpty()) {
          StringBuffer messages=new StringBuffer();
          for (          ParseError error : errors) {
            messages.append(error.toString());
          }
          throw new IllegalActionException(this,""String_Node_Str"" + htmlText.toString() + ""String_Node_Str""+ messages);
        }
        for (        Element element : elements) {
          element.html(htmlText.toString());
        }
      }
    }
    content=new StringBuffer(_document.html());
    if (content != null && content.length() > 0) {
      int startTagIndex=content.indexOf(""String_Node_Str"",0);
      int closeTagIndex=0;
      while (startTagIndex != -1) {
        closeTagIndex=content.indexOf(""String_Node_Str"",startTagIndex);
        content.deleteCharAt(closeTagIndex);
        startTagIndex=content.indexOf(""String_Node_Str"",startTagIndex + 1);
      }
    }
    output.broadcast(new StringToken(content.toString()));
    if (((BooleanToken)saveToFile.getToken()).booleanValue()) {
      outputFile.openForWriting().write(content.toString());
      outputFile.close();
    }
    template.close();
  }
 catch (  IOException e) {
    throw new IllegalActionException(this,e,""String_Node_Str"");
  }
}","@Override public void fire() throws IllegalActionException {
  super.fire();
  StringBuffer content=new StringBuffer(""String_Node_Str"");
  try {
    Parser htmlParser=Parser.htmlParser();
    htmlParser.setTrackErrors(1);
    BufferedReader reader=null;
    StringBuffer lineBuffer=new StringBuffer();
    try {
      reader=template.openForReading();
      String newlineValue=((StringToken)newline.getToken()).stringValue();
      while (true) {
        String line=reader.readLine();
        if (line == null) {
          break;
        }
        lineBuffer=lineBuffer.append(line);
        lineBuffer=lineBuffer.append(newlineValue);
      }
    }
 catch (    Throwable throwable) {
      throw new IllegalActionException(this,throwable,""String_Node_Str"" + template.getValueAsString() + ""String_Node_Str"");
    }
 finally {
      if (template != null) {
        template.close();
      }
    }
    _document=htmlParser.parseInput(lineBuffer.toString(),""String_Node_Str"");
    List<ParseError> errors=htmlParser.getErrors();
    if (errors != null && !errors.isEmpty()) {
      StringBuffer messages=new StringBuffer();
      for (      ParseError error : errors) {
        messages.append(error.toString());
      }
      throw new IllegalActionException(this,""String_Node_Str"" + template.getValueAsString() + ""String_Node_Str""+ messages);
    }
    _document.title(htmlTitle.stringValue().trim());
    List<TypedIOPort> portList=inputPortList();
    for (    TypedIOPort port : portList) {
      String id=port.getName();
      Elements elements=_document.select(""String_Node_Str"" + id);
      if (elements == null || elements.isEmpty()) {
        throw new IllegalActionException(this,""String_Node_Str"" + id + ""String_Node_Str"");
      }
      if (elements.size() > 1) {
        throw new IllegalActionException(this,""String_Node_Str"" + id + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      }
      for (int i=port.getWidth() - 1; i >= 0; i--) {
        Token token=port.get(i);
        StringBuffer htmlText=new StringBuffer();
        if (token instanceof ArrayToken) {
          ArrayToken array=(ArrayToken)token;
          Token[] lines=array.arrayValue();
          for (          Token line : lines) {
            htmlText.append(((StringToken)line).stringValue() + ""String_Node_Str"");
          }
        }
 else {
          htmlText.append(((StringToken)token).stringValue() + ""String_Node_Str"");
        }
        String testFragment=""String_Node_Str"" + htmlText.toString() + ""String_Node_Str"";
        htmlParser.parseInput(testFragment,""String_Node_Str"");
        errors=htmlParser.getErrors();
        if (errors != null && !errors.isEmpty()) {
          StringBuffer messages=new StringBuffer();
          for (          ParseError error : errors) {
            messages.append(error.toString());
          }
          throw new IllegalActionException(this,""String_Node_Str"" + htmlText.toString() + ""String_Node_Str""+ messages);
        }
        for (        Element element : elements) {
          element.html(htmlText.toString());
        }
      }
    }
    content=new StringBuffer(_document.html());
    if (content != null && content.length() > 0) {
      int startTagIndex=content.indexOf(""String_Node_Str"",0);
      int closeTagIndex=0;
      while (startTagIndex != -1) {
        closeTagIndex=content.indexOf(""String_Node_Str"",startTagIndex);
        if (closeTagIndex != -1) {
          content.deleteCharAt(closeTagIndex);
        }
        startTagIndex=content.indexOf(""String_Node_Str"",startTagIndex + 1);
      }
    }
    output.broadcast(new StringToken(content.toString()));
    if (((BooleanToken)saveToFile.getToken()).booleanValue()) {
      outputFile.openForWriting().write(content.toString());
      outputFile.close();
    }
    template.close();
  }
 catch (  IOException e) {
    throw new IllegalActionException(this,e,""String_Node_Str"");
  }
}"
72506,"/** 
 * Private constructor for WebSocketHelper to open a client-side web socket. Open an internal web socket using Vert.x.
 * @param currentObj The JavaScript instance of Socket that this helps.
 * @param address The URL of the WebSocket host with an optional port number(e.g. 'ws://localhost:8000'). If no port number is given, 80 is used.
 */
private HttpClientHelper(ScriptObjectMirror currentObj,Map<String,Object> options){
  _currentObj=currentObj;
  HttpClient client=_vertx.createHttpClient();
  client.setHost((String)options.get(""String_Node_Str""));
  client.setPort((int)options.get(""String_Node_Str""));
  client.exceptionHandler(new HttpClientExceptionHandler());
  if ((boolean)options.get(""String_Node_Str"")) {
    client.setKeepAlive(true);
  }
  String query=options.get(""String_Node_Str"").toString().trim();
  if (!query.equals(""String_Node_Str"") && !query.startsWith(""String_Node_Str"")) {
    query=""String_Node_Str"" + query;
  }
  String uri=options.get(""String_Node_Str"") + ""String_Node_Str"" + options.get(""String_Node_Str"")+ ""String_Node_Str""+ options.get(""String_Node_Str"")+ options.get(""String_Node_Str"")+ query;
  _request=client.request((String)options.get(""String_Node_Str""),uri,new HttpClientResponseHandler());
  Map headers=(Map)options.get(""String_Node_Str"");
  if (!headers.isEmpty()) {
    for (    Object key : headers.keySet()) {
      Object value=headers.get(key);
      if (value instanceof String) {
        _request.putHeader((String)key,(String)value);
      }
 else       if (value instanceof Iterable) {
        _request.putHeader((String)key,(Iterable<String>)value);
      }
    }
  }
}","/** 
 * Private constructor for WebSocketHelper to open a client-side web socket. Open an internal web socket using Vert.x.
 * @param currentObj The JavaScript instance of Socket that this helps.
 * @param address The URL of the WebSocket host with an optional port number(e.g. 'ws://localhost:8000'). If no port number is given, 80 is used.
 */
private HttpClientHelper(ScriptObjectMirror currentObj,Map<String,Object> options){
  _currentObj=currentObj;
  HttpClient client=_vertx.createHttpClient();
  client.setHost((String)options.get(""String_Node_Str""));
  client.setPort((int)options.get(""String_Node_Str""));
  client.exceptionHandler(new HttpClientExceptionHandler());
  if ((boolean)options.get(""String_Node_Str"")) {
    client.setKeepAlive(true);
  }
  String query=(String)options.get(""String_Node_Str"");
  if (query != null) {
    query.toString().trim();
  }
 else {
    query=""String_Node_Str"";
  }
  if (!query.equals(""String_Node_Str"") && !query.startsWith(""String_Node_Str"")) {
    query=""String_Node_Str"" + query;
  }
  String uri=options.get(""String_Node_Str"") + ""String_Node_Str"" + options.get(""String_Node_Str"")+ ""String_Node_Str""+ options.get(""String_Node_Str"")+ options.get(""String_Node_Str"")+ query;
  _request=client.request((String)options.get(""String_Node_Str""),uri,new HttpClientResponseHandler());
  Map headers=(Map)options.get(""String_Node_Str"");
  if (!headers.isEmpty()) {
    for (    Object key : headers.keySet()) {
      Object value=headers.get(key);
      if (value instanceof String) {
        _request.putHeader((String)key,(String)value);
      }
 else       if (value instanceof Iterable) {
        _request.putHeader((String)key,(Iterable<String>)value);
      }
    }
  }
}"
72507,"/** 
 * Expose the send() method of the port.
 * @param channelIndex The channel index.
 * @param data The token to send.
 * @throws IllegalActionException If this is a proxy for a parameter or if sending fails.
 * @throws NoRoomException If there is no room at the destination.
 */
public void send(int channelIndex,Token data) throws NoRoomException, IllegalActionException {
  if (_port == null) {
    throw new IllegalActionException(JavaScript.this,""String_Node_Str"" + _parameter.getName() + ""String_Node_Str"");
  }
  if (!_executing) {
    throw new InternalErrorException(""String_Node_Str"" + data + ""String_Node_Str""+ _port.getName()+ ""String_Node_Str"");
  }
synchronized (JavaScript.this) {
    if (!_port.isOutput()) {
      if (!_port.isInput()) {
        throw new IllegalActionException(JavaScript.this,""String_Node_Str"");
      }
      if (_localInputTokens == null) {
        _localInputTokens=new LinkedList<Token>();
      }
      _localInputTokens.add(data);
      _fireAtCurrentTime();
    }
 else     if (_inFire) {
      if (_debugging) {
        _debug(""String_Node_Str"" + data + ""String_Node_Str""+ _port.getName());
      }
      _port.send(channelIndex,data);
    }
 else {
      if (_outputTokens == null) {
        _outputTokens=new HashMap<IOPort,HashMap<Integer,List<Token>>>();
      }
      HashMap<Integer,List<Token>> tokens=_outputTokens.get(_port);
      if (tokens == null) {
        tokens=new HashMap<Integer,List<Token>>();
        _outputTokens.put(_port,tokens);
      }
      List<Token> queue=tokens.get(channelIndex);
      if (queue == null) {
        queue=new LinkedList<Token>();
        tokens.put(channelIndex,queue);
      }
      queue.add(data);
      if (_debugging) {
        _debug(""String_Node_Str"" + data + ""String_Node_Str""+ _port.getName()+ ""String_Node_Str"");
      }
      getDirector().fireAtCurrentTime(JavaScript.this);
    }
  }
}","/** 
 * Expose the send() method of the port.
 * @param channelIndex The channel index.
 * @param data The token to send.
 * @throws IllegalActionException If this is a proxy for a parameter or if sending fails.
 * @throws NoRoomException If there is no room at the destination.
 */
public void send(int channelIndex,Token data) throws NoRoomException, IllegalActionException {
  if (_port == null) {
    throw new IllegalActionException(JavaScript.this,""String_Node_Str"" + _parameter.getName() + ""String_Node_Str"");
  }
  if (getManager().getState() == ptolemy.actor.Manager.WRAPPING_UP) {
    System.err.println(""String_Node_Str"" + data);
    return;
  }
synchronized (JavaScript.this) {
    if (!_executing) {
      throw new InternalErrorException(""String_Node_Str"" + data + ""String_Node_Str""+ _port.getName()+ ""String_Node_Str"");
    }
    if (!_port.isOutput()) {
      if (!_port.isInput()) {
        throw new IllegalActionException(JavaScript.this,""String_Node_Str"");
      }
      if (_localInputTokens == null) {
        _localInputTokens=new LinkedList<Token>();
      }
      _localInputTokens.add(data);
      _fireAtCurrentTime();
    }
 else     if (_inFire) {
      if (_debugging) {
        _debug(""String_Node_Str"" + data + ""String_Node_Str""+ _port.getName());
      }
      _port.send(channelIndex,data);
    }
 else {
      if (_outputTokens == null) {
        _outputTokens=new HashMap<IOPort,HashMap<Integer,List<Token>>>();
      }
      HashMap<Integer,List<Token>> tokens=_outputTokens.get(_port);
      if (tokens == null) {
        tokens=new HashMap<Integer,List<Token>>();
        _outputTokens.put(_port,tokens);
      }
      List<Token> queue=tokens.get(channelIndex);
      if (queue == null) {
        queue=new LinkedList<Token>();
        tokens.put(channelIndex,queue);
      }
      queue.add(data);
      if (_debugging) {
        _debug(""String_Node_Str"" + data + ""String_Node_Str""+ _port.getName()+ ""String_Node_Str"");
      }
      getDirector().fireAtCurrentTime(JavaScript.this);
    }
  }
}"
72508,"/** 
 * Close the web socket.
 */
public synchronized void close(){
  if (_webSocket != null) {
    if (_wsIsOpen) {
      _webSocket.close();
    }
    _webSocket=null;
  }
  if (_pendingOutputs != null && _pendingOutputs.size() > 0) {
    _currentObj.callMember(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
}","/** 
 * Close the web socket.
 */
public synchronized void close(){
  new Exception(""String_Node_Str"").printStackTrace();
  if (_webSocket != null) {
    if (_wsIsOpen) {
      try {
        _webSocket.close();
      }
 catch (      IllegalStateException ex) {
      }
    }
    _webSocket=null;
  }
  if (_pendingOutputs != null && _pendingOutputs.size() > 0) {
    _currentObj.callMember(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
}"
72509,"/** 
 * Trigger quantization-events if necessary. <p>Update the external, quantized state models.</p>
 * @param currentTime The current simulation time.
 * @param forceAll If true, requantize all state models.
 */
private final void _triggerQuantizationEvents(final Time currentTime,final boolean forceAll) throws IllegalActionException {
  final int stateCt=_qssSolver.getStateCount();
  if (_debugging) {
    _debugToStdOut(String.format(""String_Node_Str"",System.identityHashCode(this),currentTime.toString()));
  }
  int qIdx=-1;
  while (true) {
    if (forceAll) {
      qIdx++;
      if (qIdx >= stateCt) {
        break;
      }
    }
 else {
      qIdx=_qssSolver.needQuantizationEventIndex();
      if (qIdx < 0) {
        break;
      }
    }
    _qssSolver.triggerQuantizationEvent(qIdx);
    final TypedIOPort outPort=_fmiModelDescription.continuousStates.get(qIdx).port;
    _sendModelToPort(_qssSolver.getStateModel(qIdx).coeffs,outPort,currentTime);
    if (_debugging) {
      _debugToStdOut(String.format(""String_Node_Str"",System.identityHashCode(this),qIdx,_qssSolver.getStateModel(qIdx).toString()));
    }
  }
  _produceOutputs(currentTime);
}","/** 
 * Trigger quantization-events if necessary. <p>Update the external, quantized state models.</p>
 * @param currentTime The current simulation time.
 * @param forceAll If true, requantize all state models.
 */
private final void _triggerQuantizationEvents(final Time currentTime,final boolean forceAll) throws IllegalActionException {
  final int stateCt=_qssSolver.getStateCount();
  List<Boolean> needQuantizationEvents=new LinkedList<Boolean>();
  if (_debugging) {
    _debugToStdOut(String.format(""String_Node_Str"",System.identityHashCode(this),currentTime.toString()));
  }
  int qIdx=-1;
  while (true) {
    if (forceAll) {
      qIdx++;
      if (qIdx >= stateCt) {
        break;
      }
    }
 else {
      qIdx=_qssSolver.needQuantizationEventIndex();
      if (qIdx < 0) {
        break;
      }
    }
    _qssSolver.triggerQuantizationEvent(qIdx);
    final TypedIOPort outPort=_fmiModelDescription.continuousStates.get(qIdx).port;
    needQuantizationEvents.add(true);
    _sendModelToPort(_qssSolver.getStateModel(qIdx).coeffs,outPort,currentTime);
    if (_debugging) {
      _debugToStdOut(String.format(""String_Node_Str"",System.identityHashCode(this),qIdx,_qssSolver.getStateModel(qIdx).toString()));
    }
  }
  final double[] stateVariables=new double[stateCt];
  if (_firstRound || needQuantizationEvents.contains(true)) {
    for (int i=0; i < stateCt; i++) {
      stateVariables[i]=_qssSolver.getStateModel(i).coeffs[0];
    }
    _fmiSetContinuousStates(stateVariables);
  }
  _produceOutputs(currentTime);
}"
72510,"/** 
 * Initialize the   {@link PtolemyFederateAmbassadorInner} which handlesthe communication from RTI -> to RTIA -> to FEDERATE. The <i>rtia</i> manages the interaction with the external communicant process RTIA. This method called the Declaration Management services provide by HLA/CERTI to publish/subscribe to HLA attributes in a HLA Federation.
 * @param rtia
 * @throws NameNotFound
 * @throws ObjectClassNotDefined
 * @throws FederateNotExecutionMember
 * @throws RTIinternalError
 * @throws AttributeNotDefined
 * @throws SaveInProgress
 * @throws RestoreInProgress
 * @throws ConcurrentAccessAttempted All those exceptions are from the HLA/CERTI implementation.
 */
public void initialize(RTIambassador rtia) throws NameNotFound, ObjectClassNotDefined, FederateNotExecutionMember, RTIinternalError, AttributeNotDefined, SaveInProgress, RestoreInProgress, ConcurrentAccessAttempted {
  this.timeAdvanceGrant=false;
  this.timeConstrained=false;
  this.timeRegulator=false;
  this.synchronizationSuccess=false;
  this.synchronizationFailed=false;
  this.inPause=false;
  setUpHlaPublisher(rtia);
  setUpHLASubscriber(rtia);
}","/** 
 * Initialize the   {@link PtolemyFederateAmbassadorInner} which handlesthe communication from RTI -> to RTIA -> to FEDERATE. The <i>rtia</i> manages the interaction with the external communicant process RTIA. This method called the Declaration Management services provide by HLA/CERTI to publish/subscribe to HLA attributes in a HLA Federation.
 * @param rtia
 * @throws NameNotFound
 * @throws ObjectClassNotDefined
 * @throws FederateNotExecutionMember
 * @throws RTIinternalError
 * @throws AttributeNotDefined
 * @throws SaveInProgress
 * @throws RestoreInProgress
 * @throws ConcurrentAccessAttempted All those exceptions are from the HLA/CERTI implementation.
 */
public void initialize(RTIambassador rtia) throws NameNotFound, ObjectClassNotDefined, FederateNotExecutionMember, RTIinternalError, AttributeNotDefined, SaveInProgress, RestoreInProgress, ConcurrentAccessAttempted {
  this.timeAdvanceGrant=false;
  this.timeConstrained=false;
  this.timeRegulator=false;
  this.synchronizationSuccess=false;
  this.synchronizationFailed=false;
  this.inPause=false;
  setUpHlaPublisher(rtia);
  setUpSubscription(rtia);
}"
72511,"/** 
 * Propose a time to advance to. This method is the one implementing the TimeRegulator interface and using the HLA/CERTI Time Management services (if required). Following HLA and CERTI recommendations, if the Time Management is required then we have the following behavior: Case 1: If lookahead = 0 -a) if time-stepped Federate, then the timeAdvanceRequestAvailable() (TARA) service is used; -b) if event-based Federate, then the nextEventRequestAvailable() (NERA) service is used Case 2: If lookahead > 0 -c) if time-stepped Federate, then timeAdvanceRequest() (TAR) is used; -d) if event-based Federate, then the nextEventRequest() (NER) is used; Otherwise the proposedTime is returned. NOTE: For the Ptolemy II - HLA/CERTI cooperation the default (and correct) behavior is the case 1 and CERTI has to be compiled with the option ""CERTI_USE_NULL_PRIME_MESSAGE_PROTOCOL"".
 * @param proposedTime The proposed time.
 * @return The proposed time or a smaller time.
 * @exception IllegalActionException If this attribute is notcontained by an Actor.
 */
@Override public Time proposeTime(Time proposedTime) throws IllegalActionException {
  Time breakpoint=null;
  if (_rtia == null) {
    if (_debugging) {
      _debug(this.getDisplayName() + ""String_Node_Str"" + ""String_Node_Str"");
    }
    return proposedTime;
  }
  if (_isTimeRegulator && _isTimeConstrained) {
synchronized (this) {
      CertiLogicalTime certiProposedTime=new CertiLogicalTime(proposedTime.getDoubleValue());
      try {
        if (_eventBased) {
          if (_hlaLookAHead > 0) {
            if (_debugging) {
              _debug(this.getDisplayName() + ""String_Node_Str"" + ""String_Node_Str""+ certiProposedTime.getTime()+ ""String_Node_Str"");
            }
            _rtia.nextEventRequest(certiProposedTime);
          }
 else {
            if (_debugging) {
              _debug(this.getDisplayName() + ""String_Node_Str"" + ""String_Node_Str""+ certiProposedTime.getTime()+ ""String_Node_Str"");
            }
            _rtia.nextEventRequestAvailable(certiProposedTime);
            _federateAmbassador.timeAdvanceGrant=false;
            while (!(_federateAmbassador.timeAdvanceGrant)) {
              if (_debugging) {
                _debug(this.getDisplayName() + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ certiProposedTime.getTime()+ ""String_Node_Str"");
              }
              try {
                _rtia.tick2();
              }
 catch (              RTIexception e) {
                throw new IllegalActionException(this,e,e.getMessage());
              }
            }
            if (_debugging) {
              _debug(this.getDisplayName() + ""String_Node_Str"" + ""String_Node_Str""+ certiProposedTime.getTime()+ ""String_Node_Str"");
            }
            _rtia.nextEventRequest(certiProposedTime);
          }
        }
 else {
          if (_hlaLookAHead > 0) {
            if (_debugging) {
              _debug(this.getDisplayName() + ""String_Node_Str"" + ""String_Node_Str""+ certiProposedTime.getTime()+ ""String_Node_Str"");
            }
            _rtia.timeAdvanceRequest(certiProposedTime);
          }
 else {
            if (_debugging) {
              _debug(this.getDisplayName() + ""String_Node_Str"" + ""String_Node_Str""+ certiProposedTime.getTime()+ ""String_Node_Str"");
            }
            _rtia.timeAdvanceRequestAvailable(certiProposedTime);
            _federateAmbassador.timeAdvanceGrant=false;
            while (!(_federateAmbassador.timeAdvanceGrant)) {
              if (_debugging) {
                _debug(this.getDisplayName() + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ certiProposedTime.getTime()+ ""String_Node_Str"");
              }
              try {
                _rtia.tick2();
              }
 catch (              SpecifiedSaveLabelDoesNotExist e) {
                throw new IllegalActionException(this,e,""String_Node_Str"");
              }
catch (              ConcurrentAccessAttempted e) {
                throw new IllegalActionException(this,e,""String_Node_Str"");
              }
catch (              RTIinternalError e) {
                throw new IllegalActionException(this,e,""String_Node_Str"");
              }
            }
            if (_debugging) {
              _debug(this.getDisplayName() + ""String_Node_Str"" + ""String_Node_Str""+ certiProposedTime.getTime()+ ""String_Node_Str"");
            }
            _rtia.timeAdvanceRequest(certiProposedTime);
          }
        }
      }
 catch (      InvalidFederationTime e) {
        throw new IllegalActionException(this,e,""String_Node_Str"");
      }
catch (      FederationTimeAlreadyPassed e) {
        throw new IllegalActionException(this,e,""String_Node_Str"");
      }
catch (      TimeAdvanceAlreadyInProgress e) {
        throw new IllegalActionException(this,e,""String_Node_Str"");
      }
catch (      EnableTimeRegulationPending e) {
        throw new IllegalActionException(this,e,""String_Node_Str"");
      }
catch (      EnableTimeConstrainedPending e) {
        throw new IllegalActionException(this,e,""String_Node_Str"");
      }
catch (      FederateNotExecutionMember e) {
        throw new IllegalActionException(this,e,""String_Node_Str"");
      }
catch (      SaveInProgress e) {
        throw new IllegalActionException(this,e,""String_Node_Str"");
      }
catch (      RestoreInProgress e) {
        throw new IllegalActionException(this,e,""String_Node_Str"");
      }
catch (      RTIinternalError e) {
        throw new IllegalActionException(this,e,""String_Node_Str"");
      }
catch (      ConcurrentAccessAttempted e) {
        throw new IllegalActionException(this,e,""String_Node_Str"");
      }
catch (      NoSuchElementException e) {
        if (_debugging) {
          _debug(this.getDisplayName() + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
        }
        return proposedTime;
      }
      _federateAmbassador.timeAdvanceGrant=false;
      while (!(_federateAmbassador.timeAdvanceGrant)) {
        if (_debugging) {
          _debug(this.getDisplayName() + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ certiProposedTime.getTime()+ ""String_Node_Str"");
        }
        try {
          _rtia.tick2();
        }
 catch (        RTIexception e) {
          throw new IllegalActionException(this,e,e.getMessage());
        }
      }
      try {
        breakpoint=new Time(_director,((CertiLogicalTime)_federateAmbassador.logicalTimeHLA).getTime());
      }
 catch (      IllegalActionException e) {
        throw new IllegalActionException(this,e,""String_Node_Str"");
      }
      _putReflectedAttributesOnHlaSubscribers();
    }
  }
  return breakpoint;
}","/** 
 * Propose a time to advance to. This method is the one implementing the TimeRegulator interface and using the HLA/CERTI Time Management services (if required). Following HLA and CERTI recommendations, if the Time Management is required then we have the following behavior: Case 1: If lookahead = 0 -a) if time-stepped Federate, then the timeAdvanceRequestAvailable() (TARA) service is used; -b) if event-based Federate, then the nextEventRequestAvailable() (NERA) service is used Case 2: If lookahead > 0 -c) if time-stepped Federate, then timeAdvanceRequest() (TAR) is used; -d) if event-based Federate, then the nextEventRequest() (NER) is used; Otherwise the proposedTime is returned. NOTE: For the Ptolemy II - HLA/CERTI cooperation the default (and correct) behavior is the case 1 and CERTI has to be compiled with the option ""CERTI_USE_NULL_PRIME_MESSAGE_PROTOCOL"".
 * @param proposedTime The proposed time.
 * @return The proposed time or a smaller time.
 * @exception IllegalActionException If this attribute is notcontained by an Actor.
 */
@Override public Time proposeTime(Time proposedTime) throws IllegalActionException {
  Time breakpoint=null;
  if (_rtia == null) {
    if (_debugging) {
      _debug(this.getDisplayName() + ""String_Node_Str"" + ""String_Node_Str"");
    }
    return proposedTime;
  }
  if (_lastProposedTime != null) {
    if (_lastProposedTime.compareTo(proposedTime) == 0) {
      try {
        _rtia.tick();
      }
 catch (      ConcurrentAccessAttempted e) {
        throw new IllegalActionException(this,e,""String_Node_Str"");
      }
catch (      RTIinternalError e) {
        throw new IllegalActionException(this,e,""String_Node_Str"");
      }
      return _lastProposedTime;
    }
  }
  if (_isTimeRegulator && _isTimeConstrained) {
synchronized (this) {
      CertiLogicalTime certiProposedTime=new CertiLogicalTime(proposedTime.getDoubleValue());
      try {
        if (_eventBased) {
          if (_hlaLookAHead > 0) {
            if (_debugging) {
              _debug(this.getDisplayName() + ""String_Node_Str"" + ""String_Node_Str""+ certiProposedTime.getTime()+ ""String_Node_Str"");
            }
            _rtia.nextEventRequest(certiProposedTime);
          }
 else {
            if (_debugging) {
              _debug(this.getDisplayName() + ""String_Node_Str"" + ""String_Node_Str""+ certiProposedTime.getTime()+ ""String_Node_Str"");
            }
            _rtia.nextEventRequestAvailable(certiProposedTime);
            _federateAmbassador.timeAdvanceGrant=false;
            while (!(_federateAmbassador.timeAdvanceGrant)) {
              if (_debugging) {
                _debug(this.getDisplayName() + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ certiProposedTime.getTime()+ ""String_Node_Str"");
              }
              try {
                _rtia.tick2();
              }
 catch (              RTIexception e) {
                throw new IllegalActionException(this,e,e.getMessage());
              }
            }
            if (_debugging) {
              _debug(this.getDisplayName() + ""String_Node_Str"" + ""String_Node_Str""+ certiProposedTime.getTime()+ ""String_Node_Str"");
            }
            _rtia.nextEventRequest(certiProposedTime);
          }
        }
 else {
          if (_hlaLookAHead > 0) {
            if (_debugging) {
              _debug(this.getDisplayName() + ""String_Node_Str"" + ""String_Node_Str""+ certiProposedTime.getTime()+ ""String_Node_Str"");
            }
            _rtia.timeAdvanceRequest(certiProposedTime);
          }
 else {
            if (_debugging) {
              _debug(this.getDisplayName() + ""String_Node_Str"" + ""String_Node_Str""+ certiProposedTime.getTime()+ ""String_Node_Str"");
            }
            _rtia.timeAdvanceRequestAvailable(certiProposedTime);
            _federateAmbassador.timeAdvanceGrant=false;
            while (!(_federateAmbassador.timeAdvanceGrant)) {
              if (_debugging) {
                _debug(this.getDisplayName() + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ certiProposedTime.getTime()+ ""String_Node_Str"");
              }
              try {
                _rtia.tick2();
              }
 catch (              SpecifiedSaveLabelDoesNotExist e) {
                throw new IllegalActionException(this,e,""String_Node_Str"");
              }
catch (              ConcurrentAccessAttempted e) {
                throw new IllegalActionException(this,e,""String_Node_Str"");
              }
catch (              RTIinternalError e) {
                throw new IllegalActionException(this,e,""String_Node_Str"");
              }
            }
            if (_debugging) {
              _debug(this.getDisplayName() + ""String_Node_Str"" + ""String_Node_Str""+ certiProposedTime.getTime()+ ""String_Node_Str"");
            }
            _rtia.timeAdvanceRequest(certiProposedTime);
          }
        }
      }
 catch (      InvalidFederationTime e) {
        throw new IllegalActionException(this,e,""String_Node_Str"");
      }
catch (      FederationTimeAlreadyPassed e) {
        throw new IllegalActionException(this,e,""String_Node_Str"");
      }
catch (      TimeAdvanceAlreadyInProgress e) {
        throw new IllegalActionException(this,e,""String_Node_Str"");
      }
catch (      EnableTimeRegulationPending e) {
        throw new IllegalActionException(this,e,""String_Node_Str"");
      }
catch (      EnableTimeConstrainedPending e) {
        throw new IllegalActionException(this,e,""String_Node_Str"");
      }
catch (      FederateNotExecutionMember e) {
        throw new IllegalActionException(this,e,""String_Node_Str"");
      }
catch (      SaveInProgress e) {
        throw new IllegalActionException(this,e,""String_Node_Str"");
      }
catch (      RestoreInProgress e) {
        throw new IllegalActionException(this,e,""String_Node_Str"");
      }
catch (      RTIinternalError e) {
        throw new IllegalActionException(this,e,""String_Node_Str"");
      }
catch (      ConcurrentAccessAttempted e) {
        throw new IllegalActionException(this,e,""String_Node_Str"");
      }
catch (      NoSuchElementException e) {
        if (_debugging) {
          _debug(this.getDisplayName() + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
        }
        return proposedTime;
      }
      _federateAmbassador.timeAdvanceGrant=false;
      while (!(_federateAmbassador.timeAdvanceGrant)) {
        if (_debugging) {
          _debug(this.getDisplayName() + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ certiProposedTime.getTime()+ ""String_Node_Str"");
        }
        try {
          _rtia.tick2();
        }
 catch (        RTIexception e) {
          throw new IllegalActionException(this,e,e.getMessage());
        }
      }
      try {
        breakpoint=new Time(_director,((CertiLogicalTime)_federateAmbassador.logicalTimeHLA).getTime());
      }
 catch (      IllegalActionException e) {
        throw new IllegalActionException(this,e,""String_Node_Str"");
      }
      _putReflectedAttributesOnHlaSubscribers();
    }
  }
  _lastProposedTime=breakpoint;
  return breakpoint;
}"
72512,"/** 
 * Manage the correct termination of the   {@link HlaManager}. Call the HLA services to: unsubscribe to HLA attributes, unpublish HLA attributes, resign a Federation and destroy a Federation if the current Federate is the last participant.
 * @throws IllegalActionException If the parent class throws itof if a CERTI exception is raised then displayed it to the user.
 */
@Override public void wrapup() throws IllegalActionException {
  super.wrapup();
  _strucuralInformation.clear();
  if (_debugging) {
    _debug(this.getDisplayName() + ""String_Node_Str"");
  }
  for (  Object[] obj : _hlaAttributesSubscribedTo.values()) {
    try {
      _rtia.unsubscribeObjectClass(_getClassHandleFromTab(obj));
    }
 catch (    RTIexception e) {
      throw new IllegalActionException(this,e,e.getMessage());
    }
    if (_debugging) {
      _debug(this.getDisplayName() + ""String_Node_Str"" + _getPortFromTab(obj).getContainer().getName()+ ""String_Node_Str""+ _getClassHandleFromTab(obj)+ ""String_Node_Str"");
    }
  }
  for (  Object[] obj : _hlaAttributesToPublish.values()) {
    try {
      _rtia.unpublishObjectClass(_getClassHandleFromTab(obj));
    }
 catch (    RTIexception e) {
      throw new IllegalActionException(this,e,e.getMessage());
    }
    if (_debugging) {
      _debug(this.getDisplayName() + ""String_Node_Str"" + _getPortFromTab(obj).getContainer().getName()+ ""String_Node_Str""+ _getClassHandleFromTab(obj)+ ""String_Node_Str"");
    }
  }
  try {
    _rtia.resignFederationExecution(ResignAction.DELETE_OBJECTS_AND_RELEASE_ATTRIBUTES);
  }
 catch (  RTIexception e) {
    throw new IllegalActionException(this,e,e.getMessage());
  }
  if (_debugging) {
    _debug(this.getDisplayName() + ""String_Node_Str"");
  }
  boolean canDestroyRtig=false;
  while (!canDestroyRtig) {
    try {
      _rtia.destroyFederationExecution(_federationName);
    }
 catch (    FederatesCurrentlyJoined e) {
      if (_debugging) {
        _debug(this.getDisplayName() + ""String_Node_Str"");
      }
    }
catch (    FederationExecutionDoesNotExist e) {
      if (_debugging) {
        _debug(this.getDisplayName() + ""String_Node_Str"");
      }
      canDestroyRtig=true;
    }
catch (    RTIinternalError e) {
      throw new IllegalActionException(this,e,""String_Node_Str"");
    }
catch (    ConcurrentAccessAttempted e) {
      throw new IllegalActionException(this,e,""String_Node_Str"");
    }
    if (_debugging) {
      _debug(this.getDisplayName() + ""String_Node_Str"" + ""String_Node_Str"");
    }
    canDestroyRtig=true;
  }
  if (_certiRtig != null) {
    _certiRtig.terminateProcess();
    if (_debugging) {
      _debug(this.getDisplayName() + ""String_Node_Str"" + ""String_Node_Str"");
    }
  }
  _hlaAttributesToPublish.clear();
  _hlaAttributesSubscribedTo.clear();
  _fromFederationEvents.clear();
  _objectIdToClassHandle.clear();
}","/** 
 * Manage the correct termination of the   {@link HlaManager}. Call the HLA services to: unsubscribe to HLA attributes, unpublish HLA attributes, resign a Federation and destroy a Federation if the current Federate is the last participant.
 * @throws IllegalActionException If the parent class throws itof if a CERTI exception is raised then displayed it to the user.
 */
@Override public void wrapup() throws IllegalActionException {
  super.wrapup();
  _strucuralInformation.clear();
  _registeredObject.clear();
  if (_debugging) {
    _debug(this.getDisplayName() + ""String_Node_Str"");
  }
  for (  Object[] obj : _hlaAttributesSubscribedTo.values()) {
    try {
      _rtia.unsubscribeObjectClass(_getClassHandleFromTab(obj));
    }
 catch (    RTIexception e) {
      throw new IllegalActionException(this,e,e.getMessage());
    }
    if (_debugging) {
      _debug(this.getDisplayName() + ""String_Node_Str"" + _getPortFromTab(obj).getContainer().getName()+ ""String_Node_Str""+ _getClassHandleFromTab(obj)+ ""String_Node_Str"");
    }
  }
  for (  Object[] obj : _hlaAttributesToPublish.values()) {
    try {
      _rtia.unpublishObjectClass(_getClassHandleFromTab(obj));
    }
 catch (    RTIexception e) {
      throw new IllegalActionException(this,e,e.getMessage());
    }
    if (_debugging) {
      _debug(this.getDisplayName() + ""String_Node_Str"" + _getPortFromTab(obj).getContainer().getName()+ ""String_Node_Str""+ _getClassHandleFromTab(obj)+ ""String_Node_Str"");
    }
  }
  try {
    _rtia.resignFederationExecution(ResignAction.DELETE_OBJECTS_AND_RELEASE_ATTRIBUTES);
  }
 catch (  RTIexception e) {
    throw new IllegalActionException(this,e,e.getMessage());
  }
  if (_debugging) {
    _debug(this.getDisplayName() + ""String_Node_Str"");
  }
  boolean canDestroyRtig=false;
  while (!canDestroyRtig) {
    try {
      _rtia.destroyFederationExecution(_federationName);
    }
 catch (    FederatesCurrentlyJoined e) {
      if (_debugging) {
        _debug(this.getDisplayName() + ""String_Node_Str"");
      }
    }
catch (    FederationExecutionDoesNotExist e) {
      if (_debugging) {
        _debug(this.getDisplayName() + ""String_Node_Str"");
      }
      canDestroyRtig=true;
    }
catch (    RTIinternalError e) {
      throw new IllegalActionException(this,e,""String_Node_Str"");
    }
catch (    ConcurrentAccessAttempted e) {
      throw new IllegalActionException(this,e,""String_Node_Str"");
    }
    if (_debugging) {
      _debug(this.getDisplayName() + ""String_Node_Str"" + ""String_Node_Str"");
    }
    canDestroyRtig=true;
  }
  if (_certiRtig != null) {
    _certiRtig.terminateProcess();
    if (_debugging) {
      _debug(this.getDisplayName() + ""String_Node_Str"" + ""String_Node_Str"");
    }
  }
  _hlaAttributesToPublish.clear();
  _hlaAttributesSubscribedTo.clear();
  _fromFederationEvents.clear();
  _objectIdToClassHandle.clear();
}"
72513,"/** 
 * Callback delivered by the RTI (CERTI) to discover attribute instance of HLA attribute that the Federate is subscribed to.
 */
@Override public void discoverObjectInstance(int objectHandle,final int classHandle,final String objectName) throws CouldNotDiscover, ObjectClassNotKnown, FederateInternalError {
  _objectIdToClassHandle.put(objectHandle,classHandle);
  final CompositeActor classToInstantiate=(CompositeActor)_strucuralInformation.get(classHandle).classToInstantiate;
  ChangeRequest request=new ChangeRequest(this,""String_Node_Str"" + objectName,true){
    @Override protected void _execute() throws IllegalActionException {
      CompositeActor container=(CompositeActor)classToInstantiate.getContainer();
      CompositeActor newActor=null;
      try {
        Instantiable instance=null;
        StructuralInformation info=_strucuralInformation.get(classHandle);
        LinkedList<ComponentEntity> actors=info.freeActors;
        if (actors.size() == 0) {
          instance=classToInstantiate.instantiate(container,objectName);
          newActor=(CompositeActor)instance;
          LinkedList<IOPort> outputPortList=(LinkedList<IOPort>)newActor.outputPortList();
          Iterator i=outputPortList.iterator();
          container.notifyConnectivityChange();
          for (          IOPort out : outputPortList) {
            ComponentRelation r=null;
            for (            IOPort recv : info.relations.get(out.getName())) {
              if (r == null) {
                r=container.connect(out,recv,objectName + ""String_Node_Str"" + out.getName());
              }
 else {
                recv.link(r);
              }
            }
          }
          if (_debugging) {
            _debug(""String_Node_Str"" + objectName);
          }
          _newlyCreated.add(instance);
        }
 else {
          instance=actors.poll();
          newActor=(CompositeActor)instance;
          newActor.setDisplayName(objectName);
          if (_debugging) {
            _debug(instance.getName() + ""String_Node_Str"" + objectName);
          }
        }
        List<HlaSubscriber> subscribers=newActor.entityList(HlaSubscriber.class);
        for (int i=0; i < subscribers.size(); ++i) {
          HlaSubscriber sub=subscribers.get(i);
          sub.objectName.setExpression(""String_Node_Str"" + objectName + ""String_Node_Str"");
          ;
          sub.setObjectHandle(objectHandle);
          _hlaAttributesSubscribedTo.put(sub.getIdentity(),new Object[]{sub.output,sub.output.getType(),""String_Node_Str"",classHandle,sub.getAttributeHandle()});
          _fromFederationEvents.put(sub.getIdentity(),new LinkedList<TimedEvent>());
        }
      }
 catch (      NameDuplicationException|CloneNotSupportedException ex) {
        ex.printStackTrace();
      }
    }
  }
;
  request.setPersistent(false);
  String toLog=HlaManager.this.getDisplayName() + ""String_Node_Str"" + ""String_Node_Str""+ objectName+ ""String_Node_Str""+ ""String_Node_Str""+ objectHandle+ ""String_Node_Str""+ classHandle+ ""String_Node_Str"";
  if (classToInstantiate != null) {
    requestChange(request);
  }
 else {
    toLog+=""String_Node_Str"";
  }
  if (_debugging) {
    _debug(toLog);
  }
}","/** 
 * Callback delivered by the RTI (CERTI) to discover attribute instance of HLA attribute that the Federate is subscribed to.
 */
@Override public void discoverObjectInstance(int objectHandle_,int classHandle_,String objectName_) throws CouldNotDiscover, ObjectClassNotKnown, FederateInternalError {
  final int classHandle=classHandle_;
  final String objectName=objectName_;
  final int objectHandle=objectHandle_;
  _objectIdToClassHandle.put(objectHandle,classHandle);
  final CompositeActor classToInstantiate=(CompositeActor)_strucuralInformation.get(classHandle).classToInstantiate;
  ChangeRequest request=new ChangeRequest(this,""String_Node_Str"" + objectName,true){
    @Override protected void _execute() throws IllegalActionException {
      CompositeActor container=(CompositeActor)classToInstantiate.getContainer();
      CompositeActor newActor=null;
      try {
        Instantiable instance=null;
        StructuralInformation info=_strucuralInformation.get(classHandle);
        LinkedList<ComponentEntity> actors=info.freeActors;
        if (actors.size() == 0) {
          instance=classToInstantiate.instantiate(container,objectName);
          newActor=(CompositeActor)instance;
          LinkedList<IOPort> outputPortList=(LinkedList<IOPort>)newActor.outputPortList();
          Iterator i=outputPortList.iterator();
          container.notifyConnectivityChange();
          for (          IOPort out : outputPortList) {
            ComponentRelation r=null;
            for (            IOPort recv : info.relations.get(out.getName())) {
              if (r == null) {
                r=container.connect(out,recv,objectName + ""String_Node_Str"" + out.getName());
              }
 else {
                recv.link(r);
              }
            }
          }
          if (_debugging) {
            _debug(""String_Node_Str"" + objectName);
          }
          _newlyCreated.add(instance);
        }
 else {
          instance=actors.poll();
          newActor=(CompositeActor)instance;
          newActor.setDisplayName(objectName);
          if (_debugging) {
            _debug(instance.getName() + ""String_Node_Str"" + objectName);
          }
        }
        List<HlaSubscriber> subscribers=newActor.entityList(HlaSubscriber.class);
        for (int i=0; i < subscribers.size(); ++i) {
          HlaSubscriber sub=subscribers.get(i);
          sub.objectName.setExpression(""String_Node_Str"" + objectName + ""String_Node_Str"");
          ;
          sub.setObjectHandle(objectHandle);
          _hlaAttributesSubscribedTo.put(sub.getIdentity(),new Object[]{sub.output,sub.output.getType(),""String_Node_Str"",classHandle,sub.getAttributeHandle()});
          _fromFederationEvents.put(sub.getIdentity(),new LinkedList<TimedEvent>());
        }
      }
 catch (      NameDuplicationException|CloneNotSupportedException ex) {
        ex.printStackTrace();
      }
    }
  }
;
  request.setPersistent(false);
  String toLog=HlaManager.this.getDisplayName() + ""String_Node_Str"" + ""String_Node_Str""+ objectName+ ""String_Node_Str""+ ""String_Node_Str""+ objectHandle+ ""String_Node_Str""+ classHandle+ ""String_Node_Str"";
  if (classToInstantiate != null) {
    requestChange(request);
  }
 else {
    toLog+=""String_Node_Str"";
  }
  if (_debugging) {
    _debug(toLog);
  }
}"
72514,"/** 
 * Update the HLA attribute <i>attributeName</i> with the containment of the token <i>in</i>. The updated attribute is sent to the HLA/CERTI Federation.
 * @param hp The HLA publisher actor (HLA attribute) to update.
 * @param in The updated value of the HLA attribute to update.
 * @throws IllegalActionException If a CERTI exception is raised thendisplayed it to the user.
 */
void updateHlaAttribute(HlaPublisher hp,Token in,int objectID) throws IllegalActionException {
  Time currentTime=_director.getModelTime();
  Object[] tObj=_hlaAttributesToPublish.get(hp.getName());
  byte[] valAttribute=MessageProcessing.encodeHlaValue(hp,in);
  if (_debugging) {
    if (hp.useCertiMessageBuffer()) {
      _debug(this.getDisplayName() + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ _director.getModelTime().getDoubleValue());
    }
  }
  SuppliedAttributes suppAttributes=null;
  try {
    suppAttributes=RtiFactoryFactory.getRtiFactory().createSuppliedAttributes();
  }
 catch (  RTIinternalError e) {
    throw new IllegalActionException(this,e,""String_Node_Str"");
  }
  suppAttributes.add(_getAttributeHandleFromTab(tObj),valAttribute);
  byte[] tag=EncodingHelpers.encodeString(_getPortFromTab(tObj).getContainer().getName());
  CertiLogicalTime ct=new CertiLogicalTime(currentTime.getDoubleValue() + _hlaLookAHead);
  try {
    _rtia.updateAttributeValues(objectID,suppAttributes,tag,ct);
  }
 catch (  Exception e) {
    throw new IllegalActionException(this,e,e.getMessage());
  }
  if (_debugging) {
    _debug(this.getDisplayName() + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ currentTime.getDoubleValue()+ ""String_Node_Str""+ _getPortFromTab(tObj).getContainer().getName()+ ""String_Node_Str""+ ct.getTime()+ ""String_Node_Str""+ in.toString()+ ""String_Node_Str"");
  }
}","/** 
 * Update the HLA attribute <i>attributeName</i> with the containment of the token <i>in</i>. The updated attribute is sent to the HLA/CERTI Federation.
 * @param hp The HLA publisher actor (HLA attribute) to update.
 * @param in The updated value of the HLA attribute to update.
 * @throws IllegalActionException If a CERTI exception is raised thendisplayed it to the user.
 */
void updateHlaAttribute(HlaPublisher hp,Token in,String senderName) throws IllegalActionException {
  Time currentTime=_director.getModelTime();
  Object[] tObj=_hlaAttributesToPublish.get(hp.getName());
  byte[] valAttribute=MessageProcessing.encodeHlaValue(hp,in);
  if (_debugging) {
    if (hp.useCertiMessageBuffer()) {
      _debug(this.getDisplayName() + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ _director.getModelTime().getDoubleValue());
    }
  }
  SuppliedAttributes suppAttributes=null;
  try {
    suppAttributes=RtiFactoryFactory.getRtiFactory().createSuppliedAttributes();
  }
 catch (  RTIinternalError e) {
    throw new IllegalActionException(this,e,""String_Node_Str"");
  }
  suppAttributes.add(_getAttributeHandleFromTab(tObj),valAttribute);
  byte[] tag=EncodingHelpers.encodeString(_getPortFromTab(tObj).getContainer().getName());
  CertiLogicalTime ct=new CertiLogicalTime(currentTime.getDoubleValue() + _hlaLookAHead);
  try {
    int id=_registeredObject.get(_federateName + ""String_Node_Str"" + senderName);
    _rtia.updateAttributeValues(id,suppAttributes,tag,ct);
  }
 catch (  Exception e) {
    throw new IllegalActionException(this,e,e.getMessage());
  }
  if (_debugging) {
    _debug(this.getDisplayName() + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ currentTime.getDoubleValue()+ ""String_Node_Str""+ _getPortFromTab(tObj).getContainer().getName()+ ""String_Node_Str""+ ct.getTime()+ ""String_Node_Str""+ in.toString()+ ""String_Node_Str"");
  }
}"
72515,"private void setUpHlaPublisher(RTIambassador rtia) throws NameNotFound, ObjectClassNotDefined, FederateNotExecutionMember, RTIinternalError, AttributeNotDefined, SaveInProgress, RestoreInProgress, ConcurrentAccessAttempted {
  Iterator<Entry<String,Object[]>> it=_hlaAttributesToPublish.entrySet().iterator();
  while (it.hasNext()) {
    Map.Entry<String,Object[]> elt=it.next();
    Object[] tObj=elt.getValue();
    int classHandle=rtia.getObjectClassHandle(_getClassNameFromTab(tObj));
    int objAttributeHandle=rtia.getAttributeHandle(_getPortFromTab(tObj).getContainer().getName(),classHandle);
    elt.setValue(new Object[]{_getPortFromTab(tObj),_getTypeFromTab(tObj),_getClassNameFromTab(tObj),classHandle,objAttributeHandle});
  }
  HashMap<String,LinkedList<String>> classHandleHlaPublisherTable=null;
  classHandleHlaPublisherTable=new HashMap<String,LinkedList<String>>();
  Iterator<Entry<String,Object[]>> it2=_hlaAttributesToPublish.entrySet().iterator();
  while (it2.hasNext()) {
    Map.Entry<String,Object[]> elt=it2.next();
    Object[] tObj=elt.getValue();
    String classHandleName=_getClassNameFromTab(tObj);
    if (classHandleHlaPublisherTable.containsKey(classHandleName)) {
      classHandleHlaPublisherTable.get(classHandleName).add(elt.getKey());
    }
 else {
      LinkedList<String> list=new LinkedList<String>();
      list.add(elt.getKey());
      classHandleHlaPublisherTable.put(classHandleName,list);
    }
  }
  Iterator<Entry<String,LinkedList<String>>> it3=classHandleHlaPublisherTable.entrySet().iterator();
  while (it3.hasNext()) {
    Map.Entry<String,LinkedList<String>> elt=it3.next();
    LinkedList<String> hlaPublishers=elt.getValue();
    int classHandle=rtia.getObjectClassHandle(elt.getKey());
    AttributeHandleSet _attributesLocal=RtiFactoryFactory.getRtiFactory().createAttributeHandleSet();
    for (    String s : hlaPublishers) {
      _attributesLocal.add(_getAttributeHandleFromTab(_hlaAttributesToPublish.get(s)));
    }
    try {
      rtia.publishObjectClass(classHandle,_attributesLocal);
    }
 catch (    OwnershipAcquisitionPending e) {
      e.printStackTrace();
    }
  }
  Iterator<Entry<String,Object[]>> it5=_hlaAttributesToPublish.entrySet().iterator();
  LinkedList<String> alreadyRegistered=new LinkedList<String>();
  while (it5.hasNext()) {
    Map.Entry<String,Object[]> elt=it5.next();
    Object[] tObj=elt.getValue();
    int classHandle=rtia.getObjectClassHandle(_getClassNameFromTab(tObj));
    TypedIOPort port=_getPortFromTab(tObj);
    HlaPublisher pub=(HlaPublisher)port.getContainer();
    List<IOPort> senders=port.sourcePortList();
    for (    IOPort sender : senders) {
      String senderName=_federateName + ""String_Node_Str"" + sender.getContainer().getName();
      if (!alreadyRegistered.contains(senderName)) {
        alreadyRegistered.add(senderName);
        int myObjectInstId=-1;
        try {
          myObjectInstId=rtia.registerObjectInstance(classHandle,senderName);
          pub.register(senderName,myObjectInstId);
        }
 catch (        ObjectClassNotPublished e) {
          e.printStackTrace();
        }
catch (        ObjectAlreadyRegistered e) {
          e.printStackTrace();
        }
      }
    }
  }
}","private void setUpHlaPublisher(RTIambassador rtia) throws NameNotFound, ObjectClassNotDefined, FederateNotExecutionMember, RTIinternalError, AttributeNotDefined, SaveInProgress, RestoreInProgress, ConcurrentAccessAttempted {
  Iterator<Entry<String,Object[]>> it=_hlaAttributesToPublish.entrySet().iterator();
  while (it.hasNext()) {
    Map.Entry<String,Object[]> elt=it.next();
    Object[] tObj=elt.getValue();
    int classHandle=rtia.getObjectClassHandle(_getClassNameFromTab(tObj));
    int objAttributeHandle=rtia.getAttributeHandle(_getPortFromTab(tObj).getContainer().getName(),classHandle);
    elt.setValue(new Object[]{_getPortFromTab(tObj),_getTypeFromTab(tObj),_getClassNameFromTab(tObj),classHandle,objAttributeHandle});
  }
  HashMap<String,LinkedList<String>> classHandleHlaPublisherTable=new HashMap<String,LinkedList<String>>();
  Iterator<Entry<String,Object[]>> it2=_hlaAttributesToPublish.entrySet().iterator();
  while (it2.hasNext()) {
    Map.Entry<String,Object[]> elt=it2.next();
    Object[] tObj=elt.getValue();
    String classHandleName=_getClassNameFromTab(tObj);
    if (classHandleHlaPublisherTable.containsKey(classHandleName)) {
      classHandleHlaPublisherTable.get(classHandleName).add(elt.getKey());
    }
 else {
      LinkedList<String> list=new LinkedList<String>();
      list.add(elt.getKey());
      classHandleHlaPublisherTable.put(classHandleName,list);
    }
  }
  Iterator<Entry<String,LinkedList<String>>> it3=classHandleHlaPublisherTable.entrySet().iterator();
  while (it3.hasNext()) {
    Map.Entry<String,LinkedList<String>> elt=it3.next();
    LinkedList<String> hlaPublishers=elt.getValue();
    int classHandle=rtia.getObjectClassHandle(elt.getKey());
    AttributeHandleSet _attributesLocal=RtiFactoryFactory.getRtiFactory().createAttributeHandleSet();
    for (    String s : hlaPublishers) {
      _attributesLocal.add(_getAttributeHandleFromTab(_hlaAttributesToPublish.get(s)));
    }
    try {
      rtia.publishObjectClass(classHandle,_attributesLocal);
    }
 catch (    OwnershipAcquisitionPending e) {
      e.printStackTrace();
    }
  }
  Iterator<Entry<String,Object[]>> it5=_hlaAttributesToPublish.entrySet().iterator();
  while (it5.hasNext()) {
    Map.Entry<String,Object[]> elt=it5.next();
    Object[] tObj=elt.getValue();
    int classHandle=rtia.getObjectClassHandle(_getClassNameFromTab(tObj));
    TypedIOPort port=_getPortFromTab(tObj);
    HlaPublisher pub=(HlaPublisher)port.getContainer();
    List<IOPort> senders=port.sourcePortList();
    for (    IOPort sender : senders) {
      String senderName=_federateName + ""String_Node_Str"" + sender.getContainer().getName();
      if (!_registeredObject.containsKey(senderName)) {
        int myObjectInstId=-1;
        try {
          myObjectInstId=rtia.registerObjectInstance(classHandle,senderName);
          _registeredObject.put(senderName,myObjectInstId);
        }
 catch (        ObjectClassNotPublished e) {
          e.printStackTrace();
        }
catch (        ObjectAlreadyRegistered e) {
          e.printStackTrace();
        }
      }
    }
  }
}"
72516,"/** 
 * Construct a HlaManager with a name and a container. The container argument must not be null, or a NullPointerException will be thrown. This actor will use the workspace of the container for synchronization and version counts. If the name argument is null, then the name is set to the empty string. Increment the version of the workspace.
 * @param container Container of this attribute.
 * @param name Name of this attribute.
 * @exception IllegalActionException If the container is incompatiblewith this actor.
 * @exception NameDuplicationException If the name coincides withan actor already in the container.
 */
public HlaManager(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  _rtia=null;
  _federateAmbassador=null;
  _hlaAttributesToPublish=new HashMap<String,Object[]>();
  _hlaAttributesSubscribedTo=new HashMap<String,Object[]>();
  _fromFederationEvents=new HashMap<String,LinkedList<TimedEvent>>();
  _objectIdToClassHandle=new HashMap<Integer,Integer>();
  _strucuralInformation=new HashMap<Integer,StructuralInformation>();
  _newlyCreated=new LinkedList<Instantiable>();
  _hlaStartTime=null;
  _hlaTimeStep=null;
  _hlaLookAHead=null;
  federateName=new Parameter(this,""String_Node_Str"");
  federateName.setDisplayName(""String_Node_Str"");
  federateName.setTypeEquals(BaseType.STRING);
  federateName.setExpression(""String_Node_Str"");
  attributeChanged(federateName);
  federationName=new Parameter(this,""String_Node_Str"");
  federationName.setDisplayName(""String_Node_Str"");
  federationName.setTypeEquals(BaseType.STRING);
  federationName.setExpression(""String_Node_Str"");
  attributeChanged(federationName);
  fedFile=new FileParameter(this,""String_Node_Str"");
  fedFile.setDisplayName(""String_Node_Str"");
  new Parameter(fedFile,""String_Node_Str"",BooleanToken.TRUE);
  new Parameter(fedFile,""String_Node_Str"",BooleanToken.FALSE);
  fedFile.setExpression(""String_Node_Str"");
  eventBased=new Parameter(this,""String_Node_Str"");
  eventBased.setTypeEquals(BaseType.BOOLEAN);
  eventBased.setExpression(""String_Node_Str"");
  eventBased.setDisplayName(""String_Node_Str"");
  attributeChanged(eventBased);
  timeStepped=new Parameter(this,""String_Node_Str"");
  timeStepped.setTypeEquals(BaseType.BOOLEAN);
  timeStepped.setExpression(""String_Node_Str"");
  timeStepped.setDisplayName(""String_Node_Str"");
  attributeChanged(timeStepped);
  isTimeConstrained=new Parameter(this,""String_Node_Str"");
  isTimeConstrained.setTypeEquals(BaseType.BOOLEAN);
  isTimeConstrained.setExpression(""String_Node_Str"");
  isTimeConstrained.setDisplayName(""String_Node_Str"");
  isTimeConstrained.setVisibility(Settable.NOT_EDITABLE);
  attributeChanged(isTimeConstrained);
  isTimeRegulator=new Parameter(this,""String_Node_Str"");
  isTimeRegulator.setTypeEquals(BaseType.BOOLEAN);
  isTimeRegulator.setExpression(""String_Node_Str"");
  isTimeRegulator.setDisplayName(""String_Node_Str"");
  isTimeRegulator.setVisibility(Settable.NOT_EDITABLE);
  attributeChanged(isTimeRegulator);
  hlaStartTime=new Parameter(this,""String_Node_Str"");
  hlaStartTime.setDisplayName(""String_Node_Str"");
  hlaStartTime.setExpression(""String_Node_Str"");
  hlaStartTime.setTypeEquals(BaseType.DOUBLE);
  attributeChanged(hlaStartTime);
  hlaTimeStep=new Parameter(this,""String_Node_Str"");
  hlaTimeStep.setDisplayName(""String_Node_Str"");
  hlaTimeStep.setExpression(""String_Node_Str"");
  hlaTimeStep.setTypeEquals(BaseType.DOUBLE);
  hlaTimeStep.setVisibility(Settable.NOT_EDITABLE);
  attributeChanged(hlaTimeStep);
  hlaLookAHead=new Parameter(this,""String_Node_Str"");
  hlaLookAHead.setDisplayName(""String_Node_Str"");
  hlaLookAHead.setExpression(""String_Node_Str"");
  hlaLookAHead.setTypeEquals(BaseType.DOUBLE);
  attributeChanged(hlaLookAHead);
  requireSynchronization=new Parameter(this,""String_Node_Str"");
  requireSynchronization.setTypeEquals(BaseType.BOOLEAN);
  requireSynchronization.setExpression(""String_Node_Str"");
  requireSynchronization.setDisplayName(""String_Node_Str"");
  attributeChanged(requireSynchronization);
  synchronizationPointName=new Parameter(this,""String_Node_Str"");
  synchronizationPointName.setDisplayName(""String_Node_Str"");
  synchronizationPointName.setTypeEquals(BaseType.STRING);
  synchronizationPointName.setExpression(""String_Node_Str"");
  attributeChanged(synchronizationPointName);
  isCreator=new Parameter(this,""String_Node_Str"");
  isCreator.setTypeEquals(BaseType.BOOLEAN);
  isCreator.setExpression(""String_Node_Str"");
  isCreator.setDisplayName(""String_Node_Str"");
  attributeChanged(isCreator);
}","/** 
 * Construct a HlaManager with a name and a container. The container argument must not be null, or a NullPointerException will be thrown. This actor will use the workspace of the container for synchronization and version counts. If the name argument is null, then the name is set to the empty string. Increment the version of the workspace.
 * @param container Container of this attribute.
 * @param name Name of this attribute.
 * @exception IllegalActionException If the container is incompatiblewith this actor.
 * @exception NameDuplicationException If the name coincides withan actor already in the container.
 */
public HlaManager(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  _lastProposedTime=null;
  _rtia=null;
  _federateAmbassador=null;
  _registeredObject=new HashMap<String,Integer>();
  _hlaAttributesToPublish=new HashMap<String,Object[]>();
  _hlaAttributesSubscribedTo=new HashMap<String,Object[]>();
  _fromFederationEvents=new HashMap<String,LinkedList<TimedEvent>>();
  _objectIdToClassHandle=new HashMap<Integer,Integer>();
  _strucuralInformation=new HashMap<Integer,StructuralInformation>();
  _newlyCreated=new LinkedList<Instantiable>();
  _hlaStartTime=null;
  _hlaTimeStep=null;
  _hlaLookAHead=null;
  federateName=new Parameter(this,""String_Node_Str"");
  federateName.setDisplayName(""String_Node_Str"");
  federateName.setTypeEquals(BaseType.STRING);
  federateName.setExpression(""String_Node_Str"");
  attributeChanged(federateName);
  federationName=new Parameter(this,""String_Node_Str"");
  federationName.setDisplayName(""String_Node_Str"");
  federationName.setTypeEquals(BaseType.STRING);
  federationName.setExpression(""String_Node_Str"");
  attributeChanged(federationName);
  fedFile=new FileParameter(this,""String_Node_Str"");
  fedFile.setDisplayName(""String_Node_Str"");
  new Parameter(fedFile,""String_Node_Str"",BooleanToken.TRUE);
  new Parameter(fedFile,""String_Node_Str"",BooleanToken.FALSE);
  fedFile.setExpression(""String_Node_Str"");
  eventBased=new Parameter(this,""String_Node_Str"");
  eventBased.setTypeEquals(BaseType.BOOLEAN);
  eventBased.setExpression(""String_Node_Str"");
  eventBased.setDisplayName(""String_Node_Str"");
  attributeChanged(eventBased);
  timeStepped=new Parameter(this,""String_Node_Str"");
  timeStepped.setTypeEquals(BaseType.BOOLEAN);
  timeStepped.setExpression(""String_Node_Str"");
  timeStepped.setDisplayName(""String_Node_Str"");
  attributeChanged(timeStepped);
  isTimeConstrained=new Parameter(this,""String_Node_Str"");
  isTimeConstrained.setTypeEquals(BaseType.BOOLEAN);
  isTimeConstrained.setExpression(""String_Node_Str"");
  isTimeConstrained.setDisplayName(""String_Node_Str"");
  isTimeConstrained.setVisibility(Settable.NOT_EDITABLE);
  attributeChanged(isTimeConstrained);
  isTimeRegulator=new Parameter(this,""String_Node_Str"");
  isTimeRegulator.setTypeEquals(BaseType.BOOLEAN);
  isTimeRegulator.setExpression(""String_Node_Str"");
  isTimeRegulator.setDisplayName(""String_Node_Str"");
  isTimeRegulator.setVisibility(Settable.NOT_EDITABLE);
  attributeChanged(isTimeRegulator);
  hlaStartTime=new Parameter(this,""String_Node_Str"");
  hlaStartTime.setDisplayName(""String_Node_Str"");
  hlaStartTime.setExpression(""String_Node_Str"");
  hlaStartTime.setTypeEquals(BaseType.DOUBLE);
  attributeChanged(hlaStartTime);
  hlaTimeStep=new Parameter(this,""String_Node_Str"");
  hlaTimeStep.setDisplayName(""String_Node_Str"");
  hlaTimeStep.setExpression(""String_Node_Str"");
  hlaTimeStep.setTypeEquals(BaseType.DOUBLE);
  hlaTimeStep.setVisibility(Settable.NOT_EDITABLE);
  attributeChanged(hlaTimeStep);
  hlaLookAHead=new Parameter(this,""String_Node_Str"");
  hlaLookAHead.setDisplayName(""String_Node_Str"");
  hlaLookAHead.setExpression(""String_Node_Str"");
  hlaLookAHead.setTypeEquals(BaseType.DOUBLE);
  attributeChanged(hlaLookAHead);
  requireSynchronization=new Parameter(this,""String_Node_Str"");
  requireSynchronization.setTypeEquals(BaseType.BOOLEAN);
  requireSynchronization.setExpression(""String_Node_Str"");
  requireSynchronization.setDisplayName(""String_Node_Str"");
  attributeChanged(requireSynchronization);
  synchronizationPointName=new Parameter(this,""String_Node_Str"");
  synchronizationPointName.setDisplayName(""String_Node_Str"");
  synchronizationPointName.setTypeEquals(BaseType.STRING);
  synchronizationPointName.setExpression(""String_Node_Str"");
  attributeChanged(synchronizationPointName);
  isCreator=new Parameter(this,""String_Node_Str"");
  isCreator.setTypeEquals(BaseType.BOOLEAN);
  isCreator.setExpression(""String_Node_Str"");
  isCreator.setDisplayName(""String_Node_Str"");
  attributeChanged(isCreator);
}"
72517,"/** 
 * Clone the actor into the specified workspace.
 * @param workspace The workspace for the new object.
 * @return A new actor.
 * @exception CloneNotSupportedException If a derived class containsan attribute that cannot be cloned.
 */
@Override public Object clone(Workspace workspace) throws CloneNotSupportedException {
  HlaManager newObject=(HlaManager)super.clone(workspace);
  newObject._hlaAttributesToPublish=new HashMap<String,Object[]>();
  newObject._hlaAttributesSubscribedTo=new HashMap<String,Object[]>();
  newObject._fromFederationEvents=new HashMap<String,LinkedList<TimedEvent>>();
  newObject._objectIdToClassHandle=new HashMap<Integer,Integer>();
  newObject._strucuralInformation=new HashMap<Integer,StructuralInformation>();
  newObject._newlyCreated=new LinkedList<Instantiable>();
  newObject._rtia=null;
  newObject._federateAmbassador=null;
  newObject._federateName=_federateName;
  newObject._federationName=_federationName;
  newObject._isTimeConstrained=_isTimeConstrained;
  newObject._isTimeRegulator=_isTimeRegulator;
  try {
    newObject._hlaStartTime=((DoubleToken)hlaStartTime.getToken()).doubleValue();
    newObject._hlaTimeStep=((DoubleToken)hlaTimeStep.getToken()).doubleValue();
    newObject._hlaLookAHead=((DoubleToken)hlaLookAHead.getToken()).doubleValue();
  }
 catch (  IllegalActionException ex) {
    CloneNotSupportedException ex2=new CloneNotSupportedException(""String_Node_Str"");
    ex2.initCause(ex);
    throw ex2;
  }
  newObject._requireSynchronization=_requireSynchronization;
  newObject._synchronizationPointName=_synchronizationPointName;
  newObject._isCreator=_isCreator;
  newObject._eventBased=_eventBased;
  newObject._timeStepped=_timeStepped;
  return newObject;
}","/** 
 * Clone the actor into the specified workspace.
 * @param workspace The workspace for the new object.
 * @return A new actor.
 * @exception CloneNotSupportedException If a derived class containsan attribute that cannot be cloned.
 */
@Override public Object clone(Workspace workspace) throws CloneNotSupportedException {
  HlaManager newObject=(HlaManager)super.clone(workspace);
  newObject._hlaAttributesToPublish=new HashMap<String,Object[]>();
  newObject._hlaAttributesSubscribedTo=new HashMap<String,Object[]>();
  newObject._fromFederationEvents=new HashMap<String,LinkedList<TimedEvent>>();
  newObject._objectIdToClassHandle=new HashMap<Integer,Integer>();
  newObject._strucuralInformation=new HashMap<Integer,StructuralInformation>();
  newObject._newlyCreated=new LinkedList<Instantiable>();
  newObject._registeredObject=new HashMap<String,Integer>();
  newObject._rtia=null;
  newObject._federateAmbassador=null;
  newObject._federateName=_federateName;
  newObject._federationName=_federationName;
  newObject._isTimeConstrained=_isTimeConstrained;
  newObject._isTimeRegulator=_isTimeRegulator;
  try {
    newObject._hlaStartTime=((DoubleToken)hlaStartTime.getToken()).doubleValue();
    newObject._hlaTimeStep=((DoubleToken)hlaTimeStep.getToken()).doubleValue();
    newObject._hlaLookAHead=((DoubleToken)hlaLookAHead.getToken()).doubleValue();
  }
 catch (  IllegalActionException ex) {
    CloneNotSupportedException ex2=new CloneNotSupportedException(""String_Node_Str"");
    ex2.initCause(ex);
    throw ex2;
  }
  newObject._requireSynchronization=_requireSynchronization;
  newObject._synchronizationPointName=_synchronizationPointName;
  newObject._isCreator=_isCreator;
  newObject._eventBased=_eventBased;
  newObject._timeStepped=_timeStepped;
  return newObject;
}"
72518,"/** 
 * Each tokens, received in the input port, are transmitted to the  {@link HlaManager} for a publication to the HLA/CERTI Federation.
 */
@Override public void fire() throws IllegalActionException {
  for (int i=0; i < input.getWidth(); ++i) {
    if (input.hasToken(i)) {
      Token in=input.get(i);
      String actorName=input.sourcePortList().get(i).getContainer().getName();
      String fedName=((StringToken)_hlaManager.federateName.getToken()).stringValue();
      int id=_registeredObject.get(fedName + ""String_Node_Str"" + actorName);
      _hlaManager.updateHlaAttribute(this,in,id);
      if (_debugging) {
        _debug(this.getDisplayName() + ""String_Node_Str"" + in.toString()+ ""String_Node_Str""+ this.getName()+ ""String_Node_Str""+ _hlaManager.getDisplayName()+ ""String_Node_Str"");
      }
    }
  }
}","/** 
 * Each tokens, received in the input port, are transmitted to the  {@link HlaManager} for a publication to the HLA/CERTI Federation.
 */
@Override public void fire() throws IllegalActionException {
  for (int i=0; i < input.getWidth(); ++i) {
    if (input.hasToken(i)) {
      Token in=input.get(i);
      _hlaManager.updateHlaAttribute(this,in,input.sourcePortList().get(i).getContainer().getName());
      if (_debugging) {
        _debug(this.getDisplayName() + ""String_Node_Str"" + in.toString()+ ""String_Node_Str""+ this.getName()+ ""String_Node_Str""+ _hlaManager.getDisplayName()+ ""String_Node_Str"");
      }
    }
  }
}"
72519,"public void addPortSinks(IOPort port){
  relations.putIfAbsent(port.getName(),new HashSet<IOPort>());
  relations.get(port.getName()).addAll(port.sinkPortList());
}","public void addPortSinks(IOPort port){
  if (!relations.containsKey(port.getName())) {
    relations.put(port.getName(),new HashSet<IOPort>());
  }
  relations.get(port.getName()).addAll(port.sinkPortList());
}"
72520,"/** 
 * Trigger a rate-event if necessary. <p>Update the internal, continuous state models.</p>
 * @param currentTime The current simulation time.
 * @param force If true, always trigger a rate-event. Otherwise,only trigger a rate-event if an input changed or if the integrator signals it needs one to satisfy internal logic.
 */
private final void _triggerRateEvent(final Time currentTime,final boolean force) throws IllegalActionException {
  if (_debugging) {
    _debugToStdOut(String.format(""String_Node_Str"",System.identityHashCode(this),currentTime.toString()));
  }
  int curIdx=0;
  boolean updatedInputVarMdl=false;
  for (  Input input : _inputs) {
    assert(input.port.isKnown(0));
    if (input.port.hasNewToken(0)) {
      final Token token=input.port.get(0);
      if (!token.equals(input.lastInput)) {
        final ModelPolynomial ivMdl=_inputVariableModels[curIdx];
        _setModelFromToken(ivMdl,token);
        ivMdl.tMdl=currentTime;
        _inputs.get(curIdx).lastInput=token;
        _inputs.get(curIdx).hasChanged=true;
        if (_debugging) {
          _debugToStdOut(String.format(""String_Node_Str"",System.identityHashCode(this),curIdx,ivMdl.toString()));
        }
      }
      updatedInputVarMdl=true;
    }
    curIdx++;
  }
  assert(_qssSolver.getInputVariableCount() == curIdx);
  if (force || updatedInputVarMdl || _qssSolver.needRateEvent()) {
    if (_debugging) {
      _debugToStdOut(String.format(""String_Node_Str"",System.identityHashCode(this),force,updatedInputVarMdl,_qssSolver.needRateEvent()));
    }
    try {
      _qssSolver.triggerRateEvent();
    }
 catch (    Exception ee) {
      throw new IllegalActionException(this,ee,""String_Node_Str"");
    }
  }
}","/** 
 * Trigger a rate-event if necessary. <p>Update the internal, continuous state models.</p>
 * @param currentTime The current simulation time.
 * @param force If true, always trigger a rate-event. Otherwise,only trigger a rate-event if an input changed or if the integrator signals it needs one to satisfy internal logic.
 */
private final void _triggerRateEvent(final Time currentTime,final boolean force) throws IllegalActionException {
  if (_debugging) {
    _debugToStdOut(String.format(""String_Node_Str"",System.identityHashCode(this),currentTime.toString()));
  }
  int curIdx=0;
  boolean updatedInputVarMdl=false;
  for (  Input input : _inputs) {
    assert(input.port.isKnown(0));
    if (input.port.hasNewToken(0)) {
      final Token token=input.port.get(0);
      final ModelPolynomial ivMdl=_inputVariableModels[curIdx];
      _setModelFromToken(ivMdl,token);
      ivMdl.tMdl=currentTime;
      _inputs.get(curIdx).lastInput=token;
      _inputs.get(curIdx).hasChanged=true;
      if (_debugging) {
        _debugToStdOut(String.format(""String_Node_Str"",System.identityHashCode(this),curIdx,ivMdl.toString()));
      }
      updatedInputVarMdl=true;
    }
    curIdx++;
  }
  assert(_qssSolver.getInputVariableCount() == curIdx);
  if (force || updatedInputVarMdl || _qssSolver.needRateEvent()) {
    if (_debugging) {
      _debugToStdOut(String.format(""String_Node_Str"",System.identityHashCode(this),force,updatedInputVarMdl,_qssSolver.needRateEvent()));
    }
    try {
      _qssSolver.triggerRateEvent();
    }
 catch (    Exception ee) {
      throw new IllegalActionException(this,ee,""String_Node_Str"");
    }
  }
}"
72521,"/** 
 * Parse the ModelStructure to catch the I/O direct dependencies.
 * @param node The node  to be parsed
 */
public void parseDependenciese(Node node){
  NamedNodeMap attributes=node.getAttributes();
  Long valueReference=modelVariables.get(Integer.parseInt(attributes.getNamedItem(""String_Node_Str"").getNodeValue()) - 1).valueReference;
  Node dependencyNode=attributes.getNamedItem(""String_Node_Str"");
  if (dependencyNode != null) {
    String[] dependencies;
    if (dependencyNode.getNodeValue().trim().length() != 0) {
      dependencies=dependencyNode.getNodeValue().trim().split(""String_Node_Str"");
    }
 else {
      dependencies=new String[0];
    }
    for (int i=0; i < modelVariables.size(); i++) {
      if (modelVariables.get(i).valueReference == valueReference) {
        modelVariables.get(i).directDependency.clear();
        for (int j=0; j < dependencies.length; j++) {
          for (int k=0; k < modelVariables.size(); k++) {
            try {
              if (modelVariables.get(k).valueReference == modelVariables.get(Integer.parseInt(dependencies[j]) - 1).valueReference) {
                modelVariables.get(i).directDependency.add(modelVariables.get(k).name);
                break;
              }
            }
 catch (            NumberFormatException ex) {
              NumberFormatException nfx=new NumberFormatException(""String_Node_Str"" + dependencies[j] + ""String_Node_Str""+ j+ ""String_Node_Str"");
              nfx.initCause(ex);
              throw nfx;
            }
          }
        }
      }
    }
  }
}","/** 
 * Parse the ModelStructure to catch the I/O direct dependencies.
 * @param node The node  to be parsed
 */
public void parseDependenciese(Node node){
  NamedNodeMap attributes=node.getAttributes();
  Long valueReference=modelVariables.get(Integer.parseInt(attributes.getNamedItem(""String_Node_Str"").getNodeValue()) - 1).valueReference;
  Node dependencyNode=attributes.getNamedItem(""String_Node_Str"");
  if (dependencyNode != null) {
    String[] dependencies;
    if (dependencyNode.getNodeValue().trim().length() != 0) {
      dependencies=dependencyNode.getNodeValue().trim().split(""String_Node_Str"");
    }
 else {
      dependencies=new String[0];
    }
    for (int i=0; i < modelVariables.size(); i++) {
      if (modelVariables.get(i).valueReference == valueReference) {
        modelVariables.get(i).directDependency.clear();
        for (int j=0; j < dependencies.length; j++) {
          for (int k=0; k < modelVariables.size(); k++) {
            try {
              if ((modelVariables.get(k).valueReference == modelVariables.get(Integer.parseInt(dependencies[j]) - 1).valueReference) && modelVariables.get(k).causality.equals(Causality.input)) {
                modelVariables.get(i).directDependency.add(modelVariables.get(k).name);
                break;
              }
            }
 catch (            NumberFormatException ex) {
              NumberFormatException nfx=new NumberFormatException(""String_Node_Str"" + dependencies[j] + ""String_Node_Str""+ j+ ""String_Node_Str"");
              nfx.initCause(ex);
              throw nfx;
            }
          }
        }
      }
    }
  }
}"
72522,"/** 
 * Parse the ModelStructure to catch the I/O direct dependencies.
 * @param node The node  to be parsed
 */
public void parseDependenciese(Node node){
  NamedNodeMap attributes=node.getAttributes();
  Long valueReference=modelVariables.get(Integer.parseInt(attributes.getNamedItem(""String_Node_Str"").getNodeValue()) - 1).valueReference;
  Node dependencyNode=attributes.getNamedItem(""String_Node_Str"");
  if (dependencyNode != null) {
    String[] dependencies;
    if (dependencyNode.getNodeValue().trim().length() != 0) {
      dependencies=dependencyNode.getNodeValue().trim().split(""String_Node_Str"");
    }
 else {
      dependencies=new String[0];
    }
    for (int i=0; i < modelVariables.size(); i++) {
      if (modelVariables.get(i).valueReference == valueReference) {
        modelVariables.get(i).directDependency.clear();
        for (int j=0; j < dependencies.length; j++) {
          for (int k=0; k < modelVariables.size(); k++) {
            try {
              if (modelVariables.get(k).valueReference == modelVariables.get(Integer.parseInt(dependencies[j]) - 1).valueReference && modelVariables.get(k).causality.equals(Causality.input)) {
                modelVariables.get(i).directDependency.add(modelVariables.get(k).name);
                break;
              }
            }
 catch (            NumberFormatException ex) {
              NumberFormatException nfx=new NumberFormatException(""String_Node_Str"" + dependencies[j] + ""String_Node_Str""+ j+ ""String_Node_Str"");
              nfx.initCause(ex);
              throw nfx;
            }
          }
        }
      }
    }
  }
}","/** 
 * Parse the ModelStructure to catch the I/O direct dependencies.
 * @param node The node  to be parsed
 */
public void parseDependenciese(Node node){
  NamedNodeMap attributes=node.getAttributes();
  Long valueReference=modelVariables.get(Integer.parseInt(attributes.getNamedItem(""String_Node_Str"").getNodeValue()) - 1).valueReference;
  Node dependencyNode=attributes.getNamedItem(""String_Node_Str"");
  if (dependencyNode != null) {
    String[] dependencies;
    if (dependencyNode.getNodeValue().trim().length() != 0) {
      dependencies=dependencyNode.getNodeValue().trim().split(""String_Node_Str"");
    }
 else {
      dependencies=new String[0];
    }
    for (int i=0; i < modelVariables.size(); i++) {
      if (modelVariables.get(i).valueReference == valueReference) {
        modelVariables.get(i).directDependency.clear();
        for (int j=0; j < dependencies.length; j++) {
          for (int k=0; k < modelVariables.size(); k++) {
            try {
              if (modelVariables.get(k).valueReference == modelVariables.get(Integer.parseInt(dependencies[j]) - 1).valueReference) {
                modelVariables.get(i).directDependency.add(modelVariables.get(k).name);
                break;
              }
            }
 catch (            NumberFormatException ex) {
              NumberFormatException nfx=new NumberFormatException(""String_Node_Str"" + dependencies[j] + ""String_Node_Str""+ j+ ""String_Node_Str"");
              nfx.initCause(ex);
              throw nfx;
            }
          }
        }
      }
    }
  }
}"
72523,"/** 
 * Parse the ModelStructure to catch the I/O direct dependencies.
 * @param node The node to be parsed
 */
public void parseDependenciese(Node node){
  NamedNodeMap attributes=node.getAttributes();
  Long valueReference=Long.parseLong(attributes.getNamedItem(""String_Node_Str"").getNodeValue()) - 1;
  Node dependencyNode=attributes.getNamedItem(""String_Node_Str"");
  if (dependencyNode != null && dependencyNode.getNodeValue().trim().length() != 0) {
    String[] dependencies=dependencyNode.getNodeValue().trim().split(""String_Node_Str"");
    for (int i=0; i < modelVariables.size(); i++) {
      if (modelVariables.get(i).valueReference == valueReference) {
        modelVariables.get(i).directDependency.clear();
        for (int j=0; j < dependencies.length; j++) {
          for (int k=0; k < modelVariables.size(); k++) {
            try {
              if (modelVariables.get(k).valueReference == (Long.parseLong(dependencies[j]) - 1) && modelVariables.get(k).causality.equals(Causality.input)) {
                modelVariables.get(i).directDependency.add(modelVariables.get(k).name);
                break;
              }
            }
 catch (            NumberFormatException ex) {
              NumberFormatException nfx=new NumberFormatException(""String_Node_Str"" + dependencies[j] + ""String_Node_Str""+ j+ ""String_Node_Str"");
              nfx.initCause(ex);
              throw nfx;
            }
          }
        }
      }
    }
  }
}","/** 
 * Parse the ModelStructure to catch the I/O direct dependencies.
 * @param node The node  to be parsed
 */
public void parseDependenciese(Node node){
  NamedNodeMap attributes=node.getAttributes();
  Long valueReference=modelVariables.get(Integer.parseInt(attributes.getNamedItem(""String_Node_Str"").getNodeValue()) - 1).valueReference;
  Node dependencyNode=attributes.getNamedItem(""String_Node_Str"");
  if (dependencyNode != null) {
    String[] dependencies;
    if (dependencyNode.getNodeValue().trim().length() != 0) {
      dependencies=dependencyNode.getNodeValue().trim().split(""String_Node_Str"");
    }
 else {
      dependencies=new String[0];
    }
    for (int i=0; i < modelVariables.size(); i++) {
      if (modelVariables.get(i).valueReference == valueReference) {
        modelVariables.get(i).directDependency.clear();
        for (int j=0; j < dependencies.length; j++) {
          for (int k=0; k < modelVariables.size(); k++) {
            try {
              if (modelVariables.get(k).valueReference == modelVariables.get(Integer.parseInt(dependencies[j]) - 1).valueReference && modelVariables.get(k).causality.equals(Causality.input)) {
                modelVariables.get(i).directDependency.add(modelVariables.get(k).name);
                break;
              }
            }
 catch (            NumberFormatException ex) {
              NumberFormatException nfx=new NumberFormatException(""String_Node_Str"" + dependencies[j] + ""String_Node_Str""+ j+ ""String_Node_Str"");
              nfx.initCause(ex);
              throw nfx;
            }
          }
        }
      }
    }
  }
}"
72524,"/** 
 * Configure the different HLASubscribers (ie will make them suscribe to what they should)
 */
private void setUpHLASubscriber(RTIambassador rtia) throws NameNotFound, ObjectClassNotDefined, FederateNotExecutionMember, RTIinternalError, AttributeNotDefined, SaveInProgress, RestoreInProgress, ConcurrentAccessAttempted {
  CompositeEntity container=(CompositeEntity)getContainer();
  List<ComponentEntity> classes=container.classDefinitionList();
  for (  ComponentEntity currentClass : classes) {
    int classHandle=rtia.getObjectClassHandle(currentClass.getName());
    try {
      _idToClasses.put(classHandle,currentClass);
      AttributeHandleSet _attributesLocal=RtiFactoryFactory.getRtiFactory().createAttributeHandleSet();
      List<HlaSubscriber> subscribers=((CompositeActor)currentClass).entityList(HlaSubscriber.class);
      for (      HlaSubscriber sub : subscribers) {
        int attributeHandle=rtia.getAttributeHandle(sub.getParameterName(),classHandle);
        sub.attributeHandle=attributeHandle;
        sub.classHandle=classHandle;
        _attributesLocal.add(attributeHandle);
        if (_debugging) {
          _debug(""String_Node_Str"" + sub.getParameterName() + ""String_Node_Str""+ currentClass.getName());
        }
      }
      rtia.subscribeObjectClassAttributes(classHandle,_attributesLocal);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
    Class javaClass=currentClass.getClass();
    List objects=container.entityList(javaClass);
    LinkedList<ComponentEntity> freeActorForThatClass=new LinkedList<ComponentEntity>();
    _freeActors.put(classHandle,freeActorForThatClass);
    for (int i=0; i < objects.size(); i++) {
      CompositeActor currentActor=(CompositeActor)objects.get(i);
      freeActorForThatClass.add(currentActor);
      List<HlaSubscriber> subscribers=currentActor.entityList(HlaSubscriber.class);
      for (      HlaSubscriber sub : subscribers) {
        int attributeHandle=rtia.getAttributeHandle(sub.getParameterName(),classHandle);
        sub.attributeHandle=attributeHandle;
        sub.classHandle=classHandle;
      }
    }
  }
}","/** 
 * Configure the different HLASubscribers (ie will make them suscribe to what they should)
 */
private void setUpHLASubscriber(RTIambassador rtia) throws NameNotFound, ObjectClassNotDefined, FederateNotExecutionMember, RTIinternalError, AttributeNotDefined, SaveInProgress, RestoreInProgress, ConcurrentAccessAttempted {
  CompositeEntity container=(CompositeEntity)getContainer();
  List<ComponentEntity> classes=container.classDefinitionList();
  for (  ComponentEntity currentClass : classes) {
    int classHandle=rtia.getObjectClassHandle(currentClass.getName());
    try {
      _classIdToPtIIClasses.put(classHandle,currentClass);
      AttributeHandleSet _attributesLocal=RtiFactoryFactory.getRtiFactory().createAttributeHandleSet();
      List<HlaSubscriber> subscribers=((CompositeActor)currentClass).entityList(HlaSubscriber.class);
      for (      HlaSubscriber sub : subscribers) {
        int attributeHandle=rtia.getAttributeHandle(sub.getParameterName(),classHandle);
        sub.setAttributeHandle(attributeHandle);
        sub.setClassHandle(classHandle);
        _attributesLocal.add(attributeHandle);
        if (_debugging) {
          _debug(""String_Node_Str"" + sub.getParameterName() + ""String_Node_Str""+ currentClass.getName());
        }
      }
      rtia.subscribeObjectClassAttributes(classHandle,_attributesLocal);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
    Class javaClass=currentClass.getClass();
    List objects=container.entityList(javaClass);
    LinkedList<ComponentEntity> freeActorForThatClass=new LinkedList<ComponentEntity>();
    _freeActors.put(classHandle,freeActorForThatClass);
    for (int i=0; i < objects.size(); i++) {
      CompositeActor currentActor=(CompositeActor)objects.get(i);
      freeActorForThatClass.add(currentActor);
      List<HlaSubscriber> subscribers=currentActor.entityList(HlaSubscriber.class);
      for (      HlaSubscriber sub : subscribers) {
        int attributeHandle=rtia.getAttributeHandle(sub.getParameterName(),classHandle);
        sub.setAttributeHandle(attributeHandle);
        sub.setClassHandle(classHandle);
      }
    }
  }
}"
72525,"@Override protected void _execute() throws IllegalActionException {
  CompositeActor container=(CompositeActor)classToInstantiate.getContainer();
  try {
    Instantiable instance;
    LinkedList<ComponentEntity> actors=_freeActors.get(classHandle);
    if (actors.size() == 0) {
      instance=classToInstantiate.instantiate(container,objectName);
      container.notifyConnectivityChange();
      _newlyCreated.add(instance);
    }
 else {
      instance=actors.poll();
      if (_debugging) {
        _debug(instance.getName() + ""String_Node_Str"" + objectHandle);
      }
    }
    CompositeActor newActor=(CompositeActor)instance;
    List<HlaSubscriber> subscribers=newActor.entityList(HlaSubscriber.class);
    for (int i=0; i < subscribers.size(); ++i) {
      HlaSubscriber sub=subscribers.get(i);
      sub.objectName.setExpression(""String_Node_Str"" + objectName + ""String_Node_Str"");
      ;
      sub.objectHandle=objectHandle;
      _hlaAttributesSubscribedTo.put(sub.getIdentity(),new Object[]{sub.output,sub.output.getType(),""String_Node_Str"",classHandle,sub.attributeHandle});
      _fromFederationEvents.put(sub.getIdentity(),new LinkedList<TimedEvent>());
    }
  }
 catch (  NameDuplicationException|CloneNotSupportedException ex) {
    ex.printStackTrace();
  }
}","@Override protected void _execute() throws IllegalActionException {
  CompositeActor container=(CompositeActor)classToInstantiate.getContainer();
  try {
    Instantiable instance;
    LinkedList<ComponentEntity> actors=_freeActors.get(classHandle);
    if (actors.size() == 0) {
      instance=classToInstantiate.instantiate(container,objectName);
      container.notifyConnectivityChange();
      _newlyCreated.add(instance);
    }
 else {
      instance=actors.poll();
      if (_debugging) {
        _debug(instance.getName() + ""String_Node_Str"" + objectHandle);
      }
    }
    CompositeActor newActor=(CompositeActor)instance;
    List<HlaSubscriber> subscribers=newActor.entityList(HlaSubscriber.class);
    for (int i=0; i < subscribers.size(); ++i) {
      HlaSubscriber sub=subscribers.get(i);
      sub.objectName.setExpression(""String_Node_Str"" + objectName + ""String_Node_Str"");
      ;
      sub.setObjectHandle(objectHandle);
      _hlaAttributesSubscribedTo.put(sub.getIdentity(),new Object[]{sub.output,sub.output.getType(),""String_Node_Str"",classHandle,sub.getAttributeHandle()});
      _fromFederationEvents.put(sub.getIdentity(),new LinkedList<TimedEvent>());
    }
  }
 catch (  NameDuplicationException|CloneNotSupportedException ex) {
    ex.printStackTrace();
  }
}"
72526,"/** 
 * Callback delivered by the RTI (CERTI) to discover attribute instance of HLA attribute that the Federate is subscribed to.
 */
@Override public void discoverObjectInstance(int objectHandle,int classHandle,String objectName) throws CouldNotDiscover, ObjectClassNotKnown, FederateInternalError {
  if (_debugging) {
    _debug(HlaManager.this.getDisplayName() + ""String_Node_Str"" + ""String_Node_Str""+ objectName+ ""String_Node_Str""+ ""String_Node_Str""+ objectHandle+ ""String_Node_Str""+ classHandle+ ""String_Node_Str"");
  }
  _objectIdToClassHandle.put(objectHandle,classHandle);
  final CompositeActor classToInstantiate=(CompositeActor)_idToClasses.get(classHandle);
  ChangeRequest request=new ChangeRequest(this,""String_Node_Str"" + objectName,true){
    @Override protected void _execute() throws IllegalActionException {
      CompositeActor container=(CompositeActor)classToInstantiate.getContainer();
      try {
        Instantiable instance;
        LinkedList<ComponentEntity> actors=_freeActors.get(classHandle);
        if (actors.size() == 0) {
          instance=classToInstantiate.instantiate(container,objectName);
          container.notifyConnectivityChange();
          _newlyCreated.add(instance);
        }
 else {
          instance=actors.poll();
          if (_debugging) {
            _debug(instance.getName() + ""String_Node_Str"" + objectHandle);
          }
        }
        CompositeActor newActor=(CompositeActor)instance;
        List<HlaSubscriber> subscribers=newActor.entityList(HlaSubscriber.class);
        for (int i=0; i < subscribers.size(); ++i) {
          HlaSubscriber sub=subscribers.get(i);
          sub.objectName.setExpression(""String_Node_Str"" + objectName + ""String_Node_Str"");
          ;
          sub.objectHandle=objectHandle;
          _hlaAttributesSubscribedTo.put(sub.getIdentity(),new Object[]{sub.output,sub.output.getType(),""String_Node_Str"",classHandle,sub.attributeHandle});
          _fromFederationEvents.put(sub.getIdentity(),new LinkedList<TimedEvent>());
        }
      }
 catch (      NameDuplicationException|CloneNotSupportedException ex) {
        ex.printStackTrace();
      }
    }
  }
;
  request.setPersistent(false);
  if (classToInstantiate != null) {
    requestChange(request);
  }
}","/** 
 * Callback delivered by the RTI (CERTI) to discover attribute instance of HLA attribute that the Federate is subscribed to.
 */
@Override public void discoverObjectInstance(int objectHandle,int classHandle,String objectName) throws CouldNotDiscover, ObjectClassNotKnown, FederateInternalError {
  if (_debugging) {
    _debug(HlaManager.this.getDisplayName() + ""String_Node_Str"" + ""String_Node_Str""+ objectName+ ""String_Node_Str""+ ""String_Node_Str""+ objectHandle+ ""String_Node_Str""+ classHandle+ ""String_Node_Str"");
  }
  _objectIdToClassHandle.put(objectHandle,classHandle);
  final CompositeActor classToInstantiate=(CompositeActor)_classIdToPtIIClasses.get(classHandle);
  ChangeRequest request=new ChangeRequest(this,""String_Node_Str"" + objectName,true){
    @Override protected void _execute() throws IllegalActionException {
      CompositeActor container=(CompositeActor)classToInstantiate.getContainer();
      try {
        Instantiable instance;
        LinkedList<ComponentEntity> actors=_freeActors.get(classHandle);
        if (actors.size() == 0) {
          instance=classToInstantiate.instantiate(container,objectName);
          container.notifyConnectivityChange();
          _newlyCreated.add(instance);
        }
 else {
          instance=actors.poll();
          if (_debugging) {
            _debug(instance.getName() + ""String_Node_Str"" + objectHandle);
          }
        }
        CompositeActor newActor=(CompositeActor)instance;
        List<HlaSubscriber> subscribers=newActor.entityList(HlaSubscriber.class);
        for (int i=0; i < subscribers.size(); ++i) {
          HlaSubscriber sub=subscribers.get(i);
          sub.objectName.setExpression(""String_Node_Str"" + objectName + ""String_Node_Str"");
          ;
          sub.setObjectHandle(objectHandle);
          _hlaAttributesSubscribedTo.put(sub.getIdentity(),new Object[]{sub.output,sub.output.getType(),""String_Node_Str"",classHandle,sub.getAttributeHandle()});
          _fromFederationEvents.put(sub.getIdentity(),new LinkedList<TimedEvent>());
        }
      }
 catch (      NameDuplicationException|CloneNotSupportedException ex) {
        ex.printStackTrace();
      }
    }
  }
;
  request.setPersistent(false);
  if (classToInstantiate != null) {
    requestChange(request);
  }
}"
72527,"/** 
 * Construct a HlaManager with a name and a container. The container argument must not be null, or a NullPointerException will be thrown. This actor will use the workspace of the container for synchronization and version counts. If the name argument is null, then the name is set to the empty string. Increment the version of the workspace.
 * @param container Container of this attribute.
 * @param name Name of this attribute.
 * @exception IllegalActionException If the container is incompatiblewith this actor.
 * @exception NameDuplicationException If the name coincides withan actor already in the container.
 */
public HlaManager(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  _rtia=null;
  _federateAmbassador=null;
  _hlaAttributesToPublish=new HashMap<String,Object[]>();
  _hlaAttributesSubscribedTo=new HashMap<String,Object[]>();
  _fromFederationEvents=new HashMap<String,LinkedList<TimedEvent>>();
  _objectIdToClassHandle=new HashMap<Integer,Integer>();
  _idToClasses=new HashMap<Integer,ComponentEntity>();
  _newlyCreated=new LinkedList<Instantiable>();
  _freeActors=new HashMap<Integer,LinkedList<ComponentEntity>>();
  _hlaStartTime=null;
  _hlaTimeStep=null;
  _hlaLookAHead=null;
  federateName=new Parameter(this,""String_Node_Str"");
  federateName.setDisplayName(""String_Node_Str"");
  federateName.setTypeEquals(BaseType.STRING);
  federateName.setExpression(""String_Node_Str"");
  attributeChanged(federateName);
  federationName=new Parameter(this,""String_Node_Str"");
  federationName.setDisplayName(""String_Node_Str"");
  federationName.setTypeEquals(BaseType.STRING);
  federationName.setExpression(""String_Node_Str"");
  attributeChanged(federationName);
  fedFile=new FileParameter(this,""String_Node_Str"");
  fedFile.setDisplayName(""String_Node_Str"");
  new Parameter(fedFile,""String_Node_Str"",BooleanToken.TRUE);
  new Parameter(fedFile,""String_Node_Str"",BooleanToken.FALSE);
  fedFile.setExpression(""String_Node_Str"");
  eventBased=new Parameter(this,""String_Node_Str"");
  eventBased.setTypeEquals(BaseType.BOOLEAN);
  eventBased.setExpression(""String_Node_Str"");
  eventBased.setDisplayName(""String_Node_Str"");
  attributeChanged(eventBased);
  timeStepped=new Parameter(this,""String_Node_Str"");
  timeStepped.setTypeEquals(BaseType.BOOLEAN);
  timeStepped.setExpression(""String_Node_Str"");
  timeStepped.setDisplayName(""String_Node_Str"");
  attributeChanged(timeStepped);
  isTimeConstrained=new Parameter(this,""String_Node_Str"");
  isTimeConstrained.setTypeEquals(BaseType.BOOLEAN);
  isTimeConstrained.setExpression(""String_Node_Str"");
  isTimeConstrained.setDisplayName(""String_Node_Str"");
  isTimeConstrained.setVisibility(Settable.NOT_EDITABLE);
  attributeChanged(isTimeConstrained);
  isTimeRegulator=new Parameter(this,""String_Node_Str"");
  isTimeRegulator.setTypeEquals(BaseType.BOOLEAN);
  isTimeRegulator.setExpression(""String_Node_Str"");
  isTimeRegulator.setDisplayName(""String_Node_Str"");
  isTimeRegulator.setVisibility(Settable.NOT_EDITABLE);
  attributeChanged(isTimeRegulator);
  hlaStartTime=new Parameter(this,""String_Node_Str"");
  hlaStartTime.setDisplayName(""String_Node_Str"");
  hlaStartTime.setExpression(""String_Node_Str"");
  hlaStartTime.setTypeEquals(BaseType.DOUBLE);
  attributeChanged(hlaStartTime);
  hlaTimeStep=new Parameter(this,""String_Node_Str"");
  hlaTimeStep.setDisplayName(""String_Node_Str"");
  hlaTimeStep.setExpression(""String_Node_Str"");
  hlaTimeStep.setTypeEquals(BaseType.DOUBLE);
  hlaTimeStep.setVisibility(Settable.NOT_EDITABLE);
  attributeChanged(hlaTimeStep);
  hlaLookAHead=new Parameter(this,""String_Node_Str"");
  hlaLookAHead.setDisplayName(""String_Node_Str"");
  hlaLookAHead.setExpression(""String_Node_Str"");
  hlaLookAHead.setTypeEquals(BaseType.DOUBLE);
  attributeChanged(hlaLookAHead);
  requireSynchronization=new Parameter(this,""String_Node_Str"");
  requireSynchronization.setTypeEquals(BaseType.BOOLEAN);
  requireSynchronization.setExpression(""String_Node_Str"");
  requireSynchronization.setDisplayName(""String_Node_Str"");
  attributeChanged(requireSynchronization);
  synchronizationPointName=new Parameter(this,""String_Node_Str"");
  synchronizationPointName.setDisplayName(""String_Node_Str"");
  synchronizationPointName.setTypeEquals(BaseType.STRING);
  synchronizationPointName.setExpression(""String_Node_Str"");
  attributeChanged(synchronizationPointName);
  isCreator=new Parameter(this,""String_Node_Str"");
  isCreator.setTypeEquals(BaseType.BOOLEAN);
  isCreator.setExpression(""String_Node_Str"");
  isCreator.setDisplayName(""String_Node_Str"");
  attributeChanged(isCreator);
}","/** 
 * Construct a HlaManager with a name and a container. The container argument must not be null, or a NullPointerException will be thrown. This actor will use the workspace of the container for synchronization and version counts. If the name argument is null, then the name is set to the empty string. Increment the version of the workspace.
 * @param container Container of this attribute.
 * @param name Name of this attribute.
 * @exception IllegalActionException If the container is incompatiblewith this actor.
 * @exception NameDuplicationException If the name coincides withan actor already in the container.
 */
public HlaManager(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  _rtia=null;
  _federateAmbassador=null;
  _hlaAttributesToPublish=new HashMap<String,Object[]>();
  _hlaAttributesSubscribedTo=new HashMap<String,Object[]>();
  _fromFederationEvents=new HashMap<String,LinkedList<TimedEvent>>();
  _objectIdToClassHandle=new HashMap<Integer,Integer>();
  _classIdToPtIIClasses=new HashMap<Integer,ComponentEntity>();
  _newlyCreated=new LinkedList<Instantiable>();
  _freeActors=new HashMap<Integer,LinkedList<ComponentEntity>>();
  _hlaStartTime=null;
  _hlaTimeStep=null;
  _hlaLookAHead=null;
  federateName=new Parameter(this,""String_Node_Str"");
  federateName.setDisplayName(""String_Node_Str"");
  federateName.setTypeEquals(BaseType.STRING);
  federateName.setExpression(""String_Node_Str"");
  attributeChanged(federateName);
  federationName=new Parameter(this,""String_Node_Str"");
  federationName.setDisplayName(""String_Node_Str"");
  federationName.setTypeEquals(BaseType.STRING);
  federationName.setExpression(""String_Node_Str"");
  attributeChanged(federationName);
  fedFile=new FileParameter(this,""String_Node_Str"");
  fedFile.setDisplayName(""String_Node_Str"");
  new Parameter(fedFile,""String_Node_Str"",BooleanToken.TRUE);
  new Parameter(fedFile,""String_Node_Str"",BooleanToken.FALSE);
  fedFile.setExpression(""String_Node_Str"");
  eventBased=new Parameter(this,""String_Node_Str"");
  eventBased.setTypeEquals(BaseType.BOOLEAN);
  eventBased.setExpression(""String_Node_Str"");
  eventBased.setDisplayName(""String_Node_Str"");
  attributeChanged(eventBased);
  timeStepped=new Parameter(this,""String_Node_Str"");
  timeStepped.setTypeEquals(BaseType.BOOLEAN);
  timeStepped.setExpression(""String_Node_Str"");
  timeStepped.setDisplayName(""String_Node_Str"");
  attributeChanged(timeStepped);
  isTimeConstrained=new Parameter(this,""String_Node_Str"");
  isTimeConstrained.setTypeEquals(BaseType.BOOLEAN);
  isTimeConstrained.setExpression(""String_Node_Str"");
  isTimeConstrained.setDisplayName(""String_Node_Str"");
  isTimeConstrained.setVisibility(Settable.NOT_EDITABLE);
  attributeChanged(isTimeConstrained);
  isTimeRegulator=new Parameter(this,""String_Node_Str"");
  isTimeRegulator.setTypeEquals(BaseType.BOOLEAN);
  isTimeRegulator.setExpression(""String_Node_Str"");
  isTimeRegulator.setDisplayName(""String_Node_Str"");
  isTimeRegulator.setVisibility(Settable.NOT_EDITABLE);
  attributeChanged(isTimeRegulator);
  hlaStartTime=new Parameter(this,""String_Node_Str"");
  hlaStartTime.setDisplayName(""String_Node_Str"");
  hlaStartTime.setExpression(""String_Node_Str"");
  hlaStartTime.setTypeEquals(BaseType.DOUBLE);
  attributeChanged(hlaStartTime);
  hlaTimeStep=new Parameter(this,""String_Node_Str"");
  hlaTimeStep.setDisplayName(""String_Node_Str"");
  hlaTimeStep.setExpression(""String_Node_Str"");
  hlaTimeStep.setTypeEquals(BaseType.DOUBLE);
  hlaTimeStep.setVisibility(Settable.NOT_EDITABLE);
  attributeChanged(hlaTimeStep);
  hlaLookAHead=new Parameter(this,""String_Node_Str"");
  hlaLookAHead.setDisplayName(""String_Node_Str"");
  hlaLookAHead.setExpression(""String_Node_Str"");
  hlaLookAHead.setTypeEquals(BaseType.DOUBLE);
  attributeChanged(hlaLookAHead);
  requireSynchronization=new Parameter(this,""String_Node_Str"");
  requireSynchronization.setTypeEquals(BaseType.BOOLEAN);
  requireSynchronization.setExpression(""String_Node_Str"");
  requireSynchronization.setDisplayName(""String_Node_Str"");
  attributeChanged(requireSynchronization);
  synchronizationPointName=new Parameter(this,""String_Node_Str"");
  synchronizationPointName.setDisplayName(""String_Node_Str"");
  synchronizationPointName.setTypeEquals(BaseType.STRING);
  synchronizationPointName.setExpression(""String_Node_Str"");
  attributeChanged(synchronizationPointName);
  isCreator=new Parameter(this,""String_Node_Str"");
  isCreator.setTypeEquals(BaseType.BOOLEAN);
  isCreator.setExpression(""String_Node_Str"");
  isCreator.setDisplayName(""String_Node_Str"");
  attributeChanged(isCreator);
}"
72528,"/** 
 * Clone the actor into the specified workspace.
 * @param workspace The workspace for the new object.
 * @return A new actor.
 * @exception CloneNotSupportedException If a derived class containsan attribute that cannot be cloned.
 */
@Override public Object clone(Workspace workspace) throws CloneNotSupportedException {
  HlaManager newObject=(HlaManager)super.clone(workspace);
  newObject._hlaAttributesToPublish=new HashMap<String,Object[]>();
  newObject._hlaAttributesSubscribedTo=new HashMap<String,Object[]>();
  newObject._fromFederationEvents=new HashMap<String,LinkedList<TimedEvent>>();
  newObject._objectIdToClassHandle=new HashMap<Integer,Integer>();
  newObject._rtia=null;
  newObject._federateAmbassador=null;
  newObject._federateName=_federateName;
  newObject._federationName=_federationName;
  newObject._isTimeConstrained=_isTimeConstrained;
  newObject._isTimeRegulator=_isTimeRegulator;
  try {
    newObject._hlaStartTime=((DoubleToken)hlaStartTime.getToken()).doubleValue();
    newObject._hlaTimeStep=((DoubleToken)hlaTimeStep.getToken()).doubleValue();
    newObject._hlaLookAHead=((DoubleToken)hlaLookAHead.getToken()).doubleValue();
  }
 catch (  IllegalActionException ex) {
    CloneNotSupportedException ex2=new CloneNotSupportedException(""String_Node_Str"");
    ex2.initCause(ex);
    throw ex2;
  }
  newObject._requireSynchronization=_requireSynchronization;
  newObject._synchronizationPointName=_synchronizationPointName;
  newObject._isCreator=_isCreator;
  newObject._eventBased=_eventBased;
  newObject._timeStepped=_timeStepped;
  return newObject;
}","/** 
 * Clone the actor into the specified workspace.
 * @param workspace The workspace for the new object.
 * @return A new actor.
 * @exception CloneNotSupportedException If a derived class containsan attribute that cannot be cloned.
 */
@Override public Object clone(Workspace workspace) throws CloneNotSupportedException {
  HlaManager newObject=(HlaManager)super.clone(workspace);
  newObject._hlaAttributesToPublish=new HashMap<String,Object[]>();
  newObject._hlaAttributesSubscribedTo=new HashMap<String,Object[]>();
  newObject._fromFederationEvents=new HashMap<String,LinkedList<TimedEvent>>();
  newObject._objectIdToClassHandle=new HashMap<Integer,Integer>();
  newObject._freeActors=new HashMap<Integer,LinkedList<ComponentEntity>>();
  newObject._classIdToPtIIClasses=new HashMap<Integer,ComponentEntity>();
  newObject._newlyCreated=new LinkedList<Instantiable>();
  newObject._rtia=null;
  newObject._federateAmbassador=null;
  newObject._federateName=_federateName;
  newObject._federationName=_federationName;
  newObject._isTimeConstrained=_isTimeConstrained;
  newObject._isTimeRegulator=_isTimeRegulator;
  try {
    newObject._hlaStartTime=((DoubleToken)hlaStartTime.getToken()).doubleValue();
    newObject._hlaTimeStep=((DoubleToken)hlaTimeStep.getToken()).doubleValue();
    newObject._hlaLookAHead=((DoubleToken)hlaLookAHead.getToken()).doubleValue();
  }
 catch (  IllegalActionException ex) {
    CloneNotSupportedException ex2=new CloneNotSupportedException(""String_Node_Str"");
    ex2.initCause(ex);
    throw ex2;
  }
  newObject._requireSynchronization=_requireSynchronization;
  newObject._synchronizationPointName=_synchronizationPointName;
  newObject._isCreator=_isCreator;
  newObject._eventBased=_eventBased;
  newObject._timeStepped=_timeStepped;
  return newObject;
}"
72529,"@Override public void wrapup() throws IllegalActionException {
  super.wrapup();
  attributeHandle=Integer.MIN_VALUE;
  classHandle=Integer.MIN_VALUE;
  objectHandle=Integer.MIN_VALUE;
}","@Override public void wrapup() throws IllegalActionException {
  super.wrapup();
  setAttributeHandle(Integer.MIN_VALUE);
  setClassHandle(Integer.MIN_VALUE);
  setObjectHandle(Integer.MIN_VALUE);
}"
72530,"/** 
 * Construct a HlaSubscriber actor.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the entity cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public HlaSubscriber(CompositeEntity container,String name) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  output=new TypedIOPort(this,""String_Node_Str"",false,true);
  typeSelector=new StringParameter(this,""String_Node_Str"");
  typeSelector.addChoice(""String_Node_Str"");
  typeSelector.addChoice(""String_Node_Str"");
  typeSelector.addChoice(""String_Node_Str"");
  typeSelector.addChoice(""String_Node_Str"");
  output.addTypeListener(new TypeListener(){
    @Override public void typeChanged(    TypeEvent event){
      typeSelector.setExpression(event.getNewType().toString());
    }
  }
);
  attributeHandle=Integer.MIN_VALUE;
  classHandle=Integer.MIN_VALUE;
  objectHandle=Integer.MIN_VALUE;
  useCertiMessageBuffer=new Parameter(this,""String_Node_Str"");
  useCertiMessageBuffer.setTypeEquals(BaseType.BOOLEAN);
  useCertiMessageBuffer.setExpression(""String_Node_Str"");
  useCertiMessageBuffer.setDisplayName(""String_Node_Str"");
  attributeChanged(useCertiMessageBuffer);
  objectName=new Parameter(this,""String_Node_Str"");
  objectName.setVisibility(Settable.NOT_EDITABLE);
  objectName.setDisplayName(""String_Node_Str"");
  objectName.setTypeEquals(BaseType.STRING);
  objectName.setExpression(""String_Node_Str"");
  parameterName=new Parameter(this,""String_Node_Str"");
  parameterName.setDisplayName(""String_Node_Str"");
  parameterName.setTypeEquals(BaseType.STRING);
  parameterName.setExpression(""String_Node_Str"");
  attributeChanged(objectName);
  attributeChanged(parameterName);
  _reflectedAttributeValues=new LinkedList<TimedEvent>();
  _useCertiMessageBuffer=false;
}","/** 
 * Construct a HlaSubscriber actor.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the entity cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public HlaSubscriber(CompositeEntity container,String name) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  output=new TypedIOPort(this,""String_Node_Str"",false,true);
  typeSelector=new StringParameter(this,""String_Node_Str"");
  typeSelector.setDisplayName(""String_Node_Str"");
  typeSelector.addChoice(""String_Node_Str"");
  typeSelector.addChoice(""String_Node_Str"");
  typeSelector.addChoice(""String_Node_Str"");
  typeSelector.addChoice(""String_Node_Str"");
  output.addTypeListener(new TypeListener(){
    @Override public void typeChanged(    TypeEvent event){
      typeSelector.setExpression(event.getNewType().toString());
    }
  }
);
  _attributeHandle=Integer.MIN_VALUE;
  _classHandle=Integer.MIN_VALUE;
  _objectHandle=Integer.MIN_VALUE;
  useCertiMessageBuffer=new Parameter(this,""String_Node_Str"");
  useCertiMessageBuffer.setTypeEquals(BaseType.BOOLEAN);
  useCertiMessageBuffer.setExpression(""String_Node_Str"");
  useCertiMessageBuffer.setDisplayName(""String_Node_Str"");
  attributeChanged(useCertiMessageBuffer);
  objectName=new Parameter(this,""String_Node_Str"");
  objectName.setVisibility(Settable.NOT_EDITABLE);
  objectName.setDisplayName(""String_Node_Str"");
  objectName.setTypeEquals(BaseType.STRING);
  objectName.setExpression(""String_Node_Str"");
  parameterName=new Parameter(this,""String_Node_Str"");
  parameterName.setDisplayName(""String_Node_Str"");
  parameterName.setTypeEquals(BaseType.STRING);
  parameterName.setExpression(""String_Node_Str"");
  attributeChanged(objectName);
  attributeChanged(parameterName);
  _reflectedAttributeValues=new LinkedList<TimedEvent>();
  _useCertiMessageBuffer=false;
}"
72531,"/** 
 * Clone the actor into the specified workspace.
 * @param workspace The workspace for the new object.
 * @return A new actor.
 * @exception CloneNotSupportedException If a derived class containsan attribute that cannot be cloned.
 */
@Override public Object clone(Workspace workspace) throws CloneNotSupportedException {
  HlaSubscriber newObject=(HlaSubscriber)super.clone(workspace);
  newObject._reflectedAttributeValues=new LinkedList<TimedEvent>();
  newObject._useCertiMessageBuffer=_useCertiMessageBuffer;
  newObject.attributeHandle=attributeHandle;
  newObject.classHandle=classHandle;
  newObject.objectHandle=Integer.MIN_VALUE;
  return newObject;
}","/** 
 * Clone the actor into the specified workspace.
 * @param workspace The workspace for the new object.
 * @return A new actor.
 * @exception CloneNotSupportedException If a derived class containsan attribute that cannot be cloned.
 */
@Override public Object clone(Workspace workspace) throws CloneNotSupportedException {
  HlaSubscriber newObject=(HlaSubscriber)super.clone(workspace);
  newObject._reflectedAttributeValues=new LinkedList<TimedEvent>();
  newObject._useCertiMessageBuffer=_useCertiMessageBuffer;
  newObject.setAttributeHandle(getAttributeHandle());
  newObject.setClassHandle(getClassHandle());
  newObject.setObjectHandle(Integer.MIN_VALUE);
  return newObject;
}"
72532,"/** 
 * Send each update value of the HLA attribute (mapped to this actor) as token when its time.
 * @exception IllegalActionException Not thrown here.
 */
@Override public void fire() throws IllegalActionException {
  super.fire();
  Time currentTime=getDirector().getModelTime();
  Iterator<TimedEvent> it=_reflectedAttributeValues.iterator();
  while (it.hasNext()) {
    TimedEvent te=it.next();
    if (te.timeStamp.compareTo(currentTime) == 0) {
      Token content=_buildToken((Object[])te.contents);
      int origin=-1;
      if (te instanceof OriginatedEvent) {
        OriginatedEvent oe=(OriginatedEvent)te;
        origin=oe.objectID;
      }
      if (origin == -1 || origin == objectHandle) {
        this.outputPortList().get(0).send(0,content);
        if (_debugging) {
          _debug(this.getDisplayName() + ""String_Node_Str"" + ""String_Node_Str""+ getParameterName()+ ""String_Node_Str""+ origin+ ""String_Node_Str""+ te.timeStamp+ ""String_Node_Str""+ content.toString()+ ""String_Node_Str"");
        }
      }
      it.remove();
    }
  }
}","/** 
 * Send each update value of the HLA attribute (mapped to this actor) as token when its time.
 * @exception IllegalActionException Not thrown here.
 */
@Override public void fire() throws IllegalActionException {
  super.fire();
  Time currentTime=getDirector().getModelTime();
  Iterator<TimedEvent> it=_reflectedAttributeValues.iterator();
  while (it.hasNext()) {
    TimedEvent te=it.next();
    if (te.timeStamp.compareTo(currentTime) == 0) {
      Token content=_buildToken((Object[])te.contents);
      int origin=-1;
      if (te instanceof OriginatedEvent) {
        OriginatedEvent oe=(OriginatedEvent)te;
        origin=oe.objectID;
      }
      if (origin == -1 || origin == getObjectHandle()) {
        this.outputPortList().get(0).send(0,content);
        if (_debugging) {
          _debug(this.getDisplayName() + ""String_Node_Str"" + ""String_Node_Str""+ getParameterName()+ ""String_Node_Str""+ origin+ ""String_Node_Str""+ te.timeStamp+ ""String_Node_Str""+ content.toString()+ ""String_Node_Str"");
        }
      }
      it.remove();
    }
  }
}"
72533,"/** 
 * Configure the different HLASubscribers (ie will make them suscribe to what they should)
 */
private void setUpHLASubscriber(RTIambassador rtia) throws NameNotFound, ObjectClassNotDefined, FederateNotExecutionMember, RTIinternalError, AttributeNotDefined, SaveInProgress, RestoreInProgress, ConcurrentAccessAttempted {
  Iterator<Entry<String,Object[]>> ot=_hlaAttributesSubscribedTo.entrySet().iterator();
  while (ot.hasNext()) {
    Map.Entry<String,Object[]> elt=ot.next();
    Object[] tObj=elt.getValue();
    TypedIOPort port=_getPortFromTab(tObj);
    int classHandle=rtia.getObjectClassHandle(_getClassNameFromTab(tObj));
    int objAttributeHandle=rtia.getAttributeHandle(((HlaSubscriber)port.getContainer()).getParameterName(),classHandle);
    elt.setValue(new Object[]{_getPortFromTab(tObj),_getTypeFromTab(tObj),_getClassNameFromTab(tObj),classHandle,objAttributeHandle});
  }
  HashMap<String,LinkedList<String>> classHandleHlaSubscriberTable=null;
  classHandleHlaSubscriberTable=new HashMap<String,LinkedList<String>>();
  Iterator<Entry<String,Object[]>> it4=_hlaAttributesSubscribedTo.entrySet().iterator();
  while (it4.hasNext()) {
    Map.Entry<String,Object[]> elt=it4.next();
    Object[] tObj=elt.getValue();
    String classHandleName=_getClassNameFromTab(tObj);
    if (classHandleHlaSubscriberTable.containsKey(classHandleName)) {
      classHandleHlaSubscriberTable.get(classHandleName).add(elt.getKey());
    }
 else {
      LinkedList<String> list=new LinkedList<String>();
      list.add(elt.getKey());
      classHandleHlaSubscriberTable.put(classHandleName,list);
    }
  }
  Iterator<Entry<String,LinkedList<String>>> it5=classHandleHlaSubscriberTable.entrySet().iterator();
  while (it5.hasNext()) {
    Map.Entry<String,LinkedList<String>> elt=it5.next();
    LinkedList<String> hlaSubList=elt.getValue();
    int classHandle=rtia.getObjectClassHandle(elt.getKey());
    AttributeHandleSet _attributesLocal=RtiFactoryFactory.getRtiFactory().createAttributeHandleSet();
    for (    String s : hlaSubList) {
      _attributesLocal.add(_getAttributeHandleFromTab(_hlaAttributesSubscribedTo.get(s)));
    }
    _rtia.subscribeObjectClassAttributes(classHandle,_attributesLocal);
  }
}","/** 
 * Configure the different HLASubscribers (ie will make them suscribe to what they should)
 */
private void setUpHLASubscriber(RTIambassador rtia) throws NameNotFound, ObjectClassNotDefined, FederateNotExecutionMember, RTIinternalError, AttributeNotDefined, SaveInProgress, RestoreInProgress, ConcurrentAccessAttempted {
  CompositeEntity container=(CompositeEntity)getContainer();
  List<ComponentEntity> classes=container.classDefinitionList();
  for (  ComponentEntity currentClass : classes) {
    try {
      int classHandle=rtia.getObjectClassHandle(currentClass.getName());
      _idToClasses.put(classHandle,currentClass);
      AttributeHandleSet _attributesLocal=RtiFactoryFactory.getRtiFactory().createAttributeHandleSet();
      List<HlaSubscriber> subscribers=((CompositeActor)currentClass).entityList(HlaSubscriber.class);
      for (      HlaSubscriber sub : subscribers) {
        int attributeHandle=rtia.getAttributeHandle(sub.getParameterName(),classHandle);
        _attributesLocal.add(attributeHandle);
      }
      rtia.subscribeObjectClassAttributes(classHandle,_attributesLocal);
    }
 catch (    Exception e) {
    }
  }
  Iterator<Entry<String,Object[]>> ot=_hlaAttributesSubscribedTo.entrySet().iterator();
  while (ot.hasNext()) {
    Map.Entry<String,Object[]> elt=ot.next();
    Object[] tObj=elt.getValue();
    TypedIOPort port=_getPortFromTab(tObj);
    int classHandle=rtia.getObjectClassHandle(_getClassNameFromTab(tObj));
    int objAttributeHandle=rtia.getAttributeHandle(((HlaSubscriber)port.getContainer()).getParameterName(),classHandle);
    elt.setValue(new Object[]{_getPortFromTab(tObj),_getTypeFromTab(tObj),_getClassNameFromTab(tObj),classHandle,objAttributeHandle});
  }
}"
72534,"/** 
 * Construct a HlaManager with a name and a container. The container argument must not be null, or a NullPointerException will be thrown. This actor will use the workspace of the container for synchronization and version counts. If the name argument is null, then the name is set to the empty string. Increment the version of the workspace.
 * @param container Container of this attribute.
 * @param name Name of this attribute.
 * @exception IllegalActionException If the container is incompatiblewith this actor.
 * @exception NameDuplicationException If the name coincides withan actor already in the container.
 */
public HlaManager(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  _rtia=null;
  _federateAmbassador=null;
  _hlaAttributesToPublish=new HashMap<String,Object[]>();
  _hlaAttributesSubscribedTo=new HashMap<String,Object[]>();
  _fromFederationEvents=new HashMap<String,LinkedList<TimedEvent>>();
  _objectIdToClassHandle=new HashMap<Integer,Integer>();
  _hlaStartTime=null;
  _hlaTimeStep=null;
  _hlaLookAHead=null;
  federateName=new Parameter(this,""String_Node_Str"");
  federateName.setDisplayName(""String_Node_Str"");
  federateName.setTypeEquals(BaseType.STRING);
  federateName.setExpression(""String_Node_Str"");
  attributeChanged(federateName);
  federationName=new Parameter(this,""String_Node_Str"");
  federationName.setDisplayName(""String_Node_Str"");
  federationName.setTypeEquals(BaseType.STRING);
  federationName.setExpression(""String_Node_Str"");
  attributeChanged(federationName);
  fedFile=new FileParameter(this,""String_Node_Str"");
  fedFile.setDisplayName(""String_Node_Str"");
  new Parameter(fedFile,""String_Node_Str"",BooleanToken.TRUE);
  new Parameter(fedFile,""String_Node_Str"",BooleanToken.FALSE);
  fedFile.setExpression(""String_Node_Str"");
  eventBased=new Parameter(this,""String_Node_Str"");
  eventBased.setTypeEquals(BaseType.BOOLEAN);
  eventBased.setExpression(""String_Node_Str"");
  eventBased.setDisplayName(""String_Node_Str"");
  attributeChanged(eventBased);
  timeStepped=new Parameter(this,""String_Node_Str"");
  timeStepped.setTypeEquals(BaseType.BOOLEAN);
  timeStepped.setExpression(""String_Node_Str"");
  timeStepped.setDisplayName(""String_Node_Str"");
  attributeChanged(timeStepped);
  isTimeConstrained=new Parameter(this,""String_Node_Str"");
  isTimeConstrained.setTypeEquals(BaseType.BOOLEAN);
  isTimeConstrained.setExpression(""String_Node_Str"");
  isTimeConstrained.setDisplayName(""String_Node_Str"");
  isTimeConstrained.setVisibility(Settable.NOT_EDITABLE);
  attributeChanged(isTimeConstrained);
  isTimeRegulator=new Parameter(this,""String_Node_Str"");
  isTimeRegulator.setTypeEquals(BaseType.BOOLEAN);
  isTimeRegulator.setExpression(""String_Node_Str"");
  isTimeRegulator.setDisplayName(""String_Node_Str"");
  isTimeRegulator.setVisibility(Settable.NOT_EDITABLE);
  attributeChanged(isTimeRegulator);
  hlaStartTime=new Parameter(this,""String_Node_Str"");
  hlaStartTime.setDisplayName(""String_Node_Str"");
  hlaStartTime.setExpression(""String_Node_Str"");
  hlaStartTime.setTypeEquals(BaseType.DOUBLE);
  attributeChanged(hlaStartTime);
  hlaTimeStep=new Parameter(this,""String_Node_Str"");
  hlaTimeStep.setDisplayName(""String_Node_Str"");
  hlaTimeStep.setExpression(""String_Node_Str"");
  hlaTimeStep.setTypeEquals(BaseType.DOUBLE);
  hlaTimeStep.setVisibility(Settable.NOT_EDITABLE);
  attributeChanged(hlaTimeStep);
  hlaLookAHead=new Parameter(this,""String_Node_Str"");
  hlaLookAHead.setDisplayName(""String_Node_Str"");
  hlaLookAHead.setExpression(""String_Node_Str"");
  hlaLookAHead.setTypeEquals(BaseType.DOUBLE);
  attributeChanged(hlaLookAHead);
  requireSynchronization=new Parameter(this,""String_Node_Str"");
  requireSynchronization.setTypeEquals(BaseType.BOOLEAN);
  requireSynchronization.setExpression(""String_Node_Str"");
  requireSynchronization.setDisplayName(""String_Node_Str"");
  attributeChanged(requireSynchronization);
  synchronizationPointName=new Parameter(this,""String_Node_Str"");
  synchronizationPointName.setDisplayName(""String_Node_Str"");
  synchronizationPointName.setTypeEquals(BaseType.STRING);
  synchronizationPointName.setExpression(""String_Node_Str"");
  attributeChanged(synchronizationPointName);
  isCreator=new Parameter(this,""String_Node_Str"");
  isCreator.setTypeEquals(BaseType.BOOLEAN);
  isCreator.setExpression(""String_Node_Str"");
  isCreator.setDisplayName(""String_Node_Str"");
  attributeChanged(isCreator);
}","/** 
 * Construct a HlaManager with a name and a container. The container argument must not be null, or a NullPointerException will be thrown. This actor will use the workspace of the container for synchronization and version counts. If the name argument is null, then the name is set to the empty string. Increment the version of the workspace.
 * @param container Container of this attribute.
 * @param name Name of this attribute.
 * @exception IllegalActionException If the container is incompatiblewith this actor.
 * @exception NameDuplicationException If the name coincides withan actor already in the container.
 */
public HlaManager(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  _rtia=null;
  _federateAmbassador=null;
  _hlaAttributesToPublish=new HashMap<String,Object[]>();
  _hlaAttributesSubscribedTo=new HashMap<String,Object[]>();
  _fromFederationEvents=new HashMap<String,LinkedList<TimedEvent>>();
  _objectIdToClassHandle=new HashMap<Integer,Integer>();
  _idToClasses=new HashMap<Integer,ComponentEntity>();
  _hlaStartTime=null;
  _hlaTimeStep=null;
  _hlaLookAHead=null;
  federateName=new Parameter(this,""String_Node_Str"");
  federateName.setDisplayName(""String_Node_Str"");
  federateName.setTypeEquals(BaseType.STRING);
  federateName.setExpression(""String_Node_Str"");
  attributeChanged(federateName);
  federationName=new Parameter(this,""String_Node_Str"");
  federationName.setDisplayName(""String_Node_Str"");
  federationName.setTypeEquals(BaseType.STRING);
  federationName.setExpression(""String_Node_Str"");
  attributeChanged(federationName);
  fedFile=new FileParameter(this,""String_Node_Str"");
  fedFile.setDisplayName(""String_Node_Str"");
  new Parameter(fedFile,""String_Node_Str"",BooleanToken.TRUE);
  new Parameter(fedFile,""String_Node_Str"",BooleanToken.FALSE);
  fedFile.setExpression(""String_Node_Str"");
  eventBased=new Parameter(this,""String_Node_Str"");
  eventBased.setTypeEquals(BaseType.BOOLEAN);
  eventBased.setExpression(""String_Node_Str"");
  eventBased.setDisplayName(""String_Node_Str"");
  attributeChanged(eventBased);
  timeStepped=new Parameter(this,""String_Node_Str"");
  timeStepped.setTypeEquals(BaseType.BOOLEAN);
  timeStepped.setExpression(""String_Node_Str"");
  timeStepped.setDisplayName(""String_Node_Str"");
  attributeChanged(timeStepped);
  isTimeConstrained=new Parameter(this,""String_Node_Str"");
  isTimeConstrained.setTypeEquals(BaseType.BOOLEAN);
  isTimeConstrained.setExpression(""String_Node_Str"");
  isTimeConstrained.setDisplayName(""String_Node_Str"");
  isTimeConstrained.setVisibility(Settable.NOT_EDITABLE);
  attributeChanged(isTimeConstrained);
  isTimeRegulator=new Parameter(this,""String_Node_Str"");
  isTimeRegulator.setTypeEquals(BaseType.BOOLEAN);
  isTimeRegulator.setExpression(""String_Node_Str"");
  isTimeRegulator.setDisplayName(""String_Node_Str"");
  isTimeRegulator.setVisibility(Settable.NOT_EDITABLE);
  attributeChanged(isTimeRegulator);
  hlaStartTime=new Parameter(this,""String_Node_Str"");
  hlaStartTime.setDisplayName(""String_Node_Str"");
  hlaStartTime.setExpression(""String_Node_Str"");
  hlaStartTime.setTypeEquals(BaseType.DOUBLE);
  attributeChanged(hlaStartTime);
  hlaTimeStep=new Parameter(this,""String_Node_Str"");
  hlaTimeStep.setDisplayName(""String_Node_Str"");
  hlaTimeStep.setExpression(""String_Node_Str"");
  hlaTimeStep.setTypeEquals(BaseType.DOUBLE);
  hlaTimeStep.setVisibility(Settable.NOT_EDITABLE);
  attributeChanged(hlaTimeStep);
  hlaLookAHead=new Parameter(this,""String_Node_Str"");
  hlaLookAHead.setDisplayName(""String_Node_Str"");
  hlaLookAHead.setExpression(""String_Node_Str"");
  hlaLookAHead.setTypeEquals(BaseType.DOUBLE);
  attributeChanged(hlaLookAHead);
  requireSynchronization=new Parameter(this,""String_Node_Str"");
  requireSynchronization.setTypeEquals(BaseType.BOOLEAN);
  requireSynchronization.setExpression(""String_Node_Str"");
  requireSynchronization.setDisplayName(""String_Node_Str"");
  attributeChanged(requireSynchronization);
  synchronizationPointName=new Parameter(this,""String_Node_Str"");
  synchronizationPointName.setDisplayName(""String_Node_Str"");
  synchronizationPointName.setTypeEquals(BaseType.STRING);
  synchronizationPointName.setExpression(""String_Node_Str"");
  attributeChanged(synchronizationPointName);
  isCreator=new Parameter(this,""String_Node_Str"");
  isCreator.setTypeEquals(BaseType.BOOLEAN);
  isCreator.setExpression(""String_Node_Str"");
  isCreator.setDisplayName(""String_Node_Str"");
  attributeChanged(isCreator);
}"
72535,"/** 
 * Initialize command, arguments and environment variables to invoke the subprocess.
 * @param directory The current path where the simulation is executed.
 * @exception IllegalActionException If the directory to launch theRTIG process doesn't exit.
 */
public void initialize(String directory) throws IllegalActionException {
  _directoryAsFile=null;
  _isAlreadyLaunched=false;
  _runtime=Runtime.getRuntime();
  String certiHome=null;
  if (System.getenv(""String_Node_Str"") != null) {
    certiHome=System.getenv(""String_Node_Str"");
  }
 else   if (_hlaManager.getContainer().getAttribute(""String_Node_Str"") != null) {
    certiHome=((StringToken)((Parameter)_hlaManager.getContainer().getAttribute(""String_Node_Str"")).getToken()).stringValue();
  }
 else   if (_hlaManager.getAttribute(""String_Node_Str"") != null) {
    certiHome=((StringToken)((Parameter)_hlaManager.getAttribute(""String_Node_Str"")).getToken()).stringValue();
  }
 else {
    throw new IllegalActionException(_hlaManager,""String_Node_Str"");
  }
  if (_debugging) {
    _debug(""String_Node_Str"" + certiHome);
  }
  File fedFileName=new File(directory);
  List<String> commandList=new LinkedList<String>();
  commandList=_getCommandList();
  commandList.add(certiHome + ""String_Node_Str"");
  commandList.add(fedFileName.getName());
  _commandArray=commandList.toArray(new String[commandList.size()]);
  String pathSeparator=System.getProperty(""String_Node_Str"");
  _environmentArray=new String[1];
  String osName=StringUtilities.getProperty(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + osName);
  if (osName.startsWith(""String_Node_Str"")) {
    String dyldLibraryPath=""String_Node_Str"" + certiHome + ""String_Node_Str"";
    String dyldVariable=System.getenv(""String_Node_Str"");
    if (dyldVariable != null) {
      dyldLibraryPath+=pathSeparator + dyldVariable;
    }
    _environmentArray[0]=dyldLibraryPath;
  }
 else   if (osName.startsWith(""String_Node_Str"")) {
    String path=""String_Node_Str"" + certiHome + ""String_Node_Str"";
    String pathVariable=System.getenv(""String_Node_Str"");
    if (pathVariable != null) {
      path+=pathSeparator + pathVariable;
    }
    _environmentArray[0]=path;
  }
 else {
    String ldLibraryPath=""String_Node_Str"" + certiHome + ""String_Node_Str"";
    String ldVariable=System.getenv(""String_Node_Str"");
    if (ldVariable != null) {
      ldLibraryPath+=pathSeparator + ldVariable;
    }
    _environmentArray[0]=ldLibraryPath;
  }
  _directoryAsFile=new File(fedFileName.getParent());
  if (!_directoryAsFile.isDirectory()) {
    throw new IllegalActionException(_hlaManager,""String_Node_Str"" + _directoryAsFile);
  }
}","/** 
 * Initialize command, arguments and environment variables to invoke the subprocess.
 * @param directory The current path where the simulation is executed.
 * @exception IllegalActionException If the directory to launch theRTIG process doesn't exit.
 */
public void initialize(String directory) throws IllegalActionException {
  _directoryAsFile=null;
  _isAlreadyLaunched=false;
  _runtime=Runtime.getRuntime();
  String certiHome=null;
  if (System.getenv(""String_Node_Str"") != null) {
    certiHome=System.getenv(""String_Node_Str"");
  }
 else   if (_hlaManager.getContainer().getAttribute(""String_Node_Str"") != null) {
    certiHome=((StringToken)((Parameter)_hlaManager.getContainer().getAttribute(""String_Node_Str"")).getToken()).stringValue();
  }
 else   if (_hlaManager.getAttribute(""String_Node_Str"") != null) {
    certiHome=((StringToken)((Parameter)_hlaManager.getAttribute(""String_Node_Str"")).getToken()).stringValue();
  }
 else {
    throw new IllegalActionException(_hlaManager,""String_Node_Str"");
  }
  if (_debugging) {
    _debug(""String_Node_Str"" + certiHome);
  }
  File fedFileName=new File(directory);
  List<String> commandList=null;
  commandList=_getCommandList();
  commandList.add(certiHome + ""String_Node_Str"");
  commandList.add(fedFileName.getName());
  _commandArray=commandList.toArray(new String[commandList.size()]);
  String pathSeparator=System.getProperty(""String_Node_Str"");
  _environmentArray=new String[1];
  String osName=StringUtilities.getProperty(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + osName);
  if (osName.startsWith(""String_Node_Str"")) {
    String dyldLibraryPath=""String_Node_Str"" + certiHome + ""String_Node_Str"";
    String dyldVariable=System.getenv(""String_Node_Str"");
    if (dyldVariable != null) {
      dyldLibraryPath+=pathSeparator + dyldVariable;
    }
    _environmentArray[0]=dyldLibraryPath;
  }
 else   if (osName.startsWith(""String_Node_Str"")) {
    String path=""String_Node_Str"" + certiHome + ""String_Node_Str"";
    String pathVariable=System.getenv(""String_Node_Str"");
    if (pathVariable != null) {
      path+=pathSeparator + pathVariable;
    }
    _environmentArray[0]=path;
  }
 else {
    String ldLibraryPath=""String_Node_Str"" + certiHome + ""String_Node_Str"";
    String ldVariable=System.getenv(""String_Node_Str"");
    if (ldVariable != null) {
      ldLibraryPath+=pathSeparator + ldVariable;
    }
    _environmentArray[0]=ldLibraryPath;
  }
  _directoryAsFile=new File(fedFileName.getParent());
  if (!_directoryAsFile.isDirectory()) {
    throw new IllegalActionException(_hlaManager,""String_Node_Str"" + _directoryAsFile);
  }
}"
72536,"/** 
 * Callback to receive updated value of a HLA attribute from the whole Federation (delivered by the RTI (CERTI)).
 */
@Override public void reflectAttributeValues(int theObject,ReflectedAttributes theAttributes,byte[] userSuppliedTag,LogicalTime theTime,EventRetractionHandle retractionHandle) throws ObjectNotKnown, AttributeNotKnown, FederateOwnsAttributes, InvalidFederationTime, FederateInternalError {
  try {
    int classHandle=_objectIdToClassHandle.get(theObject);
    for (int i=0; i < theAttributes.size(); i++) {
      Iterator<Entry<String,Object[]>> ot=_hlaAttributesSubscribedTo.entrySet().iterator();
      while (ot.hasNext()) {
        Map.Entry<String,Object[]> elt=ot.next();
        Object[] tObj=elt.getValue();
        Time ts=null;
        TimedEvent te=null;
        Object value=null;
        if (theAttributes.getAttributeHandle(i) == _getAttributeHandleFromTab(tObj) && _getClassHandleFromTab(tObj) == classHandle) {
          try {
            HlaSubscriber hs=(HlaSubscriber)_getPortFromTab(tObj).getContainer();
            if (_getTypeFromTab(tObj) instanceof RecordType) {
              HlaPtidesEvent hpe=new HlaPtidesEvent(theAttributes.getValue(i));
              ts=new Time(_director,((CertiLogicalTime)theTime).getTime());
              te=new TimedEvent(ts,new Object[]{(RecordType)_getTypeFromTab(tObj),MessageProcessing.decodeHlaValue(hs,(RecordType)_getTypeFromTab(tObj),hpe.getValue()),ts.getDoubleValue(),hpe.getMicroStep(),hpe.getSourceTime()});
            }
 else {
              ts=new Time(_director,((CertiLogicalTime)theTime).getTime());
              value=MessageProcessing.decodeHlaValue(hs,(BaseType)_getTypeFromTab(tObj),theAttributes.getValue(i));
              te=new OriginatedEvent(ts,new Object[]{(BaseType)_getTypeFromTab(tObj),value},theObject);
            }
          }
 catch (          IllegalActionException e) {
            e.printStackTrace();
          }
          HlaSubscriber hs=(HlaSubscriber)(_getPortFromTab(tObj)).getContainer();
          _fromFederationEvents.get(hs.getIdentity()).add(te);
          if (_debugging) {
            _debug(getDisplayName() + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ hs.getParameterName()+ ""String_Node_Str""+ te.timeStamp+ ""String_Node_Str""+ value.toString()+ ""String_Node_Str""+ hs.getDisplayName());
          }
        }
      }
    }
  }
 catch (  ArrayIndexOutOfBounds e) {
    e.printStackTrace();
  }
}","/** 
 * Callback to receive updated value of a HLA attribute from the whole Federation (delivered by the RTI (CERTI)).
 */
@Override public void reflectAttributeValues(int theObject,ReflectedAttributes theAttributes,byte[] userSuppliedTag,LogicalTime theTime,EventRetractionHandle retractionHandle) throws ObjectNotKnown, AttributeNotKnown, FederateOwnsAttributes, InvalidFederationTime, FederateInternalError {
  try {
    int classHandle=_objectIdToClassHandle.get(theObject);
    for (int i=0; i < theAttributes.size(); i++) {
      Iterator<Entry<String,Object[]>> ot=_hlaAttributesSubscribedTo.entrySet().iterator();
      while (ot.hasNext()) {
        Map.Entry<String,Object[]> elt=ot.next();
        Object[] tObj=elt.getValue();
        Time ts=null;
        TimedEvent te=null;
        Object value=null;
        if (theAttributes.getAttributeHandle(i) == _getAttributeHandleFromTab(tObj) && _getClassHandleFromTab(tObj) == classHandle) {
          try {
            HlaSubscriber hs=(HlaSubscriber)_getPortFromTab(tObj).getContainer();
            if (_getTypeFromTab(tObj) instanceof RecordType) {
              HlaPtidesEvent hpe=new HlaPtidesEvent(theAttributes.getValue(i));
              ts=new Time(_director,((CertiLogicalTime)theTime).getTime());
              te=new TimedEvent(ts,new Object[]{(RecordType)_getTypeFromTab(tObj),MessageProcessing.decodeHlaValue(hs,(RecordType)_getTypeFromTab(tObj),hpe.getValue()),ts.getDoubleValue(),hpe.getMicroStep(),hpe.getSourceTime()});
            }
 else {
              ts=new Time(_director,((CertiLogicalTime)theTime).getTime());
              value=MessageProcessing.decodeHlaValue(hs,(BaseType)_getTypeFromTab(tObj),theAttributes.getValue(i));
              te=new OriginatedEvent(ts,new Object[]{(BaseType)_getTypeFromTab(tObj),value},theObject);
            }
            _fromFederationEvents.get(hs.getIdentity()).add(te);
            if (_debugging) {
              _debug(getDisplayName() + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ hs.getParameterName()+ ""String_Node_Str""+ te.timeStamp+ ""String_Node_Str""+ value.toString()+ ""String_Node_Str""+ hs.getDisplayName());
            }
          }
 catch (          IllegalActionException e) {
            e.printStackTrace();
          }
        }
      }
    }
  }
 catch (  ArrayIndexOutOfBounds e) {
    e.printStackTrace();
  }
}"
72537,"private void setUpHlaPublisher(RTIambassador rtia) throws NameNotFound, ObjectClassNotDefined, FederateNotExecutionMember, RTIinternalError, AttributeNotDefined, SaveInProgress, RestoreInProgress, ConcurrentAccessAttempted {
  Iterator<Entry<String,Object[]>> it=_hlaAttributesToPublish.entrySet().iterator();
  while (it.hasNext()) {
    Map.Entry<String,Object[]> elt=it.next();
    Object[] tObj=elt.getValue();
    int classHandle=rtia.getObjectClassHandle(_getClassNameFromTab(tObj));
    int objAttributeHandle=rtia.getAttributeHandle(_getPortFromTab(tObj).getContainer().getName(),classHandle);
    elt.setValue(new Object[]{_getPortFromTab(tObj),_getTypeFromTab(tObj),_getClassNameFromTab(tObj),classHandle,objAttributeHandle});
  }
  HashMap<String,LinkedList<String>> classHandleHlaPublisherTable=null;
  classHandleHlaPublisherTable=new HashMap<String,LinkedList<String>>();
  Iterator<Entry<String,Object[]>> it2=_hlaAttributesToPublish.entrySet().iterator();
  while (it2.hasNext()) {
    Map.Entry<String,Object[]> elt=it2.next();
    Object[] tObj=elt.getValue();
    String classHandleName=_getClassNameFromTab(tObj);
    if (classHandleHlaPublisherTable.containsKey(classHandleName)) {
      classHandleHlaPublisherTable.get(classHandleName).add(elt.getKey());
    }
 else {
      LinkedList<String> list=new LinkedList<String>();
      list.add(elt.getKey());
      classHandleHlaPublisherTable.put(classHandleName,list);
    }
  }
  Iterator<Entry<String,LinkedList<String>>> it3=classHandleHlaPublisherTable.entrySet().iterator();
  while (it3.hasNext()) {
    Map.Entry<String,LinkedList<String>> elt=it3.next();
    LinkedList<String> hlaPublishers=elt.getValue();
    int classHandle=rtia.getObjectClassHandle(elt.getKey());
    AttributeHandleSet _attributesLocal=RtiFactoryFactory.getRtiFactory().createAttributeHandleSet();
    for (    String s : hlaPublishers) {
      _attributesLocal.add(_getAttributeHandleFromTab(_hlaAttributesToPublish.get(s)));
    }
    try {
      rtia.publishObjectClass(classHandle,_attributesLocal);
    }
 catch (    OwnershipAcquisitionPending e) {
      e.printStackTrace();
    }
  }
  Iterator<Entry<String,Object[]>> it5=_hlaAttributesToPublish.entrySet().iterator();
  LinkedList<String> alreadyRegistered=new LinkedList<String>();
  while (it5.hasNext()) {
    Map.Entry<String,Object[]> elt=it5.next();
    Object[] tObj=elt.getValue();
    int classHandle=rtia.getObjectClassHandle(_getClassNameFromTab(tObj));
    TypedIOPort port=_getPortFromTab(tObj);
    List<IOPort> sender=port.sourcePortList();
    for (    IOPort s : sender) {
      String senderName=s.getContainer().getName();
      if (!alreadyRegistered.contains(senderName)) {
        alreadyRegistered.add(senderName);
        int myObjectInstId=-1;
        try {
          myObjectInstId=rtia.registerObjectInstance(classHandle,senderName);
          HlaPublisher pub=(HlaPublisher)port.getContainer();
          pub.register(senderName,myObjectInstId);
        }
 catch (        ObjectClassNotPublished e) {
          e.printStackTrace();
        }
catch (        ObjectAlreadyRegistered e) {
          e.printStackTrace();
        }
      }
    }
  }
}","private void setUpHlaPublisher(RTIambassador rtia) throws NameNotFound, ObjectClassNotDefined, FederateNotExecutionMember, RTIinternalError, AttributeNotDefined, SaveInProgress, RestoreInProgress, ConcurrentAccessAttempted {
  Iterator<Entry<String,Object[]>> it=_hlaAttributesToPublish.entrySet().iterator();
  while (it.hasNext()) {
    Map.Entry<String,Object[]> elt=it.next();
    Object[] tObj=elt.getValue();
    int classHandle=rtia.getObjectClassHandle(_getClassNameFromTab(tObj));
    int objAttributeHandle=rtia.getAttributeHandle(_getPortFromTab(tObj).getContainer().getName(),classHandle);
    elt.setValue(new Object[]{_getPortFromTab(tObj),_getTypeFromTab(tObj),_getClassNameFromTab(tObj),classHandle,objAttributeHandle});
  }
  HashMap<String,LinkedList<String>> classHandleHlaPublisherTable=null;
  classHandleHlaPublisherTable=new HashMap<String,LinkedList<String>>();
  Iterator<Entry<String,Object[]>> it2=_hlaAttributesToPublish.entrySet().iterator();
  while (it2.hasNext()) {
    Map.Entry<String,Object[]> elt=it2.next();
    Object[] tObj=elt.getValue();
    String classHandleName=_getClassNameFromTab(tObj);
    if (classHandleHlaPublisherTable.containsKey(classHandleName)) {
      classHandleHlaPublisherTable.get(classHandleName).add(elt.getKey());
    }
 else {
      LinkedList<String> list=new LinkedList<String>();
      list.add(elt.getKey());
      classHandleHlaPublisherTable.put(classHandleName,list);
    }
  }
  Iterator<Entry<String,LinkedList<String>>> it3=classHandleHlaPublisherTable.entrySet().iterator();
  while (it3.hasNext()) {
    Map.Entry<String,LinkedList<String>> elt=it3.next();
    LinkedList<String> hlaPublishers=elt.getValue();
    int classHandle=rtia.getObjectClassHandle(elt.getKey());
    AttributeHandleSet _attributesLocal=RtiFactoryFactory.getRtiFactory().createAttributeHandleSet();
    for (    String s : hlaPublishers) {
      _attributesLocal.add(_getAttributeHandleFromTab(_hlaAttributesToPublish.get(s)));
    }
    try {
      rtia.publishObjectClass(classHandle,_attributesLocal);
    }
 catch (    OwnershipAcquisitionPending e) {
      e.printStackTrace();
    }
  }
  Iterator<Entry<String,Object[]>> it5=_hlaAttributesToPublish.entrySet().iterator();
  LinkedList<String> alreadyRegistered=new LinkedList<String>();
  while (it5.hasNext()) {
    Map.Entry<String,Object[]> elt=it5.next();
    Object[] tObj=elt.getValue();
    int classHandle=rtia.getObjectClassHandle(_getClassNameFromTab(tObj));
    TypedIOPort port=_getPortFromTab(tObj);
    HlaPublisher pub=(HlaPublisher)port.getContainer();
    List<IOPort> senders=port.sourcePortList();
    for (    IOPort sender : senders) {
      String senderName=_federateName + ""String_Node_Str"" + sender.getContainer().getName();
      if (!alreadyRegistered.contains(senderName)) {
        alreadyRegistered.add(senderName);
        int myObjectInstId=-1;
        try {
          myObjectInstId=rtia.registerObjectInstance(classHandle,senderName);
          pub.register(senderName,myObjectInstId);
        }
 catch (        ObjectClassNotPublished e) {
          e.printStackTrace();
        }
catch (        ObjectAlreadyRegistered e) {
          e.printStackTrace();
        }
      }
    }
  }
}"
72538,"/** 
 * Each tokens, received in the input port, are transmitted to the  {@link HlaManager} for a publication to the HLA/CERTI Federation.
 */
@Override public void fire() throws IllegalActionException {
  for (int i=0; i < input.getWidth(); ++i) {
    if (input.hasToken(i)) {
      Token in=input.get(i);
      String name=input.sourcePortList().get(i).getContainer().getDisplayName();
      _hlaManager.updateHlaAttribute(this,in,_registeredObject.get(name));
      if (_debugging) {
        _debug(this.getDisplayName() + ""String_Node_Str"" + in.toString()+ ""String_Node_Str""+ this.getName()+ ""String_Node_Str""+ _hlaManager.getDisplayName()+ ""String_Node_Str"");
      }
    }
  }
}","/** 
 * Each tokens, received in the input port, are transmitted to the  {@link HlaManager} for a publication to the HLA/CERTI Federation.
 */
@Override public void fire() throws IllegalActionException {
  for (int i=0; i < input.getWidth(); ++i) {
    if (input.hasToken(i)) {
      Token in=input.get(i);
      String actorName=input.sourcePortList().get(i).getContainer().getName();
      String fedName=((StringToken)_hlaManager.federateName.getToken()).stringValue();
      int id=_registeredObject.get(fedName + ""String_Node_Str"" + actorName);
      _hlaManager.updateHlaAttribute(this,in,id);
      if (_debugging) {
        _debug(this.getDisplayName() + ""String_Node_Str"" + in.toString()+ ""String_Node_Str""+ this.getName()+ ""String_Node_Str""+ _hlaManager.getDisplayName()+ ""String_Node_Str"");
      }
    }
  }
}"
72539,"/** 
 * Expose the send() method of the port.
 * @param channelIndex The channel index.
 * @param data The token to send.
 * @throws IllegalActionException If this is a proxy for a parameter or if sending fails.
 * @throws NoRoomException If there is no room at the destination.
 */
public void send(int channelIndex,Token data) throws NoRoomException, IllegalActionException {
  if (_port == null) {
    throw new IllegalActionException(JavaScript.this,""String_Node_Str"" + _parameter.getName() + ""String_Node_Str"");
  }
  if (!_executing) {
    throw new InternalErrorException(""String_Node_Str"" + data + ""String_Node_Str""+ _port.getName()+ ""String_Node_Str"");
  }
synchronized (this) {
    if (_inFire) {
      if (_debugging) {
        _debug(""String_Node_Str"" + data + ""String_Node_Str""+ _port.getName());
      }
      _port.send(channelIndex,data);
    }
 else {
      if (_outputTokens == null) {
        _outputTokens=new HashMap<IOPort,HashMap<Integer,List<Token>>>();
      }
      HashMap<Integer,List<Token>> tokens=_outputTokens.get(_port);
      if (tokens == null) {
        tokens=new HashMap<Integer,List<Token>>();
        _outputTokens.put(_port,tokens);
      }
      List<Token> queue=tokens.get(channelIndex);
      if (queue == null) {
        queue=new LinkedList<Token>();
        tokens.put(channelIndex,queue);
      }
      queue.add(data);
      if (_debugging) {
        _debug(""String_Node_Str"" + data + ""String_Node_Str""+ _port.getName()+ ""String_Node_Str"");
      }
      getDirector().fireAtCurrentTime(JavaScript.this);
    }
  }
}","/** 
 * Expose the send() method of the port.
 * @param channelIndex The channel index.
 * @param data The token to send.
 * @throws IllegalActionException If this is a proxy for a parameter or if sending fails.
 * @throws NoRoomException If there is no room at the destination.
 */
public void send(int channelIndex,Token data) throws NoRoomException, IllegalActionException {
  if (_port == null) {
    throw new IllegalActionException(JavaScript.this,""String_Node_Str"" + _parameter.getName() + ""String_Node_Str"");
  }
  if (!_executing) {
    throw new InternalErrorException(""String_Node_Str"" + data + ""String_Node_Str""+ _port.getName()+ ""String_Node_Str"");
  }
synchronized (JavaScript.this) {
    if (_inFire) {
      if (_debugging) {
        _debug(""String_Node_Str"" + data + ""String_Node_Str""+ _port.getName());
      }
      _port.send(channelIndex,data);
    }
 else {
      if (_outputTokens == null) {
        _outputTokens=new HashMap<IOPort,HashMap<Integer,List<Token>>>();
      }
      HashMap<Integer,List<Token>> tokens=_outputTokens.get(_port);
      if (tokens == null) {
        tokens=new HashMap<Integer,List<Token>>();
        _outputTokens.put(_port,tokens);
      }
      List<Token> queue=tokens.get(channelIndex);
      if (queue == null) {
        queue=new LinkedList<Token>();
        tokens.put(channelIndex,queue);
      }
      queue.add(data);
      if (_debugging) {
        _debug(""String_Node_Str"" + data + ""String_Node_Str""+ _port.getName()+ ""String_Node_Str"");
      }
      getDirector().fireAtCurrentTime(JavaScript.this);
    }
  }
}"
72540,"/** 
 * If an input is available and either it equals zero or it has crossed zero from the most recently seen input, then output 0.0; otherwise, if an input available and that input is a   {@link SmoothToken} with non-zeroderivatives, then predict the time at which a zero crossing will occur and request a refiring at that time; Otherwise, if no input is available and current time matches the time of a previous refiring request, then produce the output 0.0.
 * @exception IllegalActionException If sending an output fails.
 */
@Override public void fire() throws IllegalActionException {
  super.fire();
  Time currentTime=getDirector().getModelTime();
  if (_debugging) {
    _debug(""String_Node_Str"" + currentTime);
  }
  DoubleToken inputToken=null;
  if (input.hasNewToken(0)) {
    inputToken=(DoubleToken)input.get(0);
    if (_debugging) {
      _debug(""String_Node_Str"" + inputToken);
    }
  }
  if (inputToken == null && currentTime.equals(_lastFireAtTime)) {
    if (_previousInput != null) {
      SmoothToken projectedToNow=((SmoothToken)_previousInput).extrapolate(currentTime);
      inputToken=new SmoothToken(0.0,currentTime,projectedToNow.derivativeValues());
      if (_debugging) {
        _debug(""String_Node_Str"" + inputToken);
      }
    }
  }
  if (inputToken instanceof SmoothToken) {
    double inputValue=inputToken.doubleValue();
    if (_previousInput != null) {
      double previousValue=_previousInput.doubleValue();
      boolean inputIsRising=inputValue >= 0.0 && previousValue < 0.0;
      boolean inputIsFalling=inputValue <= 0.0 && previousValue > 0.0;
      if (_detectFallingCrossing && inputIsFalling || _detectRisingCrossing && inputIsRising) {
        output.send(0,value.getToken());
        if (_debugging) {
          _debug(""String_Node_Str"");
        }
      }
    }
    if (inputToken instanceof SmoothToken) {
      Time future=null;
      double[] derivatives=((SmoothToken)inputToken).derivativeValues();
      if (derivatives.length == 1 || (derivatives.length == 2 && derivatives[1] == 0.0) || (derivatives.length > 2 && derivatives[1] == 0.0 && derivatives[2] == 0.0)) {
        if (_detectRisingCrossing && inputValue < 0.0 && derivatives[0] > 0.0 || _detectFallingCrossing && inputValue > 0.0 && derivatives[0] < 0.0) {
          future=currentTime.add(-inputValue / derivatives[0]);
        }
      }
 else       if (derivatives.length == 2 || (derivatives.length > 2 && derivatives[2] == 0.0)) {
        double delta=PolynomialRoot.findMinimumPositiveRoot2(derivatives[1] / 2.0,derivatives[0],inputValue);
        if (delta >= _errorTolerance && delta != Double.POSITIVE_INFINITY) {
          future=currentTime.add(delta);
        }
      }
 else       if (derivatives.length >= 3) {
        double delta=PolynomialRoot.findMinimumPositiveRoot3(derivatives[2] / 6.0,derivatives[1] / 2.0,derivatives[0],inputValue,_errorTolerance,0.0);
        if (delta >= _errorTolerance && delta != Double.POSITIVE_INFINITY) {
          future=currentTime.add(delta);
        }
      }
      if (future != null) {
        if (_lastFireAtTime == null || currentTime.subtractToDouble(_lastFireAtTime) >= _errorTolerance) {
          if (_lastFireAtTime != null) {
            if (_debugging) {
              _debug(""String_Node_Str"" + _lastFireAtTime);
            }
            ((DEDirector)getDirector()).cancelFireAt(this,_lastFireAtTime);
          }
          getDirector().fireAt(this,future);
          _lastFireAtTime=future;
        }
      }
 else {
        if (_lastFireAtTime != null) {
          if (_debugging) {
            _debug(""String_Node_Str"" + _lastFireAtTime);
          }
          ((DEDirector)getDirector()).cancelFireAt(this,_lastFireAtTime);
          _lastFireAtTime=null;
        }
      }
    }
 else {
      if (_lastFireAtTime != null) {
        if (_debugging) {
          _debug(""String_Node_Str"" + _lastFireAtTime);
        }
        ((DEDirector)getDirector()).cancelFireAt(this,_lastFireAtTime);
      }
      _lastFireAtTime=null;
    }
    _previousInput=(SmoothToken)inputToken;
  }
}","/** 
 * If an input is available and either it equals zero or it has crossed zero from the most recently seen input, then output 0.0; otherwise, if an input available and that input is a   {@link SmoothToken} with non-zeroderivatives, then predict the time at which a zero crossing will occur and request a refiring at that time; Otherwise, if no input is available and current time matches the time of a previous refiring request, then produce the output 0.0.
 * @exception IllegalActionException If sending an output fails.
 */
@Override public void fire() throws IllegalActionException {
  super.fire();
  Time currentTime=getDirector().getModelTime();
  if (_debugging) {
    _debug(""String_Node_Str"" + currentTime);
  }
  DoubleToken inputToken=null;
  if (input.hasNewToken(0)) {
    inputToken=(DoubleToken)input.get(0);
    if (_debugging) {
      _debug(""String_Node_Str"" + inputToken);
    }
  }
  if (inputToken == null && currentTime.equals(_lastFireAtTime)) {
    if (_previousInput != null) {
      SmoothToken projectedToNow=((SmoothToken)_previousInput).extrapolate(currentTime);
      inputToken=new SmoothToken(0.0,currentTime,projectedToNow.derivativeValues());
      if (_debugging) {
        _debug(""String_Node_Str"" + inputToken);
      }
    }
  }
  if (inputToken instanceof SmoothToken) {
    double inputValue=inputToken.doubleValue();
    if (_previousInput != null) {
      double previousValue=_previousInput.doubleValue();
      boolean inputIsRising=inputValue >= 0.0 && previousValue < 0.0;
      boolean inputIsFalling=inputValue <= 0.0 && previousValue > 0.0;
      if (_detectFallingCrossing && inputIsFalling || _detectRisingCrossing && inputIsRising) {
        output.send(0,value.getToken());
        if (_debugging) {
          _debug(""String_Node_Str"");
        }
      }
    }
    Time future=null;
    double[] derivatives=((SmoothToken)inputToken).derivativeValues();
    if (derivatives.length == 1 || (derivatives.length == 2 && derivatives[1] == 0.0) || (derivatives.length > 2 && derivatives[1] == 0.0 && derivatives[2] == 0.0)) {
      if (_detectRisingCrossing && inputValue < 0.0 && derivatives[0] > 0.0 || _detectFallingCrossing && inputValue > 0.0 && derivatives[0] < 0.0) {
        future=currentTime.add(-inputValue / derivatives[0]);
      }
    }
 else     if (derivatives.length == 2 || (derivatives.length > 2 && derivatives[2] == 0.0)) {
      double delta=PolynomialRoot.findMinimumPositiveRoot2(derivatives[1] / 2.0,derivatives[0],inputValue);
      if (delta >= _errorTolerance && delta != Double.POSITIVE_INFINITY) {
        future=currentTime.add(delta);
      }
    }
 else     if (derivatives.length >= 3) {
      double delta=PolynomialRoot.findMinimumPositiveRoot3(derivatives[2] / 6.0,derivatives[1] / 2.0,derivatives[0],inputValue,_errorTolerance,0.0);
      if (delta >= _errorTolerance && delta != Double.POSITIVE_INFINITY) {
        future=currentTime.add(delta);
      }
    }
    if (future != null) {
      if (_lastFireAtTime == null || Math.abs(future.subtractToDouble(_lastFireAtTime)) >= _errorTolerance) {
        if (_lastFireAtTime != null) {
          if (_debugging) {
            _debug(""String_Node_Str"" + _lastFireAtTime);
          }
          ((DEDirector)getDirector()).cancelFireAt(this,_lastFireAtTime);
        }
        getDirector().fireAt(this,future);
        _lastFireAtTime=future;
      }
    }
 else {
      if (_lastFireAtTime != null) {
        if (_debugging) {
          _debug(""String_Node_Str"" + _lastFireAtTime);
        }
        ((DEDirector)getDirector()).cancelFireAt(this,_lastFireAtTime);
        _lastFireAtTime=null;
      }
    }
  }
 else {
    if (_lastFireAtTime != null) {
      if (_debugging) {
        _debug(""String_Node_Str"" + _lastFireAtTime);
      }
      ((DEDirector)getDirector()).cancelFireAt(this,_lastFireAtTime);
    }
    _lastFireAtTime=null;
  }
  _previousInput=(SmoothToken)inputToken;
}"
72541,"/** 
 * Clone the actor into the specified workspace.
 * @param workspace The workspace for the new object.
 * @return A new actor.
 * @exception CloneNotSupportedException If a derived class containsan attribute that cannot be cloned.
 */
@Override public Object clone(Workspace workspace) throws CloneNotSupportedException {
  RecordAssembler newObject=(RecordAssembler)super.clone(workspace);
  newObject._portMap=new HashMap<String,TypedIOPort>();
  return newObject;
}","/** 
 * Clone the actor into the specified workspace.
 * @param workspace The workspace for the new object.
 * @return A new actor.
 * @exception CloneNotSupportedException If a derived class containsan attribute that cannot be cloned.
 */
@Override public Object clone(Workspace workspace) throws CloneNotSupportedException {
  RecordAssembler newObject=(RecordAssembler)super.clone(workspace);
  newObject._portMap=_newPortMap();
  return newObject;
}"
72542,"/** 
 * Map port names or aliases to port objects. If the mapping has changed, then invalidate the resolved types, which forces new type constraints with appropriate field names to be generated.
 */
protected void _mapPorts(){
  Manager manager=this.getManager();
  Map<String,TypedIOPort> oldMap=_portMap;
  _portMap=new HashMap<String,TypedIOPort>();
  for (  TypedIOPort p : this.inputPortList()) {
    String name=p.getName();
    String alias=p.getDisplayName();
    if (p.numberOfSources() < 1) {
      continue;
    }
    if (alias == null || alias.equals(""String_Node_Str"")) {
      _portMap.put(name,p);
    }
 else {
      _portMap.put(alias,p);
    }
  }
  if (manager != null && (oldMap == null || !_portMap.equals(oldMap))) {
    manager.invalidateResolvedTypes();
  }
}","/** 
 * Map port names or aliases to port objects. If the mapping has changed, then invalidate the resolved types, which forces new type constraints with appropriate field names to be generated.
 */
protected void _mapPorts(){
  Manager manager=this.getManager();
  Map<String,TypedIOPort> oldMap=_portMap;
  _portMap=_newPortMap();
  for (  TypedIOPort p : this.inputPortList()) {
    String name=p.getName();
    String alias=p.getDisplayName();
    if (p.numberOfSources() < 1) {
      continue;
    }
    if (alias == null || alias.equals(""String_Node_Str"")) {
      _portMap.put(name,p);
    }
 else {
      _portMap.put(alias,p);
    }
  }
  if (manager != null && (oldMap == null || !_portMap.equals(oldMap))) {
    manager.invalidateResolvedTypes();
  }
}"
72543,"/** 
 * Import a FMUFile.
 * @param originator The originator of the change request.
 * @param fmuFileParameter The .fmuFile
 * @param context The context in which the FMU actor is created.
 * @param x The x-axis value of the actor to be created.
 * @param y The y-axis value of the actor to be created.
 * @param modelExchange True if the fmu should be importedas a model exchange fmu.
 * @param addMaximumStepSizeParameter True if a parameter named""maximumStepSize"" should be added.
 * @param actorClassName The class name of the Ptolemy actorto be instantiated, for example ""ptolemy.actor.lib.fmi.FMUImport"".
 * @param acceptFMUMethod The {@link #_acceptFMU(FMIModelDescription)}method.  Derived classes provide a different method than the parent class.
 * @exception IllegalActionException If there is a probleminstantiating the actor.
 * @exception IOException If there is a problem parsing the fmu file.
 */
protected static void _importFMU(Object originator,FileParameter fmuFileParameter,NamedObj context,double x,double y,boolean modelExchange,boolean addMaximumStepSizeParameter,String actorClassName,Method acceptFMUMethod) throws IllegalActionException, IOException {
  File fmuFile=fmuFileParameter.asFile();
  String fmuFileName=fmuFile.getCanonicalPath();
  FMIModelDescription fmiModelDescription=FMUFile.parseFMUFile(fmuFileName);
  if (modelExchange) {
    fmiModelDescription.modelExchange=true;
  }
 else {
    fmiModelDescription.modelExchange=false;
  }
  try {
    Boolean accept=(Boolean)acceptFMUMethod.invoke(null,new Object[]{fmiModelDescription});
    if (!accept) {
      return;
    }
  }
 catch (  Throwable throwable) {
    new IllegalActionException(context,throwable,""String_Node_Str"" + acceptFMUMethod);
  }
  String source=""String_Node_Str"";
  if (fmuFileName.startsWith(""String_Node_Str"")) {
    source=""String_Node_Str"" + fmuFileName.trim() + ""String_Node_Str"";
  }
  String rootName=new File(fmuFileName).getName();
  int index=rootName.lastIndexOf('.');
  if (index != -1) {
    rootName=rootName.substring(0,index);
  }
  int maximumNumberOfPortsToDisplay=20;
  int modelVariablesLength=fmiModelDescription.modelVariables.size();
  String hide=""String_Node_Str"";
  String hiddenStyle=""String_Node_Str"";
  String dependency=""String_Node_Str"";
  String showName=""String_Node_Str"" + ""String_Node_Str"" + hiddenStyle + ""String_Node_Str"";
  if (modelVariablesLength > maximumNumberOfPortsToDisplay) {
    MessageHandler.message(""String_Node_Str"" + fmuFileName + ""String_Node_Str""+ modelVariablesLength+ ""String_Node_Str""+ ""String_Node_Str"");
  }
  int portCount=0;
  StringBuffer parameterMoML=new StringBuffer();
  StringBuffer portMoML=new StringBuffer();
  for (  FMIScalarVariable scalar : fmiModelDescription.modelVariables) {
    if (scalar.variability == FMIScalarVariable.Variability.parameter || scalar.variability == FMIScalarVariable.Variability.fixed || scalar.variability == FMIScalarVariable.Variability.tunable) {
switch (scalar.causality) {
case output:
        portCount++;
      String causality=""String_Node_Str"";
    portMoML.append(""String_Node_Str"" + StringUtilities.sanitizeName(scalar.name) + ""String_Node_Str""+ ""String_Node_Str""+ causality+ ""String_Node_Str""+ ""String_Node_Str""+ StringUtilities.escapeForXML(scalar.name)+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ _fmiType2PtolemyType(scalar.type)+ ""String_Node_Str""+ hiddenStyle+ ""String_Node_Str""+ dependency+ showName+ ""String_Node_Str"");
  break;
case input:
break;
case local:
break;
case internal:
break;
case calculatedParameter:
break;
case parameter:
parameterMoML.append(""String_Node_Str"" + StringUtilities.sanitizeName(scalar.name) + ""String_Node_Str""+ scalar.type+ ""String_Node_Str""+ ""String_Node_Str"");
break;
case none:
break;
}
}
 else if (scalar.variability == FMIScalarVariable.Variability.constant) {
continue;
}
 else {
boolean hideLocal=false;
String causality=""String_Node_Str"";
switch (scalar.causality) {
case local:
hideLocal=true;
if (fmiModelDescription.modelExchange) {
if (scalar.isState) {
hideLocal=false;
}
 else {
if (scalar.type instanceof FMIRealType) {
if (((FMIRealType)scalar.type).indexState != -1) {
portCount++;
dependency=""String_Node_Str"";
}
}
}
}
causality=""String_Node_Str"";
break;
case input:
portCount++;
hideLocal=false;
causality=""String_Node_Str"";
break;
case none:
hideLocal=true;
causality=""String_Node_Str"";
break;
case output:
portCount++;
hideLocal=false;
causality=""String_Node_Str"";
dependency=""String_Node_Str"";
break;
case internal:
hideLocal=true;
causality=""String_Node_Str"";
break;
}
portMoML.append(""String_Node_Str"" + StringUtilities.sanitizeName(scalar.name) + ""String_Node_Str""+ ""String_Node_Str""+ causality+ ""String_Node_Str""+ ""String_Node_Str""+ StringUtilities.escapeForXML(scalar.name)+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ _fmiType2PtolemyType(scalar.type)+ ""String_Node_Str""+ hiddenStyle+ ""String_Node_Str""+ dependency+ showName+ (portCount > maximumNumberOfPortsToDisplay || scalar.causality == Causality.internal || hideLocal ? hide : ""String_Node_Str"")+ ""String_Node_Str"");
}
}
if (modelExchange) {
parameterMoML.append(""String_Node_Str"");
if (addMaximumStepSizeParameter) {
parameterMoML.append(""String_Node_Str"");
}
}
String moml=""String_Node_Str"" + ""String_Node_Str"" + rootName + ""String_Node_Str""+ actorClassName+ ""String_Node_Str""+ source+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ x+ ""String_Node_Str""+ y+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ fmuFileParameter.getExpression()+ ""String_Node_Str""+ ""String_Node_Str""+ parameterMoML+ portMoML+ ""String_Node_Str"";
MoMLChangeRequest request=new MoMLChangeRequest(originator,context,moml);
context.requestChange(request);
}","/** 
 * Import a FMUFile.
 * @param originator The originator of the change request.
 * @param fmuFileParameter The .fmuFile
 * @param context The context in which the FMU actor is created.
 * @param x The x-axis value of the actor to be created.
 * @param y The y-axis value of the actor to be created.
 * @param modelExchange True if the fmu should be importedas a model exchange fmu.
 * @param addMaximumStepSizeParameter True if a parameter named""maximumStepSize"" should be added.
 * @param actorClassName The class name of the Ptolemy actorto be instantiated, for example ""ptolemy.actor.lib.fmi.FMUImport"".
 * @param acceptFMUMethod The {@link #_acceptFMU(FMIModelDescription)}method.  Derived classes provide a different method than the parent class.
 * @exception IllegalActionException If there is a probleminstantiating the actor.
 * @exception IOException If there is a problem parsing the fmu file.
 */
protected static void _importFMU(Object originator,FileParameter fmuFileParameter,NamedObj context,double x,double y,boolean modelExchange,boolean addMaximumStepSizeParameter,String actorClassName,Method acceptFMUMethod) throws IllegalActionException, IOException {
  File fmuFile=fmuFileParameter.asFile();
  String fmuFileName=fmuFile.getCanonicalPath();
  FMIModelDescription fmiModelDescription=FMUFile.parseFMUFile(fmuFileName);
  if (modelExchange) {
    fmiModelDescription.modelExchange=true;
  }
 else {
    fmiModelDescription.modelExchange=false;
  }
  try {
    Boolean accept=(Boolean)acceptFMUMethod.invoke(null,new Object[]{fmiModelDescription});
    if (!accept) {
      return;
    }
  }
 catch (  Throwable throwable) {
    if (throwable.getCause() instanceof IOException) {
      throw new IllegalActionException(context,throwable.getCause(),""String_Node_Str"" + fmuFile + ""String_Node_Str"");
    }
 else {
      throw new IllegalActionException(context,throwable,""String_Node_Str"" + acceptFMUMethod);
    }
  }
  String source=""String_Node_Str"";
  if (fmuFileName.startsWith(""String_Node_Str"")) {
    source=""String_Node_Str"" + fmuFileName.trim() + ""String_Node_Str"";
  }
  String rootName=new File(fmuFileName).getName();
  int index=rootName.lastIndexOf('.');
  if (index != -1) {
    rootName=rootName.substring(0,index);
  }
  int maximumNumberOfPortsToDisplay=20;
  int modelVariablesLength=fmiModelDescription.modelVariables.size();
  String hide=""String_Node_Str"";
  String hiddenStyle=""String_Node_Str"";
  String dependency=""String_Node_Str"";
  String showName=""String_Node_Str"" + ""String_Node_Str"" + hiddenStyle + ""String_Node_Str"";
  if (modelVariablesLength > maximumNumberOfPortsToDisplay) {
    MessageHandler.message(""String_Node_Str"" + fmuFileName + ""String_Node_Str""+ modelVariablesLength+ ""String_Node_Str""+ ""String_Node_Str"");
  }
  int portCount=0;
  StringBuffer parameterMoML=new StringBuffer();
  StringBuffer portMoML=new StringBuffer();
  for (  FMIScalarVariable scalar : fmiModelDescription.modelVariables) {
    if (scalar.variability == FMIScalarVariable.Variability.parameter || scalar.variability == FMIScalarVariable.Variability.fixed || scalar.variability == FMIScalarVariable.Variability.tunable) {
switch (scalar.causality) {
case output:
        portCount++;
      String causality=""String_Node_Str"";
    portMoML.append(""String_Node_Str"" + StringUtilities.sanitizeName(scalar.name) + ""String_Node_Str""+ ""String_Node_Str""+ causality+ ""String_Node_Str""+ ""String_Node_Str""+ StringUtilities.escapeForXML(scalar.name)+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ _fmiType2PtolemyType(scalar.type)+ ""String_Node_Str""+ hiddenStyle+ ""String_Node_Str""+ dependency+ showName+ ""String_Node_Str"");
  break;
case input:
break;
case local:
break;
case internal:
break;
case calculatedParameter:
break;
case parameter:
parameterMoML.append(""String_Node_Str"" + StringUtilities.sanitizeName(scalar.name) + ""String_Node_Str""+ scalar.type+ ""String_Node_Str""+ ""String_Node_Str"");
break;
case none:
break;
}
}
 else if (scalar.variability == FMIScalarVariable.Variability.constant) {
continue;
}
 else {
boolean hideLocal=false;
String causality=""String_Node_Str"";
switch (scalar.causality) {
case local:
hideLocal=true;
if (fmiModelDescription.modelExchange) {
if (scalar.isState) {
hideLocal=false;
}
 else {
if (scalar.type instanceof FMIRealType) {
if (((FMIRealType)scalar.type).indexState != -1) {
portCount++;
dependency=""String_Node_Str"";
}
}
}
}
causality=""String_Node_Str"";
break;
case input:
portCount++;
hideLocal=false;
causality=""String_Node_Str"";
break;
case none:
hideLocal=true;
causality=""String_Node_Str"";
break;
case output:
portCount++;
hideLocal=false;
causality=""String_Node_Str"";
dependency=""String_Node_Str"";
break;
case internal:
hideLocal=true;
causality=""String_Node_Str"";
break;
}
portMoML.append(""String_Node_Str"" + StringUtilities.sanitizeName(scalar.name) + ""String_Node_Str""+ ""String_Node_Str""+ causality+ ""String_Node_Str""+ ""String_Node_Str""+ StringUtilities.escapeForXML(scalar.name)+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ _fmiType2PtolemyType(scalar.type)+ ""String_Node_Str""+ hiddenStyle+ ""String_Node_Str""+ dependency+ showName+ (portCount > maximumNumberOfPortsToDisplay || scalar.causality == Causality.internal || hideLocal ? hide : ""String_Node_Str"")+ ""String_Node_Str"");
}
}
if (modelExchange) {
parameterMoML.append(""String_Node_Str"");
if (addMaximumStepSizeParameter) {
parameterMoML.append(""String_Node_Str"");
}
}
String moml=""String_Node_Str"" + ""String_Node_Str"" + rootName + ""String_Node_Str""+ actorClassName+ ""String_Node_Str""+ source+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ x+ ""String_Node_Str""+ y+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ fmuFileParameter.getExpression()+ ""String_Node_Str""+ ""String_Node_Str""+ parameterMoML+ portMoML+ ""String_Node_Str"";
MoMLChangeRequest request=new MoMLChangeRequest(originator,context,moml);
context.requestChange(request);
}"
72544,"/** 
 * Generate the code for the firing of actors. In this base class, it is attempted to fire all the actors once. In subclasses such as the adapters for SDF and Giotto directors, the firings of actors observe the associated schedule. In addition, some special handling is needed, e.g., the iteration limit in SDF and time advancement in Giotto.
 * @return The generated code.
 * @exception IllegalActionException If the adapter associated with an actor throws it while generating fire code for the actor.
 */
@Override public String generateFMIMA() throws IllegalActionException {
  StringBuffer code=new StringBuffer();
  NamedProgramCodeGeneratorAdapter adapter=(NamedProgramCodeGeneratorAdapter)getAdapter(getComponent());
  Iterator<?> actors=((CompositeActor)adapter.getComponent().getContainer()).deepEntityList().iterator();
  code.append(getCodeGenerator().comment(""String_Node_Str"" + _eol + ""String_Node_Str""+ adapter.getComponent().getName()));
  CodeStream codeStream=_templateParser.getCodeStream();
  codeStream.clear();
  codeStream.appendCodeBlock(""String_Node_Str"");
  code.append(processCode(codeStream.toString()));
  actors=((CompositeActor)adapter.getComponent().getContainer()).deepEntityList().iterator();
  while (actors.hasNext()) {
    ptolemy.actor.lib.fmi.FMUImport actor=(ptolemy.actor.lib.fmi.FMUImport)actors.next();
    code.append(""String_Node_Str"" + actor.getName() + ""String_Node_Str"");
    code.append(""String_Node_Str"" + actor.getName() + ""String_Node_Str""+ actor.fmuFile.asFile().toString().replace(""String_Node_Str"",""String_Node_Str"")+ ""String_Node_Str"");
    code.append(""String_Node_Str"" + actor.getName() + ""String_Node_Str""+ actor.fmuFile.asFile().toString().replace(""String_Node_Str"",""String_Node_Str"")+ ""String_Node_Str"");
    code.append(""String_Node_Str"" + actor.getName() + ""String_Node_Str"");
    code.append(""String_Node_Str"" + actor.getName() + ""String_Node_Str""+ actor.getName()+ ""String_Node_Str"");
  }
  HashMap<Node,FMIScalarVariable> node2Scalar=new HashMap<Node,FMIScalarVariable>();
  HashMap<Node,TypedIOPort> node2Port=new HashMap<Node,TypedIOPort>();
  HashMap<TypedIOPort,FMIScalarVariable> port2Scalar=new HashMap<TypedIOPort,FMIScalarVariable>();
  HashMap<TypedIOPort,Node> port2Node=new HashMap<TypedIOPort,Node>();
  DirectedGraph graph=new DirectedGraph();
  actors=((CompositeActor)adapter.getComponent().getContainer()).deepEntityList().iterator();
  while (actors.hasNext()) {
    ptolemy.actor.lib.fmi.FMUImport actor=(ptolemy.actor.lib.fmi.FMUImport)actors.next();
    for (    TypedIOPort port : actor.portList()) {
      for (      FMIScalarVariable scalar : actor.getScalarVariables()) {
        if ((scalar.causality == Causality.input || scalar.causality == Causality.output) && scalar.name.equals(port.getName())) {
          Node node=new Node(port);
          port2Scalar.put(port,scalar);
          node2Scalar.put(node,scalar);
          port2Node.put(port,node);
          node2Port.put(node,port);
          graph.addNode(node);
        }
      }
    }
  }
  actors=((CompositeActor)adapter.getComponent().getContainer()).deepEntityList().iterator();
  int connectionNumber=0;
  while (actors.hasNext()) {
    ptolemy.actor.lib.fmi.FMUImport actor=(ptolemy.actor.lib.fmi.FMUImport)actors.next();
    for (    TypedIOPort output : actor.outputPortList()) {
      FMIScalarVariable scalar=port2Scalar.get(output);
      List<FMIScalarVariable> inputDependencies=actor.getInputDependencyList(scalar);
      if (inputDependencies != null) {
        for (        FMIScalarVariable inputScalar : inputDependencies) {
          Node source=null;
          Node sink=port2Node.get(output);
          for (          TypedIOPort port : actor.inputPortList()) {
            if (port.getName().equals(inputScalar.name))             source=port2Node.get(port);
          }
          graph.addEdge(source,sink);
        }
      }
    }
    for (    TypedIOPort input : actor.inputPortList()) {
      Node sink=port2Node.get(input);
      List<TypedIOPort> connected_ports=input.connectedPortList();
      for (      TypedIOPort output : connected_ports) {
        Node source=port2Node.get(output);
        graph.addEdge(source,sink);
        connectionNumber++;
      }
    }
  }
  actors=((CompositeActor)adapter.getComponent().getContainer()).deepEntityList().iterator();
  Collection<Node> nodeCollection=graph.nodes();
  if (graph.isAcyclic() == false) {
    throw new IllegalActionException(adapter.getComponent(),""String_Node_Str"");
  }
  List sortedGraph=graph.topologicalSort(nodeCollection);
  int connectionIndex=0;
  for (int i=0; i < connectionNumber; i++) {
    Node portSourceNode=(Node)sortedGraph.get(0);
    Node portSinkNode=(Node)sortedGraph.get(1);
    sortedGraph.remove(portSourceNode);
    sortedGraph.remove(portSinkNode);
    FMIScalarVariable sourceScalar=node2Scalar.get(portSourceNode);
    FMIScalarVariable sinkScalar=node2Scalar.get(portSinkNode);
    ptolemy.actor.lib.fmi.FMUImport sourceActor=(ptolemy.actor.lib.fmi.FMUImport)node2Port.get(portSourceNode).getContainer();
    ptolemy.actor.lib.fmi.FMUImport sinkActor=(ptolemy.actor.lib.fmi.FMUImport)node2Port.get(portSinkNode).getContainer();
    String fmuSourceName=sourceActor.getName();
    String fmuSinkName=sinkActor.getName();
    String sourceType=""String_Node_Str"";
    String sinkType=""String_Node_Str"";
    if (sourceScalar.type instanceof FMIBooleanType) {
      sourceType=""String_Node_Str"";
    }
 else     if (sourceScalar.type instanceof FMIIntegerType) {
      sourceType=""String_Node_Str"";
    }
 else     if (sourceScalar.type instanceof FMIRealType) {
      sourceType=""String_Node_Str"";
    }
 else     if (sourceScalar.type instanceof FMIStringType) {
      sourceType=""String_Node_Str"";
    }
    if (sinkScalar.type instanceof FMIBooleanType) {
      sinkType=""String_Node_Str"";
    }
 else     if (sinkScalar.type instanceof FMIIntegerType) {
      sinkType=""String_Node_Str"";
    }
 else     if (sinkScalar.type instanceof FMIRealType) {
      sinkType=""String_Node_Str"";
    }
 else     if (sinkScalar.type instanceof FMIStringType) {
      sinkType=""String_Node_Str"";
    }
    code.append(""String_Node_Str"" + connectionIndex + ""String_Node_Str""+ fmuSourceName+ ""String_Node_Str""+ ""String_Node_Str""+ connectionIndex+ ""String_Node_Str""+ fmuSourceName+ ""String_Node_Str""+ sourceScalar.valueReference+ ""String_Node_Str""+ ""String_Node_Str""+ connectionIndex+ ""String_Node_Str""+ sourceType+ ""String_Node_Str""+ ""String_Node_Str""+ connectionIndex+ ""String_Node_Str""+ fmuSinkName+ ""String_Node_Str"");
    code.append(""String_Node_Str"" + connectionIndex + ""String_Node_Str""+ fmuSinkName+ ""String_Node_Str""+ sinkScalar.valueReference+ ""String_Node_Str"");
    code.append(""String_Node_Str"" + connectionIndex + ""String_Node_Str""+ sinkType+ ""String_Node_Str"");
    connectionIndex++;
  }
  codeStream=_templateParser.getCodeStream();
  codeStream.clear();
  codeStream.appendCodeBlock(""String_Node_Str"");
  code.append(processCode(codeStream.toString()));
  code.append(getCodeGenerator().comment(""String_Node_Str""));
  return code.toString();
}","/** 
 * Generate the code for the firing of actors. In this base class, it is attempted to fire all the actors once. In subclasses such as the adapters for SDF and Giotto directors, the firings of actors observe the associated schedule. In addition, some special handling is needed, e.g., the iteration limit in SDF and time advancement in Giotto.
 * @return The generated code.
 * @exception IllegalActionException If the adapter associated with an actor throws it while generating fire code for the actor.
 */
@Override public String generateFMIMA() throws IllegalActionException {
  StringBuffer code=new StringBuffer();
  NamedProgramCodeGeneratorAdapter adapter=(NamedProgramCodeGeneratorAdapter)getAdapter(getComponent());
  Iterator<?> actors=((CompositeActor)adapter.getComponent().getContainer()).deepEntityList().iterator();
  code.append(getCodeGenerator().comment(""String_Node_Str"" + _eol + ""String_Node_Str""+ adapter.getComponent().getName()));
  CodeStream codeStream=_templateParser.getCodeStream();
  codeStream.clear();
  codeStream.appendCodeBlock(""String_Node_Str"");
  code.append(processCode(codeStream.toString()));
  actors=((CompositeActor)adapter.getComponent().getContainer()).deepEntityList().iterator();
  while (actors.hasNext()) {
    ptolemy.actor.lib.fmi.FMUImport actor=(ptolemy.actor.lib.fmi.FMUImport)actors.next();
    code.append(""String_Node_Str"" + actor.getName() + ""String_Node_Str"");
    code.append(""String_Node_Str"" + actor.getName() + ""String_Node_Str""+ actor.fmuFile.asFile().toString().replace(""String_Node_Str"",""String_Node_Str"")+ ""String_Node_Str"");
    code.append(""String_Node_Str"" + actor.getName() + ""String_Node_Str""+ actor.fmuFile.asFile().toString().replace(""String_Node_Str"",""String_Node_Str"")+ ""String_Node_Str"");
    code.append(""String_Node_Str"" + actor.getName() + ""String_Node_Str"");
    code.append(""String_Node_Str"" + actor.getName() + ""String_Node_Str""+ actor.getName()+ ""String_Node_Str"");
  }
  HashMap<Node,FMIScalarVariable> node2Scalar=new HashMap<Node,FMIScalarVariable>();
  HashMap<Node,TypedIOPort> node2Port=new HashMap<Node,TypedIOPort>();
  HashMap<TypedIOPort,FMIScalarVariable> port2Scalar=new HashMap<TypedIOPort,FMIScalarVariable>();
  HashMap<TypedIOPort,Node> port2Node=new HashMap<TypedIOPort,Node>();
  DirectedGraph graph=new DirectedGraph();
  actors=((CompositeActor)adapter.getComponent().getContainer()).deepEntityList().iterator();
  while (actors.hasNext()) {
    ptolemy.actor.lib.fmi.FMUImport actor=(ptolemy.actor.lib.fmi.FMUImport)actors.next();
    for (    TypedIOPort port : actor.portList()) {
      for (      FMIScalarVariable scalar : actor.getScalarVariables()) {
        if ((scalar.causality == Causality.input || scalar.causality == Causality.output) && scalar.name.equals(port.getName())) {
          Node node=new Node(port);
          port2Scalar.put(port,scalar);
          node2Scalar.put(node,scalar);
          port2Node.put(port,node);
          node2Port.put(node,port);
          graph.addNode(node);
        }
      }
    }
  }
  actors=((CompositeActor)adapter.getComponent().getContainer()).deepEntityList().iterator();
  while (actors.hasNext()) {
    ptolemy.actor.lib.fmi.FMUImport actor=(ptolemy.actor.lib.fmi.FMUImport)actors.next();
    for (    TypedIOPort output : actor.outputPortList()) {
      FMIScalarVariable scalar=port2Scalar.get(output);
      List<FMIScalarVariable> inputDependencies=actor.getInputDependencyList(scalar);
      if (inputDependencies != null) {
        for (        FMIScalarVariable inputScalar : inputDependencies) {
          Node source=null;
          Node sink=port2Node.get(output);
          for (          TypedIOPort port : actor.inputPortList()) {
            if (port.getName().equals(inputScalar.name))             source=port2Node.get(port);
          }
          graph.addEdge(source,sink);
        }
      }
    }
    for (    TypedIOPort input : actor.inputPortList()) {
      Node sink=port2Node.get(input);
      List<TypedIOPort> connected_ports=input.connectedPortList();
      for (      TypedIOPort output : connected_ports) {
        Node source=port2Node.get(output);
        graph.addEdge(source,sink);
      }
    }
  }
  actors=((CompositeActor)adapter.getComponent().getContainer()).deepEntityList().iterator();
  Collection<Node> nodeCollection=graph.nodes();
  if (graph.isAcyclic() == false) {
    throw new IllegalActionException(adapter.getComponent(),""String_Node_Str"");
  }
  List<Node> sortedGraph=graph.topologicalSort(nodeCollection);
  int connectionIndex=0;
  for (  Node sourceNode : sortedGraph) {
    if (node2Port.get(sourceNode).isOutput()) {
      Collection<Node> successors=graph.successors(sourceNode);
      for (      Node sinkNode : successors) {
        FMIScalarVariable sourceScalar=node2Scalar.get(sourceNode);
        FMIScalarVariable sinkScalar=node2Scalar.get(sinkNode);
        ptolemy.actor.lib.fmi.FMUImport sourceActor=(ptolemy.actor.lib.fmi.FMUImport)node2Port.get(sourceNode).getContainer();
        ptolemy.actor.lib.fmi.FMUImport sinkActor=(ptolemy.actor.lib.fmi.FMUImport)node2Port.get(sinkNode).getContainer();
        String fmuSourceName=sourceActor.getName();
        String fmuSinkName=sinkActor.getName();
        String sourceType=""String_Node_Str"";
        String sinkType=""String_Node_Str"";
        if (sourceScalar.type instanceof FMIBooleanType) {
          sourceType=""String_Node_Str"";
        }
 else         if (sourceScalar.type instanceof FMIIntegerType) {
          sourceType=""String_Node_Str"";
        }
 else         if (sourceScalar.type instanceof FMIRealType) {
          sourceType=""String_Node_Str"";
        }
 else         if (sourceScalar.type instanceof FMIStringType) {
          sourceType=""String_Node_Str"";
        }
        if (sinkScalar.type instanceof FMIBooleanType) {
          sinkType=""String_Node_Str"";
        }
 else         if (sinkScalar.type instanceof FMIIntegerType) {
          sinkType=""String_Node_Str"";
        }
 else         if (sinkScalar.type instanceof FMIRealType) {
          sinkType=""String_Node_Str"";
        }
 else         if (sinkScalar.type instanceof FMIStringType) {
          sinkType=""String_Node_Str"";
        }
        code.append(""String_Node_Str"" + connectionIndex + ""String_Node_Str""+ fmuSourceName+ ""String_Node_Str""+ ""String_Node_Str""+ connectionIndex+ ""String_Node_Str""+ fmuSourceName+ ""String_Node_Str""+ sourceScalar.valueReference+ ""String_Node_Str""+ ""String_Node_Str""+ connectionIndex+ ""String_Node_Str""+ sourceType+ ""String_Node_Str""+ ""String_Node_Str""+ connectionIndex+ ""String_Node_Str""+ fmuSinkName+ ""String_Node_Str"");
        code.append(""String_Node_Str"" + connectionIndex + ""String_Node_Str""+ fmuSinkName+ ""String_Node_Str""+ sinkScalar.valueReference+ ""String_Node_Str"");
        code.append(""String_Node_Str"" + connectionIndex + ""String_Node_Str""+ sinkType+ ""String_Node_Str"");
        connectionIndex++;
      }
    }
  }
  codeStream=_templateParser.getCodeStream();
  codeStream.clear();
  codeStream.appendCodeBlock(""String_Node_Str"");
  code.append(processCode(codeStream.toString()));
  code.append(getCodeGenerator().comment(""String_Node_Str""));
  return code.toString();
}"
72545,"/** 
 * Return the input port dependency for a given output port.
 * @param port The output port for which you want the inputdependency list
 * @return the list of input ports that directly influence thevalue of the given output port. If port is not an output port return null.
 */
public Set<String> getInputDependencyList(String port){
  Set<String> inputVariables=null;
  for (int i=0; i < _fmiModelDescription.modelVariables.size(); i++) {
    if (_fmiModelDescription.modelVariables.get(i).name.equals(port)) {
      if (_fmiModelDescription.modelVariables.get(i).name.equals(port)) {
        inputVariables=_fmiModelDescription.modelVariables.get(i).directDependency;
      }
    }
  }
  return inputVariables;
}","/** 
 * Return the input port dependency for a given output port.
 * @param port The output port for which you want the inputdependency list
 * @return the list of input ports that directly influence thevalue of the given output port. If port is not an output port return null.
 */
public List<FMIScalarVariable> getInputDependencyList(FMIScalarVariable scalar){
  List<FMIScalarVariable> inputVariables=new ArrayList<FMIScalarVariable>();
  if (scalar != null) {
    for (    String inputScalarName : scalar.directDependency) {
      for (      FMIScalarVariable inputVar : _fmiModelDescription.modelVariables) {
        if (inputVar.name.equals(inputScalarName))         inputVariables.add(inputVar);
      }
    }
  }
  return inputVariables;
}"
72546,"/** 
 * Import a FMUFile.
 * @param originator The originator of the change request.
 * @param fmuFileParameter The .fmuFile
 * @param context The context in which the FMU actor is created.
 * @param x The x-axis value of the actor to be created.
 * @param y The y-axis value of the actor to be created.
 * @param modelExchange True if the fmu should be importedas a model exchange fmu.
 * @param addMaximumStepSizeParameter True if a parameter named""maximumStepSize"" should be added.
 * @param actorClassName The class name of the Ptolemy actorto be instantiated, for example ""ptolemy.actor.lib.fmi.FMUImport"".
 * @exception IllegalActionException If there is a probleminstantiating the actor.
 * @exception IOException If there is a problem parsing the fmu file.
 */
public static void _importFMU(Object originator,FileParameter fmuFileParameter,NamedObj context,double x,double y,boolean modelExchange,boolean addMaximumStepSizeParameter,String actorClassName) throws IllegalActionException, IOException {
  File fmuFile=fmuFileParameter.asFile();
  String fmuFileName=fmuFile.getCanonicalPath();
  FMIModelDescription fmiModelDescription=FMUFile.parseFMUFile(fmuFileName);
  if (modelExchange) {
    fmiModelDescription.modelExchange=true;
  }
  if (!_acceptFMU(fmiModelDescription)) {
    return;
  }
  String source=""String_Node_Str"";
  if (fmuFileName.startsWith(""String_Node_Str"")) {
    source=""String_Node_Str"" + fmuFileName.trim() + ""String_Node_Str"";
  }
  String rootName=new File(fmuFileName).getName();
  int index=rootName.lastIndexOf('.');
  if (index != -1) {
    rootName=rootName.substring(0,index);
  }
  int maximumNumberOfPortsToDisplay=20;
  int modelVariablesLength=fmiModelDescription.modelVariables.size();
  String hide=""String_Node_Str"";
  String hiddenStyle=""String_Node_Str"";
  String dependency=""String_Node_Str"";
  String showName=""String_Node_Str"" + ""String_Node_Str"" + hiddenStyle + ""String_Node_Str"";
  if (modelVariablesLength > maximumNumberOfPortsToDisplay) {
    MessageHandler.message(""String_Node_Str"" + fmuFileName + ""String_Node_Str""+ modelVariablesLength+ ""String_Node_Str""+ ""String_Node_Str"");
  }
  int portCount=0;
  StringBuffer parameterMoML=new StringBuffer();
  StringBuffer portMoML=new StringBuffer();
  for (  FMIScalarVariable scalar : fmiModelDescription.modelVariables) {
    if (scalar.variability == FMIScalarVariable.Variability.parameter || scalar.variability == FMIScalarVariable.Variability.fixed || scalar.variability == FMIScalarVariable.Variability.tunable) {
switch (scalar.causality) {
case output:
        portCount++;
      String causality=""String_Node_Str"";
    portMoML.append(""String_Node_Str"" + StringUtilities.sanitizeName(scalar.name) + ""String_Node_Str""+ ""String_Node_Str""+ causality+ ""String_Node_Str""+ ""String_Node_Str""+ StringUtilities.escapeForXML(scalar.name)+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ _fmiType2PtolemyType(scalar.type)+ ""String_Node_Str""+ hiddenStyle+ ""String_Node_Str""+ dependency+ showName+ ""String_Node_Str"");
  break;
case input:
break;
case local:
break;
case internal:
break;
case calculatedParameter:
break;
case parameter:
parameterMoML.append(""String_Node_Str"" + StringUtilities.sanitizeName(scalar.name) + ""String_Node_Str""+ scalar.type+ ""String_Node_Str""+ ""String_Node_Str"");
break;
case none:
break;
}
}
 else if (scalar.variability == FMIScalarVariable.Variability.constant) {
continue;
}
 else {
boolean hideLocal=false;
String causality=""String_Node_Str"";
switch (scalar.causality) {
case local:
hideLocal=true;
if (fmiModelDescription.modelExchange) {
if (scalar.isState) {
hideLocal=false;
}
 else {
if (scalar.type instanceof FMIRealType) {
if (((FMIRealType)scalar.type).indexState != -1) {
portCount++;
dependency=""String_Node_Str"";
}
}
}
}
causality=""String_Node_Str"";
break;
case input:
portCount++;
hideLocal=false;
causality=""String_Node_Str"";
break;
case none:
hideLocal=true;
causality=""String_Node_Str"";
break;
case output:
portCount++;
hideLocal=false;
causality=""String_Node_Str"";
dependency=""String_Node_Str"";
break;
case internal:
hideLocal=true;
causality=""String_Node_Str"";
break;
}
portMoML.append(""String_Node_Str"" + StringUtilities.sanitizeName(scalar.name) + ""String_Node_Str""+ ""String_Node_Str""+ causality+ ""String_Node_Str""+ ""String_Node_Str""+ StringUtilities.escapeForXML(scalar.name)+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ _fmiType2PtolemyType(scalar.type)+ ""String_Node_Str""+ hiddenStyle+ ""String_Node_Str""+ dependency+ showName+ (portCount > maximumNumberOfPortsToDisplay || scalar.causality == Causality.internal || hideLocal ? hide : ""String_Node_Str"")+ ""String_Node_Str"");
}
}
if (modelExchange) {
parameterMoML.append(""String_Node_Str"");
if (addMaximumStepSizeParameter) {
parameterMoML.append(""String_Node_Str"");
}
}
String moml=""String_Node_Str"" + ""String_Node_Str"" + rootName + ""String_Node_Str""+ actorClassName+ ""String_Node_Str""+ source+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ x+ ""String_Node_Str""+ y+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ fmuFileParameter.getExpression()+ ""String_Node_Str""+ ""String_Node_Str""+ parameterMoML+ portMoML+ ""String_Node_Str"";
MoMLChangeRequest request=new MoMLChangeRequest(originator,context,moml);
context.requestChange(request);
}","/** 
 * Import a FMUFile.
 * @param originator The originator of the change request.
 * @param fmuFileParameter The .fmuFile
 * @param context The context in which the FMU actor is created.
 * @param x The x-axis value of the actor to be created.
 * @param y The y-axis value of the actor to be created.
 * @param modelExchange True if the fmu should be importedas a model exchange fmu.
 * @param addMaximumStepSizeParameter True if a parameter named""maximumStepSize"" should be added.
 * @param actorClassName The class name of the Ptolemy actorto be instantiated, for example ""ptolemy.actor.lib.fmi.FMUImport"".
 * @exception IllegalActionException If there is a probleminstantiating the actor.
 * @exception IOException If there is a problem parsing the fmu file.
 */
public static void _importFMU(Object originator,FileParameter fmuFileParameter,NamedObj context,double x,double y,boolean modelExchange,boolean addMaximumStepSizeParameter,String actorClassName) throws IllegalActionException, IOException {
  File fmuFile=fmuFileParameter.asFile();
  String fmuFileName=fmuFile.getCanonicalPath();
  FMIModelDescription fmiModelDescription=FMUFile.parseFMUFile(fmuFileName);
  if (modelExchange) {
    fmiModelDescription.modelExchange=true;
  }
  if (!_acceptFMU(fmiModelDescription)) {
    return;
  }
  String source=""String_Node_Str"";
  if (fmuFileName.startsWith(""String_Node_Str"")) {
    source=""String_Node_Str"" + fmuFileName.trim() + ""String_Node_Str"";
  }
  String rootName=new File(fmuFileName).getName();
  int index=rootName.lastIndexOf('.');
  if (index != -1) {
    rootName=rootName.substring(0,index);
  }
  int maximumNumberOfPortsToDisplay=20;
  int modelVariablesLength=fmiModelDescription.modelVariables.size();
  String hide=""String_Node_Str"";
  String hiddenStyle=""String_Node_Str"";
  String dependency=""String_Node_Str"";
  String showName=""String_Node_Str"" + ""String_Node_Str"" + hiddenStyle + ""String_Node_Str"";
  if (modelVariablesLength > maximumNumberOfPortsToDisplay) {
    MessageHandler.message(""String_Node_Str"" + fmuFileName + ""String_Node_Str""+ modelVariablesLength+ ""String_Node_Str""+ ""String_Node_Str"");
  }
  int portCount=0;
  StringBuffer parameterMoML=new StringBuffer();
  StringBuffer portMoML=new StringBuffer();
  for (  FMIScalarVariable scalar : fmiModelDescription.modelVariables) {
    System.out.println(""String_Node_Str"" + scalar.name + ""String_Node_Str""+ scalar.valueReference);
    if (scalar.variability == FMIScalarVariable.Variability.parameter || scalar.variability == FMIScalarVariable.Variability.fixed || scalar.variability == FMIScalarVariable.Variability.tunable) {
switch (scalar.causality) {
case output:
        portCount++;
      String causality=""String_Node_Str"";
    portMoML.append(""String_Node_Str"" + StringUtilities.sanitizeName(scalar.name) + ""String_Node_Str""+ ""String_Node_Str""+ causality+ ""String_Node_Str""+ ""String_Node_Str""+ StringUtilities.escapeForXML(scalar.name)+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ _fmiType2PtolemyType(scalar.type)+ ""String_Node_Str""+ hiddenStyle+ ""String_Node_Str""+ dependency+ showName+ ""String_Node_Str"");
  break;
case input:
break;
case local:
break;
case internal:
break;
case calculatedParameter:
break;
case parameter:
parameterMoML.append(""String_Node_Str"" + StringUtilities.sanitizeName(scalar.name) + ""String_Node_Str""+ scalar.type+ ""String_Node_Str""+ ""String_Node_Str"");
break;
case none:
break;
}
}
 else if (scalar.variability == FMIScalarVariable.Variability.constant) {
continue;
}
 else {
boolean hideLocal=false;
String causality=""String_Node_Str"";
switch (scalar.causality) {
case local:
hideLocal=true;
if (fmiModelDescription.modelExchange) {
if (scalar.isState) {
hideLocal=false;
}
 else {
if (scalar.type instanceof FMIRealType) {
if (((FMIRealType)scalar.type).indexState != -1) {
portCount++;
dependency=""String_Node_Str"";
}
}
}
}
causality=""String_Node_Str"";
break;
case input:
portCount++;
hideLocal=false;
causality=""String_Node_Str"";
break;
case none:
hideLocal=true;
causality=""String_Node_Str"";
break;
case output:
portCount++;
hideLocal=false;
causality=""String_Node_Str"";
dependency=""String_Node_Str"";
break;
case internal:
hideLocal=true;
causality=""String_Node_Str"";
break;
}
portMoML.append(""String_Node_Str"" + StringUtilities.sanitizeName(scalar.name) + ""String_Node_Str""+ ""String_Node_Str""+ causality+ ""String_Node_Str""+ ""String_Node_Str""+ StringUtilities.escapeForXML(scalar.name)+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ _fmiType2PtolemyType(scalar.type)+ ""String_Node_Str""+ hiddenStyle+ ""String_Node_Str""+ dependency+ showName+ (portCount > maximumNumberOfPortsToDisplay || scalar.causality == Causality.internal || hideLocal ? hide : ""String_Node_Str"")+ ""String_Node_Str"");
}
}
if (modelExchange) {
parameterMoML.append(""String_Node_Str"");
if (addMaximumStepSizeParameter) {
parameterMoML.append(""String_Node_Str"");
}
}
String moml=""String_Node_Str"" + ""String_Node_Str"" + rootName + ""String_Node_Str""+ actorClassName+ ""String_Node_Str""+ source+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ x+ ""String_Node_Str""+ y+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ fmuFileParameter.getExpression()+ ""String_Node_Str""+ ""String_Node_Str""+ parameterMoML+ portMoML+ ""String_Node_Str"";
MoMLChangeRequest request=new MoMLChangeRequest(originator,context,moml);
context.requestChange(request);
}"
72547,"/** 
 * Get the persistent value for the specified channel, if there is one. If the persistent value is a SmoothToken, the first extrapolate its value to the current time.
 * @param channelIndex The channel.
 * @return The persistent value, or null if there isn't one.
 */
private Token _getPersistentValue(int channelIndex){
  if (_persistentToken != null) {
    return _persistentToken;
  }
 else   if (_persistentTokens != null && _persistentTokens.length > channelIndex && _persistentTokens[channelIndex] != null) {
    Token result=_persistentTokens[channelIndex];
    if (result instanceof SmoothToken) {
      Actor container=(Actor)getContainer();
      if (container != null) {
        Director director=container.getDirector();
        if (director != null) {
          Time currentTime=director.getModelTime();
          return ((SmoothToken)result).extrapolate(currentTime);
        }
      }
    }
  }
  return null;
}","/** 
 * Get the persistent value for the specified channel, if there is one. If the persistent value is a SmoothToken, the first extrapolate its value to the current time.
 * @param channelIndex The channel.
 * @return The persistent value, or null if there isn't one.
 */
private Token _getPersistentValue(int channelIndex){
  if (_persistentToken != null) {
    return _persistentToken;
  }
 else   if (_persistentTokens != null && _persistentTokens.length > channelIndex && _persistentTokens[channelIndex] != null) {
    Token result=_persistentTokens[channelIndex];
    if (result instanceof SmoothToken) {
      Actor container=(Actor)getContainer();
      if (container != null) {
        Director director=container.getDirector();
        if (director != null) {
          Time currentTime=director.getModelTime();
          return ((SmoothToken)result).extrapolate(currentTime);
        }
      }
    }
 else {
      return _persistentTokens[channelIndex];
    }
  }
  return null;
}"
72548,"/** 
 * Convert the left-hand argument to an array of size one. Then do an element-wise addition with each element of the right-hand argument. This method is only invoked when addition is attempted using a  base type left-hand argument (e.g., 1 + {1, 2, 3} which will  yield {2, 3, 4}.
 * @param leftArgument The array to add this array to.
 * @return The result of the addition.
 * @exception IllegalActionException If addition between this array and the provided argument is not supported.
 */
@Override public Token addReverse(Token leftArgument) throws IllegalActionException {
  try {
    Token[] arr={leftArgument};
    return new ArrayToken(arr).add(this);
  }
 catch (  IllegalActionException ex) {
    throw new IllegalActionException(null,ex,notSupportedMessage(""String_Node_Str"",this,leftArgument));
  }
}","/** 
 * If the left-hand argument is a base type token, then convert it  to an array of size one. Then do an element-wise addition with  each element of the right-hand argument. This method is only invoked when addition is attempted using a  base type left-hand argument (e.g., 1 + {1, 2, 3} which will  yield {2, 3, 4}.
 * @param leftArgument The array to add this array to.
 * @return The result of the addition.
 * @exception IllegalActionException If addition between this array and the provided argument is not supported.
 */
@Override public Token addReverse(Token leftArgument) throws IllegalActionException {
  try {
    int typeInfo=TypeLattice.compare(leftArgument,BaseType.STRING);
    if ((typeInfo == CPO.LOWER || typeInfo == CPO.SAME)) {
      Token[] arr={leftArgument};
      return new ArrayToken(arr).add(this);
    }
 else     if (getClass() == leftArgument.getClass()) {
      return ((ArrayToken)leftArgument).add(this);
    }
 else {
      throw new IllegalActionException(null,notSupportedMessage(""String_Node_Str"",this,leftArgument));
    }
  }
 catch (  IllegalActionException ex) {
    throw new IllegalActionException(null,ex,notSupportedMessage(""String_Node_Str"",this,leftArgument));
  }
}"
72549,"/** 
 * Set the type of the given node to be the return type of the method determined for the given node.
 * @param node The specified node.
 * @exception IllegalActionException If an inference error occurs.
 */
@Override public void visitMethodCallNode(ASTPtMethodCallNode node) throws IllegalActionException {
  Type[] childTypes=_inferAllChildren(node);
  if (childTypes.length == 1 && childTypes[0] instanceof RecordType) {
    RecordType type=(RecordType)childTypes[0];
    if (type.labelSet().contains(node.getMethodName())) {
      _setType(node,type.get(node.getMethodName()));
      return;
    }
  }
  _setType(node,_methodCall(node.getMethodName(),childTypes));
}","/** 
 * Set the type of the given node to be the return type of the method determined for the given node.
 * @param node The specified node.
 * @exception IllegalActionException If an inference error occurs.
 */
@Override public void visitMethodCallNode(ASTPtMethodCallNode node) throws IllegalActionException {
  Type[] childTypes=_inferAllChildren(node);
  if (childTypes.length == 1 && childTypes[0] instanceof RecordType) {
    RecordType type=(RecordType)childTypes[0];
    if (type.labelSet().contains(node.getMethodName())) {
      _setType(node,type.get(node.getMethodName()));
      return;
    }
  }
  if (childTypes.length == 1 && childTypes[0] == BaseType.UNKNOWN) {
    _setType(node,BaseType.UNKNOWN);
  }
 else {
    _setType(node,_methodCall(node.getMethodName(),childTypes));
  }
}"
72550,"/** 
 * Copy object files from $PTII/ptolemy/cg/adapter/generic/program/procedural/c/mbed/lib.
 */
private void _mbedCopy() throws IllegalActionException {
  File directory=codeDirectory.asFile();
  String mbedLibraryDirectory=""String_Node_Str"";
  try {
    File cgLibDirectory=new File(codeDirectory.asFile(),""String_Node_Str"");
    if (!cgLibDirectory.mkdirs()) {
      throw new java.io.FileNotFoundException(""String_Node_Str"" + cgLibDirectory + ""String_Node_Str"");
    }
    String[] objectFiles=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
    for (    String objectFile : objectFiles) {
      _copyCFileTosrc(mbedLibraryDirectory,cgLibDirectory.getCanonicalPath() + ""String_Node_Str"",objectFile);
    }
  }
 catch (  Throwable throwable) {
    throw new IllegalActionException(getComponent(),throwable,""String_Node_Str"" + mbedLibraryDirectory + ""String_Node_Str"");
  }
}","/** 
 * Copy object files from $PTII/ptolemy/cg/adapter/generic/program/procedural/c/mbed/lib.
 */
private void _mbedCopy() throws IllegalActionException {
  File cgLibDirectory=new File(codeDirectory.asFile(),""String_Node_Str"");
  String mbedLibraryDirectory=""String_Node_Str"";
  try {
    if (!cgLibDirectory.mkdirs()) {
      throw new java.io.FileNotFoundException(""String_Node_Str"" + cgLibDirectory + ""String_Node_Str"");
    }
    String[] objectFiles=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
    for (    String objectFile : objectFiles) {
      _copyCFileTosrc(mbedLibraryDirectory,cgLibDirectory.getCanonicalPath() + ""String_Node_Str"",objectFile);
    }
  }
 catch (  Throwable throwable) {
    throw new IllegalActionException(getComponent(),throwable,""String_Node_Str"" + mbedLibraryDirectory + ""String_Node_Str""+ cgLibDirectory+ ""String_Node_Str"");
  }
}"
72551,"/** 
 * Fire the actor actor at the current model time or, if synchronizeToRealTime is enabled, fire the actor at the model time that corresponds to the current real time. This model time is computed by subtracting the model start time recorded by this director at the beginning of the simulation from the  system time and dividing by 1000, as the default unit of time is seconds.
 * @param actor The actor to be fired.
 * @return The model time the actor will be fired at.
 * @exception IllegalActionException If thrown while creating a Time objector while calling fireAt.
 */
@Override public Time fireAtCurrentTime(Actor actor) throws IllegalActionException {
  if (_synchronizeToRealTime) {
    Time modelTimeForCurrentRealTime=new Time(this,(System.currentTimeMillis() - this.getRealStartTimeMillis()) / 1000);
    return fireAt(actor,modelTimeForCurrentRealTime);
  }
 else {
    return super.fireAtCurrentTime(actor);
  }
}","/** 
 * Fire the actor actor at the current model time or, if synchronizeToRealTime is enabled, fire the actor at the model time that corresponds to the current real time. This model time is computed by subtracting the model start time recorded by this director at the beginning of the simulation from the  system time and dividing by 1000, as the default unit of time is seconds.
 * @param actor The actor to be fired.
 * @return The model time the actor will be fired at.
 * @exception IllegalActionException If thrown while creating a Time objector while calling fireAt.
 */
@Override public Time fireAtCurrentTime(Actor actor) throws IllegalActionException {
  if (_synchronizeToRealTime) {
    long elapsedTime=System.currentTimeMillis() - _realStartTime;
    Time modelTimeForCurrentRealTime=new Time(this,(double)elapsedTime / 1000);
    return fireAt(actor,modelTimeForCurrentRealTime);
  }
 else {
    return super.fireAtCurrentTime(actor);
  }
}"
72552,"/** 
 * Initialize this solver, associating it with the specified derivativeFunction object, which determines the number of state variables and input variables and provides a method for calculating the derivatives of the state variables. This method also initializes all input and state variables to zero. These can be the initialized to some other value by calling   {@link #setStateValue(int,double)} and{@link #setInputVariableModel(int,ModelPolynomial)}. The caller of this method should then, after setting state and input values, call   {@link #triggerQuantizationEvents(boolean)}with argument true. <p> This is a convenience method wrapping a sequence of calls to more detailed methods. </p>
 * @param derivativeFunction The object implementing thefunction that provides the derivatives for state variables that this solver is responsible for integrating. This object also provides a method specifying the number of state variables and the number of input variables.
 * @param startTime The start time for the solver.
 * @param maximumTime The maximum time for predicted events (e.g. the stoptime of the simulation). This may be infinite.
 * @param absoluteTolerance The absolute tolerance for all state variables(these can be modified later for individual states using  {@link #setQuantizationTolerance(int,double,double)}).
 * @param relativeTolerance The relative tolerance for all state variables(these can be modified later for individual states using  {@link #setQuantizationTolerance(int,double,double)}).
 * @param inputVariableOrder The order (the number of derivatives provided)for each input variable. If these differ by input variable, then the caller may later modify the input variable models by calling {@link QSSBase#setInputVariableModel(int,ModelPolynomial)}.
 */
public final void initialize(DerivativeFunction derivativeFunction,Time startTime,Time maximumTime,double absoluteTolerance,double relativeTolerance,int inputVariableOrder){
  initializeDerivativeFunction(derivativeFunction);
  initializeSimulationTime(startTime);
  setQuantizationEventTimeMaximum(maximumTime);
  for (int i=0; i < _stateCt; i++) {
    setStateValue(i,0.0);
    setQuantizationTolerance(0,absoluteTolerance,relativeTolerance);
  }
  for (int i=0; i < getInputVariableCount(); i++) {
    ModelPolynomial input=new ModelPolynomial(inputVariableOrder);
    input.claimWriteAccess();
    input.tMdl=startTime;
    setInputVariableModel(i,input);
  }
  final String failMsg=validate();
  assert(failMsg == null);
}","/** 
 * Initialize this solver, associating it with the specified derivativeFunction object, which determines the number of state variables and input variables and provides a method for calculating the derivatives of the state variables. This method also initializes all input and state variables to zero. These can be the initialized to some other value by calling   {@link #setStateValue(int,double)} and{@link #setInputVariableModel(int,ModelPolynomial)}. The caller of this method should then, after setting state and input values, call   {@link #triggerQuantizationEvents(boolean)}with argument true. <p> This is a convenience method wrapping a sequence of calls to more detailed methods. </p>
 * @param derivativeFunction The object implementing thefunction that provides the derivatives for state variables that this solver is responsible for integrating. This object also provides a method specifying the number of state variables and the number of input variables.
 * @param startTime The start time for the solver.
 * @param maximumTime The maximum time for predicted events (e.g. the stoptime of the simulation). This may be infinite.
 * @param absoluteTolerance The absolute tolerance for all state variables(these can be modified later for individual states using  {@link #setQuantizationTolerance(int,double,double)}).
 * @param relativeTolerance The relative tolerance for all state variables(these can be modified later for individual states using  {@link #setQuantizationTolerance(int,double,double)}).
 * @param inputVariableOrder The order (the number of derivatives provided)for each input variable. If these differ by input variable, then the caller may later modify the input variable models by calling {@link QSSBase#setInputVariableModel(int,ModelPolynomial)}.
 */
public final void initialize(DerivativeFunction derivativeFunction,Time startTime,Time maximumTime,double absoluteTolerance,double relativeTolerance,int inputVariableOrder){
  initializeDerivativeFunction(derivativeFunction);
  initializeSimulationTime(startTime);
  setQuantizationEventTimeMaximum(maximumTime);
  for (int i=0; i < _stateCt; i++) {
    setStateValue(i,0.0);
    setQuantizationTolerance(i,absoluteTolerance,relativeTolerance);
  }
  for (int i=0; i < getInputVariableCount(); i++) {
    ModelPolynomial input=new ModelPolynomial(inputVariableOrder);
    input.claimWriteAccess();
    input.tMdl=startTime;
    setInputVariableModel(i,input);
  }
  final String failMsg=validate();
  assert(failMsg == null);
}"
72553,"/** 
 * Get the next actor that can be fired from a specified event queue. Check whether the event is safe to process, the actors prefire returns true and the event can be scheduled. Because Ptides does not store tokens in receivers but keeps them in the event until the actor is really fired, we have to temporarily put tokens into receivers and then remove them in order for the prefire to give correct results.
 * @param queue The event queue.
 * @return The next actor to fire or null.
 * @exception IllegalActionException Thrown by safeToProcess, prefireor schedule.
 */
private Actor _getNextActorFrom(DEEventQueue queue) throws IllegalActionException {
  Object[] eventArray=queue.toArray();
  for (  Object event : eventArray) {
    if (_isSafeToProcess((PtidesEvent)event)) {
      PtidesEvent ptidesEvent=(PtidesEvent)event;
      Actor actor=ptidesEvent.actor();
      Time timestamp=ptidesEvent.timeStamp();
      if (queue == _pureEvents) {
        for (        Object triggeredEventObject : _eventQueue.toArray()) {
          PtidesEvent triggeredEvent=(PtidesEvent)triggeredEventObject;
          if (triggeredEvent.actor() == actor && triggeredEvent.timeStamp().compareTo(timestamp) < 0) {
            ptidesEvent=triggeredEvent;
          }
        }
      }
      actor=ptidesEvent.actor();
      timestamp=ptidesEvent.timeStamp();
      List<PtidesEvent> sameTagEvents=new ArrayList<PtidesEvent>();
      int i=0;
      while (i < queue.size()) {
        PtidesEvent eventInQueue=((PtidesListEventQueue)queue).get(i);
        if (eventInQueue.hasTheSameTagAs(ptidesEvent) && eventInQueue.actor().equals(actor)) {
          sameTagEvents.add(eventInQueue);
          if (eventInQueue.receiver() != null) {
            if (eventInQueue.receiver() instanceof PtidesReceiver) {
              ((PtidesReceiver)eventInQueue.receiver()).putToReceiver(eventInQueue.token());
            }
          }
        }
        i++;
      }
      _currentLogicalTime=timestamp;
      _currentLogicalIndex=ptidesEvent.microstep();
      _currentSourceTimestamp=ptidesEvent.sourceTimestamp();
      boolean prefire=actor.prefire();
      _currentLogicalTime=null;
      for (      PtidesEvent sameTagEvent : sameTagEvents) {
        if (sameTagEvent.receiver() != null) {
          if (sameTagEvent.receiver() instanceof PtidesReceiver) {
            ((PtidesReceiver)sameTagEvent.receiver()).remove(sameTagEvent.token());
          }
        }
      }
      if (prefire && (!_aspectsPresent || ((actor instanceof TimeDelay && !ptidesEvent.isPureEvent()) || _actorsFinished.contains(actor) || _schedule((NamedObj)actor,timestamp)) && (!(actor instanceof CompositeActor) || ((CompositeActor)actor).getDirector().scheduleContainedActors()))) {
        _currentLogicalTime=timestamp;
        _currentLogicalIndex=ptidesEvent.microstep();
        _currentSourceTimestamp=ptidesEvent.sourceTimestamp();
        _removeEventsFromQueue(_eventQueue,ptidesEvent);
        _removeEventsFromQueue(_pureEvents,ptidesEvent);
        _actorsFinished.remove(actor);
        if (_debugging) {
          _debug(""String_Node_Str"" + actor + ""String_Node_Str""+ timestamp);
        }
        return actor;
      }
    }
  }
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  return null;
}","/** 
 * Get the next actor that can be fired from a specified event queue. Check whether the event is safe to process, the actors prefire returns true and the event can be scheduled. Because Ptides does not store tokens in receivers but keeps them in the event until the actor is really fired, we have to temporarily put tokens into receivers and then remove them in order for the prefire to give correct results.
 * @param queue The event queue.
 * @return The next actor to fire or null.
 * @exception IllegalActionException Thrown by safeToProcess, prefireor schedule.
 */
private Actor _getNextActorFrom(DEEventQueue queue) throws IllegalActionException {
  Object[] eventArray=queue.toArray();
  for (  Object event : eventArray) {
    if (_isSafeToProcess((PtidesEvent)event)) {
      PtidesEvent ptidesEvent=(PtidesEvent)event;
      Actor actor=ptidesEvent.actor();
      Time timestamp=ptidesEvent.timeStamp();
      if (queue == _pureEvents) {
        for (        Object triggeredEventObject : _eventQueue.toArray()) {
          PtidesEvent triggeredEvent=(PtidesEvent)triggeredEventObject;
          if (triggeredEvent.actor() == actor && triggeredEvent.timeStamp().compareTo(timestamp) < 0) {
            ptidesEvent=triggeredEvent;
          }
        }
      }
      actor=ptidesEvent.actor();
      timestamp=ptidesEvent.timeStamp();
      List<PtidesEvent> sameTagEvents=new ArrayList<PtidesEvent>();
      int i=0;
      while (i < queue.size()) {
        PtidesEvent eventInQueue=((PtidesListEventQueue)queue).get(i);
        if (eventInQueue.actor().equals(actor) && eventInQueue.hasTheSameTagAs(ptidesEvent)) {
          sameTagEvents.add(eventInQueue);
          if (eventInQueue.receiver() != null) {
            if (eventInQueue.receiver() instanceof PtidesReceiver) {
              ((PtidesReceiver)eventInQueue.receiver()).putToReceiver(eventInQueue.token());
            }
          }
        }
        i++;
      }
      _currentLogicalTime=timestamp;
      _currentLogicalIndex=ptidesEvent.microstep();
      _currentSourceTimestamp=ptidesEvent.sourceTimestamp();
      boolean prefire=actor.prefire();
      _currentLogicalTime=null;
      for (      PtidesEvent sameTagEvent : sameTagEvents) {
        if (sameTagEvent.receiver() != null) {
          if (sameTagEvent.receiver() instanceof PtidesReceiver) {
            ((PtidesReceiver)sameTagEvent.receiver()).remove(sameTagEvent.token());
          }
        }
      }
      if (prefire && (!_aspectsPresent || ((actor instanceof TimeDelay && !ptidesEvent.isPureEvent()) || _actorsFinished.contains(actor) || _schedule((NamedObj)actor,timestamp)) && (!(actor instanceof CompositeActor) || ((CompositeActor)actor).getDirector().scheduleContainedActors()))) {
        _currentLogicalTime=timestamp;
        _currentLogicalIndex=ptidesEvent.microstep();
        _currentSourceTimestamp=ptidesEvent.sourceTimestamp();
        _removeEventsFromQueue(_eventQueue,ptidesEvent);
        _removeEventsFromQueue(_pureEvents,ptidesEvent);
        _actorsFinished.remove(actor);
        if (_debugging) {
          _debug(""String_Node_Str"" + actor + ""String_Node_Str""+ timestamp);
        }
        return actor;
      }
    }
  }
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  return null;
}"
72554,"/** 
 * Remove all events with the same tag and at the same actor from the event queue.
 * @param event The event.
 * @return A list of all events with same tag and at the same actor as theevent.
 */
private List<PtidesEvent> _removeEventsFromQueue(DEEventQueue queue,PtidesEvent event){
  List<PtidesEvent> eventList=new ArrayList<PtidesEvent>();
  int i=0;
  while (i < queue.size()) {
    PtidesEvent eventInQueue=((PtidesListEventQueue)queue).get(i);
    if (eventInQueue.hasTheSameTagAs(event) && eventInQueue.actor().equals(event.actor())) {
      eventList.add(eventInQueue);
      IOPort port=eventInQueue.ioPort();
      if (port != null) {
        _numberOfTokensPerPort.put(port,_numberOfTokensPerPort.get(port) - 1);
      }
      ((PtidesListEventQueue)queue).take(i);
      continue;
    }
    i++;
  }
  return eventList;
}","/** 
 * Remove all events with the same tag and at the same actor from the event queue.
 * @param event The event.
 * @return A list of all events with same tag and at the same actor as theevent.
 */
private List<PtidesEvent> _removeEventsFromQueue(DEEventQueue queue,PtidesEvent event){
  List<PtidesEvent> eventList=new ArrayList<PtidesEvent>();
  int i=0;
  while (i < queue.size()) {
    PtidesEvent eventInQueue=((PtidesListEventQueue)queue).get(i);
    if (eventInQueue.actor().equals(event.actor()) && eventInQueue.hasTheSameTagAs(event)) {
      eventList.add(eventInQueue);
      IOPort port=eventInQueue.ioPort();
      if (port != null) {
        _numberOfTokensPerPort.put(port,_numberOfTokensPerPort.get(port) - 1);
      }
      ((PtidesListEventQueue)queue).take(i);
      continue;
    }
    i++;
  }
  return eventList;
}"
72555,"@Override public boolean hasTheSameTagAs(DEEvent event){
  Actor actor=event.actor();
  if (actor == null) {
    actor=(Actor)event.ioPort().getContainer();
  }
  Double clockSyncBound=null;
  try {
    clockSyncBound=PtidesDirector._getDoubleParameterValue((NamedObj)actor,""String_Node_Str"");
  }
 catch (  IllegalActionException e) {
  }
  if (clockSyncBound == null) {
    clockSyncBound=0.0;
  }
  boolean same=false;
  if (clockSyncBound == 0.0) {
    same=_timestamp.compareTo(event.timeStamp()) == 0 && _microstep == event.microstep();
  }
 else {
    same=_timestamp.subtract(clockSyncBound).compareTo(event.timeStamp()) <= 0 && _timestamp.add(clockSyncBound).compareTo(event.timeStamp()) >= 0;
    same=same & _microstep == event.microstep();
  }
  return same;
}","/** 
 * Compare event timestamp and microstep.
 * @param event The event to compare with.
 */
@Override public boolean hasTheSameTagAs(DEEvent event){
  if (event == this) {
    return true;
  }
  Actor actor=event.actor();
  if (actor == null) {
    actor=(Actor)event.ioPort().getContainer();
  }
  boolean same=_timestamp.compareTo(event.timeStamp()) == 0 && _microstep == event.microstep();
  return same;
}"
72556,"/** 
 * Construct a date token with all tokens present. If a token for the long value is present, use this token and time zone as well as precision. Otherwise use tokens on other inputs to create ports.
 * @exception IllegalActionException If thrown by the superclass,if there is no director, ifthere is a problem reading a parameter, or if there is a problem sending the date token.
 */
@Override public void fire(){
  super.fire();
  DateToken dateToken=null;
  int datePrecision=DateToken.PRECISION_MILLISECOND;
  String precisionValue=((StringToken)precision.getToken()).stringValue();
  if (precisionValue.equals(""String_Node_Str"")) {
    datePrecision=DateToken.PRECISION_SECOND;
  }
 else   if (precisionValue.equals(""String_Node_Str"")) {
    datePrecision=DateToken.PRECISION_MILLISECOND;
  }
 else   if (precisionValue.equals(""String_Node_Str"")) {
    datePrecision=DateToken.PRECISION_MICROSECOND;
  }
 else   if (precisionValue.equals(""String_Node_Str"")) {
    datePrecision=DateToken.PRECISION_NANOSECOND;
  }
 else {
    datePrecision=DateToken.PRECISION_MILLISECOND;
  }
  Integer timeZoneValue=_getIntValue(timeZoneOffset);
  TimeZone timeZone=TimeZone.getDefault();
  if (timeZoneValue != null) {
    timeZone=TimeZone.getTimeZone(""String_Node_Str"" + (timeZoneValue < 0 ? ""String_Node_Str"" : ""String_Node_Str"") + String.format(""String_Node_Str"",timeZoneValue));
  }
  long timeAsLongValue=_getLongValue(timeInMillis);
  int microsecondValue=_getIntValue(microsecond);
  int nanosecondValue=_getIntValue(nanosecond);
  if (!((BooleanToken)useTimeInMillis.getToken()).booleanValue()) {
    int yearValue=_getIntValue(year);
    int monthValue=_getIntValue(month);
    int dayValue=_getIntValue(day);
    int hourValue=_getIntValue(hour);
    int minuteValue=_getIntValue(minute);
    int secondValue=_getIntValue(second);
    int millisecondValue=_getIntValue(millisecond);
    Calendar c=Calendar.getInstance(timeZone);
    c.set(Calendar.YEAR,yearValue);
    c.set(Calendar.MONTH,monthValue);
    c.set(Calendar.DAY_OF_MONTH,dayValue);
    c.set(Calendar.HOUR_OF_DAY,hourValue);
    c.set(Calendar.MINUTE,minuteValue);
    c.set(Calendar.SECOND,secondValue);
    c.set(Calendar.MILLISECOND,millisecondValue);
    timeAsLongValue=c.getTimeInMillis();
    if (datePrecision == DateToken.PRECISION_SECOND) {
      timeAsLongValue=timeAsLongValue / 1000;
    }
 else     if (datePrecision == DateToken.PRECISION_MICROSECOND) {
      timeAsLongValue=timeAsLongValue * 1000;
    }
 else     if (datePrecision == DateToken.PRECISION_NANOSECOND) {
      timeAsLongValue=timeAsLongValue * 1000 * 1000;
    }
  }
  dateToken=new DateToken(timeAsLongValue,datePrecision,timeZone);
  dateToken.addMicroseconds(microsecondValue);
  dateToken.addNanoseconds(nanosecondValue);
  output.send(0,dateToken);
}","/** 
 * Construct a date token with all tokens present. If a token for the long value is present, use this token and time zone as well as precision. Otherwise use tokens on other inputs to create ports.
 * @exception IllegalActionException If thrown by the superclass,if there is no director, ifthere is a problem reading a parameter, or if there is a problem sending the date token.
 */
@Override public void fire() throws IllegalActionException {
  super.fire();
  DateToken dateToken=null;
  int datePrecision=DateToken.PRECISION_MILLISECOND;
  String precisionValue=((StringToken)precision.getToken()).stringValue();
  if (precisionValue.equals(""String_Node_Str"")) {
    datePrecision=DateToken.PRECISION_SECOND;
  }
 else   if (precisionValue.equals(""String_Node_Str"")) {
    datePrecision=DateToken.PRECISION_MILLISECOND;
  }
 else   if (precisionValue.equals(""String_Node_Str"")) {
    datePrecision=DateToken.PRECISION_MICROSECOND;
  }
 else   if (precisionValue.equals(""String_Node_Str"")) {
    datePrecision=DateToken.PRECISION_NANOSECOND;
  }
 else {
    datePrecision=DateToken.PRECISION_MILLISECOND;
  }
  Integer timeZoneValue=_getIntValue(timeZoneOffset);
  TimeZone timeZone=TimeZone.getDefault();
  if (timeZoneValue != null) {
    timeZone=TimeZone.getTimeZone(""String_Node_Str"" + (timeZoneValue < 0 ? ""String_Node_Str"" : ""String_Node_Str"") + String.format(""String_Node_Str"",timeZoneValue));
  }
  long timeAsLongValue=_getLongValue(timeInMillis);
  int microsecondValue=_getIntValue(microsecond);
  int nanosecondValue=_getIntValue(nanosecond);
  if (!((BooleanToken)useTimeInMillis.getToken()).booleanValue()) {
    int yearValue=_getIntValue(year);
    int monthValue=_getIntValue(month);
    int dayValue=_getIntValue(day);
    int hourValue=_getIntValue(hour);
    int minuteValue=_getIntValue(minute);
    int secondValue=_getIntValue(second);
    int millisecondValue=_getIntValue(millisecond);
    Calendar c=Calendar.getInstance(timeZone);
    c.set(Calendar.YEAR,yearValue);
    c.set(Calendar.MONTH,monthValue);
    c.set(Calendar.DAY_OF_MONTH,dayValue);
    c.set(Calendar.HOUR_OF_DAY,hourValue);
    c.set(Calendar.MINUTE,minuteValue);
    c.set(Calendar.SECOND,secondValue);
    c.set(Calendar.MILLISECOND,millisecondValue);
    timeAsLongValue=c.getTimeInMillis();
    if (datePrecision == DateToken.PRECISION_SECOND) {
      timeAsLongValue=timeAsLongValue / 1000;
    }
 else     if (datePrecision == DateToken.PRECISION_MICROSECOND) {
      timeAsLongValue=timeAsLongValue * 1000;
    }
 else     if (datePrecision == DateToken.PRECISION_NANOSECOND) {
      timeAsLongValue=timeAsLongValue * 1000 * 1000;
    }
  }
  dateToken=new DateToken(timeAsLongValue,datePrecision,timeZone);
  dateToken.addMicroseconds(microsecondValue);
  dateToken.addNanoseconds(nanosecondValue);
  output.send(0,dateToken);
}"
72557,"/** 
 * Generate the code for the firing of actors. In this base class, it is attempted to fire all the actors once. In subclasses such as the adapters for SDF and Giotto directors, the firings of actors observe the associated schedule. In addition, some special handling is needed, e.g., the iteration limit in SDF and time advancement in Giotto.
 * @return The generated code.
 * @exception IllegalActionException If the adapter associated with an actor throws it while generating fire code for the actor.
 */
@Override public String generateFMIMA() throws IllegalActionException {
  StringBuffer code=new StringBuffer();
  NamedProgramCodeGeneratorAdapter adapter=(NamedProgramCodeGeneratorAdapter)getAdapter(getComponent());
  Iterator<?> actors=((CompositeActor)adapter.getComponent().getContainer()).deepEntityList().iterator();
  code.append(getCodeGenerator().comment(""String_Node_Str"" + _eol + ""String_Node_Str""+ adapter.getComponent().getName()));
  CodeStream codeStream=_templateParser.getCodeStream();
  codeStream.clear();
  codeStream.appendCodeBlock(""String_Node_Str"");
  code.append(processCode(codeStream.toString()));
  HashMap<TypedIOPort,Node> actorNodeMap=new HashMap<TypedIOPort,Node>();
  HashMap<Node,TypedIOPort> actorPortMap=new HashMap<Node,TypedIOPort>();
  HashMap<String,Node> actorNodeNamesMap=new HashMap<String,Node>();
  DirectedGraph graph=new DirectedGraph();
  actors=((CompositeActor)adapter.getComponent().getContainer()).deepEntityList().iterator();
  while (actors.hasNext()) {
    ptolemy.actor.lib.fmi.FMUImport actor=(ptolemy.actor.lib.fmi.FMUImport)actors.next();
    for (    TypedIOPort input : actor.inputPortList()) {
      Node node=new Node(input);
      actorNodeMap.put(input,node);
      actorPortMap.put(node,input);
      actorNodeNamesMap.put(input.getFullName(),node);
      graph.addNode(node);
    }
    for (    TypedIOPort output : actor.outputPortList()) {
      Node node=new Node(output);
      actorNodeMap.put(output,node);
      actorPortMap.put(node,output);
      actorNodeNamesMap.put(output.getFullName(),node);
      graph.addNode(node);
    }
  }
  actors=((CompositeActor)adapter.getComponent().getContainer()).deepEntityList().iterator();
  while (actors.hasNext()) {
    ptolemy.actor.lib.fmi.FMUImport actor=(ptolemy.actor.lib.fmi.FMUImport)actors.next();
    for (    TypedIOPort input : actor.inputPortList()) {
      Node sinkNode=(Node)actorNodeMap.get(input);
      List<TypedIOPort> connected_ports=input.connectedPortList();
      for (int port_idx=0; port_idx < connected_ports.size(); port_idx++) {
        TypedIOPort output=(TypedIOPort)connected_ports.get(port_idx);
        Node sourceNode=(Node)actorNodeMap.get(output);
        graph.addEdge(sourceNode,sinkNode);
      }
    }
    for (    TypedIOPort output : actor.outputPortList()) {
      Node sinkNode=(Node)actorNodeMap.get(output);
      Set<String> inputPorts=actor.getInputDependencyList(output.getName());
      if (inputPorts != null) {
        Iterator<String> inputIterator=inputPorts.iterator();
        while (inputIterator.hasNext()) {
          String input=(String)inputIterator.next();
          Node sourceNode=(Node)actorNodeNamesMap.get(actor.getPort(input).getFullName());
          graph.addEdge(sourceNode,sinkNode);
        }
      }
    }
    code.append(""String_Node_Str"" + actor.getName() + ""String_Node_Str"");
    code.append(""String_Node_Str"" + actor.getName() + ""String_Node_Str""+ actor.fmuFile.asFile().toString().replace(""String_Node_Str"",""String_Node_Str"")+ ""String_Node_Str"");
    code.append(""String_Node_Str"" + actor.getName() + ""String_Node_Str""+ actor.fmuFile.asFile().toString().replace(""String_Node_Str"",""String_Node_Str"")+ ""String_Node_Str"");
    code.append(""String_Node_Str"" + actor.getName() + ""String_Node_Str"");
    code.append(""String_Node_Str"" + actor.getName() + ""String_Node_Str""+ actor.getName()+ ""String_Node_Str"");
  }
  Collection<Node> nodeCollection=graph.nodes();
  if (graph.isAcyclic() == false) {
    throw new IllegalActionException(adapter.getComponent(),""String_Node_Str"");
  }
  List sortedGraph=graph.topologicalSort(nodeCollection);
  int connectionIndex=0;
  while (sortedGraph.size() > 1) {
    Node portSourceNode=(Node)sortedGraph.get(0);
    Node portSinkNode=(Node)sortedGraph.get(1);
    sortedGraph.remove(portSourceNode);
    sortedGraph.remove(portSinkNode);
    TypedIOPort outputPort=actorPortMap.get(portSourceNode);
    TypedIOPort inputPort=actorPortMap.get(portSinkNode);
    ptolemy.actor.lib.fmi.FMUImport sourceActor=(ptolemy.actor.lib.fmi.FMUImport)actorPortMap.get(portSourceNode).getContainer();
    ptolemy.actor.lib.fmi.FMUImport sinkActor=(ptolemy.actor.lib.fmi.FMUImport)actorPortMap.get(portSinkNode).getContainer();
    String fmuSourceName=sourceActor.getName();
    String fmuSinkName=sinkActor.getName();
    code.append(""String_Node_Str"" + connectionIndex + ""String_Node_Str""+ fmuSourceName+ ""String_Node_Str""+ ""String_Node_Str""+ connectionIndex+ ""String_Node_Str""+ fmuSourceName+ ""String_Node_Str""+ sourceActor.getValueReference(outputPort.getName())+ ""String_Node_Str""+ ""String_Node_Str""+ connectionIndex+ ""String_Node_Str""+ sourceActor.getTypeOfPort(outputPort.getName())+ ""String_Node_Str""+ ""String_Node_Str""+ connectionIndex+ ""String_Node_Str""+ fmuSinkName+ ""String_Node_Str"");
    Long sinkActorInputValueReference=sinkActor.getValueReference(inputPort.getName());
    if (sinkActorInputValueReference < 0) {
      System.err.println(""String_Node_Str"" + inputPort.getName() + ""String_Node_Str""+ sinkActor.getFullName()+ ""String_Node_Str""+ sinkActorInputValueReference+ ""String_Node_Str"");
    }
 else {
      code.append(""String_Node_Str"" + connectionIndex + ""String_Node_Str""+ fmuSinkName+ ""String_Node_Str""+ sinkActorInputValueReference+ ""String_Node_Str"");
    }
    String sinkActorPortType=sinkActor.getTypeOfPort(inputPort.getName());
    if (sinkActorPortType.equals(""String_Node_Str"")) {
      System.err.println(""String_Node_Str"" + inputPort.getName() + ""String_Node_Str""+ sinkActor.getFullName());
    }
 else {
      code.append(""String_Node_Str"" + connectionIndex + ""String_Node_Str""+ sinkActorPortType+ ""String_Node_Str"");
    }
    connectionIndex++;
  }
  codeStream=_templateParser.getCodeStream();
  codeStream.clear();
  codeStream.appendCodeBlock(""String_Node_Str"");
  code.append(processCode(codeStream.toString()));
  code.append(getCodeGenerator().comment(""String_Node_Str""));
  return code.toString();
}","/** 
 * Generate the code for the firing of actors. In this base class, it is attempted to fire all the actors once. In subclasses such as the adapters for SDF and Giotto directors, the firings of actors observe the associated schedule. In addition, some special handling is needed, e.g., the iteration limit in SDF and time advancement in Giotto.
 * @return The generated code.
 * @exception IllegalActionException If the adapter associated with an actor throws it while generating fire code for the actor.
 */
@Override public String generateFMIMA() throws IllegalActionException {
  StringBuffer code=new StringBuffer();
  NamedProgramCodeGeneratorAdapter adapter=(NamedProgramCodeGeneratorAdapter)getAdapter(getComponent());
  Iterator<?> actors=((CompositeActor)adapter.getComponent().getContainer()).deepEntityList().iterator();
  code.append(getCodeGenerator().comment(""String_Node_Str"" + _eol + ""String_Node_Str""+ adapter.getComponent().getName()));
  CodeStream codeStream=_templateParser.getCodeStream();
  codeStream.clear();
  codeStream.appendCodeBlock(""String_Node_Str"");
  code.append(processCode(codeStream.toString()));
  HashMap<TypedIOPort,Node> actorNodeMap=new HashMap<TypedIOPort,Node>();
  HashMap<Node,TypedIOPort> actorPortMap=new HashMap<Node,TypedIOPort>();
  HashMap<String,Node> actorNodeNamesMap=new HashMap<String,Node>();
  DirectedGraph graph=new DirectedGraph();
  actors=((CompositeActor)adapter.getComponent().getContainer()).deepEntityList().iterator();
  while (actors.hasNext()) {
    ptolemy.actor.lib.fmi.FMUImport actor=(ptolemy.actor.lib.fmi.FMUImport)actors.next();
    for (    TypedIOPort input : actor.inputPortList()) {
      Node node=new Node(input);
      actorNodeMap.put(input,node);
      actorPortMap.put(node,input);
      actorNodeNamesMap.put(input.getFullName(),node);
      graph.addNode(node);
    }
    for (    TypedIOPort output : actor.outputPortList()) {
      Node node=new Node(output);
      actorNodeMap.put(output,node);
      actorPortMap.put(node,output);
      actorNodeNamesMap.put(output.getFullName(),node);
      graph.addNode(node);
    }
  }
  actors=((CompositeActor)adapter.getComponent().getContainer()).deepEntityList().iterator();
  int connectionNumber=0;
  while (actors.hasNext()) {
    ptolemy.actor.lib.fmi.FMUImport actor=(ptolemy.actor.lib.fmi.FMUImport)actors.next();
    for (    TypedIOPort input : actor.inputPortList()) {
      Node sinkNode=(Node)actorNodeMap.get(input);
      List<TypedIOPort> connected_ports=input.connectedPortList();
      for (int port_idx=0; port_idx < connected_ports.size(); port_idx++) {
        TypedIOPort output=(TypedIOPort)connected_ports.get(port_idx);
        Node sourceNode=(Node)actorNodeMap.get(output);
        graph.addEdge(sourceNode,sinkNode);
        connectionNumber++;
      }
    }
    for (    TypedIOPort output : actor.outputPortList()) {
      Node sinkNode=(Node)actorNodeMap.get(output);
      Set<String> inputPorts=actor.getInputDependencyList(output.getName());
      if (inputPorts != null) {
        Iterator<String> inputIterator=inputPorts.iterator();
        while (inputIterator.hasNext()) {
          String input=(String)inputIterator.next();
          Node sourceNode=(Node)actorNodeNamesMap.get(actor.getPort(input).getFullName());
          graph.addEdge(sourceNode,sinkNode);
        }
      }
    }
    code.append(""String_Node_Str"" + actor.getName() + ""String_Node_Str"");
    code.append(""String_Node_Str"" + actor.getName() + ""String_Node_Str""+ actor.fmuFile.asFile().toString().replace(""String_Node_Str"",""String_Node_Str"")+ ""String_Node_Str"");
    code.append(""String_Node_Str"" + actor.getName() + ""String_Node_Str""+ actor.fmuFile.asFile().toString().replace(""String_Node_Str"",""String_Node_Str"")+ ""String_Node_Str"");
    code.append(""String_Node_Str"" + actor.getName() + ""String_Node_Str"");
    code.append(""String_Node_Str"" + actor.getName() + ""String_Node_Str""+ actor.getName()+ ""String_Node_Str"");
  }
  Collection<Node> nodeCollection=graph.nodes();
  if (graph.isAcyclic() == false) {
    throw new IllegalActionException(adapter.getComponent(),""String_Node_Str"");
  }
  List sortedGraph=graph.topologicalSort(nodeCollection);
  int connectionIndex=0;
  for (int i=0; i < connectionNumber; i++) {
    Node portSourceNode=(Node)sortedGraph.get(0);
    Node portSinkNode=(Node)sortedGraph.get(1);
    sortedGraph.remove(portSourceNode);
    sortedGraph.remove(portSinkNode);
    TypedIOPort outputPort=actorPortMap.get(portSourceNode);
    TypedIOPort inputPort=actorPortMap.get(portSinkNode);
    ptolemy.actor.lib.fmi.FMUImport sourceActor=(ptolemy.actor.lib.fmi.FMUImport)actorPortMap.get(portSourceNode).getContainer();
    ptolemy.actor.lib.fmi.FMUImport sinkActor=(ptolemy.actor.lib.fmi.FMUImport)actorPortMap.get(portSinkNode).getContainer();
    String fmuSourceName=sourceActor.getName();
    String fmuSinkName=sinkActor.getName();
    code.append(""String_Node_Str"" + connectionIndex + ""String_Node_Str""+ fmuSourceName+ ""String_Node_Str""+ ""String_Node_Str""+ connectionIndex+ ""String_Node_Str""+ fmuSourceName+ ""String_Node_Str""+ sourceActor.getValueReference(outputPort.getName())+ ""String_Node_Str""+ ""String_Node_Str""+ connectionIndex+ ""String_Node_Str""+ sourceActor.getTypeOfPort(outputPort.getName())+ ""String_Node_Str""+ ""String_Node_Str""+ connectionIndex+ ""String_Node_Str""+ fmuSinkName+ ""String_Node_Str"");
    Long sinkActorInputValueReference=sinkActor.getValueReference(inputPort.getName());
    if (sinkActorInputValueReference < 0) {
      System.err.println(""String_Node_Str"" + inputPort.getName() + ""String_Node_Str""+ sinkActor.getFullName()+ ""String_Node_Str""+ sinkActorInputValueReference+ ""String_Node_Str"");
    }
 else {
      code.append(""String_Node_Str"" + connectionIndex + ""String_Node_Str""+ fmuSinkName+ ""String_Node_Str""+ sinkActorInputValueReference+ ""String_Node_Str"");
    }
    String sinkActorPortType=sinkActor.getTypeOfPort(inputPort.getName());
    if (sinkActorPortType.equals(""String_Node_Str"")) {
      System.err.println(""String_Node_Str"" + inputPort.getName() + ""String_Node_Str""+ sinkActor.getFullName());
    }
 else {
      code.append(""String_Node_Str"" + connectionIndex + ""String_Node_Str""+ sinkActorPortType+ ""String_Node_Str"");
    }
    connectionIndex++;
  }
  codeStream=_templateParser.getCodeStream();
  codeStream.clear();
  codeStream.appendCodeBlock(""String_Node_Str"");
  code.append(processCode(codeStream.toString()));
  code.append(getCodeGenerator().comment(""String_Node_Str""));
  return code.toString();
}"
72558,"/** 
 * Construct a new instance of this integrator.
 * @param container The container.
 * @param name The name.
 * @exception IllegalActionException If setting up ports and parameters fails.
 * @exception NameDuplicationException If the container already contains an object with this name.
 */
public QSSIntegrator(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  u=new TypedIOPort(this,""String_Node_Str"",true,false);
  u.setTypeEquals(BaseType.DOUBLE);
  q=new TypedIOPort(this,""String_Node_Str"",false,true);
  q.setTypeEquals(BaseType.DOUBLE);
  xInit=new Parameter(this,""String_Node_Str"");
  xInit.setTypeEquals(BaseType.DOUBLE);
  xInit.setExpression(""String_Node_Str"");
  quantum=new Parameter(this,""String_Node_Str"");
  quantum.setTypeEquals(BaseType.DOUBLE);
  quantum.setExpression(""String_Node_Str"");
}","/** 
 * Construct a new instance of this integrator.
 * @param container The container.
 * @param name The name.
 * @exception IllegalActionException If setting up ports and parameters fails.
 * @exception NameDuplicationException If the container already contains an object with this name.
 */
public QSSIntegrator(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  u=new TypedIOPort(this,""String_Node_Str"",true,false);
  u.setTypeEquals(BaseType.DOUBLE);
  q=new TypedIOPort(this,""String_Node_Str"",false,true);
  q.setTypeEquals(BaseType.DOUBLE);
  xInit=new Parameter(this,""String_Node_Str"");
  xInit.setTypeEquals(BaseType.DOUBLE);
  xInit.setExpression(""String_Node_Str"");
  errorTolerance=new Parameter(this,""String_Node_Str"");
  errorTolerance.setTypeEquals(BaseType.DOUBLE);
}"
72559,"/** 
 * If it is time to produce a quantized output, produce it. Otherwise, indicate that the output is absent.
 * @exception IllegalActionException If sending an output fails.
 */
@Override public void fire() throws IllegalActionException {
  super.fire();
  Time currentTime=getDirector().getModelTime();
  if (_debugging) {
    _debug(""String_Node_Str"" + currentTime);
  }
  assert(_qssSolver.needQuantizationEventIndex() == -1);
  if (_qssSolver.getCurrentSimulationTime().compareTo(currentTime) < 0) {
    try {
      _qssSolver.stepToTime(currentTime);
    }
 catch (    Exception ee) {
      throw new IllegalActionException(this,ee,ee.getMessage());
    }
    if (_qssSolver.needQuantizationEventIndex() >= 0) {
      _qssSolver.triggerQuantizationEvent(0);
      if (q.getWidth() > 0) {
        double[] model=_qssSolver.getStateModel(0).coeffs;
        q.send(0,new SmoothToken(model[0]));
      }
    }
  }
}","/** 
 * If it is time to produce a quantized output, produce it. Otherwise, indicate that the output is absent.
 * @exception IllegalActionException If sending an output fails.
 */
@Override public void fire() throws IllegalActionException {
  super.fire();
  Time currentTime=getDirector().getModelTime();
  if (_debugging) {
    _debug(""String_Node_Str"" + currentTime);
  }
  assert(_qssSolver.needQuantizationEventIndex() == -1);
  if (_qssSolver.getCurrentSimulationTime().compareTo(currentTime) < 0) {
    try {
      _qssSolver.stepToTime(currentTime);
    }
 catch (    Exception ee) {
      throw new IllegalActionException(this,ee,ee.getMessage());
    }
    if (_qssSolver.needQuantizationEventIndex() >= 0) {
      _qssSolver.triggerQuantizationEvent(0);
      if (q.getWidth() > 0) {
        double[] model=_qssSolver.getStateModel(0).coeffs;
        q.send(0,new SmoothToken(model[0]));
      }
    }
  }
 else   if (_firstRound) {
    double[] model=_qssSolver.getStateModel(0).coeffs;
    q.send(0,new SmoothToken(model[0]));
  }
}"
72560,"/** 
 * Initialize this actor to indicate that no input has yet been provided.
 */
@Override public void initialize() throws IllegalActionException {
  super.initialize();
  Director director=getDirector();
  if (!(director instanceof QSSDirector)) {
    throw new IllegalActionException(this,String.format(""String_Node_Str"",director.getName()));
  }
  _director=(QSSDirector)director;
  final Time currentTime=_director.getModelTime();
  _qssSolver=_director.newQSSSolver();
  _qssSolver.initializeDerivativeFunction(this);
  _qssSolver.initializeSimulationTime(currentTime);
  _qssSolver.setQuantizationEventTimeMaximum(_director.getModelStopTime());
  double xInitValue=((DoubleToken)xInit.getToken()).doubleValue();
  _qssSolver.setStateValue(0,xInitValue);
  double tolerance=_director.getErrorTolerance();
  _qssSolver.setQuantizationTolerance(0,tolerance,tolerance);
  getDirector().fireAtCurrentTime(this);
  _firstRound=true;
}","/** 
 * Initialize this actor to indicate that no input has yet been provided.
 */
@Override public void initialize() throws IllegalActionException {
  super.initialize();
  Director director=getDirector();
  if (!(director instanceof QSSDirector)) {
    throw new IllegalActionException(this,String.format(""String_Node_Str"",director.getName()));
  }
  _director=(QSSDirector)director;
  final Time currentTime=_director.getModelTime();
  _qssSolver=_director.newQSSSolver();
  _qssSolver.initializeDerivativeFunction(this);
  _qssSolver.initializeSimulationTime(currentTime);
  _qssSolver.setQuantizationEventTimeMaximum(_director.getModelStopTime());
  double xInitValue=((DoubleToken)xInit.getToken()).doubleValue();
  _qssSolver.setStateValue(0,xInitValue);
  double tolerance=_director.getErrorTolerance();
  DoubleToken toleranceToken=(DoubleToken)errorTolerance.getToken();
  if (toleranceToken != null) {
    tolerance=toleranceToken.doubleValue();
  }
  _qssSolver.setQuantizationTolerance(0,tolerance,tolerance);
  getDirector().fireAtCurrentTime(this);
  _firstRound=true;
  _lastFireAtTime=null;
}"
72561,"/** 
 * Configure the QSS integrator's input variable models. <p>This cannot be done during initialization stage, because did not yet have all the information needed.</p>
 * @param currentTime The current simulation time.
 */
private final void _initializeQSSIntegratorInputVariables(final Time currentTime) throws IllegalActionException {
  if (_debugging) {
    _debugToStdOut(String.format(""String_Node_Str"",System.identityHashCode(this),currentTime.toString()));
  }
  final int ivCt=_qssSolver.getInputVariableCount();
  if (ivCt > 0) {
    _inputVariableModels=new ModelPolynomial[ivCt];
  }
  final int ivMdlOrder=_qssSolver.getStateModelOrder();
  for (int ii=0; ii < ivCt; ++ii) {
    final Input input=_inputs.get(ii);
    if (!input.port.isKnown(0)) {
      throw new IllegalActionException(this,String.format(""String_Node_Str"",input.port.getName()));
    }
    final ModelPolynomial ivMdl=new ModelPolynomial(ivMdlOrder);
    _inputVariableModels[ii]=ivMdl;
    ivMdl.claimWriteAccess();
    _qssSolver.addInputVariableModel(ii,ivMdl);
  }
  for (int ii=0; ii < ivCt; ++ii) {
    final Input input=_inputs.get(ii);
    double initialValue;
    if (input.port.hasToken(0)) {
      final Token token=input.port.get(0);
      if (token instanceof QSSToken) {
        final QSSToken qssTok=(QSSToken)token;
        initialValue=qssTok.valueAndDerivatives()[0];
      }
 else       if (token instanceof DoubleToken) {
        initialValue=((DoubleToken)token).doubleValue();
      }
 else {
        throw new IllegalActionException(this,String.format(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",input.port.getName()));
      }
    }
 else {
      initialValue=input.start;
      if (_debugging) {
        _debugToStdOut(String.format(""String_Node_Str"",System.identityHashCode(this),ii,initialValue));
      }
    }
    final ModelPolynomial ivMdl=_inputVariableModels[ii];
    ivMdl.coeffs[0]=initialValue;
    ivMdl.tMdl=currentTime;
  }
  final String failMsg=_qssSolver.validate();
  if (null != failMsg) {
    throw new IllegalActionException(this,failMsg);
  }
  _triggerQuantizationEvents(currentTime,false);
  try {
    _qssSolver.triggerRateEvent();
  }
 catch (  Exception ee) {
    throw new IllegalActionException(this,ee,""String_Node_Str"");
  }
}","/** 
 * Configure the QSS integrator's input variable models. <p>This cannot be done during initialization stage, because did not yet have all the information needed.</p>
 * @param currentTime The current simulation time.
 */
private final void _initializeQSSIntegratorInputVariables(final Time currentTime) throws IllegalActionException {
  if (_debugging) {
    _debugToStdOut(String.format(""String_Node_Str"",System.identityHashCode(this),currentTime.toString()));
  }
  final int ivCt=_qssSolver.getInputVariableCount();
  if (ivCt > 0) {
    _inputVariableModels=new ModelPolynomial[ivCt];
  }
  final int ivMdlOrder=_qssSolver.getStateModelOrder();
  for (int ii=0; ii < ivCt; ++ii) {
    final Input input=_inputs.get(ii);
    if (!input.port.isKnown(0)) {
      throw new IllegalActionException(this,String.format(""String_Node_Str"",input.port.getName()));
    }
    final ModelPolynomial ivMdl=new ModelPolynomial(ivMdlOrder);
    _inputVariableModels[ii]=ivMdl;
    ivMdl.claimWriteAccess();
    _qssSolver.addInputVariableModel(ii,ivMdl);
  }
  for (int ii=0; ii < ivCt; ++ii) {
    final Input input=_inputs.get(ii);
    double initialValue;
    if (input.port.hasToken(0)) {
      final Token token=input.port.get(0);
      if (token instanceof QSSToken) {
        final QSSToken qssTok=(QSSToken)token;
        initialValue=qssTok.doubleValue();
      }
 else       if (token instanceof DoubleToken) {
        initialValue=((DoubleToken)token).doubleValue();
      }
 else {
        throw new IllegalActionException(this,String.format(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",input.port.getName()));
      }
    }
 else {
      initialValue=input.start;
      if (_debugging) {
        _debugToStdOut(String.format(""String_Node_Str"",System.identityHashCode(this),ii,initialValue));
      }
    }
    final ModelPolynomial ivMdl=_inputVariableModels[ii];
    ivMdl.coeffs[0]=initialValue;
    ivMdl.tMdl=currentTime;
  }
  final String failMsg=_qssSolver.validate();
  if (null != failMsg) {
    throw new IllegalActionException(this,failMsg);
  }
  _triggerQuantizationEvents(currentTime,false);
  try {
    _qssSolver.triggerRateEvent();
  }
 catch (  Exception ee) {
    throw new IllegalActionException(this,ee,""String_Node_Str"");
  }
}"
72562,"/** 
 * Trigger a rate-event if necessary. <p>Update the internal, continuous state models.</p>
 * @param currentTime The current simulation time.
 * @param force If true, always trigger a rate-event. Otherwise,only trigger a rate-event if an input changed or if the integrator signals it needs one to satisfy internal logic.
 */
private final void _triggerRateEvent(final Time currentTime,final boolean force) throws IllegalActionException {
  if (_debugging) {
    _debugToStdOut(String.format(""String_Node_Str"",System.identityHashCode(this),currentTime.toString()));
  }
  int currIdx=0;
  boolean updatedInputVarMdl=false;
  for (  Input input : _inputs) {
    assert(input.port.isKnown(0));
    if (input.port.hasToken(0)) {
      final Token token=input.port.get(0);
      final ModelPolynomial ivMdl=_inputVariableModels[currIdx];
      final int order=_qssSolver.getStateModelOrder();
      _getModelFromPort(order,ivMdl,token);
      ivMdl.tMdl=currentTime;
      updatedInputVarMdl=true;
      _inputs.get(currIdx).hasChanged=true;
      if (_debugging) {
        _debugToStdOut(String.format(""String_Node_Str"",System.identityHashCode(this),currIdx,ivMdl.toString()));
      }
    }
    currIdx++;
  }
  assert(_qssSolver.getInputVariableCount() == currIdx);
  if (force || updatedInputVarMdl || _qssSolver.needRateEvent()) {
    if (_debugging) {
      _debugToStdOut(String.format(""String_Node_Str"",System.identityHashCode(this),force,updatedInputVarMdl,_qssSolver.needRateEvent()));
    }
    try {
      _qssSolver.triggerRateEvent();
    }
 catch (    Exception ee) {
      throw new IllegalActionException(this,ee,""String_Node_Str"");
    }
  }
}","/** 
 * Trigger a rate-event if necessary. <p>Update the internal, continuous state models.</p>
 * @param currentTime The current simulation time.
 * @param force If true, always trigger a rate-event. Otherwise,only trigger a rate-event if an input changed or if the integrator signals it needs one to satisfy internal logic.
 */
private final void _triggerRateEvent(final Time currentTime,final boolean force) throws IllegalActionException {
  if (_debugging) {
    _debugToStdOut(String.format(""String_Node_Str"",System.identityHashCode(this),currentTime.toString()));
  }
  int currIdx=0;
  boolean updatedInputVarMdl=false;
  for (  Input input : _inputs) {
    assert(input.port.isKnown(0));
    if (input.port.hasToken(0)) {
      final Token token=input.port.get(0);
      final ModelPolynomial ivMdl=_inputVariableModels[currIdx];
      _getModelFromToken(ivMdl,token);
      ivMdl.tMdl=currentTime;
      updatedInputVarMdl=true;
      _inputs.get(currIdx).hasChanged=true;
      if (_debugging) {
        _debugToStdOut(String.format(""String_Node_Str"",System.identityHashCode(this),currIdx,ivMdl.toString()));
      }
    }
    currIdx++;
  }
  assert(_qssSolver.getInputVariableCount() == currIdx);
  if (force || updatedInputVarMdl || _qssSolver.needRateEvent()) {
    if (_debugging) {
      _debugToStdOut(String.format(""String_Node_Str"",System.identityHashCode(this),force,updatedInputVarMdl,_qssSolver.needRateEvent()));
    }
    try {
      _qssSolver.triggerRateEvent();
    }
 catch (    Exception ee) {
      throw new IllegalActionException(this,ee,""String_Node_Str"");
    }
  }
}"
72563,"/** 
 * Invoke fmiDoStep() of the slave FMU, if necessary to catch up to current time, and then set the (known) inputs of the FMU and retrieve and send out any outputs for which all inputs on which the output depends are known.
 * @exception IllegalActionException If the FMU indicates a failure.
 */
@Override public void fire() throws IllegalActionException {
  super.fire();
  Director director=getDirector();
  Time currentTime=director.getModelTime();
  int currentMicrostep=1;
  if (director instanceof SuperdenseTimeDirector) {
    currentMicrostep=((SuperdenseTimeDirector)director).getIndex();
  }
  if (_debugging) {
    _debugToStdOut(""String_Node_Str"" + currentTime + ""String_Node_Str""+ currentMicrostep);
  }
  double derivatives[]=null;
  FMI20EventInfo.ByReference fmi20EventInfo=null;
  if (_fmiModelDescription.modelExchange) {
    if (!_firstFire) {
      derivatives=_fmiGetDerivatives();
    }
    if (_fmiVersion < 2.0) {
      _fmiSetTime(currentTime);
    }
    if (_firstFire) {
      _fmiInitialize();
      if (_fmiVersion >= 2.0) {
        FMI20ModelInstance fmi20ModelInstance=new FMI20ModelInstance(_fmiComponent);
        FMI20EventInfo fmi20EventInfoStruct=fmi20ModelInstance.eventInfo;
        fmi20EventInfo=new FMI20EventInfo.ByReference(fmi20EventInfoStruct);
        fmi20EventInfo.newDiscreteStatesNeeded=(byte)1;
        fmi20EventInfo.terminateSimulation=(byte)0;
        if (fmi20EventInfo.terminateSimulation == (byte)1) {
          double currentTimeValue=currentTime.getDoubleValue();
          System.out.println(""String_Node_Str"" + currentTimeValue);
          getDirector().finish();
          return;
        }
      }
      _recordFMUState();
      _lastCommitTime=currentTime;
      _checkEventIndicators();
    }
    if (_fmiVersion >= 2.0) {
      _enterEventMode();
    }
    double states[]=_states.array();
    if (_newStates == null || _newStates.length != states.length) {
      _newStates=new double[states.length];
    }
  }
 else {
    if (_firstFire) {
      for (      Input input : _getInputs()) {
        if (input.start != null) {
          _setFMUScalarVariable(input.scalarVariable,new DoubleToken(input.start.doubleValue()));
          if (_debugging) {
            _debug(""String_Node_Str"" + input.port.getName() + ""String_Node_Str""+ input.start);
          }
        }
      }
    }
    double refinedStepSize=_fmiDoStep(currentTime,currentMicrostep);
    if (refinedStepSize >= 0.0) {
      _stepSizeRejected=true;
      if (_refinedStepSize < 0.0 || refinedStepSize < _refinedStepSize) {
        _refinedStepSize=refinedStepSize;
      }
    }
  }
  int _index;
  for (  Input input : _getInputs()) {
    if (input.port.getWidth() > 0 && input.port.isKnown(0)) {
      if (input.port.hasToken(0)) {
        Token token=input.port.get(0);
        _setFMUScalarVariable(input.scalarVariable,token);
        if ((_fmiVersion >= 2.0) && _fmiModelDescription.modelExchange && _fmiModelDescription.continuousStateNames.contains(input.scalarVariable.name)) {
          _index=_fmiModelDescription.continuousStateNames.indexOf(input.scalarVariable.name);
          _newStates[_index]=((DoubleToken)token).doubleValue();
        }
        if (_debugging) {
          _debugToStdOut(""String_Node_Str"" + input.scalarVariable.name + ""String_Node_Str""+ token);
        }
      }
 else {
        boolean persistentInputsValue=((BooleanToken)persistentInputs.getToken()).booleanValue();
        if (!persistentInputsValue) {
          throw new IllegalActionException(this,""String_Node_Str"" + input.scalarVariable.name + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
        }
 else {
          if (_debugging) {
            _debug(""String_Node_Str"" + input.port.getName() + ""String_Node_Str"");
          }
        }
      }
    }
 else {
      if (_debugging) {
        _debug(""String_Node_Str"" + input.port.getName() + ""String_Node_Str"");
      }
    }
  }
  if (_fmiModelDescription.modelExchange) {
    double currentTimeValue=currentTime.getDoubleValue();
    double states[]=_states.array();
    if (_fmiVersion >= 2.0) {
      _enterContinuousTimeMode();
    }
    if (currentTimeValue > _lastCommitTime.getDoubleValue()) {
      if (states.length > 0) {
        if (_fmiVersion < 2.0) {
          double step=currentTimeValue - _lastCommitTime.getDoubleValue();
          for (int i=0; i < states.length; i++) {
            _newStates[i]=states[i] + derivatives[i] * step;
          }
        }
        _fmiSetContinuousStates(_newStates);
      }
      boolean stateEventOccurred=_checkEventIndicators();
      boolean timeEventOccurred=false;
      if (_fmiVersion < 2.0) {
        _fmiCompletedIntegratorStep(stateEventOccurred || timeEventOccurred);
      }
 else {
        boolean noSetFMUStatePriorToCurrentPoint=true;
        boolean stepEvent=_fmiCompletedIntegratorStep(noSetFMUStatePriorToCurrentPoint);
        if (stepEvent) {
          _enterEventMode();
          if (stepEvent) {
            if (_debugging) {
              _debug(""String_Node_Str"" + currentTimeValue);
            }
          }
          fmi20EventInfo.newDiscreteStatesNeeded=(byte)1;
          fmi20EventInfo.terminateSimulation=(byte)0;
          System.out.println(""String_Node_Str"");
          if (fmi20EventInfo.terminateSimulation == (byte)1) {
            System.out.println(""String_Node_Str"" + currentTimeValue);
            getDirector().finish();
          }
          _enterContinuousTimeMode();
          if (_debugging) {
            if (fmi20EventInfo.valuesOfContinuousStatesChanged == (byte)1) {
              _debug(""String_Node_Str"" + currentTimeValue);
            }
            if (fmi20EventInfo.nominalsOfContinuousStatesChanged == (byte)1) {
              _debug(""String_Node_Str"" + currentTimeValue);
            }
          }
        }
      }
    }
 else {
    }
  }
  for (  Output output : _getOutputs()) {
    TypedIOPort port=output.port;
    if (_debugging) {
      _debugToStdOut(""String_Node_Str"" + port.getName());
    }
    if (_skipIfKnown() && port.isKnown(0)) {
      continue;
    }
    boolean foundUnknownInputOnWhichOutputDepends=false;
    if (output.dependencies != null) {
      for (      TypedIOPort inputPort : output.dependencies) {
        if (_debugging) {
          _debugToStdOut(""String_Node_Str"" + port.getName() + ""String_Node_Str""+ inputPort.getName());
        }
        if (!inputPort.isKnown(0)) {
          if (_debugging) {
            _debugToStdOut(""String_Node_Str"" + ""String_Node_Str"" + port.getName() + ""String_Node_Str""+ inputPort.getName()+ ""String_Node_Str"");
          }
          foundUnknownInputOnWhichOutputDepends=true;
          break;
        }
      }
    }
 else {
      List<TypedIOPort> inputPorts=inputPortList();
      for (      TypedIOPort inputPort : inputPorts) {
        if (_debugging) {
          _debugToStdOut(""String_Node_Str"" + port.getName() + ""String_Node_Str""+ inputPort.getName());
        }
        if (inputPort.getWidth() < 0 || !inputPort.isKnown(0)) {
          foundUnknownInputOnWhichOutputDepends=true;
          if (_debugging) {
            _debugToStdOut(""String_Node_Str"" + ""String_Node_Str"" + port.getName() + ""String_Node_Str""+ inputPort.getName()+ ""String_Node_Str"");
          }
          break;
        }
      }
    }
    if (_debugging) {
      _debugToStdOut(""String_Node_Str"" + port.getName() + ""String_Node_Str""+ foundUnknownInputOnWhichOutputDepends);
    }
    if (!foundUnknownInputOnWhichOutputDepends) {
      Token token=null;
      FMIScalarVariable scalarVariable=output.scalarVariable;
      if (scalarVariable.type instanceof FMIBooleanType) {
        boolean result=scalarVariable.getBoolean(_fmiComponent);
        token=new BooleanToken(result);
      }
 else       if (scalarVariable.type instanceof FMIIntegerType) {
        int result=scalarVariable.getInt(_fmiComponent);
        token=new IntToken(result);
      }
 else       if (scalarVariable.type instanceof FMIRealType) {
        double result=scalarVariable.getDouble(_fmiComponent);
        token=new DoubleToken(result);
      }
 else       if (scalarVariable.type instanceof FMIStringType) {
        String result=scalarVariable.getString(_fmiComponent);
        token=new StringToken(result);
      }
 else {
        throw new IllegalActionException(""String_Node_Str"" + scalarVariable.type + ""String_Node_Str"");
      }
      if (_debugging) {
        _debugToStdOut(""String_Node_Str"" + scalarVariable.name + ""String_Node_Str""+ token+ ""String_Node_Str""+ currentTime+ ""String_Node_Str""+ currentMicrostep);
      }
      port.send(0,token);
    }
  }
  _firstFireInIteration=false;
  _firstFire=false;
}","/** 
 * Invoke fmiDoStep() of the slave FMU, if necessary to catch up to current time, and then set the (known) inputs of the FMU and retrieve and send out any outputs for which all inputs on which the output depends are known.
 * @exception IllegalActionException If the FMU indicates a failure.
 */
@Override public void fire() throws IllegalActionException {
  super.fire();
  Director director=getDirector();
  Time currentTime=director.getModelTime();
  int currentMicrostep=1;
  if (director instanceof SuperdenseTimeDirector) {
    currentMicrostep=((SuperdenseTimeDirector)director).getIndex();
  }
  if (_debugging) {
    _debugToStdOut(""String_Node_Str"" + currentTime + ""String_Node_Str""+ currentMicrostep);
  }
  double derivatives[]=null;
  FMI20EventInfo.ByReference fmi20EventInfo=null;
  if (_fmiModelDescription.modelExchange) {
    if (!_firstFire) {
      derivatives=_fmiGetDerivatives();
    }
    if (_fmiVersion < 2.0) {
      _fmiSetTime(currentTime);
    }
    if (_firstFire) {
      _fmiInitialize();
      if (_fmiVersion >= 2.0) {
        FMI20ModelInstance fmi20ModelInstance=new FMI20ModelInstance(_fmiComponent);
        fmi20EventInfo=new FMI20EventInfo.ByReference(fmi20ModelInstance.eventInfo);
        fmi20EventInfo.newDiscreteStatesNeeded=(byte)1;
        fmi20EventInfo.terminateSimulation=(byte)0;
        if (fmi20EventInfo.terminateSimulation == (byte)1) {
          double currentTimeValue=currentTime.getDoubleValue();
          System.out.println(""String_Node_Str"" + currentTimeValue);
          getDirector().finish();
          return;
        }
      }
      _recordFMUState();
      _lastCommitTime=currentTime;
      _checkEventIndicators();
    }
    if (_fmiVersion >= 2.0) {
      _enterEventMode();
    }
    double states[]=_states.array();
    if (_newStates == null || _newStates.length != states.length) {
      _newStates=new double[states.length];
    }
  }
 else {
    if (_firstFire) {
      for (      Input input : _getInputs()) {
        if (input.start != null) {
          _setFMUScalarVariable(input.scalarVariable,new DoubleToken(input.start.doubleValue()));
          if (_debugging) {
            _debug(""String_Node_Str"" + input.port.getName() + ""String_Node_Str""+ input.start);
          }
        }
      }
    }
    double refinedStepSize=_fmiDoStep(currentTime,currentMicrostep);
    if (refinedStepSize >= 0.0) {
      _stepSizeRejected=true;
      if (_refinedStepSize < 0.0 || refinedStepSize < _refinedStepSize) {
        _refinedStepSize=refinedStepSize;
      }
    }
  }
  int _index;
  for (  Input input : _getInputs()) {
    if (input.port.getWidth() > 0 && input.port.isKnown(0)) {
      if (input.port.hasToken(0)) {
        Token token=input.port.get(0);
        _setFMUScalarVariable(input.scalarVariable,token);
        if ((_fmiVersion >= 2.0) && _fmiModelDescription.modelExchange && _fmiModelDescription.continuousStateNames.contains(input.scalarVariable.name)) {
          _index=_fmiModelDescription.continuousStateNames.indexOf(input.scalarVariable.name);
          _newStates[_index]=((DoubleToken)token).doubleValue();
        }
        if (_debugging) {
          _debugToStdOut(""String_Node_Str"" + input.scalarVariable.name + ""String_Node_Str""+ token);
        }
      }
 else {
        boolean persistentInputsValue=((BooleanToken)persistentInputs.getToken()).booleanValue();
        if (!persistentInputsValue) {
          throw new IllegalActionException(this,""String_Node_Str"" + input.scalarVariable.name + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
        }
 else {
          if (_debugging) {
            _debug(""String_Node_Str"" + input.port.getName() + ""String_Node_Str"");
          }
        }
      }
    }
 else {
      if (_debugging) {
        _debug(""String_Node_Str"" + input.port.getName() + ""String_Node_Str"");
      }
    }
  }
  if (_fmiModelDescription.modelExchange) {
    double currentTimeValue=currentTime.getDoubleValue();
    double states[]=_states.array();
    if (_fmiVersion >= 2.0) {
      _enterContinuousTimeMode();
    }
    if (currentTimeValue > _lastCommitTime.getDoubleValue()) {
      if (states.length > 0) {
        if (_fmiVersion < 2.0) {
          double step=currentTimeValue - _lastCommitTime.getDoubleValue();
          for (int i=0; i < states.length; i++) {
            _newStates[i]=states[i] + derivatives[i] * step;
          }
        }
        _fmiSetContinuousStates(_newStates);
      }
      boolean stateEventOccurred=_checkEventIndicators();
      boolean timeEventOccurred=false;
      if (_fmiVersion < 2.0) {
        _fmiCompletedIntegratorStep(stateEventOccurred || timeEventOccurred);
      }
 else {
        boolean noSetFMUStatePriorToCurrentPoint=true;
        boolean stepEvent=_fmiCompletedIntegratorStep(noSetFMUStatePriorToCurrentPoint);
        if (stepEvent) {
          _enterEventMode();
          if (stepEvent) {
            if (_debugging) {
              _debug(""String_Node_Str"" + currentTimeValue);
            }
          }
          fmi20EventInfo.newDiscreteStatesNeeded=(byte)1;
          fmi20EventInfo.terminateSimulation=(byte)0;
          System.out.println(""String_Node_Str"");
          if (fmi20EventInfo.terminateSimulation == (byte)1) {
            System.out.println(""String_Node_Str"" + currentTimeValue);
            getDirector().finish();
          }
          _enterContinuousTimeMode();
          if (_debugging) {
            if (fmi20EventInfo.valuesOfContinuousStatesChanged == (byte)1) {
              _debug(""String_Node_Str"" + currentTimeValue);
            }
            if (fmi20EventInfo.nominalsOfContinuousStatesChanged == (byte)1) {
              _debug(""String_Node_Str"" + currentTimeValue);
            }
          }
        }
      }
    }
 else {
    }
  }
  for (  Output output : _getOutputs()) {
    TypedIOPort port=output.port;
    if (_debugging) {
      _debugToStdOut(""String_Node_Str"" + port.getName());
    }
    if (_skipIfKnown() && port.isKnown(0)) {
      continue;
    }
    boolean foundUnknownInputOnWhichOutputDepends=false;
    if (output.dependencies != null) {
      for (      TypedIOPort inputPort : output.dependencies) {
        if (_debugging) {
          _debugToStdOut(""String_Node_Str"" + port.getName() + ""String_Node_Str""+ inputPort.getName());
        }
        if (!inputPort.isKnown(0)) {
          if (_debugging) {
            _debugToStdOut(""String_Node_Str"" + ""String_Node_Str"" + port.getName() + ""String_Node_Str""+ inputPort.getName()+ ""String_Node_Str"");
          }
          foundUnknownInputOnWhichOutputDepends=true;
          break;
        }
      }
    }
 else {
      List<TypedIOPort> inputPorts=inputPortList();
      for (      TypedIOPort inputPort : inputPorts) {
        if (_debugging) {
          _debugToStdOut(""String_Node_Str"" + port.getName() + ""String_Node_Str""+ inputPort.getName());
        }
        if (inputPort.getWidth() < 0 || !inputPort.isKnown(0)) {
          foundUnknownInputOnWhichOutputDepends=true;
          if (_debugging) {
            _debugToStdOut(""String_Node_Str"" + ""String_Node_Str"" + port.getName() + ""String_Node_Str""+ inputPort.getName()+ ""String_Node_Str"");
          }
          break;
        }
      }
    }
    if (_debugging) {
      _debugToStdOut(""String_Node_Str"" + port.getName() + ""String_Node_Str""+ foundUnknownInputOnWhichOutputDepends);
    }
    if (!foundUnknownInputOnWhichOutputDepends) {
      Token token=null;
      FMIScalarVariable scalarVariable=output.scalarVariable;
      if (scalarVariable.type instanceof FMIBooleanType) {
        boolean result=scalarVariable.getBoolean(_fmiComponent);
        token=new BooleanToken(result);
      }
 else       if (scalarVariable.type instanceof FMIIntegerType) {
        int result=scalarVariable.getInt(_fmiComponent);
        token=new IntToken(result);
      }
 else       if (scalarVariable.type instanceof FMIRealType) {
        double result=scalarVariable.getDouble(_fmiComponent);
        token=new DoubleToken(result);
      }
 else       if (scalarVariable.type instanceof FMIStringType) {
        String result=scalarVariable.getString(_fmiComponent);
        token=new StringToken(result);
      }
 else {
        throw new IllegalActionException(""String_Node_Str"" + scalarVariable.type + ""String_Node_Str"");
      }
      if (_debugging) {
        _debugToStdOut(""String_Node_Str"" + scalarVariable.name + ""String_Node_Str""+ token+ ""String_Node_Str""+ currentTime+ ""String_Node_Str""+ currentMicrostep);
      }
      port.send(0,token);
    }
  }
  _firstFireInIteration=false;
  _firstFire=false;
}"
72564,"/** 
 * Instantiate the slave FMU component.
 * @exception IllegalActionException If it cannot be instantiated.
 */
@Override public void preinitialize() throws IllegalActionException {
  if (_fmiModelDescription == null) {
    throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
  }
  super.preinitialize();
  if (_debugging) {
    _debugToStdOut(""String_Node_Str"");
  }
  try {
    _nativeLibrary=_fmiModelDescription.getNativeLibrary();
  }
 catch (  IOException e1) {
    throw new IllegalActionException(this,e1,""String_Node_Str"");
  }
  if (_nativeLibrary == null) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  _checkFmiCommon();
  try {
    if (_fmiModelDescription.modelExchange) {
      try {
        if (_fmiVersion < 2.0 || !_completedIntegratorStepNotNeeded()) {
          _fmiCompletedIntegratorStepFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        }
      }
 catch (      Throwable throwable) {
        throw new IllegalActionException(this,throwable,""String_Node_Str"" + _fmuFileName + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      }
      if (_fmiVersion < 2.0) {
        try {
          _fmiFreeModelInstanceFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        }
 catch (        UnsatisfiedLinkError ex) {
          throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
        }
      }
 else {
        try {
          _fmiFreeInstanceFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        }
 catch (        UnsatisfiedLinkError ex) {
          throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
        }
      }
      _fmiGetContinuousStatesFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      _fmiSetContinuousStates=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      _fmiGetDerivativesFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      try {
        _fmiGetEventIndicatorsFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
 catch (      UnsatisfiedLinkError ex) {
        _fmiGetEventIndicatorsFunction=null;
      }
      if (_fmiVersion < 1.5) {
        _fmiInitializeFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiInstantiateModelFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
 else       if (_fmiVersion >= 1.5 && _fmiVersion < 2.0) {
        throw new IllegalActionException(this,""String_Node_Str"" + _fmiVersion);
      }
 else {
        _fmiEnterContinuousTimeModeFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiEnterEventModeFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiEnterInitializationModeFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiExitInitializationModeFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiInstantiateFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiNewDiscreteStatesFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
      _fmiSetTimeFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      _fmiTerminateFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      if (_fmiVersion >= 2.0) {
        try {
          _fmiSetupExperimentFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        }
 catch (        UnsatisfiedLinkError ex) {
          throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
        }
      }
      _checkFmiModelExchange();
    }
 else {
      _fmiDoStepFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      if (_fmiVersion < 2.0) {
        try {
          _fmiFreeSlaveInstanceFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        }
 catch (        UnsatisfiedLinkError ex) {
          throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
        }
      }
 else {
        _fmiEnterInitializationModeFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiExitInitializationModeFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        try {
          _fmiFreeInstanceFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        }
 catch (        UnsatisfiedLinkError ex) {
          throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
        }
      }
      if (_fmiVersion < 2.0) {
        _fmiInitializeSlaveFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiInstantiateSlaveFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
 else {
        _fmiInstantiateFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
      if (_fmiVersion < 2.0) {
        _fmiTerminateSlaveFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
 else {
        _fmiTerminateFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
      try {
        _fmiGetRealStatusFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
 catch (      UnsatisfiedLinkError ex) {
        _fmiGetRealStatusFunction=null;
      }
      if (_fmiModelDescription.canGetAndSetFMUstate) {
        _fmiFreeFMUstateFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiGetFMUstateFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiSetFMUstate=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
 else {
        _fmiFreeFMUstateFunction=null;
        _fmiGetFMUstateFunction=null;
        _fmiSetFMUstate=null;
      }
      if (_fmiVersion >= 2.0) {
        try {
          _fmiSetupExperimentFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        }
 catch (        UnsatisfiedLinkError ex) {
          throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
        }
      }
      _checkFmiCoSimulation();
    }
  }
 catch (  IOException ex) {
    throw new IllegalActionException(this,ex,""String_Node_Str"");
  }
  String modelIdentifier=_fmiModelDescription.modelIdentifier;
  String mimeType=""String_Node_Str"";
  double timeout=1000;
  byte toBeVisible=0;
  int toBeVisibleFMI2=0;
  if (((BooleanToken)visible.getToken()).booleanValue()) {
    toBeVisible=1;
    toBeVisibleFMI2=1;
  }
  byte interactive=0;
  byte loggingOn=_debugging ? (byte)1 : (byte)0;
  int loggingOnFMI2=_debugging ? (byte)1 : (byte)0;
  if (_fmiVersion < 1.5) {
    _callbacks=new FMICallbackFunctions.ByValue(new FMULibrary.FMULogger(_fmiModelDescription),new FMULibrary.FMUAllocateMemory(),new FMULibrary.FMUFreeMemory(),new FMULibrary.FMUStepFinished());
    if (_fmiModelDescription.modelExchange) {
      if (_debugging) {
        _debugToStdOut(""String_Node_Str"" + modelIdentifier + ""String_Node_Str"");
      }
      _fmiComponent=(Pointer)_fmiInstantiateModelFunction.invoke(Pointer.class,new Object[]{getFullName(),_fmiModelDescription.guid,_callbacks,loggingOn});
    }
 else {
      if (_debugging) {
        _debugToStdOut(""String_Node_Str"" + modelIdentifier + ""String_Node_Str"");
      }
      _fmiComponent=(Pointer)_fmiInstantiateSlaveFunction.invoke(Pointer.class,new Object[]{getFullName(),_fmiModelDescription.guid,_fmiModelDescription.fmuResourceLocation,mimeType,timeout,toBeVisible,interactive,_callbacks,loggingOn});
    }
  }
 else {
    _callbacks=new FMICallbackFunctions(new FMULibrary.FMULogger(_fmiModelDescription),new FMULibrary.FMUAllocateMemory(),new FMULibrary.FMUFreeMemory(),new FMULibrary.FMUStepFinished());
    if (_debugging) {
      _debugToStdOut(""String_Node_Str"" + modelIdentifier + ""String_Node_Str"");
    }
    int fmiType=1;
    if (_fmiModelDescription.modelExchange) {
      fmiType=0;
    }
    if (_fmiVersion < 2.0) {
      if (_fmiModelDescription.modelExchange) {
        throw new IllegalActionException(this,""String_Node_Str"" + _fmiVersion);
      }
 else {
        _fmiComponent=(Pointer)_fmiInstantiateSlaveFunction.invoke(Pointer.class,new Object[]{getFullName(),_fmiModelDescription.guid,_fmiModelDescription.fmuResourceLocation,_callbacks,toBeVisible,loggingOn});
      }
    }
 else     if (_fmiVersion >= 2.0) {
      _fmiComponent=(Pointer)_fmiInstantiateFunction.invoke(Pointer.class,new Object[]{getFullName(),fmiType,_fmiModelDescription.guid,_fmiModelDescription.fmuResourceLocation,_callbacks,toBeVisibleFMI2,loggingOnFMI2});
    }
  }
  if (_fmiComponent == null || _fmiComponent.equals(Pointer.NULL)) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
}","/** 
 * Instantiate the slave FMU component.
 * @exception IllegalActionException If it cannot be instantiated.
 */
@Override public void preinitialize() throws IllegalActionException {
  if (_fmiModelDescription == null) {
    throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
  }
  super.preinitialize();
  if (_debugging) {
    _debugToStdOut(""String_Node_Str"");
  }
  try {
    _nativeLibrary=_fmiModelDescription.getNativeLibrary();
  }
 catch (  IOException e1) {
    throw new IllegalActionException(this,e1,""String_Node_Str"");
  }
  if (_nativeLibrary == null) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  _checkFmiCommon();
  try {
    if (_fmiModelDescription.modelExchange) {
      try {
        if (_fmiVersion < 2.0 || !_completedIntegratorStepNotNeeded()) {
          _fmiCompletedIntegratorStepFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        }
      }
 catch (      Throwable throwable) {
        throw new IllegalActionException(this,throwable,""String_Node_Str"" + _fmuFileName + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      }
      if (_fmiVersion < 2.0) {
        try {
          _fmiFreeModelInstanceFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        }
 catch (        UnsatisfiedLinkError ex) {
          throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
        }
      }
 else {
        try {
          _fmiFreeInstanceFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        }
 catch (        UnsatisfiedLinkError ex) {
          throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
        }
      }
      _fmiGetContinuousStatesFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      _fmiSetContinuousStates=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      _fmiGetDerivativesFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      try {
        _fmiGetEventIndicatorsFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
 catch (      UnsatisfiedLinkError ex) {
        _fmiGetEventIndicatorsFunction=null;
      }
      if (_fmiVersion < 1.5) {
        _fmiInitializeFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiInstantiateModelFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
 else       if (_fmiVersion >= 1.5 && _fmiVersion < 2.0) {
        throw new IllegalActionException(this,""String_Node_Str"" + _fmiVersion);
      }
 else {
        _fmiEnterContinuousTimeModeFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiEnterEventModeFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiEnterInitializationModeFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiExitInitializationModeFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiInstantiateFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiNewDiscreteStatesFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
      _fmiSetTimeFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      _fmiTerminateFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      if (_fmiVersion >= 2.0) {
        try {
          _fmiSetupExperimentFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        }
 catch (        UnsatisfiedLinkError ex) {
          throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
        }
      }
      _checkFmiModelExchange();
    }
 else {
      try {
        _fmiDoStepFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
 catch (      Throwable throwable) {
        throw new IllegalActionException(this,throwable,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"" + modelExchange.getExpression() + ""String_Node_Str""+ _fmiModelDescription.modelExchange);
      }
      if (_fmiVersion < 2.0) {
        try {
          _fmiFreeSlaveInstanceFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        }
 catch (        UnsatisfiedLinkError ex) {
          throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
        }
      }
 else {
        _fmiEnterInitializationModeFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiExitInitializationModeFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        try {
          _fmiFreeInstanceFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        }
 catch (        UnsatisfiedLinkError ex) {
          throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
        }
      }
      if (_fmiVersion < 2.0) {
        _fmiInitializeSlaveFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiInstantiateSlaveFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
 else {
        _fmiInstantiateFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
      if (_fmiVersion < 2.0) {
        _fmiTerminateSlaveFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
 else {
        _fmiTerminateFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
      try {
        _fmiGetRealStatusFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
 catch (      UnsatisfiedLinkError ex) {
        _fmiGetRealStatusFunction=null;
      }
      if (_fmiModelDescription.canGetAndSetFMUstate) {
        _fmiFreeFMUstateFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiGetFMUstateFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiSetFMUstate=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
 else {
        _fmiFreeFMUstateFunction=null;
        _fmiGetFMUstateFunction=null;
        _fmiSetFMUstate=null;
      }
      if (_fmiVersion >= 2.0) {
        try {
          _fmiSetupExperimentFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        }
 catch (        UnsatisfiedLinkError ex) {
          throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
        }
      }
      _checkFmiCoSimulation();
    }
  }
 catch (  IOException ex) {
    throw new IllegalActionException(this,ex,""String_Node_Str"");
  }
  String modelIdentifier=_fmiModelDescription.modelIdentifier;
  String mimeType=""String_Node_Str"";
  double timeout=1000;
  byte toBeVisible=0;
  int toBeVisibleFMI2=0;
  if (((BooleanToken)visible.getToken()).booleanValue()) {
    toBeVisible=1;
    toBeVisibleFMI2=1;
  }
  byte interactive=0;
  byte loggingOn=_debugging ? (byte)1 : (byte)0;
  int loggingOnFMI2=_debugging ? (byte)1 : (byte)0;
  if (_fmiVersion < 1.5) {
    _callbacks=new FMICallbackFunctions.ByValue(new FMULibrary.FMULogger(_fmiModelDescription),new FMULibrary.FMUAllocateMemory(),new FMULibrary.FMUFreeMemory(),new FMULibrary.FMUStepFinished());
    if (_fmiModelDescription.modelExchange) {
      if (_debugging) {
        _debugToStdOut(""String_Node_Str"" + modelIdentifier + ""String_Node_Str"");
      }
      _fmiComponent=(Pointer)_fmiInstantiateModelFunction.invoke(Pointer.class,new Object[]{getFullName(),_fmiModelDescription.guid,_callbacks,loggingOn});
    }
 else {
      if (_debugging) {
        _debugToStdOut(""String_Node_Str"" + modelIdentifier + ""String_Node_Str"");
      }
      _fmiComponent=(Pointer)_fmiInstantiateSlaveFunction.invoke(Pointer.class,new Object[]{getFullName(),_fmiModelDescription.guid,_fmiModelDescription.fmuResourceLocation,mimeType,timeout,toBeVisible,interactive,_callbacks,loggingOn});
    }
  }
 else {
    _callbacks=new FMICallbackFunctions(new FMULibrary.FMULogger(_fmiModelDescription),new FMULibrary.FMUAllocateMemory(),new FMULibrary.FMUFreeMemory(),new FMULibrary.FMUStepFinished());
    if (_debugging) {
      _debugToStdOut(""String_Node_Str"" + modelIdentifier + ""String_Node_Str"");
    }
    int fmiType=1;
    if (_fmiModelDescription.modelExchange) {
      fmiType=0;
    }
    if (_fmiVersion < 2.0) {
      if (_fmiModelDescription.modelExchange) {
        throw new IllegalActionException(this,""String_Node_Str"" + _fmiVersion);
      }
 else {
        _fmiComponent=(Pointer)_fmiInstantiateSlaveFunction.invoke(Pointer.class,new Object[]{getFullName(),_fmiModelDescription.guid,_fmiModelDescription.fmuResourceLocation,_callbacks,toBeVisible,loggingOn});
      }
    }
 else     if (_fmiVersion >= 2.0) {
      _fmiComponent=(Pointer)_fmiInstantiateFunction.invoke(Pointer.class,new Object[]{getFullName(),fmiType,_fmiModelDescription.guid,_fmiModelDescription.fmuResourceLocation,_callbacks,toBeVisibleFMI2,loggingOnFMI2});
    }
  }
  if (_fmiComponent == null || _fmiComponent.equals(Pointer.NULL)) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
}"
72565,"/** 
 * Initialize this FMU wrapper. <p>According to ""System Design, Modeling, and Simulation Using Ptolemy II"", version 1.02, section 12.3.1 ""Execution Control"": ""The initialize action of the setup phase initializes parameters, resets local state, and sends out any initial messages.""</p>
 * @exception IllegalActionException If the slave FMU cannot be initialized.
 */
public void initialize() throws IllegalActionException {
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  if (_initializables != null) {
    for (    Initializable initializable : _initializables) {
      initializable.initialize();
    }
  }
  if (_debugging) {
    _debugToStdOut(String.format(""String_Node_Str"",System.identityHashCode(this)));
  }
  int fmiFlag;
  _firstRound=true;
  if (((BooleanToken)initFMUParameters.getToken()).booleanValue()) {
    _initializeFMUParameters();
  }
  _fmiInitialize();
  _checkStateEvents();
  int newDiscreteStatesNeeded=1;
  int terminateSimulation=0;
  int nominalsOfContinuousStatesChanged=0;
  int valuesOfContinuousStatesChanged=0;
  int nextEventTimeDefined=0;
  double nextEventTime=0;
  _eventInfo=new FMI20EventInfo(newDiscreteStatesNeeded,terminateSimulation,nominalsOfContinuousStatesChanged,valuesOfContinuousStatesChanged,nextEventTimeDefined,nextEventTime);
  fmiFlag=((Integer)_fmiNewDiscreteStatesFunction.invoke(Integer.class,new Object[]{_fmiComponent,_eventInfo})).intValue();
  if (fmiFlag != FMILibrary.FMIStatus.fmiOK) {
    throw new IllegalActionException(this,""String_Node_Str"" + _fmiStatusDescription(fmiFlag));
  }
  if (_eventInfo.newDiscreteStatesNeeded != 0) {
    new Exception(""String_Node_Str"").printStackTrace();
  }
  if (_eventInfo.terminateSimulation != 0) {
    getDirector().finish();
  }
  fmiFlag=((Integer)_fmiEnterContinuousTimeModeFunction.invokeInt(new Object[]{_fmiComponent})).intValue();
  if (fmiFlag != FMILibrary.FMIStatus.fmiOK) {
    throw new IllegalActionException(this,""String_Node_Str"" + _fmiStatusDescription(fmiFlag));
  }
  _createQSSSolver();
  return;
}","/** 
 * Initialize this FMU wrapper. <p>According to ""System Design, Modeling, and Simulation Using Ptolemy II"", version 1.02, section 12.3.1 ""Execution Control"": ""The initialize action of the setup phase initializes parameters, resets local state, and sends out any initial messages.""</p>
 * @exception IllegalActionException If the slave FMU cannot be initialized.
 */
public void initialize() throws IllegalActionException {
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  if (_initializables != null) {
    for (    Initializable initializable : _initializables) {
      initializable.initialize();
    }
  }
  if (_debugging) {
    _debugToStdOut(String.format(""String_Node_Str"",System.identityHashCode(this)));
  }
  int fmiFlag;
  _firstRound=true;
  if (((BooleanToken)initFMUParameters.getToken()).booleanValue()) {
    _initializeFMUParameters();
  }
  _fmiInitialize();
  _checkStateEvents();
  int newDiscreteStatesNeeded=1;
  int terminateSimulation=0;
  int nominalsOfContinuousStatesChanged=0;
  int valuesOfContinuousStatesChanged=0;
  int nextEventTimeDefined=0;
  double nextEventTime=0;
  _eventInfo=new FMI20EventInfo(newDiscreteStatesNeeded,terminateSimulation,nominalsOfContinuousStatesChanged,valuesOfContinuousStatesChanged,nextEventTimeDefined,nextEventTime);
  if (_fmiNewDiscreteStatesFunction == null) {
    throw new InternalErrorException(this,null,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + modelExchange + ""String_Node_Str""+ _fmiModelDescription.modelExchange);
  }
  fmiFlag=((Integer)_fmiNewDiscreteStatesFunction.invoke(Integer.class,new Object[]{_fmiComponent,_eventInfo})).intValue();
  if (fmiFlag != FMILibrary.FMIStatus.fmiOK) {
    throw new IllegalActionException(this,""String_Node_Str"" + _fmiStatusDescription(fmiFlag));
  }
  if (_eventInfo.newDiscreteStatesNeeded != 0) {
    new Exception(""String_Node_Str"").printStackTrace();
  }
  if (_eventInfo.terminateSimulation != 0) {
    getDirector().finish();
  }
  fmiFlag=((Integer)_fmiEnterContinuousTimeModeFunction.invokeInt(new Object[]{_fmiComponent})).intValue();
  if (fmiFlag != FMILibrary.FMIStatus.fmiOK) {
    throw new IllegalActionException(this,""String_Node_Str"" + _fmiStatusDescription(fmiFlag));
  }
  _createQSSSolver();
  return;
}"
72566,"/** 
 * Read lines from the _inputStream and output them. 
 */
@Override public void run(){
  try {
    InputStreamReader inputStreamReader=new InputStreamReader(_inputStream);
    BufferedReader bufferedReader=new BufferedReader(inputStreamReader);
    String line=null;
    while ((line=bufferedReader.readLine()) != null) {
      _fmuBuilder.stdout(line);
    }
  }
 catch (  IOException ioe) {
    _fmuBuilder.stderr(""String_Node_Str"" + ioe);
  }
}","/** 
 * Read lines from the _inputStream and output them. 
 */
@Override public void run(){
  try {
    InputStreamReader inputStreamReader=new InputStreamReader(_inputStream,Charset.defaultCharset());
    BufferedReader bufferedReader=new BufferedReader(inputStreamReader);
    String line=null;
    while ((line=bufferedReader.readLine()) != null) {
      _fmuBuilder.stdout(line);
    }
  }
 catch (  IOException ioe) {
    _fmuBuilder.stderr(""String_Node_Str"" + ioe);
  }
}"
72567,"/** 
 * Perform co-simulation using the named Functional Mock-up Unit (FMU) file.
 * @param fmuFileName The pathname of the co-simulation .fmu file
 * @param endTime The ending time in seconds.
 * @param stepSize The step size in seconds.
 * @param enableLogging True if logging is enabled.
 * @param csvSeparator The character used for separating fields.Note that sometimes the decimal point in floats is converted to ','.
 * @param outputFileName The output file.
 * @exception Exception If there is a problem parsing the .fmu file or invokingthe methods in the shared library.
 */
@Override public void simulate(String fmuFileName,double endTime,double stepSize,boolean enableLogging,char csvSeparator,String outputFileName) throws Exception {
  _setEnableLogging(enableLogging);
  FMIModelDescription fmiModelDescription=FMUFile.parseFMUFile(fmuFileName);
  _nativeLibrary=fmiModelDescription.getNativeLibrary();
  _modelIdentifier=fmiModelDescription.modelIdentifier;
  String fmuLocation=new File(fmuFileName).toURI().toURL().toString();
  String mimeType=""String_Node_Str"";
  double timeout=1000;
  byte visible=0;
  int toBeVisibleFMI2=0;
  byte interactive=0;
  byte loggingOn=enableLogging ? (byte)1 : (byte)0;
  int loggingOnFMI2=_enableLogging ? 1 : 0;
  _fmiVersion=Double.valueOf(fmiModelDescription.fmiVersion);
  Pointer fmiComponent=null;
  if (_fmiVersion < 1.5) {
    FMICallbackFunctions.ByValue callbacks=new FMICallbackFunctions.ByValue(new FMULibrary.FMULogger(fmiModelDescription),fmiModelDescription.getFMUAllocateMemory(),new FMULibrary.FMUFreeMemory(),new FMULibrary.FMUStepFinished());
    Function instantiateSlave=fmiModelDescription.getFmiFunction(""String_Node_Str"");
    fmiComponent=(Pointer)instantiateSlave.invoke(Pointer.class,new Object[]{_modelIdentifier,fmiModelDescription.guid,fmuLocation,mimeType,timeout,visible,interactive,callbacks,loggingOn});
  }
 else {
    FMI20CallbackFunctions callbacks20=new FMI20CallbackFunctions(new FMULibrary.FMULogger(fmiModelDescription),fmiModelDescription.getFMUAllocateMemory(),new FMULibrary.FMUFreeMemory(),new FMULibrary.FMUStepFinished(),fmiComponent);
    Function fmiInstantiateFunction=fmiModelDescription.getFmiFunction(""String_Node_Str"");
    int fmiType=1;
    if (fmiModelDescription.modelExchange) {
      fmiType=0;
    }
    fmiComponent=(Pointer)fmiInstantiateFunction.invoke(Pointer.class,new Object[]{_modelIdentifier,fmiType,fmiModelDescription.guid,fmiModelDescription.fmuResourceLocation,callbacks20,toBeVisibleFMI2,loggingOnFMI2});
  }
  if (fmiComponent.equals(Pointer.NULL)) {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (enableLogging) {
    System.out.println(""String_Node_Str"");
  }
  double startTime=0;
  if (enableLogging) {
    System.out.println(""String_Node_Str"");
  }
  if (_fmiVersion < 1.5) {
    invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent,startTime,(byte)1,endTime},""String_Node_Str"");
  }
 else {
    double relativeTolerance=1e-4;
    byte _toleranceControlled=(byte)0;
    invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent,_toleranceControlled,relativeTolerance,startTime,(byte)1,endTime},""String_Node_Str"");
    invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent},""String_Node_Str"");
    invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent},""String_Node_Str"");
  }
  File outputFile=new File(outputFileName);
  PrintStream file=null;
  try {
    file=new PrintStream(outputFileName);
    if (enableLogging) {
      System.out.println(""String_Node_Str"");
    }
    OutputRow.outputRow(_nativeLibrary,fmiModelDescription,fmiComponent,startTime,file,csvSeparator,Boolean.TRUE);
    OutputRow.outputRow(_nativeLibrary,fmiModelDescription,fmiComponent,startTime,file,csvSeparator,Boolean.FALSE);
    double time=startTime;
    Function doStep=fmiModelDescription.getFmiFunction(""String_Node_Str"");
    while (time < endTime) {
      if (enableLogging) {
        System.out.println(""String_Node_Str"" + _modelIdentifier + ""String_Node_Str""+ time+ ""String_Node_Str""+ stepSize+ ""String_Node_Str"");
      }
      invoke(doStep,new Object[]{fmiComponent,time,stepSize,(byte)1},""String_Node_Str"" + time + ""String_Node_Str"");
      time+=stepSize;
      OutputRow.outputRow(_nativeLibrary,fmiModelDescription,fmiComponent,time,file,csvSeparator,Boolean.FALSE);
    }
    if (_fmiVersion < 2.0) {
      invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent},""String_Node_Str"");
      Function freeSlaveInstance=fmiModelDescription.getFmiFunction(""String_Node_Str"");
      freeSlaveInstance.invoke(new Object[]{fmiComponent});
    }
 else {
      invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent},""String_Node_Str"");
      Function function=fmiModelDescription.getFmiFunction(""String_Node_Str"");
      function.invoke(new Object[]{fmiComponent});
    }
  }
  finally {
    if (file != null) {
      file.close();
    }
    if (fmiModelDescription != null) {
      fmiModelDescription.dispose();
    }
  }
  if (enableLogging) {
    System.out.println(""String_Node_Str"" + outputFile.getCanonicalPath());
    System.out.flush();
  }
}","/** 
 * Perform co-simulation using the named Functional Mock-up Unit (FMU) file.
 * @param fmuFileName The pathname of the co-simulation .fmu file
 * @param endTime The ending time in seconds.
 * @param stepSize The step size in seconds.
 * @param enableLogging True if logging is enabled.
 * @param csvSeparator The character used for separating fields.Note that sometimes the decimal point in floats is converted to ','.
 * @param outputFileName The output file.
 * @exception Exception If there is a problem parsing the .fmu file or invokingthe methods in the shared library.
 */
@Override public void simulate(String fmuFileName,double endTime,double stepSize,boolean enableLogging,char csvSeparator,String outputFileName) throws Exception {
  _setEnableLogging(enableLogging);
  FMIModelDescription fmiModelDescription=FMUFile.parseFMUFile(fmuFileName);
  _nativeLibrary=fmiModelDescription.getNativeLibrary();
  _modelIdentifier=fmiModelDescription.modelIdentifier;
  String fmuLocation=new File(fmuFileName).toURI().toURL().toString();
  String mimeType=""String_Node_Str"";
  double timeout=1000;
  byte visible=0;
  int toBeVisibleFMI2=0;
  byte interactive=0;
  byte loggingOn=enableLogging ? (byte)1 : (byte)0;
  int loggingOnFMI2=_enableLogging ? 1 : 0;
  _fmiVersion=Double.valueOf(fmiModelDescription.fmiVersion);
  Pointer fmiComponent=null;
  if (_fmiVersion < 1.5) {
    FMICallbackFunctions.ByValue callbacks=new FMICallbackFunctions.ByValue(new FMULibrary.FMULogger(fmiModelDescription),fmiModelDescription.getFMUAllocateMemory(),new FMULibrary.FMUFreeMemory(),new FMULibrary.FMUStepFinished());
    Function instantiateSlave=fmiModelDescription.getFmiFunction(""String_Node_Str"");
    fmiComponent=(Pointer)instantiateSlave.invoke(Pointer.class,new Object[]{_modelIdentifier,fmiModelDescription.guid,fmuLocation,mimeType,timeout,visible,interactive,callbacks,loggingOn});
  }
 else {
    FMI20CallbackFunctions callbacks20=new FMI20CallbackFunctions(new FMULibrary.FMULogger(fmiModelDescription),fmiModelDescription.getFMUAllocateMemory(),new FMULibrary.FMUFreeMemory(),new FMULibrary.FMUStepFinished(),fmiComponent);
    Function fmiInstantiateFunction=fmiModelDescription.getFmiFunction(""String_Node_Str"");
    int fmiType=1;
    if (fmiModelDescription.modelExchange) {
      fmiType=0;
    }
    fmiComponent=(Pointer)fmiInstantiateFunction.invoke(Pointer.class,new Object[]{_modelIdentifier,fmiType,fmiModelDescription.guid,fmiModelDescription.fmuResourceLocation,callbacks20,toBeVisibleFMI2,loggingOnFMI2});
  }
  if (fmiComponent.equals(Pointer.NULL)) {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (enableLogging) {
    System.out.println(""String_Node_Str"");
  }
  double startTime=0;
  if (enableLogging) {
    System.out.println(""String_Node_Str"");
  }
  if (_fmiVersion < 1.5) {
    invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent,startTime,(byte)1,endTime},""String_Node_Str"");
  }
 else {
    double relativeTolerance=1e-4;
    byte _toleranceControlled=(byte)0;
    invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent,_toleranceControlled,relativeTolerance,startTime,(byte)1,endTime},""String_Node_Str"");
    invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent},""String_Node_Str"");
    invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent},""String_Node_Str"");
  }
  File outputFile=new File(outputFileName);
  PrintStream file=null;
  try {
    file=new PrintStream(outputFileName,Charset.defaultCharset().toString());
    if (enableLogging) {
      System.out.println(""String_Node_Str"");
    }
    OutputRow.outputRow(_nativeLibrary,fmiModelDescription,fmiComponent,startTime,file,csvSeparator,Boolean.TRUE);
    OutputRow.outputRow(_nativeLibrary,fmiModelDescription,fmiComponent,startTime,file,csvSeparator,Boolean.FALSE);
    double time=startTime;
    Function doStep=fmiModelDescription.getFmiFunction(""String_Node_Str"");
    while (time < endTime) {
      if (enableLogging) {
        System.out.println(""String_Node_Str"" + _modelIdentifier + ""String_Node_Str""+ time+ ""String_Node_Str""+ stepSize+ ""String_Node_Str"");
      }
      invoke(doStep,new Object[]{fmiComponent,time,stepSize,(byte)1},""String_Node_Str"" + time + ""String_Node_Str"");
      time+=stepSize;
      OutputRow.outputRow(_nativeLibrary,fmiModelDescription,fmiComponent,time,file,csvSeparator,Boolean.FALSE);
    }
    if (_fmiVersion < 2.0) {
      invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent},""String_Node_Str"");
      Function freeSlaveInstance=fmiModelDescription.getFmiFunction(""String_Node_Str"");
      freeSlaveInstance.invoke(new Object[]{fmiComponent});
    }
 else {
      invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent},""String_Node_Str"");
      Function function=fmiModelDescription.getFmiFunction(""String_Node_Str"");
      function.invoke(new Object[]{fmiComponent});
    }
  }
  finally {
    if (file != null) {
      file.close();
    }
    if (fmiModelDescription != null) {
      fmiModelDescription.dispose();
    }
  }
  if (enableLogging) {
    System.out.println(""String_Node_Str"" + outputFile.getCanonicalPath());
    System.out.flush();
  }
}"
72568,"/** 
 * Perform model exchange using the named Functional Mock-up Unit (FMU) file.
 * @param fmuFileName The pathname of the co-simulation .fmu file
 * @param endTime The ending time in seconds.
 * @param stepSize The step size in seconds.
 * @param enableLogging True if logging is enabled.
 * @param csvSeparator The character used for separating fields.Note that sometimes the decimal point in floats is converted to ','.
 * @param outputFileName The output file.
 * @exception Exception If there is a problem parsing the .fmu file or invokingthe methods in the shared library.
 */
@Override public void simulate(String fmuFileName,double endTime,double stepSize,boolean enableLogging,char csvSeparator,String outputFileName) throws Exception {
  _setEnableLogging(enableLogging);
  FMIModelDescription fmiModelDescription=FMUFile.parseFMUFile(fmuFileName);
  _nativeLibrary=fmiModelDescription.getNativeLibrary();
  _modelIdentifier=fmiModelDescription.modelIdentifier;
  new File(fmuFileName).toURI().toURL().toString();
  int numberOfStateEvents=0;
  int numberOfStepEvents=0;
  int numberOfSteps=0;
  int numberOfTimeEvents=0;
  byte loggingOn=enableLogging ? (byte)1 : (byte)0;
  int loggingOnFMI2=_enableLogging ? 1 : 0;
  _fmiVersion=Double.valueOf(fmiModelDescription.fmiVersion);
  Pointer fmiComponent=null;
  if (_fmiVersion < 1.5) {
    FMICallbackFunctions.ByValue callbacks=new FMICallbackFunctions.ByValue(new FMULibrary.FMULogger(fmiModelDescription),fmiModelDescription.getFMUAllocateMemory(),new FMULibrary.FMUFreeMemory(),new FMULibrary.FMUStepFinished());
    Function instantiateModelFunction;
    try {
      instantiateModelFunction=fmiModelDescription.getFmiFunction(""String_Node_Str"");
    }
 catch (    UnsatisfiedLinkError ex) {
      UnsatisfiedLinkError error=new UnsatisfiedLinkError(""String_Node_Str"" + _modelIdentifier + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      error.initCause(ex);
      throw error;
    }
    fmiComponent=(Pointer)instantiateModelFunction.invoke(Pointer.class,new Object[]{_modelIdentifier,fmiModelDescription.guid,callbacks,loggingOn});
  }
 else {
    FMI20CallbackFunctions callbacks20=new FMI20CallbackFunctions(new FMULibrary.FMULogger(fmiModelDescription),fmiModelDescription.getFMUAllocateMemory(),new FMULibrary.FMUFreeMemory(),new FMULibrary.FMUStepFinished(),fmiComponent);
    Function fmiInstantiateFunction=fmiModelDescription.getFmiFunction(""String_Node_Str"");
    int toBeVisibleFMI2=0;
    int fmiType=1;
    if (fmiModelDescription.modelExchange) {
      fmiType=0;
    }
    fmiComponent=(Pointer)fmiInstantiateFunction.invoke(Pointer.class,new Object[]{_modelIdentifier,fmiType,fmiModelDescription.guid,fmiModelDescription.fmuResourceLocation,callbacks20,toBeVisibleFMI2,loggingOnFMI2});
  }
  if (fmiComponent.equals(Pointer.NULL)) {
    throw new RuntimeException(""String_Node_Str"");
  }
  final int numberOfStates=fmiModelDescription.numberOfContinuousStates;
  final int numberOfEventIndicators=fmiModelDescription.numberOfEventIndicators;
  double[] states=new double[numberOfStates];
  double[] derivatives=new double[numberOfStates];
  double[] eventIndicators=null;
  double[] preEventIndicators=null;
  if (numberOfEventIndicators > 0) {
    eventIndicators=new double[numberOfEventIndicators];
    preEventIndicators=new double[numberOfEventIndicators];
  }
  double startTime=0.0;
  Function setTime=fmiModelDescription.getFmiFunction(""String_Node_Str"");
  if (_fmiVersion < 2.0) {
    invoke(setTime,new Object[]{fmiComponent,startTime},""String_Node_Str"" + startTime + ""String_Node_Str"");
  }
  byte toleranceControlled=0;
  FMIEventInfo eventInfo=null;
  FMI20EventInfo eventInfo20=null;
  FMI20EventInfo.ByReference eventInfo20Reference=null;
  if (_fmiVersion < 1.5) {
    eventInfo=new FMIEventInfo();
    invoke(setTime,new Object[]{fmiComponent,startTime},""String_Node_Str"" + startTime + ""String_Node_Str"");
    invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent,toleranceControlled,startTime,eventInfo},""String_Node_Str"");
  }
 else {
    eventInfo20=new FMI20EventInfo();
    double relativeTolerance=1e-4;
    int _toleranceControlled=0;
    invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent,_toleranceControlled,relativeTolerance,startTime,1,endTime},""String_Node_Str"");
    invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent},""String_Node_Str"");
    invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent},""String_Node_Str"");
    eventInfo20Reference=new FMI20EventInfo.ByReference(eventInfo20);
    eventInfo20Reference.newDiscreteStatesNeeded=1;
    eventInfo20Reference.terminateSimulation=0;
    while (eventInfo20Reference.newDiscreteStatesNeeded == 1 && eventInfo20Reference.terminateSimulation == 0) {
      invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent,eventInfo20Reference},""String_Node_Str"");
    }
  }
  double time=startTime;
  if (eventInfo20Reference != null && eventInfo20Reference.terminateSimulation != 0) {
    System.out.println(""String_Node_Str"" + time);
    endTime=time;
  }
  if ((eventInfo20Reference != null && eventInfo20Reference.terminateSimulation != 1) || _fmiVersion < 1.5) {
    if (_fmiVersion > 1.5) {
      invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent},""String_Node_Str"");
    }
    PrintStream file=null;
    try {
      file=new PrintStream(outputFileName);
      if (enableLogging) {
        System.out.println(""String_Node_Str"");
      }
      OutputRow.outputRow(_nativeLibrary,fmiModelDescription,fmiComponent,startTime,file,csvSeparator,Boolean.TRUE);
      OutputRow.outputRow(_nativeLibrary,fmiModelDescription,fmiComponent,startTime,file,csvSeparator,Boolean.FALSE);
      Function completedIntegratorStep=fmiModelDescription.getFmiFunction(""String_Node_Str"");
      Function eventUpdate=null;
      if (_fmiVersion < 1.5) {
        eventUpdate=fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
      Function getContinuousStates=fmiModelDescription.getFmiFunction(""String_Node_Str"");
      Function getDerivatives=fmiModelDescription.getFmiFunction(""String_Node_Str"");
      Function getEventIndicators=fmiModelDescription.getFmiFunction(""String_Node_Str"");
      Function enterEventMode=null;
      if (_fmiVersion > 1.5) {
        enterEventMode=fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
      Function setContinuousStates=fmiModelDescription.getFmiFunction(""String_Node_Str"");
      boolean stateEvent=false;
      byte stepEventByte=(byte)0;
      int stepEventInt=0;
      while (time < endTime) {
        invoke(getContinuousStates,new Object[]{fmiComponent,states,numberOfStates},""String_Node_Str"" + time + ""String_Node_Str"");
        invoke(getDerivatives,new Object[]{fmiComponent,derivatives,numberOfStates},""String_Node_Str"" + time + ""String_Node_Str"");
        double stepStartTime=time;
        time=Math.min(time + stepSize,endTime);
        boolean timeEvent=false;
        if (_fmiVersion < 1.5) {
          timeEvent=eventInfo.upcomingTimeEvent == 1 && eventInfo.nextEventTime < time;
        }
 else {
          timeEvent=eventInfo20Reference.nextEventTimeDefined == 1 && eventInfo20Reference.nextEventTime < time;
        }
        if (timeEvent) {
          time=eventInfo.nextEventTime;
        }
        double dt=time - stepStartTime;
        invoke(setTime,new Object[]{fmiComponent,time},""String_Node_Str"" + time + ""String_Node_Str"");
        for (int i=0; i < numberOfStates; i++) {
          states[i]+=dt * derivatives[i];
        }
        invoke(setContinuousStates,new Object[]{fmiComponent,states,numberOfStates},""String_Node_Str"" + time + ""String_Node_Str"");
        if (enableLogging) {
          System.out.println(""String_Node_Str"" + numberOfSteps + ""String_Node_Str""+ time);
        }
        if (_fmiVersion > 1.5) {
          for (int i=0; i < numberOfEventIndicators; i++) {
            preEventIndicators[i]=eventIndicators[i];
          }
          invoke(getEventIndicators,new Object[]{fmiComponent,eventIndicators,numberOfEventIndicators},""String_Node_Str"" + time + ""String_Node_Str"");
          stateEvent=false;
          for (int i=0; i < numberOfEventIndicators; i++) {
            stateEvent=stateEvent || (preEventIndicators[i] * eventIndicators[i] < 0);
          }
        }
        if (_fmiVersion < 1.5) {
          ByteByReference stepEventByteReference=new ByteByReference(stepEventByte);
          invoke(completedIntegratorStep,new Object[]{fmiComponent,stepEventByteReference},""String_Node_Str"" + time + ""String_Node_Str"");
          for (int i=0; i < numberOfEventIndicators; i++) {
            preEventIndicators[i]=eventIndicators[i];
          }
        }
 else {
          IntByReference stepEventIntReference=new IntByReference(stepEventInt);
          int terminateSimulation=0;
          IntByReference terminateSimulationReference=new IntByReference(terminateSimulation);
          invoke(completedIntegratorStep,new Object[]{fmiComponent,1,stepEventIntReference,terminateSimulationReference},""String_Node_Str"" + time + ""String_Node_Str"");
          if (terminateSimulation != 0) {
            System.out.println(""String_Node_Str"" + time);
            break;
          }
        }
        if (_fmiVersion < 1.5) {
          invoke(getEventIndicators,new Object[]{fmiComponent,eventIndicators,numberOfEventIndicators},""String_Node_Str"" + time + ""String_Node_Str"");
          stateEvent=Boolean.FALSE;
          for (int i=0; i < numberOfEventIndicators; i++) {
            stateEvent=stateEvent || preEventIndicators[i] * eventIndicators[i] < 0;
          }
        }
        if (stateEvent || stepEventByte != (byte)0 || stepEventInt != 0 || timeEvent) {
          if (_fmiVersion > 1.5) {
            invoke(enterEventMode,new Object[]{fmiComponent},""String_Node_Str"" + time + ""String_Node_Str"");
          }
          if (stateEvent) {
            numberOfStateEvents++;
            if (enableLogging) {
              for (int i=0; i < numberOfEventIndicators; i++) {
                System.out.println(""String_Node_Str"" + (preEventIndicators[i] > 0 && eventIndicators[i] < 0 ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ i+ ""String_Node_Str""+ time);
              }
            }
          }
          if (stepEventByte != (byte)0 || stepEventInt != 0) {
            numberOfStepEvents++;
            if (enableLogging) {
              System.out.println(""String_Node_Str"" + time);
            }
          }
          if (timeEvent) {
            numberOfTimeEvents++;
            if (enableLogging) {
              System.out.println(""String_Node_Str"" + time);
            }
          }
          if (_fmiVersion < 1.5) {
            invoke(eventUpdate,new Object[]{fmiComponent,(byte)0,eventInfo},""String_Node_Str"" + time + ""String_Node_Str"");
            if (eventInfo.stateValuesChanged != (byte)0 && enableLogging) {
              System.out.println(""String_Node_Str"" + time);
            }
            if (eventInfo.stateValueReferencesChanged != (byte)0 && enableLogging) {
              System.out.println(""String_Node_Str"" + time);
            }
          }
 else {
            eventInfo20Reference.newDiscreteStatesNeeded=1;
            eventInfo20Reference.terminateSimulation=0;
            while ((eventInfo20Reference.newDiscreteStatesNeeded == 1) && eventInfo20Reference.terminateSimulation == 0) {
              invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent,eventInfo20Reference},""String_Node_Str"");
            }
            if (eventInfo20Reference.terminateSimulation != 0) {
              System.out.println(""String_Node_Str"" + time);
              break;
            }
            invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent},""String_Node_Str"");
            if ((eventInfo20Reference.valuesOfContinuousStatesChanged == 1) && enableLogging) {
              System.out.println(""String_Node_Str"" + time);
            }
            if ((eventInfo20Reference.nominalsOfContinuousStatesChanged == 1) && enableLogging) {
              System.out.println(""String_Node_Str"" + time);
            }
          }
        }
        OutputRow.outputRow(_nativeLibrary,fmiModelDescription,fmiComponent,time,file,csvSeparator,Boolean.FALSE);
        numberOfSteps++;
      }
      if (_fmiVersion < 1.5) {
        invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent},""String_Node_Str"");
        Function freeModelInstance=fmiModelDescription.getFmiFunction(""String_Node_Str"");
        freeModelInstance.invoke(new Object[]{fmiComponent});
      }
 else {
        if (!(eventInfo20.terminateSimulation == 1)) {
          invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent},""String_Node_Str"");
        }
        Function function=fmiModelDescription.getFmiFunction(""String_Node_Str"");
        function.invoke(new Object[]{fmiComponent});
      }
    }
  finally {
      if (file != null) {
        file.close();
      }
      if (fmiModelDescription != null) {
        fmiModelDescription.dispose();
      }
    }
  }
  System.out.println(""String_Node_Str"" + startTime + ""String_Node_Str""+ endTime+ ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + numberOfSteps);
  System.out.println(""String_Node_Str"" + stepSize);
  System.out.println(""String_Node_Str"" + numberOfStateEvents);
  System.out.println(""String_Node_Str"" + numberOfStepEvents);
  System.out.println(""String_Node_Str"" + numberOfTimeEvents);
  System.out.flush();
}","/** 
 * Perform model exchange using the named Functional Mock-up Unit (FMU) file.
 * @param fmuFileName The pathname of the co-simulation .fmu file
 * @param endTime The ending time in seconds.
 * @param stepSize The step size in seconds.
 * @param enableLogging True if logging is enabled.
 * @param csvSeparator The character used for separating fields.Note that sometimes the decimal point in floats is converted to ','.
 * @param outputFileName The output file.
 * @exception Exception If there is a problem parsing the .fmu file or invokingthe methods in the shared library.
 */
@Override public void simulate(String fmuFileName,double endTime,double stepSize,boolean enableLogging,char csvSeparator,String outputFileName) throws Exception {
  _setEnableLogging(enableLogging);
  FMIModelDescription fmiModelDescription=FMUFile.parseFMUFile(fmuFileName);
  _nativeLibrary=fmiModelDescription.getNativeLibrary();
  _modelIdentifier=fmiModelDescription.modelIdentifier;
  new File(fmuFileName).toURI().toURL().toString();
  int numberOfStateEvents=0;
  int numberOfStepEvents=0;
  int numberOfSteps=0;
  int numberOfTimeEvents=0;
  byte loggingOn=enableLogging ? (byte)1 : (byte)0;
  int loggingOnFMI2=_enableLogging ? 1 : 0;
  _fmiVersion=Double.valueOf(fmiModelDescription.fmiVersion);
  Pointer fmiComponent=null;
  if (_fmiVersion < 1.5) {
    FMICallbackFunctions.ByValue callbacks=new FMICallbackFunctions.ByValue(new FMULibrary.FMULogger(fmiModelDescription),fmiModelDescription.getFMUAllocateMemory(),new FMULibrary.FMUFreeMemory(),new FMULibrary.FMUStepFinished());
    Function instantiateModelFunction;
    try {
      instantiateModelFunction=fmiModelDescription.getFmiFunction(""String_Node_Str"");
    }
 catch (    UnsatisfiedLinkError ex) {
      UnsatisfiedLinkError error=new UnsatisfiedLinkError(""String_Node_Str"" + _modelIdentifier + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      error.initCause(ex);
      throw error;
    }
    fmiComponent=(Pointer)instantiateModelFunction.invoke(Pointer.class,new Object[]{_modelIdentifier,fmiModelDescription.guid,callbacks,loggingOn});
  }
 else {
    FMI20CallbackFunctions callbacks20=new FMI20CallbackFunctions(new FMULibrary.FMULogger(fmiModelDescription),fmiModelDescription.getFMUAllocateMemory(),new FMULibrary.FMUFreeMemory(),new FMULibrary.FMUStepFinished(),fmiComponent);
    Function fmiInstantiateFunction=fmiModelDescription.getFmiFunction(""String_Node_Str"");
    int toBeVisibleFMI2=0;
    int fmiType=1;
    if (fmiModelDescription.modelExchange) {
      fmiType=0;
    }
    fmiComponent=(Pointer)fmiInstantiateFunction.invoke(Pointer.class,new Object[]{_modelIdentifier,fmiType,fmiModelDescription.guid,fmiModelDescription.fmuResourceLocation,callbacks20,toBeVisibleFMI2,loggingOnFMI2});
  }
  if (fmiComponent.equals(Pointer.NULL)) {
    throw new RuntimeException(""String_Node_Str"");
  }
  final int numberOfStates=fmiModelDescription.numberOfContinuousStates;
  final int numberOfEventIndicators=fmiModelDescription.numberOfEventIndicators;
  double[] states=new double[numberOfStates];
  double[] derivatives=new double[numberOfStates];
  double[] eventIndicators=null;
  double[] preEventIndicators=null;
  if (numberOfEventIndicators > 0) {
    eventIndicators=new double[numberOfEventIndicators];
    preEventIndicators=new double[numberOfEventIndicators];
  }
  double startTime=0.0;
  Function setTime=fmiModelDescription.getFmiFunction(""String_Node_Str"");
  if (_fmiVersion < 2.0) {
    invoke(setTime,new Object[]{fmiComponent,startTime},""String_Node_Str"" + startTime + ""String_Node_Str"");
  }
  byte toleranceControlled=0;
  FMIEventInfo eventInfo=null;
  FMI20EventInfo eventInfo20=null;
  FMI20EventInfo.ByReference eventInfo20Reference=null;
  if (_fmiVersion < 1.5) {
    eventInfo=new FMIEventInfo();
    invoke(setTime,new Object[]{fmiComponent,startTime},""String_Node_Str"" + startTime + ""String_Node_Str"");
    invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent,toleranceControlled,startTime,eventInfo},""String_Node_Str"");
  }
 else {
    eventInfo20=new FMI20EventInfo();
    double relativeTolerance=1e-4;
    int _toleranceControlled=0;
    invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent,_toleranceControlled,relativeTolerance,startTime,1,endTime},""String_Node_Str"");
    invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent},""String_Node_Str"");
    invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent},""String_Node_Str"");
    eventInfo20Reference=new FMI20EventInfo.ByReference(eventInfo20);
    eventInfo20Reference.newDiscreteStatesNeeded=1;
    eventInfo20Reference.terminateSimulation=0;
    while (eventInfo20Reference.newDiscreteStatesNeeded == 1 && eventInfo20Reference.terminateSimulation == 0) {
      invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent,eventInfo20Reference},""String_Node_Str"");
    }
  }
  double time=startTime;
  if (eventInfo20Reference != null && eventInfo20Reference.terminateSimulation != 0) {
    System.out.println(""String_Node_Str"" + time);
    endTime=time;
  }
  if ((eventInfo20Reference != null && eventInfo20Reference.terminateSimulation != 1) || _fmiVersion < 1.5) {
    if (_fmiVersion > 1.5) {
      invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent},""String_Node_Str"");
    }
    PrintStream file=null;
    try {
      file=new PrintStream(outputFileName,Charset.defaultCharset().toString());
      if (enableLogging) {
        System.out.println(""String_Node_Str"");
      }
      OutputRow.outputRow(_nativeLibrary,fmiModelDescription,fmiComponent,startTime,file,csvSeparator,Boolean.TRUE);
      OutputRow.outputRow(_nativeLibrary,fmiModelDescription,fmiComponent,startTime,file,csvSeparator,Boolean.FALSE);
      Function completedIntegratorStep=fmiModelDescription.getFmiFunction(""String_Node_Str"");
      Function eventUpdate=null;
      if (_fmiVersion < 1.5) {
        eventUpdate=fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
      Function getContinuousStates=fmiModelDescription.getFmiFunction(""String_Node_Str"");
      Function getDerivatives=fmiModelDescription.getFmiFunction(""String_Node_Str"");
      Function getEventIndicators=fmiModelDescription.getFmiFunction(""String_Node_Str"");
      Function enterEventMode=null;
      if (_fmiVersion > 1.5) {
        enterEventMode=fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
      Function setContinuousStates=fmiModelDescription.getFmiFunction(""String_Node_Str"");
      boolean stateEvent=false;
      byte stepEventByte=(byte)0;
      int stepEventInt=0;
      while (time < endTime) {
        invoke(getContinuousStates,new Object[]{fmiComponent,states,numberOfStates},""String_Node_Str"" + time + ""String_Node_Str"");
        invoke(getDerivatives,new Object[]{fmiComponent,derivatives,numberOfStates},""String_Node_Str"" + time + ""String_Node_Str"");
        double stepStartTime=time;
        time=Math.min(time + stepSize,endTime);
        boolean timeEvent=false;
        if (_fmiVersion < 1.5) {
          timeEvent=eventInfo.upcomingTimeEvent == 1 && eventInfo.nextEventTime < time;
        }
 else {
          timeEvent=eventInfo20Reference.nextEventTimeDefined == 1 && eventInfo20Reference.nextEventTime < time;
        }
        if (timeEvent) {
          time=eventInfo.nextEventTime;
        }
        double dt=time - stepStartTime;
        invoke(setTime,new Object[]{fmiComponent,time},""String_Node_Str"" + time + ""String_Node_Str"");
        for (int i=0; i < numberOfStates; i++) {
          states[i]+=dt * derivatives[i];
        }
        invoke(setContinuousStates,new Object[]{fmiComponent,states,numberOfStates},""String_Node_Str"" + time + ""String_Node_Str"");
        if (enableLogging) {
          System.out.println(""String_Node_Str"" + numberOfSteps + ""String_Node_Str""+ time);
        }
        if (_fmiVersion > 1.5) {
          for (int i=0; i < numberOfEventIndicators; i++) {
            preEventIndicators[i]=eventIndicators[i];
          }
          invoke(getEventIndicators,new Object[]{fmiComponent,eventIndicators,numberOfEventIndicators},""String_Node_Str"" + time + ""String_Node_Str"");
          stateEvent=false;
          for (int i=0; i < numberOfEventIndicators; i++) {
            stateEvent=stateEvent || (preEventIndicators[i] * eventIndicators[i] < 0);
          }
        }
        if (_fmiVersion < 1.5) {
          ByteByReference stepEventByteReference=new ByteByReference(stepEventByte);
          invoke(completedIntegratorStep,new Object[]{fmiComponent,stepEventByteReference},""String_Node_Str"" + time + ""String_Node_Str"");
          for (int i=0; i < numberOfEventIndicators; i++) {
            preEventIndicators[i]=eventIndicators[i];
          }
        }
 else {
          IntByReference stepEventIntReference=new IntByReference(stepEventInt);
          int terminateSimulation=0;
          IntByReference terminateSimulationReference=new IntByReference(terminateSimulation);
          invoke(completedIntegratorStep,new Object[]{fmiComponent,1,stepEventIntReference,terminateSimulationReference},""String_Node_Str"" + time + ""String_Node_Str"");
          if (terminateSimulation != 0) {
            System.out.println(""String_Node_Str"" + time);
            break;
          }
        }
        if (_fmiVersion < 1.5) {
          invoke(getEventIndicators,new Object[]{fmiComponent,eventIndicators,numberOfEventIndicators},""String_Node_Str"" + time + ""String_Node_Str"");
          stateEvent=Boolean.FALSE;
          for (int i=0; i < numberOfEventIndicators; i++) {
            stateEvent=stateEvent || preEventIndicators[i] * eventIndicators[i] < 0;
          }
        }
        if (stateEvent || stepEventByte != (byte)0 || stepEventInt != 0 || timeEvent) {
          if (_fmiVersion > 1.5) {
            invoke(enterEventMode,new Object[]{fmiComponent},""String_Node_Str"" + time + ""String_Node_Str"");
          }
          if (stateEvent) {
            numberOfStateEvents++;
            if (enableLogging) {
              for (int i=0; i < numberOfEventIndicators; i++) {
                System.out.println(""String_Node_Str"" + (preEventIndicators[i] > 0 && eventIndicators[i] < 0 ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ i+ ""String_Node_Str""+ time);
              }
            }
          }
          if (stepEventByte != (byte)0 || stepEventInt != 0) {
            numberOfStepEvents++;
            if (enableLogging) {
              System.out.println(""String_Node_Str"" + time);
            }
          }
          if (timeEvent) {
            numberOfTimeEvents++;
            if (enableLogging) {
              System.out.println(""String_Node_Str"" + time);
            }
          }
          if (_fmiVersion < 1.5) {
            invoke(eventUpdate,new Object[]{fmiComponent,(byte)0,eventInfo},""String_Node_Str"" + time + ""String_Node_Str"");
            if (eventInfo.stateValuesChanged != (byte)0 && enableLogging) {
              System.out.println(""String_Node_Str"" + time);
            }
            if (eventInfo.stateValueReferencesChanged != (byte)0 && enableLogging) {
              System.out.println(""String_Node_Str"" + time);
            }
          }
 else {
            eventInfo20Reference.newDiscreteStatesNeeded=1;
            eventInfo20Reference.terminateSimulation=0;
            while ((eventInfo20Reference.newDiscreteStatesNeeded == 1) && eventInfo20Reference.terminateSimulation == 0) {
              invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent,eventInfo20Reference},""String_Node_Str"");
            }
            if (eventInfo20Reference.terminateSimulation != 0) {
              System.out.println(""String_Node_Str"" + time);
              break;
            }
            invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent},""String_Node_Str"");
            if ((eventInfo20Reference.valuesOfContinuousStatesChanged == 1) && enableLogging) {
              System.out.println(""String_Node_Str"" + time);
            }
            if ((eventInfo20Reference.nominalsOfContinuousStatesChanged == 1) && enableLogging) {
              System.out.println(""String_Node_Str"" + time);
            }
          }
        }
        OutputRow.outputRow(_nativeLibrary,fmiModelDescription,fmiComponent,time,file,csvSeparator,Boolean.FALSE);
        numberOfSteps++;
      }
      if (_fmiVersion < 1.5) {
        invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent},""String_Node_Str"");
        Function freeModelInstance=fmiModelDescription.getFmiFunction(""String_Node_Str"");
        freeModelInstance.invoke(new Object[]{fmiComponent});
      }
 else {
        if (!(eventInfo20.terminateSimulation == 1)) {
          invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent},""String_Node_Str"");
        }
        Function function=fmiModelDescription.getFmiFunction(""String_Node_Str"");
        function.invoke(new Object[]{fmiComponent});
      }
    }
  finally {
      if (file != null) {
        file.close();
      }
      if (fmiModelDescription != null) {
        fmiModelDescription.dispose();
      }
    }
  }
  System.out.println(""String_Node_Str"" + startTime + ""String_Node_Str""+ endTime+ ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + numberOfSteps);
  System.out.println(""String_Node_Str"" + stepSize);
  System.out.println(""String_Node_Str"" + numberOfStateEvents);
  System.out.println(""String_Node_Str"" + numberOfStepEvents);
  System.out.println(""String_Node_Str"" + numberOfTimeEvents);
  System.out.flush();
}"
72569,"/** 
 * A test driver for the indexer. <p>Usage:</p> <pre> java -classpath $PTII doc.doclets.PtIndexer [-c] [target] </pre> <p>If called with no arguments, create the dictionary PtIndexer.ser The standard input is read and assumed to be file names.  Each file is read and the dictionary is updated with words and locations.  The location is determined by substituting ""."" for ""/"" in the file name.  </p> <p>Typically, the PtDoclet creates the dictionary, but this driver can be used for testing. To create the .xml file to be read:</p> <pre> cd $PTII/doc; make docs </pre> <p>To run the tool on the .xml files and create the dictionary again:</p> <pre> cd codeDoc find . -name ""*.xml"" | java -classpath $PTII doc.doclets.PtIndexer </pre> <p>If called with <code>-c</code> then use compression.</p> <p> If called with one argument that is not <code>-c</code>, then the argument is assumed to be a target and the collection of places where target is found is returned.</p>
 * @param args The arguments, if any
 * @exception IOException If thrown while reading the input files or dictionary.
 * @exception ClassNotFoundException If the file does not contain thedictionary class.
 */
public static void main(String args[]) throws IOException, ClassNotFoundException {
  String usage=""String_Node_Str"";
  String dictionaryFile=""String_Node_Str"";
  if (args.length > 2) {
    System.err.println(usage);
    return;
  }
  String target=null;
  if (args.length >= 1) {
    if (args[0].equals(""String_Node_Str"")) {
      _useCompression=true;
      if (args.length == 2) {
        target=args[1];
      }
    }
 else {
      target=args[0];
    }
  }
  if (_useCompression) {
    dictionaryFile=""String_Node_Str"";
  }
  PtIndexer ptIndexer=new PtIndexer();
  if (target == null) {
    BufferedReader stdin=null;
    BufferedReader fileInput=null;
    int numberOfFiles=0;
    int numberOfLines=0;
    try {
      stdin=new BufferedReader(new InputStreamReader(System.in));
      String fileName=null;
      String line=null;
      while ((fileName=stdin.readLine()) != null) {
        numberOfFiles++;
        try {
          fileInput=new BufferedReader(new InputStreamReader(new FileInputStream(fileName)));
          fileName=fileName.substring(0,fileName.lastIndexOf(""String_Node_Str""));
          String className=fileName.replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"");
          while ((line=fileInput.readLine()) != null) {
            numberOfLines++;
            ptIndexer.append(className,line);
          }
        }
  finally {
          if (fileInput != null) {
            fileInput.close();
          }
        }
      }
      System.out.println(""String_Node_Str"" + numberOfFiles + ""String_Node_Str""+ numberOfLines+ ""String_Node_Str"");
    }
  finally {
      try {
        if (stdin != null) {
          stdin.close();
        }
      }
  finally {
        if (fileInput != null) {
          fileInput.close();
        }
      }
    }
    System.out.println(ptIndexer.statistics());
    ptIndexer.write(dictionaryFile);
  }
 else {
    ptIndexer.read(dictionaryFile);
    System.out.println(ptIndexer.search(target));
  }
}","/** 
 * A test driver for the indexer. <p>Usage:</p> <pre> java -classpath $PTII doc.doclets.PtIndexer [-c] [target] </pre> <p>If called with no arguments, create the dictionary PtIndexer.ser The standard input is read and assumed to be file names.  Each file is read and the dictionary is updated with words and locations.  The location is determined by substituting ""."" for ""/"" in the file name.  </p> <p>Typically, the PtDoclet creates the dictionary, but this driver can be used for testing. To create the .xml file to be read:</p> <pre> cd $PTII/doc; make docs </pre> <p>To run the tool on the .xml files and create the dictionary again:</p> <pre> cd codeDoc find . -name ""*.xml"" | java -classpath $PTII doc.doclets.PtIndexer </pre> <p>If called with <code>-c</code> then use compression.</p> <p> If called with one argument that is not <code>-c</code>, then the argument is assumed to be a target and the collection of places where target is found is returned.</p>
 * @param args The arguments, if any
 * @exception IOException If thrown while reading the input files or dictionary.
 * @exception ClassNotFoundException If the file does not contain thedictionary class.
 */
public static void main(String args[]) throws IOException, ClassNotFoundException {
  String usage=""String_Node_Str"";
  String dictionaryFile=""String_Node_Str"";
  if (args.length > 2) {
    System.err.println(usage);
    return;
  }
  String target=null;
  if (args.length >= 1) {
    if (args[0].equals(""String_Node_Str"")) {
      _useCompression=true;
      if (args.length == 2) {
        target=args[1];
      }
    }
 else {
      target=args[0];
    }
  }
  if (_useCompression) {
    dictionaryFile=""String_Node_Str"";
  }
  PtIndexer ptIndexer=new PtIndexer();
  if (target == null) {
    BufferedReader stdin=null;
    BufferedReader fileInput=null;
    int numberOfFiles=0;
    int numberOfLines=0;
    try {
      stdin=new BufferedReader(new InputStreamReader(System.in,java.nio.charset.Charset.defaultCharset()));
      String fileName=null;
      String line=null;
      while ((fileName=stdin.readLine()) != null) {
        numberOfFiles++;
        try {
          fileInput=new BufferedReader(new InputStreamReader(new FileInputStream(fileName)));
          fileName=fileName.substring(0,fileName.lastIndexOf(""String_Node_Str""));
          String className=fileName.replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"");
          while ((line=fileInput.readLine()) != null) {
            numberOfLines++;
            ptIndexer.append(className,line);
          }
        }
  finally {
          if (fileInput != null) {
            fileInput.close();
          }
        }
      }
      System.out.println(""String_Node_Str"" + numberOfFiles + ""String_Node_Str""+ numberOfLines+ ""String_Node_Str"");
    }
  finally {
      try {
        if (stdin != null) {
          stdin.close();
        }
      }
  finally {
        if (fileInput != null) {
          fileInput.close();
        }
      }
    }
    System.out.println(ptIndexer.statistics());
    ptIndexer.write(dictionaryFile);
  }
 else {
    ptIndexer.read(dictionaryFile);
    System.out.println(ptIndexer.search(target));
  }
}"
72570,"/** 
 * Write to the GCL. <p>Usage:<code> DYLD_LIBRARY_PATH=${PTII}/org/terraswarm/gdp/src/gdp/libs:/usr/local/lib LD_LIBRARY_PATH=${PTII}/org/terraswarm/gdp/src/gdp/libs:/usr/local/lib $(JAVA) -Djna.debug_load=true -Djna.dump_memory=true -classpath $(CLASSPATH) org.terraswarm.gdp.apps.ReaderTest elvis</code></p> <p>The arguments below are optional:</p> <p><code>-D <i>debuggingSpecification</i></code>, where an example of <i>debuggingSpecifiction</i> is, <code>gdp.api=100</code>.  See the gdp .c files for debugging specifications</p>. <p><code>-G <i>gdpdAddress</i></code>, which names the IP address and port name of the gdp daemon (<code>gdpd</code>) where an example of <i>gdpdAddress</i> is <code>127.0.0.1:2468</code>.  If <code>-G</code> is not present, then the default address of <code>127.0.0.1:2468</code> is used. <p><code>-a</code> FIXME: what does this do?</p> <p><code><i>gcl_name</i></code> The name of the gcl.  This string is used with ReaderTest</p>
 * @param argv The command line arguments, documented above.
 */
public static void main(String[] argv) throws Throwable {
  Native.setProtected(true);
  _debug(""String_Node_Str"" + Native.isProtected());
  Pointer gclh=null;
  ByteBuffer gcliname=ByteBuffer.allocate(32);
  EP_STAT estat;
  boolean append=false;
  String gdpd_addr=null;
  String xname=null;
  int argc=argv.length;
  for (int i=0; i < argv.length; i++) {
    if (argv[i].equals(""String_Node_Str"")) {
      append=true;
      argc--;
    }
 else     if (argv[i].equals(""String_Node_Str"")) {
      argc--;
      Gdp10Library.INSTANCE.ep_dbg_set(argv[i + 1]);
      argc--;
    }
 else     if (argv[i].equals(""String_Node_Str"")) {
      argc--;
      gdpd_addr=argv[i + 1];
      argc--;
    }
  }
  _debug(""String_Node_Str"" + argv.length + ""String_Node_Str""+ argc);
  if (argc > 0) {
    xname=argv[argv.length - 1];
    argc--;
  }
  if (argc != 0 || (append && xname == null)) {
    System.err.println(""String_Node_Str"" + ""String_Node_Str"");
    _debug(""String_Node_Str"" + argc + ""String_Node_Str""+ append+ ""String_Node_Str""+ (xname == null ? ""String_Node_Str"" : xname));
    System.exit(64);
  }
  _debug(""String_Node_Str"");
  estat=Gdp10Library.INSTANCE.gdp_init(gdpd_addr);
  if (!GdpUtilities.EP_STAT_ISOK(estat)) {
    System.err.println(""String_Node_Str"");
    _fail0(estat);
  }
  _debug(""String_Node_Str"");
  if (xname == null) {
    _debug(""String_Node_Str"");
    PointerByReference gclhByReference=new PointerByReference();
    estat=Gdp10Library.INSTANCE.gdp_gcl_create((ByteBuffer)null,gclhByReference);
    gclh=gclhByReference.getValue();
    _debug(""String_Node_Str"" + estat);
    _debug(""String_Node_Str"" + gclh);
  }
 else {
    _debug(""String_Node_Str"" + xname);
    Gdp10Library.INSTANCE.gdp_gcl_parse_name(xname,gcliname);
    if (append) {
      _debug(""String_Node_Str"");
      PointerByReference gclhByReference=new PointerByReference();
      estat=Gdp10Library.INSTANCE.gdp_gcl_open(gcliname,Gdp10Library.gdp_iomode_t.GDP_MODE_AO,gclhByReference);
      gclh=gclhByReference.getValue();
    }
 else {
      _debug(""String_Node_Str"");
      PointerByReference gclhByReference=new PointerByReference();
      estat=Gdp10Library.INSTANCE.gdp_gcl_create(gcliname,gclhByReference);
      gclh=gclhByReference.getValue();
    }
  }
  _debug(""String_Node_Str"");
  if (!GdpUtilities.EP_STAT_ISOK(estat)) {
    _fail0(estat);
  }
  _debug(""String_Node_Str"" + System.identityHashCode(gclh) + ""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  _debug(""String_Node_Str"");
  PointerByReference datum=Gdp10Library.INSTANCE.gdp_datum_new();
  _debug(""String_Node_Str"");
  _debug(""String_Node_Str"" + datum);
  BufferedReader bufferedReader=null;
  try {
    bufferedReader=new BufferedReader(new InputStreamReader(System.in));
    String line;
    final int bufferLength=200;
    while ((line=bufferedReader.readLine()) != null) {
      System.out.println(""String_Node_Str"" + line + ""String_Node_Str"");
      if (line.length() > bufferLength) {
        throw new Exception(""String_Node_Str"" + line + ""String_Node_Str""+ bufferLength);
      }
      Memory memory=new Memory(bufferLength);
      Memory alignedMemory=memory.align(4);
      memory.clear();
      Pointer pointer=alignedMemory.share(0);
      pointer.setString(0,line);
      _debug(""String_Node_Str"");
      PointerByReference dbuf=Gdp10Library.INSTANCE.gdp_datum_getbuf(datum);
      _debug(""String_Node_Str"" + pointer + ""String_Node_Str""+ pointer.getString(0));
      Gdp10Library.INSTANCE.gdp_buf_write(dbuf,pointer,new NativeSizeT(line.length()));
      _debug(""String_Node_Str"");
      _debug(""String_Node_Str"" + gclh);
      _debug(""String_Node_Str"" + datum);
      GdpUtilities.gdp_datum_print(datum);
      estat=Gdp10Library.INSTANCE.gdp_gcl_publish(gclh,datum);
      if (!GdpUtilities.EP_STAT_ISOK(estat)) {
        PointerByReference gclhByReference=new PointerByReference();
        _fail1(estat,gclhByReference);
        gclh=gclhByReference.getValue();
      }
      _debug(""String_Node_Str"");
      GdpUtilities.gdp_datum_print(datum);
    }
  }
  finally {
    if (bufferedReader != null) {
      bufferedReader.close();
    }
  }
  Gdp10Library.INSTANCE.gdp_datum_free(datum);
  _fail0(estat);
}","/** 
 * Write to the GCL. <p>Usage:<code> DYLD_LIBRARY_PATH=${PTII}/org/terraswarm/gdp/src/gdp/libs:/usr/local/lib LD_LIBRARY_PATH=${PTII}/org/terraswarm/gdp/src/gdp/libs:/usr/local/lib $(JAVA) -Djna.debug_load=true -Djna.dump_memory=true -classpath $(CLASSPATH) org.terraswarm.gdp.apps.ReaderTest elvis</code></p> <p>The arguments below are optional:</p> <p><code>-D <i>debuggingSpecification</i></code>, where an example of <i>debuggingSpecifiction</i> is, <code>gdp.api=100</code>.  See the gdp .c files for debugging specifications</p>. <p><code>-G <i>gdpdAddress</i></code>, which names the IP address and port name of the gdp daemon (<code>gdpd</code>) where an example of <i>gdpdAddress</i> is <code>127.0.0.1:2468</code>.  If <code>-G</code> is not present, then the default address of <code>127.0.0.1:2468</code> is used. <p><code>-a</code> FIXME: what does this do?</p> <p><code><i>gcl_name</i></code> The name of the gcl.  This string is used with ReaderTest</p>
 * @param argv The command line arguments, documented above.
 */
public static void main(String[] argv) throws Throwable {
  Native.setProtected(true);
  _debug(""String_Node_Str"" + Native.isProtected());
  Pointer gclh=null;
  ByteBuffer gcliname=ByteBuffer.allocate(32);
  EP_STAT estat;
  boolean append=false;
  String gdpd_addr=null;
  String xname=null;
  int argc=argv.length;
  for (int i=0; i < argv.length; i++) {
    if (argv[i].equals(""String_Node_Str"")) {
      append=true;
      argc--;
    }
 else     if (argv[i].equals(""String_Node_Str"")) {
      argc--;
      Gdp10Library.INSTANCE.ep_dbg_set(argv[i + 1]);
      argc--;
    }
 else     if (argv[i].equals(""String_Node_Str"")) {
      argc--;
      gdpd_addr=argv[i + 1];
      argc--;
    }
  }
  _debug(""String_Node_Str"" + argv.length + ""String_Node_Str""+ argc);
  if (argc > 0) {
    xname=argv[argv.length - 1];
    argc--;
  }
  if (argc != 0 || (append && xname == null)) {
    System.err.println(""String_Node_Str"" + ""String_Node_Str"");
    _debug(""String_Node_Str"" + argc + ""String_Node_Str""+ append+ ""String_Node_Str""+ (xname == null ? ""String_Node_Str"" : xname));
    System.exit(64);
  }
  _debug(""String_Node_Str"");
  estat=Gdp10Library.INSTANCE.gdp_init(gdpd_addr);
  if (!GdpUtilities.EP_STAT_ISOK(estat)) {
    System.err.println(""String_Node_Str"");
    _fail0(estat);
  }
  _debug(""String_Node_Str"");
  if (xname == null) {
    _debug(""String_Node_Str"");
    PointerByReference gclhByReference=new PointerByReference();
    estat=Gdp10Library.INSTANCE.gdp_gcl_create((ByteBuffer)null,gclhByReference);
    gclh=gclhByReference.getValue();
    _debug(""String_Node_Str"" + estat);
    _debug(""String_Node_Str"" + gclh);
  }
 else {
    _debug(""String_Node_Str"" + xname);
    Gdp10Library.INSTANCE.gdp_gcl_parse_name(xname,gcliname);
    if (append) {
      _debug(""String_Node_Str"");
      PointerByReference gclhByReference=new PointerByReference();
      estat=Gdp10Library.INSTANCE.gdp_gcl_open(gcliname,Gdp10Library.gdp_iomode_t.GDP_MODE_AO,gclhByReference);
      gclh=gclhByReference.getValue();
    }
 else {
      _debug(""String_Node_Str"");
      PointerByReference gclhByReference=new PointerByReference();
      estat=Gdp10Library.INSTANCE.gdp_gcl_create(gcliname,gclhByReference);
      gclh=gclhByReference.getValue();
    }
  }
  _debug(""String_Node_Str"");
  if (!GdpUtilities.EP_STAT_ISOK(estat)) {
    _fail0(estat);
  }
  _debug(""String_Node_Str"" + System.identityHashCode(gclh) + ""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  _debug(""String_Node_Str"");
  PointerByReference datum=Gdp10Library.INSTANCE.gdp_datum_new();
  _debug(""String_Node_Str"");
  _debug(""String_Node_Str"" + datum);
  BufferedReader bufferedReader=null;
  try {
    bufferedReader=new BufferedReader(new InputStreamReader(System.in,java.nio.charset.Charset.defaultCharset()));
    String line;
    final int bufferLength=200;
    while ((line=bufferedReader.readLine()) != null) {
      System.out.println(""String_Node_Str"" + line + ""String_Node_Str"");
      if (line.length() > bufferLength) {
        throw new Exception(""String_Node_Str"" + line + ""String_Node_Str""+ bufferLength);
      }
      Memory memory=new Memory(bufferLength);
      Memory alignedMemory=memory.align(4);
      memory.clear();
      Pointer pointer=alignedMemory.share(0);
      pointer.setString(0,line);
      _debug(""String_Node_Str"");
      PointerByReference dbuf=Gdp10Library.INSTANCE.gdp_datum_getbuf(datum);
      _debug(""String_Node_Str"" + pointer + ""String_Node_Str""+ pointer.getString(0));
      Gdp10Library.INSTANCE.gdp_buf_write(dbuf,pointer,new NativeSizeT(line.length()));
      _debug(""String_Node_Str"");
      _debug(""String_Node_Str"" + gclh);
      _debug(""String_Node_Str"" + datum);
      GdpUtilities.gdp_datum_print(datum);
      estat=Gdp10Library.INSTANCE.gdp_gcl_publish(gclh,datum);
      if (!GdpUtilities.EP_STAT_ISOK(estat)) {
        PointerByReference gclhByReference=new PointerByReference();
        _fail1(estat,gclhByReference);
        gclh=gclhByReference.getValue();
      }
      _debug(""String_Node_Str"");
      GdpUtilities.gdp_datum_print(datum);
    }
  }
  finally {
    if (bufferedReader != null) {
      bufferedReader.close();
    }
  }
  Gdp10Library.INSTANCE.gdp_datum_free(datum);
  _fail0(estat);
}"
72571,"/** 
 * Read the content of a given file and return it to the caller as a string.
 * @param file The file that we need to read its content.
 * @return A string representation of the content of the model.
 * @exception IOException Thrown if there is an error reading the content ofthe file.
 */
private String _getContent(File file) throws IOException {
  StringBuilder contents=new StringBuilder();
  BufferedReader input=new BufferedReader(new FileReader(file));
  try {
    String line=null;
    while ((line=input.readLine()) != null) {
      contents.append(line);
      contents.append(System.getProperty(""String_Node_Str""));
    }
  }
  finally {
    input.close();
  }
  return contents.toString();
}","/** 
 * Read the content of a given file and return it to the caller as a string.
 * @param file The file that we need to read its content.
 * @return A string representation of the content of the model.
 * @exception IOException Thrown if there is an error reading the content ofthe file.
 */
private String _getContent(File file) throws IOException {
  StringBuilder contents=new StringBuilder();
  BufferedReader input=new BufferedReader(new java.io.InputStreamReader(new java.io.FileInputStream(file),java.nio.charset.Charset.defaultCharset()));
  try {
    String line=null;
    while ((line=input.readLine()) != null) {
      contents.append(line);
      contents.append(System.getProperty(""String_Node_Str""));
    }
  }
  finally {
    input.close();
  }
  return contents.toString();
}"
72572,"/** 
 * Test the migrateModels() method in the case when the given path is correct and it contains models at the first level and models inside a directory which is inside the current directory but we want to only migrate those in the first level.
 * @exception Exception Thrown by PowerMock if error occurs in the testing.
 */
@Test public void testMigrateModelsNoDepth_checkContent() throws Exception {
  String directoryPath=createDirectory(2,2);
  MigrateModelsManager migrateModelsManager=new MigrateModelsManager();
  try {
    String csvFilePath=migrateModelsManager.migrateModels(directoryPath,false,true);
    assertTrue(csvFilePath.equals(directoryPath + System.getProperty(""String_Node_Str"") + ""String_Node_Str""));
    File csvFile=new File(csvFilePath);
    BufferedReader input=new BufferedReader(new FileReader(csvFile));
    try {
      int count=0;
      String line=""String_Node_Str"";
      while (input.readLine() != null) {
        if (line.length() > 10) {
          count++;
        }
      }
      assertTrue(count == 3);
    }
  finally {
      input.close();
    }
    PowerMock.verifyAll();
  }
 catch (  IOException e) {
    fail(""String_Node_Str"" + e.getMessage());
  }
 finally {
    _cleanup(directoryPath);
  }
}","/** 
 * Test the migrateModels() method in the case when the given path is correct and it contains models at the first level and models inside a directory which is inside the current directory but we want to only migrate those in the first level.
 * @exception Exception Thrown by PowerMock if error occurs in the testing.
 */
@Test public void testMigrateModelsNoDepth_checkContent() throws Exception {
  String directoryPath=createDirectory(2,2);
  MigrateModelsManager migrateModelsManager=new MigrateModelsManager();
  try {
    String csvFilePath=migrateModelsManager.migrateModels(directoryPath,false,true);
    assertTrue(csvFilePath.equals(directoryPath + System.getProperty(""String_Node_Str"") + ""String_Node_Str""));
    File csvFile=new File(csvFilePath);
    BufferedReader input=new BufferedReader(new java.io.InputStreamReader(new java.io.FileInputStream(csvFile),java.nio.charset.Charset.defaultCharset()));
    try {
      int count=0;
      String line=""String_Node_Str"";
      while (input.readLine() != null) {
        if (line.length() > 10) {
          count++;
        }
      }
      assertTrue(count == 3);
    }
  finally {
      input.close();
    }
    PowerMock.verifyAll();
  }
 catch (  IOException e) {
    fail(""String_Node_Str"" + e.getMessage());
  }
 finally {
    _cleanup(directoryPath);
  }
}"
72573,"/** 
 * Test the migrateModels() method in the case when the given path is correct and it contains models at the first level and models inside a directory which is inside the current directory but we want to only migrate those in the first level.
 * @exception Exception Thrown by PowerMock if error occurs in the testing.
 */
@Test public void testMigrateModelsNoDepth_NoCheckContent() throws Exception {
  String directoryPath=createDirectory(2,2);
  MigrateModelsManager migrateModelsManager=new MigrateModelsManager();
  try {
    String csvFilePath=migrateModelsManager.migrateModels(directoryPath,false,false);
    assertTrue(csvFilePath.equals(directoryPath + System.getProperty(""String_Node_Str"") + ""String_Node_Str""));
    File csvFile=new File(csvFilePath);
    BufferedReader input=new BufferedReader(new FileReader(csvFile));
    try {
      int count=0;
      String line=""String_Node_Str"";
      while (input.readLine() != null) {
        if (line.length() > 10) {
          count++;
        }
      }
      assertTrue(count == 3);
    }
  finally {
      input.close();
    }
    PowerMock.verifyAll();
  }
 catch (  IOException e) {
    fail(""String_Node_Str"" + e.getMessage());
  }
 finally {
    _cleanup(directoryPath);
  }
}","/** 
 * Test the migrateModels() method in the case when the given path is correct and it contains models at the first level and models inside a directory which is inside the current directory but we want to only migrate those in the first level.
 * @exception Exception Thrown by PowerMock if error occurs in the testing.
 */
@Test public void testMigrateModelsNoDepth_NoCheckContent() throws Exception {
  String directoryPath=createDirectory(2,2);
  MigrateModelsManager migrateModelsManager=new MigrateModelsManager();
  try {
    String csvFilePath=migrateModelsManager.migrateModels(directoryPath,false,false);
    assertTrue(csvFilePath.equals(directoryPath + System.getProperty(""String_Node_Str"") + ""String_Node_Str""));
    File csvFile=new File(csvFilePath);
    BufferedReader input=new BufferedReader(new java.io.InputStreamReader(new java.io.FileInputStream(csvFile),java.nio.charset.Charset.defaultCharset()));
    try {
      int count=0;
      String line=""String_Node_Str"";
      while (input.readLine() != null) {
        if (line.length() > 10) {
          count++;
        }
      }
      assertTrue(count == 3);
    }
  finally {
      input.close();
    }
    PowerMock.verifyAll();
  }
 catch (  IOException e) {
    fail(""String_Node_Str"" + e.getMessage());
  }
 finally {
    _cleanup(directoryPath);
  }
}"
72574,"/** 
 * Test the migrateModels() method in the case when the given path is correct and it contains models at the first level and models inside a directory which is inside the current directory but we want to only migrate those in the first level.
 * @exception Exception Thrown by PowerMock if error occurs in the testing.
 */
@Test public void testMigrateModelsNoDepth() throws Exception {
  String directoryPath=createDirectory(2,2);
  MigrateModelsManager migrateModelsManager=new MigrateModelsManager();
  try {
    String csvFilePath=migrateModelsManager.migrateModels(directoryPath,false,true);
    assertTrue(csvFilePath.equals(directoryPath + System.getProperty(""String_Node_Str"") + ""String_Node_Str""));
    File csvFile=new File(csvFilePath);
    BufferedReader input=new BufferedReader(new FileReader(csvFile));
    try {
      int count=0;
      String line=""String_Node_Str"";
      while ((line=input.readLine()) != null) {
        if (line.length() > 10) {
          count++;
        }
      }
      assertTrue(count == 3);
    }
  finally {
      input.close();
    }
    PowerMock.verifyAll();
  }
 catch (  IOException e) {
    fail(""String_Node_Str"" + e.getMessage());
  }
 finally {
    _cleanup(directoryPath);
  }
}","/** 
 * Test the migrateModels() method in the case when the given path is correct and it contains models at the first level and models inside a directory which is inside the current directory but we want to only migrate those in the first level.
 * @exception Exception Thrown by PowerMock if error occurs in the testing.
 */
@Test public void testMigrateModelsNoDepth() throws Exception {
  String directoryPath=createDirectory(2,2);
  MigrateModelsManager migrateModelsManager=new MigrateModelsManager();
  try {
    String csvFilePath=migrateModelsManager.migrateModels(directoryPath,false,true);
    assertTrue(csvFilePath.equals(directoryPath + System.getProperty(""String_Node_Str"") + ""String_Node_Str""));
    File csvFile=new File(csvFilePath);
    BufferedReader input=new BufferedReader(new java.io.InputStreamReader(new java.io.FileInputStream(csvFile),java.nio.charset.Charset.defaultCharset()));
    try {
      int count=0;
      String line=""String_Node_Str"";
      while ((line=input.readLine()) != null) {
        if (line.length() > 10) {
          count++;
        }
      }
      assertTrue(count == 3);
    }
  finally {
      input.close();
    }
    PowerMock.verifyAll();
  }
 catch (  IOException e) {
    fail(""String_Node_Str"" + e.getMessage());
  }
 finally {
    _cleanup(directoryPath);
  }
}"
72575,"/** 
 * Save the search criteria to a file in the XML format.
 * @param searchCriteria The DTO containing the search criteria to besaved.
 * @param searchCriteriaFile The file path and name where the criteriashould be saved.
 * @return true - if the search criteria is saved successful.<br>False - if the search criteria is not saved successful.
 * @exception IllegalActionException Thrown if the passed attributes'values cannot be obtained.
 * @exception IOException Thrown if error happens during writing thesearch criteria information to the file.
 */
public static boolean save(SearchCriteria searchCriteria,String searchCriteriaFile) throws IllegalActionException, IOException {
  StringBuffer searchCriteriaStringBuffer=new StringBuffer();
  searchCriteriaStringBuffer.append(""String_Node_Str"");
  if (searchCriteria.getPatternMoML() != null) {
    String patternMoMl=searchCriteria.getPatternMoML();
    searchCriteriaStringBuffer.append(""String_Node_Str"");
    searchCriteriaStringBuffer.append(patternMoMl);
    searchCriteriaStringBuffer.append(""String_Node_Str"");
  }
  ArrayList<Attribute> attributesList=searchCriteria.getAttributes();
  if (attributesList != null && attributesList.size() > 0) {
    searchCriteriaStringBuffer.append(""String_Node_Str"");
    for (    Attribute attribute : attributesList) {
      searchCriteriaStringBuffer.append(""String_Node_Str"" + attribute.getName() + ""String_Node_Str""+ ((StringParameter)attribute).getToken().toString()+ ""String_Node_Str"");
    }
    searchCriteriaStringBuffer.append(""String_Node_Str"");
  }
  if (searchCriteria.getModelName() != null && !searchCriteria.getModelName().trim().isEmpty()) {
    searchCriteriaStringBuffer.append(""String_Node_Str"" + searchCriteria.getModelName() + ""String_Node_Str"");
  }
  searchCriteriaStringBuffer.append(""String_Node_Str"");
  File file=new File(searchCriteriaFile);
  FileOutputStream fileOutputStream=new FileOutputStream(file);
  BufferedWriter bufferedWriter=new BufferedWriter(new OutputStreamWriter(fileOutputStream));
  try {
    if (!file.exists()) {
      if (!file.createNewFile()) {
        throw new IOException(""String_Node_Str"");
      }
    }
    bufferedWriter.write(searchCriteriaStringBuffer.toString());
    bufferedWriter.flush();
  }
  finally {
    bufferedWriter.close();
  }
  return true;
}","/** 
 * Save the search criteria to a file in the XML format.
 * @param searchCriteria The DTO containing the search criteria to besaved.
 * @param searchCriteriaFile The file path and name where the criteriashould be saved.
 * @return true - if the search criteria is saved successful.<br>False - if the search criteria is not saved successful.
 * @exception IllegalActionException Thrown if the passed attributes'values cannot be obtained.
 * @exception IOException Thrown if error happens during writing thesearch criteria information to the file.
 */
public static boolean save(SearchCriteria searchCriteria,String searchCriteriaFile) throws IllegalActionException, IOException {
  StringBuffer searchCriteriaStringBuffer=new StringBuffer();
  searchCriteriaStringBuffer.append(""String_Node_Str"");
  if (searchCriteria.getPatternMoML() != null) {
    String patternMoMl=searchCriteria.getPatternMoML();
    searchCriteriaStringBuffer.append(""String_Node_Str"");
    searchCriteriaStringBuffer.append(patternMoMl);
    searchCriteriaStringBuffer.append(""String_Node_Str"");
  }
  ArrayList<Attribute> attributesList=searchCriteria.getAttributes();
  if (attributesList != null && attributesList.size() > 0) {
    searchCriteriaStringBuffer.append(""String_Node_Str"");
    for (    Attribute attribute : attributesList) {
      searchCriteriaStringBuffer.append(""String_Node_Str"" + attribute.getName() + ""String_Node_Str""+ ((StringParameter)attribute).getToken().toString()+ ""String_Node_Str"");
    }
    searchCriteriaStringBuffer.append(""String_Node_Str"");
  }
  if (searchCriteria.getModelName() != null && !searchCriteria.getModelName().trim().isEmpty()) {
    searchCriteriaStringBuffer.append(""String_Node_Str"" + searchCriteria.getModelName() + ""String_Node_Str"");
  }
  searchCriteriaStringBuffer.append(""String_Node_Str"");
  File file=new File(searchCriteriaFile);
  FileOutputStream fileOutputStream=new FileOutputStream(file);
  BufferedWriter bufferedWriter=new BufferedWriter(new OutputStreamWriter(fileOutputStream,java.nio.charset.Charset.defaultCharset()));
  try {
    if (!file.exists()) {
      if (!file.createNewFile()) {
        throw new IOException(""String_Node_Str"");
      }
    }
    bufferedWriter.write(searchCriteriaStringBuffer.toString());
    bufferedWriter.flush();
  }
  finally {
    bufferedWriter.close();
  }
  return true;
}"
72576,"/** 
 * Read the user input to decide whether the rebuild references process should be started or not.
 * @return The user input.
 * @exception IOException If thrown while reading input from the console.
 */
private static String _readInput() throws IOException {
  BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
  String userInput=null;
  try {
    userInput=br.readLine();
  }
  finally {
    br.close();
  }
  return userInput;
}","/** 
 * Read the user input to decide whether the rebuild references process should be started or not.
 * @return The user input.
 * @exception IOException If thrown while reading input from the console.
 */
private static String _readInput() throws IOException {
  BufferedReader br=new BufferedReader(new InputStreamReader(System.in,java.nio.charset.Charset.defaultCharset()));
  String userInput=null;
  try {
    userInput=br.readLine();
  }
  finally {
    br.close();
  }
  return userInput;
}"
72577,"/** 
 * Check the URL input for a DTD.  Only the first 5 lines are read from the URL.  Any text that matches <code>&lt;?xml.*?&gt;</code> is removed before checking.
 * @param input The DTD to check.
 * @param dtdStart The start of the DTD, typically ""&lt;!DOCTYPE"".
 * @param dtdEndRegExp The optional ending regular expression.  Ifthis parameter is null, then it is ignored.
 * @return True if the input starts with dtdStart and, if dtdEndRegExpis non-null, ends with dtdEndRegExp.
 * @exception IOException if there is a problem opening or readingthe input.
 */
public static boolean checkForDTD(URL input,String dtdStart,String dtdEndRegExp) throws IOException {
  InputStream stream=null;
  try {
    stream=input.openStream();
  }
 catch (  AccessControlException ex) {
    AccessControlException exception=new AccessControlException(""String_Node_Str"" + input + ""String_Node_Str"");
    exception.initCause(ex);
    throw exception;
  }
catch (  IOException ex) {
    URL anotherURL=ClassUtilities.jarURLEntryResource(input.toExternalForm());
    if (anotherURL == null) {
      throw ex;
    }
    stream=anotherURL.openStream();
  }
  boolean foundDTD=false;
  BufferedReader reader=null;
  try {
    reader=new BufferedReader(new InputStreamReader(stream));
    int lineCount=0;
    while (lineCount < 5) {
      String contents=reader.readLine();
      lineCount++;
      if (contents == null) {
        break;
      }
      contents=contents.replaceFirst(""String_Node_Str"",""String_Node_Str"");
      if (dtdEndRegExp != null) {
        if (contents.startsWith(dtdStart) && contents.matches(dtdEndRegExp)) {
          foundDTD=true;
          break;
        }
 else {
          if (contents.startsWith(dtdStart)) {
            contents+=reader.readLine();
            if (contents.matches(dtdEndRegExp)) {
              foundDTD=true;
              break;
            }
          }
        }
      }
 else       if (contents.startsWith(dtdStart)) {
        foundDTD=true;
        break;
      }
    }
  }
  finally {
    if (reader != null) {
      reader.close();
    }
  }
  return foundDTD;
}","/** 
 * Check the URL input for a DTD.  Only the first 5 lines are read from the URL.  Any text that matches <code>&lt;?xml.*?&gt;</code> is removed before checking.
 * @param input The DTD to check.
 * @param dtdStart The start of the DTD, typically ""&lt;!DOCTYPE"".
 * @param dtdEndRegExp The optional ending regular expression.  Ifthis parameter is null, then it is ignored.
 * @return True if the input starts with dtdStart and, if dtdEndRegExpis non-null, ends with dtdEndRegExp.
 * @exception IOException if there is a problem opening or readingthe input.
 */
public static boolean checkForDTD(URL input,String dtdStart,String dtdEndRegExp) throws IOException {
  InputStream stream=null;
  try {
    stream=input.openStream();
  }
 catch (  AccessControlException ex) {
    AccessControlException exception=new AccessControlException(""String_Node_Str"" + input + ""String_Node_Str"");
    exception.initCause(ex);
    throw exception;
  }
catch (  IOException ex) {
    URL anotherURL=ClassUtilities.jarURLEntryResource(input.toExternalForm());
    if (anotherURL == null) {
      throw ex;
    }
    stream=anotherURL.openStream();
  }
  boolean foundDTD=false;
  BufferedReader reader=null;
  try {
    reader=new BufferedReader(new InputStreamReader(stream,java.nio.charset.Charset.defaultCharset()));
    int lineCount=0;
    while (lineCount < 5) {
      String contents=reader.readLine();
      lineCount++;
      if (contents == null) {
        break;
      }
      contents=contents.replaceFirst(""String_Node_Str"",""String_Node_Str"");
      if (dtdEndRegExp != null) {
        if (contents.startsWith(dtdStart) && contents.matches(dtdEndRegExp)) {
          foundDTD=true;
          break;
        }
 else {
          if (contents.startsWith(dtdStart)) {
            contents+=reader.readLine();
            if (contents.matches(dtdEndRegExp)) {
              foundDTD=true;
              break;
            }
          }
        }
      }
 else       if (contents.startsWith(dtdStart)) {
        foundDTD=true;
        break;
      }
    }
  }
  finally {
    if (reader != null) {
      reader.close();
    }
  }
  return foundDTD;
}"
72578,"/** 
 * Create a _StreamReaderThread.
 * @param inputStream The stream to read from.
 * @param name The name of this StreamReaderThread,which is useful for debugging.
 * @param actor The parent actor of this thread, whichis used in error messages.
 */
_StreamReaderThread(InputStream inputStream,String name,Nameable actor){
  super(name);
  _inputStream=inputStream;
  _inputStreamReader=new InputStreamReader(_inputStream);
  _actor=actor;
  _stringBuffer=new StringBuffer();
}","/** 
 * Create a _StreamReaderThread.
 * @param inputStream The stream to read from.
 * @param name The name of this StreamReaderThread,which is useful for debugging.
 * @param actor The parent actor of this thread, whichis used in error messages.
 */
_StreamReaderThread(InputStream inputStream,String name,Nameable actor){
  super(name);
  _inputStream=inputStream;
  _inputStreamReader=new InputStreamReader(_inputStream,java.nio.charset.Charset.defaultCharset());
  _actor=actor;
  _stringBuffer=new StringBuffer();
}"
72579,"/** 
 * Construct an actor with the given container and name.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public Reader(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  output.setMultiport(true);
  output.setTypeEquals(BaseType.DOUBLE);
  sourceURL=new Parameter(this,""String_Node_Str"",new StringToken(""String_Node_Str""));
  sourceURL.setTypeEquals(BaseType.STRING);
  refresh=new Parameter(this,""String_Node_Str"",new BooleanToken(false));
  refresh.setTypeEquals(BaseType.BOOLEAN);
  if (_stdIn == null) {
    _stdIn=new BufferedReader(new InputStreamReader(System.in));
  }
  setReader(_stdIn);
}","/** 
 * Construct an actor with the given container and name.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public Reader(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  output.setMultiport(true);
  output.setTypeEquals(BaseType.DOUBLE);
  sourceURL=new Parameter(this,""String_Node_Str"",new StringToken(""String_Node_Str""));
  sourceURL.setTypeEquals(BaseType.STRING);
  refresh=new Parameter(this,""String_Node_Str"",new BooleanToken(false));
  refresh.setTypeEquals(BaseType.BOOLEAN);
  if (_stdIn == null) {
    _stdIn=new BufferedReader(new InputStreamReader(System.in,java.nio.charset.Charset.defaultCharset()));
  }
  setReader(_stdIn);
}"
72580,"/** 
 * Construct an actor with the given container and name.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public URLReader(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  output.setMultiport(true);
  output.setTypeEquals(BaseType.DOUBLE);
  sourceURL=new Parameter(this,""String_Node_Str"",new StringToken(""String_Node_Str""));
  sourceURL.setTypeEquals(BaseType.STRING);
  refresh=new Parameter(this,""String_Node_Str"",new BooleanToken(false));
  refresh.setTypeEquals(BaseType.BOOLEAN);
  if (_stdIn == null) {
    _stdIn=new BufferedReader(new InputStreamReader(System.in));
  }
  _setURLReader(_stdIn);
}","/** 
 * Construct an actor with the given container and name.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public URLReader(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  output.setMultiport(true);
  output.setTypeEquals(BaseType.DOUBLE);
  sourceURL=new Parameter(this,""String_Node_Str"",new StringToken(""String_Node_Str""));
  sourceURL.setTypeEquals(BaseType.STRING);
  refresh=new Parameter(this,""String_Node_Str"",new BooleanToken(false));
  refresh.setTypeEquals(BaseType.BOOLEAN);
  if (_stdIn == null) {
    _stdIn=new BufferedReader(new InputStreamReader(System.in,java.nio.charset.Charset.defaultCharset()));
  }
  _setURLReader(_stdIn);
}"
72581,"/** 
 * Check the csv file against equations. The equations come from sparse_fmi by James Nutaro. Some variance is acceptable, though the test fails if there is too much.
 * @param testName The name of the test, ex. ""Linsys"".
 * @param csvFile The comma separated file to be checked, typically generatedby the  {@link #modelExchange(String)} method.
 * @param checkX2 True if the 3rd argument is x2 and should be checked.
 * @exception Exception If there is a problem parsing the file.
 */
public void modelExchangeCheck(String testName,String csvFile,boolean checkX2) throws Exception {
  double x1MaximumError=0.0;
  double x2MaximumError=0.0;
  double epsilon=0.003;
  int row=0;
  String line=null;
  BufferedReader bufferedReader=null;
  try {
    bufferedReader=new BufferedReader(new FileReader(csvFile));
    while ((line=bufferedReader.readLine()) != null) {
      String[] fields=line.split(""String_Node_Str"");
      row++;
      if (row > 1) {
        double t=Double.valueOf(fields[0]);
        double x1=Double.valueOf(fields[1]);
        double x1CalculatedValue=0.0;
        double x2=0.0;
        double x2CalculatedValue=0.0;
        String message=""String_Node_Str"" + testName + ""String_Node_Str""+ csvFile+ ""String_Node_Str""+ row+ ""String_Node_Str""+ t+ ""String_Node_Str""+ x1+ ""String_Node_Str""+ x1CalculatedValue+ (checkX2 ? (""String_Node_Str"" + x2 + ""String_Node_Str""+ x2CalculatedValue) : ""String_Node_Str"");
        if (checkX2) {
          x1CalculatedValue=1.0 * Math.exp(-0.5 * t);
          x2=Double.valueOf(fields[2]);
          x2CalculatedValue=2.0 * Math.exp(-1.0 * t);
          x2MaximumError=Math.max(x2MaximumError,Math.abs(x2 - x2CalculatedValue));
          assertEquals(message,x2,x2CalculatedValue,epsilon);
        }
 else {
          x1CalculatedValue=1.0 * Math.exp(-1.0 * t);
        }
        x1MaximumError=Math.max(x1MaximumError,Math.abs(x1 - x1CalculatedValue));
        assertEquals(message,x1,x1CalculatedValue,epsilon);
      }
    }
  }
  finally {
    if (bufferedReader != null) {
      bufferedReader.close();
    }
  }
  System.out.println(testName + ""String_Node_Str"" + x1MaximumError+ (checkX2 ? (""String_Node_Str"" + x2MaximumError) : ""String_Node_Str"")+ ""String_Node_Str"");
  assertTrue(""String_Node_Str"" + x1MaximumError + ""String_Node_Str""+ epsilon,x1MaximumError < epsilon);
  assertTrue(""String_Node_Str"" + x2MaximumError + ""String_Node_Str""+ epsilon,x2MaximumError < epsilon);
}","/** 
 * Check the csv file against equations. The equations come from sparse_fmi by James Nutaro. Some variance is acceptable, though the test fails if there is too much.
 * @param testName The name of the test, ex. ""Linsys"".
 * @param csvFile The comma separated file to be checked, typically generatedby the  {@link #modelExchange(String)} method.
 * @param checkX2 True if the 3rd argument is x2 and should be checked.
 * @exception Exception If there is a problem parsing the file.
 */
public void modelExchangeCheck(String testName,String csvFile,boolean checkX2) throws Exception {
  double x1MaximumError=0.0;
  double x2MaximumError=0.0;
  double epsilon=0.003;
  int row=0;
  String line=null;
  BufferedReader bufferedReader=null;
  try {
    bufferedReader=new BufferedReader(new java.io.InputStreamReader(new java.io.FileInputStream(csvFile),java.nio.charset.Charset.defaultCharset()));
    while ((line=bufferedReader.readLine()) != null) {
      String[] fields=line.split(""String_Node_Str"");
      row++;
      if (row > 1) {
        double t=Double.valueOf(fields[0]);
        double x1=Double.valueOf(fields[1]);
        double x1CalculatedValue=0.0;
        double x2=0.0;
        double x2CalculatedValue=0.0;
        String message=""String_Node_Str"" + testName + ""String_Node_Str""+ csvFile+ ""String_Node_Str""+ row+ ""String_Node_Str""+ t+ ""String_Node_Str""+ x1+ ""String_Node_Str""+ x1CalculatedValue+ (checkX2 ? (""String_Node_Str"" + x2 + ""String_Node_Str""+ x2CalculatedValue) : ""String_Node_Str"");
        if (checkX2) {
          x1CalculatedValue=1.0 * Math.exp(-0.5 * t);
          x2=Double.valueOf(fields[2]);
          x2CalculatedValue=2.0 * Math.exp(-1.0 * t);
          x2MaximumError=Math.max(x2MaximumError,Math.abs(x2 - x2CalculatedValue));
          assertEquals(message,x2,x2CalculatedValue,epsilon);
        }
 else {
          x1CalculatedValue=1.0 * Math.exp(-1.0 * t);
        }
        x1MaximumError=Math.max(x1MaximumError,Math.abs(x1 - x1CalculatedValue));
        assertEquals(message,x1,x1CalculatedValue,epsilon);
      }
    }
  }
  finally {
    if (bufferedReader != null) {
      bufferedReader.close();
    }
  }
  System.out.println(testName + ""String_Node_Str"" + x1MaximumError+ (checkX2 ? (""String_Node_Str"" + x2MaximumError) : ""String_Node_Str"")+ ""String_Node_Str"");
  assertTrue(""String_Node_Str"" + x1MaximumError + ""String_Node_Str""+ epsilon,x1MaximumError < epsilon);
  assertTrue(""String_Node_Str"" + x2MaximumError + ""String_Node_Str""+ epsilon,x2MaximumError < epsilon);
}"
72582,"/** 
 * Create a _StreamReaderThread.
 * @param inputStream The stream to read from.
 * @param name The name of this StreamReaderThread,which is useful for debugging.
 * @param actor The parent actor of this thread, whichis used in error messages.
 */
_StreamReaderThread(InputStream inputStream,String name,Nameable actor){
  super(name);
  _inputStream=inputStream;
  _inputStreamReader=new InputStreamReader(_inputStream);
  _actor=actor;
  _stringBuffer=new StringBuffer();
}","/** 
 * Create a _StreamReaderThread.
 * @param inputStream The stream to read from.
 * @param name The name of this StreamReaderThread,which is useful for debugging.
 * @param actor The parent actor of this thread, whichis used in error messages.
 */
_StreamReaderThread(InputStream inputStream,String name,Nameable actor){
  super(name);
  _inputStream=inputStream;
  _inputStreamReader=new InputStreamReader(_inputStream,java.nio.charset.Charset.defaultCharset());
  _actor=actor;
  _stringBuffer=new StringBuffer();
}"
72583,"/** 
 * Create a _StreamReaderThread.
 * @param inputStream The stream to read from.
 * @param name The name of this StreamReaderThread,which is useful for debugging.
 * @param actor The parent actor of this thread, whichis used in error messages.
 */
_StreamReaderThread(InputStream inputStream,String name,Nameable actor){
  super(name);
  _inputStream=inputStream;
  _inputStreamReader=new InputStreamReader(_inputStream);
  _actor=actor;
  _stringBuffer=new StringBuffer();
}","/** 
 * Create a _StreamReaderThread.
 * @param inputStream The stream to read from.
 * @param name The name of this StreamReaderThread,which is useful for debugging.
 * @param actor The parent actor of this thread, whichis used in error messages.
 */
_StreamReaderThread(InputStream inputStream,String name,Nameable actor){
  super(name);
  _inputStream=inputStream;
  _inputStreamReader=new InputStreamReader(_inputStream,java.nio.charset.Charset.defaultCharset());
  _actor=actor;
  _stringBuffer=new StringBuffer();
}"
72584,"/** 
 * Output XML configuration to the pre-defined file (specified with ""-config"" argument in   {@link #main(String[])}).
 * @exception Exception If any error occurs.
 */
protected static void _outputConfig() throws Exception {
  if (_configName != null) {
    SourceOutputStream stream=SourceOutputStream.getStream(_configName,_overwrite);
    Set<String> classSet=new HashSet<String>();
    classSet.addAll(_classes);
    ConfigParser parser=new ConfigParser();
    parser.addExcludedFile(new File(_configName).getCanonicalPath());
    parser.parseConfigFile(ConfigParser.DEFAULT_SYSTEM_ID,classSet);
    if ((_prefix != null) && (_prefix.length() > 0)) {
      parser.addPackagePrefix(_prefix,classSet);
    }
    OutputStreamWriter writer=null;
    try {
      writer=new OutputStreamWriter(stream);
      XmlOutput.outputXmlTree(parser.getTree(),writer);
    }
  finally {
      if (writer != null) {
        writer.close();
      }
    }
  }
}","/** 
 * Output XML configuration to the pre-defined file (specified with ""-config"" argument in   {@link #main(String[])}).
 * @exception Exception If any error occurs.
 */
protected static void _outputConfig() throws Exception {
  if (_configName != null) {
    SourceOutputStream stream=SourceOutputStream.getStream(_configName,_overwrite);
    Set<String> classSet=new HashSet<String>();
    classSet.addAll(_classes);
    ConfigParser parser=new ConfigParser();
    parser.addExcludedFile(new File(_configName).getCanonicalPath());
    parser.parseConfigFile(ConfigParser.DEFAULT_SYSTEM_ID,classSet);
    if ((_prefix != null) && (_prefix.length() > 0)) {
      parser.addPackagePrefix(_prefix,classSet);
    }
    OutputStreamWriter writer=null;
    try {
      writer=new OutputStreamWriter(stream,java.nio.charset.Charset.defaultCharset());
      XmlOutput.outputXmlTree(parser.getTree(),writer);
    }
  finally {
      if (writer != null) {
        writer.close();
      }
    }
  }
}"
72585,"/** 
 * Update the ""Preview"" tab if the source code is changed in the ""Raw"" tab.
 */
protected void _update(){
  if (!_needRefactoring) {
    return;
  }
  String root=Environment.getRefactoringRoot(_container.getShell());
  if (root == null) {
    return;
  }
  IPreferenceStore store=EclipsePlugin.getDefault().getPreferenceStore();
  IFile file=(IFile)getEditorInput().getAdapter(IFile.class);
  IFile previewFile=_getPreviewFile();
  PipedOutputStream outputStream=new PipedOutputStream();
  OutputStreamWriter writer=new OutputStreamWriter(outputStream);
  try {
    Environment.createFolders(previewFile.getParent());
    boolean overwrite=store.getBoolean(PreferenceConstants.BACKTRACK_OVERWRITE);
    if (!overwrite && previewFile.exists()) {
      OutputConsole.outputError(""String_Node_Str"" + previewFile.getLocation().toOSString() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      return;
    }
    PipedInputStream inputStream=new PipedInputStream(outputStream);
    CompilationUnit compilationUnit=_getCompilationUnit();
    new RefactoringOutputThread(previewFile,inputStream).start();
    String[] PTClassPaths=Environment.getClassPaths(null);
    IWorkspaceRoot workspace=ResourcesPlugin.getWorkspace().getRoot();
    IProject[] projects=workspace.getProjects();
    String[] extraClassPaths=new String[projects.length];
    for (int i=0; i < projects.length; i++) {
      extraClassPaths[i]=projects[i].getLocation().toOSString();
    }
    String extraClassPathsInOptions=store.getString(PreferenceConstants.BACKTRACK_EXTRA_CLASSPATHS);
    if (!extraClassPathsInOptions.equals(""String_Node_Str"")) {
      extraClassPaths=Strings.combineArrays(extraClassPaths,Strings.decodeFileNames(extraClassPathsInOptions));
    }
    if (!Environment.setupTransformerArguments(_container.getShell(),false,true)) {
      OutputConsole.outputError(""String_Node_Str"");
      return;
    }
    BusyIndicator.showWhile(Display.getCurrent(),new TransformerRunnable(file.getLocation().toOSString(),compilationUnit,writer,Strings.combineArrays(PTClassPaths,extraClassPaths),new String[]{}));
    _needRefactoring=false;
  }
 catch (  Exception e) {
    OutputConsole.outputError(e.getMessage());
  }
 finally {
    try {
      writer.close();
      _preview.setInput(new FileEditorInput(previewFile));
      _preview.getViewer().setEditable(false);
    }
 catch (    Exception e) {
      OutputConsole.outputError(e.getMessage());
    }
  }
}","/** 
 * Update the ""Preview"" tab if the source code is changed in the ""Raw"" tab.
 */
protected void _update(){
  if (!_needRefactoring) {
    return;
  }
  String root=Environment.getRefactoringRoot(_container.getShell());
  if (root == null) {
    return;
  }
  IPreferenceStore store=EclipsePlugin.getDefault().getPreferenceStore();
  IFile file=(IFile)getEditorInput().getAdapter(IFile.class);
  IFile previewFile=_getPreviewFile();
  PipedOutputStream outputStream=new PipedOutputStream();
  OutputStreamWriter writer=new OutputStreamWriter(outputStream,java.nio.charset.Charset.defaultCharset());
  try {
    Environment.createFolders(previewFile.getParent());
    boolean overwrite=store.getBoolean(PreferenceConstants.BACKTRACK_OVERWRITE);
    if (!overwrite && previewFile.exists()) {
      OutputConsole.outputError(""String_Node_Str"" + previewFile.getLocation().toOSString() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      return;
    }
    PipedInputStream inputStream=new PipedInputStream(outputStream);
    CompilationUnit compilationUnit=_getCompilationUnit();
    new RefactoringOutputThread(previewFile,inputStream).start();
    String[] PTClassPaths=Environment.getClassPaths(null);
    IWorkspaceRoot workspace=ResourcesPlugin.getWorkspace().getRoot();
    IProject[] projects=workspace.getProjects();
    String[] extraClassPaths=new String[projects.length];
    for (int i=0; i < projects.length; i++) {
      extraClassPaths[i]=projects[i].getLocation().toOSString();
    }
    String extraClassPathsInOptions=store.getString(PreferenceConstants.BACKTRACK_EXTRA_CLASSPATHS);
    if (!extraClassPathsInOptions.equals(""String_Node_Str"")) {
      extraClassPaths=Strings.combineArrays(extraClassPaths,Strings.decodeFileNames(extraClassPathsInOptions));
    }
    if (!Environment.setupTransformerArguments(_container.getShell(),false,true)) {
      OutputConsole.outputError(""String_Node_Str"");
      return;
    }
    BusyIndicator.showWhile(Display.getCurrent(),new TransformerRunnable(file.getLocation().toOSString(),compilationUnit,writer,Strings.combineArrays(PTClassPaths,extraClassPaths),new String[]{}));
    _needRefactoring=false;
  }
 catch (  Exception e) {
    OutputConsole.outputError(e.getMessage());
  }
 finally {
    try {
      writer.close();
      _preview.setInput(new FileEditorInput(previewFile));
      _preview.getViewer().setEditable(false);
    }
 catch (    Exception e) {
      OutputConsole.outputError(e.getMessage());
    }
  }
}"
72586,"/** 
 * Parse a configuration file and build the XML tree below the given parent node (or <tt>null</tt> if not given). Only the nodes corresponding to the classes in <tt>includedClasses</tt> and their parent nodes are created. Other nodes in the XML tree are ignored.
 * @param fileName The name of the configuration file.
 * @param includedClasses The set of names of classes to be included.
 * @param backtrackingElement Whether to set the parent node of theconstructed XML tree to be the ""backtrack"" node.
 * @exception Exception If error occurs.
 */
public void parseConfigFile(String fileName,Set<String> includedClasses,boolean backtrackingElement) throws Exception {
  XmlParser parser=new XmlParser();
  BufferedReader br=new BufferedReader(new FileReader(fileName));
  ConfigXmlHandler handler=new ConfigXmlHandler(_xmlTree,fileName,includedClasses);
  handler.addExcludedFiles(_excludedFiles);
  parser.setHandler(handler);
  try {
    parser.parse(fileName,null,br);
  }
 catch (  Throwable throwable) {
    throw new Exception(""String_Node_Str"" + fileName + ""String_Node_Str"",throwable);
  }
  if (backtrackingElement) {
    _xmlTree._setElementName(""String_Node_Str"");
  }
}","/** 
 * Parse a configuration file and build the XML tree below the given parent node (or <tt>null</tt> if not given). Only the nodes corresponding to the classes in <tt>includedClasses</tt> and their parent nodes are created. Other nodes in the XML tree are ignored.
 * @param fileName The name of the configuration file.
 * @param includedClasses The set of names of classes to be included.
 * @param backtrackingElement Whether to set the parent node of theconstructed XML tree to be the ""backtrack"" node.
 * @exception Exception If error occurs.
 */
public void parseConfigFile(String fileName,Set<String> includedClasses,boolean backtrackingElement) throws Exception {
  XmlParser parser=new XmlParser();
  BufferedReader br=new BufferedReader(new java.io.InputStreamReader(new java.io.FileInputStream(fileName),java.nio.charset.Charset.defaultCharset()));
  ConfigXmlHandler handler=new ConfigXmlHandler(_xmlTree,fileName,includedClasses);
  handler.addExcludedFiles(_excludedFiles);
  parser.setHandler(handler);
  try {
    parser.parse(fileName,null,br);
  }
 catch (  Throwable throwable) {
    throw new Exception(""String_Node_Str"" + fileName + ""String_Node_Str"",throwable);
  }
  if (backtrackingElement) {
    _xmlTree._setElementName(""String_Node_Str"");
  }
}"
72587,"/** 
 * Given a string that names a file, URL or resource, try to open as a file, and then as a URL, then as a resource.
 * @param inputFileName The name of the file or URL to open
 * @return A BufferedReader that refers to the inputFileName
 * @exception FileNotFoundException If the file cannot be found.
 * @exception IOException If there were problems creatingthe BufferedReader.
 */
public static BufferedReader openAsFileOrURL(String inputFileName) throws FileNotFoundException, IOException {
  BufferedReader inputFile;
  try {
    inputFile=new BufferedReader(new FileReader(inputFileName));
  }
 catch (  IOException ex) {
    try {
      inputFile=new BufferedReader(new InputStreamReader(new URL(inputFileName).openStream()));
    }
 catch (    Throwable throwable) {
      URL inputFileURL=Thread.currentThread().getContextClassLoader().getResource(inputFileName);
      if (inputFileURL == null) {
        throw ex;
      }
      inputFile=new BufferedReader(new InputStreamReader(inputFileURL.openStream()));
    }
  }
  return inputFile;
}","/** 
 * Given a string that names a file, URL or resource, try to open as a file, and then as a URL, then as a resource.
 * @param inputFileName The name of the file or URL to open
 * @return A BufferedReader that refers to the inputFileName
 * @exception FileNotFoundException If the file cannot be found.
 * @exception IOException If there were problems creatingthe BufferedReader.
 */
public static BufferedReader openAsFileOrURL(String inputFileName) throws FileNotFoundException, IOException {
  BufferedReader inputFile;
  try {
    inputFile=new BufferedReader(new java.io.InputStreamReader(new java.io.FileInputStream(inputFileName),java.nio.charset.Charset.defaultCharset()));
  }
 catch (  IOException ex) {
    try {
      inputFile=new BufferedReader(new InputStreamReader(new URL(inputFileName).openStream()));
    }
 catch (    Throwable throwable) {
      URL inputFileURL=Thread.currentThread().getContextClassLoader().getResource(inputFileName);
      if (inputFileURL == null) {
        throw ex;
      }
      inputFile=new BufferedReader(new InputStreamReader(inputFileURL.openStream()));
    }
  }
  return inputFile;
}"
72588,"/** 
 * Write out the Jimple file. Sample option arguments: <code>-p wjtp.writeJimple1 outputDirectory:jimple1</code>
 * @see ClassWriter
 * @param phaseName The name of the phase, for example<code>wjtp.writeJimple2</code>.
 * @param options The options Map.  This method uses the<code>outdir</code> option to specify where the .jimple file should be written
 */
@Override protected void internalTransform(String phaseName,Map options){
  System.out.println(""String_Node_Str"" + phaseName + ""String_Node_Str""+ options+ ""String_Node_Str"");
  String outputDirectory=PhaseOptions.getString(options,""String_Node_Str"");
  for (Iterator classes=Scene.v().getApplicationClasses().iterator(); classes.hasNext(); ) {
    SootClass theClass=(SootClass)classes.next();
    String fileName;
    if (!outputDirectory.equals(""String_Node_Str"")) {
      File outputDirectoryFile=new File(outputDirectory);
      if (!outputDirectoryFile.isDirectory()) {
        if (!outputDirectoryFile.mkdirs()) {
          throw new RuntimeException(""String_Node_Str"" + outputDirectoryFile + ""String_Node_Str"");
        }
      }
      fileName=outputDirectory + System.getProperty(""String_Node_Str"");
    }
 else {
      fileName=""String_Node_Str"";
    }
    fileName+=theClass.getName() + ""String_Node_Str"";
    FileOutputStream streamOut=null;
    PrintWriter writerOut=null;
    try {
      streamOut=new FileOutputStream(fileName);
      writerOut=new PrintWriter(new EscapedWriter(new OutputStreamWriter(streamOut)));
      Printer printer=Printer.v();
      printer.setOption(Integer.MAX_VALUE);
      printer.printTo(theClass,new java.io.PrintWriter(writerOut));
    }
 catch (    Exception e) {
      System.out.println(""String_Node_Str"" + ""String_Node_Str"" + fileName + ""String_Node_Str""+ e);
    }
 finally {
      if (writerOut != null) {
        writerOut.close();
      }
      try {
        if (streamOut != null) {
          streamOut.close();
        }
      }
 catch (      IOException io) {
      }
    }
  }
}","/** 
 * Write out the Jimple file. Sample option arguments: <code>-p wjtp.writeJimple1 outputDirectory:jimple1</code>
 * @see ClassWriter
 * @param phaseName The name of the phase, for example<code>wjtp.writeJimple2</code>.
 * @param options The options Map.  This method uses the<code>outdir</code> option to specify where the .jimple file should be written
 */
@Override protected void internalTransform(String phaseName,Map options){
  System.out.println(""String_Node_Str"" + phaseName + ""String_Node_Str""+ options+ ""String_Node_Str"");
  String outputDirectory=PhaseOptions.getString(options,""String_Node_Str"");
  for (Iterator classes=Scene.v().getApplicationClasses().iterator(); classes.hasNext(); ) {
    SootClass theClass=(SootClass)classes.next();
    String fileName;
    if (!outputDirectory.equals(""String_Node_Str"")) {
      File outputDirectoryFile=new File(outputDirectory);
      if (!outputDirectoryFile.isDirectory()) {
        if (!outputDirectoryFile.mkdirs()) {
          throw new RuntimeException(""String_Node_Str"" + outputDirectoryFile + ""String_Node_Str"");
        }
      }
      fileName=outputDirectory + System.getProperty(""String_Node_Str"");
    }
 else {
      fileName=""String_Node_Str"";
    }
    fileName+=theClass.getName() + ""String_Node_Str"";
    FileOutputStream streamOut=null;
    PrintWriter writerOut=null;
    try {
      streamOut=new FileOutputStream(fileName);
      writerOut=new PrintWriter(new EscapedWriter(new OutputStreamWriter(streamOut,java.nio.charset.Charset.defaultCharset())));
      Printer printer=Printer.v();
      printer.setOption(Integer.MAX_VALUE);
      printer.printTo(theClass,new java.io.PrintWriter(writerOut));
    }
 catch (    Exception e) {
      System.out.println(""String_Node_Str"" + ""String_Node_Str"" + fileName + ""String_Node_Str""+ e);
    }
 finally {
      if (writerOut != null) {
        writerOut.close();
      }
      try {
        if (streamOut != null) {
          streamOut.close();
        }
      }
 catch (      IOException io) {
      }
    }
  }
}"
72589,"/** 
 * Get the string text contained in the specified file. The argument is first interpreted using findFile(), so file names relative to the current working directory, the user's home directory, or the classpath are understood. If the file contains text that is a valid expression in the expression language, then that text can interpreted using the eval() function in ptolemy.data.expr.ASTPtFunctionApplicationNode. For example: <code>eval(readFile(""<i>filename</i>""))</code><p> Note that readFile() does not work inside applets, use  {@link #readResource(String)} instead.
 * @param filename The name of the file to read from.
 * @return A StringToken containing the text contained inthe specified file.
 * @exception IllegalActionException If the file cannot be opened.
 * @see ptolemy.data.expr.ASTPtFunctionApplicationNode
 * @see #readResource(String)
 */
public static StringToken readFile(String filename) throws IllegalActionException {
  File file=new File(findFile(filename));
  BufferedReader fin=null;
  String line;
  StringBuffer result=new StringBuffer(""String_Node_Str"");
  String newline=System.getProperty(""String_Node_Str"");
  try {
    fin=new BufferedReader(new FileReader(file));
    while (true) {
      try {
        line=fin.readLine();
      }
 catch (      IOException e) {
        break;
      }
      if (line == null) {
        break;
      }
      result.append(line + newline);
    }
  }
 catch (  FileNotFoundException ex) {
    throw new IllegalActionException(null,ex,""String_Node_Str"");
  }
 finally {
    if (fin != null) {
      try {
        fin.close();
      }
 catch (      IOException ex) {
        throw new IllegalActionException(null,ex,""String_Node_Str"" + file + ""String_Node_Str"");
      }
    }
  }
  return new StringToken(result.toString());
}","/** 
 * Get the string text contained in the specified file. The argument is first interpreted using findFile(), so file names relative to the current working directory, the user's home directory, or the classpath are understood. If the file contains text that is a valid expression in the expression language, then that text can interpreted using the eval() function in ptolemy.data.expr.ASTPtFunctionApplicationNode. For example: <code>eval(readFile(""<i>filename</i>""))</code><p> Note that readFile() does not work inside applets, use  {@link #readResource(String)} instead.
 * @param filename The name of the file to read from.
 * @return A StringToken containing the text contained inthe specified file.
 * @exception IllegalActionException If the file cannot be opened.
 * @see ptolemy.data.expr.ASTPtFunctionApplicationNode
 * @see #readResource(String)
 */
public static StringToken readFile(String filename) throws IllegalActionException {
  File file=new File(findFile(filename));
  BufferedReader fin=null;
  String line;
  StringBuffer result=new StringBuffer(""String_Node_Str"");
  String newline=System.getProperty(""String_Node_Str"");
  try {
    fin=new BufferedReader(new java.io.InputStreamReader(new java.io.FileInputStream(file),java.nio.charset.Charset.defaultCharset()));
    while (true) {
      try {
        line=fin.readLine();
      }
 catch (      IOException e) {
        break;
      }
      if (line == null) {
        break;
      }
      result.append(line + newline);
    }
  }
 catch (  FileNotFoundException ex) {
    throw new IllegalActionException(null,ex,""String_Node_Str"");
  }
 finally {
    if (fin != null) {
      try {
        fin.close();
      }
 catch (      IOException ex) {
        throw new IllegalActionException(null,ex,""String_Node_Str"" + file + ""String_Node_Str"");
      }
    }
  }
  return new StringToken(result.toString());
}"
72590,"/** 
 * Reads mapping constraints from a file. MappingConstraintSolver
 * @param filename Filename of the mapping constraint file.
 * @return the constraint file in a string.
 * @exception IOException a failed or interrupted I/O operations has occurred.
 */
public static String readMappingFile(String filename) throws IOException {
  FileInputStream stream=new FileInputStream(filename);
  DataInputStream in=new DataInputStream(stream);
  BufferedReader reader=new BufferedReader(new InputStreamReader(in));
  String line;
  StringBuilder stringBuilder=new StringBuilder();
  try {
    while ((line=reader.readLine()) != null) {
      stringBuilder.append(line);
      stringBuilder.append('\n');
    }
    return stringBuilder.toString();
  }
  finally {
    reader.close();
  }
}","/** 
 * Reads mapping constraints from a file. MappingConstraintSolver
 * @param filename Filename of the mapping constraint file.
 * @return the constraint file in a string.
 * @exception IOException a failed or interrupted I/O operations has occurred.
 */
public static String readMappingFile(String filename) throws IOException {
  FileInputStream stream=new FileInputStream(filename);
  DataInputStream in=new DataInputStream(stream);
  BufferedReader reader=new BufferedReader(new InputStreamReader(in,java.nio.charset.Charset.defaultCharset()));
  String line;
  StringBuilder stringBuilder=new StringBuilder();
  try {
    while ((line=reader.readLine()) != null) {
      stringBuilder.append(line);
      stringBuilder.append('\n');
    }
    return stringBuilder.toString();
  }
  finally {
    reader.close();
  }
}"
72591,"/** 
 * Read in .nc xml files, generate .moml files.
 * @param args A series of command line arguments, see theclass comment for details.
 * @exception IOException If there is a problem reading orwriting a file.
 */
public static void main(String[] args) throws IOException {
  if (args.length < 5) {
    System.err.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    return;
  }
  int index=0;
  String inputPrefix=args[index++].trim();
  String inputSuffix=args[index++].trim();
  String subPrefix=args[index++].trim();
  String outputPrefix=args[index++].trim();
  String inputFiles=args[index++].trim();
  BufferedReader in=null;
  try {
    in=new BufferedReader(new FileReader(inputFiles));
    String inputFileName;
    while ((inputFileName=in.readLine()) != null) {
      String xmlSuffix=inputFileName.replaceFirst(""String_Node_Str"",inputSuffix);
      String xmlInputFile=inputPrefix + _FILESEPARATOR + xmlSuffix;
      String pathToNCFile=subPrefix + _FILESEPARATOR + inputFileName;
      String[] subdirs=inputFileName.split(_FILESEPARATOR);
      String componentName=subdirs[subdirs.length - 1];
      componentName=componentName.replaceFirst(""String_Node_Str"",""String_Node_Str"");
      String momlSuffix=inputFileName.replaceFirst(""String_Node_Str"",""String_Node_Str"");
      String momlOutputFile=outputPrefix + _FILESEPARATOR + momlSuffix;
      try {
        if (new NDReader().parse(xmlInputFile)) {
          System.out.println(""String_Node_Str"" + xmlInputFile);
        }
 else {
          System.out.println(""String_Node_Str"" + xmlInputFile);
        }
        try {
          generateComponent(pathToNCFile,componentName,momlOutputFile);
        }
 catch (        Exception ex) {
          System.err.println(""String_Node_Str"" + momlOutputFile + ""String_Node_Str""+ ex);
        }
      }
 catch (      SAXException ex) {
        System.err.println(""String_Node_Str"" + xmlInputFile + ""String_Node_Str"");
      }
catch (      FileNotFoundException ex) {
        System.err.println(""String_Node_Str"" + xmlInputFile + ""String_Node_Str"");
      }
catch (      Exception ex) {
        System.err.println(""String_Node_Str"" + xmlInputFile + ""String_Node_Str""+ ex);
      }
    }
  }
 catch (  IOException ex) {
    System.err.println(""String_Node_Str"" + inputFiles);
    System.err.println(""String_Node_Str"" + ex);
  }
 finally {
    if (in != null) {
      in.close();
    }
  }
}","/** 
 * Read in .nc xml files, generate .moml files.
 * @param args A series of command line arguments, see theclass comment for details.
 * @exception IOException If there is a problem reading orwriting a file.
 */
public static void main(String[] args) throws IOException {
  if (args.length < 5) {
    System.err.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    return;
  }
  int index=0;
  String inputPrefix=args[index++].trim();
  String inputSuffix=args[index++].trim();
  String subPrefix=args[index++].trim();
  String outputPrefix=args[index++].trim();
  String inputFiles=args[index++].trim();
  BufferedReader in=null;
  try {
    in=new BufferedReader(new java.io.InputStreamReader(new java.io.FileInputStream(inputFiles),java.nio.charset.Charset.defaultCharset()));
    String inputFileName;
    while ((inputFileName=in.readLine()) != null) {
      String xmlSuffix=inputFileName.replaceFirst(""String_Node_Str"",inputSuffix);
      String xmlInputFile=inputPrefix + _FILESEPARATOR + xmlSuffix;
      String pathToNCFile=subPrefix + _FILESEPARATOR + inputFileName;
      String[] subdirs=inputFileName.split(_FILESEPARATOR);
      String componentName=subdirs[subdirs.length - 1];
      componentName=componentName.replaceFirst(""String_Node_Str"",""String_Node_Str"");
      String momlSuffix=inputFileName.replaceFirst(""String_Node_Str"",""String_Node_Str"");
      String momlOutputFile=outputPrefix + _FILESEPARATOR + momlSuffix;
      try {
        if (new NDReader().parse(xmlInputFile)) {
          System.out.println(""String_Node_Str"" + xmlInputFile);
        }
 else {
          System.out.println(""String_Node_Str"" + xmlInputFile);
        }
        try {
          generateComponent(pathToNCFile,componentName,momlOutputFile);
        }
 catch (        Exception ex) {
          System.err.println(""String_Node_Str"" + momlOutputFile + ""String_Node_Str""+ ex);
        }
      }
 catch (      SAXException ex) {
        System.err.println(""String_Node_Str"" + xmlInputFile + ""String_Node_Str"");
      }
catch (      FileNotFoundException ex) {
        System.err.println(""String_Node_Str"" + xmlInputFile + ""String_Node_Str"");
      }
catch (      Exception ex) {
        System.err.println(""String_Node_Str"" + xmlInputFile + ""String_Node_Str""+ ex);
      }
    }
  }
 catch (  IOException ex) {
    System.err.println(""String_Node_Str"" + inputFiles);
    System.err.println(""String_Node_Str"" + ex);
  }
 finally {
    if (in != null) {
      in.close();
    }
  }
}"
72592,"/** 
 * Read applet parameters, open the URL and display the contents in a TextArea.
 */
@Override public void init(){
  super.init();
  int rows;
  int columns;
  String rowsString=getParameter(""String_Node_Str"");
  if (rowsString != null) {
    rows=Integer.parseInt(rowsString);
  }
 else {
    rows=10;
  }
  String columnsString=getParameter(""String_Node_Str"");
  if (columnsString != null) {
    columns=Integer.parseInt(columnsString);
  }
 else {
    columns=40;
  }
  String sourceURLString=getParameter(""String_Node_Str"");
  URL sourceURL=null;
  if (sourceURLString != null) {
    try {
      showStatus(""String_Node_Str"");
      sourceURL=new URL(getDocumentBase(),sourceURLString);
    }
 catch (    MalformedURLException e) {
      System.err.println(e.toString());
    }
  }
  new JFrame();
  _jTextArea=new JTextArea(rows,columns);
  _jTextArea.setEditable(false);
  _scrollPane=new JScrollPane(_jTextArea);
  getContentPane().add(_scrollPane);
  String newline=System.getProperty(""String_Node_Str"");
  if (sourceURL == null) {
    showStatus(""String_Node_Str"" + sourceURLString);
    System.err.println(""String_Node_Str"" + sourceURLString);
  }
 else {
    InputStream in=null;
    try {
      in=sourceURL.openStream();
      _bufferedReader=new BufferedReader(new InputStreamReader(in));
      String line=_bufferedReader.readLine();
      while (line != null) {
        _jTextArea.append(line + newline);
        line=_bufferedReader.readLine();
      }
      showStatus(""String_Node_Str"");
    }
 catch (    FileNotFoundException e) {
      System.err.println(""String_Node_Str"" + e);
    }
catch (    IOException e) {
      System.err.println(""String_Node_Str"" + e);
    }
 finally {
      if (in != null) {
        try {
          in.close();
        }
 catch (        Exception ex) {
          System.err.println(""String_Node_Str"" + sourceURLString + ""String_Node_Str""+ ex);
        }
      }
    }
  }
  validate();
  repaint();
}","/** 
 * Read applet parameters, open the URL and display the contents in a TextArea.
 */
@Override public void init(){
  super.init();
  int rows;
  int columns;
  String rowsString=getParameter(""String_Node_Str"");
  if (rowsString != null) {
    rows=Integer.parseInt(rowsString);
  }
 else {
    rows=10;
  }
  String columnsString=getParameter(""String_Node_Str"");
  if (columnsString != null) {
    columns=Integer.parseInt(columnsString);
  }
 else {
    columns=40;
  }
  String sourceURLString=getParameter(""String_Node_Str"");
  URL sourceURL=null;
  if (sourceURLString != null) {
    try {
      showStatus(""String_Node_Str"");
      sourceURL=new URL(getDocumentBase(),sourceURLString);
    }
 catch (    MalformedURLException e) {
      System.err.println(e.toString());
    }
  }
  new JFrame();
  _jTextArea=new JTextArea(rows,columns);
  _jTextArea.setEditable(false);
  _scrollPane=new JScrollPane(_jTextArea);
  getContentPane().add(_scrollPane);
  String newline=System.getProperty(""String_Node_Str"");
  if (sourceURL == null) {
    showStatus(""String_Node_Str"" + sourceURLString);
    System.err.println(""String_Node_Str"" + sourceURLString);
  }
 else {
    InputStream in=null;
    try {
      in=sourceURL.openStream();
      _bufferedReader=new BufferedReader(new InputStreamReader(in,java.nio.charset.Charset.defaultCharset()));
      String line=_bufferedReader.readLine();
      while (line != null) {
        _jTextArea.append(line + newline);
        line=_bufferedReader.readLine();
      }
      showStatus(""String_Node_Str"");
    }
 catch (    FileNotFoundException e) {
      System.err.println(""String_Node_Str"" + e);
    }
catch (    IOException e) {
      System.err.println(""String_Node_Str"" + e);
    }
 finally {
      if (in != null) {
        try {
          in.close();
        }
 catch (        Exception ex) {
          System.err.println(""String_Node_Str"" + sourceURLString + ""String_Node_Str""+ ex);
        }
      }
    }
  }
  validate();
  repaint();
}"
72593,"/** 
 * Return the value given by the configure tag.  This is the text read from the specified URL (if any), followed by the text specified in the body of the configure element.  Note that the URL given in the configure() method, if any, is read each time this method is called.
 * @return The value set in the configure tag.
 * @exception IOException If the URL given in the configure method(if any) cannot be read.
 */
public String value() throws IOException {
  StringBuffer value=new StringBuffer();
  if (_configureSource != null && !_configureSource.trim().equals(""String_Node_Str"")) {
    URL textFile=new URL(_configureSource);
    InputStream stream=textFile.openStream();
    BufferedReader reader=null;
    try {
      reader=new BufferedReader(new InputStreamReader(stream));
      String line=reader.readLine();
      while (line != null) {
        value.append(line);
        value.append(""String_Node_Str"");
        line=reader.readLine();
      }
    }
  finally {
      if (reader != null) {
        reader.close();
      }
    }
    stream.close();
  }
  if (_configureText != null) {
    value.append(_configureText);
  }
  return value.toString();
}","/** 
 * Return the value given by the configure tag.  This is the text read from the specified URL (if any), followed by the text specified in the body of the configure element.  Note that the URL given in the configure() method, if any, is read each time this method is called.
 * @return The value set in the configure tag.
 * @exception IOException If the URL given in the configure method(if any) cannot be read.
 */
public String value() throws IOException {
  StringBuffer value=new StringBuffer();
  if (_configureSource != null && !_configureSource.trim().equals(""String_Node_Str"")) {
    URL textFile=new URL(_configureSource);
    InputStream stream=textFile.openStream();
    BufferedReader reader=null;
    try {
      reader=new BufferedReader(new InputStreamReader(stream,java.nio.charset.Charset.defaultCharset()));
      String line=reader.readLine();
      while (line != null) {
        value.append(line);
        value.append(""String_Node_Str"");
        line=reader.readLine();
      }
    }
  finally {
      if (reader != null) {
        reader.close();
      }
    }
    stream.close();
  }
  if (_configureText != null) {
    value.append(_configureText);
  }
  return value.toString();
}"
72594,"/** 
 * Generate the index files.
 * @param classesFileName The name of the file that contains thedot separated class names - one class per line. This file is usually called allActors.txt, which is generated by running the $PTII/doc/doclets/PtDoc doclet.  For example, see $PTII/doc/codeDoc/allActors.txt
 * @param modelsFileName The name of the file that contains theurls that point to the models to be parsed, one model per line.  This file is usually called models.txt and is generated by running ptolemy.actor.gui.HTMLAbout.
 * @param outputDirectory Directory in which to write index files.The files generated have the name <i>actorName</i>idx.htm, where <i>actorName</i> is the name of the actor.  Typically, the value for this parameter is doc/codeDoc.
 * @exception Exception If there is a problem reading or writinga file.
 */
public static void generateActorIndex(String classesFileName,String modelsFileName,String outputDirectory) throws Exception {
  HashMap classesToBeIndexed=new HashMap();
  BufferedReader classesReader=null;
  BufferedReader modelReader=null;
  try {
    ActorModuleInitializer.initializeInjector();
    classesReader=new BufferedReader(new FileReader(classesFileName));
    String className;
    while ((className=classesReader.readLine()) != null) {
      System.out.println(""String_Node_Str"" + className);
      classesToBeIndexed.put(className,new HashSet());
    }
    modelReader=new BufferedReader(new FileReader(modelsFileName));
    String modelName;
    MoMLParser parser=new MoMLParser();
    MoMLParser.setMoMLFilters(BackwardCompatibility.allFilters());
    NamedObjClassesSeen namedObjClassesSeen=new NamedObjClassesSeen(classesToBeIndexed);
    MoMLParser.addMoMLFilter(namedObjClassesSeen);
    RemoveGraphicalClasses removeGraphicalClasses=new RemoveGraphicalClasses();
    removeGraphicalClasses.setRemoveGR(true);
    MoMLParser.addMoMLFilter(removeGraphicalClasses);
    while ((modelName=modelReader.readLine()) != null) {
      namedObjClassesSeen.reset(modelName);
      try {
        URL modelURL=FileUtilities.nameToURL(modelName,null,null);
        System.out.println(""String_Node_Str"" + modelURL);
        parser.reset();
        parser.parse(null,modelURL);
      }
 catch (      Exception ex) {
        System.err.println(""String_Node_Str"" + modelName);
        ex.printStackTrace();
      }
    }
  }
  finally {
    if (classesReader != null) {
      try {
        classesReader.close();
      }
 catch (      IOException ex) {
        System.out.println(""String_Node_Str"" + classesReader + ""String_Node_Str""+ ex);
      }
    }
    if (modelReader != null) {
      try {
        modelReader.close();
      }
 catch (      IOException ex) {
        System.out.println(""String_Node_Str"" + modelReader + ""String_Node_Str""+ ex);
      }
    }
  }
  Iterator classes=classesToBeIndexed.entrySet().iterator();
  while (classes.hasNext()) {
    Map.Entry entry=(Map.Entry)classes.next();
    String actorClassName=(String)entry.getKey();
    if (((Set)entry.getValue()).size() == 0) {
      continue;
    }
    BufferedWriter writer=null;
    try {
      String outputFileName=outputDirectory + File.separator + actorClassName.replace('.',File.separatorChar)+ ""String_Node_Str"";
      String canonicalOutputFileName=new File(outputFileName).getCanonicalPath().replace('\\','/');
      String ptII=null;
      try {
        ptII=new URI(StringUtilities.getProperty(""String_Node_Str"")).normalize().getPath();
        ptII=new File(ptII).getCanonicalPath().replace('\\','/');
      }
 catch (      URISyntaxException ex) {
        throw new InternalErrorException(null,ex,""String_Node_Str"" + ptII);
      }
      if (ptII == null || ptII.length() == 0) {
        throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"");
      }
      String relativePath=""String_Node_Str"";
      if (canonicalOutputFileName.startsWith(ptII)) {
        String relativeOutputFileName=StringUtilities.substitute(canonicalOutputFileName,ptII,""String_Node_Str"");
        StringBuffer relativePathBuffer=new StringBuffer();
        int index=0;
        while (relativeOutputFileName.indexOf('/',index) != -1) {
          index=relativeOutputFileName.indexOf('/',index) + 1;
          relativePathBuffer.append(""String_Node_Str"");
        }
        relativePath=relativePathBuffer.toString();
        relativePath=relativePath.substring(0,relativePath.length() - 3);
      }
      File outputDirectoryFile=new File(new File(outputFileName).getParent());
      if (!outputDirectoryFile.exists()) {
        System.out.println(""String_Node_Str"" + outputDirectoryFile);
        if (!outputDirectoryFile.mkdirs()) {
          throw new IOException(""String_Node_Str"" + outputDirectoryFile + ""String_Node_Str"");
        }
      }
      System.out.println(""String_Node_Str"" + outputFileName);
      writer=new BufferedWriter(new FileWriter(outputFileName));
      writer.write(""String_Node_Str"" + actorClassName + ""String_Node_Str""+ ""String_Node_Str""+ relativePath+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ actorClassName+ ""String_Node_Str""+ ""String_Node_Str""+ actorClassName+ ""String_Node_Str"");
      Iterator models=((Set)entry.getValue()).iterator();
      while (models.hasNext()) {
        String model=(String)models.next();
        if (model.startsWith(""String_Node_Str"")) {
          model=model.substring(11);
        }
        writer.write(""String_Node_Str"" + relativePath + model+ ""String_Node_Str""+ model+ ""String_Node_Str"");
      }
      writer.write(""String_Node_Str"");
    }
  finally {
      if (writer != null) {
        writer.close();
      }
    }
  }
}","/** 
 * Generate the index files.
 * @param classesFileName The name of the file that contains thedot separated class names - one class per line. This file is usually called allActors.txt, which is generated by running the $PTII/doc/doclets/PtDoc doclet.  For example, see $PTII/doc/codeDoc/allActors.txt
 * @param modelsFileName The name of the file that contains theurls that point to the models to be parsed, one model per line.  This file is usually called models.txt and is generated by running ptolemy.actor.gui.HTMLAbout.
 * @param outputDirectory Directory in which to write index files.The files generated have the name <i>actorName</i>idx.htm, where <i>actorName</i> is the name of the actor.  Typically, the value for this parameter is doc/codeDoc.
 * @exception Exception If there is a problem reading or writinga file.
 */
public static void generateActorIndex(String classesFileName,String modelsFileName,String outputDirectory) throws Exception {
  HashMap classesToBeIndexed=new HashMap();
  BufferedReader classesReader=null;
  BufferedReader modelReader=null;
  try {
    ActorModuleInitializer.initializeInjector();
    classesReader=new BufferedReader(new java.io.InputStreamReader(new java.io.FileInputStream(classesFileName),java.nio.charset.Charset.defaultCharset()));
    String className;
    while ((className=classesReader.readLine()) != null) {
      System.out.println(""String_Node_Str"" + className);
      classesToBeIndexed.put(className,new HashSet());
    }
    modelReader=new BufferedReader(new java.io.InputStreamReader(new java.io.FileInputStream(modelsFileName),java.nio.charset.Charset.defaultCharset()));
    String modelName;
    MoMLParser parser=new MoMLParser();
    MoMLParser.setMoMLFilters(BackwardCompatibility.allFilters());
    NamedObjClassesSeen namedObjClassesSeen=new NamedObjClassesSeen(classesToBeIndexed);
    MoMLParser.addMoMLFilter(namedObjClassesSeen);
    RemoveGraphicalClasses removeGraphicalClasses=new RemoveGraphicalClasses();
    removeGraphicalClasses.setRemoveGR(true);
    MoMLParser.addMoMLFilter(removeGraphicalClasses);
    while ((modelName=modelReader.readLine()) != null) {
      namedObjClassesSeen.reset(modelName);
      try {
        URL modelURL=FileUtilities.nameToURL(modelName,null,null);
        System.out.println(""String_Node_Str"" + modelURL);
        parser.reset();
        parser.parse(null,modelURL);
      }
 catch (      Exception ex) {
        System.err.println(""String_Node_Str"" + modelName);
        ex.printStackTrace();
      }
    }
  }
  finally {
    if (classesReader != null) {
      try {
        classesReader.close();
      }
 catch (      IOException ex) {
        System.out.println(""String_Node_Str"" + classesReader + ""String_Node_Str""+ ex);
      }
    }
    if (modelReader != null) {
      try {
        modelReader.close();
      }
 catch (      IOException ex) {
        System.out.println(""String_Node_Str"" + modelReader + ""String_Node_Str""+ ex);
      }
    }
  }
  Iterator classes=classesToBeIndexed.entrySet().iterator();
  while (classes.hasNext()) {
    Map.Entry entry=(Map.Entry)classes.next();
    String actorClassName=(String)entry.getKey();
    if (((Set)entry.getValue()).size() == 0) {
      continue;
    }
    BufferedWriter writer=null;
    try {
      String outputFileName=outputDirectory + File.separator + actorClassName.replace('.',File.separatorChar)+ ""String_Node_Str"";
      String canonicalOutputFileName=new File(outputFileName).getCanonicalPath().replace('\\','/');
      String ptII=null;
      try {
        ptII=new URI(StringUtilities.getProperty(""String_Node_Str"")).normalize().getPath();
        ptII=new File(ptII).getCanonicalPath().replace('\\','/');
      }
 catch (      URISyntaxException ex) {
        throw new InternalErrorException(null,ex,""String_Node_Str"" + ptII);
      }
      if (ptII == null || ptII.length() == 0) {
        throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"");
      }
      String relativePath=""String_Node_Str"";
      if (canonicalOutputFileName.startsWith(ptII)) {
        String relativeOutputFileName=StringUtilities.substitute(canonicalOutputFileName,ptII,""String_Node_Str"");
        StringBuffer relativePathBuffer=new StringBuffer();
        int index=0;
        while (relativeOutputFileName.indexOf('/',index) != -1) {
          index=relativeOutputFileName.indexOf('/',index) + 1;
          relativePathBuffer.append(""String_Node_Str"");
        }
        relativePath=relativePathBuffer.toString();
        relativePath=relativePath.substring(0,relativePath.length() - 3);
      }
      File outputDirectoryFile=new File(new File(outputFileName).getParent());
      if (!outputDirectoryFile.exists()) {
        System.out.println(""String_Node_Str"" + outputDirectoryFile);
        if (!outputDirectoryFile.mkdirs()) {
          throw new IOException(""String_Node_Str"" + outputDirectoryFile + ""String_Node_Str"");
        }
      }
      System.out.println(""String_Node_Str"" + outputFileName);
      writer=new BufferedWriter(new FileWriter(outputFileName));
      writer.write(""String_Node_Str"" + actorClassName + ""String_Node_Str""+ ""String_Node_Str""+ relativePath+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ actorClassName+ ""String_Node_Str""+ ""String_Node_Str""+ actorClassName+ ""String_Node_Str"");
      Iterator models=((Set)entry.getValue()).iterator();
      while (models.hasNext()) {
        String model=(String)models.next();
        if (model.startsWith(""String_Node_Str"")) {
          model=model.substring(11);
        }
        writer.write(""String_Node_Str"" + relativePath + model+ ""String_Node_Str""+ model+ ""String_Node_Str"");
      }
      writer.write(""String_Node_Str"");
    }
  finally {
      if (writer != null) {
        writer.close();
      }
    }
  }
}"
72595,"/** 
 * Return a two dimensional array of arrays of strings that name the model to be exported.
 * @return a two dimension array of arrays of strings that name themodels to be exported.
 * @exception IOException If there is a problem accessing the directory.
 */
public Object[] demos() throws IOException {
  String ptolemyPtIIDir=StringUtilities.getProperty(""String_Node_Str"");
  String modelsFile=ptolemyPtIIDir + ""String_Node_Str"";
  FileInputStream fileInputStream=null;
  DataInputStream dataInputStream=null;
  BufferedReader reader=null;
  List<String> demos=new LinkedList<String>();
  try {
    fileInputStream=new FileInputStream(modelsFile);
    dataInputStream=new DataInputStream(fileInputStream);
    reader=new BufferedReader(new InputStreamReader(dataInputStream));
    String line;
    while ((line=reader.readLine()) != null) {
      String prefix=""String_Node_Str"";
      if (!line.startsWith(prefix)) {
        throw new IOException(""String_Node_Str"" + modelsFile + ""String_Node_Str""+ prefix+ ""String_Node_Str""+ line);
      }
      String modelPath=line.substring(prefix.length());
      if (_openModel(modelPath)) {
        demos.add(modelPath);
      }
    }
  }
 catch (  Exception ex) {
    IOException exception=new IOException(""String_Node_Str"" + modelsFile + ""String_Node_Str"");
    exception.initCause(ex);
    throw exception;
  }
 finally {
    if (reader != null) {
      reader.close();
    }
  }
  int i=0;
  Object[][] data=new Object[demos.size()][1];
  for (  String demo : demos) {
    data[i++][0]=demo;
  }
  return data;
}","/** 
 * Return a two dimensional array of arrays of strings that name the model to be exported.
 * @return a two dimension array of arrays of strings that name themodels to be exported.
 * @exception IOException If there is a problem accessing the directory.
 */
public Object[] demos() throws IOException {
  String ptolemyPtIIDir=StringUtilities.getProperty(""String_Node_Str"");
  String modelsFile=ptolemyPtIIDir + ""String_Node_Str"";
  FileInputStream fileInputStream=null;
  DataInputStream dataInputStream=null;
  BufferedReader reader=null;
  List<String> demos=new LinkedList<String>();
  try {
    fileInputStream=new FileInputStream(modelsFile);
    dataInputStream=new DataInputStream(fileInputStream);
    reader=new BufferedReader(new InputStreamReader(dataInputStream,java.nio.charset.Charset.defaultCharset()));
    String line;
    while ((line=reader.readLine()) != null) {
      String prefix=""String_Node_Str"";
      if (!line.startsWith(prefix)) {
        throw new IOException(""String_Node_Str"" + modelsFile + ""String_Node_Str""+ prefix+ ""String_Node_Str""+ line);
      }
      String modelPath=line.substring(prefix.length());
      if (_openModel(modelPath)) {
        demos.add(modelPath);
      }
    }
  }
 catch (  Exception ex) {
    IOException exception=new IOException(""String_Node_Str"" + modelsFile + ""String_Node_Str"");
    exception.initCause(ex);
    throw exception;
  }
 finally {
    if (reader != null) {
      reader.close();
    }
  }
  int i=0;
  Object[][] data=new Object[demos.size()][1];
  for (  String demo : demos) {
    data[i++][0]=demo;
  }
  return data;
}"
72596,"private static void _loadSemanticFiles(StringBuffer buffer,boolean inline) throws IllegalActionException {
  if (inline) {
    ClassLoader loader=RTMaudeUtility.class.getClassLoader();
    InputStream stream=loader.getResourceAsStream(SEMANTIC_FILE_PATH + ""String_Node_Str"");
    BufferedReader reader=null;
    Stack<BufferedReader> readerStack=null;
    try {
      reader=new BufferedReader(new InputStreamReader(stream));
      readerStack=new Stack<BufferedReader>();
      readerStack.push(null);
      while (!readerStack.isEmpty()) {
        try {
          String line=reader.readLine();
          boolean skip=false;
          while (line != null) {
            String trim=line.trim();
            if (trim.startsWith(""String_Node_Str"")) {
              trim=trim.substring(5).trim();
              stream=loader.getResourceAsStream(SEMANTIC_FILE_PATH + ""String_Node_Str"" + trim+ ""String_Node_Str"");
              if (stream != null) {
                readerStack.push(reader);
                reader=new BufferedReader(new InputStreamReader(stream));
                skip=true;
              }
            }
            if (skip) {
              skip=false;
            }
 else {
              buffer.append(line);
              buffer.append(""String_Node_Str"");
            }
            line=reader.readLine();
          }
        }
 catch (        IOException e) {
          throw new IllegalActionException(""String_Node_Str"");
        }
 finally {
          try {
            if (reader != null) {
              reader.close();
              reader=null;
            }
          }
 catch (          IOException e) {
            throw new IllegalActionException(""String_Node_Str"" + reader);
          }
        }
        reader=readerStack.pop();
      }
    }
  finally {
      if (reader != null) {
        try {
          reader.close();
        }
 catch (        IOException ex) {
          throw new IllegalActionException(""String_Node_Str"" + reader);
        }
      }
      if (readerStack != null) {
        while (!readerStack.isEmpty()) {
          reader=readerStack.pop();
          if (reader != null) {
            try {
              reader.close();
            }
 catch (            IOException ex) {
              throw new IllegalActionException(""String_Node_Str"" + reader);
            }
          }
        }
      }
    }
  }
 else {
    buffer.append(""String_Node_Str"");
  }
}","private static void _loadSemanticFiles(StringBuffer buffer,boolean inline) throws IllegalActionException {
  if (inline) {
    ClassLoader loader=RTMaudeUtility.class.getClassLoader();
    InputStream stream=loader.getResourceAsStream(SEMANTIC_FILE_PATH + ""String_Node_Str"");
    BufferedReader reader=null;
    Stack<BufferedReader> readerStack=null;
    try {
      reader=new BufferedReader(new InputStreamReader(stream,java.nio.charset.Charset.defaultCharset()));
      readerStack=new Stack<BufferedReader>();
      readerStack.push(null);
      while (!readerStack.isEmpty()) {
        try {
          String line=reader.readLine();
          boolean skip=false;
          while (line != null) {
            String trim=line.trim();
            if (trim.startsWith(""String_Node_Str"")) {
              trim=trim.substring(5).trim();
              stream=loader.getResourceAsStream(SEMANTIC_FILE_PATH + ""String_Node_Str"" + trim+ ""String_Node_Str"");
              if (stream != null) {
                readerStack.push(reader);
                reader=new BufferedReader(new InputStreamReader(stream,java.nio.charset.Charset.defaultCharset()));
                skip=true;
              }
            }
            if (skip) {
              skip=false;
            }
 else {
              buffer.append(line);
              buffer.append(""String_Node_Str"");
            }
            line=reader.readLine();
          }
        }
 catch (        IOException e) {
          throw new IllegalActionException(""String_Node_Str"");
        }
 finally {
          try {
            if (reader != null) {
              reader.close();
              reader=null;
            }
          }
 catch (          IOException e) {
            throw new IllegalActionException(""String_Node_Str"" + reader);
          }
        }
        reader=readerStack.pop();
      }
    }
  finally {
      if (reader != null) {
        try {
          reader.close();
        }
 catch (        IOException ex) {
          throw new IllegalActionException(""String_Node_Str"" + reader);
        }
      }
      if (readerStack != null) {
        while (!readerStack.isEmpty()) {
          reader=readerStack.pop();
          if (reader != null) {
            try {
              reader.close();
            }
 catch (            IOException ex) {
              throw new IllegalActionException(""String_Node_Str"" + reader);
            }
          }
        }
      }
    }
  }
 else {
    buffer.append(""String_Node_Str"");
  }
}"
72597,"/** 
 * Override the base class to queue a change request to remove any previously contained entity and its mirrored ports, and to mirror the ports of the added entity.
 * @param entity Entity to contain.
 * @exception IllegalActionException If the entity has no name, or theaction would result in a recursive containment structure, or the argument does not implement the TypedActor interface.
 * @exception NameDuplicationException If the name collides with a namealready on the actor contents list, or if the added element is a class definition.
 */
@Override protected void _addEntity(ComponentEntity entity) throws IllegalActionException, NameDuplicationException {
  if (entity.isClassDefinition()) {
    throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
  }
  super._addEntity(entity);
  ChangeRequest request=new ChangeRequest(this,""String_Node_Str""){
    @Override public NamedObj getLocality(){
      return ReflectComposite.this;
    }
    @Override protected void _execute() throws Exception {
synchronized (this) {
        try {
          workspace().getWriteAccess();
          ComponentEntity entity=null;
          List priorEntities=entityList();
          Iterator priors=priorEntities.iterator();
          while (priors.hasNext()) {
            ComponentEntity prior=(ComponentEntity)priors.next();
            if (priors.hasNext()) {
              prior.setContainer(null);
            }
 else {
              entity=prior;
            }
          }
          if (entity == null) {
            return;
          }
          Iterator entityPorts=entity.portList().iterator();
          while (entityPorts.hasNext()) {
            ComponentPort insidePort=(ComponentPort)entityPorts.next();
            if ((!_mirrorParameterPorts && insidePort instanceof ParameterPort) || !(insidePort instanceof MirrorPort)) {
              continue;
            }
            String name=insidePort.getName();
            IOPort newPort=(IOPort)getPort(name);
            if (newPort == null) {
              newPort=(IOPort)newPort(name);
            }
            if (insidePort instanceof IOPort) {
              IOPort castPort=(IOPort)insidePort;
              newPort.setMultiport(castPort.isMultiport());
              newPort.setInput(castPort.isInput());
              newPort.setOutput(castPort.isOutput());
            }
            List connectedPorts=insidePort.connectedPortList();
            if (!connectedPorts.contains(newPort)) {
              ComponentRelation relation=newRelation(uniqueName(""String_Node_Str""));
              newPort.link(relation);
              insidePort.link(relation);
            }
          }
        }
  finally {
          workspace().doneWriting();
        }
      }
    }
  }
;
  requestChange(request);
}","/** 
 * Override the base class to queue a change request to remove any previously contained entity and its mirrored ports, and to mirror the ports of the added entity.
 * @param entity Entity to contain.
 * @exception IllegalActionException If the entity has no name, or theaction would result in a recursive containment structure, or the argument does not implement the TypedActor interface.
 * @exception NameDuplicationException If the name collides with a namealready on the actor contents list, or if the added element is a class definition.
 */
@Override protected void _addEntity(ComponentEntity entity) throws IllegalActionException, NameDuplicationException {
  if (entity.isClassDefinition()) {
    throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
  }
  super._addEntity(entity);
  ChangeRequest request=new ChangeRequest(this,""String_Node_Str""){
    @Override public NamedObj getLocality(){
      return ReflectComposite.this;
    }
    @Override protected void _execute() throws Exception {
synchronized (ReflectComposite.this) {
        try {
          workspace().getWriteAccess();
          ComponentEntity entity=null;
          List priorEntities=entityList();
          Iterator priors=priorEntities.iterator();
          while (priors.hasNext()) {
            ComponentEntity prior=(ComponentEntity)priors.next();
            if (priors.hasNext()) {
              prior.setContainer(null);
            }
 else {
              entity=prior;
            }
          }
          if (entity == null) {
            return;
          }
          Iterator entityPorts=entity.portList().iterator();
          while (entityPorts.hasNext()) {
            ComponentPort insidePort=(ComponentPort)entityPorts.next();
            if (!_mirrorPort(insidePort)) {
              continue;
            }
            String name=insidePort.getName();
            IOPort newPort=(IOPort)getPort(name);
            if (newPort == null) {
              newPort=(IOPort)newPort(name);
            }
            if (insidePort instanceof IOPort) {
              IOPort castPort=(IOPort)insidePort;
              newPort.setMultiport(castPort.isMultiport());
              newPort.setInput(castPort.isInput());
              newPort.setOutput(castPort.isOutput());
            }
            List connectedPorts=insidePort.connectedPortList();
            if (!connectedPorts.contains(newPort)) {
              ComponentRelation relation=newRelation(uniqueName(""String_Node_Str""));
              newPort.link(relation);
              insidePort.link(relation);
            }
          }
        }
  finally {
          workspace().doneWriting();
        }
      }
    }
  }
;
  requestChange(request);
}"
72598,"/** 
 * Log a message. Note that arguments after the message are currently ignored.
 * @param modelDescription The model description that containsthe names of the variables.  The FMI specification states that the variable names might not be stored in the C-functions, which is why we can't just use the fmiComponent.
 * @param fmiComponent The component that was instantiated.
 * @param instanceName The name of the instance of the FMU.
 * @param status The fmiStatus, see{@link org.ptolemy.fmi.FMILibrary.FMIStatus}
 * @param category The category of the message,defined by the tool that created the fmu.  Typical values are ""log"" or ""error"".
 * @param message The message in printf format
 * @param parameters The printf style parameters.
 */
public static void log(FMIModelDescription modelDescription,Pointer fmiComponent,String instanceName,int status,String category,String message){
  if (_useVariadicExtensions && _pointerClass == null) {
    try {
      _initialize();
    }
 catch (    Throwable throwable) {
      System.out.println(""String_Node_Str"" + throwable);
      _useVariadicExtensions=false;
    }
  }
  if (!_useVariadicExtensions) {
    FMULog._nonVariadicLog(modelDescription,fmiComponent,instanceName,status,category,message,null);
    return;
  }
  try {
    long ffi_cif=((Long)_nativeCif.invoke(null,new Object[]{fmiComponent})).longValue();
    if (ffi_cif != 0) {
      final char[] msg=message.toCharArray();
      StringBuffer out=new StringBuffer();
      boolean foundEscape=false;
      boolean foundHash=false;
      for (int i=0; i < msg.length; i++) {
        if (foundEscape) {
          final char[] conversions=new char[]{'d','i','o','x','X','e','E','f','F','g','G','a','A','c','s','p','n','u','%'};
          StringBuffer flags=new StringBuffer();
          boolean foundConversion=false;
          boolean foundLong=false;
          while (!foundConversion) {
            if (msg[i] == 'l' || msg[i] == 'L') {
              foundLong=true;
            }
            for (            char c : conversions) {
              if (msg[i] == c) {
                foundConversion=true;
                break;
              }
            }
            if (!foundConversion) {
              flags.append(msg[i]);
              i++;
            }
          }
switch (msg[i]) {
case 'd':
case 'i':
            out.append(String.format(""String_Node_Str"" + flags.toString() + msg[i],foundLong ? _ffi_closure_va_sint64.invoke(null,new Object[]{ffi_cif}) : _ffi_closure_va_sint32.invoke(null,new Object[]{ffi_cif})));
          break;
case 'o':
case 'x':
case 'X':
case 'u':
        out.append(String.format(""String_Node_Str"" + flags.toString() + (msg[i] == 'u' ? 'd' : msg[i]),foundLong ? _ffi_closure_va_uint64.invoke(null,new Object[]{ffi_cif}) : _ffi_closure_va_uint32.invoke(null,new Object[]{ffi_cif})));
      break;
case 'e':
case 'E':
case 'f':
case 'F':
case 'g':
case 'G':
case 'a':
case 'A':
    out.append(String.format(""String_Node_Str"" + flags.toString() + msg[i],_ffi_closure_va_double.invoke(null,new Object[]{ffi_cif})));
  break;
case 'c':
out.append(String.format(""String_Node_Str"" + flags.toString() + msg[i],(char)_ffi_closure_va_uint8.invoke(null,new Object[]{ffi_cif})));
break;
case 's':
String formatValue=""String_Node_Str"";
Pointer closureVaPointer=(Pointer)_ffi_closure_va_pointer.invoke(null,new Object[]{ffi_cif});
if (closureVaPointer == null) {
formatValue=""String_Node_Str"";
}
 else {
formatValue=closureVaPointer.getString(0);
}
out.append(String.format(""String_Node_Str"" + flags.toString() + ""String_Node_Str"",formatValue));
break;
case 'p':
out.append(Pointer.nativeValue((Pointer)_ffi_closure_va_pointer.invoke(null,new Object[]{ffi_cif})));
break;
case 'n':
Pointer p=(Pointer)_ffi_closure_va_pointer.invoke(null,new Object[]{ffi_cif});
p.setInt(0,out.length());
break;
case '%':
out.append(""String_Node_Str"");
break;
default :
System.out.println(""String_Node_Str"" + msg[i]);
out.append(msg[i]);
break;
}
foundEscape=false;
}
 else if (foundHash) {
if (msg[i] == '#') {
out.append(""String_Node_Str"");
foundHash=false;
}
 else if (msg[i] == '%') {
foundEscape=true;
}
 else {
out.append(msg[i]);
}
}
 else if (msg[i] == '#') {
out.append(""String_Node_Str"");
if (msg[i + 1] == '#') {
i++;
}
 else {
foundHash=true;
}
}
 else if (msg[i] == '%') {
foundEscape=true;
}
 else {
out.append(msg[i]);
}
}
System.out.println(FMULogUtilities.fmiStatusToString(status) + ""String_Node_Str"" + instanceName+ ""String_Node_Str""+ category+ ""String_Node_Str""+ FMULogUtilities.replaceVariableReferences(modelDescription,out.toString()));
}
}
 catch (Throwable throwable) {
FMULog._nonVariadicLog(modelDescription,fmiComponent,instanceName,status,category,message,null);
}
}","/** 
 * Log a message. Note that arguments after the message are currently ignored.
 * @param modelDescription The model description that containsthe names of the variables.  The FMI specification states that the variable names might not be stored in the C-functions, which is why we can't just use the fmiComponent.
 * @param fmiComponent The component that was instantiated.
 * @param instanceName The name of the instance of the FMU.
 * @param status The fmiStatus, see{@link org.ptolemy.fmi.FMILibrary.FMIStatus}
 * @param category The category of the message,defined by the tool that created the fmu.  Typical values are ""log"" or ""error"".
 * @param message The message in printf format
 * @param parameters The printf style parameters.
 */
public static void log(FMIModelDescription modelDescription,Pointer fmiComponent,String instanceName,int status,String category,String message){
  System.out.println(""String_Node_Str"" + message);
  if (_useVariadicExtensions && _pointerClass == null) {
    try {
      _initialize();
    }
 catch (    Throwable throwable) {
      System.out.println(""String_Node_Str"" + throwable);
      _useVariadicExtensions=false;
    }
  }
  if (!_useVariadicExtensions) {
    System.out.println(""String_Node_Str"" + message);
    FMULog._nonVariadicLog(modelDescription,fmiComponent,instanceName,status,category,message,null);
    return;
  }
  System.out.println(""String_Node_Str"");
  try {
    long ffi_cif=((Long)_nativeCif.invoke(null,new Object[]{fmiComponent})).longValue();
    System.out.println(""String_Node_Str"" + ffi_cif);
    if (ffi_cif != 0) {
      final char[] msg=message.toCharArray();
      StringBuffer out=new StringBuffer();
      boolean foundEscape=false;
      boolean foundHash=false;
      for (int i=0; i < msg.length; i++) {
        if (foundEscape) {
          final char[] conversions=new char[]{'d','i','o','x','X','e','E','f','F','g','G','a','A','c','s','p','n','u','%'};
          StringBuffer flags=new StringBuffer();
          boolean foundConversion=false;
          boolean foundLong=false;
          while (!foundConversion) {
            if (msg[i] == 'l' || msg[i] == 'L') {
              foundLong=true;
            }
            for (            char c : conversions) {
              if (msg[i] == c) {
                foundConversion=true;
                break;
              }
            }
            if (!foundConversion) {
              flags.append(msg[i]);
              i++;
            }
          }
switch (msg[i]) {
case 'd':
case 'i':
            out.append(String.format(""String_Node_Str"" + flags.toString() + msg[i],foundLong ? _ffi_closure_va_sint64.invoke(null,new Object[]{ffi_cif}) : _ffi_closure_va_sint32.invoke(null,new Object[]{ffi_cif})));
          break;
case 'o':
case 'x':
case 'X':
case 'u':
        out.append(String.format(""String_Node_Str"" + flags.toString() + (msg[i] == 'u' ? 'd' : msg[i]),foundLong ? _ffi_closure_va_uint64.invoke(null,new Object[]{ffi_cif}) : _ffi_closure_va_uint32.invoke(null,new Object[]{ffi_cif})));
      break;
case 'e':
case 'E':
case 'f':
case 'F':
case 'g':
case 'G':
case 'a':
case 'A':
    out.append(String.format(""String_Node_Str"" + flags.toString() + msg[i],_ffi_closure_va_double.invoke(null,new Object[]{ffi_cif})));
  break;
case 'c':
out.append(String.format(""String_Node_Str"" + flags.toString() + msg[i],_ffi_closure_va_uint8.invoke(null,new Object[]{ffi_cif})));
break;
case 's':
String formatValue=""String_Node_Str"";
Pointer closureVaPointer=(Pointer)_ffi_closure_va_pointer.invoke(null,new Object[]{ffi_cif});
if (closureVaPointer == null) {
formatValue=""String_Node_Str"";
}
 else {
formatValue=closureVaPointer.getString(0);
}
out.append(String.format(""String_Node_Str"" + flags.toString() + ""String_Node_Str"",formatValue));
break;
case 'p':
out.append(Pointer.nativeValue((Pointer)_ffi_closure_va_pointer.invoke(null,new Object[]{ffi_cif})));
break;
case 'n':
Pointer p=(Pointer)_ffi_closure_va_pointer.invoke(null,new Object[]{ffi_cif});
p.setInt(0,out.length());
break;
case '%':
out.append(""String_Node_Str"");
break;
default :
System.out.println(""String_Node_Str"" + msg[i]);
out.append(msg[i]);
break;
}
foundEscape=false;
}
 else if (foundHash) {
if (msg[i] == '#') {
out.append(""String_Node_Str"");
foundHash=false;
}
 else if (msg[i] == '%') {
foundEscape=true;
}
 else {
out.append(msg[i]);
}
}
 else if (msg[i] == '#') {
out.append(""String_Node_Str"");
if (msg[i + 1] == '#') {
i++;
}
 else {
foundHash=true;
}
}
 else if (msg[i] == '%') {
foundEscape=true;
}
 else {
out.append(msg[i]);
}
}
System.out.println(FMULogUtilities.fmiStatusToString(status) + ""String_Node_Str"" + instanceName+ ""String_Node_Str""+ category+ ""String_Node_Str""+ FMULogUtilities.replaceVariableReferences(modelDescription,out.toString()));
}
}
 catch (Throwable throwable) {
FMULog._nonVariadicLog(modelDescription,fmiComponent,instanceName,status,category,message,null);
}
}"
72599,"/** 
 * Instantiate a Java representation of the C structure that contains the FMI call backs.
 * @param logger The method called to log a status message(C type: fmiCallbackLogger).
 * @param allocateMemory The method called to allocate cleared memory(C type: fmiCallbackAllocateMemory
 * @param freeMemory The method called to free allocated memory(C type: fmiCallbackFreeMemory)
 * @param stepFinished The method called when the step is finished.(C type: FmiStepFinished)
 */
public FMICallbackFunctions(FMICallbackLogger logger,FMICallbackAllocateMemory allocateMemory,FMICallbackFreeMemory freeMemory,FMIStepFinished stepFinished){
  super();
  this.logger=logger;
  this.allocateMemory=allocateMemory;
  this.freeMemory=freeMemory;
  this.stepFinished=stepFinished;
  setAlignType(Structure.ALIGN_GNUC);
}","/** 
 * Instantiate a Java representation of the C structure that contains the FMI call backs.
 * @param logger The method called to log a status message(C type: fmiCallbackLogger).
 * @param allocateMemory The method called to allocate cleared memory(C type: fmiCallbackAllocateMemory
 * @param freeMemory The method called to free allocated memory(C type: fmiCallbackFreeMemory)
 * @param stepFinished The method called when the step is finished.(C type: FmiStepFinished)
 */
public FMICallbackFunctions(FMICallbackLogger logger,FMICallbackAllocateMemory allocateMemory,FMICallbackFreeMemory freeMemory,FMIStepFinished stepFinished){
  super();
  this.logger=logger;
  this.allocateMemory=allocateMemory;
  this.freeMemory=freeMemory;
  this.stepFinished=stepFinished;
}"
72600,"/** 
 * Get the native library of C functions for the current platform. A side effect is that if the native library does not exist, then  {@link org.ptolemy.fmi.FMUBuilder#build(File)} is invoked, which maybuild the shared library.
 * @return The library of functions for the current platform.
 * @exception IOException If the FMU file does not contain binaries for the current platform.
 */
public NativeLibrary getNativeLibrary() throws IOException {
  if (_nativeLibrary != null) {
    return _nativeLibrary;
  }
  String sharedLibrary=getNativeLibraryPath();
  try {
    Map options=new HashMap();
    options.put(Library.OPTION_OPEN_FLAGS,new Integer(1));
    _nativeLibrary=NativeLibrary.getInstance(sharedLibrary,options);
  }
 catch (  Throwable throwable3) {
    IOException exception=new IOException(""String_Node_Str"" + sharedLibrary + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    exception.initCause(throwable3);
    throw exception;
  }
  return _nativeLibrary;
}","/** 
 * Get the native library of C functions for the current platform. A side effect is that if the native library does not exist, then  {@link org.ptolemy.fmi.FMUBuilder#build(File)} is invoked, which maybuild the shared library.
 * @return The library of functions for the current platform.
 * @exception IOException If the FMU file does not contain binaries for the current platform.
 */
public NativeLibrary getNativeLibrary() throws IOException {
  if (_nativeLibrary != null) {
    return _nativeLibrary;
  }
  String sharedLibrary=getNativeLibraryPath();
  try {
    String osName=System.getProperty(""String_Node_Str"").toLowerCase(Locale.getDefault());
    if (osName.startsWith(""String_Node_Str"")) {
      Map options=new HashMap();
      Integer RTLD_LAZY=new Integer(1);
      options.put(Library.OPTION_OPEN_FLAGS,RTLD_LAZY);
      _nativeLibrary=NativeLibrary.getInstance(sharedLibrary,options);
    }
 else {
      _nativeLibrary=NativeLibrary.getInstance(sharedLibrary);
    }
  }
 catch (  Throwable throwable3) {
    IOException exception=new IOException(""String_Node_Str"" + sharedLibrary + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    exception.initCause(throwable3);
    throw exception;
  }
  return _nativeLibrary;
}"
72601,"/** 
 * Log a message. Note that arguments after the message are currently ignored.
 * @param modelDescription The model description that containsthe names of the variables.  The FMI specification states that the variable names might not be stored in the C-functions, which is why we can't just use the fmiComponent.
 * @param fmiComponent The component that was instantiated.
 * @param instanceName The name of the instance of the FMU.
 * @param status The fmiStatus, see{@link org.ptolemy.fmi.FMILibrary.FMIStatus}
 * @param category The category of the message,defined by the tool that created the fmu.  Typical values are ""log"" or ""error"".
 * @param message The message in printf format
 * @param parameters The printf style parameters.
 */
public static void log(FMIModelDescription modelDescription,Pointer fmiComponent,String instanceName,int status,String category,String message){
  System.out.println(""String_Node_Str"" + message);
  if (_useVariadicExtensions && _pointerClass == null) {
    try {
      _initialize();
    }
 catch (    Throwable throwable) {
      _useVariadicExtensions=false;
    }
  }
  if (!_useVariadicExtensions) {
    FMULog._nonVariadicLog(modelDescription,fmiComponent,instanceName,status,category,message,null);
    return;
  }
  try {
    long ffi_cif=((Long)_nativeCif.invoke(null,new Object[]{fmiComponent})).longValue();
    if (ffi_cif == 0) {
      if (!_printedMessage) {
        _printedMessage=true;
        System.err.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
        FMULog._nonVariadicLog(modelDescription,fmiComponent,instanceName,status,category,message,null);
      }
    }
 else {
      final char[] msg=message.toCharArray();
      StringBuffer out=new StringBuffer();
      boolean foundEscape=false;
      boolean foundHash=false;
      for (int i=0; i < msg.length; i++) {
        if (foundEscape) {
          final char[] conversions=new char[]{'d','i','o','x','X','e','E','f','F','g','G','a','A','c','s','p','n','u','%'};
          StringBuffer flags=new StringBuffer();
          boolean foundConversion=false;
          boolean foundLong=false;
          while (!foundConversion) {
            if (msg[i] == 'l' || msg[i] == 'L') {
              foundLong=true;
            }
            for (            char c : conversions) {
              if (msg[i] == c) {
                foundConversion=true;
                break;
              }
            }
            if (!foundConversion) {
              flags.append(msg[i]);
              i++;
            }
          }
switch (msg[i]) {
case 'd':
case 'i':
            out.append(String.format(""String_Node_Str"" + flags.toString() + msg[i],foundLong ? _ffi_closure_va_sint64.invoke(null,new Object[]{ffi_cif}) : _ffi_closure_va_sint32.invoke(null,new Object[]{ffi_cif})));
          break;
case 'o':
case 'x':
case 'X':
case 'u':
        out.append(String.format(""String_Node_Str"" + flags.toString() + (msg[i] == 'u' ? 'd' : msg[i]),foundLong ? _ffi_closure_va_uint64.invoke(null,new Object[]{ffi_cif}) : _ffi_closure_va_uint32.invoke(null,new Object[]{ffi_cif})));
      break;
case 'e':
case 'E':
case 'f':
case 'F':
case 'g':
case 'G':
case 'a':
case 'A':
    out.append(String.format(""String_Node_Str"" + flags.toString() + msg[i],_ffi_closure_va_double.invoke(null,new Object[]{ffi_cif})));
  break;
case 'c':
out.append(String.format(""String_Node_Str"" + flags.toString() + msg[i],_ffi_closure_va_uint8.invoke(null,new Object[]{ffi_cif})));
break;
case 's':
String formatValue=""String_Node_Str"";
Pointer closureVaPointer=(Pointer)_ffi_closure_va_pointer.invoke(null,new Object[]{ffi_cif});
if (closureVaPointer == null) {
formatValue=""String_Node_Str"";
}
 else {
formatValue=closureVaPointer.getString(0);
}
out.append(String.format(""String_Node_Str"" + flags.toString() + ""String_Node_Str"",formatValue));
break;
case 'p':
out.append(Pointer.nativeValue((Pointer)_ffi_closure_va_pointer.invoke(null,new Object[]{ffi_cif})));
break;
case 'n':
Pointer p=(Pointer)_ffi_closure_va_pointer.invoke(null,new Object[]{ffi_cif});
p.setInt(0,out.length());
break;
case '%':
out.append(""String_Node_Str"");
break;
default :
System.out.println(""String_Node_Str"" + msg[i]);
out.append(msg[i]);
break;
}
foundEscape=false;
}
 else if (foundHash) {
if (msg[i] == '#') {
out.append(""String_Node_Str"");
foundHash=false;
}
 else if (msg[i] == '%') {
foundEscape=true;
}
 else {
out.append(msg[i]);
}
}
 else if (msg[i] == '#') {
out.append(""String_Node_Str"");
if (msg[i + 1] == '#') {
i++;
}
 else {
foundHash=true;
}
}
 else if (msg[i] == '%') {
foundEscape=true;
}
 else {
out.append(msg[i]);
}
}
System.out.println(FMULogUtilities.fmiStatusToString(status) + ""String_Node_Str"" + instanceName+ ""String_Node_Str""+ category+ ""String_Node_Str""+ FMULogUtilities.replaceVariableReferences(modelDescription,out.toString()));
}
}
 catch (Throwable throwable) {
FMULog._nonVariadicLog(modelDescription,fmiComponent,instanceName,status,category,message,null);
}
}","/** 
 * Log a message. Note that arguments after the message are currently ignored.
 * @param modelDescription The model description that containsthe names of the variables.  The FMI specification states that the variable names might not be stored in the C-functions, which is why we can't just use the fmiComponent.
 * @param fmiComponent The component that was instantiated.
 * @param instanceName The name of the instance of the FMU.
 * @param status The fmiStatus, see{@link org.ptolemy.fmi.FMILibrary.FMIStatus}
 * @param category The category of the message,defined by the tool that created the fmu.  Typical values are ""log"" or ""error"".
 * @param message The message in printf format
 * @param parameters The printf style parameters.
 */
public static void log(FMIModelDescription modelDescription,Pointer fmiComponent,String instanceName,int status,String category,String message){
  if (_useVariadicExtensions && _pointerClass == null) {
    try {
      _initialize();
    }
 catch (    Throwable throwable) {
      _useVariadicExtensions=false;
    }
  }
  if (!_useVariadicExtensions) {
    FMULog._nonVariadicLog(modelDescription,fmiComponent,instanceName,status,category,message,null);
    return;
  }
  try {
    long ffi_cif=((Long)_nativeCif.invoke(null,new Object[]{fmiComponent})).longValue();
    if (ffi_cif == 0) {
      if (!_printedMessage) {
        _printedMessage=true;
        System.err.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
        FMULog._nonVariadicLog(modelDescription,fmiComponent,instanceName,status,category,message,null);
      }
    }
 else {
      final char[] msg=message.toCharArray();
      StringBuffer out=new StringBuffer();
      boolean foundEscape=false;
      boolean foundHash=false;
      for (int i=0; i < msg.length; i++) {
        if (foundEscape) {
          final char[] conversions=new char[]{'d','i','o','x','X','e','E','f','F','g','G','a','A','c','s','p','n','u','%'};
          StringBuffer flags=new StringBuffer();
          boolean foundConversion=false;
          boolean foundLong=false;
          while (!foundConversion) {
            if (msg[i] == 'l' || msg[i] == 'L') {
              foundLong=true;
            }
            for (            char c : conversions) {
              if (msg[i] == c) {
                foundConversion=true;
                break;
              }
            }
            if (!foundConversion) {
              flags.append(msg[i]);
              i++;
            }
          }
switch (msg[i]) {
case 'd':
case 'i':
            out.append(String.format(""String_Node_Str"" + flags.toString() + msg[i],foundLong ? _ffi_closure_va_sint64.invoke(null,new Object[]{ffi_cif}) : _ffi_closure_va_sint32.invoke(null,new Object[]{ffi_cif})));
          break;
case 'o':
case 'x':
case 'X':
case 'u':
        out.append(String.format(""String_Node_Str"" + flags.toString() + (msg[i] == 'u' ? 'd' : msg[i]),foundLong ? _ffi_closure_va_uint64.invoke(null,new Object[]{ffi_cif}) : _ffi_closure_va_uint32.invoke(null,new Object[]{ffi_cif})));
      break;
case 'e':
case 'E':
case 'f':
case 'F':
case 'g':
case 'G':
case 'a':
case 'A':
    out.append(String.format(""String_Node_Str"" + flags.toString() + msg[i],_ffi_closure_va_double.invoke(null,new Object[]{ffi_cif})));
  break;
case 'c':
out.append(String.format(""String_Node_Str"" + flags.toString() + msg[i],_ffi_closure_va_uint8.invoke(null,new Object[]{ffi_cif})));
break;
case 's':
String formatValue=""String_Node_Str"";
Pointer closureVaPointer=(Pointer)_ffi_closure_va_pointer.invoke(null,new Object[]{ffi_cif});
if (closureVaPointer == null) {
formatValue=""String_Node_Str"";
}
 else {
formatValue=closureVaPointer.getString(0);
}
out.append(String.format(""String_Node_Str"" + flags.toString() + ""String_Node_Str"",formatValue));
break;
case 'p':
out.append(Pointer.nativeValue((Pointer)_ffi_closure_va_pointer.invoke(null,new Object[]{ffi_cif})));
break;
case 'n':
Pointer p=(Pointer)_ffi_closure_va_pointer.invoke(null,new Object[]{ffi_cif});
p.setInt(0,out.length());
break;
case '%':
out.append(""String_Node_Str"");
break;
default :
System.out.println(""String_Node_Str"" + msg[i]);
out.append(msg[i]);
break;
}
foundEscape=false;
}
 else if (foundHash) {
if (msg[i] == '#') {
out.append(""String_Node_Str"");
foundHash=false;
}
 else if (msg[i] == '%') {
foundEscape=true;
}
 else {
out.append(msg[i]);
}
}
 else if (msg[i] == '#') {
out.append(""String_Node_Str"");
if (msg[i + 1] == '#') {
i++;
}
 else {
foundHash=true;
}
}
 else if (msg[i] == '%') {
foundEscape=true;
}
 else {
out.append(msg[i]);
}
}
System.out.println(FMULogUtilities.fmiStatusToString(status) + ""String_Node_Str"" + instanceName+ ""String_Node_Str""+ category+ ""String_Node_Str""+ FMULogUtilities.replaceVariableReferences(modelDescription,out.toString()));
}
}
 catch (Throwable throwable) {
FMULog._nonVariadicLog(modelDescription,fmiComponent,instanceName,status,category,message,null);
}
}"
72602,"/** 
 * Perform co-simulation using the named Functional Mock-up Unit (FMU) file.
 * @param fmuFileName The pathname of the co-simulation .fmu file
 * @param endTime The ending time in seconds.
 * @param stepSize The step size in seconds.
 * @param enableLogging True if logging is enabled.
 * @param csvSeparator The character used for separating fields.Note that sometimes the decimal point in floats is converted to ','.
 * @param outputFileName The output file.
 * @exception Exception If there is a problem parsing the .fmu file or invokingthe methods in the shared library.
 */
@Override public void simulate(String fmuFileName,double endTime,double stepSize,boolean enableLogging,char csvSeparator,String outputFileName) throws Exception {
  _setEnableLogging(enableLogging);
  FMIModelDescription fmiModelDescription=FMUFile.parseFMUFile(fmuFileName);
  _nativeLibrary=fmiModelDescription.getNativeLibrary();
  _modelIdentifier=fmiModelDescription.modelIdentifier;
  String fmuLocation=new File(fmuFileName).toURI().toURL().toString();
  String mimeType=""String_Node_Str"";
  double timeout=1000;
  byte visible=0;
  int toBeVisibleFMI2=0;
  byte interactive=0;
  byte loggingOn=enableLogging ? (byte)1 : (byte)0;
  int loggingOnFMI2=_enableLogging ? 1 : 0;
  _fmiVersion=Double.valueOf(fmiModelDescription.fmiVersion);
  Pointer fmiComponent=null;
  if (_fmiVersion < 1.5) {
    FMICallbackFunctions.ByValue callbacks=new FMICallbackFunctions.ByValue(new FMULibrary.FMULogger(fmiModelDescription),fmiModelDescription.getFMUAllocateMemory(),new FMULibrary.FMUFreeMemory(),new FMULibrary.FMUStepFinished());
    Function instantiateSlave=fmiModelDescription.getFmiFunction(""String_Node_Str"");
    System.out.println(""String_Node_Str"" + instantiateSlave);
    fmiComponent=(Pointer)instantiateSlave.invoke(Pointer.class,new Object[]{_modelIdentifier,fmiModelDescription.guid,fmuLocation,mimeType,timeout,visible,interactive,callbacks,loggingOn});
  }
 else {
    FMICallbackFunctions callbacks=new FMICallbackFunctions(new FMULibrary.FMULogger(fmiModelDescription),new FMULibrary.FMUAllocateMemory(),new FMULibrary.FMUFreeMemory(),new FMULibrary.FMUStepFinished());
    Function fmiInstantiateFunction=fmiModelDescription.getFmiFunction(""String_Node_Str"");
    byte toBeVisible=0;
    int fmiType=1;
    if (fmiModelDescription.modelExchange) {
      fmiType=0;
    }
    fmiComponent=(Pointer)fmiInstantiateFunction.invoke(Pointer.class,new Object[]{_modelIdentifier,fmiType,fmiModelDescription.guid,fmiModelDescription.fmuResourceLocation,callbacks,toBeVisibleFMI2,loggingOnFMI2});
  }
  if (fmiComponent.equals(Pointer.NULL)) {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (enableLogging) {
    System.out.println(""String_Node_Str"");
  }
  double startTime=0;
  if (enableLogging) {
    System.out.println(""String_Node_Str"");
  }
  if (_fmiVersion < 1.5) {
    invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent,startTime,(byte)1,endTime},""String_Node_Str"");
  }
 else {
    double relativeTolerance=1e-4;
    byte _toleranceControlled=(byte)0;
    invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent,_toleranceControlled,relativeTolerance,startTime,(byte)1,endTime},""String_Node_Str"");
    invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent},""String_Node_Str"");
    invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent},""String_Node_Str"");
  }
  File outputFile=new File(outputFileName);
  PrintStream file=null;
  try {
    file=new PrintStream(outputFileName);
    if (enableLogging) {
      System.out.println(""String_Node_Str"");
    }
    OutputRow.outputRow(_nativeLibrary,fmiModelDescription,fmiComponent,startTime,file,csvSeparator,Boolean.TRUE);
    OutputRow.outputRow(_nativeLibrary,fmiModelDescription,fmiComponent,startTime,file,csvSeparator,Boolean.FALSE);
    double time=startTime;
    Function doStep=fmiModelDescription.getFmiFunction(""String_Node_Str"");
    while (time < endTime) {
      if (enableLogging) {
        System.out.println(""String_Node_Str"" + _modelIdentifier + ""String_Node_Str""+ time+ ""String_Node_Str""+ stepSize+ ""String_Node_Str"");
      }
      invoke(doStep,new Object[]{fmiComponent,time,stepSize,(byte)1},""String_Node_Str"" + time + ""String_Node_Str"");
      time+=stepSize;
      OutputRow.outputRow(_nativeLibrary,fmiModelDescription,fmiComponent,time,file,csvSeparator,Boolean.FALSE);
    }
    if (_fmiVersion < 2.0) {
      invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent},""String_Node_Str"");
      Function freeSlave=fmiModelDescription.getFmiFunction(""String_Node_Str"");
      int fmiFlag=((Integer)freeSlave.invoke(Integer.class,new Object[]{fmiComponent})).intValue();
      if (fmiFlag >= FMILibrary.FMIStatus.fmiWarning) {
        new Exception(""String_Node_Str"" + fmiFlag).printStackTrace();
      }
    }
 else {
      invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent},""String_Node_Str"");
      invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent},""String_Node_Str"");
    }
  }
  finally {
    if (file != null) {
      file.close();
    }
    if (fmiModelDescription != null) {
      fmiModelDescription.dispose();
    }
  }
  if (enableLogging) {
    System.out.println(""String_Node_Str"" + outputFile.getCanonicalPath());
    System.out.flush();
  }
}","/** 
 * Perform co-simulation using the named Functional Mock-up Unit (FMU) file.
 * @param fmuFileName The pathname of the co-simulation .fmu file
 * @param endTime The ending time in seconds.
 * @param stepSize The step size in seconds.
 * @param enableLogging True if logging is enabled.
 * @param csvSeparator The character used for separating fields.Note that sometimes the decimal point in floats is converted to ','.
 * @param outputFileName The output file.
 * @exception Exception If there is a problem parsing the .fmu file or invokingthe methods in the shared library.
 */
@Override public void simulate(String fmuFileName,double endTime,double stepSize,boolean enableLogging,char csvSeparator,String outputFileName) throws Exception {
  _setEnableLogging(enableLogging);
  FMIModelDescription fmiModelDescription=FMUFile.parseFMUFile(fmuFileName);
  _nativeLibrary=fmiModelDescription.getNativeLibrary();
  _modelIdentifier=fmiModelDescription.modelIdentifier;
  String fmuLocation=new File(fmuFileName).toURI().toURL().toString();
  String mimeType=""String_Node_Str"";
  double timeout=1000;
  byte visible=0;
  int toBeVisibleFMI2=0;
  byte interactive=0;
  byte loggingOn=enableLogging ? (byte)1 : (byte)0;
  int loggingOnFMI2=_enableLogging ? 1 : 0;
  _fmiVersion=Double.valueOf(fmiModelDescription.fmiVersion);
  Pointer fmiComponent=null;
  if (_fmiVersion < 1.5) {
    FMICallbackFunctions.ByValue callbacks=new FMICallbackFunctions.ByValue(new FMULibrary.FMULogger(fmiModelDescription),fmiModelDescription.getFMUAllocateMemory(),new FMULibrary.FMUFreeMemory(),new FMULibrary.FMUStepFinished());
    Function instantiateSlave=fmiModelDescription.getFmiFunction(""String_Node_Str"");
    fmiComponent=(Pointer)instantiateSlave.invoke(Pointer.class,new Object[]{_modelIdentifier,fmiModelDescription.guid,fmuLocation,mimeType,timeout,visible,interactive,callbacks,loggingOn});
  }
 else {
    FMI20CallbackFunctions callbacks20=new FMI20CallbackFunctions(new FMULibrary.FMULogger(fmiModelDescription),fmiModelDescription.getFMUAllocateMemory(),new FMULibrary.FMUFreeMemory(),new FMULibrary.FMUStepFinished(),fmiComponent);
    Function fmiInstantiateFunction=fmiModelDescription.getFmiFunction(""String_Node_Str"");
    int fmiType=1;
    if (fmiModelDescription.modelExchange) {
      fmiType=0;
    }
    fmiComponent=(Pointer)fmiInstantiateFunction.invoke(Pointer.class,new Object[]{_modelIdentifier,fmiType,fmiModelDescription.guid,fmiModelDescription.fmuResourceLocation,callbacks20,toBeVisibleFMI2,loggingOnFMI2});
  }
  if (fmiComponent.equals(Pointer.NULL)) {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (enableLogging) {
    System.out.println(""String_Node_Str"");
  }
  double startTime=0;
  if (enableLogging) {
    System.out.println(""String_Node_Str"");
  }
  if (_fmiVersion < 1.5) {
    invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent,startTime,(byte)1,endTime},""String_Node_Str"");
  }
 else {
    double relativeTolerance=1e-4;
    byte _toleranceControlled=(byte)0;
    invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent,_toleranceControlled,relativeTolerance,startTime,(byte)1,endTime},""String_Node_Str"");
    invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent},""String_Node_Str"");
    invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent},""String_Node_Str"");
  }
  File outputFile=new File(outputFileName);
  PrintStream file=null;
  try {
    file=new PrintStream(outputFileName);
    if (enableLogging) {
      System.out.println(""String_Node_Str"");
    }
    OutputRow.outputRow(_nativeLibrary,fmiModelDescription,fmiComponent,startTime,file,csvSeparator,Boolean.TRUE);
    OutputRow.outputRow(_nativeLibrary,fmiModelDescription,fmiComponent,startTime,file,csvSeparator,Boolean.FALSE);
    double time=startTime;
    Function doStep=fmiModelDescription.getFmiFunction(""String_Node_Str"");
    while (time < endTime) {
      if (enableLogging) {
        System.out.println(""String_Node_Str"" + _modelIdentifier + ""String_Node_Str""+ time+ ""String_Node_Str""+ stepSize+ ""String_Node_Str"");
      }
      invoke(doStep,new Object[]{fmiComponent,time,stepSize,(byte)1},""String_Node_Str"" + time + ""String_Node_Str"");
      time+=stepSize;
      OutputRow.outputRow(_nativeLibrary,fmiModelDescription,fmiComponent,time,file,csvSeparator,Boolean.FALSE);
    }
    if (_fmiVersion < 2.0) {
      invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent},""String_Node_Str"");
      Function freeSlave=fmiModelDescription.getFmiFunction(""String_Node_Str"");
      int fmiFlag=((Integer)freeSlave.invoke(Integer.class,new Object[]{fmiComponent})).intValue();
      if (fmiFlag >= FMILibrary.FMIStatus.fmiWarning) {
        new Exception(""String_Node_Str"" + fmiFlag).printStackTrace();
      }
    }
 else {
      invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent},""String_Node_Str"");
      invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent},""String_Node_Str"");
    }
  }
  finally {
    if (file != null) {
      file.close();
    }
    if (fmiModelDescription != null) {
      fmiModelDescription.dispose();
    }
  }
  if (enableLogging) {
    System.out.println(""String_Node_Str"" + outputFile.getCanonicalPath());
    System.out.flush();
  }
}"
72603,"/** 
 * Perform model exchange using the named Functional Mock-up Unit (FMU) file.
 * @param fmuFileName The pathname of the co-simulation .fmu file
 * @param endTime The ending time in seconds.
 * @param stepSize The step size in seconds.
 * @param enableLogging True if logging is enabled.
 * @param csvSeparator The character used for separating fields.Note that sometimes the decimal point in floats is converted to ','.
 * @param outputFileName The output file.
 * @exception Exception If there is a problem parsing the .fmu file or invokingthe methods in the shared library.
 */
@Override public void simulate(String fmuFileName,double endTime,double stepSize,boolean enableLogging,char csvSeparator,String outputFileName) throws Exception {
  _setEnableLogging(enableLogging);
  FMIModelDescription fmiModelDescription=FMUFile.parseFMUFile(fmuFileName);
  _nativeLibrary=fmiModelDescription.getNativeLibrary();
  _modelIdentifier=fmiModelDescription.modelIdentifier;
  new File(fmuFileName).toURI().toURL().toString();
  int numberOfStateEvents=0;
  int numberOfStepEvents=0;
  int numberOfSteps=0;
  int numberOfTimeEvents=0;
  byte loggingOn=enableLogging ? (byte)1 : (byte)0;
  int loggingOnFMI2=_enableLogging ? 1 : 0;
  _fmiVersion=Double.valueOf(fmiModelDescription.fmiVersion);
  Pointer fmiComponent=null;
  if (_fmiVersion < 1.5) {
    FMICallbackFunctions.ByValue callbacks=new FMICallbackFunctions.ByValue(new FMULibrary.FMULogger(fmiModelDescription),fmiModelDescription.getFMUAllocateMemory(),new FMULibrary.FMUFreeMemory(),new FMULibrary.FMUStepFinished());
    Function instantiateModelFunction;
    try {
      instantiateModelFunction=fmiModelDescription.getFmiFunction(""String_Node_Str"");
    }
 catch (    UnsatisfiedLinkError ex) {
      UnsatisfiedLinkError error=new UnsatisfiedLinkError(""String_Node_Str"" + _modelIdentifier + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      error.initCause(ex);
      throw error;
    }
    fmiComponent=(Pointer)instantiateModelFunction.invoke(Pointer.class,new Object[]{_modelIdentifier,fmiModelDescription.guid,callbacks,loggingOn});
  }
 else {
    FMICallbackFunctions callbacks=new FMICallbackFunctions(new FMULibrary.FMULogger(fmiModelDescription),new FMULibrary.FMUAllocateMemory(),new FMULibrary.FMUFreeMemory(),new FMULibrary.FMUStepFinished());
    Function fmiInstantiateFunction=fmiModelDescription.getFmiFunction(""String_Node_Str"");
    byte toBeVisible=0;
    int toBeVisibleFMI2=0;
    int fmiType=1;
    if (fmiModelDescription.modelExchange) {
      fmiType=0;
    }
    fmiComponent=(Pointer)fmiInstantiateFunction.invoke(Pointer.class,new Object[]{_modelIdentifier,fmiType,fmiModelDescription.guid,fmiModelDescription.fmuResourceLocation,callbacks,toBeVisibleFMI2,loggingOnFMI2});
  }
  if (fmiComponent.equals(Pointer.NULL)) {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (enableLogging) {
    System.out.println(""String_Node_Str"");
  }
  final int numberOfStates=fmiModelDescription.numberOfContinuousStates;
  final int numberOfEventIndicators=fmiModelDescription.numberOfEventIndicators;
  double[] states=new double[numberOfStates];
  double[] derivatives=new double[numberOfStates];
  double[] eventIndicators=null;
  double[] preEventIndicators=null;
  if (numberOfEventIndicators > 0) {
    eventIndicators=new double[numberOfEventIndicators];
    preEventIndicators=new double[numberOfEventIndicators];
  }
  double startTime=0.0;
  Function setTime=fmiModelDescription.getFmiFunction(""String_Node_Str"");
  invoke(setTime,new Object[]{fmiComponent,startTime},""String_Node_Str"" + startTime + ""String_Node_Str"");
  byte toleranceControlled=0;
  FMIEventInfo eventInfo=null;
  FMI20EventInfo eventInfo20=null;
  FMI20EventInfo.ByReference eventInfo20Reference=null;
  if (_fmiVersion < 1.5) {
    eventInfo=new FMIEventInfo();
    invoke(setTime,new Object[]{fmiComponent,startTime},""String_Node_Str"" + startTime + ""String_Node_Str"");
    invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent,toleranceControlled,startTime,eventInfo},""String_Node_Str"");
  }
 else {
    eventInfo20=new FMI20EventInfo();
    double relativeTolerance=1e-4;
    byte _toleranceControlled=(byte)0;
    invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent,_toleranceControlled,relativeTolerance,startTime,(byte)1,endTime},""String_Node_Str"");
    invoke(setTime,new Object[]{fmiComponent,startTime},""String_Node_Str"" + startTime + ""String_Node_Str"");
    invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent},""String_Node_Str"");
    invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent},""String_Node_Str"");
    eventInfo20.newDiscreteStatesNeeded=(byte)1;
    eventInfo20.terminateSimulation=(byte)0;
    System.out.println(""String_Node_Str"" + eventInfo20.toString());
    while (eventInfo20.newDiscreteStatesNeeded == (byte)1 && !(eventInfo20.terminateSimulation == (byte)1)) {
      eventInfo20Reference=new FMI20EventInfo.ByReference(eventInfo20);
      System.out.println(""String_Node_Str"" + eventInfo20Reference.toString());
      invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent,eventInfo20Reference},""String_Node_Str"");
    }
  }
  double time=startTime;
  if (eventInfo20 != null && eventInfo20.terminateSimulation != 0) {
    System.out.println(""String_Node_Str"" + time);
    endTime=time;
  }
  if ((eventInfo20 != null && eventInfo20.terminateSimulation != 1) || _fmiVersion < 1.5) {
    if (_fmiVersion > 1.5) {
      invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent},""String_Node_Str"");
    }
    PrintStream file=null;
    try {
      file=new PrintStream(outputFileName);
      if (enableLogging) {
        System.out.println(""String_Node_Str"");
      }
      OutputRow.outputRow(_nativeLibrary,fmiModelDescription,fmiComponent,startTime,file,csvSeparator,Boolean.TRUE);
      OutputRow.outputRow(_nativeLibrary,fmiModelDescription,fmiComponent,startTime,file,csvSeparator,Boolean.FALSE);
      Function completedIntegratorStep=fmiModelDescription.getFmiFunction(""String_Node_Str"");
      Function eventUpdate=null;
      if (_fmiVersion < 1.5) {
        eventUpdate=fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
      Function getContinuousStates=fmiModelDescription.getFmiFunction(""String_Node_Str"");
      Function getDerivatives=fmiModelDescription.getFmiFunction(""String_Node_Str"");
      Function getEventIndicators=fmiModelDescription.getFmiFunction(""String_Node_Str"");
      Function setContinuousStates=fmiModelDescription.getFmiFunction(""String_Node_Str"");
      boolean stateEvent=false;
      byte stepEvent=(byte)0;
      while (time < endTime) {
        invoke(getContinuousStates,new Object[]{fmiComponent,states,numberOfStates},""String_Node_Str"" + time + ""String_Node_Str"");
        invoke(getDerivatives,new Object[]{fmiComponent,derivatives,numberOfStates},""String_Node_Str"" + time + ""String_Node_Str"");
        double stepStartTime=time;
        time=Math.min(time + stepSize,endTime);
        boolean timeEvent=false;
        if (_fmiVersion < 1.5) {
          timeEvent=eventInfo.upcomingTimeEvent == 1 && eventInfo.nextEventTime < time;
        }
 else {
          timeEvent=eventInfo20.nextEventTimeDefined == 1 && eventInfo20.nextEventTime < time;
        }
        if (timeEvent) {
          time=eventInfo.nextEventTime;
        }
        double dt=time - stepStartTime;
        invoke(setTime,new Object[]{fmiComponent,time},""String_Node_Str"" + time + ""String_Node_Str"");
        for (int i=0; i < numberOfStates; i++) {
          states[i]+=dt * derivatives[i];
        }
        invoke(setContinuousStates,new Object[]{fmiComponent,states,numberOfStates},""String_Node_Str"" + time + ""String_Node_Str"");
        if (enableLogging) {
          System.out.println(""String_Node_Str"" + numberOfSteps + ""String_Node_Str""+ time);
        }
        if (_fmiVersion > 1.5) {
          for (int i=0; i < numberOfEventIndicators; i++) {
            preEventIndicators[i]=eventIndicators[i];
          }
          invoke(getEventIndicators,new Object[]{fmiComponent,eventIndicators,numberOfEventIndicators},""String_Node_Str"" + time + ""String_Node_Str"");
          stateEvent=false;
          for (int i=0; i < numberOfEventIndicators; i++) {
            stateEvent=stateEvent || (preEventIndicators[i] * eventIndicators[i] < 0);
          }
        }
        if (_fmiVersion < 1.5) {
          ByteByReference stepEventReference=new ByteByReference(stepEvent);
          invoke(completedIntegratorStep,new Object[]{fmiComponent,stepEventReference},""String_Node_Str"" + time + ""String_Node_Str"");
          for (int i=0; i < numberOfEventIndicators; i++) {
            preEventIndicators[i]=eventIndicators[i];
          }
        }
 else {
          ByteByReference stepEventReference=new ByteByReference(stepEvent);
          Byte terminateSimulation=(byte)0;
          ByteByReference terminateSimulationReference=new ByteByReference(terminateSimulation);
          invoke(completedIntegratorStep,new Object[]{fmiComponent,(byte)1,stepEventReference,terminateSimulationReference},""String_Node_Str"" + time + ""String_Node_Str"");
          if (terminateSimulation != (byte)0) {
            System.out.println(""String_Node_Str"" + time);
            break;
          }
        }
        if (_fmiVersion < 1.5) {
          invoke(getEventIndicators,new Object[]{fmiComponent,eventIndicators,numberOfEventIndicators},""String_Node_Str"" + time + ""String_Node_Str"");
          stateEvent=Boolean.FALSE;
          for (int i=0; i < numberOfEventIndicators; i++) {
            stateEvent=stateEvent || preEventIndicators[i] * eventIndicators[i] < 0;
          }
        }
        if (stateEvent || stepEvent != (byte)0 || timeEvent) {
          if (stateEvent) {
            numberOfStateEvents++;
            if (enableLogging) {
              for (int i=0; i < numberOfEventIndicators; i++) {
                System.out.println(""String_Node_Str"" + (preEventIndicators[i] > 0 && eventIndicators[i] < 0 ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ i+ ""String_Node_Str""+ time);
              }
            }
          }
          if (stepEvent != (byte)0) {
            numberOfStepEvents++;
            if (enableLogging) {
              System.out.println(""String_Node_Str"" + time);
            }
          }
          if (timeEvent) {
            numberOfTimeEvents++;
            if (enableLogging) {
              System.out.println(""String_Node_Str"" + time);
            }
          }
          if (_fmiVersion < 1.5) {
            invoke(eventUpdate,new Object[]{fmiComponent,(byte)0,eventInfo},""String_Node_Str"" + time + ""String_Node_Str"");
            if (eventInfo.stateValuesChanged != (byte)0 && enableLogging) {
              System.out.println(""String_Node_Str"" + time);
            }
            if (eventInfo.stateValueReferencesChanged != (byte)0 && enableLogging) {
              System.out.println(""String_Node_Str"" + time);
            }
          }
 else {
            eventInfo20.newDiscreteStatesNeeded=(byte)1;
            eventInfo20.terminateSimulation=(byte)0;
            while ((eventInfo20.newDiscreteStatesNeeded == (byte)1) && !(eventInfo20.terminateSimulation == (byte)1)) {
              eventInfo20Reference=new FMI20EventInfo.ByReference(eventInfo20);
              invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent,eventInfo20Reference},""String_Node_Str"");
            }
            if (eventInfo20.terminateSimulation != (byte)0) {
              System.out.println(""String_Node_Str"" + time);
              break;
            }
            invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent},""String_Node_Str"");
            if ((eventInfo20.valuesOfContinuousStatesChanged == (byte)1) && enableLogging) {
              System.out.println(""String_Node_Str"" + time);
            }
            if ((eventInfo20.nominalsOfContinuousStatesChanged == (byte)1) && enableLogging) {
              System.out.println(""String_Node_Str"" + time);
            }
          }
        }
        OutputRow.outputRow(_nativeLibrary,fmiModelDescription,fmiComponent,time,file,csvSeparator,Boolean.FALSE);
        numberOfSteps++;
      }
      if (_fmiVersion < 1.5) {
        invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent},""String_Node_Str"");
        Function freeModelInstance=fmiModelDescription.getFmiFunction(""String_Node_Str"");
        int fmiFlag=((Integer)freeModelInstance.invoke(Integer.class,new Object[]{fmiComponent})).intValue();
        if (fmiFlag >= FMILibrary.FMIStatus.fmiWarning) {
          System.err.println(""String_Node_Str"" + FMIModelDescription.fmiStatusDescription(fmiFlag));
        }
      }
 else {
        if (!(eventInfo20.terminateSimulation == 1)) {
          invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent},""String_Node_Str"");
        }
        invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent},""String_Node_Str"");
      }
    }
  finally {
      if (file != null) {
        file.close();
      }
      if (fmiModelDescription != null) {
        fmiModelDescription.dispose();
      }
    }
  }
  System.out.println(""String_Node_Str"" + startTime + ""String_Node_Str""+ endTime+ ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + numberOfSteps);
  System.out.println(""String_Node_Str"" + stepSize);
  System.out.println(""String_Node_Str"" + numberOfStateEvents);
  System.out.println(""String_Node_Str"" + numberOfStepEvents);
  System.out.println(""String_Node_Str"" + numberOfTimeEvents);
  System.out.flush();
}","/** 
 * Perform model exchange using the named Functional Mock-up Unit (FMU) file.
 * @param fmuFileName The pathname of the co-simulation .fmu file
 * @param endTime The ending time in seconds.
 * @param stepSize The step size in seconds.
 * @param enableLogging True if logging is enabled.
 * @param csvSeparator The character used for separating fields.Note that sometimes the decimal point in floats is converted to ','.
 * @param outputFileName The output file.
 * @exception Exception If there is a problem parsing the .fmu file or invokingthe methods in the shared library.
 */
@Override public void simulate(String fmuFileName,double endTime,double stepSize,boolean enableLogging,char csvSeparator,String outputFileName) throws Exception {
  _setEnableLogging(enableLogging);
  FMIModelDescription fmiModelDescription=FMUFile.parseFMUFile(fmuFileName);
  _nativeLibrary=fmiModelDescription.getNativeLibrary();
  _modelIdentifier=fmiModelDescription.modelIdentifier;
  new File(fmuFileName).toURI().toURL().toString();
  int numberOfStateEvents=0;
  int numberOfStepEvents=0;
  int numberOfSteps=0;
  int numberOfTimeEvents=0;
  byte loggingOn=enableLogging ? (byte)1 : (byte)0;
  int loggingOnFMI2=_enableLogging ? 1 : 0;
  _fmiVersion=Double.valueOf(fmiModelDescription.fmiVersion);
  Pointer fmiComponent=null;
  if (_fmiVersion < 1.5) {
    FMICallbackFunctions.ByValue callbacks=new FMICallbackFunctions.ByValue(new FMULibrary.FMULogger(fmiModelDescription),fmiModelDescription.getFMUAllocateMemory(),new FMULibrary.FMUFreeMemory(),new FMULibrary.FMUStepFinished());
    Function instantiateModelFunction;
    try {
      instantiateModelFunction=fmiModelDescription.getFmiFunction(""String_Node_Str"");
    }
 catch (    UnsatisfiedLinkError ex) {
      UnsatisfiedLinkError error=new UnsatisfiedLinkError(""String_Node_Str"" + _modelIdentifier + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      error.initCause(ex);
      throw error;
    }
    fmiComponent=(Pointer)instantiateModelFunction.invoke(Pointer.class,new Object[]{_modelIdentifier,fmiModelDescription.guid,callbacks,loggingOn});
  }
 else {
    FMI20CallbackFunctions callbacks20=new FMI20CallbackFunctions(new FMULibrary.FMULogger(fmiModelDescription),fmiModelDescription.getFMUAllocateMemory(),new FMULibrary.FMUFreeMemory(),new FMULibrary.FMUStepFinished(),fmiComponent);
    Function fmiInstantiateFunction=fmiModelDescription.getFmiFunction(""String_Node_Str"");
    int toBeVisibleFMI2=0;
    int fmiType=1;
    if (fmiModelDescription.modelExchange) {
      fmiType=0;
    }
    fmiComponent=(Pointer)fmiInstantiateFunction.invoke(Pointer.class,new Object[]{_modelIdentifier,fmiType,fmiModelDescription.guid,fmiModelDescription.fmuResourceLocation,callbacks20,toBeVisibleFMI2,loggingOnFMI2});
  }
  if (fmiComponent.equals(Pointer.NULL)) {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (enableLogging) {
    System.out.println(""String_Node_Str"");
  }
  final int numberOfStates=fmiModelDescription.numberOfContinuousStates;
  final int numberOfEventIndicators=fmiModelDescription.numberOfEventIndicators;
  double[] states=new double[numberOfStates];
  double[] derivatives=new double[numberOfStates];
  double[] eventIndicators=null;
  double[] preEventIndicators=null;
  if (numberOfEventIndicators > 0) {
    eventIndicators=new double[numberOfEventIndicators];
    preEventIndicators=new double[numberOfEventIndicators];
  }
  double startTime=0.0;
  Function setTime=fmiModelDescription.getFmiFunction(""String_Node_Str"");
  invoke(setTime,new Object[]{fmiComponent,startTime},""String_Node_Str"" + startTime + ""String_Node_Str"");
  byte toleranceControlled=0;
  FMIEventInfo eventInfo=null;
  FMI20EventInfo eventInfo20=null;
  FMI20EventInfo.ByReference eventInfo20Reference=null;
  if (_fmiVersion < 1.5) {
    eventInfo=new FMIEventInfo();
    invoke(setTime,new Object[]{fmiComponent,startTime},""String_Node_Str"" + startTime + ""String_Node_Str"");
    invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent,toleranceControlled,startTime,eventInfo},""String_Node_Str"");
  }
 else {
    eventInfo20=new FMI20EventInfo();
    double relativeTolerance=1e-4;
    byte _toleranceControlled=(byte)0;
    invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent,_toleranceControlled,relativeTolerance,startTime,(byte)1,endTime},""String_Node_Str"");
    invoke(setTime,new Object[]{fmiComponent,startTime},""String_Node_Str"" + startTime + ""String_Node_Str"");
    invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent},""String_Node_Str"");
    invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent},""String_Node_Str"");
    eventInfo20.newDiscreteStatesNeeded=(byte)1;
    eventInfo20.terminateSimulation=(byte)0;
    System.out.println(""String_Node_Str"" + eventInfo20.toString());
    while (eventInfo20.newDiscreteStatesNeeded == (byte)1 && !(eventInfo20.terminateSimulation == (byte)1)) {
      eventInfo20Reference=new FMI20EventInfo.ByReference(eventInfo20);
      System.out.println(""String_Node_Str"" + eventInfo20Reference.toString());
      invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent,eventInfo20Reference},""String_Node_Str"");
    }
  }
  double time=startTime;
  if (eventInfo20 != null && eventInfo20.terminateSimulation != 0) {
    System.out.println(""String_Node_Str"" + time);
    endTime=time;
  }
  if ((eventInfo20 != null && eventInfo20.terminateSimulation != 1) || _fmiVersion < 1.5) {
    if (_fmiVersion > 1.5) {
      invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent},""String_Node_Str"");
    }
    PrintStream file=null;
    try {
      file=new PrintStream(outputFileName);
      if (enableLogging) {
        System.out.println(""String_Node_Str"");
      }
      OutputRow.outputRow(_nativeLibrary,fmiModelDescription,fmiComponent,startTime,file,csvSeparator,Boolean.TRUE);
      OutputRow.outputRow(_nativeLibrary,fmiModelDescription,fmiComponent,startTime,file,csvSeparator,Boolean.FALSE);
      Function completedIntegratorStep=fmiModelDescription.getFmiFunction(""String_Node_Str"");
      Function eventUpdate=null;
      if (_fmiVersion < 1.5) {
        eventUpdate=fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
      Function getContinuousStates=fmiModelDescription.getFmiFunction(""String_Node_Str"");
      Function getDerivatives=fmiModelDescription.getFmiFunction(""String_Node_Str"");
      Function getEventIndicators=fmiModelDescription.getFmiFunction(""String_Node_Str"");
      Function setContinuousStates=fmiModelDescription.getFmiFunction(""String_Node_Str"");
      boolean stateEvent=false;
      byte stepEvent=(byte)0;
      while (time < endTime) {
        invoke(getContinuousStates,new Object[]{fmiComponent,states,numberOfStates},""String_Node_Str"" + time + ""String_Node_Str"");
        invoke(getDerivatives,new Object[]{fmiComponent,derivatives,numberOfStates},""String_Node_Str"" + time + ""String_Node_Str"");
        double stepStartTime=time;
        time=Math.min(time + stepSize,endTime);
        boolean timeEvent=false;
        if (_fmiVersion < 1.5) {
          timeEvent=eventInfo.upcomingTimeEvent == 1 && eventInfo.nextEventTime < time;
        }
 else {
          timeEvent=eventInfo20.nextEventTimeDefined == 1 && eventInfo20.nextEventTime < time;
        }
        if (timeEvent) {
          time=eventInfo.nextEventTime;
        }
        double dt=time - stepStartTime;
        invoke(setTime,new Object[]{fmiComponent,time},""String_Node_Str"" + time + ""String_Node_Str"");
        for (int i=0; i < numberOfStates; i++) {
          states[i]+=dt * derivatives[i];
        }
        invoke(setContinuousStates,new Object[]{fmiComponent,states,numberOfStates},""String_Node_Str"" + time + ""String_Node_Str"");
        if (enableLogging) {
          System.out.println(""String_Node_Str"" + numberOfSteps + ""String_Node_Str""+ time);
        }
        if (_fmiVersion > 1.5) {
          for (int i=0; i < numberOfEventIndicators; i++) {
            preEventIndicators[i]=eventIndicators[i];
          }
          invoke(getEventIndicators,new Object[]{fmiComponent,eventIndicators,numberOfEventIndicators},""String_Node_Str"" + time + ""String_Node_Str"");
          stateEvent=false;
          for (int i=0; i < numberOfEventIndicators; i++) {
            stateEvent=stateEvent || (preEventIndicators[i] * eventIndicators[i] < 0);
          }
        }
        if (_fmiVersion < 1.5) {
          ByteByReference stepEventReference=new ByteByReference(stepEvent);
          invoke(completedIntegratorStep,new Object[]{fmiComponent,stepEventReference},""String_Node_Str"" + time + ""String_Node_Str"");
          for (int i=0; i < numberOfEventIndicators; i++) {
            preEventIndicators[i]=eventIndicators[i];
          }
        }
 else {
          ByteByReference stepEventReference=new ByteByReference(stepEvent);
          Byte terminateSimulation=(byte)0;
          ByteByReference terminateSimulationReference=new ByteByReference(terminateSimulation);
          invoke(completedIntegratorStep,new Object[]{fmiComponent,(byte)1,stepEventReference,terminateSimulationReference},""String_Node_Str"" + time + ""String_Node_Str"");
          if (terminateSimulation != (byte)0) {
            System.out.println(""String_Node_Str"" + time);
            break;
          }
        }
        if (_fmiVersion < 1.5) {
          invoke(getEventIndicators,new Object[]{fmiComponent,eventIndicators,numberOfEventIndicators},""String_Node_Str"" + time + ""String_Node_Str"");
          stateEvent=Boolean.FALSE;
          for (int i=0; i < numberOfEventIndicators; i++) {
            stateEvent=stateEvent || preEventIndicators[i] * eventIndicators[i] < 0;
          }
        }
        if (stateEvent || stepEvent != (byte)0 || timeEvent) {
          if (stateEvent) {
            numberOfStateEvents++;
            if (enableLogging) {
              for (int i=0; i < numberOfEventIndicators; i++) {
                System.out.println(""String_Node_Str"" + (preEventIndicators[i] > 0 && eventIndicators[i] < 0 ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ i+ ""String_Node_Str""+ time);
              }
            }
          }
          if (stepEvent != (byte)0) {
            numberOfStepEvents++;
            if (enableLogging) {
              System.out.println(""String_Node_Str"" + time);
            }
          }
          if (timeEvent) {
            numberOfTimeEvents++;
            if (enableLogging) {
              System.out.println(""String_Node_Str"" + time);
            }
          }
          if (_fmiVersion < 1.5) {
            invoke(eventUpdate,new Object[]{fmiComponent,(byte)0,eventInfo},""String_Node_Str"" + time + ""String_Node_Str"");
            if (eventInfo.stateValuesChanged != (byte)0 && enableLogging) {
              System.out.println(""String_Node_Str"" + time);
            }
            if (eventInfo.stateValueReferencesChanged != (byte)0 && enableLogging) {
              System.out.println(""String_Node_Str"" + time);
            }
          }
 else {
            eventInfo20.newDiscreteStatesNeeded=(byte)1;
            eventInfo20.terminateSimulation=(byte)0;
            while ((eventInfo20.newDiscreteStatesNeeded == (byte)1) && !(eventInfo20.terminateSimulation == (byte)1)) {
              eventInfo20Reference=new FMI20EventInfo.ByReference(eventInfo20);
              invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent,eventInfo20Reference},""String_Node_Str"");
            }
            if (eventInfo20.terminateSimulation != (byte)0) {
              System.out.println(""String_Node_Str"" + time);
              break;
            }
            invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent},""String_Node_Str"");
            if ((eventInfo20.valuesOfContinuousStatesChanged == (byte)1) && enableLogging) {
              System.out.println(""String_Node_Str"" + time);
            }
            if ((eventInfo20.nominalsOfContinuousStatesChanged == (byte)1) && enableLogging) {
              System.out.println(""String_Node_Str"" + time);
            }
          }
        }
        OutputRow.outputRow(_nativeLibrary,fmiModelDescription,fmiComponent,time,file,csvSeparator,Boolean.FALSE);
        numberOfSteps++;
      }
      if (_fmiVersion < 1.5) {
        invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent},""String_Node_Str"");
        Function freeModelInstance=fmiModelDescription.getFmiFunction(""String_Node_Str"");
        int fmiFlag=((Integer)freeModelInstance.invoke(Integer.class,new Object[]{fmiComponent})).intValue();
        if (fmiFlag >= FMILibrary.FMIStatus.fmiWarning) {
          System.err.println(""String_Node_Str"" + FMIModelDescription.fmiStatusDescription(fmiFlag));
        }
      }
 else {
        if (!(eventInfo20.terminateSimulation == 1)) {
          invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent},""String_Node_Str"");
        }
        invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent},""String_Node_Str"");
      }
    }
  finally {
      if (file != null) {
        file.close();
      }
      if (fmiModelDescription != null) {
        fmiModelDescription.dispose();
      }
    }
  }
  System.out.println(""String_Node_Str"" + startTime + ""String_Node_Str""+ endTime+ ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + numberOfSteps);
  System.out.println(""String_Node_Str"" + stepSize);
  System.out.println(""String_Node_Str"" + numberOfStateEvents);
  System.out.println(""String_Node_Str"" + numberOfStepEvents);
  System.out.println(""String_Node_Str"" + numberOfTimeEvents);
  System.out.flush();
}"
72604,"private void _init() throws IllegalActionException, NameDuplicationException {
  particles=new TypedIOPort(this,""String_Node_Str"",true,false);
  ArrayToken names=new ArrayToken(""String_Node_Str"");
  String stateName;
  _labels=new String[names.length() + 1];
  _types=new Type[names.length() + 1];
  for (int i=0; i < names.length(); i++) {
    stateName=((StringToken)names.getElement(i)).stringValue();
    _labels[i]=stateName;
    _types[i]=BaseType.DOUBLE;
  }
  _labels[names.length()]=""String_Node_Str"";
  _types[names.length()]=BaseType.DOUBLE;
  particles.setTypeEquals(new ArrayType(new RecordType(_labels,_types)));
  _px=new double[0];
  _py=new double[0];
  _weights=new double[0];
  locations=new TypedIOPort(this,""String_Node_Str"",true,false);
  _robotLocations=new LinkedList<RecordToken>();
  output=new TypedIOPort(this,""String_Node_Str"",false,true);
  output.setTypeEquals(BaseType.DOUBLE);
  _covariance=2.0;
}","private void _init() throws IllegalActionException, NameDuplicationException {
  particles=new TypedIOPort(this,""String_Node_Str"",true,false);
  ArrayToken names=new ArrayToken(""String_Node_Str"");
  String stateName;
  _labels=new String[names.length() + 1];
  _types=new Type[names.length() + 1];
  for (int i=0; i < names.length(); i++) {
    stateName=((StringToken)names.getElement(i)).stringValue();
    _labels[i]=stateName;
    _types[i]=BaseType.DOUBLE;
  }
  _labels[names.length()]=""String_Node_Str"";
  _types[names.length()]=BaseType.DOUBLE;
  particles.setTypeEquals(new ArrayType(new RecordType(_labels,_types)));
  _px=new double[0];
  _py=new double[0];
  _weights=new double[0];
  locations=new TypedIOPort(this,""String_Node_Str"",true,false);
  _robotLocations=new LinkedList<RecordToken>();
  output=new TypedIOPort(this,""String_Node_Str"",false,true);
  output.setTypeEquals(BaseType.DOUBLE);
  _firstStep=true;
  _covariance=2.0;
}"
72605,"@Override public void fire() throws IllegalActionException {
  super.fire();
  if (particles.hasToken(0)) {
    ArrayToken incoming=(ArrayToken)particles.get(0);
    N=incoming.length();
    _weights=new double[N];
    if (_px.length == 0) {
      _px=new double[N];
      _py=new double[N];
      _weights=new double[N];
    }
    for (int i=0; i < N; i++) {
      RecordToken token=(RecordToken)incoming.getElement(i);
      for (int k=0; k < _labels.length; k++) {
        if (_labels[k].equals(""String_Node_Str"")) {
          _weights[i]=((DoubleToken)token.get(_labels[k])).doubleValue();
        }
 else         if (_labels[k].equals(""String_Node_Str"")) {
          _px[i]=((DoubleToken)token.get(_labels[k])).doubleValue();
        }
 else         if (_labels[k].equals(""String_Node_Str"")) {
          _py[i]=((DoubleToken)token.get(_labels[k])).doubleValue();
        }
      }
    }
    double wsum=0;
    for (int i=0; i < N; i++) {
      wsum+=_weights[i];
    }
    for (int i=0; i < N; i++) {
      _weights[i]/=wsum;
    }
  }
  if (locations.hasToken(0)) {
    ArrayToken robotLocations=(ArrayToken)locations.get(0);
    _nRobots=robotLocations.length();
    _robotLocations.clear();
    for (int i=0; i < _nRobots; i++) {
      RecordToken robotLocation=(RecordToken)robotLocations.getElement(i);
      _robotLocations.add(robotLocation);
    }
  }
  output.send(0,new DoubleToken(Hz(_xValue)));
}","@Override public void fire() throws IllegalActionException {
  super.fire();
  if (particles.hasToken(0)) {
    ArrayToken incoming=(ArrayToken)particles.get(0);
    N=incoming.length();
    if (_firstStep) {
      _px=new double[N];
      _py=new double[N];
      _weights=new double[N];
      _firstStep=false;
    }
    for (int i=0; i < N; i++) {
      RecordToken token=(RecordToken)incoming.getElement(i);
      for (int k=0; k < _labels.length; k++) {
        if (_labels[k].equals(""String_Node_Str"")) {
          _weights[i]=((DoubleToken)token.get(_labels[k])).doubleValue();
        }
 else         if (_labels[k].equals(""String_Node_Str"")) {
          _px[i]=((DoubleToken)token.get(_labels[k])).doubleValue();
        }
 else         if (_labels[k].equals(""String_Node_Str"")) {
          _py[i]=((DoubleToken)token.get(_labels[k])).doubleValue();
        }
      }
    }
    double wsum=0;
    for (int i=0; i < N; i++) {
      wsum+=_weights[i];
    }
    for (int i=0; i < N; i++) {
      _weights[i]/=wsum;
    }
  }
  if (locations.hasToken(0)) {
    ArrayToken robotLocations=(ArrayToken)locations.get(0);
    _nRobots=robotLocations.length();
    _robotLocations.clear();
    for (int i=0; i < _nRobots; i++) {
      RecordToken robotLocation=(RecordToken)robotLocations.getElement(i);
      _robotLocations.add(robotLocation);
    }
  }
  output.send(0,new DoubleToken(Hz(_xValue)));
}"
72606,"/** 
 * Remove all decorated ports from the container
 * @throws NameDuplicationException 
 * @throws IllegalActionException 
 */
public void removeDecorationsFromContainer(){
  super.removeDecorationsFromContainer();
  removeStateSpaceVariablesFromContainer();
}","/** 
 * Remove all decorated ports from the container
 * @throws NameDuplicationException 
 * @throws IllegalActionException 
 */
public void removeDecorationsFromContainer() throws IllegalActionException, NameDuplicationException {
  super.removeDecorationsFromContainer();
  removeStateSpaceVariablesFromContainer();
}"
72607,"/** 
 * Create the parameters. Including any parameter the decorator already includes.
 */
private void _init(){
  try {
    enable=new Parameter(this,""String_Node_Str"");
    enable.setExpression(""String_Node_Str"");
    enable.setTypeEquals(BaseType.BOOLEAN);
    enable.setPersistent(true);
    _addAllParameters();
  }
 catch (  KernelException ex) {
    throw new InternalErrorException(ex);
  }
}","/** 
 * Create the parameters. Including any parameter the decorator already includes.
 */
private void _init(){
  _cachedDecoratorPorts=new HashMap<>();
  _cachedDecoratorPortParameters=new HashMap<>();
  try {
    enable=new Parameter(this,""String_Node_Str"");
    enable.setExpression(""String_Node_Str"");
    enable.setTypeEquals(BaseType.BOOLEAN);
    enable.setPersistent(true);
    _addAllParameters();
  }
 catch (  KernelException ex) {
    throw new InternalErrorException(ex);
  }
}"
72608,"/** 
 * React to a change in an attribute.  If the attribute is <i>enable</i>, remember the value.
 * @param attribute The attribute that changed.
 * @exception IllegalActionException If the change is not acceptableto this container (not thrown in this base class).
 */
@Override public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == enable) {
    _enabled=((BooleanToken)enable.getToken()).booleanValue();
    if (enabled()) {
      decorateContainer();
    }
 else {
      removeDecorationsFromContainer();
    }
  }
  super.attributeChanged(attribute);
}","/** 
 * React to a change in an attribute.  If the attribute is <i>enable</i>, remember the value.
 * @param attribute The attribute that changed.
 * @exception IllegalActionException If the change is not acceptableto this container (not thrown in this base class).
 */
@Override public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == enable) {
    _enabled=((BooleanToken)enable.getToken()).booleanValue();
    if (enabled()) {
      decorateContainer();
    }
 else {
      try {
        removeDecorationsFromContainer();
      }
 catch (      NameDuplicationException e) {
        throw new InternalErrorException(e);
      }
    }
  }
  super.attributeChanged(attribute);
}"
72609,"@Override public Object clone(Workspace workspace) throws CloneNotSupportedException {
  MirrorDecoratorAttributes result=(MirrorDecoratorAttributes)super.clone(workspace);
  result._enabled=false;
  return result;
}","@Override public Object clone(Workspace workspace) throws CloneNotSupportedException {
  MirrorDecoratorAttributes result=(MirrorDecoratorAttributes)super.clone(workspace);
  result._enabled=false;
  result._cachedDecoratorPortParameters=null;
  result._cachedDecoratorPorts=null;
  return result;
}"
72610,"/** 
 * Remove all decorated ports from the container
 * @throws NameDuplicationException 
 * @throws IllegalActionException 
 */
public void removeDecorationsFromContainer(){
  if (this._decorator != null) {
    List<String> addedPortNames=((MirrorDecorator)this._decorator).getAddedPortNames();
    if (addedPortNames != null) {
      for (      String port : addedPortNames) {
        event((MirrorDecorator)this._decorator,DecoratorEvent.REMOVED_PORT,port);
      }
    }
    List<String> addedPortParNames=((MirrorDecorator)this._decorator).getAddedPortParameterNames();
    if (addedPortNames != null) {
      for (      String decoratorPort : addedPortParNames) {
        event((MirrorDecorator)this._decorator,DecoratorEvent.REMOVED_PORT,(Parameter)((MirrorDecorator)this._decorator).getAttribute(decoratorPort));
      }
    }
  }
}","/** 
 * Remove all decorated ports from the container
 * @throws NameDuplicationException 
 * @throws IllegalActionException 
 */
public void removeDecorationsFromContainer() throws IllegalActionException, NameDuplicationException {
  if (this._decorator != null) {
    for (    Port p : _cachedDecoratorPorts.values()) {
      p.setContainer(null);
    }
    for (    Parameter p : _cachedDecoratorPortParameters.values()) {
      ParameterPort expectedPort=(ParameterPort)((ComponentEntity)this.getContainer()).getPort(p.getName());
      if (expectedPort != null) {
        expectedPort.setContainer(null);
      }
      p.setContainer(null);
    }
    _cachedDecoratorPorts.clear();
    _cachedDecoratorPortParameters.clear();
  }
}"
72611,"/** 
 * Send out an
 */
@Override public void event(MirrorDecorator ssm,DecoratorEvent eventType,String portName){
  ComponentEntity container=(ComponentEntity)this.getContainer();
  try {
    String decoratorName=this.getDecorator().getName();
    String targetPortName=decoratorName + ""String_Node_Str"" + portName;
    TypedIOPort port=(TypedIOPort)container.getPort(targetPortName);
    if (eventType == DecoratorEvent.ADDED_PORT) {
      if (enabled()) {
        if (port == null) {
          port=new TypedIOPort(container,targetPortName,true,false);
          SingletonParameter showNameParam=((SingletonParameter)port.getAttribute(""String_Node_Str""));
          if (showNameParam == null) {
            showNameParam=new SingletonParameter(port,""String_Node_Str"");
          }
          showNameParam.setExpression(""String_Node_Str"");
        }
 else {
          if (port.isOutput()) {
            throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
          }
        }
      }
    }
 else     if (eventType == DecoratorEvent.REMOVED_PORT) {
      boolean portAddedByDecorator=((MirrorDecorator)this._decorator).getAddedPortNames().contains(portName);
      boolean paramPortAddedByDecorator=((MirrorDecorator)this._decorator).getAddedPortParameterNames().contains(portName);
      if (port != null) {
        if (portAddedByDecorator) {
          port.setContainer(null);
        }
      }
 else {
        port=(TypedIOPort)container.getPort(portName);
        if (port != null && paramPortAddedByDecorator) {
          port.setContainer(null);
        }
      }
    }
  }
 catch (  IllegalActionException|NameDuplicationException e) {
    throw new InternalErrorException(e);
  }
}","/** 
 * Send out an
 */
@Override public void event(MirrorDecorator ssm,DecoratorEvent eventType,String portName){
  ComponentEntity container=(ComponentEntity)this.getContainer();
  try {
    String decoratorName=this.getDecorator().getName();
    String targetPortName=decoratorName + ""String_Node_Str"" + portName;
    TypedIOPort port=(TypedIOPort)container.getPort(targetPortName);
    if (eventType == DecoratorEvent.ADDED_PORT) {
      if (enabled()) {
        if (port == null) {
          port=new TypedIOPort(container,targetPortName,true,false);
          SingletonParameter showNameParam=((SingletonParameter)port.getAttribute(""String_Node_Str""));
          if (showNameParam == null) {
            showNameParam=new SingletonParameter(port,""String_Node_Str"");
          }
          showNameParam.setExpression(""String_Node_Str"");
        }
 else {
          if (port.isOutput()) {
            throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
          }
        }
      }
      _cachedDecoratorPorts.put(portName,port);
    }
 else     if (eventType == DecoratorEvent.REMOVED_PORT) {
      boolean portAddedByDecorator=_cachedDecoratorPorts.keySet().contains(portName);
      boolean paramPortAddedByDecorator=_cachedDecoratorPortParameters.keySet().contains(portName);
      if (port != null) {
        if (portAddedByDecorator) {
          port.setContainer(null);
        }
      }
 else {
        port=(TypedIOPort)container.getPort(portName);
        if (port != null && paramPortAddedByDecorator) {
          port.setContainer(null);
        }
      }
      _cachedDecoratorPorts.remove(portName);
    }
  }
 catch (  IllegalActionException|NameDuplicationException e) {
    throw new InternalErrorException(e);
  }
}"
72612,"/** 
 * Initialize ports and parameters.
 * @exception IllegalActionException
 * @exception NameDuplicationException
 */
private void _init() throws IllegalActionException, NameDuplicationException {
  publish=new TypedIOPort(this,""String_Node_Str"",true,false);
  subscribe=new TypedIOPort(this,""String_Node_Str"",false,true);
  subscribe.setTypeEquals(BaseType.STRING);
  address=new Parameter(this,""String_Node_Str"");
  host=new Parameter(this,""String_Node_Str"");
  port=new Parameter(this,""String_Node_Str"");
}","/** 
 * Initialize ports and parameters.
 * @exception IllegalActionException
 * @exception NameDuplicationException
 */
private void _init() throws IllegalActionException, NameDuplicationException {
  publish=new TypedIOPort(this,""String_Node_Str"",true,false);
  subscribe=new TypedIOPort(this,""String_Node_Str"",false,true);
  address=new Parameter(this,""String_Node_Str"");
  host=new Parameter(this,""String_Node_Str"");
  port=new Parameter(this,""String_Node_Str"");
}"
72613,"/** 
 * If there is a token on the input, convert the token to a json object and publish that to the event bus.
 */
@Override public void fire() throws IllegalActionException {
  if (_exception != null) {
    throw new IllegalActionException(this,_exception,_exception.getMessage());
  }
  for (int i=0; i < publish.getWidth(); i++) {
    if (publish.hasToken(i)) {
      String tokenString=publish.get(0).toString();
      JsonObject msg=new JsonObject().putString(""String_Node_Str"",""String_Node_Str"").putString(""String_Node_Str"",_address).putString(""String_Node_Str"",tokenString);
      _sendTextFrame(msg);
    }
  }
  if (_buffer != null) {
    List<StringToken> _bufferCopy=new ArrayList<StringToken>();
synchronized (_buffer) {
      if (_buffer.size() > 0) {
        _bufferCopy.addAll(_buffer);
        _buffer.clear();
      }
    }
    for (int i=0; i < _bufferCopy.size(); i++) {
      subscribe.send(0,_bufferCopy.get(i));
    }
  }
}","/** 
 * If there is a token on the input, convert the token to a json object and publish that to the event bus.
 */
@Override public void fire() throws IllegalActionException {
  if (_exception != null) {
    throw new IllegalActionException(this,_exception,_exception.getMessage());
  }
  for (int i=0; i < publish.getWidth(); i++) {
    if (publish.hasToken(i)) {
      String tokenString=publish.get(0).toString();
      JsonObject msg=new JsonObject().putString(""String_Node_Str"",""String_Node_Str"").putString(""String_Node_Str"",_address).putString(""String_Node_Str"",tokenString);
      _sendTextFrame(msg);
    }
  }
  if (_buffer != null) {
    List<Token> bufferCopy=new ArrayList<Token>();
synchronized (_buffer) {
      if (_buffer.size() > 0) {
        bufferCopy.addAll(_buffer);
        _buffer.clear();
      }
    }
    for (int i=0; i < bufferCopy.size(); i++) {
      subscribe.send(0,bufferCopy.get(i));
    }
  }
}"
72614,"/** 
 * Open a web socket that serves as a connection to the event bus.
 */
private void _openWebSocket(){
  if (!_stopRequested) {
    _client.connectWebsocket(""String_Node_Str"",new Handler<WebSocket>(){
      @Override public void handle(      WebSocket websocket){
        JsonObject msg=new JsonObject().putString(""String_Node_Str"",""String_Node_Str"").putString(""String_Node_Str"",_address);
        websocket.writeTextFrame(msg.encode());
        _websocket=websocket;
        websocket.dataHandler(new Handler<Buffer>(){
          @Override public void handle(          Buffer buff){
            String msg=buff.toString();
            JsonObject received=new JsonObject(msg);
            if (_buffer == null) {
              _buffer=new ArrayList<StringToken>();
            }
synchronized (_buffer) {
              if (received.getField(""String_Node_Str"") != null) {
                _buffer.add(new StringToken(received.getField(""String_Node_Str"").toString()));
              }
            }
            try {
              getDirector().fireAtCurrentRealTime((Actor)subscribe.getContainer());
            }
 catch (            IllegalActionException e) {
              e.printStackTrace();
            }
          }
        }
);
      }
    }
);
    _client.exceptionHandler(new Handler<Throwable>(){
      @Override public void handle(      Throwable event){
        _exception=event;
        _vertx.cancelTimer(_periodicPing);
      }
    }
);
  }
}","/** 
 * Open a web socket that serves as a connection to the event bus.
 */
private void _openWebSocket(){
  if (!_stopRequested) {
    _client.connectWebsocket(""String_Node_Str"",new Handler<WebSocket>(){
      @Override public void handle(      WebSocket websocket){
        JsonObject msg=new JsonObject().putString(""String_Node_Str"",""String_Node_Str"").putString(""String_Node_Str"",_address);
        websocket.writeTextFrame(msg.encode());
        _websocket=websocket;
        if (subscribe.connectedPortList().size() > 0) {
          websocket.dataHandler(new Handler<Buffer>(){
            @Override public void handle(            Buffer buff){
              String msg=buff.toString();
              JsonObject received=new JsonObject(msg);
              if (_buffer == null) {
                _buffer=new ArrayList<Token>();
              }
synchronized (_buffer) {
                if (received.getField(""String_Node_Str"") != null) {
                  String body=received.getField(""String_Node_Str"");
                  if (body.startsWith(""String_Node_Str"") && body.endsWith(""String_Node_Str"")) {
                    body=body.substring(1,body.length() - 1);
                  }
                  body=body.replaceAll(""String_Node_Str"",""String_Node_Str"");
                  _buffer.add(new StringToken(body));
                }
              }
              try {
                getDirector().fireAtCurrentRealTime((Actor)subscribe.getContainer());
              }
 catch (              IllegalActionException e) {
                _exception=e;
              }
            }
          }
);
        }
      }
    }
);
    _client.exceptionHandler(new Handler<Throwable>(){
      @Override public void handle(      Throwable event){
        _exception=event;
        _vertx.cancelTimer(_periodicPing);
      }
    }
);
  }
}"
72615,"/** 
 * Initialize verticle, create http client and open web socket to connect to event bus.
 * @throws IllegalActionException 
 */
@Override public void initialize() throws IllegalActionException {
  _exception=null;
  _vertx=VertxFactory.newVertx();
  _client=_vertx.createHttpClient().setHost(_host).setPort(_port);
  _openWebSocket();
  _periodicPing=_vertx.setPeriodic(1000,new Handler<Long>(){
    @Override public void handle(    Long timerID){
      JsonObject json=new JsonObject().putString(""String_Node_Str"",""String_Node_Str"");
      try {
        _sendTextFrame(json);
      }
 catch (      IllegalActionException e) {
        _exception=e;
      }
    }
  }
);
}","/** 
 * Initialize verticle, create http client and open web socket to connect to event bus.
 * @throws IllegalActionException 
 */
@Override public void initialize() throws IllegalActionException {
  _exception=null;
  _vertx=VertxFactory.newVertx();
  _client=_vertx.createHttpClient().setHost(_host).setPort(_port);
  _openWebSocket();
  _periodicPing=_vertx.setPeriodic(5000,new Handler<Long>(){
    @Override public void handle(    Long timerID){
      JsonObject json=new JsonObject().putString(""String_Node_Str"",""String_Node_Str"");
      try {
        _sendTextFrame(json);
      }
 catch (      IllegalActionException e) {
        _exception=e;
      }
    }
  }
);
}"
72616,"/** 
 * Wrap up, close web socket if open, stop vertx.
 */
@Override public synchronized void wrapup() throws IllegalActionException {
  super.wrapup();
  _vertx.cancelTimer(_periodicPing);
  _vertx.stop();
}","/** 
 * Wrap up, close web socket if open, stop vertx.
 */
@Override public synchronized void wrapup() throws IllegalActionException {
  super.wrapup();
  _vertx.cancelTimer(_periodicPing);
  _vertx.stop();
  _websocket=null;
}"
72617,"/** 
 * Open a web socket that serves as a connection to the event bus.
 */
private synchronized void _openWebSocket(){
  if (!_stopRequested) {
    _client.connectWebsocket(""String_Node_Str"",new Handler<WebSocket>(){
      @Override public void handle(      WebSocket websocket){
        JsonObject msg=new JsonObject().putString(""String_Node_Str"",""String_Node_Str"").putString(""String_Node_Str"",_address);
        websocket.writeTextFrame(msg.encode());
        _websocket=websocket;
        websocket.dataHandler(new Handler<Buffer>(){
          @Override public void handle(          Buffer buff){
            String msg=buff.toString();
            JsonObject received=new JsonObject(msg);
            if (_buffer == null) {
              _buffer=new ArrayList<StringToken>();
            }
synchronized (_buffer) {
              _buffer.add(new StringToken(received.getField(""String_Node_Str"").toString()));
            }
            try {
              getDirector().fireAtCurrentRealTime((Actor)subscribe.getContainer());
            }
 catch (            IllegalActionException e) {
              e.printStackTrace();
            }
          }
        }
);
      }
    }
);
    _client.exceptionHandler(new Handler<Throwable>(){
      @Override public void handle(      Throwable event){
        _exception=event;
        _vertx.cancelTimer(_periodicPing);
      }
    }
);
  }
}","/** 
 * Open a web socket that serves as a connection to the event bus.
 */
private void _openWebSocket(){
  if (!_stopRequested) {
    _client.connectWebsocket(""String_Node_Str"",new Handler<WebSocket>(){
      @Override public void handle(      WebSocket websocket){
        JsonObject msg=new JsonObject().putString(""String_Node_Str"",""String_Node_Str"").putString(""String_Node_Str"",_address);
        websocket.writeTextFrame(msg.encode());
        _websocket=websocket;
        websocket.dataHandler(new Handler<Buffer>(){
          @Override public void handle(          Buffer buff){
            String msg=buff.toString();
            JsonObject received=new JsonObject(msg);
            if (_buffer == null) {
              _buffer=new ArrayList<StringToken>();
            }
synchronized (_buffer) {
              if (received.getField(""String_Node_Str"") != null) {
                _buffer.add(new StringToken(received.getField(""String_Node_Str"").toString()));
              }
            }
            try {
              getDirector().fireAtCurrentRealTime((Actor)subscribe.getContainer());
            }
 catch (            IllegalActionException e) {
              e.printStackTrace();
            }
          }
        }
);
      }
    }
);
    _client.exceptionHandler(new Handler<Throwable>(){
      @Override public void handle(      Throwable event){
        _exception=event;
        _vertx.cancelTimer(_periodicPing);
      }
    }
);
  }
}"
72618,"/** 
 * Construct an instance of the attribute.
 * @param container The container.
 * @param name The name.
 * @exception IllegalActionException If the superclass throws it.
 * @exception NameDuplicationException If the superclass throws it.
 */
public WebServer(NamedObj container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  preferredPort=new Parameter(this,""String_Node_Str"");
  preferredPort.setTypeEquals(BaseType.INT);
  preferredPort.setExpression(Integer.toString(WebServerUtilities.DEFAULT_PORT_NUMBER));
  applicationPath=new StringParameter(this,""String_Node_Str"");
  applicationPath.setExpression(""String_Node_Str"");
  resourcePath=new StringParameter(this,""String_Node_Str"");
  resourcePath.setExpression(""String_Node_Str"");
  resourceLocation=new FileParameter(this,""String_Node_Str"");
  Parameter allowDirectories=new Parameter(resourceLocation,""String_Node_Str"");
  allowDirectories.setToken(""String_Node_Str"");
  allowDirectories.setVisibility(Settable.NONE);
  Parameter allowFiles=new Parameter(resourceLocation,""String_Node_Str"");
  allowFiles.setToken(""String_Node_Str"");
  allowFiles.setVisibility(Settable.NONE);
  URI modelURI=URIAttribute.getModelURI(this);
  String path;
  if (modelURI != null && modelURI.getPath() != null && !modelURI.getPath().isEmpty()) {
    path=modelURI.getPath();
    int slash=path.lastIndexOf(""String_Node_Str"");
    if (slash != -1) {
      path=path.substring(0,slash);
    }
  }
 else {
    path=""String_Node_Str"";
  }
  resourceLocation.setExpression(path);
  temporaryFileLocation=new FileParameter(this,""String_Node_Str"");
  temporaryFileLocation.setExpression(""String_Node_Str"");
  deployedPort=new Parameter(this,""String_Node_Str"");
  deployedPort.setExpression(""String_Node_Str"");
  deployedPort.setVisibility(Settable.NOT_EDITABLE);
  deployedPort.setPersistent(false);
  _dynamicPortSelection=false;
  _endpointManager=WebSocketEndpointManager.getInstance();
}","/** 
 * Construct an instance of the attribute.
 * @param container The container.
 * @param name The name.
 * @exception IllegalActionException If the superclass throws it.
 * @exception NameDuplicationException If the superclass throws it.
 */
public WebServer(NamedObj container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  preferredPort=new Parameter(this,""String_Node_Str"");
  preferredPort.setTypeEquals(BaseType.INT);
  preferredPort.setExpression(Integer.toString(WebServerUtilities.DEFAULT_PORT_NUMBER));
  applicationPath=new StringParameter(this,""String_Node_Str"");
  applicationPath.setExpression(""String_Node_Str"");
  resourcePath=new StringParameter(this,""String_Node_Str"");
  resourcePath.setExpression(""String_Node_Str"");
  resourceLocation=new FileParameter(this,""String_Node_Str"");
  Parameter allowDirectories=new Parameter(resourceLocation,""String_Node_Str"");
  allowDirectories.setToken(""String_Node_Str"");
  allowDirectories.setVisibility(Settable.NONE);
  Parameter allowFiles=new Parameter(resourceLocation,""String_Node_Str"");
  allowFiles.setToken(""String_Node_Str"");
  allowFiles.setVisibility(Settable.NONE);
  URI modelURI=URIAttribute.getModelURI(this);
  String path;
  if (modelURI != null && modelURI.getPath() != null && !modelURI.getPath().isEmpty()) {
    path=modelURI.getPath();
    int slash=path.lastIndexOf(""String_Node_Str"");
    if (slash != -1) {
      path=path.substring(0,slash);
    }
  }
 else {
    path=""String_Node_Str"";
  }
  resourceLocation.setExpression(path);
  temporaryFileLocation=new FileParameter(this,""String_Node_Str"");
  temporaryFileLocation.setExpression(""String_Node_Str"");
  deployedPort=new Parameter(this,""String_Node_Str"");
  deployedPort.setExpression(""String_Node_Str"");
  deployedPort.setVisibility(Settable.NOT_EDITABLE);
  deployedPort.setPersistent(false);
  _dynamicPortSelection=false;
}"
72619,"/** 
 * Clone the attribute.
 * @param workspace The workspace in which to place the cloned attribute.
 * @exception CloneNotSupportedException Not thrown in this base class.
 * @see java.lang.Object#clone()
 * @return The cloned attribute.
 */
@Override public Object clone(Workspace workspace) throws CloneNotSupportedException {
  WebServer newObject=(WebServer)super.clone(workspace);
  newObject._appInfo=null;
  newObject._dynamicPortSelection=false;
  newObject._serverManager=WebServerManager.getInstance();
  return newObject;
}","/** 
 * Clone the attribute.
 * @param workspace The workspace in which to place the cloned attribute.
 * @exception CloneNotSupportedException Not thrown in this base class.
 * @see java.lang.Object#clone()
 * @return The cloned attribute.
 */
@Override public Object clone(Workspace workspace) throws CloneNotSupportedException {
  WebServer newObject=(WebServer)super.clone(workspace);
  newObject._appInfo=null;
  newObject._dynamicPortSelection=false;
  newObject._serverManager=null;
  return newObject;
}"
72620,"/** 
 * Collect servlets from all model objects implementing HttpService and WebSocketService and start the web server in a new thread. <p> In the current implementation, servlets must be registered before the Jetty server starts.  Servlets are not allowed to be added to a running ContextHandler.  Currently, the Jetty server is started once and runs until the model finishes executing.  It would also be possible to pause the server, add a servlet, and restart the server, which would allow a model to dynamically add servlets.  This might cause strange behavior to an outside observer, however, since some HttpRequests could fail if a servlet has not been loaded yet. References: <ul> <li> <a href=""http://wiki.eclipse.org/Jetty/Tutorial/Embedding_Jetty"">http://wiki.eclipse.org/Jetty/Tutorial/Embedding_Jetty</a></li> <li> <a href=""http://wiki.eclipse.org/Jetty/Tutorial/Embedding_Jetty"">http://wiki.eclipse.org/Jetty/Tutorial/Embedding_Jetty</a></li> <li> <a href=""http://draconianoverlord.com/2009/01/10/war-less-dev-with-jetty.html"">http://draconianoverlord.com/2009/01/10/war-less-dev-with-jetty.html</a></li> </ul>
 * @exception IllegalActionException Not thrown in this base class.
 */
@Override public void initialize() throws IllegalActionException {
  super.initialize();
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  HashSet<WebSocketService> servicesToOpen=new HashSet();
  int preferredPortValue=WebServerUtilities.DEFAULT_PORT_NUMBER;
  if (preferredPort != null && !preferredPort.getExpression().isEmpty()) {
    preferredPortValue=Integer.parseInt(preferredPort.getExpression());
    _dynamicPortSelection=false;
  }
 else {
    _dynamicPortSelection=true;
  }
  if (_serverManager == null) {
    _serverManager=WebServerManager.getInstance();
  }
  String modelName=getFullName();
  String applicationPathString=""String_Node_Str"";
  if (applicationPath != null) {
    if (applicationPath.getExpression().startsWith(""String_Node_Str"")) {
      applicationPathString=applicationPath.getExpression();
    }
 else {
      applicationPathString=""String_Node_Str"" + applicationPath.getExpression();
    }
  }
  try {
    _appInfo=new WebApplicationInfo(modelName,applicationPathString,temporaryFileLocation);
  }
 catch (  Exception e) {
    throw new IllegalActionException(this,e,""String_Node_Str"");
  }
  NamedObj container=getContainer();
  if (!(container instanceof CompositeEntity)) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  List<Entity> entities=((CompositeEntity)container).allAtomicEntityList();
  for (  Entity entity : entities) {
    if (entity instanceof HttpService) {
      HttpService service=(HttpService)entity;
      service.setWebServer(this);
      if (_debugging) {
        _debug(""String_Node_Str"" + entity.getFullName());
      }
      URI path=service.getRelativePath();
      try {
        _appInfo.addServletInfo(path,service.getServlet());
      }
 catch (      Exception e) {
        throw new IllegalActionException(this,""String_Node_Str"" + entity.getName() + ""String_Node_Str""+ path+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      }
    }
 else     if (entity instanceof WebSocketService) {
      WebSocketService service=(WebSocketService)entity;
      boolean isLocal=!WebSocketEndpointManager.isRemoteURI(service.getRelativePath());
      if (isLocal && service.isClient()) {
        servicesToOpen.add(service);
      }
      if (_debugging) {
        _debug(""String_Node_Str"" + entity.getFullName());
      }
      if (isLocal) {
        URI path=service.getRelativePath();
        try {
          _appInfo.addSocketInfo(path,entity);
        }
 catch (        Exception e) {
          throw new IllegalActionException(this,""String_Node_Str"" + entity.getName() + ""String_Node_Str""+ path+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
        }
      }
    }
  }
  LinkedHashSet<Resource> resourceLocations=new LinkedHashSet<Resource>();
  List<FileParameter> bases=attributeList(FileParameter.class);
  HashSet<URL> seen=new HashSet<URL>();
  for (  FileParameter base : bases) {
    if (base.getExpression() != null && !base.getExpression().isEmpty()) {
      try {
        String expression=base.getExpression();
        if (expression.startsWith(""String_Node_Str"")) {
          expression=expression.substring(6);
        }
        URL baseURL;
        if (expression.startsWith(""String_Node_Str"")) {
          baseURL=base.asURL();
        }
 else         if (this.getClass().getClassLoader().getResource(expression) != null) {
          baseURL=new URL(this.getClass().getClassLoader().getResource(expression).toExternalForm());
        }
 else {
          baseURL=base.asURL();
        }
        if (baseURL != null) {
          URL baseAsURL=base.asURL();
          if (seen.contains(baseAsURL)) {
            continue;
          }
          seen.add(baseAsURL);
          if (_debugging) {
            _debug(""String_Node_Str"" + baseAsURL);
          }
          String stringURL=baseAsURL.toExternalForm();
          if (!stringURL.endsWith(""String_Node_Str"")) {
            stringURL=stringURL + ""String_Node_Str"";
          }
          resourceLocations.add(Resource.newResource(stringURL));
        }
      }
 catch (      IOException e3) {
        throw new IllegalActionException(this,""String_Node_Str"" + base.stringValue());
      }
    }
  }
  try {
    _appInfo.addResourceInfo(new URI(resourcePath.stringValue()),resourceLocations);
  }
 catch (  URISyntaxException e) {
    throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
  }
catch (  Exception e2) {
    throw new IllegalActionException(this,e2,""String_Node_Str"");
  }
  try {
    int actualPort=_serverManager.register(_appInfo,preferredPortValue,_dynamicPortSelection);
    if (actualPort != -1) {
      deployedPort.setExpression(Integer.toString(actualPort));
      deployedPort.validate();
    }
    _endpointManager.openLocalServices(servicesToOpen,actualPort);
  }
 catch (  Exception e) {
    throw new IllegalActionException(this,e,""String_Node_Str"");
  }
}","/** 
 * Collect servlets from all model objects implementing HttpService and WebSocketService and start the web server in a new thread. <p> In the current implementation, servlets must be registered before the Jetty server starts.  Servlets are not allowed to be added to a running ContextHandler.  Currently, the Jetty server is started once and runs until the model finishes executing.  It would also be possible to pause the server, add a servlet, and restart the server, which would allow a model to dynamically add servlets.  This might cause strange behavior to an outside observer, however, since some HttpRequests could fail if a servlet has not been loaded yet. References: <ul> <li> <a href=""http://wiki.eclipse.org/Jetty/Tutorial/Embedding_Jetty"">http://wiki.eclipse.org/Jetty/Tutorial/Embedding_Jetty</a></li> <li> <a href=""http://wiki.eclipse.org/Jetty/Tutorial/Embedding_Jetty"">http://wiki.eclipse.org/Jetty/Tutorial/Embedding_Jetty</a></li> <li> <a href=""http://draconianoverlord.com/2009/01/10/war-less-dev-with-jetty.html"">http://draconianoverlord.com/2009/01/10/war-less-dev-with-jetty.html</a></li> </ul>
 * @exception IllegalActionException Not thrown in this base class.
 */
@Override public void initialize() throws IllegalActionException {
  super.initialize();
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  if (_endpointManager == null) {
    _endpointManager=WebSocketEndpointManager.getInstance();
  }
  HashSet<WebSocketService> servicesToOpen=new HashSet();
  int preferredPortValue=WebServerUtilities.DEFAULT_PORT_NUMBER;
  if (preferredPort != null && !preferredPort.getExpression().isEmpty()) {
    preferredPortValue=Integer.parseInt(preferredPort.getExpression());
    _dynamicPortSelection=false;
  }
 else {
    _dynamicPortSelection=true;
  }
  if (_serverManager == null) {
    _serverManager=WebServerManager.getInstance();
  }
  String modelName=getFullName();
  String applicationPathString=""String_Node_Str"";
  if (applicationPath != null) {
    if (applicationPath.getExpression().startsWith(""String_Node_Str"")) {
      applicationPathString=applicationPath.getExpression();
    }
 else {
      applicationPathString=""String_Node_Str"" + applicationPath.getExpression();
    }
  }
  try {
    _appInfo=new WebApplicationInfo(modelName,applicationPathString,temporaryFileLocation);
  }
 catch (  Exception e) {
    throw new IllegalActionException(this,e,""String_Node_Str"");
  }
  NamedObj container=getContainer();
  if (!(container instanceof CompositeEntity)) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  List<Entity> entities=((CompositeEntity)container).allAtomicEntityList();
  for (  Entity entity : entities) {
    if (entity instanceof HttpService) {
      HttpService service=(HttpService)entity;
      service.setWebServer(this);
      if (_debugging) {
        _debug(""String_Node_Str"" + entity.getFullName());
      }
      URI path=service.getRelativePath();
      try {
        _appInfo.addServletInfo(path,service.getServlet());
      }
 catch (      Exception e) {
        throw new IllegalActionException(this,""String_Node_Str"" + entity.getName() + ""String_Node_Str""+ path+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      }
    }
 else     if (entity instanceof WebSocketService) {
      WebSocketService service=(WebSocketService)entity;
      boolean isLocal=!WebSocketEndpointManager.isRemoteURI(service.getRelativePath());
      if (isLocal && service.isClient()) {
        servicesToOpen.add(service);
      }
      if (_debugging) {
        _debug(""String_Node_Str"" + entity.getFullName());
      }
      if (isLocal) {
        URI path=service.getRelativePath();
        try {
          _appInfo.addSocketInfo(path,entity);
        }
 catch (        Exception e) {
          throw new IllegalActionException(this,""String_Node_Str"" + entity.getName() + ""String_Node_Str""+ path+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
        }
      }
    }
  }
  LinkedHashSet<Resource> resourceLocations=new LinkedHashSet<Resource>();
  List<FileParameter> bases=attributeList(FileParameter.class);
  HashSet<URL> seen=new HashSet<URL>();
  for (  FileParameter base : bases) {
    if (base.getExpression() != null && !base.getExpression().isEmpty()) {
      try {
        String expression=base.getExpression();
        if (expression.startsWith(""String_Node_Str"")) {
          expression=expression.substring(6);
        }
        URL baseURL;
        if (expression.startsWith(""String_Node_Str"")) {
          baseURL=base.asURL();
        }
 else         if (this.getClass().getClassLoader().getResource(expression) != null) {
          baseURL=new URL(this.getClass().getClassLoader().getResource(expression).toExternalForm());
        }
 else {
          baseURL=base.asURL();
        }
        if (baseURL != null) {
          URL baseAsURL=base.asURL();
          if (seen.contains(baseAsURL)) {
            continue;
          }
          seen.add(baseAsURL);
          if (_debugging) {
            _debug(""String_Node_Str"" + baseAsURL);
          }
          String stringURL=baseAsURL.toExternalForm();
          if (!stringURL.endsWith(""String_Node_Str"")) {
            stringURL=stringURL + ""String_Node_Str"";
          }
          resourceLocations.add(Resource.newResource(stringURL));
        }
      }
 catch (      IOException e3) {
        throw new IllegalActionException(this,""String_Node_Str"" + base.stringValue());
      }
    }
  }
  try {
    _appInfo.addResourceInfo(new URI(resourcePath.stringValue()),resourceLocations);
  }
 catch (  URISyntaxException e) {
    throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
  }
catch (  Exception e2) {
    throw new IllegalActionException(this,e2,""String_Node_Str"");
  }
  try {
    int actualPort=_serverManager.register(_appInfo,preferredPortValue,_dynamicPortSelection);
    if (actualPort != -1) {
      deployedPort.setExpression(Integer.toString(actualPort));
      deployedPort.validate();
    }
    _endpointManager.openLocalServices(servicesToOpen,actualPort);
  }
 catch (  Exception e) {
    throw new IllegalActionException(this,e,""String_Node_Str"");
  }
}"
72621,"/** 
 * Create an instance of the actor.
 * @param container The container
 * @param name The name.
 * @exception IllegalActionException If the superclass throws it.
 * @exception NameDuplicationException If the superclass throws it.
 */
public WebSocketReader(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  path=new StringParameter(this,""String_Node_Str"");
  path.setExpression(""String_Node_Str"");
  client=new Parameter(this,""String_Node_Str"");
  client.setToken(""String_Node_Str"");
  client.setVisibility(Settable.NOT_EDITABLE);
  output=new TypedIOPort(this,""String_Node_Str"",false,true);
  output.setTypeEquals(BaseType.STRING);
  _endpointManager=WebSocketEndpointManager.getInstance();
}","/** 
 * Create an instance of the actor.
 * @param container The container
 * @param name The name.
 * @exception IllegalActionException If the superclass throws it.
 * @exception NameDuplicationException If the superclass throws it.
 */
public WebSocketReader(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  path=new StringParameter(this,""String_Node_Str"");
  path.setExpression(""String_Node_Str"");
  client=new Parameter(this,""String_Node_Str"");
  client.setToken(""String_Node_Str"");
  client.setVisibility(Settable.NOT_EDITABLE);
  output=new TypedIOPort(this,""String_Node_Str"",false,true);
  output.setTypeEquals(BaseType.STRING);
}"
72622,"/** 
 * Remember the time at which this actor was initialized in order to request firings at a particular time. Subscribe this service to the  appropriate endpoint.
 * @exception IllegalActionException If the parent throws it.
 */
@Override public void initialize() throws IllegalActionException {
  super.initialize();
  _initializeModelTime=getDirector().getModelTime();
  _initializeRealTime=System.currentTimeMillis() - 100;
  if (!(!WebSocketEndpointManager.isRemoteURI(_URIpath) && isClient())) {
    _endpointManager.subscribe(this,_URIpath.toString());
  }
}","/** 
 * Remember the time at which this actor was initialized in order to request firings at a particular time. Subscribe this service to the  appropriate endpoint.
 * @exception IllegalActionException If the parent throws it.
 */
@Override public void initialize() throws IllegalActionException {
  super.initialize();
  if (_endpointManager == null) {
    _endpointManager=WebSocketEndpointManager.getInstance();
  }
  _initializeModelTime=getDirector().getModelTime();
  _initializeRealTime=System.currentTimeMillis() - 100;
  if (!(!WebSocketEndpointManager.isRemoteURI(_URIpath) && isClient())) {
    _endpointManager.subscribe(this,_URIpath.toString());
  }
}"
72623,"/** 
 * Subscribe this service to the appropriate endpoint.
 * @exception IllegalActionException If the parent throws it.
 */
@Override public void initialize() throws IllegalActionException {
  super.initialize();
  if (!(!WebSocketEndpointManager.isRemoteURI(_URIpath) && isClient())) {
    _endpointManager.subscribe(this,_URIpath.toString());
  }
}","/** 
 * Subscribe this service to the appropriate endpoint.
 * @exception IllegalActionException If the parent throws it.
 */
@Override public void initialize() throws IllegalActionException {
  super.initialize();
  if (_endpointManager == null) {
    _endpointManager=WebSocketEndpointManager.getInstance();
  }
  if (!(!WebSocketEndpointManager.isRemoteURI(_URIpath) && isClient())) {
    _endpointManager.subscribe(this,_URIpath.toString());
  }
}"
72624,"/** 
 * Create an instance of the actor.
 * @param container The container
 * @param name The name.
 * @exception IllegalActionException If the superclass throws it.
 * @exception NameDuplicationException If the superclass throws it.
 */
public WebSocketWriter(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  path=new StringParameter(this,""String_Node_Str"");
  path.setExpression(""String_Node_Str"");
  client=new Parameter(this,""String_Node_Str"");
  client.setToken(""String_Node_Str"");
  client.setVisibility(Settable.NOT_EDITABLE);
  input=new TypedIOPort(this,""String_Node_Str"",true,false);
  input.setTypeEquals(BaseType.STRING);
  _endpointManager=WebSocketEndpointManager.getInstance();
}","/** 
 * Create an instance of the actor.
 * @param container The container
 * @param name The name.
 * @exception IllegalActionException If the superclass throws it.
 * @exception NameDuplicationException If the superclass throws it.
 */
public WebSocketWriter(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  path=new StringParameter(this,""String_Node_Str"");
  path.setExpression(""String_Node_Str"");
  client=new Parameter(this,""String_Node_Str"");
  client.setToken(""String_Node_Str"");
  client.setVisibility(Settable.NOT_EDITABLE);
  input=new TypedIOPort(this,""String_Node_Str"",true,false);
  input.setTypeEquals(BaseType.STRING);
}"
72625,"/** 
 * Create a new icon with the given name in the given container.
 * @param container The container.
 * @param name The name of the attribute.
 * @exception IllegalActionException If the attribute is not of anacceptable class for the container.
 * @exception NameDuplicationException If the name coincides withan attribute already in the container.
 */
public PDFIcon(NamedObj container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
}","/** 
 * Create a new icon with the given name in the given container.
 * @param container The container.
 * @param name The name of the attribute.
 * @exception IllegalActionException If the attribute is not of anacceptable class for the container.
 * @exception NameDuplicationException If the name coincides withan attribute already in the container.
 */
public PDFIcon(NamedObj container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  try {
    Class.forName(""String_Node_Str"");
    Class.forName(""String_Node_Str"");
    Class.forName(""String_Node_Str"");
  }
 catch (  Throwable throwable) {
    throw new IllegalActionException(this,throwable,""String_Node_Str"");
  }
}"
72626,"/** 
 * Construct a date token with all tokens present. If a token for the long value is present, use this token and time zone as well as precision. Otherwise use tokens on other inputs to create ports.
 * @exception IllegalActionException If there is no director.
 */
@Override public void fire() throws IllegalActionException {
  super.fire();
  DateToken dateToken=null;
  int datePrecision=DateToken.PRECISION_MILLISECOND;
  String precisionValue=((StringToken)precision.getToken()).stringValue();
  if (precisionValue.equals(""String_Node_Str"")) {
    datePrecision=DateToken.PRECISION_SECOND;
  }
  if (precisionValue.equals(""String_Node_Str"")) {
    datePrecision=DateToken.PRECISION_MILLISECOND;
  }
  if (precisionValue.equals(""String_Node_Str"")) {
    datePrecision=DateToken.PRECISION_MICROSECOND;
  }
  if (precisionValue.equals(""String_Node_Str"")) {
    datePrecision=DateToken.PRECISION_NANOSECOND;
  }
 else {
    datePrecision=DateToken.PRECISION_MILLISECOND;
  }
  String timeZoneValue=_getStringValue(timeZone);
  long timeAsLongValue=_getLongValue(timeInMillis);
  int microsecondValue=_getIntValue(microsecond);
  int nanosecondValue=_getIntValue(nanosecond);
  if (!((BooleanToken)useTimeInMillis.getToken()).booleanValue()) {
    int yearValue=_getIntValue(year);
    int monthValue=_getIntValue(month);
    int dayValue=_getIntValue(day);
    int hourValue=_getIntValue(hour);
    int minuteValue=_getIntValue(minute);
    int secondValue=_getIntValue(second);
    int millisecondValue=_getIntValue(millisecond);
    Calendar c=Calendar.getInstance();
    c.set(Calendar.YEAR,yearValue);
    c.set(Calendar.MONTH,monthValue);
    c.set(Calendar.DAY_OF_MONTH,dayValue);
    c.set(Calendar.HOUR,hourValue);
    c.set(Calendar.MINUTE,minuteValue);
    c.set(Calendar.SECOND,secondValue);
    c.set(Calendar.MILLISECOND,millisecondValue);
    timeAsLongValue=c.getTimeInMillis();
  }
  dateToken=new DateToken(timeAsLongValue,datePrecision,TimeZone.getTimeZone(""String_Node_Str"" + timeZoneValue));
  dateToken.addMicroseconds(microsecondValue);
  dateToken.addNanoseconds(nanosecondValue);
  output.send(0,dateToken);
}","/** 
 * Construct a date token with all tokens present. If a token for the long value is present, use this token and time zone as well as precision. Otherwise use tokens on other inputs to create ports.
 * @exception IllegalActionException If there is no director.
 */
@Override public void fire() throws IllegalActionException {
  super.fire();
  DateToken dateToken=null;
  int datePrecision=DateToken.PRECISION_MILLISECOND;
  String precisionValue=((StringToken)precision.getToken()).stringValue();
  if (precisionValue.equals(""String_Node_Str"")) {
    datePrecision=DateToken.PRECISION_SECOND;
  }
  if (precisionValue.equals(""String_Node_Str"")) {
    datePrecision=DateToken.PRECISION_MILLISECOND;
  }
  if (precisionValue.equals(""String_Node_Str"")) {
    datePrecision=DateToken.PRECISION_MICROSECOND;
  }
  if (precisionValue.equals(""String_Node_Str"")) {
    datePrecision=DateToken.PRECISION_NANOSECOND;
  }
 else {
    datePrecision=DateToken.PRECISION_MILLISECOND;
  }
  String timeZoneValue=_getStringValue(timeZone);
  long timeAsLongValue=_getLongValue(timeInMillis);
  int microsecondValue=_getIntValue(microsecond);
  int nanosecondValue=_getIntValue(nanosecond);
  if (!((BooleanToken)useTimeInMillis.getToken()).booleanValue()) {
    int yearValue=_getIntValue(year);
    int monthValue=_getIntValue(month);
    int dayValue=_getIntValue(day);
    int hourValue=_getIntValue(hour);
    int minuteValue=_getIntValue(minute);
    int secondValue=_getIntValue(second);
    int millisecondValue=_getIntValue(millisecond);
    Calendar c=Calendar.getInstance();
    c.setTimeZone(TimeZone.getTimeZone(""String_Node_Str""));
    c.set(Calendar.YEAR,yearValue);
    c.set(Calendar.MONTH,monthValue);
    c.set(Calendar.DAY_OF_MONTH,dayValue);
    c.set(Calendar.HOUR_OF_DAY,hourValue);
    c.set(Calendar.MINUTE,minuteValue);
    c.set(Calendar.SECOND,secondValue);
    c.set(Calendar.MILLISECOND,millisecondValue);
    timeAsLongValue=c.getTimeInMillis();
    if (datePrecision == DateToken.PRECISION_SECOND) {
      timeAsLongValue=timeAsLongValue / 1000;
    }
 else     if (datePrecision == DateToken.PRECISION_MICROSECOND) {
      timeAsLongValue=timeAsLongValue * 1000;
    }
 else     if (datePrecision == DateToken.PRECISION_NANOSECOND) {
      timeAsLongValue=timeAsLongValue * 1000 * 1000;
    }
  }
  dateToken=new DateToken(timeAsLongValue,datePrecision,TimeZone.getTimeZone(""String_Node_Str"" + timeZoneValue));
  dateToken.addMicroseconds(microsecondValue);
  dateToken.addNanoseconds(nanosecondValue);
  output.send(0,dateToken);
}"
72627,"/** 
 * Wrap up, close web socket if open, stop vertx.
 */
@Override public synchronized void wrapup() throws IllegalActionException {
  super.wrapup();
  _websocket.close();
  _client.close();
  _vertx.stop();
}","/** 
 * Wrap up, close web socket if open, stop vertx.
 */
@Override public synchronized void wrapup() throws IllegalActionException {
  super.wrapup();
  if (_websocket != null) {
    _websocket.close();
  }
  if (_client != null) {
    _client.close();
  }
  _vertx.stop();
}"
72628,"/** 
 * If there is a token on the input, convert the token to a json object and publish that to the event bus.
 */
@Override public void fire() throws IllegalActionException {
  for (int i=0; i < publish.getWidth(); i++) {
    if (publish.hasToken(i)) {
      StringToken token=(StringToken)publish.get(i);
      String tokenString=token.stringValue();
      JsonObject msg=new JsonObject().putString(""String_Node_Str"",""String_Node_Str"").putString(""String_Node_Str"",_address).putString(""String_Node_Str"",tokenString);
synchronized (workspace()) {
        while ((_websocket == null) && !_stopRequested) {
          try {
            workspace().wait(1);
          }
 catch (          InterruptedException e) {
            throw new IllegalActionException(this,e.getCause(),e.getMessage());
          }
        }
        _websocket.writeTextFrame(msg.encode());
      }
    }
  }
  if (_buffer != null && _buffer.size() > 0) {
    List<StringToken> _bufferCopy=new ArrayList<StringToken>();
synchronized (_buffer) {
      _bufferCopy.addAll(_buffer);
      _buffer.clear();
    }
    for (int i=0; i < _bufferCopy.size(); i++) {
      subscribe.send(0,_bufferCopy.get(i));
    }
  }
}","/** 
 * If there is a token on the input, convert the token to a json object and publish that to the event bus.
 */
@Override public void fire() throws IllegalActionException {
  if (_exception != null) {
    throw new IllegalActionException(this,_exception,_exception.getMessage());
  }
  for (int i=0; i < publish.getWidth(); i++) {
    if (publish.hasToken(i)) {
      StringToken token=(StringToken)publish.get(i);
      String tokenString=token.stringValue();
      JsonObject msg=new JsonObject().putString(""String_Node_Str"",""String_Node_Str"").putString(""String_Node_Str"",_address).putString(""String_Node_Str"",tokenString);
      _sendTextFrame(msg);
    }
  }
  if (_buffer != null) {
    List<StringToken> _bufferCopy=new ArrayList<StringToken>();
synchronized (_buffer) {
      if (_buffer.size() > 0) {
        _bufferCopy.addAll(_buffer);
        _buffer.clear();
      }
    }
    for (int i=0; i < _bufferCopy.size(); i++) {
      subscribe.send(0,_bufferCopy.get(i));
    }
  }
}"
72629,"/** 
 * Open a web socket that serves as a connection to the event bus.
 */
private synchronized void _openWebSocket(){
  if (!_stopRequested) {
    MultiMap map=new CaseInsensitiveMultiMap();
    map.add(""String_Node_Str"",""String_Node_Str"");
    _client.setConnectTimeout(100000000);
    _client.connectWebsocket(""String_Node_Str"",WebSocketVersion.RFC6455,map,new Handler<WebSocket>(){
      @Override public void handle(      WebSocket websocket){
        JsonObject msg=new JsonObject().putString(""String_Node_Str"",""String_Node_Str"").putString(""String_Node_Str"",_address);
        websocket.writeTextFrame(msg.encode());
        _websocket=websocket;
        websocket.dataHandler(new Handler<Buffer>(){
          @Override public void handle(          Buffer buff){
            String msg=buff.toString();
            JsonObject received=new JsonObject(msg);
            if (_buffer == null) {
              _buffer=new ArrayList<StringToken>();
            }
synchronized (_buffer) {
              _buffer.add(new StringToken(received.getField(""String_Node_Str"").toString()));
            }
            try {
              getDirector().fireAtCurrentRealTime((Actor)subscribe.getContainer());
            }
 catch (            IllegalActionException e) {
              e.printStackTrace();
            }
          }
        }
);
        websocket.closeHandler(new Handler<Void>(){
          @Override public void handle(          final Void event){
          }
        }
);
      }
    }
);
  }
}","/** 
 * Open a web socket that serves as a connection to the event bus.
 */
private synchronized void _openWebSocket(){
  if (!_stopRequested) {
    _client.connectWebsocket(""String_Node_Str"",new Handler<WebSocket>(){
      @Override public void handle(      WebSocket websocket){
        JsonObject msg=new JsonObject().putString(""String_Node_Str"",""String_Node_Str"").putString(""String_Node_Str"",_address);
        websocket.writeTextFrame(msg.encode());
        _websocket=websocket;
        websocket.dataHandler(new Handler<Buffer>(){
          @Override public void handle(          Buffer buff){
            String msg=buff.toString();
            JsonObject received=new JsonObject(msg);
            if (_buffer == null) {
              _buffer=new ArrayList<StringToken>();
            }
synchronized (_buffer) {
              _buffer.add(new StringToken(received.getField(""String_Node_Str"").toString()));
            }
            try {
              getDirector().fireAtCurrentRealTime((Actor)subscribe.getContainer());
            }
 catch (            IllegalActionException e) {
              e.printStackTrace();
            }
          }
        }
);
      }
    }
);
    _client.exceptionHandler(new Handler<Throwable>(){
      @Override public void handle(      Throwable event){
        _exception=event;
        _vertx.cancelTimer(_periodicPing);
      }
    }
);
  }
}"
72630,"@Override public void handle(final Void event){
}","@Override public void handle(Throwable event){
  _exception=event;
  _vertx.cancelTimer(_periodicPing);
}"
72631,"/** 
 * Initialize verticle, create http client and open web socket to connect to event bus.
 */
@Override public void initialize(){
  _vertx=VertxFactory.newVertx();
  _client=_vertx.createHttpClient().setHost(_host).setPort(_port);
  _openWebSocket();
  _vertx.setPeriodic(1000,new Handler<Long>(){
    @Override public void handle(    Long timerID){
      JsonObject json=new JsonObject().putString(""String_Node_Str"",""String_Node_Str"");
      _websocket.writeTextFrame(json.encode());
    }
  }
);
}","/** 
 * Initialize verticle, create http client and open web socket to connect to event bus.
 * @throws IllegalActionException 
 */
@Override public void initialize() throws IllegalActionException {
  _exception=null;
  _vertx=VertxFactory.newVertx();
  _client=_vertx.createHttpClient().setHost(_host).setPort(_port);
  _openWebSocket();
  _periodicPing=_vertx.setPeriodic(1000,new Handler<Long>(){
    @Override public void handle(    Long timerID){
      JsonObject json=new JsonObject().putString(""String_Node_Str"",""String_Node_Str"");
      try {
        _sendTextFrame(json);
      }
 catch (      IllegalActionException e) {
        e.printStackTrace();
      }
    }
  }
);
}"
72632,"/** 
 * Read date tokens from the input and store them until the real time equals the date in the token. If the date token on the input contains a date in the past, an exception is thrown.
 * @exception Thrown if the input date in the date token lies in the past.
 */
@Override public void fire() throws IllegalActionException {
  super.fire();
  long systemTime=System.currentTimeMillis();
  Time time=_director.getModelTime();
  if (_outputTokensForChannel != null && _outputTokensForChannel.size() > 0) {
    Time t=(Collections.min(_outputTokensForChannel.keySet()));
    if (t.compareTo(time) == 0) {
      List<Integer> channels=_outputTokensForChannel.get(t);
      for (int i=0; i < channels.size(); i++) {
        output.send(channels.get(i),new DateToken(systemTime));
      }
      _outputTokensForChannel.remove(t);
    }
  }
  for (int channel=0; channel < input.getWidth(); channel++) {
    if (input.hasToken(0)) {
      DateToken token=(DateToken)input.get(0);
      if (token.getCalendarInstance().getTimeInMillis() < systemTime) {
        throw new IllegalActionException(this,""String_Node_Str"" + token.toString() + ""String_Node_Str"");
      }
 else {
        Time fireTime=new Time(_director,(token.getCalendarInstance().getTimeInMillis() - _director.getRealStartTimeMillis()) * _director.localClock.getTimeResolution());
        _director.fireAt(this,fireTime);
        if (_outputTokensForChannel == null) {
          _outputTokensForChannel=new HashMap<Time,List<Integer>>();
        }
        List<Integer> channels=_outputTokensForChannel.get(fireTime);
        if (channels == null) {
          channels=new ArrayList<Integer>();
        }
        channels.add(channel);
        _outputTokensForChannel.put(fireTime,channels);
      }
    }
  }
}","/** 
 * Read date tokens from the input and store them until the real time equals the date in the token. If the date token on the input contains a date in the past, an exception is thrown.
 * @exception IllegalActionException Thrown if the input date in the date token lies in the past.
 */
@Override public void fire() throws IllegalActionException {
  super.fire();
  long systemTime=System.currentTimeMillis();
  Time time=_director.getModelTime();
  if (_outputTokensForChannel != null && _outputTokensForChannel.size() > 0) {
    Time t=(Collections.min(_outputTokensForChannel.keySet()));
    if (t.compareTo(time) == 0) {
      List<Integer> channels=_outputTokensForChannel.get(t);
      for (int i=0; i < channels.size(); i++) {
        output.send(channels.get(i),new DateToken(systemTime));
      }
      _outputTokensForChannel.remove(t);
    }
  }
  for (int channel=0; channel < input.getWidth(); channel++) {
    if (input.hasToken(0)) {
      DateToken token=(DateToken)input.get(0);
      if (token.getCalendarInstance().getTimeInMillis() < systemTime) {
        throw new IllegalActionException(this,""String_Node_Str"" + token.toString() + ""String_Node_Str"");
      }
 else {
        long realTimeDifference=token.getCalendarInstance().getTimeInMillis() - _director.getRealStartTimeMillis();
        Time fireTime=new Time(_director,realTimeDifference * _director.localClock.getTimeResolution());
        _director.fireAt(this,fireTime);
        if (_outputTokensForChannel == null) {
          _outputTokensForChannel=new HashMap<Time,List<Integer>>();
        }
        List<Integer> channels=_outputTokensForChannel.get(fireTime);
        if (channels == null) {
          channels=new ArrayList<Integer>();
        }
        channels.add(channel);
        _outputTokensForChannel.put(fireTime,channels);
      }
    }
  }
}"
72633,"@Override public void fire() throws IllegalActionException {
  super.fire();
  for (int i=0; i < input.getWidth(); i++) {
    if (input.hasToken(i)) {
      input.get(i);
    }
    long time=(long)(_director.getModelTime().getDoubleValue() / _director.localClock.getTimeResolution()) + _director.getRealStartTimeMillis();
    output.send(0,new DateToken(time));
  }
}","/** 
 * Output a DateToken with a date that corresponds to the current model time.
 * @exception IllegalActionException Not thrown here. 
 */
@Override public void fire() throws IllegalActionException {
  super.fire();
  for (int channel=0; channel < input.getWidth(); channel++) {
    if (input.hasToken(channel)) {
      input.get(channel);
    }
    double modelTimeSinceStart=_director.getModelTime().getDoubleValue() - _director.getModelStartTime().getDoubleValue();
    long time=(long)(modelTimeSinceStart / _director.localClock.getTimeResolution()) + _director.getRealStartTimeMillis();
    output.send(channel,new DateToken(time));
  }
}"
72634,"/** 
 * Construct a date token with all tokens present. If a token for the long value is present, use this token and time zone as well as precision. Otherwise use tokens on other inputs to create ports.
 * @exception IllegalActionException If there is no director.
 */
@Override public void fire() throws IllegalActionException {
  super.fire();
  DateToken dateToken=null;
  int datePrecision=DateToken.PRECISION_MILLISECOND;
  if (timeInMillis.connectedPortList().size() > 0 && timeInMillis.hasToken(0)) {
    long timeAsLongValue=1l;
    timeAsLongValue=((LongToken)timeInMillis.get(0)).longValue();
    String precisionValue=""String_Node_Str"";
    precisionValue=((StringToken)precision.getToken()).stringValue();
    if (precisionValue.equals(""String_Node_Str"")) {
      datePrecision=DateToken.PRECISION_SECOND;
    }
    if (precisionValue.equals(""String_Node_Str"")) {
      datePrecision=DateToken.PRECISION_MILLISECOND;
    }
    if (precisionValue.equals(""String_Node_Str"")) {
      datePrecision=DateToken.PRECISION_MICROSECOND;
    }
    if (precisionValue.equals(""String_Node_Str"")) {
      datePrecision=DateToken.PRECISION_NANOSECOND;
    }
 else {
      datePrecision=DateToken.PRECISION_MILLISECOND;
    }
    String timeZoneValue=TimeZone.getDefault().getID();
    if ((timeZone.connectedPortList().size() > 0) && timeZone.hasToken(0)) {
      timeZoneValue=((StringToken)timeZone.get(0)).stringValue();
    }
    dateToken=new DateToken(timeAsLongValue,datePrecision,TimeZone.getTimeZone(timeZoneValue));
  }
 else {
    int yearValue=1970;
    if (year.connectedPortList().size() > 0 && year.hasToken(0)) {
      yearValue=((IntToken)year.get(0)).intValue();
    }
    int monthValue=1;
    if (month.connectedPortList().size() > 0 && month.hasToken(0)) {
      monthValue=((IntToken)month.get(0)).intValue();
    }
    int dayValue=1;
    if (day.connectedPortList().size() > 0 && day.hasToken(0)) {
      dayValue=((IntToken)day.get(0)).intValue();
    }
    int hourValue=0;
    if (hour.connectedPortList().size() > 0 && hour.hasToken(0)) {
      hourValue=((IntToken)hour.get(0)).intValue();
    }
    int minuteValue=0;
    if (minute.connectedPortList().size() > 0 && minute.hasToken(0)) {
      minuteValue=((IntToken)minute.get(0)).intValue();
    }
    int secondValue=0;
    if (second.connectedPortList().size() > 0 && second.hasToken(0)) {
      secondValue=((IntToken)second.get(0)).intValue();
      datePrecision=DateToken.PRECISION_SECOND;
    }
    int millisecondValue=0;
    if (millisecond.connectedPortList().size() > 0 && millisecond.hasToken(0)) {
      millisecondValue=((IntToken)millisecond.get(0)).intValue();
      datePrecision=DateToken.PRECISION_MILLISECOND;
    }
    int microsecondValue=0;
    if (microsecond.connectedPortList().size() > 0 && microsecond.hasToken(0)) {
      microsecondValue=((IntToken)microsecond.get(0)).intValue();
      datePrecision=DateToken.PRECISION_MICROSECOND;
    }
    int nanosecondValue=0;
    if (nanosecond.connectedPortList().size() > 0 && nanosecond.hasToken(0)) {
      nanosecondValue=((IntToken)nanosecond.get(0)).intValue();
      datePrecision=DateToken.PRECISION_NANOSECOND;
    }
    String timeZoneValue=TimeZone.getDefault().getID();
    if ((timeZone.connectedPortList().size() > 0) && timeZone.hasToken(0)) {
      timeZoneValue=((StringToken)timeZone.get(0)).stringValue();
    }
    Calendar c=Calendar.getInstance();
    c.set(Calendar.YEAR,yearValue);
    c.set(Calendar.MONTH,monthValue);
    c.set(Calendar.DAY_OF_MONTH,dayValue);
    c.set(Calendar.HOUR,hourValue);
    c.set(Calendar.MINUTE,minuteValue);
    c.set(Calendar.SECOND,secondValue);
    c.set(Calendar.MILLISECOND,millisecondValue);
    c.setTimeZone(TimeZone.getTimeZone(timeZoneValue));
    dateToken=new DateToken(c.getTimeInMillis(),DateToken.PRECISION_MILLISECOND,TimeZone.getTimeZone(timeZoneValue));
    dateToken.addMicroseconds(microsecondValue);
    dateToken.addNanoseconds(nanosecondValue);
  }
  output.send(0,dateToken);
}","/** 
 * Construct a date token with all tokens present. If a token for the long value is present, use this token and time zone as well as precision. Otherwise use tokens on other inputs to create ports.
 * @exception IllegalActionException If there is no director.
 */
@Override public void fire() throws IllegalActionException {
  super.fire();
  DateToken dateToken=null;
  int datePrecision=DateToken.PRECISION_MILLISECOND;
  String precisionValue=((StringToken)precision.getToken()).stringValue();
  if (precisionValue.equals(""String_Node_Str"")) {
    datePrecision=DateToken.PRECISION_SECOND;
  }
  if (precisionValue.equals(""String_Node_Str"")) {
    datePrecision=DateToken.PRECISION_MILLISECOND;
  }
  if (precisionValue.equals(""String_Node_Str"")) {
    datePrecision=DateToken.PRECISION_MICROSECOND;
  }
  if (precisionValue.equals(""String_Node_Str"")) {
    datePrecision=DateToken.PRECISION_NANOSECOND;
  }
 else {
    datePrecision=DateToken.PRECISION_MILLISECOND;
  }
  String timeZoneValue=_getStringValue(timeZone);
  long timeAsLongValue=_getLongValue(timeInMillis);
  int microsecondValue=_getIntValue(microsecond);
  int nanosecondValue=_getIntValue(nanosecond);
  if (!((BooleanToken)useTimeInMillis.getToken()).booleanValue()) {
    int yearValue=_getIntValue(year);
    int monthValue=_getIntValue(month);
    int dayValue=_getIntValue(day);
    int hourValue=_getIntValue(hour);
    int minuteValue=_getIntValue(minute);
    int secondValue=_getIntValue(second);
    int millisecondValue=_getIntValue(millisecond);
    Calendar c=Calendar.getInstance();
    c.set(Calendar.YEAR,yearValue);
    c.set(Calendar.MONTH,monthValue);
    c.set(Calendar.DAY_OF_MONTH,dayValue);
    c.set(Calendar.HOUR,hourValue);
    c.set(Calendar.MINUTE,minuteValue);
    c.set(Calendar.SECOND,secondValue);
    c.set(Calendar.MILLISECOND,millisecondValue);
    timeAsLongValue=c.getTimeInMillis();
  }
  dateToken=new DateToken(timeAsLongValue,datePrecision,TimeZone.getTimeZone(""String_Node_Str"" + timeZoneValue));
  dateToken.addMicroseconds(microsecondValue);
  dateToken.addNanoseconds(nanosecondValue);
  output.send(0,dateToken);
}"
72635,"/** 
 * Construct an actor with the given container and name.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public DateConstructor(CompositeEntity container,String name) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  output=new TypedIOPort(this,""String_Node_Str"",false,true);
  output.setTypeEquals(BaseType.DATE);
  year=new TypedIOPort(this,""String_Node_Str"",true,false);
  year.setTypeEquals(BaseType.INT);
  new SingletonParameter(year,""String_Node_Str"").setToken(BooleanToken.TRUE);
  month=new TypedIOPort(this,""String_Node_Str"",true,false);
  month.setTypeEquals(BaseType.INT);
  new SingletonParameter(year,""String_Node_Str"").setToken(BooleanToken.TRUE);
  day=new TypedIOPort(this,""String_Node_Str"",true,false);
  day.setTypeEquals(BaseType.INT);
  new SingletonParameter(day,""String_Node_Str"").setToken(BooleanToken.TRUE);
  hour=new TypedIOPort(this,""String_Node_Str"",true,false);
  hour.setTypeEquals(BaseType.INT);
  new SingletonParameter(hour,""String_Node_Str"").setToken(BooleanToken.TRUE);
  minute=new TypedIOPort(this,""String_Node_Str"",true,false);
  minute.setTypeEquals(BaseType.INT);
  new SingletonParameter(minute,""String_Node_Str"").setToken(BooleanToken.TRUE);
  second=new TypedIOPort(this,""String_Node_Str"",true,false);
  second.setTypeEquals(BaseType.INT);
  new SingletonParameter(minute,""String_Node_Str"").setToken(BooleanToken.TRUE);
  millisecond=new TypedIOPort(this,""String_Node_Str"",true,false);
  millisecond.setTypeEquals(BaseType.INT);
  new SingletonParameter(millisecond,""String_Node_Str"").setToken(BooleanToken.TRUE);
  microsecond=new TypedIOPort(this,""String_Node_Str"",true,false);
  microsecond.setTypeEquals(BaseType.INT);
  new SingletonParameter(microsecond,""String_Node_Str"").setToken(BooleanToken.TRUE);
  nanosecond=new TypedIOPort(this,""String_Node_Str"",true,false);
  nanosecond.setTypeEquals(BaseType.INT);
  new SingletonParameter(microsecond,""String_Node_Str"").setToken(BooleanToken.TRUE);
  timeZone=new TypedIOPort(this,""String_Node_Str"",true,false);
  timeZone.setTypeEquals(BaseType.STRING);
  new SingletonParameter(timeZone,""String_Node_Str"").setToken(BooleanToken.TRUE);
  timeInMillis=new TypedIOPort(this,""String_Node_Str"",true,false);
  timeInMillis.setTypeEquals(BaseType.LONG);
  new SingletonParameter(timeInMillis,""String_Node_Str"").setToken(BooleanToken.TRUE);
  precision=new StringParameter(this,""String_Node_Str"");
  precision.addChoice(""String_Node_Str"");
  precision.addChoice(""String_Node_Str"");
  precision.addChoice(""String_Node_Str"");
  precision.addChoice(""String_Node_Str"");
  precision.setExpression(""String_Node_Str"");
}","/** 
 * Construct an actor with the given container and name.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public DateConstructor(CompositeEntity container,String name) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  output=new TypedIOPort(this,""String_Node_Str"",false,true);
  output.setTypeEquals(BaseType.DATE);
  year=new PortParameter(this,""String_Node_Str"",new IntToken(0));
  new SingletonParameter(year.getPort(),""String_Node_Str"").setToken(BooleanToken.TRUE);
  month=new PortParameter(this,""String_Node_Str"",new IntToken(0));
  month.setTypeEquals(BaseType.INT);
  new SingletonParameter(month.getPort(),""String_Node_Str"").setToken(BooleanToken.TRUE);
  day=new PortParameter(this,""String_Node_Str"",new IntToken(1));
  day.setTypeEquals(BaseType.INT);
  new SingletonParameter(day.getPort(),""String_Node_Str"").setToken(BooleanToken.TRUE);
  hour=new PortParameter(this,""String_Node_Str"",new IntToken(0));
  hour.setTypeEquals(BaseType.INT);
  new SingletonParameter(hour.getPort(),""String_Node_Str"").setToken(BooleanToken.TRUE);
  minute=new PortParameter(this,""String_Node_Str"",new IntToken(0));
  minute.setTypeEquals(BaseType.INT);
  new SingletonParameter(minute.getPort(),""String_Node_Str"").setToken(BooleanToken.TRUE);
  second=new PortParameter(this,""String_Node_Str"",new IntToken(0));
  second.setTypeEquals(BaseType.INT);
  new SingletonParameter(second.getPort(),""String_Node_Str"").setToken(BooleanToken.TRUE);
  millisecond=new PortParameter(this,""String_Node_Str"",new IntToken(0));
  millisecond.setTypeEquals(BaseType.INT);
  new SingletonParameter(millisecond.getPort(),""String_Node_Str"").setToken(BooleanToken.TRUE);
  microsecond=new PortParameter(this,""String_Node_Str"",new IntToken(0));
  microsecond.setTypeEquals(BaseType.INT);
  new SingletonParameter(microsecond.getPort(),""String_Node_Str"").setToken(BooleanToken.TRUE);
  nanosecond=new PortParameter(this,""String_Node_Str"",new IntToken(0));
  nanosecond.setTypeEquals(BaseType.INT);
  new SingletonParameter(nanosecond.getPort(),""String_Node_Str"").setToken(BooleanToken.TRUE);
  timeZone=new PortParameter(this,""String_Node_Str"",new StringToken(""String_Node_Str""));
  timeZone.setTypeEquals(BaseType.STRING);
  new SingletonParameter(timeZone.getPort(),""String_Node_Str"").setToken(BooleanToken.TRUE);
  useTimeInMillis=new Parameter(this,""String_Node_Str"",new BooleanToken(false));
  useTimeInMillis.setTypeEquals(BaseType.BOOLEAN);
  timeInMillis=new PortParameter(this,""String_Node_Str"",new IntToken(0));
  timeInMillis.setTypeEquals(BaseType.LONG);
  new SingletonParameter(timeInMillis.getPort(),""String_Node_Str"").setToken(BooleanToken.TRUE);
  precision=new StringParameter(this,""String_Node_Str"");
  precision.addChoice(""String_Node_Str"");
  precision.addChoice(""String_Node_Str"");
  precision.addChoice(""String_Node_Str"");
  precision.addChoice(""String_Node_Str"");
  precision.setExpression(""String_Node_Str"");
}"
72636,"/** 
 * Output all elements of a date if input has a date token.
 * @exception IllegalActionException If there is no director.
 */
@Override public void fire() throws IllegalActionException {
  super.fire();
  if (input.hasToken(0)) {
    Token token=input.get(0);
    if (token instanceof DateToken) {
      DateToken dateToken=(DateToken)token;
      year.send(0,new IntToken(dateToken.getYear()));
      month.send(0,new IntToken(dateToken.getMonth()));
      day.send(0,new IntToken(dateToken.getDay()));
      hour.send(0,new IntToken(dateToken.getHour()));
      minute.send(0,new IntToken(dateToken.getMinute()));
      second.send(0,new IntToken(dateToken.getSecond()));
      millisecond.send(0,new IntToken(dateToken.getMillisecond()));
      microsecond.send(0,new IntToken(dateToken.getMicrosecond()));
      nanosecond.send(0,new IntToken(dateToken.getNanosecond()));
      timezone.send(0,new StringToken(dateToken.getTimezoneID()));
      timeInMillis.send(0,new LongToken(dateToken.getCalendarInstance().getTimeInMillis()));
    }
  }
}","/** 
 * Output all elements of a date if input has a date token.
 * @exception IllegalActionException If there is no director.
 */
@Override public void fire() throws IllegalActionException {
  super.fire();
  if (input.hasToken(0)) {
    Token token=input.get(0);
    if (token instanceof DateToken) {
      DateToken dateToken=(DateToken)token;
      year.send(0,new IntToken(dateToken.getYear()));
      month.send(0,new IntToken(dateToken.getMonth()));
      day.send(0,new IntToken(dateToken.getDay()));
      hour.send(0,new IntToken(dateToken.getHour()));
      minute.send(0,new IntToken(dateToken.getMinute()));
      second.send(0,new IntToken(dateToken.getSecond()));
      millisecond.send(0,new IntToken(dateToken.getMillisecond()));
      microsecond.send(0,new IntToken(dateToken.getMicrosecond()));
      nanosecond.send(0,new IntToken(dateToken.getNanosecond()));
      SimpleDateFormat sdf=new SimpleDateFormat(""String_Node_Str"");
      sdf.setTimeZone(dateToken.getTimeZone());
      timezone.send(0,new StringToken(sdf.format(dateToken.getCalendarInstance().getTime())));
      timeInMillis.send(0,new LongToken(dateToken.getCalendarInstance().getTimeInMillis()));
    }
  }
}"
72637,"/** 
 * Construct a DateToken that represents the time specified as a string. The string is first parsed by the default java.text.DateFormat parser. Because we have up to nanosecond precision, we might have to pre-process the string and take out the digits representing nanoseconds and microseconds. Then any leading and trailing double quotes are removed and a java.text.SimpleDateFormat with a parser with the value of  {@link #_SIMPLE_DATE_FORMAT} is used.
 * @param value The date specified in a format acceptableto java.text.DateFormat.
 * @exception IllegalActionException If the date is notparseable by java.text.DateFormat.
 */
public DateToken(String value) throws IllegalActionException {
  _precision=PRECISION_MILLISECOND;
  if (value == null) {
    _isNil=false;
    _value=0l;
    return;
  }
  if (value.equals(_NIL)) {
    _isNil=true;
    _value=0l;
    return;
  }
  String dateString=value;
synchronized (_SIMPLE_DATE_FORMAT) {
    try {
      if (value.startsWith(""String_Node_Str"") && value.endsWith(""String_Node_Str"")) {
        value=value.substring(1,value.length() - 1);
      }
      Calendar calendar=Calendar.getInstance();
      if (value.length() == _SIMPLE_DATE_FORMAT.length()) {
        calendar.setTime(_simpleDateFormat.parse(value));
        _value=calendar.getTimeInMillis();
        _precision=PRECISION_MILLISECOND;
      }
 else       if (value.length() == _SIMPLE_DATE_FORMAT.length() + 3) {
        String micros=value.substring(value.indexOf(""String_Node_Str"") + 4,value.indexOf(""String_Node_Str"") + 7);
        value=value.substring(0,value.indexOf(""String_Node_Str"") + 4) + value.substring(value.indexOf(""String_Node_Str"") + 7);
        calendar.setTime(_simpleDateFormat.parse(value));
        _value=calendar.getTimeInMillis();
        _value=_value * 1000 + Integer.parseInt(micros);
        _precision=PRECISION_MICROSECOND;
      }
 else       if (value.length() == _SIMPLE_DATE_FORMAT.length() + 6) {
        String micros=value.substring(value.indexOf(""String_Node_Str"") + 4,value.indexOf(""String_Node_Str"") + 7);
        String nanos=value.substring(value.indexOf(""String_Node_Str"") + 7,value.indexOf(""String_Node_Str"") + 10);
        value=value.substring(0,value.indexOf(""String_Node_Str"") + 4) + value.substring(value.indexOf(""String_Node_Str"") + 10);
        calendar.setTime(_simpleDateFormat.parse(value));
        _value=calendar.getTimeInMillis();
        _value=(_value * 1000 + Integer.parseInt(micros)) * 1000 + Integer.parseInt(nanos);
        _precision=PRECISION_NANOSECOND;
      }
 else {
        throw new IllegalActionException(null,""String_Node_Str"" + ""String_Node_Str"" + dateString + ""String_Node_Str""+ _SIMPLE_DATE_FORMAT);
      }
      int offset=(calendar.get(Calendar.ZONE_OFFSET) + calendar.get(Calendar.DST_OFFSET)) / (60 * 60 * 1000);
      _timeZone=TimeZone.getTimeZone(""String_Node_Str"" + offset);
      calendar.setTimeZone(_timeZone);
      _calendar=calendar;
    }
 catch (    ParseException ex) {
      throw new IllegalActionException(null,ex,""String_Node_Str"" + value + ""String_Node_Str""+ ""String_Node_Str""+ _simpleDateFormat.toPattern()+ ""String_Node_Str""+ ex.getMessage());
    }
  }
  _isNil=false;
}","/** 
 * Construct a DateToken that represents the time specified as a string. The string is first parsed by the default java.text.DateFormat parser. Because we have up to nanosecond precision, we might have to pre-process the string and take out the digits representing nanoseconds and microseconds. Then any leading and trailing double quotes are removed and a java.text.SimpleDateFormat with a parser with the value of  {@link #_SIMPLE_DATE_FORMAT} is used.
 * @param value The date specified in a format acceptableto java.text.DateFormat.
 * @exception IllegalActionException If the date is notparseable by java.text.DateFormat.
 */
public DateToken(String value) throws IllegalActionException {
  _precision=PRECISION_MILLISECOND;
  if (value == null) {
    _isNil=false;
    _value=0l;
    return;
  }
  if (value.equals(_NIL)) {
    _isNil=true;
    _value=0l;
    return;
  }
  String dateString=value;
synchronized (_SIMPLE_DATE_FORMAT) {
    try {
      if (value.startsWith(""String_Node_Str"") && value.endsWith(""String_Node_Str"")) {
        value=value.substring(1,value.length() - 1);
      }
      Calendar calendar=Calendar.getInstance();
      if (value.length() == _SIMPLE_DATE_FORMAT.length()) {
        calendar.setTime(_simpleDateFormat.parse(value));
        _value=calendar.getTimeInMillis();
        _precision=PRECISION_MILLISECOND;
      }
 else       if (value.length() == _SIMPLE_DATE_FORMAT.length() + 3) {
        String micros=value.substring(value.indexOf(""String_Node_Str"") + 4,value.indexOf(""String_Node_Str"") + 7);
        value=value.substring(0,value.indexOf(""String_Node_Str"") + 4) + value.substring(value.indexOf(""String_Node_Str"") + 7);
        calendar.setTime(_simpleDateFormat.parse(value));
        _value=calendar.getTimeInMillis();
        _value=_value * 1000 + Integer.parseInt(micros);
        _precision=PRECISION_MICROSECOND;
      }
 else       if (value.length() == _SIMPLE_DATE_FORMAT.length() + 6) {
        String micros=value.substring(value.indexOf(""String_Node_Str"") + 4,value.indexOf(""String_Node_Str"") + 7);
        String nanos=value.substring(value.indexOf(""String_Node_Str"") + 7,value.indexOf(""String_Node_Str"") + 10);
        value=value.substring(0,value.indexOf(""String_Node_Str"") + 4) + value.substring(value.indexOf(""String_Node_Str"") + 10);
        calendar.setTime(_simpleDateFormat.parse(value));
        _value=calendar.getTimeInMillis();
        _value=(_value * 1000 + Integer.parseInt(micros)) * 1000 + Integer.parseInt(nanos);
        _precision=PRECISION_NANOSECOND;
      }
 else {
        throw new IllegalActionException(null,""String_Node_Str"" + ""String_Node_Str"" + dateString + ""String_Node_Str""+ _SIMPLE_DATE_FORMAT);
      }
      String timeZoneOffset=value.substring(24,29);
      int offset=(calendar.get(Calendar.ZONE_OFFSET) + calendar.get(Calendar.DST_OFFSET)) / (60 * 60 * 1000);
      _timeZone=TimeZone.getTimeZone(""String_Node_Str"" + timeZoneOffset);
      calendar.setTimeZone(_timeZone);
      _calendar=calendar;
    }
 catch (    ParseException ex) {
      throw new IllegalActionException(null,ex,""String_Node_Str"" + value + ""String_Node_Str""+ ""String_Node_Str""+ _simpleDateFormat.toPattern()+ ""String_Node_Str""+ ex.getMessage());
    }
  }
  _isNil=false;
}"
72638,"/** 
 * Wrap up, close web socket if open, stop vertx.
 */
@Override public synchronized void wrapup() throws IllegalActionException {
  super.wrapup();
  if (_websocket != null) {
    _websocket.close();
  }
  if (_client != null) {
    _client.close();
  }
  _vertx.stop();
}","/** 
 * Wrap up, close web socket if open, stop vertx.
 */
@Override public synchronized void wrapup() throws IllegalActionException {
  super.wrapup();
  _vertx.cancelTimer(_periodicPing);
  _vertx.stop();
}"
72639,"/** 
 * Initialize verticle, create http client and open web socket to connect to event bus.
 * @throws IllegalActionException 
 */
@Override public void initialize() throws IllegalActionException {
  _exception=null;
  _vertx=VertxFactory.newVertx();
  _client=_vertx.createHttpClient().setHost(_host).setPort(_port);
  _openWebSocket();
  _periodicPing=_vertx.setPeriodic(1000,new Handler<Long>(){
    @Override public void handle(    Long timerID){
      JsonObject json=new JsonObject().putString(""String_Node_Str"",""String_Node_Str"");
      try {
        _sendTextFrame(json);
      }
 catch (      IllegalActionException e) {
        e.printStackTrace();
      }
    }
  }
);
}","/** 
 * Initialize verticle, create http client and open web socket to connect to event bus.
 * @throws IllegalActionException 
 */
@Override public void initialize() throws IllegalActionException {
  _exception=null;
  _vertx=VertxFactory.newVertx();
  _client=_vertx.createHttpClient().setHost(_host).setPort(_port);
  _openWebSocket();
  _periodicPing=_vertx.setPeriodic(1000,new Handler<Long>(){
    @Override public void handle(    Long timerID){
      JsonObject json=new JsonObject().putString(""String_Node_Str"",""String_Node_Str"");
      try {
        _sendTextFrame(json);
      }
 catch (      IllegalActionException e) {
        _exception=e;
      }
    }
  }
);
}"
72640,"/** 
 * Construct a date token with all tokens present. If a token for the long value is present, use this token and time zone as well as precision. Otherwise use tokens on other inputs to create ports.
 * @exception IllegalActionException If there is no director.
 */
@Override public void fire() throws IllegalActionException {
  super.fire();
  DateToken dateToken=null;
  int datePrecision=DateToken.PRECISION_MILLISECOND;
  if (timeAsLong.connectedPortList().size() > 0 && timeAsLong.hasToken(0)) {
    long timeAsLongValue=1l;
    timeAsLongValue=((LongToken)timeAsLong.get(0)).longValue();
    String precisionValue=""String_Node_Str"";
    precisionValue=((StringToken)precision.getToken()).stringValue();
    if (precisionValue.equals(""String_Node_Str"")) {
      datePrecision=DateToken.PRECISION_SECOND;
    }
    if (precisionValue.equals(""String_Node_Str"")) {
      datePrecision=DateToken.PRECISION_MILLISECOND;
    }
    if (precisionValue.equals(""String_Node_Str"")) {
      datePrecision=DateToken.PRECISION_MICROSECOND;
    }
    if (precisionValue.equals(""String_Node_Str"")) {
      datePrecision=DateToken.PRECISION_NANOSECOND;
    }
 else {
      datePrecision=DateToken.PRECISION_MILLISECOND;
    }
    String timeZoneValue=TimeZone.getDefault().getID();
    if ((timeZone.connectedPortList().size() > 0) && timeZone.hasToken(0)) {
      timeZoneValue=((StringToken)timeZone.get(0)).stringValue();
    }
    dateToken=new DateToken(timeAsLongValue,datePrecision,TimeZone.getTimeZone(timeZoneValue));
  }
 else {
    int yearValue=1970;
    if (year.connectedPortList().size() > 0 && year.hasToken(0)) {
      yearValue=((IntToken)year.get(0)).intValue();
    }
    int monthValue=1;
    if (month.connectedPortList().size() > 0 && month.hasToken(0)) {
      monthValue=((IntToken)month.get(0)).intValue();
    }
    int dayValue=1;
    if (day.connectedPortList().size() > 0 && day.hasToken(0)) {
      dayValue=((IntToken)day.get(0)).intValue();
    }
    int hourValue=0;
    if (hour.connectedPortList().size() > 0 && hour.hasToken(0)) {
      hourValue=((IntToken)hour.get(0)).intValue();
    }
    int minuteValue=0;
    if (minute.connectedPortList().size() > 0 && minute.hasToken(0)) {
      minuteValue=((IntToken)minute.get(0)).intValue();
    }
    int secondValue=0;
    if (second.connectedPortList().size() > 0 && second.hasToken(0)) {
      secondValue=((IntToken)second.get(0)).intValue();
      datePrecision=DateToken.PRECISION_SECOND;
    }
    int millisecondValue=0;
    if (millisecond.connectedPortList().size() > 0 && millisecond.hasToken(0)) {
      millisecondValue=((IntToken)millisecond.get(0)).intValue();
      datePrecision=DateToken.PRECISION_MILLISECOND;
    }
    int microsecondValue=0;
    if (microsecond.connectedPortList().size() > 0 && microsecond.hasToken(0)) {
      microsecondValue=((IntToken)microsecond.get(0)).intValue();
      datePrecision=DateToken.PRECISION_MICROSECOND;
    }
    int nanosecondValue=0;
    if (nanosecond.connectedPortList().size() > 0 && nanosecond.hasToken(0)) {
      nanosecondValue=((IntToken)nanosecond.get(0)).intValue();
      datePrecision=DateToken.PRECISION_NANOSECOND;
    }
    String timeZoneValue=TimeZone.getDefault().getID();
    if (timeZone.connectedPortList().size() > 0 && timeZone.hasToken(0)) {
      timeZoneValue=((StringToken)timeZone.get(0)).stringValue();
    }
    dateToken=new DateToken();
    dateToken.getCalendarInstance().setTimeZone(TimeZone.getTimeZone(timeZoneValue));
    dateToken.getCalendarInstance().set(Calendar.YEAR,yearValue);
    dateToken.getCalendarInstance().set(Calendar.MONTH,monthValue);
    dateToken.getCalendarInstance().set(Calendar.DAY_OF_MONTH,dayValue);
    dateToken.getCalendarInstance().set(Calendar.HOUR,hourValue);
    dateToken.getCalendarInstance().set(Calendar.MINUTE,minuteValue);
    dateToken.getCalendarInstance().set(Calendar.SECOND,secondValue);
    dateToken.getCalendarInstance().set(Calendar.MILLISECOND,millisecondValue);
    dateToken.addMicroseconds(microsecondValue);
    dateToken.addNanoseconds(nanosecondValue);
  }
  output.send(0,dateToken);
}","/** 
 * Construct a date token with all tokens present. If a token for the long value is present, use this token and time zone as well as precision. Otherwise use tokens on other inputs to create ports.
 * @exception IllegalActionException If there is no director.
 */
@Override public void fire() throws IllegalActionException {
  super.fire();
  DateToken dateToken=null;
  int datePrecision=DateToken.PRECISION_MILLISECOND;
  if (timeAsLong.connectedPortList().size() > 0 && timeAsLong.hasToken(0)) {
    long timeAsLongValue=1l;
    timeAsLongValue=((LongToken)timeAsLong.get(0)).longValue();
    String precisionValue=""String_Node_Str"";
    precisionValue=((StringToken)precision.getToken()).stringValue();
    if (precisionValue.equals(""String_Node_Str"")) {
      datePrecision=DateToken.PRECISION_SECOND;
    }
    if (precisionValue.equals(""String_Node_Str"")) {
      datePrecision=DateToken.PRECISION_MILLISECOND;
    }
    if (precisionValue.equals(""String_Node_Str"")) {
      datePrecision=DateToken.PRECISION_MICROSECOND;
    }
    if (precisionValue.equals(""String_Node_Str"")) {
      datePrecision=DateToken.PRECISION_NANOSECOND;
    }
 else {
      datePrecision=DateToken.PRECISION_MILLISECOND;
    }
    String timeZoneValue=TimeZone.getDefault().getID();
    if ((timeZone.connectedPortList().size() > 0) && timeZone.hasToken(0)) {
      timeZoneValue=((StringToken)timeZone.get(0)).stringValue();
    }
    dateToken=new DateToken(timeAsLongValue,datePrecision,TimeZone.getTimeZone(timeZoneValue));
  }
 else {
    int yearValue=1970;
    if (year.connectedPortList().size() > 0 && year.hasToken(0)) {
      yearValue=((IntToken)year.get(0)).intValue();
    }
    int monthValue=1;
    if (month.connectedPortList().size() > 0 && month.hasToken(0)) {
      monthValue=((IntToken)month.get(0)).intValue();
    }
    int dayValue=1;
    if (day.connectedPortList().size() > 0 && day.hasToken(0)) {
      dayValue=((IntToken)day.get(0)).intValue();
    }
    int hourValue=0;
    if (hour.connectedPortList().size() > 0 && hour.hasToken(0)) {
      hourValue=((IntToken)hour.get(0)).intValue();
    }
    int minuteValue=0;
    if (minute.connectedPortList().size() > 0 && minute.hasToken(0)) {
      minuteValue=((IntToken)minute.get(0)).intValue();
    }
    int secondValue=0;
    if (second.connectedPortList().size() > 0 && second.hasToken(0)) {
      secondValue=((IntToken)second.get(0)).intValue();
      datePrecision=DateToken.PRECISION_SECOND;
    }
    int millisecondValue=0;
    if (millisecond.connectedPortList().size() > 0 && millisecond.hasToken(0)) {
      millisecondValue=((IntToken)millisecond.get(0)).intValue();
      datePrecision=DateToken.PRECISION_MILLISECOND;
    }
    int microsecondValue=0;
    if (microsecond.connectedPortList().size() > 0 && microsecond.hasToken(0)) {
      microsecondValue=((IntToken)microsecond.get(0)).intValue();
      datePrecision=DateToken.PRECISION_MICROSECOND;
    }
    int nanosecondValue=0;
    if (nanosecond.connectedPortList().size() > 0 && nanosecond.hasToken(0)) {
      nanosecondValue=((IntToken)nanosecond.get(0)).intValue();
      datePrecision=DateToken.PRECISION_NANOSECOND;
    }
    String timeZoneValue=TimeZone.getDefault().getID();
    if ((timeZone.connectedPortList().size() > 0) && timeZone.hasToken(0)) {
      timeZoneValue=((StringToken)timeZone.get(0)).stringValue();
    }
    Calendar c=Calendar.getInstance();
    c.set(Calendar.YEAR,yearValue);
    c.set(Calendar.MONTH,monthValue);
    c.set(Calendar.DAY_OF_MONTH,dayValue);
    c.set(Calendar.HOUR,hourValue);
    c.set(Calendar.MINUTE,minuteValue);
    c.set(Calendar.SECOND,secondValue);
    c.set(Calendar.MILLISECOND,millisecondValue);
    c.setTimeZone(TimeZone.getTimeZone(timeZoneValue));
    dateToken=new DateToken(c.getTimeInMillis(),DateToken.PRECISION_MILLISECOND,TimeZone.getTimeZone(timeZoneValue));
    dateToken.addMicroseconds(microsecondValue);
    dateToken.addNanoseconds(nanosecondValue);
  }
  output.send(0,dateToken);
}"
72641,"/** 
 * Clone the actor.
 * @param workspace The workspace in which to place the cloned attribute.
 * @return The cloned attribute.
 * @exception CloneNotSupportedException Not thrown in this base class.
 * @see java.lang.Object#clone()
 */
@Override public Object clone(Workspace workspace) throws CloneNotSupportedException {
  WebSocketReader newObject=(WebSocketReader)super.clone(workspace);
  newObject._connection=null;
  newObject._connectionManager=_connectionManager;
  newObject._initializeModelTime=null;
  newObject._initializeRealTime=0L;
  newObject._isLocal=false;
  newObject._isShared=true;
  newObject._message=null;
  newObject._URIpath=null;
  return newObject;
}","/** 
 * Clone the actor.
 * @param workspace The workspace in which to place the cloned attribute.
 * @return The cloned attribute.
 * @exception CloneNotSupportedException Not thrown in this base class.
 * @see java.lang.Object#clone()
 */
@Override public Object clone(Workspace workspace) throws CloneNotSupportedException {
  WebSocketReader newObject=(WebSocketReader)super.clone(workspace);
  newObject._connection=null;
  newObject._connectionManager=WebSocketConnectionManager.getInstance();
  newObject._initializeModelTime=null;
  newObject._initializeRealTime=0L;
  newObject._isLocal=false;
  newObject._isShared=true;
  newObject._message=null;
  newObject._URIpath=null;
  return newObject;
}"
72642,"/** 
 * Clone the actor.
 * @param workspace The workspace in which to place the cloned attribute.
 * @return The cloned attribute.
 * @exception CloneNotSupportedException Not thrown in this base class.
 * @see java.lang.Object#clone()
 */
@Override public Object clone(Workspace workspace) throws CloneNotSupportedException {
  WebSocketWriter newObject=(WebSocketWriter)super.clone(workspace);
  newObject._connection=null;
  newObject._connectionManager=_connectionManager;
  newObject._connectionMonitor=new Object();
  newObject._connectionTimeout=5000;
  newObject._isLocal=false;
  newObject._isShared=true;
  newObject._URIpath=null;
  return newObject;
}","/** 
 * Clone the actor.
 * @param workspace The workspace in which to place the cloned attribute.
 * @return The cloned attribute.
 * @exception CloneNotSupportedException Not thrown in this base class.
 * @see java.lang.Object#clone()
 */
@Override public Object clone(Workspace workspace) throws CloneNotSupportedException {
  WebSocketWriter newObject=(WebSocketWriter)super.clone(workspace);
  newObject._connection=null;
  newObject._connectionManager=WebSocketConnectionManager.getInstance();
  newObject._connectionMonitor=new Object();
  newObject._connectionTimeout=5000;
  newObject._isLocal=false;
  newObject._isShared=true;
  newObject._URIpath=null;
  return newObject;
}"
72643,"/** 
 * Constructs a FactorOracle object.
 * @param container         The Container
 * @param name              The name
 * @param trainingSequence  An object array containing the training sequence
 * @param repetitionFactor  a double indicating the factor repetition probability
 * @param symbolicOutput    a boolean that determines whether symbolic outputs should be produced
 * @param validateSymbols   a boolean -- true if symbol validation should be included in guard expressions
 * @throws IllegalActionException repetition factor range checking
 * @throws NameDuplicationException
 */
public FactorOracle(CompositeEntity container,String name,Object[] trainingSequence,double repetitionFactor,boolean symbolicOutput,boolean validateSymbols) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  setClassName(""String_Node_Str"");
  if (repetitionFactor > 1.0 || repetitionFactor < 0.0) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  _adjacencyList=new HashMap<Integer,List<Integer>>();
  _adjacencyListSymbols=new HashMap<Integer,List<Integer>>();
  _suffixLinks=new HashMap();
  _alphabet=new HashSet();
  _sequenceLength=0;
  _repetitionFactor=repetitionFactor;
  if (trainingSequence != null) {
    _inputSequence=trainingSequence;
    _sequenceLength=_inputSequence.length;
  }
 else {
    _sequenceLength=0;
    _inputSequence=new Object[1];
  }
  _symbolic=symbolicOutput;
  _validatePitch=validateSymbols;
  _learnFactorOracle();
  _buildFactorOracle();
  validatePitch=new Parameter(this,""String_Node_Str"");
  validatePitch.setToken(new ChordFunctionToken());
  validatePitch.setVisibility(Settable.EXPERT);
  validatePitch.setPersistent(false);
}","/** 
 * Constructs a FactorOracle object.
 * @param container         The Container
 * @param name              The name
 * @param trainingSequence  An object array containing the training sequence
 * @param repetitionFactor  a double indicating the factor repetition probability
 * @param symbolicOutput    a boolean that determines whether symbolic outputs should be produced
 * @param validateSymbols   a boolean -- true if symbol validation should be included in guard expressions
 * @exception IllegalActionException repetition factor range checking
 * @exception NameDuplicationException
 */
public FactorOracle(CompositeEntity container,String name,Object[] trainingSequence,double repetitionFactor,boolean symbolicOutput,boolean validateSymbols) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  setClassName(""String_Node_Str"");
  if (repetitionFactor > 1.0 || repetitionFactor < 0.0) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  _adjacencyList=new HashMap<Integer,List<Integer>>();
  _adjacencyListSymbols=new HashMap<Integer,List<Integer>>();
  _suffixLinks=new HashMap();
  _alphabet=new HashSet();
  _sequenceLength=0;
  _repetitionFactor=repetitionFactor;
  if (trainingSequence != null) {
    _inputSequence=trainingSequence;
    _sequenceLength=_inputSequence.length;
  }
 else {
    _sequenceLength=0;
    _inputSequence=new Object[1];
  }
  _symbolic=symbolicOutput;
  _validatePitch=validateSymbols;
  _learnFactorOracle();
  _buildFactorOracle();
  validatePitch=new Parameter(this,""String_Node_Str"");
  validatePitch.setToken(new ChordFunctionToken());
  validatePitch.setVisibility(Settable.EXPERT);
  validatePitch.setPersistent(false);
}"
72644,"/** 
 * Create a Factor Oracle to be used within the hierarchical FO that is used for generation of improvised jazz ""licks"".
 * @param trainingSequence the training sequence
 * @param repetitionFactor the repetition factor on the forward links
 * @param pitch boolean indicating a pitch oracle
 * @param validate boolean indicating whether the pitches should be validated
 * @return A controller to be used in the top level hierarchical FO
 * @throws IllegalActionException If the modal model isincompatible with the controller.
 * @throws NameDuplicationException If the name of the controllercollides with a name already in the container.
 */
protected FactorOracle _createController(Object[] trainingSequence,double repetitionFactor,boolean pitch,boolean validate) throws IllegalActionException, NameDuplicationException {
  return new FactorOracle(this,""String_Node_Str"",trainingSequence,repetitionFactor,pitch,validate);
}","/** 
 * Create a Factor Oracle to be used within the hierarchical FO that is used for generation of improvised jazz ""licks"".
 * @param trainingSequence the training sequence
 * @param repetitionFactor the repetition factor on the forward links
 * @param pitch boolean indicating a pitch oracle
 * @param validate boolean indicating whether the pitches should be validated
 * @return A controller to be used in the top level hierarchical FO
 * @exception IllegalActionException If the modal model isincompatible with the controller.
 * @exception NameDuplicationException If the name of the controllercollides with a name already in the container.
 */
protected FactorOracle _createController(Object[] trainingSequence,double repetitionFactor,boolean pitch,boolean validate) throws IllegalActionException, NameDuplicationException {
  return new FactorOracle(this,""String_Node_Str"",trainingSequence,repetitionFactor,pitch,validate);
}"
72645,"/** 
 * Constructs a FactorOracleTop object.
 * @param workspace         The workspace.
 * @param trainingSequence  The training sequence as an Object array.
 * @param repetitionFactor  a double indicating the repetition factor on the forward links.
 * @param pitch             a boolean -- true if music pitch specifications are being used.
 * @param validate          a boolean -- true if pitches are subject to validation.
 * @throws NameDuplicationException ...
 * @throws IllegalActionException ...
 */
public FactorOracleTop(Workspace workspace,Object[] trainingSequence,double repetitionFactor,boolean pitch,boolean validate) throws NameDuplicationException, IllegalActionException {
  super(workspace);
  _init(trainingSequence,repetitionFactor,pitch,validate);
}","/** 
 * Constructs a FactorOracleTop object.
 * @param workspace         The workspace.
 * @param trainingSequence  The training sequence as an Object array.
 * @param repetitionFactor  a double indicating the repetition factor on the forward links.
 * @param pitch             a boolean -- true if music pitch specifications are being used.
 * @param validate          a boolean -- true if pitches are subject to validation.
 * @exception NameDuplicationException ...
 * @exception IllegalActionException ...
 */
public FactorOracleTop(Workspace workspace,Object[] trainingSequence,double repetitionFactor,boolean pitch,boolean validate) throws NameDuplicationException, IllegalActionException {
  super(workspace);
  _init(trainingSequence,repetitionFactor,pitch,validate);
}"
72646,"/** 
 * Construct an actor with the given container and name.
 * @param container The container.
 * @param name The name of this actor
 * @throws NameDuplicationException
 * @throws IllegalActionException
 */
public NoteParser(CompositeEntity container,String name) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  freq=new TypedIOPort(this,""String_Node_Str"",true,false);
  freq.setTypeEquals(BaseType.DOUBLE);
  dur=new TypedIOPort(this,""String_Node_Str"",true,false);
  dur.setTypeEquals(BaseType.DOUBLE);
  timestamp=new TypedIOPort(this,""String_Node_Str"",true,false);
  timestamp.setTypeEquals(BaseType.INT);
  resetFO=new TypedIOPort(this,""String_Node_Str"",true,false);
  resetFO.setTypeEquals(BaseType.DOUBLE);
  notes=new TypedIOPort(this,""String_Node_Str"",false,true);
  notes.setTypeEquals(BaseType.OBJECT);
  replicationProbability=new TypedIOPort(this,""String_Node_Str"",false,true);
  replicationProbability.setTypeEquals(BaseType.DOUBLE);
  bars=new TypedIOPort(this,""String_Node_Str"",false,true);
  bars.setTypeEquals(BaseType.DOUBLE);
  StringAttribute cardinality=new StringAttribute(bars,""String_Node_Str"");
  cardinality.setExpression(""String_Node_Str"");
  endTraining=new TypedIOPort(this,""String_Node_Str"",true,false);
  endTraining.setTypeEquals(BaseType.INT);
  _durations=new LinkedList<Double>();
  _orderedNotes=new HashMap<Integer,Note>();
  _notes=new LinkedList<Double>();
  _timestamps=new LinkedList<Integer>();
  _terminate=false;
  _terminateLength=0;
}","/** 
 * Construct an actor with the given container and name.
 * @param container The container.
 * @param name The name of this actor
 * @exception NameDuplicationException
 * @exception IllegalActionException
 */
public NoteParser(CompositeEntity container,String name) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  freq=new TypedIOPort(this,""String_Node_Str"",true,false);
  freq.setTypeEquals(BaseType.DOUBLE);
  dur=new TypedIOPort(this,""String_Node_Str"",true,false);
  dur.setTypeEquals(BaseType.DOUBLE);
  timestamp=new TypedIOPort(this,""String_Node_Str"",true,false);
  timestamp.setTypeEquals(BaseType.INT);
  resetFO=new TypedIOPort(this,""String_Node_Str"",true,false);
  resetFO.setTypeEquals(BaseType.DOUBLE);
  notes=new TypedIOPort(this,""String_Node_Str"",false,true);
  notes.setTypeEquals(BaseType.OBJECT);
  replicationProbability=new TypedIOPort(this,""String_Node_Str"",false,true);
  replicationProbability.setTypeEquals(BaseType.DOUBLE);
  bars=new TypedIOPort(this,""String_Node_Str"",false,true);
  bars.setTypeEquals(BaseType.DOUBLE);
  StringAttribute cardinality=new StringAttribute(bars,""String_Node_Str"");
  cardinality.setExpression(""String_Node_Str"");
  endTraining=new TypedIOPort(this,""String_Node_Str"",true,false);
  endTraining.setTypeEquals(BaseType.INT);
  _durations=new LinkedList<Double>();
  _orderedNotes=new HashMap<Integer,Note>();
  _notes=new LinkedList<Double>();
  _timestamps=new LinkedList<Integer>();
  _terminate=false;
  _terminateLength=0;
}"
72647,"/** 
 * Create a Factor Oracle controller
 * @param trainingSequence
 * @param repetitionFactor
 * @param pitch
 * @param validate
 * @return
 * @throws IllegalActionException
 * @throws NameDuplicationException
 */
protected FactorOracle _createController(Object[] trainingSequence,double repetitionFactor,boolean pitch,boolean validate) throws IllegalActionException, NameDuplicationException {
  return new FactorOracle(this,""String_Node_Str"",trainingSequence,repetitionFactor,pitch,validate);
}","/** 
 * Create a Factor Oracle controller
 * @param trainingSequence
 * @param repetitionFactor
 * @param pitch
 * @param validate
 * @return
 * @exception IllegalActionException
 * @exception NameDuplicationException
 */
protected FactorOracle _createController(Object[] trainingSequence,double repetitionFactor,boolean pitch,boolean validate) throws IllegalActionException, NameDuplicationException {
  return new FactorOracle(this,""String_Node_Str"",trainingSequence,repetitionFactor,pitch,validate);
}"
72648,"/** 
 * Return the probability mass function P(x=k) ~ Poisson(mean) value at k, for the poisson distribution with parameter mean
 * @param k The value at which the probability mass function will be computed
 * @param mean The mean (lambda) of the poisson distribution
 * @return The PMF value at k.
 * @throws IllegalActionException
 * @exception Exception If k < 0
 */
public static double poissonPmf(int k,double mean,double logFactorial) throws IllegalActionException {
  if (k < 0) {
    throw new IllegalActionException(""String_Node_Str"");
  }
  double logTerm=-mean + k * Math.log(mean) - logFactorial;
  return Math.exp(logTerm);
}","/** 
 * Return the probability mass function P(x=k) ~ Poisson(mean) value at k, for the poisson distribution with parameter mean
 * @param k The value at which the probability mass function will be computed
 * @param mean The mean (lambda) of the poisson distribution
 * @return The PMF value at k.
 * @exception IllegalActionException
 * @exception Exception If k < 0
 */
public static double poissonPmf(int k,double mean,double logFactorial) throws IllegalActionException {
  if (k < 0) {
    throw new IllegalActionException(""String_Node_Str"");
  }
  double logTerm=-mean + k * Math.log(mean) - logFactorial;
  return Math.exp(logTerm);
}"
72649,"/** 
 * Initialize arrays to be used in parameter estimation
 * @throws IllegalActionException
 */
protected void _initializeArrays() throws IllegalActionException {
  _likelihood=0.0;
  _nStates=((IntToken)nStates.getToken()).intValue();
  _transitionMatrix=new double[_nStates][_nStates];
  _A0=new double[_nStates][_nStates];
  _priors=new double[_nStates];
}","/** 
 * Initialize arrays to be used in parameter estimation
 * @exception IllegalActionException
 */
protected void _initializeArrays() throws IllegalActionException {
  _likelihood=0.0;
  _nStates=((IntToken)nStates.getToken()).intValue();
  _transitionMatrix=new double[_nStates][_nStates];
  _A0=new double[_nStates][_nStates];
  _priors=new double[_nStates];
}"
72650,"/** 
 * Expectation-Maximization, which internally executes a gradient-descent algorithm for parameter estimation.
 * @return whether parameter estimation has succeded
 * @throws IllegalActionException
 */
protected boolean _EMParameterEstimation() throws IllegalActionException {
  boolean success=false;
  _initializeEMParameters();
  for (int iterations=0; iterations < _nIterations; iterations++) {
    _iterateEM();
    success=_checkForConvergence(iterations);
    if (!_randomize && !success) {
      break;
    }
    _updateEstimates();
    if (Math.abs(likelihood - _likelihood) < _likelihoodThreshold) {
      break;
    }
 else {
      _likelihood=likelihood;
    }
  }
  return success;
}","/** 
 * Expectation-Maximization, which internally executes a gradient-descent algorithm for parameter estimation.
 * @return whether parameter estimation has succeded
 * @exception IllegalActionException
 */
protected boolean _EMParameterEstimation() throws IllegalActionException {
  boolean success=false;
  _initializeEMParameters();
  for (int iterations=0; iterations < _nIterations; iterations++) {
    _iterateEM();
    success=_checkForConvergence(iterations);
    if (!_randomize && !success) {
      break;
    }
    _updateEstimates();
    if (Math.abs(likelihood - _likelihood) < _likelihoodThreshold) {
      break;
    }
 else {
      _likelihood=likelihood;
    }
  }
  return success;
}"
72651,"/** 
 * Check whether the gradient-descent algorithm has converged
 * @param i Current iteration index
 * @return boolean indicating whether algorithm has converged
 * @throws IllegalActionException
 */
protected abstract boolean _checkForConvergence(int i) throws IllegalActionException ;","/** 
 * Check whether the gradient-descent algorithm has converged
 * @param i Current iteration index
 * @return boolean indicating whether algorithm has converged
 * @exception IllegalActionException
 */
protected abstract boolean _checkForConvergence(int i) throws IllegalActionException ;"
72652,"/** 
 * Constructs a MutualInformationCalculator object.
 * @param workspace The workspace
 * @throws IllegalActionException
 * @throws NameDuplicationException
 */
public MutualInformationCalculator(Workspace workspace) throws IllegalActionException, NameDuplicationException {
  super(workspace);
  _init();
}","/** 
 * Constructs a MutualInformationCalculator object.
 * @param workspace The workspace
 * @exception IllegalActionException
 * @exception NameDuplicationException
 */
public MutualInformationCalculator(Workspace workspace) throws IllegalActionException, NameDuplicationException {
  super(workspace);
  _init();
}"
72653,"@Override public int getTypeHash(){
  return 15;
}","@Override public int getTypeHash(){
  return 16;
}"
72654,"/** 
 * Open a web socket that serves as a connection to the event bus.
 */
private void _openWebSocket(){
  MultiMap map=new CaseInsensitiveMultiMap();
  map.add(""String_Node_Str"",""String_Node_Str"");
  _client.connectWebsocket(""String_Node_Str"",WebSocketVersion.RFC6455,map,new Handler<WebSocket>(){
    @Override public void handle(    WebSocket websocket){
      JsonObject msg=new JsonObject().putString(""String_Node_Str"",""String_Node_Str"").putString(""String_Node_Str"",_address);
      websocket.writeTextFrame(msg.encode());
      _websocket=websocket;
      websocket.dataHandler(new Handler<Buffer>(){
        @Override public void handle(        Buffer buff){
          String msg=buff.toString();
          JsonObject received=new JsonObject(msg);
          try {
            subscribe.send(0,new StringToken(received.getField(""String_Node_Str"")));
          }
 catch (          NoRoomException e) {
            e.printStackTrace();
          }
catch (          IllegalActionException e) {
            e.printStackTrace();
          }
        }
      }
);
      _websocket.closeHandler(new Handler<Void>(){
        @Override public void handle(        final Void event){
          _openWebSocket();
        }
      }
);
    }
  }
);
}","/** 
 * Open a web socket that serves as a connection to the event bus.
 */
private void _openWebSocket(){
  MultiMap map=new CaseInsensitiveMultiMap();
  map.add(""String_Node_Str"",""String_Node_Str"");
  _client.connectWebsocket(""String_Node_Str"",WebSocketVersion.RFC6455,map,new Handler<WebSocket>(){
    @Override public void handle(    WebSocket websocket){
      JsonObject msg=new JsonObject().putString(""String_Node_Str"",""String_Node_Str"").putString(""String_Node_Str"",_address);
      websocket.writeTextFrame(msg.encode());
      _websocket=websocket;
      websocket.dataHandler(new Handler<Buffer>(){
        @Override public void handle(        Buffer buff){
          String msg=buff.toString();
          JsonObject received=new JsonObject(msg);
          try {
            subscribe.send(0,new StringToken(received.getField(""String_Node_Str"").toString()));
          }
 catch (          NoRoomException e) {
            e.printStackTrace();
          }
catch (          IllegalActionException e) {
            e.printStackTrace();
          }
        }
      }
);
      _websocket.closeHandler(new Handler<Void>(){
        @Override public void handle(        final Void event){
          _openWebSocket();
        }
      }
);
    }
  }
);
}"
72655,"/** 
 * Construct a DateToken that represents the time specified as a string. The string is first parsed by the default java.text.DateFormat parser. Because we have up to nanosecond precision, we might have to pre-process the string and take out the digits representing nanoseconds and microseconds. Then any leading and trailing double quotes are removed and a java.text.SimpleDateFormat with a parser with the value of  {@link #_SIMPLE_DATE_FORMAT} is used.
 * @param value The date specified in a format acceptableto java.text.DateFormat.
 * @exception IllegalActionException If the date is notparseable by java.text.DateFormat.
 */
public DateToken(String value) throws IllegalActionException {
  _precision=PRECISION_MILLISECOND;
  if (value == null) {
    _isNil=false;
    _value=0l;
    return;
  }
  if (value.equals(_NIL)) {
    _isNil=true;
    _value=0l;
    return;
  }
  String dateString=value;
synchronized (_simpleDateFormat) {
    try {
      if (value.startsWith(""String_Node_Str"") && value.endsWith(""String_Node_Str"")) {
        value=value.substring(1,value.length() - 1);
      }
      Calendar calendar=Calendar.getInstance();
      if (value.length() == _SIMPLE_DATE_FORMAT.length()) {
        calendar.setTime(_simpleDateFormat.parse(value));
        _value=calendar.getTimeInMillis();
        _precision=PRECISION_MILLISECOND;
      }
 else       if (value.length() == _SIMPLE_DATE_FORMAT.length() + 3) {
        String micros=value.substring(value.indexOf(""String_Node_Str"") + 4,value.indexOf(""String_Node_Str"") + 7);
        value=value.substring(0,value.indexOf(""String_Node_Str"") + 4) + value.substring(value.indexOf(""String_Node_Str"") + 7);
        calendar.setTime(_simpleDateFormat.parse(value));
        _value=calendar.getTimeInMillis();
        _value=_value * 1000 + Integer.parseInt(micros);
        _precision=PRECISION_MICROSECOND;
      }
 else       if (value.length() == _SIMPLE_DATE_FORMAT.length() + 6) {
        String micros=value.substring(value.indexOf(""String_Node_Str"") + 4,value.indexOf(""String_Node_Str"") + 7);
        String nanos=value.substring(value.indexOf(""String_Node_Str"") + 7,value.indexOf(""String_Node_Str"") + 10);
        value=value.substring(0,value.indexOf(""String_Node_Str"") + 4) + value.substring(value.indexOf(""String_Node_Str"") + 10);
        calendar.setTime(_simpleDateFormat.parse(value));
        _value=calendar.getTimeInMillis();
        _value=(_value * 1000 + Integer.parseInt(micros)) * 1000 + Integer.parseInt(nanos);
        _precision=PRECISION_NANOSECOND;
      }
 else {
        throw new IllegalActionException(null,""String_Node_Str"" + ""String_Node_Str"" + dateString + ""String_Node_Str""+ _SIMPLE_DATE_FORMAT);
      }
      int offset=(calendar.get(Calendar.ZONE_OFFSET) + calendar.get(Calendar.DST_OFFSET)) / (60 * 60 * 1000);
      _timeZone=TimeZone.getTimeZone(""String_Node_Str"" + offset);
      calendar.setTimeZone(_timeZone);
      _calendar=calendar;
    }
 catch (    ParseException ex) {
      throw new IllegalActionException(null,ex,""String_Node_Str"" + value + ""String_Node_Str""+ ""String_Node_Str""+ _simpleDateFormat.toPattern()+ ""String_Node_Str""+ ex.getMessage());
    }
  }
  _isNil=false;
}","/** 
 * Construct a DateToken that represents the time specified as a string. The string is first parsed by the default java.text.DateFormat parser. Because we have up to nanosecond precision, we might have to pre-process the string and take out the digits representing nanoseconds and microseconds. Then any leading and trailing double quotes are removed and a java.text.SimpleDateFormat with a parser with the value of  {@link #_SIMPLE_DATE_FORMAT} is used.
 * @param value The date specified in a format acceptableto java.text.DateFormat.
 * @exception IllegalActionException If the date is notparseable by java.text.DateFormat.
 */
public DateToken(String value) throws IllegalActionException {
  _precision=PRECISION_MILLISECOND;
  if (value == null) {
    _isNil=false;
    _value=0l;
    return;
  }
  if (value.equals(_NIL)) {
    _isNil=true;
    _value=0l;
    return;
  }
  String dateString=value;
synchronized (_SIMPLE_DATE_FORMAT) {
    try {
      if (value.startsWith(""String_Node_Str"") && value.endsWith(""String_Node_Str"")) {
        value=value.substring(1,value.length() - 1);
      }
      Calendar calendar=Calendar.getInstance();
      if (value.length() == _SIMPLE_DATE_FORMAT.length()) {
        calendar.setTime(_simpleDateFormat.parse(value));
        _value=calendar.getTimeInMillis();
        _precision=PRECISION_MILLISECOND;
      }
 else       if (value.length() == _SIMPLE_DATE_FORMAT.length() + 3) {
        String micros=value.substring(value.indexOf(""String_Node_Str"") + 4,value.indexOf(""String_Node_Str"") + 7);
        value=value.substring(0,value.indexOf(""String_Node_Str"") + 4) + value.substring(value.indexOf(""String_Node_Str"") + 7);
        calendar.setTime(_simpleDateFormat.parse(value));
        _value=calendar.getTimeInMillis();
        _value=_value * 1000 + Integer.parseInt(micros);
        _precision=PRECISION_MICROSECOND;
      }
 else       if (value.length() == _SIMPLE_DATE_FORMAT.length() + 6) {
        String micros=value.substring(value.indexOf(""String_Node_Str"") + 4,value.indexOf(""String_Node_Str"") + 7);
        String nanos=value.substring(value.indexOf(""String_Node_Str"") + 7,value.indexOf(""String_Node_Str"") + 10);
        value=value.substring(0,value.indexOf(""String_Node_Str"") + 4) + value.substring(value.indexOf(""String_Node_Str"") + 10);
        calendar.setTime(_simpleDateFormat.parse(value));
        _value=calendar.getTimeInMillis();
        _value=(_value * 1000 + Integer.parseInt(micros)) * 1000 + Integer.parseInt(nanos);
        _precision=PRECISION_NANOSECOND;
      }
 else {
        throw new IllegalActionException(null,""String_Node_Str"" + ""String_Node_Str"" + dateString + ""String_Node_Str""+ _SIMPLE_DATE_FORMAT);
      }
      int offset=(calendar.get(Calendar.ZONE_OFFSET) + calendar.get(Calendar.DST_OFFSET)) / (60 * 60 * 1000);
      _timeZone=TimeZone.getTimeZone(""String_Node_Str"" + offset);
      calendar.setTimeZone(_timeZone);
      _calendar=calendar;
    }
 catch (    ParseException ex) {
      throw new IllegalActionException(null,ex,""String_Node_Str"" + value + ""String_Node_Str""+ ""String_Node_Str""+ _simpleDateFormat.toPattern()+ ""String_Node_Str""+ ex.getMessage());
    }
  }
  _isNil=false;
}"
72656,"/** 
 * Construct a DateToken that represents the time specified as a string. The string is first parsed by the default java.text.DateFormat parser. Because we have up to nanosecond precision, we might have to pre-process the string and take out the digits representing nanoseconds and microseconds. Then any leading and trailing double quotes are removed and a java.text.SimpleDateFormat with a parser with the value of  {@link #_SIMPLE_DATE_FORMAT} is used.
 * @param value The date specified in a format acceptableto java.text.DateFormat.
 * @exception IllegalActionException If the date is notparseable by java.text.DateFormat.
 */
public DateToken(String value) throws IllegalActionException {
  _precision=PRECISION_MILLISECOND;
  if (value == null) {
    _isNil=false;
    _value=0l;
    return;
  }
  if (value.equals(_NIL)) {
    _isNil=true;
    _value=0l;
    return;
  }
synchronized (_simpleDateFormat) {
    try {
      if (value.startsWith(""String_Node_Str"") && value.endsWith(""String_Node_Str"")) {
        value=value.substring(1,value.length() - 1);
      }
      Calendar calendar=Calendar.getInstance();
      if (value.length() == _SIMPLE_DATE_FORMAT.length()) {
        calendar.setTime(_simpleDateFormat.parse(value));
        _value=calendar.getTimeInMillis();
        _precision=PRECISION_MILLISECOND;
      }
 else       if (value.length() == _SIMPLE_DATE_FORMAT.length() + 3) {
        String micros=value.substring(value.indexOf(""String_Node_Str"") + 4,value.indexOf(""String_Node_Str"") + 7);
        value=value.substring(0,value.indexOf(""String_Node_Str"") + 4) + value.substring(value.indexOf(""String_Node_Str"") + 7);
        calendar.setTime(_simpleDateFormat.parse(value));
        _value=calendar.getTimeInMillis();
        _value=_value * 1000 + Integer.parseInt(micros);
        _precision=PRECISION_MICROSECOND;
      }
 else       if (value.length() == _SIMPLE_DATE_FORMAT.length() + 6) {
        String micros=value.substring(value.indexOf(""String_Node_Str"") + 4,value.indexOf(""String_Node_Str"") + 7);
        String nanos=value.substring(value.indexOf(""String_Node_Str"") + 7,value.indexOf(""String_Node_Str"") + 10);
        value=value.substring(0,value.indexOf(""String_Node_Str"") + 4) + value.substring(value.indexOf(""String_Node_Str"") + 10);
        calendar.setTime(_simpleDateFormat.parse(value));
        _value=calendar.getTimeInMillis();
        _value=(_value * 1000 + Integer.parseInt(micros)) * 1000 + Integer.parseInt(nanos);
        _precision=PRECISION_NANOSECOND;
      }
      _calendar=calendar;
      int offset=(calendar.get(Calendar.ZONE_OFFSET) + calendar.get(Calendar.DST_OFFSET)) / (60 * 60 * 1000);
      _timeZone=TimeZone.getTimeZone(""String_Node_Str"" + offset);
      calendar.setTimeZone(_timeZone);
    }
 catch (    ParseException ex) {
      throw new IllegalActionException(null,ex,""String_Node_Str"" + value + ""String_Node_Str""+ ""String_Node_Str""+ _simpleDateFormat.toPattern()+ ""String_Node_Str""+ ex.getMessage());
    }
  }
  _isNil=false;
}","/** 
 * Construct a DateToken that represents the time specified as a string. The string is first parsed by the default java.text.DateFormat parser. Because we have up to nanosecond precision, we might have to pre-process the string and take out the digits representing nanoseconds and microseconds. Then any leading and trailing double quotes are removed and a java.text.SimpleDateFormat with a parser with the value of  {@link #_SIMPLE_DATE_FORMAT} is used.
 * @param value The date specified in a format acceptableto java.text.DateFormat.
 * @exception IllegalActionException If the date is notparseable by java.text.DateFormat.
 */
public DateToken(String value) throws IllegalActionException {
  _precision=PRECISION_MILLISECOND;
  if (value == null) {
    _isNil=false;
    _value=0l;
    return;
  }
  if (value.equals(_NIL)) {
    _isNil=true;
    _value=0l;
    return;
  }
  String dateString=value;
synchronized (_simpleDateFormat) {
    try {
      if (value.startsWith(""String_Node_Str"") && value.endsWith(""String_Node_Str"")) {
        value=value.substring(1,value.length() - 1);
      }
      Calendar calendar=Calendar.getInstance();
      System.out.println(_simpleDateFormat.format(calendar.getTime()));
      System.out.println(value.length() + ""String_Node_Str"" + _SIMPLE_DATE_FORMAT.length());
      if (value.length() == _SIMPLE_DATE_FORMAT.length()) {
        calendar.setTime(_simpleDateFormat.parse(value));
        _value=calendar.getTimeInMillis();
        _precision=PRECISION_MILLISECOND;
      }
 else       if (value.length() == _SIMPLE_DATE_FORMAT.length() + 3) {
        String micros=value.substring(value.indexOf(""String_Node_Str"") + 4,value.indexOf(""String_Node_Str"") + 7);
        value=value.substring(0,value.indexOf(""String_Node_Str"") + 4) + value.substring(value.indexOf(""String_Node_Str"") + 7);
        calendar.setTime(_simpleDateFormat.parse(value));
        _value=calendar.getTimeInMillis();
        _value=_value * 1000 + Integer.parseInt(micros);
        _precision=PRECISION_MICROSECOND;
      }
 else       if (value.length() == _SIMPLE_DATE_FORMAT.length() + 6) {
        String micros=value.substring(value.indexOf(""String_Node_Str"") + 4,value.indexOf(""String_Node_Str"") + 7);
        String nanos=value.substring(value.indexOf(""String_Node_Str"") + 7,value.indexOf(""String_Node_Str"") + 10);
        value=value.substring(0,value.indexOf(""String_Node_Str"") + 4) + value.substring(value.indexOf(""String_Node_Str"") + 10);
        calendar.setTime(_simpleDateFormat.parse(value));
        _value=calendar.getTimeInMillis();
        _value=(_value * 1000 + Integer.parseInt(micros)) * 1000 + Integer.parseInt(nanos);
        _precision=PRECISION_NANOSECOND;
      }
 else {
        throw new IllegalActionException(null,""String_Node_Str"" + ""String_Node_Str"" + dateString + ""String_Node_Str""+ _SIMPLE_DATE_FORMAT);
      }
      System.out.println(_simpleDateFormat.format(calendar.getTime()));
      int offset=(calendar.get(Calendar.ZONE_OFFSET) + calendar.get(Calendar.DST_OFFSET)) / (60 * 60 * 1000);
      _timeZone=TimeZone.getTimeZone(""String_Node_Str"" + offset);
      calendar.setTimeZone(_timeZone);
      _calendar=calendar;
    }
 catch (    ParseException ex) {
      throw new IllegalActionException(null,ex,""String_Node_Str"" + value + ""String_Node_Str""+ ""String_Node_Str""+ _simpleDateFormat.toPattern()+ ""String_Node_Str""+ ex.getMessage());
    }
  }
  _isNil=false;
}"
72657,"@Override public void fire() throws IllegalActionException {
  super.fire();
  if (particles.hasToken(0)) {
    ArrayToken incoming=(ArrayToken)particles.get(0);
    N=incoming.length();
    if (_px.length == 0) {
      _px=new double[N];
      _py=new double[N];
      _weights=new double[incoming.length()];
    }
    for (int i=0; i < incoming.length(); i++) {
      RecordToken token=(RecordToken)incoming.getElement(i);
      for (int k=0; k < _labels.length; k++) {
        if (_labels[k].equals(""String_Node_Str"")) {
          _weights[i]=((DoubleToken)token.get(_labels[k])).doubleValue();
        }
      }
      _px[i]=((DoubleToken)token.get(_labels[0])).doubleValue();
      _py[i]=((DoubleToken)token.get(_labels[1])).doubleValue();
    }
    double wsum=0;
    for (int i=0; i < N; i++) {
      wsum+=_weights[i];
    }
    for (int i=0; i < N; i++) {
      _weights[i]/=wsum;
    }
  }
  if (locations.hasToken(0)) {
    ArrayToken robotLocations=(ArrayToken)locations.get(0);
    _nRobots=robotLocations.length();
    _robotLocations.clear();
    for (int i=0; i < _nRobots; i++) {
      RecordToken robotLocation=(RecordToken)robotLocations.getElement(i);
      _robotLocations.add(robotLocation);
    }
  }
  if (xValue.hasToken(0)) {
    ArrayToken xArray=((ArrayToken)xValue.get(0));
    _xValue=new double[xArray.length()];
    for (int i=0; i < xArray.length(); i++) {
      _xValue[i]=((DoubleToken)xArray.getElement(i)).doubleValue();
    }
  }
  output.send(0,new DoubleToken(Hz(_xValue)));
}","@Override public void fire() throws IllegalActionException {
  super.fire();
  if (particles.hasToken(0)) {
    ArrayToken incoming=(ArrayToken)particles.get(0);
    N=incoming.length();
    _weights=new double[N];
    if (_px.length == 0) {
      _px=new double[N];
      _py=new double[N];
      _weights=new double[N];
    }
    for (int i=0; i < N; i++) {
      RecordToken token=(RecordToken)incoming.getElement(i);
      for (int k=0; k < _labels.length; k++) {
        if (_labels[k].equals(""String_Node_Str"")) {
          _weights[i]=((DoubleToken)token.get(_labels[k])).doubleValue();
        }
      }
      _px[i]=((DoubleToken)token.get(_labels[0])).doubleValue();
      _py[i]=((DoubleToken)token.get(_labels[1])).doubleValue();
    }
    double wsum=0;
    for (int i=0; i < N; i++) {
      wsum+=_weights[i];
    }
    for (int i=0; i < N; i++) {
      _weights[i]/=wsum;
    }
  }
  if (locations.hasToken(0)) {
    ArrayToken robotLocations=(ArrayToken)locations.get(0);
    _nRobots=robotLocations.length();
    _robotLocations.clear();
    for (int i=0; i < _nRobots; i++) {
      RecordToken robotLocation=(RecordToken)robotLocations.getElement(i);
      _robotLocations.add(robotLocation);
    }
  }
  if (xValue.hasToken(0)) {
    ArrayToken xArray=((ArrayToken)xValue.get(0));
    _xValue=new double[xArray.length()];
    for (int i=0; i < xArray.length(); i++) {
      _xValue[i]=((DoubleToken)xArray.getElement(i)).doubleValue();
    }
  }
  output.send(0,new DoubleToken(Hz(_xValue)));
}"
72658,"public MutualInformationCalculator(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  optIndex=new Parameter(this,""String_Node_Str"");
  optIndex.setExpression(""String_Node_Str"");
  optIndex.setTypeEquals(BaseType.INT);
  _optIndex=-1;
  timeHorizon=new Parameter(this,""String_Node_Str"");
  timeHorizon.setExpression(""String_Node_Str"");
  timeHorizon.setTypeEquals(BaseType.INT);
  xValue=new TypedIOPort(this,""String_Node_Str"",true,false);
  xValue.setTypeEquals(new ArrayType(BaseType.DOUBLE));
  particles=new TypedIOPort(this,""String_Node_Str"",true,false);
  ArrayToken names=new ArrayToken(""String_Node_Str"");
  String stateName;
  _labels=new String[names.length() + 1];
  _types=new Type[names.length() + 1];
  try {
    for (int i=0; i < names.length(); i++) {
      stateName=((StringToken)names.getElement(i)).stringValue();
      if (this.getAttribute(stateName) == null && stateName.length() != 0) {
        Parameter y=new Parameter(this,stateName);
        y.setExpression(""String_Node_Str"");
        y.setVisibility(Settable.EXPERT);
      }
      _labels[i]=stateName;
    }
    _labels[names.length()]=""String_Node_Str"";
    _types[names.length()]=BaseType.DOUBLE;
    particles.setTypeEquals(new ArrayType(new RecordType(_labels,_types)));
  }
 catch (  NameDuplicationException e) {
    System.err.println(""String_Node_Str"" + this.getName());
  }
  _px=new double[0];
  _py=new double[0];
  _weights=new double[0];
  locations=new TypedIOPort(this,""String_Node_Str"",true,false);
  _robotLocations=new LinkedList<RecordToken>();
  output=new TypedIOPort(this,""String_Node_Str"",false,true);
  output.setTypeEquals(BaseType.DOUBLE);
  _covariance=2.0;
}","/** 
 * Constructs a MutualInformationCalculator object.
 * @param workspace The workspace
 * @throws IllegalActionException 
 * @throws NameDuplicationException 
 */
public MutualInformationCalculator(Workspace workspace) throws IllegalActionException, NameDuplicationException {
  super(workspace);
  _init();
}"
72659,"/** 
 * Return a list of inputs of the FMU. An input has both a declared ScalarVariable in the model description file with causality declared to be ""input"" and a port with the same name contained by this actor. Each returned input contains a reference to the port and a reference to the   {@link FMIScalarVariable}.
 * @return A list of inputs of the FMU.
 * @exception IllegalActionException If no port matching the nameof a variable declared as an input is found.
 */
private List<Input> _getInputs() throws IllegalActionException {
  if (workspace().getVersion() == _inputsVersion) {
    return _inputs;
  }
  _inputs=new LinkedList<Input>();
  for (  FMIScalarVariable scalarVariable : _fmiModelDescription.modelVariables) {
    if (scalarVariable.alias != null && !scalarVariable.alias.equals(Alias.noAlias)) {
      continue;
    }
    if (scalarVariable.variability != FMIScalarVariable.Variability.parameter && scalarVariable.variability != FMIScalarVariable.Variability.constant && scalarVariable.variability != FMIScalarVariable.Variability.fixed && (scalarVariable.causality == Causality.input)) {
      TypedIOPort port=(TypedIOPort)_getPortByNameOrDisplayName(scalarVariable.name);
      if (port == null) {
        throw new IllegalActionException(this,""String_Node_Str"" + scalarVariable.name + ""String_Node_Str"");
      }
      Input input=new Input();
      input.scalarVariable=scalarVariable;
      input.port=port;
      if (scalarVariable.type instanceof FMIRealType) {
        input.start=((FMIRealType)scalarVariable.type).start;
      }
 else {
        input.start=null;
      }
      _inputs.add(input);
    }
  }
  _inputsVersion=workspace().getVersion();
  return _inputs;
}","/** 
 * Return a list of inputs of the FMU. An input has both a declared ScalarVariable in the model description file with causality declared to be ""input"" and a port with the same name contained by this actor. Each returned input contains a reference to the port and a reference to the   {@link FMIScalarVariable}.
 * @return A list of inputs of the FMU.
 * @exception IllegalActionException If no port matching the nameof a variable declared as an input is found.
 */
private List<Input> _getInputs() throws IllegalActionException {
  if (workspace().getVersion() == _inputsVersion) {
    return _inputs;
  }
  _inputs=new LinkedList<Input>();
  for (  FMIScalarVariable scalarVariable : _fmiModelDescription.modelVariables) {
    if (scalarVariable.alias != null && !scalarVariable.alias.equals(Alias.noAlias)) {
      continue;
    }
    if (scalarVariable.variability != FMIScalarVariable.Variability.parameter && scalarVariable.variability != FMIScalarVariable.Variability.constant && scalarVariable.variability != FMIScalarVariable.Variability.fixed && (scalarVariable.causality == Causality.input || (_fmiModelDescription.modelExchange && scalarVariable.causality == Causality.local && (((scalarVariable.type instanceof FMIRealType && ((FMIRealType)scalarVariable.type).indexState == -1)) || !(scalarVariable.type instanceof FMIRealType))))) {
      TypedIOPort port=(TypedIOPort)_getPortByNameOrDisplayName(scalarVariable.name);
      if (port == null) {
        throw new IllegalActionException(this,""String_Node_Str"" + scalarVariable.name + ""String_Node_Str"");
      }
      Input input=new Input();
      input.scalarVariable=scalarVariable;
      input.port=port;
      if (scalarVariable.type instanceof FMIRealType) {
        input.start=((FMIRealType)scalarVariable.type).start;
      }
 else {
        input.start=null;
      }
      _inputs.add(input);
    }
  }
  _inputsVersion=workspace().getVersion();
  return _inputs;
}"
72660,"/** 
 * Import a FMUFile.
 * @param originator The originator of the change request.
 * @param fmuFileParameter The .fmuFile
 * @param context The context in which the FMU actor is created.
 * @param x The x-axis value of the actor to be created.
 * @param y The y-axis value of the actor to be created.
 * @param modelExchange If true, import for model exchange (vs. co-simulation).
 * @exception IllegalActionException If there is a problem instantiating the actor.
 * @exception IOException If there is a problem parsing the fmu file.
 */
public static void importFMU(Object originator,FileParameter fmuFileParameter,NamedObj context,double x,double y,boolean modelExchange) throws IllegalActionException, IOException {
  File fmuFile=fmuFileParameter.asFile();
  String fmuFileName=fmuFile.getCanonicalPath();
  FMIModelDescription fmiModelDescription=FMUFile.parseFMUFile(fmuFileName);
  String source=""String_Node_Str"";
  if (fmuFileName.startsWith(""String_Node_Str"")) {
    source=""String_Node_Str"" + fmuFileName.trim() + ""String_Node_Str"";
  }
  String rootName=new File(fmuFileName).getName();
  int index=rootName.lastIndexOf('.');
  if (index != -1) {
    rootName=rootName.substring(0,index);
  }
  int maximumNumberOfPortsToDisplay=20;
  int modelVariablesLength=fmiModelDescription.modelVariables.size();
  String hide=""String_Node_Str"";
  String hiddenStyle=""String_Node_Str"";
  String dependency=""String_Node_Str"";
  String showName=""String_Node_Str"" + ""String_Node_Str"" + hiddenStyle + ""String_Node_Str"";
  if (modelVariablesLength > maximumNumberOfPortsToDisplay) {
    MessageHandler.message(""String_Node_Str"" + fmuFileName + ""String_Node_Str""+ modelVariablesLength+ ""String_Node_Str""+ ""String_Node_Str"");
  }
  int portCount=0;
  StringBuffer parameterMoML=new StringBuffer();
  StringBuffer portMoML=new StringBuffer();
  for (  FMIScalarVariable scalar : fmiModelDescription.modelVariables) {
    if (scalar.variability == FMIScalarVariable.Variability.parameter || scalar.variability == FMIScalarVariable.Variability.fixed) {
switch (scalar.causality) {
case output:
case input:
        portCount++;
      parameterMoML.append(""String_Node_Str"" + StringUtilities.sanitizeName(scalar.name) + ""String_Node_Str""+ scalar.type+ ""String_Node_Str"");
    break;
case local:
case internal:
case calculatedParameter:
case parameter:
case none:
  parameterMoML.append(""String_Node_Str"" + StringUtilities.sanitizeName(scalar.name) + ""String_Node_Str""+ scalar.type+ ""String_Node_Str""+ ""String_Node_Str"");
break;
}
continue;
}
 else {
boolean hideLocal=false;
String causality=""String_Node_Str"";
System.out.println(""String_Node_Str"" + scalar.causality + ""String_Node_Str""+ scalar.name);
switch (scalar.causality) {
case local:
hideLocal=true;
if (fmiModelDescription.modelExchange) {
if (fmiModelDescription.continuousStates.contains(scalar.name)) {
System.out.println(""String_Node_Str"" + scalar.causality + ""String_Node_Str""+ scalar.name);
hideLocal=false;
}
portCount++;
dependency=""String_Node_Str"";
causality=""String_Node_Str"";
break;
}
case input:
portCount++;
causality=""String_Node_Str"";
break;
case none:
continue;
case output:
portCount++;
dependency=""String_Node_Str"";
case internal:
causality=""String_Node_Str"";
break;
}
portMoML.append(""String_Node_Str"" + StringUtilities.sanitizeName(scalar.name) + ""String_Node_Str""+ ""String_Node_Str""+ causality+ ""String_Node_Str""+ ""String_Node_Str""+ StringUtilities.escapeForXML(scalar.name)+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ _fmiType2PtolemyType(scalar.type)+ ""String_Node_Str""+ hiddenStyle+ ""String_Node_Str""+ dependency+ showName+ (portCount > maximumNumberOfPortsToDisplay || scalar.causality == Causality.internal || hideLocal ? hide : ""String_Node_Str"")+ ""String_Node_Str"");
}
}
if (modelExchange) {
fmiModelDescription.modelExchange=true;
parameterMoML.append(""String_Node_Str"");
parameterMoML.append(""String_Node_Str"");
}
String moml=""String_Node_Str"" + ""String_Node_Str"" + rootName + ""String_Node_Str""+ source+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ x+ ""String_Node_Str""+ y+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ fmuFileParameter.getExpression()+ ""String_Node_Str""+ ""String_Node_Str""+ parameterMoML+ portMoML+ ""String_Node_Str"";
MoMLChangeRequest request=new MoMLChangeRequest(originator,context,moml);
context.requestChange(request);
}","/** 
 * Import a FMUFile.
 * @param originator The originator of the change request.
 * @param fmuFileParameter The .fmuFile
 * @param context The context in which the FMU actor is created.
 * @param x The x-axis value of the actor to be created.
 * @param y The y-axis value of the actor to be created.
 * @param modelExchange If true, import for model exchange (vs. co-simulation).
 * @exception IllegalActionException If there is a problem instantiating the actor.
 * @exception IOException If there is a problem parsing the fmu file.
 */
public static void importFMU(Object originator,FileParameter fmuFileParameter,NamedObj context,double x,double y,boolean modelExchange) throws IllegalActionException, IOException {
  File fmuFile=fmuFileParameter.asFile();
  String fmuFileName=fmuFile.getCanonicalPath();
  FMIModelDescription fmiModelDescription=FMUFile.parseFMUFile(fmuFileName);
  String source=""String_Node_Str"";
  if (fmuFileName.startsWith(""String_Node_Str"")) {
    source=""String_Node_Str"" + fmuFileName.trim() + ""String_Node_Str"";
  }
  String rootName=new File(fmuFileName).getName();
  int index=rootName.lastIndexOf('.');
  if (index != -1) {
    rootName=rootName.substring(0,index);
  }
  int maximumNumberOfPortsToDisplay=20;
  int modelVariablesLength=fmiModelDescription.modelVariables.size();
  String hide=""String_Node_Str"";
  String hiddenStyle=""String_Node_Str"";
  String dependency=""String_Node_Str"";
  String showName=""String_Node_Str"" + ""String_Node_Str"" + hiddenStyle + ""String_Node_Str"";
  if (modelVariablesLength > maximumNumberOfPortsToDisplay) {
    MessageHandler.message(""String_Node_Str"" + fmuFileName + ""String_Node_Str""+ modelVariablesLength+ ""String_Node_Str""+ ""String_Node_Str"");
  }
  int portCount=0;
  StringBuffer parameterMoML=new StringBuffer();
  StringBuffer portMoML=new StringBuffer();
  for (  FMIScalarVariable scalar : fmiModelDescription.modelVariables) {
    if (scalar.variability == FMIScalarVariable.Variability.parameter || scalar.variability == FMIScalarVariable.Variability.fixed) {
switch (scalar.causality) {
case output:
case input:
        portCount++;
      parameterMoML.append(""String_Node_Str"" + StringUtilities.sanitizeName(scalar.name) + ""String_Node_Str""+ scalar.type+ ""String_Node_Str"");
    break;
case local:
case internal:
case calculatedParameter:
case parameter:
case none:
  parameterMoML.append(""String_Node_Str"" + StringUtilities.sanitizeName(scalar.name) + ""String_Node_Str""+ scalar.type+ ""String_Node_Str""+ ""String_Node_Str"");
break;
}
continue;
}
 else {
boolean hideLocal=false;
String causality=""String_Node_Str"";
System.out.println(""String_Node_Str"" + scalar.causality + ""String_Node_Str""+ scalar.name);
switch (scalar.causality) {
case local:
hideLocal=true;
if (fmiModelDescription.modelExchange) {
if (fmiModelDescription.continuousStates.contains(scalar.name)) {
System.out.println(""String_Node_Str"" + scalar.causality + ""String_Node_Str""+ scalar.name);
hideLocal=false;
}
 else {
if (scalar.type instanceof FMIRealType) {
  if (((FMIRealType)scalar.type).indexState != -1) {
    portCount++;
    dependency=""String_Node_Str"";
    causality=""String_Node_Str"";
  }
}
break;
}
}
case input:
portCount++;
causality=""String_Node_Str"";
break;
case none:
continue;
case output:
portCount++;
dependency=""String_Node_Str"";
case internal:
causality=""String_Node_Str"";
break;
}
portMoML.append(""String_Node_Str"" + StringUtilities.sanitizeName(scalar.name) + ""String_Node_Str""+ ""String_Node_Str""+ causality+ ""String_Node_Str""+ ""String_Node_Str""+ StringUtilities.escapeForXML(scalar.name)+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ _fmiType2PtolemyType(scalar.type)+ ""String_Node_Str""+ hiddenStyle+ ""String_Node_Str""+ dependency+ showName+ (portCount > maximumNumberOfPortsToDisplay || scalar.causality == Causality.internal || hideLocal ? hide : ""String_Node_Str"")+ ""String_Node_Str"");
}
}
if (modelExchange) {
fmiModelDescription.modelExchange=true;
parameterMoML.append(""String_Node_Str"");
parameterMoML.append(""String_Node_Str"");
}
String moml=""String_Node_Str"" + ""String_Node_Str"" + rootName + ""String_Node_Str""+ source+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ x+ ""String_Node_Str""+ y+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ fmuFileParameter.getExpression()+ ""String_Node_Str""+ ""String_Node_Str""+ parameterMoML+ portMoML+ ""String_Node_Str"";
MoMLChangeRequest request=new MoMLChangeRequest(originator,context,moml);
context.requestChange(request);
}"
72661,"private void _processMessage(Object[] message,String address){
synchronized (_receivedTokens) {
    String[] addressBits=address.split(""String_Node_Str"");
    if (addressBits != null) {
      String identifier=addressBits[addressBits.length - 1];
      if (identifier.length() > 0) {
        List<Object> tokenList;
        if (_receivedTokens.containsKey(identifier)) {
          tokenList=_receivedTokens.get(identifier);
        }
 else {
          tokenList=new LinkedList<Object>();
        }
        for (int i=0; i < message.length; i++) {
          Object b=message[i];
          if (b instanceof Double) {
            tokenList.add((Double)b);
          }
 else           if (b instanceof Integer) {
            tokenList.add((Integer)b);
          }
 else           if (b instanceof String) {
            tokenList.add((String)b);
          }
 else           if (b instanceof Float) {
            tokenList.add((Float)b);
          }
 else {
            tokenList.add(b);
          }
        }
        _receivedTokens.put(identifier,tokenList);
      }
    }
  }
}","private void _processMessage(Object[] message,String address){
  String[] addressBits=address.split(""String_Node_Str"");
  if (addressBits != null) {
    String identifier=addressBits[addressBits.length - 1];
    if (identifier.length() > 0) {
      List<Object> tokenList;
      if (_receivedTokens.containsKey(identifier)) {
        tokenList=_receivedTokens.get(identifier);
      }
 else {
        tokenList=new LinkedList<Object>();
      }
      for (int i=0; i < message.length; i++) {
        Object b=message[i];
        if (b instanceof Double) {
          tokenList.add((Double)b);
        }
 else         if (b instanceof Integer) {
          tokenList.add((Integer)b);
        }
 else         if (b instanceof String) {
          tokenList.add((String)b);
        }
 else         if (b instanceof Float) {
          tokenList.add((Float)b);
        }
 else {
          tokenList.add(b);
        }
      }
      _receivedTokens.put(identifier,tokenList);
    }
  }
}"
72662,"public void fire() throws IllegalActionException {
  super.fire();
  boolean portTypeDefined=false;
synchronized (_receivedTokens) {
    if (_receivedTokens.size() > 0) {
      if (_receivedTokens.keySet().size() > 0) {
        for (        String identifier : _receivedTokens.keySet()) {
          TypedIOPort destinationPort=(TypedIOPort)this.getPort(identifier);
          if (destinationPort == null || !destinationPort.isOutput()) {
            _receivedTokens.remove(identifier);
          }
 else {
            if (destinationPort.getType() != null) {
              portTypeDefined=true;
            }
            for (            Object token : _receivedTokens.get(identifier)) {
              if (token instanceof Double) {
                if (!portTypeDefined) {
                  destinationPort.setTypeEquals(BaseType.DOUBLE);
                  portTypeDefined=true;
                }
                destinationPort.send(0,new DoubleToken((Double)token));
              }
 else               if (token instanceof Integer) {
                if (!portTypeDefined) {
                  destinationPort.setTypeEquals(BaseType.INT);
                  portTypeDefined=true;
                }
                destinationPort.send(0,new IntToken((Integer)token));
              }
 else               if (token instanceof String) {
                if (!portTypeDefined) {
                  destinationPort.setTypeEquals(BaseType.STRING);
                  portTypeDefined=true;
                }
                destinationPort.send(0,new StringToken((String)token));
              }
 else               if (token instanceof Float) {
                if (!portTypeDefined) {
                  destinationPort.setTypeEquals(BaseType.FLOAT);
                  portTypeDefined=true;
                }
                destinationPort.send(0,new FloatToken((Float)token));
              }
 else {
                if (!portTypeDefined) {
                  destinationPort.setTypeEquals(BaseType.OBJECT);
                  portTypeDefined=true;
                }
                destinationPort.send(0,new ObjectToken(token));
              }
            }
            _receivedTokens.get(identifier).clear();
          }
        }
      }
    }
  }
}","public void fire() throws IllegalActionException {
  super.fire();
  boolean portTypeDefined=false;
synchronized (this) {
    if (_receivedTokens.size() > 0) {
      if (_receivedTokens.keySet().size() > 0) {
        for (        String identifier : _receivedTokens.keySet()) {
          TypedIOPort destinationPort=(TypedIOPort)this.getPort(identifier);
          if (destinationPort == null || !destinationPort.isOutput()) {
            _receivedTokens.remove(identifier);
          }
 else {
            if (destinationPort.getType() != null) {
              portTypeDefined=true;
            }
            for (            Object token : _receivedTokens.get(identifier)) {
              if (token instanceof Double) {
                if (!portTypeDefined) {
                  destinationPort.setTypeEquals(BaseType.DOUBLE);
                  portTypeDefined=true;
                }
                destinationPort.send(0,new DoubleToken((Double)token));
              }
 else               if (token instanceof Integer) {
                if (!portTypeDefined) {
                  destinationPort.setTypeEquals(BaseType.INT);
                  portTypeDefined=true;
                }
                destinationPort.send(0,new IntToken((Integer)token));
              }
 else               if (token instanceof String) {
                if (!portTypeDefined) {
                  destinationPort.setTypeEquals(BaseType.STRING);
                  portTypeDefined=true;
                }
                destinationPort.send(0,new StringToken((String)token));
              }
 else               if (token instanceof Float) {
                if (!portTypeDefined) {
                  destinationPort.setTypeEquals(BaseType.FLOAT);
                  portTypeDefined=true;
                }
                destinationPort.send(0,new FloatToken((Float)token));
              }
 else {
                if (!portTypeDefined) {
                  destinationPort.setTypeEquals(BaseType.OBJECT);
                  portTypeDefined=true;
                }
                destinationPort.send(0,new ObjectToken(token));
              }
            }
            _receivedTokens.get(identifier).clear();
          }
        }
      }
    }
  }
}"
72663,"public void oscEvent(OscMessage theMessage){
synchronized (this) {
    try {
      Object[] receivedData=theMessage.arguments();
      String addressPattern=theMessage.addrPattern();
      _processMessage(receivedData,addressPattern);
      getDirector().fireAtCurrentTime(this);
    }
 catch (    IllegalActionException e) {
      System.err.println(""String_Node_Str"" + theMessage.toString());
    }
  }
}","public void oscEvent(OscMessage theMessage){
  try {
    Object[] receivedData=theMessage.arguments();
    String addressPattern=theMessage.addrPattern();
    _processMessage(receivedData,addressPattern);
    getDirector().fireAtCurrentTime(this);
  }
 catch (  IllegalActionException e) {
    System.err.println(""String_Node_Str"" + theMessage.toString());
  }
}"
72664,"private void _sendOscPackets(HashMap<String,Object> tokenMap) throws IllegalActionException {
  myRemoteLocation=new NetAddress(_host,_remotePort);
  OscBundle bundle=new OscBundle();
  String prefix=((StringToken)tagPrefix.getToken()).stringValue();
  if (!prefix.equals(""String_Node_Str"") && !prefix.startsWith(""String_Node_Str"")) {
    prefix=""String_Node_Str"" + prefix;
  }
  for (  String label : tokenMap.keySet()) {
    OscMessage m=new OscMessage(prefix + ""String_Node_Str"" + label);
    Object o=tokenMap.get(label);
    if (o instanceof Double) {
      m.add((Double)o);
    }
 else     if (o instanceof Integer) {
      m.add((Integer)o);
    }
 else     if (o instanceof String) {
      m.add((String)o);
    }
 else {
      throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
    }
    bundle.add(m);
    m.print();
  }
  oscP5.send(bundle,myRemoteLocation);
  tokenMap.clear();
}","private void _sendOscPackets(HashMap<String,Object> tokenMap) throws IllegalActionException {
  myRemoteLocation=new NetAddress(_host,_remotePort);
  OscBundle bundle=new OscBundle();
  String prefix=((StringToken)tagPrefix.getToken()).stringValue();
  if (!prefix.equals(""String_Node_Str"") && !prefix.startsWith(""String_Node_Str"")) {
    prefix=""String_Node_Str"" + prefix;
  }
  for (  Map.Entry<String,Object> entry : tokenMap.entrySet()) {
    String label=entry.getKey();
    Object o=entry.getValue();
    OscMessage m=new OscMessage(prefix + ""String_Node_Str"" + label);
    if (o instanceof Double) {
      m.add((Double)o);
    }
 else     if (o instanceof Integer) {
      m.add((Integer)o);
    }
 else     if (o instanceof String) {
      m.add((String)o);
    }
 else {
      throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
    }
    bundle.add(m);
  }
  oscP5.send(bundle,myRemoteLocation);
  tokenMap.clear();
}"
72665,"public void wrapup(){
  _allChords.clear();
  _currentBeat=0.0;
  _barProgress=0.0;
  _durations.clear();
  _triggersSinceLastOutput=0;
}","public void wrapup(){
  _allChords.clear();
  _currentBeatCursor=0.0;
  _barProgress=0.0;
  _durations.clear();
  _triggersSinceLastOutput=0;
}"
72666,"public void fire() throws IllegalActionException {
  super.fire();
  if (resetBeat.isOutsideConnected() && resetBeat.hasToken(0)) {
    if (((BooleanToken)resetBeat.get(0)).booleanValue()) {
      _currentBeat=0.0;
    }
  }
  if (reset.isOutsideConnected() && reset.hasToken(0)) {
    if (((BooleanToken)reset.get(0)).booleanValue()) {
      _allChords.clear();
      _currentBeat=0.0;
      _barProgress=0.0;
      _durations.clear();
    }
  }
  if (chordSequence.hasToken(0)) {
    Chord c=(Chord)((ObjectToken)chordSequence.get(0)).getValue();
    Double chordDuration=c.getDuration();
    String chordName=c.getName();
    if (chordName.equals(MusicSpecs.TERMINATION_CHORD)) {
    }
 else {
      Chord newChord=new Chord(chordName,chordDuration);
      _allChords.put(_barProgress,newChord);
      _barProgress+=chordDuration;
    }
  }
  if (trigger.isOutsideConnected() && trigger.hasToken(0)) {
    trigger.get(0);
    _currentChord=_getChordForBeat(_currentBeat);
    if (_currentChord != null && !_currentChord.equals(""String_Node_Str"")) {
      nextChord.send(0,new StringToken(_currentChord));
    }
    _triggersSinceLastOutput++;
  }
  if (_triggersSinceLastOutput >= 10) {
    startLick.send(0,new BooleanToken(true));
  }
  if (incomingNote.hasToken(0)) {
    StringToken note=((StringToken)incomingNote.get(0));
    if (_durations != null && _durations.size() > 0) {
      double duration=_durations.get(0);
      Token[] nextTokens=new Token[2];
      nextTokens[1]=new DoubleToken(duration);
      if (duration < 0) {
        nextTokens[0]=new StringToken(MusicSpecs.REST_SYMBOL);
      }
 else {
        nextTokens[0]=note;
      }
      RecordToken next=new RecordToken(labels,nextTokens);
      acceptedTuples.send(0,next);
      _currentBeat+=Math.abs(duration);
      currentBeat.send(0,new DoubleToken(_currentBeat));
      _durations.remove(0);
    }
  }
  if (incomingDuration.hasToken(0)) {
    double nextDurationValue=((DoubleToken)incomingDuration.get(0)).doubleValue();
    if (nextDurationValue != 0) {
      _durations.add(nextDurationValue);
    }
    if (Math.abs(nextDurationValue - 0.33) < 0.1) {
      _durations.add(nextDurationValue);
      _durations.add(nextDurationValue);
    }
  }
}","public void fire() throws IllegalActionException {
  super.fire();
  if (resetBeat.isOutsideConnected() && resetBeat.hasToken(0)) {
    if (((BooleanToken)resetBeat.get(0)).booleanValue()) {
      _currentBeatCursor=0.0;
    }
  }
  if (reset.isOutsideConnected() && reset.hasToken(0)) {
    if (((BooleanToken)reset.get(0)).booleanValue()) {
      _allChords.clear();
      _currentBeatCursor=0.0;
      _barProgress=0.0;
      _durations.clear();
    }
  }
  if (chordSequence.hasToken(0)) {
    Chord c=(Chord)((ObjectToken)chordSequence.get(0)).getValue();
    Double chordDuration=c.getDuration();
    String chordName=c.getName();
    if (chordName.equals(MusicSpecs.TERMINATION_CHORD)) {
    }
 else {
      Chord newChord=new Chord(chordName,chordDuration);
      _allChords.put(_barProgress,newChord);
      _barProgress+=chordDuration;
    }
  }
  if (trigger.isOutsideConnected() && trigger.hasToken(0)) {
    trigger.get(0);
    _currentChord=_getChordForBeat(_currentBeatCursor);
    if (_currentChord != null && !_currentChord.equals(""String_Node_Str"")) {
      nextChord.send(0,new StringToken(_currentChord));
    }
    _triggersSinceLastOutput++;
  }
  if (_triggersSinceLastOutput >= 10) {
    startLick.send(0,new BooleanToken(true));
  }
  if (incomingNote.hasToken(0)) {
    StringToken note=((StringToken)incomingNote.get(0));
    if (_durations != null && _durations.size() > 0) {
      double duration=_durations.get(0);
      Token[] nextTokens=new Token[2];
      nextTokens[1]=new DoubleToken(duration);
      if (duration < 0) {
        nextTokens[0]=new StringToken(MusicSpecs.REST_SYMBOL);
      }
 else {
        nextTokens[0]=note;
      }
      RecordToken next=new RecordToken(labels,nextTokens);
      acceptedTuples.send(0,next);
      _currentBeatCursor+=Math.abs(duration);
      currentBeat.send(0,new DoubleToken(_currentBeatCursor));
      _durations.remove(0);
    }
  }
  if (incomingDuration.hasToken(0)) {
    double nextDurationValue=((DoubleToken)incomingDuration.get(0)).doubleValue();
    if (nextDurationValue != 0) {
      _durations.add(nextDurationValue);
    }
    if (Math.abs(nextDurationValue - 0.33) < 0.1) {
      _durations.add(nextDurationValue);
      _durations.add(nextDurationValue);
    }
  }
}"
72667,"/** 
 * Construct an actor in the specified container with the specified name.
 * @param container The container.
 * @param name The name of this adder within the container.
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the name coincides withan actor already in the container.
 */
public ChordFollower(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  incomingDuration=new TypedIOPort(this,""String_Node_Str"",true,false);
  incomingDuration.setTypeEquals(BaseType.DOUBLE);
  chordSequence=new TypedIOPort(this,""String_Node_Str"",true,false);
  chordSequence.setTypeEquals(BaseType.OBJECT);
  acceptedTuples=new TypedIOPort(this,""String_Node_Str"",false,true);
  Type[] tupleType={BaseType.STRING,BaseType.DOUBLE};
  acceptedTuples.setTypeEquals(new RecordType(labels,tupleType));
  trigger=new TypedIOPort(this,""String_Node_Str"",true,false);
  _triggersSinceLastOutput=0;
  nextChord=new TypedIOPort(this,""String_Node_Str"",false,true);
  nextChord.setTypeEquals(BaseType.STRING);
  reset=new TypedIOPort(this,""String_Node_Str"",true,false);
  StringAttribute cardinality=new StringAttribute(reset,""String_Node_Str"");
  cardinality.setExpression(""String_Node_Str"");
  startLick=new TypedIOPort(this,""String_Node_Str"",false,true);
  cardinality=new StringAttribute(startLick,""String_Node_Str"");
  cardinality.setExpression(""String_Node_Str"");
  startLick.setTypeEquals(BaseType.BOOLEAN);
  currentBeat=new TypedIOPort(this,""String_Node_Str"",false,true);
  currentBeat.setTypeEquals(BaseType.DOUBLE);
  incomingNote=new TypedIOPort(this,""String_Node_Str"",true,false);
  incomingNote.setTypeEquals(BaseType.STRING);
  resetBeat=new TypedIOPort(this,""String_Node_Str"",true,false);
  _allChords=new HashMap<Double,Chord>();
  _currentBeat=0.0;
  _durations=new LinkedList<Double>();
}","/** 
 * Construct an actor in the specified container with the specified name.
 * @param container The container.
 * @param name The name of this adder within the container.
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the name coincides withan actor already in the container.
 */
public ChordFollower(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  incomingDuration=new TypedIOPort(this,""String_Node_Str"",true,false);
  incomingDuration.setTypeEquals(BaseType.DOUBLE);
  chordSequence=new TypedIOPort(this,""String_Node_Str"",true,false);
  chordSequence.setTypeEquals(BaseType.OBJECT);
  acceptedTuples=new TypedIOPort(this,""String_Node_Str"",false,true);
  Type[] tupleType={BaseType.STRING,BaseType.DOUBLE};
  acceptedTuples.setTypeEquals(new RecordType(labels,tupleType));
  trigger=new TypedIOPort(this,""String_Node_Str"",true,false);
  _triggersSinceLastOutput=0;
  nextChord=new TypedIOPort(this,""String_Node_Str"",false,true);
  nextChord.setTypeEquals(BaseType.STRING);
  reset=new TypedIOPort(this,""String_Node_Str"",true,false);
  StringAttribute cardinality=new StringAttribute(reset,""String_Node_Str"");
  cardinality.setExpression(""String_Node_Str"");
  startLick=new TypedIOPort(this,""String_Node_Str"",false,true);
  cardinality=new StringAttribute(startLick,""String_Node_Str"");
  cardinality.setExpression(""String_Node_Str"");
  startLick.setTypeEquals(BaseType.BOOLEAN);
  currentBeat=new TypedIOPort(this,""String_Node_Str"",false,true);
  currentBeat.setTypeEquals(BaseType.DOUBLE);
  incomingNote=new TypedIOPort(this,""String_Node_Str"",true,false);
  incomingNote.setTypeEquals(BaseType.STRING);
  resetBeat=new TypedIOPort(this,""String_Node_Str"",true,false);
  _allChords=new HashMap<Double,Chord>();
  _currentBeatCursor=0.0;
  _durations=new LinkedList<Double>();
}"
72668,"/** 
 * Construct an actor with the given container and name.
 * @param container The container.
 * @param name The name of this actor
 * @param trainingSequence The input string that the oracle is built from
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public ChordParser(CompositeEntity container,String name) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  chordName=new TypedIOPort(this,""String_Node_Str"",true,false);
  chordName.setTypeEquals(BaseType.STRING);
  chordDuration=new TypedIOPort(this,""String_Node_Str"",true,false);
  chordDuration.setTypeEquals(BaseType.DOUBLE);
  chordIndex=new TypedIOPort(this,""String_Node_Str"",true,false);
  chordIndex.setTypeEquals(BaseType.INT);
  chords=new TypedIOPort(this,""String_Node_Str"",false,true);
  chords.setTypeEquals(BaseType.OBJECT);
  endChord=new TypedIOPort(this,""String_Node_Str"",true,false);
  endChord.setTypeEquals(BaseType.INT);
  _durations=new LinkedList<Double>();
  _notes=new LinkedList<String>();
  _orderedChords=new HashMap<Integer,Chord>();
  _timestamps=new LinkedList<Integer>();
  _terminateChord=false;
  _terminateLength=0;
}","/** 
 * Construct an actor with the given container and name.
 * @param container The container.
 * @param name The name of this actor
 * @param trainingSequence The input string that the oracle is built from
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public ChordParser(CompositeEntity container,String name) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  chordName=new TypedIOPort(this,""String_Node_Str"",true,false);
  chordName.setTypeEquals(BaseType.STRING);
  chordDuration=new TypedIOPort(this,""String_Node_Str"",true,false);
  chordDuration.setTypeEquals(BaseType.DOUBLE);
  chordIndex=new TypedIOPort(this,""String_Node_Str"",true,false);
  chordIndex.setTypeEquals(BaseType.INT);
  chords=new TypedIOPort(this,""String_Node_Str"",false,true);
  chords.setTypeEquals(BaseType.OBJECT);
  endChord=new TypedIOPort(this,""String_Node_Str"",true,false);
  endChord.setTypeEquals(BaseType.INT);
  _durations=new LinkedList<Double>();
  _chordNames=new LinkedList<String>();
  _orderedChords=new HashMap<Integer,Chord>();
  _timestamps=new LinkedList<Integer>();
  _terminateChord=false;
  _chordLength=0;
}"
72669,"public void fire() throws IllegalActionException {
  super.fire();
  if (chordName.hasToken(0)) {
    String chord=((StringToken)chordName.get(0)).stringValue();
    _notes.add(chord);
  }
  if (chordDuration.hasToken(0)) {
    double duration=((DoubleToken)chordDuration.get(0)).doubleValue();
    _durations.add(duration);
  }
  if (chordIndex.hasToken(0)) {
    int ts=((IntToken)chordIndex.get(0)).intValue();
    _timestamps.add(ts);
  }
  if (endChord.hasToken(0)) {
    _terminateChord=true;
    _chordLength=((IntToken)endChord.get(0)).intValue();
    _orderedChords.put(_chordLength + 1,new Chord(MusicSpecs.TERMINATION_CHORD,0.0));
    _terminateLength=_chordLength;
  }
  if (_notes.size() == _durations.size() && _notes.size() == _timestamps.size() && _notes.size() >= _terminateLength && _terminateLength > 0) {
    for (int i=_timestamps.size() - 1; i >= 0; i--) {
      int index=_timestamps.get(i);
      if (index < _durations.size() && index < _notes.size()) {
        double duration=_durations.get(index);
        _orderedChords.put(index,new Chord(_notes.get(index),duration));
        _timestamps.remove(i);
      }
    }
  }
  if (_terminateChord && _orderedChords.keySet().size() >= _terminateLength) {
    List keysSoFar=new LinkedList();
    keysSoFar.addAll(_orderedChords.keySet());
    Collections.sort(keysSoFar);
    Iterator iter=keysSoFar.iterator();
    while (iter.hasNext()) {
      chords.send(0,new ObjectToken((Chord)_orderedChords.get(iter.next())));
    }
    _orderedChords.clear();
    _notes.clear();
    _durations.clear();
    _timestamps.clear();
    _terminateChord=false;
    _terminateLength=0;
  }
}","public void fire() throws IllegalActionException {
  super.fire();
  if (chordName.hasToken(0)) {
    String chord=((StringToken)chordName.get(0)).stringValue();
    _chordNames.add(chord);
  }
  if (chordDuration.hasToken(0)) {
    double duration=((DoubleToken)chordDuration.get(0)).doubleValue();
    _durations.add(duration);
  }
  if (chordIndex.hasToken(0)) {
    int ts=((IntToken)chordIndex.get(0)).intValue();
    _timestamps.add(ts);
  }
  if (endChord.hasToken(0)) {
    _terminateChord=true;
    _chordLength=((IntToken)endChord.get(0)).intValue();
    _orderedChords.put(_chordLength + 1,new Chord(MusicSpecs.TERMINATION_CHORD,0.0));
  }
  if (_chordNames.size() == _durations.size() && _chordNames.size() == _timestamps.size() && _chordNames.size() >= _chordLength && _chordLength > 0) {
    for (int i=_timestamps.size() - 1; i >= 0; i--) {
      int index=_timestamps.get(i);
      if (index < _durations.size() && index < _chordNames.size()) {
        double duration=_durations.get(index);
        _orderedChords.put(index,new Chord(_chordNames.get(index),duration));
        _timestamps.remove(i);
      }
    }
  }
  if (_terminateChord && _orderedChords.keySet().size() >= _chordLength) {
    List keysSoFar=new LinkedList();
    keysSoFar.addAll(_orderedChords.keySet());
    Collections.sort(keysSoFar);
    Iterator iter=keysSoFar.iterator();
    while (iter.hasNext()) {
      chords.send(0,new ObjectToken(_orderedChords.get(iter.next())));
    }
    _orderedChords.clear();
    _chordNames.clear();
    _durations.clear();
    _timestamps.clear();
    _terminateChord=false;
    _chordLength=0;
  }
}"
72670,"/** 
 * Subscribe or multiread from a GCL. ""This routine handles calls that return multiple values via the event interface.  They might include subscriptions.""
 * @param gclh The handle to the GCL
 * @param the record number of the first record.
 * @return the status.
 */
static EP_STAT do_subscribe(Pointer gclh,long firstrec,int numrecs,boolean subscribe){
  EP_STAT estat;
  if (numrecs < 0) {
    numrecs=0;
  }
  if (subscribe) {
    PointerByReference gclhByReference=new PointerByReference();
    estat=Gdp10Library.INSTANCE.gdp_gcl_subscribe(gclhByReference,firstrec,numrecs,null,null,null);
    gclh=gclhByReference.getValue();
  }
 else {
    PointerByReference gclhByReference=new PointerByReference();
    estat=Gdp10Library.INSTANCE.gdp_gcl_multiread(gclhByReference,firstrec,numrecs,null,null);
    gclh=gclhByReference.getValue();
  }
  if (!GdpUtilities.EP_STAT_ISOK(estat)) {
    System.err.println(""String_Node_Str"" + (subscribe ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ estat.code);
  }
  for (; ; ) {
    PointerByReference gev=Gdp10Library.INSTANCE.gdp_event_next(true ? (byte)1 : (byte)0);
switch (Gdp10Library.INSTANCE.gdp_event_gettype(gev)) {
case GdpUtilities.GDP_EVENT_DATA:
      System.out.print(""String_Node_Str"");
    GdpUtilities.gdp_datum_print(Gdp10Library.INSTANCE.gdp_event_getdatum(gev));
  break;
case GdpUtilities.GDP_EVENT_EOS:
System.err.println(""String_Node_Str"" + (subscribe ? ""String_Node_Str"" : ""String_Node_Str""));
return estat;
default :
System.err.print(""String_Node_Str"" + Gdp10Library.INSTANCE.gdp_event_gettype(gev));
break;
}
Gdp10Library.INSTANCE.gdp_event_free(gev);
}
}","/** 
 * Subscribe or multiread from a GCL. ""This routine handles calls that return multiple values via the event interface.  They might include subscriptions.""
 * @param gclh The handle to the GCL
 * @param the record number of the first record.
 * @return the status.
 */
static EP_STAT do_subscribe(Pointer gclh,long firstrec,int numrecs,boolean subscribe){
  EP_STAT estat;
  if (numrecs < 0) {
    numrecs=0;
  }
  if (subscribe) {
    estat=Gdp10Library.INSTANCE.gdp_gcl_subscribe(gclh,firstrec,numrecs,null,null,null);
  }
 else {
    estat=Gdp10Library.INSTANCE.gdp_gcl_multiread(gclh,firstrec,numrecs,null,null);
  }
  if (!GdpUtilities.EP_STAT_ISOK(estat)) {
    System.err.println(""String_Node_Str"" + (subscribe ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ estat.code);
  }
  for (; ; ) {
    PointerByReference gev=Gdp10Library.INSTANCE.gdp_event_next(true ? (byte)1 : (byte)0);
switch (Gdp10Library.INSTANCE.gdp_event_gettype(gev)) {
case GdpUtilities.GDP_EVENT_DATA:
      System.out.print(""String_Node_Str"");
    GdpUtilities.gdp_datum_print(Gdp10Library.INSTANCE.gdp_event_getdatum(gev));
  break;
case GdpUtilities.GDP_EVENT_EOS:
System.err.println(""String_Node_Str"" + (subscribe ? ""String_Node_Str"" : ""String_Node_Str""));
return estat;
default :
System.err.print(""String_Node_Str"" + Gdp10Library.INSTANCE.gdp_event_gettype(gev));
break;
}
Gdp10Library.INSTANCE.gdp_event_free(gev);
}
}"
72671,"/** 
 * Print the datum to standard out.  This is a port of gdp_datum_print from gdp/gdp_datum.c by Eric Allman.
 * @param datum The datum to be printed.
 */
public static void gdp_datum_print(PointerByReference datum){
  Pointer d=null;
  NativeSizeT length=new NativeSizeT();
  length.setValue(-1);
  if (datum == null) {
    System.out.print(""String_Node_Str"");
  }
  System.out.print(""String_Node_Str"" + Gdp10Library.INSTANCE.gdp_datum_getrecno(datum) + ""String_Node_Str"");
  PointerByReference dbuf=Gdp10Library.INSTANCE.gdp_datum_getbuf(datum);
  if (dbuf == null) {
    System.out.print(""String_Node_Str"");
  }
 else {
    length=Gdp10Library.INSTANCE.gdp_buf_getlength(dbuf);
    System.out.print(""String_Node_Str"" + length);
    d=Gdp10Library.INSTANCE.gdp_buf_getptr(dbuf,new NativeSizeT(length.longValue()));
  }
  EP_TIME_SPEC ts=new EP_TIME_SPEC();
  Gdp10Library.INSTANCE.gdp_datum_getts(datum,ts);
  if (ts.tv_sec != Long.MIN_VALUE) {
    System.out.println(""String_Node_Str"" + ts.tv_sec + ""String_Node_Str""+ ts.tv_nsec+ ""String_Node_Str""+ ts.tv_accuracy);
  }
 else {
    System.out.print(""String_Node_Str"");
  }
  if (length.longValue() > 0) {
    System.out.print(""String_Node_Str"" + d.getString(0) + ""String_Node_Str"");
  }
  System.out.println(""String_Node_Str"");
}","/** 
 * Print the datum to standard out.  This is a port of gdp_datum_print from gdp/gdp_datum.c by Eric Allman.
 * @param datum The datum to be printed.
 */
public static void gdp_datum_print(PointerByReference datum){
  Pointer d=null;
  NativeSizeT length=new NativeSizeT();
  length.setValue(-1);
  if (datum == null) {
    System.out.print(""String_Node_Str"");
  }
  System.out.print(""String_Node_Str"" + Gdp10Library.INSTANCE.gdp_datum_getrecno(datum) + ""String_Node_Str"");
  PointerByReference dbuf=Gdp10Library.INSTANCE.gdp_datum_getbuf(datum);
  if (dbuf == null) {
    System.out.print(""String_Node_Str"");
  }
 else {
    length=Gdp10Library.INSTANCE.gdp_buf_getlength(dbuf);
    System.out.print(""String_Node_Str"" + length);
    d=Gdp10Library.INSTANCE.gdp_buf_getptr(dbuf,new NativeSizeT(length.longValue()));
  }
  EP_TIME_SPEC ts=new EP_TIME_SPEC();
  Gdp10Library.INSTANCE.gdp_datum_getts(datum,ts);
  if (ts.tv_sec != Long.MIN_VALUE) {
    Date myDate=new Date(ts.tv_sec * 1000);
    SimpleDateFormat dateFormat=new SimpleDateFormat(""String_Node_Str"" + ts.tv_nsec + ""String_Node_Str"");
    dateFormat.setTimeZone(TimeZone.getTimeZone(""String_Node_Str""));
    System.out.println(""String_Node_Str"" + dateFormat.format(myDate));
  }
 else {
    System.out.print(""String_Node_Str"");
  }
  if (length.longValue() > 0) {
    byte[] bytes=d.getByteArray(0,length.intValue());
    System.out.print(""String_Node_Str"" + new String(bytes) + ""String_Node_Str"");
    if (d.getString(0).length() != length.intValue()) {
      System.out.print(""String_Node_Str"" + d.getString(0) + ""String_Node_Str""+ d.getString(0).length()+ ""String_Node_Str""+ length);
    }
  }
  System.out.println(""String_Node_Str"");
}"
72672,"/** 
 * Return true if the status code is ok. Based on ep_stat.h, Copyright Eric Allman, See ep_license.htm
 * @param estat The status code.
 * @return true if the code is less than EP_STAT_SEV_WARN
 */
public static boolean EP_STAT_ISOK(EP_STAT estat){
  long code=estat.code.longValue();
  long EP_STAT_SEVERITY=(code >> Gdp10Library._EP_STAT_SEVSHIFT) & ((1l << Gdp10Library._EP_STAT_SEVBITS) - 1);
  return EP_STAT_SEVERITY < Gdp10Library.EP_STAT_SEV_WARN;
}","/** 
 * Return true if the status code is ok. Based on ep_stat.h, Copyright Eric Allman, See ep_license.htm
 * @param estat The status code.
 * @return true if the code is less than EP_STAT_SEV_WARN
 */
public static boolean EP_STAT_ISOK(EP_STAT estat){
  long code=estat.code.longValue();
  long EP_STAT_SEVERITY=(code >>> Gdp10Library._EP_STAT_SEVSHIFT) & ((1l << Gdp10Library._EP_STAT_SEVBITS) - 1);
  return EP_STAT_SEVERITY < Gdp10Library.EP_STAT_SEV_WARN;
}"
72673,"/** 
 * Initialize the class. 
 */
private void _init() throws IllegalActionException, NameDuplicationException {
  StringToken[] empty=new StringToken[1];
  stateVariableNames=new Parameter(this,""String_Node_Str"");
  empty[0]=new StringToken(""String_Node_Str"");
  stateVariableNames.setToken(new ArrayToken(BaseType.STRING,empty));
  bootstrap=new Parameter(this,""String_Node_Str"");
  bootstrap.setTypeEquals(BaseType.BOOLEAN);
  bootstrap.setExpression(""String_Node_Str"");
  lowVarianceSampler=new Parameter(this,""String_Node_Str"");
  lowVarianceSampler.setTypeEquals(BaseType.BOOLEAN);
  lowVarianceSampler.setExpression(""String_Node_Str"");
  particleCount=new Parameter(this,""String_Node_Str"");
  particleCount.setExpression(""String_Node_Str"");
  Nparticles=1000;
  outputParticleCount=new Parameter(this,""String_Node_Str"");
  outputParticleCount.setExpression(""String_Node_Str"");
  Noutput=100;
  processNoise=new Parameter(this,""String_Node_Str"");
  processNoise.setExpression(""String_Node_Str"");
  particleOutput=new TypedIOPort(this,""String_Node_Str"",false,true);
  particleOutput.setTypeEquals(RecordType.EMPTY_RECORD);
  SingletonParameter showName=(SingletonParameter)particleOutput.getAttribute(""String_Node_Str"");
  if (showName == null) {
    showName=new SingletonParameter(particleOutput,""String_Node_Str"");
    showName.setToken(""String_Node_Str"");
  }
 else {
    showName.setToken(""String_Node_Str"");
  }
  seed=new SharedParameter(this,""String_Node_Str"");
  seed.setExpression(""String_Node_Str"");
  seed.setTypeEquals(BaseType.LONG);
  seed.setVisibility(Settable.EXPERT);
  resetOnEachRun=new SharedParameter(this,""String_Node_Str"");
  resetOnEachRun.setExpression(""String_Node_Str"");
  resetOnEachRun.setVisibility(Settable.EXPERT);
  resetOnEachRun.setTypeEquals(BaseType.BOOLEAN);
  stateEstimate=new TypedIOPort(this,""String_Node_Str"",false,true);
  stateEstimate.setTypeEquals(RecordType.EMPTY_RECORD);
  showName=(SingletonParameter)stateEstimate.getAttribute(""String_Node_Str"");
  if (showName == null) {
    showName=new SingletonParameter(stateEstimate,""String_Node_Str"");
    showName.setToken(""String_Node_Str"");
  }
 else {
    showName.setToken(""String_Node_Str"");
  }
  prior=new Parameter(this,""String_Node_Str"");
  prior.setExpression(""String_Node_Str"");
  t=new Parameter(this,""String_Node_Str"");
  t.setTypeEquals(BaseType.DOUBLE);
  t.setVisibility(Settable.EXPERT);
  t.setExpression(""String_Node_Str"");
  measurementCovariance=new Parameter(this,""String_Node_Str"");
  measurementCovariance.setExpression(""String_Node_Str"");
  _measurementParameters=new HashMap<String,Parameter>();
  _measurementValues=new HashMap<String,Token>();
  _measurementEquations=new LinkedList<Expression>();
  _firstIteration=true;
  particles=new Particle[Nparticles];
  _createRandomGenerator();
  _tokenMap=new HashMap<String,Token>();
  _parseTreeEvaluator=new ParseTreeEvaluator();
  _scope=new VariableScope();
  new DEDirector(this,""String_Node_Str"").setPersistent(false);
  _attachText(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","/** 
 * Initialize the class. 
 */
private void _init() throws IllegalActionException, NameDuplicationException {
  StringToken[] empty=new StringToken[1];
  stateVariableNames=new Parameter(this,""String_Node_Str"");
  empty[0]=new StringToken(""String_Node_Str"");
  stateVariableNames.setToken(new ArrayToken(BaseType.STRING,empty));
  bootstrap=new Parameter(this,""String_Node_Str"");
  bootstrap.setTypeEquals(BaseType.BOOLEAN);
  bootstrap.setExpression(""String_Node_Str"");
  lowVarianceSampler=new Parameter(this,""String_Node_Str"");
  lowVarianceSampler.setTypeEquals(BaseType.BOOLEAN);
  lowVarianceSampler.setExpression(""String_Node_Str"");
  particleCount=new Parameter(this,""String_Node_Str"");
  particleCount.setExpression(""String_Node_Str"");
  Nparticles=1000;
  outputParticleCount=new Parameter(this,""String_Node_Str"");
  outputParticleCount.setExpression(""String_Node_Str"");
  Noutput=100;
  processNoise=new Parameter(this,""String_Node_Str"");
  processNoise.setExpression(""String_Node_Str"");
  particleOutput=new TypedIOPort(this,""String_Node_Str"",false,true);
  particleOutput.setTypeEquals(RecordType.EMPTY_RECORD);
  SingletonParameter showName=(SingletonParameter)particleOutput.getAttribute(""String_Node_Str"");
  if (showName == null) {
    showName=new SingletonParameter(particleOutput,""String_Node_Str"");
    showName.setToken(""String_Node_Str"");
  }
 else {
    showName.setToken(""String_Node_Str"");
  }
  seed=new SharedParameter(this,""String_Node_Str"");
  seed.setExpression(""String_Node_Str"");
  seed.setTypeEquals(BaseType.LONG);
  seed.setVisibility(Settable.EXPERT);
  resetOnEachRun=new SharedParameter(this,""String_Node_Str"");
  resetOnEachRun.setExpression(""String_Node_Str"");
  resetOnEachRun.setVisibility(Settable.EXPERT);
  resetOnEachRun.setTypeEquals(BaseType.BOOLEAN);
  stateEstimate=new TypedIOPort(this,""String_Node_Str"",false,true);
  stateEstimate.setTypeEquals(RecordType.EMPTY_RECORD);
  showName=(SingletonParameter)stateEstimate.getAttribute(""String_Node_Str"");
  if (showName == null) {
    showName=new SingletonParameter(stateEstimate,""String_Node_Str"");
    showName.setToken(""String_Node_Str"");
  }
 else {
    showName.setToken(""String_Node_Str"");
  }
  prior=new Parameter(this,""String_Node_Str"");
  prior.setExpression(""String_Node_Str"");
  t=new Parameter(this,""String_Node_Str"");
  t.setTypeEquals(BaseType.DOUBLE);
  t.setVisibility(Settable.EXPERT);
  t.setExpression(""String_Node_Str"");
  measurementCovariance=new Parameter(this,""String_Node_Str"");
  measurementCovariance.setExpression(""String_Node_Str"");
  _measurementParameters=new HashMap<String,Parameter>();
  _measurementValues=new HashMap<String,Token>();
  _measurementEquations=new LinkedList<Expression>();
  _firstIteration=true;
  particles=new Particle[Nparticles];
  _createRandomGenerator();
  _tokenMap=new HashMap<String,Token>();
  new DEDirector(this,""String_Node_Str"").setPersistent(false);
  _attachText(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}"
72674,"/** 
 * Print the datum to standard out.  This is a port of gdp_datum_print from gdp/gdp_api.c by Eric Allman.
 * @param datum The datum to be printed.
 */
private static void _gdp_datum_print(gdp_datum datum){
  int length=-1;
  if (datum == null) {
    System.out.println(""String_Node_Str"");
  }
  System.out.print(""String_Node_Str"" + datum.recno);
  if (datum.dbuf == null) {
    System.out.print(""String_Node_Str"");
  }
 else {
    System.out.print(""String_Node_Str"" + datum.dlen + ""String_Node_Str""+ length);
  }
  if (datum.ts.tv_sec != Long.MIN_VALUE) {
    System.out.print(""String_Node_Str"");
    System.out.print(""String_Node_Str"");
  }
 else {
    System.out.print(""String_Node_Str"");
  }
  if (length > 0) {
    System.out.print(""String_Node_Str"");
  }
}","/** 
 * Print the datum to standard out.  This is a port of gdp_datum_print from gdp/gdp_api.c by Eric Allman.
 * @param datum The datum to be printed.
 */
private static void _gdp_datum_print(gdp_datum datum){
  Pointer d;
  NativeSizeT length=new NativeSizeT();
  length.setValue(-1);
  if (datum == null) {
    System.out.println(""String_Node_Str"");
  }
  System.out.print(""String_Node_Str"" + datum.recno);
  if (datum.dbuf == null) {
    System.out.print(""String_Node_Str"");
  }
 else {
    length=Event2Library.INSTANCE.evbuffer_get_length(new evbuffer(datum.dbuf.getValue()));
    System.out.print(""String_Node_Str"" + datum.dlen + ""String_Node_Str""+ length);
    d=Event2Library.INSTANCE.evbuffer_pullup(new evbuffer(datum.dbuf.getValue()),new NativeLong(length.longValue()));
  }
  if (datum.ts.tv_sec != Long.MIN_VALUE) {
    System.out.print(""String_Node_Str"");
    System.out.print(""String_Node_Str"");
  }
 else {
    System.out.print(""String_Node_Str"");
  }
  if (length.longValue() > 0) {
    System.out.print(""String_Node_Str"");
  }
}"
72675,"public static void main(String[] argv) throws Throwable {
  PointerByReference gclh=null;
  ByteBuffer gcliname=null;
  int opt;
  EP_STAT estat;
  boolean append=false;
  String xname=null;
  String buf=""String_Node_Str"";
  String ptII=StringUtilities.getProperty(""String_Node_Str"");
  NativeLibrary nativeLibrary=NativeLibrary.getInstance(ptII + ""String_Node_Str"");
  int argc=argv.length;
  for (int i=0; i < argv.length; i++) {
    if (argv[i].equals('a')) {
      append=true;
      argc--;
    }
 else     if (argv[i].equals('D')) {
      argc--;
      GdpLibrary.INSTANCE.ep_dbg_set(argv[i + 1]);
    }
  }
  if (argc > 0) {
    xname=argv[argc];
    argc--;
  }
  if (argc != 0 || (append && xname == null)) {
    System.err.println(""String_Node_Str"" + ""String_Node_Str"");
    System.exit(64);
  }
  estat=GdpLibrary.INSTANCE.gdp_init();
  if (estat.code.intValue() != 0) {
    System.err.println(""String_Node_Str"");
    _fail0(estat);
  }
  if (xname == null) {
    estat=GdpLibrary.INSTANCE.gdp_gcl_create((ByteBuffer)null,gclh);
  }
 else {
    GdpLibrary.INSTANCE.gdp_gcl_parse_name(xname,gcliname);
    if (append) {
      estat=GdpLibrary.INSTANCE.gdp_gcl_open(gcliname,GdpLibrary.gdp_iomode_t.GDP_MODE_AO,gclh);
    }
 else {
      estat=GdpLibrary.INSTANCE.gdp_gcl_create(gcliname,gclh);
    }
  }
  if (estat.code.intValue() != 0) {
    _fail0(estat);
  }
  System.out.print(""String_Node_Str"" + System.identityHashCode(gclh) + ""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  gdp_datum datum=GdpLibrary.INSTANCE.gdp_datum_new();
  BufferedReader bufferedReader=null;
  try {
    bufferedReader=new BufferedReader(new InputStreamReader(System.in));
    while ((buf=bufferedReader.readLine()) != null) {
      System.out.println(""String_Node_Str"" + buf + ""String_Node_Str"");
      System.err.println(""String_Node_Str"");
      estat=GdpLibrary.INSTANCE.gdp_gcl_publish(gclh,datum);
      if (estat.code.intValue() != 0) {
        _fail1(estat,gclh);
      }
      _gdp_datum_print(datum);
    }
  }
  finally {
    if (bufferedReader != null) {
      bufferedReader.close();
    }
  }
  GdpLibrary.INSTANCE.gdp_datum_free(datum);
  _fail0(estat);
}","public static void main(String[] argv) throws Throwable {
  PointerByReference gclh=null;
  ByteBuffer gcliname=null;
  int opt;
  EP_STAT estat;
  boolean append=false;
  String xname=null;
  String buf=""String_Node_Str"";
  String ptII=StringUtilities.getProperty(""String_Node_Str"");
  NativeLibrary nativeLibrary=NativeLibrary.getInstance(ptII + ""String_Node_Str"");
  int argc=argv.length;
  for (int i=0; i < argv.length; i++) {
    if (argv[i].equals('a')) {
      append=true;
      argc--;
    }
 else     if (argv[i].equals('D')) {
      argc--;
      GdpLibrary.INSTANCE.ep_dbg_set(argv[i + 1]);
    }
  }
  if (argc > 0) {
    xname=argv[argc];
    argc--;
  }
  if (argc != 0 || (append && xname == null)) {
    System.err.println(""String_Node_Str"" + ""String_Node_Str"");
    System.exit(64);
  }
  estat=GdpLibrary.INSTANCE.gdp_init();
  if (estat.code.intValue() != 0) {
    System.err.println(""String_Node_Str"");
    _fail0(estat);
  }
  if (xname == null) {
    estat=GdpLibrary.INSTANCE.gdp_gcl_create((ByteBuffer)null,gclh);
  }
 else {
    GdpLibrary.INSTANCE.gdp_gcl_parse_name(xname,gcliname);
    if (append) {
      estat=GdpLibrary.INSTANCE.gdp_gcl_open(gcliname,GdpLibrary.gdp_iomode_t.GDP_MODE_AO,gclh);
    }
 else {
      estat=GdpLibrary.INSTANCE.gdp_gcl_create(gcliname,gclh);
    }
  }
  if (estat.code.intValue() != 0) {
    _fail0(estat);
  }
  System.out.print(""String_Node_Str"" + System.identityHashCode(gclh) + ""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  gdp_datum datum=GdpLibrary.INSTANCE.gdp_datum_new();
  BufferedReader bufferedReader=null;
  try {
    bufferedReader=new BufferedReader(new InputStreamReader(System.in));
    String line;
    final int bufferLength=200;
    while ((line=bufferedReader.readLine()) != null) {
      System.out.println(""String_Node_Str"" + buf + ""String_Node_Str"");
      if (line.length() > bufferLength) {
        throw new Exception(""String_Node_Str"" + line + ""String_Node_Str""+ bufferLength);
      }
      Memory memory=new Memory(bufferLength);
      Memory alignedMemory=memory.align(4);
      memory.clear();
      Pointer pointer=alignedMemory.share(0);
      pointer.setString(0,line);
      Event2Library.INSTANCE.evbuffer_add(new evbuffer(datum.dbuf.getValue()),pointer,new NativeSizeT(line.length()));
      estat=GdpLibrary.INSTANCE.gdp_gcl_publish(gclh,datum);
      if (estat.code.intValue() != 0) {
        _fail1(estat,gclh);
      }
      _gdp_datum_print(datum);
    }
  }
  finally {
    if (bufferedReader != null) {
      bufferedReader.close();
    }
  }
  GdpLibrary.INSTANCE.gdp_datum_free(datum);
  _fail0(estat);
}"
72676,"/** 
 * Construct a AFDXESs with a name and a container. The container argument must not be null, or a NullPointerException will be thrown.  This actor will use the workspace of the container for synchronization and version counts. If the name argument is null, then the name is set to the empty string. Increment the version of the workspace.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the container is incompatiblewith this actor.
 * @exception NameDuplicationException If the name coincides withan actor already in the container.
 */
public AFDXESs(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  bitRate=new Parameter(this,""String_Node_Str"");
  bitRate.setDisplayName(""String_Node_Str"");
  bitRate.setExpression(""String_Node_Str"");
  bitRate.setTypeEquals(BaseType.DOUBLE);
  _bitRate=100;
  _tokenCount=0;
  _virtualLinkTable=new HashMap<String,AFDXVlink>();
  _portToVirtualLinks=new HashMap<IOPort,AFDXVlink>();
  _lastEmissionTable=new HashMap<String,Time>();
  _afdxVLinksQueue=new HashMap<String,LinkedList<TimedEvent>>();
  _afdxSchedMuxsQueue=new HashMap<String,LinkedList<TimedEvent>>();
  _attachText(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","/** 
 * Construct a AFDXESs with a name and a container. The container argument must not be null, or a NullPointerException will be thrown.  This actor will use the workspace of the container for synchronization and version counts. If the name argument is null, then the name is set to the empty string. Increment the version of the workspace.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the container is incompatiblewith this actor.
 * @exception NameDuplicationException If the name coincides withan actor already in the container.
 */
public AFDXESs(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  bitRate=new Parameter(this,""String_Node_Str"");
  bitRate.setDisplayName(""String_Node_Str"");
  bitRate.setExpression(""String_Node_Str"");
  bitRate.setTypeEquals(BaseType.DOUBLE);
  _bitRate=100;
  _tokenCount=0;
  _virtualLinkTable=new HashMap<String,AFDXVlink>();
  _portToVirtualLinks=new HashMap<IOPort,AFDXVlink>();
  _lastEmissionTable=new HashMap<String,Time>();
  _afdxVLinksQueue=new LinkedHashMap<String,LinkedList<TimedEvent>>();
  _afdxSchedMuxsQueue=new HashMap<String,LinkedList<TimedEvent>>();
  _attachText(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}"
72677,"/** 
 * Initiate a send of the specified token to the specified receiver. This method will schedule a refiring of this actor according to the requirements of the AFDX protocol.
 * @param source Sender of the token.
 * @param receiver The receiver to send to.
 * @param token The token to send.
 * @exception IllegalActionException If the refiring request fails.
 */
@Override public void sendToken(Receiver source,Receiver receiver,Token token) throws IllegalActionException {
  Time currentTime=getDirector().getModelTime();
  Time lastTimeStamp=null;
  boolean multicast=false;
  IOPort receiverContainer=receiver.getContainer();
  Actor emitterSource=((IntermediateReceiver)source).source;
  AFDXVlink vl=_portToVirtualLinks.get(receiverContainer);
  vl.setSource(emitterSource);
  if (!_lastEmissionTable.containsKey(vl.getName())) {
    _lastEmissionTable.put(vl.getName(),new Time(getDirector(),currentTime.getDoubleValue()));
  }
  if (!_virtualLinkTable.containsKey(vl.getName())) {
    _virtualLinkTable.put(vl.getName(),vl);
  }
  if (!_afdxSchedMuxsQueue.containsKey(vl.getSchedulerMux())) {
    _afdxSchedMuxsQueue.put(vl.getSchedulerMux(),new LinkedList<TimedEvent>());
  }
  if (!_afdxVLinksQueue.containsKey(vl.getName())) {
    _afdxVLinksQueue.put(vl.getName(),new LinkedList());
  }
  if (_afdxVLinksQueue.get(vl.getName()).size() > 0) {
    lastTimeStamp=_afdxVLinksQueue.get(vl.getName()).getLast().timeStamp;
    Object[] output=(Object[])_afdxVLinksQueue.get(vl.getName()).getLast().contents;
    if (((AFDXVlink)output[2]).getSource().equals(((IntermediateReceiver)source).source) && ((Time)output[3]).compareTo(currentTime) == 0) {
      multicast=true;
    }
  }
 else {
    lastTimeStamp=_lastEmissionTable.get(vl.getName());
  }
  if (multicast) {
    _lastEmissionTable.put(vl.getName(),lastTimeStamp);
    _afdxVLinksQueue.get(vl.getName()).add(new TimedEvent(lastTimeStamp,new Object[]{receiver,token,vl,currentTime}));
    multicast=false;
  }
 else {
    if (lastTimeStamp.compareTo(currentTime) == 0 && _afdxVLinksQueue.get(vl.getName()).size() < 1) {
      _delay=0.0;
    }
 else     if (lastTimeStamp.add(vl.getBag()).compareTo(currentTime) < 0) {
      _delay=0.0;
    }
 else     if (lastTimeStamp.add(vl.getBag()).compareTo(currentTime) == 0) {
      _delay=0.0;
    }
 else     if (lastTimeStamp.add(vl.getBag()).compareTo(currentTime) > 0) {
      _delay=lastTimeStamp.add(vl.getBag()).subtract(currentTime).getDoubleValue();
    }
    _lastEmissionTable.put(vl.getName(),currentTime.add(_delay));
    _afdxVLinksQueue.get(vl.getName()).add(new TimedEvent(currentTime.add(_delay),new Object[]{receiver,token,vl,currentTime}));
  }
  _tokenCount++;
  _scheduleRefire();
}","/** 
 * Initiate a send of the specified token to the specified receiver. This method will schedule a refiring of this actor according to the requirements of the AFDX protocol.
 * @param source Sender of the token.
 * @param receiver The receiver to send to.
 * @param token The token to send.
 * @exception IllegalActionException If the refiring request fails.
 */
@Override public void sendToken(Receiver source,Receiver receiver,Token token) throws IllegalActionException {
  Time currentTime=getDirector().getModelTime();
  Time lastTimeStamp=null;
  boolean multicast=false;
  IOPort receiverContainer=receiver.getContainer();
  Actor emitterSource=((IntermediateReceiver)source).source;
  System.out.println(""String_Node_Str"" + token.toString() + ""String_Node_Str""+ receiver);
  System.out.println(""String_Node_Str"" + _portToVirtualLinks.toString());
  AFDXVlink vl=_portToVirtualLinks.get(receiverContainer);
  vl.setSource(emitterSource);
  if (!_lastEmissionTable.containsKey(vl.getName())) {
    _lastEmissionTable.put(vl.getName(),new Time(getDirector(),currentTime.getDoubleValue()));
  }
  if (!_virtualLinkTable.containsKey(vl.getName())) {
    _virtualLinkTable.put(vl.getName(),vl);
  }
  if (!_afdxSchedMuxsQueue.containsKey(vl.getSchedulerMux())) {
    _afdxSchedMuxsQueue.put(vl.getSchedulerMux(),new LinkedList<TimedEvent>());
  }
  if (!_afdxVLinksQueue.containsKey(vl.getName())) {
    _afdxVLinksQueue.put(vl.getName(),new LinkedList());
  }
  if (_afdxVLinksQueue.get(vl.getName()).size() > 0) {
    lastTimeStamp=_afdxVLinksQueue.get(vl.getName()).getLast().timeStamp;
    Object[] output=(Object[])_afdxVLinksQueue.get(vl.getName()).getLast().contents;
    if (((AFDXVlink)output[2]).getSource().equals(((IntermediateReceiver)source).source) && ((Time)output[3]).compareTo(currentTime) == 0) {
      multicast=true;
    }
  }
 else {
    lastTimeStamp=_lastEmissionTable.get(vl.getName());
  }
  if (multicast) {
    _lastEmissionTable.put(vl.getName(),lastTimeStamp);
    _afdxVLinksQueue.get(vl.getName()).add(new TimedEvent(lastTimeStamp,new Object[]{receiver,token,vl,currentTime}));
    multicast=false;
  }
 else {
    if (lastTimeStamp.compareTo(currentTime) == 0 && _afdxVLinksQueue.get(vl.getName()).size() < 1) {
      _delay=0.0;
    }
 else     if (lastTimeStamp.add(vl.getBag()).compareTo(currentTime) < 0) {
      _delay=0.0;
    }
 else     if (lastTimeStamp.add(vl.getBag()).compareTo(currentTime) == 0) {
      _delay=0.0;
    }
 else     if (lastTimeStamp.add(vl.getBag()).compareTo(currentTime) > 0) {
      _delay=lastTimeStamp.add(vl.getBag()).subtract(currentTime).getDoubleValue();
    }
    _lastEmissionTable.put(vl.getName(),currentTime.add(_delay));
    _afdxVLinksQueue.get(vl.getName()).add(new TimedEvent(currentTime.add(_delay),new Object[]{receiver,token,vl,currentTime}));
  }
  _tokenCount++;
  _scheduleRefire();
}"
72678,"/** 
 * Clone this actor into the specified workspace. The new actor is <i>not</i> added to the directory of that workspace (you must do this yourself if you want it there). The result is a new actor with the same ports as the original, but no connections and no container.  A container must be set before much can be done with this actor.
 * @param workspace The workspace for the cloned object.
 * @exception CloneNotSupportedException If cloned ports cannot haveas their container the cloned entity (this should not occur), or if one of the attributes cannot be cloned.
 * @return A new AFDXESs.
 */
@Override public Object clone(Workspace workspace) throws CloneNotSupportedException {
  AFDXESs newObject=(AFDXESs)super.clone(workspace);
  newObject._afdxVLinksQueue=new HashMap();
  newObject._afdxSchedMuxsQueue=new HashMap();
  newObject._virtualLinkTable=new HashMap();
  newObject._portToVirtualLinks=new HashMap();
  newObject._lastEmissionTable=new HashMap();
  newObject._nextFireTime=_nextFireTime;
  newObject._bitRate=_bitRate;
  return newObject;
}","/** 
 * Clone this actor into the specified workspace. The new actor is <i>not</i> added to the directory of that workspace (you must do this yourself if you want it there). The result is a new actor with the same ports as the original, but no connections and no container.  A container must be set before much can be done with this actor.
 * @param workspace The workspace for the cloned object.
 * @exception CloneNotSupportedException If cloned ports cannot haveas their container the cloned entity (this should not occur), or if one of the attributes cannot be cloned.
 * @return A new AFDXESs.
 */
@Override public Object clone(Workspace workspace) throws CloneNotSupportedException {
  AFDXESs newObject=(AFDXESs)super.clone(workspace);
  newObject._afdxVLinksQueue=new LinkedHashMap();
  newObject._afdxSchedMuxsQueue=new HashMap();
  newObject._virtualLinkTable=new HashMap();
  newObject._portToVirtualLinks=new HashMap();
  newObject._lastEmissionTable=new HashMap();
  newObject._nextFireTime=_nextFireTime;
  newObject._bitRate=_bitRate;
  return newObject;
}"
72679,"/** 
 * Fire the actor. Typically, the fire() method performs the computation associated with an actor. Here, it delivers (if required) the intended token to the intended receiver(s).
 * @exception IllegalActionException If firing is not permitted.
 */
@Override public void fire() throws IllegalActionException {
  super.fire();
  Time currentTime=getDirector().getModelTime();
  Time computedTimeStamp=null;
  boolean multicast=false;
  for (  Entry<String,LinkedList<TimedEvent>> entry : _afdxVLinksQueue.entrySet()) {
    if (entry.getValue().size() > 0) {
      TimedEvent e=entry.getValue().getFirst();
      if (e.timeStamp.compareTo(currentTime) == 0) {
        Time lastTimeStamp=currentTime;
        AFDXVlink vl=_virtualLinkTable.get(entry.getKey());
        if (_afdxSchedMuxsQueue.get(vl.getSchedulerMux()).size() > 0) {
          Object[] last=(Object[])_afdxSchedMuxsQueue.get(vl.getSchedulerMux()).getLast().contents;
          Object[] output=(Object[])e.contents;
          if (((AFDXVlink)output[2]).getSource().equals(((AFDXVlink)last[2]).getSource()) && ((Time)output[3]).compareTo(last[3]) == 0) {
            multicast=true;
          }
          lastTimeStamp=_afdxSchedMuxsQueue.get(vl.getSchedulerMux()).getLast().timeStamp;
        }
        if (multicast) {
          computedTimeStamp=lastTimeStamp;
          multicast=false;
        }
 else {
          computedTimeStamp=lastTimeStamp.add(vl.getFrameSize() / (_bitRate * 1000000));
        }
        _afdxSchedMuxsQueue.get(vl.getSchedulerMux()).add(new TimedEvent(computedTimeStamp,e.contents));
        entry.getValue().remove(e);
      }
    }
  }
  if (_nextFireTime != null && currentTime.compareTo(_nextFireTime) == 0) {
    for (    Entry<String,LinkedList<TimedEvent>> entry : _afdxSchedMuxsQueue.entrySet()) {
      if (entry.getValue().size() > 0) {
        TimedEvent e=entry.getValue().getFirst();
        if (e.timeStamp.compareTo(currentTime) == 0) {
          Object[] output=(Object[])e.contents;
          Receiver receiver=(Receiver)output[0];
          if (receiver instanceof IntermediateReceiver) {
            String[] labels=new String[]{timestamp,vlink,payload};
            Token[] values=new Token[]{new DoubleToken(e.timeStamp.getDoubleValue()),new ObjectToken(output[2]),(Token)output[1]};
            RecordToken record=new RecordToken(labels,values);
            _sendToReceiver((Receiver)output[0],record);
          }
 else {
            Token token=(Token)output[1];
            _sendToReceiver(receiver,token);
          }
          entry.getValue().remove(e);
          if (_debugging) {
            _debug(""String_Node_Str"" + entry.getKey() + ""String_Node_Str""+ currentTime);
          }
        }
      }
    }
  }
  _scheduleRefire();
}","/** 
 * Fire the actor. Typically, the fire() method performs the computation associated with an actor. Here, it delivers (if required) the intended token to the intended receiver(s).
 * @exception IllegalActionException If firing is not permitted.
 */
@Override public void fire() throws IllegalActionException {
  super.fire();
  Time currentTime=getDirector().getModelTime();
  Time computedTimeStamp=null;
  boolean multicast=false;
  for (  Entry<String,LinkedList<TimedEvent>> entry : _afdxVLinksQueue.entrySet()) {
    if (entry.getValue().size() > 0) {
      TimedEvent e=entry.getValue().getFirst();
      System.out.println(""String_Node_Str"" + e.contents);
      if (e.timeStamp.compareTo(currentTime) == 0) {
        Time lastTimeStamp=currentTime;
        AFDXVlink vl=_virtualLinkTable.get(entry.getKey());
        if (_afdxSchedMuxsQueue.get(vl.getSchedulerMux()).size() > 0) {
          Object[] last=(Object[])_afdxSchedMuxsQueue.get(vl.getSchedulerMux()).getLast().contents;
          Object[] output=(Object[])e.contents;
          if (((AFDXVlink)output[2]).getSource().equals(((AFDXVlink)last[2]).getSource()) && ((Time)output[3]).compareTo(last[3]) == 0) {
            multicast=true;
          }
          lastTimeStamp=_afdxSchedMuxsQueue.get(vl.getSchedulerMux()).getLast().timeStamp;
        }
        if (multicast) {
          computedTimeStamp=lastTimeStamp;
          multicast=false;
        }
 else {
          computedTimeStamp=lastTimeStamp.add(vl.getFrameSize() / (_bitRate * 1000000));
        }
        _afdxSchedMuxsQueue.get(vl.getSchedulerMux()).add(new TimedEvent(computedTimeStamp,e.contents));
        entry.getValue().remove(e);
      }
    }
  }
  if (_nextFireTime != null && currentTime.compareTo(_nextFireTime) == 0) {
    for (    Entry<String,LinkedList<TimedEvent>> entry : _afdxSchedMuxsQueue.entrySet()) {
      if (entry.getValue().size() > 0) {
        TimedEvent e=entry.getValue().getFirst();
        if (e.timeStamp.compareTo(currentTime) == 0) {
          Object[] output=(Object[])e.contents;
          Receiver receiver=(Receiver)output[0];
          if (receiver instanceof IntermediateReceiver) {
            String[] labels=new String[]{timestamp,vlink,payload};
            Token[] values=new Token[]{new DoubleToken(e.timeStamp.getDoubleValue()),new ObjectToken(output[2]),(Token)output[1]};
            RecordToken record=new RecordToken(labels,values);
            _sendToReceiver((Receiver)output[0],record);
          }
 else {
            Token token=(Token)output[1];
            _sendToReceiver(receiver,token);
          }
          entry.getValue().remove(e);
          if (_debugging) {
            _debug(""String_Node_Str"" + entry.getKey() + ""String_Node_Str""+ currentTime);
          }
        }
      }
    }
  }
  _scheduleRefire();
}"
72680,"/** 
 * Initialize the actor.
 * @exception IllegalActionException If the superclass throws it.
 */
@Override public void initialize() throws IllegalActionException {
  super.initialize();
  _nextFireTime=null;
  _afdxVLinksQueue=new HashMap();
  _virtualLinkTable=new HashMap();
  _lastEmissionTable=new HashMap();
  _afdxSchedMuxsQueue=new HashMap();
  _afdxVLinksQueue.clear();
  _virtualLinkTable.clear();
  _afdxSchedMuxsQueue.clear();
  _lastEmissionTable.clear();
}","/** 
 * Initialize the actor.
 * @exception IllegalActionException If the superclass throws it.
 */
@Override public void initialize() throws IllegalActionException {
  super.initialize();
  _nextFireTime=null;
  _afdxVLinksQueue=new LinkedHashMap();
  _virtualLinkTable=new HashMap();
  _lastEmissionTable=new HashMap();
  _afdxSchedMuxsQueue=new HashMap();
  _afdxVLinksQueue.clear();
  _virtualLinkTable.clear();
  _afdxSchedMuxsQueue.clear();
  _lastEmissionTable.clear();
}"
72681,"/** 
 * Reset the communication aspect and the receiver that we delegate to.
 */
@Override public void clear() throws IllegalActionException {
  communicationAspect.reset();
  _receiver.clear();
}","/** 
 * Reset the communication aspect and the receiver that we delegate to.
 */
@Override public void clear() throws IllegalActionException {
  communicationAspect.reset();
}"
72682,"/** 
 * Return a String representation of the DateToken. The string is surrounded by double-quotes; without them, the Ptolemy expression parser fails to parse it. <p>Unfortunately, the Java Date class has a fatal flaw in that Date.toString() does not return the value of the number of ms., so we use a format that includes the number of ms.</p>
 * @return A String representation of the DateToken.
 */
@Override public String toString(){
  if (isNil()) {
    return _NIL;
  }
  Calendar c=getCalendarInstance();
  _simpleDateFormat.setTimeZone(_timeZone);
  String timeString=_simpleDateFormat.format(c.getTime());
  return ""String_Node_Str"" + timeString.substring(0,timeString.length() - 9) + String.format(""String_Node_Str"",getMicrosecond())+ String.format(""String_Node_Str"",getNanosecond())+ timeString.substring(timeString.length() - 9)+ ""String_Node_Str"";
}","/** 
 * Return a String representation of the DateToken. The string is surrounded by double-quotes; without them, the Ptolemy expression parser fails to parse it. <p>Unfortunately, the Java Date class has a fatal flaw in that Date.toString() does not return the value of the number of ms., so we use a format that includes the number of ms.</p>
 * @return A String representation of the DateToken.
 */
@Override public String toString(){
  if (isNil()) {
    return _NIL;
  }
  Calendar c=getCalendarInstance();
  _simpleDateFormat.setTimeZone(_timeZone);
  String timeString=_simpleDateFormat.format(c.getTime());
  String beforeTimeZone=timeString.substring(0,timeString.lastIndexOf(""String_Node_Str""));
  beforeTimeZone=beforeTimeZone.substring(0,beforeTimeZone.lastIndexOf(""String_Node_Str""));
  String remainder=timeString.substring(beforeTimeZone.length());
  return ""String_Node_Str"" + beforeTimeZone + String.format(""String_Node_Str"",getMicrosecond())+ String.format(""String_Node_Str"",getNanosecond())+ remainder+ ""String_Node_Str"";
}"
72683,"/** 
 * Clone the object into the specified workspace.
 * @param workspace The workspace for the new object.
 * @return A new NamedObj.
 * @exception CloneNotSupportedException If any of the attributescannot be cloned.
 */
@Override public Object clone(Workspace workspace) throws CloneNotSupportedException {
  ExceptionEmailer newObject=(ExceptionEmailer)super.clone(workspace);
  try {
    _newline=new Parameter(newObject,""String_Node_Str"");
    _newline.setExpression(""String_Node_Str"");
  }
 catch (  NameDuplicationException e) {
  }
catch (  IllegalActionException e2) {
  }
  newObject._password=null;
  newObject._props=null;
  return newObject;
}","/** 
 * Clone the object into the specified workspace.
 * @param workspace The workspace for the new object.
 * @return A new NamedObj.
 * @exception CloneNotSupportedException If any of the attributescannot be cloned.
 */
@Override public Object clone(Workspace workspace) throws CloneNotSupportedException {
  ExceptionEmailer newObject=(ExceptionEmailer)super.clone(workspace);
  newObject._newline=(Parameter)newObject.getAttribute(""String_Node_Str"");
  newObject._newline.setExpression(""String_Node_Str"");
  newObject._password=null;
  newObject._props=null;
  return newObject;
}"
72684,"/** 
 * Return true if this receiver has status known, that is, this receiver either is either known to have a token or known to not to have a token.
 * @return True if this receiver has status known.
 */
@Override public boolean isKnown(){
  return _known;
}","/** 
 * Return true if this receiver has status known, that is, this receiver either is either known to have a token or known to not to have a token.
 * @return True if this receiver has status known.
 */
@Override public boolean isKnown(){
  IOPort container=getContainer();
  if (container != null && container.sourcePortList().size() == 0 && container.insideSourcePortList().size() == 0) {
    return true;
  }
  return _known;
}"
72685,"/** 
 * Reset the receiver by deleting any contained tokens and setting the status of this receiver to unknown.  This is called by the , normally in its initialize() and postfire() methods.
 */
@Override public void reset(){
  _token=null;
  _known=false;
}","/** 
 * Reset the receiver by deleting any contained tokens and setting the status of this receiver to unknown, unless the containing port has no sources, in which case set to known and absent.  This is called by the , normally in its initialize() and postfire() methods.
 */
@Override public void reset(){
  _token=null;
  _known=false;
}"
72686,"/** 
 * Construct an algebraic loop solver.
 * @param variableNames Names of each break variable.
 * @param tolerance Tolerance for each variable.
 * @param maxIterations Maximum number of iterations.
 */
public NewtonRaphson(String[] variableNames,double[] tolerance,int maxIterations) throws IllegalActionException {
  super(variableNames,tolerance,maxIterations);
  _g=new double[_nVars];
  _deltaX=new double[tolerance.length];
  for (int i=0; i < tolerance.length; i++) {
    _deltaX[i]=1E-5;
  }
}","/** 
 * Construct an algebraic loop solver.
 * @param variableNames Names of each break variable.
 * @param tolerance Tolerance for each variable.
 * @param maxIterations Maximum number of iterations.
 */
public NewtonRaphson(String[] variableNames,double[] tolerance,int maxIterations) throws IllegalActionException {
  super(variableNames,tolerance,maxIterations);
  _f=new double[_nVars];
  _deltaX=new double[tolerance.length];
  for (int i=0; i < tolerance.length; i++) {
    _deltaX[i]=1E-5;
  }
}"
72687,"/** 
 * Return the new iterate of a Newton step. 
 * @param x The best known iterate.
 * @param g The function value g(x).
 * @return The new guess for the solution.
 * @exception IllegalActionException If the solver fails to find a solution.
 */
protected double[] _newtonStep(final double[] x,final double[] g) throws IllegalActionException {
  final int n=x.length;
  double[] xNew=new double[n];
  double[] gNew=new double[n];
  System.arraycopy(x,0,xNew,0,n);
  double[][] J=new double[n][n];
  for (int i=0; i < n; i++) {
    final double xOri=xNew[i];
    xNew[i]+=_deltaX[i];
    _evaluateLoopFunction(xNew,gNew);
    for (int k=0; k < n; k++) {
      J[i][k]=(gNew[k] - g[k]) / _deltaX[i];
    }
    xNew[i]=xOri;
  }
  final double det=DoubleMatrixMath.determinant(J);
  if (Math.abs(det) < 1E-5) {
    StringBuffer message=new StringBuffer();
    message.append(""String_Node_Str"");
    message.append(""String_Node_Str"");
    for (    String name : _variableNames) {
      message.append(""String_Node_Str"");
      message.append(name);
      message.append(""String_Node_Str"");
    }
    message.append(""String_Node_Str"");
    message.append(DoubleMatrixMath.toString(J));
    message.append(""String_Node_Str"");
    message.append(""String_Node_Str"");
    message.append(det);
    throw new IllegalActionException(message.toString());
  }
  if (n == 1) {
    final double d=-g[0] / J[0][0];
    xNew[0]=x[0] + d;
  }
 else {
    final double[] d=_gaussElimination(J,g);
    for (int i=0; i < n; i++)     xNew[i]=x[i] - d[i];
  }
  return xNew;
}","/** 
 * Return the new iterate of a Newton step. 
 * @param x The best known iterate.
 * @param f The function value f(x)=g(x)-x.
 * @return The new guess for the solution f(x) = 0.
 * @exception IllegalActionException If the solver fails to find a solution.
 */
protected double[] _newtonStep(final double[] x,final double[] f) throws IllegalActionException {
  final int n=x.length;
  double[] xNew=new double[n];
  double[] fNew=new double[n];
  System.arraycopy(x,0,xNew,0,n);
  double[][] J=new double[n][n];
  for (int i=0; i < n; i++) {
    final double xOri=xNew[i];
    xNew[i]+=_deltaX[i];
    _residual(xNew,fNew);
    for (int k=0; k < n; k++) {
      J[i][k]=(fNew[k] - f[k]) / _deltaX[i];
    }
    xNew[i]=xOri;
  }
  final double det=DoubleMatrixMath.determinant(J);
  if (Math.abs(det) < 1E-5) {
    StringBuffer message=new StringBuffer();
    message.append(""String_Node_Str"");
    message.append(""String_Node_Str"");
    for (    String name : _variableNames) {
      message.append(""String_Node_Str"");
      message.append(name);
      message.append(""String_Node_Str"");
    }
    message.append(""String_Node_Str"");
    message.append(DoubleMatrixMath.toString(J));
    message.append(""String_Node_Str"");
    message.append(""String_Node_Str"");
    message.append(det);
    throw new IllegalActionException(message.toString());
  }
  if (n == 1) {
    final double d=-f[0] / J[0][0];
    xNew[0]=x[0] + d;
  }
 else {
    final double[] d=_gaussElimination(J,f);
    for (int i=0; i < n; i++)     xNew[i]=x[i] - d[i];
  }
  return xNew;
}"
72688,"/** 
 * The objective and constraints function evaluation method used in COBYLA2 minimization.
 * @param n Number of variables.
 * @param m Number of constraints.
 * @param x Variable values to be employed in function and constraints calculation.
 * @param con Calculated function values of the constraints.
 * @param terminate A boolean array that provides the terminate state. Only the first element of the array is read
 * @return Calculated objective function value.
 * @throws IllegalActionException 
 */
double Compute(int n,int m,double[] x,double[] con,boolean[] terminate) throws IllegalActionException ;","/** 
 * The objective and constraints function evaluation method used in COBYLA2 minimization.
 * @param n Number of variables.
 * @param m Number of constraints.
 * @param x Variable values to be employed in function and constraints calculation.
 * @param con Calculated function values of the constraints.
 * @param terminate A boolean array that provides the terminate state. Only the first element of the array is read
 * @return Calculated objective function value.
 * @exception IllegalActionException 
 */
double Compute(int n,int m,double[] x,double[] con,boolean[] terminate) throws IllegalActionException ;"
72689,"/** 
 * Minimizes the objective function F with respect to a set of inequality constraints CON, and returns the optimal variable array. F and CON may be non-linear, and should preferably be smooth.
 * @param calcfc Interface implementation for calculating objective function and constraints.
 * @param n Number of variables.
 * @param m Number of constraints.
 * @param x On input initial values of the variables (zero-based array). On outputoptimal values of the variables obtained in the COBYLA minimization.
 * @param rhobeg Initial size of the simplex.
 * @param rhoend Final value of the simplex.
 * @param iprint Print level, 0 &lt;= iprint &lt;= 3, where 0 provides no output and3 provides full output to the console.
 * @param maxfun Maximum number of function evaluations before terminating.
 * @return Exit status of the COBYLA2 optimization.
 * @throws IllegalActionException 
 */
public static CobylaExitStatus FindMinimum(final Calcfc calcfc,int n,int m,double[] x,double rhobeg,double rhoend,int iprint,int maxfun,boolean[] terminate) throws IllegalActionException {
  int mpp=m + 2;
  double[] iox=new double[n + 1];
  System.arraycopy(x,0,iox,1,n);
  Calcfc fcalcfc=new Calcfc(){
    /** 
 * @param n the value of n
 * @param m the value of m
 * @param x the value of x
 * @param con the value of con
 * @return the double
 */
    @Override public double Compute(    int n,    int m,    double[] x,    double[] con,    boolean[] terminate) throws IllegalActionException {
      double[] ix=new double[n];
      System.arraycopy(x,1,ix,0,n);
      double[] ocon=new double[m];
      double f=calcfc.Compute(n,m,ix,ocon,terminate);
      System.arraycopy(ocon,0,con,1,m);
      return f;
    }
  }
;
  CobylaExitStatus status=cobylb(fcalcfc,n,m,mpp,iox,rhobeg,rhoend,iprint,maxfun,terminate);
  System.arraycopy(iox,1,x,0,n);
  return status;
}","/** 
 * Minimizes the objective function F with respect to a set of inequality constraints CON, and returns the optimal variable array. F and CON may be non-linear, and should preferably be smooth.
 * @param calcfc Interface implementation for calculating objective function and constraints.
 * @param n Number of variables.
 * @param m Number of constraints.
 * @param x On input initial values of the variables (zero-based array). On outputoptimal values of the variables obtained in the COBYLA minimization.
 * @param rhobeg Initial size of the simplex.
 * @param rhoend Final value of the simplex.
 * @param iprint Print level, 0 &lt;= iprint &lt;= 3, where 0 provides no output and3 provides full output to the console.
 * @param maxfun Maximum number of function evaluations before terminating.
 * @return Exit status of the COBYLA2 optimization.
 * @exception IllegalActionException 
 */
public static CobylaExitStatus FindMinimum(final Calcfc calcfc,int n,int m,double[] x,double rhobeg,double rhoend,int iprint,int maxfun,boolean[] terminate) throws IllegalActionException {
  int mpp=m + 2;
  double[] iox=new double[n + 1];
  System.arraycopy(x,0,iox,1,n);
  Calcfc fcalcfc=new Calcfc(){
    /** 
 * @param n the value of n
 * @param m the value of m
 * @param x the value of x
 * @param con the value of con
 * @return the double
 */
    @Override public double Compute(    int n,    int m,    double[] x,    double[] con,    boolean[] terminate) throws IllegalActionException {
      double[] ix=new double[n];
      System.arraycopy(x,1,ix,0,n);
      double[] ocon=new double[m];
      double f=calcfc.Compute(n,m,ix,ocon,terminate);
      System.arraycopy(ocon,0,con,1,m);
      return f;
    }
  }
;
  CobylaExitStatus status=cobylb(fcalcfc,n,m,mpp,iox,rhobeg,rhoend,iprint,maxfun,terminate);
  System.arraycopy(iox,1,x,0,n);
  return status;
}"
72690,"/** 
 * Perform the collection operation.
 * @param handler The processor object to return results to.
 * @exception CollectionAbortedException The collection operation was aborted part way through.
 * @throws IllegalActionException 
 */
void collect(ResultHandler<T> handler) throws CollectionAbortedException, IllegalActionException ;","/** 
 * Perform the collection operation.
 * @param handler The processor object to return results to.
 * @exception CollectionAbortedException The collection operation was aborted part way through.
 * @exception IllegalActionException 
 */
void collect(ResultHandler<T> handler) throws CollectionAbortedException, IllegalActionException ;"
72691,"/** 
 * Convert a method that implements the Collector<> class with a standard Iterable<>, by collecting the results in a list, and returning an iterator to that list.
 * @throws IllegalActionException 
 */
public YieldAdapterIterable<T> adapt(Collector<T> client) throws IllegalActionException {
  final ArrayList<T> results=new ArrayList<T>();
  try {
    client.collect(new ResultHandler<T>(){
      public void handleResult(      T value){
        results.add(value);
      }
    }
);
  }
 catch (  CollectionAbortedException e) {
  }
  return new YieldAdapterIterable<T>(){
    public YieldAdapterIterator<T> iterator(){
      final Iterator<T> iterator=results.iterator();
      return new YieldAdapterIterator<T>(){
        public boolean hasNext(){
          return iterator.hasNext();
        }
        public T next(){
          return iterator.next();
        }
        public void remove(){
          iterator.remove();
        }
        public void dispose(){
        }
      }
;
    }
  }
;
}","/** 
 * Convert a method that implements the Collector<> class with a standard Iterable<>, by collecting the results in a list, and returning an iterator to that list.
 * @exception IllegalActionException 
 */
public YieldAdapterIterable<T> adapt(Collector<T> client) throws IllegalActionException {
  final ArrayList<T> results=new ArrayList<T>();
  try {
    client.collect(new ResultHandler<T>(){
      public void handleResult(      T value){
        results.add(value);
      }
    }
);
  }
 catch (  CollectionAbortedException e) {
  }
  return new YieldAdapterIterable<T>(){
    public YieldAdapterIterator<T> iterator(){
      final Iterator<T> iterator=results.iterator();
      return new YieldAdapterIterator<T>(){
        public boolean hasNext(){
          return iterator.hasNext();
        }
        public T next(){
          return iterator.next();
        }
        public void remove(){
          iterator.remove();
        }
        public void dispose(){
        }
      }
;
    }
  }
;
}"
72692,"/** 
 * Create receivers and invoke the preinitialize() method of the local director. If this actor is not opaque, throw an exception.  This method also resets the protected variable _stopRequested to false, so if a derived class overrides this method, then it should also do that.  This method is read-synchronized on the workspace, so the preinitialize() method of the director need not be, assuming it is only called from here.
 * @exception IllegalActionException If there is no director, orif the director's preinitialize() method throws it, or if this actor is not opaque.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  try {
    _generatingCode=true;
    if (_modelChanged()) {
      super.preinitialize();
      executeChangeRequests();
      _generateCode();
    }
    String className=CodeGeneratorAdapter.generateName(this);
    URL url=_codeGenerator.codeDirectory.asFile().toURI().toURL();
    if (((BooleanToken)_codeGenerator.generateInSubdirectory.getToken()).booleanValue()) {
      className=className + ""String_Node_Str"" + className;
      url=_codeGenerator.codeDirectory.asFile().getParentFile().toURI().toURL();
    }
    if (!url.getPath().endsWith(""String_Node_Str"")) {
      url=new URL(url.toString() + ""String_Node_Str"");
    }
    URL[] urls=new URL[]{url};
    URLClassLoader classLoader=null;
    Class<?> classInstance=null;
    try {
      classLoader=new URLClassLoader(urls);
      classInstance=classLoader.loadClass(className);
    }
 catch (    ClassNotFoundException ex) {
      _generateCode();
      try {
        classInstance=classLoader.loadClass(className);
      }
 catch (      ClassNotFoundException ex2) {
        ex2.printStackTrace();
        throw new ClassNotFoundException(""String_Node_Str"" + className + ""String_Node_Str""+ url+ ""String_Node_Str""+ java.util.Arrays.deepToString(classLoader.getURLs())+ ""String_Node_Str""+ ex2);
      }
    }
 finally {
      if (classLoader != null) {
        try {
          classLoader.close();
        }
 catch (        IOException ex) {
          throw new IllegalActionException(this,ex,""String_Node_Str"" + (url == null ? ""String_Node_Str"" : url) + ""String_Node_Str"");
        }
      }
    }
    _objectWrapper=classInstance.newInstance();
    Method[] methods=classInstance.getMethods();
    Method initializeMethod=null;
    for (    Method method : methods) {
      String name=method.getName();
      if (name.equals(""String_Node_Str"")) {
        _fireMethod=method;
      }
      if (name.equals(""String_Node_Str"")) {
        initializeMethod=method;
      }
    }
    if (_fireMethod == null) {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
    }
    if (initializeMethod == null) {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
    }
    initializeMethod.invoke(_objectWrapper,(Object[])null);
    if (_debugging) {
      _debug(""String_Node_Str"");
    }
    recompileThisLevel.setToken(new BooleanToken(false));
    recompileHierarchy.setToken(new BooleanToken(false));
    _compiled=true;
  }
 catch (  Throwable throwable) {
    _objectWrapper=null;
    _fireMethod=null;
    throw new IllegalActionException(this,throwable,""String_Node_Str"");
  }
 finally {
    _generatingCode=false;
  }
}","/** 
 * Create receivers and invoke the preinitialize() method of the local director. If this actor is not opaque, throw an exception.  This method also resets the protected variable _stopRequested to false, so if a derived class overrides this method, then it should also do that.  This method is read-synchronized on the workspace, so the preinitialize() method of the director need not be, assuming it is only called from here.
 * @exception IllegalActionException If there is no director, orif the director's preinitialize() method throws it, or if this actor is not opaque.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  try {
    _generatingCode=true;
    if (_modelChanged()) {
      super.preinitialize();
      executeChangeRequests();
      _generateCode();
    }
    String className=CodeGeneratorAdapter.generateName(this);
    URL url=_codeGenerator.codeDirectory.asFile().toURI().toURL();
    if (((BooleanToken)_codeGenerator.generateInSubdirectory.getToken()).booleanValue()) {
      className=className + ""String_Node_Str"" + className;
      url=_codeGenerator.codeDirectory.asFile().getParentFile().toURI().toURL();
    }
    if (!url.getPath().endsWith(""String_Node_Str"")) {
      url=new URL(url.toString() + ""String_Node_Str"");
    }
    URL[] urls=new URL[]{url};
    URLClassLoader classLoader=null;
    Class<?> classInstance=null;
    try {
      try {
        classLoader=new URLClassLoader(urls);
        classInstance=classLoader.loadClass(className);
      }
 catch (      ClassNotFoundException ex) {
        _generateCode();
        try {
          classInstance=classLoader.loadClass(className);
        }
 catch (        ClassNotFoundException ex2) {
          ex2.printStackTrace();
          throw new ClassNotFoundException(""String_Node_Str"" + className + ""String_Node_Str""+ url+ ""String_Node_Str""+ java.util.Arrays.deepToString(classLoader.getURLs())+ ""String_Node_Str""+ ex2);
        }
      }
      _objectWrapper=classInstance.newInstance();
      Method[] methods=classInstance.getMethods();
      Method initializeMethod=null;
      for (      Method method : methods) {
        String name=method.getName();
        if (name.equals(""String_Node_Str"")) {
          _fireMethod=method;
        }
        if (name.equals(""String_Node_Str"")) {
          initializeMethod=method;
        }
      }
      if (_fireMethod == null) {
        throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
      }
      if (initializeMethod == null) {
        throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
      }
      initializeMethod.invoke(_objectWrapper,(Object[])null);
      if (_debugging) {
        _debug(""String_Node_Str"");
      }
    }
  finally {
      if (classLoader != null) {
        try {
          classLoader.close();
        }
 catch (        IOException ex) {
          throw new IllegalActionException(this,ex,""String_Node_Str"" + (url == null ? ""String_Node_Str"" : url) + ""String_Node_Str"");
        }
      }
    }
    recompileThisLevel.setToken(new BooleanToken(false));
    recompileHierarchy.setToken(new BooleanToken(false));
    _compiled=true;
  }
 catch (  Throwable throwable) {
    _objectWrapper=null;
    _fireMethod=null;
    throw new IllegalActionException(this,throwable,""String_Node_Str"");
  }
 finally {
    _generatingCode=false;
  }
}"
72693,"/** 
 * If <i>executeEmbeddedCode</i> is true, then generate and compile the code (if necessary), and then execute the initialize() method of the generated code. Otherwise, delegate to the superclass, which initializes this actor like an ordinary composite actor.
 * @exception IllegalActionException If there is no director, orif the director's initialize() method throws it, or if the actor is not opaque.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  boolean invoked=((BooleanToken)executeEmbeddedCode.getToken()).booleanValue();
  if (invoked) {
    if (_generatedCodeVersion != _workspace.getVersion()) {
      _updateSanitizedActorName();
      if (_buildSharedObjectFile()) {
        if (_loadedCodeVersion != -1) {
          _updateSanitizedActorName();
        }
        String generatorPackageString=generatorPackage.getExpression();
        if (generatorPackageString.equals(""String_Node_Str"")) {
          _generateAndCompileJNICode();
        }
        _generateAndCompileEmbeddedCode();
        _generatedCodeVersion=_workspace.getVersion();
      }
      if (_generatedCodeVersion == -1) {
        _generatedCodeVersion=_workspace.getVersion();
      }
      if (_loadedCodeVersion != _generatedCodeVersion) {
        String className=_sanitizedActorName;
        URL url=null;
        URLClassLoader classLoader=null;
        Class<?> classInstance=null;
        try {
          url=codeDirectory.asFile().toURI().toURL();
          URL[] urls=new URL[]{url};
          classLoader=new URLClassLoader(urls);
          classInstance=classLoader.loadClass(className);
        }
 catch (        ClassNotFoundException ex) {
          throw new IllegalActionException(this,ex,""String_Node_Str"" + url + ""String_Node_Str""+ className+ ""String_Node_Str""+ ""String_Node_Str"");
        }
catch (        MalformedURLException ex) {
          throw new IllegalActionException(this,ex,""String_Node_Str"" + url + ""String_Node_Str""+ className+ ""String_Node_Str"");
        }
catch (        UnsupportedClassVersionError ex) {
          throw new IllegalActionException(this,ex,""String_Node_Str"" + className + ""String_Node_Str""+ url+ ""String_Node_Str""+ className+ ""String_Node_Str""+ url+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
        }
catch (        Throwable ex) {
          throw new IllegalActionException(this,ex,""String_Node_Str"" + className + ""String_Node_Str""+ url+ ""String_Node_Str"");
        }
 finally {
          if (classLoader != null) {
            try {
              classLoader.close();
            }
 catch (            IOException ex) {
              throw new IllegalActionException(this,ex,""String_Node_Str"" + (url == null ? ""String_Node_Str"" : url) + ""String_Node_Str"");
            }
          }
        }
        try {
          _objectWrapper=classInstance.newInstance();
        }
 catch (        Throwable throwable) {
          throw new IllegalActionException(this,throwable,""String_Node_Str"");
        }
        Method[] methods=classInstance.getMethods();
        for (        Method method : methods) {
          String name=method.getName();
          if (name.equals(""String_Node_Str"")) {
            _fireMethod=method;
          }
 else           if (name.equals(""String_Node_Str"")) {
            _initializeMethod=method;
          }
 else           if (name.equals(""String_Node_Str"")) {
            _wrapupMethod=method;
          }
        }
        if (_fireMethod == null) {
          throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
        }
        if (_initializeMethod == null) {
          throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
        }
        if (_wrapupMethod == null) {
          throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
        }
        _loadedCodeVersion=_workspace.getVersion();
      }
    }
    try {
      _initializeMethod.invoke(_objectWrapper,(Object[])null);
    }
 catch (    Throwable throwable) {
      System.out.println(""String_Node_Str"" + _initializeMethod + ""String_Node_Str""+ throwable.getCause());
      throw new IllegalActionException(this,throwable,""String_Node_Str"" + _initializeMethod + ""String_Node_Str""+ ""String_Node_Str"");
    }
  }
}","/** 
 * If <i>executeEmbeddedCode</i> is true, then generate and compile the code (if necessary), and then execute the initialize() method of the generated code. Otherwise, delegate to the superclass, which initializes this actor like an ordinary composite actor.
 * @exception IllegalActionException If there is no director, orif the director's initialize() method throws it, or if the actor is not opaque.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  boolean invoked=((BooleanToken)executeEmbeddedCode.getToken()).booleanValue();
  if (invoked) {
    if (_generatedCodeVersion != _workspace.getVersion()) {
      _updateSanitizedActorName();
      if (_buildSharedObjectFile()) {
        if (_loadedCodeVersion != -1) {
          _updateSanitizedActorName();
        }
        String generatorPackageString=generatorPackage.getExpression();
        if (generatorPackageString.equals(""String_Node_Str"")) {
          _generateAndCompileJNICode();
        }
        _generateAndCompileEmbeddedCode();
        _generatedCodeVersion=_workspace.getVersion();
      }
      if (_generatedCodeVersion == -1) {
        _generatedCodeVersion=_workspace.getVersion();
      }
      if (_loadedCodeVersion != _generatedCodeVersion) {
        String className=_sanitizedActorName;
        URL url=null;
        URLClassLoader classLoader=null;
        Class<?> classInstance=null;
        try {
          try {
            url=codeDirectory.asFile().toURI().toURL();
            URL[] urls=new URL[]{url};
            classLoader=new URLClassLoader(urls);
            classInstance=classLoader.loadClass(className);
          }
 catch (          ClassNotFoundException ex) {
            throw new IllegalActionException(this,ex,""String_Node_Str"" + url + ""String_Node_Str""+ className+ ""String_Node_Str""+ ""String_Node_Str"");
          }
catch (          MalformedURLException ex) {
            throw new IllegalActionException(this,ex,""String_Node_Str"" + url + ""String_Node_Str""+ className+ ""String_Node_Str"");
          }
catch (          UnsupportedClassVersionError ex) {
            throw new IllegalActionException(this,ex,""String_Node_Str"" + className + ""String_Node_Str""+ url+ ""String_Node_Str""+ className+ ""String_Node_Str""+ url+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
          }
catch (          Throwable ex) {
            throw new IllegalActionException(this,ex,""String_Node_Str"" + className + ""String_Node_Str""+ url+ ""String_Node_Str"");
          }
          try {
            _objectWrapper=classInstance.newInstance();
          }
 catch (          Throwable throwable) {
            throw new IllegalActionException(this,throwable,""String_Node_Str"");
          }
          Method[] methods=classInstance.getMethods();
          for (          Method method : methods) {
            String name=method.getName();
            if (name.equals(""String_Node_Str"")) {
              _fireMethod=method;
            }
 else             if (name.equals(""String_Node_Str"")) {
              _initializeMethod=method;
            }
 else             if (name.equals(""String_Node_Str"")) {
              _wrapupMethod=method;
            }
          }
          if (_fireMethod == null) {
            throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
          }
          if (_initializeMethod == null) {
            throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
          }
          if (_wrapupMethod == null) {
            throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
          }
          _loadedCodeVersion=_workspace.getVersion();
        }
  finally {
          if (classLoader != null) {
            try {
              classLoader.close();
            }
 catch (            IOException ex) {
              throw new IllegalActionException(this,ex,""String_Node_Str"" + (url == null ? ""String_Node_Str"" : url) + ""String_Node_Str"");
            }
          }
        }
      }
    }
    try {
      _initializeMethod.invoke(_objectWrapper,(Object[])null);
    }
 catch (    Throwable throwable) {
      System.out.println(""String_Node_Str"" + _initializeMethod + ""String_Node_Str""+ throwable.getCause());
      throw new IllegalActionException(this,throwable,""String_Node_Str"" + _initializeMethod + ""String_Node_Str""+ ""String_Node_Str"");
    }
  }
}"
72694,"/** 
 * Clone the actor into the specified workspace. This calls the base class and then sets the <code>iteration</code> public member to the parameters of the new actor.
 * @param workspace The workspace for the new object.
 * @return A new actor.
 * @exception CloneNotSupportedException If a derived class containsan attribute that cannot be cloned.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  Expression newObject=(Expression)super.clone(workspace);
  newObject._addPathCommand=null;
  newObject._iterationCount=1;
  newObject._previousPath=null;
  return newObject;
}","/** 
 * Clone the actor into the specified workspace. This calls the base class and then sets the <code>iteration</code> public member to the parameters of the new actor.
 * @param workspace The workspace for the new object.
 * @return A new actor.
 * @exception CloneNotSupportedException If a derived class containsan attribute that cannot be cloned.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  Expression newObject=(Expression)super.clone(workspace);
  newObject._addPathCommand=null;
  newObject._iterationCount=1;
  newObject._previousPath=null;
  newObject._inputTokens=new HashMap<String,Token>();
  return newObject;
}"
72695,"/** 
 * Evaluate the expression and send its result to the output.
 * @exception IllegalActionException If the evaluation of the expressiontriggers it, or the evaluation yields a null result, or the evaluation yields an incompatible type, or if there is no director.
 */
public void fire() throws IllegalActionException {
  super.fire();
  Director director=getDirector();
  if (director == null) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
synchronized (Engine.semaphore) {
    matlabEngine.evalString(engine,""String_Node_Str"");
    if (_addPathCommand != null) {
      matlabEngine.evalString(engine,_addPathCommand);
    }
    try {
      matlabEngine.put(engine,""String_Node_Str"",new DoubleToken(director.getModelTime().getDoubleValue()));
    }
 catch (    IllegalActionException ex) {
      throw new IllegalActionException(this,ex,""String_Node_Str"" + ""String_Node_Str"" + new DoubleToken(director.getModelTime().getDoubleValue()));
    }
    try {
      matlabEngine.put(engine,""String_Node_Str"",_iteration.getToken());
    }
 catch (    IllegalActionException ex) {
      throw new IllegalActionException(this,ex,""String_Node_Str"" + ""String_Node_Str"" + _iteration.getToken());
    }
    Iterator inputPorts=inputPortList().iterator();
    while (inputPorts.hasNext()) {
      IOPort port=(IOPort)inputPorts.next();
      matlabEngine.put(engine,port.getName(),port.get(0));
    }
    matlabEngine.evalString(engine,expression.stringValue());
    Iterator outputPorts=outputPortList().iterator();
    while (outputPorts.hasNext()) {
      IOPort port=(IOPort)outputPorts.next();
      if (port.isOutsideConnected()) {
        port.send(0,matlabEngine.get(engine,port.getName(),_dataParameters));
      }
    }
    if (_previousPath != null) {
      matlabEngine.put(engine,""String_Node_Str"",_previousPath);
      matlabEngine.evalString(engine,""String_Node_Str"");
    }
  }
}","/** 
 * Evaluate the expression and send its result to the output.
 * @exception IllegalActionException If the evaluation of the expressiontriggers it, or the evaluation yields a null result, or the evaluation yields an incompatible type, or if there is no director.
 */
public void fire() throws IllegalActionException {
  super.fire();
  Director director=getDirector();
  if (director == null) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  try {
    for (    TypedIOPort port : inputPortList()) {
      _inputTokens.put(port.getName(),port.get(0));
    }
synchronized (Engine.semaphore) {
      matlabEngine.evalString(engine,""String_Node_Str"");
      if (_addPathCommand != null) {
        matlabEngine.evalString(engine,_addPathCommand);
      }
      try {
        matlabEngine.put(engine,""String_Node_Str"",new DoubleToken(director.getModelTime().getDoubleValue()));
      }
 catch (      IllegalActionException ex) {
        throw new IllegalActionException(this,ex,""String_Node_Str"" + ""String_Node_Str"" + new DoubleToken(director.getModelTime().getDoubleValue()));
      }
      try {
        matlabEngine.put(engine,""String_Node_Str"",_iteration.getToken());
      }
 catch (      IllegalActionException ex) {
        throw new IllegalActionException(this,ex,""String_Node_Str"" + ""String_Node_Str"" + _iteration.getToken());
      }
      for (      Map.Entry<String,Token> entry : _inputTokens.entrySet()) {
        matlabEngine.put(engine,entry.getKey(),entry.getValue());
      }
      matlabEngine.evalString(engine,expression.stringValue());
      Iterator outputPorts=outputPortList().iterator();
      while (outputPorts.hasNext()) {
        IOPort port=(IOPort)outputPorts.next();
        if (port.isOutsideConnected()) {
          port.send(0,matlabEngine.get(engine,port.getName(),_dataParameters));
        }
      }
      if (_previousPath != null) {
        matlabEngine.put(engine,""String_Node_Str"",_previousPath);
        matlabEngine.evalString(engine,""String_Node_Str"");
      }
    }
  }
  finally {
    _inputTokens.clear();
  }
}"
72696,"/** 
 * Clone the actor into the specified workspace. This calls the base class and then sets the <code>iteration</code> public member to the parameters of the new actor.
 * @param workspace The workspace for the new object.
 * @return A new actor.
 * @exception CloneNotSupportedException If a derived class containsan attribute that cannot be cloned.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  Expression newObject=(Expression)super.clone(workspace);
  newObject._addPathCommand=null;
  newObject._iterationCount=1;
  try {
    newObject._iteration.setContainer(null);
    newObject._iteration=new Variable(this,""String_Node_Str"",new IntToken(1));
  }
 catch (  Throwable throwable) {
    throw new CloneNotSupportedException(""String_Node_Str"" + ""String_Node_Str"" + throwable);
  }
  newObject._previousPath=null;
  return newObject;
}","/** 
 * Clone the actor into the specified workspace. This calls the base class and then sets the <code>iteration</code> public member to the parameters of the new actor.
 * @param workspace The workspace for the new object.
 * @return A new actor.
 * @exception CloneNotSupportedException If a derived class containsan attribute that cannot be cloned.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  Expression newObject=(Expression)super.clone(workspace);
  newObject._addPathCommand=null;
  newObject._iterationCount=1;
  newObject._previousPath=null;
  return newObject;
}"
72697,"/** 
 * Initialize this actor to indicate that no input has yet been provided.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  _getInputPorts();
  _getOutputPorts();
  if (dx.size() != q.size()) {
    final String em=""String_Node_Str"" + this.getFullName() + LS+ ""String_Node_Str""+ dx.size()+ LS+ ""String_Node_Str""+ q.size();
    throw new IllegalActionException(this,em);
  }
  int dqSize=((ArrayToken)quantum.getToken()).length();
  int xIniSize=((ArrayToken)initialState.getToken()).length();
  if (dx.size() != dqSize) {
    final String em=""String_Node_Str"" + this.getFullName() + LS+ ""String_Node_Str""+ dx.size()+ LS+ ""String_Node_Str""+ dqSize;
    throw new IllegalActionException(this,em);
  }
  if (dx.size() != xIniSize) {
    final String em=""String_Node_Str"" + this.getFullName() + LS+ ""String_Node_Str""+ dx.size()+ LS+ ""String_Node_Str""+ xIniSize;
    throw new IllegalActionException(this,em);
  }
  dq=_getDoubleArray(quantum,dqSize);
  xIni=_getDoubleArray(initialState,xIniSize);
  t_min=null;
  previousStateUpdateTime=null;
  u=new Token[dx.size()];
  x=new double[dx.size()];
  slope=new double[dx.size()];
  previousSlope=new double[dx.size()];
  nextOutputValue=new double[dx.size()];
  previousOutputValue=new double[dx.size()];
  previousInput=new Token[dx.size()];
  inputReceived=new boolean[dx.size()];
  _firstFiring=new boolean[dx.size()];
  nextOutputTime=new Time[dx.size()];
  index_min=new ArrayList<Integer>();
  for (int i=0; i < dx.size(); i++) {
    nextOutputTime[i]=null;
    x[i]=xIni[i];
    nextOutputValue[i]=_quantize(x[i],dq[i]);
    previousOutputValue=nextOutputValue;
    previousInput[i]=null;
    inputReceived[i]=false;
    _firstFiring[i]=true;
  }
  getDirector().fireAtCurrentTime(this);
}","/** 
 * Initialize this actor to indicate that no input has yet been provided.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  _getInputPorts();
  _getOutputPorts();
  if (dx.size() != q.size()) {
    final String em=""String_Node_Str"" + this.getFullName() + LS+ ""String_Node_Str""+ dx.size()+ LS+ ""String_Node_Str""+ q.size();
    throw new IllegalActionException(this,em);
  }
  int dqSize=((ArrayToken)quantum.getToken()).length();
  int xIniSize=((ArrayToken)initialState.getToken()).length();
  if (dx.size() != dqSize) {
    final String em=""String_Node_Str"" + this.getFullName() + LS+ ""String_Node_Str""+ dx.size()+ LS+ ""String_Node_Str""+ dqSize;
    throw new IllegalActionException(this,em);
  }
  if (dx.size() != xIniSize) {
    final String em=""String_Node_Str"" + this.getFullName() + LS+ ""String_Node_Str""+ dx.size()+ LS+ ""String_Node_Str""+ xIniSize;
    throw new IllegalActionException(this,em);
  }
  dq=_getDoubleArray(quantum,dqSize);
  xIni=_getDoubleArray(initialState,xIniSize);
  t_min=null;
  previousStateUpdateTime=null;
  u=new Token[dx.size()];
  x=new double[dx.size()];
  slope=new double[dx.size()];
  previousSlope=new double[dx.size()];
  nextOutputValue=new double[dx.size()];
  previousOutputValue=new double[dx.size()];
  previousInput=new Token[dx.size()];
  inputReceived=new boolean[dx.size()];
  _firstFiring=new boolean[dx.size()];
  nextOutputTime=new Time[dx.size()];
  index_min=new ArrayList<Integer>();
  for (int i=0; i < dx.size(); i++) {
    nextOutputTime[i]=null;
    x[i]=xIni[i];
    nextOutputValue[i]=_quantize(x[i],dq[i]);
    previousOutputValue[i]=nextOutputValue[i];
    previousInput[i]=null;
    inputReceived[i]=false;
    _firstFiring[i]=true;
  }
  getDirector().fireAtCurrentTime(this);
}"
72698,"public Token convert(Token t) throws IllegalActionException {
  return StringToken.convert(t);
}","public Token convert(Token t) throws IllegalActionException {
  return DateToken.convert(t);
}"
72699,"/** 
 * Construct an algebraic loop solver.
 * @param tolerance Tolerance for each variable.
 * @param maxIterations Maximum number of iterations.
 */
public AlgebraicLoopSolver(double[] tolerance,int maxIterations){
  _tolerance=tolerance;
  _maxIterations=maxIterations;
  _converged=false;
  _iterationCount=0;
  if (_isNewtonRaphson) {
    _deltaX=new double[tolerance.length];
    for (int i=0; i < tolerance.length; i++) {
      _tolerance[i]=1E-5;
      _deltaX[i]=1E-5;
    }
  }
}","/** 
 * Construct an algebraic loop solver.
 * @param variableNames Names of each break variable.
 * @param tolerance Tolerance for each variable.
 * @param maxIterations Maximum number of iterations.
 */
public AlgebraicLoopSolver(String[] variableNames,double[] tolerance,int maxIterations){
  _variableNames=variableNames;
  _tolerance=tolerance;
  _maxIterations=maxIterations;
  _converged=false;
  _iterationCount=0;
  if (_isNewtonRaphson) {
    _deltaX=new double[tolerance.length];
    for (int i=0; i < tolerance.length; i++) {
      _tolerance[i]=1E-5;
      _deltaX[i]=1E-5;
    }
  }
}"
72700,"/** 
 * Return the new iterate of a Newton step. 
 * @param x The best known iterate.
 * @return The new guess for the solution.
 * @exception IllegalActionException If an actor violates themonotonicity constraints, or the prefire() or fire() method of the actor throws it.
 * @exception IllegalArgumentException If the solver fails to find a solution.
 */
protected double[] _newtonStep(double[] x) throws IllegalActionException {
  final int n=x.length;
  double[] xNew=new double[n];
  System.arraycopy(x,0,xNew,0,n);
  double[][] J=new double[n][n];
  final double[] g=_evaluateLoopFunction(x);
  for (int i=0; i < n; i++) {
    final double xOri=xNew[i];
    xNew[i]+=_deltaX[i];
    final double[] gNew=_evaluateLoopFunction(xNew);
    for (int k=0; k < n; k++)     J[i][k]=(gNew[k] - g[k]) / _deltaX[i];
    xNew[i]=xOri;
  }
  final double det=DoubleMatrixMath.determinant(J);
  if (Math.abs(det) < 1E-5) {
    final String LS=System.getProperty(""String_Node_Str"");
    String em=""String_Node_Str"" + LS + ""String_Node_Str""+ DoubleMatrixMath.toString(J)+ LS+ ""String_Node_Str""+ det;
    throw new IllegalArgumentException(em);
  }
  if (n == 1) {
    final double d=-g[0] / J[0][0];
    xNew[0]=x[0] + d;
  }
 else {
    final double[] d=gaussElimination(J,g);
    for (int i=0; i < n; i++)     xNew[i]=x[i] - d[i];
  }
  return xNew;
}","/** 
 * Return the new iterate of a Newton step. 
 * @param x The best known iterate.
 * @return The new guess for the solution.
 * @exception IllegalActionException If the solver fails to find a solution.
 */
protected double[] _newtonStep(double[] x) throws IllegalActionException {
  final int n=x.length;
  double[] xNew=new double[n];
  System.arraycopy(x,0,xNew,0,n);
  double[][] J=new double[n][n];
  final double[] g=_evaluateLoopFunction(x);
  for (int i=0; i < n; i++) {
    final double xOri=xNew[i];
    xNew[i]+=_deltaX[i];
    final double[] gNew=_evaluateLoopFunction(xNew);
    for (int k=0; k < n; k++) {
      J[i][k]=(gNew[k] - g[k]) / _deltaX[i];
    }
    xNew[i]=xOri;
  }
  final double det=DoubleMatrixMath.determinant(J);
  if (Math.abs(det) < 1E-5) {
    final String LS=System.getProperty(""String_Node_Str"");
    String em=""String_Node_Str"" + LS + ""String_Node_Str""+ LS;
    for (    String name : _variableNames) {
      em+=""String_Node_Str"" + name + LS;
    }
    em+=""String_Node_Str"" + DoubleMatrixMath.toString(J) + LS+ ""String_Node_Str""+ det;
    throw new IllegalActionException(em);
  }
  if (n == 1) {
    final double d=-g[0] / J[0][0];
    xNew[0]=x[0] + d;
  }
 else {
    final double[] d=gaussElimination(J,g);
    for (int i=0; i < n; i++)     xNew[i]=x[i] - d[i];
  }
  return xNew;
}"
72701,"/** 
 * Solve the algebraic loop using the specified array as the initial guess for the variables being solved for and replace the contents of the specified array with the solution that is found.  <p> This method iterates until a solution is found. If it does not converge within the maximum number of iterations, it throws an IllegalActionException. A method that calls solve(double[] xInitial) can then call converged() to check whether the exception is thrown because of lack of convergence.
 * @param x Array with the initial values of the variables, to be replacedwith the solution by this method.
 * @exception IllegalActionException If the prefire() or fire() methodof an actor throws it.
 * @exception IllegalArgumentException If the solver fails to find a solution.
 */
public void solve(double[] x) throws IllegalActionException {
  _iterationCount=0;
  do {
    double[] xNew;
    if (_isNewtonRaphson) {
      xNew=_newtonStep(x);
    }
 else {
      xNew=_evaluateLoopFunction(x);
    }
    _iterationCount++;
    _converged=true;
    for (int i=0; i < x.length; i++) {
      double diff=x[i] - xNew[i];
      if (diff > _tolerance[i] || -diff > _tolerance[i]) {
        _converged=false;
        break;
      }
    }
    System.arraycopy(xNew,0,x,0,x.length);
    if (!_converged && _iterationCount > _maxIterations) {
      throw new RuntimeException(""String_Node_Str"" + _maxIterations + ""String_Node_Str"");
    }
  }
 while (!_converged && !_stopRequested);
}","/** 
 * Solve the algebraic loop using the specified array as the initial guess for the variables being solved for and replace the contents of the specified array with the solution that is found.  <p> This method iterates until a solution is found. If it does not converge within the maximum number of iterations, it throws an IllegalActionException. A method that calls solve(double[] xInitial) can then call converged() to check whether the exception is thrown because of lack of convergence.
 * @param x Array with the initial values of the variables, to be replacedwith the solution by this method.
 * @exception IllegalActionException If the prefire() or fire() methodof an actor throws it.
 * @exception IllegalActionException If the solver fails to find a solution.
 */
public void solve(double[] x) throws IllegalActionException {
  _iterationCount=0;
  do {
    double[] xNew;
    if (_isNewtonRaphson) {
      xNew=_newtonStep(x);
    }
 else {
      xNew=_evaluateLoopFunction(x);
    }
    _iterationCount++;
    _converged=true;
    for (int i=0; i < x.length; i++) {
      final double diff=Math.abs(x[i] - xNew[i]);
      if (diff > Math.max(_tolerance[i],diff * _tolerance[i])) {
        _converged=false;
        break;
      }
    }
    System.arraycopy(xNew,0,x,0,x.length);
    if (!_converged && _iterationCount > _maxIterations) {
      throw new IllegalActionException(""String_Node_Str"" + _maxIterations + ""String_Node_Str"");
    }
  }
 while (!_converged && !_stopRequested);
  if (_debugging && _converged) {
    _debug(""String_Node_Str"" + _iterationCount + ""String_Node_Str"");
  }
}"
72702,"/** 
 * Prefire and fire actors in the order given by the scheduler until the iteration converges. An iteration converges when a pass through the schedule does not change the status of any receiver.
 * @exception IllegalActionException If an actor violates themonotonicity constraints, or the prefire() or fire() method of the actor throws it.
 */
public void fire() throws IllegalActionException {
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  int i=0;
  for (  IOPort port : _breakVariables) {
    Receiver[][] receivers=port.getReceivers();
    for (    Receiver[] receivers2 : receivers) {
      for (      Receiver receiver : receivers2) {
        Token t=receiver.get();
        if (t instanceof DoubleToken) {
          _x_n[i]=((DoubleToken)t).doubleValue();
          _tolerance[i]=_getErrorTolerance(port);
          i++;
        }
 else {
          throw new IllegalActionException(""String_Node_Str"" + t + ""String_Node_Str""+ port.getName(getContainer()));
        }
      }
    }
  }
  int maxIterationsValue=((IntToken)(maxIterations.getToken())).intValue();
  AlgebraicLoopSolver solver=new AlgebraicLoopSolver(_tolerance,maxIterationsValue);
  try {
    solver.solve(_x_n);
  }
 catch (  IllegalArgumentException e) {
    throw new IllegalActionException(this,e.getMessage());
  }
  if (_debugging) {
    _debug(this.getFullName() + ""String_Node_Str"" + solver.getIterationCount()+ ""String_Node_Str"");
  }
}","/** 
 * Prefire and fire actors in the order given by the scheduler until the iteration converges. An iteration converges when a pass through the schedule does not change the status of any receiver.
 * @exception IllegalActionException If an actor violates themonotonicity constraints, or the prefire() or fire() method of the actor throws it.
 */
public void fire() throws IllegalActionException {
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  int i=0;
  for (  IOPort port : _breakVariables) {
    Receiver[][] receivers=port.getReceivers();
    for (    Receiver[] receivers2 : receivers) {
      for (      Receiver receiver : receivers2) {
        Token t=receiver.get();
        if (t instanceof DoubleToken) {
          _x_n[i]=((DoubleToken)t).doubleValue();
          i++;
        }
 else {
          throw new IllegalActionException(""String_Node_Str"" + t + ""String_Node_Str""+ port.getName(getContainer()));
        }
      }
    }
  }
  _solver.solve(_x_n);
  if (_debugging) {
    _debug(this.getFullName() + ""String_Node_Str"" + _solver.getIterationCount()+ ""String_Node_Str"");
  }
}"
72703,"/** 
 * Return g(x). This function is called by the solver to evaluate the loop function.
 * @param x Input to the loop function.
 * @return Result of the loop function.
 * @exception IllegalActionException If the prefire() methodreturns false having previously returned true in the same iteration, or if the prefire() or fire() method of the actor throws it, or if evaluating the function yields a value that is not a double.
 */
protected double[] _evaluateLoopFunction(double[] x) throws IllegalActionException {
  int iRec=0;
  for (  IOPort port : _breakVariables) {
    Receiver[][] receivers=port.getReceivers();
    for (    Receiver[] receivers2 : receivers) {
      for (      Receiver receiver : receivers2) {
        DoubleToken t=new DoubleToken(x[iRec]);
        receiver.put(t);
        if (_debugging) {
          _debug(""String_Node_Str"" + receiver.getContainer().getName() + ""String_Node_Str""+ x[iRec]);
        }
        iRec++;
      }
    }
  }
  Schedule schedule=getScheduler().getSchedule();
  Iterator firingIterator=schedule.firingIterator();
  while (firingIterator.hasNext() && !_stopRequested) {
    Actor actor=((Firing)firingIterator.next()).getActor();
    if (!_actorsFinishedExecution.contains(actor)) {
      _fireActor(actor);
    }
 else {
      if (_debugging) {
        _debug(""String_Node_Str"" + actor.getFullName());
      }
      _clearAllDestinationReceivers(actor);
    }
  }
  double[] g=new double[_nVars];
  int i=0;
  for (  IOPort port : _breakVariables) {
    Receiver[][] receivers=port.getReceivers();
    for (    Receiver[] receivers2 : receivers) {
      for (      Receiver receiver : receivers2) {
        Token t=receiver.get();
        if (t instanceof DoubleToken) {
          g[i]=((DoubleToken)(t)).doubleValue();
          if (_debugging) {
            _debug(""String_Node_Str"" + receiver.getContainer().getName(getContainer()) + ""String_Node_Str""+ g[i]);
          }
          i++;
        }
 else {
          throw new IllegalActionException(""String_Node_Str"" + t + ""String_Node_Str""+ port.getName(getContainer()));
        }
      }
    }
  }
  return g;
}","/** 
 * Return g(x). This function is called by the solver to evaluate the loop function.
 * @param x Input to the loop function.
 * @return Result of the loop function.
 * @exception IllegalActionException If the prefire() methodreturns false having previously returned true in the same iteration, or if the prefire() or fire() method of the actor throws it, or if evaluating the function yields a value that is not a double.
 */
protected double[] _evaluateLoopFunction(double[] x) throws IllegalActionException {
  int iRec=0;
  for (  IOPort port : _breakVariables) {
    Receiver[][] receivers=port.getReceivers();
    for (    Receiver[] receivers2 : receivers) {
      for (      Receiver receiver : receivers2) {
        DoubleToken t=new DoubleToken(x[iRec]);
        receiver.put(t);
        if (_debugging) {
          _debug(""String_Node_Str"" + receiver.getContainer().getName() + ""String_Node_Str""+ x[iRec]);
        }
        iRec++;
      }
    }
  }
  Schedule schedule=getScheduler().getSchedule();
  Iterator firingIterator=schedule.firingIterator();
  while (firingIterator.hasNext() && !_stopRequested) {
    Actor actor=((Firing)firingIterator.next()).getActor();
    if (!_actorsFinishedExecution.contains(actor)) {
      _fireActor(actor);
    }
 else {
      if (_debugging) {
        _debug(""String_Node_Str"" + actor.getFullName());
      }
      _clearAllDestinationReceivers(actor);
    }
  }
  double[] g=new double[_nVars];
  int i=0;
  for (  IOPort port : _breakVariables) {
    Receiver[][] receivers=port.getReceivers();
    for (    Receiver[] receivers2 : receivers) {
      for (      Receiver receiver : receivers2) {
        Token t=receiver.get();
        if (t instanceof DoubleToken) {
          g[i]=((DoubleToken)(t)).doubleValue();
          if (_debugging) {
            _debug(""String_Node_Str"" + port.getName(getContainer()) + ""String_Node_Str""+ g[i]);
          }
          i++;
        }
 else {
          throw new IllegalActionException(""String_Node_Str"" + t + ""String_Node_Str""+ port.getName(getContainer()));
        }
      }
    }
  }
  return g;
}"
72704,"/** 
 * Initialize the director and all deeply contained actors by calling the super.initialize() method.
 * @exception IllegalActionException If the superclass throws it.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  _isNewtonRaphson=method.stringValue().equals(""String_Node_Str"");
  _breakVariables=new LinkedList<IOPort>();
  CompositeEntity container=(CompositeEntity)getContainer();
  @SuppressWarnings(""String_Node_Str"") List<Actor> actors=container.deepEntityList();
  _nVars=0;
  for (  Actor actor : actors) {
    @SuppressWarnings(""String_Node_Str"") List<IOPort> inputPorts=actor.inputPortList();
    for (    IOPort port : inputPorts) {
      if (port.defaultValue.getToken() != null) {
        CausalityInterface causality=actor.getCausalityInterface();
        List<IOPort> outputPorts=actor.outputPortList();
        for (        IOPort output : outputPorts) {
          causality.removeDependency(port,output);
        }
        _breakVariables.add(port);
        int numberOfReceivers=0;
        Receiver[][] receivers=port.getReceivers();
        for (        Receiver[] receivers2 : receivers) {
          numberOfReceivers+=receivers2.length;
        }
        if (_debugging) {
          _debug(""String_Node_Str"" + port.getName(getContainer()) + ""String_Node_Str""+ numberOfReceivers+ ""String_Node_Str"");
        }
        _nVars+=numberOfReceivers;
      }
    }
  }
  _x_n=new double[_nVars];
  _g_n=new double[_nVars];
  _tolerance=new double[_nVars];
}","/** 
 * Initialize the director and all deeply contained actors by calling the super.initialize() method.
 * @exception IllegalActionException If the superclass throws it.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  _isNewtonRaphson=method.stringValue().equals(""String_Node_Str"");
  _breakVariables=new LinkedList<IOPort>();
  CompositeEntity container=(CompositeEntity)getContainer();
  @SuppressWarnings(""String_Node_Str"") List<Actor> actors=container.deepEntityList();
  _nVars=0;
  for (  Actor actor : actors) {
    @SuppressWarnings(""String_Node_Str"") List<IOPort> inputPorts=actor.inputPortList();
    for (    IOPort port : inputPorts) {
      if (port.defaultValue.getToken() != null) {
        CausalityInterface causality=actor.getCausalityInterface();
        List<IOPort> outputPorts=actor.outputPortList();
        for (        IOPort output : outputPorts) {
          causality.removeDependency(port,output);
        }
        _breakVariables.add(port);
        int numberOfReceivers=0;
        Receiver[][] receivers=port.getReceivers();
        for (        Receiver[] receivers2 : receivers) {
          numberOfReceivers+=receivers2.length;
        }
        if (_debugging) {
          _debug(""String_Node_Str"" + port.getName(getContainer()) + ""String_Node_Str""+ numberOfReceivers+ ""String_Node_Str"");
        }
        _nVars+=numberOfReceivers;
      }
    }
  }
  _x_n=new double[_nVars];
  _g_n=new double[_nVars];
  _tolerance=new double[_nVars];
  final int maxIterationsValue=((IntToken)(maxIterations.getToken())).intValue();
  final String[] variableNames=new String[_nVars];
  int i=0;
  for (  IOPort port : _breakVariables) {
    Receiver[][] receivers=port.getReceivers();
    for (    Receiver[] receivers2 : receivers) {
      for (      Receiver receiver : receivers2) {
        Token t=receiver.get();
        final String name=port.getName(getContainer());
        if (t instanceof DoubleToken) {
          variableNames[i]=name;
          _tolerance[i]=_getErrorTolerance(port);
          i++;
        }
 else {
          throw new IllegalActionException(""String_Node_Str"" + t + ""String_Node_Str""+ name);
        }
      }
    }
  }
  _solver=new AlgebraicLoopSolver(variableNames,_tolerance,maxIterationsValue);
}"
72705,"/** 
 * Perform model exchange using the named Functional Mock-up Unit (FMU) file.
 * @param fmuFileName The pathname of the co-simulation .fmu file
 * @param endTime The ending time in seconds.
 * @param stepSize The step size in seconds.
 * @param enableLogging True if logging is enabled.
 * @param csvSeparator The character used for separating fields.Note that sometimes the decimal point in floats is converted to ','.
 * @param outputFileName The output file.
 * @exception Exception If there is a problem parsing the .fmu file or invokingthe methods in the shared library.
 */
public void simulate(String fmuFileName,double endTime,double stepSize,boolean enableLogging,char csvSeparator,String outputFileName) throws Exception {
  FMUDriver._setEnableLogging(enableLogging);
  FMIModelDescription fmiModelDescription=FMUFile.parseFMUFile(fmuFileName);
  String sharedLibrary=FMUFile.fmuSharedLibrary(fmiModelDescription);
  if (enableLogging) {
    System.out.println(""String_Node_Str"" + sharedLibrary);
  }
  _nativeLibrary=NativeLibrary.getInstance(sharedLibrary);
  _modelIdentifier=fmiModelDescription.modelIdentifier;
  new File(fmuFileName).toURI().toURL().toString();
  int numberOfStateEvents=0;
  int numberOfStepEvents=0;
  int numberOfSteps=0;
  int numberOfTimeEvents=0;
  byte loggingOn=enableLogging ? (byte)1 : (byte)0;
  _fmiVersion=Double.valueOf(fmiModelDescription.fmiVersion);
  Pointer fmiComponent=null;
  if (_fmiVersion < 1.5) {
    FMICallbackFunctions.ByValue callbacks=new FMICallbackFunctions.ByValue(new FMULibrary.FMULogger(fmiModelDescription),fmiModelDescription.getFMUAllocateMemory(),new FMULibrary.FMUFreeMemory(),new FMULibrary.FMUStepFinished());
    Function instantiateModelFunction;
    try {
      instantiateModelFunction=fmiModelDescription.getFmiFunction(""String_Node_Str"");
    }
 catch (    UnsatisfiedLinkError ex) {
      UnsatisfiedLinkError error=new UnsatisfiedLinkError(""String_Node_Str"" + _modelIdentifier + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      error.initCause(ex);
      throw error;
    }
    fmiComponent=(Pointer)instantiateModelFunction.invoke(Pointer.class,new Object[]{_modelIdentifier,fmiModelDescription.guid,callbacks,loggingOn});
  }
 else {
    FMICallbackFunctions callbacks=new FMICallbackFunctions(new FMULibrary.FMULogger(fmiModelDescription),new FMULibrary.FMUAllocateMemory(),new FMULibrary.FMUFreeMemory(),new FMULibrary.FMUStepFinished());
    Function fmiInstantiateFunction=fmiModelDescription.getFmiFunction(""String_Node_Str"");
    byte toBeVisible=0;
    int fmiType=1;
    if (fmiModelDescription.modelExchange) {
      fmiType=0;
    }
    fmiComponent=(Pointer)fmiInstantiateFunction.invoke(Pointer.class,new Object[]{_modelIdentifier,fmiType,fmiModelDescription.guid,fmiModelDescription.fmuResourceLocation,callbacks,toBeVisible,loggingOn});
  }
  if (fmiComponent.equals(Pointer.NULL)) {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (enableLogging) {
    System.out.println(""String_Node_Str"");
  }
  final int numberOfStates=fmiModelDescription.numberOfContinuousStates;
  final int numberOfEventIndicators=fmiModelDescription.numberOfEventIndicators;
  double[] states=new double[numberOfStates];
  double[] derivatives=new double[numberOfStates];
  double[] eventIndicators=null;
  double[] preEventIndicators=null;
  if (numberOfEventIndicators > 0) {
    eventIndicators=new double[numberOfEventIndicators];
    preEventIndicators=new double[numberOfEventIndicators];
  }
  double startTime=0.0;
  Function setTime=fmiModelDescription.getFmiFunction(""String_Node_Str"");
  invoke(setTime,new Object[]{fmiComponent,startTime},""String_Node_Str"" + startTime + ""String_Node_Str"");
  byte toleranceControlled=0;
  FMIEventInfo eventInfo=null;
  FMI20EventInfo eventInfo20=null;
  FMI20EventInfo.ByReference eventInfo20Reference=null;
  if (_fmiVersion < 1.5) {
    eventInfo=new FMIEventInfo();
    invoke(setTime,new Object[]{fmiComponent,startTime},""String_Node_Str"" + startTime + ""String_Node_Str"");
    invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent,toleranceControlled,startTime,eventInfo},""String_Node_Str"");
  }
 else {
    eventInfo20=new FMI20EventInfo();
    double relativeTolerance=1e-4;
    byte _toleranceControlled=(byte)0;
    invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent,_toleranceControlled,relativeTolerance,startTime,(byte)1,endTime},""String_Node_Str"");
    invoke(setTime,new Object[]{fmiComponent,startTime},""String_Node_Str"" + startTime + ""String_Node_Str"");
    invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent},""String_Node_Str"");
    invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent},""String_Node_Str"");
    eventInfo20.newDiscreteStatesNeeded=(byte)1;
    eventInfo20.terminateSimulation=(byte)0;
    System.out.println(eventInfo20.toString());
    while (eventInfo20.newDiscreteStatesNeeded == (byte)1 && !(eventInfo20.terminateSimulation == (byte)1)) {
      eventInfo20Reference=new FMI20EventInfo.ByReference(eventInfo20);
      System.out.println(eventInfo20Reference.toString());
      invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent,eventInfo20Reference},""String_Node_Str"");
    }
  }
  double time=startTime;
  if (eventInfo20.terminateSimulation != 0 || eventInfo20.terminateSimulation != 0) {
    System.out.println(""String_Node_Str"" + time);
    endTime=time;
  }
  if (eventInfo20.terminateSimulation != 1 || _fmiVersion < 1.5) {
    if (_fmiVersion > 1.5) {
      invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent},""String_Node_Str"");
    }
    PrintStream file=null;
    try {
      file=new PrintStream(outputFileName);
      if (enableLogging) {
        System.out.println(""String_Node_Str"");
      }
      OutputRow.outputRow(_nativeLibrary,fmiModelDescription,fmiComponent,startTime,file,csvSeparator,Boolean.TRUE);
      OutputRow.outputRow(_nativeLibrary,fmiModelDescription,fmiComponent,startTime,file,csvSeparator,Boolean.FALSE);
      Function completedIntegratorStep=fmiModelDescription.getFmiFunction(""String_Node_Str"");
      Function eventUpdate=null;
      if (_fmiVersion < 1.5) {
        eventUpdate=fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
      Function getContinuousStates=fmiModelDescription.getFmiFunction(""String_Node_Str"");
      Function getDerivatives=fmiModelDescription.getFmiFunction(""String_Node_Str"");
      Function getEventIndicators=fmiModelDescription.getFmiFunction(""String_Node_Str"");
      Function setContinuousStates=fmiModelDescription.getFmiFunction(""String_Node_Str"");
      boolean stateEvent=false;
      byte stepEvent=(byte)0;
      while (time < endTime) {
        invoke(getContinuousStates,new Object[]{fmiComponent,states,numberOfStates},""String_Node_Str"" + time + ""String_Node_Str"");
        invoke(getDerivatives,new Object[]{fmiComponent,derivatives,numberOfStates},""String_Node_Str"" + time + ""String_Node_Str"");
        double stepStartTime=time;
        time=Math.min(time + stepSize,endTime);
        boolean timeEvent=false;
        if (_fmiVersion < 1.5) {
          timeEvent=eventInfo.upcomingTimeEvent == 1 && eventInfo.nextEventTime < time;
        }
 else {
          timeEvent=eventInfo20.nextEventTimeDefined == 1 && eventInfo20.nextEventTime < time;
        }
        if (timeEvent) {
          time=eventInfo.nextEventTime;
        }
        double dt=time - stepStartTime;
        invoke(setTime,new Object[]{fmiComponent,time},""String_Node_Str"" + time + ""String_Node_Str"");
        for (int i=0; i < numberOfStates; i++) {
          states[i]+=dt * derivatives[i];
        }
        invoke(setContinuousStates,new Object[]{fmiComponent,states,numberOfStates},""String_Node_Str"" + time + ""String_Node_Str"");
        if (enableLogging) {
          System.out.println(""String_Node_Str"" + numberOfSteps + ""String_Node_Str""+ time);
        }
        if (_fmiVersion > 1.5) {
          for (int i=0; i < numberOfEventIndicators; i++) {
            preEventIndicators[i]=eventIndicators[i];
          }
          invoke(getEventIndicators,new Object[]{fmiComponent,eventIndicators,numberOfEventIndicators},""String_Node_Str"" + time + ""String_Node_Str"");
          stateEvent=false;
          for (int i=0; i < numberOfEventIndicators; i++) {
            stateEvent=stateEvent || (preEventIndicators[i] * eventIndicators[i] < 0);
          }
        }
        if (_fmiVersion < 1.5) {
          ByteByReference stepEventReference=new ByteByReference(stepEvent);
          invoke(completedIntegratorStep,new Object[]{fmiComponent,stepEventReference},""String_Node_Str"" + time + ""String_Node_Str"");
          for (int i=0; i < numberOfEventIndicators; i++) {
            preEventIndicators[i]=eventIndicators[i];
          }
        }
 else {
          ByteByReference stepEventReference=new ByteByReference(stepEvent);
          Byte terminateSimulation=(byte)0;
          ByteByReference terminateSimulationReference=new ByteByReference(terminateSimulation);
          invoke(completedIntegratorStep,new Object[]{fmiComponent,(byte)1,stepEventReference,terminateSimulationReference},""String_Node_Str"" + time + ""String_Node_Str"");
          if (terminateSimulation != (byte)0) {
            System.out.println(""String_Node_Str"" + time);
            break;
          }
        }
        if (_fmiVersion < 1.5) {
          invoke(getEventIndicators,new Object[]{fmiComponent,eventIndicators,numberOfEventIndicators},""String_Node_Str"" + time + ""String_Node_Str"");
          stateEvent=Boolean.FALSE;
          for (int i=0; i < numberOfEventIndicators; i++) {
            stateEvent=stateEvent || preEventIndicators[i] * eventIndicators[i] < 0;
          }
        }
        if (stateEvent || stepEvent != (byte)0 || timeEvent) {
          if (stateEvent) {
            numberOfStateEvents++;
            if (enableLogging) {
              for (int i=0; i < numberOfEventIndicators; i++) {
                System.out.println(""String_Node_Str"" + (preEventIndicators[i] > 0 && eventIndicators[i] < 0 ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ i+ ""String_Node_Str""+ time);
              }
            }
          }
          if (stepEvent != (byte)0) {
            numberOfStepEvents++;
            if (enableLogging) {
              System.out.println(""String_Node_Str"" + time);
            }
          }
          if (timeEvent) {
            numberOfTimeEvents++;
            if (enableLogging) {
              System.out.println(""String_Node_Str"" + time);
            }
          }
          if (_fmiVersion < 1.5) {
            invoke(eventUpdate,new Object[]{fmiComponent,(byte)0,eventInfo},""String_Node_Str"" + time + ""String_Node_Str"");
            if (eventInfo.stateValuesChanged != (byte)0 && enableLogging) {
              System.out.println(""String_Node_Str"" + time);
            }
            if (eventInfo.stateValueReferencesChanged != (byte)0 && enableLogging) {
              System.out.println(""String_Node_Str"" + time);
            }
          }
 else {
            eventInfo20.newDiscreteStatesNeeded=(byte)1;
            eventInfo20.terminateSimulation=(byte)0;
            while ((eventInfo20.newDiscreteStatesNeeded == (byte)1) && !(eventInfo20.terminateSimulation == (byte)1)) {
              eventInfo20Reference=new FMI20EventInfo.ByReference(eventInfo20);
              invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent,eventInfo20Reference},""String_Node_Str"");
            }
            if (eventInfo20.terminateSimulation != (byte)0) {
              System.out.println(""String_Node_Str"" + time);
              break;
            }
            invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent},""String_Node_Str"");
            if ((eventInfo20.valuesOfContinuousStatesChanged == (byte)1) && enableLogging) {
              System.out.println(""String_Node_Str"" + time);
            }
            if ((eventInfo20.nominalsOfContinuousStatesChanged == (byte)1) && enableLogging) {
              System.out.println(""String_Node_Str"" + time);
            }
          }
        }
        OutputRow.outputRow(_nativeLibrary,fmiModelDescription,fmiComponent,time,file,csvSeparator,Boolean.FALSE);
        numberOfSteps++;
      }
      if (_fmiVersion < 1.5) {
        invoke(""String_Node_Str"",new Object[]{fmiComponent},""String_Node_Str"");
        Function freeSlave=fmiModelDescription.getFmiFunction(""String_Node_Str"");
        int fmiFlag=((Integer)freeSlave.invoke(Integer.class,new Object[]{fmiComponent})).intValue();
        if (fmiFlag >= FMILibrary.FMIStatus.fmiWarning) {
          new Exception(""String_Node_Str"" + fmiFlag).printStackTrace();
        }
      }
 else {
        if (!(eventInfo20.terminateSimulation == 1)) {
          invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent},""String_Node_Str"");
        }
        invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent},""String_Node_Str"");
      }
    }
  finally {
      if (file != null) {
        file.close();
      }
      if (fmiModelDescription != null) {
        fmiModelDescription.dispose();
      }
    }
  }
  System.out.println(""String_Node_Str"" + startTime + ""String_Node_Str""+ endTime+ ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + numberOfSteps);
  System.out.println(""String_Node_Str"" + stepSize);
  System.out.println(""String_Node_Str"" + numberOfStateEvents);
  System.out.println(""String_Node_Str"" + numberOfStepEvents);
  System.out.println(""String_Node_Str"" + numberOfTimeEvents);
  System.out.flush();
}","/** 
 * Perform model exchange using the named Functional Mock-up Unit (FMU) file.
 * @param fmuFileName The pathname of the co-simulation .fmu file
 * @param endTime The ending time in seconds.
 * @param stepSize The step size in seconds.
 * @param enableLogging True if logging is enabled.
 * @param csvSeparator The character used for separating fields.Note that sometimes the decimal point in floats is converted to ','.
 * @param outputFileName The output file.
 * @exception Exception If there is a problem parsing the .fmu file or invokingthe methods in the shared library.
 */
public void simulate(String fmuFileName,double endTime,double stepSize,boolean enableLogging,char csvSeparator,String outputFileName) throws Exception {
  FMUDriver._setEnableLogging(enableLogging);
  FMIModelDescription fmiModelDescription=FMUFile.parseFMUFile(fmuFileName);
  String sharedLibrary=FMUFile.fmuSharedLibrary(fmiModelDescription);
  if (enableLogging) {
    System.out.println(""String_Node_Str"" + sharedLibrary);
  }
  _nativeLibrary=NativeLibrary.getInstance(sharedLibrary);
  _modelIdentifier=fmiModelDescription.modelIdentifier;
  new File(fmuFileName).toURI().toURL().toString();
  int numberOfStateEvents=0;
  int numberOfStepEvents=0;
  int numberOfSteps=0;
  int numberOfTimeEvents=0;
  byte loggingOn=enableLogging ? (byte)1 : (byte)0;
  _fmiVersion=Double.valueOf(fmiModelDescription.fmiVersion);
  Pointer fmiComponent=null;
  if (_fmiVersion < 1.5) {
    FMICallbackFunctions.ByValue callbacks=new FMICallbackFunctions.ByValue(new FMULibrary.FMULogger(fmiModelDescription),fmiModelDescription.getFMUAllocateMemory(),new FMULibrary.FMUFreeMemory(),new FMULibrary.FMUStepFinished());
    Function instantiateModelFunction;
    try {
      instantiateModelFunction=fmiModelDescription.getFmiFunction(""String_Node_Str"");
    }
 catch (    UnsatisfiedLinkError ex) {
      UnsatisfiedLinkError error=new UnsatisfiedLinkError(""String_Node_Str"" + _modelIdentifier + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      error.initCause(ex);
      throw error;
    }
    fmiComponent=(Pointer)instantiateModelFunction.invoke(Pointer.class,new Object[]{_modelIdentifier,fmiModelDescription.guid,callbacks,loggingOn});
  }
 else {
    FMICallbackFunctions callbacks=new FMICallbackFunctions(new FMULibrary.FMULogger(fmiModelDescription),new FMULibrary.FMUAllocateMemory(),new FMULibrary.FMUFreeMemory(),new FMULibrary.FMUStepFinished());
    Function fmiInstantiateFunction=fmiModelDescription.getFmiFunction(""String_Node_Str"");
    byte toBeVisible=0;
    int fmiType=1;
    if (fmiModelDescription.modelExchange) {
      fmiType=0;
    }
    fmiComponent=(Pointer)fmiInstantiateFunction.invoke(Pointer.class,new Object[]{_modelIdentifier,fmiType,fmiModelDescription.guid,fmiModelDescription.fmuResourceLocation,callbacks,toBeVisible,loggingOn});
  }
  if (fmiComponent.equals(Pointer.NULL)) {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (enableLogging) {
    System.out.println(""String_Node_Str"");
  }
  final int numberOfStates=fmiModelDescription.numberOfContinuousStates;
  final int numberOfEventIndicators=fmiModelDescription.numberOfEventIndicators;
  double[] states=new double[numberOfStates];
  double[] derivatives=new double[numberOfStates];
  double[] eventIndicators=null;
  double[] preEventIndicators=null;
  if (numberOfEventIndicators > 0) {
    eventIndicators=new double[numberOfEventIndicators];
    preEventIndicators=new double[numberOfEventIndicators];
  }
  double startTime=0.0;
  Function setTime=fmiModelDescription.getFmiFunction(""String_Node_Str"");
  invoke(setTime,new Object[]{fmiComponent,startTime},""String_Node_Str"" + startTime + ""String_Node_Str"");
  byte toleranceControlled=0;
  FMIEventInfo eventInfo=null;
  FMI20EventInfo eventInfo20=null;
  FMI20EventInfo.ByReference eventInfo20Reference=null;
  if (_fmiVersion < 1.5) {
    eventInfo=new FMIEventInfo();
    invoke(setTime,new Object[]{fmiComponent,startTime},""String_Node_Str"" + startTime + ""String_Node_Str"");
    invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent,toleranceControlled,startTime,eventInfo},""String_Node_Str"");
  }
 else {
    eventInfo20=new FMI20EventInfo();
    double relativeTolerance=1e-4;
    byte _toleranceControlled=(byte)0;
    invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent,_toleranceControlled,relativeTolerance,startTime,(byte)1,endTime},""String_Node_Str"");
    invoke(setTime,new Object[]{fmiComponent,startTime},""String_Node_Str"" + startTime + ""String_Node_Str"");
    invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent},""String_Node_Str"");
    invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent},""String_Node_Str"");
    eventInfo20.newDiscreteStatesNeeded=(byte)1;
    eventInfo20.terminateSimulation=(byte)0;
    System.out.println(eventInfo20.toString());
    while (eventInfo20.newDiscreteStatesNeeded == (byte)1 && !(eventInfo20.terminateSimulation == (byte)1)) {
      eventInfo20Reference=new FMI20EventInfo.ByReference(eventInfo20);
      System.out.println(eventInfo20Reference.toString());
      invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent,eventInfo20Reference},""String_Node_Str"");
    }
  }
  double time=startTime;
  if (eventInfo20 != null && (eventInfo20.terminateSimulation != 0 || eventInfo20.terminateSimulation != 0)) {
    System.out.println(""String_Node_Str"" + time);
    endTime=time;
  }
  if ((eventInfo20 != null && eventInfo20.terminateSimulation != 1) || _fmiVersion < 1.5) {
    if (_fmiVersion > 1.5) {
      invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent},""String_Node_Str"");
    }
    PrintStream file=null;
    try {
      file=new PrintStream(outputFileName);
      if (enableLogging) {
        System.out.println(""String_Node_Str"");
      }
      OutputRow.outputRow(_nativeLibrary,fmiModelDescription,fmiComponent,startTime,file,csvSeparator,Boolean.TRUE);
      OutputRow.outputRow(_nativeLibrary,fmiModelDescription,fmiComponent,startTime,file,csvSeparator,Boolean.FALSE);
      Function completedIntegratorStep=fmiModelDescription.getFmiFunction(""String_Node_Str"");
      Function eventUpdate=null;
      if (_fmiVersion < 1.5) {
        eventUpdate=fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
      Function getContinuousStates=fmiModelDescription.getFmiFunction(""String_Node_Str"");
      Function getDerivatives=fmiModelDescription.getFmiFunction(""String_Node_Str"");
      Function getEventIndicators=fmiModelDescription.getFmiFunction(""String_Node_Str"");
      Function setContinuousStates=fmiModelDescription.getFmiFunction(""String_Node_Str"");
      boolean stateEvent=false;
      byte stepEvent=(byte)0;
      while (time < endTime) {
        invoke(getContinuousStates,new Object[]{fmiComponent,states,numberOfStates},""String_Node_Str"" + time + ""String_Node_Str"");
        invoke(getDerivatives,new Object[]{fmiComponent,derivatives,numberOfStates},""String_Node_Str"" + time + ""String_Node_Str"");
        double stepStartTime=time;
        time=Math.min(time + stepSize,endTime);
        boolean timeEvent=false;
        if (_fmiVersion < 1.5) {
          timeEvent=eventInfo.upcomingTimeEvent == 1 && eventInfo.nextEventTime < time;
        }
 else {
          timeEvent=eventInfo20.nextEventTimeDefined == 1 && eventInfo20.nextEventTime < time;
        }
        if (timeEvent) {
          time=eventInfo.nextEventTime;
        }
        double dt=time - stepStartTime;
        invoke(setTime,new Object[]{fmiComponent,time},""String_Node_Str"" + time + ""String_Node_Str"");
        for (int i=0; i < numberOfStates; i++) {
          states[i]+=dt * derivatives[i];
        }
        invoke(setContinuousStates,new Object[]{fmiComponent,states,numberOfStates},""String_Node_Str"" + time + ""String_Node_Str"");
        if (enableLogging) {
          System.out.println(""String_Node_Str"" + numberOfSteps + ""String_Node_Str""+ time);
        }
        if (_fmiVersion > 1.5) {
          for (int i=0; i < numberOfEventIndicators; i++) {
            preEventIndicators[i]=eventIndicators[i];
          }
          invoke(getEventIndicators,new Object[]{fmiComponent,eventIndicators,numberOfEventIndicators},""String_Node_Str"" + time + ""String_Node_Str"");
          stateEvent=false;
          for (int i=0; i < numberOfEventIndicators; i++) {
            stateEvent=stateEvent || (preEventIndicators[i] * eventIndicators[i] < 0);
          }
        }
        if (_fmiVersion < 1.5) {
          ByteByReference stepEventReference=new ByteByReference(stepEvent);
          invoke(completedIntegratorStep,new Object[]{fmiComponent,stepEventReference},""String_Node_Str"" + time + ""String_Node_Str"");
          for (int i=0; i < numberOfEventIndicators; i++) {
            preEventIndicators[i]=eventIndicators[i];
          }
        }
 else {
          ByteByReference stepEventReference=new ByteByReference(stepEvent);
          Byte terminateSimulation=(byte)0;
          ByteByReference terminateSimulationReference=new ByteByReference(terminateSimulation);
          invoke(completedIntegratorStep,new Object[]{fmiComponent,(byte)1,stepEventReference,terminateSimulationReference},""String_Node_Str"" + time + ""String_Node_Str"");
          if (terminateSimulation != (byte)0) {
            System.out.println(""String_Node_Str"" + time);
            break;
          }
        }
        if (_fmiVersion < 1.5) {
          invoke(getEventIndicators,new Object[]{fmiComponent,eventIndicators,numberOfEventIndicators},""String_Node_Str"" + time + ""String_Node_Str"");
          stateEvent=Boolean.FALSE;
          for (int i=0; i < numberOfEventIndicators; i++) {
            stateEvent=stateEvent || preEventIndicators[i] * eventIndicators[i] < 0;
          }
        }
        if (stateEvent || stepEvent != (byte)0 || timeEvent) {
          if (stateEvent) {
            numberOfStateEvents++;
            if (enableLogging) {
              for (int i=0; i < numberOfEventIndicators; i++) {
                System.out.println(""String_Node_Str"" + (preEventIndicators[i] > 0 && eventIndicators[i] < 0 ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ i+ ""String_Node_Str""+ time);
              }
            }
          }
          if (stepEvent != (byte)0) {
            numberOfStepEvents++;
            if (enableLogging) {
              System.out.println(""String_Node_Str"" + time);
            }
          }
          if (timeEvent) {
            numberOfTimeEvents++;
            if (enableLogging) {
              System.out.println(""String_Node_Str"" + time);
            }
          }
          if (_fmiVersion < 1.5) {
            invoke(eventUpdate,new Object[]{fmiComponent,(byte)0,eventInfo},""String_Node_Str"" + time + ""String_Node_Str"");
            if (eventInfo.stateValuesChanged != (byte)0 && enableLogging) {
              System.out.println(""String_Node_Str"" + time);
            }
            if (eventInfo.stateValueReferencesChanged != (byte)0 && enableLogging) {
              System.out.println(""String_Node_Str"" + time);
            }
          }
 else {
            eventInfo20.newDiscreteStatesNeeded=(byte)1;
            eventInfo20.terminateSimulation=(byte)0;
            while ((eventInfo20.newDiscreteStatesNeeded == (byte)1) && !(eventInfo20.terminateSimulation == (byte)1)) {
              eventInfo20Reference=new FMI20EventInfo.ByReference(eventInfo20);
              invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent,eventInfo20Reference},""String_Node_Str"");
            }
            if (eventInfo20.terminateSimulation != (byte)0) {
              System.out.println(""String_Node_Str"" + time);
              break;
            }
            invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent},""String_Node_Str"");
            if ((eventInfo20.valuesOfContinuousStatesChanged == (byte)1) && enableLogging) {
              System.out.println(""String_Node_Str"" + time);
            }
            if ((eventInfo20.nominalsOfContinuousStatesChanged == (byte)1) && enableLogging) {
              System.out.println(""String_Node_Str"" + time);
            }
          }
        }
        OutputRow.outputRow(_nativeLibrary,fmiModelDescription,fmiComponent,time,file,csvSeparator,Boolean.FALSE);
        numberOfSteps++;
      }
      if (_fmiVersion < 1.5) {
        invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent},""String_Node_Str"");
        Function freeModelInstance=fmiModelDescription.getFmiFunction(""String_Node_Str"");
        int fmiFlag=((Integer)freeModelInstance.invoke(Integer.class,new Object[]{fmiComponent})).intValue();
        if (fmiFlag >= FMILibrary.FMIStatus.fmiWarning) {
          System.err.println(""String_Node_Str"" + FMIModelDescription.fmiStatusDescription(fmiFlag));
        }
      }
 else {
        if (!(eventInfo20.terminateSimulation == 1)) {
          invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent},""String_Node_Str"");
        }
        invoke(fmiModelDescription,""String_Node_Str"",new Object[]{fmiComponent},""String_Node_Str"");
      }
    }
  finally {
      if (file != null) {
        file.close();
      }
      if (fmiModelDescription != null) {
        fmiModelDescription.dispose();
      }
    }
  }
  System.out.println(""String_Node_Str"" + startTime + ""String_Node_Str""+ endTime+ ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + numberOfSteps);
  System.out.println(""String_Node_Str"" + stepSize);
  System.out.println(""String_Node_Str"" + numberOfStateEvents);
  System.out.println(""String_Node_Str"" + numberOfStepEvents);
  System.out.println(""String_Node_Str"" + numberOfTimeEvents);
  System.out.flush();
}"
72706,"/** 
 * Send the current value of the state of this actor to the output.
 * @exception IllegalActionException If calling send() or super.fire()throws it.
 */
@Override public void fire() throws IllegalActionException {
  super.fire();
  for (  PortParameter portParameter : attributeList(PortParameter.class)) {
    portParameter.update();
  }
  if (_pendingCallbacks != null) {
    while (!_pendingCallbacks.isEmpty()) {
      Function function=_pendingCallbacks.remove(0);
      function.call(_context,_scope,function,_EMPTY_ARGS);
    }
  }
synchronized (this) {
    if (_outputTokens != null) {
      for (      IOPort port : _outputTokens.keySet()) {
        HashMap<Integer,List<Token>> tokens=_outputTokens.get(port);
        for (        Map.Entry<Integer,List<Token>> entry : tokens.entrySet()) {
          List<Token> queue=entry.getValue();
          if (queue != null) {
            for (            Token token : queue) {
              port.send(entry.getKey(),token);
            }
          }
        }
      }
      _outputTokens.clear();
    }
  }
  _inputTokens.clear();
  for (  IOPort input : this.inputPortList()) {
    if (input == scriptIn) {
      continue;
    }
    HashMap<Integer,Token> tokens=new HashMap<Integer,Token>();
    for (int i=0; i < input.getWidth(); i++) {
      if (input.hasToken(i)) {
        tokens.put(i,input.get(i));
      }
    }
    _inputTokens.put(input,tokens);
  }
  try {
    if (scriptIn.getWidth() > 0 && scriptIn.hasToken(0)) {
      String scriptValue=((StringToken)scriptIn.get(0)).stringValue();
      _compiledScript=_context.compileString(scriptValue,getName(),1,null);
      _compiledScript.exec(Context.getCurrentContext(),_scope);
      Object initializeFunction=_scope.get(""String_Node_Str"",_scope);
      if (initializeFunction instanceof Function) {
        ((Function)initializeFunction).call(Context.getCurrentContext(),_scope,_global,null);
      }
    }
    Object fireFunction=_scope.get(""String_Node_Str"",_scope);
    if (fireFunction instanceof Function) {
synchronized (JavaScript.this) {
        _inFire=true;
        try {
          ((Function)fireFunction).call(Context.getCurrentContext(),_scope,_global,_EMPTY_ARGS);
        }
  finally {
          _inFire=false;
        }
      }
    }
  }
 catch (  WrappedException ex) {
    Throwable original=ex.getWrappedException();
    throw new IllegalActionException(this,ex,""String_Node_Str"" + ex.lineNumber() + ""String_Node_Str""+ original.getMessage());
  }
}","/** 
 * Send the current value of the state of this actor to the output.
 * @exception IllegalActionException If calling send() or super.fire()throws it.
 */
@Override public void fire() throws IllegalActionException {
  super.fire();
  for (  PortParameter portParameter : attributeList(PortParameter.class)) {
    portParameter.update();
  }
  if (_pendingCallbacks != null) {
    while (!_pendingCallbacks.isEmpty()) {
      Function function=_pendingCallbacks.remove(0);
      function.call(_context,_scope,function,_EMPTY_ARGS);
    }
  }
synchronized (this) {
    if (_outputTokens != null) {
      for (      IOPort port : _outputTokens.keySet()) {
        HashMap<Integer,List<Token>> tokens=_outputTokens.get(port);
        for (        Map.Entry<Integer,List<Token>> entry : tokens.entrySet()) {
          List<Token> queue=entry.getValue();
          if (queue != null) {
            for (            Token token : queue) {
              port.send(entry.getKey(),token);
            }
          }
        }
      }
      _outputTokens.clear();
    }
  }
  _inputTokens.clear();
  for (  IOPort input : this.inputPortList()) {
    if (input == scriptIn) {
      continue;
    }
    if (input instanceof ParameterPort) {
      continue;
    }
    HashMap<Integer,Token> tokens=new HashMap<Integer,Token>();
    for (int i=0; i < input.getWidth(); i++) {
      if (input.hasToken(i)) {
        tokens.put(i,input.get(i));
      }
    }
    _inputTokens.put(input,tokens);
  }
  try {
    if (scriptIn.getWidth() > 0 && scriptIn.hasToken(0)) {
      String scriptValue=((StringToken)scriptIn.get(0)).stringValue();
      _compiledScript=_context.compileString(scriptValue,getName(),1,null);
      _compiledScript.exec(Context.getCurrentContext(),_scope);
      Object initializeFunction=_scope.get(""String_Node_Str"",_scope);
      if (initializeFunction instanceof Function) {
        ((Function)initializeFunction).call(Context.getCurrentContext(),_scope,_global,null);
      }
    }
    Object fireFunction=_scope.get(""String_Node_Str"",_scope);
    if (fireFunction instanceof Function) {
synchronized (JavaScript.this) {
        _inFire=true;
        try {
          ((Function)fireFunction).call(Context.getCurrentContext(),_scope,_global,_EMPTY_ARGS);
        }
  finally {
          _inFire=false;
        }
      }
    }
  }
 catch (  WrappedException ex) {
    Throwable original=ex.getWrappedException();
    throw new IllegalActionException(this,ex,""String_Node_Str"" + ex.lineNumber() + ""String_Node_Str""+ original.getMessage());
  }
}"
72707,"/** 
 * Execution aspects are decorators and this method recursively computes all entities inside a given container that are decorated by execution aspects.
 * @param container The container.
 * @return All entities to decorate.
 */
public static List<NamedObj> getEntitiesToDecorate(CompositeEntity container){
  List<NamedObj> toDecorate=new ArrayList<NamedObj>();
  for (  Object entity : container.entityList()) {
    if (!(entity instanceof ActorExecutionAspect)) {
      toDecorate.add((NamedObj)entity);
      if (entity instanceof CompositeEntity) {
        toDecorate.addAll(ExecutionAspectHelper.getEntitiesToDecorate((CompositeEntity)entity));
      }
    }
  }
  return toDecorate;
}","/** 
 * Execution aspects are decorators and this method recursively computes all entities inside a given container that are decorated by execution aspects.
 * @param container The container.
 * @return All entities to decorate.
 */
public static List<NamedObj> getEntitiesToDecorate(CompositeEntity container){
  List<NamedObj> toDecorate=new ArrayList<NamedObj>();
  for (  Object entity : container.entityList()) {
    if (!(entity instanceof ActorExecutionAspect || entity instanceof Director)) {
      toDecorate.add((NamedObj)entity);
      if (entity instanceof CompositeEntity) {
        toDecorate.addAll(ExecutionAspectHelper.getEntitiesToDecorate((CompositeEntity)entity));
      }
    }
  }
  return toDecorate;
}"
72708,"/** 
 * Iterate through resource mapping output ports and if they contain tokens, inform the director of the actors in the tokens that these actors can resume execution.
 * @exception illegalActionException Not explicitly thrown here.
 */
@Override public boolean postfire() throws IllegalActionException {
  boolean postfire=super.postfire();
  for (  Object entity : entityList()) {
    if (entity instanceof ExecutionResponsePort) {
      ExecutionResponsePort outputPort=((ExecutionResponsePort)entity);
      if (outputPort.hasToken() && outputPort.getToken() instanceof RecordToken) {
        RecordToken recordToken=(RecordToken)outputPort.getToken();
        if (recordToken.get(""String_Node_Str"") != null && ((ObjectToken)recordToken.get(""String_Node_Str"")).getValue() != null) {
          Actor actor=(Actor)((ObjectToken)recordToken.get(""String_Node_Str"")).getValue();
          notifyExecutionListeners((NamedObj)actor,getExecutiveDirector().getModelTime().getDoubleValue(),ExecutionEventType.STOP);
          outputPort.takeToken();
          _currentlyExecuting.remove(actor);
          actor.getExecutiveDirector().resumeActor((NamedObj)actor);
          _lastActorFinished=true;
        }
      }
    }
  }
  return postfire;
}","/** 
 * Iterate through resource mapping output ports and if they contain tokens, inform the director of the actors in the tokens that these actors can resume execution.
 * @exception illegalActionException Not explicitly thrown here.
 */
@Override public boolean postfire() throws IllegalActionException {
  boolean postfire=super.postfire();
  for (  Object entity : entityList()) {
    if (entity instanceof ExecutionResponsePort) {
      ExecutionResponsePort outputPort=((ExecutionResponsePort)entity);
      if (outputPort.hasToken() && outputPort.getToken() instanceof RecordToken) {
        RecordToken recordToken=(RecordToken)outputPort.getToken();
        if (recordToken.get(""String_Node_Str"") != null && ((ObjectToken)recordToken.get(""String_Node_Str"")).getValue() != null) {
          NamedObj actor=(NamedObj)((ObjectToken)recordToken.get(""String_Node_Str"")).getValue();
          notifyExecutionListeners(actor,getExecutiveDirector().getModelTime().getDoubleValue(),ExecutionEventType.STOP);
          outputPort.takeToken();
          _currentlyExecuting.remove(actor);
          Director director=null;
          if (actor instanceof Actor) {
            director=((Actor)actor).getExecutiveDirector();
          }
 else {
            Nameable container=actor.getContainer();
            while (!(container instanceof Actor)) {
              container=container.getContainer();
            }
            director=((Actor)container).getDirector();
          }
          director.resumeActor(actor);
          _lastActorFinished=true;
        }
      }
    }
  }
  return postfire;
}"
72709,"/** 
 * Return the decorated attributes for the target NamedObj. If the specified target is not an Actor, return null.
 * @param target The NamedObj that will be decorated.
 * @return The decorated attributes for the target NamedObj, ornull if the specified target is not an Actor.
 */
@Override public DecoratorAttributes createDecoratorAttributes(NamedObj target){
  if (target instanceof NamedObj && !_isPartOfExecutionAspect(target)) {
    try {
      return new CompositeExecutionAspectAttributes(target,this);
    }
 catch (    KernelException ex) {
      throw new InternalErrorException(ex);
    }
  }
 else {
    return null;
  }
}","/** 
 * Return the decorated attributes for the target NamedObj. If the specified target is not an Actor, return null.
 * @param target The NamedObj that will be decorated.
 * @return The decorated attributes for the target NamedObj, ornull if the specified target is not an Actor.
 */
@Override public DecoratorAttributes createDecoratorAttributes(NamedObj target){
  if (!_isPartOfExecutionAspect(target)) {
    try {
      return new CompositeExecutionAspectAttributes(target,this);
    }
 catch (    KernelException ex) {
      throw new InternalErrorException(ex);
    }
  }
 else {
    return null;
  }
}"
72710,"/** 
 * Get the priority of the actor.
 * @param actor The actor.
 * @return The priority of the actor or, if the actor has no priorityassigned, the lowest priority.
 * @exception IllegalActionException Thrown if parameter cannot be read.
 */
protected double _getPriority(NamedObj actor) throws IllegalActionException {
  return ((IntToken)((Parameter)actor.getDecoratorAttribute(this,""String_Node_Str"")).getToken()).intValue();
}","/** 
 * Get the priority of the actor.
 * @param actor The actor.
 * @return The priority of the actor or, if the actor has no priorityassigned, the lowest priority.
 * @exception IllegalActionException Thrown if parameter cannot be read.
 */
protected double _getPriority(NamedObj actor) throws IllegalActionException {
  Attribute attributes=actor.getDecoratorAttribute(this,""String_Node_Str"");
  if (attributes == null || !(attributes instanceof Parameter)) {
    throw new IllegalActionException(this,""String_Node_Str"" + actor.getName());
  }
  Token token=((Parameter)attributes).getToken();
  if (token == null) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
 else   if (!(token instanceof IntToken)) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  return ((IntToken)token).intValue();
}"
72711,"/** 
 * Resume the execution of an actor that was previously blocked because it didn't have all the resources it needed for execution. This method puts an event into the queue for the current time.
 * @param actor The actor that resumes execution.
 * @exception IllegalActionException Not thrown here but in derived classes.
 */
@Override public void resumeActor(NamedObj actor) throws IllegalActionException {
  List<DEEvent> events=_actorsInExecution.get(actor);
  Time time=((CompositeActor)getExecutionAspect((NamedObj)actor).getContainer()).getDirector().getModelTime();
  DEEvent event=events.get(0);
  events.remove(event);
  _actorsInExecution.put((Actor)actor,events);
  if (event.ioPort() != null) {
    _enqueueTriggerEvent(event.ioPort(),time);
  }
 else {
    _enqueueEvent((Actor)actor,time,1);
  }
  fireContainerAt(time);
  if (_actorsFinished == null) {
    _actorsFinished=new ArrayList();
  }
  _actorsFinished.add((Actor)actor);
}","/** 
 * Resume the execution of an actor that was previously blocked because it didn't have all the resources it needed for execution. This method puts an event into the queue for the current time.
 * @param actor The actor that resumes execution.
 * @exception IllegalActionException Not thrown here but in derived classes.
 */
@Override public void resumeActor(NamedObj actor) throws IllegalActionException {
  List<DEEvent> events=_actorsInExecution.get(actor);
  ActorExecutionAspect aspect=getExecutionAspect(actor);
  if (aspect == null) {
    throw new IllegalActionException(this,""String_Node_Str"" + actor.getName() + ""String_Node_Str"");
  }
  NamedObj container=aspect.getContainer();
  if (container == null) {
    throw new IllegalActionException(this,""String_Node_Str"" + actor.getName());
  }
  Director director=((CompositeActor)container).getDirector();
  if (director == null) {
    throw new IllegalActionException(this,""String_Node_Str"" + container.getName() + ""String_Node_Str""+ actor.getName());
  }
  Time time=director.getModelTime();
  DEEvent event=events.get(0);
  events.remove(event);
  _actorsInExecution.put((Actor)actor,events);
  if (event.ioPort() != null) {
    _enqueueTriggerEvent(event.ioPort(),time);
  }
 else {
    _enqueueEvent((Actor)actor,time,1);
  }
  fireContainerAt(time);
  if (_actorsFinished == null) {
    _actorsFinished=new ArrayList();
  }
  _actorsFinished.add((Actor)actor);
}"
72712,"/** 
 * Set the values of input variables. Choose the enabled transition among the outgoing transitions of the current state. Throw an exception if there is more than one transition enabled. Otherwise, execute the output actions contained by the chosen transition.
 * @exception IllegalActionException If there is more than onetransition enabled.
 */
public void fire() throws IllegalActionException {
  if (_debugging) {
    _debug(""String_Node_Str"" + _currentState.getName());
  }
  if (_firstFire) {
    _schedule(_currentState,getDirector().getModelTime());
  }
  Time environmentTime=_getEnvironmentTime();
  Director director=getDirector();
  boolean inModalModel=false;
  if (director instanceof FSMDirector) {
    inModalModel=true;
    director.setModelTime(environmentTime);
  }
  readInputs();
  _lastChosenTransitions.clear();
  _lastChosenTransition=null;
  _outputsThatMustBeUnknown.clear();
  _transitionRefinementsToPostfire.clear();
  _stateRefinementsToPostfire.clear();
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  List<Transition> transitionList=_currentState.nonErrorNonTerminationTransitionList();
  _chooseTransitions(transitionList,true,false,false,false);
  if (_lastChosenTransitions.size() > 0) {
    if (inModalModel) {
      director.setModelTime(environmentTime);
    }
    TypedActor[] refinements=_currentState.getRefinement();
    if (refinements != null) {
      for (      Actor refinementActor : refinements) {
        if (refinementActor instanceof CompositeActor) {
          CompositeActor refinement=(CompositeActor)refinementActor;
          for (          IOPort refinementPort : (List<IOPort>)refinement.outputPortList()) {
            for (int i=0; i < refinementPort.getWidth(); i++) {
              if (!refinementPort.isKnown(i)) {
                if (_debugging) {
                  _debug(""String_Node_Str"" + refinementPort.getName() + ""String_Node_Str""+ i);
                }
                refinementPort.sendClear(i);
              }
            }
          }
        }
      }
    }
  }
 else {
    if (!foundUnknown()) {
      Actor[] stateRefinements=_currentState.getRefinement();
      if (stateRefinements != null) {
        try {
          for (int i=0; i < stateRefinements.length; ++i) {
            if (_stopRequested || _disabledRefinements.contains(stateRefinements[i])) {
              continue;
            }
            _setTimeForRefinement(stateRefinements[i]);
            if (stateRefinements[i].prefire()) {
              if (_debugging) {
                _debug(""String_Node_Str"",stateRefinements[i].getName());
              }
              if (_modelErrorHandled == null) {
                stateRefinements[i].fire();
                if (_modelErrorHandled == null) {
                  _stateRefinementsToPostfire.add(stateRefinements[i]);
                }
              }
            }
          }
        }
 catch (        Throwable ex) {
          _chooseErrorTransition(ex);
          if (_lastChosenTransitions.size() > 0) {
            if (inModalModel) {
              director.setModelTime(environmentTime);
            }
            return;
          }
          throw new IllegalActionException(this,ex,""String_Node_Str"");
        }
        if (_modelErrorHandled != null) {
          _chooseErrorTransition(_modelErrorHandled);
          if (inModalModel) {
            director.setModelTime(environmentTime);
          }
          return;
        }
      }
      if (inModalModel) {
        director.setModelTime(environmentTime);
      }
      readOutputsFromRefinement();
      if (_debugging) {
        _debug(""String_Node_Str"");
      }
      List<Transition> terminationTransitions=_currentState.terminationTransitionList();
      boolean checkTerminationTransitions=false;
      if (terminationTransitions.size() > 0) {
        TypedActor[] refinements=_currentState.getRefinement();
        if (refinements != null && refinements.length > 0) {
          checkTerminationTransitions=true;
          for (          Actor refinementActor : refinements) {
            if (refinementActor instanceof ModalRefinement) {
              ModalRefinement refinement=(ModalRefinement)refinementActor;
              FSMActor refinementController=refinement.getController();
              State destinationState=refinementController._destinationState();
              if (!((BooleanToken)refinementController.currentState().isFinalState.getToken()).booleanValue() && (destinationState == null || !((BooleanToken)destinationState.isFinalState.getToken()).booleanValue())) {
                checkTerminationTransitions=false;
                break;
              }
            }
 else {
              checkTerminationTransitions=false;
              break;
            }
          }
        }
      }
      if (checkTerminationTransitions) {
        _chooseTransitions(_currentState.nonpreemptiveTransitionList(),false,false,false,false);
      }
 else {
        _chooseTransitions(transitionList,false,false,false,false);
      }
    }
  }
  _assertAbsentOutputs(this);
}","/** 
 * Set the values of input variables. Choose the enabled transition among the outgoing transitions of the current state. Throw an exception if there is more than one transition enabled. Otherwise, execute the output actions contained by the chosen transition.
 * @exception IllegalActionException If there is more than onetransition enabled.
 */
public void fire() throws IllegalActionException {
  if (_debugging) {
    _debug(""String_Node_Str"" + _currentState.getName());
  }
  if (_firstFire) {
    _schedule(_currentState,getDirector().getModelTime());
    _firstFire=false;
  }
  Time environmentTime=_getEnvironmentTime();
  Director director=getDirector();
  boolean inModalModel=false;
  if (director instanceof FSMDirector) {
    inModalModel=true;
    director.setModelTime(environmentTime);
  }
  readInputs();
  _lastChosenTransitions.clear();
  _lastChosenTransition=null;
  _outputsThatMustBeUnknown.clear();
  _transitionRefinementsToPostfire.clear();
  _stateRefinementsToPostfire.clear();
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  List<Transition> transitionList=_currentState.nonErrorNonTerminationTransitionList();
  _chooseTransitions(transitionList,true,false,false,false);
  if (_lastChosenTransitions.size() > 0) {
    if (inModalModel) {
      director.setModelTime(environmentTime);
    }
    TypedActor[] refinements=_currentState.getRefinement();
    if (refinements != null) {
      for (      Actor refinementActor : refinements) {
        if (refinementActor instanceof CompositeActor) {
          CompositeActor refinement=(CompositeActor)refinementActor;
          for (          IOPort refinementPort : (List<IOPort>)refinement.outputPortList()) {
            for (int i=0; i < refinementPort.getWidth(); i++) {
              if (!refinementPort.isKnown(i)) {
                if (_debugging) {
                  _debug(""String_Node_Str"" + refinementPort.getName() + ""String_Node_Str""+ i);
                }
                refinementPort.sendClear(i);
              }
            }
          }
        }
      }
    }
  }
 else {
    if (!foundUnknown()) {
      Actor[] stateRefinements=_currentState.getRefinement();
      if (stateRefinements != null) {
        try {
          for (int i=0; i < stateRefinements.length; ++i) {
            if (_stopRequested || _disabledRefinements.contains(stateRefinements[i])) {
              continue;
            }
            _setTimeForRefinement(stateRefinements[i]);
            if (stateRefinements[i].prefire()) {
              if (_debugging) {
                _debug(""String_Node_Str"",stateRefinements[i].getName());
              }
              if (_modelErrorHandled == null) {
                stateRefinements[i].fire();
                if (_modelErrorHandled == null) {
                  _stateRefinementsToPostfire.add(stateRefinements[i]);
                }
              }
            }
          }
        }
 catch (        Throwable ex) {
          _chooseErrorTransition(ex);
          if (_lastChosenTransitions.size() > 0) {
            if (inModalModel) {
              director.setModelTime(environmentTime);
            }
            return;
          }
          throw new IllegalActionException(this,ex,""String_Node_Str"");
        }
        if (_modelErrorHandled != null) {
          _chooseErrorTransition(_modelErrorHandled);
          if (inModalModel) {
            director.setModelTime(environmentTime);
          }
          return;
        }
      }
      if (inModalModel) {
        director.setModelTime(environmentTime);
      }
      readOutputsFromRefinement();
      if (_debugging) {
        _debug(""String_Node_Str"");
      }
      List<Transition> terminationTransitions=_currentState.terminationTransitionList();
      boolean checkTerminationTransitions=false;
      if (terminationTransitions.size() > 0) {
        TypedActor[] refinements=_currentState.getRefinement();
        if (refinements != null && refinements.length > 0) {
          checkTerminationTransitions=true;
          for (          Actor refinementActor : refinements) {
            if (refinementActor instanceof ModalRefinement) {
              ModalRefinement refinement=(ModalRefinement)refinementActor;
              FSMActor refinementController=refinement.getController();
              State destinationState=refinementController._destinationState();
              if (!((BooleanToken)refinementController.currentState().isFinalState.getToken()).booleanValue() && (destinationState == null || !((BooleanToken)destinationState.isFinalState.getToken()).booleanValue())) {
                checkTerminationTransitions=false;
                break;
              }
            }
 else {
              checkTerminationTransitions=false;
              break;
            }
          }
        }
      }
      if (checkTerminationTransitions) {
        _chooseTransitions(_currentState.nonpreemptiveTransitionList(),false,false,false,false);
      }
 else {
        _chooseTransitions(transitionList,false,false,false,false);
      }
    }
  }
  _assertAbsentOutputs(this);
}"
72713,"/** 
 * Execute all set actions contained by the transition chosen from the current state. Change current state to the destination state of the last of these chosen transitions. If the new current state is a transient state that has a chosen transition emanating from it, then also execute the set actions on that transition. Reset the refinement of the destination state if the <i>reset</i> parameter of the chosen transition is true.
 * @param inPreinitialize If true, then only set the currentstate after following immediate transitions. Note that the guards on the immediate transitions need to be evaluatable.
 * @param inInitialize True when this method is calledfrom initialize or preinitialize, in which case, firing and initializing refinements is not allowed; note that the refinements will be initialized by the initialize method, but this prevents them from being initialized more than once. This could be important if, for example, the refinement produces an output during initialize in a domain where outputs are consumed, such as SDF.
 * @exception IllegalActionException If any commit action throws it,or the last chosen transition does not have a destination state.
 */
private void _commitLastChosenTransition(boolean inPreinitialize,boolean inInitialize) throws IllegalActionException {
  Transition currentTransition=_lastChosenTransitions.get(_currentState);
  if (currentTransition == null) {
    return;
  }
  _lastTakenTransitions.add(currentTransition);
  _lastChosenTransitions.remove(_currentState);
  if (_debugging) {
    _debug(""String_Node_Str"",currentTransition.getFullName() + ""String_Node_Str"" + getDirector().getModelTime());
    _debug(""String_Node_Str"" + currentTransition.guardExpression.getExpression());
  }
  if (currentTransition.destinationState() == null) {
    throw new IllegalActionException(this,currentTransition,""String_Node_Str"" + ""String_Node_Str"");
  }
  Iterator actions=currentTransition.commitActionList().iterator();
  while (actions.hasNext() && !_stopRequested) {
    Action action=(Action)actions.next();
    action.execute();
  }
  State nextState=currentTransition.destinationState();
  if (_lastChosenTransitions.get(nextState) == null) {
    if (!currentTransition.isHistory() && !inPreinitialize && !inInitialize) {
      _initializeRefinements(nextState);
    }
  }
  boolean stateChanged=_currentState != currentTransition.destinationState();
  _schedule(nextState,getDirector().getModelTime());
  _currentState=nextState;
  if (stateChanged) {
    _oldThreshold=0.0;
  }
  if (_debugging) {
    _debug(new StateEvent(this,_currentState));
  }
  _timeOfNextTimeoutExpiration=null;
  _timeEnteredCurrentState=getDirector().getModelTime();
  if (((BooleanToken)_currentState.isFinalState.getToken()).booleanValue()) {
    _reachedFinalState=true;
  }
  _setCurrentConnectionMap();
  boolean stateDependent=((BooleanToken)stateDependentCausality.getToken()).booleanValue();
  if (stateDependent && stateChanged) {
    ChangeRequest request=new ChangeRequest(this,""String_Node_Str"",false){
      protected void _execute(){
        getDirector().invalidateSchedule();
      }
    }
;
    request.setPersistent(false);
    requestChange(request);
  }
  if (!inPreinitialize) {
    getDirector().fireAtCurrentTime(this);
  }
  if (!_reachedFinalState && stateChanged) {
    _commitLastChosenTransition(inPreinitialize,inInitialize);
  }
 else {
    _lastChosenTransitions.clear();
  }
}","/** 
 * Execute all set actions contained by the transition chosen from the current state. Change current state to the destination state of the last of these chosen transitions. If the new current state is a transient state that has a chosen transition emanating from it, then also execute the set actions on that transition. Reset the refinement of the destination state if the <i>reset</i> parameter of the chosen transition is true.
 * @param inPreinitialize If true, then only set the currentstate after following immediate transitions. Note that the guards on the immediate transitions need to be evaluatable.
 * @param inInitialize True when this method is calledfrom initialize or preinitialize, in which case, firing and initializing refinements is not allowed; note that the refinements will be initialized by the initialize method, but this prevents them from being initialized more than once. This could be important if, for example, the refinement produces an output during initialize in a domain where outputs are consumed, such as SDF.
 * @exception IllegalActionException If any commit action throws it,or the last chosen transition does not have a destination state.
 */
private void _commitLastChosenTransition(boolean inPreinitialize,boolean inInitialize) throws IllegalActionException {
  Transition currentTransition=_lastChosenTransitions.get(_currentState);
  if (currentTransition == null) {
    return;
  }
  _lastTakenTransitions.add(currentTransition);
  _lastChosenTransitions.remove(_currentState);
  if (_debugging) {
    _debug(""String_Node_Str"",currentTransition.getFullName() + ""String_Node_Str"" + getDirector().getModelTime());
    _debug(""String_Node_Str"" + currentTransition.guardExpression.getExpression());
  }
  if (currentTransition.destinationState() == null) {
    throw new IllegalActionException(this,currentTransition,""String_Node_Str"" + ""String_Node_Str"");
  }
  Iterator actions=currentTransition.commitActionList().iterator();
  while (actions.hasNext() && !_stopRequested) {
    Action action=(Action)actions.next();
    action.execute();
  }
  State nextState=currentTransition.destinationState();
  if (_lastChosenTransitions.get(nextState) == null) {
    if (!currentTransition.isHistory() && !inPreinitialize && !inInitialize) {
      _initializeRefinements(nextState);
    }
  }
  boolean stateChanged=_currentState != currentTransition.destinationState();
  _schedule(nextState,getExecutiveDirector().getModelTime());
  System.out.println(getExecutiveDirector().getModelTime() + ""String_Node_Str"" + nextState.getName());
  _currentState=nextState;
  if (stateChanged) {
    _oldThreshold=0.0;
  }
  if (_debugging) {
    _debug(new StateEvent(this,_currentState));
  }
  _timeOfNextTimeoutExpiration=null;
  _timeEnteredCurrentState=getDirector().getModelTime();
  if (((BooleanToken)_currentState.isFinalState.getToken()).booleanValue()) {
    _reachedFinalState=true;
  }
  _setCurrentConnectionMap();
  boolean stateDependent=((BooleanToken)stateDependentCausality.getToken()).booleanValue();
  if (stateDependent && stateChanged) {
    ChangeRequest request=new ChangeRequest(this,""String_Node_Str"",false){
      protected void _execute(){
        getDirector().invalidateSchedule();
      }
    }
;
    request.setPersistent(false);
    requestChange(request);
  }
  if (!inPreinitialize) {
    getDirector().fireAtCurrentTime(this);
  }
  if (!_reachedFinalState && stateChanged) {
    _commitLastChosenTransition(inPreinitialize,inInitialize);
  }
 else {
    _lastChosenTransitions.clear();
  }
}"
72714,"/** 
 * Override the base class to adjust the number of contained actors, if the number is no longer correct.
 * @param port The port that has connection changes.
 */
public void connectionsChanged(Port port){
  super.connectionsChanged(port);
  if (port == input) {
    Manager manager=getManager();
    if (manager != null && manager.getState() != Manager.IDLE && manager.getState() != Manager.INFERING_WIDTHS && manager.getState() != Manager.PREINITIALIZING) {
      _reinitializeInnerActors();
    }
  }
}","/** 
 * Override the base class to adjust the number of contained actors, if the number is no longer correct.
 * @param port The port that has connection changes.
 */
public void connectionsChanged(Port port){
  super.connectionsChanged(port);
  if (port == input) {
    Manager manager=getManager();
    if (manager != null) {
      Manager.State managerState=manager.getState();
      if (managerState == Manager.ITERATING || managerState == Manager.PAUSED || managerState == Manager.PAUSED_ON_BREAKPOINT) {
        _reinitializeInnerActors();
      }
    }
  }
}"
72715,"/** 
 * Open a URL of web service that is protected by OAuth 2.0.
 * @param url The protected URL on a Resource server. Usually this is some kind of RESTful API.
 * @param accessToken The code used to prove access authorization to the Resource server.
 * @return
 * @throws IllegalActionException 
 */
public String readProtectedURL(String url,String accessToken) throws IllegalActionException {
  OAuthResourceResponse resourceResponse=null;
  try {
    OAuthClientRequest bearerClientRequest=new OAuthBearerClientRequest(url).setAccessToken(accessToken).buildQueryMessage();
    OAuthClient client=new OAuthClient(new URLConnectionClient());
    resourceResponse=client.resource(bearerClientRequest,OAuth.HttpMethod.GET,OAuthResourceResponse.class);
  }
 catch (  OAuthSystemException ex) {
    throw new IllegalActionException(null,ex,""String_Node_Str"" + ex.getMessage());
  }
catch (  OAuthProblemException ex2) {
    throw new IllegalActionException(null,ex2,""String_Node_Str"" + ex2.getMessage());
  }
  if (resourceResponse != null) {
    if (resourceResponse.getResponseCode() == 200) {
      return resourceResponse.getBody();
    }
  }
  return ""String_Node_Str"" + resourceResponse.getResponseCode() + ""String_Node_Str""+ resourceResponse.getBody();
}","/** 
 * Open a URL of web service that is protected by OAuth 2.0.
 * @param url The protected URL on a Resource server. Usually this is some kind of RESTful API.
 * @param accessToken The code used to prove access authorization to the Resource server.
 * @return
 * @throws IllegalActionException 
 */
public String readProtectedURL(String url,String accessToken) throws IllegalActionException {
  OAuthResourceResponse resourceResponse=null;
  try {
    OAuthClientRequest bearerClientRequest=new OAuthBearerClientRequest(url).setAccessToken(accessToken).buildQueryMessage();
    OAuthClient client=new OAuthClient(new URLConnectionClient());
    resourceResponse=client.resource(bearerClientRequest,OAuth.HttpMethod.GET,OAuthResourceResponse.class);
  }
 catch (  OAuthSystemException ex) {
    throw new IllegalActionException(null,ex,""String_Node_Str"" + ex.getMessage());
  }
catch (  OAuthProblemException ex2) {
    throw new IllegalActionException(null,ex2,""String_Node_Str"" + ex2.getMessage());
  }
  if (resourceResponse != null) {
    if (resourceResponse.getResponseCode() == 200) {
      return resourceResponse.getBody();
    }
 else {
      return ""String_Node_Str"" + resourceResponse.getResponseCode() + ""String_Node_Str""+ resourceResponse.getBody();
    }
  }
 else {
    throw new IllegalActionException(""String_Node_Str"");
  }
}"
72716,"/** 
 * Send the current value of the state of this actor to the output.
 * @exception IllegalActionException If calling send() or super.fire()throws it.
 */
@Override public void fire() throws IllegalActionException {
  super.fire();
  for (  PortParameter portParameter : attributeList(PortParameter.class)) {
    portParameter.update();
  }
  try {
    if (scriptIn.getWidth() > 0 && scriptIn.hasToken(0)) {
      String scriptValue=((StringToken)scriptIn.get(0)).stringValue();
      _compiledScript=_context.compileString(scriptValue,getName(),1,null);
      _compiledScript.exec(Context.getCurrentContext(),_scope);
      Object initializeFunction=_scope.get(""String_Node_Str"",_scope);
      if (initializeFunction instanceof Function) {
        ((Function)initializeFunction).call(Context.getCurrentContext(),_scope,_global,null);
      }
    }
    Object fireFunction=_scope.get(""String_Node_Str"",_scope);
    if (fireFunction instanceof Function) {
      for (      IOPort port : _outputTokens.keySet()) {
        HashMap<Integer,Token> tokens=_outputTokens.get(port);
        for (        Integer i : tokens.keySet()) {
          Token token=tokens.get(i);
          port.send(i,token);
        }
      }
      _outputTokens.clear();
      _inputTokens.clear();
      for (      IOPort input : this.inputPortList()) {
        HashMap<Integer,Token> tokens=new HashMap<Integer,Token>();
        for (int i=0; i < input.getWidth(); i++) {
          tokens.put(i,input.get(i));
        }
        _inputTokens.put(input,tokens);
      }
      _inFire=true;
      ((Function)fireFunction).call(Context.getCurrentContext(),_scope,_global,null);
      _inFire=false;
    }
  }
 catch (  WrappedException ex) {
    Throwable original=ex.getWrappedException();
    throw new IllegalActionException(this,ex,""String_Node_Str"" + ex.lineNumber() + ""String_Node_Str""+ original.getMessage());
  }
}","/** 
 * Send the current value of the state of this actor to the output.
 * @exception IllegalActionException If calling send() or super.fire()throws it.
 */
@Override public void fire() throws IllegalActionException {
  super.fire();
  for (  PortParameter portParameter : attributeList(PortParameter.class)) {
    portParameter.update();
  }
  try {
    if (scriptIn.getWidth() > 0 && scriptIn.hasToken(0)) {
      String scriptValue=((StringToken)scriptIn.get(0)).stringValue();
      _compiledScript=_context.compileString(scriptValue,getName(),1,null);
      _compiledScript.exec(Context.getCurrentContext(),_scope);
      Object initializeFunction=_scope.get(""String_Node_Str"",_scope);
      if (initializeFunction instanceof Function) {
        ((Function)initializeFunction).call(Context.getCurrentContext(),_scope,_global,null);
      }
    }
    Object fireFunction=_scope.get(""String_Node_Str"",_scope);
    if (fireFunction instanceof Function) {
      for (      IOPort port : _outputTokens.keySet()) {
        HashMap<Integer,Token> tokens=_outputTokens.get(port);
        for (        Map.Entry<Integer,Token> entry : tokens.entrySet()) {
          port.send(entry.getKey(),entry.getValue());
        }
      }
      _outputTokens.clear();
      _inputTokens.clear();
      for (      IOPort input : this.inputPortList()) {
        HashMap<Integer,Token> tokens=new HashMap<Integer,Token>();
        for (int i=0; i < input.getWidth(); i++) {
          tokens.put(i,input.get(i));
        }
        _inputTokens.put(input,tokens);
      }
      _inFire=true;
      ((Function)fireFunction).call(Context.getCurrentContext(),_scope,_global,null);
      _inFire=false;
    }
  }
 catch (  WrappedException ex) {
    Throwable original=ex.getWrappedException();
    throw new IllegalActionException(this,ex,""String_Node_Str"" + ex.lineNumber() + ""String_Node_Str""+ original.getMessage());
  }
}"
72717,"protected void _updateEstimates(){
  _transitionMatrix=A_new;
  _sigma=s_new;
  _mu=m_new;
  _priorIn=_priors;
  _D=D_new;
  _durationPriors=dPrior_new;
}","protected void _updateEstimates(){
  _transitionMatrix=A_new;
  _sigma=s_new;
  _mu=m_new;
  _priorIn=prior_new;
  _D=D_new;
  _durationPriors=dPrior_new;
}"
72718,"protected boolean _checkForConvergence(int iterations){
  if ((m_new[0] != m_new[0]) || (s_new[0] != s_new[0]) || (A_new[0] != A_new[0])|| (prior_new[0] != prior_new[0])) {
    if ((iterations >= _nIterations - 1)) {
      m_new=_mu0;
      s_new=_sigma0;
      A_new=_A0;
      prior_new=_priors;
      System.out.println(""String_Node_Str"");
      return false;
    }
 else     if (_randomize) {
      double minO=_observations[0];
      double maxO=_observations[0];
      for (int t=0; t < _observations.length; t++) {
        if (_observations[t] < minO) {
          minO=_observations[t];
        }
        if (_observations[t] > maxO) {
          maxO=_observations[t];
        }
      }
      double L=maxO - minO;
      for (int i=0; i < _nStates; i++) {
        m_new[i]=L / _nStates * Math.random() + L * i / _nStates + minO;
        s_new[i]=Math.abs((maxO - minO) * Math.random()) / _nStates;
        for (int j=0; j < _nStates; j++) {
        }
      }
      A_new=_A0;
      Arrays.sort(m_new);
      prior_new=_priors;
    }
  }
  return true;
}","protected boolean _checkForConvergence(int iterations){
  boolean nanDetected=false;
  for (int i=0; i < m_new.length; i++) {
    if ((m_new[i] != m_new[i]) || (s_new[i] != s_new[i]) || (A_new[i][i] != A_new[i][i])|| (prior_new[i] != prior_new[i])|| (D_new[i] != D_new[i])) {
      nanDetected=true;
      break;
    }
  }
  if (nanDetected) {
    if ((iterations >= _nIterations - 1)) {
      m_new=_mu0;
      s_new=_sigma0;
      A_new=_A0;
      prior_new=_priors;
      _D=_D0;
      _durationPriors=_dPriors0;
      System.out.println(""String_Node_Str"");
      return false;
    }
 else     if (_randomize) {
      double minO=_observations[0];
      double maxO=_observations[0];
      for (int t=0; t < _observations.length; t++) {
        if (_observations[t] < minO) {
          minO=_observations[t];
        }
        if (_observations[t] > maxO) {
          maxO=_observations[t];
        }
      }
      double L=maxO - minO;
      for (int i=0; i < _nStates; i++) {
        m_new[i]=L / _nStates * Math.random() + L * i / _nStates + minO;
        s_new[i]=Math.abs((maxO - minO) * Math.random()) / _nStates;
        for (int j=0; j < _nStates; j++) {
        }
      }
      A_new=_A0;
      Arrays.sort(m_new);
      prior_new=_priors;
    }
 else {
      System.out.println(""String_Node_Str"");
      return false;
    }
  }
  return true;
}"
72719,"public void fire() throws IllegalActionException {
  super.fire();
  if ((_nStates != _sigma0.length) || (_nStates != _transitionMatrix.length) || (_nStates != _priors.length)|| (_nStates != _mu0.length)) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  _EMParameterEstimation();
  int _nObservations=_observations.length;
  Token[] mTokens=new Token[_nStates];
  Token[] sTokens=new Token[_nStates];
  Token[] pTokens=new Token[_nStates];
  Token[] cTokens=new Token[_nObservations];
  Token[] dTokens=new Token[_maxDuration];
  for (int i=0; i < _nStates; i++) {
    mTokens[i]=new DoubleToken(m_new[i]);
    sTokens[i]=new DoubleToken(s_new[i]);
    pTokens[i]=new DoubleToken(prior_new[i]);
  }
  for (int i=0; i < _maxDuration; i++) {
    dTokens[i]=new DoubleToken(dPrior_new[i]);
  }
  for (int i=0; i < _nObservations; i++) {
    cTokens[i]=new IntToken(clusters[i]);
  }
  mean.send(0,new ArrayToken(mTokens));
  standardDeviation.send(0,new ArrayToken(sTokens));
  transitionMatrix.send(0,new DoubleMatrixToken(A_new));
  priorEstimates.send(0,new ArrayToken(pTokens));
  durationEstimates.send(0,new DoubleMatrixToken(D_new));
  clusterAssignments.send(0,new ArrayToken(cTokens));
  durationPriorEstimates.send(0,new ArrayToken(dTokens));
}","public void fire() throws IllegalActionException {
  super.fire();
  if ((_nStates != _sigma0.length) || (_nStates != _transitionMatrix.length) || (_nStates != _priors.length)|| (_nStates != _mu0.length)) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  _EMParameterEstimation();
  int _nObservations=_observations.length;
  Token[] mTokens=new Token[_nStates];
  Token[] sTokens=new Token[_nStates];
  Token[] pTokens=new Token[_nStates];
  Token[] cTokens=new Token[_nObservations];
  Token[] dTokens=new Token[_maxDuration];
  Token[] lTokens=new Token[_likelihoodHistory.size()];
  for (int i=0; i < _nStates; i++) {
    mTokens[i]=new DoubleToken(m_new[i]);
    sTokens[i]=new DoubleToken(s_new[i]);
    pTokens[i]=new DoubleToken(prior_new[i]);
  }
  for (int i=0; i < _maxDuration; i++) {
    dTokens[i]=new DoubleToken(dPrior_new[i]);
  }
  for (int i=0; i < _nObservations; i++) {
    cTokens[i]=new IntToken(clusters[i]);
  }
  for (int i=0; i < lTokens.length; i++) {
    lTokens[i]=new DoubleToken(_likelihoodHistory.get(i));
  }
  _likelihoodHistory.clear();
  mean.send(0,new ArrayToken(mTokens));
  standardDeviation.send(0,new ArrayToken(sTokens));
  transitionMatrix.send(0,new DoubleMatrixToken(A_new));
  priorEstimates.send(0,new ArrayToken(pTokens));
  durationEstimates.send(0,new DoubleMatrixToken(D_new));
  clusterAssignments.send(0,new ArrayToken(cTokens));
  durationPriorEstimates.send(0,new ArrayToken(dTokens));
  modelLikelihood.send(0,new ArrayToken(lTokens));
}"
72720,"/** 
 * Get inputs via an input port.
 * @param portWrapper A JavaScript wrapper for a Port.
 * @param channel A channel number, or NaN to use the default (0).
 */
public Object get(NativeJavaObject portWrapper,Double channel){
  int channelNumber=0;
  if (channel != null && !channel.isNaN()) {
    if (channel.doubleValue() % 1 == 0) {
      channelNumber=channel.intValue();
    }
 else {
      throw new InternalErrorException(JavaScript.this,null,""String_Node_Str"" + channel);
    }
  }
  Object unwrappedPort=portWrapper.unwrap();
  if (unwrappedPort instanceof TypedIOPort) {
    TypedIOPort port=(TypedIOPort)unwrappedPort;
    if (!port.isInput()) {
      throw new InternalErrorException(JavaScript.this,null,""String_Node_Str"" + port.getName() + ""String_Node_Str"");
    }
    try {
      if (port.getWidth() < 1) {
        return null;
      }
      if (!port.hasToken(channelNumber)) {
        return null;
      }
      return _wrapToken(port.get(channelNumber));
    }
 catch (    KernelException e) {
      throw new InternalErrorException(JavaScript.this,e,""String_Node_Str"" + port.getName() + ""String_Node_Str"");
    }
  }
 else {
    throw new InternalErrorException(JavaScript.this,null,""String_Node_Str"" + unwrappedPort.toString() + ""String_Node_Str"");
  }
}","/** 
 * Get inputs via an input port.
 * @param portWrapper A JavaScript wrapper for a Port.
 * @param channel A channel number, or NaN to use the default (0).
 */
public Object get(NativeJavaObject portWrapper,Double channel){
  int channelNumber=0;
  if (channel != null && !channel.isNaN()) {
    if (channel.doubleValue() % 1 == 0) {
      channelNumber=channel.intValue();
    }
 else {
      throw new InternalErrorException(JavaScript.this,null,""String_Node_Str"" + channel);
    }
  }
  Object unwrappedPort=portWrapper.unwrap();
  if (unwrappedPort instanceof TypedIOPort) {
    TypedIOPort port=(TypedIOPort)unwrappedPort;
    if (!port.isInput()) {
      throw new InternalErrorException(JavaScript.this,null,""String_Node_Str"" + port.getName() + ""String_Node_Str"");
    }
    try {
      if (port.getWidth() < 1) {
        return null;
      }
      if (!port.hasToken(channelNumber)) {
        return null;
      }
      return _wrapToken(port.get(channelNumber));
    }
 catch (    KernelException e) {
      throw new InternalErrorException(JavaScript.this,e,""String_Node_Str"" + port.getName() + ""String_Node_Str"");
    }
  }
 else   if (unwrappedPort instanceof PortParameter) {
    try {
      PortParameter parameter=(PortParameter)unwrappedPort;
      return _wrapToken(parameter.getToken());
    }
 catch (    KernelException e) {
      throw new InternalErrorException(JavaScript.this,e,""String_Node_Str"" + ((PortParameter)unwrappedPort).getName() + ""String_Node_Str"");
    }
  }
 else {
    throw new InternalErrorException(JavaScript.this,null,""String_Node_Str"" + unwrappedPort.toString() + ""String_Node_Str"");
  }
}"
72721,"/** 
 * Generate code for making transition. It generates code for both choice action and commit action.
 * @param code The string buffer that the generated code is appended to.
 * @param transitionRetriever An instance of a class implementinga method. which returns an iterator of all, preemptive or non-preemptive transitions of the current state.
 * @exception IllegalActionException If thrown while generatingtransition code.
 */
public void generateTransitionCode(StringBuffer code,TransitionRetriever transitionRetriever) throws IllegalActionException {
  StringBuffer codeBuffer=new StringBuffer();
  codeBuffer.append(getCodeGenerator().comment(""String_Node_Str""));
  ptolemy.domains.modal.kernel.FSMActor fsmActor=(ptolemy.domains.modal.kernel.FSMActor)getComponent();
  String name=fsmActor.getFullName().substring(1);
  String modalName=name.replace(""String_Node_Str"",""String_Node_Str"");
  modalName=modalName.replace('.','_').replace(' ','_');
  codeBuffer.append(getCodeGenerator().comment(""String_Node_Str""));
  codeBuffer.append(_eol + modalName + ""String_Node_Str""+ _eol);
  codeBuffer.append(""String_Node_Str"" + _eol + ""String_Node_Str""+ _eol);
  for (  State state : (List<State>)fsmActor.entityList()) {
    codeBuffer.append(""String_Node_Str"" + _generateStateConstantLabel(state) + ""String_Node_Str""+ _eol);
    Iterator transitions=transitionRetriever.retrieveTransitions(state);
    List reOrderedTransitions=new LinkedList();
    List defaultTransitions=new LinkedList();
    while (transitions.hasNext()) {
      Transition transition=(Transition)transitions.next();
      if (generateSimpleName(transition).equals(""String_Node_Str"")) {
        defaultTransitions.add(transition);
      }
 else {
        reOrderedTransitions.add(transition);
      }
    }
    reOrderedTransitions.addAll(defaultTransitions);
    transitions=reOrderedTransitions.iterator();
    int transitionCount=0;
    boolean hasDefaultCase=false;
    while (!hasDefaultCase && transitions.hasNext()) {
      Transition transition=(Transition)transitions.next();
      String guard=transition.getGuardExpression();
      if (transition.isDefault() || guard.toLowerCase(Locale.getDefault()).equals(""String_Node_Str"")) {
        hasDefaultCase=true;
      }
 else {
        if (transitionCount == 0) {
          codeBuffer.append(""String_Node_Str"");
        }
 else {
          codeBuffer.append(""String_Node_Str"");
        }
        transitionCount++;
        PtParser parser=new PtParser();
        ASTPtRootNode guardParseTree=parser.generateParseTree(guard);
        if (getTemplateParser() == null) {
          if (getCodeGenerator() == null) {
            throw new InternalErrorException(this,null,""String_Node_Str"");
          }
          getCodeGenerator().getAdapter(fsmActor);
        }
        ParseTreeCodeGenerator parseTreeCodeGenerator=getTemplateParser().getParseTreeCodeGenerator();
        parseTreeCodeGenerator.evaluateParseTree(guardParseTree,_scope);
        codeBuffer.append(parseTreeCodeGenerator.generateFireCode());
        codeBuffer.append(""String_Node_Str"");
      }
      codeBuffer.append(_eol + ""String_Node_Str"" + _eol);
      for (      AbstractActionsAttribute action : (List<AbstractActionsAttribute>)transition.choiceActionList()) {
        Iterator channelNumberList=action.getChannelNumberList().iterator();
        Iterator parseTreeList=action.getParseTreeList().iterator();
        for (        String destinationName : (List<String>)action.getDestinationNameList()) {
          Integer channelNumber=(Integer)channelNumberList.next();
          ASTPtRootNode parseTree=(ASTPtRootNode)parseTreeList.next();
          NamedObj destination=action.getDestination(destinationName);
          int channel=-1;
          if (channelNumber != null) {
            channel=channelNumber.intValue();
          }
          StringBuffer sendCode=new StringBuffer();
          if (channel >= 0) {
            codeBuffer.append(""String_Node_Str"" + destinationName + ""String_Node_Str""+ channel+ ""String_Node_Str"");
            if (((IOPort)destination).isInput()) {
              NamedProgramCodeGeneratorAdapter containerHelper=(NamedProgramCodeGeneratorAdapter)getCodeGenerator().getAdapter(((IOPort)destination).getContainer().getContainer());
              StringBuffer containerReference=new StringBuffer();
              containerReference.append(""String_Node_Str"" + generateSimpleName(destination));
              if (((IOPort)destination).isMultiport()) {
                containerReference.append(""String_Node_Str"" + channel);
              }
              containerReference.append(""String_Node_Str"");
              codeBuffer.append(containerHelper.processCode(containerReference.toString()) + ""String_Node_Str"");
              sendCode.append(""String_Node_Str"" + destinationName + ""String_Node_Str""+ channel+ ""String_Node_Str""+ _eol);
            }
          }
 else {
            int width=((IOPort)action.getDestination(destinationName)).getWidth();
            for (int i=0; i < width; i++) {
              codeBuffer.append(""String_Node_Str"" + destinationName + ""String_Node_Str""+ i+ ""String_Node_Str"");
              if (((IOPort)destination).isInput()) {
                NamedProgramCodeGeneratorAdapter containerHelper=(NamedProgramCodeGeneratorAdapter)getCodeGenerator().getAdapter(((IOPort)destination).getContainer().getContainer());
                StringBuffer containerReference=new StringBuffer();
                containerReference.append(""String_Node_Str"" + generateSimpleName(destination));
                if (((IOPort)destination).isMultiport()) {
                  containerReference.append(""String_Node_Str"" + i);
                }
                containerReference.append(""String_Node_Str"");
                codeBuffer.append(containerHelper.processCode(containerReference.toString()) + ""String_Node_Str"");
              }
            }
          }
          ParseTreeCodeGenerator parseTreeCodeGenerator=getTemplateParser().getParseTreeCodeGenerator();
          parseTreeCodeGenerator.evaluateParseTree(parseTree,_scope);
          codeBuffer.append(parseTreeCodeGenerator.generateFireCode());
          codeBuffer.append(""String_Node_Str"" + _eol);
        }
      }
      Actor[] actors=transition.getRefinement();
      if (actors != null) {
        for (        Actor actor : actors) {
          NamedProgramCodeGeneratorAdapter helper=(NamedProgramCodeGeneratorAdapter)getAdapter(actor);
          codeBuffer.append(helper.generateFireCode());
        }
      }
      for (      AbstractActionsAttribute action : (List<AbstractActionsAttribute>)transition.commitActionList()) {
        Iterator channelNumberList=action.getChannelNumberList().iterator();
        Iterator parseTreeList=action.getParseTreeList().iterator();
        for (        String destinationName : (List<String>)action.getDestinationNameList()) {
          Integer channelNumber=(Integer)channelNumberList.next();
          ASTPtRootNode parseTree=(ASTPtRootNode)parseTreeList.next();
          NamedObj destination=action.getDestination(destinationName);
          int channel=-1;
          if (channelNumber != null) {
            channel=channelNumber.intValue();
          }
          ParseTreeCodeGenerator parseTreeCodeGenerator=getTemplateParser().getParseTreeCodeGenerator();
          parseTreeCodeGenerator.evaluateParseTree(parseTree,_scope);
          String scopeFireCode=parseTreeCodeGenerator.generateFireCode();
          if (destination instanceof IOPort) {
            if (channel >= 0) {
              codeBuffer.append(""String_Node_Str"" + destinationName + ""String_Node_Str""+ channel+ ""String_Node_Str""+ scopeFireCode+ ""String_Node_Str"");
            }
 else {
              int width=((IOPort)action.getDestination(destinationName)).getWidth();
              for (int i=0; i < width; i++) {
                codeBuffer.append(""String_Node_Str"" + destinationName + ""String_Node_Str""+ i+ ""String_Node_Str""+ scopeFireCode+ ""String_Node_Str"");
              }
            }
          }
 else           if (destination instanceof Variable) {
            codeBuffer.append(getCodeGenerator().generateVariableName(destination) + ""String_Node_Str"" + scopeFireCode+ ""String_Node_Str"");
          }
        }
      }
      State destinationState=transition.destinationState();
      _updateCurrentState(codeBuffer,destinationState);
      if (!transition.isHistory()) {
        actors=destinationState.getRefinement();
        if (actors != null) {
          for (int i=0; i < actors.length; ++i) {
            NamedProgramCodeGeneratorAdapter helper=(NamedProgramCodeGeneratorAdapter)getAdapter(actors[i]);
            codeBuffer.append(helper.generateInitializeCode());
          }
        }
      }
      codeBuffer.append(_eol + ""String_Node_Str"" + _eol);
    }
    if (!hasDefaultCase) {
      if (transitionCount > 0) {
        codeBuffer.append(""String_Node_Str"" + _eol + ""String_Node_Str""+ _eol);
      }
 else {
        codeBuffer.append(_eol);
      }
      codeBuffer.append(_eol + modalName + ""String_Node_Str""+ _eol);
      if (transitionCount > 0) {
        codeBuffer.append(_eol + ""String_Node_Str"" + _eol);
      }
    }
    codeBuffer.append(_eol + ""String_Node_Str"" + _eol);
  }
  codeBuffer.append(_eol + ""String_Node_Str"" + _eol);
  code.append(TemplateParser.unescapeName(processCode(codeBuffer.toString())));
}","/** 
 * Generate code for making transition. It generates code for both choice action and commit action.
 * @param code The string buffer that the generated code is appended to.
 * @param transitionRetriever An instance of a class implementinga method. which returns an iterator of all, preemptive or non-preemptive transitions of the current state.
 * @exception IllegalActionException If thrown while generatingtransition code.
 */
public void generateTransitionCode(StringBuffer code,TransitionRetriever transitionRetriever) throws IllegalActionException {
  StringBuffer codeBuffer=new StringBuffer();
  codeBuffer.append(getCodeGenerator().comment(""String_Node_Str""));
  ptolemy.domains.modal.kernel.FSMActor fsmActor=(ptolemy.domains.modal.kernel.FSMActor)getComponent();
  String name=fsmActor.getFullName().substring(1);
  String modalName=name.replace(""String_Node_Str"",""String_Node_Str"");
  modalName=modalName.replace('.','_').replace(' ','_');
  codeBuffer.append(getCodeGenerator().comment(""String_Node_Str""));
  codeBuffer.append(_eol + modalName + ""String_Node_Str""+ _eol);
  codeBuffer.append(""String_Node_Str"" + _eol + ""String_Node_Str""+ _eol);
  for (  State state : (List<State>)fsmActor.entityList()) {
    codeBuffer.append(""String_Node_Str"" + _generateStateConstantLabel(state) + ""String_Node_Str""+ _eol);
    Iterator transitions=transitionRetriever.retrieveTransitions(state);
    List reOrderedTransitions=new LinkedList();
    List defaultTransitions=new LinkedList();
    while (transitions.hasNext()) {
      Transition transition=(Transition)transitions.next();
      if (generateSimpleName(transition).equals(""String_Node_Str"")) {
        defaultTransitions.add(transition);
      }
 else {
        reOrderedTransitions.add(transition);
      }
    }
    reOrderedTransitions.addAll(defaultTransitions);
    transitions=reOrderedTransitions.iterator();
    int transitionCount=0;
    boolean hasDefaultCase=false;
    while (!hasDefaultCase && transitions.hasNext()) {
      Transition transition=(Transition)transitions.next();
      String guard=transition.getGuardExpression();
      if (transition.isDefault() || guard.toLowerCase(Locale.getDefault()).equals(""String_Node_Str"")) {
        hasDefaultCase=true;
      }
 else {
        if (transitionCount == 0) {
          codeBuffer.append(""String_Node_Str"");
        }
 else {
          codeBuffer.append(""String_Node_Str"");
        }
        transitionCount++;
        PtParser parser=new PtParser();
        ASTPtRootNode guardParseTree=parser.generateParseTree(guard);
        if (getTemplateParser() == null) {
          if (getCodeGenerator() == null) {
            throw new InternalErrorException(this,null,""String_Node_Str"");
          }
          getCodeGenerator().getAdapter(fsmActor);
        }
        ParseTreeCodeGenerator parseTreeCodeGenerator=getTemplateParser().getParseTreeCodeGenerator();
        parseTreeCodeGenerator.evaluateParseTree(guardParseTree,_scope);
        codeBuffer.append(parseTreeCodeGenerator.generateFireCode());
        codeBuffer.append(""String_Node_Str"");
      }
      codeBuffer.append(_eol + ""String_Node_Str"" + _eol);
      for (      AbstractActionsAttribute action : (List<AbstractActionsAttribute>)transition.choiceActionList()) {
        Iterator channelNumberList=action.getChannelNumberList().iterator();
        Iterator parseTreeList=action.getParseTreeList().iterator();
        for (        String destinationName : (List<String>)action.getDestinationNameList()) {
          Integer channelNumber=(Integer)channelNumberList.next();
          ASTPtRootNode parseTree=(ASTPtRootNode)parseTreeList.next();
          NamedObj destination=action.getDestination(destinationName);
          codeBuffer.append(destinationName + ""String_Node_Str"" + modalName+ ""String_Node_Str""+ destinationName+ ""String_Node_Str""+ _eol);
          int channel=-1;
          if (channelNumber != null) {
            channel=channelNumber.intValue();
          }
          StringBuffer sendCode=new StringBuffer();
          if (channel >= 0) {
            codeBuffer.append(""String_Node_Str"" + destinationName + ""String_Node_Str""+ channel+ ""String_Node_Str"");
            if (((IOPort)destination).isInput()) {
              NamedProgramCodeGeneratorAdapter containerHelper=(NamedProgramCodeGeneratorAdapter)getCodeGenerator().getAdapter(((IOPort)destination).getContainer().getContainer());
              StringBuffer containerReference=new StringBuffer();
              containerReference.append(""String_Node_Str"" + generateSimpleName(destination));
              if (((IOPort)destination).isMultiport()) {
                containerReference.append(""String_Node_Str"" + channel);
              }
              containerReference.append(""String_Node_Str"");
              codeBuffer.append(containerHelper.processCode(containerReference.toString()) + ""String_Node_Str"");
              sendCode.append(""String_Node_Str"" + destinationName + ""String_Node_Str""+ channel+ ""String_Node_Str""+ _eol);
            }
          }
 else {
            int width=((IOPort)action.getDestination(destinationName)).getWidth();
            for (int i=0; i < width; i++) {
              codeBuffer.append(""String_Node_Str"" + destinationName + ""String_Node_Str""+ i+ ""String_Node_Str"");
            }
          }
          ParseTreeCodeGenerator parseTreeCodeGenerator=getTemplateParser().getParseTreeCodeGenerator();
          parseTreeCodeGenerator.evaluateParseTree(parseTree,_scope);
          codeBuffer.append(parseTreeCodeGenerator.generateFireCode());
          codeBuffer.append(""String_Node_Str"" + _eol);
        }
      }
      Actor[] actors=transition.getRefinement();
      if (actors != null) {
        for (        Actor actor : actors) {
          NamedProgramCodeGeneratorAdapter helper=(NamedProgramCodeGeneratorAdapter)getAdapter(actor);
          codeBuffer.append(helper.generateFireCode());
        }
      }
      for (      AbstractActionsAttribute action : (List<AbstractActionsAttribute>)transition.commitActionList()) {
        Iterator channelNumberList=action.getChannelNumberList().iterator();
        Iterator parseTreeList=action.getParseTreeList().iterator();
        for (        String destinationName : (List<String>)action.getDestinationNameList()) {
          Integer channelNumber=(Integer)channelNumberList.next();
          ASTPtRootNode parseTree=(ASTPtRootNode)parseTreeList.next();
          NamedObj destination=action.getDestination(destinationName);
          int channel=-1;
          if (channelNumber != null) {
            channel=channelNumber.intValue();
          }
          ParseTreeCodeGenerator parseTreeCodeGenerator=getTemplateParser().getParseTreeCodeGenerator();
          parseTreeCodeGenerator.evaluateParseTree(parseTree,_scope);
          String scopeFireCode=parseTreeCodeGenerator.generateFireCode();
          if (destination instanceof IOPort) {
            if (channel >= 0) {
              codeBuffer.append(""String_Node_Str"" + destinationName + ""String_Node_Str""+ channel+ ""String_Node_Str""+ scopeFireCode+ ""String_Node_Str"");
            }
 else {
              int width=((IOPort)action.getDestination(destinationName)).getWidth();
              for (int i=0; i < width; i++) {
                codeBuffer.append(""String_Node_Str"" + destinationName + ""String_Node_Str""+ i+ ""String_Node_Str""+ scopeFireCode+ ""String_Node_Str"");
              }
            }
          }
 else           if (destination instanceof Variable) {
            codeBuffer.append(getCodeGenerator().generateVariableName(destination) + ""String_Node_Str"" + scopeFireCode+ ""String_Node_Str"");
          }
        }
      }
      State destinationState=transition.destinationState();
      _updateCurrentState(codeBuffer,destinationState);
      if (!transition.isHistory()) {
        actors=destinationState.getRefinement();
        if (actors != null) {
          for (int i=0; i < actors.length; ++i) {
            NamedProgramCodeGeneratorAdapter helper=(NamedProgramCodeGeneratorAdapter)getAdapter(actors[i]);
            codeBuffer.append(helper.generateInitializeCode());
          }
        }
      }
      codeBuffer.append(_eol + ""String_Node_Str"" + _eol);
    }
    if (!hasDefaultCase) {
      if (transitionCount > 0) {
        codeBuffer.append(""String_Node_Str"" + _eol + ""String_Node_Str""+ _eol);
      }
 else {
        codeBuffer.append(_eol);
      }
      codeBuffer.append(_eol + modalName + ""String_Node_Str""+ _eol);
      if (transitionCount > 0) {
        codeBuffer.append(_eol + ""String_Node_Str"" + _eol);
      }
    }
    codeBuffer.append(_eol + ""String_Node_Str"" + _eol);
  }
  codeBuffer.append(_eol + ""String_Node_Str"" + _eol);
  code.append(TemplateParser.unescapeName(processCode(codeBuffer.toString())));
}"
72722,"/** 
 * Generate code for the firing of refinements.
 * @param code The string buffer that the generated code is appended to.
 * @exception IllegalActionException If the helper associated withan actor throws it while generating fire code for the actor.
 */
protected void _generateRefinementCode(StringBuffer code) throws IllegalActionException {
  ProgramCodeGeneratorAdapter controllerHelper=(ProgramCodeGeneratorAdapter)getCodeGenerator().getAdapter(_myController);
  int depth=1;
  code.append(_getIndentPrefix(depth));
  code.append(""String_Node_Str"" + controllerHelper.processCode(""String_Node_Str"") + ""String_Node_Str""+ _eol);
  Iterator states=_myController.entityList().iterator();
  int stateCount=0;
  depth++;
  while (states.hasNext()) {
    code.append(_getIndentPrefix(depth));
    code.append(""String_Node_Str"" + stateCount + ""String_Node_Str""+ _eol);
    stateCount++;
    depth++;
    State state=(State)states.next();
    Actor[] actors=state.getRefinement();
    if (actors != null) {
      for (      Actor actor : actors) {
        NamedProgramCodeGeneratorAdapter actorHelper=(NamedProgramCodeGeneratorAdapter)getCodeGenerator().getAdapter(actor);
        code.append(actorHelper.generateFireCode());
        List<IOPort> outputPorts=actor.outputPortList();
        for (        IOPort outputPort : outputPorts) {
          String source=outputPort.getFullName().substring(1).replace(""String_Node_Str"",""String_Node_Str"");
          int k=source.lastIndexOf(""String_Node_Str"");
          int l=source.substring(0,k).lastIndexOf(""String_Node_Str"");
          String destination=source.substring(0,l) + ""String_Node_Str"" + source.substring(k);
          code.append(_eol + getCodeGenerator().generatePortName((TypedIOPort)outputPort,destination,1) + ""String_Node_Str""+ getCodeGenerator().generatePortName((TypedIOPort)outputPort,source,1)+ ""String_Node_Str""+ _eol);
        }
      }
    }
    code.append(_getIndentPrefix(depth));
    code.append(""String_Node_Str"" + _eol);
    depth--;
  }
  depth--;
  code.append(_getIndentPrefix(depth));
  code.append(""String_Node_Str"" + _eol);
}","/** 
 * Generate code for the firing of refinements.
 * @param code The string buffer that the generated code is appended to.
 * @exception IllegalActionException If the helper associated withan actor throws it while generating fire code for the actor.
 */
protected boolean _generateRefinementCode(StringBuffer code) throws IllegalActionException {
  ProgramCodeGeneratorAdapter controllerHelper=(ProgramCodeGeneratorAdapter)getCodeGenerator().getAdapter(_myController);
  boolean refined=false;
  int depth=1;
  code.append(_getIndentPrefix(depth));
  code.append(""String_Node_Str"" + controllerHelper.processCode(""String_Node_Str"") + ""String_Node_Str""+ _eol);
  Iterator states=_myController.entityList().iterator();
  int stateCount=0;
  depth++;
  while (states.hasNext()) {
    code.append(_getIndentPrefix(depth));
    code.append(""String_Node_Str"" + stateCount + ""String_Node_Str""+ _eol);
    stateCount++;
    depth++;
    State state=(State)states.next();
    Actor[] actors=state.getRefinement();
    if (actors != null) {
      refined=true;
      for (      Actor actor : actors) {
        NamedProgramCodeGeneratorAdapter actorHelper=(NamedProgramCodeGeneratorAdapter)getCodeGenerator().getAdapter(actor);
        code.append(actorHelper.generateFireCode());
        List<IOPort> outputPorts=actor.outputPortList();
        for (        IOPort outputPort : outputPorts) {
          String source=outputPort.getFullName().substring(1).replace(""String_Node_Str"",""String_Node_Str"");
          int k=source.lastIndexOf(""String_Node_Str"");
          int l=source.substring(0,k).lastIndexOf(""String_Node_Str"");
          String destination=source.substring(0,l) + ""String_Node_Str"" + source.substring(k);
          code.append(_eol + getCodeGenerator().generatePortName((TypedIOPort)outputPort,destination,1) + ""String_Node_Str""+ getCodeGenerator().generatePortName((TypedIOPort)outputPort,source,1)+ ""String_Node_Str""+ _eol);
        }
      }
    }
    code.append(_getIndentPrefix(depth));
    code.append(""String_Node_Str"" + _eol);
    depth--;
  }
  depth--;
  code.append(_getIndentPrefix(depth));
  code.append(""String_Node_Str"" + _eol);
  return refined;
}"
72723,"/** 
 * Generate code for making transition. It generates code for both choice action and commit action.
 * @param code The string buffer that the generated code is appended to.
 * @param transitionRetriever An instance of a class implementinga method. which returns an iterator of all, preemptive or non-preemptive transitions of the current state.
 * @exception IllegalActionException If thrown while generatingtransition code.
 */
public void generateTransitionCode(StringBuffer code,TransitionRetriever transitionRetriever) throws IllegalActionException {
  StringBuffer codeBuffer=new StringBuffer();
  codeBuffer.append(getCodeGenerator().comment(""String_Node_Str""));
  ptolemy.domains.modal.kernel.FSMActor fsmActor=(ptolemy.domains.modal.kernel.FSMActor)getComponent();
  String name=fsmActor.getFullName().substring(1);
  String modalName=name.replace(""String_Node_Str"",""String_Node_Str"");
  modalName=modalName.replace('.','_').replace(' ','_');
  codeBuffer.append(getCodeGenerator().comment(""String_Node_Str""));
  codeBuffer.append(_eol + modalName + ""String_Node_Str""+ _eol);
  codeBuffer.append(""String_Node_Str"" + _eol + ""String_Node_Str""+ _eol);
  for (  State state : (List<State>)fsmActor.entityList()) {
    codeBuffer.append(""String_Node_Str"" + _generateStateConstantLabel(state) + ""String_Node_Str""+ _eol);
    Iterator transitions=transitionRetriever.retrieveTransitions(state);
    List reOrderedTransitions=new LinkedList();
    List defaultTransitions=new LinkedList();
    while (transitions.hasNext()) {
      Transition transition=(Transition)transitions.next();
      if (generateSimpleName(transition).equals(""String_Node_Str"")) {
        defaultTransitions.add(transition);
      }
 else {
        reOrderedTransitions.add(transition);
      }
    }
    reOrderedTransitions.addAll(defaultTransitions);
    transitions=reOrderedTransitions.iterator();
    int transitionCount=0;
    boolean hasDefaultCase=false;
    while (!hasDefaultCase && transitions.hasNext()) {
      Transition transition=(Transition)transitions.next();
      String guard=transition.getGuardExpression();
      if (transition.isDefault() || guard.toLowerCase(Locale.getDefault()).equals(""String_Node_Str"")) {
        hasDefaultCase=true;
      }
 else {
        if (transitionCount == 0) {
          codeBuffer.append(""String_Node_Str"");
        }
 else {
          codeBuffer.append(""String_Node_Str"");
        }
        transitionCount++;
        PtParser parser=new PtParser();
        ASTPtRootNode guardParseTree=parser.generateParseTree(guard);
        if (getTemplateParser() == null) {
          if (getCodeGenerator() == null) {
            throw new InternalErrorException(this,null,""String_Node_Str"");
          }
          getCodeGenerator().getAdapter(fsmActor);
        }
        ParseTreeCodeGenerator parseTreeCodeGenerator=getTemplateParser().getParseTreeCodeGenerator();
        parseTreeCodeGenerator.evaluateParseTree(guardParseTree,_scope);
        codeBuffer.append(parseTreeCodeGenerator.generateFireCode());
        codeBuffer.append(""String_Node_Str"");
      }
      codeBuffer.append(_eol + ""String_Node_Str"" + _eol);
      for (      AbstractActionsAttribute action : (List<AbstractActionsAttribute>)transition.choiceActionList()) {
        Iterator channelNumberList=action.getChannelNumberList().iterator();
        Iterator parseTreeList=action.getParseTreeList().iterator();
        for (        String destinationName : (List<String>)action.getDestinationNameList()) {
          Integer channelNumber=(Integer)channelNumberList.next();
          ASTPtRootNode parseTree=(ASTPtRootNode)parseTreeList.next();
          NamedObj destination=action.getDestination(destinationName);
          codeBuffer.append(destinationName + ""String_Node_Str"" + modalName+ ""String_Node_Str""+ destinationName+ ""String_Node_Str""+ _eol);
          int channel=-1;
          if (channelNumber != null) {
            channel=channelNumber.intValue();
          }
          StringBuffer sendCode=new StringBuffer();
          if (channel >= 0) {
            codeBuffer.append(""String_Node_Str"" + destinationName + ""String_Node_Str""+ channel+ ""String_Node_Str"");
            if (((IOPort)destination).isInput()) {
              NamedProgramCodeGeneratorAdapter containerHelper=(NamedProgramCodeGeneratorAdapter)getCodeGenerator().getAdapter(((IOPort)destination).getContainer().getContainer());
              StringBuffer containerReference=new StringBuffer();
              containerReference.append(""String_Node_Str"" + generateSimpleName(destination));
              if (((IOPort)destination).isMultiport()) {
                containerReference.append(""String_Node_Str"" + channel);
              }
              containerReference.append(""String_Node_Str"");
              codeBuffer.append(containerHelper.processCode(containerReference.toString()) + ""String_Node_Str"");
              sendCode.append(""String_Node_Str"" + destinationName + ""String_Node_Str""+ channel+ ""String_Node_Str""+ _eol);
            }
          }
 else {
            int width=((IOPort)action.getDestination(destinationName)).getWidth();
            for (int i=0; i < width; i++) {
              codeBuffer.append(""String_Node_Str"" + destinationName + ""String_Node_Str""+ i+ ""String_Node_Str"");
            }
          }
          ParseTreeCodeGenerator parseTreeCodeGenerator=getTemplateParser().getParseTreeCodeGenerator();
          parseTreeCodeGenerator.evaluateParseTree(parseTree,_scope);
          codeBuffer.append(parseTreeCodeGenerator.generateFireCode());
          codeBuffer.append(""String_Node_Str"" + _eol);
        }
      }
      Actor[] actors=transition.getRefinement();
      if (actors != null) {
        for (        Actor actor : actors) {
          NamedProgramCodeGeneratorAdapter helper=(NamedProgramCodeGeneratorAdapter)getAdapter(actor);
          codeBuffer.append(helper.generateFireCode());
        }
      }
      for (      AbstractActionsAttribute action : (List<AbstractActionsAttribute>)transition.commitActionList()) {
        Iterator channelNumberList=action.getChannelNumberList().iterator();
        Iterator parseTreeList=action.getParseTreeList().iterator();
        for (        String destinationName : (List<String>)action.getDestinationNameList()) {
          Integer channelNumber=(Integer)channelNumberList.next();
          ASTPtRootNode parseTree=(ASTPtRootNode)parseTreeList.next();
          NamedObj destination=action.getDestination(destinationName);
          int channel=-1;
          if (channelNumber != null) {
            channel=channelNumber.intValue();
          }
          ParseTreeCodeGenerator parseTreeCodeGenerator=getTemplateParser().getParseTreeCodeGenerator();
          parseTreeCodeGenerator.evaluateParseTree(parseTree,_scope);
          String scopeFireCode=parseTreeCodeGenerator.generateFireCode();
          if (destination instanceof IOPort) {
            if (channel >= 0) {
              codeBuffer.append(""String_Node_Str"" + destinationName + ""String_Node_Str""+ channel+ ""String_Node_Str""+ scopeFireCode+ ""String_Node_Str"");
            }
 else {
              int width=((IOPort)action.getDestination(destinationName)).getWidth();
              for (int i=0; i < width; i++) {
                codeBuffer.append(""String_Node_Str"" + destinationName + ""String_Node_Str""+ i+ ""String_Node_Str""+ scopeFireCode+ ""String_Node_Str"");
              }
            }
          }
 else           if (destination instanceof Variable) {
            codeBuffer.append(getCodeGenerator().generateVariableName(destination) + ""String_Node_Str"" + scopeFireCode+ ""String_Node_Str"");
          }
        }
      }
      State destinationState=transition.destinationState();
      _updateCurrentState(codeBuffer,destinationState);
      if (!transition.isHistory()) {
        actors=destinationState.getRefinement();
        if (actors != null) {
          for (int i=0; i < actors.length; ++i) {
            NamedProgramCodeGeneratorAdapter helper=(NamedProgramCodeGeneratorAdapter)getAdapter(actors[i]);
            codeBuffer.append(helper.generateInitializeCode());
          }
        }
      }
      codeBuffer.append(_eol + ""String_Node_Str"" + _eol);
    }
    if (!hasDefaultCase) {
      if (transitionCount > 0) {
        codeBuffer.append(""String_Node_Str"" + _eol + ""String_Node_Str""+ _eol);
      }
 else {
        codeBuffer.append(_eol);
      }
      codeBuffer.append(_eol + modalName + ""String_Node_Str""+ _eol);
      if (transitionCount > 0) {
        codeBuffer.append(_eol + ""String_Node_Str"" + _eol);
      }
    }
    codeBuffer.append(_eol + ""String_Node_Str"" + _eol);
  }
  codeBuffer.append(_eol + ""String_Node_Str"" + _eol);
  code.append(TemplateParser.unescapeName(processCode(codeBuffer.toString())));
}","/** 
 * Generate code for making transition. It generates code for both choice action and commit action.
 * @param code The string buffer that the generated code is appended to.
 * @param transitionRetriever An instance of a class implementinga method. which returns an iterator of all, preemptive or non-preemptive transitions of the current state.
 * @exception IllegalActionException If thrown while generatingtransition code.
 */
public void generateTransitionCode(StringBuffer code,TransitionRetriever transitionRetriever) throws IllegalActionException {
  StringBuffer codeBuffer=new StringBuffer();
  codeBuffer.append(getCodeGenerator().comment(""String_Node_Str""));
  ptolemy.domains.modal.kernel.FSMActor fsmActor=(ptolemy.domains.modal.kernel.FSMActor)getComponent();
  String name=fsmActor.getFullName().substring(1);
  String modalName=name.replace(""String_Node_Str"",""String_Node_Str"");
  modalName=modalName.replace('.','_').replace(' ','_');
  codeBuffer.append(getCodeGenerator().comment(""String_Node_Str""));
  codeBuffer.append(_eol + modalName + ""String_Node_Str""+ _eol);
  codeBuffer.append(""String_Node_Str"" + _eol + ""String_Node_Str""+ _eol);
  for (  State state : (List<State>)fsmActor.entityList()) {
    codeBuffer.append(""String_Node_Str"" + _generateStateConstantLabel(state) + ""String_Node_Str""+ _eol);
    Iterator transitions=transitionRetriever.retrieveTransitions(state);
    List reOrderedTransitions=new LinkedList();
    List defaultTransitions=new LinkedList();
    while (transitions.hasNext()) {
      Transition transition=(Transition)transitions.next();
      if (generateSimpleName(transition).equals(""String_Node_Str"")) {
        defaultTransitions.add(transition);
      }
 else {
        reOrderedTransitions.add(transition);
      }
    }
    reOrderedTransitions.addAll(defaultTransitions);
    transitions=reOrderedTransitions.iterator();
    int transitionCount=0;
    boolean hasDefaultCase=false;
    while (!hasDefaultCase && transitions.hasNext()) {
      Transition transition=(Transition)transitions.next();
      String guard=transition.getGuardExpression();
      if (transition.isDefault() || guard.toLowerCase(Locale.getDefault()).equals(""String_Node_Str"")) {
        hasDefaultCase=true;
      }
 else {
        if (transitionCount == 0) {
          codeBuffer.append(""String_Node_Str"");
        }
 else {
          codeBuffer.append(""String_Node_Str"");
        }
        transitionCount++;
        PtParser parser=new PtParser();
        ASTPtRootNode guardParseTree=parser.generateParseTree(guard);
        if (getTemplateParser() == null) {
          if (getCodeGenerator() == null) {
            throw new InternalErrorException(this,null,""String_Node_Str"");
          }
          getCodeGenerator().getAdapter(fsmActor);
        }
        ParseTreeCodeGenerator parseTreeCodeGenerator=getTemplateParser().getParseTreeCodeGenerator();
        parseTreeCodeGenerator.evaluateParseTree(guardParseTree,_scope);
        codeBuffer.append(parseTreeCodeGenerator.generateFireCode());
        codeBuffer.append(""String_Node_Str"");
      }
      codeBuffer.append(_eol + ""String_Node_Str"" + _eol);
      for (      AbstractActionsAttribute action : (List<AbstractActionsAttribute>)transition.choiceActionList()) {
        Iterator channelNumberList=action.getChannelNumberList().iterator();
        Iterator parseTreeList=action.getParseTreeList().iterator();
        for (        String destinationName : (List<String>)action.getDestinationNameList()) {
          Integer channelNumber=(Integer)channelNumberList.next();
          ASTPtRootNode parseTree=(ASTPtRootNode)parseTreeList.next();
          NamedObj destination=action.getDestination(destinationName);
          int channel=-1;
          if (channelNumber != null) {
            channel=channelNumber.intValue();
          }
          StringBuffer sendCode=new StringBuffer();
          if (channel >= 0) {
            codeBuffer.append(""String_Node_Str"" + destinationName + ""String_Node_Str""+ channel+ ""String_Node_Str"");
            if (((IOPort)destination).isInput()) {
              NamedProgramCodeGeneratorAdapter containerHelper=(NamedProgramCodeGeneratorAdapter)getCodeGenerator().getAdapter(((IOPort)destination).getContainer().getContainer());
              StringBuffer containerReference=new StringBuffer();
              containerReference.append(""String_Node_Str"" + generateSimpleName(destination));
              if (((IOPort)destination).isMultiport()) {
                containerReference.append(""String_Node_Str"" + channel);
              }
              containerReference.append(""String_Node_Str"");
              codeBuffer.append(containerHelper.processCode(containerReference.toString()) + ""String_Node_Str"");
              sendCode.append(""String_Node_Str"" + destinationName + ""String_Node_Str""+ channel+ ""String_Node_Str""+ _eol);
            }
          }
 else {
            int width=((IOPort)action.getDestination(destinationName)).getWidth();
            for (int i=0; i < width; i++) {
              if (fsmActor instanceof ptolemy.domains.modal.modal.ModalController) {
                codeBuffer.append(""String_Node_Str"" + destinationName + ""String_Node_Str""+ i+ ""String_Node_Str"");
              }
 else {
                codeBuffer.append(""String_Node_Str"" + destinationName + ""String_Node_Str""+ i+ ""String_Node_Str"");
                if (((IOPort)destination).isInput()) {
                  NamedProgramCodeGeneratorAdapter containerHelper=(NamedProgramCodeGeneratorAdapter)getCodeGenerator().getAdapter(((IOPort)destination).getContainer().getContainer());
                  StringBuffer containerReference=new StringBuffer();
                  containerReference.append(""String_Node_Str"" + generateSimpleName(destination));
                  if (((IOPort)destination).isMultiport()) {
                    containerReference.append(""String_Node_Str"" + i);
                  }
                  containerReference.append(""String_Node_Str"");
                  codeBuffer.append(containerHelper.processCode(containerReference.toString()) + ""String_Node_Str"");
                }
              }
            }
          }
          ParseTreeCodeGenerator parseTreeCodeGenerator=getTemplateParser().getParseTreeCodeGenerator();
          parseTreeCodeGenerator.evaluateParseTree(parseTree,_scope);
          codeBuffer.append(parseTreeCodeGenerator.generateFireCode());
          codeBuffer.append(""String_Node_Str"" + _eol);
        }
      }
      Actor[] actors=transition.getRefinement();
      if (actors != null) {
        for (        Actor actor : actors) {
          NamedProgramCodeGeneratorAdapter helper=(NamedProgramCodeGeneratorAdapter)getAdapter(actor);
          codeBuffer.append(helper.generateFireCode());
        }
      }
      for (      AbstractActionsAttribute action : (List<AbstractActionsAttribute>)transition.commitActionList()) {
        Iterator channelNumberList=action.getChannelNumberList().iterator();
        Iterator parseTreeList=action.getParseTreeList().iterator();
        for (        String destinationName : (List<String>)action.getDestinationNameList()) {
          Integer channelNumber=(Integer)channelNumberList.next();
          ASTPtRootNode parseTree=(ASTPtRootNode)parseTreeList.next();
          NamedObj destination=action.getDestination(destinationName);
          int channel=-1;
          if (channelNumber != null) {
            channel=channelNumber.intValue();
          }
          ParseTreeCodeGenerator parseTreeCodeGenerator=getTemplateParser().getParseTreeCodeGenerator();
          parseTreeCodeGenerator.evaluateParseTree(parseTree,_scope);
          String scopeFireCode=parseTreeCodeGenerator.generateFireCode();
          if (destination instanceof IOPort) {
            if (channel >= 0) {
              codeBuffer.append(""String_Node_Str"" + destinationName + ""String_Node_Str""+ channel+ ""String_Node_Str""+ scopeFireCode+ ""String_Node_Str"");
            }
 else {
              int width=((IOPort)action.getDestination(destinationName)).getWidth();
              for (int i=0; i < width; i++) {
                codeBuffer.append(""String_Node_Str"" + destinationName + ""String_Node_Str""+ i+ ""String_Node_Str""+ scopeFireCode+ ""String_Node_Str"");
              }
            }
          }
 else           if (destination instanceof Variable) {
            codeBuffer.append(getCodeGenerator().generateVariableName(destination) + ""String_Node_Str"" + scopeFireCode+ ""String_Node_Str"");
          }
        }
      }
      State destinationState=transition.destinationState();
      _updateCurrentState(codeBuffer,destinationState);
      if (!transition.isHistory()) {
        actors=destinationState.getRefinement();
        if (actors != null) {
          for (int i=0; i < actors.length; ++i) {
            NamedProgramCodeGeneratorAdapter helper=(NamedProgramCodeGeneratorAdapter)getAdapter(actors[i]);
            codeBuffer.append(helper.generateInitializeCode());
          }
        }
      }
      codeBuffer.append(_eol + ""String_Node_Str"" + _eol);
    }
    if (!hasDefaultCase) {
      if (transitionCount > 0) {
        codeBuffer.append(""String_Node_Str"" + _eol + ""String_Node_Str""+ _eol);
      }
 else {
        codeBuffer.append(_eol);
      }
      codeBuffer.append(_eol + modalName + ""String_Node_Str""+ _eol);
      if (transitionCount > 0) {
        codeBuffer.append(_eol + ""String_Node_Str"" + _eol);
      }
    }
    codeBuffer.append(_eol + ""String_Node_Str"" + _eol);
  }
  codeBuffer.append(_eol + ""String_Node_Str"" + _eol);
  code.append(TemplateParser.unescapeName(processCode(codeBuffer.toString())));
}"
72724,"/** 
 * Generate the fire code of the associated controller. All the steps are described below It is slightly different from the super class in order to take into account the receivers (if embedded in a DE model)
 * @return The fire code of the associated controller.
 * @exception IllegalActionException If the adapter associated withan actor throws it while generating fire code for the actor
 */
public String generateFireCode() throws IllegalActionException {
  FSMActor controllerHelper;
  try {
    controllerHelper=new FSMActor(_myController);
    controllerHelper.setCodeGenerator(getCodeGenerator());
    controllerHelper.setTemplateParser(getTemplateParser());
  }
 catch (  NameDuplicationException ndx) {
    throw new IllegalActionException(ndx.toString());
  }
  StringBuffer code=new StringBuffer();
  String name=_myController.getFullName().substring(1);
  String modalName=name.replace(""String_Node_Str"",""String_Node_Str"");
  modalName=modalName.replace('.','_');
  code.append(_eol + getCodeGenerator().comment(""String_Node_Str""));
  controllerHelper.generateTransitionCode(code,new PreemptiveTransitions());
  code.append(_eol);
  code.append(""String_Node_Str"" + modalName + ""String_Node_Str""+ _eol);
  if (_generateRefinementCode(code)) {
    code.append(_eol + ""String_Node_Str"" + _eol);
  }
  code.append(getCodeGenerator().comment(""String_Node_Str""));
  controllerHelper.generateTransitionCode(code,new NonPreemptiveTransitions());
  code.append(""String_Node_Str"" + _eol);
  code.append(_eol + ""String_Node_Str"" + _eol);
  return code.toString();
}","/** 
 * Generate the fire code of the associated controller. All the steps are described below It is slightly different from the super class in order to take into account the receivers (if embedded in a DE model)
 * @return The fire code of the associated controller.
 * @exception IllegalActionException If the adapter associated withan actor throws it while generating fire code for the actor
 */
public String generateFireCode() throws IllegalActionException {
  FSMActor controllerHelper;
  try {
    controllerHelper=new FSMActor(_myController);
    controllerHelper.setCodeGenerator(getCodeGenerator());
    controllerHelper.setTemplateParser(getTemplateParser());
  }
 catch (  NameDuplicationException ndx) {
    throw new IllegalActionException(ndx.toString());
  }
  StringBuffer code=new StringBuffer();
  String name=_myController.getFullName().substring(1);
  String modalName=name.replace(""String_Node_Str"",""String_Node_Str"");
  modalName=modalName.replace('.','_');
  code.append(_eol + getCodeGenerator().comment(""String_Node_Str""));
  controllerHelper.generateTransitionCode(code,new PreemptiveTransitions());
  code.append(_eol);
  code.append(""String_Node_Str"" + modalName + ""String_Node_Str""+ _eol);
  if (_generateRefinementCode(code)) {
    code.append(_eol + ""String_Node_Str"" + _eol);
  }
 else {
    code.append(_eol + ""String_Node_Str"" + _eol);
  }
  code.append(getCodeGenerator().comment(""String_Node_Str""));
  controllerHelper.generateTransitionCode(code,new NonPreemptiveTransitions());
  code.append(""String_Node_Str"" + _eol);
  code.append(_eol + ""String_Node_Str"" + _eol);
  return code.toString();
}"
72725,"/** 
 * If this GeneratorAttribute has not yet been initialized, the initialized it by reading the moml file named by the initialParametersURL and creating Parameters and Variables accordingly.
 */
public void initialize() throws IllegalActionException, NameDuplicationException {
  if (_initialized) {
    return;
  }
  if (initialParametersURL == null) {
    throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
  }
  URL initialParameters=getClass().getClassLoader().getResource(initialParametersURL.getExpression());
  if (initialParameters == null) {
    throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + initialParametersURL.getExpression() + ""String_Node_Str"");
  }
  BufferedReader inputReader=null;
  try {
    inputReader=new BufferedReader(new InputStreamReader(initialParameters.openStream()));
    String inputLine;
    StringBuffer buffer=new StringBuffer();
    while ((inputLine=inputReader.readLine()) != null) {
      buffer.append(inputLine + ""String_Node_Str"");
    }
    inputReader.close();
    addChangeListener(this);
    try {
      requestChange(new MoMLChangeRequest(this,this,buffer.toString()));
    }
 catch (    Exception ex) {
      throw new IllegalActionException(this,ex,""String_Node_Str"" + buffer.toString());
    }
  }
 catch (  Exception ex) {
    throw new IllegalActionException(this,ex,""String_Node_Str"" + initialParametersURL.getExpression() + ""String_Node_Str"");
  }
 finally {
    try {
      if (inputReader != null) {
        inputReader.close();
      }
    }
 catch (    IOException ex) {
      throw new IllegalActionException(this,ex,""String_Node_Str"" + initialParameters + ""String_Node_Str"");
    }
  }
  _initialized=true;
}","/** 
 * If this GeneratorAttribute has not yet been initialized, the initialized it by reading the moml file named by the initialParametersURL and creating Parameters and Variables accordingly.
 */
public void initialize() throws IllegalActionException, NameDuplicationException {
  if (_initialized) {
    return;
  }
  if (initialParametersURL == null) {
    throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"");
  }
  URL initialParameters=getClass().getClassLoader().getResource(initialParametersURL.getExpression());
  if (initialParameters == null) {
    throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + initialParametersURL.getExpression() + ""String_Node_Str"");
  }
  BufferedReader inputReader=null;
  try {
    inputReader=new BufferedReader(new InputStreamReader(initialParameters.openStream(),""String_Node_Str""));
    String inputLine;
    StringBuffer buffer=new StringBuffer();
    while ((inputLine=inputReader.readLine()) != null) {
      buffer.append(inputLine + ""String_Node_Str"");
    }
    inputReader.close();
    addChangeListener(this);
    try {
      requestChange(new MoMLChangeRequest(this,this,buffer.toString()));
    }
 catch (    Exception ex) {
      throw new IllegalActionException(this,ex,""String_Node_Str"" + buffer.toString());
    }
  }
 catch (  Exception ex) {
    throw new IllegalActionException(this,ex,""String_Node_Str"" + initialParametersURL.getExpression() + ""String_Node_Str"");
  }
 finally {
    try {
      if (inputReader != null) {
        inputReader.close();
      }
    }
 catch (    IOException ex) {
      throw new IllegalActionException(this,ex,""String_Node_Str"" + initialParameters + ""String_Node_Str"");
    }
  }
  _initialized=true;
}"
72726,"/** 
 * If functions needed for co-simulation are absent, then thrown an exception with an informative message.  The .fmu file may not have a shared library for the current platform.
 * @exception IllegalActionException If functions needed for co-simulationare missing.
 */
private void _checkFmiCoSimulation() throws IllegalActionException {
  String missingFunction=null;
  if (_fmiDoStepFunction == null) {
    missingFunction=""String_Node_Str"";
  }
  if (_fmiInstantiateSlaveFunction == null) {
    missingFunction=""String_Node_Str"";
  }
  if (_fmiTerminateSlaveFunction == null) {
    missingFunction=""String_Node_Str"";
  }
  if (_fmiFreeSlaveInstanceFunction == null) {
    missingFunction=""String_Node_Str"";
  }
  if (missingFunction != null) {
    String sharedLibrary=""String_Node_Str"";
    try {
      sharedLibrary=""String_Node_Str"" + FMUFile.fmuSharedLibrary(_fmiModelDescription) + ""String_Node_Str"";
    }
 catch (    IOException ex) {
      sharedLibrary=""String_Node_Str"" + ex;
    }
    List<String> binariesFiles=new LinkedList<String>();
    for (    File file : _fmiModelDescription.files) {
      if (file.toString().indexOf(""String_Node_Str"") != -1) {
        binariesFiles.add(file.toString() + ""String_Node_Str"");
      }
    }
    throw new IllegalActionException(this,""String_Node_Str"" + _fmiModelDescription.modelIdentifier + missingFunction+ ""String_Node_Str""+ fmuFile.asFile()+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ sharedLibrary+ ""String_Node_Str""+ ""String_Node_Str""+ binariesFiles);
  }
}","/** 
 * If functions needed for co-simulation are absent, then thrown an exception with an informative message.  The .fmu file may not have a shared library for the current platform.
 * @exception IllegalActionException If functions needed for co-simulationare missing.
 */
private void _checkFmiCoSimulation() throws IllegalActionException {
  String missingFunction=null;
  if (_fmiDoStepFunction == null) {
    missingFunction=""String_Node_Str"";
  }
  if (_fmiVersion < 2.0) {
    if (_fmiInstantiateSlaveFunction == null) {
      missingFunction=""String_Node_Str"";
    }
    if (_fmiTerminateSlaveFunction == null) {
      missingFunction=""String_Node_Str"";
    }
    if (_fmiFreeSlaveInstanceFunction == null) {
      missingFunction=""String_Node_Str"";
    }
  }
 else {
    if (_fmiInstantiateFunction == null) {
      missingFunction=""String_Node_Str"";
    }
    if (_fmiTerminateFunction == null) {
      missingFunction=""String_Node_Str"";
    }
    if (_fmiFreeInstanceFunction == null) {
      missingFunction=""String_Node_Str"";
    }
  }
  if (missingFunction != null) {
    String sharedLibrary=""String_Node_Str"";
    try {
      sharedLibrary=""String_Node_Str"" + FMUFile.fmuSharedLibrary(_fmiModelDescription) + ""String_Node_Str"";
    }
 catch (    IOException ex) {
      sharedLibrary=""String_Node_Str"" + ex;
    }
    List<String> binariesFiles=new LinkedList<String>();
    for (    File file : _fmiModelDescription.files) {
      if (file.toString().indexOf(""String_Node_Str"") != -1) {
        binariesFiles.add(file.toString() + ""String_Node_Str"");
      }
    }
    throw new IllegalActionException(this,""String_Node_Str"" + _fmiModelDescription.modelIdentifier + missingFunction+ ""String_Node_Str""+ fmuFile.asFile()+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ sharedLibrary+ ""String_Node_Str""+ ""String_Node_Str""+ binariesFiles);
  }
}"
72727,"/** 
 * Invoke _fmiInitialize() (for model exchange) or _fmiInitializeSlave() (for co-simulation) on the FMU. In the case of model exchange, this method also checks for a returned next event time and calls fireAt() on the director if a next event time is returned. In the case of co-simulation, if the FMU provides a maximum step size, get that from the FMU and call fireAt() as well.
 * @exception IllegalActionException If the FMU does not return fmiOK.
 */
@SuppressWarnings(""String_Node_Str"") protected void _fmiInitialize() throws IllegalActionException {
  if (_fmiModelDescription.modelExchange) {
    if (_fmiVersion < 1.5) {
      FMIEventInfo eventInfo=new FMIEventInfo.ByValue();
      int fmiFlag=((Integer)_fmiInitializeFunction.invoke(Integer.class,new Object[]{_fmiComponent,_toleranceControlled,_relativeTolerance,eventInfo.getPointer()})).intValue();
      if (fmiFlag != FMILibrary.FMIStatus.fmiOK) {
        throw new IllegalActionException(this,""String_Node_Str"" + _fmiStatusDescription(fmiFlag));
      }
      if (eventInfo.terminateSimulation != (byte)0) {
        throw new IllegalActionException(this,""String_Node_Str"");
      }
      if (eventInfo.upcomingTimeEvent != (byte)0) {
        getDirector().fireAt(this,eventInfo.nextEventTime);
      }
    }
 else {
      int fmiFlag=((Integer)_fmiEnterInitializationModeFunction.invoke(Integer.class,new Object[]{_fmiComponent})).intValue();
      if (fmiFlag != FMILibrary.FMIStatus.fmiOK) {
        throw new IllegalActionException(this,""String_Node_Str"" + _fmiStatusDescription(fmiFlag));
      }
      if (_fmiModelDescription.numberOfEventIndicators > 0) {
        new Exception(""String_Node_Str"").printStackTrace();
      }
    }
  }
 else {
    String modelIdentifier=_fmiModelDescription.modelIdentifier;
    Director director=getDirector();
    Time startTime=director.getModelStartTime();
    Time stopTime=director.getModelStopTime();
    int fmiFlag;
    if (_fmiVersion < 1.5) {
      fmiFlag=((Integer)_fmiInitializeSlaveFunction.invoke(Integer.class,new Object[]{_fmiComponent,startTime.getDoubleValue(),(byte)1,stopTime.getDoubleValue()})).intValue();
    }
 else {
      fmiFlag=((Integer)_fmiInitializeSlaveFunction.invoke(Integer.class,new Object[]{_fmiComponent,_relativeTolerance,startTime.getDoubleValue(),(byte)1,stopTime.getDoubleValue()})).intValue();
      _requestRefiringIfNecessary();
      _recordFMUState();
    }
    if (fmiFlag > FMILibrary.FMIStatus.fmiWarning) {
      throw new IllegalActionException(this,""String_Node_Str"" + modelIdentifier + ""String_Node_Str""+ startTime.getDoubleValue()+ ""String_Node_Str""+ stopTime.getDoubleValue()+ ""String_Node_Str""+ _fmiStatusDescription(fmiFlag));
    }
  }
  if (_debugging) {
    _debugToStdOut(""String_Node_Str"");
  }
  _modelInitialized=true;
}","/** 
 * Invoke _fmiInitialize() (for model exchange) or _fmiInitializeSlave() (for co-simulation) on the FMU. In the case of model exchange, this method also checks for a returned next event time and calls fireAt() on the director if a next event time is returned. In the case of co-simulation, if the FMU provides a maximum step size, get that from the FMU and call fireAt() as well.
 * @exception IllegalActionException If the FMU does not return fmiOK.
 */
@SuppressWarnings(""String_Node_Str"") protected void _fmiInitialize() throws IllegalActionException {
  if (_fmiModelDescription.modelExchange) {
    if (_fmiVersion < 1.5) {
      FMIEventInfo eventInfo=new FMIEventInfo.ByValue();
      int fmiFlag=((Integer)_fmiInitializeFunction.invoke(Integer.class,new Object[]{_fmiComponent,_toleranceControlled,_relativeTolerance,eventInfo.getPointer()})).intValue();
      if (fmiFlag != FMILibrary.FMIStatus.fmiOK) {
        throw new IllegalActionException(this,""String_Node_Str"" + _fmiStatusDescription(fmiFlag));
      }
      if (eventInfo.terminateSimulation != (byte)0) {
        throw new IllegalActionException(this,""String_Node_Str"");
      }
      if (eventInfo.upcomingTimeEvent != (byte)0) {
        getDirector().fireAt(this,eventInfo.nextEventTime);
      }
    }
 else     if (_fmiVersion >= 1.5 && _fmiVersion < 2.0) {
      throw new IllegalActionException(this,""String_Node_Str"" + _fmiVersion);
    }
 else {
      Director director=getDirector();
      Time startTime=director.getModelStartTime();
      Time stopTime=director.getModelStopTime();
      int fmiFlag=((Integer)_fmiSetupExperimentFunction.invoke(Integer.class,new Object[]{_fmiComponent,_toleranceControlled,_relativeTolerance,startTime.getDoubleValue(),(byte)1,stopTime.getDoubleValue()})).intValue();
      if (fmiFlag != FMILibrary.FMIStatus.fmiOK) {
        throw new IllegalActionException(this,""String_Node_Str"" + _fmiStatusDescription(fmiFlag));
      }
      fmiFlag=((Integer)_fmiEnterInitializationModeFunction.invoke(Integer.class,new Object[]{_fmiComponent})).intValue();
      if (fmiFlag != FMILibrary.FMIStatus.fmiOK) {
        throw new IllegalActionException(this,""String_Node_Str"" + _fmiStatusDescription(fmiFlag));
      }
      fmiFlag=((Integer)_fmiExitInitializationModeFunction.invoke(Integer.class,new Object[]{_fmiComponent})).intValue();
      if (fmiFlag != FMILibrary.FMIStatus.fmiOK) {
        throw new IllegalActionException(this,""String_Node_Str"" + _fmiStatusDescription(fmiFlag));
      }
      if (_fmiModelDescription.numberOfEventIndicators > 0) {
        new Exception(""String_Node_Str"").printStackTrace();
      }
    }
  }
 else {
    String modelIdentifier=_fmiModelDescription.modelIdentifier;
    Director director=getDirector();
    Time startTime=director.getModelStartTime();
    Time stopTime=director.getModelStopTime();
    int fmiFlag;
    if (_fmiVersion < 1.5) {
      fmiFlag=((Integer)_fmiInitializeSlaveFunction.invoke(Integer.class,new Object[]{_fmiComponent,startTime.getDoubleValue(),(byte)1,stopTime.getDoubleValue()})).intValue();
    }
 else     if (_fmiVersion >= 1.5 && _fmiVersion < 2.0) {
      fmiFlag=((Integer)_fmiInitializeSlaveFunction.invoke(Integer.class,new Object[]{_fmiComponent,_relativeTolerance,startTime.getDoubleValue(),(byte)1,stopTime.getDoubleValue()})).intValue();
      _requestRefiringIfNecessary();
      _recordFMUState();
    }
 else {
      fmiFlag=((Integer)_fmiSetupExperimentFunction.invoke(Integer.class,new Object[]{_fmiComponent,_toleranceControlled,_relativeTolerance,startTime.getDoubleValue(),(byte)1,stopTime.getDoubleValue()})).intValue();
      if (fmiFlag != FMILibrary.FMIStatus.fmiOK) {
        throw new IllegalActionException(this,""String_Node_Str"" + _fmiStatusDescription(fmiFlag));
      }
      if (fmiFlag != FMILibrary.FMIStatus.fmiOK) {
        throw new IllegalActionException(this,""String_Node_Str"" + _fmiStatusDescription(fmiFlag));
      }
      fmiFlag=((Integer)_fmiExitInitializationModeFunction.invoke(Integer.class,new Object[]{_fmiComponent})).intValue();
      if (fmiFlag != FMILibrary.FMIStatus.fmiOK) {
        throw new IllegalActionException(this,""String_Node_Str"" + _fmiStatusDescription(fmiFlag));
      }
      _requestRefiringIfNecessary();
      _recordFMUState();
    }
    if (fmiFlag > FMILibrary.FMIStatus.fmiWarning) {
      throw new IllegalActionException(this,""String_Node_Str"" + modelIdentifier + ""String_Node_Str""+ startTime.getDoubleValue()+ ""String_Node_Str""+ stopTime.getDoubleValue()+ ""String_Node_Str""+ _fmiStatusDescription(fmiFlag));
    }
  }
  if (_debugging) {
    _debugToStdOut(""String_Node_Str"");
  }
  _modelInitialized=true;
}"
72728,"/** 
 * Instantiate the slave FMU component.
 * @exception IllegalActionException if it cannot be instantiated.
 */
public void preinitialize() throws IllegalActionException {
  if (_fmiModelDescription == null) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  super.preinitialize();
  if (_debugging) {
    _debugToStdOut(""String_Node_Str"");
  }
  try {
    _nativeLibrary=_fmiModelDescription.getNativeLibrary();
  }
 catch (  IOException e1) {
    throw new IllegalActionException(this,e1,""String_Node_Str"");
  }
  if (_nativeLibrary == null) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  _checkFmiCommon();
  try {
    if (_fmiModelDescription.modelExchange) {
      try {
        if (_fmiVersion < 2.0 || !_completedIntegratorStepNotNeeded()) {
          _fmiCompletedIntegratorStepFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        }
      }
 catch (      Throwable throwable) {
        throw new IllegalActionException(this,throwable,""String_Node_Str"" + _fmuFileName + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      }
      if (_fmiVersion < 2.0) {
        try {
          _fmiFreeModelInstanceFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        }
 catch (        UnsatisfiedLinkError ex) {
          throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
        }
      }
 else {
        try {
          _fmiFreeInstanceFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        }
 catch (        UnsatisfiedLinkError ex) {
          throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
        }
      }
      _fmiGetContinuousStatesFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      _fmiSetContinuousStates=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      _fmiGetDerivativesFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      try {
        _fmiGetEventIndicatorsFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
 catch (      UnsatisfiedLinkError ex) {
        _fmiGetEventIndicatorsFunction=null;
      }
      if (_fmiVersion < 1.5) {
        _fmiInitializeFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiInstantiateModelFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
 else       if (_fmiVersion >= 1.5 && _fmiVersion < 2.0) {
        throw new IllegalActionException(this,""String_Node_Str"" + _fmiVersion);
      }
 else {
        _fmiEnterInitializationModeFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiExitInitializationModeFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiInstantiateFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
      _fmiSetTimeFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      _fmiTerminateFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      _checkFmiModelExchange();
    }
 else {
      _fmiDoStepFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      if (_fmiVersion < 2.0) {
        try {
          _fmiFreeSlaveInstanceFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        }
 catch (        UnsatisfiedLinkError ex) {
          throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
        }
      }
 else {
        try {
          _fmiFreeInstanceFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        }
 catch (        UnsatisfiedLinkError ex) {
          throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
        }
      }
      if (_fmiVersion < 2.0) {
        _fmiInitializeSlaveFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiInstantiateSlaveFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
 else {
        _fmiInstantiateFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
      if (_fmiVersion < 2.0) {
        _fmiTerminateSlaveFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
 else {
        _fmiTerminateFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
      try {
        _fmiGetRealStatusFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
 catch (      UnsatisfiedLinkError ex) {
        _fmiGetRealStatusFunction=null;
      }
      if (_fmiModelDescription.canGetAndSetFMUstate) {
        _fmiFreeFMUstateFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiGetFMUstateFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiSetFMUstate=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
 else {
        _fmiFreeFMUstateFunction=null;
        _fmiGetFMUstateFunction=null;
        _fmiSetFMUstate=null;
      }
      _checkFmiCoSimulation();
    }
  }
 catch (  IOException ex) {
    throw new IllegalActionException(this,ex,""String_Node_Str"");
  }
  String modelIdentifier=_fmiModelDescription.modelIdentifier;
  String mimeType=""String_Node_Str"";
  double timeout=1000;
  byte toBeVisible=0;
  if (((BooleanToken)visible.getToken()).booleanValue()) {
    toBeVisible=1;
  }
  byte interactive=0;
  byte loggingOn=_debugging ? (byte)1 : (byte)0;
  if (_fmiVersion < 1.5) {
    _callbacks=new FMICallbackFunctions.ByValue(new FMULibrary.FMULogger(_fmiModelDescription),new FMULibrary.FMUAllocateMemory(),new FMULibrary.FMUFreeMemory(),new FMULibrary.FMUStepFinished());
    if (_fmiModelDescription.modelExchange) {
      if (_debugging) {
        _debugToStdOut(""String_Node_Str"" + modelIdentifier + ""String_Node_Str"");
      }
      _fmiComponent=(Pointer)_fmiInstantiateModelFunction.invoke(Pointer.class,new Object[]{getFullName(),_fmiModelDescription.guid,_callbacks,loggingOn});
    }
 else {
      if (_debugging) {
        _debugToStdOut(""String_Node_Str"" + modelIdentifier + ""String_Node_Str"");
      }
      _fmiComponent=(Pointer)_fmiInstantiateSlaveFunction.invoke(Pointer.class,new Object[]{getFullName(),_fmiModelDescription.guid,_fmiModelDescription.fmuResourceLocation,mimeType,timeout,toBeVisible,interactive,_callbacks,loggingOn});
    }
  }
 else {
    _callbacks=new FMICallbackFunctions(new FMULibrary.FMULogger(_fmiModelDescription),new FMULibrary.FMUAllocateMemory(),new FMULibrary.FMUFreeMemory(),new FMULibrary.FMUStepFinished());
    if (_debugging) {
      _debugToStdOut(""String_Node_Str"" + modelIdentifier + ""String_Node_Str"");
    }
    int fmiType=1;
    if (_fmiModelDescription.modelExchange) {
      fmiType=0;
    }
    if (_fmiVersion < 2.0) {
      if (_fmiModelDescription.modelExchange) {
        throw new IllegalActionException(this,""String_Node_Str"" + _fmiVersion);
      }
 else {
        _fmiComponent=(Pointer)_fmiInstantiateSlaveFunction.invoke(Pointer.class,new Object[]{getFullName(),_fmiModelDescription.guid,_fmiModelDescription.fmuResourceLocation,_callbacks,toBeVisible,loggingOn});
      }
    }
 else     if (_fmiVersion >= 2.0) {
      _fmiComponent=(Pointer)_fmiInstantiateFunction.invoke(Pointer.class,new Object[]{getFullName(),fmiType,_fmiModelDescription.guid,_fmiModelDescription.fmuResourceLocation,_callbacks,toBeVisible,loggingOn});
      if (_fmiComponent != null && _fmiComponent.equals(Pointer.NULL)) {
        int fmiFlag=((Integer)_fmiEnterInitializationModeFunction.invoke(Integer.class,new Object[]{_fmiComponent})).intValue();
        if (fmiFlag != FMILibrary.FMIStatus.fmiOK) {
          throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + _fmiStatusDescription(fmiFlag));
        }
        fmiFlag=((Integer)_fmiExitInitializationModeFunction.invoke(Integer.class,new Object[]{_fmiComponent})).intValue();
        if (fmiFlag != FMILibrary.FMIStatus.fmiOK) {
          throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + _fmiStatusDescription(fmiFlag));
        }
      }
    }
  }
  if (_fmiComponent == null || _fmiComponent.equals(Pointer.NULL)) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
}","/** 
 * Instantiate the slave FMU component.
 * @exception IllegalActionException if it cannot be instantiated.
 */
public void preinitialize() throws IllegalActionException {
  if (_fmiModelDescription == null) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  super.preinitialize();
  if (_debugging) {
    _debugToStdOut(""String_Node_Str"");
  }
  try {
    _nativeLibrary=_fmiModelDescription.getNativeLibrary();
  }
 catch (  IOException e1) {
    throw new IllegalActionException(this,e1,""String_Node_Str"");
  }
  if (_nativeLibrary == null) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  _checkFmiCommon();
  try {
    if (_fmiModelDescription.modelExchange) {
      try {
        if (_fmiVersion < 2.0 || !_completedIntegratorStepNotNeeded()) {
          _fmiCompletedIntegratorStepFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        }
      }
 catch (      Throwable throwable) {
        throw new IllegalActionException(this,throwable,""String_Node_Str"" + _fmuFileName + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      }
      if (_fmiVersion < 2.0) {
        try {
          _fmiFreeModelInstanceFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        }
 catch (        UnsatisfiedLinkError ex) {
          throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
        }
      }
 else {
        try {
          _fmiFreeInstanceFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        }
 catch (        UnsatisfiedLinkError ex) {
          throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
        }
      }
      _fmiGetContinuousStatesFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      _fmiSetContinuousStates=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      _fmiGetDerivativesFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      try {
        _fmiGetEventIndicatorsFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
 catch (      UnsatisfiedLinkError ex) {
        _fmiGetEventIndicatorsFunction=null;
      }
      if (_fmiVersion < 1.5) {
        _fmiInitializeFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiInstantiateModelFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
 else       if (_fmiVersion >= 1.5 && _fmiVersion < 2.0) {
        throw new IllegalActionException(this,""String_Node_Str"" + _fmiVersion);
      }
 else {
        _fmiEnterInitializationModeFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiExitInitializationModeFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiInstantiateFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
      _fmiSetTimeFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      _fmiTerminateFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      if (_fmiVersion >= 2.0) {
        try {
          _fmiSetupExperimentFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        }
 catch (        UnsatisfiedLinkError ex) {
          throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
        }
      }
      _checkFmiModelExchange();
    }
 else {
      _fmiDoStepFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      if (_fmiVersion < 2.0) {
        try {
          _fmiFreeSlaveInstanceFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        }
 catch (        UnsatisfiedLinkError ex) {
          throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
        }
      }
 else {
        try {
          _fmiFreeInstanceFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        }
 catch (        UnsatisfiedLinkError ex) {
          throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
        }
      }
      if (_fmiVersion < 2.0) {
        _fmiInitializeSlaveFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiInstantiateSlaveFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
 else {
        _fmiInstantiateFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
      if (_fmiVersion < 2.0) {
        _fmiTerminateSlaveFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
 else {
        _fmiTerminateFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
      try {
        _fmiGetRealStatusFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
 catch (      UnsatisfiedLinkError ex) {
        _fmiGetRealStatusFunction=null;
      }
      if (_fmiModelDescription.canGetAndSetFMUstate) {
        _fmiFreeFMUstateFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiGetFMUstateFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiSetFMUstate=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
 else {
        _fmiFreeFMUstateFunction=null;
        _fmiGetFMUstateFunction=null;
        _fmiSetFMUstate=null;
      }
      if (_fmiVersion >= 2.0) {
        try {
          _fmiSetupExperimentFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        }
 catch (        UnsatisfiedLinkError ex) {
          throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
        }
      }
      _checkFmiCoSimulation();
    }
  }
 catch (  IOException ex) {
    throw new IllegalActionException(this,ex,""String_Node_Str"");
  }
  String modelIdentifier=_fmiModelDescription.modelIdentifier;
  String mimeType=""String_Node_Str"";
  double timeout=1000;
  byte toBeVisible=0;
  if (((BooleanToken)visible.getToken()).booleanValue()) {
    toBeVisible=1;
  }
  byte interactive=0;
  byte loggingOn=_debugging ? (byte)1 : (byte)0;
  if (_fmiVersion < 1.5) {
    _callbacks=new FMICallbackFunctions.ByValue(new FMULibrary.FMULogger(_fmiModelDescription),new FMULibrary.FMUAllocateMemory(),new FMULibrary.FMUFreeMemory(),new FMULibrary.FMUStepFinished());
    if (_fmiModelDescription.modelExchange) {
      if (_debugging) {
        _debugToStdOut(""String_Node_Str"" + modelIdentifier + ""String_Node_Str"");
      }
      _fmiComponent=(Pointer)_fmiInstantiateModelFunction.invoke(Pointer.class,new Object[]{getFullName(),_fmiModelDescription.guid,_callbacks,loggingOn});
    }
 else {
      if (_debugging) {
        _debugToStdOut(""String_Node_Str"" + modelIdentifier + ""String_Node_Str"");
      }
      _fmiComponent=(Pointer)_fmiInstantiateSlaveFunction.invoke(Pointer.class,new Object[]{getFullName(),_fmiModelDescription.guid,_fmiModelDescription.fmuResourceLocation,mimeType,timeout,toBeVisible,interactive,_callbacks,loggingOn});
    }
  }
 else {
    _callbacks=new FMICallbackFunctions(new FMULibrary.FMULogger(_fmiModelDescription),new FMULibrary.FMUAllocateMemory(),new FMULibrary.FMUFreeMemory(),new FMULibrary.FMUStepFinished());
    if (_debugging) {
      _debugToStdOut(""String_Node_Str"" + modelIdentifier + ""String_Node_Str"");
    }
    int fmiType=1;
    if (_fmiModelDescription.modelExchange) {
      fmiType=0;
    }
    if (_fmiVersion < 2.0) {
      if (_fmiModelDescription.modelExchange) {
        throw new IllegalActionException(this,""String_Node_Str"" + _fmiVersion);
      }
 else {
        _fmiComponent=(Pointer)_fmiInstantiateSlaveFunction.invoke(Pointer.class,new Object[]{getFullName(),_fmiModelDescription.guid,_fmiModelDescription.fmuResourceLocation,_callbacks,toBeVisible,loggingOn});
      }
    }
 else     if (_fmiVersion >= 2.0) {
      _fmiComponent=(Pointer)_fmiInstantiateFunction.invoke(Pointer.class,new Object[]{getFullName(),fmiType,_fmiModelDescription.guid,_fmiModelDescription.fmuResourceLocation,_callbacks,toBeVisible,loggingOn});
    }
  }
  if (_fmiComponent == null || _fmiComponent.equals(Pointer.NULL)) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
}"
72729,"/** 
 * If functions needed for model exchange are absent, then thrown an exception with an informative message.  The .fmu file may not have a shared library for the current platform.
 * @exception IllegalActionException If functions needed for co-simulationare missing.
 */
private void _checkFmiModelExchange() throws IllegalActionException {
  StringBuffer missingFunctions=new StringBuffer();
  if (_fmiSetTimeFunction == null) {
    missingFunctions.append(""String_Node_Str"");
  }
  if (_fmiVersion < 2.0) {
    if (_fmiInitializeFunction == null) {
      missingFunctions.append(""String_Node_Str"");
    }
    if (_fmiInstantiateModelFunction == null) {
      if (missingFunctions.length() > 0) {
        missingFunctions.append(""String_Node_Str"");
      }
      missingFunctions.append(""String_Node_Str"");
    }
  }
 else {
    if (_fmiEnterInitializationModeFunction == null) {
      missingFunctions.append(""String_Node_Str"");
    }
    if (_fmiEnterInitializationModeFunction == null) {
      if (missingFunctions.length() > 0) {
        missingFunctions.append(""String_Node_Str"");
      }
      missingFunctions.append(""String_Node_Str"");
    }
    if (_fmiInstantiateFunction == null) {
      if (missingFunctions.length() > 0) {
        missingFunctions.append(""String_Node_Str"");
      }
      missingFunctions.append(""String_Node_Str"");
    }
  }
  if (_fmiModelDescription.numberOfContinuousStates > 0) {
    if (_fmiGetContinuousStatesFunction == null) {
      if (missingFunctions.length() > 0) {
        missingFunctions.append(""String_Node_Str"");
      }
      missingFunctions.append(""String_Node_Str"");
    }
    if (_fmiSetContinuousStates == null) {
      if (missingFunctions.length() > 0) {
        missingFunctions.append(""String_Node_Str"");
      }
      missingFunctions.append(""String_Node_Str"");
    }
    if (_fmiGetDerivativesFunction == null) {
      if (missingFunctions.length() > 0) {
        missingFunctions.append(""String_Node_Str"");
      }
      missingFunctions.append(""String_Node_Str"");
    }
    if (!_completedIntegratorStepNotNeeded()) {
      if (_fmiCompletedIntegratorStepFunction == null) {
        if (missingFunctions.length() > 0) {
          missingFunctions.append(""String_Node_Str"");
        }
        missingFunctions.append(""String_Node_Str"");
      }
    }
  }
  if (missingFunctions.length() != 0) {
    String sharedLibrary=""String_Node_Str"";
    try {
      sharedLibrary=""String_Node_Str"" + FMUFile.fmuSharedLibrary(_fmiModelDescription) + ""String_Node_Str"";
    }
 catch (    IOException ex) {
      sharedLibrary=""String_Node_Str"" + ex;
    }
    List<String> binariesFiles=new LinkedList<String>();
    for (    File file : _fmiModelDescription.files) {
      if (file.toString().indexOf(""String_Node_Str"") != -1) {
        binariesFiles.add(file.toString() + ""String_Node_Str"");
      }
    }
    throw new IllegalActionException(this,""String_Node_Str"" + missingFunctions + ""String_Node_Str""+ ""String_Node_Str""+ _fmiModelDescription.modelIdentifier+ ""String_Node_Str""+ ""String_Node_Str""+ fmuFile.asFile()+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ sharedLibrary+ ""String_Node_Str""+ ""String_Node_Str""+ binariesFiles);
  }
}","/** 
 * If functions needed for model exchange are absent, then thrown an exception with an informative message.  The .fmu file may not have a shared library for the current platform.
 * @exception IllegalActionException If functions needed for co-simulationare missing.
 */
private void _checkFmiModelExchange() throws IllegalActionException {
  StringBuffer missingFunctions=new StringBuffer();
  if (_fmiSetTimeFunction == null) {
    missingFunctions.append(""String_Node_Str"");
  }
  if (_fmiVersion < 1.5) {
    if (_fmiInitializeFunction == null) {
      missingFunctions.append(""String_Node_Str"");
    }
    if (_fmiInstantiateModelFunction == null) {
      if (missingFunctions.length() > 0) {
        missingFunctions.append(""String_Node_Str"");
      }
      missingFunctions.append(""String_Node_Str"");
    }
  }
 else   if (_fmiVersion >= 1.5 && _fmiVersion < 2.0) {
    throw new IllegalActionException(this,""String_Node_Str"" + _fmiVersion);
  }
 else {
    if (_fmiEnterInitializationModeFunction == null) {
      missingFunctions.append(""String_Node_Str"");
    }
    if (_fmiEnterInitializationModeFunction == null) {
      if (missingFunctions.length() > 0) {
        missingFunctions.append(""String_Node_Str"");
      }
      missingFunctions.append(""String_Node_Str"");
    }
    if (_fmiInstantiateFunction == null) {
      if (missingFunctions.length() > 0) {
        missingFunctions.append(""String_Node_Str"");
      }
      missingFunctions.append(""String_Node_Str"");
    }
  }
  if (_fmiModelDescription.numberOfContinuousStates > 0) {
    if (_fmiGetContinuousStatesFunction == null) {
      if (missingFunctions.length() > 0) {
        missingFunctions.append(""String_Node_Str"");
      }
      missingFunctions.append(""String_Node_Str"");
    }
    if (_fmiSetContinuousStates == null) {
      if (missingFunctions.length() > 0) {
        missingFunctions.append(""String_Node_Str"");
      }
      missingFunctions.append(""String_Node_Str"");
    }
    if (_fmiGetDerivativesFunction == null) {
      if (missingFunctions.length() > 0) {
        missingFunctions.append(""String_Node_Str"");
      }
      missingFunctions.append(""String_Node_Str"");
    }
    if (!_completedIntegratorStepNotNeeded()) {
      if (_fmiCompletedIntegratorStepFunction == null) {
        if (missingFunctions.length() > 0) {
          missingFunctions.append(""String_Node_Str"");
        }
        missingFunctions.append(""String_Node_Str"");
      }
    }
  }
  if (missingFunctions.length() != 0) {
    String sharedLibrary=""String_Node_Str"";
    try {
      sharedLibrary=""String_Node_Str"" + FMUFile.fmuSharedLibrary(_fmiModelDescription) + ""String_Node_Str"";
    }
 catch (    IOException ex) {
      sharedLibrary=""String_Node_Str"" + ex;
    }
    List<String> binariesFiles=new LinkedList<String>();
    for (    File file : _fmiModelDescription.files) {
      if (file.toString().indexOf(""String_Node_Str"") != -1) {
        binariesFiles.add(file.toString() + ""String_Node_Str"");
      }
    }
    throw new IllegalActionException(this,""String_Node_Str"" + missingFunctions + ""String_Node_Str""+ ""String_Node_Str""+ _fmiModelDescription.modelIdentifier+ ""String_Node_Str""+ ""String_Node_Str""+ fmuFile.asFile()+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ sharedLibrary+ ""String_Node_Str""+ ""String_Node_Str""+ binariesFiles);
  }
}"
72730,"/** 
 * Free the instance of the FMU.
 * @exception IllegalActionException If the FMU does not return fmiOK.
 */
protected void _fmiFreeInstance() throws IllegalActionException {
  if (_debugging) {
    _debugToStdOut(""String_Node_Str"");
  }
  int fmiFlag=0;
  if (_fmiModelDescription.modelExchange) {
    if (_fmiVersion >= 1.5 && _fmiVersion < 2.0) {
      fmiFlag=((Integer)_fmiFreeModelInstanceFunction.invokeInt(new Object[]{_fmiComponent})).intValue();
      if (fmiFlag != FMILibrary.FMIStatus.fmiOK) {
        throw new IllegalActionException(this,""String_Node_Str"" + _fmiStatusDescription(fmiFlag));
      }
    }
  }
 else {
    if (_fmiVersion < 2.0) {
      _fmiFreeSlaveInstanceFunction.invokeInt(new Object[]{_fmiComponent});
    }
 else {
    }
  }
}","/** 
 * Free the instance of the FMU.
 * @exception IllegalActionException If the FMU does not return fmiOK.
 */
protected void _fmiFreeInstance() throws IllegalActionException {
  if (_debugging) {
    _debugToStdOut(""String_Node_Str"");
  }
  if (_fmiVersion < 2.0) {
    if (_fmiModelDescription.modelExchange) {
      _fmiFreeModelInstanceFunction.invokeInt(new Object[]{_fmiComponent});
    }
 else {
      _fmiFreeSlaveInstanceFunction.invokeInt(new Object[]{_fmiComponent});
    }
  }
 else {
    _fmiFreeInstanceFunction.invokeInt(new Object[]{_fmiComponent});
  }
}"
72731,"/** 
 * Invoke fmiDoStep() of the slave FMU, if necessary to catch up to current time, and then set the (known) inputs of the FMU and retrieve and send out any outputs for which all inputs on which the output depends are known.
 * @exception IllegalActionException If FMU indicates a failure.
 */
public void fire() throws IllegalActionException {
  super.fire();
  Director director=getDirector();
  Time currentTime=director.getModelTime();
  int currentMicrostep=1;
  if (director instanceof SuperdenseTimeDirector) {
    currentMicrostep=((SuperdenseTimeDirector)director).getIndex();
  }
  if (_debugging) {
    _debugToStdOut(""String_Node_Str"" + currentTime + ""String_Node_Str""+ currentMicrostep);
  }
  double derivatives[]=null;
  if (_fmiModelDescription.modelExchange) {
    if (!_firstFire) {
      derivatives=_fmiGetDerivatives();
    }
    _fmiSetTime(currentTime);
    if (_firstFire) {
      _fmiInitialize();
      _recordFMUState();
      _lastCommitTime=currentTime;
      _checkEventIndicators();
    }
    double states[]=_states.array();
    if (_newStates == null || _newStates.length != states.length) {
      _newStates=new double[states.length];
    }
  }
 else {
    if (_firstFire) {
      for (      Input input : _getInputs()) {
        if (input.start != null) {
          _setFMUScalarVariable(input.scalarVariable,new DoubleToken(input.start.doubleValue()));
          if (_debugging) {
            _debug(""String_Node_Str"" + input.port.getName() + ""String_Node_Str""+ input.start);
          }
        }
      }
    }
    double refinedStepSize=_fmiDoStep(currentTime,currentMicrostep);
    if (refinedStepSize >= 0.0) {
      _stepSizeRejected=true;
      if (_refinedStepSize < 0.0 || refinedStepSize < _refinedStepSize) {
        _refinedStepSize=refinedStepSize;
      }
    }
  }
  int _index;
  for (  Input input : _getInputs()) {
    if (input.port.getWidth() > 0 && input.port.isKnown(0)) {
      if (input.port.hasToken(0)) {
        Token token=input.port.get(0);
        _setFMUScalarVariable(input.scalarVariable,token);
        if ((_fmiVersion == 2.0) && _fmiModelDescription.modelExchange && _fmiModelDescription.continuousStates.contains(input.port.getName())) {
          _index=_fmiModelDescription.continuousStates.indexOf(input.port.getName());
          _newStates[_index]=((DoubleToken)token).doubleValue();
        }
        if (_debugging) {
          _debugToStdOut(""String_Node_Str"" + input.scalarVariable.name + ""String_Node_Str""+ token);
        }
      }
 else {
        boolean persistentInputsValue=((BooleanToken)persistentInputs.getToken()).booleanValue();
        if (!persistentInputsValue) {
          throw new IllegalActionException(this,""String_Node_Str"" + input.scalarVariable.name + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
        }
 else {
          if (_debugging) {
            _debug(""String_Node_Str"" + input.port.getName() + ""String_Node_Str"");
          }
        }
      }
    }
 else {
      if (_debugging) {
        _debug(""String_Node_Str"" + input.port.getName() + ""String_Node_Str"");
      }
    }
  }
  if (_fmiModelDescription.modelExchange) {
    double currentTimeValue=currentTime.getDoubleValue();
    double states[]=_states.array();
    if (currentTimeValue > _lastCommitTime.getDoubleValue()) {
      if (states.length > 0) {
        if (_fmiVersion < 2.0) {
          double step=currentTimeValue - _lastCommitTime.getDoubleValue();
          for (int i=0; i < states.length; i++) {
            _newStates[i]=states[i] + derivatives[i] * step;
          }
        }
        _fmiSetContinuousStates(_newStates);
      }
      boolean stateEventOccurred=_checkEventIndicators();
      boolean timeEventOccurred=false;
      _fmiCompletedIntegratorStep(stateEventOccurred || timeEventOccurred);
    }
 else {
    }
  }
  for (  Output output : _getOutputs()) {
    TypedIOPort port=output.port;
    if (_skipIfKnown() && port.isKnown(0)) {
      continue;
    }
    boolean foundUnknownInputOnWhichOutputDepends=false;
    if (output.dependencies != null) {
      for (      TypedIOPort inputPort : output.dependencies) {
        if (!inputPort.isKnown(0)) {
          if (_debugging) {
            _debugToStdOut(""String_Node_Str"" + ""String_Node_Str"" + port.getName() + ""String_Node_Str""+ inputPort.getName()+ ""String_Node_Str"");
          }
          foundUnknownInputOnWhichOutputDepends=true;
          break;
        }
      }
    }
 else {
      List<TypedIOPort> inputPorts=inputPortList();
      for (      TypedIOPort inputPort : inputPorts) {
        if (inputPort.getWidth() < 0 || !inputPort.isKnown(0)) {
          foundUnknownInputOnWhichOutputDepends=true;
          if (_debugging) {
            _debugToStdOut(""String_Node_Str"" + ""String_Node_Str"" + port.getName() + ""String_Node_Str""+ inputPort.getName()+ ""String_Node_Str"");
          }
          break;
        }
      }
    }
    if (!foundUnknownInputOnWhichOutputDepends) {
      Token token=null;
      FMIScalarVariable scalarVariable=output.scalarVariable;
      if (scalarVariable.type instanceof FMIBooleanType) {
        boolean result=scalarVariable.getBoolean(_fmiComponent);
        token=new BooleanToken(result);
      }
 else       if (scalarVariable.type instanceof FMIIntegerType) {
        int result=scalarVariable.getInt(_fmiComponent);
        token=new IntToken(result);
      }
 else       if (scalarVariable.type instanceof FMIRealType) {
        double result=scalarVariable.getDouble(_fmiComponent);
        token=new DoubleToken(result);
      }
 else       if (scalarVariable.type instanceof FMIStringType) {
        String result=scalarVariable.getString(_fmiComponent);
        token=new StringToken(result);
      }
 else {
        throw new IllegalActionException(""String_Node_Str"" + scalarVariable.type + ""String_Node_Str"");
      }
      if (_debugging) {
        _debugToStdOut(""String_Node_Str"" + scalarVariable.name + ""String_Node_Str""+ token+ ""String_Node_Str""+ currentTime+ ""String_Node_Str""+ currentMicrostep);
      }
      port.send(0,token);
    }
  }
  _firstFireInIteration=false;
  _firstFire=false;
}","/** 
 * Invoke fmiDoStep() of the slave FMU, if necessary to catch up to current time, and then set the (known) inputs of the FMU and retrieve and send out any outputs for which all inputs on which the output depends are known.
 * @exception IllegalActionException If FMU indicates a failure.
 */
public void fire() throws IllegalActionException {
  super.fire();
  Director director=getDirector();
  Time currentTime=director.getModelTime();
  int currentMicrostep=1;
  if (director instanceof SuperdenseTimeDirector) {
    currentMicrostep=((SuperdenseTimeDirector)director).getIndex();
  }
  if (_debugging) {
    _debugToStdOut(""String_Node_Str"" + currentTime + ""String_Node_Str""+ currentMicrostep);
  }
  double derivatives[]=null;
  if (_fmiModelDescription.modelExchange) {
    if (!_firstFire) {
      derivatives=_fmiGetDerivatives();
    }
    _fmiSetTime(currentTime);
    if (_firstFire) {
      _fmiInitialize();
      _recordFMUState();
      _lastCommitTime=currentTime;
      _checkEventIndicators();
    }
    double states[]=_states.array();
    if (_newStates == null || _newStates.length != states.length) {
      _newStates=new double[states.length];
    }
  }
 else {
    if (_firstFire) {
      for (      Input input : _getInputs()) {
        if (input.start != null) {
          _setFMUScalarVariable(input.scalarVariable,new DoubleToken(input.start.doubleValue()));
          if (_debugging) {
            _debug(""String_Node_Str"" + input.port.getName() + ""String_Node_Str""+ input.start);
          }
        }
      }
    }
    double refinedStepSize=_fmiDoStep(currentTime,currentMicrostep);
    if (refinedStepSize >= 0.0) {
      _stepSizeRejected=true;
      if (_refinedStepSize < 0.0 || refinedStepSize < _refinedStepSize) {
        _refinedStepSize=refinedStepSize;
      }
    }
  }
  int _index;
  for (  Input input : _getInputs()) {
    if (input.port.getWidth() > 0 && input.port.isKnown(0)) {
      if (input.port.hasToken(0)) {
        Token token=input.port.get(0);
        _setFMUScalarVariable(input.scalarVariable,token);
        if ((_fmiVersion >= 2.0) && _fmiModelDescription.modelExchange && _fmiModelDescription.continuousStates.contains(input.port.getName())) {
          _index=_fmiModelDescription.continuousStates.indexOf(input.port.getName());
          _newStates[_index]=((DoubleToken)token).doubleValue();
        }
        if (_debugging) {
          _debugToStdOut(""String_Node_Str"" + input.scalarVariable.name + ""String_Node_Str""+ token);
        }
      }
 else {
        boolean persistentInputsValue=((BooleanToken)persistentInputs.getToken()).booleanValue();
        if (!persistentInputsValue) {
          throw new IllegalActionException(this,""String_Node_Str"" + input.scalarVariable.name + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
        }
 else {
          if (_debugging) {
            _debug(""String_Node_Str"" + input.port.getName() + ""String_Node_Str"");
          }
        }
      }
    }
 else {
      if (_debugging) {
        _debug(""String_Node_Str"" + input.port.getName() + ""String_Node_Str"");
      }
    }
  }
  if (_fmiModelDescription.modelExchange) {
    double currentTimeValue=currentTime.getDoubleValue();
    double states[]=_states.array();
    if (currentTimeValue > _lastCommitTime.getDoubleValue()) {
      if (states.length > 0) {
        if (_fmiVersion < 2.0) {
          double step=currentTimeValue - _lastCommitTime.getDoubleValue();
          for (int i=0; i < states.length; i++) {
            _newStates[i]=states[i] + derivatives[i] * step;
          }
        }
        _fmiSetContinuousStates(_newStates);
      }
      boolean stateEventOccurred=_checkEventIndicators();
      boolean timeEventOccurred=false;
      _fmiCompletedIntegratorStep(stateEventOccurred || timeEventOccurred);
    }
 else {
    }
  }
  for (  Output output : _getOutputs()) {
    TypedIOPort port=output.port;
    if (_skipIfKnown() && port.isKnown(0)) {
      continue;
    }
    boolean foundUnknownInputOnWhichOutputDepends=false;
    if (output.dependencies != null) {
      for (      TypedIOPort inputPort : output.dependencies) {
        if (!inputPort.isKnown(0)) {
          if (_debugging) {
            _debugToStdOut(""String_Node_Str"" + ""String_Node_Str"" + port.getName() + ""String_Node_Str""+ inputPort.getName()+ ""String_Node_Str"");
          }
          foundUnknownInputOnWhichOutputDepends=true;
          break;
        }
      }
    }
 else {
      List<TypedIOPort> inputPorts=inputPortList();
      for (      TypedIOPort inputPort : inputPorts) {
        if (inputPort.getWidth() < 0 || !inputPort.isKnown(0)) {
          foundUnknownInputOnWhichOutputDepends=true;
          if (_debugging) {
            _debugToStdOut(""String_Node_Str"" + ""String_Node_Str"" + port.getName() + ""String_Node_Str""+ inputPort.getName()+ ""String_Node_Str"");
          }
          break;
        }
      }
    }
    if (!foundUnknownInputOnWhichOutputDepends) {
      Token token=null;
      FMIScalarVariable scalarVariable=output.scalarVariable;
      if (scalarVariable.type instanceof FMIBooleanType) {
        boolean result=scalarVariable.getBoolean(_fmiComponent);
        token=new BooleanToken(result);
      }
 else       if (scalarVariable.type instanceof FMIIntegerType) {
        int result=scalarVariable.getInt(_fmiComponent);
        token=new IntToken(result);
      }
 else       if (scalarVariable.type instanceof FMIRealType) {
        double result=scalarVariable.getDouble(_fmiComponent);
        token=new DoubleToken(result);
      }
 else       if (scalarVariable.type instanceof FMIStringType) {
        String result=scalarVariable.getString(_fmiComponent);
        token=new StringToken(result);
      }
 else {
        throw new IllegalActionException(""String_Node_Str"" + scalarVariable.type + ""String_Node_Str"");
      }
      if (_debugging) {
        _debugToStdOut(""String_Node_Str"" + scalarVariable.name + ""String_Node_Str""+ token+ ""String_Node_Str""+ currentTime+ ""String_Node_Str""+ currentMicrostep);
      }
      port.send(0,token);
    }
  }
  _firstFireInIteration=false;
  _firstFire=false;
}"
72732,"/** 
 * Instantiate the slave FMU component.
 * @exception IllegalActionException if it cannot be instantiated.
 */
public void preinitialize() throws IllegalActionException {
  if (_fmiModelDescription == null) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  super.preinitialize();
  if (_debugging) {
    _debugToStdOut(""String_Node_Str"");
  }
  try {
    _nativeLibrary=_fmiModelDescription.getNativeLibrary();
  }
 catch (  IOException e1) {
    throw new IllegalActionException(this,e1,""String_Node_Str"");
  }
  if (_nativeLibrary == null) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  _checkFmiCommon();
  try {
    if (_fmiModelDescription.modelExchange) {
      try {
        if (_fmiVersion < 2.0 || !_completedIntegratorStepNotNeeded()) {
          _fmiCompletedIntegratorStepFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        }
      }
 catch (      Throwable throwable) {
        throw new IllegalActionException(this,throwable,""String_Node_Str"" + _fmuFileName + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      }
      if (_fmiVersion < 2.0) {
        _fmiFreeModelInstanceFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
      _fmiGetContinuousStatesFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      _fmiSetContinuousStates=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      _fmiGetDerivativesFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      try {
        _fmiGetEventIndicatorsFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
 catch (      UnsatisfiedLinkError ex) {
        _fmiGetEventIndicatorsFunction=null;
      }
      if (_fmiVersion < 2.0) {
        _fmiInitializeFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiInstantiateModelFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
 else {
        _fmiEnterInitializationModeFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiExitInitializationModeFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiInstantiateFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
      _fmiSetTimeFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      _fmiTerminateFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      _checkFmiModelExchange();
    }
 else {
      _fmiDoStepFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      if (_fmiVersion < 2.0) {
        try {
          _fmiFreeSlaveInstanceFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        }
 catch (        UnsatisfiedLinkError ex) {
          throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
        }
      }
 else {
        try {
          _fmiFreeInstanceFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        }
 catch (        UnsatisfiedLinkError ex) {
          throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
        }
      }
      if (_fmiVersion < 2.0) {
        _fmiInitializeSlaveFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiInstantiateSlaveFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
 else {
        _fmiInstantiateFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
      if (_fmiVersion < 2.0) {
        _fmiTerminateSlaveFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
 else {
        _fmiTerminateFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
      try {
        _fmiGetRealStatusFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
 catch (      UnsatisfiedLinkError ex) {
        _fmiGetRealStatusFunction=null;
      }
      if (_fmiModelDescription.canGetAndSetFMUstate) {
        _fmiFreeFMUstateFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiGetFMUstateFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiSetFMUstate=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
 else {
        _fmiFreeFMUstateFunction=null;
        _fmiGetFMUstateFunction=null;
        _fmiSetFMUstate=null;
      }
      _checkFmiCoSimulation();
    }
  }
 catch (  IOException ex) {
    throw new IllegalActionException(this,ex,""String_Node_Str"");
  }
  String modelIdentifier=_fmiModelDescription.modelIdentifier;
  String mimeType=""String_Node_Str"";
  double timeout=1000;
  byte toBeVisible=0;
  if (((BooleanToken)visible.getToken()).booleanValue()) {
    toBeVisible=1;
  }
  byte interactive=0;
  byte loggingOn=_debugging ? (byte)1 : (byte)0;
  if (_fmiVersion < 1.5) {
    _callbacks=new FMICallbackFunctions.ByValue(new FMULibrary.FMULogger(_fmiModelDescription),new FMULibrary.FMUAllocateMemory(),new FMULibrary.FMUFreeMemory(),new FMULibrary.FMUStepFinished());
    if (_fmiModelDescription.modelExchange) {
      if (_debugging) {
        _debugToStdOut(""String_Node_Str"" + modelIdentifier + ""String_Node_Str"");
      }
      _fmiComponent=(Pointer)_fmiInstantiateModelFunction.invoke(Pointer.class,new Object[]{getFullName(),_fmiModelDescription.guid,_callbacks,loggingOn});
    }
 else {
      if (_debugging) {
        _debugToStdOut(""String_Node_Str"" + modelIdentifier + ""String_Node_Str"");
      }
      _fmiComponent=(Pointer)_fmiInstantiateSlaveFunction.invoke(Pointer.class,new Object[]{getFullName(),_fmiModelDescription.guid,_fmiModelDescription.fmuResourceLocation,mimeType,timeout,toBeVisible,interactive,_callbacks,loggingOn});
    }
  }
 else {
    _callbacks=new FMICallbackFunctions(new FMULibrary.FMULogger(_fmiModelDescription),new FMULibrary.FMUAllocateMemory(),new FMULibrary.FMUFreeMemory(),new FMULibrary.FMUStepFinished());
    if (_debugging) {
      _debugToStdOut(""String_Node_Str"" + modelIdentifier + ""String_Node_Str"");
    }
    int fmiType=1;
    if (_fmiModelDescription.modelExchange) {
      fmiType=0;
    }
    if (_fmiVersion < 2.0) {
      if (_fmiModelDescription.modelExchange) {
        throw new IllegalActionException(this,""String_Node_Str"" + _fmiVersion);
      }
 else {
        _fmiComponent=(Pointer)_fmiInstantiateSlaveFunction.invoke(Pointer.class,new Object[]{getFullName(),_fmiModelDescription.guid,_fmiModelDescription.fmuResourceLocation,_callbacks,toBeVisible,loggingOn});
      }
    }
 else     if (_fmiVersion >= 2.0) {
      _fmiComponent=(Pointer)_fmiInstantiateFunction.invoke(Pointer.class,new Object[]{getFullName(),fmiType,_fmiModelDescription.guid,_fmiModelDescription.fmuResourceLocation,_callbacks,toBeVisible,loggingOn});
      if (_fmiComponent != null && _fmiComponent.equals(Pointer.NULL)) {
        int fmiFlag=((Integer)_fmiEnterInitializationModeFunction.invoke(Integer.class,new Object[]{_fmiComponent})).intValue();
        if (fmiFlag != FMILibrary.FMIStatus.fmiOK) {
          throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + _fmiStatusDescription(fmiFlag));
        }
        fmiFlag=((Integer)_fmiExitInitializationModeFunction.invoke(Integer.class,new Object[]{_fmiComponent})).intValue();
        if (fmiFlag != FMILibrary.FMIStatus.fmiOK) {
          throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + _fmiStatusDescription(fmiFlag));
        }
      }
    }
  }
  if (_fmiComponent == null || _fmiComponent.equals(Pointer.NULL)) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
}","/** 
 * Instantiate the slave FMU component.
 * @exception IllegalActionException if it cannot be instantiated.
 */
public void preinitialize() throws IllegalActionException {
  if (_fmiModelDescription == null) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  super.preinitialize();
  if (_debugging) {
    _debugToStdOut(""String_Node_Str"");
  }
  try {
    _nativeLibrary=_fmiModelDescription.getNativeLibrary();
  }
 catch (  IOException e1) {
    throw new IllegalActionException(this,e1,""String_Node_Str"");
  }
  if (_nativeLibrary == null) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  _checkFmiCommon();
  try {
    if (_fmiModelDescription.modelExchange) {
      try {
        if (_fmiVersion < 2.0 || !_completedIntegratorStepNotNeeded()) {
          _fmiCompletedIntegratorStepFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        }
      }
 catch (      Throwable throwable) {
        throw new IllegalActionException(this,throwable,""String_Node_Str"" + _fmuFileName + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      }
      if (_fmiVersion < 2.0) {
        try {
          _fmiFreeModelInstanceFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        }
 catch (        UnsatisfiedLinkError ex) {
          throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
        }
      }
 else {
        try {
          _fmiFreeInstanceFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        }
 catch (        UnsatisfiedLinkError ex) {
          throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
        }
      }
      _fmiGetContinuousStatesFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      _fmiSetContinuousStates=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      _fmiGetDerivativesFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      try {
        _fmiGetEventIndicatorsFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
 catch (      UnsatisfiedLinkError ex) {
        _fmiGetEventIndicatorsFunction=null;
      }
      if (_fmiVersion < 2.0) {
        _fmiInitializeFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiInstantiateModelFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
 else {
        _fmiEnterInitializationModeFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiExitInitializationModeFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiInstantiateFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
      _fmiSetTimeFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      _fmiTerminateFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      _checkFmiModelExchange();
    }
 else {
      _fmiDoStepFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      if (_fmiVersion < 2.0) {
        try {
          _fmiFreeSlaveInstanceFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        }
 catch (        UnsatisfiedLinkError ex) {
          throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
        }
      }
 else {
        try {
          _fmiFreeInstanceFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        }
 catch (        UnsatisfiedLinkError ex) {
          throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
        }
      }
      if (_fmiVersion < 2.0) {
        _fmiInitializeSlaveFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiInstantiateSlaveFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
 else {
        _fmiInstantiateFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
      if (_fmiVersion < 2.0) {
        _fmiTerminateSlaveFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
 else {
        _fmiTerminateFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
      try {
        _fmiGetRealStatusFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
 catch (      UnsatisfiedLinkError ex) {
        _fmiGetRealStatusFunction=null;
      }
      if (_fmiModelDescription.canGetAndSetFMUstate) {
        _fmiFreeFMUstateFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiGetFMUstateFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiSetFMUstate=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
 else {
        _fmiFreeFMUstateFunction=null;
        _fmiGetFMUstateFunction=null;
        _fmiSetFMUstate=null;
      }
      _checkFmiCoSimulation();
    }
  }
 catch (  IOException ex) {
    throw new IllegalActionException(this,ex,""String_Node_Str"");
  }
  String modelIdentifier=_fmiModelDescription.modelIdentifier;
  String mimeType=""String_Node_Str"";
  double timeout=1000;
  byte toBeVisible=0;
  if (((BooleanToken)visible.getToken()).booleanValue()) {
    toBeVisible=1;
  }
  byte interactive=0;
  byte loggingOn=_debugging ? (byte)1 : (byte)0;
  if (_fmiVersion < 1.5) {
    _callbacks=new FMICallbackFunctions.ByValue(new FMULibrary.FMULogger(_fmiModelDescription),new FMULibrary.FMUAllocateMemory(),new FMULibrary.FMUFreeMemory(),new FMULibrary.FMUStepFinished());
    if (_fmiModelDescription.modelExchange) {
      if (_debugging) {
        _debugToStdOut(""String_Node_Str"" + modelIdentifier + ""String_Node_Str"");
      }
      _fmiComponent=(Pointer)_fmiInstantiateModelFunction.invoke(Pointer.class,new Object[]{getFullName(),_fmiModelDescription.guid,_callbacks,loggingOn});
    }
 else {
      if (_debugging) {
        _debugToStdOut(""String_Node_Str"" + modelIdentifier + ""String_Node_Str"");
      }
      _fmiComponent=(Pointer)_fmiInstantiateSlaveFunction.invoke(Pointer.class,new Object[]{getFullName(),_fmiModelDescription.guid,_fmiModelDescription.fmuResourceLocation,mimeType,timeout,toBeVisible,interactive,_callbacks,loggingOn});
    }
  }
 else {
    _callbacks=new FMICallbackFunctions(new FMULibrary.FMULogger(_fmiModelDescription),new FMULibrary.FMUAllocateMemory(),new FMULibrary.FMUFreeMemory(),new FMULibrary.FMUStepFinished());
    if (_debugging) {
      _debugToStdOut(""String_Node_Str"" + modelIdentifier + ""String_Node_Str"");
    }
    int fmiType=1;
    if (_fmiModelDescription.modelExchange) {
      fmiType=0;
    }
    if (_fmiVersion < 2.0) {
      if (_fmiModelDescription.modelExchange) {
        throw new IllegalActionException(this,""String_Node_Str"" + _fmiVersion);
      }
 else {
        _fmiComponent=(Pointer)_fmiInstantiateSlaveFunction.invoke(Pointer.class,new Object[]{getFullName(),_fmiModelDescription.guid,_fmiModelDescription.fmuResourceLocation,_callbacks,toBeVisible,loggingOn});
      }
    }
 else     if (_fmiVersion >= 2.0) {
      _fmiComponent=(Pointer)_fmiInstantiateFunction.invoke(Pointer.class,new Object[]{getFullName(),fmiType,_fmiModelDescription.guid,_fmiModelDescription.fmuResourceLocation,_callbacks,toBeVisible,loggingOn});
      if (_fmiComponent != null && _fmiComponent.equals(Pointer.NULL)) {
        int fmiFlag=((Integer)_fmiEnterInitializationModeFunction.invoke(Integer.class,new Object[]{_fmiComponent})).intValue();
        if (fmiFlag != FMILibrary.FMIStatus.fmiOK) {
          throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + _fmiStatusDescription(fmiFlag));
        }
        fmiFlag=((Integer)_fmiExitInitializationModeFunction.invoke(Integer.class,new Object[]{_fmiComponent})).intValue();
        if (fmiFlag != FMILibrary.FMIStatus.fmiOK) {
          throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + _fmiStatusDescription(fmiFlag));
        }
      }
    }
  }
  if (_fmiComponent == null || _fmiComponent.equals(Pointer.NULL)) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
}"
72733,"/** 
 * If functions needed for co-simulation are absent, then thrown an exception with an informative message.  The .fmu file may not have a shared library for the current platform.
 * @exception IllegalActionException If functions needed for co-simulationare missing.
 */
private void _checkFmiCoSimulation() throws IllegalActionException {
  String missingFunction=null;
  if (_fmiDoStepFunction == null) {
    missingFunction=""String_Node_Str"";
  }
  if (_fmiInstantiateSlaveFunction == null) {
    missingFunction=""String_Node_Str"";
  }
  if (_fmiTerminateSlaveFunction == null) {
    missingFunction=""String_Node_Str"";
  }
  if (_fmiFreeSlaveInstanceFunction == null) {
    missingFunction=""String_Node_Str"";
  }
  if (missingFunction != null) {
    String sharedLibrary=""String_Node_Str"";
    try {
      sharedLibrary=""String_Node_Str"" + FMUFile.fmuSharedLibrary(_fmiModelDescription) + ""String_Node_Str"";
    }
 catch (    IOException ex) {
      sharedLibrary=""String_Node_Str"" + ex;
    }
    List<String> binariesFiles=new LinkedList<String>();
    for (    File file : _fmiModelDescription.files) {
      if (file.toString().indexOf(""String_Node_Str"") != -1) {
        binariesFiles.add(file.toString() + ""String_Node_Str"");
      }
    }
    throw new IllegalActionException(this,""String_Node_Str"" + _fmiModelDescription.modelIdentifier + missingFunction+ ""String_Node_Str""+ fmuFile.asFile()+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ sharedLibrary+ ""String_Node_Str""+ ""String_Node_Str""+ binariesFiles);
  }
}","/** 
 * If functions needed for co-simulation are absent, then thrown an exception with an informative message.  The .fmu file may not have a shared library for the current platform.
 * @exception IllegalActionException If functions needed for co-simulationare missing.
 */
private void _checkFmiCoSimulation() throws IllegalActionException {
  String missingFunction=null;
  if (_fmiDoStepFunction == null) {
    missingFunction=""String_Node_Str"";
  }
  if (_fmiVersion < 2.0) {
    if (_fmiInstantiateSlaveFunction == null) {
      missingFunction=""String_Node_Str"";
    }
    if (_fmiTerminateSlaveFunction == null) {
      missingFunction=""String_Node_Str"";
    }
    if (_fmiFreeSlaveInstanceFunction == null) {
      missingFunction=""String_Node_Str"";
    }
  }
 else {
    if (_fmiInstantiateFunction == null) {
      missingFunction=""String_Node_Str"";
    }
    if (_fmiTerminateFunction == null) {
      missingFunction=""String_Node_Str"";
    }
    if (_fmiFreeInstanceFunction == null) {
      missingFunction=""String_Node_Str"";
    }
  }
  if (missingFunction != null) {
    String sharedLibrary=""String_Node_Str"";
    try {
      sharedLibrary=""String_Node_Str"" + FMUFile.fmuSharedLibrary(_fmiModelDescription) + ""String_Node_Str"";
    }
 catch (    IOException ex) {
      sharedLibrary=""String_Node_Str"" + ex;
    }
    List<String> binariesFiles=new LinkedList<String>();
    for (    File file : _fmiModelDescription.files) {
      if (file.toString().indexOf(""String_Node_Str"") != -1) {
        binariesFiles.add(file.toString() + ""String_Node_Str"");
      }
    }
    throw new IllegalActionException(this,""String_Node_Str"" + _fmiModelDescription.modelIdentifier + missingFunction+ ""String_Node_Str""+ fmuFile.asFile()+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ sharedLibrary+ ""String_Node_Str""+ ""String_Node_Str""+ binariesFiles);
  }
}"
72734,"/** 
 * Invoke _fmiInitialize() (for model exchange) or _fmiInitializeSlave() (for co-simulation) on the FMU. In the case of model exchange, this method also checks for a returned next event time and calls fireAt() on the director if a next event time is returned. In the case of co-simulation, if the FMU provides a maximum step size, get that from the FMU and call fireAt() as well.
 * @exception IllegalActionException If the FMU does not return fmiOK.
 */
@SuppressWarnings(""String_Node_Str"") protected void _fmiInitialize() throws IllegalActionException {
  if (_fmiModelDescription.modelExchange) {
    if (_fmiVersion < 1.5) {
      FMIEventInfo eventInfo=new FMIEventInfo.ByValue();
      int fmiFlag=((Integer)_fmiInitializeFunction.invoke(Integer.class,new Object[]{_fmiComponent,_toleranceControlled,_relativeTolerance,eventInfo.getPointer()})).intValue();
      if (fmiFlag != FMILibrary.FMIStatus.fmiOK) {
        throw new IllegalActionException(this,""String_Node_Str"" + _fmiStatusDescription(fmiFlag));
      }
      if (eventInfo.terminateSimulation != (byte)0) {
        throw new IllegalActionException(this,""String_Node_Str"");
      }
      if (eventInfo.upcomingTimeEvent != (byte)0) {
        getDirector().fireAt(this,eventInfo.nextEventTime);
      }
    }
 else {
      int fmiFlag=((Integer)_fmiEnterInitializationModeFunction.invoke(Integer.class,new Object[]{_fmiComponent})).intValue();
      if (fmiFlag != FMILibrary.FMIStatus.fmiOK) {
        throw new IllegalActionException(this,""String_Node_Str"" + _fmiStatusDescription(fmiFlag));
      }
      if (_fmiModelDescription.numberOfEventIndicators > 0) {
        new Exception(""String_Node_Str"").printStackTrace();
      }
    }
  }
 else {
    String modelIdentifier=_fmiModelDescription.modelIdentifier;
    Director director=getDirector();
    Time startTime=director.getModelStartTime();
    Time stopTime=director.getModelStopTime();
    int fmiFlag;
    if (_fmiVersion < 1.5) {
      fmiFlag=((Integer)_fmiInitializeSlaveFunction.invoke(Integer.class,new Object[]{_fmiComponent,startTime.getDoubleValue(),(byte)1,stopTime.getDoubleValue()})).intValue();
    }
 else {
      fmiFlag=((Integer)_fmiInitializeSlaveFunction.invoke(Integer.class,new Object[]{_fmiComponent,_relativeTolerance,startTime.getDoubleValue(),(byte)1,stopTime.getDoubleValue()})).intValue();
      _requestRefiringIfNecessary();
      _recordFMUState();
    }
    if (fmiFlag > FMILibrary.FMIStatus.fmiWarning) {
      throw new IllegalActionException(this,""String_Node_Str"" + modelIdentifier + ""String_Node_Str""+ startTime.getDoubleValue()+ ""String_Node_Str""+ stopTime.getDoubleValue()+ ""String_Node_Str""+ _fmiStatusDescription(fmiFlag));
    }
  }
  if (_debugging) {
    _debugToStdOut(""String_Node_Str"");
  }
  _modelInitialized=true;
}","/** 
 * Invoke _fmiInitialize() (for model exchange) or _fmiInitializeSlave() (for co-simulation) on the FMU. In the case of model exchange, this method also checks for a returned next event time and calls fireAt() on the director if a next event time is returned. In the case of co-simulation, if the FMU provides a maximum step size, get that from the FMU and call fireAt() as well.
 * @exception IllegalActionException If the FMU does not return fmiOK.
 */
@SuppressWarnings(""String_Node_Str"") protected void _fmiInitialize() throws IllegalActionException {
  if (_fmiModelDescription.modelExchange) {
    if (_fmiVersion < 1.5) {
      FMIEventInfo eventInfo=new FMIEventInfo.ByValue();
      int fmiFlag=((Integer)_fmiInitializeFunction.invoke(Integer.class,new Object[]{_fmiComponent,_toleranceControlled,_relativeTolerance,eventInfo.getPointer()})).intValue();
      if (fmiFlag != FMILibrary.FMIStatus.fmiOK) {
        throw new IllegalActionException(this,""String_Node_Str"" + _fmiStatusDescription(fmiFlag));
      }
      if (eventInfo.terminateSimulation != (byte)0) {
        throw new IllegalActionException(this,""String_Node_Str"");
      }
      if (eventInfo.upcomingTimeEvent != (byte)0) {
        getDirector().fireAt(this,eventInfo.nextEventTime);
      }
    }
 else {
      int fmiFlag=((Integer)_fmiEnterInitializationModeFunction.invoke(Integer.class,new Object[]{_fmiComponent})).intValue();
      if (fmiFlag != FMILibrary.FMIStatus.fmiOK) {
        throw new IllegalActionException(this,""String_Node_Str"" + _fmiStatusDescription(fmiFlag));
      }
      fmiFlag=((Integer)_fmiExitInitializationModeFunction.invoke(Integer.class,new Object[]{_fmiComponent})).intValue();
      if (fmiFlag != FMILibrary.FMIStatus.fmiOK) {
        throw new IllegalActionException(this,""String_Node_Str"" + _fmiStatusDescription(fmiFlag));
      }
      if (_fmiModelDescription.numberOfEventIndicators > 0) {
        new Exception(""String_Node_Str"").printStackTrace();
      }
    }
  }
 else {
    String modelIdentifier=_fmiModelDescription.modelIdentifier;
    Director director=getDirector();
    Time startTime=director.getModelStartTime();
    Time stopTime=director.getModelStopTime();
    int fmiFlag;
    if (_fmiVersion < 1.5) {
      fmiFlag=((Integer)_fmiInitializeSlaveFunction.invoke(Integer.class,new Object[]{_fmiComponent,startTime.getDoubleValue(),(byte)1,stopTime.getDoubleValue()})).intValue();
    }
 else {
      fmiFlag=((Integer)_fmiEnterInitializationModeFunction.invoke(Integer.class,new Object[]{_fmiComponent})).intValue();
      if (fmiFlag != FMILibrary.FMIStatus.fmiOK) {
        throw new IllegalActionException(this,""String_Node_Str"" + _fmiStatusDescription(fmiFlag));
      }
      fmiFlag=((Integer)_fmiExitInitializationModeFunction.invoke(Integer.class,new Object[]{_fmiComponent})).intValue();
      if (fmiFlag != FMILibrary.FMIStatus.fmiOK) {
        throw new IllegalActionException(this,""String_Node_Str"" + _fmiStatusDescription(fmiFlag));
      }
      _requestRefiringIfNecessary();
      _recordFMUState();
    }
    if (fmiFlag > FMILibrary.FMIStatus.fmiWarning) {
      throw new IllegalActionException(this,""String_Node_Str"" + modelIdentifier + ""String_Node_Str""+ startTime.getDoubleValue()+ ""String_Node_Str""+ stopTime.getDoubleValue()+ ""String_Node_Str""+ _fmiStatusDescription(fmiFlag));
    }
  }
  if (_debugging) {
    _debugToStdOut(""String_Node_Str"");
  }
  _modelInitialized=true;
}"
72735,"/** 
 * Free the instance of the FMU.
 * @exception IllegalActionException If the FMU does not return fmiOK.
 */
protected void _fmiFreeInstance() throws IllegalActionException {
  if (_debugging) {
    _debugToStdOut(""String_Node_Str"");
  }
  int fmiFlag=0;
  if (_fmiModelDescription.modelExchange) {
    if (_fmiVersion >= 1.5 && _fmiVersion < 2.0) {
      fmiFlag=((Integer)_fmiFreeModelInstanceFunction.invokeInt(new Object[]{_fmiComponent})).intValue();
      if (fmiFlag != FMILibrary.FMIStatus.fmiOK) {
        throw new IllegalActionException(this,""String_Node_Str"" + _fmiStatusDescription(fmiFlag));
      }
    }
  }
 else {
    if (_fmiVersion < 2.0) {
      _fmiFreeSlaveInstanceFunction.invokeInt(new Object[]{_fmiComponent});
    }
 else {
    }
  }
}","/** 
 * Free the instance of the FMU.
 * @exception IllegalActionException If the FMU does not return fmiOK.
 */
protected void _fmiFreeInstance() throws IllegalActionException {
  if (_debugging) {
    _debugToStdOut(""String_Node_Str"");
  }
  int fmiFlag=0;
  if (_fmiVersion < 2.0) {
    if (_fmiModelDescription.modelExchange) {
      if (_fmiVersion >= 1.5 && _fmiVersion < 2.0) {
        fmiFlag=((Integer)_fmiFreeModelInstanceFunction.invokeInt(new Object[]{_fmiComponent})).intValue();
        if (fmiFlag != FMILibrary.FMIStatus.fmiOK) {
          throw new IllegalActionException(this,""String_Node_Str"" + _fmiStatusDescription(fmiFlag));
        }
      }
    }
 else {
      _fmiFreeSlaveInstanceFunction.invokeInt(new Object[]{_fmiComponent});
    }
  }
 else {
    _fmiFreeInstanceFunction.invokeInt(new Object[]{_fmiComponent});
  }
}"
72736,"/** 
 * Invoke fmiDoStep() of the slave FMU, if necessary to catch up to current time, and then set the (known) inputs of the FMU and retrieve and send out any outputs for which all inputs on which the output depends are known.
 * @exception IllegalActionException If FMU indicates a failure.
 */
public void fire() throws IllegalActionException {
  super.fire();
  Director director=getDirector();
  Time currentTime=director.getModelTime();
  int currentMicrostep=1;
  if (director instanceof SuperdenseTimeDirector) {
    currentMicrostep=((SuperdenseTimeDirector)director).getIndex();
  }
  if (_debugging) {
    _debugToStdOut(""String_Node_Str"" + currentTime + ""String_Node_Str""+ currentMicrostep);
  }
  double derivatives[]=null;
  if (_fmiModelDescription.modelExchange) {
    if (!_firstFire) {
      derivatives=_fmiGetDerivatives();
    }
    _fmiSetTime(currentTime);
    if (_firstFire) {
      _fmiInitialize();
      _recordFMUState();
      _lastCommitTime=currentTime;
      _checkEventIndicators();
    }
    double states[]=_states.array();
    if (_newStates == null || _newStates.length != states.length) {
      _newStates=new double[states.length];
    }
  }
 else {
    if (_firstFire) {
      for (      Input input : _getInputs()) {
        if (input.start != null) {
          _setFMUScalarVariable(input.scalarVariable,new DoubleToken(input.start.doubleValue()));
          if (_debugging) {
            _debug(""String_Node_Str"" + input.port.getName() + ""String_Node_Str""+ input.start);
          }
        }
      }
    }
    double refinedStepSize=_fmiDoStep(currentTime,currentMicrostep);
    if (refinedStepSize >= 0.0) {
      _stepSizeRejected=true;
      if (_refinedStepSize < 0.0 || refinedStepSize < _refinedStepSize) {
        _refinedStepSize=refinedStepSize;
      }
    }
  }
  int _index;
  for (  Input input : _getInputs()) {
    if (input.port.getWidth() > 0 && input.port.isKnown(0)) {
      if (input.port.hasToken(0)) {
        Token token=input.port.get(0);
        _setFMUScalarVariable(input.scalarVariable,token);
        if ((_fmiVersion == 2.0) && _fmiModelDescription.modelExchange && _fmiModelDescription.continuousStates.contains(input.port.getName())) {
          _index=_fmiModelDescription.continuousStates.indexOf(input.port.getName());
          _newStates[_index]=((DoubleToken)token).doubleValue();
        }
        if (_debugging) {
          _debugToStdOut(""String_Node_Str"" + input.scalarVariable.name + ""String_Node_Str""+ token);
        }
      }
 else {
        boolean persistentInputsValue=((BooleanToken)persistentInputs.getToken()).booleanValue();
        if (!persistentInputsValue) {
          throw new IllegalActionException(this,""String_Node_Str"" + input.scalarVariable.name + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
        }
 else {
          if (_debugging) {
            _debug(""String_Node_Str"" + input.port.getName() + ""String_Node_Str"");
          }
        }
      }
    }
 else {
      if (_debugging) {
        _debug(""String_Node_Str"" + input.port.getName() + ""String_Node_Str"");
      }
    }
  }
  if (_fmiModelDescription.modelExchange) {
    double currentTimeValue=currentTime.getDoubleValue();
    double states[]=_states.array();
    if (currentTimeValue > _lastCommitTime.getDoubleValue()) {
      if (states.length > 0) {
        if (_fmiVersion < 2.0) {
          double step=currentTimeValue - _lastCommitTime.getDoubleValue();
          for (int i=0; i < states.length; i++) {
            _newStates[i]=states[i] + derivatives[i] * step;
          }
        }
        _fmiSetContinuousStates(_newStates);
      }
      boolean stateEventOccurred=_checkEventIndicators();
      boolean timeEventOccurred=false;
      _fmiCompletedIntegratorStep(stateEventOccurred || timeEventOccurred);
    }
 else {
    }
  }
  for (  Output output : _getOutputs()) {
    TypedIOPort port=output.port;
    if (_skipIfKnown() && port.isKnown(0)) {
      continue;
    }
    boolean foundUnknownInputOnWhichOutputDepends=false;
    if (output.dependencies != null) {
      for (      TypedIOPort inputPort : output.dependencies) {
        if (!inputPort.isKnown(0)) {
          if (_debugging) {
            _debugToStdOut(""String_Node_Str"" + ""String_Node_Str"" + port.getName() + ""String_Node_Str""+ inputPort.getName()+ ""String_Node_Str"");
          }
          foundUnknownInputOnWhichOutputDepends=true;
          break;
        }
      }
    }
 else {
      List<TypedIOPort> inputPorts=inputPortList();
      for (      TypedIOPort inputPort : inputPorts) {
        if (inputPort.getWidth() < 0 || !inputPort.isKnown(0)) {
          foundUnknownInputOnWhichOutputDepends=true;
          if (_debugging) {
            _debugToStdOut(""String_Node_Str"" + ""String_Node_Str"" + port.getName() + ""String_Node_Str""+ inputPort.getName()+ ""String_Node_Str"");
          }
          break;
        }
      }
    }
    if (!foundUnknownInputOnWhichOutputDepends) {
      Token token=null;
      FMIScalarVariable scalarVariable=output.scalarVariable;
      if (scalarVariable.type instanceof FMIBooleanType) {
        boolean result=scalarVariable.getBoolean(_fmiComponent);
        token=new BooleanToken(result);
      }
 else       if (scalarVariable.type instanceof FMIIntegerType) {
        int result=scalarVariable.getInt(_fmiComponent);
        token=new IntToken(result);
      }
 else       if (scalarVariable.type instanceof FMIRealType) {
        double result=scalarVariable.getDouble(_fmiComponent);
        token=new DoubleToken(result);
      }
 else       if (scalarVariable.type instanceof FMIStringType) {
        String result=scalarVariable.getString(_fmiComponent);
        token=new StringToken(result);
      }
 else {
        throw new IllegalActionException(""String_Node_Str"" + scalarVariable.type + ""String_Node_Str"");
      }
      if (_debugging) {
        _debugToStdOut(""String_Node_Str"" + scalarVariable.name + ""String_Node_Str""+ token+ ""String_Node_Str""+ currentTime+ ""String_Node_Str""+ currentMicrostep);
      }
      port.send(0,token);
    }
  }
  _firstFireInIteration=false;
  _firstFire=false;
}","/** 
 * Invoke fmiDoStep() of the slave FMU, if necessary to catch up to current time, and then set the (known) inputs of the FMU and retrieve and send out any outputs for which all inputs on which the output depends are known.
 * @exception IllegalActionException If FMU indicates a failure.
 */
public void fire() throws IllegalActionException {
  super.fire();
  Director director=getDirector();
  Time currentTime=director.getModelTime();
  int currentMicrostep=1;
  if (director instanceof SuperdenseTimeDirector) {
    currentMicrostep=((SuperdenseTimeDirector)director).getIndex();
  }
  if (_debugging) {
    _debugToStdOut(""String_Node_Str"" + currentTime + ""String_Node_Str""+ currentMicrostep);
  }
  double derivatives[]=null;
  if (_fmiModelDescription.modelExchange) {
    if (!_firstFire) {
      derivatives=_fmiGetDerivatives();
    }
    _fmiSetTime(currentTime);
    if (_firstFire) {
      _fmiInitialize();
      _recordFMUState();
      _lastCommitTime=currentTime;
      _checkEventIndicators();
    }
    double states[]=_states.array();
    if (_newStates == null || _newStates.length != states.length) {
      _newStates=new double[states.length];
    }
  }
 else {
    if (_firstFire) {
      for (      Input input : _getInputs()) {
        if (input.start != null) {
          _setFMUScalarVariable(input.scalarVariable,new DoubleToken(input.start.doubleValue()));
          if (_debugging) {
            _debug(""String_Node_Str"" + input.port.getName() + ""String_Node_Str""+ input.start);
          }
        }
      }
    }
    double refinedStepSize=_fmiDoStep(currentTime,currentMicrostep);
    if (refinedStepSize >= 0.0) {
      _stepSizeRejected=true;
      if (_refinedStepSize < 0.0 || refinedStepSize < _refinedStepSize) {
        _refinedStepSize=refinedStepSize;
      }
    }
  }
  int _index;
  for (  Input input : _getInputs()) {
    if (input.port.getWidth() > 0 && input.port.isKnown(0)) {
      if (input.port.hasToken(0)) {
        Token token=input.port.get(0);
        _setFMUScalarVariable(input.scalarVariable,token);
        if ((_fmiVersion >= 2.0) && _fmiModelDescription.modelExchange && _fmiModelDescription.continuousStates.contains(input.port.getName())) {
          _index=_fmiModelDescription.continuousStates.indexOf(input.port.getName());
          _newStates[_index]=((DoubleToken)token).doubleValue();
        }
        if (_debugging) {
          _debugToStdOut(""String_Node_Str"" + input.scalarVariable.name + ""String_Node_Str""+ token);
        }
      }
 else {
        boolean persistentInputsValue=((BooleanToken)persistentInputs.getToken()).booleanValue();
        if (!persistentInputsValue) {
          throw new IllegalActionException(this,""String_Node_Str"" + input.scalarVariable.name + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
        }
 else {
          if (_debugging) {
            _debug(""String_Node_Str"" + input.port.getName() + ""String_Node_Str"");
          }
        }
      }
    }
 else {
      if (_debugging) {
        _debug(""String_Node_Str"" + input.port.getName() + ""String_Node_Str"");
      }
    }
  }
  if (_fmiModelDescription.modelExchange) {
    double currentTimeValue=currentTime.getDoubleValue();
    double states[]=_states.array();
    if (currentTimeValue > _lastCommitTime.getDoubleValue()) {
      if (states.length > 0) {
        if (_fmiVersion < 2.0) {
          double step=currentTimeValue - _lastCommitTime.getDoubleValue();
          for (int i=0; i < states.length; i++) {
            _newStates[i]=states[i] + derivatives[i] * step;
          }
        }
        _fmiSetContinuousStates(_newStates);
      }
      boolean stateEventOccurred=_checkEventIndicators();
      boolean timeEventOccurred=false;
      _fmiCompletedIntegratorStep(stateEventOccurred || timeEventOccurred);
    }
 else {
    }
  }
  for (  Output output : _getOutputs()) {
    TypedIOPort port=output.port;
    if (_skipIfKnown() && port.isKnown(0)) {
      continue;
    }
    boolean foundUnknownInputOnWhichOutputDepends=false;
    if (output.dependencies != null) {
      for (      TypedIOPort inputPort : output.dependencies) {
        if (!inputPort.isKnown(0)) {
          if (_debugging) {
            _debugToStdOut(""String_Node_Str"" + ""String_Node_Str"" + port.getName() + ""String_Node_Str""+ inputPort.getName()+ ""String_Node_Str"");
          }
          foundUnknownInputOnWhichOutputDepends=true;
          break;
        }
      }
    }
 else {
      List<TypedIOPort> inputPorts=inputPortList();
      for (      TypedIOPort inputPort : inputPorts) {
        if (inputPort.getWidth() < 0 || !inputPort.isKnown(0)) {
          foundUnknownInputOnWhichOutputDepends=true;
          if (_debugging) {
            _debugToStdOut(""String_Node_Str"" + ""String_Node_Str"" + port.getName() + ""String_Node_Str""+ inputPort.getName()+ ""String_Node_Str"");
          }
          break;
        }
      }
    }
    if (!foundUnknownInputOnWhichOutputDepends) {
      Token token=null;
      FMIScalarVariable scalarVariable=output.scalarVariable;
      if (scalarVariable.type instanceof FMIBooleanType) {
        boolean result=scalarVariable.getBoolean(_fmiComponent);
        token=new BooleanToken(result);
      }
 else       if (scalarVariable.type instanceof FMIIntegerType) {
        int result=scalarVariable.getInt(_fmiComponent);
        token=new IntToken(result);
      }
 else       if (scalarVariable.type instanceof FMIRealType) {
        double result=scalarVariable.getDouble(_fmiComponent);
        token=new DoubleToken(result);
      }
 else       if (scalarVariable.type instanceof FMIStringType) {
        String result=scalarVariable.getString(_fmiComponent);
        token=new StringToken(result);
      }
 else {
        throw new IllegalActionException(""String_Node_Str"" + scalarVariable.type + ""String_Node_Str"");
      }
      if (_debugging) {
        _debugToStdOut(""String_Node_Str"" + scalarVariable.name + ""String_Node_Str""+ token+ ""String_Node_Str""+ currentTime+ ""String_Node_Str""+ currentMicrostep);
      }
      port.send(0,token);
    }
  }
  _firstFireInIteration=false;
  _firstFire=false;
}"
72737,"/** 
 * Instantiate the slave FMU component.
 * @exception IllegalActionException if it cannot be instantiated.
 */
public void preinitialize() throws IllegalActionException {
  if (_fmiModelDescription == null) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  super.preinitialize();
  if (_debugging) {
    _debugToStdOut(""String_Node_Str"");
  }
  try {
    _nativeLibrary=_fmiModelDescription.getNativeLibrary();
  }
 catch (  IOException e1) {
    throw new IllegalActionException(this,e1,""String_Node_Str"");
  }
  if (_nativeLibrary == null) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  _checkFmiCommon();
  try {
    if (_fmiModelDescription.modelExchange) {
      try {
        if (_fmiVersion < 2.0 || !_completedIntegratorStepNotNeeded()) {
          _fmiCompletedIntegratorStepFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        }
      }
 catch (      Throwable throwable) {
        throw new IllegalActionException(this,throwable,""String_Node_Str"" + _fmuFileName + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      }
      if (_fmiVersion < 2.0) {
        _fmiFreeModelInstanceFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
      _fmiGetContinuousStatesFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      _fmiSetContinuousStates=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      _fmiGetDerivativesFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      try {
        _fmiGetEventIndicatorsFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
 catch (      UnsatisfiedLinkError ex) {
        _fmiGetEventIndicatorsFunction=null;
      }
      if (_fmiVersion < 2.0) {
        _fmiInitializeFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiInstantiateModelFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
 else {
        _fmiEnterInitializationModeFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiExitInitializationModeFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiInstantiateFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
      _fmiSetTimeFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      _fmiTerminateFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      _checkFmiModelExchange();
    }
 else {
      _fmiDoStepFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      if (_fmiVersion < 2.0) {
        try {
          _fmiFreeSlaveInstanceFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        }
 catch (        UnsatisfiedLinkError ex) {
          throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
        }
      }
 else {
        try {
          _fmiFreeInstanceFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        }
 catch (        UnsatisfiedLinkError ex) {
          throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
        }
      }
      if (_fmiVersion < 2.0) {
        _fmiInitializeSlaveFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiInstantiateSlaveFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
 else {
        _fmiInstantiateFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
      if (_fmiVersion < 2.0) {
        _fmiTerminateSlaveFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
 else {
        _fmiTerminateFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
      try {
        _fmiGetRealStatusFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
 catch (      UnsatisfiedLinkError ex) {
        _fmiGetRealStatusFunction=null;
      }
      if (_fmiModelDescription.canGetAndSetFMUstate) {
        _fmiFreeFMUstateFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiGetFMUstateFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiSetFMUstate=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
 else {
        _fmiFreeFMUstateFunction=null;
        _fmiGetFMUstateFunction=null;
        _fmiSetFMUstate=null;
      }
      _checkFmiCoSimulation();
    }
  }
 catch (  IOException ex) {
    throw new IllegalActionException(this,ex,""String_Node_Str"");
  }
  String modelIdentifier=_fmiModelDescription.modelIdentifier;
  String mimeType=""String_Node_Str"";
  double timeout=1000;
  byte toBeVisible=0;
  if (((BooleanToken)visible.getToken()).booleanValue()) {
    toBeVisible=1;
  }
  byte interactive=0;
  byte loggingOn=_debugging ? (byte)1 : (byte)0;
  if (_fmiVersion < 1.5) {
    _callbacks=new FMICallbackFunctions.ByValue(new FMULibrary.FMULogger(_fmiModelDescription),new FMULibrary.FMUAllocateMemory(),new FMULibrary.FMUFreeMemory(),new FMULibrary.FMUStepFinished());
    if (_fmiModelDescription.modelExchange) {
      if (_debugging) {
        _debugToStdOut(""String_Node_Str"" + modelIdentifier + ""String_Node_Str"");
      }
      _fmiComponent=(Pointer)_fmiInstantiateModelFunction.invoke(Pointer.class,new Object[]{getFullName(),_fmiModelDescription.guid,_callbacks,loggingOn});
    }
 else {
      if (_debugging) {
        _debugToStdOut(""String_Node_Str"" + modelIdentifier + ""String_Node_Str"");
      }
      _fmiComponent=(Pointer)_fmiInstantiateSlaveFunction.invoke(Pointer.class,new Object[]{getFullName(),_fmiModelDescription.guid,_fmiModelDescription.fmuResourceLocation,mimeType,timeout,toBeVisible,interactive,_callbacks,loggingOn});
    }
  }
 else {
    _callbacks=new FMICallbackFunctions(new FMULibrary.FMULogger(_fmiModelDescription),new FMULibrary.FMUAllocateMemory(),new FMULibrary.FMUFreeMemory(),new FMULibrary.FMUStepFinished());
    if (_debugging) {
      _debugToStdOut(""String_Node_Str"" + modelIdentifier + ""String_Node_Str"");
    }
    int fmiType=1;
    if (_fmiModelDescription.modelExchange) {
      fmiType=0;
    }
    if (_fmiVersion < 2.0) {
      if (_fmiModelDescription.modelExchange) {
        throw new IllegalActionException(this,""String_Node_Str"" + _fmiVersion);
      }
 else {
        _fmiComponent=(Pointer)_fmiInstantiateSlaveFunction.invoke(Pointer.class,new Object[]{getFullName(),_fmiModelDescription.guid,_fmiModelDescription.fmuResourceLocation,_callbacks,toBeVisible,loggingOn});
      }
    }
 else     if (_fmiVersion >= 2.0) {
      _fmiComponent=(Pointer)_fmiInstantiateFunction.invoke(Pointer.class,new Object[]{getFullName(),fmiType,_fmiModelDescription.guid,_fmiModelDescription.fmuResourceLocation,_callbacks,toBeVisible,loggingOn});
      if (_fmiComponent != null && _fmiComponent.equals(Pointer.NULL)) {
        int fmiFlag=((Integer)_fmiEnterInitializationModeFunction.invoke(Integer.class,new Object[]{_fmiComponent})).intValue();
        if (fmiFlag != FMILibrary.FMIStatus.fmiOK) {
          throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + _fmiStatusDescription(fmiFlag));
        }
        fmiFlag=((Integer)_fmiExitInitializationModeFunction.invoke(Integer.class,new Object[]{_fmiComponent})).intValue();
        if (fmiFlag != FMILibrary.FMIStatus.fmiOK) {
          throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + _fmiStatusDescription(fmiFlag));
        }
      }
    }
  }
  if (_fmiComponent == null || _fmiComponent.equals(Pointer.NULL)) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
}","/** 
 * Instantiate the slave FMU component.
 * @exception IllegalActionException if it cannot be instantiated.
 */
public void preinitialize() throws IllegalActionException {
  if (_fmiModelDescription == null) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  super.preinitialize();
  if (_debugging) {
    _debugToStdOut(""String_Node_Str"");
  }
  try {
    _nativeLibrary=_fmiModelDescription.getNativeLibrary();
  }
 catch (  IOException e1) {
    throw new IllegalActionException(this,e1,""String_Node_Str"");
  }
  if (_nativeLibrary == null) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  _checkFmiCommon();
  try {
    if (_fmiModelDescription.modelExchange) {
      try {
        if (_fmiVersion < 2.0 || !_completedIntegratorStepNotNeeded()) {
          _fmiCompletedIntegratorStepFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        }
      }
 catch (      Throwable throwable) {
        throw new IllegalActionException(this,throwable,""String_Node_Str"" + _fmuFileName + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      }
      if (_fmiVersion < 2.0) {
        _fmiFreeModelInstanceFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
      _fmiGetContinuousStatesFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      _fmiSetContinuousStates=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      _fmiGetDerivativesFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      try {
        _fmiGetEventIndicatorsFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
 catch (      UnsatisfiedLinkError ex) {
        _fmiGetEventIndicatorsFunction=null;
      }
      if (_fmiVersion < 2.0) {
        _fmiInitializeFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiInstantiateModelFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
 else {
        _fmiEnterInitializationModeFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiExitInitializationModeFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiInstantiateFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
      _fmiSetTimeFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      _fmiTerminateFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      _checkFmiModelExchange();
    }
 else {
      _fmiDoStepFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      if (_fmiVersion < 2.0) {
        try {
          _fmiFreeSlaveInstanceFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        }
 catch (        UnsatisfiedLinkError ex) {
          throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
        }
      }
 else {
        try {
          _fmiFreeInstanceFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        }
 catch (        UnsatisfiedLinkError ex) {
          throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
        }
      }
      if (_fmiVersion < 2.0) {
        _fmiInitializeSlaveFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiInstantiateSlaveFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
 else {
        _fmiInstantiateFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
      if (_fmiVersion < 2.0) {
        _fmiTerminateSlaveFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
 else {
        _fmiTerminateFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
      try {
        _fmiGetRealStatusFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
 catch (      UnsatisfiedLinkError ex) {
        _fmiGetRealStatusFunction=null;
      }
      if (_fmiModelDescription.canGetAndSetFMUstate) {
        _fmiFreeFMUstateFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiGetFMUstateFunction=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
        _fmiSetFMUstate=_fmiModelDescription.getFmiFunction(""String_Node_Str"");
      }
 else {
        _fmiFreeFMUstateFunction=null;
        _fmiGetFMUstateFunction=null;
        _fmiSetFMUstate=null;
      }
      _checkFmiCoSimulation();
    }
  }
 catch (  IOException ex) {
    throw new IllegalActionException(this,ex,""String_Node_Str"");
  }
  String modelIdentifier=_fmiModelDescription.modelIdentifier;
  String mimeType=""String_Node_Str"";
  double timeout=1000;
  byte toBeVisible=0;
  if (((BooleanToken)visible.getToken()).booleanValue()) {
    toBeVisible=1;
  }
  byte interactive=0;
  byte loggingOn=_debugging ? (byte)1 : (byte)0;
  if (_fmiVersion < 1.5) {
    _callbacks=new FMICallbackFunctions.ByValue(new FMULibrary.FMULogger(_fmiModelDescription),new FMULibrary.FMUAllocateMemory(),new FMULibrary.FMUFreeMemory(),new FMULibrary.FMUStepFinished());
    if (_fmiModelDescription.modelExchange) {
      if (_debugging) {
        _debugToStdOut(""String_Node_Str"" + modelIdentifier + ""String_Node_Str"");
      }
      _fmiComponent=(Pointer)_fmiInstantiateModelFunction.invoke(Pointer.class,new Object[]{getFullName(),_fmiModelDescription.guid,_callbacks,loggingOn});
    }
 else {
      if (_debugging) {
        _debugToStdOut(""String_Node_Str"" + modelIdentifier + ""String_Node_Str"");
      }
      _fmiComponent=(Pointer)_fmiInstantiateSlaveFunction.invoke(Pointer.class,new Object[]{getFullName(),_fmiModelDescription.guid,_fmiModelDescription.fmuResourceLocation,mimeType,timeout,toBeVisible,interactive,_callbacks,loggingOn});
    }
  }
 else {
    _callbacks=new FMICallbackFunctions(new FMULibrary.FMULogger(_fmiModelDescription),new FMULibrary.FMUAllocateMemory(),new FMULibrary.FMUFreeMemory(),new FMULibrary.FMUStepFinished());
    if (_debugging) {
      _debugToStdOut(""String_Node_Str"" + modelIdentifier + ""String_Node_Str"");
    }
    int fmiType=1;
    if (_fmiModelDescription.modelExchange) {
      fmiType=0;
    }
    if (_fmiVersion < 2.0) {
      if (_fmiModelDescription.modelExchange) {
        throw new IllegalActionException(this,""String_Node_Str"" + _fmiVersion);
      }
 else {
        _fmiComponent=(Pointer)_fmiInstantiateSlaveFunction.invoke(Pointer.class,new Object[]{getFullName(),_fmiModelDescription.guid,_fmiModelDescription.fmuResourceLocation,_callbacks,toBeVisible,loggingOn});
      }
    }
 else     if (_fmiVersion >= 2.0) {
      _fmiComponent=(Pointer)_fmiInstantiateFunction.invoke(Pointer.class,new Object[]{getFullName(),fmiType,_fmiModelDescription.guid,_fmiModelDescription.fmuResourceLocation,_callbacks,toBeVisible,loggingOn});
    }
  }
  if (_fmiComponent == null || _fmiComponent.equals(Pointer.NULL)) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
}"
72738,"@Override public double Compute(int n,int m,double[] x,double[] con,boolean[] terminate) throws IllegalActionException {
  double evalX=0;
  DoubleToken[] xTokens=new DoubleToken[x.length];
  for (int i=0; i < xTokens.length; i++) {
    xTokens[i]=new DoubleToken(x[i]);
  }
  ArrayToken xAsToken=new ArrayToken(xTokens);
  CompositeOptimizer.this.x.sendInside(0,xAsToken);
  CompositeActor container=(CompositeActor)getContainer();
  if (_firstIteration) {
    _firstIteration=false;
  }
 else {
    Iterator<IOPort> inports=container.inputPortList().iterator();
    while (inports.hasNext()) {
      IOPort p=inports.next();
      if (!(p instanceof ParameterPort)) {
        _retransferInputs(p);
      }
    }
  }
  OptimizerDirector.super.fire();
  if (_stopRequested) {
    terminate[0]=_stopRequested;
    con[0]=-1;
    return evalX;
  }
 else {
    Iterator<IOPort> outports=container.outputPortList().iterator();
    while (outports.hasNext()) {
      IOPort p=outports.next();
      if (p.getName().equals(INTERMEDIATE_VALUE_PORT_NAME)) {
        if (p.hasTokenInside(0)) {
          Token t=p.getInside(0);
          evalX=((DoubleToken)t).doubleValue();
        }
 else {
          throw new IllegalActionException(CompositeOptimizer.this,""String_Node_Str"" + INTERMEDIATE_VALUE_PORT_NAME + ""String_Node_Str"");
        }
      }
 else       if (p.getName().equals(CONSTRAINTS_PORT_NAME)) {
        if (p.hasTokenInside(0)) {
          Token t=p.getInside(0);
          Token[] constraintArray=((ArrayToken)t).arrayValue();
          for (int i=0; i < constraintArray.length; i++) {
            con[i]=((DoubleToken)constraintArray[i]).doubleValue();
          }
        }
 else {
          throw new IllegalActionException(CompositeOptimizer.this,""String_Node_Str"" + CONSTRAINTS_PORT_NAME + ""String_Node_Str"");
        }
      }
    }
    if (_mode == MAXIMIZE) {
      evalX=-1.0 * evalX;
    }
 else {
    }
    terminate[0]=_stopRequested;
  }
  return evalX;
}","@Override public double Compute(int n,int m,double[] x,double[] con,boolean[] terminate) throws IllegalActionException {
  double evalX=0;
  DoubleToken[] xTokens=new DoubleToken[x.length];
  for (int i=0; i < xTokens.length; i++) {
    xTokens[i]=new DoubleToken(x[i]);
  }
  ArrayToken xAsToken=new ArrayToken(xTokens);
  (CompositeOptimizer.this).x.sendInside(0,xAsToken);
  CompositeActor container=(CompositeActor)getContainer();
  if (_firstIteration) {
    _firstIteration=false;
  }
 else {
    Iterator<IOPort> inports=container.inputPortList().iterator();
    while (inports.hasNext()) {
      IOPort p=inports.next();
      if (!(p instanceof ParameterPort)) {
        _retransferInputs(p);
      }
    }
  }
  OptimizerDirector.super.fire();
  if (_stopRequested) {
    terminate[0]=_stopRequested;
    con[0]=-1;
    return evalX;
  }
 else {
    Iterator<IOPort> outports=container.outputPortList().iterator();
    while (outports.hasNext()) {
      IOPort p=outports.next();
      if (p.getName().equals(INTERMEDIATE_VALUE_PORT_NAME)) {
        if (p.hasTokenInside(0)) {
          Token t=p.getInside(0);
          evalX=((DoubleToken)t).doubleValue();
        }
 else {
          throw new IllegalActionException(CompositeOptimizer.this,""String_Node_Str"" + INTERMEDIATE_VALUE_PORT_NAME + ""String_Node_Str"");
        }
      }
 else       if (p.getName().equals(CONSTRAINTS_PORT_NAME)) {
        if (p.hasTokenInside(0)) {
          Token t=p.getInside(0);
          Token[] constraintArray=((ArrayToken)t).arrayValue();
          for (int i=0; i < constraintArray.length; i++) {
            con[i]=((DoubleToken)constraintArray[i]).doubleValue();
          }
        }
 else {
          throw new IllegalActionException(CompositeOptimizer.this,""String_Node_Str"" + CONSTRAINTS_PORT_NAME + ""String_Node_Str"");
        }
      }
    }
    if (_mode == MAXIMIZE) {
      evalX=-1.0 * evalX;
    }
 else {
    }
    terminate[0]=_stopRequested;
  }
  return evalX;
}"
72739,"/** 
 * Clone the object into the specified workspace. This overrides the base class to instantiate a new IterateDirector and to set the association with iterationCount.
 * @param workspace The workspace for the new object.
 * @return A new NamedObj.
 * @exception CloneNotSupportedException If any of the attributescannot be cloned.
 * @see #exportMoML(Writer,int,String)
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  CompositeOptimizer result=(CompositeOptimizer)super.clone(workspace);
  try {
    String directorName=null;
    Iterator directors=result.attributeList(OptimizerDirector.class).iterator();
    while (directors.hasNext()) {
      OptimizerDirector oldDirector=(OptimizerDirector)directors.next();
      if (directorName == null) {
        directorName=oldDirector.getName();
      }
      oldDirector.setContainer(null);
    }
    OptimizerDirector director=result.new OptimizerDirector(workspace);
    director.setContainer(result);
    director.setName(directorName);
  }
 catch (  Throwable throwable) {
    throw new CloneNotSupportedException(""String_Node_Str"" + throwable);
  }
  result._tokenMap=new HashMap<IOPort,Token>();
  return result;
}","/** 
 * Clone the object into the specified workspace. This overrides the base class to instantiate a new OptimizerDirector 
 * @param workspace The workspace for the new object.
 * @return A new NamedObj.
 * @exception CloneNotSupportedException If any of the attributescannot be cloned.
 * @see #exportMoML(Writer,int,String)
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  CompositeOptimizer result=(CompositeOptimizer)super.clone(workspace);
  try {
    String directorName=null;
    Iterator directors=result.attributeList(OptimizerDirector.class).iterator();
    while (directors.hasNext()) {
      OptimizerDirector oldDirector=(OptimizerDirector)directors.next();
      if (directorName == null) {
        directorName=oldDirector.getName();
      }
      oldDirector.setContainer(null);
    }
    OptimizerDirector director=result.new OptimizerDirector(workspace);
    director.setContainer(result);
    director.setName(directorName);
  }
 catch (  Throwable throwable) {
    throw new CloneNotSupportedException(""String_Node_Str"" + throwable);
  }
  result._tokenMap=new HashMap<IOPort,Token>();
  result._firstIteration=true;
  return result;
}"
72740,"@Override public void fire() throws IllegalActionException {
  Calcfc calcfc=new Calcfc(){
    @Override public double Compute(    int n,    int m,    double[] x,    double[] con,    boolean[] terminate) throws IllegalActionException {
      double evalX=0;
      DoubleToken[] xTokens=new DoubleToken[x.length];
      for (int i=0; i < xTokens.length; i++) {
        xTokens[i]=new DoubleToken(x[i]);
      }
      ArrayToken xAsToken=new ArrayToken(xTokens);
      CompositeOptimizer.this.x.sendInside(0,xAsToken);
      CompositeActor container=(CompositeActor)getContainer();
      if (_firstIteration) {
        _firstIteration=false;
      }
 else {
        Iterator<IOPort> inports=container.inputPortList().iterator();
        while (inports.hasNext()) {
          IOPort p=inports.next();
          if (!(p instanceof ParameterPort)) {
            _retransferInputs(p);
          }
        }
      }
      OptimizerDirector.super.fire();
      if (_stopRequested) {
        terminate[0]=_stopRequested;
        con[0]=-1;
        return evalX;
      }
 else {
        Iterator<IOPort> outports=container.outputPortList().iterator();
        while (outports.hasNext()) {
          IOPort p=outports.next();
          if (p.getName().equals(INTERMEDIATE_VALUE_PORT_NAME)) {
            if (p.hasTokenInside(0)) {
              Token t=p.getInside(0);
              evalX=((DoubleToken)t).doubleValue();
            }
 else {
              throw new IllegalActionException(CompositeOptimizer.this,""String_Node_Str"" + INTERMEDIATE_VALUE_PORT_NAME + ""String_Node_Str"");
            }
          }
 else           if (p.getName().equals(CONSTRAINTS_PORT_NAME)) {
            if (p.hasTokenInside(0)) {
              Token t=p.getInside(0);
              Token[] constraintArray=((ArrayToken)t).arrayValue();
              for (int i=0; i < constraintArray.length; i++) {
                con[i]=((DoubleToken)constraintArray[i]).doubleValue();
              }
            }
 else {
              throw new IllegalActionException(CompositeOptimizer.this,""String_Node_Str"" + CONSTRAINTS_PORT_NAME + ""String_Node_Str"");
            }
          }
        }
        if (_mode == MAXIMIZE) {
          evalX=-1.0 * evalX;
        }
 else {
        }
        terminate[0]=_stopRequested;
      }
      return evalX;
    }
  }
;
  _optInput=new double[_dimension];
  int nVariables=_dimension;
  _firstIteration=true;
  boolean[] terminateArray=new boolean[1];
  terminateArray[0]=_stopRequested;
  CobylaExitStatus status=Cobyla.FindMinimum(calcfc,nVariables,_numConstraints,_optInput,_rhobeg,_rhoend,iprint,_maxEvaluations,terminateArray);
  _firstIteration=true;
  DoubleToken[] outTokens=new DoubleToken[_dimension];
  for (int i=0; i < outTokens.length; i++) {
    outTokens[i]=new DoubleToken(_optInput[i]);
  }
  ArrayToken outputArrayToken=new ArrayToken(outTokens);
  optimalValue.send(0,outputArrayToken);
switch (status) {
case Normal:
    break;
case MaxIterationsReached:
  throw new IllegalActionException(CompositeOptimizer.this,""String_Node_Str"" + ""String_Node_Str"");
case DivergingRoundingErrors:
throw new IllegalActionException(CompositeOptimizer.this,""String_Node_Str"" + ""String_Node_Str"");
case TerminateRequested:
throw new IllegalActionException(CompositeOptimizer.this,""String_Node_Str"" + ""String_Node_Str"");
}
}","@Override public void fire() throws IllegalActionException {
  Calcfc calcfc=new Calcfc(){
    @Override public double Compute(    int n,    int m,    double[] x,    double[] con,    boolean[] terminate) throws IllegalActionException {
      double evalX=0;
      DoubleToken[] xTokens=new DoubleToken[x.length];
      for (int i=0; i < xTokens.length; i++) {
        xTokens[i]=new DoubleToken(x[i]);
      }
      ArrayToken xAsToken=new ArrayToken(xTokens);
      (CompositeOptimizer.this).x.sendInside(0,xAsToken);
      CompositeActor container=(CompositeActor)getContainer();
      if (_firstIteration) {
        _firstIteration=false;
      }
 else {
        Iterator<IOPort> inports=container.inputPortList().iterator();
        while (inports.hasNext()) {
          IOPort p=inports.next();
          if (!(p instanceof ParameterPort)) {
            _retransferInputs(p);
          }
        }
      }
      OptimizerDirector.super.fire();
      if (_stopRequested) {
        terminate[0]=_stopRequested;
        con[0]=-1;
        return evalX;
      }
 else {
        Iterator<IOPort> outports=container.outputPortList().iterator();
        while (outports.hasNext()) {
          IOPort p=outports.next();
          if (p.getName().equals(INTERMEDIATE_VALUE_PORT_NAME)) {
            if (p.hasTokenInside(0)) {
              Token t=p.getInside(0);
              evalX=((DoubleToken)t).doubleValue();
            }
 else {
              throw new IllegalActionException(CompositeOptimizer.this,""String_Node_Str"" + INTERMEDIATE_VALUE_PORT_NAME + ""String_Node_Str"");
            }
          }
 else           if (p.getName().equals(CONSTRAINTS_PORT_NAME)) {
            if (p.hasTokenInside(0)) {
              Token t=p.getInside(0);
              Token[] constraintArray=((ArrayToken)t).arrayValue();
              for (int i=0; i < constraintArray.length; i++) {
                con[i]=((DoubleToken)constraintArray[i]).doubleValue();
              }
            }
 else {
              throw new IllegalActionException(CompositeOptimizer.this,""String_Node_Str"" + CONSTRAINTS_PORT_NAME + ""String_Node_Str"");
            }
          }
        }
        if (_mode == MAXIMIZE) {
          evalX=-1.0 * evalX;
        }
 else {
        }
        terminate[0]=_stopRequested;
      }
      return evalX;
    }
  }
;
  _optInput=new double[_dimension];
  int nVariables=_dimension;
  _firstIteration=true;
  boolean[] terminateArray=new boolean[1];
  terminateArray[0]=_stopRequested;
  CobylaExitStatus status=Cobyla.FindMinimum(calcfc,nVariables,_numConstraints,_optInput,_rhobeg,_rhoend,iprint,_maxEvaluations,terminateArray);
  _firstIteration=true;
  DoubleToken[] outTokens=new DoubleToken[_dimension];
  for (int i=0; i < outTokens.length; i++) {
    outTokens[i]=new DoubleToken(_optInput[i]);
  }
  ArrayToken outputArrayToken=new ArrayToken(outTokens);
  optimalValue.send(0,outputArrayToken);
switch (status) {
case Normal:
    break;
case MaxIterationsReached:
  throw new IllegalActionException(CompositeOptimizer.this,""String_Node_Str"" + ""String_Node_Str"");
case DivergingRoundingErrors:
throw new IllegalActionException(CompositeOptimizer.this,""String_Node_Str"" + ""String_Node_Str"");
case TerminateRequested:
throw new IllegalActionException(CompositeOptimizer.this,""String_Node_Str"" + ""String_Node_Str"");
}
}"
72741,"/** 
 * Invoke fmiDoStep() of the slave FMU, if necessary to catch up to current time, and then set the (known) inputs of the FMU and retrieve and send out any outputs for which all inputs on which the output depends are known.
 * @exception IllegalActionException If FMU indicates a failure.
 */
public void fire() throws IllegalActionException {
  super.fire();
  Director director=getDirector();
  Time currentTime=director.getModelTime();
  int currentMicrostep=1;
  if (director instanceof SuperdenseTimeDirector) {
    currentMicrostep=((SuperdenseTimeDirector)director).getIndex();
  }
  if (_debugging) {
    _debugToStdOut(""String_Node_Str"" + currentTime + ""String_Node_Str""+ currentMicrostep);
  }
  double derivatives[]=null;
  if (_fmiModelDescription.modelExchange) {
    if (!_firstFire) {
      derivatives=_fmiGetDerivatives();
    }
    _fmiSetTime(currentTime);
  }
 else {
    if (_firstFire) {
      for (      Input input : _getInputs()) {
        if (input.start != null) {
          _setFMUScalarVariable(input.scalarVariable,new DoubleToken(input.start.doubleValue()));
          if (_debugging) {
            _debug(""String_Node_Str"" + input.port.getName() + ""String_Node_Str""+ input.start);
          }
        }
      }
    }
    double refinedStepSize=_fmiDoStep(currentTime,currentMicrostep);
    if (refinedStepSize >= 0.0) {
      _stepSizeRejected=true;
      if (_refinedStepSize < 0.0 || refinedStepSize < _refinedStepSize) {
        _refinedStepSize=refinedStepSize;
      }
    }
  }
  for (  Input input : _getInputs()) {
    if (input.port.isKnown(0)) {
      if (input.port.hasToken(0)) {
        Token token=input.port.get(0);
        _setFMUScalarVariable(input.scalarVariable,token);
        if (_debugging) {
          _debugToStdOut(""String_Node_Str"" + input.scalarVariable.name + ""String_Node_Str""+ token);
        }
      }
 else {
        boolean persistentInputsValue=((BooleanToken)persistentInputs.getToken()).booleanValue();
        if (!persistentInputsValue) {
          throw new IllegalActionException(this,""String_Node_Str"" + input.scalarVariable.name + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
        }
 else {
          if (_debugging) {
            _debug(""String_Node_Str"" + input.port.getName() + ""String_Node_Str"");
          }
        }
      }
    }
 else {
      if (_debugging) {
        _debug(""String_Node_Str"" + input.port.getName() + ""String_Node_Str"");
      }
    }
  }
  if (_fmiModelDescription.modelExchange) {
    if (_firstFire) {
      _fmiInitialize();
      _recordFMUState();
      _lastCommitTime=currentTime;
      _checkEventIndicators();
    }
    double currentTimeValue=currentTime.getDoubleValue();
    double states[]=_states.array();
    if (_newStates == null || _newStates.length != states.length) {
      _newStates=new double[states.length];
    }
    if (currentTimeValue > _lastCommitTime.getDoubleValue()) {
      if (states.length > 0) {
        double step=currentTimeValue - _lastCommitTime.getDoubleValue();
        for (int i=0; i < states.length; i++) {
          _newStates[i]=states[i] + derivatives[i] * step;
        }
        _fmiSetContinuousStates(_newStates);
        for (int i=0; i < states.length; i++)         System.out.println(""String_Node_Str"" + states[i]);
        _fmiSetContinuousStates(states);
      }
      boolean stateEventOccurred=_checkEventIndicators();
      boolean timeEventOccurred=false;
      _fmiCompletedIntegratorStep(stateEventOccurred || timeEventOccurred);
    }
 else {
    }
  }
  for (  Output output : _getOutputs()) {
    TypedIOPort port=output.port;
    if (_skipIfKnown() && port.isKnown(0)) {
      continue;
    }
    boolean foundUnknownInputOnWhichOutputDepends=false;
    if (output.dependencies != null) {
      for (      TypedIOPort inputPort : output.dependencies) {
        if (!inputPort.isKnown(0)) {
          if (_debugging) {
            _debugToStdOut(""String_Node_Str"" + ""String_Node_Str"" + port.getName() + ""String_Node_Str""+ inputPort.getName()+ ""String_Node_Str"");
          }
          foundUnknownInputOnWhichOutputDepends=true;
          break;
        }
      }
    }
 else {
      List<TypedIOPort> inputPorts=inputPortList();
      for (      TypedIOPort inputPort : inputPorts) {
        if (inputPort.getWidth() < 0 || !inputPort.isKnown(0)) {
          foundUnknownInputOnWhichOutputDepends=true;
          if (_debugging) {
            _debugToStdOut(""String_Node_Str"" + ""String_Node_Str"" + port.getName() + ""String_Node_Str""+ inputPort.getName()+ ""String_Node_Str"");
          }
          break;
        }
      }
    }
    if (!foundUnknownInputOnWhichOutputDepends) {
      Token token=null;
      FMIScalarVariable scalarVariable=output.scalarVariable;
      if (scalarVariable.type instanceof FMIBooleanType) {
        boolean result=scalarVariable.getBoolean(_fmiComponent);
        token=new BooleanToken(result);
      }
 else       if (scalarVariable.type instanceof FMIIntegerType) {
        int result=scalarVariable.getInt(_fmiComponent);
        token=new IntToken(result);
      }
 else       if (scalarVariable.type instanceof FMIRealType) {
        double result=scalarVariable.getDouble(_fmiComponent);
        token=new DoubleToken(result);
      }
 else       if (scalarVariable.type instanceof FMIStringType) {
        String result=scalarVariable.getString(_fmiComponent);
        token=new StringToken(result);
      }
 else {
        throw new IllegalActionException(""String_Node_Str"" + scalarVariable.type + ""String_Node_Str"");
      }
      if (_debugging) {
        _debugToStdOut(""String_Node_Str"" + scalarVariable.name + ""String_Node_Str""+ token+ ""String_Node_Str""+ currentTime+ ""String_Node_Str""+ currentMicrostep);
      }
      port.send(0,token);
    }
  }
  _firstFireInIteration=false;
  _firstFire=false;
}","/** 
 * Invoke fmiDoStep() of the slave FMU, if necessary to catch up to current time, and then set the (known) inputs of the FMU and retrieve and send out any outputs for which all inputs on which the output depends are known.
 * @exception IllegalActionException If FMU indicates a failure.
 */
public void fire() throws IllegalActionException {
  super.fire();
  Director director=getDirector();
  Time currentTime=director.getModelTime();
  int currentMicrostep=1;
  if (director instanceof SuperdenseTimeDirector) {
    currentMicrostep=((SuperdenseTimeDirector)director).getIndex();
  }
  if (_debugging) {
    _debugToStdOut(""String_Node_Str"" + currentTime + ""String_Node_Str""+ currentMicrostep);
  }
  double derivatives[]=null;
  if (_fmiModelDescription.modelExchange) {
    if (!_firstFire) {
      derivatives=_fmiGetDerivatives();
    }
    _fmiSetTime(currentTime);
    if (_firstFire) {
      _fmiInitialize();
      _recordFMUState();
      _lastCommitTime=currentTime;
      _checkEventIndicators();
    }
    double states[]=_states.array();
    if (_newStates == null || _newStates.length != states.length) {
      _newStates=new double[states.length];
    }
  }
 else {
    if (_firstFire) {
      for (      Input input : _getInputs()) {
        if (input.start != null) {
          _setFMUScalarVariable(input.scalarVariable,new DoubleToken(input.start.doubleValue()));
          if (_debugging) {
            _debug(""String_Node_Str"" + input.port.getName() + ""String_Node_Str""+ input.start);
          }
        }
      }
    }
    double refinedStepSize=_fmiDoStep(currentTime,currentMicrostep);
    if (refinedStepSize >= 0.0) {
      _stepSizeRejected=true;
      if (_refinedStepSize < 0.0 || refinedStepSize < _refinedStepSize) {
        _refinedStepSize=refinedStepSize;
      }
    }
  }
  int _index;
  for (  Input input : _getInputs()) {
    if (input.port.isKnown(0)) {
      if (input.port.hasToken(0)) {
        Token token=input.port.get(0);
        _setFMUScalarVariable(input.scalarVariable,token);
        if ((_fmiVersion == 2.0) && _fmiModelDescription.modelExchange && _fmiModelDescription.continuousStates.contains(input.port.getName())) {
          _index=_fmiModelDescription.continuousStates.indexOf(input.port.getName());
          _newStates[_index]=((DoubleToken)token).doubleValue();
        }
        if (_debugging) {
          _debugToStdOut(""String_Node_Str"" + input.scalarVariable.name + ""String_Node_Str""+ token);
        }
      }
 else {
        boolean persistentInputsValue=((BooleanToken)persistentInputs.getToken()).booleanValue();
        if (!persistentInputsValue) {
          throw new IllegalActionException(this,""String_Node_Str"" + input.scalarVariable.name + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
        }
 else {
          if (_debugging) {
            _debug(""String_Node_Str"" + input.port.getName() + ""String_Node_Str"");
          }
        }
      }
    }
 else {
      if (_debugging) {
        _debug(""String_Node_Str"" + input.port.getName() + ""String_Node_Str"");
      }
    }
  }
  if (_fmiModelDescription.modelExchange) {
    double currentTimeValue=currentTime.getDoubleValue();
    double states[]=_states.array();
    if (currentTimeValue > _lastCommitTime.getDoubleValue()) {
      if (states.length > 0) {
        if (_fmiVersion < 2.0) {
          double step=currentTimeValue - _lastCommitTime.getDoubleValue();
          for (int i=0; i < states.length; i++) {
            _newStates[i]=states[i] + derivatives[i] * step;
          }
        }
        _fmiSetContinuousStates(_newStates);
      }
      boolean stateEventOccurred=_checkEventIndicators();
      boolean timeEventOccurred=false;
      _fmiCompletedIntegratorStep(stateEventOccurred || timeEventOccurred);
    }
 else {
    }
  }
  for (  Output output : _getOutputs()) {
    TypedIOPort port=output.port;
    if (_skipIfKnown() && port.isKnown(0)) {
      continue;
    }
    boolean foundUnknownInputOnWhichOutputDepends=false;
    if (output.dependencies != null) {
      for (      TypedIOPort inputPort : output.dependencies) {
        if (!inputPort.isKnown(0)) {
          if (_debugging) {
            _debugToStdOut(""String_Node_Str"" + ""String_Node_Str"" + port.getName() + ""String_Node_Str""+ inputPort.getName()+ ""String_Node_Str"");
          }
          foundUnknownInputOnWhichOutputDepends=true;
          break;
        }
      }
    }
 else {
      List<TypedIOPort> inputPorts=inputPortList();
      for (      TypedIOPort inputPort : inputPorts) {
        if (inputPort.getWidth() < 0 || !inputPort.isKnown(0)) {
          foundUnknownInputOnWhichOutputDepends=true;
          if (_debugging) {
            _debugToStdOut(""String_Node_Str"" + ""String_Node_Str"" + port.getName() + ""String_Node_Str""+ inputPort.getName()+ ""String_Node_Str"");
          }
          break;
        }
      }
    }
    if (!foundUnknownInputOnWhichOutputDepends) {
      Token token=null;
      FMIScalarVariable scalarVariable=output.scalarVariable;
      if (scalarVariable.type instanceof FMIBooleanType) {
        boolean result=scalarVariable.getBoolean(_fmiComponent);
        token=new BooleanToken(result);
      }
 else       if (scalarVariable.type instanceof FMIIntegerType) {
        int result=scalarVariable.getInt(_fmiComponent);
        token=new IntToken(result);
      }
 else       if (scalarVariable.type instanceof FMIRealType) {
        double result=scalarVariable.getDouble(_fmiComponent);
        token=new DoubleToken(result);
      }
 else       if (scalarVariable.type instanceof FMIStringType) {
        String result=scalarVariable.getString(_fmiComponent);
        token=new StringToken(result);
      }
 else {
        throw new IllegalActionException(""String_Node_Str"" + scalarVariable.type + ""String_Node_Str"");
      }
      if (_debugging) {
        _debugToStdOut(""String_Node_Str"" + scalarVariable.name + ""String_Node_Str""+ token+ ""String_Node_Str""+ currentTime+ ""String_Node_Str""+ currentMicrostep);
      }
      port.send(0,token);
    }
  }
  _firstFireInIteration=false;
  _firstFire=false;
}"
72742,"/** 
 * For model exchange, set the continuous states of the FMU to the specified array.
 * @param values The values to assign to the states.
 * @exception IllegalActionException If the length of the array does not matchthe number of continuous states, or if the FMU does not return fmiOK.
 */
protected void _fmiSetContinuousStates(double values[]) throws IllegalActionException {
  if (values.length != _fmiModelDescription.numberOfContinuousStates) {
    throw new IllegalActionException(this,""String_Node_Str"" + values.length + ""String_Node_Str""+ _fmiModelDescription.numberOfContinuousStates);
  }
  DoubleBuffer states=DoubleBuffer.allocate(values.length);
  for (int i=0; i < values.length; i++) {
    states.put(values[i]);
  }
  int fmiFlag=((Integer)_fmiSetContinuousStates.invoke(Integer.class,new Object[]{_fmiComponent,states,new NativeSizeT(values.length)})).intValue();
  if (fmiFlag != FMILibrary.FMIStatus.fmiOK) {
    Time currentTime=getDirector().getModelTime();
    throw new IllegalActionException(this,""String_Node_Str"" + currentTime + ""String_Node_Str""+ _fmiStatusDescription(fmiFlag));
  }
  if (_debugging) {
    _debug(""String_Node_Str"" + java.util.Arrays.toString(values));
  }
}","/** 
 * For model exchange, set the continuous states of the FMU to the specified array.
 * @param values The values to assign to the states.
 * @exception IllegalActionException If the length of the array does not matchthe number of continuous states, or if the FMU does not return fmiOK.
 */
protected void _fmiSetContinuousStates(double values[]) throws IllegalActionException {
  if (values.length != _fmiModelDescription.numberOfContinuousStates) {
    throw new IllegalActionException(this,""String_Node_Str"" + values.length + ""String_Node_Str""+ _fmiModelDescription.numberOfContinuousStates);
  }
  int fmiFlag=((Integer)_fmiSetContinuousStates.invoke(Integer.class,new Object[]{_fmiComponent,values,new NativeSizeT(values.length)})).intValue();
  if (fmiFlag != FMILibrary.FMIStatus.fmiOK) {
    Time currentTime=getDirector().getModelTime();
    throw new IllegalActionException(this,""String_Node_Str"" + currentTime + ""String_Node_Str""+ _fmiStatusDescription(fmiFlag));
  }
  if (_debugging) {
    _debug(""String_Node_Str"" + java.util.Arrays.toString(values));
  }
}"
72743,"/** 
 * Update the calculation of the next output time and request a refiring at that time. If there is a new input, read it and update the slope.
 * @return True if the base class returns true.
 * @throws IllegalActionException If reading inputs or parameters fails.
 */
public boolean postfire() throws IllegalActionException {
  Time currentTime=getDirector().getModelTime();
  for (int i=0; i < dx.size(); i++) {
    if (dx.get(i).hasToken(0)) {
      u[i]=dx.get(i).get(0);
      if (!u[i].equals(previousInput[i])) {
        previousInput[i]=u[i];
        slope[i]=((DoubleToken)u[i]).doubleValue();
        inputReceived[i]=true;
      }
    }
    if (currentTime.equals(nextOutputTime[i]) || nextOutputTime[i] == null) {
      if (nextOutputTime[i] != null) {
        x[i]=nextOutputValue[i];
      }
      previousOutputValue[i]=nextOutputValue[i];
      nextOutputTime[i]=_nextCrossingTime(slope[i],0.0,0.0,dq[i],currentTime);
    }
 else {
      if (inputReceived[i]) {
        x[i]+=slope[i] * (currentTime.subtract(previousStateUpdateTime[i])).getDoubleValue();
        System.out.println(""String_Node_Str"" + String.valueOf(i) + ""String_Node_Str""+ String.valueOf((x[i])));
        nextOutputTime[i]=_nextCrossingTime(slope[i],x[i],nextOutputValue[i],dq[i],currentTime);
        inputReceived[i]=false;
      }
    }
    nextOutputValue[i]=_nextOutputValue(slope[i],previousOutputValue[i],dq[i]);
    previousStateUpdateTime[i]=nextOutputTime[i];
  }
  _minNextCrossingTime();
  if (t_min != Time.POSITIVE_INFINITY) {
    getDirector().fireAt(this,t_min);
    for (int j=0; j < dx.size(); j++) {
      for (int i=0; i < index_min.size(); i++) {
        if (j == index_min.get(i)) {
          previousStateUpdateTime[j]=t_min;
        }
      }
    }
  }
  return super.postfire();
}","/** 
 * Update the calculation of the next output time and request a refiring at that time. If there is a new input, read it and update the slope.
 * @return True if the base class returns true.
 * @throws IllegalActionException If reading inputs or parameters fails.
 */
public boolean postfire() throws IllegalActionException {
  Time currentTime=getDirector().getModelTime();
  for (int i=0; i < dx.size(); i++) {
    if (dx.get(i).hasToken(0)) {
      u[i]=dx.get(i).get(0);
      if (!u[i].equals(previousInput[i])) {
        previousInput[i]=u[i];
        slope[i]=((DoubleToken)u[i]).doubleValue();
        inputReceived[i]=true;
      }
    }
    if (currentTime.equals(nextOutputTime[i]) || nextOutputTime[i] == null) {
      if (nextOutputTime[i] != null) {
        x[i]=nextOutputValue[i];
      }
      previousOutputValue[i]=nextOutputValue[i];
      nextOutputTime[i]=_nextCrossingTime(slope[i],0.0,0.0,dq[i],currentTime);
    }
 else {
      if (inputReceived[i]) {
        x[i]+=slope[i] * (currentTime.subtract(previousStateUpdateTime[i])).getDoubleValue();
        System.out.println(""String_Node_Str"" + String.valueOf(i) + ""String_Node_Str""+ String.valueOf((x[i])));
        nextOutputTime[i]=_nextCrossingTime(slope[i],x[i],nextOutputValue[i],dq[i],currentTime);
        inputReceived[i]=false;
      }
    }
    nextOutputValue[i]=_nextOutputValue(slope[i],previousOutputValue[i],dq[i]);
    previousStateUpdateTime[i]=currentTime;
  }
  _minNextCrossingTime();
  if (t_min != Time.POSITIVE_INFINITY) {
    getDirector().fireAt(this,t_min);
    for (int j=0; j < dx.size(); j++) {
      for (int i=0; i < index_min.size(); i++) {
        if (j == index_min.get(i)) {
          previousStateUpdateTime[j]=t_min;
        }
      }
    }
  }
  return super.postfire();
}"
72744,"/** 
 * React to attribute changes.
 */
@Override public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == defaultValue) {
    _getMirrorPort().defaultValue.setExpression(defaultValue.getExpression());
  }
  super.attributeChanged(attribute);
}","/** 
 * React to attribute changes.
 */
@Override public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == defaultValue) {
    if (_getMirrorPort() != null) {
      _getMirrorPort().defaultValue.setExpression(defaultValue.getExpression());
    }
  }
  super.attributeChanged(attribute);
}"
72745,"private RefinementPort _getMirrorPort(){
  if (getContainer() != null && ((ModalModel)getContainer())._controller != null && ((ModalModel)getContainer())._controller.getPort(this.getName()) != null) {
    return (RefinementPort)((ModalModel)getContainer())._controller.getPort(this.getName());
  }
  return null;
}","private RefinementPort _getMirrorPort(){
  if (getContainer() != null && getContainer() instanceof ModalModel && ((ModalModel)getContainer())._controller != null && ((ModalModel)getContainer())._controller.getPort(this.getName()) != null) {
    if (((ModalModel)getContainer())._controller.getPort(this.getName()) instanceof RefinementPort) {
      return (RefinementPort)((ModalModel)getContainer())._controller.getPort(this.getName());
    }
  }
  return null;
}"
72746,"private ModalPort _getMirrorPort(){
  Nameable container=getContainer();
  if (container != null) {
    Nameable modal=container.getContainer();
    if (modal instanceof ModalModel) {
      return (ModalPort)((ModalModel)modal).getPort(getName());
    }
  }
  return null;
}","private ModalPort _getMirrorPort(){
  Nameable container=getContainer();
  if (container != null) {
    Nameable modal=container.getContainer();
    if (modal instanceof ModalModel) {
      if (((ModalModel)modal).getPort(getName()) instanceof ModalPort) {
        return (ModalPort)((ModalModel)modal).getPort(getName());
      }
    }
  }
  return null;
}"
72747,"/** 
 * Build the model. <p>Read the model ""NCApplication.xml"" from the current directory.
 * @param args Ignored
 * @exception Exception If there is a problem reading the model.
 */
public static void main(String[] args) throws Exception {
  CompositeEntity _toplevel;
  try {
    Workspace workspace=new Workspace(""String_Node_Str"");
    _toplevel=new CompositeEntity(workspace);
    _toplevel.setName(""String_Node_Str"");
    Counter counter=new Counter(_toplevel,""String_Node_Str"");
    Leds leds=new Leds(_toplevel,""String_Node_Str"");
    _toplevel.connect(counter.output,leds.display,""String_Node_Str"");
    StringWriter buffer=new StringWriter();
    _toplevel.exportMoML(buffer);
    String fileName=""String_Node_Str"";
    FileOutputStream file=null;
    PrintStream out=null;
    try {
      file=new FileOutputStream(fileName);
      PrintStream out=new PrintStream(file);
      out.println(buffer);
      out.flush();
    }
  finally {
      if (out != null) {
        try {
          out.close();
        }
 catch (        Throwable throwable) {
          System.out.println(""String_Node_Str"" + ""String_Node_Str"" + fileName);
          throwable.printStackTrace();
        }
      }
    }
    counter.initialize();
    IntToken[] t=new IntToken[1];
    t[0]=new IntToken(2);
    TupleToken arg=new TupleToken(t);
    for (int i=0; i < 10; i++) {
      counter.increment.call(arg);
    }
  }
 catch (  Exception ex) {
    ex.printStackTrace();
    throw ex;
  }
}","/** 
 * Build the model. <p>Read the model ""NCApplication.xml"" from the current directory.
 * @param args Ignored
 * @exception Exception If there is a problem reading the model.
 */
public static void main(String[] args) throws Exception {
  CompositeEntity _toplevel;
  try {
    Workspace workspace=new Workspace(""String_Node_Str"");
    _toplevel=new CompositeEntity(workspace);
    _toplevel.setName(""String_Node_Str"");
    Counter counter=new Counter(_toplevel,""String_Node_Str"");
    Leds leds=new Leds(_toplevel,""String_Node_Str"");
    _toplevel.connect(counter.output,leds.display,""String_Node_Str"");
    StringWriter buffer=new StringWriter();
    _toplevel.exportMoML(buffer);
    String fileName=""String_Node_Str"";
    FileOutputStream file=null;
    PrintStream out=null;
    try {
      file=new FileOutputStream(fileName);
      out=new PrintStream(file);
      out.println(buffer);
      out.flush();
    }
  finally {
      if (out != null) {
        try {
          out.close();
        }
 catch (        Throwable throwable) {
          System.out.println(""String_Node_Str"" + ""String_Node_Str"" + fileName);
          throwable.printStackTrace();
        }
      }
    }
    counter.initialize();
    IntToken[] t=new IntToken[1];
    t[0]=new IntToken(2);
    TupleToken arg=new TupleToken(t);
    for (int i=0; i < 10; i++) {
      counter.increment.call(arg);
    }
  }
 catch (  Exception ex) {
    ex.printStackTrace();
    throw ex;
  }
}"
72748,"private void _getFSMTransitionParameter() throws IllegalActionException {
  if (getContainer() != null) {
    FSMTransitionParameter fsmtp=(FSMTransitionParameter)getContainer().getAttribute(fsmTransitionParameterName.getValueAsString());
    try {
      if (_fsmTransitionParameter != null && _fsmTransitionParameter != fsmtp) {
        _fsmTransitionParameter.setContainer(null);
      }
      _fsmTransitionParameter=fsmtp;
      if (_fsmTransitionParameter == null) {
        try {
          _fsmTransitionParameter=new FSMTransitionParameter(getContainer(),fsmTransitionParameterName.getValueAsString(),this);
        }
 catch (        NameDuplicationException e) {
          throw new IllegalActionException(this,e.getCause(),e.getMessage());
        }
      }
      _fsmTransitionParameter.setTransition(this);
    }
 catch (    NameDuplicationException e) {
      e.printStackTrace();
    }
  }
}","private void _getFSMTransitionParameter() throws IllegalActionException {
  if (getContainer() != null) {
    FSMTransitionParameter fsmtp=(FSMTransitionParameter)getContainer().getAttribute(fsmTransitionParameterName.getValueAsString());
    try {
      if (_fsmTransitionParameter != null && _fsmTransitionParameter != fsmtp) {
        _fsmTransitionParameter.setContainer(null);
      }
      _fsmTransitionParameter=fsmtp;
      if (_fsmTransitionParameter == null) {
        try {
          _fsmTransitionParameter=new FSMTransitionParameter(getContainer(),fsmTransitionParameterName.getValueAsString(),this);
        }
 catch (        NameDuplicationException e) {
          throw new IllegalActionException(this,e.getCause(),e.getMessage());
        }
      }
      if (_fsmTransitionParameter.getTransition() == null) {
        _fsmTransitionParameter.setTransition(this);
      }
    }
 catch (    NameDuplicationException e) {
      e.printStackTrace();
    }
  }
}"
72749,"/** 
 * Generate code for making transition. It generates code for both choice action and commit action.
 * @param code The string buffer that the generated code is appended to.
 * @param transitionRetriever An instance of a class implementinga method. which returns an iterator of all, preemptive or non-preemptive transitions of the current state.
 * @exception IllegalActionException If thrown while generatingtransition code.
 */
public void generateTransitionCode(StringBuffer code,TransitionRetriever transitionRetriever) throws IllegalActionException {
  StringBuffer codeBuffer=new StringBuffer();
  codeBuffer.append(getCodeGenerator().comment(""String_Node_Str""));
  ptolemy.domains.modal.kernel.FSMActor fsmActor=(ptolemy.domains.modal.kernel.FSMActor)getComponent();
  String name=fsmActor.getFullName().substring(1);
  String modalName=name.replace(""String_Node_Str"",""String_Node_Str"");
  modalName=modalName.replace('.','_').replace(' ','_');
  codeBuffer.append(getCodeGenerator().comment(""String_Node_Str""));
  codeBuffer.append(_eol + modalName + ""String_Node_Str""+ _eol);
  codeBuffer.append(""String_Node_Str"" + _eol + ""String_Node_Str""+ _eol);
  for (  State state : (List<State>)fsmActor.entityList()) {
    codeBuffer.append(""String_Node_Str"" + _generateStateConstantLabel(state) + ""String_Node_Str""+ _eol);
    Iterator transitions=transitionRetriever.retrieveTransitions(state);
    List reOrderedTransitions=new LinkedList();
    List defaultTransitions=new LinkedList();
    while (transitions.hasNext()) {
      Transition transition=(Transition)transitions.next();
      if (generateSimpleName(transition).equals(""String_Node_Str"")) {
        defaultTransitions.add(transition);
      }
 else {
        reOrderedTransitions.add(transition);
      }
    }
    reOrderedTransitions.addAll(defaultTransitions);
    transitions=reOrderedTransitions.iterator();
    int transitionCount=0;
    boolean hasDefaultCase=false;
    while (!hasDefaultCase && transitions.hasNext()) {
      Transition transition=(Transition)transitions.next();
      String guard=transition.getGuardExpression();
      if (transition.isDefault() || guard.toLowerCase(Locale.getDefault()).equals(""String_Node_Str"")) {
        hasDefaultCase=true;
      }
 else {
        if (transitionCount == 0) {
          codeBuffer.append(""String_Node_Str"");
        }
 else {
          codeBuffer.append(""String_Node_Str"");
        }
        transitionCount++;
        PtParser parser=new PtParser();
        ASTPtRootNode guardParseTree=parser.generateParseTree(guard);
        if (getTemplateParser() == null) {
          if (getCodeGenerator() == null) {
            throw new InternalErrorException(this,null,""String_Node_Str"");
          }
          getCodeGenerator().getAdapter(fsmActor);
        }
        ParseTreeCodeGenerator parseTreeCodeGenerator=getTemplateParser().getParseTreeCodeGenerator();
        parseTreeCodeGenerator.evaluateParseTree(guardParseTree,_scope);
        codeBuffer.append(parseTreeCodeGenerator.generateFireCode());
        codeBuffer.append(""String_Node_Str"");
      }
      codeBuffer.append(_eol + ""String_Node_Str"" + _eol);
      for (      AbstractActionsAttribute action : (List<AbstractActionsAttribute>)transition.choiceActionList()) {
        Iterator channelNumberList=action.getChannelNumberList().iterator();
        Iterator parseTreeList=action.getParseTreeList().iterator();
        for (        String destinationName : (List<String>)action.getDestinationNameList()) {
          Integer channelNumber=(Integer)channelNumberList.next();
          ASTPtRootNode parseTree=(ASTPtRootNode)parseTreeList.next();
          NamedObj destination=action.getDestination(destinationName);
          int channel=-1;
          if (channelNumber != null) {
            channel=channelNumber.intValue();
          }
          StringBuffer sendCode=new StringBuffer();
          if (channel >= 0) {
            codeBuffer.append(""String_Node_Str"" + destinationName + ""String_Node_Str""+ channel+ ""String_Node_Str"");
            if (((IOPort)destination).isInput()) {
              NamedProgramCodeGeneratorAdapter containerHelper=(NamedProgramCodeGeneratorAdapter)getCodeGenerator().getAdapter(((IOPort)destination).getContainer().getContainer());
              StringBuffer containerReference=new StringBuffer();
              codeBuffer.append(""String_Node_Str"");
              containerReference.append(""String_Node_Str"" + generateSimpleName(destination));
              if (((IOPort)destination).isMultiport()) {
                containerReference.append(""String_Node_Str"" + channel);
              }
              containerReference.append(""String_Node_Str"");
              codeBuffer.append(containerHelper.processCode(containerReference.toString()) + ""String_Node_Str"");
              sendCode.append(""String_Node_Str"" + destinationName + ""String_Node_Str""+ channel+ ""String_Node_Str""+ _eol);
            }
          }
 else {
            int width=((IOPort)action.getDestination(destinationName)).getWidth();
            for (int i=0; i < width; i++) {
              codeBuffer.append(""String_Node_Str"" + destinationName + ""String_Node_Str""+ i+ ""String_Node_Str"");
              if (((IOPort)destination).isInput()) {
                NamedProgramCodeGeneratorAdapter containerHelper=(NamedProgramCodeGeneratorAdapter)getCodeGenerator().getAdapter(((IOPort)destination).getContainer().getContainer());
                StringBuffer containerReference=new StringBuffer();
                containerReference.append(""String_Node_Str"" + generateSimpleName(destination));
                if (((IOPort)destination).isMultiport()) {
                  containerReference.append(""String_Node_Str"" + i);
                }
                containerReference.append(""String_Node_Str"");
                codeBuffer.append(containerHelper.processCode(containerReference.toString()) + ""String_Node_Str"");
              }
            }
          }
          ParseTreeCodeGenerator parseTreeCodeGenerator=getTemplateParser().getParseTreeCodeGenerator();
          parseTreeCodeGenerator.evaluateParseTree(parseTree,_scope);
          codeBuffer.append(parseTreeCodeGenerator.generateFireCode());
          codeBuffer.append(""String_Node_Str"" + _eol);
        }
      }
      Actor[] actors=transition.getRefinement();
      if (actors != null) {
        for (        Actor actor : actors) {
          NamedProgramCodeGeneratorAdapter helper=(NamedProgramCodeGeneratorAdapter)getAdapter(actor);
          codeBuffer.append(helper.generateFireCode());
        }
      }
      for (      AbstractActionsAttribute action : (List<AbstractActionsAttribute>)transition.commitActionList()) {
        Iterator channelNumberList=action.getChannelNumberList().iterator();
        Iterator parseTreeList=action.getParseTreeList().iterator();
        for (        String destinationName : (List<String>)action.getDestinationNameList()) {
          Integer channelNumber=(Integer)channelNumberList.next();
          ASTPtRootNode parseTree=(ASTPtRootNode)parseTreeList.next();
          NamedObj destination=action.getDestination(destinationName);
          int channel=-1;
          if (channelNumber != null) {
            channel=channelNumber.intValue();
          }
          ParseTreeCodeGenerator parseTreeCodeGenerator=getTemplateParser().getParseTreeCodeGenerator();
          parseTreeCodeGenerator.evaluateParseTree(parseTree,_scope);
          String scopeFireCode=parseTreeCodeGenerator.generateFireCode();
          if (destination instanceof IOPort) {
            if (channel >= 0) {
              codeBuffer.append(""String_Node_Str"" + destinationName + ""String_Node_Str""+ channel+ ""String_Node_Str""+ scopeFireCode+ ""String_Node_Str"");
            }
 else {
              int width=((IOPort)action.getDestination(destinationName)).getWidth();
              for (int i=0; i < width; i++) {
                codeBuffer.append(""String_Node_Str"" + destinationName + ""String_Node_Str""+ i+ ""String_Node_Str""+ scopeFireCode+ ""String_Node_Str"");
              }
            }
          }
 else           if (destination instanceof Variable) {
            codeBuffer.append(getCodeGenerator().generateVariableName(destination) + ""String_Node_Str"" + scopeFireCode+ ""String_Node_Str"");
          }
        }
      }
      State destinationState=transition.destinationState();
      _updateCurrentState(codeBuffer,destinationState);
      if (!transition.isHistory()) {
        actors=destinationState.getRefinement();
        if (actors != null) {
          for (int i=0; i < actors.length; ++i) {
            NamedProgramCodeGeneratorAdapter helper=(NamedProgramCodeGeneratorAdapter)getAdapter(actors[i]);
            codeBuffer.append(helper.generateInitializeCode());
          }
        }
      }
      codeBuffer.append(_eol + ""String_Node_Str"" + _eol);
    }
    if (!hasDefaultCase) {
      if (transitionCount > 0) {
        codeBuffer.append(""String_Node_Str"" + _eol + ""String_Node_Str""+ _eol);
      }
 else {
        codeBuffer.append(_eol);
      }
      codeBuffer.append(_eol + modalName + ""String_Node_Str""+ _eol);
      if (transitionCount > 0) {
        codeBuffer.append(_eol + ""String_Node_Str"" + _eol);
      }
    }
    codeBuffer.append(_eol + ""String_Node_Str"" + _eol);
  }
  codeBuffer.append(_eol + ""String_Node_Str"" + _eol);
  code.append(TemplateParser.unescapeName(processCode(codeBuffer.toString())));
}","/** 
 * Generate code for making transition. It generates code for both choice action and commit action.
 * @param code The string buffer that the generated code is appended to.
 * @param transitionRetriever An instance of a class implementinga method. which returns an iterator of all, preemptive or non-preemptive transitions of the current state.
 * @exception IllegalActionException If thrown while generatingtransition code.
 */
public void generateTransitionCode(StringBuffer code,TransitionRetriever transitionRetriever) throws IllegalActionException {
  StringBuffer codeBuffer=new StringBuffer();
  codeBuffer.append(getCodeGenerator().comment(""String_Node_Str""));
  ptolemy.domains.modal.kernel.FSMActor fsmActor=(ptolemy.domains.modal.kernel.FSMActor)getComponent();
  String name=fsmActor.getFullName().substring(1);
  String modalName=name.replace(""String_Node_Str"",""String_Node_Str"");
  modalName=modalName.replace('.','_').replace(' ','_');
  codeBuffer.append(getCodeGenerator().comment(""String_Node_Str""));
  codeBuffer.append(_eol + modalName + ""String_Node_Str""+ _eol);
  codeBuffer.append(""String_Node_Str"" + _eol + ""String_Node_Str""+ _eol);
  for (  State state : (List<State>)fsmActor.entityList()) {
    codeBuffer.append(""String_Node_Str"" + _generateStateConstantLabel(state) + ""String_Node_Str""+ _eol);
    Iterator transitions=transitionRetriever.retrieveTransitions(state);
    List reOrderedTransitions=new LinkedList();
    List defaultTransitions=new LinkedList();
    while (transitions.hasNext()) {
      Transition transition=(Transition)transitions.next();
      if (generateSimpleName(transition).equals(""String_Node_Str"")) {
        defaultTransitions.add(transition);
      }
 else {
        reOrderedTransitions.add(transition);
      }
    }
    reOrderedTransitions.addAll(defaultTransitions);
    transitions=reOrderedTransitions.iterator();
    int transitionCount=0;
    boolean hasDefaultCase=false;
    while (!hasDefaultCase && transitions.hasNext()) {
      Transition transition=(Transition)transitions.next();
      String guard=transition.getGuardExpression();
      if (transition.isDefault() || guard.toLowerCase(Locale.getDefault()).equals(""String_Node_Str"")) {
        hasDefaultCase=true;
      }
 else {
        if (transitionCount == 0) {
          codeBuffer.append(""String_Node_Str"");
        }
 else {
          codeBuffer.append(""String_Node_Str"");
        }
        transitionCount++;
        PtParser parser=new PtParser();
        ASTPtRootNode guardParseTree=parser.generateParseTree(guard);
        if (getTemplateParser() == null) {
          if (getCodeGenerator() == null) {
            throw new InternalErrorException(this,null,""String_Node_Str"");
          }
          getCodeGenerator().getAdapter(fsmActor);
        }
        ParseTreeCodeGenerator parseTreeCodeGenerator=getTemplateParser().getParseTreeCodeGenerator();
        parseTreeCodeGenerator.evaluateParseTree(guardParseTree,_scope);
        codeBuffer.append(parseTreeCodeGenerator.generateFireCode());
        codeBuffer.append(""String_Node_Str"");
      }
      codeBuffer.append(_eol + ""String_Node_Str"" + _eol);
      for (      AbstractActionsAttribute action : (List<AbstractActionsAttribute>)transition.choiceActionList()) {
        Iterator channelNumberList=action.getChannelNumberList().iterator();
        Iterator parseTreeList=action.getParseTreeList().iterator();
        for (        String destinationName : (List<String>)action.getDestinationNameList()) {
          Integer channelNumber=(Integer)channelNumberList.next();
          ASTPtRootNode parseTree=(ASTPtRootNode)parseTreeList.next();
          NamedObj destination=action.getDestination(destinationName);
          int channel=-1;
          if (channelNumber != null) {
            channel=channelNumber.intValue();
          }
          StringBuffer sendCode=new StringBuffer();
          if (channel >= 0) {
            codeBuffer.append(""String_Node_Str"" + destinationName + ""String_Node_Str""+ channel+ ""String_Node_Str"");
            if (((IOPort)destination).isInput()) {
              NamedProgramCodeGeneratorAdapter containerHelper=(NamedProgramCodeGeneratorAdapter)getCodeGenerator().getAdapter(((IOPort)destination).getContainer().getContainer());
              StringBuffer containerReference=new StringBuffer();
              containerReference.append(""String_Node_Str"" + generateSimpleName(destination));
              if (((IOPort)destination).isMultiport()) {
                containerReference.append(""String_Node_Str"" + channel);
              }
              containerReference.append(""String_Node_Str"");
              codeBuffer.append(containerHelper.processCode(containerReference.toString()) + ""String_Node_Str"");
              sendCode.append(""String_Node_Str"" + destinationName + ""String_Node_Str""+ channel+ ""String_Node_Str""+ _eol);
            }
          }
 else {
            int width=((IOPort)action.getDestination(destinationName)).getWidth();
            for (int i=0; i < width; i++) {
              codeBuffer.append(""String_Node_Str"" + destinationName + ""String_Node_Str""+ i+ ""String_Node_Str"");
              if (((IOPort)destination).isInput()) {
                NamedProgramCodeGeneratorAdapter containerHelper=(NamedProgramCodeGeneratorAdapter)getCodeGenerator().getAdapter(((IOPort)destination).getContainer().getContainer());
                StringBuffer containerReference=new StringBuffer();
                containerReference.append(""String_Node_Str"" + generateSimpleName(destination));
                if (((IOPort)destination).isMultiport()) {
                  containerReference.append(""String_Node_Str"" + i);
                }
                containerReference.append(""String_Node_Str"");
                codeBuffer.append(containerHelper.processCode(containerReference.toString()) + ""String_Node_Str"");
              }
            }
          }
          ParseTreeCodeGenerator parseTreeCodeGenerator=getTemplateParser().getParseTreeCodeGenerator();
          parseTreeCodeGenerator.evaluateParseTree(parseTree,_scope);
          codeBuffer.append(parseTreeCodeGenerator.generateFireCode());
          codeBuffer.append(""String_Node_Str"" + _eol);
        }
      }
      Actor[] actors=transition.getRefinement();
      if (actors != null) {
        for (        Actor actor : actors) {
          NamedProgramCodeGeneratorAdapter helper=(NamedProgramCodeGeneratorAdapter)getAdapter(actor);
          codeBuffer.append(helper.generateFireCode());
        }
      }
      for (      AbstractActionsAttribute action : (List<AbstractActionsAttribute>)transition.commitActionList()) {
        Iterator channelNumberList=action.getChannelNumberList().iterator();
        Iterator parseTreeList=action.getParseTreeList().iterator();
        for (        String destinationName : (List<String>)action.getDestinationNameList()) {
          Integer channelNumber=(Integer)channelNumberList.next();
          ASTPtRootNode parseTree=(ASTPtRootNode)parseTreeList.next();
          NamedObj destination=action.getDestination(destinationName);
          int channel=-1;
          if (channelNumber != null) {
            channel=channelNumber.intValue();
          }
          ParseTreeCodeGenerator parseTreeCodeGenerator=getTemplateParser().getParseTreeCodeGenerator();
          parseTreeCodeGenerator.evaluateParseTree(parseTree,_scope);
          String scopeFireCode=parseTreeCodeGenerator.generateFireCode();
          if (destination instanceof IOPort) {
            if (channel >= 0) {
              codeBuffer.append(""String_Node_Str"" + destinationName + ""String_Node_Str""+ channel+ ""String_Node_Str""+ scopeFireCode+ ""String_Node_Str"");
            }
 else {
              int width=((IOPort)action.getDestination(destinationName)).getWidth();
              for (int i=0; i < width; i++) {
                codeBuffer.append(""String_Node_Str"" + destinationName + ""String_Node_Str""+ i+ ""String_Node_Str""+ scopeFireCode+ ""String_Node_Str"");
              }
            }
          }
 else           if (destination instanceof Variable) {
            codeBuffer.append(getCodeGenerator().generateVariableName(destination) + ""String_Node_Str"" + scopeFireCode+ ""String_Node_Str"");
          }
        }
      }
      State destinationState=transition.destinationState();
      _updateCurrentState(codeBuffer,destinationState);
      if (!transition.isHistory()) {
        actors=destinationState.getRefinement();
        if (actors != null) {
          for (int i=0; i < actors.length; ++i) {
            NamedProgramCodeGeneratorAdapter helper=(NamedProgramCodeGeneratorAdapter)getAdapter(actors[i]);
            codeBuffer.append(helper.generateInitializeCode());
          }
        }
      }
      codeBuffer.append(_eol + ""String_Node_Str"" + _eol);
    }
    if (!hasDefaultCase) {
      if (transitionCount > 0) {
        codeBuffer.append(""String_Node_Str"" + _eol + ""String_Node_Str""+ _eol);
      }
 else {
        codeBuffer.append(_eol);
      }
      codeBuffer.append(_eol + modalName + ""String_Node_Str""+ _eol);
      if (transitionCount > 0) {
        codeBuffer.append(_eol + ""String_Node_Str"" + _eol);
      }
    }
    codeBuffer.append(_eol + ""String_Node_Str"" + _eol);
  }
  codeBuffer.append(_eol + ""String_Node_Str"" + _eol);
  code.append(TemplateParser.unescapeName(processCode(codeBuffer.toString())));
}"
72750,"/** 
 * Generate the code for the transfer of output values inside the modal model.
 * @return The generated code.
 * @exception IllegalActionException If the adapter associated withan actor throws it while generating code for the actor.
 */
public String generateTransferOutputCode() throws IllegalActionException {
  StringBuffer code=new StringBuffer();
  CompositeActor container=((CompositeActor)_director.getContainer());
  String containerName=generateName(container);
  Iterator<?> ports=container.outputPortList().iterator();
  while (ports.hasNext()) {
    TypedIOPort port=(TypedIOPort)ports.next();
    if (!port.getFullName().contains(""String_Node_Str"")) {
      code.append(_eol + port.getName() + ""String_Node_Str""+ containerName+ ""String_Node_Str""+ port.getName()+ ""String_Node_Str"");
      int width=port.getWidth();
      for (int i=0; i < width; i++) {
        code.append(_eol + ""String_Node_Str"" + port.getName()+ ""String_Node_Str""+ _eol);
        code.append(_eol + ""String_Node_Str"" + port.getName()+ ""String_Node_Str"");
        code.append(_eol + containerName + ""String_Node_Str""+ port.getName());
        code.append(""String_Node_Str"");
        code.append(""String_Node_Str"" + getCodeGenerator().codeGenType(port.getType()) + ""String_Node_Str""+ _eol);
        code.append(_eol + ""String_Node_Str"");
      }
    }
  }
  ports=container.outputPortList().iterator();
  while (ports.hasNext()) {
    TypedIOPort port=(TypedIOPort)ports.next();
    if (!port.getFullName().contains(""String_Node_Str"")) {
      code.append(_eol + port.getName() + ""String_Node_Str""+ containerName+ ""String_Node_Str""+ port.getName()+ ""String_Node_Str"");
    }
  }
  return processCode(code.toString());
}","/** 
 * Generate the code for the transfer of output values inside the modal model.
 * @return The generated code.
 * @exception IllegalActionException If the adapter associated withan actor throws it while generating code for the actor.
 */
public String generateTransferOutputCode() throws IllegalActionException {
  StringBuffer code=new StringBuffer();
  CompositeActor container=((CompositeActor)_director.getContainer());
  String containerName=generateName(container);
  Iterator<?> ports=container.outputPortList().iterator();
  while (ports.hasNext()) {
    TypedIOPort port=(TypedIOPort)ports.next();
    if (!port.getFullName().contains(""String_Node_Str"")) {
      code.append(_eol + port.getName() + ""String_Node_Str""+ containerName+ ""String_Node_Str""+ port.getName()+ ""String_Node_Str"");
      int width=port.getWidth();
      String widthDeclaration;
      for (int i=0; i < width; i++) {
        if (width > 1) {
          widthDeclaration=""String_Node_Str"" + i + ""String_Node_Str"";
        }
 else {
          widthDeclaration=""String_Node_Str"";
        }
        code.append(_eol + ""String_Node_Str"" + port.getName()+ ""String_Node_Str""+ _eol);
        code.append(_eol + ""String_Node_Str"" + port.getName()+ ""String_Node_Str"");
        code.append(_eol + containerName + ""String_Node_Str""+ port.getName()+ widthDeclaration);
        code.append(""String_Node_Str"");
        code.append(""String_Node_Str"" + getCodeGenerator().codeGenType(port.getType()) + ""String_Node_Str""+ _eol);
        code.append(_eol + ""String_Node_Str"");
      }
    }
  }
  ports=container.outputPortList().iterator();
  while (ports.hasNext()) {
    TypedIOPort port=(TypedIOPort)ports.next();
    if (!port.getFullName().contains(""String_Node_Str"")) {
      code.append(_eol + port.getName() + ""String_Node_Str""+ containerName+ ""String_Node_Str""+ port.getName()+ ""String_Node_Str"");
    }
  }
  return processCode(code.toString());
}"
72751,"public void sampleFromPrior() throws IllegalActionException {
  _parseTree=_updateTrees.get(""String_Node_Str"");
  for (int i=0; i < _ssSize; i++) {
    Token priorSample=_parseTreeEvaluator.evaluateParseTree(_parseTree,_scope);
    if (priorSample == null) {
      throw new IllegalActionException(""String_Node_Str"" + prior.getExpression());
    }
    double value=((DoubleToken)priorSample).doubleValue();
    _particleValue.add(value);
  }
}","public void sampleFromPrior() throws IllegalActionException {
  _parseTree=_updateTrees.get(""String_Node_Str"");
  for (int i=0; i < _ssSize; i++) {
    Token priorSample=_parseTreeEvaluator.evaluateParseTree(_parseTree,_scope);
    if (priorSample == null) {
      throw new IllegalActionException(""String_Node_Str"" + prior.getExpression());
    }
    double value=((DoubleToken)priorSample).doubleValue();
    _particleValue.add(Double.valueOf(value));
  }
}"
72752,"public Particle(int size){
  _particleValue=new LinkedList();
  _ssSize=size;
}","public Particle(int size){
  _particleValue=new LinkedList<Double>();
  _ssSize=size;
}"
72753,"public void assignWeight(Expression measurementEquation,String[] _stateVariables) throws IllegalActionException, NameDuplicationException {
  Token _result;
  Token _particleCovariance;
  Parameter p;
  if (this.getSize() != _stateVariables.length) {
    throw new IllegalActionException(""String_Node_Str"");
  }
 else {
    for (int i=0; i < _stateVariables.length; i++) {
      if ((ParticleFilter.this).getAttribute(_stateVariables[i]) == null) {
        p=new Parameter(ParticleFilter.this,_stateVariables[i]);
      }
 else {
        p=(Parameter)(ParticleFilter.this).getAttribute(_stateVariables[i]);
      }
      p.setExpression(_particleValue.get(i).toString());
      _tokenMap.put(_stateVariables[i],new DoubleToken((double)_particleValue.get(i)));
    }
    try {
      PtParser parser=new PtParser();
      _parseTree=parser.generateParseTree(measurementEquation.expression.getExpression());
      _result=_parseTreeEvaluator.evaluateParseTree(_parseTree,_scope);
      _parseTree=parser.generateParseTree(_measurementCovariance.expression.getExpression());
      _particleCovariance=_parseTreeEvaluator.evaluateParseTree(_parseTree,_scope);
    }
 catch (    Throwable throwable) {
      throw new IllegalActionException(""String_Node_Str"");
    }
    if (_result == null) {
      throw new IllegalActionException(""String_Node_Str"" + measurementEquation.expression.getExpression());
    }
    Type t=_measurementEquation.output.getType();
    if (t.equals(BaseType.DOUBLE)) {
      double _meanEstimate=((DoubleToken)_result).doubleValue();
      double z_t=((DoubleToken)_measurementValues.get(_measurementVariable)).doubleValue();
      _weight=1 / (Math.pow(2 * Math.PI,0.5) * DoubleMatrixMath.determinant(_Sigma)) * Math.exp(-Math.pow(z_t - _meanEstimate,2) / (2 * Math.pow(_Sigma[0][0],2)));
    }
 else {
      MatrixToken z_t=(MatrixToken)_measurementValues.get(_measurementVariable);
      int k=z_t.getRowCount();
      MatrixToken X=(DoubleMatrixToken)z_t.subtract((Token)_result);
      MatrixToken Covariance=(DoubleMatrixToken)_particleCovariance;
      MatrixToken Xt=new DoubleMatrixToken(DoubleMatrixMath.transpose(X.doubleMatrix()));
      double multiplier=Math.pow(2 * Math.PI,-0.5 * k) * Math.pow(DoubleMatrixMath.determinant(Covariance.doubleMatrix()),-0.5);
      Token exponent=Xt.multiply(Covariance);
      exponent=exponent.multiply(X);
      double value=((DoubleMatrixToken)exponent).getElementAt(0,0);
      _weight=multiplier * Math.exp(-0.5 * value);
    }
  }
}","public void assignWeight(Expression measurementEquation,String[] _stateVariables) throws IllegalActionException, NameDuplicationException {
  Token _result;
  Token _particleCovariance;
  Parameter p;
  if (this.getSize() != _stateVariables.length) {
    throw new IllegalActionException(""String_Node_Str"");
  }
 else {
    for (int i=0; i < _stateVariables.length; i++) {
      if ((ParticleFilter.this).getAttribute(_stateVariables[i]) == null) {
        p=new Parameter(ParticleFilter.this,_stateVariables[i]);
      }
 else {
        p=(Parameter)(ParticleFilter.this).getAttribute(_stateVariables[i]);
      }
      p.setExpression(_particleValue.get(i).toString());
      _tokenMap.put(_stateVariables[i],new DoubleToken(_particleValue.get(i).doubleValue()));
    }
    try {
      PtParser parser=new PtParser();
      _parseTree=parser.generateParseTree(measurementEquation.expression.getExpression());
      _result=_parseTreeEvaluator.evaluateParseTree(_parseTree,_scope);
      _parseTree=parser.generateParseTree(_measurementCovariance.expression.getExpression());
      _particleCovariance=_parseTreeEvaluator.evaluateParseTree(_parseTree,_scope);
    }
 catch (    Throwable throwable) {
      throw new IllegalActionException(""String_Node_Str"");
    }
    if (_result == null) {
      throw new IllegalActionException(""String_Node_Str"" + measurementEquation.expression.getExpression());
    }
    Type t=_measurementEquation.output.getType();
    if (t.equals(BaseType.DOUBLE)) {
      double _meanEstimate=((DoubleToken)_result).doubleValue();
      double z_t=((DoubleToken)_measurementValues.get(_measurementVariable)).doubleValue();
      _weight=1 / (Math.pow(2 * Math.PI,0.5) * DoubleMatrixMath.determinant(_Sigma)) * Math.exp(-Math.pow(z_t - _meanEstimate,2) / (2 * Math.pow(_Sigma[0][0],2)));
    }
 else {
      MatrixToken z_t=(MatrixToken)_measurementValues.get(_measurementVariable);
      int k=z_t.getRowCount();
      MatrixToken X=(DoubleMatrixToken)z_t.subtract((Token)_result);
      MatrixToken Covariance=(DoubleMatrixToken)_particleCovariance;
      MatrixToken Xt=new DoubleMatrixToken(DoubleMatrixMath.transpose(X.doubleMatrix()));
      double multiplier=Math.pow(2 * Math.PI,-0.5 * k) * Math.pow(DoubleMatrixMath.determinant(Covariance.doubleMatrix()),-0.5);
      Token exponent=Xt.multiply(Covariance);
      exponent=exponent.multiply(X);
      double value=((DoubleMatrixToken)exponent).getElementAt(0,0);
      _weight=multiplier * Math.exp(-0.5 * value);
    }
  }
}"
72754,"public void setNextParticle() throws NameDuplicationException, IllegalActionException {
  Token _result;
  Token processNoiseSample;
  LinkedList newParticle=new LinkedList();
  for (int i=0; i < _stateSpaceSize; i++) {
    Parameter p=(Parameter)(_updateEquations.get(_stateVariables[i])).getAttribute(_stateVariables[i]);
    if (p != null) {
      p.setExpression(_particleValue.get(i).toString());
    }
 else {
      p=new Parameter(_updateEquations.get(_stateVariables[i]),_stateVariables[i]);
      p.setExpression(_particleValue.get(i).toString());
    }
    _tokenMap.put(_stateVariables[i],new DoubleToken((double)_particleValue.get(i)));
    Iterator ci=_controlInputs.keySet().iterator();
    while (ci.hasNext()) {
      String controlVarName=(String)ci.next();
      Parameter c=(Parameter)(_updateEquations.get(_stateVariables[i])).getAttribute(controlVarName);
      if (c != null) {
        c.setExpression(_controlInputs.get(controlVarName).toString());
      }
 else {
        c=new Parameter(_updateEquations.get(_stateVariables[i]),controlVarName);
        c.setExpression(_controlInputs.get(controlVarName).toString());
      }
      _tokenMap.put(controlVarName,new DoubleToken(_controlInputs.get(controlVarName)));
    }
  }
  try {
    _parseTree=_updateTrees.get(""String_Node_Str"");
    processNoiseSample=_parseTreeEvaluator.evaluateParseTree(_parseTree,_scope);
  }
 catch (  Throwable throwable) {
    throw new IllegalActionException(""String_Node_Str"");
  }
  if (processNoiseSample == null) {
    throw new IllegalActionException(""String_Node_Str"" + processNoise.getExpression());
  }
  for (int i=0; i < _stateSpaceSize; i++) {
    try {
      _parseTree=_updateTrees.get(_stateVariables[i]);
      _result=_parseTreeEvaluator.evaluateParseTree(_parseTree,_scope);
    }
 catch (    Throwable throwable) {
      throw new IllegalActionException(""String_Node_Str"");
    }
    if (_result == null) {
      throw new IllegalActionException(""String_Node_Str"" + _updateEquations.get(_stateVariables[i]).expression.getExpression());
    }
    double _meanEstimate=((DoubleToken)_result.add(new DoubleToken(0.0))).doubleValue();
    double processNoiseForElement=((DoubleToken)((ArrayToken)processNoiseSample).getElement(i)).doubleValue();
    newParticle.add(_meanEstimate + processNoiseForElement);
  }
  this.setValue(newParticle);
  this.assignWeight(_measurementEquation,_stateVariables);
}","public void setNextParticle() throws NameDuplicationException, IllegalActionException {
  Token _result;
  Token processNoiseSample;
  LinkedList newParticle=new LinkedList();
  for (int i=0; i < _stateSpaceSize; i++) {
    Parameter p=(Parameter)(_updateEquations.get(_stateVariables[i])).getAttribute(_stateVariables[i]);
    if (p != null) {
      p.setExpression(_particleValue.get(i).toString());
    }
 else {
      p=new Parameter(_updateEquations.get(_stateVariables[i]),_stateVariables[i]);
      p.setExpression(_particleValue.get(i).toString());
    }
    _tokenMap.put(_stateVariables[i],new DoubleToken((double)_particleValue.get(i).doubleValue()));
    Iterator ci=_controlInputs.keySet().iterator();
    while (ci.hasNext()) {
      String controlVarName=(String)ci.next();
      Parameter c=(Parameter)(_updateEquations.get(_stateVariables[i])).getAttribute(controlVarName);
      if (c != null) {
        c.setExpression(_controlInputs.get(controlVarName).toString());
      }
 else {
        c=new Parameter(_updateEquations.get(_stateVariables[i]),controlVarName);
        c.setExpression(_controlInputs.get(controlVarName).toString());
      }
      _tokenMap.put(controlVarName,new DoubleToken(_controlInputs.get(controlVarName)));
    }
  }
  try {
    _parseTree=_updateTrees.get(""String_Node_Str"");
    processNoiseSample=_parseTreeEvaluator.evaluateParseTree(_parseTree,_scope);
  }
 catch (  Throwable throwable) {
    throw new IllegalActionException(""String_Node_Str"");
  }
  if (processNoiseSample == null) {
    throw new IllegalActionException(""String_Node_Str"" + processNoise.getExpression());
  }
  for (int i=0; i < _stateSpaceSize; i++) {
    try {
      _parseTree=_updateTrees.get(_stateVariables[i]);
      _result=_parseTreeEvaluator.evaluateParseTree(_parseTree,_scope);
    }
 catch (    Throwable throwable) {
      throw new IllegalActionException(""String_Node_Str"");
    }
    if (_result == null) {
      throw new IllegalActionException(""String_Node_Str"" + _updateEquations.get(_stateVariables[i]).expression.getExpression());
    }
    double _meanEstimate=((DoubleToken)_result.add(new DoubleToken(0.0))).doubleValue();
    double processNoiseForElement=((DoubleToken)((ArrayToken)processNoiseSample).getElement(i)).doubleValue();
    newParticle.add(_meanEstimate + processNoiseForElement);
  }
  this.setValue(newParticle);
  this.assignWeight(_measurementEquation,_stateVariables);
}"
72755,"public List getValue(){
  return _particleValue;
}","public List<Double> getValue(){
  return _particleValue;
}"
72756,"public void setValue(LinkedList l){
  _particleValue=new LinkedList();
  for (int i=0; i < l.size(); i++) {
    _particleValue.add(l.get(i));
  }
}","public void setValue(LinkedList<Double> l){
  _particleValue=new LinkedList<Double>();
  for (int i=0; i < l.size(); i++) {
    _particleValue.add(l.get(i));
  }
}"
72757,"/** 
 * Generate a sample from a multivariate Gaussian distribution.
 * @param type The type of the argument to the corresponding function.
 * @return The type of the value returned from the corresponding function.
 */
public static ArrayToken multivariateGaussian(ArrayToken mean,DoubleMatrixToken covariance) throws IllegalActionException {
  int N=mean.length();
  double[][] S=covariance.doubleMatrix();
  if ((covariance.getColumnCount() != N) || (covariance.getRowCount() != covariance.getColumnCount())) {
    throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
  }
  for (int i=0; i < N; i++) {
    for (int j=0; j < i; j++) {
      if (S[i][j] != S[j][i]) {
        throw new IllegalActionException(""String_Node_Str"");
      }
    }
  }
  double[][] L=new double[N][N];
  for (int i=0; i < N; i++) {
    for (int j=0; j <= i; j++) {
      double lowerSum=0;
      for (int k=0; k < j; k++) {
        lowerSum+=L[i][k] * L[j][k];
      }
      if (i != j) {
        L[i][j]=1.0 / L[j][j] * (S[i][j] - lowerSum);
      }
 else {
        L[i][j]=Math.pow(S[i][i] - lowerSum,0.5);
      }
    }
  }
  ArrayToken uncorrelated=gaussian(0,1,N);
  Token[] uncorrelatedTokens=uncorrelated.arrayValue();
  Token[] correlatedTokens=new Token[N];
  double[] correlatedSamples=new double[N];
  for (int i=0; i < N; i++) {
    for (int j=0; j < N; j++) {
      double uncorr=((DoubleToken)uncorrelatedTokens[j]).doubleValue();
      correlatedSamples[i]+=L[i][j] * uncorr;
    }
    correlatedTokens[i]=new DoubleToken(correlatedSamples[i]);
  }
  return new ArrayToken(correlatedTokens);
}","/** 
 * Generate a sample from a multivariate Gaussian distribution.
 * @param type The type of the argument to the corresponding function.
 * @return The type of the value returned from the corresponding function.
 */
public static ArrayToken multivariateGaussian(ArrayToken mean,DoubleMatrixToken covariance) throws IllegalActionException {
  int N=mean.length();
  double[][] S=covariance.doubleMatrix();
  if ((covariance.getColumnCount() != N) || (covariance.getRowCount() != covariance.getColumnCount())) {
    throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
  }
 else   if (!BaseType.DOUBLE.isCompatible(mean.getElementType())) {
    throw new IllegalActionException(""String_Node_Str"");
  }
  for (int i=0; i < N; i++) {
    for (int j=0; j < i; j++) {
      if (S[i][j] != S[j][i]) {
        throw new IllegalActionException(""String_Node_Str"");
      }
    }
  }
  double[][] L=new double[N][N];
  for (int i=0; i < N; i++) {
    for (int j=0; j <= i; j++) {
      double lowerSum=0;
      for (int k=0; k < j; k++) {
        lowerSum+=L[i][k] * L[j][k];
      }
      if (i != j) {
        L[i][j]=1.0 / L[j][j] * (S[i][j] - lowerSum);
      }
 else {
        L[i][j]=Math.pow(S[i][i] - lowerSum,0.5);
      }
    }
  }
  ArrayToken uncorrelated=gaussian(0,1,N);
  Token[] uncorrelatedTokens=uncorrelated.arrayValue();
  Token[] correlatedTokens=new Token[N];
  double[] correlatedSamples=new double[N];
  Token[] meanArray=mean.arrayValue();
  for (int i=0; i < N; i++) {
    for (int j=0; j < N; j++) {
      double uncorr=((DoubleToken)uncorrelatedTokens[j]).doubleValue();
      correlatedSamples[i]+=L[i][j] * uncorr;
    }
    correlatedTokens[i]=new DoubleToken(correlatedSamples[i]).add(meanArray[i]);
  }
  return new ArrayToken(BaseType.DOUBLE,correlatedTokens);
}"
72758,"/** 
 * Initialize the class. 
 */
private void _init() throws IllegalActionException, NameDuplicationException {
  particleOutput=new TypedIOPort(this,""String_Node_Str"",false,true);
  particleOutput.setTypeEquals(RecordType.EMPTY_RECORD);
  StringToken[] empty=new StringToken[1];
  stateVariableNames=new Parameter(this,""String_Node_Str"");
  empty[0]=new StringToken(""String_Node_Str"");
  stateVariableNames.setToken(new ArrayToken(BaseType.STRING,empty));
  bootstrap=new Parameter(this,""String_Node_Str"");
  bootstrap.setTypeEquals(BaseType.BOOLEAN);
  bootstrap.setExpression(""String_Node_Str"");
  measurementCovariance=new Parameter(this,""String_Node_Str"");
  measurementCovariance.setExpression(""String_Node_Str"");
  particleCount=new Parameter(this,""String_Node_Str"");
  particleCount.setExpression(""String_Node_Str"");
  Nparticles=1000;
  processNoise=new Parameter(this,""String_Node_Str"");
  processNoise.setExpression(""String_Node_Str"");
  prior=new Parameter(this,""String_Node_Str"");
  prior.setExpression(""String_Node_Str"");
  resetOnEachRun=new SharedParameter(this,""String_Node_Str"",RandomSource.class,""String_Node_Str"");
  resetOnEachRun.setTypeEquals(BaseType.BOOLEAN);
  seed=new SharedParameter(this,""String_Node_Str"",RandomSource.class,""String_Node_Str"");
  seed.setTypeEquals(BaseType.LONG);
  t=new Parameter(this,""String_Node_Str"");
  t.setTypeEquals(BaseType.DOUBLE);
  t.setVisibility(Settable.EXPERT);
  t.setExpression(""String_Node_Str"");
  _measurementParameters=new HashMap<String,Parameter>();
  _measurementValues=new HashMap<String,Token>();
  _firstIteration=true;
  particles=new Particle[Nparticles];
  _tokenMap=new HashMap<String,Token>();
  _parseTreeEvaluator=new ParseTreeEvaluator();
  _scope=new VariableScope();
  _createRandomGenerator();
  new DEDirector(this,""String_Node_Str"").setPersistent(false);
  _attachText(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","/** 
 * Initialize the class. 
 */
private void _init() throws IllegalActionException, NameDuplicationException {
  StringToken[] empty=new StringToken[1];
  stateVariableNames=new Parameter(this,""String_Node_Str"");
  empty[0]=new StringToken(""String_Node_Str"");
  stateVariableNames.setToken(new ArrayToken(BaseType.STRING,empty));
  bootstrap=new Parameter(this,""String_Node_Str"");
  bootstrap.setTypeEquals(BaseType.BOOLEAN);
  bootstrap.setExpression(""String_Node_Str"");
  particleCount=new Parameter(this,""String_Node_Str"");
  particleCount.setExpression(""String_Node_Str"");
  Nparticles=1000;
  processNoise=new Parameter(this,""String_Node_Str"");
  processNoise.setExpression(""String_Node_Str"");
  particleOutput=new TypedIOPort(this,""String_Node_Str"",false,true);
  particleOutput.setTypeEquals(RecordType.EMPTY_RECORD);
  prior=new Parameter(this,""String_Node_Str"");
  prior.setExpression(""String_Node_Str"");
  t=new Parameter(this,""String_Node_Str"");
  t.setTypeEquals(BaseType.DOUBLE);
  t.setVisibility(Settable.EXPERT);
  t.setExpression(""String_Node_Str"");
  measurementCovariance=new Parameter(this,""String_Node_Str"");
  measurementCovariance.setExpression(""String_Node_Str"");
  _measurementParameters=new HashMap<String,Parameter>();
  _measurementValues=new HashMap<String,Token>();
  _firstIteration=true;
  particles=new Particle[Nparticles];
  _tokenMap=new HashMap<String,Token>();
  _random=new Random(0);
  _parseTreeEvaluator=new ParseTreeEvaluator();
  _scope=new VariableScope();
  new DEDirector(this,""String_Node_Str"").setPersistent(false);
  _attachText(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}"
72759,"private void _initializeParticles() throws IllegalActionException, NameDuplicationException {
  for (int i=0; i < particles.length; i++) {
    particles[i]=new Particle(_stateSpaceSize);
    particles[i].sampleFromPrior();
    particles[i].assignWeight();
  }
}","private void _initializeParticles() throws IllegalActionException, NameDuplicationException {
  for (int i=0; i < particles.length; i++) {
    particles[i]=new Particle(_stateSpaceSize);
    particles[i].sampleFromPrior();
    particles[i].assignWeight(_measurementEquation,_stateVariables);
  }
}"
72760,"/** 
 * If the argument is any parameter other than <i>stateVariableNames</i> <i>t</i>, or any parameter matching an input port, then request reinitialization.
 * @param attribute The attribute that changed.
 * @exception IllegalActionException If the numerator and thedenominator matrix is not a row vector.
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  super.attributeChanged(attribute);
  if (attribute instanceof Parameter && attribute != t && attribute != stateVariableNames) {
    TypedIOPort port=(TypedIOPort)getPort(attribute.getName());
    if (port == null || !port.isInput()) {
      _requestInitialization();
    }
  }
 else   if (attribute == stateVariableNames) {
    ArrayToken names=(ArrayToken)stateVariableNames.getToken();
    try {
      for (int i=0; i < names.length(); i++) {
        String stateName=((StringToken)names.getElement(i)).stringValue();
        if (this.getAttribute(stateName) == null || stateName.length() != 0) {
          Parameter y=new Parameter(this,stateName);
          y.setExpression(""String_Node_Str"");
          y.setVisibility(Settable.EXPERT);
        }
      }
    }
 catch (    NameDuplicationException e) {
      System.err.println(""String_Node_Str"" + this.getName());
    }
  }
  if (attribute == particleCount) {
    int proposed=((IntToken)(particleCount.getToken())).intValue();
    if (proposed > 0) {
      Nparticles=proposed;
      particles=new Particle[Nparticles];
    }
  }
 else   if (attribute == measurementCovariance) {
    double[][] proposed=((MatrixToken)measurementCovariance.getToken()).doubleMatrix();
    _Sigma=proposed;
  }
 else   if (attribute == bootstrap) {
    doBootstrap=((BooleanToken)bootstrap.getToken()).booleanValue();
  }
 else   if (attribute == seed) {
    long seedValue;
    if (seed != null) {
      seedValue=((LongToken)seed.getToken()).longValue();
      _seed=seedValue;
      _createRandomGenerator();
    }
  }
 else {
    super.attributeChanged(attribute);
  }
  _upToDate=false;
}","/** 
 * If the argument is any parameter other than <i>stateVariableNames</i> <i>t</i>, or any parameter matching an input port, then request reinitialization.
 * @param attribute The attribute that changed.
 * @exception IllegalActionException If the numerator and thedenominator matrix is not a row vector.
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  super.attributeChanged(attribute);
  if (attribute instanceof Parameter && attribute != t && attribute != stateVariableNames) {
    TypedIOPort port=(TypedIOPort)getPort(attribute.getName());
    if (port == null || !port.isInput()) {
      _requestInitialization();
    }
  }
 else   if (attribute == stateVariableNames) {
    ArrayToken names=(ArrayToken)stateVariableNames.getToken();
    try {
      for (int i=0; i < names.length(); i++) {
        String stateName=((StringToken)names.getElement(i)).stringValue();
        if (this.getAttribute(stateName) == null && stateName.length() != 0) {
          Parameter y=new Parameter(this,stateName);
          y.setExpression(""String_Node_Str"");
          y.setVisibility(Settable.EXPERT);
        }
      }
    }
 catch (    NameDuplicationException e) {
      System.err.println(""String_Node_Str"" + this.getName());
    }
  }
  if (attribute == particleCount) {
    int proposed=((IntToken)(particleCount.getToken())).intValue();
    if (proposed > 0) {
      Nparticles=proposed;
      particles=new Particle[Nparticles];
    }
  }
 else   if (attribute == measurementCovariance) {
    double[][] proposed=((MatrixToken)measurementCovariance.getToken()).doubleMatrix();
    _Sigma=proposed;
  }
 else   if (attribute == bootstrap) {
    doBootstrap=((BooleanToken)bootstrap.getToken()).booleanValue();
  }
 else {
    super.attributeChanged(attribute);
  }
  _upToDate=false;
}"
72761,"public void assignWeight() throws IllegalActionException, NameDuplicationException {
  Token _result;
  Token _particleCovariance;
  Parameter p;
  if (this.getSize() != _stateVariables.length) {
    throw new IllegalActionException(""String_Node_Str"");
  }
 else {
    for (int i=0; i < _stateVariables.length; i++) {
      if (ParticleFilter.this.getAttribute(_stateVariables[i]) != null) {
        p=(Parameter)(ParticleFilter.this.getAttribute(_stateVariables[i]));
      }
 else {
        p=new Parameter(_measurementEquation,_stateVariables[i]);
      }
      p.setExpression(_particleValue.get(i).toString());
    }
    try {
      PtParser parser=new PtParser();
      _parseTree=parser.generateParseTree(_measurementEquation.expression.getExpression());
      _result=_parseTreeEvaluator.evaluateParseTree(_parseTree,_scope);
      _parseTree=parser.generateParseTree(_measurementCovariance.expression.getExpression());
      _particleCovariance=_parseTreeEvaluator.evaluateParseTree(_parseTree,_scope);
    }
 catch (    Throwable throwable) {
      throw new IllegalActionException(""String_Node_Str"");
    }
    if (_result == null) {
      throw new IllegalActionException(""String_Node_Str"" + _measurementEquation.expression.getExpression());
    }
 else     if (_particleCovariance == null) {
      throw new IllegalActionException(""String_Node_Str"" + _measurementCovariance.expression.getExpression());
    }
    Type t=_measurementEquation.output.getType();
    if (t.equals(BaseType.DOUBLE)) {
      double _meanEstimate=((DoubleToken)_result).doubleValue();
      double z_t=((DoubleToken)_measurementValues.get(_measurementVariable)).doubleValue();
      _weight=1 / (Math.pow(2 * Math.PI,0.5) * DoubleMatrixMath.determinant(_Sigma)) * Math.exp(-Math.pow(z_t - _meanEstimate,2) / (2 * Math.pow(_Sigma[0][0],2)));
    }
 else {
      MatrixToken z_t=(MatrixToken)_measurementValues.get(_measurementVariable);
      int k=z_t.getRowCount();
      MatrixToken X=(DoubleMatrixToken)z_t.subtract((Token)_result);
      MatrixToken Covariance=(DoubleMatrixToken)_particleCovariance;
      MatrixToken Xt=new DoubleMatrixToken(DoubleMatrixMath.transpose(X.doubleMatrix()));
      double multiplier=Math.pow(2 * Math.PI,-0.5 * k) * Math.pow(DoubleMatrixMath.determinant(Covariance.doubleMatrix()),-0.5);
      Token exponent=Xt.multiply(Covariance);
      exponent=exponent.multiply(X);
      double value=((DoubleMatrixToken)exponent).getElementAt(0,0);
      _weight=multiplier * Math.exp(-0.5 * value);
    }
  }
}","public void assignWeight(Expression measurementEquation,String[] _stateVariables) throws IllegalActionException, NameDuplicationException {
  Token _result;
  Token _particleCovariance;
  Parameter p;
  if (this.getSize() != _stateVariables.length) {
    throw new IllegalActionException(""String_Node_Str"");
  }
 else {
    for (int i=0; i < _stateVariables.length; i++) {
      if ((ParticleFilter.this).getAttribute(_stateVariables[i]) == null) {
        p=new Parameter(ParticleFilter.this,_stateVariables[i]);
      }
 else {
        p=(Parameter)(ParticleFilter.this).getAttribute(_stateVariables[i]);
      }
      p.setExpression(_particleValue.get(i).toString());
      _tokenMap.put(_stateVariables[i],new DoubleToken((double)_particleValue.get(i)));
    }
    try {
      PtParser parser=new PtParser();
      _parseTree=parser.generateParseTree(measurementEquation.expression.getExpression());
      _result=_parseTreeEvaluator.evaluateParseTree(_parseTree,_scope);
      _parseTree=parser.generateParseTree(_measurementCovariance.expression.getExpression());
      _particleCovariance=_parseTreeEvaluator.evaluateParseTree(_parseTree,_scope);
    }
 catch (    Throwable throwable) {
      throw new IllegalActionException(""String_Node_Str"");
    }
    if (_result == null) {
      throw new IllegalActionException(""String_Node_Str"" + measurementEquation.expression.getExpression());
    }
    Type t=_measurementEquation.output.getType();
    if (t.equals(BaseType.DOUBLE)) {
      double _meanEstimate=((DoubleToken)_result).doubleValue();
      double z_t=((DoubleToken)_measurementValues.get(_measurementVariable)).doubleValue();
      _weight=1 / (Math.pow(2 * Math.PI,0.5) * DoubleMatrixMath.determinant(_Sigma)) * Math.exp(-Math.pow(z_t - _meanEstimate,2) / (2 * Math.pow(_Sigma[0][0],2)));
    }
 else {
      MatrixToken z_t=(MatrixToken)_measurementValues.get(_measurementVariable);
      int k=z_t.getRowCount();
      MatrixToken X=(DoubleMatrixToken)z_t.subtract((Token)_result);
      MatrixToken Covariance=(DoubleMatrixToken)_particleCovariance;
      MatrixToken Xt=new DoubleMatrixToken(DoubleMatrixMath.transpose(X.doubleMatrix()));
      double multiplier=Math.pow(2 * Math.PI,-0.5 * k) * Math.pow(DoubleMatrixMath.determinant(Covariance.doubleMatrix()),-0.5);
      Token exponent=Xt.multiply(Covariance);
      exponent=exponent.multiply(X);
      double value=((DoubleMatrixToken)exponent).getElementAt(0,0);
      _weight=multiplier * Math.exp(-0.5 * value);
    }
  }
}"
72762,"public void setNextParticle() throws NameDuplicationException, IllegalActionException {
  Token _result;
  Token processNoiseSample;
  LinkedList newParticle=new LinkedList();
  for (int i=0; i < _stateSpaceSize; i++) {
    Parameter p=(Parameter)(_updateEquations.get(_stateVariables[i])).getAttribute(_stateVariables[i]);
    if (p != null) {
      p.setExpression(_particleValue.get(i).toString());
    }
 else {
      p=new Parameter(_updateEquations.get(_stateVariables[i]),_stateVariables[i]);
      p.setExpression(_particleValue.get(i).toString());
    }
    _tokenMap.put(_stateVariables[i],new DoubleToken((double)_particleValue.get(i)));
    Iterator ci=_controlInputs.keySet().iterator();
    while (ci.hasNext()) {
      String controlVarName=(String)ci.next();
      Parameter c=(Parameter)(_updateEquations.get(_stateVariables[i])).getAttribute(controlVarName);
      if (c != null) {
        c.setExpression(_controlInputs.get(controlVarName).toString());
      }
 else {
        c=new Parameter(_updateEquations.get(_stateVariables[i]),controlVarName);
        c.setExpression(_controlInputs.get(controlVarName).toString());
      }
      _tokenMap.put(controlVarName,new DoubleToken(_controlInputs.get(controlVarName)));
    }
  }
  try {
    _parseTree=_updateTrees.get(""String_Node_Str"");
    processNoiseSample=_parseTreeEvaluator.evaluateParseTree(_parseTree,_scope);
  }
 catch (  Throwable throwable) {
    throw new IllegalActionException(""String_Node_Str"");
  }
  if (processNoiseSample == null) {
    throw new IllegalActionException(""String_Node_Str"" + processNoise.getExpression());
  }
  for (int i=0; i < _stateSpaceSize; i++) {
    try {
      _parseTree=_updateTrees.get(_stateVariables[i]);
      _result=_parseTreeEvaluator.evaluateParseTree(_parseTree,_scope);
    }
 catch (    Throwable throwable) {
      throw new IllegalActionException(""String_Node_Str"");
    }
    if (_result == null) {
      throw new IllegalActionException(""String_Node_Str"" + _updateEquations.get(_stateVariables[i]).expression.getExpression());
    }
    double _meanEstimate=((DoubleToken)_result).doubleValue();
    double processNoiseForElement=((DoubleToken)((ArrayToken)processNoiseSample).getElement(i)).doubleValue();
    newParticle.add(_meanEstimate + processNoiseForElement);
  }
  this.setValue(newParticle);
  this.assignWeight();
}","public void setNextParticle() throws NameDuplicationException, IllegalActionException {
  Token _result;
  Token processNoiseSample;
  LinkedList newParticle=new LinkedList();
  for (int i=0; i < _stateSpaceSize; i++) {
    Parameter p=(Parameter)(_updateEquations.get(_stateVariables[i])).getAttribute(_stateVariables[i]);
    if (p != null) {
      p.setExpression(_particleValue.get(i).toString());
    }
 else {
      p=new Parameter(_updateEquations.get(_stateVariables[i]),_stateVariables[i]);
      p.setExpression(_particleValue.get(i).toString());
    }
    _tokenMap.put(_stateVariables[i],new DoubleToken((double)_particleValue.get(i)));
    Iterator ci=_controlInputs.keySet().iterator();
    while (ci.hasNext()) {
      String controlVarName=(String)ci.next();
      Parameter c=(Parameter)(_updateEquations.get(_stateVariables[i])).getAttribute(controlVarName);
      if (c != null) {
        c.setExpression(_controlInputs.get(controlVarName).toString());
      }
 else {
        c=new Parameter(_updateEquations.get(_stateVariables[i]),controlVarName);
        c.setExpression(_controlInputs.get(controlVarName).toString());
      }
      _tokenMap.put(controlVarName,new DoubleToken(_controlInputs.get(controlVarName)));
    }
  }
  try {
    _parseTree=_updateTrees.get(""String_Node_Str"");
    processNoiseSample=_parseTreeEvaluator.evaluateParseTree(_parseTree,_scope);
  }
 catch (  Throwable throwable) {
    throw new IllegalActionException(""String_Node_Str"");
  }
  if (processNoiseSample == null) {
    throw new IllegalActionException(""String_Node_Str"" + processNoise.getExpression());
  }
  for (int i=0; i < _stateSpaceSize; i++) {
    try {
      _parseTree=_updateTrees.get(_stateVariables[i]);
      _result=_parseTreeEvaluator.evaluateParseTree(_parseTree,_scope);
    }
 catch (    Throwable throwable) {
      throw new IllegalActionException(""String_Node_Str"");
    }
    if (_result == null) {
      throw new IllegalActionException(""String_Node_Str"" + _updateEquations.get(_stateVariables[i]).expression.getExpression());
    }
    double _meanEstimate=((DoubleToken)_result.add(new DoubleToken(0.0))).doubleValue();
    double processNoiseForElement=((DoubleToken)((ArrayToken)processNoiseSample).getElement(i)).doubleValue();
    newParticle.add(_meanEstimate + processNoiseForElement);
  }
  this.setValue(newParticle);
  this.assignWeight(_measurementEquation,_stateVariables);
}"
72763,"/** 
 * Hide annotation names. If the attributeName is ""name"" and attributeValue ends with ""annotation"", then <pre> &lt;property name=""_hideName"" class=""ptolemy.data.expr.SingletonParameter"" value=""true""&gt; &lt;/property&gt; </pre> is added if it is not yet present.
 * @param container  The container for this attribute.in this method.
 * @param element The XML element name.
 * @param attributeName The name of the attribute.
 * @param attributeValue The value of the attribute.
 * @param xmlFile The file currently being parsed.
 * @return the value of the attributeValue argument.
 */
public String filterAttributeValue(NamedObj container,String element,String attributeName,String attributeValue,String xmlFile){
  if (attributeValue == null) {
    return null;
  }
  if (attributeName.equals(""String_Node_Str"")) {
    if (attributeValue.endsWith(""String_Node_Str"")) {
      _currentlyProcessingAnnotation=true;
      _currentAnnotationFullName=container.getFullName() + ""String_Node_Str"" + attributeValue;
    }
 else     if (_currentlyProcessingAnnotation && attributeValue.equals(""String_Node_Str"")) {
      _currentlyProcessingAnnotation=false;
      _currentAnnotationFullName=null;
    }
  }
  if (_currentlyProcessingAnnotation && container != null && !container.getFullName().equals(_currentAnnotationFullName) && (_currentAnnotationFullName == null && (!_currentAnnotationFullName.startsWith(container.getFullName()) && !container.getFullName().startsWith(_currentAnnotationFullName)))) {
    _currentlyProcessingAnnotation=false;
    _currentAnnotationFullName=null;
  }
  return attributeValue;
}","/** 
 * Hide annotation names. If the attributeName is ""name"" and attributeValue ends with ""annotation"", then <pre> &lt;property name=""_hideName"" class=""ptolemy.data.expr.SingletonParameter"" value=""true""&gt; &lt;/property&gt; </pre> is added if it is not yet present.
 * @param container  The container for this attribute.in this method.
 * @param element The XML element name.
 * @param attributeName The name of the attribute.
 * @param attributeValue The value of the attribute.
 * @param xmlFile The file currently being parsed.
 * @return the value of the attributeValue argument.
 */
public String filterAttributeValue(NamedObj container,String element,String attributeName,String attributeValue,String xmlFile){
  if (attributeValue == null) {
    return null;
  }
  if (attributeName.equals(""String_Node_Str"")) {
    if (attributeValue.endsWith(""String_Node_Str"")) {
      _currentlyProcessingAnnotation=true;
      _currentAnnotationFullName=container.getFullName() + ""String_Node_Str"" + attributeValue;
    }
 else     if (_currentlyProcessingAnnotation && attributeValue.equals(""String_Node_Str"")) {
      _currentlyProcessingAnnotation=false;
      _currentAnnotationFullName=null;
    }
  }
  if (_currentlyProcessingAnnotation) {
    if (container != null) {
      if (!container.getFullName().equals(_currentAnnotationFullName)) {
        if (_currentAnnotationFullName == null || (!_currentAnnotationFullName.startsWith(container.getFullName()) && !container.getFullName().startsWith(_currentAnnotationFullName))) {
          _currentlyProcessingAnnotation=false;
          _currentAnnotationFullName=null;
        }
      }
    }
  }
  return attributeValue;
}"
72764,"/** 
 * Prepare for the next iteration, by making the current trigger token to be the history trigger token.
 * @return True always.
 * @exception IllegalActionException If thrown by the super class.
 */
public boolean postfire() throws IllegalActionException {
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  _lastTrigger=_thisTrigger;
  _eventMissed=false;
  if (_postponed > 0) {
    if (_debugging) {
      _debug(""String_Node_Str"");
    }
    getDirector().fireAtCurrentTime(this);
  }
  if (_postponedOutputProduced) {
    _postponedOutputProduced=false;
    ContinuousDirector dir=(ContinuousDirector)getDirector();
    int microstep=dir.getIndex();
    if (microstep == _postponed) {
      _postponed=0;
    }
  }
  return super.postfire();
}","/** 
 * Prepare for the next iteration, by making the current trigger token to be the history trigger token.
 * @return True always.
 * @exception IllegalActionException If thrown by the super class.
 */
public boolean postfire() throws IllegalActionException {
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  _lastTrigger=_thisTrigger;
  _eventMissed=false;
  if (_postponed > 0) {
    if (_debugging) {
      _debug(""String_Node_Str"");
    }
    getDirector().fireAtCurrentTime(this);
  }
  if (_postponedOutputProduced) {
    _postponedOutputProduced=false;
    ContinuousDirector dir=(ContinuousDirector)getDirector();
    int microstep=dir.getIndex();
    if (microstep >= _postponed) {
      _postponed=0;
    }
  }
  return super.postfire();
}"
72765,"/** 
 * Detect whether the current input compared to the input on the last iteration indicates that a level crossing in the appropriate direction has occurred, if the time is within <i>errorTolerance</i> of the time at which the crossing occurs. If there is such a level crossing, then postfire will request a refiring at the current time, and the next invocation of fire() will produce the output event.
 * @exception IllegalActionException If it cannot get a token from the triggerport or cannot send a token through the output port.
 */
public void fire() throws IllegalActionException {
  ContinuousDirector dir=(ContinuousDirector)getDirector();
  double currentStepSize=dir.getCurrentStepSize();
  int microstep=dir.getIndex();
  _postponedOutputProduced=false;
  if (_debugging) {
    _debug(""String_Node_Str"" + dir.getModelTime() + ""String_Node_Str""+ microstep+ ""String_Node_Str""+ currentStepSize);
  }
  if (_postponed > 0 && _postponed == microstep) {
    if (_debugging) {
      _debug(""String_Node_Str"");
    }
    output.send(0,value.getToken());
    _postponedOutputProduced=true;
  }
 else {
    if (_debugging) {
      _debug(""String_Node_Str"");
    }
    output.sendClear(0);
  }
  if (trigger.getWidth() > 0 && trigger.isKnown(0) && trigger.hasToken(0)) {
    _thisTrigger=((DoubleToken)trigger.get(0)).doubleValue();
    if (_debugging) {
      _debug(""String_Node_Str"" + _thisTrigger);
      _debug(""String_Node_Str"" + _lastTrigger);
    }
    if (_lastTrigger == Double.NEGATIVE_INFINITY) {
      return;
    }
    boolean inputIsIncreasing=_thisTrigger > _lastTrigger;
    boolean inputIsDecreasing=_thisTrigger < _lastTrigger;
    if ((_lastTrigger - _level) * (_thisTrigger - _level) < 0.0 || _thisTrigger == _level) {
      if (_detectFallingCrossing && inputIsDecreasing || _detectRisingCrossing && inputIsIncreasing) {
        if (currentStepSize != 0.0 && Math.abs(_thisTrigger - _level) >= _errorTolerance) {
          if (_debugging) {
            _debug(""String_Node_Str"");
          }
          _eventMissed=true;
        }
 else {
          _postponed=microstep + 1;
        }
      }
    }
  }
}","/** 
 * Detect whether the current input compared to the input on the last iteration indicates that a level crossing in the appropriate direction has occurred, if the time is within <i>errorTolerance</i> of the time at which the crossing occurs. If there is such a level crossing, then postfire will request a refiring at the current time, and the next invocation of fire() will produce the output event.
 * @exception IllegalActionException If it cannot get a token from the triggerport or cannot send a token through the output port.
 */
public void fire() throws IllegalActionException {
  ContinuousDirector dir=(ContinuousDirector)getDirector();
  double currentStepSize=dir.getCurrentStepSize();
  int microstep=dir.getIndex();
  _postponedOutputProduced=false;
  if (_debugging) {
    _debug(""String_Node_Str"" + dir.getModelTime() + ""String_Node_Str""+ microstep+ ""String_Node_Str""+ currentStepSize);
  }
  if (_postponed > 0 && _postponed <= microstep) {
    if (_debugging) {
      _debug(""String_Node_Str"");
    }
    output.send(0,value.getToken());
    _postponedOutputProduced=true;
  }
 else {
    if (_debugging) {
      _debug(""String_Node_Str"");
    }
    output.sendClear(0);
  }
  if (trigger.getWidth() > 0 && trigger.isKnown(0) && trigger.hasToken(0)) {
    _thisTrigger=((DoubleToken)trigger.get(0)).doubleValue();
    if (_debugging) {
      _debug(""String_Node_Str"" + _thisTrigger);
      _debug(""String_Node_Str"" + _lastTrigger);
    }
    if (_lastTrigger == Double.NEGATIVE_INFINITY) {
      return;
    }
    boolean inputIsIncreasing=_thisTrigger > _lastTrigger;
    boolean inputIsDecreasing=_thisTrigger < _lastTrigger;
    if ((_lastTrigger - _level) * (_thisTrigger - _level) < 0.0 || _thisTrigger == _level) {
      if (_detectFallingCrossing && inputIsDecreasing || _detectRisingCrossing && inputIsIncreasing) {
        if (currentStepSize != 0.0 && Math.abs(_thisTrigger - _level) >= _errorTolerance) {
          if (_debugging) {
            _debug(""String_Node_Str"");
          }
          _eventMissed=true;
        }
 else {
          _postponed=microstep + 1;
        }
      }
    }
  }
}"
72766,"public void actionPerformed(ActionEvent evt){
  try {
    ModelType modelType=(ModelType)modelConverter.modelType.getChosenValue();
    File file=modelConverter.target.asFile();
    exec.updateStatusBar(""String_Node_Str"" + modelConverter + ""String_Node_Str"");
    String inputTemporalFormula=modelConverter.formula.getExpression();
    FormulaType formulaType=(FormulaType)modelConverter.formulaType.getChosenValue();
    int span=((IntToken)modelConverter.span.getToken()).intValue();
    OutputType outputType=(OutputType)modelConverter.outputType.getChosenValue();
    int bufferSize=((IntToken)modelConverter.buffer.getToken()).intValue();
    if (formulaType == FormulaType.Risk || formulaType == FormulaType.Reachability) {
      inputTemporalFormula=modelConverter.generateGraphicalSpec(formulaType);
      formulaType=FormulaType.CTL;
    }
    StringBuffer code=new StringBuffer(""String_Node_Str"");
    try {
      code.append(modelConverter.generateFile(file,modelType,inputTemporalFormula,formulaType,span,outputType,bufferSize));
    }
 catch (    Exception e) {
      MessageHandler.error(""String_Node_Str"" + ""String_Node_Str"",e);
      return;
    }
    File codeFileNameWritten=modelConverter.getCodeFile();
    if (codeFileNameWritten != null) {
      Configuration configuration=getConfiguration();
      URL codeURL=codeFileNameWritten.toURI().toURL();
      if (configuration != null) {
        configuration.openModel(null,codeURL,codeURL.toExternalForm());
      }
    }
    exec.updateStatusBar(code.toString());
    exec.updateStatusBar(""String_Node_Str"" + ""String_Node_Str"");
  }
 catch (  Exception ex) {
    MessageHandler.error(""String_Node_Str"",ex);
  }
}","public void actionPerformed(ActionEvent evt){
  try {
    ModelType modelType=(ModelType)modelConverter.modelType.getChosenValue();
    File file=modelConverter.target.asFile();
    exec.stdout(""String_Node_Str"" + file);
    exec.updateStatusBar(""String_Node_Str"" + modelConverter + ""String_Node_Str"");
    String inputTemporalFormula=modelConverter.formula.getExpression();
    FormulaType formulaType=(FormulaType)modelConverter.formulaType.getChosenValue();
    int span=((IntToken)modelConverter.span.getToken()).intValue();
    OutputType outputType=(OutputType)modelConverter.outputType.getChosenValue();
    int bufferSize=((IntToken)modelConverter.buffer.getToken()).intValue();
    if (formulaType == FormulaType.Risk || formulaType == FormulaType.Reachability) {
      inputTemporalFormula=modelConverter.generateGraphicalSpec(formulaType);
      formulaType=FormulaType.CTL;
    }
    StringBuffer code=new StringBuffer(""String_Node_Str"");
    try {
      code.append(modelConverter.generateFile(file,modelType,inputTemporalFormula,formulaType,span,outputType,bufferSize));
    }
 catch (    Exception e) {
      MessageHandler.error(""String_Node_Str"" + ""String_Node_Str"",e);
      return;
    }
    File codeFileNameWritten=modelConverter.getCodeFile();
    if (codeFileNameWritten != null) {
      Configuration configuration=getConfiguration();
      URL codeURL=codeFileNameWritten.toURI().toURL();
      if (configuration != null) {
        configuration.openModel(null,codeURL,codeURL.toExternalForm());
      }
    }
    exec.updateStatusBar(code.toString());
    exec.updateStatusBar(""String_Node_Str"" + ""String_Node_Str"");
  }
 catch (  Exception ex) {
    MessageHandler.error(""String_Node_Str"",ex);
  }
}"
72767,"/** 
 * Construct a frame to control code generation for the specified Ptolemy II model. After constructing this, it is necessary to call setVisible(true) to make the frame appear. This is typically accomplished by calling show() on enclosing tableau.
 * @param modelConverter The modelConverter to put in this frame,or null if none.
 * @param tableau The tableau responsible for this frame.
 * @exception IllegalActionException If the model rejects theconfiguration attribute.
 * @exception NameDuplicationException If a name collision occurs.
 * @deprecated ptolemy.de.lib.TimedDelay is deprecated, use ptolemy.actor.lib.TimeDelay.
 */
public MathematicalModelConverterGUI(final MathematicalModelConverter modelConverter,Tableau tableau) throws IllegalActionException, NameDuplicationException {
  super(modelConverter,tableau);
  setTitle(modelConverter.getName());
  JPanel caveatsPanel=new JPanel();
  caveatsPanel.setBorder(BorderFactory.createEmptyBorder(5,0,0,0));
  caveatsPanel.setLayout(new BoxLayout(caveatsPanel,BoxLayout.X_AXIS));
  JTextArea messageArea=new JTextArea(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",2,10);
  messageArea.setEditable(false);
  messageArea.setBorder(BorderFactory.createEtchedBorder());
  messageArea.setLineWrap(true);
  messageArea.setWrapStyleWord(true);
  caveatsPanel.add(messageArea);
  JPanel left=new JPanel();
  left.setSize(500,400);
  left.setLayout(new BoxLayout(left,BoxLayout.Y_AXIS));
  caveatsPanel.setMaximumSize(new Dimension(500,100));
  left.add(caveatsPanel);
  JPanel buttonPanel=new JPanel();
  JButton goButton=new JButton(""String_Node_Str"");
  goButton.setToolTipText(""String_Node_Str"");
  buttonPanel.add(goButton,BorderLayout.CENTER);
  JButton clearButton=new JButton(""String_Node_Str"");
  clearButton.setToolTipText(""String_Node_Str"");
  buttonPanel.add(clearButton);
  JButton moreInfoButton=new JButton(""String_Node_Str"");
  moreInfoButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent evt){
      try {
        Configuration configuration=getConfiguration();
        URL infoURL=Thread.currentThread().getContextClassLoader().getResource(""String_Node_Str"");
        if (configuration != null) {
          configuration.openModel(null,infoURL,infoURL.toExternalForm());
        }
      }
 catch (      Exception ex) {
        throw new InternalErrorException(modelConverter,ex,""String_Node_Str"");
      }
    }
  }
);
  buttonPanel.add(moreInfoButton);
  buttonPanel.setMaximumSize(new Dimension(500,50));
  left.add(buttonPanel);
  JPanel queryPanel=new JPanel();
  _query=new PtolemyQuery(modelConverter);
  _query.setInsets(new Insets(2,0,2,0));
  _query.setTextWidth(25);
  queryPanel.add(EditorPaneFactory.createEditorPane(modelConverter,_query));
  JScrollPane scrollPane=new JScrollPane(queryPanel);
  left.add(scrollPane,BorderLayout.CENTER);
  final JTextAreaExec exec=new JTextAreaExec(""String_Node_Str"",false);
  JSplitPane splitPane=new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,left,exec);
  splitPane.setOneTouchExpandable(true);
  Dimension preferred=left.getPreferredSize();
  splitPane.setDividerLocation(preferred.width + 20);
  getContentPane().add(splitPane,BorderLayout.CENTER);
  clearButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent evt){
      exec.clear();
    }
  }
);
  goButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent evt){
      try {
        ModelType modelType=(ModelType)modelConverter.modelType.getChosenValue();
        File file=modelConverter.target.asFile();
        exec.updateStatusBar(""String_Node_Str"" + modelConverter + ""String_Node_Str"");
        String inputTemporalFormula=modelConverter.formula.getExpression();
        FormulaType formulaType=(FormulaType)modelConverter.formulaType.getChosenValue();
        int span=((IntToken)modelConverter.span.getToken()).intValue();
        OutputType outputType=(OutputType)modelConverter.outputType.getChosenValue();
        int bufferSize=((IntToken)modelConverter.buffer.getToken()).intValue();
        if (formulaType == FormulaType.Risk || formulaType == FormulaType.Reachability) {
          inputTemporalFormula=modelConverter.generateGraphicalSpec(formulaType);
          formulaType=FormulaType.CTL;
        }
        StringBuffer code=new StringBuffer(""String_Node_Str"");
        try {
          code.append(modelConverter.generateFile(file,modelType,inputTemporalFormula,formulaType,span,outputType,bufferSize));
        }
 catch (        Exception e) {
          MessageHandler.error(""String_Node_Str"" + ""String_Node_Str"",e);
          return;
        }
        File codeFileNameWritten=modelConverter.getCodeFile();
        if (codeFileNameWritten != null) {
          Configuration configuration=getConfiguration();
          URL codeURL=codeFileNameWritten.toURI().toURL();
          if (configuration != null) {
            configuration.openModel(null,codeURL,codeURL.toExternalForm());
          }
        }
        exec.updateStatusBar(code.toString());
        exec.updateStatusBar(""String_Node_Str"" + ""String_Node_Str"");
      }
 catch (      Exception ex) {
        MessageHandler.error(""String_Node_Str"",ex);
      }
    }
  }
);
}","/** 
 * Construct a frame to control code generation for the specified Ptolemy II model. After constructing this, it is necessary to call setVisible(true) to make the frame appear. This is typically accomplished by calling show() on enclosing tableau.
 * @param modelConverter The modelConverter to put in this frame,or null if none.
 * @param tableau The tableau responsible for this frame.
 * @exception IllegalActionException If the model rejects theconfiguration attribute.
 * @exception NameDuplicationException If a name collision occurs.
 * @deprecated ptolemy.de.lib.TimedDelay is deprecated, use ptolemy.actor.lib.TimeDelay.
 */
public MathematicalModelConverterGUI(final MathematicalModelConverter modelConverter,Tableau tableau) throws IllegalActionException, NameDuplicationException {
  super(modelConverter,tableau);
  setTitle(modelConverter.getName());
  JPanel caveatsPanel=new JPanel();
  caveatsPanel.setBorder(BorderFactory.createEmptyBorder(5,0,0,0));
  caveatsPanel.setLayout(new BoxLayout(caveatsPanel,BoxLayout.X_AXIS));
  JTextArea messageArea=new JTextArea(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",2,10);
  messageArea.setEditable(false);
  messageArea.setBorder(BorderFactory.createEtchedBorder());
  messageArea.setLineWrap(true);
  messageArea.setWrapStyleWord(true);
  caveatsPanel.add(messageArea);
  JPanel upper=new JPanel();
  upper.setLayout(new BoxLayout(upper,BoxLayout.Y_AXIS));
  caveatsPanel.setMaximumSize(new Dimension(500,100));
  upper.add(caveatsPanel);
  JPanel buttonPanel=new JPanel();
  buttonPanel.setLayout(new GridLayout(1,3));
  JButton goButton=new JButton(""String_Node_Str"");
  goButton.setToolTipText(""String_Node_Str"");
  buttonPanel.add(goButton,BorderLayout.CENTER);
  JButton clearButton=new JButton(""String_Node_Str"");
  clearButton.setToolTipText(""String_Node_Str"");
  buttonPanel.add(clearButton);
  JButton moreInfoButton=new JButton(""String_Node_Str"");
  moreInfoButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent evt){
      try {
        Configuration configuration=getConfiguration();
        URL infoURL=Thread.currentThread().getContextClassLoader().getResource(""String_Node_Str"");
        if (configuration != null) {
          configuration.openModel(null,infoURL,infoURL.toExternalForm());
        }
      }
 catch (      Exception ex) {
        throw new InternalErrorException(modelConverter,ex,""String_Node_Str"");
      }
    }
  }
);
  buttonPanel.add(moreInfoButton);
  buttonPanel.setMaximumSize(new Dimension(500,50));
  upper.add(buttonPanel);
  Configurer configurer=new Configurer(modelConverter);
  JPanel controlPanel=new JPanel();
  controlPanel.add(configurer);
  JScrollPane scrollPane=new JScrollPane(controlPanel);
  upper.add(scrollPane,BorderLayout.CENTER);
  final JTextAreaExec exec=new JTextAreaExec(""String_Node_Str"",false);
  exec.setPreferredSize(new Dimension(500,300));
  JSplitPane splitPane=new JSplitPane(JSplitPane.VERTICAL_SPLIT,upper,exec);
  splitPane.setOneTouchExpandable(true);
  Dimension preferred=upper.getPreferredSize();
  splitPane.setDividerLocation(preferred.height + 20);
  getContentPane().add(splitPane,BorderLayout.CENTER);
  clearButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent evt){
      exec.clear();
    }
  }
);
  goButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent evt){
      try {
        ModelType modelType=(ModelType)modelConverter.modelType.getChosenValue();
        File file=modelConverter.target.asFile();
        exec.stdout(""String_Node_Str"" + file);
        exec.updateStatusBar(""String_Node_Str"" + modelConverter + ""String_Node_Str"");
        String inputTemporalFormula=modelConverter.formula.getExpression();
        FormulaType formulaType=(FormulaType)modelConverter.formulaType.getChosenValue();
        int span=((IntToken)modelConverter.span.getToken()).intValue();
        OutputType outputType=(OutputType)modelConverter.outputType.getChosenValue();
        int bufferSize=((IntToken)modelConverter.buffer.getToken()).intValue();
        if (formulaType == FormulaType.Risk || formulaType == FormulaType.Reachability) {
          inputTemporalFormula=modelConverter.generateGraphicalSpec(formulaType);
          formulaType=FormulaType.CTL;
        }
        StringBuffer code=new StringBuffer(""String_Node_Str"");
        try {
          code.append(modelConverter.generateFile(file,modelType,inputTemporalFormula,formulaType,span,outputType,bufferSize));
        }
 catch (        Exception e) {
          MessageHandler.error(""String_Node_Str"" + ""String_Node_Str"",e);
          return;
        }
        File codeFileNameWritten=modelConverter.getCodeFile();
        if (codeFileNameWritten != null) {
          Configuration configuration=getConfiguration();
          URL codeURL=codeFileNameWritten.toURI().toURL();
          if (configuration != null) {
            configuration.openModel(null,codeURL,codeURL.toExternalForm());
          }
        }
        exec.updateStatusBar(code.toString());
        exec.updateStatusBar(""String_Node_Str"" + ""String_Node_Str"");
      }
 catch (      Exception ex) {
        MessageHandler.error(""String_Node_Str"",ex);
      }
    }
  }
);
}"
72768,"/** 
 * Create an editor for configuring the specified object with the specified parent window.
 * @param object The object to configure.
 * @param parent The parent window, or null if there is none.
 */
public void createEditor(NamedObj object,Frame parent){
  MathematicalModelConverter modelConverter=(MathematicalModelConverter)getContainer();
  Effigy effigy=parent == null ? null : ((TableauFrame)parent).getEffigy();
  Tableau tableau;
  try {
    if (effigy == null) {
      tableau=new Tableau(workspace());
      tableau.setName(""String_Node_Str"");
      tableau.setTitle(""String_Node_Str"");
    }
 else {
      tableau=(Tableau)effigy.getEntity(""String_Node_Str"");
      if (tableau == null) {
        tableau=new Tableau(effigy,""String_Node_Str"");
      }
    }
  }
 catch (  KernelException e) {
    throw new InternalErrorException(e);
  }
  Frame frame=tableau.getFrame();
  if (frame == null) {
    try {
      frame=new MathematicalModelConverterGUI(modelConverter,tableau);
    }
 catch (    KernelException e) {
      throw new InternalErrorException(e);
    }
  }
  frame.setSize(800,350);
  frame.setResizable(false);
  frame.setLocationRelativeTo(null);
  frame.setVisible(true);
}","/** 
 * Create an editor for configuring the specified object with the specified parent window.
 * @param object The object to configure.
 * @param parent The parent window, or null if there is none.
 */
public void createEditor(NamedObj object,Frame parent){
  MathematicalModelConverter modelConverter=(MathematicalModelConverter)getContainer();
  Effigy effigy=parent == null ? null : ((TableauFrame)parent).getEffigy();
  Tableau tableau;
  try {
    if (effigy == null) {
      tableau=new Tableau(workspace());
      tableau.setName(""String_Node_Str"");
      tableau.setTitle(""String_Node_Str"");
    }
 else {
      tableau=(Tableau)effigy.getEntity(""String_Node_Str"");
      if (tableau == null) {
        tableau=new Tableau(effigy,""String_Node_Str"");
      }
    }
  }
 catch (  KernelException e) {
    throw new InternalErrorException(e);
  }
  Frame frame=tableau.getFrame();
  if (frame == null) {
    try {
      frame=new MathematicalModelConverterGUI(modelConverter,tableau);
    }
 catch (    KernelException e) {
      throw new InternalErrorException(e);
    }
  }
  frame.pack();
  frame.setVisible(true);
}"
72769,"public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == modelFileName) {
    StringToken modelFileNameToken=(StringToken)modelFileName.getToken();
    File modelFile=new File(modelFileNameToken.stringValue());
    if (!modelFile.exists()) {
      throw new IllegalActionException(""String_Node_Str"" + modelFileNameToken.stringValue() + ""String_Node_Str"");
    }
  }
 else   if (attribute == configFileName) {
    StringToken configFileNameToken=(StringToken)configFileName.getToken();
    File configFile=new File(configFileNameToken.stringValue());
    if (!configFile.exists()) {
      throw new IllegalActionException(""String_Node_Str"" + configFileNameToken.stringValue() + ""String_Node_Str"");
    }
  }
 else {
    super.attributeChanged(attribute);
  }
}","public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == modelFileName) {
    File modelFile=modelFileName.asFile();
    if (modelFile.getName() != ""String_Node_Str"" && !modelFile.exists()) {
      throw new IllegalActionException(""String_Node_Str"" + modelFileName.getExpression() + ""String_Node_Str"");
    }
  }
 else   if (attribute == configFileName) {
    StringToken configFileNameToken=(StringToken)configFileName.getToken();
    File configFile=new File(configFileNameToken.stringValue());
    if (!configFile.exists()) {
      throw new IllegalActionException(""String_Node_Str"" + configFileNameToken.stringValue() + ""String_Node_Str"");
    }
  }
 else {
    super.attributeChanged(attribute);
  }
}"
72770,"/** 
 * Fires the wrapped Metro-SystemC model.
 */
public void getfire(ResultHandler<Iterable<Event.Builder>> resultHandler) throws CollectionAbortedException {
  if (modelFileName != null) {
    if (!createProcess) {
      _ioThread=new Thread(){
        public void run(){
          String s=null;
          try {
            try {
              StringToken modelFileNameToken;
              StringToken configFileNameToken;
              try {
                modelFileNameToken=(StringToken)modelFileName.getToken();
                configFileNameToken=(StringToken)configFileName.getToken();
                System.out.println(modelFileNameToken.stringValue() + ""String_Node_Str"" + configFileNameToken.stringValue());
                process=Runtime.getRuntime().exec(modelFileNameToken.stringValue() + ""String_Node_Str"" + configFileNameToken.stringValue());
              }
 catch (              IllegalActionException e) {
                e.printStackTrace();
              }
              stdInput=new BufferedReader(new InputStreamReader(process.getInputStream()));
              while ((s=stdInput.readLine()) != null) {
                System.out.println(s);
              }
            }
  finally {
              stdInput.close();
            }
          }
 catch (          IOException e) {
            e.printStackTrace();
          }
        }
      }
;
      _ioThread.start();
      createProcess=true;
    }
  }
  while (!isStopRequested()) {
    syncEvents(events);
    do {
      resultHandler.handleResult(events);
    }
 while (!MetroIIEventBuilder.atLeastOneNotified(events) && !isStopRequested());
    pushEvents(events);
  }
}","/** 
 * Fires the wrapped Metro-SystemC model.
 */
public void getfire(ResultHandler<Iterable<Event.Builder>> resultHandler) throws CollectionAbortedException {
  if (modelFileName != null) {
    if (!createProcess) {
      _ioThread=new Thread(){
        public void run(){
          String s=null;
          try {
            String command=null;
            try {
              StringToken modelFileNameToken;
              StringToken configFileNameToken;
              try {
                modelFileNameToken=(StringToken)modelFileName.getToken();
                configFileNameToken=(StringToken)configFileName.getToken();
                File modelFile=new File(modelFileNameToken.stringValue());
                if (!modelFile.exists()) {
                  throw new IllegalActionException(""String_Node_Str"" + modelFileNameToken.stringValue() + ""String_Node_Str"");
                }
                command=modelFileNameToken.stringValue() + ""String_Node_Str"" + configFileNameToken.stringValue();
                System.out.println(""String_Node_Str"" + command);
                process=Runtime.getRuntime().exec(command);
              }
 catch (              IllegalActionException e) {
                e.printStackTrace();
              }
              stdInput=new BufferedReader(new InputStreamReader(process.getInputStream()));
              while ((s=stdInput.readLine()) != null) {
                System.out.println(s);
              }
            }
  finally {
              if (stdInput != null) {
                try {
                  stdInput.close();
                }
 catch (                IOException ex) {
                  System.err.println(""String_Node_Str"" + (command == null ? ""String_Node_Str"" : command) + ""String_Node_Str"");
                }
              }
            }
          }
 catch (          IOException e) {
            e.printStackTrace();
          }
        }
      }
;
      _ioThread.start();
      createProcess=true;
    }
  }
  while (!isStopRequested()) {
    if (events == null) {
      throw new NullPointerException(""String_Node_Str"");
    }
    syncEvents(events);
    do {
      resultHandler.handleResult(events);
    }
 while (!MetroIIEventBuilder.atLeastOneNotified(events) && !isStopRequested());
    pushEvents(events);
  }
}"
72771,"/** 
 * Synchronizes the status of events from the pipe.
 * @param events the events to be synchronized from the pipe.
 */
public void syncEvents(LinkedList<Event.Builder> events){
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  events.clear();
  EventVector ev=null;
  try {
    FileInputStream fis=new FileInputStream(path + pipe2client);
    try {
      ev=EventVector.parseFrom(fis);
    }
  finally {
      fis.close();
    }
  }
 catch (  FileNotFoundException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
  for (  Event e : ev.getEventList()) {
    events.add(e.toBuilder());
  }
  if (_debugging) {
    for (    Builder etb : events) {
      _debug(etb.getName() + ""String_Node_Str"" + etb.getStatus().toString());
    }
  }
}","/** 
 * Synchronizes the status of events from the pipe.
 * @param events the events to be synchronized from the pipe.
 */
public void syncEvents(LinkedList<Event.Builder> events){
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  if (events == null) {
    throw new NullPointerException(""String_Node_Str"");
  }
  events.clear();
  EventVector ev=null;
  try {
    FileInputStream fis=new FileInputStream(path + pipe2client);
    try {
      ev=EventVector.parseFrom(fis);
    }
  finally {
      fis.close();
    }
  }
 catch (  FileNotFoundException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
  for (  Event e : ev.getEventList()) {
    events.add(e.toBuilder());
  }
  if (_debugging) {
    for (    Builder etb : events) {
      _debug(etb.getName() + ""String_Node_Str"" + etb.getStatus().toString());
    }
  }
}"
72772,"public void run(){
  String s=null;
  try {
    try {
      StringToken modelFileNameToken;
      StringToken configFileNameToken;
      try {
        modelFileNameToken=(StringToken)modelFileName.getToken();
        configFileNameToken=(StringToken)configFileName.getToken();
        System.out.println(modelFileNameToken.stringValue() + ""String_Node_Str"" + configFileNameToken.stringValue());
        process=Runtime.getRuntime().exec(modelFileNameToken.stringValue() + ""String_Node_Str"" + configFileNameToken.stringValue());
      }
 catch (      IllegalActionException e) {
        e.printStackTrace();
      }
      stdInput=new BufferedReader(new InputStreamReader(process.getInputStream()));
      while ((s=stdInput.readLine()) != null) {
        System.out.println(s);
      }
    }
  finally {
      stdInput.close();
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","public void run(){
  String s=null;
  try {
    String command=null;
    try {
      StringToken modelFileNameToken;
      StringToken configFileNameToken;
      try {
        modelFileNameToken=(StringToken)modelFileName.getToken();
        configFileNameToken=(StringToken)configFileName.getToken();
        File modelFile=new File(modelFileNameToken.stringValue());
        if (!modelFile.exists()) {
          throw new IllegalActionException(""String_Node_Str"" + modelFileNameToken.stringValue() + ""String_Node_Str"");
        }
        command=modelFileNameToken.stringValue() + ""String_Node_Str"" + configFileNameToken.stringValue();
        System.out.println(""String_Node_Str"" + command);
        process=Runtime.getRuntime().exec(command);
      }
 catch (      IllegalActionException e) {
        e.printStackTrace();
      }
      stdInput=new BufferedReader(new InputStreamReader(process.getInputStream()));
      while ((s=stdInput.readLine()) != null) {
        System.out.println(s);
      }
    }
  finally {
      if (stdInput != null) {
        try {
          stdInput.close();
        }
 catch (        IOException ex) {
          System.err.println(""String_Node_Str"" + (command == null ? ""String_Node_Str"" : command) + ""String_Node_Str"");
        }
      }
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}"
72773,"/** 
 * Initializes the pipe connecting to Metro-SystemC.
 */
@Override public void initialize() throws IllegalActionException {
  super.initialize();
  path=System.getenv(""String_Node_Str"");
  path=path + ""String_Node_Str"";
  if (path == null) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  m2event_out_pipe_name=path + ""String_Node_Str"";
  m2event_in_pipe_name=path + ""String_Node_Str"";
  System.out.println(""String_Node_Str"");
  List execCommands=new LinkedList();
  execCommands.add(""String_Node_Str"" + m2event_out_pipe_name);
  execCommands.add(""String_Node_Str"" + m2event_out_pipe_name);
  execCommands.add(""String_Node_Str"" + m2event_in_pipe_name);
  execCommands.add(""String_Node_Str"" + m2event_in_pipe_name);
  final StringBufferExec exec=new StringBufferExec();
  exec.setCommands(execCommands);
  exec.start();
  File pipe1=new File(m2event_out_pipe_name);
  File pipe2=new File(m2event_in_pipe_name);
  if (!pipe1.exists() || !pipe2.exists()) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  events=new LinkedList<Event.Builder>();
  createProcess=false;
}","/** 
 * Initializes the pipe connecting to Metro-SystemC.
 */
@Override public void initialize() throws IllegalActionException {
  super.initialize();
  path=System.getenv(""String_Node_Str"");
  if (path == null) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  path=path + ""String_Node_Str"";
  m2event_out_pipe_name=path + ""String_Node_Str"";
  m2event_in_pipe_name=path + ""String_Node_Str"";
  System.out.println(""String_Node_Str"");
  List execCommands=new LinkedList();
  execCommands.add(""String_Node_Str"" + m2event_out_pipe_name);
  execCommands.add(""String_Node_Str"" + m2event_out_pipe_name);
  execCommands.add(""String_Node_Str"" + m2event_in_pipe_name);
  execCommands.add(""String_Node_Str"" + m2event_in_pipe_name);
  final StringBufferExec exec=new StringBufferExec();
  exec.setCommands(execCommands);
  exec.start();
  File pipe1=new File(m2event_out_pipe_name);
  if (!pipe1.exists()) {
    throw new IllegalActionException(this,""String_Node_Str"" + m2event_out_pipe_name + ""String_Node_Str"");
  }
  File pipe2=new File(m2event_in_pipe_name);
  if (!pipe1.exists()) {
    throw new IllegalActionException(this,""String_Node_Str"" + m2event_in_pipe_name + ""String_Node_Str"");
  }
  events=new LinkedList<Event.Builder>();
  createProcess=false;
}"
72774,"public void saveModel() throws NameDuplicationException {
  for (int i=0; i < getRowCount() - 1; i++) {
    String expression=""String_Node_Str"";
    State state=(State)_model.getEntity((String)getValueAt(i,0));
    String condition=""String_Node_Str"";
    String value=""String_Node_Str"";
    for (int j=0; j < getColumnCount() - 1; j++) {
      int contentIndex=SCRTableHelper.getContentIndex(i,j,getColumnCount());
      condition=(String)getValueAt(i,j + 1);
      value=(String)getValueAt(getRowCount() - 1,j + 1);
      expression=expression + ""String_Node_Str"" + condition+ ""String_Node_Str""+ value+ ""String_Node_Str"";
    }
    expression=expression + ""String_Node_Str"" + value;
    for (int j=0; j < getColumnCount() - 1; j++) {
      expression=expression + ""String_Node_Str"";
    }
    try {
      if (state.getRefinement() == null) {
        ((RefinementActor)state.getContainer()).addRefinement(state,((CompositeEntity)_model).uniqueName(state.getName() + ""String_Node_Str""),null,Refinement.class.getName(),null);
      }
      CompositeEntity entity=(CompositeEntity)state.getRefinement()[0];
      if (entity.attributeList(Director.class).size() == 0) {
        ContinuousDirector director=new ContinuousDirector(entity,""String_Node_Str"");
      }
      Object expressionActorObject=entity.getEntity(_port.getName() + ""String_Node_Str"");
      TypedIORelation relation=null;
      if (expressionActorObject == null) {
        expressionActorObject=new Expression(entity,_port.getName() + ""String_Node_Str"");
        relation=new TypedIORelation(entity,entity.uniqueName(""String_Node_Str""));
      }
      Expression expressionActor=(Expression)expressionActorObject;
      expressionActor.expression.setExpression(expression);
      if (relation != null) {
        expressionActor.output.link(relation);
        IOPort port=(IOPort)((CompositeActor)entity).getPort(_port.getName());
        port.link(relation);
      }
    }
 catch (    IllegalActionException e1) {
      e1.printStackTrace();
    }
  }
}","public void saveModel() throws NameDuplicationException {
  for (int i=0; i < getRowCount() - 1; i++) {
    StringBuffer expression=new StringBuffer();
    State state=(State)_model.getEntity((String)getValueAt(i,0));
    String condition=""String_Node_Str"";
    String value=""String_Node_Str"";
    for (int j=0; j < getColumnCount() - 1; j++) {
      int contentIndex=SCRTableHelper.getContentIndex(i,j,getColumnCount());
      condition=(String)getValueAt(i,j + 1);
      value=(String)getValueAt(getRowCount() - 1,j + 1);
      expression=expression.append(""String_Node_Str"" + condition + ""String_Node_Str""+ value+ ""String_Node_Str"");
    }
    expression=expression.append(""String_Node_Str"" + value);
    for (int j=0; j < getColumnCount() - 1; j++) {
      expression=expression.append(expression + ""String_Node_Str"");
    }
    try {
      if (state.getRefinement() == null) {
        ((RefinementActor)state.getContainer()).addRefinement(state,((CompositeEntity)_model).uniqueName(state.getName() + ""String_Node_Str""),null,Refinement.class.getName(),null);
      }
      CompositeEntity entity=(CompositeEntity)state.getRefinement()[0];
      if (entity.attributeList(Director.class).size() == 0) {
        ContinuousDirector director=new ContinuousDirector(entity,""String_Node_Str"");
      }
      Object expressionActorObject=entity.getEntity(_port.getName() + ""String_Node_Str"");
      TypedIORelation relation=null;
      if (expressionActorObject == null) {
        expressionActorObject=new Expression(entity,_port.getName() + ""String_Node_Str"");
        relation=new TypedIORelation(entity,entity.uniqueName(""String_Node_Str""));
      }
      Expression expressionActor=(Expression)expressionActorObject;
      expressionActor.expression.setExpression(expression.toString());
      if (relation != null) {
        expressionActor.output.link(relation);
        IOPort port=(IOPort)((CompositeActor)entity).getPort(_port.getName());
        port.link(relation);
      }
    }
 catch (    IllegalActionException e1) {
      e1.printStackTrace();
    }
  }
}"
72775,"/** 
 * (condition1 ? value1 : (condition2 ? value2 : (... : dummyValue)))
 * @param expression
 * @param columnIndex
 * @param contentIndex
 * @param concatenation
 */
private void _parseExpression(String expression,int rowIndex){
  if (expression != ""String_Node_Str"") {
    String condition=""String_Node_Str"";
    String value=""String_Node_Str"";
    for (int i=1; i < getColumnCount(); i++) {
      expression=expression.substring(expression.indexOf(""String_Node_Str"") + 1);
      expression.trim();
      int endOfCondition=expression.indexOf(""String_Node_Str"");
      if (expression.contains(""String_Node_Str"") && (expression.indexOf(""String_Node_Str"") < expression.indexOf(""String_Node_Str""))) {
        endOfCondition=SCRTableHelper.indexOfMatchingCloseBracket(expression,expression.indexOf(""String_Node_Str""));
      }
      condition=expression.substring(0,endOfCondition);
      condition=condition.trim();
      expression=expression.substring(endOfCondition);
      expression=expression.trim();
      expression=expression.substring(expression.indexOf(""String_Node_Str"") + 1);
      expression=expression.trim();
      int endOfValue=expression.indexOf(""String_Node_Str"");
      if (expression.contains(""String_Node_Str"") && (expression.indexOf(""String_Node_Str"") < expression.indexOf(""String_Node_Str""))) {
        endOfValue=SCRTableHelper.indexOfMatchingCloseBracket(expression,expression.indexOf(""String_Node_Str""));
      }
      value=expression.substring(0,endOfValue);
      value=value.trim();
      expression=expression.substring(expression.indexOf(""String_Node_Str"") + 1);
      expression=expression.trim();
      expression=expression.substring(expression.indexOf(""String_Node_Str"") + 1);
      expression=expression.trim();
      int valueIndex=SCRTableHelper.getContentIndex(getRowCount() - 1,i,getColumnCount());
      int contentIndex=SCRTableHelper.getContentIndex(rowIndex,i,getColumnCount());
      _tableContent.add(valueIndex,value);
      _tableContent.remove(valueIndex + 1);
      _tableContent.add(contentIndex,condition);
      _tableContent.remove(contentIndex + 1);
    }
  }
}","/** 
 * (condition1 ? value1 : (condition2 ? value2 : (... : dummyValue)))
 * @param expression
 * @param columnIndex
 * @param contentIndex
 * @param concatenation
 */
private void _parseExpression(String expression,int rowIndex){
  if (!expression.equals(""String_Node_Str"")) {
    String condition=""String_Node_Str"";
    String value=""String_Node_Str"";
    for (int i=1; i < getColumnCount(); i++) {
      expression=expression.substring(expression.indexOf(""String_Node_Str"") + 1).trim();
      int endOfCondition=expression.indexOf(""String_Node_Str"");
      if (expression.contains(""String_Node_Str"") && (expression.indexOf(""String_Node_Str"") < expression.indexOf(""String_Node_Str""))) {
        endOfCondition=SCRTableHelper.indexOfMatchingCloseBracket(expression,expression.indexOf(""String_Node_Str""));
      }
      condition=expression.substring(0,endOfCondition).trim();
      expression=expression.substring(endOfCondition).trim();
      expression=expression.substring(expression.indexOf(""String_Node_Str"") + 1).trim();
      int endOfValue=expression.indexOf(""String_Node_Str"");
      if (expression.contains(""String_Node_Str"") && (expression.indexOf(""String_Node_Str"") < expression.indexOf(""String_Node_Str""))) {
        endOfValue=SCRTableHelper.indexOfMatchingCloseBracket(expression,expression.indexOf(""String_Node_Str""));
      }
      value=expression.substring(0,endOfValue).trim();
      expression=expression.substring(expression.indexOf(""String_Node_Str"") + 1).trim();
      expression=expression.substring(expression.indexOf(""String_Node_Str"") + 1).trim();
      int valueIndex=SCRTableHelper.getContentIndex(getRowCount() - 1,i,getColumnCount());
      int contentIndex=SCRTableHelper.getContentIndex(rowIndex,i,getColumnCount());
      _tableContent.add(valueIndex,value);
      _tableContent.remove(valueIndex + 1);
      _tableContent.add(contentIndex,condition);
      _tableContent.remove(contentIndex + 1);
    }
  }
}"
72776,"private String[] _handleInmodeExpression(String expression,String value,State state){
  String inmodeExpression=""String_Node_Str"";
  if (expression.contains(""String_Node_Str"")) {
    String before=expression.substring(0,expression.indexOf(""String_Node_Str""));
    String after=expression.substring(expression.indexOf(""String_Node_Str"") + 10);
    before=before.trim();
    after=after.trim();
    while (before.endsWith(""String_Node_Str"")) {
      before.substring(0,before.length() - 1).trim();
      if (before.endsWith(""String_Node_Str"")) {
        int index=SCRTableHelper.indexOfMatchingOpenBracket(before,before.length());
        if (!inmodeExpression.equals(""String_Node_Str"")) {
          inmodeExpression=inmodeExpression + ""String_Node_Str"";
        }
        inmodeExpression=inmodeExpression + ""String_Node_Str"" + before.substring(index);
        before=before.substring(0,index - 1).trim();
      }
    }
    while (after.startsWith(""String_Node_Str"")) {
      after=after.substring(1).trim();
      if (after.startsWith(""String_Node_Str"")) {
        int index=SCRTableHelper.indexOfMatchingCloseBracket(after,0);
        if (!inmodeExpression.equals(""String_Node_Str"")) {
          inmodeExpression=inmodeExpression + ""String_Node_Str"";
        }
        inmodeExpression=inmodeExpression + ""String_Node_Str"" + after.substring(0,index);
        after=after.substring(index + 1).trim();
      }
    }
    if (!inmodeExpression.equals(""String_Node_Str"")) {
      inmodeExpression=inmodeExpression + ""String_Node_Str"" + value;
    }
    expression=before + after;
  }
  return new String[]{expression,inmodeExpression};
}","private String[] _handleInmodeExpression(String expression,String value,State state){
  StringBuffer inmodeExpression=new StringBuffer();
  if (expression.contains(""String_Node_Str"")) {
    String before=expression.substring(0,expression.indexOf(""String_Node_Str""));
    String after=expression.substring(expression.indexOf(""String_Node_Str"") + 10);
    before=before.trim();
    after=after.trim();
    while (before.endsWith(""String_Node_Str"")) {
      before=before.substring(0,before.length() - 1).trim();
      if (before.endsWith(""String_Node_Str"")) {
        int index=SCRTableHelper.indexOfMatchingOpenBracket(before,before.length());
        if (!inmodeExpression.equals(""String_Node_Str"")) {
          inmodeExpression=inmodeExpression.append(""String_Node_Str"");
        }
        inmodeExpression=inmodeExpression.append(""String_Node_Str"" + before.substring(index));
        before=before.substring(0,index - 1).trim();
      }
    }
    while (after.startsWith(""String_Node_Str"")) {
      after=after.substring(1).trim();
      if (after.startsWith(""String_Node_Str"")) {
        int index=SCRTableHelper.indexOfMatchingCloseBracket(after,0);
        if (!inmodeExpression.equals(""String_Node_Str"")) {
          inmodeExpression=inmodeExpression.append(""String_Node_Str"");
        }
        inmodeExpression=inmodeExpression.append(""String_Node_Str"" + after.substring(0,index));
        after=after.substring(index + 1).trim();
      }
    }
    if (!inmodeExpression.equals(""String_Node_Str"")) {
      inmodeExpression=inmodeExpression.append(""String_Node_Str"" + value);
    }
    expression=before + after;
  }
  return new String[]{expression,inmodeExpression.toString()};
}"
72777,"public void saveModel() throws IllegalActionException {
  for (int i=0; i < getRowCount() - 1; i++) {
    String selfTransitionExpression=""String_Node_Str"";
    String enterModeExpression=""String_Node_Str"";
    String guard=""String_Node_Str"";
    String value=""String_Node_Str"";
    State state=(State)_model.getEntity((String)getValueAt(i,0));
    for (int j=0; j < getColumnCount() - 1; j++) {
      int contentIndex=_getContentIndex(i,j);
      String condition=(String)getValueAt(i,j + 1);
      value=(String)getValueAt(getRowCount() - 1,j + 1);
      String[] conditions=_handleInmodeExpression(condition,value,state);
      String enterModeCondition=""String_Node_Str"";
      if (condition.contains(""String_Node_Str"")) {
        enterModeCondition=""String_Node_Str"";
      }
 else {
        enterModeCondition=conditions[1];
      }
      condition=conditions[0];
      if (condition.equals(""String_Node_Str"")) {
        condition=""String_Node_Str"";
      }
      if (!guard.equals(""String_Node_Str"")) {
        guard=guard + ""String_Node_Str"";
      }
      guard=guard + condition;
      if (enterModeCondition.equals(""String_Node_Str"")) {
        enterModeCondition=""String_Node_Str"";
      }
      selfTransitionExpression=selfTransitionExpression + ""String_Node_Str"" + condition+ ""String_Node_Str""+ value+ ""String_Node_Str"";
      enterModeExpression=enterModeExpression + ""String_Node_Str"" + enterModeCondition+ ""String_Node_Str""+ value+ ""String_Node_Str"";
    }
    selfTransitionExpression=selfTransitionExpression + ""String_Node_Str"" + value;
    enterModeExpression=enterModeExpression + ""String_Node_Str"" + value;
    for (int j=0; j < getColumnCount() - 1; j++) {
      selfTransitionExpression=selfTransitionExpression + ""String_Node_Str"";
      enterModeExpression=enterModeExpression + ""String_Node_Str"";
    }
    Transition transition=SCRTableHelper.getSelfTransition(state,_parameter);
    if (transition == null) {
      try {
        transition=new Transition(_model,((CompositeEntity)_model).uniqueName(state.getName() + ""String_Node_Str""));
        state.outgoingPort.link(transition);
        state.incomingPort.link(transition);
      }
 catch (      IllegalActionException e) {
        e.printStackTrace();
      }
catch (      NameDuplicationException e) {
        e.printStackTrace();
      }
    }
    transition.setActions.setExpression(_parameter.getName() + ""String_Node_Str"" + selfTransitionExpression);
    transition.guardExpression.setExpression(guard);
    boolean noSetActionSet=true;
    for (    Object relation : state.incomingPort.linkedRelationList()) {
      if (!state.outgoingPort.linkedRelationList().contains(relation)) {
        transition=(Transition)relation;
        String newExpression=_parameter.getName() + ""String_Node_Str"" + enterModeExpression;
        String expression=transition.setActions.getExpression();
        System.out.println(""String_Node_Str"" + expression);
        try {
          if (transition.setActions.getDestinations().contains(_parameter)) {
            int index=expression.indexOf(_parameter.getName() + ""String_Node_Str"");
            String before=expression.substring(0,index);
            int afterIdx=expression.indexOf(""String_Node_Str"",index + 1);
            String after=""String_Node_Str"";
            if (afterIdx > 0) {
              after=expression.substring(afterIdx).trim();
              if (after.startsWith(""String_Node_Str"")) {
                after=after.substring(1).trim();
              }
            }
            expression=before + after;
            expression=expression.trim();
          }
          if (!expression.equals(""String_Node_Str"") && !expression.endsWith(""String_Node_Str"")) {
            expression=expression + ""String_Node_Str"";
          }
          System.out.println(""String_Node_Str"" + expression + newExpression);
          transition.setActions.setExpression(expression + newExpression);
          transition.setActions.setPersistent(true);
          noSetActionSet=false;
        }
 catch (        IllegalActionException e) {
          throw e;
        }
      }
    }
    if (noSetActionSet) {
      throw new IllegalActionException(_model,""String_Node_Str"" + state.getName());
    }
  }
}","public void saveModel() throws IllegalActionException {
  for (int i=0; i < getRowCount() - 1; i++) {
    StringBuffer selfTransitionExpression=new StringBuffer();
    StringBuffer enterModeExpression=new StringBuffer();
    String guard=""String_Node_Str"";
    String value=""String_Node_Str"";
    State state=(State)_model.getEntity((String)getValueAt(i,0));
    for (int j=0; j < getColumnCount() - 1; j++) {
      int contentIndex=_getContentIndex(i,j);
      String condition=(String)getValueAt(i,j + 1);
      value=(String)getValueAt(getRowCount() - 1,j + 1);
      String[] conditions=_handleInmodeExpression(condition,value,state);
      String enterModeCondition=""String_Node_Str"";
      if (condition.contains(""String_Node_Str"")) {
        enterModeCondition=""String_Node_Str"";
      }
 else {
        enterModeCondition=conditions[1];
      }
      condition=conditions[0];
      if (condition.equals(""String_Node_Str"")) {
        condition=""String_Node_Str"";
      }
      if (!guard.equals(""String_Node_Str"")) {
        guard=guard + ""String_Node_Str"";
      }
      guard=guard + condition;
      if (enterModeCondition.equals(""String_Node_Str"")) {
        enterModeCondition=""String_Node_Str"";
      }
      selfTransitionExpression=selfTransitionExpression.append(""String_Node_Str"" + condition + ""String_Node_Str""+ value+ ""String_Node_Str"");
      enterModeExpression=enterModeExpression.append(""String_Node_Str"" + enterModeCondition + ""String_Node_Str""+ value+ ""String_Node_Str"");
    }
    selfTransitionExpression=selfTransitionExpression.append(""String_Node_Str"" + value);
    enterModeExpression=enterModeExpression.append(""String_Node_Str"" + value);
    for (int j=0; j < getColumnCount() - 1; j++) {
      selfTransitionExpression=selfTransitionExpression.append(""String_Node_Str"");
      enterModeExpression=enterModeExpression.append(""String_Node_Str"");
    }
    Transition transition=SCRTableHelper.getSelfTransition(state,_parameter);
    if (transition == null) {
      try {
        transition=new Transition(_model,((CompositeEntity)_model).uniqueName(state.getName() + ""String_Node_Str""));
        state.outgoingPort.link(transition);
        state.incomingPort.link(transition);
      }
 catch (      IllegalActionException e) {
        e.printStackTrace();
      }
catch (      NameDuplicationException e) {
        e.printStackTrace();
      }
    }
    transition.setActions.setExpression(_parameter.getName() + ""String_Node_Str"" + selfTransitionExpression);
    transition.guardExpression.setExpression(guard);
    boolean noSetActionSet=true;
    for (    Object relation : state.incomingPort.linkedRelationList()) {
      if (!state.outgoingPort.linkedRelationList().contains(relation)) {
        transition=(Transition)relation;
        String newExpression=_parameter.getName() + ""String_Node_Str"" + enterModeExpression;
        String expression=transition.setActions.getExpression();
        System.out.println(""String_Node_Str"" + expression);
        try {
          if (transition.setActions.getDestinations().contains(_parameter)) {
            int index=expression.indexOf(_parameter.getName() + ""String_Node_Str"");
            String before=expression.substring(0,index);
            int afterIdx=expression.indexOf(""String_Node_Str"",index + 1);
            String after=""String_Node_Str"";
            if (afterIdx > 0) {
              after=expression.substring(afterIdx).trim();
              if (after.startsWith(""String_Node_Str"")) {
                after=after.substring(1).trim();
              }
            }
            expression=before + after;
            expression=expression.trim();
          }
          if (!expression.equals(""String_Node_Str"") && !expression.endsWith(""String_Node_Str"")) {
            expression=expression + ""String_Node_Str"";
          }
          System.out.println(""String_Node_Str"" + expression + newExpression);
          transition.setActions.setExpression(expression + newExpression);
          transition.setActions.setPersistent(true);
          noSetActionSet=false;
        }
 catch (        IllegalActionException e) {
          throw e;
        }
      }
    }
    if (noSetActionSet) {
      throw new IllegalActionException(_model,""String_Node_Str"" + state.getName());
    }
  }
}"
72778,"private void _initializeTableContent(){
  if (_tableContent == null) {
    _tableContent=new ArrayList();
    for (int i=0; i < (getColumnCount() - 1) * (getRowCount() + 1); i++) {
      _tableContent.add(""String_Node_Str"");
    }
    for (int rowIndex=0; rowIndex < getRowCount() - 1; rowIndex++) {
      State state=(State)_model.getEntity((String)getValueAt(rowIndex,0));
      boolean parsedInmode=false;
      if (state.incomingPort.linkedRelationList().size() > 0) {
        for (        Object object : state.incomingPort.linkedRelationList()) {
          Transition transition=(Transition)object;
          String expression=null;
          try {
            if (transition.setActions.getDestinations().contains(_parameter)) {
              expression=transition.setActions.getExpression(_parameter.getName());
            }
 else {
              expression=""String_Node_Str"";
            }
          }
 catch (          IllegalActionException e) {
            e.printStackTrace();
          }
          if (!expression.equals(""String_Node_Str"")) {
            if (state.outgoingPort.linkedRelationList().contains(transition)) {
              _parseExpression(expression,rowIndex,false);
            }
 else             if (!parsedInmode) {
              _parseExpression(expression,rowIndex,true);
              parsedInmode=true;
            }
          }
        }
      }
    }
  }
}","private void _initializeTableContent(){
  if (_tableContent == null) {
    _tableContent=new ArrayList();
    for (int i=0; i < (getColumnCount() - 1) * (getRowCount() + 1); i++) {
      _tableContent.add(""String_Node_Str"");
    }
    for (int rowIndex=0; rowIndex < getRowCount() - 1; rowIndex++) {
      State state=(State)_model.getEntity((String)getValueAt(rowIndex,0));
      boolean parsedInmode=false;
      if (state.incomingPort.linkedRelationList().size() > 0) {
        for (        Object object : state.incomingPort.linkedRelationList()) {
          Transition transition=(Transition)object;
          String expression=null;
          try {
            if (transition.setActions.getDestinations().contains(_parameter)) {
              expression=transition.setActions.getExpression(_parameter.getName());
            }
 else {
              expression=""String_Node_Str"";
            }
          }
 catch (          IllegalActionException e) {
            expression=""String_Node_Str"";
          }
          if (!expression.equals(""String_Node_Str"")) {
            if (state.outgoingPort.linkedRelationList().contains(transition)) {
              _parseExpression(expression,rowIndex,false);
            }
 else             if (!parsedInmode) {
              _parseExpression(expression,rowIndex,true);
              parsedInmode=true;
            }
          }
        }
      }
    }
  }
}"
72779,"/** 
 * (condition1 ? value1 : (condition2 ? value2 : (... : dummyValue)))
 * @param expression
 * @param columnIndex
 * @param contentIndex
 * @param concatenation
 */
private void _parseExpression(String expression,int rowIndex,boolean inmode){
  if (expression != ""String_Node_Str"") {
    String condition=""String_Node_Str"";
    String value=""String_Node_Str"";
    for (int i=1; i < getColumnCount(); i++) {
      expression=expression.substring(expression.indexOf(""String_Node_Str"") + 1);
      expression.trim();
      int endOfCondition=expression.indexOf(""String_Node_Str"");
      if (expression.contains(""String_Node_Str"") && (expression.indexOf(""String_Node_Str"") < expression.indexOf(""String_Node_Str""))) {
        endOfCondition=SCRTableHelper.indexOfMatchingCloseBracket(expression,expression.indexOf(""String_Node_Str""));
      }
      condition=expression.substring(0,endOfCondition).trim();
      expression=expression.substring(endOfCondition).trim();
      expression=expression.substring(expression.indexOf(""String_Node_Str"") + 1).trim();
      int endOfValue=expression.indexOf(""String_Node_Str"");
      if (expression.contains(""String_Node_Str"") && (expression.indexOf(""String_Node_Str"") < expression.indexOf(""String_Node_Str""))) {
        endOfValue=SCRTableHelper.indexOfMatchingCloseBracket(expression,expression.indexOf(""String_Node_Str""));
      }
      value=expression.substring(0,endOfValue).trim();
      expression=expression.substring(expression.indexOf(""String_Node_Str"") + 1).trim();
      expression=expression.substring(expression.indexOf(""String_Node_Str"") + 1).trim();
      int valueIndex=_getContentIndex(getRowCount() - 1,i);
      int contentIndex=_getContentIndex(rowIndex,i);
      if (inmode && condition.equals(""String_Node_Str"")) {
        condition=""String_Node_Str"";
      }
      String content=(String)_tableContent.get(contentIndex);
      if (!content.equals(""String_Node_Str"")) {
        if (content.equals(""String_Node_Str"")) {
          content=condition;
        }
 else         if (condition.equals(""String_Node_Str"")) {
        }
 else {
          content=content + ""String_Node_Str"" + condition;
        }
      }
 else {
        content=condition;
      }
      _tableContent.add(valueIndex,value);
      _tableContent.remove(valueIndex + 1);
      _tableContent.add(contentIndex,content);
      _tableContent.remove(contentIndex + 1);
    }
  }
}","/** 
 * (condition1 ? value1 : (condition2 ? value2 : (... : dummyValue)))
 * @param expression
 * @param columnIndex
 * @param contentIndex
 * @param concatenation
 */
private void _parseExpression(String expression,int rowIndex,boolean inmode){
  if (expression != ""String_Node_Str"") {
    String condition=""String_Node_Str"";
    String value=""String_Node_Str"";
    for (int i=1; i < getColumnCount(); i++) {
      expression=expression.substring(expression.indexOf(""String_Node_Str"") + 1).trim();
      int endOfCondition=expression.indexOf(""String_Node_Str"");
      if (expression.contains(""String_Node_Str"") && (expression.indexOf(""String_Node_Str"") < expression.indexOf(""String_Node_Str""))) {
        endOfCondition=SCRTableHelper.indexOfMatchingCloseBracket(expression,expression.indexOf(""String_Node_Str""));
      }
      condition=expression.substring(0,endOfCondition).trim();
      expression=expression.substring(endOfCondition).trim();
      expression=expression.substring(expression.indexOf(""String_Node_Str"") + 1).trim();
      int endOfValue=expression.indexOf(""String_Node_Str"");
      if (expression.contains(""String_Node_Str"") && (expression.indexOf(""String_Node_Str"") < expression.indexOf(""String_Node_Str""))) {
        endOfValue=SCRTableHelper.indexOfMatchingCloseBracket(expression,expression.indexOf(""String_Node_Str""));
      }
      value=expression.substring(0,endOfValue).trim();
      expression=expression.substring(expression.indexOf(""String_Node_Str"") + 1).trim();
      expression=expression.substring(expression.indexOf(""String_Node_Str"") + 1).trim();
      int valueIndex=_getContentIndex(getRowCount() - 1,i);
      int contentIndex=_getContentIndex(rowIndex,i);
      if (inmode && condition.equals(""String_Node_Str"")) {
        condition=""String_Node_Str"";
      }
      String content=(String)_tableContent.get(contentIndex);
      if (!content.equals(""String_Node_Str"")) {
        if (content.equals(""String_Node_Str"")) {
          content=condition;
        }
 else         if (condition.equals(""String_Node_Str"")) {
        }
 else {
          content=content + ""String_Node_Str"" + condition;
        }
      }
 else {
        content=condition;
      }
      _tableContent.add(valueIndex,value);
      _tableContent.remove(valueIndex + 1);
      _tableContent.add(contentIndex,content);
      _tableContent.remove(contentIndex + 1);
    }
  }
}"
72780,"private JComponent _getEventTablePanel(){
  final JTabbedPane eventTablesPanel=new JTabbedPane();
  Parameter parameter=null;
  for (  Object entity : _model.attributeList()) {
    if (entity instanceof Parameter) {
      parameter=(Parameter)entity;
      if (parameter.getName().startsWith(""String_Node_Str"")) {
        _addParameterTable(parameter,eventTablesPanel);
      }
    }
  }
  final JPanel tabPanel=new JPanel(new BorderLayout());
  JButton addParameter=new JButton(""String_Node_Str"");
  addParameter.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      final JDialog inputbox=new JDialog(SCRTableFrame.this,""String_Node_Str"");
      inputbox.getContentPane().setLayout(new FlowLayout());
      JLabel lblname=new JLabel(""String_Node_Str"");
      final JTextField parameterNameTxt=new JTextField(""String_Node_Str"");
      parameterNameTxt.setColumns(10);
      JLabel lblvalue=new JLabel(""String_Node_Str"");
      final JTextField parameterValueTxt=new JTextField(""String_Node_Str"");
      parameterValueTxt.setColumns(10);
      JButton ok=new JButton(""String_Node_Str"");
      inputbox.getContentPane().add(lblname);
      inputbox.getContentPane().add(parameterNameTxt);
      inputbox.getContentPane().add(lblvalue);
      inputbox.getContentPane().add(parameterValueTxt);
      Parameter parameter=null;
      try {
        parameter=new Parameter(_model,parameterNameTxt.getText());
      }
 catch (      IllegalActionException e1) {
        MessageHandler.error(e1.getMessage(),e1);
      }
catch (      NameDuplicationException e1) {
        MessageHandler.error(e1.getMessage(),e1);
      }
      final Parameter param=parameter;
      ok.addActionListener(new ActionListener(){
        public void actionPerformed(        ActionEvent e){
          inputbox.setVisible(false);
          try {
            param.setName(parameterNameTxt.getText());
            param.setToken(parameterValueTxt.getText());
            _addParameterTable(param,eventTablesPanel);
          }
 catch (          IllegalActionException e1) {
            MessageHandler.error(e1.getMessage(),e1);
          }
catch (          NameDuplicationException e1) {
            MessageHandler.error(e1.getMessage(),e1);
          }
        }
      }
);
      inputbox.getContentPane().add(ok);
      final Toolkit toolkit=Toolkit.getDefaultToolkit();
      final Dimension screenSize=toolkit.getScreenSize();
      final int x=(screenSize.width - inputbox.getWidth()) / 2;
      final int y=(screenSize.height - inputbox.getHeight()) / 2;
      inputbox.setLocation(x,y);
      inputbox.setSize(250,150);
      inputbox.setVisible(true);
      JDialog dialog=new JDialog();
    }
  }
);
  JPanel buttons=new JPanel();
  buttons.add(addParameter);
  JPanel eventTablePanel=new JPanel(new BorderLayout());
  eventTablePanel.add(eventTablesPanel,BorderLayout.CENTER);
  eventTablePanel.add(buttons,BorderLayout.SOUTH);
  return eventTablePanel;
}","private JComponent _getEventTablePanel(){
  final JTabbedPane eventTablesPanel=new JTabbedPane();
  Parameter parameter=null;
  for (  Object entity : _model.attributeList()) {
    if (entity instanceof Parameter) {
      parameter=(Parameter)entity;
      if (parameter.getName().startsWith(""String_Node_Str"")) {
        _addParameterTable(parameter,eventTablesPanel);
      }
    }
  }
  JButton addParameter=new JButton(""String_Node_Str"");
  addParameter.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      final JDialog inputbox=new JDialog(SCRTableFrame.this,""String_Node_Str"");
      inputbox.getContentPane().setLayout(new FlowLayout());
      JLabel lblname=new JLabel(""String_Node_Str"");
      final JTextField parameterNameTxt=new JTextField(""String_Node_Str"");
      parameterNameTxt.setColumns(10);
      JLabel lblvalue=new JLabel(""String_Node_Str"");
      final JTextField parameterValueTxt=new JTextField(""String_Node_Str"");
      parameterValueTxt.setColumns(10);
      JButton ok=new JButton(""String_Node_Str"");
      inputbox.getContentPane().add(lblname);
      inputbox.getContentPane().add(parameterNameTxt);
      inputbox.getContentPane().add(lblvalue);
      inputbox.getContentPane().add(parameterValueTxt);
      Parameter parameter=null;
      try {
        parameter=new Parameter(_model,parameterNameTxt.getText());
      }
 catch (      IllegalActionException e1) {
        MessageHandler.error(e1.getMessage(),e1);
      }
catch (      NameDuplicationException e1) {
        MessageHandler.error(e1.getMessage(),e1);
      }
      final Parameter param=parameter;
      ok.addActionListener(new ActionListener(){
        public void actionPerformed(        ActionEvent e){
          inputbox.setVisible(false);
          try {
            param.setName(parameterNameTxt.getText());
            param.setToken(parameterValueTxt.getText());
            _addParameterTable(param,eventTablesPanel);
          }
 catch (          IllegalActionException e1) {
            MessageHandler.error(e1.getMessage(),e1);
          }
catch (          NameDuplicationException e1) {
            MessageHandler.error(e1.getMessage(),e1);
          }
        }
      }
);
      inputbox.getContentPane().add(ok);
      final Toolkit toolkit=Toolkit.getDefaultToolkit();
      final Dimension screenSize=toolkit.getScreenSize();
      final int x=(screenSize.width - inputbox.getWidth()) / 2;
      final int y=(screenSize.height - inputbox.getHeight()) / 2;
      inputbox.setLocation(x,y);
      inputbox.setSize(250,150);
      inputbox.setVisible(true);
    }
  }
);
  JPanel buttons=new JPanel();
  buttons.add(addParameter);
  JPanel eventTablePanel=new JPanel(new BorderLayout());
  eventTablePanel.add(eventTablesPanel,BorderLayout.CENTER);
  eventTablePanel.add(buttons,BorderLayout.SOUTH);
  return eventTablePanel;
}"
72781,"private JComponent _getModeTransitionPanel(){
  JPanel modeTransitionTablePanel=new JPanel(new BorderLayout());
  final ModeTransitionTableModel tableModel=new ModeTransitionTableModel(_model);
  final JTable table=new JTable(tableModel);
  table.setGridColor(Color.black);
  JButton addModeButton=new JButton(""String_Node_Str"");
  addModeButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      Vector vector=new Vector<String>();
      vector.add(""String_Node_Str"");
      vector.add(""String_Node_Str"");
      vector.add(""String_Node_Str"");
      tableModel.addRow(vector);
    }
  }
);
  JButton saveButton=new JButton(""String_Node_Str"");
  saveButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      try {
        tableModel.saveModel();
      }
 catch (      IllegalActionException e1) {
        MessageHandler.error(e1.getMessage(),e1);
      }
catch (      NameDuplicationException e1) {
        MessageHandler.error(e1.getMessage(),e1);
      }
    }
  }
);
  modeTransitionTablePanel.add(table.getTableHeader(),BorderLayout.PAGE_START);
  modeTransitionTablePanel.add(table,BorderLayout.CENTER);
  JPanel buttons=new JPanel();
  buttons.add(addModeButton);
  buttons.add(saveButton);
  modeTransitionTablePanel.add(buttons,BorderLayout.SOUTH);
  return modeTransitionTablePanel;
}","private JComponent _getModeTransitionPanel(){
  JPanel modeTransitionTablePanel=new JPanel(new BorderLayout());
  final ModeTransitionTableModel tableModel=new ModeTransitionTableModel(_model);
  final JTable table=new JTable(tableModel);
  table.setGridColor(Color.black);
  JButton addModeButton=new JButton(""String_Node_Str"");
  addModeButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      Vector<String> vector=new Vector<String>();
      vector.add(""String_Node_Str"");
      vector.add(""String_Node_Str"");
      vector.add(""String_Node_Str"");
      tableModel.addRow(vector);
    }
  }
);
  JButton saveButton=new JButton(""String_Node_Str"");
  saveButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      try {
        tableModel.saveModel();
      }
 catch (      IllegalActionException e1) {
        MessageHandler.error(e1.getMessage(),e1);
      }
catch (      NameDuplicationException e1) {
        MessageHandler.error(e1.getMessage(),e1);
      }
    }
  }
);
  modeTransitionTablePanel.add(table.getTableHeader(),BorderLayout.PAGE_START);
  modeTransitionTablePanel.add(table,BorderLayout.CENTER);
  JPanel buttons=new JPanel();
  buttons.add(addModeButton);
  buttons.add(saveButton);
  modeTransitionTablePanel.add(buttons,BorderLayout.SOUTH);
  return modeTransitionTablePanel;
}"
72782,"/** 
 * Construct a frame associated with an SCR Model. 
 * @param model The model to put in this frame, or null if none.
 * @param tableau The tableau responsible for this frame, or null if none.
 */
public SCRTableFrame(NamedObj model,Tableau tableau){
  super(tableau);
  _model=(FSMActor)model;
  _init();
}","/** 
 * Construct a frame associated with an SCR Model. 
 * @param model The model to put in this frame, or null if none.
 * @param tableau The tableau responsible for this frame, or null if none.
 */
public SCRTableFrame(NamedObj model,Tableau tableau){
  super(tableau);
  if (model instanceof FSMActor) {
    _model=(FSMActor)model;
  }
 else {
    MessageHandler.error(""String_Node_Str"" + model.getClassName());
  }
  _init();
}"
72783,"/** 
 * Create a tableau for the specified effigy, which is assumed to be an effigy for an instance of ModalModel.  This class defers to the configuration containing the specified effigy to open a tableau for the embedded controller.
 * @param effigy The model effigy.
 * @return A tableau for the effigy, or null if one cannot be created.
 * @exception Exception If the factory should be able to create aTableau for the effigy, but something goes wrong.
 */
public Tableau createTableau(Effigy effigy) throws Exception {
  Configuration configuration=(Configuration)effigy.toplevel();
  SCRModel model=(SCRModel)((PtolemyEffigy)effigy).getModel();
  FSMActor controller=((FSMDirector)model.getDirector()).getController();
  Tableau tableau=configuration.openModel(controller);
  tableau.setContainer(effigy);
  return tableau;
}","/** 
 * Create a tableau for the specified effigy, which is assumed to be an effigy for an instance of ModalModel.  This class defers to the configuration containing the specified effigy to open a tableau for the embedded controller.
 * @param effigy The model effigy.
 * @return A tableau for the effigy, or null if one cannot be created.
 * @exception Exception If the factory should be able to create aTableau for the effigy, but something goes wrong.
 */
public Tableau createTableau(Effigy effigy) throws Exception {
  Configuration configuration=(Configuration)effigy.toplevel();
  SCRModel model=null;
  if (effigy instanceof PtolemyEffigy) {
    PtolemyEffigy ptolemyEffigy=(PtolemyEffigy)effigy;
    if (ptolemyEffigy.getModel() instanceof SCRModel) {
      model=(SCRModel)ptolemyEffigy.getModel();
    }
 else {
      throw new IllegalActionException(""String_Node_Str"");
    }
  }
  FSMActor controller=((FSMDirector)model.getDirector()).getController();
  Tableau tableau=configuration.openModel(controller);
  tableau.setContainer(effigy);
  return tableau;
}"
72784,"private void _init(){
  JTabbedPane pane=new JTabbedPane();
  pane.addTab(""String_Node_Str"",_getModeTransitionPanel());
  pane.addTab(""String_Node_Str"",_getEventTablePanel());
  pane.addTab(""String_Node_Str"",_getConditionTablePanel());
  getContentPane().add(pane,BorderLayout.CENTER);
  this.setMinimumSize(new Dimension(700,400));
  super.show();
}","private void _init(){
  JTabbedPane pane=new JTabbedPane();
  pane.addTab(""String_Node_Str"",_getModeTransitionPanel());
  pane.addTab(""String_Node_Str"",_getEventTablePanel());
  pane.addTab(""String_Node_Str"",_getConditionTablePanel());
  getContentPane().add(pane,BorderLayout.CENTER);
  this.setSize(new Dimension(700,400));
  super.show();
}"
72785,"private JComponent _getModeTransitionPanel(){
  JPanel modeTransitionTablePanel=new JPanel(new BorderLayout());
  final ModeTransitionTableModel tableModel=new ModeTransitionTableModel(_model);
  final JTable table=new JTable(tableModel);
  table.setGridColor(Color.black);
  JButton addModeButton=new JButton(""String_Node_Str"");
  addModeButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      Vector<String> vector=new Vector<String>();
      vector.add(""String_Node_Str"");
      vector.add(""String_Node_Str"");
      vector.add(""String_Node_Str"");
      tableModel.addRow(vector);
    }
  }
);
  JButton saveButton=new JButton(""String_Node_Str"");
  saveButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      try {
        tableModel.saveModel();
      }
 catch (      IllegalActionException e1) {
        MessageHandler.error(e1.getMessage(),e1);
      }
catch (      NameDuplicationException e1) {
        MessageHandler.error(e1.getMessage(),e1);
      }
    }
  }
);
  modeTransitionTablePanel.add(table.getTableHeader(),BorderLayout.PAGE_START);
  modeTransitionTablePanel.add(table,BorderLayout.CENTER);
  JPanel buttons=new JPanel();
  buttons.add(addModeButton);
  buttons.add(saveButton);
  modeTransitionTablePanel.add(buttons,BorderLayout.SOUTH);
  return modeTransitionTablePanel;
}","private JComponent _getModeTransitionPanel(){
  JPanel modeTransitionTablePanel=new JPanel(new BorderLayout());
  final ModeTransitionTableModel tableModel=new ModeTransitionTableModel(_model);
  final JTable table=new JTable(tableModel);
  table.setGridColor(Color.black);
  JButton addRowButton=new JButton(""String_Node_Str"");
  addRowButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      Vector<String> vector=new Vector<String>();
      vector.add(""String_Node_Str"");
      vector.add(""String_Node_Str"");
      vector.add(""String_Node_Str"");
      tableModel.addRow(vector);
    }
  }
);
  JButton saveButton=new JButton(""String_Node_Str"");
  saveButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      try {
        tableModel.saveModel();
      }
 catch (      IllegalActionException e1) {
        MessageHandler.error(e1.getMessage(),e1);
      }
catch (      NameDuplicationException e1) {
        MessageHandler.error(e1.getMessage(),e1);
      }
    }
  }
);
  final JComboBox box=new JComboBox();
  box.setPrototypeDisplayValue(""String_Node_Str"");
  box.setModel(new ComboBoxModel(){
    List<String> _states;
    State _initialState;
    @Override public void addListDataListener(    ListDataListener arg0){
    }
    @Override public Object getElementAt(    int arg0){
      if (_states == null) {
        _initializeStates();
      }
      if (arg0 >= 0 && _states.size() > arg0) {
        System.out.println(arg0);
        return _states.get(arg0);
      }
 else {
        return ""String_Node_Str"";
      }
    }
    private void _initializeStates(){
      _states=new ArrayList<String>();
      for (      Object o : _model.entityList()) {
        if (o instanceof State) {
          State state=(State)o;
          _states.add(state.getName());
          try {
            if (((BooleanToken)state.isInitialState.getToken()).booleanValue()) {
              _initialState=state;
            }
          }
 catch (          IllegalActionException e) {
            MessageHandler.error(""String_Node_Str"",e);
          }
        }
      }
    }
    @Override public int getSize(){
      if (_states == null) {
        _initializeStates();
      }
      return _states.size();
    }
    @Override public void removeListDataListener(    ListDataListener arg0){
    }
    @Override public Object getSelectedItem(){
      if (_states == null) {
        _initializeStates();
      }
      if (_initialState != null) {
        return _initialState.getName();
      }
 else {
        return null;
      }
    }
    @Override public void setSelectedItem(    Object arg0){
      if (_states == null) {
        _initializeStates();
      }
      String stateName=(String)arg0;
      State state=(State)_model.getEntity(stateName);
      try {
        _initialState=state;
        state.isInitialState.setToken(""String_Node_Str"");
      }
 catch (      IllegalActionException e1) {
        MessageHandler.error(""String_Node_Str"",e1);
      }
    }
  }
);
  box.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (box.getSelectedItem() instanceof State) {
        State state=(State)box.getSelectedItem();
        try {
          state.isInitialState.setToken(""String_Node_Str"");
        }
 catch (        IllegalActionException e1) {
          MessageHandler.error(""String_Node_Str"",e1);
        }
      }
    }
  }
);
  modeTransitionTablePanel.add(table.getTableHeader(),BorderLayout.PAGE_START);
  modeTransitionTablePanel.add(table,BorderLayout.CENTER);
  JPanel buttons=new JPanel();
  buttons.add(addRowButton);
  buttons.add(new JLabel(""String_Node_Str""));
  buttons.add(box);
  buttons.add(saveButton);
  modeTransitionTablePanel.add(buttons,BorderLayout.SOUTH);
  return modeTransitionTablePanel;
}"
72786,"/** 
 * Generate the .moml file for this nesC component.
 * @param sourcePath The path to the component source file (.nc).
 * @param componentName The name of the component (no suffix).
 * @param outputFile The file to generate.
 */
public static void generateComponent(String sourcePath,String componentName,String outputFile){
  Element root=new Element(""String_Node_Str"");
  root.setAttribute(""String_Node_Str"",componentName);
  root.setAttribute(""String_Node_Str"",""String_Node_Str"");
  Element source=new Element(""String_Node_Str"");
  source.setAttribute(""String_Node_Str"",""String_Node_Str"");
  source.setAttribute(""String_Node_Str"",sourcePath);
  root.addContent(source);
  DocType plot=new DocType(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  Document doc=new Document(root,plot);
  ListIterator interfaces=Xnesc.interfaceList.listIterator();
  while (interfaces.hasNext()) {
    Xinterface intf=(Xinterface)interfaces.next();
    Element port=new Element(""String_Node_Str"");
    port.setAttribute(""String_Node_Str"",intf.name);
    port.setAttribute(""String_Node_Str"",""String_Node_Str"");
    Element portType=new Element(""String_Node_Str"");
    String portTypeValue=(intf.provided) ? ""String_Node_Str"" : ""String_Node_Str"";
    portType.setAttribute(""String_Node_Str"",portTypeValue);
    port.addContent(portType);
    if (intf.parameters != null) {
      Element multiport=new Element(""String_Node_Str"");
      multiport.setAttribute(""String_Node_Str"",""String_Node_Str"");
      port.addContent(multiport);
    }
    Element showName=new Element(""String_Node_Str"");
    showName.setAttribute(""String_Node_Str"",""String_Node_Str"");
    showName.setAttribute(""String_Node_Str"",""String_Node_Str"");
    port.addContent(showName);
    root.addContent(port);
  }
  try {
    FileOutputStream out=null;
    if (outputFile != null) {
      out=new FileOutputStream(outputFile);
    }
    XMLOutputter serializer=new XMLOutputter(Format.getPrettyFormat());
    Format format=serializer.getFormat();
    format.setOmitEncoding(true);
    format.setLineSeparator(""String_Node_Str"");
    serializer.setFormat(format);
    if (out != null) {
      serializer.output(doc,out);
      out.flush();
      out.close();
    }
 else {
      serializer.output(doc,System.out);
    }
  }
 catch (  IOException e) {
    System.err.println(e);
  }
}","/** 
 * Generate the .moml file for this nesC component.
 * @param sourcePath The path to the component source file (.nc).
 * @param componentName The name of the component (no suffix).
 * @param outputFile The file to generate.
 */
public static void generateComponent(String sourcePath,String componentName,String outputFile){
  Element root=new Element(""String_Node_Str"");
  root.setAttribute(""String_Node_Str"",componentName);
  root.setAttribute(""String_Node_Str"",""String_Node_Str"");
  Element source=new Element(""String_Node_Str"");
  source.setAttribute(""String_Node_Str"",""String_Node_Str"");
  source.setAttribute(""String_Node_Str"",sourcePath);
  root.addContent(source);
  DocType plot=new DocType(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  Document doc=new Document(root,plot);
  ListIterator interfaces=Xnesc.interfaceList.listIterator();
  while (interfaces.hasNext()) {
    Xinterface intf=(Xinterface)interfaces.next();
    Element port=new Element(""String_Node_Str"");
    port.setAttribute(""String_Node_Str"",intf.name);
    port.setAttribute(""String_Node_Str"",""String_Node_Str"");
    Element portType=new Element(""String_Node_Str"");
    String portTypeValue=(intf.provided) ? ""String_Node_Str"" : ""String_Node_Str"";
    portType.setAttribute(""String_Node_Str"",portTypeValue);
    port.addContent(portType);
    if (intf.parameters != null) {
      Element multiport=new Element(""String_Node_Str"");
      multiport.setAttribute(""String_Node_Str"",""String_Node_Str"");
      port.addContent(multiport);
    }
    Element showName=new Element(""String_Node_Str"");
    showName.setAttribute(""String_Node_Str"",""String_Node_Str"");
    showName.setAttribute(""String_Node_Str"",""String_Node_Str"");
    port.addContent(showName);
    root.addContent(port);
  }
  FileOutputStream out=null;
  try {
    if (outputFile != null) {
      out=new FileOutputStream(outputFile);
    }
    XMLOutputter serializer=new XMLOutputter(Format.getPrettyFormat());
    Format format=serializer.getFormat();
    format.setOmitEncoding(true);
    format.setLineSeparator(""String_Node_Str"");
    serializer.setFormat(format);
    if (out != null) {
      serializer.output(doc,out);
    }
 else {
      serializer.output(doc,System.out);
    }
  }
 catch (  IOException ex) {
    ex.printStackTrace();
  }
 finally {
    if (out != null) {
      try {
        out.flush();
        out.close();
      }
 catch (      IOException ex) {
        ex.printStackTrace();
      }
    }
  }
}"
72787,"/** 
 * Generate the .moml file for this nesC application.
 * @param componentName The name of the component (no suffix).
 * @param outputFile The file to generate.
 * @param directorOutputDir The output directory to pass to thePtinyOSDirector.
 * @param opts The compiler options (PFLAGS) to pass to thePtinyOSDirector.
 * @param micaboardFile Path to the MoML file that contains theWireless wrapper.  Null if wrapper should not be generated.
 * @exception IllegalActionException If there is a problem creatingan interface IOport or connection.
 * @exception NameDuplicationException If there is a problem creatingan interface IOport or connection.
 */
public void generatePtinyOSModel(String componentName,String outputFile,String directorOutputDir,String opts,String micaboardFile) throws IllegalActionException, NameDuplicationException {
  Element root=null;
  Element director=null;
  DocType plot=new DocType(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  Document doc=null;
  if (micaboardFile != null) {
    Element micaboard=null;
    try {
      SAXBuilder saxbuilder=new SAXBuilder();
      Document docWireless=saxbuilder.build(new File(micaboardFile));
      Filter filter=new ContentFilter(ContentFilter.ELEMENT);
      Iterator iteratorDocWireless=docWireless.getDescendants(filter);
      while (iteratorDocWireless.hasNext()) {
        Element e=(Element)iteratorDocWireless.next();
        String classname=e.getAttributeValue(""String_Node_Str"");
        if (classname != null) {
          if (classname.equals(""String_Node_Str"")) {
            micaboard=(Element)e.clone();
            break;
          }
        }
      }
      if (micaboard == null) {
        throw new Exception(""String_Node_Str"" + micaboardFile);
      }
      Iterator iteratorMicaBoard=micaboard.getDescendants(filter);
      while (iteratorMicaBoard.hasNext()) {
        Element e=(Element)iteratorMicaBoard.next();
        String classname=e.getAttributeValue(""String_Node_Str"");
        if (classname != null) {
          if (classname.equals(""String_Node_Str"")) {
            root=e;
          }
 else           if (classname.equals(""String_Node_Str"")) {
            director=e;
          }
        }
      }
      if (root == null) {
        throw new Exception(""String_Node_Str"" + micaboardFile);
      }
      if (director == null) {
        throw new Exception(""String_Node_Str"" + micaboardFile);
      }
    }
 catch (    Exception e) {
      System.err.println(""String_Node_Str"" + e);
      e.printStackTrace();
    }
    Element rootWireless=new Element(""String_Node_Str"");
    rootWireless.setAttribute(""String_Node_Str"",componentName);
    rootWireless.setAttribute(""String_Node_Str"",""String_Node_Str"");
    Element wirelessDirector=new Element(""String_Node_Str"");
    wirelessDirector.setAttribute(""String_Node_Str"",""String_Node_Str"");
    wirelessDirector.setAttribute(""String_Node_Str"",""String_Node_Str"");
    rootWireless.addContent(wirelessDirector);
    rootWireless.addContent(micaboard);
    doc=new Document(rootWireless,plot);
  }
 else {
    root=new Element(""String_Node_Str"");
    root.setAttribute(""String_Node_Str"",componentName);
    root.setAttribute(""String_Node_Str"",""String_Node_Str"");
    doc=new Document(root,plot);
    director=new Element(""String_Node_Str"");
    director.setAttribute(""String_Node_Str"",""String_Node_Str"");
    director.setAttribute(""String_Node_Str"",""String_Node_Str"");
    root.addContent(director);
  }
  Element pflags=new Element(""String_Node_Str"");
  pflags.setAttribute(""String_Node_Str"",""String_Node_Str"");
  pflags.setAttribute(""String_Node_Str"",""String_Node_Str"");
  pflags.setAttribute(""String_Node_Str"",opts.trim());
  if (director == null) {
    throw new InternalErrorException(""String_Node_Str"");
  }
 else {
    director.addContent(pflags);
  }
  Element destinationDirectory=new Element(""String_Node_Str"");
  destinationDirectory.setAttribute(""String_Node_Str"",""String_Node_Str"");
  destinationDirectory.setAttribute(""String_Node_Str"",""String_Node_Str"");
  destinationDirectory.setAttribute(""String_Node_Str"",directorOutputDir);
  director.addContent(destinationDirectory);
  Element annotation=new Element(""String_Node_Str"");
  annotation.setAttribute(""String_Node_Str"",""String_Node_Str"");
  annotation.setAttribute(""String_Node_Str"",""String_Node_Str"");
  if (root == null) {
    throw new InternalErrorException(""String_Node_Str"");
  }
 else {
    root.addContent(annotation);
  }
  Element text=new Element(""String_Node_Str"");
  text.setAttribute(""String_Node_Str"",""String_Node_Str"");
  text.setAttribute(""String_Node_Str"",""String_Node_Str"");
  text.setAttribute(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  annotation.addContent(text);
  Element location=new Element(""String_Node_Str"");
  location.setAttribute(""String_Node_Str"",""String_Node_Str"");
  location.setAttribute(""String_Node_Str"",""String_Node_Str"");
  location.setAttribute(""String_Node_Str"",""String_Node_Str"");
  annotation.addContent(location);
  readLinks();
  Enumeration enumeration=_componentFileTable.elements();
  while (enumeration.hasMoreElements()) {
    _ComponentFile componentFile=(_ComponentFile)enumeration.nextElement();
    Element entity=new Element(""String_Node_Str"");
    entity.setAttribute(""String_Node_Str"",componentFile.getName());
    entity.setAttribute(""String_Node_Str"",componentFile.getClassName());
    root.addContent(entity);
  }
  for (int i=1; i <= _relations.currentCount(); i++) {
    Element relation=new Element(""String_Node_Str"");
    relation.setAttribute(""String_Node_Str"",""String_Node_Str"" + i);
    relation.setAttribute(""String_Node_Str"",""String_Node_Str"");
    root.addContent(relation);
  }
  for (int i=0; i < _linkList.size(); i++) {
    Element xmlLink=new Element(""String_Node_Str"");
    _Link link=(_Link)_linkList.get(i);
    String fromType;
    String fromName;
    if (link.from instanceof Port) {
      fromType=""String_Node_Str"";
      Port port=(Port)link.from;
      fromName=port.getContainer().getName() + ""String_Node_Str"" + port.getName();
    }
 else     if (link.from instanceof Relation) {
      fromType=""String_Node_Str"";
      Relation relation=(Relation)link.from;
      fromName=relation.getName();
    }
 else {
      throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"");
    }
    String toType;
    String toName;
    if (link.to instanceof Port) {
      toType=""String_Node_Str"";
      Port port=(Port)link.to;
      toName=port.getContainer().getName() + ""String_Node_Str"" + port.getName();
    }
 else     if (link.to instanceof Relation) {
      toType=""String_Node_Str"";
      Relation relation=(Relation)link.to;
      toName=relation.getName();
    }
 else {
      throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"");
    }
    if (fromType.equals(""String_Node_Str"") && toType.equals(""String_Node_Str"")) {
      fromType+=""String_Node_Str"";
      toType+=""String_Node_Str"";
    }
    xmlLink.setAttribute(fromType,fromName);
    xmlLink.setAttribute(toType,toName);
    root.addContent(xmlLink);
  }
  try {
    FileOutputStream out=null;
    if (outputFile != null) {
      out=new FileOutputStream(outputFile);
    }
    XMLOutputter serializer=new XMLOutputter(Format.getPrettyFormat());
    Format format=serializer.getFormat();
    format.setOmitEncoding(true);
    format.setLineSeparator(""String_Node_Str"");
    serializer.setFormat(format);
    if (out != null) {
      serializer.output(doc,out);
      out.flush();
      out.close();
    }
 else {
      serializer.output(doc,System.out);
    }
  }
 catch (  IOException e) {
    System.err.println(e);
  }
}","/** 
 * Generate the .moml file for this nesC application.
 * @param componentName The name of the component (no suffix).
 * @param outputFile The file to generate.
 * @param directorOutputDir The output directory to pass to thePtinyOSDirector.
 * @param opts The compiler options (PFLAGS) to pass to thePtinyOSDirector.
 * @param micaboardFile Path to the MoML file that contains theWireless wrapper.  Null if wrapper should not be generated.
 * @exception IllegalActionException If there is a problem creatingan interface IOport or connection.
 * @exception NameDuplicationException If there is a problem creatingan interface IOport or connection.
 */
public void generatePtinyOSModel(String componentName,String outputFile,String directorOutputDir,String opts,String micaboardFile) throws IllegalActionException, NameDuplicationException {
  Element root=null;
  Element director=null;
  DocType plot=new DocType(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  Document doc=null;
  if (micaboardFile != null) {
    Element micaboard=null;
    try {
      SAXBuilder saxbuilder=new SAXBuilder();
      Document docWireless=saxbuilder.build(new File(micaboardFile));
      Filter filter=new ContentFilter(ContentFilter.ELEMENT);
      Iterator iteratorDocWireless=docWireless.getDescendants(filter);
      while (iteratorDocWireless.hasNext()) {
        Element e=(Element)iteratorDocWireless.next();
        String classname=e.getAttributeValue(""String_Node_Str"");
        if (classname != null) {
          if (classname.equals(""String_Node_Str"")) {
            micaboard=(Element)e.clone();
            break;
          }
        }
      }
      if (micaboard == null) {
        throw new Exception(""String_Node_Str"" + micaboardFile);
      }
      Iterator iteratorMicaBoard=micaboard.getDescendants(filter);
      while (iteratorMicaBoard.hasNext()) {
        Element e=(Element)iteratorMicaBoard.next();
        String classname=e.getAttributeValue(""String_Node_Str"");
        if (classname != null) {
          if (classname.equals(""String_Node_Str"")) {
            root=e;
          }
 else           if (classname.equals(""String_Node_Str"")) {
            director=e;
          }
        }
      }
      if (root == null) {
        throw new Exception(""String_Node_Str"" + micaboardFile);
      }
      if (director == null) {
        throw new Exception(""String_Node_Str"" + micaboardFile);
      }
    }
 catch (    Exception e) {
      System.err.println(""String_Node_Str"" + e);
      e.printStackTrace();
    }
    Element rootWireless=new Element(""String_Node_Str"");
    rootWireless.setAttribute(""String_Node_Str"",componentName);
    rootWireless.setAttribute(""String_Node_Str"",""String_Node_Str"");
    Element wirelessDirector=new Element(""String_Node_Str"");
    wirelessDirector.setAttribute(""String_Node_Str"",""String_Node_Str"");
    wirelessDirector.setAttribute(""String_Node_Str"",""String_Node_Str"");
    rootWireless.addContent(wirelessDirector);
    rootWireless.addContent(micaboard);
    doc=new Document(rootWireless,plot);
  }
 else {
    root=new Element(""String_Node_Str"");
    root.setAttribute(""String_Node_Str"",componentName);
    root.setAttribute(""String_Node_Str"",""String_Node_Str"");
    doc=new Document(root,plot);
    director=new Element(""String_Node_Str"");
    director.setAttribute(""String_Node_Str"",""String_Node_Str"");
    director.setAttribute(""String_Node_Str"",""String_Node_Str"");
    root.addContent(director);
  }
  Element pflags=new Element(""String_Node_Str"");
  pflags.setAttribute(""String_Node_Str"",""String_Node_Str"");
  pflags.setAttribute(""String_Node_Str"",""String_Node_Str"");
  pflags.setAttribute(""String_Node_Str"",opts.trim());
  if (director == null) {
    throw new InternalErrorException(""String_Node_Str"");
  }
 else {
    director.addContent(pflags);
  }
  Element destinationDirectory=new Element(""String_Node_Str"");
  destinationDirectory.setAttribute(""String_Node_Str"",""String_Node_Str"");
  destinationDirectory.setAttribute(""String_Node_Str"",""String_Node_Str"");
  destinationDirectory.setAttribute(""String_Node_Str"",directorOutputDir);
  director.addContent(destinationDirectory);
  Element annotation=new Element(""String_Node_Str"");
  annotation.setAttribute(""String_Node_Str"",""String_Node_Str"");
  annotation.setAttribute(""String_Node_Str"",""String_Node_Str"");
  if (root == null) {
    throw new InternalErrorException(""String_Node_Str"");
  }
 else {
    root.addContent(annotation);
  }
  Element text=new Element(""String_Node_Str"");
  text.setAttribute(""String_Node_Str"",""String_Node_Str"");
  text.setAttribute(""String_Node_Str"",""String_Node_Str"");
  text.setAttribute(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  annotation.addContent(text);
  Element location=new Element(""String_Node_Str"");
  location.setAttribute(""String_Node_Str"",""String_Node_Str"");
  location.setAttribute(""String_Node_Str"",""String_Node_Str"");
  location.setAttribute(""String_Node_Str"",""String_Node_Str"");
  annotation.addContent(location);
  readLinks();
  Enumeration enumeration=_componentFileTable.elements();
  while (enumeration.hasMoreElements()) {
    _ComponentFile componentFile=(_ComponentFile)enumeration.nextElement();
    Element entity=new Element(""String_Node_Str"");
    entity.setAttribute(""String_Node_Str"",componentFile.getName());
    entity.setAttribute(""String_Node_Str"",componentFile.getClassName());
    root.addContent(entity);
  }
  for (int i=1; i <= _relations.currentCount(); i++) {
    Element relation=new Element(""String_Node_Str"");
    relation.setAttribute(""String_Node_Str"",""String_Node_Str"" + i);
    relation.setAttribute(""String_Node_Str"",""String_Node_Str"");
    root.addContent(relation);
  }
  for (int i=0; i < _linkList.size(); i++) {
    Element xmlLink=new Element(""String_Node_Str"");
    _Link link=(_Link)_linkList.get(i);
    String fromType;
    String fromName;
    if (link.from instanceof Port) {
      fromType=""String_Node_Str"";
      Port port=(Port)link.from;
      fromName=port.getContainer().getName() + ""String_Node_Str"" + port.getName();
    }
 else     if (link.from instanceof Relation) {
      fromType=""String_Node_Str"";
      Relation relation=(Relation)link.from;
      fromName=relation.getName();
    }
 else {
      throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"");
    }
    String toType;
    String toName;
    if (link.to instanceof Port) {
      toType=""String_Node_Str"";
      Port port=(Port)link.to;
      toName=port.getContainer().getName() + ""String_Node_Str"" + port.getName();
    }
 else     if (link.to instanceof Relation) {
      toType=""String_Node_Str"";
      Relation relation=(Relation)link.to;
      toName=relation.getName();
    }
 else {
      throw new InternalErrorException(""String_Node_Str"" + ""String_Node_Str"");
    }
    if (fromType.equals(""String_Node_Str"") && toType.equals(""String_Node_Str"")) {
      fromType+=""String_Node_Str"";
      toType+=""String_Node_Str"";
    }
    xmlLink.setAttribute(fromType,fromName);
    xmlLink.setAttribute(toType,toName);
    root.addContent(xmlLink);
  }
  FileOutputStream out=null;
  try {
    if (outputFile != null) {
      out=new FileOutputStream(outputFile);
    }
    XMLOutputter serializer=new XMLOutputter(Format.getPrettyFormat());
    Format format=serializer.getFormat();
    format.setOmitEncoding(true);
    format.setLineSeparator(""String_Node_Str"");
    serializer.setFormat(format);
    if (out != null) {
      serializer.output(doc,out);
    }
 else {
      serializer.output(doc,System.out);
    }
  }
 catch (  IOException ex) {
    System.err.println(ex);
  }
 finally {
    if (out != null) {
      try {
        out.flush();
        out.close();
      }
 catch (      IOException ex) {
        ex.printStackTrace();
      }
    }
  }
}"
72788,"/** 
 * If the <i>initialValue</i> parameter is the argument, then reset the current output to match the new value.
 * @param attribute The attribute that changed.
 * @exception IllegalActionException If the change is not acceptableto this container (not thrown in this base class).
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == initialValue) {
    if (initialValue.getToken() != null) {
      _lastInputs=new Token[input.getWidth()];
      for (int i=0; i < input.getWidth(); i++) {
        _lastInputs[i]=initialValue.getToken();
      }
    }
 else {
      _lastInputs=null;
    }
  }
 else {
    super.attributeChanged(attribute);
  }
}","/** 
 * If the <i>initialValue</i> parameter is the argument, then reset the current output to match the new value.
 * @param attribute The attribute that changed.
 * @exception IllegalActionException If the change is not acceptableto this container (not thrown in this base class).
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == initialValue) {
    if (initialValue.getToken() != null) {
      int width=1;
      if (_initializeDone) {
        width=input.getWidth();
      }
      if (width < 1) {
        width=1;
      }
      _lastInputs=new Token[width];
      for (int i=0; i < width; i++) {
        _lastInputs[i]=initialValue.getToken();
      }
    }
 else {
      _lastInputs=null;
    }
  }
 else {
    super.attributeChanged(attribute);
  }
}"
72789,"/** 
 * Clear the cached input tokens.
 * @exception IllegalActionException If there is no director.
 */
public void initialize() throws IllegalActionException {
  if (initialValue.getToken() != null) {
    _lastInputs=new Token[input.getWidth()];
    for (int i=0; i < input.getWidth(); i++) {
      _lastInputs[i]=initialValue.getToken();
    }
  }
 else {
    _lastInputs=null;
  }
  super.initialize();
}","/** 
 * Clear the cached input tokens.
 * @exception IllegalActionException If there is no director.
 */
public void initialize() throws IllegalActionException {
  if (initialValue.getToken() != null) {
    _lastInputs=new Token[input.getWidth()];
    for (int i=0; i < input.getWidth(); i++) {
      _lastInputs[i]=initialValue.getToken();
    }
  }
 else {
    _lastInputs=null;
  }
  _initializeDone=true;
  super.initialize();
}"
72790,"/** 
 * Return the refined step size, which is the minimum of the current step size and the suggested step size of all actors that implement ContinuousStepSizeController and that also ensures that we do not pass a breakpoint. If these actors request a step size smaller than the time resolution, then the first time this happens this method returns the time resolution. If it happens again on the next call to this method, then this method throws an exception.
 * @return The refined step size.
 * @exception IllegalActionException If the scheduler throws it or therefined step size is less than the time resolution.
 */
public double refinedStepSize() throws IllegalActionException {
  if (_debugging) {
    _debug(""String_Node_Str"" + _currentStepSize);
  }
  double timeResolution=getTimeResolution();
  double refinedStep=_currentStepSize;
  Iterator stepSizeControlActors=_stepSizeControllers().iterator();
  while (stepSizeControlActors.hasNext() && !_stopRequested) {
    ContinuousStepSizeController actor=(ContinuousStepSizeController)stepSizeControlActors.next();
    refinedStep=Math.min(refinedStep,actor.refinedStepSize());
  }
  if (refinedStep < timeResolution) {
    if (!_triedTheMinimumStepSize) {
      refinedStep=timeResolution;
      _triedTheMinimumStepSize=true;
    }
 else {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + getModelTime());
    }
  }
 else {
    _triedTheMinimumStepSize=false;
  }
  if (_debugging) {
    _debug(""String_Node_Str"" + refinedStep);
  }
  if (!_breakpoints.isEmpty()) {
    SuperdenseTime nextBreakpoint=(SuperdenseTime)_breakpoints.first();
    Time nextBreakpointTime=nextBreakpoint.timestamp();
    int comparison=nextBreakpointTime.compareTo(_iterationBeginTime.add(refinedStep));
    if (comparison < 0) {
      refinedStep=nextBreakpointTime.subtract(_iterationBeginTime).getDoubleValue();
      if (refinedStep < 0.0) {
        throw new IllegalActionException(this,""String_Node_Str"" + nextBreakpoint);
      }
      if (_debugging) {
        _debug(""String_Node_Str"" + refinedStep);
      }
    }
  }
  return refinedStep;
}","/** 
 * Return the refined step size, which is the minimum of the current step size and the suggested step size of all actors that implement ContinuousStepSizeController and that also ensures that we do not pass a breakpoint. If these actors request a step size smaller than the time resolution, then the first time this happens this method returns the time resolution. If it happens again on the next call to this method, then this method throws an exception.
 * @return The refined step size.
 * @exception IllegalActionException If the scheduler throws it or therefined step size is less than the time resolution.
 */
public double refinedStepSize() throws IllegalActionException {
  if (_debugging) {
    _debug(""String_Node_Str"" + _currentStepSize);
  }
  double timeResolution=getTimeResolution();
  double refinedStep=_currentStepSize;
  Iterator stepSizeControlActors=_stepSizeControllers().iterator();
  while (stepSizeControlActors.hasNext() && !_stopRequested) {
    ContinuousStepSizeController actor=(ContinuousStepSizeController)stepSizeControlActors.next();
    refinedStep=Math.min(refinedStep,actor.refinedStepSize());
  }
  if (refinedStep < timeResolution) {
    if (!_triedTheMinimumStepSize) {
      refinedStep=timeResolution;
      _triedTheMinimumStepSize=true;
    }
 else {
      throw new IllegalActionException(this,""String_Node_Str"" + ""String_Node_Str"" + getModelTime());
    }
  }
 else {
    _triedTheMinimumStepSize=false;
  }
  if (_debugging) {
    _debug(""String_Node_Str"" + refinedStep);
  }
  if (refinedStep >= _currentStepSize) {
    refinedStep=_currentStepSize * 0.5;
    if (_debugging) {
      _debug(""String_Node_Str"" + refinedStep);
    }
  }
  if (!_breakpoints.isEmpty()) {
    SuperdenseTime nextBreakpoint=(SuperdenseTime)_breakpoints.first();
    Time nextBreakpointTime=nextBreakpoint.timestamp();
    int comparison=nextBreakpointTime.compareTo(_iterationBeginTime.add(refinedStep));
    if (comparison < 0) {
      refinedStep=nextBreakpointTime.subtract(_iterationBeginTime).getDoubleValue();
      if (refinedStep < 0.0) {
        throw new IllegalActionException(this,""String_Node_Str"" + nextBreakpoint);
      }
      if (_debugging) {
        _debug(""String_Node_Str"" + refinedStep);
      }
    }
  }
  return refinedStep;
}"
72791,"/** 
 * Advance the current model tag to that of the earliest event in the event queue, and fire all actors that have requested or are triggered to be fired at the current tag. If <i>synchronizeToRealTime</i> is true, then before firing, wait until real time matches or exceeds the timestamp of the event. Note that the default unit for time is seconds. <p> Each actor is fired repeatedly (prefire(), fire()), until either it has no more input tokens, or its prefire() method returns false. Note that if the actor fails to consume its inputs, then this can result in an infinite loop. Each actor that is fired is then postfired once at the conclusion of the iteration. </p><p> If there are no events in the event queue, then the behavior depends on the <i>stopWhenQueueIsEmpty</i> parameter. If it is false, then this thread will stall until events become available in the event queue. Otherwise, time will advance to the stop time and the execution will halt.</p>
 * @return 0 if firing was successful, and the next event in eventqueue should be checked for processing; -1 if there's no actor to fire, and we should not keep firing; 1 if there's no actor to fire, but the next event should be checked for processing.
 * @exception IllegalActionException If the firing actor throws it, orevent queue is not ready, or an event is missed, or time is set backwards.
 */
protected int _fire() throws IllegalActionException {
  Actor actorToFire=_getNextActorToFire();
  if (actorToFire == null) {
    if (_isTopLevel()) {
      if (_debugging) {
        _debug(""String_Node_Str"");
      }
      if (!_stopFireRequested) {
        _noMoreActorsToFire=true;
      }
    }
 else {
      if (_debugging) {
        _debug(""String_Node_Str"" + ""String_Node_Str"");
      }
    }
    _stopFireRequested=false;
    return -1;
  }
  if (actorToFire == getContainer()) {
    return 1;
  }
  if (_debugging) {
    _debug(""String_Node_Str"" + actorToFire.getFullName());
  }
  boolean refire;
  do {
    refire=false;
    if (_debugging) {
      if (!((CompositeEntity)getContainer()).deepContains((NamedObj)actorToFire)) {
        _debug(""String_Node_Str"");
        _disableActor(actorToFire);
        break;
      }
      _debug(new FiringEvent(this,actorToFire,FiringEvent.BEFORE_PREFIRE));
      if (!actorToFire.prefire()) {
        _debug(""String_Node_Str"");
        break;
      }
      _debug(new FiringEvent(this,actorToFire,FiringEvent.AFTER_PREFIRE));
      _debug(new FiringEvent(this,actorToFire,FiringEvent.BEFORE_FIRE));
      actorToFire.fire();
      _debug(new FiringEvent(this,actorToFire,FiringEvent.AFTER_FIRE));
      _debug(new FiringEvent(this,actorToFire,FiringEvent.BEFORE_POSTFIRE));
      if (!actorToFire.postfire()) {
        _debug(""String_Node_Str"",((Nameable)actorToFire).getName());
        _disableActor(actorToFire);
        break;
      }
      _debug(new FiringEvent(this,actorToFire,FiringEvent.AFTER_POSTFIRE));
    }
 else {
      if (!((CompositeEntity)getContainer()).deepContains((NamedObj)actorToFire)) {
        _disableActor(actorToFire);
        break;
      }
      if (!actorToFire.prefire()) {
        break;
      }
      actorToFire.fire();
      if (!actorToFire.postfire()) {
        _disableActor(actorToFire);
        break;
      }
    }
    Iterator<?> inputPorts=actorToFire.inputPortList().iterator();
    while (inputPorts.hasNext() && !refire) {
      IOPort port=(IOPort)inputPorts.next();
      for (int i=0; i < port.getWidth(); i++) {
        if (port.hasToken(i)) {
          if (_debugging) {
            _debug(""String_Node_Str"" + port.getName() + ""String_Node_Str""+ i+ ""String_Node_Str"");
          }
          if (!_aspectsPresent || _schedule(actorToFire,getModelTime())) {
            refire=true;
            break;
          }
 else           if (_aspectsPresent) {
            if (_actorsInExecution == null) {
              _actorsInExecution=new HashMap();
            }
            List<DEEvent> events=_actorsInExecution.get(actorToFire);
            if (events == null) {
              events=new ArrayList<DEEvent>();
            }
            events.add(new DEEvent(actorToFire,getModelTime(),1,_getDepthOfActor(actorToFire)));
            _actorsInExecution.put(actorToFire,events);
          }
        }
      }
    }
  }
 while (refire);
  return 0;
}","/** 
 * Advance the current model tag to that of the earliest event in the event queue, and fire all actors that have requested or are triggered to be fired at the current tag. If <i>synchronizeToRealTime</i> is true, then before firing, wait until real time matches or exceeds the timestamp of the event. Note that the default unit for time is seconds. <p> Each actor is fired repeatedly (prefire(), fire()), until either it has no more input tokens, or its prefire() method returns false. Note that if the actor fails to consume its inputs, then this can result in an infinite loop. Each actor that is fired is then postfired once at the conclusion of the iteration. </p><p> If there are no events in the event queue, then the behavior depends on the <i>stopWhenQueueIsEmpty</i> parameter. If it is false, then this thread will stall until events become available in the event queue. Otherwise, time will advance to the stop time and the execution will halt.</p>
 * @return 0 if firing was successful, and the next event in eventqueue should be checked for processing; -1 if there's no actor to fire, and we should not keep firing; 1 if there's no actor to fire, but the next event should be checked for processing.
 * @exception IllegalActionException If the firing actor throws it, orevent queue is not ready, or an event is missed, or time is set backwards.
 */
protected int _fire() throws IllegalActionException {
  Actor actorToFire=_getNextActorToFire();
  if (actorToFire == null) {
    if (_isTopLevel()) {
      if (_debugging) {
        _debug(""String_Node_Str"");
      }
      if (!_stopFireRequested) {
        _noMoreActorsToFire=true;
      }
    }
 else {
      if (_debugging) {
        _debug(""String_Node_Str"" + ""String_Node_Str"");
      }
    }
    _stopFireRequested=false;
    return -1;
  }
  if (actorToFire == getContainer()) {
    return 1;
  }
  if (_debugging) {
    _debug(""String_Node_Str"" + actorToFire.getFullName());
  }
  boolean refire;
  do {
    refire=false;
    if (_debugging) {
      if (!((CompositeEntity)getContainer()).deepContains((NamedObj)actorToFire)) {
        _debug(""String_Node_Str"");
        _disableActor(actorToFire);
        break;
      }
      _debug(new FiringEvent(this,actorToFire,FiringEvent.BEFORE_PREFIRE));
      if (!actorToFire.prefire()) {
        _debug(""String_Node_Str"");
        break;
      }
      _debug(new FiringEvent(this,actorToFire,FiringEvent.AFTER_PREFIRE));
      _debug(new FiringEvent(this,actorToFire,FiringEvent.BEFORE_FIRE));
      actorToFire.fire();
      _debug(new FiringEvent(this,actorToFire,FiringEvent.AFTER_FIRE));
      _debug(new FiringEvent(this,actorToFire,FiringEvent.BEFORE_POSTFIRE));
      if (!actorToFire.postfire()) {
        _debug(""String_Node_Str"",((Nameable)actorToFire).getName());
        _disableActor(actorToFire);
        break;
      }
      _debug(new FiringEvent(this,actorToFire,FiringEvent.AFTER_POSTFIRE));
    }
 else {
      if (!((CompositeEntity)getContainer()).deepContains((NamedObj)actorToFire)) {
        _disableActor(actorToFire);
        break;
      }
      if (!actorToFire.prefire()) {
        break;
      }
      actorToFire.fire();
      if (!actorToFire.postfire()) {
        _disableActor(actorToFire);
        break;
      }
    }
    Iterator<?> inputPorts=actorToFire.inputPortList().iterator();
    while (inputPorts.hasNext() && !refire) {
      IOPort port=(IOPort)inputPorts.next();
      for (int i=0; i < port.getWidth(); i++) {
        if (port.hasToken(i)) {
          if (_debugging) {
            _debug(""String_Node_Str"" + port.getName() + ""String_Node_Str""+ i+ ""String_Node_Str"");
          }
          if (!_aspectsPresent || _schedule(actorToFire,getModelTime())) {
            refire=true;
            break;
          }
 else           if (_aspectsPresent) {
            if (_actorsInExecution == null) {
              _actorsInExecution=new HashMap();
            }
            List<DEEvent> events=_actorsInExecution.get(actorToFire);
            if (events == null) {
              events=new ArrayList<DEEvent>();
            }
            events.add(new DEEvent(port,getModelTime(),1,_getDepthOfActor(actorToFire)));
            _actorsInExecution.put(actorToFire,events);
          }
        }
      }
    }
  }
 while (refire);
  return 0;
}"
72792,"/** 
 * Dequeue the events that have the smallest tag from the event queue. Return their destination actor. Advance the model tag to their tag. If the timestamp of the smallest tag is greater than the stop time then return null. If there are no events in the event queue, and the stopWhenQueueIsEmpty parameter is set to true, then return null. Both cases will have the effect of stopping the simulation. <p> If the stopWhenQueueIsEmpty parameter is false and the queue is empty, then stall the current thread by calling wait() on the _eventQueue until there are new events available.  If the synchronizeToRealTime parameter is true, then this method may suspend the calling thread by using Object.wait(long) to let elapsed real time catch up with the current model time.</p>
 * @return The next actor to be fired, which can be null.
 * @exception IllegalActionException If event queue is not ready, oran event is missed, or time is set backwards.
 */
protected Actor _getNextActorToFire() throws IllegalActionException {
  if (_eventQueue == null) {
    throw new IllegalActionException(""String_Node_Str"");
  }
  Actor actorToFire=null;
  DEEvent lastFoundEvent=null;
  DEEvent nextEvent=null;
  while (!_stopRequested) {
    if (_stopWhenQueueIsEmpty) {
      if (_eventQueue.isEmpty()) {
        break;
      }
    }
    if (isEmbedded()) {
      if (_eventQueue.isEmpty()) {
        break;
      }
      nextEvent=_eventQueue.get();
      if (nextEvent.timeStamp().compareTo(getModelTime()) < 0) {
        throw new IllegalActionException(""String_Node_Str"" + nextEvent.timeStamp() + ""String_Node_Str""+ nextEvent.microstep()+ ""String_Node_Str""+ getModelTime()+ ""String_Node_Str""+ _microstep+ ""String_Node_Str"");
      }
      boolean microstepMatches=true;
      Nameable container=getContainer();
      if (container instanceof CompositeActor) {
        Director executiveDirector=((CompositeActor)container).getExecutiveDirector();
        if (executiveDirector instanceof SuperdenseTimeDirector && !_isTopLevel()) {
          microstepMatches=nextEvent.microstep() <= _microstep;
        }
      }
      int comparison=nextEvent.timeStamp().compareTo(getModelTime());
      if (comparison > 0 || comparison == 0 && !microstepMatches) {
        nextEvent=null;
        break;
      }
    }
 else {
      if (_eventQueue.isEmpty()) {
        if (actorToFire != null || getModelTime().equals(getModelStopTime())) {
          break;
        }
      }
synchronized (_eventQueue) {
        while (_eventQueue.isEmpty() && !_stopRequested && !_stopFireRequested) {
          if (_debugging) {
            _debug(""String_Node_Str"");
          }
          try {
            workspace().wait(_eventQueue);
          }
 catch (          InterruptedException e) {
            break;
          }
        }
        if (_eventQueue.isEmpty()) {
          return null;
        }
        nextEvent=_eventQueue.get();
      }
    }
    if (actorToFire == null) {
      Time currentTime;
      int depth=0;
      try {
synchronized (_eventQueue) {
          lastFoundEvent=_eventQueue.get();
          currentTime=_consultTimeRegulators(lastFoundEvent.timeStamp());
          if (_synchronizeToRealTime) {
            while (!_stopRequested && !_stopFireRequested) {
              lastFoundEvent=_eventQueue.get();
              currentTime=lastFoundEvent.timeStamp();
              long elapsedTime=System.currentTimeMillis() - _realStartTime;
              double elapsedTimeInSeconds=elapsedTime / 1000.0;
              ptolemy.actor.util.Time elapsed=new ptolemy.actor.util.Time(this,elapsedTimeInSeconds);
              if (currentTime.compareTo(elapsed) <= 0) {
                break;
              }
              long timeToWait=(long)(currentTime.subtract(elapsed).getDoubleValue() * 1000.0);
              if (timeToWait > 0) {
                if (_debugging) {
                  _debug(""String_Node_Str"" + timeToWait);
                }
                try {
                  depth=_workspace.releaseReadPermission();
                  _eventQueue.wait(timeToWait);
                }
 catch (                InterruptedException ex) {
                  throw new IllegalActionException(this,ex,""String_Node_Str"" + ""String_Node_Str"");
                }
              }
            }
            if (_stopRequested || _stopFireRequested) {
              return null;
            }
          }
        }
      }
  finally {
        if (depth > 0) {
          _workspace.reacquireReadPermission(depth);
        }
      }
synchronized (_eventQueue) {
        lastFoundEvent=_eventQueue.take();
        currentTime=lastFoundEvent.timeStamp();
        actorToFire=lastFoundEvent.actor();
        if (_disabledActors != null && _disabledActors.contains(actorToFire)) {
          if (_debugging) {
            _debug(""String_Node_Str"",((Nameable)actorToFire).getFullName());
          }
          actorToFire=null;
          continue;
        }
        setModelTime(currentTime);
        _microstep=lastFoundEvent.microstep();
        if (_debugging) {
          _debug(""String_Node_Str"" + currentTime + ""String_Node_Str""+ _microstep+ ""String_Node_Str"");
        }
      }
      if (currentTime.compareTo(getModelStopTime()) > 0) {
        if (_debugging) {
          _debug(""String_Node_Str"");
        }
        _exceedStopTime=true;
        return null;
      }
    }
 else {
      if (nextEvent.hasTheSameTagAs(lastFoundEvent) && nextEvent.actor() == actorToFire) {
synchronized (_eventQueue) {
          _eventQueue.take();
        }
      }
 else {
        break;
      }
    }
    if (actorToFire != null && _aspectsPresent) {
      if (_actorsFinished.contains(actorToFire)) {
        _actorsFinished.remove(actorToFire);
      }
 else       if (!_schedule(actorToFire,getModelTime())) {
        _nextScheduleTime.get(_aspectForActor.get(actorToFire)).add(getModelTime());
        if (_actorsInExecution == null) {
          _actorsInExecution=new HashMap();
        }
        List<DEEvent> events=_actorsInExecution.get(actorToFire);
        if (events == null) {
          events=new ArrayList<DEEvent>();
        }
        events.add(lastFoundEvent);
        _actorsInExecution.put(actorToFire,events);
        actorToFire=null;
      }
    }
  }
  return actorToFire;
}","/** 
 * Dequeue the events that have the smallest tag from the event queue. Return their destination actor. Advance the model tag to their tag. If the timestamp of the smallest tag is greater than the stop time then return null. If there are no events in the event queue, and the stopWhenQueueIsEmpty parameter is set to true, then return null. Both cases will have the effect of stopping the simulation. <p> If the stopWhenQueueIsEmpty parameter is false and the queue is empty, then stall the current thread by calling wait() on the _eventQueue until there are new events available.  If the synchronizeToRealTime parameter is true, then this method may suspend the calling thread by using Object.wait(long) to let elapsed real time catch up with the current model time.</p>
 * @return The next actor to be fired, which can be null.
 * @exception IllegalActionException If event queue is not ready, oran event is missed, or time is set backwards.
 */
protected Actor _getNextActorToFire() throws IllegalActionException {
  if (_eventQueue == null) {
    throw new IllegalActionException(""String_Node_Str"");
  }
  Actor actorToFire=null;
  DEEvent lastFoundEvent=null;
  DEEvent nextEvent=null;
  while (!_stopRequested) {
    if (_stopWhenQueueIsEmpty) {
      if (_eventQueue.isEmpty()) {
        break;
      }
    }
    if (isEmbedded()) {
      if (_eventQueue.isEmpty()) {
        break;
      }
      nextEvent=_eventQueue.get();
      if (nextEvent.timeStamp().compareTo(getModelTime()) < 0) {
        throw new IllegalActionException(""String_Node_Str"" + nextEvent.timeStamp() + ""String_Node_Str""+ nextEvent.microstep()+ ""String_Node_Str""+ getModelTime()+ ""String_Node_Str""+ _microstep+ ""String_Node_Str"");
      }
      boolean microstepMatches=true;
      Nameable container=getContainer();
      if (container instanceof CompositeActor) {
        Director executiveDirector=((CompositeActor)container).getExecutiveDirector();
        if (executiveDirector instanceof SuperdenseTimeDirector && !_isTopLevel()) {
          microstepMatches=nextEvent.microstep() <= _microstep;
        }
      }
      int comparison=nextEvent.timeStamp().compareTo(getModelTime());
      if (comparison > 0 || comparison == 0 && !microstepMatches) {
        nextEvent=null;
        break;
      }
    }
 else {
      if (_eventQueue.isEmpty()) {
        if (actorToFire != null || getModelTime().equals(getModelStopTime())) {
          break;
        }
      }
synchronized (_eventQueue) {
        while (_eventQueue.isEmpty() && !_stopRequested && !_stopFireRequested) {
          if (_debugging) {
            _debug(""String_Node_Str"");
          }
          try {
            workspace().wait(_eventQueue);
          }
 catch (          InterruptedException e) {
            break;
          }
        }
        if (_eventQueue.isEmpty()) {
          return null;
        }
        nextEvent=_eventQueue.get();
      }
    }
    if (actorToFire == null) {
      Time currentTime;
      int depth=0;
      try {
synchronized (_eventQueue) {
          lastFoundEvent=_eventQueue.get();
          currentTime=_consultTimeRegulators(lastFoundEvent.timeStamp());
          if (_synchronizeToRealTime) {
            while (!_stopRequested && !_stopFireRequested) {
              lastFoundEvent=_eventQueue.get();
              currentTime=lastFoundEvent.timeStamp();
              long elapsedTime=System.currentTimeMillis() - _realStartTime;
              double elapsedTimeInSeconds=elapsedTime / 1000.0;
              ptolemy.actor.util.Time elapsed=new ptolemy.actor.util.Time(this,elapsedTimeInSeconds);
              if (currentTime.compareTo(elapsed) <= 0) {
                break;
              }
              long timeToWait=(long)(currentTime.subtract(elapsed).getDoubleValue() * 1000.0);
              if (timeToWait > 0) {
                if (_debugging) {
                  _debug(""String_Node_Str"" + timeToWait);
                }
                try {
                  depth=_workspace.releaseReadPermission();
                  _eventQueue.wait(timeToWait);
                }
 catch (                InterruptedException ex) {
                  throw new IllegalActionException(this,ex,""String_Node_Str"" + ""String_Node_Str"");
                }
              }
            }
            if (_stopRequested || _stopFireRequested) {
              return null;
            }
          }
        }
      }
  finally {
        if (depth > 0) {
          _workspace.reacquireReadPermission(depth);
        }
      }
synchronized (_eventQueue) {
        lastFoundEvent=_eventQueue.take();
        currentTime=lastFoundEvent.timeStamp();
        actorToFire=lastFoundEvent.actor();
        if (_disabledActors != null && _disabledActors.contains(actorToFire)) {
          if (_debugging) {
            _debug(""String_Node_Str"",((Nameable)actorToFire).getFullName());
          }
          actorToFire=null;
          continue;
        }
        setModelTime(currentTime);
        _microstep=lastFoundEvent.microstep();
        if (_debugging) {
          _debug(""String_Node_Str"" + currentTime + ""String_Node_Str""+ _microstep+ ""String_Node_Str"");
        }
      }
      if (currentTime.compareTo(getModelStopTime()) > 0) {
        if (_debugging) {
          _debug(""String_Node_Str"");
        }
        _exceedStopTime=true;
        return null;
      }
    }
 else {
      if (nextEvent.hasTheSameTagAs(lastFoundEvent) && nextEvent.actor() == actorToFire) {
synchronized (_eventQueue) {
          _eventQueue.take();
        }
      }
 else {
        break;
      }
    }
    if (actorToFire != null && _aspectsPresent) {
      if (_actorsFinished.contains(actorToFire)) {
        _actorsFinished.remove(actorToFire);
      }
 else       if (!_schedule(actorToFire,getModelTime())) {
        _nextScheduleTime.get(_aspectForActor.get(actorToFire)).add(getModelTime());
        if (_actorsInExecution == null) {
          _actorsInExecution=new HashMap();
        }
        List<DEEvent> events=_actorsInExecution.get(actorToFire);
        if (events == null) {
          events=new ArrayList<DEEvent>();
        }
        events.add(lastFoundEvent);
        _actorsInExecution.put(actorToFire,events);
        System.out.println(actorToFire + ""String_Node_Str"" + events.size());
        actorToFire=null;
      }
    }
  }
  return actorToFire;
}"
72793,"/** 
 * Resume the execution of an actor that was previously blocked because it didn't have all the resources it needed for execution. This method puts an event into the queue for the current time.
 * @param actor The actor that resumes execution.
 * @exception IllegalActionException Not thrown here but in derived classes.
 */
public void resumeActor(Actor actor) throws IllegalActionException {
  List<DEEvent> events=_actorsInExecution.get(actor);
  Time time=((CompositeActor)_getExecutionAspect(actor).getContainer()).getDirector().getModelTime();
  if (events == null || events.size() == 0) {
    events=null;
  }
  DEEvent event=events.get(0);
  events.remove(event);
  _actorsInExecution.put(actor,events);
  if (event.ioPort() != null) {
    _enqueueTriggerEvent(event.ioPort(),time);
  }
 else {
    _enqueueEvent(actor,time,1);
  }
  fireContainerAt(time);
  if (_actorsFinished == null) {
    _actorsFinished=new ArrayList();
  }
  _actorsFinished.add(actor);
}","/** 
 * Resume the execution of an actor that was previously blocked because it didn't have all the resources it needed for execution. This method puts an event into the queue for the current time.
 * @param actor The actor that resumes execution.
 * @exception IllegalActionException Not thrown here but in derived classes.
 */
public void resumeActor(Actor actor) throws IllegalActionException {
  List<DEEvent> events=_actorsInExecution.get(actor);
  Time time=((CompositeActor)_getExecutionAspect(actor).getContainer()).getDirector().getModelTime();
  if (events == null || events.size() == 0) {
    events=null;
  }
  DEEvent event=events.get(0);
  events.remove(event);
  _actorsInExecution.put(actor,events);
  System.out.println(actor + ""String_Node_Str"" + events.size());
  if (event.ioPort() != null) {
    _enqueueTriggerEvent(event.ioPort(),time);
  }
 else {
    _enqueueEvent(actor,time,1);
  }
  fireContainerAt(time);
  if (_actorsFinished == null) {
    _actorsFinished=new ArrayList();
  }
  _actorsFinished.add(actor);
}"
72794,"/** 
 * Advance the current model tag to that of the earliest event in the event queue, and fire all actors that have requested or are triggered to be fired at the current tag. If <i>synchronizeToRealTime</i> is true, then before firing, wait until real time matches or exceeds the timestamp of the event. Note that the default unit for time is seconds. <p> Each actor is fired repeatedly (prefire(), fire()), until either it has no more input tokens, or its prefire() method returns false. Note that if the actor fails to consume its inputs, then this can result in an infinite loop. Each actor that is fired is then postfired once at the conclusion of the iteration. </p><p> If there are no events in the event queue, then the behavior depends on the <i>stopWhenQueueIsEmpty</i> parameter. If it is false, then this thread will stall until events become available in the event queue. Otherwise, time will advance to the stop time and the execution will halt.</p>
 * @return 0 if firing was successful, and the next event in eventqueue should be checked for processing; -1 if there's no actor to fire, and we should not keep firing; 1 if there's no actor to fire, but the next event should be checked for processing.
 * @exception IllegalActionException If the firing actor throws it, orevent queue is not ready, or an event is missed, or time is set backwards.
 */
protected int _fire() throws IllegalActionException {
  Actor actorToFire=_getNextActorToFire();
  if (actorToFire == null) {
    if (_isTopLevel()) {
      if (_debugging) {
        _debug(""String_Node_Str"");
      }
      if (!_stopFireRequested) {
        _noMoreActorsToFire=true;
      }
    }
 else {
      if (_debugging) {
        _debug(""String_Node_Str"" + ""String_Node_Str"");
      }
    }
    _stopFireRequested=false;
    return -1;
  }
  if (actorToFire == getContainer()) {
    return 1;
  }
  if (_debugging) {
    _debug(""String_Node_Str"" + actorToFire.getFullName());
  }
  boolean refire;
  do {
    refire=false;
    if (_debugging) {
      if (!((CompositeEntity)getContainer()).deepContains((NamedObj)actorToFire)) {
        _debug(""String_Node_Str"");
        _disableActor(actorToFire);
        break;
      }
      _debug(new FiringEvent(this,actorToFire,FiringEvent.BEFORE_PREFIRE));
      if (!actorToFire.prefire()) {
        _debug(""String_Node_Str"");
        break;
      }
      _debug(new FiringEvent(this,actorToFire,FiringEvent.AFTER_PREFIRE));
      _debug(new FiringEvent(this,actorToFire,FiringEvent.BEFORE_FIRE));
      actorToFire.fire();
      _debug(new FiringEvent(this,actorToFire,FiringEvent.AFTER_FIRE));
      _debug(new FiringEvent(this,actorToFire,FiringEvent.BEFORE_POSTFIRE));
      if (!actorToFire.postfire()) {
        _debug(""String_Node_Str"",((Nameable)actorToFire).getName());
        _disableActor(actorToFire);
        break;
      }
      _debug(new FiringEvent(this,actorToFire,FiringEvent.AFTER_POSTFIRE));
    }
 else {
      if (!((CompositeEntity)getContainer()).deepContains((NamedObj)actorToFire)) {
        _disableActor(actorToFire);
        break;
      }
      if (!actorToFire.prefire()) {
        break;
      }
      actorToFire.fire();
      if (!actorToFire.postfire()) {
        _disableActor(actorToFire);
        break;
      }
    }
    Iterator<?> inputPorts=actorToFire.inputPortList().iterator();
    while (inputPorts.hasNext() && !refire) {
      IOPort port=(IOPort)inputPorts.next();
      for (int i=0; i < port.getWidth(); i++) {
        if (port.hasToken(i)) {
          if (_debugging) {
            _debug(""String_Node_Str"" + port.getName() + ""String_Node_Str""+ i+ ""String_Node_Str"");
          }
          if (!_aspectsPresent || _schedule(actorToFire,getModelTime())) {
            refire=true;
            break;
          }
        }
      }
    }
  }
 while (refire);
  return 0;
}","/** 
 * Advance the current model tag to that of the earliest event in the event queue, and fire all actors that have requested or are triggered to be fired at the current tag. If <i>synchronizeToRealTime</i> is true, then before firing, wait until real time matches or exceeds the timestamp of the event. Note that the default unit for time is seconds. <p> Each actor is fired repeatedly (prefire(), fire()), until either it has no more input tokens, or its prefire() method returns false. Note that if the actor fails to consume its inputs, then this can result in an infinite loop. Each actor that is fired is then postfired once at the conclusion of the iteration. </p><p> If there are no events in the event queue, then the behavior depends on the <i>stopWhenQueueIsEmpty</i> parameter. If it is false, then this thread will stall until events become available in the event queue. Otherwise, time will advance to the stop time and the execution will halt.</p>
 * @return 0 if firing was successful, and the next event in eventqueue should be checked for processing; -1 if there's no actor to fire, and we should not keep firing; 1 if there's no actor to fire, but the next event should be checked for processing.
 * @exception IllegalActionException If the firing actor throws it, orevent queue is not ready, or an event is missed, or time is set backwards.
 */
protected int _fire() throws IllegalActionException {
  Actor actorToFire=_getNextActorToFire();
  if (actorToFire == null) {
    if (_isTopLevel()) {
      if (_debugging) {
        _debug(""String_Node_Str"");
      }
      if (!_stopFireRequested) {
        _noMoreActorsToFire=true;
      }
    }
 else {
      if (_debugging) {
        _debug(""String_Node_Str"" + ""String_Node_Str"");
      }
    }
    _stopFireRequested=false;
    return -1;
  }
  if (actorToFire == getContainer()) {
    return 1;
  }
  if (_debugging) {
    _debug(""String_Node_Str"" + actorToFire.getFullName());
  }
  boolean refire;
  do {
    refire=false;
    if (_debugging) {
      if (!((CompositeEntity)getContainer()).deepContains((NamedObj)actorToFire)) {
        _debug(""String_Node_Str"");
        _disableActor(actorToFire);
        break;
      }
      _debug(new FiringEvent(this,actorToFire,FiringEvent.BEFORE_PREFIRE));
      if (!actorToFire.prefire()) {
        _debug(""String_Node_Str"");
        break;
      }
      _debug(new FiringEvent(this,actorToFire,FiringEvent.AFTER_PREFIRE));
      _debug(new FiringEvent(this,actorToFire,FiringEvent.BEFORE_FIRE));
      actorToFire.fire();
      _debug(new FiringEvent(this,actorToFire,FiringEvent.AFTER_FIRE));
      _debug(new FiringEvent(this,actorToFire,FiringEvent.BEFORE_POSTFIRE));
      if (!actorToFire.postfire()) {
        _debug(""String_Node_Str"",((Nameable)actorToFire).getName());
        _disableActor(actorToFire);
        break;
      }
      _debug(new FiringEvent(this,actorToFire,FiringEvent.AFTER_POSTFIRE));
    }
 else {
      if (!((CompositeEntity)getContainer()).deepContains((NamedObj)actorToFire)) {
        _disableActor(actorToFire);
        break;
      }
      if (!actorToFire.prefire()) {
        break;
      }
      actorToFire.fire();
      if (!actorToFire.postfire()) {
        _disableActor(actorToFire);
        break;
      }
    }
    Iterator<?> inputPorts=actorToFire.inputPortList().iterator();
    while (inputPorts.hasNext() && !refire) {
      IOPort port=(IOPort)inputPorts.next();
      for (int i=0; i < port.getWidth(); i++) {
        if (port.hasToken(i)) {
          if (_debugging) {
            _debug(""String_Node_Str"" + port.getName() + ""String_Node_Str""+ i+ ""String_Node_Str"");
          }
          if (!_aspectsPresent || _schedule(actorToFire,getModelTime())) {
            refire=true;
            break;
          }
 else           if (_aspectsPresent) {
            if (_actorsInExecution == null) {
              _actorsInExecution=new HashMap();
            }
            List<DEEvent> events=_actorsInExecution.get(actorToFire);
            if (events == null) {
              events=new ArrayList<DEEvent>();
            }
            events.add(new DEEvent(actorToFire,getModelTime(),1,_getDepthOfActor(actorToFire)));
            _actorsInExecution.put(actorToFire,events);
          }
        }
      }
    }
  }
 while (refire);
  return 0;
}"
72795,"/** 
 * Parent constructor that replaces either targetEntity if replaceTargetEntity is true or otherwise all entities connected to it with a proxy instance (ProxySink or ProxySource).  The proxy actor is named the same as the original with addition of ""_remote"" suffix.  All links of the targetEntity are removed. The proxy actor dynamically adds ports that were present in the targetEntity (with the same port name) or and connects them to the targetEntity's relations.
 * @param container The container of the actor.
 * @param targetEntity the targetEntity to be replaced by a proxy
 * @param replaceTargetEntity if true replace the target entity with the proxy,otherwise replace all entities connecting to it with one proxy
 * @param portTypes Map of ports and their resolved types
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 * @exception CloneNotSupportedException If port cloning is not supported
 */
public ProxyActor(CompositeEntity container,ComponentEntity targetEntity,boolean replaceTargetEntity,HashMap<String,String> portTypes) throws IllegalActionException, NameDuplicationException, CloneNotSupportedException {
  this(container,targetEntity.getName() + ServerUtility.REMOTE_OBJECT_TAG);
  setTargetEntityName(targetEntity.getFullName());
  _targetEntityName.setExpression(getTargetEntityName());
  if (replaceTargetEntity) {
    _replaceTargetEntity(targetEntity,portTypes);
  }
 else {
    _replaceConnectingEntities(targetEntity,portTypes);
  }
}","/** 
 * Parent constructor that replaces either targetEntity if replaceTargetEntity is true or otherwise all entities connected to it with a proxy instance (ProxySink or ProxySource).  The proxy actor is named the same as the original with addition of ""_remote"" suffix.  All links of the targetEntity are removed. The proxy actor dynamically adds ports that were present in the targetEntity (with the same port name) or and connects them to the targetEntity's relations.
 * @param container The container of the actor.
 * @param targetEntity the targetEntity to be replaced by a proxy
 * @param replaceTargetEntity if true replace the target entity with the proxy,otherwise replace all entities connecting to it with one proxy
 * @param portTypes Map of ports and their resolved types
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 * @exception CloneNotSupportedException If port cloning is not supported
 */
public ProxyActor(CompositeEntity container,ComponentEntity targetEntity,boolean replaceTargetEntity,HashMap<String,String> portTypes) throws IllegalActionException, NameDuplicationException, CloneNotSupportedException {
  this(container,targetEntity.getName() + ServerUtility.REMOTE_OBJECT_TAG);
  System.out.println(""String_Node_Str"" + targetEntity.getName() + ServerUtility.REMOTE_OBJECT_TAG);
  setTargetEntityName(targetEntity.getFullName());
  _targetEntityName.setExpression(getTargetEntityName());
  if (replaceTargetEntity) {
    _replaceTargetEntity(targetEntity,portTypes);
  }
 else {
    _replaceConnectingEntities(targetEntity,portTypes);
  }
}"
72796,"/** 
 * Load the model that already has ProxySinks/Sources and set appropriate model types from the inferred model mapping. <p>This method is indented to be used on the Android to avoid loading unneeded actors.</p>
 * @exception IllegalActionException if there is a problem parsing model types orsetting types on Typeable objects.
 */
private void _loadPreprocessedModel() throws IllegalActionException {
  for (  Object obj : getTopLevelActor().deepEntityList()) {
    ComponentEntity actor=(ComponentEntity)obj;
    if (actor instanceof ProxySink) {
      ProxySink proxySink=(ProxySink)actor;
      proxySink.setTokenPublisher(_tokenPublisher);
      _proxySinkMap.put(proxySink.getTargetEntityName(),proxySink);
      proxySink.setProxyModelInfrastructure(this);
    }
 else     if (actor instanceof ProxySource) {
      ProxySource proxySource=(ProxySource)actor;
      ProxySourceData remoteSourceData=new ProxySourceData(proxySource);
      proxySource.setProxySourceData(remoteSourceData);
      proxySource.setProxyModelInfrastructure(this);
      getProxySourceMap().put(proxySource.getTargetEntityName(),remoteSourceData);
    }
    Type type;
    for (    Object portObject : actor.portList()) {
      if (portObject instanceof TypedIOPort) {
        TypedIOPort port=(TypedIOPort)portObject;
        if (port.deepConnectedPortList().isEmpty()) {
          continue;
        }
        StringAttribute targetPortName=(StringAttribute)port.getAttribute(""String_Node_Str"");
        if (targetPortName != null) {
          type=TypeParser.parse(_modelTypes.get(targetPortName.getExpression()));
          if (type != null) {
            port.setTypeEquals(type);
          }
          port.typeConstraints().clear();
        }
 else         if ((type=TypeParser.parse(_modelTypes.get(port.getFullName()))) != null) {
          port.setTypeEquals(type);
          port.typeConstraints().clear();
        }
 else {
          throw new IllegalActionException(port,""String_Node_Str"");
        }
      }
    }
    for (    Typeable attribute : actor.attributeList(Typeable.class)) {
      if ((type=TypeParser.parse(_modelTypes.get(((Nameable)attribute).getFullName()))) != null) {
        attribute.setTypeEquals(type);
        attribute.typeConstraints().clear();
      }
    }
  }
  ServerUtility.findRemoteAttributes(ServerUtility.deepAttributeList(_topLevelActor),_remoteAttributesMap);
}","/** 
 * Load the model that already has ProxySinks/Sources and set appropriate model types from the inferred model mapping. <p>This method is indented to be used on the Android to avoid loading unneeded actors.</p>
 * @exception IllegalActionException if there is a problem parsing model types orsetting types on Typeable objects.
 */
private void _loadPreprocessedModel() throws IllegalActionException {
  for (  Object obj : getTopLevelActor().deepEntityList()) {
    ComponentEntity actor=(ComponentEntity)obj;
    if (actor instanceof ProxySink) {
      ProxySink proxySink=(ProxySink)actor;
      proxySink.setTokenPublisher(_tokenPublisher);
      _proxySinkMap.put(proxySink.getTargetEntityName(),proxySink);
      proxySink.setProxyModelInfrastructure(this);
    }
 else     if (actor instanceof ProxySource) {
      ProxySource proxySource=(ProxySource)actor;
      ProxySourceData remoteSourceData=new ProxySourceData(proxySource);
      proxySource.setProxySourceData(remoteSourceData);
      proxySource.setProxyModelInfrastructure(this);
      getProxySourceMap().put(proxySource.getTargetEntityName(),remoteSourceData);
    }
    Type type;
    for (    Object portObject : actor.portList()) {
      if (portObject instanceof TypedIOPort) {
        TypedIOPort port=(TypedIOPort)portObject;
        if (port.deepConnectedPortList().isEmpty()) {
          continue;
        }
        StringAttribute targetPortName=(StringAttribute)port.getAttribute(""String_Node_Str"");
        if (targetPortName != null) {
          type=TypeParser.parse(_modelTypes.get(targetPortName.getExpression()));
          if (type != null) {
            port.setTypeEquals(type);
          }
          port.typeConstraints().clear();
        }
 else         if ((type=TypeParser.parse(_modelTypes.get(port.getFullName()))) != null) {
          port.setTypeEquals(type);
          port.typeConstraints().clear();
        }
 else {
          throw new IllegalActionException(port,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ _modelTypes);
        }
      }
    }
    for (    Typeable attribute : actor.attributeList(Typeable.class)) {
      if ((type=TypeParser.parse(_modelTypes.get(((Nameable)attribute).getFullName()))) != null) {
        attribute.setTypeEquals(type);
        attribute.typeConstraints().clear();
      }
    }
  }
  ServerUtility.findRemoteAttributes(ServerUtility.deepAttributeList(_topLevelActor),_remoteAttributesMap);
}"
72797,"/** 
 * Look up and return the attribute with the specified name in the scope. Return null if such an attribute does not exist.
 * @param name The name of the attribute.
 * @return The attribute with the specified name in the scope.
 * @exception IllegalActionException If a value in the scopeexists with the given name, but cannot be evaluated.
 */
public synchronized Variable getVariable(String name) throws IllegalActionException {
  if (_variablesDependentOn == null) {
    _variablesDependentOn=new HashMap<String,Variable>();
  }
 else {
    if (_variablesDependentOnVersion == workspace().getVersion()) {
      Variable result=(Variable)_variablesDependentOn.get(name);
      if (result != null) {
        return result;
      }
    }
 else {
      _variablesDependentOn.clear();
    }
  }
  _variablesDependentOnVersion=workspace().getVersion();
  NamedObj reference=_reference;
  if (_reference == null) {
    reference=Variable.this.getContainer();
  }
  Variable result=getScopedVariable(Variable.this,reference,name);
  if (result != null) {
    if (!_variablesDependentOn.containsValue(result)) {
      result.addValueListener(Variable.this);
      _variablesDependentOn.put(name,result);
    }
    return result;
  }
 else {
    return null;
  }
}","/** 
 * Look up and return the attribute with the specified name in the scope. Return null if such an attribute does not exist. This method acquires read permission on the workspace.
 * @param name The name of the attribute.
 * @return The attribute with the specified name in the scope.
 * @exception IllegalActionException If a value in the scopeexists with the given name, but cannot be evaluated.
 */
public Variable getVariable(String name) throws IllegalActionException {
  workspace().getReadAccess();
  try {
    NamedObj reference=_reference;
    if (_reference == null) {
      reference=Variable.this.getContainer();
    }
    Variable result=getScopedVariable(Variable.this,reference,name);
    if (result != null) {
      result.addValueListener(Variable.this);
synchronized (Variable.this) {
        if (_variablesDependentOn == null) {
          _variablesDependentOn=new HashMap<String,Variable>();
        }
        _variablesDependentOn.put(name,result);
      }
    }
    return result;
  }
  finally {
    workspace().doneReading();
  }
}"
72798,"/** 
 * Invoke the wrapup() of the super class. Then, quit OpenModelica environment.
 * @exception IllegalActionException If OMC server is unable to stop.
 */
public void wrapup() throws IllegalActionException {
  super.wrapup();
  try {
    _omcCommand.stopServer();
    String loggerInfo=""String_Node_Str"";
    _omcLogger.getInfo(loggerInfo);
    _omcLogger.destroy();
  }
 catch (  ConnectException e) {
    new IllegalActionException(""String_Node_Str"" + e.getMessage()).printStackTrace();
  }
}","/** 
 * Invoke the wrapup() of the super class. Then, quit OpenModelica environment.
 * @exception IllegalActionException If OMC server is unable to stop.
 */
public void wrapup() throws IllegalActionException {
  super.wrapup();
  try {
    _omcCommand.stopServer();
    String loggerInfo=""String_Node_Str"";
    _omcLogger.getInfo(loggerInfo);
  }
 catch (  ConnectException e) {
    e.printStackTrace();
  }
}"
72799,"/** 
 * Invoke the fire() of the super class. Then, Modelica library and model(s) are loaded. Upon modifying the value of variable(s) and parameter(s) by input port or actors' parameters, the Modelica model is built in <i>non-interactive</i> or <i>interactive</i> mode. <p>After building the model in an interactive mode, the simulation result is calculated step by step according to the parameters of the OpenModelica actor. The result is sent in the string format to the output port of the OpenModelica actor to be displayed by Display actor.</p>
 * @exception IllegalActionException If the evaluation of the expressiontriggers it, or the evaluation yields a null result, or the evaluation yields an incompatible type, or if there is no director.
 */
public void fire() throws IllegalActionException {
  super.fire();
  try {
    _omcCommand.loadModelicaFile(fileName.getExpression(),subModel.getExpression());
    if (!(dependencies.getExpression().isEmpty() && baseModel.getExpression().isEmpty()))     _omcCommand.loadModelicaFile(dependencies.getExpression(),baseModel.getExpression());
  }
 catch (  ConnectException e) {
    throw new IllegalActionException(""String_Node_Str"" + e.getMessage());
  }
  if (input.getWidth() > 0) {
    IntToken inputPort=(IntToken)input.get(0);
    try {
      if (!(parameter.getExpression().isEmpty() && initialValue.getExpression().isEmpty())) {
        if (!(baseModel.getExpression().isEmpty())) {
          _omcCommand.modifyComponents(inputPort.toString(),baseModel.getExpression(),parameter.getExpression());
        }
 else {
          _omcCommand.modifyComponents(inputPort.toString(),subModel.getExpression(),parameter.getExpression());
        }
      }
 else {
        _omcLogger.getInfo(""String_Node_Str"");
      }
    }
 catch (    ConnectException e) {
      throw new IllegalActionException(""String_Node_Str"" + e.getMessage());
    }
  }
 else   if (!(input.getWidth() > 0)) {
    if (!(parameter.getExpression().isEmpty() && initialValue.getExpression().isEmpty())) {
      try {
        if (baseModel.getExpression().isEmpty()) {
          _omcCommand.modifyComponents(initialValue.getExpression(),subModel.getExpression(),parameter.getExpression());
        }
 else {
          _omcCommand.modifyComponents(initialValue.getExpression(),baseModel.getExpression(),parameter.getExpression());
        }
      }
 catch (      ConnectException e) {
        throw new IllegalActionException(""String_Node_Str"" + baseModel.getExpression() + ""String_Node_Str""+ e.getMessage());
      }
    }
 else {
      _omcLogger.getInfo(""String_Node_Str"");
    }
  }
  try {
    if (!(dependencies.getExpression().isEmpty() && baseModel.getExpression().isEmpty())) {
      _omcCommand.runModel(dependencies.getExpression(),baseModel.getExpression(),simulationStartTime.getExpression(),simulationStopTime.getExpression(),Integer.parseInt(numberOfIntervals.getExpression()),outputFormat.getExpression(),processingMode.getExpression());
      if (outputFormat.getExpression().equalsIgnoreCase(""String_Node_Str"") && processingMode.getExpression().equalsIgnoreCase(""String_Node_Str"")) {
        _omcCommand.plotPltFile(baseModel.getExpression());
      }
    }
 else {
      _omcCommand.runModel(fileName.getExpression(),subModel.getExpression(),simulationStartTime.getExpression(),simulationStopTime.getExpression(),Integer.parseInt(numberOfIntervals.getExpression()),outputFormat.getExpression(),processingMode.getExpression());
      if (outputFormat.getExpression().equalsIgnoreCase(""String_Node_Str"") && processingMode.getExpression().equalsIgnoreCase(""String_Node_Str"")) {
        _omcCommand.plotPltFile(subModel.getExpression());
      }
    }
    if (processingMode.getExpression().equalsIgnoreCase(""String_Node_Str"")) {
      _omiThread=new OMIThread(variableFilter.getExpression(),simulationStopTime.getExpression(),output);
      _omiThread.run();
    }
  }
 catch (  UnknownHostException e) {
    throw new IllegalActionException(e.getMessage());
  }
catch (  IOException e) {
    throw new IllegalActionException(e.getMessage());
  }
catch (  ConnectException e) {
    throw new IllegalActionException(""String_Node_Str"" + e.getMessage());
  }
}","/** 
 * Invoke the fire() of the super class. Then, Modelica library and model(s) are loaded. Upon modifying the value of variable(s) and parameter(s) by input port or actors' parameters, the Modelica model is built in <i>non-interactive</i> or <i>interactive</i> mode. <p>After building the model in an interactive mode, the simulation result is calculated step by step according to the parameters of the OpenModelica actor. The result is sent in the string format to the output port of the OpenModelica actor to be displayed by Display actor.</p>
 * @exception IllegalActionException If the evaluation of the expressiontriggers it, or the evaluation yields a null result, or the evaluation yields an incompatible type, or if there is no director.
 */
public void fire() throws IllegalActionException {
  super.fire();
  try {
    _omcCommand.loadModelicaFile(fileName.getExpression(),subModel.getExpression());
    if (!(dependencies.getExpression().isEmpty() && baseModel.getExpression().isEmpty()))     _omcCommand.loadModelicaFile(dependencies.getExpression(),baseModel.getExpression());
  }
 catch (  ConnectException e) {
    throw new IllegalActionException(""String_Node_Str"" + e.getMessage());
  }
  if (input.getWidth() > 0) {
    IntToken inputPort=(IntToken)input.get(0);
    try {
      if (!(parameter.getExpression().isEmpty() && initialValue.getExpression().isEmpty())) {
        if (!(baseModel.getExpression().isEmpty())) {
          _omcCommand.modifyComponents(inputPort.toString(),baseModel.getExpression(),parameter.getExpression());
        }
 else {
          _omcCommand.modifyComponents(inputPort.toString(),subModel.getExpression(),parameter.getExpression());
        }
      }
 else {
        _omcLogger.getInfo(""String_Node_Str"");
      }
    }
 catch (    ConnectException e) {
      throw new IllegalActionException(""String_Node_Str"" + e.getMessage());
    }
  }
 else   if (!(input.getWidth() > 0)) {
    if (!(parameter.getExpression().isEmpty() && initialValue.getExpression().isEmpty())) {
      try {
        if (baseModel.getExpression().isEmpty()) {
          _omcCommand.modifyComponents(initialValue.getExpression(),subModel.getExpression(),parameter.getExpression());
        }
 else {
          _omcCommand.modifyComponents(initialValue.getExpression(),baseModel.getExpression(),parameter.getExpression());
        }
      }
 catch (      ConnectException e) {
        throw new IllegalActionException(""String_Node_Str"" + baseModel.getExpression() + ""String_Node_Str""+ e.getMessage());
      }
    }
 else {
      _omcLogger.getInfo(""String_Node_Str"");
    }
  }
  try {
    if (!(dependencies.getExpression().isEmpty() && baseModel.getExpression().isEmpty())) {
      _omcCommand.runModel(dependencies.getExpression(),baseModel.getExpression(),simulationStartTime.getExpression(),simulationStopTime.getExpression(),Integer.parseInt(numberOfIntervals.getExpression()),outputFormat.getExpression(),processingMode.getExpression());
      if (outputFormat.getExpression().equalsIgnoreCase(""String_Node_Str"") && processingMode.getExpression().equalsIgnoreCase(""String_Node_Str"")) {
        _omcCommand.plotPltFile(baseModel.getExpression());
      }
    }
 else {
      _omcCommand.runModel(fileName.getExpression(),subModel.getExpression(),simulationStartTime.getExpression(),simulationStopTime.getExpression(),Integer.parseInt(numberOfIntervals.getExpression()),outputFormat.getExpression(),processingMode.getExpression());
      if (outputFormat.getExpression().equalsIgnoreCase(""String_Node_Str"") && processingMode.getExpression().equalsIgnoreCase(""String_Node_Str"")) {
        _omcCommand.plotPltFile(subModel.getExpression());
      }
    }
    if (processingMode.getExpression().equalsIgnoreCase(""String_Node_Str"")) {
      _omiThread=new OMIThread(variableFilter.getExpression(),simulationStopTime.getExpression(),output);
      _omiThread.run();
    }
  }
 catch (  UnknownHostException e) {
    e.printStackTrace();
    throw new IllegalActionException(""String_Node_Str"" + e.getMessage());
  }
catch (  IOException e) {
    e.printStackTrace();
    throw new IllegalActionException(""String_Node_Str"" + e.getMessage());
  }
catch (  ConnectException e) {
    e.printStackTrace();
    throw new IllegalActionException(""String_Node_Str"" + e.getMessage());
  }
}"
72800,"/** 
 * load the Modelica file and library.
 * @param fileName File that the (base-)model should be loaded from.
 * @param modelName Name of the (base-)model that should be built.
 * @exception ConnectException If commands couldn'tbe sent to the (OpenModelic Compiler)OMC.
 * @exception FileNotFoundException If no file found at the selective path for loading.
 */
public void loadModelicaFile(String fileName,String modelName) throws ConnectException {
  String loggerInfo=null;
  _filePath=_systemPath + ""String_Node_Str"" + fileName;
  File file=new File(_filePath.toString());
  if (file.exists()) {
    loggerInfo=fileName + ""String_Node_Str"" + _filePath;
    _omcLogger.getInfo(loggerInfo);
    CompilerResult loadFileInteractiveQualifiedResult=sendCommand(""String_Node_Str"" + _filePath + ""String_Node_Str"");
    if (!loadFileInteractiveQualifiedResult.getFirstResult().isEmpty() && loadFileInteractiveQualifiedResult.getError().isEmpty()) {
      loggerInfo=modelName + ""String_Node_Str"" + _filePath+ ""String_Node_Str"";
      _omcLogger.getInfo(loggerInfo);
    }
 else     if (!loadFileInteractiveQualifiedResult.getError().isEmpty()) {
      loggerInfo=loadFileInteractiveQualifiedResult.getError();
      _omcLogger.getInfo(loggerInfo);
      throw new ConnectException(loggerInfo);
    }
    CompilerResult loadModelResult=sendCommand(""String_Node_Str"");
    if (loadModelResult.getFirstResult().compareTo(""String_Node_Str"") == 0) {
      loggerInfo=""String_Node_Str"";
      _omcLogger.getInfo(loggerInfo);
    }
 else     if (!loadModelResult.getError().isEmpty()) {
      loggerInfo=loadModelResult.getError();
      _omcLogger.getInfo(loggerInfo);
      throw new ConnectException(loggerInfo);
    }
  }
 else {
    throw new ConnectException(""String_Node_Str"" + _filePath);
  }
}","/** 
 * load the Modelica file and library.
 * @param fileName File that the (base-)model should be loaded from.
 * @param modelName Name of the (base-)model that should be built.
 * @exception ConnectException If commands couldn'tbe sent to the (OpenModelic Compiler)OMC.
 * @exception FileNotFoundException If no file found at the selective path for loading.
 */
public void loadModelicaFile(String fileName,String modelName) throws ConnectException {
  String loggerInfo=null;
  _filePath=_ptIISystemPath + ""String_Node_Str"" + fileName;
  File file=new File(_filePath.toString());
  if (file.exists()) {
    loggerInfo=fileName + ""String_Node_Str"" + _filePath;
    _omcLogger.getInfo(loggerInfo);
    CompilerResult loadFileInteractiveQualifiedResult=sendCommand(""String_Node_Str"" + _filePath + ""String_Node_Str"");
    if (!loadFileInteractiveQualifiedResult.getFirstResult().isEmpty() && loadFileInteractiveQualifiedResult.getError().isEmpty()) {
      loggerInfo=modelName + ""String_Node_Str"" + _filePath+ ""String_Node_Str"";
      _omcLogger.getInfo(loggerInfo);
    }
 else     if (!loadFileInteractiveQualifiedResult.getError().isEmpty()) {
      loggerInfo=loadFileInteractiveQualifiedResult.getError();
      _omcLogger.getInfo(loggerInfo);
      throw new ConnectException(loggerInfo);
    }
    CompilerResult loadModelResult=sendCommand(""String_Node_Str"");
    if (loadModelResult.getFirstResult().compareTo(""String_Node_Str"") == 0) {
      loggerInfo=""String_Node_Str"";
      _omcLogger.getInfo(loggerInfo);
    }
 else     if (!loadModelResult.getError().isEmpty()) {
      loggerInfo=loadModelResult.getError();
      _omcLogger.getInfo(loggerInfo);
      throw new ConnectException(loggerInfo);
    }
  }
 else {
    throw new ConnectException(""String_Node_Str"" + _filePath);
  }
}"
72801,"/** 
 * Leave OpenModelica environment, destroy the OMC process and deallocate OMCCommand object.
 * @exception ConnectException If quit command couldn't be sent to OMC.
 */
public void stopServer() throws ConnectException {
  if (hasInitialized) {
    sendCommand(""String_Node_Str"");
    _omcCommandInstance=null;
    if (_omcProcess != null) {
      _omcProcess.destroy();
    }
  }
}","/** 
 * Leave OpenModelica environment, destroy the OMC process and deallocate OMCCommand object.
 * @exception ConnectException If quit command couldn't be sent to OMC.
 */
public void stopServer() throws ConnectException {
  if (hasInitialized) {
    sendCommand(""String_Node_Str"");
    _omcCommandInstance=null;
    _omcLogger=null;
  }
}"
72802,"/** 
 * Modify parameter(s) and variable(s) of the Modelica model before building the Modelica model.
 * @param values The new values to change the value of the components.
 * @param modelName The (base-)model that should be built.
 * @param components The name of the components to change.
 * @exception ConnectException If commands couldn'tbe sent to the (OpenModelica Compiler)OMC.
 * @exception IllegalActionException
 */
public void modifyComponents(String values,String modelName,String components) throws IllegalActionException, ConnectException {
  String childModel=modelName;
  String childKey=null;
  String loggerInfo=null;
  boolean found=false;
  HashMap<String,String> baseIndividualComponent=null;
  HashMap<String,String> childIndividualComponent=null;
  CompilerResult getComponentModifierNames=null;
  CompilerResult getNthInheritanceClassResult=null;
  String parameterDelimiter=""String_Node_Str"";
  String valueDelimiter=""String_Node_Str"";
  String[] parameterList=components.split(parameterDelimiter);
  String[] valueList=values.split(valueDelimiter);
  String[] variableList=null;
  try {
    childIndividualComponent=getModelComponent(childModel);
    if (childIndividualComponent != null) {
      if (parameterList.length == valueList.length) {
        for (int i=0; i < parameterList.length; i++) {
          if (getInheritanceCount(childModel)) {
            for (int j=1; j <= 2; j++) {
              getNthInheritanceClassResult=sendCommand(""String_Node_Str"" + childModel + ""String_Node_Str""+ j+ ""String_Node_Str"");
              if (getNthInheritanceClassResult.getError().isEmpty() && !getNthInheritanceClassResult.getFirstResult().trim().toString().contains(""String_Node_Str"")) {
                baseIndividualComponent=getModelComponent(getNthInheritanceClassResult.getFirstResult().toString());
                if (baseIndividualComponent != null) {
                  Iterator baseIterator=baseIndividualComponent.keySet().iterator();
                  while (baseIterator.hasNext()) {
                    String key=baseIterator.next().toString();
                    if (parameterList[i].equalsIgnoreCase(key)) {
                      found=true;
                      CompilerResult extendModifierValueResult=sendCommand(""String_Node_Str"" + childModel + ""String_Node_Str""+ getNthInheritanceClassResult.getFirstResult().trim().toString()+ ""String_Node_Str""+ key+ ""String_Node_Str""+ valueList[i]+ ""String_Node_Str"");
                      if (extendModifierValueResult.getError().isEmpty() && !extendModifierValueResult.getFirstResult().trim().toString().contains(""String_Node_Str"")) {
                        loggerInfo=""String_Node_Str"" + key + ""String_Node_Str""+ getNthInheritanceClassResult.getFirstResult().trim().toString()+ ""String_Node_Str""+ valueList[i]+ ""String_Node_Str"";
                        _omcLogger.getInfo(loggerInfo);
                      }
 else {
                        loggerInfo=extendModifierValueResult.getError();
                        _omcLogger.getInfo(loggerInfo);
                        throw new ConnectException(loggerInfo);
                      }
                    }
                  }
                }
              }
            }
          }
          Iterator childIterator=childIndividualComponent.keySet().iterator();
          while (childIterator.hasNext()) {
            childKey=childIterator.next().toString();
            if (childKey.equalsIgnoreCase(parameterList[i])) {
              found=true;
              if (childIndividualComponent.get(childKey).compareTo(""String_Node_Str"") == 0) {
                getComponentModifierNames=sendCommand(""String_Node_Str"" + modelName + ""String_Node_Str""+ childKey+ ""String_Node_Str"");
                if (!getComponentModifierNames.getError().toString().isEmpty()) {
                  _omcLogger.getInfo(getComponentModifierNames.getError().toString());
                }
                if (getComponentModifierNames.getFirstResult().trim().compareTo(""String_Node_Str"") == 0) {
                  CompilerResult unspecifiedModifier=sendCommand(""String_Node_Str"" + modelName + ""String_Node_Str""+ childKey+ ""String_Node_Str""+ valueList[i]+ ""String_Node_Str"");
                  if (unspecifiedModifier.getError().toString().isEmpty()) {
                    _omcLogger.getInfo(""String_Node_Str"" + childKey + ""String_Node_Str""+ modelName+ ""String_Node_Str""+ valueList[i]+ ""String_Node_Str"");
                  }
                }
 else {
                  StringBuffer componentsBuffer=new StringBuffer(getComponentModifierNames.getFirstResult().trim().toString());
                  componentsBuffer.deleteCharAt(0);
                  String variableNames=componentsBuffer.deleteCharAt(componentsBuffer.length() - 1).toString();
                  variableList=variableNames.split(valueDelimiter);
                  for (                  String variables : variableList) {
                    String tempParameter=childKey + ""String_Node_Str"" + variables;
                    CompilerResult setComponentModifierValueResult=sendCommand(""String_Node_Str"" + modelName + ""String_Node_Str""+ tempParameter+ ""String_Node_Str""+ valueList[i]+ ""String_Node_Str"");
                    if (setComponentModifierValueResult.getError().toString().isEmpty()) {
                      loggerInfo=""String_Node_Str"" + childKey + ""String_Node_Str""+ variables+ ""String_Node_Str""+ modelName+ ""String_Node_Str""+ valueList[i]+ ""String_Node_Str"";
                      _omcLogger.getInfo(loggerInfo);
                    }
 else {
                      loggerInfo=setComponentModifierValueResult.getError();
                      _omcLogger.getInfo(loggerInfo);
                    }
                  }
                }
              }
              if (childIndividualComponent.get(childKey).compareTo(""String_Node_Str"") == 0) {
                CompilerResult parameterChange=sendCommand(""String_Node_Str"" + modelName + ""String_Node_Str""+ childKey+ ""String_Node_Str""+ valueList[i]+ ""String_Node_Str"");
                if (parameterChange.getError().toString().isEmpty()) {
                  loggerInfo=""String_Node_Str"" + childKey + ""String_Node_Str""+ modelName+ ""String_Node_Str""+ valueList[i]+ ""String_Node_Str"";
                  _omcLogger.getInfo(loggerInfo);
                }
 else {
                  loggerInfo=getNthInheritanceClassResult.getError();
                  _omcLogger.getInfo(loggerInfo);
                }
              }
 else               if (childIndividualComponent.get(childKey).compareTo(""String_Node_Str"") == 0) {
                _omcLogger.getInfo(""String_Node_Str"" + components + ""String_Node_Str""+ modelName+ ""String_Node_Str"");
              }
            }
          }
        }
        if (!found) {
          _omcLogger.getInfo(components + ""String_Node_Str"" + modelName+ ""String_Node_Str"");
        }
      }
 else {
        _omcLogger.getInfo(""String_Node_Str"");
      }
    }
  }
 catch (  Exception e) {
    throw new IllegalActionException(e.getMessage());
  }
}","/** 
 * Modify parameter(s) and variable(s) of the Modelica model before building the model.
 * @param values The new values to change the value of the components.
 * @param modelName The (base-)model that should be built.
 * @param components The name of the components to change.
 * @exception ConnectException If commands couldn'tbe sent to the (OpenModelica Compiler)OMC.
 * @exception IllegalActionException
 */
public void modifyComponents(String values,String modelName,String components) throws IllegalActionException, ConnectException {
  String childModel=modelName;
  String childKey=null;
  String loggerInfo=null;
  boolean found=false;
  HashMap<String,String> baseIndividualComponent=null;
  HashMap<String,String> childIndividualComponent=null;
  CompilerResult getComponentModifierNames=null;
  CompilerResult getNthInheritanceClassResult=null;
  String parameterDelimiter=""String_Node_Str"";
  String valueDelimiter=""String_Node_Str"";
  String[] parameterList=components.split(parameterDelimiter);
  String[] valueList=values.split(valueDelimiter);
  String[] variableList=null;
  try {
    childIndividualComponent=getModelComponent(childModel);
    if (childIndividualComponent != null) {
      if (parameterList.length == valueList.length) {
        for (int i=0; i < parameterList.length; i++) {
          if (getInheritanceCount(childModel)) {
            for (int j=1; j <= 2; j++) {
              getNthInheritanceClassResult=sendCommand(""String_Node_Str"" + childModel + ""String_Node_Str""+ j+ ""String_Node_Str"");
              if (getNthInheritanceClassResult.getError().isEmpty() && !getNthInheritanceClassResult.getFirstResult().trim().toString().contains(""String_Node_Str"")) {
                baseIndividualComponent=getModelComponent(getNthInheritanceClassResult.getFirstResult().toString());
                if (baseIndividualComponent != null) {
                  Iterator baseIterator=baseIndividualComponent.keySet().iterator();
                  while (baseIterator.hasNext()) {
                    String key=baseIterator.next().toString();
                    if (parameterList[i].equalsIgnoreCase(key)) {
                      found=true;
                      CompilerResult extendModifierValueResult=sendCommand(""String_Node_Str"" + childModel + ""String_Node_Str""+ getNthInheritanceClassResult.getFirstResult().trim().toString()+ ""String_Node_Str""+ key+ ""String_Node_Str""+ valueList[i]+ ""String_Node_Str"");
                      if (extendModifierValueResult.getError().isEmpty() && !extendModifierValueResult.getFirstResult().trim().toString().contains(""String_Node_Str"")) {
                        loggerInfo=""String_Node_Str"" + key + ""String_Node_Str""+ getNthInheritanceClassResult.getFirstResult().trim().toString()+ ""String_Node_Str""+ valueList[i]+ ""String_Node_Str"";
                        _omcLogger.getInfo(loggerInfo);
                      }
 else {
                        loggerInfo=extendModifierValueResult.getError();
                        _omcLogger.getInfo(loggerInfo);
                        throw new ConnectException(loggerInfo);
                      }
                    }
                  }
                }
              }
            }
          }
          Iterator childIterator=childIndividualComponent.keySet().iterator();
          while (childIterator.hasNext()) {
            childKey=childIterator.next().toString();
            if (childKey.equalsIgnoreCase(parameterList[i])) {
              found=true;
              if (childIndividualComponent.get(childKey).compareTo(""String_Node_Str"") == 0) {
                getComponentModifierNames=sendCommand(""String_Node_Str"" + modelName + ""String_Node_Str""+ childKey+ ""String_Node_Str"");
                if (!getComponentModifierNames.getError().toString().isEmpty()) {
                  _omcLogger.getInfo(getComponentModifierNames.getError().toString());
                }
                if (getComponentModifierNames.getFirstResult().trim().compareTo(""String_Node_Str"") == 0) {
                  CompilerResult unspecifiedModifier=sendCommand(""String_Node_Str"" + modelName + ""String_Node_Str""+ childKey+ ""String_Node_Str""+ valueList[i]+ ""String_Node_Str"");
                  if (unspecifiedModifier.getError().toString().isEmpty()) {
                    _omcLogger.getInfo(""String_Node_Str"" + childKey + ""String_Node_Str""+ modelName+ ""String_Node_Str""+ valueList[i]+ ""String_Node_Str"");
                  }
                }
 else {
                  StringBuffer componentsBuffer=new StringBuffer(getComponentModifierNames.getFirstResult().trim().toString());
                  componentsBuffer.deleteCharAt(0);
                  String variableNames=componentsBuffer.deleteCharAt(componentsBuffer.length() - 1).toString();
                  variableList=variableNames.split(valueDelimiter);
                  for (                  String variables : variableList) {
                    String tempParameter=childKey + ""String_Node_Str"" + variables;
                    CompilerResult setComponentModifierValueResult=sendCommand(""String_Node_Str"" + modelName + ""String_Node_Str""+ tempParameter+ ""String_Node_Str""+ valueList[i]+ ""String_Node_Str"");
                    if (setComponentModifierValueResult.getError().toString().isEmpty()) {
                      loggerInfo=""String_Node_Str"" + childKey + ""String_Node_Str""+ variables+ ""String_Node_Str""+ modelName+ ""String_Node_Str""+ valueList[i]+ ""String_Node_Str"";
                      _omcLogger.getInfo(loggerInfo);
                    }
 else {
                      loggerInfo=setComponentModifierValueResult.getError();
                      _omcLogger.getInfo(loggerInfo);
                    }
                  }
                }
              }
              if (childIndividualComponent.get(childKey).compareTo(""String_Node_Str"") == 0) {
                CompilerResult parameterChange=sendCommand(""String_Node_Str"" + modelName + ""String_Node_Str""+ childKey+ ""String_Node_Str""+ valueList[i]+ ""String_Node_Str"");
                if (parameterChange.getError().toString().isEmpty()) {
                  loggerInfo=""String_Node_Str"" + childKey + ""String_Node_Str""+ modelName+ ""String_Node_Str""+ valueList[i]+ ""String_Node_Str"";
                  _omcLogger.getInfo(loggerInfo);
                }
 else {
                  loggerInfo=getNthInheritanceClassResult.getError();
                  _omcLogger.getInfo(loggerInfo);
                }
              }
 else               if (childIndividualComponent.get(childKey).compareTo(""String_Node_Str"") == 0) {
                _omcLogger.getInfo(""String_Node_Str"" + components + ""String_Node_Str""+ modelName+ ""String_Node_Str"");
              }
            }
          }
        }
        if (!found) {
          _omcLogger.getInfo(components + ""String_Node_Str"" + modelName+ ""String_Node_Str"");
        }
      }
 else {
        _omcLogger.getInfo(""String_Node_Str"");
      }
    }
  }
 catch (  Exception e) {
    throw new IllegalActionException(e.getMessage());
  }
}"
72803,"/** 
 * Find the OpenModelica Compiler(OMC) executable file by using path variables.
 * @param executableName The name of the executable file
 * @return File The OMC executable file
 */
private File _findExecutableOnPath(String executableName){
  String systemPath=System.getenv(""String_Node_Str"");
  if (systemPath == null) {
    systemPath=System.getenv(""String_Node_Str"");
  }
  String[] pathDirs=systemPath.split(File.pathSeparator);
  File fullyQualifiedExecutable=null;
  for (  String pathDir : pathDirs) {
    File file=new File(pathDir,executableName);
    if (file.isFile()) {
      fullyQualifiedExecutable=file;
      break;
    }
  }
  return fullyQualifiedExecutable;
}","/** 
 * Find the OpenModelica Compiler(OMC) executable file by using path variables.
 * @param executableName The name of the executable file
 * @return File The OMC executable file
 */
private File _findExecutableOnPath(String executableName){
  if (_openModelicaSystemPath == null) {
    _openModelicaSystemPath=System.getenv(""String_Node_Str"");
  }
  String[] pathDirs=_openModelicaSystemPath.split(File.pathSeparator);
  File fullyQualifiedExecutable=null;
  for (  String pathDir : pathDirs) {
    File file=new File(pathDir,executableName);
    if (file.isFile()) {
      fullyQualifiedExecutable=file;
      break;
    }
  }
  return fullyQualifiedExecutable;
}"
72804,"/** 
 * Determine the path to the (OpenModelica Compiler)OMC binary that user (probably) wants to use and the working directory of where that binary (most likely) should be started in. This will returns for example 'c:\openmodelica132\omc.exe' or '/usr/local/share/openmodelica/omc' depending on such factors as: OS type, environmental Variables settings, where the first matching binary found.
 * @return full path to the OMC binary and the working folder.
 * @exception ConnectException If OPENMODELICAHOME is not setand we could not find binary file in the path.
 */
private File[] _getOmcBinaryPaths() throws ConnectException {
  String binaryName=""String_Node_Str"";
  if (_os == _osType.WINDOWS) {
    binaryName+=""String_Node_Str"";
  }
  File omcBinary=null;
  File omcWorkingDirectory=null;
  File openModelicaHomeDirectory=null;
  String loggerInfo=""String_Node_Str"";
  _omcLogger.getInfo(loggerInfo);
  String openModelicaHome=System.getenv(""String_Node_Str"");
  if (openModelicaHome == null) {
    loggerInfo=""String_Node_Str"";
    _omcLogger.getInfo(loggerInfo);
    File omc=_findExecutableOnPath(binaryName);
    if (omc != null) {
      loggerInfo=""String_Node_Str"" + omc.getAbsolutePath();
      _omcLogger.getInfo(loggerInfo);
      openModelicaHome=omc.getParentFile().getParentFile().getAbsolutePath();
    }
 else {
      final String m=""String_Node_Str"" + binaryName + ""String_Node_Str"";
      _omcLogger.getInfo(m);
      throw new ConnectException(m);
    }
  }
  openModelicaHomeDirectory=new File(openModelicaHome);
  String[] subdirs={""String_Node_Str""};
  for (  String subdir : subdirs) {
    String path=openModelicaHomeDirectory.getAbsolutePath() + File.separator;
    path+=subdir.equals(""String_Node_Str"") ? binaryName : subdir + File.separator + binaryName;
    File file=new File(path);
    if (file.exists()) {
      omcBinary=file;
      loggerInfo=""String_Node_Str"" + omcBinary.getAbsolutePath() + ""String_Node_Str"";
      _omcLogger.getInfo(loggerInfo);
      break;
    }
 else {
      loggerInfo=""String_Node_Str"" + path + ""String_Node_Str"";
      _omcLogger.getInfo(loggerInfo);
    }
  }
  if (omcBinary == null) {
    loggerInfo=""String_Node_Str"";
    _omcLogger.getInfo(loggerInfo);
    throw new ConnectException(loggerInfo);
  }
switch (getOs()) {
case WINDOWS:
    if (_username == null) {
      System.err.println(""String_Node_Str"");
      omcWorkingDirectory=new File(_temp + ""String_Node_Str"");
    }
 else {
      omcWorkingDirectory=new File(_temp + _username + ""String_Node_Str"");
    }
  break;
case UNIX:
if (_username == null) {
  System.err.println(""String_Node_Str"");
  omcWorkingDirectory=new File(_temp + ""String_Node_Str"");
}
 else {
  omcWorkingDirectory=new File(_temp + ""String_Node_Str"" + _username+ ""String_Node_Str"");
}
break;
case MAC:
if (_username == null) {
System.err.println(""String_Node_Str"");
omcWorkingDirectory=new File(_temp + ""String_Node_Str"");
}
 else {
omcWorkingDirectory=new File(_temp + _username + ""String_Node_Str"");
}
break;
}
return new File[]{omcBinary,omcWorkingDirectory};
}","/** 
 * Determine the path to the (OpenModelica Compiler)OMC binary that user (probably) wants to use and the working directory of where that binary (most likely) should be started in. This will returns for example 'c:\openmodelica132\omc.exe' or '/usr/local/share/openmodelica/omc' depending on such factors as: OS type, environmental Variables settings, where the first matching binary found.
 * @return full path to the OMC binary and the working folder.
 * @exception ConnectException If OPENMODELICAHOME is not setand we could not find binary file in the path.
 */
private File[] _getOmcBinaryPaths() throws ConnectException {
  String binaryName=""String_Node_Str"";
  if (_os == _osType.WINDOWS) {
    binaryName+=""String_Node_Str"";
  }
  File omcBinary=null;
  File omcWorkingDirectory=null;
  File openModelicaHomeDirectory=null;
  String loggerInfo=""String_Node_Str"";
  _omcLogger.getInfo(loggerInfo);
  if (_openModelicaHome == null) {
    loggerInfo=""String_Node_Str"";
    _omcLogger.getInfo(loggerInfo);
    File omc=_findExecutableOnPath(binaryName);
    if (omc != null) {
      loggerInfo=""String_Node_Str"" + omc.getAbsolutePath();
      _omcLogger.getInfo(loggerInfo);
      _openModelicaHome=omc.getParentFile().getParentFile().getAbsolutePath();
    }
 else {
      final String m=""String_Node_Str"" + binaryName + ""String_Node_Str"";
      _omcLogger.getInfo(m);
      throw new ConnectException(m);
    }
  }
  openModelicaHomeDirectory=new File(_openModelicaHome);
  String[] subdirs={""String_Node_Str""};
  for (  String subdir : subdirs) {
    String path=openModelicaHomeDirectory.getAbsolutePath() + File.separator;
    path+=subdir.equals(""String_Node_Str"") ? binaryName : subdir + File.separator + binaryName;
    File file=new File(path);
    if (file.exists()) {
      omcBinary=file;
      loggerInfo=""String_Node_Str"" + omcBinary.getAbsolutePath() + ""String_Node_Str"";
      _omcLogger.getInfo(loggerInfo);
      break;
    }
 else {
      loggerInfo=""String_Node_Str"" + path + ""String_Node_Str"";
      _omcLogger.getInfo(loggerInfo);
    }
  }
  if (omcBinary == null) {
    loggerInfo=""String_Node_Str"";
    _omcLogger.getInfo(loggerInfo);
    throw new ConnectException(loggerInfo);
  }
switch (getOs()) {
case WINDOWS:
    if (_username == null) {
      System.err.println(""String_Node_Str"");
      omcWorkingDirectory=new File(_temp + ""String_Node_Str"");
    }
 else {
      omcWorkingDirectory=new File(_temp + _username + ""String_Node_Str"");
    }
  break;
case UNIX:
if (_username == null) {
  System.err.println(""String_Node_Str"");
  omcWorkingDirectory=new File(_temp + ""String_Node_Str"");
}
 else {
  omcWorkingDirectory=new File(_temp + ""String_Node_Str"" + _username+ ""String_Node_Str"");
}
break;
case MAC:
if (_username == null) {
System.err.println(""String_Node_Str"");
omcWorkingDirectory=new File(_temp + ""String_Node_Str"");
}
 else {
omcWorkingDirectory=new File(_temp + _username + ""String_Node_Str"");
}
break;
}
return new File[]{omcBinary,omcWorkingDirectory};
}"
72805,"/** 
 * Build the Modelica model. Then, run the executable result file of buildModel() in both interactive and non-interactive processing mode in order to generate the simulation result file.
 * @param fileName File which the model should be loaded from.
 * @param modelName Name of the (base-)model which should be built.
 * @param startTime The start time of simulation.
 * @param stopTime The stop time of simulation.
 * @param numberOfIntervals Number of intervals in the result file.
 * @param outputFormat Format of the result file.
 * @param processingMode The mode of processing for running the executable result file of building the Modelica model.
 * @exception ConnectException If commands couldn'tbe sent to the (OpenModelic Compiler)OMC.
 * @exception IOException If the executable result file of buildModel()couldn't be executed.
 * @exception IllegalActionException
 */
public void runModel(String fileName,String modelName,String startTime,String stopTime,int numberOfIntervals,String outputFormat,String processingMode) throws ConnectException, IOException, IllegalActionException {
  String commands=null;
  String loggerInfo=null;
  commands=modelName + ""String_Node_Str"" + Float.valueOf(startTime).floatValue()+ ""String_Node_Str""+ Float.valueOf(stopTime).floatValue()+ ""String_Node_Str""+ numberOfIntervals+ ""String_Node_Str""+ ""String_Node_Str""+ outputFormat+ ""String_Node_Str"";
  loggerInfo=""String_Node_Str"" + modelName + ""String_Node_Str"";
  _omcLogger.getInfo(loggerInfo);
  CompilerResult buildModelResult=sendCommand(""String_Node_Str"" + commands + ""String_Node_Str"");
  if (!buildModelResult.getFirstResult().isEmpty() && (!buildModelResult.getError().isEmpty() && buildModelResult.getError().contains(""String_Node_Str""))) {
    loggerInfo=modelName + ""String_Node_Str"";
    _omcLogger.getInfo(loggerInfo);
  }
  if (!buildModelResult.getError().isEmpty() && !(buildModelResult.getError().contains(""String_Node_Str""))) {
    loggerInfo=buildModelResult.getError();
    _omcLogger.getInfo(loggerInfo);
    throw new ConnectException(loggerInfo);
  }
  if (!outputFormat.equalsIgnoreCase(""String_Node_Str"")) {
switch (getOs()) {
case WINDOWS:
      commands=_temp + _username + ""String_Node_Str""+ modelName+ ""String_Node_Str"";
    break;
case UNIX:
  commands=_temp + ""String_Node_Str"" + _username+ ""String_Node_Str""+ modelName;
break;
case MAC:
commands=_temp + _username + ""String_Node_Str""+ modelName;
break;
}
if (processingMode.equalsIgnoreCase(""String_Node_Str"")) {
try {
Runtime.getRuntime().exec(commands,_environmentalVariables,_workDir);
}
 catch (IOException e) {
System.err.println(""String_Node_Str"" + commands);
StringUtilities.exit(1);
}
loggerInfo=""String_Node_Str"";
_omcLogger.getInfo(loggerInfo);
switch (getOs()) {
case WINDOWS:
loggerInfo=modelName + ""String_Node_Str"" + outputFormat+ ""String_Node_Str""+ _temp+ _username+ ""String_Node_Str"";
_omcLogger.getInfo(loggerInfo);
break;
case UNIX:
loggerInfo=modelName + ""String_Node_Str"" + outputFormat+ ""String_Node_Str""+ _temp+ ""String_Node_Str""+ _username+ ""String_Node_Str"";
_omcLogger.getInfo(loggerInfo);
break;
case MAC:
loggerInfo=modelName + ""String_Node_Str"" + outputFormat+ ""String_Node_Str""+ _temp+ _username+ ""String_Node_Str"";
_omcLogger.getInfo(loggerInfo);
break;
}
}
 else {
commands=commands + ""String_Node_Str"";
try {
loggerInfo=""String_Node_Str"" + commands + ""String_Node_Str"";
_omcLogger.getInfo(loggerInfo);
Runtime.getRuntime().exec(commands,_environmentalVariables,_workDir);
loggerInfo=""String_Node_Str"" + commands + ""String_Node_Str"";
_omcLogger.getInfo(loggerInfo);
}
 catch (IOException e) {
new IOException(e.getMessage()).printStackTrace();
return;
}
loggerInfo=""String_Node_Str"";
_omcLogger.getInfo(loggerInfo);
}
}
}","/** 
 * Build the Modelica model. Then, run the executable result file of buildModel() in both interactive and non-interactive processing mode in order to generate the simulation result file.
 * @param fileName File which the model should be loaded from.
 * @param modelName Name of the (base-)model which should be built.
 * @param startTime The start time of simulation.
 * @param stopTime The stop time of simulation.
 * @param numberOfIntervals Number of intervals in the result file.
 * @param outputFormat Format of the result file.
 * @param processingMode The mode of processing for running the executable result file of building the Modelica model.
 * @exception ConnectException If commands couldn'tbe sent to the (OpenModelic Compiler)OMC.
 * @exception IOException If the executable result file of buildModel()couldn't be executed.
 * @exception IllegalActionException
 */
public void runModel(String fileName,String modelName,String startTime,String stopTime,int numberOfIntervals,String outputFormat,String processingMode) throws ConnectException, IOException, IllegalActionException {
  String commands=null;
  String loggerInfo=null;
  commands=modelName + ""String_Node_Str"" + Float.valueOf(startTime).floatValue()+ ""String_Node_Str""+ Float.valueOf(stopTime).floatValue()+ ""String_Node_Str""+ numberOfIntervals+ ""String_Node_Str""+ ""String_Node_Str""+ outputFormat+ ""String_Node_Str"";
  loggerInfo=""String_Node_Str"" + modelName + ""String_Node_Str"";
  _omcLogger.getInfo(loggerInfo);
  CompilerResult buildModelResult=sendCommand(""String_Node_Str"" + commands + ""String_Node_Str"");
  if (!buildModelResult.getFirstResult().isEmpty() && (!buildModelResult.getError().isEmpty() && buildModelResult.getError().contains(""String_Node_Str""))) {
    loggerInfo=modelName + ""String_Node_Str"";
    _omcLogger.getInfo(loggerInfo);
  }
  if (!buildModelResult.getError().isEmpty() && !(buildModelResult.getError().contains(""String_Node_Str""))) {
    loggerInfo=buildModelResult.getError();
    _omcLogger.getInfo(loggerInfo);
    throw new ConnectException(loggerInfo);
  }
  if (!outputFormat.equalsIgnoreCase(""String_Node_Str"")) {
switch (getOs()) {
case WINDOWS:
      commands=_temp + _username + ""String_Node_Str""+ modelName+ ""String_Node_Str"";
    break;
case UNIX:
  commands=_temp + ""String_Node_Str"" + _username+ ""String_Node_Str""+ modelName;
break;
case MAC:
commands=_temp + _username + ""String_Node_Str""+ modelName;
break;
}
if (processingMode.equalsIgnoreCase(""String_Node_Str"")) {
try {
loggerInfo=""String_Node_Str"" + commands + ""String_Node_Str"";
_omcLogger.getInfo(loggerInfo);
Runtime.getRuntime().exec(commands,_environmentalVariables,_workDir);
loggerInfo=""String_Node_Str"";
_omcLogger.getInfo(loggerInfo);
}
 catch (IOException e) {
System.err.println(""String_Node_Str"" + commands);
StringUtilities.exit(1);
}
switch (getOs()) {
case WINDOWS:
loggerInfo=modelName + ""String_Node_Str"" + outputFormat+ ""String_Node_Str""+ _temp+ _username+ ""String_Node_Str"";
_omcLogger.getInfo(loggerInfo);
break;
case UNIX:
loggerInfo=modelName + ""String_Node_Str"" + outputFormat+ ""String_Node_Str""+ _temp+ ""String_Node_Str""+ _username+ ""String_Node_Str"";
_omcLogger.getInfo(loggerInfo);
break;
case MAC:
loggerInfo=modelName + ""String_Node_Str"" + outputFormat+ ""String_Node_Str""+ _temp+ _username+ ""String_Node_Str"";
_omcLogger.getInfo(loggerInfo);
break;
}
}
 else {
commands=commands + ""String_Node_Str"";
try {
loggerInfo=""String_Node_Str"" + commands + ""String_Node_Str"";
_omcLogger.getInfo(loggerInfo);
Runtime.getRuntime().exec(commands,_environmentalVariables,_workDir);
loggerInfo=""String_Node_Str"";
_omcLogger.getInfo(loggerInfo);
}
 catch (IOException e) {
new IOException(e.getMessage()).printStackTrace();
return;
}
}
}
}"
72806,"/** 
 * Check if the (base-)model inherits from other classes.
 * @param modelName The (base-)model that should be built.
 * @return Check Return true, if the number of inherited classes is more than zero.
 */
public boolean getInheritanceCount(String modelName){
  CompilerResult getInheritanceCountResult=null;
  String inheritanceCount=null;
  try {
    getInheritanceCountResult=sendCommand(""String_Node_Str"" + modelName + ""String_Node_Str"");
  }
 catch (  ConnectException e) {
    new ConnectException(e.getMessage()).printStackTrace();
  }
  if (getInheritanceCountResult.getError().isEmpty()) {
    inheritanceCount=getInheritanceCountResult.getFirstResult().toString();
  }
  if (!(inheritanceCount.compareTo(""String_Node_Str"") == 0)) {
    return true;
  }
 else {
    return false;
  }
}","/** 
 * Check if the (base-)model inherits from other classes.
 * @param modelName The (base-)model that should be built.
 * @return Check Return true, if the number of inherited classes is more than zero.
 */
public boolean getInheritanceCount(String modelName){
  CompilerResult getInheritanceCountResult=null;
  String inheritanceCount=null;
  try {
    getInheritanceCountResult=sendCommand(""String_Node_Str"" + modelName + ""String_Node_Str"");
  }
 catch (  ConnectException e) {
    new ConnectException(e.getMessage()).printStackTrace();
  }
  if (getInheritanceCountResult.getError().isEmpty())   inheritanceCount=getInheritanceCountResult.getFirstResult().toString();
  if (!(inheritanceCount.compareTo(""String_Node_Str"") == 0))   return true;
 else   return false;
}"
72807,"/** 
 * Create an instance of OMCLogger object in order to provide a global point of access to the instance. It provides a unique source of OMCLogger instance.
 * @return An OMCLogger object representing the instance value.
 */
public static OMCLogger getInstance(){
  if (_omcLoggerInstance == null) {
    try {
      _omcLoggerInstance=new OMCLogger();
    }
 catch (    IllegalActionException e) {
      new IllegalActionException(""String_Node_Str"" + e.getMessage());
    }
  }
  return _omcLoggerInstance;
}","/** 
 * Create an instance of OMCLogger object in order to provide a global point of access to the instance. It provides a unique source of OMCLogger instance.
 * @return An OMCLogger object representing the instance value.
 */
public static OMCLogger getInstance(){
  if (_omcLoggerInstance == null) {
    try {
      _omcLoggerInstance=new OMCLogger();
    }
 catch (    IllegalActionException e) {
      e.printStackTrace();
    }
  }
  return _omcLoggerInstance;
}"
72808,"/** 
 * Clone this actor into the specified workspace. The new actor is <i>not</i> added to the directory of that workspace (you must do this yourself if you want it there). The result is a new actor with the same ports as the original, but no connections and no container.  A container must be set before much can be done with this actor.
 * @param workspace The workspace for the cloned object.
 * @exception CloneNotSupportedException If cloned ports cannot haveas their container the cloned entity (this should not occur), or if one of the attributes cannot be cloned.
 * @return A new CanBus.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  CanBus newObject=(CanBus)super.clone(workspace);
  _ioPortToCanPriority=new HashMap<Port,Integer>();
  newObject._tokenTree=new TreeMap<Integer,LinkedList<Object[]>>();
  newObject._multiCast=new HashMap<Integer,Integer>();
  newObject._frameSize=_frameSize;
  newObject._nextTokenSize=_nextTokenSize;
  newObject._nextTokenFiringTime=null;
  newObject._startingTime=null;
  newObject._channelUsed=_channelUsed;
  newObject._bitRate=_bitRate;
  newObject._mostRecentFrame=_mostRecentFrame;
  return newObject;
}","/** 
 * Clone this actor into the specified workspace. The new actor is <i>not</i> added to the directory of that workspace (you must do this yourself if you want it there). The result is a new actor with the same ports as the original, but no connections and no container.  A container must be set before much can be done with this actor.
 * @param workspace The workspace for the cloned object.
 * @exception CloneNotSupportedException If cloned ports cannot haveas their container the cloned entity (this should not occur), or if one of the attributes cannot be cloned.
 * @return A new CanBus.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  CanBus newObject=(CanBus)super.clone(workspace);
  newObject._ioPortToCanPriority=new HashMap<Port,Integer>();
  newObject._tokenTree=new TreeMap<Integer,LinkedList<Object[]>>();
  newObject._multiCast=new HashMap<Integer,Integer>();
  newObject._frameSize=_frameSize;
  newObject._nextTokenSize=_nextTokenSize;
  newObject._nextTokenFiringTime=null;
  newObject._startingTime=null;
  newObject._channelUsed=_channelUsed;
  newObject._bitRate=_bitRate;
  newObject._mostRecentFrame=_mostRecentFrame;
  return newObject;
}"
72809,"/** 
 * If there is an input, then post to the specified URL the data on the input record, wait for a response, and output the response on the output port.
 * @exception IllegalActionException If an IO error occurs.
 */
public void fire() throws IllegalActionException {
  super.fire();
  url.update();
  if (input.hasToken(0)) {
    RecordToken record=(RecordToken)input.get(0);
    if (_debugging) {
      _debug(""String_Node_Str"" + record);
    }
    StringBuffer data=new StringBuffer();
    boolean first=true;
    for (    String field : record.labelSet()) {
      if (!first) {
        data.append(""String_Node_Str"");
      }
      first=false;
      try {
        data.append(URLEncoder.encode(field,""String_Node_Str""));
        data.append(""String_Node_Str"");
        Token value=record.get(field);
        String string=value.toString();
        if (value instanceof StringToken) {
          string=((StringToken)value).stringValue();
        }
        data.append(URLEncoder.encode(string,""String_Node_Str""));
      }
 catch (      UnsupportedEncodingException e) {
        throw new InternalErrorException(e);
      }
    }
    String urlValue=((StringToken)url.getToken()).stringValue();
    if (urlValue == null || urlValue.isEmpty()) {
      throw new IllegalActionException(""String_Node_Str"");
    }
    StringBuffer response=new StringBuffer();
    try {
      URL url=new URL(urlValue);
      URLConnection connection=url.openConnection();
      connection.setDoOutput(true);
      OutputStreamWriter writer=null;
      try {
        writer=new OutputStreamWriter(connection.getOutputStream());
        writer.write(data.toString());
        writer.flush();
        if (_debugging) {
          _debug(""String_Node_Str"" + data.toString());
          _debug(""String_Node_Str"" + url.toString());
          _debug(""String_Node_Str"");
        }
        BufferedReader reader=null;
        try {
          String line;
          while ((line=reader.readLine()) != null) {
            response.append(line);
            if (!line.endsWith(""String_Node_Str"")) {
              response.append(""String_Node_Str"");
            }
          }
          if (_debugging) {
            _debug(""String_Node_Str"" + response.toString());
          }
        }
  finally {
          if (reader != null) {
            reader.close();
          }
        }
      }
  finally {
        if (writer != null) {
          writer.close();
        }
      }
      output.send(0,new StringToken(response.toString()));
    }
 catch (    IOException ex) {
      throw new IllegalActionException(this,ex,""String_Node_Str"");
    }
  }
 else   if (_debugging) {
    _debug(""String_Node_Str"");
  }
}","/** 
 * If there is an input, then post to the specified URL the data on the input record, wait for a response, and output the response on the output port.
 * @exception IllegalActionException If an IO error occurs.
 */
public void fire() throws IllegalActionException {
  super.fire();
  url.update();
  if (input.hasToken(0)) {
    RecordToken record=(RecordToken)input.get(0);
    if (_debugging) {
      _debug(""String_Node_Str"" + record);
    }
    StringBuffer data=new StringBuffer();
    boolean first=true;
    for (    String field : record.labelSet()) {
      if (!first) {
        data.append(""String_Node_Str"");
      }
      first=false;
      try {
        data.append(URLEncoder.encode(field,""String_Node_Str""));
        data.append(""String_Node_Str"");
        Token value=record.get(field);
        String string=value.toString();
        if (value instanceof StringToken) {
          string=((StringToken)value).stringValue();
        }
        data.append(URLEncoder.encode(string,""String_Node_Str""));
      }
 catch (      UnsupportedEncodingException e) {
        throw new InternalErrorException(e);
      }
    }
    String urlValue=((StringToken)url.getToken()).stringValue();
    if (urlValue == null || urlValue.isEmpty()) {
      throw new IllegalActionException(""String_Node_Str"");
    }
    try {
      URL url=new URL(urlValue);
      URLConnection connection=url.openConnection();
      connection.setDoOutput(true);
      OutputStreamWriter writer=new OutputStreamWriter(connection.getOutputStream());
      writer.write(data.toString());
      writer.flush();
      if (_debugging) {
        _debug(""String_Node_Str"" + data.toString());
        _debug(""String_Node_Str"" + url.toString());
        _debug(""String_Node_Str"");
      }
      BufferedReader reader=new BufferedReader(new InputStreamReader(connection.getInputStream()));
      StringBuffer response=new StringBuffer();
      String line;
      while ((line=reader.readLine()) != null) {
        response.append(line);
        if (!line.endsWith(""String_Node_Str"")) {
          response.append(""String_Node_Str"");
        }
      }
      if (_debugging) {
        _debug(""String_Node_Str"" + response.toString());
      }
      writer.close();
      reader.close();
      output.send(0,new StringToken(response.toString()));
    }
 catch (    IOException ex) {
      throw new IllegalActionException(this,ex,""String_Node_Str"");
    }
  }
 else   if (_debugging) {
    _debug(""String_Node_Str"");
  }
}"
72810,"/** 
 * Create a sensor with the given type, units of measurement, and  time interval between measurements, which has no readings.
 * @param type  The type of measurement, for example, temperature
 * @param unit  The units of measurement, for example, degC
 * @param interval  The time interval between measurements
 */
Sensor(String type,String unit,String interval){
  setType(type);
  _unit=unit;
  _interval=interval;
  _readings=new ArrayList<Double>();
  _readings.add(new Double.valueOf(5.67));
  _readings.add(new Double.valueOf(7.89));
}","/** 
 * Create a sensor with the given type, units of measurement, and  time interval between measurements, which has no readings.
 * @param type  The type of measurement, for example, temperature
 * @param unit  The units of measurement, for example, degC
 * @param interval  The time interval between measurements
 */
Sensor(String type,String unit,String interval){
  setType(type);
  _unit=unit;
  _interval=interval;
  _readings=new ArrayList<Double>();
  _readings.add(Double.valueOf(5.67));
  _readings.add(Double.valueOf(7.89));
}"
72811,"/** 
 * Set the name of the port that will receive scheduling requests for the actor.
 * @param actor The actor.
 * @param portName The request port.
 */
public void setRequestPort(Actor actor,String portName){
  if (_requestPorts == null) {
    _requestPorts=new HashMap<Actor,String>();
  }
  _requestPorts.put(actor,portName);
}","/** 
 * Set the name of the port that will receive scheduling requests for the actor.
 * @param actor The actor.
 * @param portName The request port.
 */
public void setRequestPort(Actor actor,String portName){
  if (portName != null) {
    if (_requestPorts == null) {
      _requestPorts=new HashMap<Actor,String>();
    }
    _requestPorts.put(actor,portName);
  }
}"
72812,"/** 
 * Schedule a new actor for execution. Find the const actor in the _model that is mapped to this actor and trigger a firing of that one, if the actor is not already in execution. If the actor finished execution, return zero time, otherwise return the next time the model has something to do.
 * @param actor The actor to be scheduled.
 * @param currentPlatformTime The current platform time.
 * @param deadline The deadline of the event.
 * @param executionTime The execution time of the actor.
 * @return Relative time when this aspect has to be executedagain.
 * @exception IllegalActionException Thrown if actor parameters suchas execution time or priority cannot be read.
 */
protected Time _schedule(Actor actor,Time currentPlatformTime,Time deadline,Time executionTime) throws IllegalActionException {
  _lastActorFinished=false;
  getDirector().setModelTime(getExecutiveDirector().localClock.getLocalTime());
  Time time=_lastTimeScheduled.get(actor);
  if ((_justMonitor && (time == null || !time.equals(currentPlatformTime))) || !_currentlyExecuting.contains(actor)) {
    _lastTimeScheduled.put(actor,currentPlatformTime);
    notifyExecutionListeners((NamedObj)actor,getExecutiveDirector().localClock.getLocalTime().getDoubleValue(),ExecutionEventType.START);
    if (_requestPorts.get(actor) == null) {
      throw new IllegalActionException(this,""String_Node_Str"" + actor + ""String_Node_Str""+ ""String_Node_Str"");
    }
    ExecutionRequestPort requestPort=(ExecutionRequestPort)getEntity(_requestPorts.get(actor));
    if (requestPort != null) {
      RecordToken recordToken=new RecordToken(new String[]{""String_Node_Str"",""String_Node_Str""},new Token[]{new ObjectToken(actor),new DoubleToken(executionTime.getDoubleValue())});
      requestPort.value.setToken(recordToken);
      getDirector().fireAtCurrentTime(requestPort);
      getExecutiveDirector().fireAt(this,getDirector().getModelTime());
      _currentlyExecuting.add(actor);
    }
 else {
      throw new IllegalActionException(this,""String_Node_Str"" + _requestPorts.get(actor));
    }
  }
  if (_justMonitor) {
    _lastActorFinished=true;
    return new Time(getDirector(),0.0);
  }
 else {
    return Time.POSITIVE_INFINITY;
  }
}","/** 
 * Schedule a new actor for execution. Find the const actor in the _model that is mapped to this actor and trigger a firing of that one, if the actor is not already in execution. If the actor finished execution, return zero time, otherwise return the next time the model has something to do.
 * @param actor The actor to be scheduled.
 * @param currentPlatformTime The current platform time.
 * @param deadline The deadline of the event.
 * @param executionTime The execution time of the actor.
 * @return Relative time when this aspect has to be executedagain.
 * @exception IllegalActionException Thrown if actor parameters suchas execution time or priority cannot be read.
 */
protected Time _schedule(Actor actor,Time currentPlatformTime,Time deadline,Time executionTime) throws IllegalActionException {
  _lastActorFinished=false;
  getDirector().setModelTime(getExecutiveDirector().localClock.getLocalTime());
  Time time=_lastTimeScheduled.get(actor);
  if ((_justMonitor && (time == null || !time.equals(currentPlatformTime))) || !_currentlyExecuting.contains(actor)) {
    _lastTimeScheduled.put(actor,currentPlatformTime);
    notifyExecutionListeners((NamedObj)actor,getExecutiveDirector().localClock.getLocalTime().getDoubleValue(),ExecutionEventType.START);
    if (_requestPorts == null || _requestPorts.get(actor) == null) {
      CompositeExecutionAspectAttributes decoratorAttributes=(CompositeExecutionAspectAttributes)((NamedObj)actor).getDecoratorAttributes(this);
      String portName=((StringParameter)decoratorAttributes.getAttribute(""String_Node_Str"")).getValueAsString();
      if (portName == null || portName.equals(""String_Node_Str"")) {
        throw new IllegalActionException(this,""String_Node_Str"" + actor + ""String_Node_Str""+ ""String_Node_Str"");
      }
      setRequestPort(actor,portName);
    }
    ExecutionRequestPort requestPort=(ExecutionRequestPort)getEntity(_requestPorts.get(actor));
    if (requestPort != null) {
      RecordToken recordToken=new RecordToken(new String[]{""String_Node_Str"",""String_Node_Str""},new Token[]{new ObjectToken(actor),new DoubleToken(executionTime.getDoubleValue())});
      requestPort.value.setToken(recordToken);
      getDirector().fireAtCurrentTime(requestPort);
      getExecutiveDirector().fireAt(this,getDirector().getModelTime());
      _currentlyExecuting.add(actor);
    }
 else {
      throw new IllegalActionException(this,""String_Node_Str"" + _requestPorts.get(actor));
    }
  }
  if (_justMonitor) {
    _lastActorFinished=true;
    return new Time(getDirector(),0.0);
  }
 else {
    return Time.POSITIVE_INFINITY;
  }
}"
72813,"/** 
 * Unzip a file into a temporary directory. Based on http://java.sun.com/developer/technicalArticles/Programming/compression/.
 * @param zipFileName  The file to be unzipped.
 * @return the list of files that were extracted.
 * @exception IOException if the file cannot be opened, if there are problems readingthe zip file or if there are problems creating the files or directories.
 */
public static List<File> unzip(String zipFileName) throws IOException {
  BufferedOutputStream destination=null;
  final int BUFFER=2048;
  byte data[]=new byte[BUFFER];
  File topDirectoryFile=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
  if (!topDirectoryFile.delete()) {
    throw new IOException(""String_Node_Str"" + topDirectoryFile);
  }
  if (!topDirectoryFile.mkdir()) {
    throw new IOException(""String_Node_Str"" + topDirectoryFile);
  }
  topDirectoryFile.deleteOnExit();
  String topDirectory=topDirectoryFile.getCanonicalPath();
  System.out.println(""String_Node_Str"" + topDirectory);
  List<File> files=new LinkedList<File>();
  FileInputStream fileInputStream=null;
  ZipInputStream zipInputStream=null;
  try {
    fileInputStream=new FileInputStream(zipFileName);
    zipInputStream=new ZipInputStream(new BufferedInputStream(fileInputStream));
    ZipEntry entry;
    while ((entry=zipInputStream.getNextEntry()) != null) {
      String entryName=entry.getName();
      File destinationFile=new File(topDirectory,entryName);
      File destinationParent=destinationFile.getParentFile();
      if (!destinationParent.isDirectory() && !destinationParent.mkdirs()) {
        throw new IOException(""String_Node_Str"" + destinationParent + ""String_Node_Str"");
      }
      if (!entry.isDirectory()) {
        try {
          FileOutputStream fos=new FileOutputStream(destinationFile);
          destination=new BufferedOutputStream(fos,BUFFER);
          int count;
          while ((count=zipInputStream.read(data,0,BUFFER)) != -1) {
            destination.write(data,0,count);
          }
          files.add(destinationFile);
        }
  finally {
          if (destination != null) {
            destination.flush();
            destination.close();
          }
        }
      }
    }
  }
  finally {
    if (destination != null) {
      try {
        destination.close();
      }
 catch (      IOException ex) {
        System.out.println(""String_Node_Str"" + destinationFile + ""String_Node_Str"");
      }
    }
    if (zipInputStream != null) {
      zipInputStream.close();
    }
  }
  return files;
}","/** 
 * Unzip a file into a temporary directory. Based on http://java.sun.com/developer/technicalArticles/Programming/compression/.
 * @param zipFileName  The file to be unzipped.
 * @return the list of files that were extracted.
 * @exception IOException if the file cannot be opened, if there are problems readingthe zip file or if there are problems creating the files or directories.
 */
public static List<File> unzip(String zipFileName) throws IOException {
  BufferedOutputStream destination=null;
  final int BUFFER=2048;
  byte data[]=new byte[BUFFER];
  File topDirectoryFile=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
  if (!topDirectoryFile.delete()) {
    throw new IOException(""String_Node_Str"" + topDirectoryFile);
  }
  if (!topDirectoryFile.mkdir()) {
    throw new IOException(""String_Node_Str"" + topDirectoryFile);
  }
  topDirectoryFile.deleteOnExit();
  String topDirectory=topDirectoryFile.getCanonicalPath();
  System.out.println(""String_Node_Str"" + topDirectory);
  List<File> files=new LinkedList<File>();
  FileInputStream fileInputStream=null;
  ZipInputStream zipInputStream=null;
  File destinationFile=null;
  try {
    fileInputStream=new FileInputStream(zipFileName);
    zipInputStream=new ZipInputStream(new BufferedInputStream(fileInputStream));
    ZipEntry entry;
    while ((entry=zipInputStream.getNextEntry()) != null) {
      String entryName=entry.getName();
      destinationFile=new File(topDirectory,entryName);
      File destinationParent=destinationFile.getParentFile();
      if (!destinationParent.isDirectory() && !destinationParent.mkdirs()) {
        throw new IOException(""String_Node_Str"" + destinationParent + ""String_Node_Str"");
      }
      if (!entry.isDirectory()) {
        try {
          FileOutputStream fos=new FileOutputStream(destinationFile);
          destination=new BufferedOutputStream(fos,BUFFER);
          int count;
          while ((count=zipInputStream.read(data,0,BUFFER)) != -1) {
            destination.write(data,0,count);
          }
          files.add(destinationFile);
        }
  finally {
          if (destination != null) {
            destination.flush();
            destination.close();
            destination=null;
          }
        }
      }
    }
  }
  finally {
    if (destination != null) {
      try {
        destination.close();
      }
 catch (      IOException ex) {
        System.out.println(""String_Node_Str"" + destinationFile + ""String_Node_Str"");
      }
    }
    if (zipInputStream != null) {
      zipInputStream.close();
    }
  }
  return files;
}"
72814,"/** 
 * Return a list of the entities deeply contained by the container of this resource scheduler.
 * @return A list of the objects decorated by this decorator.
 */
public List<NamedObj> decoratedObjects(){
  List<NamedObj> list=new ArrayList();
  CompositeEntity container=(CompositeEntity)getContainer();
  for (  Object object : container.deepEntityList()) {
    if (object instanceof Actor) {
      for (      Object port : ((Actor)object).inputPortList()) {
        list.add((NamedObj)port);
      }
    }
  }
  return list;
}","/** 
 * Return a list of the entities deeply contained by the container of this resource scheduler.
 * @return A list of the objects decorated by this decorator.
 */
public List<NamedObj> decoratedObjects(){
  if (workspace().getVersion() == _decoratedObjectsVersion) {
    return _decoratedObjects;
  }
  _decoratedObjectsVersion=workspace().getVersion();
  List<NamedObj> list=new ArrayList();
  CompositeEntity container=(CompositeEntity)getContainer();
  for (  Object object : container.deepEntityList()) {
    if (object instanceof Actor) {
      for (      Object port : ((Actor)object).inputPortList()) {
        list.add((NamedObj)port);
      }
    }
  }
  _decoratedObjects=list;
  return list;
}"
72815,"/** 
 * Clone the object into the specified workspace.
 * @param workspace The workspace for the new object.
 * @return A new NamedObj.
 * @exception CloneNotSupportedException If any of the attributescannot be cloned.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  AtomicCommunicationAspect newObject=(AtomicCommunicationAspect)super.clone(workspace);
  newObject._listeners=null;
  newObject._parameters=null;
  return newObject;
}","/** 
 * Clone the object into the specified workspace.
 * @param workspace The workspace for the new object.
 * @return A new NamedObj.
 * @exception CloneNotSupportedException If any of the attributescannot be cloned.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  AtomicCommunicationAspect newObject=(AtomicCommunicationAspect)super.clone(workspace);
  newObject._listeners=null;
  newObject._parameters=null;
  newObject._decoratedObjects=null;
  newObject._decoratedObjectsVersion=-1L;
  return newObject;
}"
72816,"/** 
 * Make sure that this communication aspect is only used in the DE domain. 
 * @param container The container of this actor.
 * @exception IllegalActionException If thrown by the super class or if thedirector of this actor is not a DEDirector.
 * @exception NameDuplicationException If thrown by the super class.
 */
public void setContainer(CompositeEntity container) throws IllegalActionException, NameDuplicationException {
  super.setContainer(container);
  if (getDirector() != null && !(getDirector() instanceof DEDirector)) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
}","/** 
 * Make sure that this communication aspect is only used in the DE domain. 
 * @param container The container of this actor.
 * @exception IllegalActionException If thrown by the super class or if thedirector of this actor is not a DEDirector.
 * @exception NameDuplicationException If thrown by the super class.
 */
public void setContainer(CompositeEntity container) throws IllegalActionException, NameDuplicationException {
  super.setContainer(container);
  if (getDirector() != null && !(getDirector() instanceof DEDirector)) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  if (container != null) {
    List<NamedObj> decoratedObjects=decoratedObjects();
    for (    NamedObj decoratedObject : decoratedObjects) {
      BasicSwitchAttributes decoratorAttributes=(BasicSwitchAttributes)decoratedObject.getDecoratorAttributes(this);
      setPortIn((IOPort)decoratedObject,decoratorAttributes._portIn);
      setPortOut((IOPort)decoratedObject,decoratorAttributes._portOut);
    }
  }
}"
72817,"/** 
 * Create the parameters.
 */
private void _init(){
  try {
    messageLength=new Parameter(this,""String_Node_Str"");
    messageLength.setExpression(""String_Node_Str"");
  }
 catch (  KernelException ex) {
    throw new InternalErrorException(ex);
  }
}","/** 
 * Create the parameters.
 */
private void _init(){
  try {
    messageLength=new Parameter(this,""String_Node_Str"");
    messageLength.setExpression(""String_Node_Str"");
    _messageLength=1;
  }
 catch (  KernelException ex) {
    throw new InternalErrorException(ex);
  }
}"
72818,"/** 
 * If attribute is <i>messageLength</i> report the new value  to the communication aspect. 
 * @param attribute The changed parameter.
 * @exception IllegalActionException If the parameter set is not valid.Not thrown in this class.
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == messageLength) {
    if (((BooleanToken)enable.getToken()).booleanValue()) {
      IOPort port=(IOPort)getContainer();
      Bus bus=(Bus)getDecorator();
      if (bus != null) {
        Token token=messageLength.getToken();
        if (token != null) {
          bus.setMessageLength(port,((ScalarToken)token).doubleValue());
        }
      }
    }
  }
 else {
    super.attributeChanged(attribute);
  }
}","/** 
 * If attribute is <i>messageLength</i> report the new value  to the communication aspect. 
 * @param attribute The changed parameter.
 * @exception IllegalActionException If the parameter set is not valid.Not thrown in this class.
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == messageLength) {
    if (((BooleanToken)enable.getToken()).booleanValue()) {
      IOPort port=(IOPort)getContainer();
      Bus bus=(Bus)getDecorator();
      if (bus != null) {
        Token token=messageLength.getToken();
        if (token != null) {
          _messageLength=((ScalarToken)token).doubleValue();
          bus.setMessageLength(port,_messageLength);
        }
      }
    }
  }
 else {
    super.attributeChanged(attribute);
  }
}"
72819,"/** 
 * Return a list of the entities deeply contained by the container of this resource scheduler.
 * @return A list of the objects decorated by this decorator.
 */
public List<NamedObj> decoratedObjects(){
  List<NamedObj> list=new ArrayList<NamedObj>();
  CompositeEntity container=(CompositeEntity)getContainer();
  for (  Object object : container.deepEntityList()) {
    if (object instanceof Actor) {
      for (      Object port : ((Actor)object).inputPortList()) {
        list.add((NamedObj)port);
      }
    }
  }
  return list;
}","/** 
 * Return a list of the entities deeply contained by the container of this resource scheduler.
 * @return A list of the objects decorated by this decorator.
 */
public List<NamedObj> decoratedObjects(){
  if (workspace().getVersion() == _decoratedObjectsVersion) {
    return _decoratedObjects;
  }
  _decoratedObjectsVersion=workspace().getVersion();
  List<NamedObj> list=new ArrayList<NamedObj>();
  CompositeEntity container=(CompositeEntity)getContainer();
  for (  Object object : container.deepEntityList()) {
    if (object instanceof Actor) {
      for (      Object port : ((Actor)object).inputPortList()) {
        list.add((NamedObj)port);
      }
    }
  }
  _decoratedObjects=list;
  return list;
}"
72820,"/** 
 * Clone the actor into the specified workspace.
 * @param workspace The workspace for the cloned object.
 * @exception CloneNotSupportedException Not thrown here.
 * @return A new CompositeQM.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  CompositeCommunicationAspect newObject=(CompositeCommunicationAspect)super.clone(workspace);
  newObject._parameters=new HashMap<IOPort,List<Attribute>>();
  return newObject;
}","/** 
 * Clone the actor into the specified workspace.
 * @param workspace The workspace for the cloned object.
 * @exception CloneNotSupportedException Not thrown here.
 * @return A new CompositeQM.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  CompositeCommunicationAspect newObject=(CompositeCommunicationAspect)super.clone(workspace);
  newObject._parameters=new HashMap<IOPort,List<Attribute>>();
  newObject._decoratedObjects=null;
  newObject._decoratedObjectsVersion=-1L;
  return newObject;
}"
72821,"/** 
 * Override the base class to first set the container, then establish a connection with any decorated objects it finds in scope in the new container.
 * @param container The container to attach this attribute to..
 * @exception IllegalActionException If this attribute is not of theexpected class for the container, or it has no name, or the attribute and container are not in the same workspace, or the proposed container would result in recursive containment.
 * @exception NameDuplicationException If the container already hasan attribute with the name of this attribute.
 * @see #getContainer()
 */
public void setContainer(CompositeEntity container) throws IllegalActionException, NameDuplicationException {
  super.setContainer(container);
  if (container != null) {
    List<NamedObj> decoratedObjects=decoratedObjects();
    for (    NamedObj decoratedObject : decoratedObjects) {
      decoratedObject.getDecoratorAttributes(this);
    }
  }
}","/** 
 * Override the base class to first set the container, then establish a connection with any decorated objects it finds in scope in the new container.
 * @param container The container to attach this attribute to..
 * @exception IllegalActionException If this attribute is not of theexpected class for the container, or it has no name, or the attribute and container are not in the same workspace, or the proposed container would result in recursive containment.
 * @exception NameDuplicationException If the container already hasan attribute with the name of this attribute.
 * @see #getContainer()
 */
public void setContainer(CompositeEntity container) throws IllegalActionException, NameDuplicationException {
  super.setContainer(container);
  if (container != null) {
    List<NamedObj> decoratedObjects=decoratedObjects();
    for (    NamedObj decoratedObject : decoratedObjects) {
      CompositeCommunicationAspectAttributes decoratorAttributes=(CompositeCommunicationAspectAttributes)decoratedObject.getDecoratorAttributes(this);
      setInputPortName((Port)decoratedObject,decoratorAttributes._inputPort);
    }
  }
}"
72822,"/** 
 * If attribute <i>requestPort</i> report the new value  to the ExecutionAspect. 
 * @param attribute The changed parameter.
 * @exception IllegalActionException If the parameter set is not valid.Not thrown in this class.
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == requestPort) {
    Actor actor=(Actor)getContainer();
    CompositeExecutionAspect aspect=(CompositeExecutionAspect)getDecorator();
    String portName=((StringToken)((Parameter)attribute).getToken()).stringValue();
    if (aspect != null && !portName.equals(""String_Node_Str"")) {
      aspect.setRequestPort(actor,portName);
    }
  }
 else {
    super.attributeChanged(attribute);
  }
}","/** 
 * If attribute <i>requestPort</i> report the new value  to the ExecutionAspect. 
 * @param attribute The changed parameter.
 * @exception IllegalActionException If the parameter set is not valid.Not thrown in this class.
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == requestPort) {
    Actor actor=(Actor)getContainer();
    CompositeExecutionAspect aspect=(CompositeExecutionAspect)getDecorator();
    String portName=((StringToken)((Parameter)attribute).getToken()).stringValue();
    if (aspect != null && !portName.equals(""String_Node_Str"") && enabled()) {
      _requestPortName=portName;
      aspect.setRequestPort(actor,_requestPortName);
    }
  }
 else {
    super.attributeChanged(attribute);
  }
}"
72823,"/** 
 * Create a new actor in the specified container with the specified name.  The name must be unique within the container or an exception is thrown. The container argument must not be null, or a NullPointerException will be thrown.
 * @param container The container.
 * @param name The name of this actor within the container.
 * @exception IllegalActionException If this actor cannot be containedby the proposed container (see the setContainer() method).
 * @exception NameDuplicationException If the name coincides withan entity already in the container.
 */
public CompositeExecutionAspect(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  ColorAttribute attribute=new ColorAttribute(this,""String_Node_Str"");
  attribute.setExpression(""String_Node_Str"");
  _requestPorts=new HashMap<Actor,String>();
  _previousY=new HashMap<NamedObj,Double>();
  justMonitor=new Parameter(this,""String_Node_Str"");
  justMonitor.setTypeEquals(BaseType.BOOLEAN);
  justMonitor.setExpression(""String_Node_Str"");
  _justMonitor=false;
  _lastTimeScheduled=new HashMap<Actor,Time>();
  _executionAspectListeners=new ArrayList<ExecutionAspectListener>();
}","/** 
 * Create a new actor in the specified container with the specified name.  The name must be unique within the container or an exception is thrown. The container argument must not be null, or a NullPointerException will be thrown.
 * @param container The container.
 * @param name The name of this actor within the container.
 * @exception IllegalActionException If this actor cannot be containedby the proposed container (see the setContainer() method).
 * @exception NameDuplicationException If the name coincides withan entity already in the container.
 */
public CompositeExecutionAspect(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  ColorAttribute attribute=new ColorAttribute(this,""String_Node_Str"");
  attribute.setExpression(""String_Node_Str"");
  _previousY=new HashMap<NamedObj,Double>();
  justMonitor=new Parameter(this,""String_Node_Str"");
  justMonitor.setTypeEquals(BaseType.BOOLEAN);
  justMonitor.setExpression(""String_Node_Str"");
  _justMonitor=false;
  _lastTimeScheduled=new HashMap<Actor,Time>();
  _executionAspectListeners=new ArrayList<ExecutionAspectListener>();
}"
72824,"/** 
 * Set the name of the port that will receive scheduling requests for the actor.
 * @param actor The actor.
 * @param portName The request port.
 */
public void setRequestPort(Actor actor,String portName){
  _requestPorts.put(actor,portName);
}","/** 
 * Set the name of the port that will receive scheduling requests for the actor.
 * @param actor The actor.
 * @param portName The request port.
 */
public void setRequestPort(Actor actor,String portName){
  if (_requestPorts == null) {
    _requestPorts=new HashMap<Actor,String>();
  }
  _requestPorts.put(actor,portName);
}"
72825,"/** 
 * Override the base class to first set the container, then establish a connection with any decorated objects it finds in scope in the new container.
 * @param container The container to attach this attribute to..
 * @exception IllegalActionException If this attribute is not of theexpected class for the container, or it has no name, or the attribute and container are not in the same workspace, or the proposed container would result in recursive containment.
 * @exception NameDuplicationException If the container already hasan attribute with the name of this attribute.
 * @see #getContainer()
 */
@Override public void setContainer(CompositeEntity container) throws IllegalActionException, NameDuplicationException {
  super.setContainer((CompositeEntity)container);
  if (container != null) {
    List<NamedObj> decoratedObjects=decoratedObjects();
    for (    NamedObj decoratedObject : decoratedObjects) {
      decoratedObject.getDecoratorAttributes(this);
    }
  }
}","/** 
 * Override the base class to first set the container, then establish a connection with any decorated objects it finds in scope in the new container.
 * @param container The container to attach this attribute to..
 * @exception IllegalActionException If this attribute is not of theexpected class for the container, or it has no name, or the attribute and container are not in the same workspace, or the proposed container would result in recursive containment.
 * @exception NameDuplicationException If the container already hasan attribute with the name of this attribute.
 * @see #getContainer()
 */
@Override public void setContainer(CompositeEntity container) throws IllegalActionException, NameDuplicationException {
  super.setContainer((CompositeEntity)container);
  if (container != null) {
    List<NamedObj> decoratedObjects=decoratedObjects();
    for (    NamedObj decoratedObject : decoratedObjects) {
      CompositeExecutionAspectAttributes decoratorAttributes=(CompositeExecutionAspectAttributes)decoratedObject.getDecoratorAttributes(this);
      if (decoratedObject instanceof Actor) {
        setRequestPort((Actor)decoratedObject,decoratorAttributes._requestPortName);
      }
    }
  }
}"
72826,"/** 
 * Return the list of communication aspects in this port. A communication aspect is a   {@link Parameter} whose value is an{@link ObjectToken} that references an object that implementsthe  {@link CommunicationAspect} interface.Update the sequence number of communication aspects.
 * @return The list of communication aspects.
 * @exception IllegalActionException Thrown if the token of the parametercontaining the communication aspect object cannot be retrieved.
 */
public List<CommunicationAspect> getCommunicationAspects() throws IllegalActionException {
  if (_communicationAspects == null) {
    _communicationAspects=new ArrayList<CommunicationAspect>();
  }
  HashMap<Integer,CommunicationAspectAttributes> _communicationAspectMap=new HashMap<Integer,CommunicationAspectAttributes>();
  int sequenceNumber=1;
  List<CommunicationAspectAttributes> communicationAspectList=this.attributeList(CommunicationAspectAttributes.class);
  if (communicationAspectList.size() > 0) {
    try {
      _workspace.getWriteAccess();
      List<CommunicationAspectAttributes> enabledAttributes=new ArrayList();
      for (int i=0; i < communicationAspectList.size(); i++) {
        CommunicationAspectAttributes attribute=communicationAspectList.get(i);
        if (((BooleanToken)attribute.enable.getToken()).booleanValue()) {
          enabledAttributes.add(attribute);
          int s=((IntToken)attribute.sequenceNumber.getToken()).intValue();
          if (s > sequenceNumber) {
            sequenceNumber=s;
          }
        }
 else {
          attribute.sequenceNumber.setToken(new IntToken(-1));
        }
      }
      sequenceNumber=sequenceNumber + 1;
      for (int i=0; i < enabledAttributes.size(); i++) {
        final CommunicationAspectAttributes attribute=enabledAttributes.get(i);
        final int seqNum=sequenceNumber;
        CommunicationAspect communicationAspect=(CommunicationAspect)attribute.getDecorator();
        int oldSeqNum=((IntToken)attribute.sequenceNumber.getToken()).intValue();
        if (oldSeqNum == -1 && communicationAspect != null && !_communicationAspects.contains(communicationAspect)) {
          attribute.sequenceNumber.setToken(new IntToken(seqNum));
          _communicationAspectMap.put(seqNum,attribute);
          sequenceNumber=sequenceNumber + 1;
        }
 else {
          _communicationAspectMap.put(oldSeqNum,attribute);
        }
      }
      _communicationAspects.clear();
      Iterator<Integer> iterator=_communicationAspectMap.keySet().iterator();
      int i=1;
      while (iterator.hasNext()) {
        CommunicationAspectAttributes attribute=_communicationAspectMap.get(iterator.next());
        attribute.sequenceNumber.setToken(new IntToken(i));
        i=i + 1;
        _communicationAspects.add((CommunicationAspect)attribute.getDecorator());
      }
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
 finally {
      _workspace.doneWriting();
    }
  }
  _communicationAspectsValid=true;
  return _communicationAspects;
}","/** 
 * Return the list of communication aspects in this port. A communication aspect is a   {@link Parameter} whose value is an{@link ObjectToken} that references an object that implementsthe  {@link CommunicationAspect} interface.Update the sequence number of communication aspects.
 * @return The list of communication aspects.
 * @exception IllegalActionException Thrown if the token of the parametercontaining the communication aspect object cannot be retrieved.
 */
public List<CommunicationAspect> getCommunicationAspects() throws IllegalActionException {
  if (_communicationAspects == null) {
    _communicationAspects=new ArrayList<CommunicationAspect>();
  }
  HashMap<Integer,CommunicationAspectAttributes> _communicationAspectMap=new HashMap<Integer,CommunicationAspectAttributes>();
  int sequenceNumber=1;
  List<CommunicationAspectAttributes> communicationAspectList=this.attributeList(CommunicationAspectAttributes.class);
  if (communicationAspectList.size() > 0) {
    try {
      _workspace.getWriteAccess();
      List<CommunicationAspectAttributes> enabledAttributes=new ArrayList();
      for (int i=0; i < communicationAspectList.size(); i++) {
        CommunicationAspectAttributes attribute=communicationAspectList.get(i);
        if (((BooleanToken)attribute.enable.getToken()).booleanValue()) {
          enabledAttributes.add(attribute);
          int s=((IntToken)attribute.sequenceNumber.getToken()).intValue();
          if (s > sequenceNumber) {
            sequenceNumber=s;
          }
        }
 else {
          attribute.sequenceNumber.setToken(new IntToken(-1));
        }
      }
      sequenceNumber=sequenceNumber + 1;
      for (int i=0; i < enabledAttributes.size(); i++) {
        final CommunicationAspectAttributes attribute=enabledAttributes.get(i);
        final int seqNum=sequenceNumber;
        CommunicationAspect communicationAspect=(CommunicationAspect)attribute.getDecorator();
        int oldSeqNum=((IntToken)attribute.sequenceNumber.getToken()).intValue();
        if (oldSeqNum == -1 && communicationAspect != null && !_communicationAspects.contains(communicationAspect)) {
          attribute.sequenceNumber.setToken(new IntToken(seqNum));
          _communicationAspectMap.put(seqNum,attribute);
          sequenceNumber=sequenceNumber + 1;
        }
 else {
          _communicationAspectMap.put(oldSeqNum,attribute);
        }
      }
      _communicationAspects.clear();
      Iterator<Integer> iterator=_communicationAspectMap.keySet().iterator();
      int i=1;
      while (iterator.hasNext()) {
        CommunicationAspectAttributes attribute=_communicationAspectMap.get(iterator.next());
        attribute.sequenceNumber.setToken(new IntToken(i));
        i=i + 1;
        Decorator decorator=attribute.getDecorator();
        if (decorator != null) {
          _communicationAspects.add((CommunicationAspect)decorator);
        }
      }
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
 finally {
      _workspace.doneWriting();
    }
  }
  _communicationAspectsValid=true;
  return _communicationAspects;
}"
72827,"/** 
 * Render a visual representation of the given node. If the StringAttribute _color of the node is set then use that color to highlight the node. If the StringAttribute _explanation of the node is set then use it to set the tooltip.
 * @see diva.graph.NodeRenderer#render(java.lang.Object)
 */
public Figure render(Object n){
  Locatable location=(Locatable)n;
  final NamedObj object=location.getContainer();
  Figure result=null;
  try {
    List iconList=object.attributeList(EditorIcon.class);
    if (iconList.size() == 0) {
      XMLIcon alreadyCreated=(XMLIcon)_iconsPendingContainer.get(object);
      if (alreadyCreated != null) {
        iconList.add(alreadyCreated);
      }
    }
    if (iconList.size() == 0) {
      final EditorIcon icon=XMLIcon.getXMLIcon(object.workspace(),""String_Node_Str"");
      icon.setContainerToBe(object);
      icon.setPersistent(false);
      result=icon.createFigure();
      _iconsPendingContainer.put(object,icon);
      GraphController controller=IconController.this.getController();
      GraphModel graphModel=controller.getGraphModel();
      ChangeRequest request=new ChangeRequest(graphModel,""String_Node_Str""){
        protected void _execute() throws KernelException {
          _iconsPendingContainer.remove(object);
          if (icon.getContainer() != null) {
            return;
          }
          if (object.getAttribute(""String_Node_Str"") != null) {
            return;
          }
          icon.setContainer(object);
        }
      }
;
      request.setPersistent(false);
      object.requestChange(request);
    }
 else     if (iconList.size() >= 1) {
      EditorIcon icon=(EditorIcon)iconList.get(iconList.size() - 1);
      result=icon.createFigure();
    }
  }
 catch (  KernelException ex) {
    throw new InternalErrorException(null,ex,""String_Node_Str"" + ""String_Node_Str"" + object + ""String_Node_Str""+ ""String_Node_Str"");
  }
  if (result == null) {
    throw new InternalErrorException(""String_Node_Str"");
  }
 else {
    result.setToolTipText(object.getClassName());
  }
  try {
    StringAttribute colorAttr=(StringAttribute)object.getAttribute(""String_Node_Str"",StringAttribute.class);
    if (colorAttr != null) {
      String color=colorAttr.getExpression();
      AnimationRenderer animationRenderer=new AnimationRenderer(SVGUtilities.getColor(color));
      animationRenderer.renderSelected(result);
    }
  }
 catch (  IllegalActionException e) {
  }
  AttributeController.renderHighlight(object,result);
  try {
    Attribute highlightColor=object.getAttribute(""String_Node_Str"");
    if (highlightColor != null) {
      object.removeAttribute(highlightColor);
      object.validateSettables();
    }
    List<Decorator> decorators=new ArrayList();
    decorators.addAll(object.decorators());
    for (    Decorator decorator : decorators) {
      DecoratorAttributes decoratorAttributes=object.getDecoratorAttributes(decorator);
      if (decoratorAttributes instanceof ExecutionAttributes) {
        if (decoratorAttributes.getDecorator() != null && ((ExecutionAttributes)decoratorAttributes).enabled()) {
          try {
            if (object.getAttribute(""String_Node_Str"") == null) {
              highlightColor=new ColorAttribute(object,""String_Node_Str"");
              Attribute attribute=((NamedObj)decorator).getAttribute(""String_Node_Str"");
              String colorExpression=""String_Node_Str"";
              if (attribute != null) {
                colorExpression=(((ColorAttribute)attribute).getToken()).toString();
              }
              ((ColorAttribute)highlightColor).setExpression(colorExpression);
            }
          }
 catch (          NameDuplicationException e) {
          }
        }
      }
    }
  }
 catch (  IllegalActionException e1) {
    e1.printStackTrace();
  }
  AttributeController.renderDecoratorHighlight(object,result);
  try {
    ColorAttribute shadowAttribute=(ColorAttribute)object.getAttribute(""String_Node_Str"",ColorAttribute.class);
    if (shadowAttribute != null) {
      if (!shadowAttribute.getExpression().trim().equals(""String_Node_Str"")) {
        Color color=shadowAttribute.asColor();
        ShadowRenderer animationRenderer=new ShadowRenderer(color);
        animationRenderer.renderSelected(result);
      }
    }
 else     if (object instanceof Entity) {
      NamedObj container=object.getContainer();
      if (container != null) {
        shadowAttribute=(ColorAttribute)container.getAttribute(""String_Node_Str"",ColorAttribute.class);
        if (shadowAttribute != null && !shadowAttribute.getExpression().trim().equals(""String_Node_Str"")) {
          Color color=shadowAttribute.asColor();
          ShadowRenderer animationRenderer=new ShadowRenderer(color);
          animationRenderer.renderSelected(result);
        }
      }
    }
  }
 catch (  IllegalActionException e) {
  }
  try {
    StringAttribute explanationAttribute=(StringAttribute)object.getAttribute(""String_Node_Str"",StringAttribute.class);
    if (explanationAttribute != null) {
      result.setToolTipText(explanationAttribute.getExpression());
    }
  }
 catch (  IllegalActionException e) {
  }
  return result;
}","/** 
 * Render a visual representation of the given node. If the StringAttribute _color of the node is set then use that color to highlight the node. If the StringAttribute _explanation of the node is set then use it to set the tooltip.
 * @see diva.graph.NodeRenderer#render(java.lang.Object)
 */
public Figure render(Object n){
  Locatable location=(Locatable)n;
  final NamedObj object=location.getContainer();
  Figure result=null;
  try {
    List iconList=object.attributeList(EditorIcon.class);
    if (iconList.size() == 0) {
      XMLIcon alreadyCreated=(XMLIcon)_iconsPendingContainer.get(object);
      if (alreadyCreated != null) {
        iconList.add(alreadyCreated);
      }
    }
    if (iconList.size() == 0) {
      final EditorIcon icon=XMLIcon.getXMLIcon(object.workspace(),""String_Node_Str"");
      icon.setContainerToBe(object);
      icon.setPersistent(false);
      result=icon.createFigure();
      _iconsPendingContainer.put(object,icon);
      GraphController controller=IconController.this.getController();
      GraphModel graphModel=controller.getGraphModel();
      ChangeRequest request=new ChangeRequest(graphModel,""String_Node_Str""){
        protected void _execute() throws KernelException {
          _iconsPendingContainer.remove(object);
          if (icon.getContainer() != null) {
            return;
          }
          if (object.getAttribute(""String_Node_Str"") != null) {
            return;
          }
          icon.setContainer(object);
        }
      }
;
      request.setPersistent(false);
      object.requestChange(request);
    }
 else     if (iconList.size() >= 1) {
      EditorIcon icon=(EditorIcon)iconList.get(iconList.size() - 1);
      result=icon.createFigure();
    }
  }
 catch (  KernelException ex) {
    throw new InternalErrorException(null,ex,""String_Node_Str"" + ""String_Node_Str"" + object + ""String_Node_Str""+ ""String_Node_Str"");
  }
  if (result == null) {
    throw new InternalErrorException(""String_Node_Str"");
  }
 else {
    result.setToolTipText(object.getClassName());
  }
  try {
    StringAttribute colorAttr=(StringAttribute)object.getAttribute(""String_Node_Str"",StringAttribute.class);
    if (colorAttr != null) {
      String color=colorAttr.getExpression();
      AnimationRenderer animationRenderer=new AnimationRenderer(SVGUtilities.getColor(color));
      animationRenderer.renderSelected(result);
    }
  }
 catch (  IllegalActionException e) {
  }
  AttributeController.renderHighlight(object,result);
  try {
    Attribute highlightColor=object.getAttribute(""String_Node_Str"");
    if (highlightColor != null) {
      object.removeAttribute(highlightColor);
    }
    List<Decorator> decorators=new ArrayList();
    decorators.addAll(object.decorators());
    for (    Decorator decorator : decorators) {
      DecoratorAttributes decoratorAttributes=object.getDecoratorAttributes(decorator);
      if (decoratorAttributes instanceof ExecutionAttributes) {
        if (decoratorAttributes.getDecorator() != null && ((ExecutionAttributes)decoratorAttributes).enabled()) {
          try {
            if (object.getAttribute(""String_Node_Str"") == null) {
              highlightColor=new ColorAttribute(object,""String_Node_Str"");
              Attribute attribute=((NamedObj)decorator).getAttribute(""String_Node_Str"");
              String colorExpression=""String_Node_Str"";
              if (attribute != null) {
                colorExpression=(((ColorAttribute)attribute).getToken()).toString();
              }
              ((ColorAttribute)highlightColor).setExpression(colorExpression);
            }
          }
 catch (          NameDuplicationException e) {
          }
        }
      }
    }
  }
 catch (  IllegalActionException e1) {
    e1.printStackTrace();
  }
  AttributeController.renderDecoratorHighlight(object,result);
  try {
    ColorAttribute shadowAttribute=(ColorAttribute)object.getAttribute(""String_Node_Str"",ColorAttribute.class);
    if (shadowAttribute != null) {
      if (!shadowAttribute.getExpression().trim().equals(""String_Node_Str"")) {
        Color color=shadowAttribute.asColor();
        ShadowRenderer animationRenderer=new ShadowRenderer(color);
        animationRenderer.renderSelected(result);
      }
    }
 else     if (object instanceof Entity) {
      NamedObj container=object.getContainer();
      if (container != null) {
        shadowAttribute=(ColorAttribute)container.getAttribute(""String_Node_Str"",ColorAttribute.class);
        if (shadowAttribute != null && !shadowAttribute.getExpression().trim().equals(""String_Node_Str"")) {
          Color color=shadowAttribute.asColor();
          ShadowRenderer animationRenderer=new ShadowRenderer(color);
          animationRenderer.renderSelected(result);
        }
      }
    }
  }
 catch (  IllegalActionException e) {
  }
  try {
    StringAttribute explanationAttribute=(StringAttribute)object.getAttribute(""String_Node_Str"",StringAttribute.class);
    if (explanationAttribute != null) {
      result.setToolTipText(explanationAttribute.getExpression());
    }
  }
 catch (  IllegalActionException e) {
  }
  return result;
}"
72828,"/** 
 * Trim the model name from a full name of an actor or an event. 
 * @param name A full name of an actor or an event.
 * @return The trimmed name.
 */
private String _trimModelName(String name){
}","/** 
 * Trim the model name from a full name of an actor or an event.
 * @param name A full name of an actor or an event.
 * @return The trimmed name.
 */
private String _trimModelName(String name){
}"
72829,"/** 
 * Get the MetroII event associated with the current state and  set the state of the event to be PROPOSED.
 * @return the MetroII event associated with the current state
 */
protected Builder proposeStateEvent(){
  Builder event=getStateEvent();
  event.setStatus(Status.PROPOSED);
  event.clearTime();
  return event;
}","/** 
 * Get the MetroII event associated with the current state and set the state of the event to be PROPOSED.
 * @return the MetroII event associated with the current state
 */
protected Builder proposeStateEvent(){
  Builder event=getStateEvent();
  event.setStatus(Status.PROPOSED);
  event.clearTime();
  return event;
}"
72830,"/** 
 * Get the MetroII event associated with the current state. 
 * @return the MetroII event associated with the current state.
 */
public Builder getStateEvent(){
}","/** 
 * Get the MetroII event associated with the current state.
 * @return the MetroII event associated with the current state.
 */
public Builder getStateEvent(){
}"
72831,"/** 
 * When startOrResume(event_list) is called, the wrapper checks if the Metro event associated with  the current state is notified. If the event is notified, call related function of the  wrapped actor, transition to the next state, and propose the Metro event associated with  the next state. Otherwise stay in the current state. The 'next' state is defined as follows:  PREFIRE_BEGIN -> PREFIRE_END_FIRE_BEGIN -> FIRING -> FIRE_END_POSTFIRE_BEGIN -> POSTFIRE_END -> PREFIRE_BEGIN. The outgoing transitions for PREFIRE_BEGIN is as follows:   guard: PREFIRE_BEGIN is notified    action: call prefire(), propose FIRE_BEGIN PREFIRE_BEGIN ---------------------------------------> PREFIRE_END_FIRE_BEGIN guard: PREFIRE_BEGIN is not notified    action: propose PREFIRE_BEGIN PREFIRE_BEGIN ---------------------------------------> PREFIRE_BEGIN 'propose' means setting the state of the Metro event to be 'PROPOSED' and adding it into  event_list (the parameter of startOrResume(event_list)). Thus the caller of startOrResume  will get a reference to the proposed event. 
 * @param metroIIEventList a list of MetroII events that are proposed. It is set by startOrResume()not the caller.
 * @throws IllegalActionException If firing is not permitted.
 */
@Override public void startOrResume(LinkedList<Builder> metroIIEventList) throws IllegalActionException {
}","/** 
 * When startOrResume(event_list) is called, the wrapper checks if the Metro event associated with the current state is notified. If the event is notified, call related function of the wrapped actor, transition to the next state, and propose the Metro event associated with the next state. Otherwise stay in the current state. The 'next' state is defined as follows: PREFIRE_BEGIN -> PREFIRE_END_FIRE_BEGIN -> FIRING -> FIRE_END_POSTFIRE_BEGIN -> POSTFIRE_END -> PREFIRE_BEGIN. <pre> The outgoing transitions for PREFIRE_BEGIN is as follows:   guard: PREFIRE_BEGIN is notified    action: call prefire(), propose FIRE_BEGIN PREFIRE_BEGIN ---------------------------------------> PREFIRE_END_FIRE_BEGIN guard: PREFIRE_BEGIN is not notified    action: propose PREFIRE_BEGIN PREFIRE_BEGIN ---------------------------------------> PREFIRE_BEGIN </pre> <p> 'propose' means setting the state of the Metro event to be 'PROPOSED' and adding it into event_list (the parameter of startOrResume(event_list)). Thus the caller of startOrResume will get a reference to the proposed event. </p>
 * @param metroIIEventList a list of MetroII events that are proposed. It is set by startOrResume() not the caller.
 * @throws IllegalActionException If firing is not permitted.
 */
@Override public void startOrResume(LinkedList<Builder> metroIIEventList) throws IllegalActionException {
}"
72832,"/** 
 * When startOrResume(event_list) is called, the wrapper checks if the Metro event associated with  the current state is notified. If the event is notified, call related function of the  wrapped actor, transition to the next state, and propose the Metro event associated with  the next state. Otherwise stay in the current state. The 'next' state is defined as follows:  PREFIRE_BEGIN -> PREFIRE_END_FIRE_BEGIN -> FIRING -> FIRE_END_POSTFIRE_BEGIN -> POSTFIRE_END -> PREFIRE_BEGIN. The outgoing transitions for PREFIRE_BEGIN is as follows:   guard: PREFIRE_BEGIN is notified    action: call prefire(), propose FIRE_BEGIN PREFIRE_BEGIN ---------------------------------------> PREFIRE_END_FIRE_BEGIN guard: PREFIRE_BEGIN is not notified    action: propose PREFIRE_BEGIN PREFIRE_BEGIN ---------------------------------------> PREFIRE_BEGIN 'propose' means setting the state of the Metro event to be 'PROPOSED' and adding it into  event_list (the parameter of startOrResume(event_list)). Thus the caller of startOrResume  will get a reference to the proposed event. 
 * @param metroIIEventList a list of MetroII events that are proposed. It is set by startOrResume()not the caller.
 */
@Override public void startOrResume(LinkedList<Builder> metroIIEventList) throws IllegalActionException {
}","/** 
 * When startOrResume(event_list) is called, the wrapper checks if the Metro event associated with  the current state is notified. If the event is notified, call related function of the  wrapped actor, transition to the next state, and propose the Metro event associated with  the next state. Otherwise stay in the current state. The 'next' state is defined as follows:  PREFIRE_BEGIN -> PREFIRE_END_FIRE_BEGIN -> FIRING -> FIRE_END_POSTFIRE_BEGIN -> POSTFIRE_END -> PREFIRE_BEGIN. The outgoing transitions for PREFIRE_BEGIN is as follows:   guard: PREFIRE_BEGIN is notified    action: call prefire(), propose FIRE_BEGIN PREFIRE_BEGIN ---------------------------------------> PREFIRE_END_FIRE_BEGIN guard: PREFIRE_BEGIN is not notified    action: propose PREFIRE_BEGIN PREFIRE_BEGIN ---------------------------------------> PREFIRE_BEGIN 'propose' means setting the state of the Metro event to be 'PROPOSED' and adding it into  event_list (the parameter of startOrResume(event_list)). Thus the caller of startOrResume  will get a reference to the proposed event. 
 * @param metroIIEventList a list of MetroII events that are proposed. It is set by startOrResume()not the caller.
 * @throws IllegalActionException If firing is not permitted.
 */
@Override public void startOrResume(LinkedList<Builder> metroIIEventList) throws IllegalActionException {
}"
72833,"/** 
 * When startOrResume() is called, the wrapper checks if the Metro event associated  with the current state is notified. If the event is notified, call related function  of the wrapped actor, transition to the next state, and propose the  Metro event associated with the next state. If the state is associated with no state  event, simply transition to the next state, and propose the Metro event associated with  the next state. The 'next' state is defined as follows: STAR -> BEGIN -> END -> FINAL.  For example,  action: propose FIRE_BEGIN START ---------------------------------------> BEGIN guard: FIRE_BEGIN is notified    action: call fire(), propose FIRE_END BEGIN ---------------------------------------> FIRE_END guard: FIRE_BEGIN is not notified    action: propose FIRE_BEGIN BEGIN ---------------------------------------> BEGIN
 * @param metroIIEventList a list of MetroII events that are proposed. It is set by startOrResume()not the caller.
 */
@Override public void startOrResume(LinkedList<Builder> metroIIEventList) throws IllegalActionException {
}","/** 
 * When startOrResume() is called, the wrapper checks if the Metro event associated  with the current state is notified. If the event is notified, call related function  of the wrapped actor, transition to the next state, and propose the  Metro event associated with the next state. If the state is associated with no state  event, simply transition to the next state, and propose the Metro event associated with  the next state. The 'next' state is defined as follows: STAR -> BEGIN -> END -> FINAL.  For example,  action: propose FIRE_BEGIN START ---------------------------------------> BEGIN guard: FIRE_BEGIN is notified    action: call fire(), propose FIRE_END BEGIN ---------------------------------------> FIRE_END guard: FIRE_BEGIN is not notified    action: propose FIRE_BEGIN BEGIN ---------------------------------------> BEGIN
 * @param metroIIEventList a list of MetroII events that are proposed. It is set by startOrResume()not the caller.
 * @throws IllegalActionException If firing is not permitted.
 */
@Override public void startOrResume(LinkedList<Builder> metroIIEventList) throws IllegalActionException {
}"
72834,"/** 
 * Update the MetroII events in the specified list
 * @param metroIIEventList A list of MetroII events to be updated
 */
public void resolve(Iterable<Event.Builder> metroIIEventList);","/** 
 * Update the MetroII events in the specified list.
 * @param metroIIEventList a list of MetroII events to be updated.
 */
public void resolve(Iterable<Event.Builder> metroIIEventList);"
72835,"/** 
 * Clone an EventDictionary
 */
public EventDictionary clone() throws CloneNotSupportedException {
  EventDictionary newObject=(EventDictionary)super.clone();
  newObject._eventName2ID=(Hashtable<String,Integer>)_eventName2ID.clone();
  return newObject;
}","/** 
 * Clone an EventDictionary.
 * @throws CloneNotSupportedException the object's class does not implement the Cloneable interface.
 */
@Override public EventDictionary clone() throws CloneNotSupportedException {
  EventDictionary newObject=(EventDictionary)super.clone();
  newObject._eventName2ID=(Hashtable<String,Integer>)_eventName2ID.clone();
  return newObject;
}"
72836,"/** 
 * Construct an EventDictionary
 */
public EventDictionary(){
  _eventName2ID=new Hashtable<String,Integer>();
}","/** 
 * Construct an EventDictionary.
 */
public EventDictionary(){
  _eventName2ID=new Hashtable<String,Integer>();
}"
72837,"private String _trimModelName(String name){
}","/** 
 * Trim the substring until (including) '.' from name.
 * @param name the input string.
 * @return
 */
private String _trimModelName(String name){
}"
72838,"/** 
 * Set the state of the wrapped actor.
 * @param state
 * @see #getState()
 */
protected void setState(State state){
  _state=state;
}","/** 
 * Set the state of the wrapped actor.
 * @param state the state to be set.
 * @see #getState()
 */
protected void setState(State state){
  _state=state;
}"
72839,"/** 
 * An implementation of getfire() has the ability to 'yield return' in getfire() by calling 'resultHandler.handleResult(events)'.
 * @param resultHandler Iterable of events 'yield returned'
 * @exception CollectionAbortedException
 */
public void getfire(ResultHandler<Iterable<Event.Builder>> resultHandler) throws CollectionAbortedException ;","/** 
 * An implementation of getfire() has the ability to 'yield return' in getfire() by calling 'resultHandler.handleResult(events)'.
 * @param resultHandler iterable of events 'yield returned'.
 * @exception CollectionAbortedException
 */
public void getfire(ResultHandler<Iterable<Event.Builder>> resultHandler) throws CollectionAbortedException ;"
72840,"/** 
 * Return the iterator for the caller function of getfire().
 * @return iterator
 */
public YieldAdapterIterable<Iterable<Event.Builder>> adapter();","/** 
 * Return the iterator for the caller function of getfire().
 * @return iterator the iterator for the caller function of getfire()
 */
public YieldAdapterIterable<Iterable<Event.Builder>> adapter();"
72841,"/** 
 * Return the size of edges.
 * @return the size of edges
 */
public int edgeSize(){
  return _edge.size();
}","/** 
 * Return the size of edges.
 * @return the size of edges.
 */
public int edgeSize(){
  return _edge.size();
}"
72842,"/** 
 * Construct a linked list
 */
public Graph(){
  _nodeConnection=new ArrayList<ArrayList<Integer>>();
  _edge=new ArrayList<Pair<Integer,Integer>>();
}","/** 
 * Construct a linked list.
 */
public Graph(){
  _nodeConnection=new ArrayList<ArrayList<Integer>>();
  _edge=new ArrayList<Pair<Integer,Integer>>();
}"
72843,"/** 
 * Clone the linked list
 */
public Graph clone() throws CloneNotSupportedException {
  Graph newObject=(Graph)super.clone();
  newObject._nodeConnection=(ArrayList<ArrayList<Integer>>)_nodeConnection.clone();
  newObject._edge=(ArrayList<Pair<Integer,Integer>>)_edge.clone();
  return newObject;
}","/** 
 * Clone the linked list.
 * @throws CloneNotSupportedException the object's class does not implement the Cloneable interface.
 */
@Override public Graph clone() throws CloneNotSupportedException {
  Graph newObject=(Graph)super.clone();
  newObject._nodeConnection=(ArrayList<ArrayList<Integer>>)_nodeConnection.clone();
  newObject._edge=(ArrayList<Pair<Integer,Integer>>)_edge.clone();
  return newObject;
}"
72844,"/** 
 * Get the edge with the given edge ID
 * @param edgeId the edge Id
 * @return the edge
 */
public Pair<Integer,Integer> getEdge(int edgeId){
  return _edge.get(edgeId);
}","/** 
 * Get the edge with the given edge ID.
 * @param edgeId the edge Id.
 * @return the edge.
 */
public Pair<Integer,Integer> getEdge(int edgeId){
  return _edge.get(edgeId);
}"
72845,"/** 
 * Read mapping constraints from a file
 * @param filename Filename of the mapping constraint file.
 * @exception IOException
 */
public void readMapping(String filename) throws IOException {
}","/** 
 * Read mapping constraints from a file.
 * @param filename Filename of the mapping constraint file.
 * @exception IOException a failed or interrupted I/O operations has occurred.
 */
public void readMapping(String filename) throws IOException {
}"
72846,"/** 
 * Add a mapping constraint
 * @param eventName1 first event in the mapping
 * @param eventName2 second event in the mapping
 */
public void addMapping(String eventName1,String eventName2){
  _eventIDDictionary.add(eventName1);
  _eventIDDictionary.add(eventName2);
  int id1=_eventIDDictionary.getID(eventName1);
  int id2=_eventIDDictionary.getID(eventName2);
  _mapping.add(id1,id2);
}","/** 
 * Add a mapping constraint.
 * @param eventName1 first event in the mapping.
 * @param eventName2 second event in the mapping.
 */
public void addMapping(String eventName1,String eventName2){
  _eventIDDictionary.add(eventName1);
  _eventIDDictionary.add(eventName2);
  int id1=_eventIDDictionary.getID(eventName1);
  int id2=_eventIDDictionary.getID(eventName2);
  _mapping.add(id1,id2);
}"
72847,"/** 
 * Return the number of mapping constraints
 * @return the number of mapping constraints
 */
public int numConstraints(){
  return _mapping.edgeSize();
}","/** 
 * Return the number of mapping constraints.
 * @return the number of mapping constraints.
 */
public int numConstraints(){
  return _mapping.edgeSize();
}"
72848,"/** 
 * turn on debugging option
 */
public void turnOnDebugging(){
  _debugging=true;
}","/** 
 * Turn on debugging option.
 */
public void turnOnDebugging(){
  _debugging=true;
}"
72849,"/** 
 * turn off debugging option
 */
public void turnOffDebugging(){
  _debugging=false;
}","/** 
 * Turn off debugging option.
 */
public void turnOffDebugging(){
  _debugging=false;
}"
72850,"/** 
 * Schedule a new actor for execution and return the next time this scheduler has to perform a reschedule.
 * @param actor The actor to be scheduled.
 * @param currentPlatformTime The current platform time.
 * @param deadline The event deadline - not used here.
 * @param executionTime The execution time of the actor.
 * @return Relative time when this Scheduler has to be executedagain.
 * @exception IllegalActionException Thrown if actor parameters suchas execution time or priority cannot be read.
 */
@Override public Time schedule(Actor actor,Time currentPlatformTime,Time deadline,Time executionTime) throws IllegalActionException {
  super.schedule(actor,currentPlatformTime,deadline,executionTime);
  _lastActorFinished=false;
  Time remainingTime=null;
  if (_currentlyExecuting.size() == 0) {
    scheduleNewActor(actor,currentPlatformTime,executionTime);
    remainingTime=executionTime;
  }
 else {
    Actor executing=_currentlyExecuting.peek();
    Time lasttime=_lastTimeScheduled.get(executing);
    Time timePassed=currentPlatformTime.subtract(lasttime);
    remainingTime=_remainingTimes.get(executing).subtract(timePassed);
    if (remainingTime.getDoubleValue() < 0) {
      throw new IllegalActionException(this,""String_Node_Str"");
    }
    _remainingTimes.put(executing,remainingTime);
    if (!_currentlyExecuting.contains(actor) && executing != actor) {
      if (_preemptive) {
        double executingPriority=_getPriority(executing);
        double newActorPriority=_getPriority(actor);
        if (newActorPriority < executingPriority) {
          if (remainingTime.getDoubleValue() == 0.0) {
            notifyScheduleListeners((NamedObj)_currentlyExecuting.peek(),currentPlatformTime.getDoubleValue(),ExecutionEventType.STOP);
          }
 else {
            notifyScheduleListeners((NamedObj)executing,currentPlatformTime.getDoubleValue(),ExecutionEventType.PREEMPTED);
          }
          remainingTime=executionTime;
          scheduleNewActor(actor,currentPlatformTime,executionTime);
        }
 else {
          _add(actor,executionTime);
        }
      }
 else {
        Object[] actors=_currentlyExecuting.toArray();
        _currentlyExecuting.clear();
        for (int j=0; j < actors.length; j++) {
          _currentlyExecuting.push((Actor)actors[j]);
        }
        _currentlyExecuting.push(actor);
        _remainingTimes.put(actor,executionTime);
      }
    }
    for (    Actor preemptedActor : _currentlyExecuting) {
      _lastTimeScheduled.put(preemptedActor,currentPlatformTime);
    }
  }
  if (remainingTime.getDoubleValue() == 0.0 && _currentlyExecuting.peek() == actor) {
    notifyScheduleListeners((NamedObj)_currentlyExecuting.peek(),currentPlatformTime.getDoubleValue(),ExecutionEventType.STOP);
    _remainingTimes.put(_currentlyExecuting.peek(),null);
    _currentlyExecuting.pop();
    if (_currentlyExecuting.size() > 0) {
      remainingTime=_remainingTimes.get(_currentlyExecuting.peek());
      if (remainingTime.getDoubleValue() > 0.0) {
        notifyScheduleListeners((NamedObj)_currentlyExecuting.peek(),currentPlatformTime.getDoubleValue(),ExecutionEventType.START);
      }
    }
    _lastActorFinished=true;
    _lastActorThatFinished=actor;
  }
  return remainingTime;
}","/** 
 * Schedule a new actor for execution and return the next time this scheduler has to perform a reschedule.
 * @param actor The actor to be scheduled.
 * @param currentPlatformTime The current platform time.
 * @param deadline The event deadline - not used here.
 * @param executionTime The execution time of the actor.
 * @return Relative time when this Scheduler has to be executedagain.
 * @exception IllegalActionException Thrown if actor parameters suchas execution time or priority cannot be read.
 */
@Override public Time schedule(Actor actor,Time currentPlatformTime,Time deadline,Time executionTime) throws IllegalActionException {
  super.schedule(actor,currentPlatformTime,deadline,executionTime);
  _lastActorFinished=false;
  Time remainingTime=null;
  if (_currentlyExecuting.size() == 0) {
    scheduleNewActor(actor,currentPlatformTime,executionTime);
    remainingTime=executionTime;
  }
 else {
    Actor executing=_currentlyExecuting.peek();
    Time lasttime=_lastTimeScheduled.get(executing);
    Time timePassed=currentPlatformTime.subtract(lasttime);
    remainingTime=_remainingTimes.get(executing).subtract(timePassed);
    _remainingTimes.put(executing,remainingTime);
    if (!_currentlyExecuting.contains(actor) && executing != actor) {
      if (_preemptive) {
        double executingPriority=_getPriority(executing);
        double newActorPriority=_getPriority(actor);
        if (newActorPriority < executingPriority) {
          if (remainingTime.getDoubleValue() == 0.0) {
            notifyScheduleListeners((NamedObj)_currentlyExecuting.peek(),currentPlatformTime.getDoubleValue(),ExecutionEventType.STOP);
          }
 else {
            notifyScheduleListeners((NamedObj)executing,currentPlatformTime.getDoubleValue(),ExecutionEventType.PREEMPTED);
          }
          remainingTime=executionTime;
          scheduleNewActor(actor,currentPlatformTime,executionTime);
        }
 else {
          _add(actor,executionTime);
        }
      }
 else {
        Object[] actors=_currentlyExecuting.toArray();
        _currentlyExecuting.clear();
        for (int j=0; j < actors.length; j++) {
          _currentlyExecuting.push((Actor)actors[j]);
        }
        _currentlyExecuting.push(actor);
        _remainingTimes.put(actor,executionTime);
      }
    }
    for (    Actor preemptedActor : _currentlyExecuting) {
      _lastTimeScheduled.put(preemptedActor,currentPlatformTime);
    }
  }
  if (remainingTime.getDoubleValue() == 0.0 && _currentlyExecuting.peek() == actor) {
    notifyScheduleListeners((NamedObj)_currentlyExecuting.peek(),currentPlatformTime.getDoubleValue(),ExecutionEventType.STOP);
    _remainingTimes.put(_currentlyExecuting.peek(),null);
    _currentlyExecuting.pop();
    if (_currentlyExecuting.size() > 0) {
      remainingTime=_remainingTimes.get(_currentlyExecuting.peek());
      if (remainingTime.getDoubleValue() > 0.0) {
        notifyScheduleListeners((NamedObj)_currentlyExecuting.peek(),currentPlatformTime.getDoubleValue(),ExecutionEventType.START);
      }
    }
    _lastActorFinished=true;
    _lastActorThatFinished=actor;
  }
  return remainingTime;
}"
72851,"private void _add(Actor actor,Time executionTime) throws IllegalActionException {
  double priority=_getPriority(actor);
  boolean added=false;
  Object[] actors=_currentlyExecuting.toArray();
  _currentlyExecuting.clear();
  for (int i=0; i < actors.length; i++) {
    Actor actorInArray=(Actor)actors[i];
    double actorInArrayPriority=_getPriority(actorInArray);
    if (!added && priority > actorInArrayPriority) {
      _currentlyExecuting.push(actor);
      _remainingTimes.put(actor,executionTime);
      added=true;
    }
    _currentlyExecuting.push(actorInArray);
  }
}","private void _add(Actor actor,Time executionTime) throws IllegalActionException {
  double priority=_getPriority(actor);
  boolean added=false;
  Object[] actors=_currentlyExecuting.toArray();
  _currentlyExecuting.clear();
  for (int i=0; i < actors.length; i++) {
    Actor actorInArray=(Actor)actors[i];
    double actorInArrayPriority=_getPriority(actorInArray);
    if (!added && priority >= actorInArrayPriority) {
      _currentlyExecuting.push(actor);
      _remainingTimes.put(actor,executionTime);
      added=true;
    }
    _currentlyExecuting.push(actorInArray);
  }
}"
72852,"/** 
 * Parse the published item from the XMPP node, save the XML and request that the actor be fired. This method is declared in the smack ItemEventListener interface. This method is called when an item is published. NOTE: This method is synchronized, and the lock is _not_ released until the method is finished processing the current item event.  The first item event is completely processed before a second item event can be started.
 * @param items  The item event from the XMPP node.  Can containmultiple pieces of information.
 */
@Override public synchronized void handlePublishedItems(ItemPublishEvent<Item> items){
  while (!_hasInitialized) {
    try {
      this.wait(0);
    }
 catch (    InterruptedException e) {
      break;
    }
  }
  _handlePublishedItems(items);
}","/** 
 * Parse the published item from the XMPP node, save the XML and request that the actor be fired. This method is declared in the smack ItemEventListener interface. This method is called when an item is published. NOTE: This method is synchronized, and the lock is _not_ released until the method is finished processing the current item event.  The first item event is completely processed before a second item event can be started.
 * @param items  The item event from the XMPP node.  Can containmultiple pieces of information.
 */
@Override public synchronized void handlePublishedItems(ItemPublishEvent<Item> items){
  while (!_hasInitialized) {
    try {
      this.wait(0);
    }
 catch (    InterruptedException e) {
      break;
    }
  }
  _handlePublishedItems(items);
  this.notify();
}"
72853,"/** 
 * Parse the published item from the XMPP node, save the XML and request that the actor be fired.  Synchronized on a lock object so this method will release the lock on the lock object so the fire() method may execute, but retain the lock on XMPPSource.this object so that future invocations of handlePublishedItems() must block until the current invocation is finished.
 * @param items  The item event from the XMPP node.  Can containmultiple pieces of information.
 */
private void _handlePublishedItems(ItemPublishEvent<Item> items){
synchronized (lock) {
    _hasFired=false;
    PayloadItem<SimplePayload> item=(PayloadItem<SimplePayload>)items.getItems().get(0);
    SimplePayload payload=item.getPayload();
    _currentValue=payload.toXML();
    try {
      long elapsedRealTime=System.currentTimeMillis() - _initializeRealTime;
      Time timeOfRequest=_initializeModelTime.add(elapsedRealTime);
      getDirector().fireAt(XMPPSource.this,timeOfRequest);
    }
 catch (    IllegalActionException e) {
      throw new InternalErrorException(this,e,""String_Node_Str"");
    }
    while (!_hasFired) {
      try {
        lock.wait(0);
      }
 catch (      InterruptedException e) {
        break;
      }
    }
  }
}","/** 
 * Parse the published item from the XMPP node, save the XML and request that the actor be fired.  Synchronized on a lock object so this method will release the lock on the lock object so the fire() method may execute, but retain the lock on XMPPSource.this object so that future invocations of handlePublishedItems() must block until the current invocation is finished.
 * @param items  The item event from the XMPP node.  Can containmultiple pieces of information.
 */
private void _handlePublishedItems(ItemPublishEvent<Item> items){
synchronized (lock) {
    _hasFired=false;
    PayloadItem<SimplePayload> item=(PayloadItem<SimplePayload>)items.getItems().get(0);
    SimplePayload payload=item.getPayload();
    _currentValue=payload.toXML();
    try {
      long elapsedRealTime=System.currentTimeMillis() - _initializeRealTime;
      elapsedRealTime=elapsedRealTime / 1000;
      Time timeOfRequest=_initializeModelTime.add(elapsedRealTime);
      getDirector().fireAt(XMPPSource.this,timeOfRequest);
    }
 catch (    IllegalActionException e) {
      throw new InternalErrorException(this,e,""String_Node_Str"");
    }
    while (!_hasFired) {
      try {
        lock.wait(0);
      }
 catch (      InterruptedException e) {
        break;
      }
    }
  }
}"
72854,"/** 
 * Dequeue the events that have the smallest tag from the event queue. Return their destination actor. Advance the model tag to their tag. If the timestamp of the smallest tag is greater than the stop time then return null. If there are no events in the event queue, and the stopWhenQueueIsEmpty parameter is set to true, then return null. Both cases will have the effect of stopping the simulation. <p> If the stopWhenQueueIsEmpty parameter is false and the queue is empty, then stall the current thread by calling wait() on the _eventQueue until there are new events available.  If the synchronizeToRealTime parameter is true, then this method may suspend the calling thread by using Object.wait(long) to let elapsed real time catch up with the current model time.</p>
 * @return The next actor to be fired, which can be null.
 * @exception IllegalActionException If event queue is not ready, oran event is missed, or time is set backwards.
 */
protected Actor _getNextActorToFire() throws IllegalActionException {
  if (_eventQueue == null) {
    throw new IllegalActionException(""String_Node_Str"");
  }
  Actor actorToFire=null;
  DEEvent lastFoundEvent=null;
  DEEvent nextEvent=null;
  while (!_stopRequested) {
    if (_stopWhenQueueIsEmpty) {
      if (_eventQueue.isEmpty()) {
        break;
      }
    }
    if (isEmbedded()) {
      if (_eventQueue.isEmpty()) {
        break;
      }
      nextEvent=_eventQueue.get();
      if (nextEvent.timeStamp().compareTo(getModelTime()) < 0) {
        throw new IllegalActionException(""String_Node_Str"" + nextEvent.timeStamp() + ""String_Node_Str""+ nextEvent.microstep()+ ""String_Node_Str""+ getModelTime()+ ""String_Node_Str""+ _microstep+ ""String_Node_Str"");
      }
      boolean microstepMatches=true;
      Nameable container=getContainer();
      if (container instanceof CompositeActor) {
        Director executiveDirector=((CompositeActor)container).getExecutiveDirector();
        if (executiveDirector instanceof SuperdenseTimeDirector && !_isTopLevel()) {
          microstepMatches=nextEvent.microstep() <= _microstep;
        }
      }
      int comparison=nextEvent.timeStamp().compareTo(getModelTime());
      if (comparison > 0 || comparison == 0 && !microstepMatches) {
        nextEvent=null;
        break;
      }
    }
 else {
      if (_eventQueue.isEmpty()) {
        if (actorToFire != null || getModelTime().equals(getModelStopTime())) {
          break;
        }
      }
synchronized (_eventQueue) {
        while (_eventQueue.isEmpty() && !_stopRequested && !_stopFireRequested) {
          if (_debugging) {
            _debug(""String_Node_Str"");
          }
          try {
            workspace().wait(_eventQueue);
          }
 catch (          InterruptedException e) {
            break;
          }
        }
        if (_eventQueue.isEmpty()) {
          return null;
        }
        nextEvent=_eventQueue.get();
      }
    }
    if (actorToFire == null) {
      Time currentTime;
      int depth=0;
      try {
synchronized (_eventQueue) {
          lastFoundEvent=_eventQueue.get();
          currentTime=_consultTimeRegulators(lastFoundEvent.timeStamp());
          if (_synchronizeToRealTime) {
            while (!_stopRequested && !_stopFireRequested) {
              lastFoundEvent=_eventQueue.get();
              currentTime=lastFoundEvent.timeStamp();
              long elapsedTime=System.currentTimeMillis() - _realStartTime;
              double elapsedTimeInSeconds=elapsedTime / 1000.0;
              ptolemy.actor.util.Time elapsed=new ptolemy.actor.util.Time(this,elapsedTimeInSeconds);
              if (currentTime.compareTo(elapsed) <= 0) {
                break;
              }
              long timeToWait=(long)(currentTime.subtract(elapsed).getDoubleValue() * 1000.0);
              if (timeToWait > 0) {
                if (_debugging) {
                  _debug(""String_Node_Str"" + timeToWait);
                }
                try {
                  depth=_workspace.releaseReadPermission();
                  _eventQueue.wait(timeToWait);
                }
 catch (                InterruptedException ex) {
                  throw new IllegalActionException(this,ex,""String_Node_Str"" + ""String_Node_Str"");
                }
              }
            }
            if (_stopRequested || _stopFireRequested) {
              return null;
            }
          }
        }
      }
  finally {
        if (depth > 0) {
          _workspace.reacquireReadPermission(depth);
        }
      }
synchronized (_eventQueue) {
        lastFoundEvent=_eventQueue.take();
        currentTime=lastFoundEvent.timeStamp();
        actorToFire=lastFoundEvent.actor();
        if (_disabledActors != null && _disabledActors.contains(actorToFire)) {
          if (_debugging) {
            _debug(""String_Node_Str"",((Nameable)actorToFire).getFullName());
          }
          actorToFire=null;
          continue;
        }
        setModelTime(currentTime);
        _microstep=lastFoundEvent.microstep();
        if (_debugging) {
          _debug(""String_Node_Str"" + currentTime + ""String_Node_Str""+ _microstep+ ""String_Node_Str"");
        }
      }
      if (currentTime.compareTo(getModelStopTime()) > 0) {
        if (_debugging) {
          _debug(""String_Node_Str"");
        }
        _exceedStopTime=true;
        return null;
      }
    }
 else {
      if (nextEvent.hasTheSameTagAs(lastFoundEvent) && nextEvent.actor() == actorToFire) {
synchronized (_eventQueue) {
          _eventQueue.take();
        }
      }
 else {
        break;
      }
    }
    if (actorToFire != null && _resourceScheduling) {
      if (_actorsFinished.contains(actorToFire)) {
        _actorsFinished.remove(actorToFire);
      }
 else       if (!_schedule(actorToFire,getModelTime())) {
        Time nextScheduleTime=_nextScheduleTime.get(_schedulerForActor.get(actorToFire)).add(getModelTime());
        if (_actorsInExecution == null) {
          _actorsInExecution=new HashMap();
        }
        _actorsInExecution.put(actorToFire,lastFoundEvent);
        actorToFire=null;
      }
    }
  }
  return actorToFire;
}","/** 
 * Dequeue the events that have the smallest tag from the event queue. Return their destination actor. Advance the model tag to their tag. If the timestamp of the smallest tag is greater than the stop time then return null. If there are no events in the event queue, and the stopWhenQueueIsEmpty parameter is set to true, then return null. Both cases will have the effect of stopping the simulation. <p> If the stopWhenQueueIsEmpty parameter is false and the queue is empty, then stall the current thread by calling wait() on the _eventQueue until there are new events available.  If the synchronizeToRealTime parameter is true, then this method may suspend the calling thread by using Object.wait(long) to let elapsed real time catch up with the current model time.</p>
 * @return The next actor to be fired, which can be null.
 * @exception IllegalActionException If event queue is not ready, oran event is missed, or time is set backwards.
 */
protected Actor _getNextActorToFire() throws IllegalActionException {
  if (_eventQueue == null) {
    throw new IllegalActionException(""String_Node_Str"");
  }
  Actor actorToFire=null;
  DEEvent lastFoundEvent=null;
  DEEvent nextEvent=null;
  while (!_stopRequested) {
    if (_stopWhenQueueIsEmpty) {
      if (_eventQueue.isEmpty()) {
        break;
      }
    }
    if (isEmbedded()) {
      if (_eventQueue.isEmpty()) {
        break;
      }
      nextEvent=_eventQueue.get();
      if (nextEvent.timeStamp().compareTo(getModelTime()) < 0) {
        throw new IllegalActionException(""String_Node_Str"" + nextEvent.timeStamp() + ""String_Node_Str""+ nextEvent.microstep()+ ""String_Node_Str""+ getModelTime()+ ""String_Node_Str""+ _microstep+ ""String_Node_Str"");
      }
      boolean microstepMatches=true;
      Nameable container=getContainer();
      if (container instanceof CompositeActor) {
        Director executiveDirector=((CompositeActor)container).getExecutiveDirector();
        if (executiveDirector instanceof SuperdenseTimeDirector && !_isTopLevel()) {
          microstepMatches=nextEvent.microstep() <= _microstep;
        }
      }
      int comparison=nextEvent.timeStamp().compareTo(getModelTime());
      if (comparison > 0 || comparison == 0 && !microstepMatches) {
        nextEvent=null;
        break;
      }
    }
 else {
      if (_eventQueue.isEmpty()) {
        if (actorToFire != null || getModelTime().equals(getModelStopTime())) {
          break;
        }
      }
synchronized (_eventQueue) {
        while (_eventQueue.isEmpty() && !_stopRequested && !_stopFireRequested) {
          if (_debugging) {
            _debug(""String_Node_Str"");
          }
          try {
            workspace().wait(_eventQueue);
          }
 catch (          InterruptedException e) {
            break;
          }
        }
        if (_eventQueue.isEmpty()) {
          return null;
        }
        nextEvent=_eventQueue.get();
      }
    }
    if (actorToFire == null) {
      Time currentTime;
      int depth=0;
      try {
synchronized (_eventQueue) {
          lastFoundEvent=_eventQueue.get();
          currentTime=_consultTimeRegulators(lastFoundEvent.timeStamp());
          if (_synchronizeToRealTime) {
            while (!_stopRequested && !_stopFireRequested) {
              lastFoundEvent=_eventQueue.get();
              currentTime=lastFoundEvent.timeStamp();
              long elapsedTime=System.currentTimeMillis() - _realStartTime;
              double elapsedTimeInSeconds=elapsedTime / 1000.0;
              ptolemy.actor.util.Time elapsed=new ptolemy.actor.util.Time(this,elapsedTimeInSeconds);
              if (currentTime.compareTo(elapsed) <= 0) {
                break;
              }
              long timeToWait=(long)(currentTime.subtract(elapsed).getDoubleValue() * 1000.0);
              if (timeToWait > 0) {
                if (_debugging) {
                  _debug(""String_Node_Str"" + timeToWait);
                }
                try {
                  depth=_workspace.releaseReadPermission();
                  _eventQueue.wait(timeToWait);
                }
 catch (                InterruptedException ex) {
                  throw new IllegalActionException(this,ex,""String_Node_Str"" + ""String_Node_Str"");
                }
              }
            }
            if (_stopRequested || _stopFireRequested) {
              return null;
            }
          }
        }
      }
  finally {
        if (depth > 0) {
          _workspace.reacquireReadPermission(depth);
        }
      }
synchronized (_eventQueue) {
        lastFoundEvent=_eventQueue.take();
        currentTime=lastFoundEvent.timeStamp();
        actorToFire=lastFoundEvent.actor();
        if (_disabledActors != null && _disabledActors.contains(actorToFire)) {
          if (_debugging) {
            _debug(""String_Node_Str"",((Nameable)actorToFire).getFullName());
          }
          actorToFire=null;
          continue;
        }
        setModelTime(currentTime);
        _microstep=lastFoundEvent.microstep();
        if (_debugging) {
          _debug(""String_Node_Str"" + currentTime + ""String_Node_Str""+ _microstep+ ""String_Node_Str"");
        }
      }
      if (currentTime.compareTo(getModelStopTime()) > 0) {
        if (_debugging) {
          _debug(""String_Node_Str"");
        }
        _exceedStopTime=true;
        return null;
      }
    }
 else {
      if (nextEvent.hasTheSameTagAs(lastFoundEvent) && nextEvent.actor() == actorToFire) {
synchronized (_eventQueue) {
          _eventQueue.take();
        }
      }
 else {
        break;
      }
    }
    if (actorToFire != null && _resourceScheduling) {
      if (_actorsFinished.contains(actorToFire)) {
        _actorsFinished.remove(actorToFire);
      }
 else       if (!_schedule(actorToFire,getModelTime())) {
        Time nextScheduleTime=_nextScheduleTime.get(_schedulerForActor.get(actorToFire)).add(getModelTime());
        if (_actorsInExecution == null) {
          _actorsInExecution=new HashMap();
        }
        List<DEEvent> events=_actorsInExecution.get(actorToFire);
        if (events == null) {
          events=new ArrayList<DEEvent>();
        }
        events.add(lastFoundEvent);
        _actorsInExecution.put(actorToFire,events);
        actorToFire=null;
      }
    }
  }
  return actorToFire;
}"
72855,"/** 
 * Resume the execution of an actor that was previously blocked because it didn't have all the resources it needed for execution. This method  puts an event into the queue for the current time.
 * @param actor The actor that resumes execution.
 * @throws IllegalActionException Not thrown here but in derived classes.
 */
public void resumeActor(Actor actor) throws IllegalActionException {
  DEEvent event=_actorsInExecution.get(actor);
  Time time=((CompositeActor)_getResourceScheduler(actor).getContainer()).getDirector().getModelTime();
  if (event.ioPort() != null) {
    _enqueueTriggerEvent(event.ioPort(),time);
  }
 else {
    _enqueueEvent(actor,time,1);
  }
  fireContainerAt(time);
  _actorsInExecution.remove(actor);
  if (_actorsFinished == null) {
    _actorsFinished=new ArrayList();
  }
  _actorsFinished.add(actor);
}","/** 
 * Resume the execution of an actor that was previously blocked because it didn't have all the resources it needed for execution. This method  puts an event into the queue for the current time.
 * @param actor The actor that resumes execution.
 * @throws IllegalActionException Not thrown here but in derived classes.
 */
public void resumeActor(Actor actor) throws IllegalActionException {
  List<DEEvent> events=_actorsInExecution.get(actor);
  Time time=((CompositeActor)_getResourceScheduler(actor).getContainer()).getDirector().getModelTime();
  if (events == null || events.size() == 0) {
    events=null;
  }
  DEEvent event=events.get(0);
  events.remove(event);
  _actorsInExecution.put(actor,events);
  if (event.ioPort() != null) {
    _enqueueTriggerEvent(event.ioPort(),time);
  }
 else {
    _enqueueEvent(actor,time,1);
  }
  fireContainerAt(time);
  if (_actorsFinished == null) {
    _actorsFinished=new ArrayList();
  }
  _actorsFinished.add(actor);
}"
72856,"/** 
 * Invoke the wrapup() of the super class.  Leave and quit OpenModelica environment.
 * @throws IllegalActionException If the wrapup() ofOpenModelica actor throws it.
 */
public void wrapup() throws IllegalActionException {
  super.wrapup();
  try {
    _omcProxy.quitServer();
    String loggerInfo=""String_Node_Str"";
    _omcLogger.getInfo(loggerInfo);
  }
 catch (  ConnectException e) {
    new IllegalActionException(""String_Node_Str"").printStackTrace();
  }
}","/** 
 * Invoke the wrapup() of the super class.  Leave and quit OpenModelica environment.
 * @throws IllegalActionException If the wrapup() ofOpenModelica actor throws it.
 */
public void wrapup() throws IllegalActionException {
  super.wrapup();
  try {
    _omcProxy.quitServer();
  }
 catch (  ConnectException e) {
    new IllegalActionException(""String_Node_Str"").printStackTrace();
  }
}"
72857,"/** 
 * Clone the object into the specified workspace. The new object is <i>not</i> added to the directory of that workspace (you must do this yourself if you want it there).
 * @param workspace The workspace for the cloned object.
 * @exception CloneNotSupportedException Not thrown in this base class
 * @return The new Attribute.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  OpenModelicaDirector newObject=(OpenModelicaDirector)super.clone(workspace);
  try {
    newObject._omcLogger=OMCLogger.getInstance();
    newObject._omcProxy=OMCProxy.getInstance();
  }
 catch (  Throwable throwable) {
    throw new CloneNotSupportedException(""String_Node_Str"" + getFullName() + ""String_Node_Str""+ throwable);
  }
  return newObject;
}","/** 
 * Clone the object into the specified workspace. The new object is <i>not</i> added to the directory of that workspace (you must do this yourself if you want it there).
 * @param workspace The workspace for the cloned object.
 * @exception CloneNotSupportedException Not thrown in this base class
 * @return The new Attribute.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  OpenModelicaDirector newObject=(OpenModelicaDirector)super.clone(workspace);
  try {
    newObject._omcProxy=OMCProxy.getInstance();
  }
 catch (  Throwable throwable) {
    throw new CloneNotSupportedException(""String_Node_Str"" + getFullName() + ""String_Node_Str""+ throwable);
  }
  return newObject;
}"
72858,"/** 
 * Invoke the preinitialize() of the super class.  Preinitialize the OpenModelica actor and initialize the OpenModelica Compiler(OMC).
 * @throws IllegalActionException If the preinitialize() ofone of the associated actors throws it.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  try {
    _omcLogger=OMCLogger.getInstance();
    _omcProxy=OMCProxy.getInstance();
    _omcProxy.initServer();
  }
 catch (  ConnectException e) {
    e.printStackTrace();
    throw new IllegalActionException(""String_Node_Str"" + e.getMessage());
  }
}","/** 
 * Invoke the preinitialize() of the super class.  Preinitialize the OpenModelica actor and initialize the OpenModelica Compiler(OMC).
 * @throws IllegalActionException If the preinitialize() ofone of the associated actors throws it.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  try {
    _omcProxy=OMCProxy.getInstance();
    _omcProxy.initServer();
  }
 catch (  ConnectException e) {
    e.printStackTrace();
    throw new IllegalActionException(""String_Node_Str"" + e.getMessage());
  }
}"
72859,"/** 
 * Evaluate the expression and send its result to the output.
 * @throws IllegalActionException If the evaluation of the expressiontriggers it, or the evaluation yields a null result, or the evaluation yields an incompatible type, or if there is no director.
 */
public void fire() throws IllegalActionException {
  super.fire();
  _omcProxy=OMCProxy.getInstance();
  try {
    _omcProxy.loadFile(fileName.getExpression(),modelName.getExpression());
  }
 catch (  ConnectException e) {
    throw new IllegalActionException(""String_Node_Str"" + e.getMessage());
  }
  if (input.getWidth() > 0) {
    IntToken inputPortValue=(IntToken)input.get(0);
    System.out.println(""String_Node_Str"");
    try {
      _omcProxy.modifyVariables(inputPortValue,modelName.getExpression());
    }
 catch (    ConnectException e) {
      throw new IllegalActionException(""String_Node_Str"" + e.getMessage());
    }
  }
  try {
    _omcProxy.loadFile(fileName.getExpression(),modelName.getExpression());
  }
 catch (  ConnectException e) {
    throw new IllegalActionException(""String_Node_Str"" + e.getMessage());
  }
  try {
    _omcProxy.simulateModel(fileName.getExpression(),modelName.getExpression(),fileNamePrefix.getExpression(),simulationStartTime.getExpression(),simulationStopTime.getExpression(),Integer.parseInt(numberOfIntervals.getExpression()),tolerance.getExpression(),method.getExpression(),outputFormat.getExpression(),variableFilter.getExpression(),cflags.getExpression(),simflags.getExpression(),processingType.getExpression());
  }
 catch (  NumberFormatException e) {
    e.printStackTrace();
  }
catch (  ConnectException e) {
    e.printStackTrace();
    throw new IllegalActionException(""String_Node_Str"" + e.getMessage());
  }
catch (  IOException e) {
    e.printStackTrace();
    throw new IllegalActionException(""String_Node_Str"" + e.getMessage());
  }
  if ((processingType.getExpression().compareTo(""String_Node_Str"") == 0) && (outputFormat.getExpression().compareTo(""String_Node_Str"") == 0)) {
    String simulationResult=null;
    try {
      _omcProxy.loadFile(fileName.getExpression(),modelName.getExpression());
    }
 catch (    ConnectException e) {
      throw new IllegalActionException(""String_Node_Str"" + e.getMessage());
    }
    try {
      simulationResult=_omcProxy.displaySimulationResult(fileName.getExpression(),modelName.getExpression());
    }
 catch (    ConnectException e) {
      throw new IllegalActionException(""String_Node_Str"" + modelName.getExpression() + ""String_Node_Str""+ e.getMessage());
    }
    output.send(0,new StringToken(simulationResult));
  }
  if (outputFormat.getExpression().compareTo(""String_Node_Str"") == 0) {
    try {
      _omcProxy.plotPltFile(fileNamePrefix.getExpression(),modelName.getExpression());
    }
 catch (    ConnectException e) {
      throw new IllegalActionException(""String_Node_Str"" + modelName.getExpression() + ""String_Node_Str""+ e.getMessage());
    }
  }
}","/** 
 * Evaluate the expression and send its result to the output.
 * @throws IllegalActionException If the evaluation of the expressiontriggers it, or the evaluation yields a null result, or the evaluation yields an incompatible type, or if there is no director.
 */
public void fire() throws IllegalActionException {
  super.fire();
  _omcProxy=OMCProxy.getInstance();
  if (input.getWidth() > 0) {
    try {
      _omcProxy.loadFile(fileName.getExpression(),modelName.getExpression());
    }
 catch (    ConnectException e) {
      throw new IllegalActionException(""String_Node_Str"" + e.getMessage());
    }
    IntToken inputPortValue=(IntToken)input.get(0);
    try {
      _omcProxy.displayComponents(inputPortValue,modelName.getExpression());
    }
 catch (    ConnectException e) {
      throw new IllegalActionException(""String_Node_Str"" + modelName.getExpression() + ""String_Node_Str""+ e.getMessage());
    }
  }
  try {
    _omcProxy.loadFile(fileName.getExpression(),modelName.getExpression());
  }
 catch (  ConnectException e) {
    throw new IllegalActionException(""String_Node_Str"" + e.getMessage());
  }
  try {
    _omcProxy.simulateModel(fileName.getExpression(),modelName.getExpression(),fileNamePrefix.getExpression(),simulationStartTime.getExpression(),simulationStopTime.getExpression(),Integer.parseInt(numberOfIntervals.getExpression()),tolerance.getExpression(),method.getExpression(),outputFormat.getExpression(),variableFilter.getExpression(),cflags.getExpression(),simflags.getExpression(),processingType.getExpression());
  }
 catch (  NumberFormatException e) {
    e.printStackTrace();
  }
catch (  ConnectException e) {
    e.printStackTrace();
    throw new IllegalActionException(""String_Node_Str"" + e.getMessage());
  }
catch (  IOException e) {
    e.printStackTrace();
    throw new IllegalActionException(""String_Node_Str"" + e.getMessage());
  }
  if ((processingType.getExpression().compareTo(""String_Node_Str"") == 0) && (outputFormat.getExpression().compareTo(""String_Node_Str"") == 0)) {
    String simulationResult=null;
    try {
      _omcProxy.loadFile(fileName.getExpression(),modelName.getExpression());
    }
 catch (    ConnectException e) {
      throw new IllegalActionException(""String_Node_Str"" + e.getMessage());
    }
    try {
      System.out.println(""String_Node_Str"");
      simulationResult=_omcProxy.displaySimulationResult(fileName.getExpression(),modelName.getExpression());
    }
 catch (    ConnectException e) {
      throw new IllegalActionException(""String_Node_Str"" + modelName.getExpression() + ""String_Node_Str""+ e.getMessage());
    }
    output.send(0,new StringToken(simulationResult));
  }
  if (outputFormat.getExpression().compareTo(""String_Node_Str"") == 0) {
    try {
      _omcProxy.plotPltFile(fileNamePrefix.getExpression(),modelName.getExpression());
    }
 catch (    ConnectException e) {
      throw new IllegalActionException(""String_Node_Str"" + modelName.getExpression() + ""String_Node_Str""+ e.getMessage());
    }
  }
}"
72860,"/** 
 * load the Modelica file and library.  
 * @param fileName File which the model should be loaded from.
 * @param modelName Name of the model which should be built.
 * @throws ConnectException If commands couldn'tbe sent to the (OpenModelic Compiler)OMC.
 * @throws IllegalActionException 
 */
public void loadFile(String fileName,String modelName) throws ConnectException, IllegalActionException ;","/** 
 * load the Modelica file and library.  
 * @param fileName File which the model should be loaded from.
 * @param modelName Name of the model which should be built.
 * @throws ConnectException If commands couldn'tbe sent to the (OpenModelic Compiler)OMC.
 * @throws IllegalActionException 
 * @throws FileNotFoundException 
 */
public void loadFile(String fileName,String modelName) throws ConnectException ;"
72861,"/** 
 * Construct an OpenModelica Compiler(OMC) proxy. This constructor has no parameter.  This private Constructor prevents other class from instantiating. 
 */
private OMCProxy(){
  if (_fOMCThread == null) {
    _fOMCThread=new OMCThread();
  }
}","/** 
 * Construct an OpenModelica Compiler(OMC) proxy. This constructor has no parameter.  This private Constructor prevents other class from instantiating. 
 */
private OMCProxy(){
}"
72862,"public void run(){
  File temp[]=null;
  try {
    temp=_getOmcBinaryPaths();
  }
 catch (  ConnectException e) {
    _omcLogger.getSever(""String_Node_Str"");
    hasInitialized=false;
    return;
  }
  File omcBinary=temp[0];
  final File workingDirectory=temp[1];
  Process omcProcess=null;
  String command[]={omcBinary.getAbsolutePath(),""String_Node_Str"" + _corbaSessionName,""String_Node_Str""};
  ArrayList<String> both=new ArrayList<String>(command.length);
  Collections.addAll(both,command);
  String commandArray[]=new String[both.size()];
  int nonNull=0;
  for (int i=0; i < both.size(); i++) {
    String str=both.get(i);
    if (str != null) {
      commandArray[nonNull]=str;
      nonNull++;
    }
  }
  StringBuffer bufferCommand=new StringBuffer();
  for (int i=0; i < nonNull; i++) {
    bufferCommand.append(commandArray[i] + ""String_Node_Str"");
  }
  String fullCommand=bufferCommand.toString();
  String loggerInfo=""String_Node_Str"" + fullCommand;
  _omcLogger.getInfo(loggerInfo);
  loggerInfo=""String_Node_Str"" + workingDirectory.getAbsolutePath();
  _omcLogger.getInfo(loggerInfo);
  try {
    if (System.getenv(""String_Node_Str"") == null) {
      Map<String,String> environmentalVariablesMap=System.getenv();
      Set<Entry<String,String>> entrySet=environmentalVariablesMap.entrySet();
      Collection<String> variableList=new ArrayList<String>();
      String x=""String_Node_Str"" + omcBinary.getParentFile().getParentFile().getAbsolutePath();
      variableList.add(x);
      if (System.getenv(""String_Node_Str"") == null) {
        String libraryPath=""String_Node_Str"" + omcBinary.getParentFile().getParentFile().getAbsolutePath() + ""String_Node_Str"";
        variableList.add(libraryPath);
      }
      Iterator<Entry<String,String>> iterator=entrySet.iterator();
      while (iterator.hasNext()) {
        Entry<String,String> entry=iterator.next();
        variableList.add(entry.getKey() + ""String_Node_Str"" + entry.getValue());
      }
      _environmentalVariables=variableList.toArray(new String[variableList.size()]);
    }
    omcProcess=Runtime.getRuntime().exec(commandArray,_environmentalVariables,workingDirectory);
    _workDir=workingDirectory;
  }
 catch (  IOException e) {
    loggerInfo=""String_Node_Str"" + fullCommand;
    _omcLogger.getInfo(loggerInfo);
    hasInitialized=false;
    return;
  }
  loggerInfo=""String_Node_Str"";
  _omcLogger.getInfo(loggerInfo);
  loggerInfo=""String_Node_Str"";
  _omcLogger.getInfo(loggerInfo);
  loggerInfo=""String_Node_Str"";
  _omcLogger.getInfo(loggerInfo);
  int omcExitCode=0;
  try {
    omcExitCode=omcProcess.waitFor();
    if (omcExitCode == 0)     System.out.println(""String_Node_Str"" + omcExitCode);
  }
 catch (  InterruptedException e) {
    new Exception(""String_Node_Str"" + e.getMessage() + (omcProcess == null ? ""String_Node_Str"" : ""String_Node_Str"" + omcProcess.exitValue())).printStackTrace();
    hasInitialized=false;
    return;
  }
  hasInitialized=false;
}","public void run(){
  File temp[]=null;
  try {
    temp=_getOmcBinaryPaths();
  }
 catch (  ConnectException e) {
    _omcLogger.getSever(""String_Node_Str"");
    hasInitialized=false;
    return;
  }
  File omcBinary=temp[0];
  final File workingDirectory=temp[1];
  Process omcProcess=null;
  String command[]={omcBinary.getAbsolutePath(),""String_Node_Str"" + _corbaSession,""String_Node_Str""};
  ArrayList<String> both=new ArrayList<String>(command.length);
  Collections.addAll(both,command);
  String commandArray[]=new String[both.size()];
  int nonNull=0;
  for (int i=0; i < both.size(); i++) {
    String str=both.get(i);
    if (str != null) {
      commandArray[nonNull]=str;
      nonNull++;
    }
  }
  StringBuffer bufferCommand=new StringBuffer();
  for (int i=0; i < nonNull; i++) {
    bufferCommand.append(commandArray[i] + ""String_Node_Str"");
  }
  String fullCommand=bufferCommand.toString();
  String loggerInfo=""String_Node_Str"" + fullCommand;
  _omcLogger.getInfo(loggerInfo);
  loggerInfo=""String_Node_Str"" + workingDirectory.getAbsolutePath();
  _omcLogger.getInfo(loggerInfo);
  try {
    if (System.getenv(""String_Node_Str"") == null) {
      Map<String,String> environmentalVariablesMap=System.getenv();
      Set<Entry<String,String>> entrySet=environmentalVariablesMap.entrySet();
      Collection<String> variableList=new ArrayList<String>();
      String x=""String_Node_Str"" + omcBinary.getParentFile().getParentFile().getAbsolutePath();
      variableList.add(x);
      if (System.getenv(""String_Node_Str"") == null) {
        String libraryPath=""String_Node_Str"" + omcBinary.getParentFile().getParentFile().getAbsolutePath() + ""String_Node_Str"";
        variableList.add(libraryPath);
      }
      Iterator<Entry<String,String>> iterator=entrySet.iterator();
      while (iterator.hasNext()) {
        Entry<String,String> entry=iterator.next();
        variableList.add(entry.getKey() + ""String_Node_Str"" + entry.getValue());
      }
      _environmentalVariables=variableList.toArray(new String[variableList.size()]);
    }
    omcProcess=Runtime.getRuntime().exec(commandArray,_environmentalVariables,workingDirectory);
    _workDir=workingDirectory;
  }
 catch (  IOException e) {
    loggerInfo=""String_Node_Str"" + fullCommand;
    _omcLogger.getInfo(loggerInfo);
    hasInitialized=false;
    return;
  }
  loggerInfo=""String_Node_Str"";
  _omcLogger.getInfo(loggerInfo);
  loggerInfo=""String_Node_Str"";
  _omcLogger.getInfo(loggerInfo);
  loggerInfo=""String_Node_Str"";
  _omcLogger.getInfo(loggerInfo);
  int omcExitCode=0;
  try {
    omcExitCode=omcProcess.waitFor();
    if (omcExitCode == 0)     System.out.println(""String_Node_Str"" + omcExitCode);
  }
 catch (  InterruptedException e) {
    new Exception(""String_Node_Str"" + e.getMessage() + (omcProcess == null ? ""String_Node_Str"" : ""String_Node_Str"" + omcProcess.exitValue())).printStackTrace();
    hasInitialized=false;
    return;
  }
  hasInitialized=false;
}"
72863,"/** 
 * Initialize the communication with the OpenModelica compiler(OMC) server.
 * @throws ConnectException If we're unable to start communicating withthe server.
 * @throws InterruptedException 
 */
public synchronized void initServer() throws ConnectException {
  _os=getOs();
  String strDate=""String_Node_Str"";
  Date date=new Date();
  SimpleDateFormat timeFormat=new SimpleDateFormat(""String_Node_Str"");
  strDate=timeFormat.format(date);
  _corbaSessionName=strDate;
  File file=new File(_getPathToObject());
  String stringifiedObjectReference=null;
  if (!file.exists()) {
    String loggerInfo=""String_Node_Str"";
    _omcLogger.getInfo(loggerInfo);
    _startServer();
  }
 else {
    String loggerInfo=""String_Node_Str"";
    _omcLogger.getInfo(loggerInfo);
  }
  try {
    stringifiedObjectReference=_readObjectFromFile();
    _setupOmcc(stringifiedObjectReference);
  }
 catch (  Throwable throwable) {
    throw new RuntimeException(""String_Node_Str"" + stringifiedObjectReference,throwable);
  }
  hasInitialized=true;
}","/** 
 * Initialize the communication with the OpenModelica compiler(OMC) server.
 * @throws ConnectException If we're unable to start communicating withthe server.
 * @throws InterruptedException 
 */
public synchronized void initServer() throws ConnectException {
  _os=getOs();
  String stringDate=""String_Node_Str"";
  Date date=new Date();
  SimpleDateFormat timeFormat=new SimpleDateFormat(""String_Node_Str"");
  stringDate=timeFormat.format(date);
  _corbaSession=stringDate;
  File file=new File(_getPathToObject());
  String stringifiedObjectReference=null;
  if (!file.exists()) {
    String loggerInfo=""String_Node_Str"";
    _omcLogger.getInfo(loggerInfo);
    _startServer();
  }
 else {
    String loggerInfo=""String_Node_Str"";
    _omcLogger.getInfo(loggerInfo);
  }
  try {
    stringifiedObjectReference=_readObjectFromFile();
    _setupOmcc(stringifiedObjectReference);
  }
 catch (  Throwable throwable) {
    throw new RuntimeException(""String_Node_Str"" + stringifiedObjectReference,throwable);
  }
  hasInitialized=true;
}"
72864,"/** 
 * Build the Modelica model. Then, run the executable result file of buildModel() in both interactive and non-interactive processing mode in order to generate the simulation result file.
 * @param fileName File which the model should be loaded from.
 * @param modelName Name of the model which should be built.
 * @param fileNamePrefix User preferable name for the result file.
 * @param startTime The start time of simulation.
 * @param stopTime The stop time of simulation.
 * @param numberOfIntervals Number of intervals in the result file.
 * @param tolerance Tolerance used by the integration method.
 * @param method Integration method used for simulation.
 * @param outputFormat Format of the result file.
 * @param variableFilter Filter for variables that should be stored in the result file.
 * @param cflags Any standard C language flags.
 * @param simflags Simulation flags.
 * @param processingType Type of processing for running the executable result file of building the Modelica model.
 * @throws ConnectException If commands couldn'tbe sent to the (OpenModelic Compiler)OMC.
 * @throws IOException If the executable result file of buildModel()couldn't be executed.
 * @throws IllegalActionException 
 */
public void simulateModel(String fileName,String modelName,String fileNamePrefix,String startTime,String stopTime,int numberOfIntervals,String tolerance,String method,String outputFormat,String variableFilter,String cflags,String simflags,String processingType) throws ConnectException, IOException, IllegalActionException {
  String commands=null;
  String loggerInfo=null;
  if (fileNamePrefix.compareTo(""String_Node_Str"") == 0) {
    commands=modelName + ""String_Node_Str"" + Float.valueOf(startTime).floatValue()+ ""String_Node_Str""+ Float.valueOf(stopTime).floatValue()+ ""String_Node_Str""+ numberOfIntervals+ ""String_Node_Str""+ Float.valueOf(tolerance).floatValue()+ ""String_Node_Str""+ method+ ""String_Node_Str""+ outputFormat+ ""String_Node_Str""+ variableFilter+ ""String_Node_Str""+ cflags+ ""String_Node_Str""+ simflags+ ""String_Node_Str"";
    loggerInfo=""String_Node_Str"" + modelName + ""String_Node_Str"";
    _omcLogger.getInfo(loggerInfo);
  }
 else {
    commands=fileNamePrefix + ""String_Node_Str"" + Float.valueOf(startTime).floatValue()+ ""String_Node_Str""+ Float.valueOf(stopTime).floatValue()+ ""String_Node_Str""+ numberOfIntervals+ ""String_Node_Str""+ Float.valueOf(tolerance).floatValue()+ ""String_Node_Str""+ method+ ""String_Node_Str""+ fileNamePrefix+ ""String_Node_Str""+ outputFormat+ ""String_Node_Str""+ variableFilter+ ""String_Node_Str""+ cflags+ ""String_Node_Str""+ simflags+ ""String_Node_Str"";
    loggerInfo=""String_Node_Str"" + modelName + ""String_Node_Str"";
    _omcLogger.getInfo(loggerInfo);
  }
  CompilerResult buildModelResult=buildModel(commands);
  if (buildModelResult.getFirstResult().compareTo(""String_Node_Str"") != 0 && buildModelResult.getError().compareTo(""String_Node_Str"") == 0) {
    loggerInfo=modelName + ""String_Node_Str"";
    _omcLogger.getInfo(loggerInfo);
  }
  if (buildModelResult.getError().compareTo(""String_Node_Str"") != 0) {
    loggerInfo=""String_Node_Str"" + modelName + ""String_Node_Str"";
    _omcLogger.getInfo(loggerInfo);
    throw new ConnectException(loggerInfo);
  }
  if (!outputFormat.equals(""String_Node_Str"")) {
    if (processingType.compareTo(""String_Node_Str"") == 0) {
      loggerInfo=""String_Node_Str"";
      _omcLogger.getInfo(loggerInfo);
      if (fileNamePrefix.compareTo(""String_Node_Str"") == 0) {
switch (getOs()) {
case WINDOWS:
          commands=_temp + _username + ""String_Node_Str""+ modelName+ ""String_Node_Str"";
        break;
case UNIX:
      commands=_temp + ""String_Node_Str"" + _username+ ""String_Node_Str""+ modelName;
    break;
case MAC:
  commands=_temp + _username + ""String_Node_Str""+ modelName;
break;
}
}
 else {
switch (getOs()) {
case WINDOWS:
commands=_temp + _username + ""String_Node_Str""+ fileNamePrefix+ ""String_Node_Str"";
break;
case UNIX:
commands=_temp + ""String_Node_Str"" + _username+ ""String_Node_Str""+ fileNamePrefix;
break;
case MAC:
commands=_temp + _username + ""String_Node_Str""+ fileNamePrefix;
break;
}
}
try {
Runtime.getRuntime().exec(commands,_environmentalVariables,_workDir);
}
 catch (IOException e) {
loggerInfo=""String_Node_Str"" + commands;
_omcLogger.getInfo(loggerInfo);
hasInitialized=false;
StringUtilities.exit(1);
}
loggerInfo=""String_Node_Str"";
_omcLogger.getInfo(loggerInfo);
if (fileNamePrefix.compareTo(""String_Node_Str"") == 0) {
switch (getOs()) {
case WINDOWS:
loggerInfo=modelName + ""String_Node_Str"" + outputFormat+ ""String_Node_Str""+ _temp+ _username+ ""String_Node_Str"";
_omcLogger.getInfo(loggerInfo);
break;
case UNIX:
loggerInfo=modelName + ""String_Node_Str"" + outputFormat+ ""String_Node_Str""+ _temp+ ""String_Node_Str""+ _username+ ""String_Node_Str"";
_omcLogger.getInfo(loggerInfo);
break;
case MAC:
loggerInfo=modelName + ""String_Node_Str"" + outputFormat+ ""String_Node_Str""+ _temp+ _username+ ""String_Node_Str"";
_omcLogger.getInfo(loggerInfo);
break;
}
}
 else if (fileNamePrefix.length() != 0) {
switch (getOs()) {
case WINDOWS:
loggerInfo=fileNamePrefix + ""String_Node_Str"" + outputFormat+ ""String_Node_Str""+ _temp+ _username+ ""String_Node_Str"";
_omcLogger.getInfo(loggerInfo);
break;
case UNIX:
loggerInfo=fileNamePrefix + ""String_Node_Str"" + outputFormat+ ""String_Node_Str""+ _temp+ ""String_Node_Str""+ _username+ ""String_Node_Str"";
_omcLogger.getInfo(loggerInfo);
break;
case MAC:
loggerInfo=fileNamePrefix + ""String_Node_Str"" + outputFormat+ ""String_Node_Str""+ _temp+ _username+ ""String_Node_Str"";
_omcLogger.getInfo(loggerInfo);
break;
}
}
}
 else {
loggerInfo=""String_Node_Str"";
_omcLogger.getInfo(loggerInfo);
switch (getOs()) {
case WINDOWS:
commands=_temp + _username + ""String_Node_Str""+ modelName+ ""String_Node_Str"";
break;
case UNIX:
commands=_temp + ""String_Node_Str"" + _username+ ""String_Node_Str""+ modelName;
break;
case MAC:
commands=_temp + _username + ""String_Node_Str""+ modelName;
break;
}
commands=commands + ""String_Node_Str"";
try {
loggerInfo=""String_Node_Str"" + commands + ""String_Node_Str"";
_omcLogger.getInfo(loggerInfo);
Runtime.getRuntime().exec(commands,_environmentalVariables,_workDir);
}
 catch (IOException e) {
loggerInfo=""String_Node_Str"" + commands;
_omcLogger.getInfo(loggerInfo);
hasInitialized=false;
return;
}
loggerInfo=""String_Node_Str"";
_omcLogger.getInfo(loggerInfo);
}
}
 else {
loggerInfo=modelName + ""String_Node_Str"";
_omcLogger.getInfo(loggerInfo);
}
}","/** 
 * Build the Modelica model. Then, run the executable result file of buildModel() in both interactive and non-interactive processing mode in order to generate the simulation result file.
 * @param fileName File which the model should be loaded from.
 * @param modelName Name of the model which should be built.
 * @param fileNamePrefix User preferable name for the result file.
 * @param startTime The start time of simulation.
 * @param stopTime The stop time of simulation.
 * @param numberOfIntervals Number of intervals in the result file.
 * @param tolerance Tolerance used by the integration method.
 * @param method Integration method used for simulation.
 * @param outputFormat Format of the result file.
 * @param variableFilter Filter for variables that should be stored in the result file.
 * @param cflags Any standard C language flags.
 * @param simflags Simulation flags.
 * @param processingType Type of processing for running the executable result file of building the Modelica model.
 * @throws ConnectException If commands couldn'tbe sent to the (OpenModelic Compiler)OMC.
 * @throws IOException If the executable result file of buildModel()couldn't be executed.
 * @throws IllegalActionException 
 */
public void simulateModel(String fileName,String modelName,String fileNamePrefix,String startTime,String stopTime,int numberOfIntervals,String tolerance,String method,String outputFormat,String variableFilter,String cflags,String simflags,String processingType) throws ConnectException, IOException, IllegalActionException {
  String commands=null;
  String loggerInfo=null;
  if (fileNamePrefix.compareTo(""String_Node_Str"") == 0) {
    commands=modelName + ""String_Node_Str"" + Float.valueOf(startTime).floatValue()+ ""String_Node_Str""+ Float.valueOf(stopTime).floatValue()+ ""String_Node_Str""+ numberOfIntervals+ ""String_Node_Str""+ Float.valueOf(tolerance).floatValue()+ ""String_Node_Str""+ method+ ""String_Node_Str""+ outputFormat+ ""String_Node_Str""+ variableFilter+ ""String_Node_Str""+ cflags+ ""String_Node_Str""+ simflags+ ""String_Node_Str"";
    loggerInfo=""String_Node_Str"" + modelName + ""String_Node_Str"";
    _omcLogger.getInfo(loggerInfo);
  }
 else {
    commands=fileNamePrefix + ""String_Node_Str"" + Float.valueOf(startTime).floatValue()+ ""String_Node_Str""+ Float.valueOf(stopTime).floatValue()+ ""String_Node_Str""+ numberOfIntervals+ ""String_Node_Str""+ Float.valueOf(tolerance).floatValue()+ ""String_Node_Str""+ method+ ""String_Node_Str""+ fileNamePrefix+ ""String_Node_Str""+ outputFormat+ ""String_Node_Str""+ variableFilter+ ""String_Node_Str""+ cflags+ ""String_Node_Str""+ simflags+ ""String_Node_Str"";
    loggerInfo=""String_Node_Str"" + modelName + ""String_Node_Str"";
    _omcLogger.getInfo(loggerInfo);
  }
  CompilerResult buildModelResult=buildModel(commands);
  if (buildModelResult.getFirstResult().compareTo(""String_Node_Str"") != 0 && buildModelResult.getError().compareTo(""String_Node_Str"") == 0) {
    loggerInfo=modelName + ""String_Node_Str"";
    _omcLogger.getInfo(loggerInfo);
  }
  if (buildModelResult.getError().compareTo(""String_Node_Str"") != 0) {
    loggerInfo=""String_Node_Str"" + modelName + ""String_Node_Str"";
    _omcLogger.getInfo(loggerInfo);
    throw new ConnectException(loggerInfo);
  }
  if (!outputFormat.equals(""String_Node_Str"")) {
    if (processingType.compareTo(""String_Node_Str"") == 0) {
      loggerInfo=""String_Node_Str"";
      _omcLogger.getInfo(loggerInfo);
      if (fileNamePrefix.compareTo(""String_Node_Str"") == 0) {
switch (getOs()) {
case WINDOWS:
          commands=_temp + _username + ""String_Node_Str""+ modelName+ ""String_Node_Str"";
        break;
case UNIX:
      commands=_temp + ""String_Node_Str"" + _username+ ""String_Node_Str""+ modelName;
    break;
case MAC:
  commands=_temp + _username + ""String_Node_Str""+ modelName;
break;
}
}
 else {
switch (getOs()) {
case WINDOWS:
commands=_temp + _username + ""String_Node_Str""+ fileNamePrefix+ ""String_Node_Str"";
break;
case UNIX:
commands=_temp + ""String_Node_Str"" + _username+ ""String_Node_Str""+ fileNamePrefix;
break;
case MAC:
commands=_temp + _username + ""String_Node_Str""+ fileNamePrefix;
break;
}
}
try {
Runtime.getRuntime().exec(commands,_environmentalVariables,_workDir);
}
 catch (IOException e) {
loggerInfo=""String_Node_Str"" + commands;
_omcLogger.getInfo(loggerInfo);
hasInitialized=false;
StringUtilities.exit(1);
}
loggerInfo=""String_Node_Str"";
_omcLogger.getInfo(loggerInfo);
if (fileNamePrefix.compareTo(""String_Node_Str"") == 0) {
switch (getOs()) {
case WINDOWS:
loggerInfo=modelName + ""String_Node_Str"" + outputFormat+ ""String_Node_Str""+ _temp+ _username+ ""String_Node_Str"";
_omcLogger.getInfo(loggerInfo);
break;
case UNIX:
loggerInfo=modelName + ""String_Node_Str"" + outputFormat+ ""String_Node_Str""+ _temp+ ""String_Node_Str""+ _username+ ""String_Node_Str"";
_omcLogger.getInfo(loggerInfo);
break;
case MAC:
loggerInfo=modelName + ""String_Node_Str"" + outputFormat+ ""String_Node_Str""+ _temp+ _username+ ""String_Node_Str"";
_omcLogger.getInfo(loggerInfo);
break;
}
}
 else if (fileNamePrefix.length() != 0) {
switch (getOs()) {
case WINDOWS:
loggerInfo=fileNamePrefix + ""String_Node_Str"" + outputFormat+ ""String_Node_Str""+ _temp+ _username+ ""String_Node_Str"";
_omcLogger.getInfo(loggerInfo);
break;
case UNIX:
loggerInfo=fileNamePrefix + ""String_Node_Str"" + outputFormat+ ""String_Node_Str""+ _temp+ ""String_Node_Str""+ _username+ ""String_Node_Str"";
_omcLogger.getInfo(loggerInfo);
break;
case MAC:
loggerInfo=fileNamePrefix + ""String_Node_Str"" + outputFormat+ ""String_Node_Str""+ _temp+ _username+ ""String_Node_Str"";
_omcLogger.getInfo(loggerInfo);
break;
}
}
}
 else {
loggerInfo=""String_Node_Str"";
_omcLogger.getInfo(loggerInfo);
switch (getOs()) {
case WINDOWS:
commands=_temp + _username + ""String_Node_Str""+ modelName+ ""String_Node_Str"";
break;
case UNIX:
commands=_temp + ""String_Node_Str"" + _username+ ""String_Node_Str""+ modelName;
break;
case MAC:
commands=_temp + _username + ""String_Node_Str""+ modelName;
break;
}
commands=commands + ""String_Node_Str"";
try {
loggerInfo=""String_Node_Str"" + commands + ""String_Node_Str"";
_omcLogger.getInfo(loggerInfo);
Runtime.getRuntime().exec(commands,_environmentalVariables,_workDir);
loggerInfo=""String_Node_Str"" + commands + ""String_Node_Str"";
_omcLogger.getInfo(loggerInfo);
}
 catch (IOException e) {
loggerInfo=""String_Node_Str"" + commands;
_omcLogger.getInfo(loggerInfo);
hasInitialized=false;
return;
}
loggerInfo=""String_Node_Str"";
_omcLogger.getInfo(loggerInfo);
}
}
 else {
loggerInfo=modelName + ""String_Node_Str"";
_omcLogger.getInfo(loggerInfo);
}
}"
72865,"/** 
 * Return the path to the (OpenModelica Compiler)OMC CORBA object that is stored on a disk.
 * @return String The path to the OMC CORBA object.
 */
private String _getPathToObject(){
  String fileName=null;
switch (getOs()) {
case UNIX:
    if (_username == null) {
      System.err.println(""String_Node_Str"");
      _username=""String_Node_Str"";
    }
  if (_corbaSessionName == null || _corbaSessionName.equalsIgnoreCase(""String_Node_Str"")) {
    fileName=_temp + ""String_Node_Str"" + _username+ ""String_Node_Str"";
  }
 else {
    fileName=_temp + ""String_Node_Str"" + _username+ ""String_Node_Str""+ ""String_Node_Str""+ _corbaSessionName;
  }
break;
case WINDOWS:
if (_corbaSessionName == null || _corbaSessionName.equalsIgnoreCase(""String_Node_Str"")) {
fileName=_temp + ""String_Node_Str"";
}
 else {
fileName=_temp + ""String_Node_Str"" + ""String_Node_Str""+ _corbaSessionName;
}
break;
case MAC:
if (_username == null) {
System.err.println(""String_Node_Str"");
_username=""String_Node_Str"";
}
if (_corbaSessionName == null || _corbaSessionName.equalsIgnoreCase(""String_Node_Str"")) {
fileName=_temp + ""String_Node_Str"" + _username+ ""String_Node_Str"";
}
 else {
fileName=_temp + ""String_Node_Str"" + _username+ ""String_Node_Str""+ ""String_Node_Str""+ _corbaSessionName;
}
break;
}
if (_omcLogger == null) {
_omcLogger=OMCLogger.getInstance();
}
String loggerInfo=""String_Node_Str"" + fileName + ""String_Node_Str"";
_omcLogger.getInfo(loggerInfo);
return fileName;
}","/** 
 * Return the path to the (OpenModelica Compiler)OMC CORBA object that is stored on a disk.
 * @return String The path to the OMC CORBA object.
 */
private String _getPathToObject(){
  String fileName=null;
switch (getOs()) {
case UNIX:
    if (_username == null) {
      System.err.println(""String_Node_Str"");
      _username=""String_Node_Str"";
    }
  if (_corbaSession == null || _corbaSession.equalsIgnoreCase(""String_Node_Str"")) {
    fileName=_temp + ""String_Node_Str"" + _username+ ""String_Node_Str"";
  }
 else {
    fileName=_temp + ""String_Node_Str"" + _username+ ""String_Node_Str""+ ""String_Node_Str""+ _corbaSession;
  }
break;
case WINDOWS:
if (_corbaSession == null || _corbaSession.equalsIgnoreCase(""String_Node_Str"")) {
fileName=_temp + ""String_Node_Str"";
}
 else {
fileName=_temp + ""String_Node_Str"" + ""String_Node_Str""+ _corbaSession;
}
break;
case MAC:
if (_username == null) {
System.err.println(""String_Node_Str"");
_username=""String_Node_Str"";
}
if (_corbaSession == null || _corbaSession.equalsIgnoreCase(""String_Node_Str"")) {
fileName=_temp + ""String_Node_Str"" + _username+ ""String_Node_Str"";
}
 else {
fileName=_temp + ""String_Node_Str"" + _username+ ""String_Node_Str""+ ""String_Node_Str""+ _corbaSession;
}
break;
}
if (_omcLogger == null) {
_omcLogger=OMCLogger.getInstance();
}
String loggerInfo=""String_Node_Str"" + fileName + ""String_Node_Str"";
_omcLogger.getInfo(loggerInfo);
return fileName;
}"
72866,"/** 
 * Start the (OpenModelica Compiler)OMC server by starting OMCThread.
 * @throws ConnectException If OPENMODELICAHOME is not set and we could not find binary file in the path.
 */
private synchronized void _startServer() throws ConnectException {
  if (!_fOMCThreadHasBeenScheduled) {
    _fOMCThread.start();
    _fOMCThreadHasBeenScheduled=true;
synchronized (_fOMCThread) {
      try {
        _fOMCThread.wait(10000);
      }
 catch (      InterruptedException e) {
        new Exception(e.getMessage()).printStackTrace();
      }
    }
  }
synchronized (_fOMCThread) {
    _fOMCThread.notify();
  }
}","/** 
 * Start the (OpenModelica Compiler)OMC server by starting OMCThread.
 * @throws ConnectException If OPENMODELICAHOME is not set and we could not find binary file in the path.
 */
private synchronized void _startServer() throws ConnectException {
  if (!_fOMCThreadHasBeenScheduled) {
    _fOMCThread.start();
    _fOMCThreadHasBeenScheduled=true;
synchronized (_fOMCThread) {
      try {
        _fOMCThread.wait(10000);
      }
 catch (      InterruptedException e) {
        new Exception(e.getMessage()).printStackTrace();
      }
    }
  }
}"
72867,"/** 
 * Add a pure event to the queue of pure events.
 * @param actor Actor to fire.
 * @param time Time the actor should be fired at.
 * @param index Microstep the actor should be fired at.
 * @return The time the actor requested to be refired at.
 * @exception IllegalActionException If firing of the container doesn't succeed.
 */
public Time fireAt(Actor actor,Time time,int index) throws IllegalActionException {
  if (actor == this.getContainer()) {
    fireContainerAt(time);
    return time;
  }
  int newIndex=index;
  if (_currentLogicalTime != null) {
    if (_currentLogicalTime.compareTo(time) == 0 && index <= getIndex()) {
      if (!(actor instanceof CompositeActor) || ((CompositeActor)actor).getDirector().scheduleContainedActors()) {
        newIndex=Math.max(getIndex(),index) + 1;
      }
    }
  }
  if (_isInitializing) {
    _currentSourceTimestamp=time;
  }
  _pureEvents.put(new PtidesEvent(actor,null,time,newIndex,_getDepthOfActor(actor),_zeroTime,_currentSourceTimestamp));
  _currentSourceTimestamp=null;
  Time environmentTime=super.getEnvironmentTime();
  if (environmentTime.compareTo(time) <= 0) {
    fireContainerAt(time,newIndex);
  }
  return time;
}","/** 
 * Add a pure event to the queue of pure events.
 * @param actor Actor to fire.
 * @param time Time the actor should be fired at.
 * @param index Microstep the actor should be fired at.
 * @return The time the actor requested to be refired at.
 * @exception IllegalActionException If firing of the container doesn't succeed.
 */
public Time fireAt(Actor actor,Time time,int index) throws IllegalActionException {
  if (actor == this.getContainer()) {
    fireContainerAt(time);
    return time;
  }
  int newIndex=index;
  if (_currentLogicalTime != null) {
    if (_currentLogicalTime.compareTo(time) == 0 && index <= getIndex()) {
      if (!(actor instanceof CompositeActor) || ((CompositeActor)actor).getDirector().scheduleContainedActors()) {
        newIndex=Math.max(getIndex(),index) + 1;
      }
    }
  }
  if (_isInitializing) {
    _currentSourceTimestamp=time;
  }
  int depth=1;
  if (!(actor instanceof ResourceScheduler)) {
    depth=_getDepthOfActor(actor);
  }
  _pureEvents.put(new PtidesEvent(actor,null,time,newIndex,depth,_zeroTime,_currentSourceTimestamp));
  _currentSourceTimestamp=null;
  Time environmentTime=super.getEnvironmentTime();
  if (environmentTime.compareTo(time) <= 0) {
    fireContainerAt(time,newIndex);
  }
  return time;
}"
72868,"/** 
 * Generate the code of the declaration of an IOPort (or a subclass) Initialize all its dependencies (container, widths ...) In this base class we deal with all the known kinds of ports, however ideally we should create an adapter for each type of port. There are essentially four types of ports : - input/output - from a composite/atomic actor The creation of the receivers relies on this distinction.
 * @return the port declaration to include in the actor constructor
 * @exception IllegalActionException if the getWidth or getWidthInsidethrows an exception 
 */
public String generatePortDeclaration() throws IllegalActionException {
  StringBuffer result=new StringBuffer();
  TemplateParser tParser=getTemplateParser();
  ProgramCodeGenerator codeGenerator=getCodeGenerator();
  ptolemy.actor.IOPort port=(ptolemy.actor.IOPort)getComponent();
  String portName=port.getName();
  String typePort=port.getClass().getSimpleName();
  if (port instanceof ParameterPort || port instanceof PubSubPort)   typePort=""String_Node_Str"";
  NamedObj actor=port.getContainer();
  String sanitizedActorName=CodeGeneratorAdapter.generateName(actor);
  if (!port.isInsideConnected() && !port.isOutsideConnected())   return ""String_Node_Str"";
  result.append(portName + ""String_Node_Str"" + typePort+ ""String_Node_Str""+ _eol);
  result.append(portName + ""String_Node_Str"" + sanitizedActorName+ ""String_Node_Str""+ _eol);
  result.append(portName + ""String_Node_Str"" + port.isInsideConnected()+ ""String_Node_Str""+ _eol);
  result.append(portName + ""String_Node_Str"" + port.isOutsideConnected()+ ""String_Node_Str""+ _eol);
  result.append(portName + ""String_Node_Str"" + port.isInput()+ ""String_Node_Str""+ _eol);
  result.append(portName + ""String_Node_Str"" + port.isOutput()+ ""String_Node_Str""+ _eol);
  result.append(portName + ""String_Node_Str"" + port.isMultiport()+ ""String_Node_Str""+ _eol);
  result.append(portName + ""String_Node_Str"" + port.getWidth()+ ""String_Node_Str""+ _eol);
  result.append(portName + ""String_Node_Str"" + port.getWidthInside()+ ""String_Node_Str""+ _eol);
  result.append(portName + ""String_Node_Str"" + port.numberOfSinks()+ ""String_Node_Str""+ _eol);
  result.append(portName + ""String_Node_Str"" + port.numberOfSources()+ ""String_Node_Str""+ _eol);
  Parameter parameter=(Parameter)((NamedObj)port).getAttribute(""String_Node_Str"");
  Double ioPortDelayOffset=null;
  if (parameter != null) {
    Token token=parameter.getToken();
    if (token instanceof DoubleToken) {
      ioPortDelayOffset=((DoubleToken)token).doubleValue();
    }
 else     if (token instanceof ArrayToken) {
      ioPortDelayOffset=((DoubleToken)((ArrayToken)token).getElement(0)).doubleValue();
    }
  }
  if (ioPortDelayOffset != null)   result.append(portName + ""String_Node_Str"" + ioPortDelayOffset.doubleValue()+ ""String_Node_Str""+ _eol);
  if (port instanceof MirrorPort) {
    MirrorPort mport=(MirrorPort)port;
    MirrorPort associatedPort=mport.getAssociatedPort();
    String accessorAssociatedPort=CodeGeneratorAdapter.generateName(associatedPort.getContainer()) + ""String_Node_Str"" + associatedPort.getName()+ ""String_Node_Str"";
    result.append(""String_Node_Str"" + portName + ""String_Node_Str""+ accessorAssociatedPort+ ""String_Node_Str""+ _eol);
    if (mport instanceof PtidesPort) {
      PtidesPort ptidesPort=(PtidesPort)mport;
      result.append(""String_Node_Str"" + portName + ""String_Node_Str""+ ((BooleanToken)ptidesPort.actuateAtEventTimestamp.getToken()).booleanValue()+ ""String_Node_Str""+ _eol);
      result.append(""String_Node_Str"" + portName + ""String_Node_Str""+ ((DoubleToken)ptidesPort.deviceDelay.getToken()).doubleValue()+ ""String_Node_Str""+ _eol);
      result.append(""String_Node_Str"" + portName + ""String_Node_Str""+ ((DoubleToken)ptidesPort.deviceDelayBound.getToken()).doubleValue()+ ""String_Node_Str""+ _eol);
      result.append(""String_Node_Str"" + portName + ""String_Node_Str""+ ((BooleanToken)ptidesPort.isNetworkPort.getToken()).booleanValue()+ ""String_Node_Str""+ _eol);
      if (ptidesPort.isNetworkReceiverPort() || ptidesPort.isNetworkTransmitterPort()) {
        result.append(""String_Node_Str"" + portName + ""String_Node_Str""+ ((DoubleToken)ptidesPort.networkDelayBound.getToken()).doubleValue()+ ""String_Node_Str""+ _eol);
        result.append(""String_Node_Str"" + portName + ""String_Node_Str""+ ((DoubleToken)ptidesPort.sourcePlatformDelayBound.getToken()).doubleValue()+ ""String_Node_Str""+ _eol);
      }
    }
  }
  if (port instanceof TypedIOPort) {
    TypedIOPort typedPort=(TypedIOPort)port;
    String type=codeGenerator.codeGenType(typedPort.getType());
    if (type.contains(""String_Node_Str"")) {
      result.append(portName + ""String_Node_Str"" + _eol);
      tParser.addNewTypesUsed(""String_Node_Str"");
      for (      String typ : type.split(""String_Node_Str"")) {
        tParser.addNewTypesUsed(typ);
      }
    }
 else {
      result.append(portName + ""String_Node_Str"" + type+ ""String_Node_Str""+ _eol);
      tParser.addNewTypesUsed(type);
    }
  }
  int foo=0;
  if (port.isInput())   result.append(""String_Node_Str"" + sanitizedActorName + ""String_Node_Str""+ portName+ ""String_Node_Str""+ _eol);
  if (port.isOutput())   result.append(""String_Node_Str"" + sanitizedActorName + ""String_Node_Str""+ portName+ ""String_Node_Str""+ _eol);
  Receiver[][] receiverss;
  if (port.isInput())   receiverss=port.getReceivers();
 else   if (port.isOutput() && actor instanceof CompositeActor)   receiverss=port.getInsideReceivers();
 else   receiverss=new Receiver[0][];
  String directorCall=(actor instanceof CompositeActor ? ""String_Node_Str"" : ""String_Node_Str"");
  if (port instanceof PtidesPort)   directorCall=(!port.isInput() && actor instanceof CompositeActor && ((CompositeActor)actor).isOpaque() ? ""String_Node_Str"" : ""String_Node_Str"");
  String localReceiver=(port.isInput() ? ""String_Node_Str"" : ""String_Node_Str"");
  for (  Receiver[] receivers : receiverss) {
    result.append(""String_Node_Str"" + portName + ""String_Node_Str""+ foo+ ""String_Node_Str""+ _eol);
    int bar=0;
    for (    Receiver receiver : receivers) {
      String typeReceiver=receiver.getClass().getSimpleName();
      if (typeReceiver.compareTo(""String_Node_Str"") == 0)       typeReceiver=""String_Node_Str"";
      String receiverName=portName + ""String_Node_Str"" + foo+ ""String_Node_Str""+ bar;
      result.append(""String_Node_Str"" + typeReceiver + ""String_Node_Str""+ receiverName+ ""String_Node_Str""+ typeReceiver+ ""String_Node_Str""+ _eol);
      result.append(receiverName + ""String_Node_Str"" + portName+ ""String_Node_Str""+ _eol);
      if (receiver instanceof PtidesReceiver) {
        result.append(receiverName + ""String_Node_Str"" + sanitizedActorName+ ""String_Node_Str""+ directorCall+ ""String_Node_Str""+ sanitizedActorName+ ""String_Node_Str""+ _eol);
      }
 else       if (receiver instanceof DEReceiver) {
        result.append(receiverName + ""String_Node_Str"" + sanitizedActorName+ ""String_Node_Str""+ directorCall+ ""String_Node_Str""+ sanitizedActorName+ ""String_Node_Str""+ _eol);
      }
      result.append(""String_Node_Str"" + portName + ""String_Node_Str""+ foo+ ""String_Node_Str""+ receiverName+ ""String_Node_Str""+ _eol);
      bar++;
    }
    result.append(""String_Node_Str"" + portName + ""String_Node_Str""+ localReceiver+ ""String_Node_Str""+ portName+ ""String_Node_Str""+ foo+ ""String_Node_Str""+ _eol);
    foo++;
  }
  if (port.isInput() && actor instanceof CompositeActor)   for (foo=0; foo < port.getWidthInside(); foo++) {
    result.append(""String_Node_Str"" + portName + ""String_Node_Str""+ foo+ ""String_Node_Str""+ _eol);
    result.append(""String_Node_Str"" + portName + ""String_Node_Str""+ portName+ ""String_Node_Str""+ foo+ ""String_Node_Str""+ _eol);
  }
  if (port.isOutput())   for (foo=0; foo < port.getWidth(); foo++) {
    result.append(""String_Node_Str"" + portName + ""String_Node_Str""+ foo+ ""String_Node_Str""+ _eol);
    result.append(""String_Node_Str"" + portName + ""String_Node_Str""+ portName+ ""String_Node_Str""+ foo+ ""String_Node_Str""+ _eol);
  }
  return result.toString();
}","/** 
 * Generate the code of the declaration of an IOPort (or a subclass) Initialize all its dependencies (container, widths ...) In this base class we deal with all the known kinds of ports, however ideally we should create an adapter for each type of port. There are essentially four types of ports : - input/output - from a composite/atomic actor The creation of the receivers relies on this distinction.
 * @return the port declaration to include in the actor constructor
 * @exception IllegalActionException if the getWidth or getWidthInsidethrows an exception 
 */
public String generatePortDeclaration() throws IllegalActionException {
  StringBuffer result=new StringBuffer();
  TemplateParser tParser=getTemplateParser();
  ProgramCodeGenerator codeGenerator=getCodeGenerator();
  ptolemy.actor.IOPort port=(ptolemy.actor.IOPort)getComponent();
  String portName=port.getName();
  String typePort=port.getClass().getSimpleName();
  if (port instanceof ParameterPort || port instanceof PubSubPort || port instanceof ModalBasePort)   typePort=""String_Node_Str"";
  NamedObj actor=port.getContainer();
  String sanitizedActorName=CodeGeneratorAdapter.generateName(actor);
  if (!port.isInsideConnected() && !port.isOutsideConnected())   return ""String_Node_Str"";
  result.append(portName + ""String_Node_Str"" + typePort+ ""String_Node_Str""+ _eol);
  result.append(portName + ""String_Node_Str"" + sanitizedActorName+ ""String_Node_Str""+ _eol);
  result.append(portName + ""String_Node_Str"" + port.isInsideConnected()+ ""String_Node_Str""+ _eol);
  result.append(portName + ""String_Node_Str"" + port.isOutsideConnected()+ ""String_Node_Str""+ _eol);
  result.append(portName + ""String_Node_Str"" + port.isInput()+ ""String_Node_Str""+ _eol);
  result.append(portName + ""String_Node_Str"" + port.isOutput()+ ""String_Node_Str""+ _eol);
  result.append(portName + ""String_Node_Str"" + port.isMultiport()+ ""String_Node_Str""+ _eol);
  result.append(portName + ""String_Node_Str"" + port.getWidth()+ ""String_Node_Str""+ _eol);
  result.append(portName + ""String_Node_Str"" + port.getWidthInside()+ ""String_Node_Str""+ _eol);
  result.append(portName + ""String_Node_Str"" + port.numberOfSinks()+ ""String_Node_Str""+ _eol);
  result.append(portName + ""String_Node_Str"" + port.numberOfSources()+ ""String_Node_Str""+ _eol);
  Parameter parameter=(Parameter)((NamedObj)port).getAttribute(""String_Node_Str"");
  Double ioPortDelayOffset=null;
  if (parameter != null) {
    Token token=parameter.getToken();
    if (token instanceof DoubleToken) {
      ioPortDelayOffset=((DoubleToken)token).doubleValue();
    }
 else     if (token instanceof ArrayToken) {
      ioPortDelayOffset=((DoubleToken)((ArrayToken)token).getElement(0)).doubleValue();
    }
  }
  if (ioPortDelayOffset != null)   result.append(portName + ""String_Node_Str"" + ioPortDelayOffset.doubleValue()+ ""String_Node_Str""+ _eol);
  if (port instanceof MirrorPort) {
    MirrorPort mport=(MirrorPort)port;
    MirrorPort associatedPort=mport.getAssociatedPort();
    String accessorAssociatedPort=CodeGeneratorAdapter.generateName(associatedPort.getContainer()) + ""String_Node_Str"" + associatedPort.getName()+ ""String_Node_Str"";
    result.append(""String_Node_Str"" + portName + ""String_Node_Str""+ accessorAssociatedPort+ ""String_Node_Str""+ _eol);
    if (mport instanceof PtidesPort) {
      PtidesPort ptidesPort=(PtidesPort)mport;
      result.append(""String_Node_Str"" + portName + ""String_Node_Str""+ ((BooleanToken)ptidesPort.actuateAtEventTimestamp.getToken()).booleanValue()+ ""String_Node_Str""+ _eol);
      result.append(""String_Node_Str"" + portName + ""String_Node_Str""+ ((DoubleToken)ptidesPort.deviceDelay.getToken()).doubleValue()+ ""String_Node_Str""+ _eol);
      result.append(""String_Node_Str"" + portName + ""String_Node_Str""+ ((DoubleToken)ptidesPort.deviceDelayBound.getToken()).doubleValue()+ ""String_Node_Str""+ _eol);
      result.append(""String_Node_Str"" + portName + ""String_Node_Str""+ ((BooleanToken)ptidesPort.isNetworkPort.getToken()).booleanValue()+ ""String_Node_Str""+ _eol);
      if (ptidesPort.isNetworkReceiverPort() || ptidesPort.isNetworkTransmitterPort()) {
        result.append(""String_Node_Str"" + portName + ""String_Node_Str""+ ((DoubleToken)ptidesPort.networkDelayBound.getToken()).doubleValue()+ ""String_Node_Str""+ _eol);
        result.append(""String_Node_Str"" + portName + ""String_Node_Str""+ ((DoubleToken)ptidesPort.sourcePlatformDelayBound.getToken()).doubleValue()+ ""String_Node_Str""+ _eol);
      }
    }
  }
  if (port instanceof TypedIOPort) {
    TypedIOPort typedPort=(TypedIOPort)port;
    String type=codeGenerator.codeGenType(typedPort.getType());
    if (type.contains(""String_Node_Str"")) {
      result.append(portName + ""String_Node_Str"" + _eol);
      tParser.addNewTypesUsed(""String_Node_Str"");
      for (      String typ : type.split(""String_Node_Str"")) {
        tParser.addNewTypesUsed(typ);
      }
    }
 else {
      result.append(portName + ""String_Node_Str"" + type+ ""String_Node_Str""+ _eol);
      tParser.addNewTypesUsed(type);
    }
  }
  int foo=0;
  if (port.isInput())   result.append(""String_Node_Str"" + sanitizedActorName + ""String_Node_Str""+ portName+ ""String_Node_Str""+ _eol);
  if (port.isOutput())   result.append(""String_Node_Str"" + sanitizedActorName + ""String_Node_Str""+ portName+ ""String_Node_Str""+ _eol);
  Receiver[][] receiverss;
  if (port.isInput())   receiverss=port.getReceivers();
 else   if (port.isOutput() && actor instanceof CompositeActor)   receiverss=port.getInsideReceivers();
 else   receiverss=new Receiver[0][];
  String directorCall=(actor instanceof CompositeActor ? ""String_Node_Str"" : ""String_Node_Str"");
  if (port instanceof PtidesPort)   directorCall=(!port.isInput() && actor instanceof CompositeActor && ((CompositeActor)actor).isOpaque() ? ""String_Node_Str"" : ""String_Node_Str"");
  String localReceiver=(port.isInput() ? ""String_Node_Str"" : ""String_Node_Str"");
  for (  Receiver[] receivers : receiverss) {
    result.append(""String_Node_Str"" + portName + ""String_Node_Str""+ foo+ ""String_Node_Str""+ _eol);
    int bar=0;
    for (    Receiver receiver : receivers) {
      String typeReceiver=receiver.getClass().getSimpleName();
      if (typeReceiver.compareTo(""String_Node_Str"") == 0)       typeReceiver=""String_Node_Str"";
      String receiverName=portName + ""String_Node_Str"" + foo+ ""String_Node_Str""+ bar;
      result.append(""String_Node_Str"" + typeReceiver + ""String_Node_Str""+ receiverName+ ""String_Node_Str""+ typeReceiver+ ""String_Node_Str""+ _eol);
      result.append(receiverName + ""String_Node_Str"" + portName+ ""String_Node_Str""+ _eol);
      if (receiver instanceof PtidesReceiver) {
        result.append(receiverName + ""String_Node_Str"" + sanitizedActorName+ ""String_Node_Str""+ directorCall+ ""String_Node_Str""+ sanitizedActorName+ ""String_Node_Str""+ _eol);
      }
 else       if (receiver instanceof DEReceiver) {
        result.append(receiverName + ""String_Node_Str"" + sanitizedActorName+ ""String_Node_Str""+ directorCall+ ""String_Node_Str""+ sanitizedActorName+ ""String_Node_Str""+ _eol);
      }
      result.append(""String_Node_Str"" + portName + ""String_Node_Str""+ foo+ ""String_Node_Str""+ receiverName+ ""String_Node_Str""+ _eol);
      bar++;
    }
    result.append(""String_Node_Str"" + portName + ""String_Node_Str""+ localReceiver+ ""String_Node_Str""+ portName+ ""String_Node_Str""+ foo+ ""String_Node_Str""+ _eol);
    foo++;
  }
  if (port.isInput() && actor instanceof CompositeActor)   for (foo=0; foo < port.getWidthInside(); foo++) {
    result.append(""String_Node_Str"" + portName + ""String_Node_Str""+ foo+ ""String_Node_Str""+ _eol);
    result.append(""String_Node_Str"" + portName + ""String_Node_Str""+ portName+ ""String_Node_Str""+ foo+ ""String_Node_Str""+ _eol);
  }
  if (port.isOutput())   for (foo=0; foo < port.getWidth(); foo++) {
    result.append(""String_Node_Str"" + portName + ""String_Node_Str""+ foo+ ""String_Node_Str""+ _eol);
    result.append(""String_Node_Str"" + portName + ""String_Node_Str""+ portName+ ""String_Node_Str""+ foo+ ""String_Node_Str""+ _eol);
  }
  return result.toString();
}"
72869,"/** 
 * Put a trigger event into the event queue. <p> The trigger event has the same timestamp as that of the director. The microstep of this event is always equal to the current microstep of this director. The depth for the queued event is the depth of the destination IO port. Finally, the token and the destination receiver are also stored in the event. </p><p> If the event queue is not ready or the actor that contains the destination port is disabled, do nothing.</p>
 * @param ioPort The destination IO port.
 * @param token The token associated with this event.
 * @param receiver The destination receiver.
 * @exception IllegalActionException If the time argument is not thecurrent time, or the depth of the given IO port has not be calculated, or the new event can not be enqueued.
 */
protected void _enqueueTriggerEvent(IOPort ioPort,Token token,Receiver receiver) throws IllegalActionException {
  Actor actor=(Actor)ioPort.getContainer();
  if (_eventQueue == null || _disabledActors != null && _disabledActors.contains(actor)) {
    return;
  }
  int depth=_getDepthOfIOPort(ioPort);
  if (_debugging) {
    _debug(""String_Node_Str"",((NamedObj)actor).getName(),""String_Node_Str"" + ioPort + ""String_Node_Str""+ getModelTime()+ ""String_Node_Str""+ _microstep+ ""String_Node_Str""+ depth);
  }
  PtidesEvent newEvent=new PtidesEvent(ioPort,ioPort.getChannelForReceiver(receiver),getModelTime(),_currentLogicalIndex,depth,token,receiver,_currentSourceTimestamp);
  if (ioPort.isOutput()) {
    Time deliveryTime;
    deliveryTime=localClock.getLocalTime();
    if (((PtidesPort)ioPort).isActuatorPort()) {
      if (((PtidesPort)ioPort).actuateAtEventTimestamp()) {
        deliveryTime=getModelTime().subtract(_getDoubleParameterValue(ioPort,""String_Node_Str""));
      }
      if (getModelTime().compareTo(deliveryTime) < 0) {
        newEvent=_handleTimingError((PtidesPort)ioPort,newEvent,""String_Node_Str"" + ioPort + ""String_Node_Str""+ ""String_Node_Str""+ getModelTime()+ ""String_Node_Str""+ localClock.getLocalTime());
      }
    }
 else     if (((PtidesPort)ioPort).isNetworkTransmitterPort()) {
      if (localClock.getLocalTime().subtract(getModelTime()).getDoubleValue() > _getDoubleParameterValue(ioPort,""String_Node_Str"")) {
        newEvent=_handleTimingError((PtidesPort)ioPort,newEvent,""String_Node_Str"" + ""String_Node_Str"" + localClock.getLocalTime() + ""String_Node_Str""+ getModelTime()+ ""String_Node_Str""+ _getDoubleParameterValue(ioPort,""String_Node_Str""));
      }
    }
    if (newEvent != null) {
      List<PtidesEvent> list=_outputEventDeadlines.get(deliveryTime);
      if (list == null) {
        list=new ArrayList<PtidesEvent>();
      }
      list.add(newEvent);
      _outputEventDeadlines.put(deliveryTime,list);
      if (_debugging) {
        _debug(""String_Node_Str"" + deliveryTime);
      }
    }
  }
 else {
    _eventQueue.put(newEvent);
    if (_numberOfTokensPerPort == null) {
      _numberOfTokensPerPort=new HashMap<IOPort,Integer>();
    }
    IOPort port=newEvent.ioPort();
    if (port != null) {
      _numberOfTokensPerPort.put(port,_numberOfTokensPerPort.get(port) + 1);
    }
  }
}","/** 
 * Put a trigger event into the event queue. <p> The trigger event has the same timestamp as that of the director. The microstep of this event is always equal to the current microstep of this director. The depth for the queued event is the depth of the destination IO port. Finally, the token and the destination receiver are also stored in the event. </p><p> If the event queue is not ready or the actor that contains the destination port is disabled, do nothing.</p>
 * @param ioPort The destination IO port.
 * @param token The token associated with this event.
 * @param receiver The destination receiver.
 * @exception IllegalActionException If the time argument is not thecurrent time, or the depth of the given IO port has not be calculated, or the new event can not be enqueued.
 */
protected void _enqueueTriggerEvent(IOPort ioPort,Token token,Receiver receiver) throws IllegalActionException {
  Actor actor=(Actor)ioPort.getContainer();
  if (_eventQueue == null || _disabledActors != null && _disabledActors.contains(actor)) {
    return;
  }
  int depth=_getDepthOfIOPort(ioPort);
  if (_debugging) {
    _debug(""String_Node_Str"",((NamedObj)actor).getName(),""String_Node_Str"" + ioPort + ""String_Node_Str""+ getModelTime()+ ""String_Node_Str""+ _microstep+ ""String_Node_Str""+ depth);
  }
  PtidesEvent newEvent=new PtidesEvent(ioPort,ioPort.getChannelForReceiver(receiver),getModelTime(),_currentLogicalIndex,depth,token,receiver,_currentSourceTimestamp);
  if (ioPort.isOutput()) {
    Time deliveryTime;
    deliveryTime=localClock.getLocalTime();
    if (((PtidesPort)ioPort).isActuatorPort()) {
      if (((PtidesPort)ioPort).actuateAtEventTimestamp()) {
        deliveryTime=getModelTime().subtract(_getDoubleParameterValue(ioPort,""String_Node_Str""));
      }
      if (getModelTime().compareTo(deliveryTime) < 0) {
        newEvent=_handleTimingError((PtidesPort)ioPort,newEvent,""String_Node_Str"" + ioPort + ""String_Node_Str""+ ""String_Node_Str""+ getModelTime()+ ""String_Node_Str""+ localClock.getLocalTime());
      }
    }
 else     if (((PtidesPort)ioPort).isNetworkTransmitterPort()) {
      if (localClock.getLocalTime().subtract(getModelTime()).getDoubleValue() > _getDoubleParameterValue(ioPort,""String_Node_Str"")) {
        newEvent=_handleTimingError((PtidesPort)ioPort,newEvent,""String_Node_Str"" + ""String_Node_Str"" + localClock.getLocalTime() + ""String_Node_Str""+ getModelTime()+ ""String_Node_Str""+ _getDoubleParameterValue(ioPort,""String_Node_Str""));
      }
    }
    if (newEvent != null) {
      List<PtidesEvent> list=_outputEventDeadlines.get(deliveryTime);
      if (list == null) {
        list=new ArrayList<PtidesEvent>();
      }
      list.add(newEvent);
      _outputEventDeadlines.put(deliveryTime,list);
      if (_debugging) {
        _debug(""String_Node_Str"" + deliveryTime);
      }
    }
  }
 else {
    _eventQueue.put(newEvent);
    if (_numberOfTokensPerPort == null) {
      _numberOfTokensPerPort=new HashMap<IOPort,Integer>();
    }
    IOPort port=newEvent.ioPort();
    if (port != null) {
      if (_numberOfTokensPerPort == null) {
        _numberOfTokensPerPort=new HashMap<IOPort,Integer>();
      }
      Integer numberofTokens=_numberOfTokensPerPort.get(port);
      if (numberofTokens == null) {
        numberofTokens=0;
      }
      _numberOfTokensPerPort.put(port,numberofTokens + 1);
    }
  }
}"
72870,"private int _getNumberOfFutureEventsFrom(Actor actor){
  HashMap<Actor,Integer> sinkActorEventQueueSize=new HashMap();
  int maxEvents=0;
  for (  Object object : actor.outputPortList()) {
    IOPort port=(IOPort)object;
    for (    Object sinkPort : port.sinkPortList()) {
      if (((IOPort)sinkPort).getContainer() == this.getContainer()) {
        for (        Time time : _outputEventDeadlines.keySet()) {
          maxEvents+=_outputEventDeadlines.get(time).size();
        }
      }
 else {
        maxEvents+=_numberOfTokensPerPort.get(sinkPort);
      }
    }
  }
  return maxEvents;
}","private int _getNumberOfFutureEventsFrom(Actor actor){
  HashMap<Actor,Integer> sinkActorEventQueueSize=new HashMap();
  int maxEvents=0;
  for (  Object object : actor.outputPortList()) {
    IOPort port=(IOPort)object;
    for (    Object sinkPort : port.sinkPortList()) {
      if (((IOPort)sinkPort).getContainer() == this.getContainer()) {
        for (        Time time : _outputEventDeadlines.keySet()) {
          maxEvents+=_outputEventDeadlines.get(time).size();
        }
      }
 else {
        if (_numberOfTokensPerPort == null) {
          _numberOfTokensPerPort=new HashMap<IOPort,Integer>();
        }
        Integer numberOfTokens=_numberOfTokensPerPort.get(sinkPort);
        if (numberOfTokens == null) {
          numberOfTokens=0;
        }
        maxEvents+=numberOfTokens;
      }
    }
  }
  return maxEvents;
}"
72871,"/** 
 * Clone the object into the specified workspace. The new object is <i>not</i> added to the directory of that workspace (you must do this yourself if you want it there). The result is an attribute with no container.
 * @param workspace The workspace for the cloned object.
 * @exception CloneNotSupportedException Not thrown in this base class
 * @return The new Attribute.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  PtidesDirector newObject=(PtidesDirector)super.clone(workspace);
  try {
    newObject._clockSynchronizationErrorBound=new Time(newObject,0.0);
  }
 catch (  IllegalActionException e) {
  }
  return newObject;
}","/** 
 * Clone the object into the specified workspace. The new object is <i>not</i> added to the directory of that workspace (you must do this yourself if you want it there). The result is an attribute with no container.
 * @param workspace The workspace for the cloned object.
 * @exception CloneNotSupportedException Not thrown in this base class
 * @return The new Attribute.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  PtidesDirector newObject=(PtidesDirector)super.clone(workspace);
  try {
    newObject._clockSynchronizationErrorBound=new Time(newObject,0.0);
    newObject._numberOfTokensPerPort=new HashMap<IOPort,Integer>();
  }
 catch (  IllegalActionException e) {
  }
  return newObject;
}"
72872,"public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == observationProbabilities) {
    int nStates=((MatrixToken)observationProbabilities.getToken()).getRowCount();
    int nCat=((MatrixToken)observationProbabilities.getToken()).getColumnCount();
    for (int i=0; i < nStates; i++) {
      for (int j=0; j < nCat; j++) {
        _B0[i][j]=((DoubleToken)((MatrixToken)observationProbabilities.getToken()).getElementAsToken(i,j)).doubleValue();
      }
    }
  }
 else   if (attribute == nCategories) {
    int cat=((IntToken)nCategories.getToken()).intValue();
    if (cat <= 0) {
      throw new IllegalActionException(this,""String_Node_Str"");
    }
 else {
      _nCategories=cat;
    }
  }
 else {
    super.attributeChanged(attribute);
  }
}","public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == observationProbabilities) {
    int nCat=((MatrixToken)observationProbabilities.getToken()).getColumnCount();
    _B0=new double[_nStates][nCat];
    for (int i=0; i < _nStates; i++) {
      for (int j=0; j < nCat; j++) {
        _B0[i][j]=((DoubleToken)((MatrixToken)observationProbabilities.getToken()).getElementAsToken(i,j)).doubleValue();
      }
    }
  }
 else   if (attribute == nCategories) {
    int cat=((IntToken)nCategories.getToken()).intValue();
    if (cat <= 0) {
      throw new IllegalActionException(this,""String_Node_Str"");
    }
 else {
      _nCategories=cat;
    }
  }
 else {
    super.attributeChanged(attribute);
  }
}"
72873,"public void fire() throws IllegalActionException {
  super.fire();
  if ((_nStates != _transitionMatrix.length) || (_nStates != _priors.length) || (_nCategories != _B0[0].length)) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  HashMap newEstimates=new HashMap();
  _transitionMatrix=_A0;
  _B=_B0;
  double[][] A_new=new double[_nStates][_nStates];
  double[][] B_new=new double[_nStates][_nCategories];
  for (int iterations=0; iterations < _nIterations; iterations++) {
    newEstimates=HMMAlphaBetaRecursion(_observations,_transitionMatrix,_priors,_nCategories);
    B_new=(double[][])newEstimates.get(""String_Node_Str"");
    A_new=(double[][])newEstimates.get(""String_Node_Str"");
    _transitionMatrix=A_new;
    _B=B_new;
    double likelihood=(Double)(newEstimates.get(""String_Node_Str""));
    if ((likelihood - _likelihood) < _likelihoodThreshold || (likelihood - _likelihood) < 0.0) {
      break;
    }
 else {
      _likelihood=likelihood;
    }
  }
  double[] pi_new=(double[])newEstimates.get(""String_Node_Str"");
  Token[] pTokens=new Token[_nStates];
  for (int i=0; i < _nStates; i++) {
    pTokens[i]=new DoubleToken(pi_new[i]);
  }
  transitionMatrix.send(0,new DoubleMatrixToken(A_new));
  emissionEstimates.send(0,new DoubleMatrixToken(B_new));
  priorEstimates.send(0,new ArrayToken(pTokens));
}","public void fire() throws IllegalActionException {
  super.fire();
  if ((_nStates != _transitionMatrix.length) || (_nStates != _priors.length) || (_nCategories != _B0[0].length)) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  boolean converged=_EMParameterEstimation();
  Token[] pTokens=new Token[_nStates];
  for (int i=0; i < _nStates; i++) {
    pTokens[i]=new DoubleToken(prior_new[i]);
  }
  transitionMatrix.send(0,new DoubleMatrixToken(A_new));
  emissionEstimates.send(0,new DoubleMatrixToken(B_new));
  priorEstimates.send(0,new ArrayToken(pTokens));
}"
72874,"/** 
 * Construct an actor in the specified container with the specified name.
 * @param container The container.
 * @param name The name of this adder within the container.
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the name coincides withan actor already in the container.
 */
public AddSubtract(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  plus=new TypedIOPort(this,""String_Node_Str"",true,false);
  plus.setMultiport(true);
  plus.setAutomaticTypeConversion(true);
  minus=new TypedIOPort(this,""String_Node_Str"",true,false);
  minus.setMultiport(true);
  minus.setAutomaticTypeConversion(true);
  output=new TypedIOPort(this,""String_Node_Str"",false,true);
  output.setTypeAtLeast(plus);
  output.setTypeAtLeast(minus);
  plus.setTypeSameAs(minus);
  _attachText(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","/** 
 * Construct an actor in the specified container with the specified name.
 * @param container The container.
 * @param name The name of this adder within the container.
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the name coincides withan actor already in the container.
 */
public AddSubtract(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  plus=new TypedIOPort(this,""String_Node_Str"",true,false);
  plus.setMultiport(true);
  plus.setAutomaticTypeConversion(false);
  minus=new TypedIOPort(this,""String_Node_Str"",true,false);
  minus.setMultiport(true);
  minus.setAutomaticTypeConversion(false);
  output=new TypedIOPort(this,""String_Node_Str"",false,true);
  output.setTypeAtLeast(plus);
  output.setTypeAtLeast(minus);
  plus.setTypeSameAs(minus);
  _attachText(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}"
72875,"/** 
 * Generate type conversion code. Determine the proper code put into the source to support dynamic type resolution. First, find out the different types used in the model. Second, find out the different polymorphic functions used. (note: types and functions are independent of each other). Third, append code blocks according to the functions used, and read from files according to the types referenced. Fourth, generate type resolution code, which consists of constants (MAX_NUM_TYPE, MAX_NUM_FUNC), the type map, the function map, function definitions read from the files, and function table. Note that this method is really different from the super one because it splits the code in a .c part and a .h part.
 * @return The type resolution code.
 * @exception IllegalActionException If an error occurs when generatingthe type resolution code, or if the adapter class for the model director cannot be found, or if an error occurs when the adapter actor generates the type resolution code.
 */
public String[] generateTypeConvertCodeCandH() throws IllegalActionException {
  StringBuffer codeH=new StringBuffer();
  StringBuffer codeC=new StringBuffer();
  codeC.append(""String_Node_Str"");
  codeH.append(_eol + ""String_Node_Str"");
  codeH.append(_eol + ""String_Node_Str"");
  codeH.append(_eol + ""String_Node_Str"");
  codeH.append(_eol + ""String_Node_Str"");
  codeH.append(_eol + ""String_Node_Str"");
  codeH.append(_eol + ""String_Node_Str"");
  codeH.append(_eol + ""String_Node_Str"");
  codeH.append(_eol + ""String_Node_Str"");
  codeH.append(_eol + ""String_Node_Str"");
  codeH.append(_eol + comment(""String_Node_Str"" + getContainer().getFullName()));
  codeC.append(_eol + comment(""String_Node_Str"" + getContainer().getFullName()));
  CodeStream sharedStream=new CodeStream(""String_Node_Str"",this);
  sharedStream.appendCodeBlock(""String_Node_Str"");
  codeH.append(sharedStream.toString());
  HashSet<String> functions=_getReferencedFunctions();
  HashSet<String> types=_getTypeIDToUsed(_getNewTypesUsed(functions));
  String[] typesArray=new String[types.size()];
  types.toArray(typesArray);
  CodeStream[] typeStreams=new CodeStream[types.size()];
  StringBuffer typeMembers=new StringBuffer();
  codeH.append(""String_Node_Str"" + _eol);
  codeH.append(""String_Node_Str"" + _eol);
  codeH.append(""String_Node_Str"" + _eol);
  for (int i=0; i < typesArray.length; i++) {
    if (typesArray[i].endsWith(""String_Node_Str"")) {
      typeStreams[i]=new CodeStream(""String_Node_Str"" + typesArray[i].substring(0,typesArray[i].indexOf(""String_Node_Str"")) + ""String_Node_Str"",this);
    }
 else {
      typeStreams[i]=new CodeStream(""String_Node_Str"" + typesArray[i] + ""String_Node_Str"",this);
      codeH.append(""String_Node_Str"" + typesArray[i] + ""String_Node_Str""+ i+ _eol);
      typeMembers.append(typesArray[i] + ""String_Node_Str"" + typesArray[i]+ ""String_Node_Str"");
      if (i < typesArray.length - 1) {
        typeMembers.append(_eol);
      }
    }
  }
  String[] functionsArray=new String[functions.size()];
  functions.toArray(functionsArray);
  boolean defineEmptyToken=false;
  int offset=0;
  for (int i=0; i < functionsArray.length; i++) {
    if (functionsArray[i].equals(""String_Node_Str"")) {
      offset=1;
    }
 else {
      codeH.append(""String_Node_Str"" + functionsArray[i] + ""String_Node_Str""+ (i - offset)+ _eol);
      if (functionsArray[i].equals(""String_Node_Str"")) {
        defineEmptyToken=true;
      }
    }
  }
  codeH.append(""String_Node_Str"" + _eol);
  for (int i=0; i < typesArray.length; i++) {
    typeStreams[i].appendCodeBlock(""String_Node_Str"");
    codeH.append(typeStreams[i].toString());
  }
  ArrayList<String> args=new ArrayList<String>();
  ArrayList<String> functionsDeclared=new ArrayList<String>();
  if (typeMembers.length() != 0) {
    sharedStream.clear();
    args.add(typeMembers.toString());
    sharedStream.appendCodeBlock(""String_Node_Str"",args);
    if (defineEmptyToken) {
      sharedStream.append(""String_Node_Str"" + comment(""String_Node_Str"") + _eol);
    }
    codeH.append(sharedStream.toString());
  }
  boolean defineUnsupportedTypeFunctionMethod=false;
  boolean defineScalarDeleteMethod=false;
  StringBuffer convertImplementation=new StringBuffer(_eol + ""String_Node_Str"" + _eol);
  convertImplementation.append(""String_Node_Str"" + _eol + ""String_Node_Str""+ _eol);
  String convertDeclaration=_eol + ""String_Node_Str"" + _eol;
  codeH.append(convertDeclaration);
  for (int i=0; i < typesArray.length; i++) {
    typeStreams[i].clear();
    typeStreams[i].appendCodeBlock(""String_Node_Str"");
    codeH.append(typeStreams[i].toString());
    typeStreams[i].clear();
    typeStreams[i].appendCodeBlock(""String_Node_Str"",true);
    codeC.append(typeStreams[i].toString());
    convertImplementation.append(_eol + ""String_Node_Str"" + typesArray[i]+ ""String_Node_Str"");
    convertImplementation.append(_eol + ""String_Node_Str"" + typesArray[i]+ ""String_Node_Str""+ _eol+ ""String_Node_Str"");
  }
  convertImplementation.append(_eol + ""String_Node_Str"" + _eol+ ""String_Node_Str""+ _eol);
  codeC.append(convertImplementation.toString());
  sharedStream.clear();
  sharedStream.appendCodeBlock(""String_Node_Str"");
  codeH.append(sharedStream.toString());
  sharedStream.clear();
  sharedStream.appendCodeBlock(""String_Node_Str"");
  codeC.append(sharedStream.toString());
  sharedStream.clear();
  StringBuffer typeFunctionCode=new StringBuffer();
  for (int i=0; i < typesArray.length; i++) {
    typeStreams[i].clear();
    if (typesArray[i].endsWith(""String_Node_Str"")) {
      continue;
    }
    for (    String element : functionsArray) {
      String functionName=typesArray[i] + ""String_Node_Str"" + element;
      try {
        if (element.equals(""String_Node_Str"") && (typesArray[i].equals(""String_Node_Str"") || typesArray[i].equals(""String_Node_Str""))) {
          if (!functions.contains(""String_Node_Str"")) {
            markFunctionCalled(typesArray[i] + ""String_Node_Str"",null);
          }
        }
 else {
          if (!_unsupportedTypeFunctions.contains(functionName) && !_overloadedFunctionSet.contains(functionName)) {
            markFunctionCalled(functionName,null);
          }
        }
      }
 catch (      IllegalActionException ex) {
        typeStreams[i].append(""String_Node_Str"" + functionName + ""String_Node_Str""+ _eol);
        _unsupportedTypeFunctions.add(functionName);
        System.out.println(""String_Node_Str"" + functionName + ""String_Node_Str"");
      }
    }
    typeFunctionCode.append(processCode(typeStreams[i].toString()));
  }
  for (int i=0; i < types.size(); i++) {
    if (typesArray[i].endsWith(""String_Node_Str""))     continue;
    for (int j=0; j < functionsArray.length; j++) {
      String functionName=typesArray[i] + ""String_Node_Str"" + functionsArray[j];
      if (_unsupportedTypeFunctions.contains(functionName)) {
        defineUnsupportedTypeFunctionMethod=true;
      }
      if (_scalarDeleteTypes.contains(typesArray[i]) && functionsArray[j].equals(""String_Node_Str"")) {
        defineScalarDeleteMethod=true;
      }
      if (functionsArray[j].equals(""String_Node_Str"") && (typesArray[i].equals(""String_Node_Str"") || typesArray[i].equals(""String_Node_Str""))) {
        boolean foundEquals=false;
        for (        String element : functionsArray) {
          if (element.equals(""String_Node_Str"")) {
            foundEquals=true;
          }
        }
        if (!foundEquals) {
          args.clear();
          functionName=typesArray[i] + ""String_Node_Str"";
          if (!_unsupportedTypeFunctions.contains(functionName)) {
            args.add(functionName);
            functionsDeclared.add(functionName);
            sharedStream.appendCodeBlock(""String_Node_Str"",args);
          }
        }
      }
      if (!_scalarDeleteTypes.contains(typesArray[i]) || !functionsArray[j].equals(""String_Node_Str"")) {
        args.clear();
        if (!_unsupportedTypeFunctions.contains(functionName) && !functionName.endsWith(""String_Node_Str"")) {
          args.add(functionName);
          functionsDeclared.add(functionName);
          sharedStream.append(""String_Node_Str"" + _eol);
          sharedStream.appendCodeBlock(""String_Node_Str"",args);
        }
      }
    }
  }
  codeH.append(sharedStream.toString());
  sharedStream.clear();
  if (defineUnsupportedTypeFunctionMethod) {
    sharedStream.appendCodeBlock(""String_Node_Str"");
  }
  if (defineScalarDeleteMethod) {
    sharedStream.appendCodeBlock(""String_Node_Str"");
  }
  codeC.append(sharedStream.toString());
  sharedStream.clear();
  if (defineUnsupportedTypeFunctionMethod) {
    sharedStream.appendCodeBlock(""String_Node_Str"");
  }
  if (defineScalarDeleteMethod) {
    sharedStream.appendCodeBlock(""String_Node_Str"");
  }
  codeH.append(sharedStream.toString());
  codeC.append(_overloadedFunctions.toString());
  codeH.append(_overloadedFunctionsDeclaration.toString());
  codeC.append(generateFunctionTable(typesArray,functionsArray));
  codeH.append(""String_Node_Str"" + typesArray.length + _eol);
  codeH.append(""String_Node_Str"" + functionsArray.length + _eol);
  codeH.append(""String_Node_Str"" + ""String_Node_Str"" + _eol);
  codeH.append(typeFunctionCode);
  codeH.append(_eol + ""String_Node_Str"");
  codeH.append(_eol + ""String_Node_Str"");
  codeH.append(_eol + ""String_Node_Str"");
  codeH.append(_eol + ""String_Node_Str"");
  codeH.append(_eol + ""String_Node_Str"");
  codeH.append(_eol + ""String_Node_Str"");
  String[] result=new String[2];
  result[0]=processCode(codeH.toString());
  result[1]=processCode(codeC.toString());
  return result;
}","/** 
 * Generate type conversion code. Determine the proper code put into the source to support dynamic type resolution. First, find out the different types used in the model. Second, find out the different polymorphic functions used. (note: types and functions are independent of each other). Third, append code blocks according to the functions used, and read from files according to the types referenced. Fourth, generate type resolution code, which consists of constants (MAX_NUM_TYPE, MAX_NUM_FUNC), the type map, the function map, function definitions read from the files, and function table. Note that this method is really different from the super one because it splits the code in a .c part and a .h part.
 * @return The type resolution code.
 * @exception IllegalActionException If an error occurs when generatingthe type resolution code, or if the adapter class for the model director cannot be found, or if an error occurs when the adapter actor generates the type resolution code.
 */
public String[] generateTypeConvertCodeCandH() throws IllegalActionException {
  StringBuffer codeH=new StringBuffer();
  StringBuffer codeC=new StringBuffer();
  codeC.append(""String_Node_Str"");
  codeH.append(_eol + ""String_Node_Str"");
  codeH.append(_eol + ""String_Node_Str"");
  codeH.append(_eol + ""String_Node_Str"");
  codeH.append(_eol + ""String_Node_Str"");
  codeH.append(_eol + ""String_Node_Str"");
  codeH.append(_eol + ""String_Node_Str"");
  codeH.append(_eol + ""String_Node_Str"");
  codeH.append(_eol + ""String_Node_Str"");
  codeH.append(_eol + ""String_Node_Str"");
  codeH.append(_eol + comment(""String_Node_Str"" + getContainer().getFullName()));
  codeC.append(_eol + comment(""String_Node_Str"" + getContainer().getFullName()));
  CodeStream sharedStream=new CodeStream(""String_Node_Str"",this);
  sharedStream.appendCodeBlock(""String_Node_Str"");
  codeH.append(sharedStream.toString());
  HashSet<String> functions=_getReferencedFunctions();
  HashSet<String> types=_getTypeIDToUsed(_getNewTypesUsed(functions));
  String[] typesArray=new String[types.size()];
  types.toArray(typesArray);
  CodeStream[] typeStreams=new CodeStream[types.size()];
  StringBuffer typeMembers=new StringBuffer();
  codeH.append(""String_Node_Str"" + _eol);
  codeH.append(""String_Node_Str"" + _eol);
  if (!types.contains(""String_Node_Str""))   codeH.append(""String_Node_Str"" + _eol);
  for (int i=0; i < typesArray.length; i++) {
    if (typesArray[i].endsWith(""String_Node_Str"")) {
      typeStreams[i]=new CodeStream(""String_Node_Str"" + typesArray[i].substring(0,typesArray[i].indexOf(""String_Node_Str"")) + ""String_Node_Str"",this);
    }
 else {
      typeStreams[i]=new CodeStream(""String_Node_Str"" + typesArray[i] + ""String_Node_Str"",this);
      codeH.append(""String_Node_Str"" + typesArray[i] + ""String_Node_Str""+ i+ _eol);
      typeMembers.append(typesArray[i] + ""String_Node_Str"" + typesArray[i]+ ""String_Node_Str"");
      if (i < typesArray.length - 1) {
        typeMembers.append(_eol);
      }
    }
  }
  String[] functionsArray=new String[functions.size()];
  functions.toArray(functionsArray);
  boolean defineEmptyToken=false;
  int offset=0;
  for (int i=0; i < functionsArray.length; i++) {
    if (functionsArray[i].equals(""String_Node_Str"")) {
      offset=1;
    }
 else {
      codeH.append(""String_Node_Str"" + functionsArray[i] + ""String_Node_Str""+ (i - offset)+ _eol);
      if (functionsArray[i].equals(""String_Node_Str"")) {
        defineEmptyToken=true;
      }
    }
  }
  codeH.append(""String_Node_Str"" + _eol);
  for (int i=0; i < typesArray.length; i++) {
    typeStreams[i].appendCodeBlock(""String_Node_Str"");
    codeH.append(typeStreams[i].toString());
  }
  ArrayList<String> args=new ArrayList<String>();
  ArrayList<String> functionsDeclared=new ArrayList<String>();
  if (typeMembers.length() != 0) {
    sharedStream.clear();
    args.add(typeMembers.toString());
    sharedStream.appendCodeBlock(""String_Node_Str"",args);
    if (defineEmptyToken) {
      sharedStream.append(""String_Node_Str"" + comment(""String_Node_Str"") + _eol);
    }
    codeH.append(sharedStream.toString());
  }
  boolean defineUnsupportedTypeFunctionMethod=false;
  boolean defineScalarDeleteMethod=false;
  StringBuffer convertImplementation=new StringBuffer(_eol + ""String_Node_Str"" + _eol);
  convertImplementation.append(""String_Node_Str"" + _eol + ""String_Node_Str""+ _eol);
  String convertDeclaration=_eol + ""String_Node_Str"" + _eol;
  codeH.append(convertDeclaration);
  for (int i=0; i < typesArray.length; i++) {
    typeStreams[i].clear();
    typeStreams[i].appendCodeBlock(""String_Node_Str"");
    codeH.append(typeStreams[i].toString());
    typeStreams[i].clear();
    typeStreams[i].appendCodeBlock(""String_Node_Str"",true);
    codeC.append(typeStreams[i].toString());
    convertImplementation.append(_eol + ""String_Node_Str"" + typesArray[i]+ ""String_Node_Str"");
    convertImplementation.append(_eol + ""String_Node_Str"" + typesArray[i]+ ""String_Node_Str""+ _eol+ ""String_Node_Str"");
  }
  convertImplementation.append(_eol + ""String_Node_Str"" + _eol+ ""String_Node_Str""+ _eol);
  codeC.append(convertImplementation.toString());
  sharedStream.clear();
  sharedStream.appendCodeBlock(""String_Node_Str"");
  codeH.append(sharedStream.toString());
  sharedStream.clear();
  sharedStream.appendCodeBlock(""String_Node_Str"");
  codeC.append(sharedStream.toString());
  sharedStream.clear();
  StringBuffer typeFunctionCode=new StringBuffer();
  for (int i=0; i < typesArray.length; i++) {
    typeStreams[i].clear();
    if (typesArray[i].endsWith(""String_Node_Str"")) {
      continue;
    }
    for (    String element : functionsArray) {
      String functionName=typesArray[i] + ""String_Node_Str"" + element;
      try {
        if (element.equals(""String_Node_Str"") && (typesArray[i].equals(""String_Node_Str"") || typesArray[i].equals(""String_Node_Str""))) {
          if (!functions.contains(""String_Node_Str"")) {
            markFunctionCalled(typesArray[i] + ""String_Node_Str"",null);
          }
        }
 else {
          if (!_unsupportedTypeFunctions.contains(functionName) && !_overloadedFunctionSet.contains(functionName)) {
            markFunctionCalled(functionName,null);
          }
        }
      }
 catch (      IllegalActionException ex) {
        typeStreams[i].append(""String_Node_Str"" + functionName + ""String_Node_Str""+ _eol);
        _unsupportedTypeFunctions.add(functionName);
        System.out.println(""String_Node_Str"" + functionName + ""String_Node_Str"");
      }
    }
    typeFunctionCode.append(processCode(typeStreams[i].toString()));
  }
  for (int i=0; i < types.size(); i++) {
    if (typesArray[i].endsWith(""String_Node_Str""))     continue;
    for (int j=0; j < functionsArray.length; j++) {
      String functionName=typesArray[i] + ""String_Node_Str"" + functionsArray[j];
      if (_unsupportedTypeFunctions.contains(functionName)) {
        defineUnsupportedTypeFunctionMethod=true;
      }
      if (_scalarDeleteTypes.contains(typesArray[i]) && functionsArray[j].equals(""String_Node_Str"")) {
        defineScalarDeleteMethod=true;
      }
      if (functionsArray[j].equals(""String_Node_Str"") && (typesArray[i].equals(""String_Node_Str"") || typesArray[i].equals(""String_Node_Str""))) {
        boolean foundEquals=false;
        for (        String element : functionsArray) {
          if (element.equals(""String_Node_Str"")) {
            foundEquals=true;
          }
        }
        if (!foundEquals) {
          args.clear();
          functionName=typesArray[i] + ""String_Node_Str"";
          if (!_unsupportedTypeFunctions.contains(functionName)) {
            args.add(functionName);
            functionsDeclared.add(functionName);
            sharedStream.appendCodeBlock(""String_Node_Str"",args);
          }
        }
      }
      if (!_scalarDeleteTypes.contains(typesArray[i]) || !functionsArray[j].equals(""String_Node_Str"")) {
        args.clear();
        if (!_unsupportedTypeFunctions.contains(functionName) && !functionName.endsWith(""String_Node_Str"")) {
          args.add(functionName);
          functionsDeclared.add(functionName);
          sharedStream.append(""String_Node_Str"" + _eol);
          sharedStream.appendCodeBlock(""String_Node_Str"",args);
        }
      }
    }
  }
  codeH.append(sharedStream.toString());
  sharedStream.clear();
  if (defineUnsupportedTypeFunctionMethod) {
    sharedStream.appendCodeBlock(""String_Node_Str"");
  }
  if (defineScalarDeleteMethod) {
    sharedStream.appendCodeBlock(""String_Node_Str"");
  }
  codeC.append(sharedStream.toString());
  sharedStream.clear();
  if (defineUnsupportedTypeFunctionMethod) {
    sharedStream.appendCodeBlock(""String_Node_Str"");
  }
  if (defineScalarDeleteMethod) {
    sharedStream.appendCodeBlock(""String_Node_Str"");
  }
  codeH.append(sharedStream.toString());
  codeC.append(_overloadedFunctions.toString());
  codeH.append(_overloadedFunctionsDeclaration.toString());
  codeC.append(generateFunctionTable(typesArray,functionsArray));
  codeH.append(""String_Node_Str"" + typesArray.length + _eol);
  codeH.append(""String_Node_Str"" + functionsArray.length + _eol);
  codeH.append(""String_Node_Str"" + ""String_Node_Str"" + _eol);
  codeH.append(typeFunctionCode);
  codeH.append(_eol + ""String_Node_Str"");
  codeH.append(_eol + ""String_Node_Str"");
  codeH.append(_eol + ""String_Node_Str"");
  codeH.append(_eol + ""String_Node_Str"");
  codeH.append(_eol + ""String_Node_Str"");
  codeH.append(_eol + ""String_Node_Str"");
  String[] result=new String[2];
  result[0]=processCode(codeH.toString());
  result[1]=processCode(codeC.toString());
  return result;
}"
72876,"private void _initialize(String[] labels,Token[] values) throws IllegalActionException {
  if (labels == null || values == null || labels.length != values.length) {
    throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
  for (int i=0; i < labels.length; i++) {
    if (labels[i] == null || values[i] == null) {
      throw new IllegalActionException(""String_Node_Str"" + i + ""String_Node_Str"");
    }
    labels[i]=labels[i];
    if (!_fields.containsKey(labels[i])) {
      _fields.put(labels[i],values[i]);
    }
 else {
      throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + labels[i]);
    }
  }
}","private void _initialize(String[] labels,Token[] values) throws IllegalActionException {
  if (labels == null || values == null || labels.length != values.length) {
    System.out.println(labels);
    System.out.println(values);
    System.out.println(labels.length);
    System.out.println(values.length);
    throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
  for (int i=0; i < labels.length; i++) {
    if (labels[i] == null || values[i] == null) {
      throw new IllegalActionException(""String_Node_Str"" + i + ""String_Node_Str"");
    }
    labels[i]=labels[i];
    if (!_fields.containsKey(labels[i])) {
      _fields.put(labels[i],values[i]);
    }
 else {
      throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"" + labels[i]);
    }
  }
}"
72877,"/** 
 * Invoke the solver directly, with a choice as to whether or not this solver should display its resolved concepts.
 * @param displayProperties  True if the solver should display itsproperties; false otherwise (for example, if it is called from another solver)
 * @return True if the invocation succeeds; otherwise false which means anerror has occurred during the process.
 */
public boolean invokeSolver(boolean displayProperties){
  boolean success=false;
  try {
    initialize();
    resolveConcepts();
    checkErrors();
    if (displayProperties) {
      displayConcepts();
    }
  }
 catch (  KernelException e) {
    reset();
    throw new InternalErrorException(e);
  }
  return success;
}","/** 
 * Invoke the solver directly, with a choice as to whether or not this solver should display its resolved concepts.
 * @param displayProperties  True if the solver should display itsproperties; false otherwise (for example, if it is called from another solver)
 * @throws IllegalActionException If there is no ontology.
 */
public void invokeSolver(boolean displayProperties) throws IllegalActionException {
  Ontology ontology=getOntology();
  if (ontology == null) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  initialize();
  resolveConcepts();
  checkErrors();
  if (displayProperties) {
    displayConcepts();
  }
}"
72878,"/** 
 * Execute the OntologySolver's algorithm to resolve which Concepts in the Ontology are assigned to each object in the model.
 * @exception KernelException If the ontology resolution fails.
 */
public abstract void resolveConcepts() throws KernelException ;","/** 
 * Execute the OntologySolver's algorithm to resolve which Concepts in the Ontology are assigned to each object in the model.
 * @exception IllegalActionException If the ontology resolution fails.
 */
public abstract void resolveConcepts() throws IllegalActionException ;"
72879,"/** 
 * Return the package name that contains the class of this solver.
 * @param solver The ontology solver for which we get the adapter package name.
 * @return The package name.
 * @exception IllegalActionException Thrown if there is a problemgetting the ontology package name.
 */
protected static String _getPackageName(OntologySolverBase solver) throws IllegalActionException {
  return solver.getClass().getPackage().getName() + ""String_Node_Str"" + solver.getOntology().getName();
}","/** 
 * Return the package name that contains the class of this solver.
 * @param solver The ontology solver for which we get the adapter package name.
 * @return The package name.
 * @exception IllegalActionException Thrown if there is a problemgetting the ontology package name.
 */
protected static String _getPackageName(OntologySolverBase solver) throws IllegalActionException {
  Ontology ontology=solver.getOntology();
  if (ontology == null) {
    throw new IllegalActionException(solver,""String_Node_Str"");
  }
  return solver.getClass().getPackage().getName() + ""String_Node_Str"" + ontology.getName();
}"
72880,"/** 
 * Called when the gui ""Resolve Concepts"" menu action is clicked. This method calls the OntologySolver's MoML handler to invoke the solver and perform the ontology solver concept resolution.
 * @param e The action event that is passed in when the actionis triggered.
 */
public void actionPerformed(ActionEvent e){
  super.actionPerformed(e);
  NamedObj container=getContainer();
  if (container instanceof OntologySolver) {
    ((OntologySolver)container).invokeSolver();
  }
}","/** 
 * Called when the gui ""Resolve Concepts"" menu action is clicked. This method calls the OntologySolver's MoML handler to invoke the solver and perform the ontology solver concept resolution.
 * @param e The action event that is passed in when the actionis triggered.
 */
public void actionPerformed(ActionEvent e){
  super.actionPerformed(e);
  NamedObj container=getContainer();
  if (container instanceof OntologySolver) {
    try {
      ((OntologySolver)container).invokeSolver();
    }
 catch (    IllegalActionException e1) {
      MessageHandler.error(""String_Node_Str"",e1);
    }
  }
}"
72881,"/** 
 * Create an editor for configuring the specified object with the specified parent window.
 * @param object The object to configure.
 * @param parent The parent window, or null if there is none.
 */
public void createEditor(NamedObj object,Frame parent){
  OntologySolver solver=(OntologySolver)getContainer();
  try {
    workspace().getWriteAccess();
    solver.invokeSolver();
  }
  finally {
    workspace().doneWriting();
  }
}","/** 
 * Create an editor for configuring the specified object with the specified parent window.
 * @param object The object to configure.
 * @param parent The parent window, or null if there is none.
 */
public void createEditor(NamedObj object,Frame parent){
  OntologySolver solver=(OntologySolver)getContainer();
  try {
    workspace().getWriteAccess();
    try {
      solver.invokeSolver();
    }
 catch (    IllegalActionException e1) {
      MessageHandler.error(""String_Node_Str"",e1);
    }
  }
  finally {
    workspace().doneWriting();
  }
}"
72882,"/** 
 * Resolve the concept values for the toplevel entity that contains this solver, given the model analyzer that invokes this.
 * @exception KernelException If there is an exception thrown during the OntologySolverresolution.
 */
public void resolveConcepts() throws KernelException {
  NamedObj toplevel=_toplevel();
  _resolveConcepts(toplevel,_initialConstraintList);
}","/** 
 * Resolve the concept values for the toplevel entity that contains this solver, given the model analyzer that invokes this.
 * @exception IllegalActionException If there is an exception thrown during the OntologySolverresolution.
 */
public void resolveConcepts() throws IllegalActionException {
  NamedObj toplevel=_toplevel();
  _resolveConcepts(toplevel,_initialConstraintList);
}"
72883,"/** 
 * Transfer data from the inside receivers of an output port of the container to the ports it is connected to on the outside. Create a RecordToken if the associated port is a NetworkTransmitterPort.
 * @exception IllegalActionException Not thrown in this base class.
 * @param port The port to transfer tokens from.
 * @return True if at least one data token is transferred.
 * @see IOPort#transferOutputs
 */
public boolean transferOutputs(IOPort port) throws IllegalActionException {
  boolean result=false;
  for (int i=0; i < port.getWidthInside(); i++) {
    try {
      while (port.isKnownInside(i) && port.hasTokenInside(i)) {
        Token t=port.getInside(i);
        if (_isAssociatedWithNetworkTransmitter(port)) {
          MetroIIPtidesDirector director=(MetroIIPtidesDirector)((MetroCompositeActor)((MirrorPort)port).getAssociatedPort().getContainer()).getDirector();
          Object[] timestamps=((MetroIIPtidesPort)((MirrorPort)port).getAssociatedPort()).getTimeStampForToken(t);
          Time timestamp=(Time)timestamps[0];
          Time sourceTimestamp=(Time)timestamps[1];
          Token[] values=new Token[]{new DoubleToken(timestamp.getDoubleValue()),new IntToken(director.getMicrostep()),t,new DoubleToken(sourceTimestamp.getDoubleValue())};
          RecordToken record=new RecordToken(PtidesNetworkType.LABELS,values);
          try {
            ((MirrorPort)port).send(i,record);
          }
 catch (          IllegalActionException ex) {
            throw new IllegalActionException(this,ex.getMessage());
          }
        }
 else {
          ((MirrorPort)port).send(i,t);
        }
      }
      result=true;
    }
 catch (    NoTokenException ex) {
      throw new InternalErrorException(this,ex,null);
    }
  }
  return result;
}","/** 
 * Transfer data from the inside receivers of an output port of the container to the ports it is connected to on the outside. Create a RecordToken if the associated port is a NetworkTransmitterPort.
 * @exception IllegalActionException Not thrown in this base class.
 * @param port The port to transfer tokens from.
 * @return True if at least one data token is transferred.
 * @see IOPort#transferOutputs
 */
public boolean transferOutputs(IOPort port) throws IllegalActionException {
  boolean result=false;
  for (int i=0; i < port.getWidthInside(); i++) {
    try {
      while (port.isKnownInside(i) && port.hasTokenInside(i)) {
        Token t=port.getInside(i);
        if (_isAssociatedWithNetworkTransmitter(port)) {
          MetroIIPtidesDirector director=(MetroIIPtidesDirector)((MetroIICompositeActor)((MirrorPort)port).getAssociatedPort().getContainer()).getDirector();
          Object[] timestamps=((MetroIIPtidesPort)((MirrorPort)port).getAssociatedPort()).getTimeStampForToken(t);
          Time timestamp=(Time)timestamps[0];
          Time sourceTimestamp=(Time)timestamps[1];
          Token[] values=new Token[]{new DoubleToken(timestamp.getDoubleValue()),new IntToken(director.getMicrostep()),t,new DoubleToken(sourceTimestamp.getDoubleValue())};
          RecordToken record=new RecordToken(PtidesNetworkType.LABELS,values);
          try {
            ((MirrorPort)port).send(i,record);
          }
 catch (          IllegalActionException ex) {
            throw new IllegalActionException(this,ex.getMessage());
          }
        }
 else {
          ((MirrorPort)port).send(i,t);
        }
      }
      result=true;
    }
 catch (    NoTokenException ex) {
      throw new InternalErrorException(this,ex,null);
    }
  }
  return result;
}"
72884,"/** 
 * React to a change in an attribute. If the changed attribute matches a parameter of the director, then the corresponding local copy of the parameter value will be updated.
 * @param attribute The changed parameter.
 * @exception IllegalActionException If the parameter set is not valid.
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == mappingFileName) {
    StringToken mappingFileNameToken=(StringToken)mappingFileName.getToken();
    if (mappingFileNameToken == null || mappingFileNameToken.equals(""String_Node_Str"")) {
      mappingFileName=null;
    }
 else {
      File file=mappingFileName.asFile();
      if (file != null) {
        String filename=file.getAbsolutePath();
        if (!filename.equals(""String_Node_Str"")) {
          try {
            System.out.println(filename);
            _mappingConstraintSolver.readMapping(filename);
          }
 catch (          IOException ex) {
            throw new IllegalActionException(this,ex,""String_Node_Str"" + filename + ""String_Node_Str"");
          }
          if (_debugging) {
            _debug(_mappingConstraintSolver.toString());
          }
        }
      }
    }
  }
 else   if (attribute == printDebug) {
    if (((BooleanToken)printDebug.getToken()).booleanValue()) {
      _mappingConstraintSolver.turnOnDebugging();
      _timeScheduler.turnOnDebugging();
      _debugger.turnOnDebugging();
    }
 else {
      _mappingConstraintSolver.turnOffDebugging();
      _timeScheduler.turnOffDebugging();
      _debugger.turnOffDebugging();
    }
  }
 else {
    super.attributeChanged(attribute);
  }
}","/** 
 * React to a change in an attribute. If the changed attribute matches a parameter of the director, then the corresponding local copy of the parameter value will be updated.
 * @param attribute The changed parameter.
 * @exception IllegalActionException If the parameter set is not valid.
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == mappingFileName) {
    StringToken mappingFileNameToken=(StringToken)mappingFileName.getToken();
    if (mappingFileNameToken == null || mappingFileNameToken.stringValue().equals(""String_Node_Str"")) {
      mappingFileName=null;
    }
 else {
      File file=mappingFileName.asFile();
      if (file != null) {
        String filename=file.getAbsolutePath();
        if (!filename.equals(""String_Node_Str"")) {
          try {
            System.out.println(filename);
            _mappingConstraintSolver.readMapping(filename);
          }
 catch (          IOException ex) {
            throw new IllegalActionException(this,ex,""String_Node_Str"" + filename + ""String_Node_Str"");
          }
          if (_debugging) {
            _debug(_mappingConstraintSolver.toString());
          }
        }
      }
    }
  }
 else   if (attribute == printDebug) {
    if (((BooleanToken)printDebug.getToken()).booleanValue()) {
      _mappingConstraintSolver.turnOnDebugging();
      _timeScheduler.turnOnDebugging();
      _debugger.turnOnDebugging();
    }
 else {
      _mappingConstraintSolver.turnOffDebugging();
      _timeScheduler.turnOffDebugging();
      _debugger.turnOffDebugging();
    }
  }
 else {
    super.attributeChanged(attribute);
  }
}"
72885,"/** 
 * OMC which is coupled to Ptolemy II is called to initialize the OMC server and simulate the Modelica model, then exchange data via BSD socket. TODO it should be detailed.
 * @param args Not used.
 * @throws IllegalActionException
 * @throws IOException
 */
public static void main(String[] args) throws IllegalActionException, IOException {
  try {
    _omcProxy.initServer();
  }
 catch (  ConnectException ex) {
    throw new IllegalActionException(""String_Node_Str"");
  }
  try {
    _omcProxy.loadFile(""String_Node_Str"",""String_Node_Str"");
  }
 catch (  ConnectException e) {
    throw new IllegalActionException(""String_Node_Str"");
  }
  try {
    _omcProxy.simulateModel(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",500,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
 catch (  Throwable throwable) {
    throw new IllegalActionException(""String_Node_Str"");
  }
  _utilSocket=UtilSocket.getInstance();
  if (!_utilSocket.establishclientsocket()) {
    try {
      _omcProxy.quitServer();
      System.out.println(""String_Node_Str"");
    }
 catch (    ConnectException ex) {
      throw new IllegalActionException(""String_Node_Str"");
    }
  }
 else {
    _utilSocket.exchangewithsocket();
    _utilSocket.closesocket();
    try {
      _omcProxy.quitServer();
      System.out.println(""String_Node_Str"");
    }
 catch (    ConnectException ex) {
      throw new IllegalActionException(""String_Node_Str"");
    }
  }
}","/** 
 * OMC which is coupled to Ptolemy II is called to initialize the OMC server and simulate the Modelica model, then exchange data via BSD socket. TODO it should be detailed.
 * @param args Not used.
 * @throws IllegalActionException
 * @throws IOException
 */
public static void main(String[] args) throws IllegalActionException, IOException {
  try {
    _omcProxy.initServer();
  }
 catch (  ConnectException ex) {
    throw new IllegalActionException(""String_Node_Str"");
  }
  try {
    _omcProxy.loadFile(""String_Node_Str"",""String_Node_Str"");
  }
 catch (  ConnectException e) {
    throw new IllegalActionException(""String_Node_Str"");
  }
  try {
    _omcProxy.simulateModel(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",500,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
 catch (  Throwable throwable) {
    throw new IllegalActionException(null,throwable,""String_Node_Str"");
  }
  _utilSocket=UtilSocket.getInstance();
  if (!_utilSocket.establishclientsocket()) {
    try {
      _omcProxy.quitServer();
      System.out.println(""String_Node_Str"");
    }
 catch (    ConnectException ex) {
      throw new IllegalActionException(null,ex,""String_Node_Str"");
    }
  }
 else {
    try {
      _utilSocket.exchangewithsocket();
    }
 catch (    Throwable throwable) {
      throw new IllegalActionException(null,throwable,""String_Node_Str"");
    }
    _utilSocket.closesocket();
    try {
      _omcProxy.quitServer();
      System.out.println(""String_Node_Str"");
    }
 catch (    ConnectException ex) {
      throw new IllegalActionException(null,ex,""String_Node_Str"");
    }
  }
}"
72886,"/** 
 * Construct an actor in the specified container with the specified name.
 * @param container The container.
 * @param name The name of this adder within the container.
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the name coincides withan actor already in the container.
 */
public AddSubtract(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  plus=new TypedIOPort(this,""String_Node_Str"",true,false);
  plus.setMultiport(true);
  minus=new TypedIOPort(this,""String_Node_Str"",true,false);
  minus.setMultiport(true);
  output=new TypedIOPort(this,""String_Node_Str"",false,true);
  output.setTypeAtLeast(plus);
  output.setTypeAtLeast(minus);
  plus.setTypeSameAs(minus);
  _attachText(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}","/** 
 * Construct an actor in the specified container with the specified name.
 * @param container The container.
 * @param name The name of this adder within the container.
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the name coincides withan actor already in the container.
 */
public AddSubtract(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  plus=new TypedIOPort(this,""String_Node_Str"",true,false);
  plus.setMultiport(true);
  plus.setDynamic(true);
  minus=new TypedIOPort(this,""String_Node_Str"",true,false);
  minus.setMultiport(true);
  minus.setDynamic(true);
  output=new TypedIOPort(this,""String_Node_Str"",false,true);
  output.setTypeAtLeast(plus);
  output.setTypeAtLeast(minus);
  plus.setTypeSameAs(minus);
  _attachText(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}"
72887,"/** 
 * Return a new token whose value is the value of the argument token subtracted from the value of this token.   Type conversion also occurs here, so that the operation is performed at the least type necessary to ensure precision.  The returned type is the same as the type chosen for the operation.  Generally, this is higher of the type of this token and the argument type.  Subclasses should not override this method, but override the protected _subtract() method to ensure that type conversion is performed consistently.
 * @param rightArgument The token to subtract from this token.
 * @return A new token containing the result.
 * @exception IllegalActionException If the argument token andthis token are of incomparable types, or the operation does not make sense for the given types.
 */
public final Token subtract(Token rightArgument) throws IllegalActionException {
  int typeInfo=TypeLattice.compare(getType(),rightArgument);
  if (typeInfo == CPO.SAME) {
    Token result=_subtract(rightArgument);
    return result;
  }
 else   if (typeInfo == CPO.HIGHER) {
    AbstractConvertibleToken convertedArgument=(AbstractConvertibleToken)getType().convert(rightArgument);
    try {
      Token result=_subtract(convertedArgument);
      return result;
    }
 catch (    IllegalActionException ex) {
      throw new IllegalActionException(null,ex,notSupportedMessage(""String_Node_Str"",this,rightArgument));
    }
  }
 else   if (typeInfo == CPO.LOWER) {
    Token result=rightArgument.subtractReverse(this);
    return result;
  }
 else {
    throw new IllegalActionException(notSupportedIncomparableMessage(""String_Node_Str"",this,rightArgument));
  }
}","/** 
 * Return a new token whose value is the value of the argument token subtracted from the value of this token.   Type conversion also occurs here, so that the operation is performed at the least type necessary to ensure precision.  The returned type is the same as the type chosen for the operation.  Generally, this is higher of the type of this token and the argument type.  Subclasses should not override this method, but override the protected _subtract() method to ensure that type conversion is performed consistently.
 * @param rightArgument The token to subtract from this token.
 * @return A new token containing the result.
 * @exception IllegalActionException If the argument token andthis token are of incomparable types, or the operation does not make sense for the given types.
 */
public final Token subtract(Token rightArgument) throws IllegalActionException {
  int typeInfo=TypeLattice.compare(getType(),rightArgument);
  if (typeInfo == CPO.SAME) {
    Token result=_subtract(rightArgument);
    return result;
  }
 else   if (typeInfo == CPO.HIGHER) {
    AbstractConvertibleToken convertedArgument=(AbstractConvertibleToken)getType().convert(rightArgument);
    Token result=_subtract(convertedArgument);
    return result;
  }
 else   if (typeInfo == CPO.LOWER) {
    Token result=rightArgument.subtractReverse(this);
    return result;
  }
 else {
    throw new IllegalActionException(notSupportedIncomparableMessage(""String_Node_Str"",this,rightArgument));
  }
}"
72888,"/** 
 * Return the list of quantity managers in this port. A quantity manager is a   {@link Parameter} whose value is an{@link ObjectToken} that references an object that implementsthe  {@link QuantityManager} interface.
 * @return The list of quantity managers.
 * @exception IllegalActionException Thrown if the token of the parametercontaining the quantity manager object cannot be retrieved.
 */
public List<QuantityManager> getQuantityManagers() throws IllegalActionException {
  _qmList=new ArrayList<QuantityManager>();
  List<ResourceAttributes> list=this.attributeList(ResourceAttributes.class);
  for (  ResourceAttributes attribute : list) {
    if (attribute.enabled()) {
      if ((QuantityManager)attribute.getDecorator() != null) {
        _qmList.add((QuantityManager)attribute.getDecorator());
        attribute.validateSettables();
      }
    }
  }
  _qmListValid=true;
  return _qmList;
}","/** 
 * Return the list of quantity managers in this port. A quantity manager is a   {@link Parameter} whose value is an{@link ObjectToken} that references an object that implementsthe  {@link QuantityManager} interface.
 * @return The list of quantity managers.
 * @exception IllegalActionException Thrown if the token of the parametercontaining the quantity manager object cannot be retrieved.
 */
public List<QuantityManager> getQuantityManagers() throws IllegalActionException {
  if (_qmList == null) {
    _qmList=new ArrayList<QuantityManager>();
  }
  List<ResourceAttributes> list=this.attributeList(ResourceAttributes.class);
  for (  ResourceAttributes attribute : list) {
    QuantityManager qm=(QuantityManager)attribute.getDecorator();
    if (qm != null) {
      if (attribute.enabled()) {
        if (!_qmList.contains(qm)) {
          _qmList.add(qm);
          attribute.validateSettables();
        }
      }
 else {
        _qmList.remove(qm);
      }
    }
  }
  _qmListValid=true;
  return _qmList;
}"
72889,"/** 
 * If a quantity manager is added, removed or modified, invalidate the list of quantity managers which is read again in the preinitialize phase.
 * @param attribute The attribute that changed.
 * @exception IllegalActionException Thrown if the new color attribute cannotbe created.
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute instanceof Parameter) {
    Token parameterToken=((Parameter)attribute).getToken();
    if (parameterToken != null) {
      if (parameterToken instanceof ObjectToken && ((ObjectToken)parameterToken).getValue() instanceof QuantityManager) {
        _qmListValid=false;
      }
    }
  }
  super.attributeChanged(attribute);
}","/** 
 * If a quantity manager is added, removed or modified, invalidate the list of quantity managers which is read again in the preinitialize phase.
 * @param attribute The attribute that changed.
 * @exception IllegalActionException Thrown if the new color attribute cannotbe created.
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute instanceof ResourceAttributes) {
    Decorator decorator=((ResourceAttributes)attribute).getDecorator();
    if (decorator != null && decorator instanceof QuantityManager) {
      _qmListValid=false;
      createReceivers();
    }
  }
  super.attributeChanged(attribute);
}"
72890,"/** 
 * Constructor to use when parsing a MoML file.
 * @param target The object being decorated.
 * @param name The name of this attribute.
 * @throws IllegalActionException If the superclass throws it.
 * @throws NameDuplicationException If the superclass throws it.
 */
public QMAttributes(NamedObj target,String name) throws IllegalActionException, NameDuplicationException {
  super(target,name);
  _init();
}","/** 
 * Constructor to use when parsing a MoML file.
 * @param target The object being decorated.
 * @param name The name of this attribute.
 * @throws IllegalActionException If the superclass throws it.
 * @throws NameDuplicationException If the superclass throws it.
 */
public QMAttributes(NamedObj target,String name) throws IllegalActionException, NameDuplicationException {
  super(target,name);
}"
72891,"/** 
 * If attribute is <i>messageLength</i> report the new value  to the quantity manager. 
 * @param attribute The changed parameter.
 * @exception IllegalActionException If the parameter set is not valid.Not thrown in this class.
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == messageLength) {
    IOPort port=(IOPort)getContainer();
    Bus bus=(Bus)getDecorator();
    if (bus != null) {
      Token token=messageLength.getToken();
      if (token != null) {
        bus.setMessageLength(port,((ScalarToken)token).doubleValue());
      }
    }
  }
 else {
    super.attributeChanged(attribute);
  }
}","/** 
 * If attribute is <i>messageLength</i> report the new value  to the quantity manager. 
 * @param attribute The changed parameter.
 * @exception IllegalActionException If the parameter set is not valid.Not thrown in this class.
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == messageLength) {
    if (enabled()) {
      IOPort port=(IOPort)getContainer();
      Bus bus=(Bus)getDecorator();
      if (bus != null) {
        Token token=messageLength.getToken();
        if (token != null) {
          bus.setMessageLength(port,((ScalarToken)token).doubleValue());
        }
      }
    }
  }
 else {
    super.attributeChanged(attribute);
  }
}"
72892,"/** 
 * React to a change in the input port attribute.
 * @param attribute The attribute that changed.
 * @exception IllegalActionException If the change is not acceptableto this container (not thrown in this base class).
 */
@Override public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == inputPort) {
    _inputPort=((StringToken)((Parameter)attribute).getToken()).stringValue();
    IOPort port=(IOPort)getContainer();
    CompositeQuantityManager compositeQM=(CompositeQuantityManager)getDecorator();
    if (compositeQM != null) {
      compositeQM.setInputPortName(port,_inputPort);
    }
  }
 else {
    super.attributeChanged(attribute);
  }
}","/** 
 * React to a change in the input port attribute.
 * @param attribute The attribute that changed.
 * @exception IllegalActionException If the change is not acceptableto this container (not thrown in this base class).
 */
@Override public void attributeChanged(Attribute attribute) throws IllegalActionException {
  IOPort port=(IOPort)getContainer();
  if (attribute == enable) {
    port.createReceivers();
  }
  if (attribute == inputPort) {
    _inputPort=((StringToken)((Parameter)attribute).getToken()).stringValue();
    CompositeQuantityManager compositeQM=(CompositeQuantityManager)getDecorator();
    if (compositeQM != null) {
      compositeQM.setInputPortName(port,_inputPort);
    }
  }
 else {
    super.attributeChanged(attribute);
  }
}"
72893,"public int getMicrostepForToken(Token t){
  Integer microstep=_transmittedTokenMicrosteps.get(t);
  if (_transmittedTokenCnt.get(t) != null) {
    _transmittedTokenCnt.put(t,_transmittedTokenCnt.get(t).intValue() - 1);
    if (_transmittedTokenCnt.get(t).intValue() == 0) {
      _transmittedTokenMicrosteps.remove(t);
      _transmittedTokenCnt.remove(t);
    }
    return microstep;
  }
 else {
    return 1;
  }
}","/** 
 * Get the microstep of the event that contained the token.
 * @param t The token.
 * @return The microstep.
 */
public int getMicrostepForToken(Token t){
  Integer microstep=_transmittedTokenMicrosteps.get(t);
  _transmittedTokenMicrosteps.remove(t);
  return microstep;
}"
72894,"/** 
 * Rename the variables, if any, in the dependentVariable that refer to the specified variableToRename.
 * @param node The root node of the parse tree.
 * @param dependentVariable The dependent variable.
 * @param variableToRename The variable to rename.
 * @param name The new name.
 */
public void renameVariables(ASTPtRootNode node,Variable dependentVariable,Variable variableToRename,String name) throws IllegalActionException {
  _scope=dependentVariable.getParserScope();
  _dependentVariable=dependentVariable;
  _variableToRename=variableToRename;
  _name=name;
  node.visit(this);
  _scope=null;
  _variableToRename=null;
  _name=null;
}","/** 
 * Rename the variables, if any, in the dependentVariable that refer to the specified variableToRename.
 * @param node The root node of the parse tree.
 * @param dependentVariable The dependent variable.
 * @param variableToRename The variable to rename.
 * @param name The new name.
 */
public void renameVariables(ASTPtRootNode node,Variable dependentVariable,Variable variableToRename,String name) throws IllegalActionException {
  _scope=dependentVariable.getParserScope();
  _dependentVariable=dependentVariable;
  _variableToRename=variableToRename;
  if (_dependentVariable.isStringMode()) {
    _name=""String_Node_Str"" + name;
  }
 else {
    _name=name;
  }
  node.visit(this);
  _scope=null;
  _variableToRename=null;
  _name=null;
}"
72895,"public void visitSumNode(ASTPtSumNode node) throws IllegalActionException {
  _writer.print(""String_Node_Str"");
  _printChildrenSeparated(node,node.getLexicalTokenList());
  _writer.print(""String_Node_Str"");
}","public void visitSumNode(ASTPtSumNode node) throws IllegalActionException {
  if (!_isStringMode) {
    _writer.print(""String_Node_Str"");
  }
  _printChildrenSeparated(node,node.getLexicalTokenList());
  if (!_isStringMode) {
    _writer.print(""String_Node_Str"");
  }
}"
72896,"public void visitLeafNode(ASTPtLeafNode node) throws IllegalActionException {
  if (node.isConstant() && node.isEvaluated()) {
    _writer.print(node.getToken().toString());
  }
 else {
    _writer.print(node.getName());
  }
}","public void visitLeafNode(ASTPtLeafNode node) throws IllegalActionException {
  if (node.isConstant() && node.isEvaluated()) {
    ptolemy.data.Token token=node.getToken();
    if (_isStringMode && (token instanceof StringToken)) {
      _writer.print(((StringToken)token).stringValue());
    }
 else {
      _writer.print(token.toString());
    }
  }
 else {
    _writer.print(node.getName());
  }
}"
72897,"/** 
 * Override the base class to throw an exception if renaming this variable results in an error evaluating some variable that depends on it. In this case, the name remains unchanged.
 * @exception IllegalActionException If the name contains a periodor if this variable is referenced in some other expression.
 * @exception NameDuplicationException If there is already anattribute with the same name in the container.
 */
public void setName(String name) throws IllegalActionException, NameDuplicationException {
  String previousName=getName();
  LinkedList<ValueListener> changed=new LinkedList<ValueListener>();
  if (previousName != null && !previousName.equals(name)) {
    try {
      if (_valueListeners != null) {
        Iterator listeners=_valueListeners.iterator();
        while (listeners.hasNext()) {
          ValueListener listener=(ValueListener)listeners.next();
          if (listener instanceof Variable) {
            ParseTreeFreeVariableRenamer renamer=new ParseTreeFreeVariableRenamer();
            ((Variable)listener)._parseIfNecessary();
            renamer.renameVariables(((Variable)listener)._parseTree,(Variable)listener,this,name);
            ParseTreeWriter writer=new ParseTreeWriter();
            ((Variable)listener).setExpression(writer.parseTreeToExpression(((Variable)listener)._parseTree));
            changed.add(listener);
          }
        }
      }
      super.setName(name);
      _invalidateShadowedSettables(getContainer());
      validate();
    }
 catch (    IllegalActionException ex) {
      super.setName(previousName);
      Iterator listeners=changed.iterator();
      while (listeners.hasNext()) {
        Variable listener=(Variable)listeners.next();
        ParseTreeFreeVariableRenamer renamer=new ParseTreeFreeVariableRenamer();
        renamer.renameVariables(listener._parseTree,listener,this,previousName);
        ParseTreeWriter writer=new ParseTreeWriter();
        listener.setExpression(writer.parseTreeToExpression(listener._parseTree));
      }
      validate();
      throw ex;
    }
  }
 else {
    super.setName(name);
  }
}","/** 
 * Override the base class to throw an exception if renaming this variable results in an error evaluating some variable that depends on it. In this case, the name remains unchanged.
 * @exception IllegalActionException If the name contains a periodor if this variable is referenced in some other expression.
 * @exception NameDuplicationException If there is already anattribute with the same name in the container.
 */
public void setName(String name) throws IllegalActionException, NameDuplicationException {
  String previousName=getName();
  LinkedList<ValueListener> changed=new LinkedList<ValueListener>();
  if (previousName != null && !previousName.equals(name)) {
    try {
      if (_valueListeners != null) {
        Iterator listeners=_valueListeners.iterator();
        while (listeners.hasNext()) {
          ValueListener listener=(ValueListener)listeners.next();
          if (listener instanceof Variable) {
            ParseTreeFreeVariableRenamer renamer=new ParseTreeFreeVariableRenamer();
            ((Variable)listener)._parseIfNecessary();
            renamer.renameVariables(((Variable)listener)._parseTree,(Variable)listener,this,name);
            ParseTreeWriter writer=new ParseTreeWriter();
            writer.setStringMode(((Variable)listener).isStringMode());
            ((Variable)listener).setExpression(writer.parseTreeToExpression(((Variable)listener)._parseTree));
            changed.add(listener);
          }
        }
      }
      super.setName(name);
      _invalidateShadowedSettables(getContainer());
      validate();
    }
 catch (    IllegalActionException ex) {
      super.setName(previousName);
      Iterator listeners=changed.iterator();
      while (listeners.hasNext()) {
        Variable listener=(Variable)listeners.next();
        ParseTreeFreeVariableRenamer renamer=new ParseTreeFreeVariableRenamer();
        renamer.renameVariables(listener._parseTree,listener,this,previousName);
        ParseTreeWriter writer=new ParseTreeWriter();
        listener.setExpression(writer.parseTreeToExpression(listener._parseTree));
      }
      validate();
      throw ex;
    }
  }
 else {
    super.setName(name);
  }
}"
72898,"/** 
 * Check whether the widths constraints are met.
 * @exception IllegalActionException If the width constraints or not met.
 */
public void checkWidthConstraints() throws IllegalActionException {
  int width=_getOutsideWidth(null);
  for (  Parameter parameter : _widthEqualToParameter) {
    IntToken t=(IntToken)parameter.getToken();
    if (t != null) {
      if (width != t.intValue()) {
        throw new IllegalActionException(this,""String_Node_Str"" + width + ""String_Node_Str""+ getFullName()+ ""String_Node_Str""+ parameter+ ""String_Node_Str""+ parameter.getContainer()+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      }
    }
  }
  for (  IOPort port : _widthEqualToPort) {
    int otherWidth=port._getOutsideWidth(null);
    if (width != otherWidth) {
      throw new IllegalActionException(this,""String_Node_Str"" + width + ""String_Node_Str""+ getFullName()+ ""String_Node_Str""+ otherWidth+ ""String_Node_Str""+ port.getFullName()+ ""String_Node_Str""+ ""String_Node_Str"");
    }
  }
}","/** 
 * Check whether the widths constraints are met.
 * @exception IllegalActionException If the width constraints or not met.
 */
public void checkWidthConstraints() throws IllegalActionException {
  int width=_getOutsideWidth(null);
  for (  Parameter parameter : _widthEqualToParameter) {
    IntToken t=(IntToken)parameter.getToken();
    if (t != null) {
      if (width != t.intValue()) {
        throw new IllegalActionException(this,""String_Node_Str"" + width + ""String_Node_Str""+ getFullName()+ ""String_Node_Str""+ parameter+ ""String_Node_Str""+ parameter.getContainer()+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      }
    }
  }
  for (  IOPort port : _widthEqualToPort) {
    int otherWidth=port._getOutsideWidth(null);
    if (width != otherWidth) {
      throw new IllegalActionException(this,""String_Node_Str"" + width + ""String_Node_Str""+ getFullName()+ ""String_Node_Str""+ otherWidth+ ""String_Node_Str""+ port.getFullName()+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    }
  }
}"
72899,"/** 
 * Get the next actor that can be fired from a specified event queue. Check whether the event is safe to process, the actors prefire returns true and the event can be scheduled. Because Ptides does not store tokens in receivers but keeps them in the event until the actor is really fired, we have to temporarily put tokens into receivers and then remove them in order for the prefire to give correct results.
 * @param queue The event queue.
 * @return The next actor to fire or null.
 * @exception IllegalActionException Thrown by safeToProcess, prefireor schedule.
 */
private Actor _getNextActorFrom(DEEventQueue queue) throws IllegalActionException {
  Object[] eventArray=queue.toArray();
  for (  Object event : eventArray) {
    if (_isSafeToProcess((PtidesEvent)event)) {
      PtidesEvent ptidesEvent=(PtidesEvent)event;
      Actor actor=ptidesEvent.actor();
      Time timestamp=ptidesEvent.timeStamp();
      if (queue == _pureEvents) {
        for (        Object triggeredEventObject : _eventQueue.toArray()) {
          PtidesEvent triggeredEvent=(PtidesEvent)triggeredEventObject;
          if (triggeredEvent.actor() == actor && triggeredEvent.timeStamp().compareTo(timestamp) < 0) {
            ptidesEvent=triggeredEvent;
          }
        }
      }
      actor=ptidesEvent.actor();
      timestamp=ptidesEvent.timeStamp();
      List<PtidesEvent> sameTagEvents=new ArrayList<PtidesEvent>();
      int i=0;
      while (i < queue.size()) {
        PtidesEvent eventInQueue=((PtidesListEventQueue)queue).get(i);
        if (eventInQueue.hasTheSameTagAs(ptidesEvent) && eventInQueue.actor().equals(actor)) {
          sameTagEvents.add(eventInQueue);
          if (eventInQueue.receiver() != null) {
            if (eventInQueue.receiver() instanceof PtidesReceiver) {
              ((PtidesReceiver)eventInQueue.receiver()).putToReceiver(eventInQueue.token());
            }
          }
        }
        i++;
      }
      _currentLogicalTime=timestamp;
      _currentLogicalIndex=ptidesEvent.microstep();
      _currentSourceTimestamp=ptidesEvent.sourceTimestamp();
      boolean prefire=actor.prefire();
      _currentLogicalTime=null;
      for (      PtidesEvent sameTagEvent : sameTagEvents) {
        if (sameTagEvent.receiver() != null) {
          if (sameTagEvent.receiver() instanceof PtidesReceiver) {
            ((PtidesReceiver)sameTagEvent.receiver()).remove(sameTagEvent.token());
          }
        }
      }
      if (prefire && (!_resourceScheduling || ((queue != _pureEvents && actor instanceof TimeDelay) || _actorsFinished.contains(actor) || _schedule(actor,timestamp)) && (!(actor instanceof CompositeActor) || ((CompositeActor)actor).getDirector().scheduleContainedActors()))) {
        _currentLogicalTime=timestamp;
        _currentLogicalIndex=ptidesEvent.microstep();
        _currentSourceTimestamp=ptidesEvent.sourceTimestamp();
        _removeEventsFromQueue(_eventQueue,ptidesEvent);
        _removeEventsFromQueue(_pureEvents,ptidesEvent);
        _actorsFinished.remove(actor);
        if (_debugging) {
          _debug(""String_Node_Str"" + actor + ""String_Node_Str""+ timestamp);
        }
        return actor;
      }
    }
  }
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  return null;
}","/** 
 * Get the next actor that can be fired from a specified event queue. Check whether the event is safe to process, the actors prefire returns true and the event can be scheduled. Because Ptides does not store tokens in receivers but keeps them in the event until the actor is really fired, we have to temporarily put tokens into receivers and then remove them in order for the prefire to give correct results.
 * @param queue The event queue.
 * @return The next actor to fire or null.
 * @exception IllegalActionException Thrown by safeToProcess, prefireor schedule.
 */
private Actor _getNextActorFrom(DEEventQueue queue) throws IllegalActionException {
  Object[] eventArray=queue.toArray();
  for (  Object event : eventArray) {
    if (_isSafeToProcess((PtidesEvent)event)) {
      PtidesEvent ptidesEvent=(PtidesEvent)event;
      Actor actor=ptidesEvent.actor();
      Time timestamp=ptidesEvent.timeStamp();
      if (queue == _pureEvents) {
        for (        Object triggeredEventObject : _eventQueue.toArray()) {
          PtidesEvent triggeredEvent=(PtidesEvent)triggeredEventObject;
          if (triggeredEvent.actor() == actor && triggeredEvent.timeStamp().compareTo(timestamp) < 0) {
            ptidesEvent=triggeredEvent;
          }
        }
      }
      actor=ptidesEvent.actor();
      timestamp=ptidesEvent.timeStamp();
      List<PtidesEvent> sameTagEvents=new ArrayList<PtidesEvent>();
      int i=0;
      while (i < queue.size()) {
        PtidesEvent eventInQueue=((PtidesListEventQueue)queue).get(i);
        if (eventInQueue.hasTheSameTagAs(ptidesEvent) && eventInQueue.actor().equals(actor)) {
          sameTagEvents.add(eventInQueue);
          if (eventInQueue.receiver() != null) {
            if (eventInQueue.receiver() instanceof PtidesReceiver) {
              ((PtidesReceiver)eventInQueue.receiver()).putToReceiver(eventInQueue.token());
            }
          }
        }
        i++;
      }
      _currentLogicalTime=timestamp;
      _currentLogicalIndex=ptidesEvent.microstep();
      _currentSourceTimestamp=ptidesEvent.sourceTimestamp();
      boolean prefire=actor.prefire();
      _currentLogicalTime=null;
      for (      PtidesEvent sameTagEvent : sameTagEvents) {
        if (sameTagEvent.receiver() != null) {
          if (sameTagEvent.receiver() instanceof PtidesReceiver) {
            ((PtidesReceiver)sameTagEvent.receiver()).remove(sameTagEvent.token());
          }
        }
      }
      if (prefire && (!_resourceScheduling || ((actor instanceof TimeDelay && !ptidesEvent.isPureEvent()) || _actorsFinished.contains(actor) || _schedule(actor,timestamp)) && (!(actor instanceof CompositeActor) || ((CompositeActor)actor).getDirector().scheduleContainedActors()))) {
        _currentLogicalTime=timestamp;
        _currentLogicalIndex=ptidesEvent.microstep();
        _currentSourceTimestamp=ptidesEvent.sourceTimestamp();
        _removeEventsFromQueue(_eventQueue,ptidesEvent);
        _removeEventsFromQueue(_pureEvents,ptidesEvent);
        _actorsFinished.remove(actor);
        if (_debugging) {
          _debug(""String_Node_Str"" + actor + ""String_Node_Str""+ timestamp);
        }
        return actor;
      }
    }
  }
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  return null;
}"
72900,"/** 
 * Generate the preinitialize code. We do not call the super method, because we have arguments to add here This code contains the different constructions and initializations.
 * @return The generated preinitialize Method code.
 * @exception IllegalActionException If thrown while appending to thethe block or processing the macros.
 */
@Override public String generatePreinitializeMethodBodyCode() throws IllegalActionException {
  CodeStream codeStream=_templateParser.getCodeStream();
  codeStream.clear();
  LinkedList args=new LinkedList();
  ptolemy.actor.CompositeActor TopActor=(ptolemy.actor.CompositeActor)getComponent();
  String sanitizedContainerName=CodeGeneratorAdapter.generateName(TopActor);
  if ((ptolemy.actor.CompositeActor)getComponent().getContainer() == null) {
    codeStream.append(_eol + sanitizedContainerName + ""String_Node_Str"");
    codeStream.append(_eol + sanitizedContainerName + ""String_Node_Str"");
    codeStream.append(_eol + sanitizedContainerName + ""String_Node_Str""+ _eol);
  }
  args.clear();
  args.add(sanitizedContainerName + ""String_Node_Str"");
  codeStream.appendCodeBlock(""String_Node_Str"",args);
  return processCode(codeStream.toString());
}","/** 
 * Generate the preinitialize code. We do not call the super method, because we have arguments to add here This code contains the different constructions and initializations.
 * @return The generated preinitialize Method code.
 * @exception IllegalActionException If thrown while appending to thethe block or processing the macros.
 */
@Override public String generatePreinitializeMethodBodyCode() throws IllegalActionException {
  CodeStream codeStream=_templateParser.getCodeStream();
  codeStream.clear();
  LinkedList args=new LinkedList();
  ptolemy.actor.CompositeActor TopActor=(ptolemy.actor.CompositeActor)getComponent();
  String sanitizedContainerName=CodeGeneratorAdapter.generateName(TopActor);
  if (TopActor.getContainer() == null || TopActor instanceof ptolemy.cg.lib.CompiledCompositeActor) {
    codeStream.append(_eol + sanitizedContainerName + ""String_Node_Str"");
    codeStream.append(_eol + sanitizedContainerName + ""String_Node_Str"");
    codeStream.append(_eol + sanitizedContainerName + ""String_Node_Str""+ _eol);
  }
  args.clear();
  args.add(sanitizedContainerName + ""String_Node_Str"");
  codeStream.appendCodeBlock(""String_Node_Str"",args);
  return processCode(codeStream.toString());
}"
72901,"public String generateInitializeCode() throws IllegalActionException {
  CodeStream codeStream=_templateParser.getCodeStream();
  codeStream.clear();
  LinkedList args=new LinkedList();
  Parameter stopTime=((ptolemy.actor.lib.PoissonClock)getComponent()).stopTime;
  double doubleStopTime=((DoubleToken)stopTime.getToken()).doubleValue();
  ptolemy.actor.lib.PoissonClock actor=(ptolemy.actor.lib.PoissonClock)getComponent();
  ptolemy.actor.CompositeActor container=(ptolemy.actor.CompositeActor)actor.getContainer();
  ptolemy.actor.Director director=container.getDirector();
  double modelStopTime=director.getModelStopTime().getDoubleValue();
  if (doubleStopTime > modelStopTime)   doubleStopTime=modelStopTime;
  Parameter meanTime=((ptolemy.actor.lib.PoissonClock)getComponent()).meanTime;
  double doubleMeanTime=((DoubleToken)meanTime.getToken()).doubleValue();
  Parameter fireAtStart=((ptolemy.actor.lib.PoissonClock)getComponent()).fireAtStart;
  boolean boolFireAtStart=((BooleanToken)fireAtStart.getToken()).booleanValue();
  args.add(Double.toString(doubleStopTime));
  args.add(Double.toString(doubleMeanTime));
  args.add(Boolean.toString(boolFireAtStart));
  Parameter valuesPar=((ptolemy.actor.lib.PoissonClock)getComponent()).values;
  Token valuesToken=valuesPar.getToken();
  Token[] values;
  double[] valuesDouble=null;
  int[] valuesInt=null;
  int size=0;
  if (valuesToken instanceof ArrayToken) {
    values=((ArrayToken)valuesToken).arrayValue();
    size=values.length;
    args.add(Integer.toString(size));
    int i=0;
    if (size > 0) {
      if (values[0] instanceof DoubleToken) {
        valuesDouble=new double[size];
      }
 else       if (values[0] instanceof IntToken) {
        valuesInt=new int[size];
      }
 else {
        throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
      }
    }
    for (    Token t : values) {
      if (t instanceof DoubleToken) {
        valuesDouble[i++]=((DoubleToken)t).doubleValue();
      }
 else       if (t instanceof IntToken) {
        valuesInt[i++]=((IntToken)t).intValue();
      }
 else {
        throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
      }
    }
  }
 else {
    throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
  }
  StringBuffer valuesString=new StringBuffer();
  int i=0;
  if (valuesDouble != null)   for (  double value : valuesDouble)   valuesString.append(""String_Node_Str"" + i++ + ""String_Node_Str""+ Double.toString(value)+ ""String_Node_Str"");
 else   if (valuesInt != null)   for (  int value : valuesInt)   valuesString.append(""String_Node_Str"" + i++ + ""String_Node_Str""+ Integer.toString(value)+ ""String_Node_Str"");
  args.add(valuesString);
  long longPrivateSeed=0;
  Parameter privateSeed=((ptolemy.actor.lib.PoissonClock)getComponent()).privateSeed;
  if (privateSeed.getToken() instanceof LongToken)   longPrivateSeed=((LongToken)privateSeed.getToken()).longValue();
  args.add(Long.toString(longPrivateSeed));
  long longSeed=0;
  Parameter seed=((ptolemy.actor.lib.PoissonClock)getComponent()).seed;
  if (seed.getToken() instanceof LongToken)   longSeed=((LongToken)seed.getToken()).longValue() + ((ptolemy.actor.lib.PoissonClock)getComponent()).getFullName().hashCode();
  args.add(Long.toString(longSeed));
  codeStream.appendCodeBlock(""String_Node_Str"",args);
  return processCode(codeStream.toString());
}","public String generateInitializeCode() throws IllegalActionException {
  CodeStream codeStream=_templateParser.getCodeStream();
  codeStream.clear();
  LinkedList args=new LinkedList();
  Parameter stopTime=((ptolemy.actor.lib.PoissonClock)getComponent()).stopTime;
  double doubleStopTime=((DoubleToken)stopTime.getToken()).doubleValue();
  ptolemy.actor.lib.PoissonClock actor=(ptolemy.actor.lib.PoissonClock)getComponent();
  ptolemy.actor.CompositeActor container=(ptolemy.actor.CompositeActor)actor.getContainer();
  ptolemy.actor.Director director=container.getDirector();
  double modelStopTime=director.getModelStopTime().getDoubleValue();
  if (doubleStopTime > modelStopTime)   doubleStopTime=modelStopTime;
  Parameter meanTime=((ptolemy.actor.lib.PoissonClock)getComponent()).meanTime;
  double doubleMeanTime=((DoubleToken)meanTime.getToken()).doubleValue();
  Parameter fireAtStart=((ptolemy.actor.lib.PoissonClock)getComponent()).fireAtStart;
  boolean boolFireAtStart=((BooleanToken)fireAtStart.getToken()).booleanValue();
  args.add(Double.toString(doubleStopTime));
  args.add(Double.toString(doubleMeanTime));
  args.add(Boolean.toString(boolFireAtStart));
  Parameter valuesPar=((ptolemy.actor.lib.PoissonClock)getComponent()).values;
  Token valuesToken=valuesPar.getToken();
  Token[] values;
  double[] valuesDouble=null;
  int[] valuesInt=null;
  int size=0;
  if (valuesToken instanceof ArrayToken) {
    values=((ArrayToken)valuesToken).arrayValue();
    size=values.length;
    args.add(Integer.toString(size));
    int i=0;
    if (size > 0) {
      if (values[0] instanceof DoubleToken) {
        valuesDouble=new double[size];
      }
 else       if (values[0] instanceof IntToken) {
        valuesInt=new int[size];
      }
 else {
        throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
      }
    }
    for (    Token t : values) {
      if (t instanceof DoubleToken) {
        valuesDouble[i++]=((DoubleToken)t).doubleValue();
      }
 else       if (t instanceof IntToken) {
        valuesInt[i++]=((IntToken)t).intValue();
      }
 else {
        throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
      }
    }
  }
 else {
    throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
  }
  StringBuffer valuesString=new StringBuffer();
  int i=0;
  if (valuesDouble != null)   for (  double value : valuesDouble)   valuesString.append(""String_Node_Str"" + i++ + ""String_Node_Str""+ Double.toString(value)+ ""String_Node_Str"");
 else   if (valuesInt != null)   for (  int value : valuesInt)   valuesString.append(""String_Node_Str"" + i++ + ""String_Node_Str""+ Integer.toString(value)+ ""String_Node_Str"");
  args.add(valuesString.toString());
  long longPrivateSeed=0;
  Parameter privateSeed=((ptolemy.actor.lib.PoissonClock)getComponent()).privateSeed;
  if (privateSeed.getToken() instanceof LongToken)   longPrivateSeed=((LongToken)privateSeed.getToken()).longValue();
  args.add(Long.toString(longPrivateSeed));
  long longSeed=0;
  Parameter seed=((ptolemy.actor.lib.PoissonClock)getComponent()).seed;
  if (seed.getToken() instanceof LongToken)   longSeed=((LongToken)seed.getToken()).longValue() + ((ptolemy.actor.lib.PoissonClock)getComponent()).getFullName().hashCode();
  args.add(Long.toString(longSeed));
  codeStream.appendCodeBlock(""String_Node_Str"",args);
  return processCode(codeStream.toString());
}"
72902,"/** 
 * Generate code for transferring enough tokens to fulfill the output production rate.
 * @param outputPort The port to transfer tokens.
 * @param code The string buffer that the generated code is appended to.
 * @exception IllegalActionException If thrown while transferring tokens.
 */
public void generateTransferOutputsCode(IOPort outputPort,StringBuffer code) throws IllegalActionException {
  code.append(CodeStream.indent(getCodeGenerator().comment(""String_Node_Str"" + ""String_Node_Str"")));
  int rate=DFUtilities.getTokenProductionRate(outputPort);
  boolean targetCpp=((BooleanToken)getCodeGenerator().generateCpp.getToken()).booleanValue();
  CompositeActor container=(CompositeActor)getComponent().getContainer();
  TypedCompositeActor compositeActorAdapter=(TypedCompositeActor)getCodeGenerator().getAdapter(container);
  if (container instanceof CompiledCompositeActor && ((BooleanToken)getCodeGenerator().generateEmbeddedCode.getToken()).booleanValue()) {
    if (_portNumber == 0) {
      int numberOfOutputPorts=container.outputPortList().size();
      code.append(""String_Node_Str"" + _objClass + ""String_Node_Str""+ CCodegenUtilities.jniFindClass(""String_Node_Str"",targetCpp)+ ""String_Node_Str""+ _eol);
      code.append(""String_Node_Str"" + CCodegenUtilities.jniNewObjectArray(String.valueOf(numberOfOutputPorts),""String_Node_Str"",targetCpp) + ""String_Node_Str""+ _eol);
    }
    String portName=outputPort.getName();
    String tokensToThisPort=""String_Node_Str"" + portName;
    if (!(outputPort instanceof TypedIOPort)) {
      throw new InternalErrorException(outputPort,null,""String_Node_Str"");
    }
    Type type=((TypedIOPort)outputPort).getType();
    String exceptionMessage=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + outputPort.getName() + ""String_Node_Str""+ type+ ""String_Node_Str""+ ""String_Node_Str""+ outputPort.getName()+ ""String_Node_Str""+ ""String_Node_Str"";
    int numberOfChannels=outputPort.getWidthInside();
    code.append(""String_Node_Str"" + tokensToThisPort + ""String_Node_Str""+ _eol);
    if (type == BaseType.INT) {
      if (!_intFlag) {
        code.append(""String_Node_Str"" + _objClassI + ""String_Node_Str""+ CCodegenUtilities.jniFindClass(""String_Node_Str"",targetCpp)+ ""String_Node_Str""+ _eol);
        _intFlag=true;
      }
      code.append(tokensToThisPort + ""String_Node_Str"" + CCodegenUtilities.jniNewObjectArray(String.valueOf(numberOfChannels),_objClassI,targetCpp)+ ""String_Node_Str""+ _eol);
    }
 else     if (type == BaseType.DOUBLE) {
      if (!_doubleFlag) {
        code.append(""String_Node_Str"" + _objClassD + ""String_Node_Str""+ CCodegenUtilities.jniFindClass(""String_Node_Str"",targetCpp)+ ""String_Node_Str""+ _eol);
        _doubleFlag=true;
      }
      code.append(tokensToThisPort + ""String_Node_Str"" + CCodegenUtilities.jniNewObjectArray(String.valueOf(numberOfChannels),_objClassD,targetCpp)+ ""String_Node_Str""+ _eol);
    }
 else     if (type == PointerToken.POINTER) {
      if (!_intFlag) {
        code.append(""String_Node_Str"" + _objClassI + ""String_Node_Str""+ CCodegenUtilities.jniFindClass(""String_Node_Str"",targetCpp)+ ""String_Node_Str""+ _eol);
        _intFlag=true;
      }
      code.append(tokensToThisPort + ""String_Node_Str"" + CCodegenUtilities.jniNewObjectArray(String.valueOf(numberOfChannels),_objClassI,targetCpp)+ ""String_Node_Str""+ _eol);
    }
 else     if (type == BaseType.BOOLEAN) {
      if (!_booleanFlag) {
        code.append(""String_Node_Str"" + CCodegenUtilities.jniFindClass(""String_Node_Str"",targetCpp) + ""String_Node_Str""+ _eol);
        _booleanFlag=true;
      }
      code.append(tokensToThisPort + ""String_Node_Str"" + CCodegenUtilities.jniNewObjectArray(String.valueOf(numberOfChannels),""String_Node_Str"",targetCpp)+ ""String_Node_Str""+ _eol);
    }
 else {
      throw new IllegalActionException(outputPort,exceptionMessage);
    }
    System.out.println(""String_Node_Str"" + outputPort.getWidthInside());
    for (int i=0; i < outputPort.getWidthInside(); i++) {
      String tokensToOneChannel=""String_Node_Str"" + portName;
      if (i == 0) {
        if (type == BaseType.INT) {
          code.append(""String_Node_Str"" + tokensToOneChannel + ""String_Node_Str""+ rate+ ""String_Node_Str""+ _eol);
        }
 else         if (type == BaseType.DOUBLE) {
          code.append(""String_Node_Str"" + tokensToOneChannel + ""String_Node_Str""+ rate+ ""String_Node_Str""+ _eol);
        }
 else         if (type == PointerToken.POINTER) {
          code.append(""String_Node_Str"" + tokensToOneChannel + ""String_Node_Str""+ rate+ ""String_Node_Str""+ _eol);
        }
 else         if (type == BaseType.BOOLEAN) {
          code.append(""String_Node_Str"" + tokensToOneChannel + ""String_Node_Str""+ rate+ ""String_Node_Str""+ _eol);
        }
 else {
          throw new IllegalActionException(outputPort,exceptionMessage);
        }
      }
      String portNameWithChannelNumber=portName;
      if (outputPort.isMultiport()) {
        portNameWithChannelNumber=portName + '#' + i;
      }
      for (int k=0; k < rate; k++) {
        if (type == PointerToken.POINTER) {
          code.append(tokensToOneChannel + ""String_Node_Str"" + k+ ""String_Node_Str"");
        }
 else {
          code.append(tokensToOneChannel + ""String_Node_Str"" + k+ ""String_Node_Str"");
        }
        code.append(""String_Node_Str"" + portNameWithChannelNumber + ""String_Node_Str""+ _eol);
      }
      String tokensToOneChannelArray=""String_Node_Str"" + portName + i;
      if (type == BaseType.INT) {
        code.append(""String_Node_Str"" + tokensToOneChannelArray + ""String_Node_Str""+ CCodegenUtilities.jniNewArray(""String_Node_Str"",String.valueOf(rate),targetCpp)+ ""String_Node_Str""+ _eol);
        code.append(CCodegenUtilities.jniSetArrayRegion(""String_Node_Str"",tokensToOneChannelArray,""String_Node_Str"",String.valueOf(rate),tokensToOneChannel,targetCpp) + ""String_Node_Str"" + _eol);
      }
 else       if (type == BaseType.DOUBLE) {
        code.append(""String_Node_Str"" + tokensToOneChannelArray + ""String_Node_Str""+ CCodegenUtilities.jniNewArray(""String_Node_Str"",String.valueOf(rate),targetCpp)+ ""String_Node_Str""+ _eol);
        code.append(CCodegenUtilities.jniSetArrayRegion(""String_Node_Str"",tokensToOneChannelArray,""String_Node_Str"",String.valueOf(rate),tokensToOneChannel,targetCpp) + ""String_Node_Str"" + _eol);
      }
 else       if (type == PointerToken.POINTER) {
        code.append(""String_Node_Str"" + tokensToOneChannelArray + ""String_Node_Str""+ CCodegenUtilities.jniNewArray(""String_Node_Str"",String.valueOf(rate),targetCpp)+ ""String_Node_Str""+ _eol);
        code.append(CCodegenUtilities.jniSetArrayRegion(""String_Node_Str"",tokensToOneChannelArray,""String_Node_Str"",String.valueOf(rate),tokensToOneChannel,targetCpp) + ""String_Node_Str"" + _eol);
      }
 else       if (type == BaseType.BOOLEAN) {
        code.append(""String_Node_Str"" + tokensToOneChannelArray + ""String_Node_Str""+ CCodegenUtilities.jniNewArray(""String_Node_Str"",String.valueOf(rate),targetCpp)+ ""String_Node_Str""+ _eol);
        code.append(CCodegenUtilities.jniSetArrayRegion(""String_Node_Str"",tokensToOneChannelArray,""String_Node_Str"",String.valueOf(rate),tokensToOneChannel,targetCpp) + ""String_Node_Str"" + _eol);
      }
 else {
        throw new IllegalActionException(outputPort,exceptionMessage);
      }
      code.append(CCodegenUtilities.jniSetObjectArrayElement(tokensToThisPort,String.valueOf(i),tokensToOneChannelArray,targetCpp) + ""String_Node_Str"" + _eol);
      code.append(CCodegenUtilities.jniDeleteLocalRef(tokensToOneChannelArray,targetCpp) + ""String_Node_Str"" + _eol);
    }
    code.append(CCodegenUtilities.jniSetObjectArrayElement(""String_Node_Str"",String.valueOf(_portNumber),tokensToThisPort,targetCpp) + ""String_Node_Str"" + _eol);
    code.append(CCodegenUtilities.jniDeleteLocalRef(tokensToThisPort,targetCpp) + ""String_Node_Str"" + _eol);
    _portNumber++;
  }
 else {
    for (int i=0; i < outputPort.getWidthInside(); i++) {
      if (i < outputPort.getWidth()) {
        String name=outputPort.getName();
        if (outputPort.isMultiport()) {
          name=name + '#' + i;
        }
        for (int k=0; k < rate; k++) {
          code.append(CodeStream.indent(compositeActorAdapter.getReference(name + ""String_Node_Str"" + k,false)));
          code.append(""String_Node_Str"" + _eol);
          code.append(CodeStream.indent(compositeActorAdapter.getReference(""String_Node_Str"" + name + ""String_Node_Str""+ k,false)));
          code.append(""String_Node_Str"" + _eol);
        }
      }
    }
  }
}","/** 
 * Generate code for transferring enough tokens to fulfill the output production rate.
 * @param outputPort The port to transfer tokens.
 * @param code The string buffer that the generated code is appended to.
 * @exception IllegalActionException If thrown while transferring tokens.
 */
public void generateTransferOutputsCode(IOPort outputPort,StringBuffer code) throws IllegalActionException {
  code.append(CodeStream.indent(getCodeGenerator().comment(""String_Node_Str"" + ""String_Node_Str"")));
  int rate=DFUtilities.getTokenProductionRate(outputPort);
  boolean targetCpp=((BooleanToken)getCodeGenerator().generateCpp.getToken()).booleanValue();
  CompositeActor container=(CompositeActor)getComponent().getContainer();
  TypedCompositeActor compositeActorAdapter=(TypedCompositeActor)getCodeGenerator().getAdapter(container);
  if (container instanceof CompiledCompositeActor && ((BooleanToken)getCodeGenerator().generateEmbeddedCode.getToken()).booleanValue()) {
    if (_portNumber == 0) {
      int numberOfOutputPorts=container.outputPortList().size();
      code.append(""String_Node_Str"" + _objClass + ""String_Node_Str""+ CCodegenUtilities.jniFindClass(""String_Node_Str"",targetCpp)+ ""String_Node_Str""+ _eol);
      code.append(""String_Node_Str"" + CCodegenUtilities.jniNewObjectArray(String.valueOf(numberOfOutputPorts),""String_Node_Str"",targetCpp) + ""String_Node_Str""+ _eol);
    }
    String portName=outputPort.getName();
    String tokensToThisPort=""String_Node_Str"" + portName;
    if (!(outputPort instanceof TypedIOPort)) {
      throw new InternalErrorException(outputPort,null,""String_Node_Str"");
    }
    Type type=((TypedIOPort)outputPort).getType();
    String exceptionMessage=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + outputPort.getName() + ""String_Node_Str""+ type+ ""String_Node_Str""+ ""String_Node_Str""+ outputPort.getName()+ ""String_Node_Str""+ ""String_Node_Str"";
    int numberOfChannels=outputPort.getWidthInside();
    code.append(""String_Node_Str"" + tokensToThisPort + ""String_Node_Str""+ _eol);
    if (type == BaseType.INT) {
      if (!_intFlag) {
        code.append(""String_Node_Str"" + _objClassI + ""String_Node_Str""+ CCodegenUtilities.jniFindClass(""String_Node_Str"",targetCpp)+ ""String_Node_Str""+ _eol);
        _intFlag=true;
      }
      code.append(tokensToThisPort + ""String_Node_Str"" + CCodegenUtilities.jniNewObjectArray(String.valueOf(numberOfChannels),_objClassI,targetCpp)+ ""String_Node_Str""+ _eol);
    }
 else     if (type == BaseType.DOUBLE) {
      if (!_doubleFlag) {
        code.append(""String_Node_Str"" + _objClassD + ""String_Node_Str""+ CCodegenUtilities.jniFindClass(""String_Node_Str"",targetCpp)+ ""String_Node_Str""+ _eol);
        _doubleFlag=true;
      }
      code.append(tokensToThisPort + ""String_Node_Str"" + CCodegenUtilities.jniNewObjectArray(String.valueOf(numberOfChannels),_objClassD,targetCpp)+ ""String_Node_Str""+ _eol);
    }
 else     if (type == PointerToken.POINTER) {
      if (!_intFlag) {
        code.append(""String_Node_Str"" + _objClassI + ""String_Node_Str""+ CCodegenUtilities.jniFindClass(""String_Node_Str"",targetCpp)+ ""String_Node_Str""+ _eol);
        _intFlag=true;
      }
      code.append(tokensToThisPort + ""String_Node_Str"" + CCodegenUtilities.jniNewObjectArray(String.valueOf(numberOfChannels),_objClassI,targetCpp)+ ""String_Node_Str""+ _eol);
    }
 else     if (type == BaseType.BOOLEAN) {
      if (!_booleanFlag) {
        code.append(""String_Node_Str"" + CCodegenUtilities.jniFindClass(""String_Node_Str"",targetCpp) + ""String_Node_Str""+ _eol);
        _booleanFlag=true;
      }
      code.append(tokensToThisPort + ""String_Node_Str"" + CCodegenUtilities.jniNewObjectArray(String.valueOf(numberOfChannels),""String_Node_Str"",targetCpp)+ ""String_Node_Str""+ _eol);
    }
 else {
      throw new IllegalActionException(outputPort,exceptionMessage);
    }
    for (int i=0; i < outputPort.getWidthInside(); i++) {
      String tokensToOneChannel=""String_Node_Str"" + portName;
      if (i == 0) {
        if (type == BaseType.INT) {
          code.append(""String_Node_Str"" + tokensToOneChannel + ""String_Node_Str""+ rate+ ""String_Node_Str""+ _eol);
        }
 else         if (type == BaseType.DOUBLE) {
          code.append(""String_Node_Str"" + tokensToOneChannel + ""String_Node_Str""+ rate+ ""String_Node_Str""+ _eol);
        }
 else         if (type == PointerToken.POINTER) {
          code.append(""String_Node_Str"" + tokensToOneChannel + ""String_Node_Str""+ rate+ ""String_Node_Str""+ _eol);
        }
 else         if (type == BaseType.BOOLEAN) {
          code.append(""String_Node_Str"" + tokensToOneChannel + ""String_Node_Str""+ rate+ ""String_Node_Str""+ _eol);
        }
 else {
          throw new IllegalActionException(outputPort,exceptionMessage);
        }
      }
      String portNameWithChannelNumber=portName;
      if (outputPort.isMultiport()) {
        portNameWithChannelNumber=portName + '#' + i;
      }
      for (int k=0; k < rate; k++) {
        String sanitizedContainerName=CodeGeneratorAdapter.generateName(container);
        String hasTokenString=""String_Node_Str"" + sanitizedContainerName + ""String_Node_Str""+ sanitizedContainerName+ ""String_Node_Str""+ outputPort.getName()+ ""String_Node_Str""+ i+ ""String_Node_Str""+ _eol;
        code.append(hasTokenString);
        String getString=""String_Node_Str"" + sanitizedContainerName + ""String_Node_Str""+ sanitizedContainerName+ ""String_Node_Str""+ outputPort.getName()+ ""String_Node_Str""+ i+ ""String_Node_Str"";
        if (type == BaseType.INT)         getString+=""String_Node_Str"";
 else         if (type == BaseType.DOUBLE)         getString+=""String_Node_Str"";
 else         if (type == BaseType.BOOLEAN)         getString+=""String_Node_Str"";
 else         throw new IllegalActionException(outputPort,exceptionMessage);
        code.append(_eol + tokensToOneChannel + ""String_Node_Str""+ k+ ""String_Node_Str""+ getString+ _eol);
      }
      String tokensToOneChannelArray=""String_Node_Str"" + portName + i;
      if (type == BaseType.INT) {
        code.append(""String_Node_Str"" + tokensToOneChannelArray + ""String_Node_Str""+ CCodegenUtilities.jniNewArray(""String_Node_Str"",String.valueOf(rate),targetCpp)+ ""String_Node_Str""+ _eol);
        code.append(CCodegenUtilities.jniSetArrayRegion(""String_Node_Str"",tokensToOneChannelArray,""String_Node_Str"",String.valueOf(rate),tokensToOneChannel,targetCpp) + ""String_Node_Str"" + _eol);
      }
 else       if (type == BaseType.DOUBLE) {
        code.append(""String_Node_Str"" + tokensToOneChannelArray + ""String_Node_Str""+ CCodegenUtilities.jniNewArray(""String_Node_Str"",String.valueOf(rate),targetCpp)+ ""String_Node_Str""+ _eol);
        code.append(CCodegenUtilities.jniSetArrayRegion(""String_Node_Str"",tokensToOneChannelArray,""String_Node_Str"",String.valueOf(rate),tokensToOneChannel,targetCpp) + ""String_Node_Str"" + _eol);
      }
 else       if (type == PointerToken.POINTER) {
        code.append(""String_Node_Str"" + tokensToOneChannelArray + ""String_Node_Str""+ CCodegenUtilities.jniNewArray(""String_Node_Str"",String.valueOf(rate),targetCpp)+ ""String_Node_Str""+ _eol);
        code.append(CCodegenUtilities.jniSetArrayRegion(""String_Node_Str"",tokensToOneChannelArray,""String_Node_Str"",String.valueOf(rate),tokensToOneChannel,targetCpp) + ""String_Node_Str"" + _eol);
      }
 else       if (type == BaseType.BOOLEAN) {
        code.append(""String_Node_Str"" + tokensToOneChannelArray + ""String_Node_Str""+ CCodegenUtilities.jniNewArray(""String_Node_Str"",String.valueOf(rate),targetCpp)+ ""String_Node_Str""+ _eol);
        code.append(CCodegenUtilities.jniSetArrayRegion(""String_Node_Str"",tokensToOneChannelArray,""String_Node_Str"",String.valueOf(rate),tokensToOneChannel,targetCpp) + ""String_Node_Str"" + _eol);
      }
 else {
        throw new IllegalActionException(outputPort,exceptionMessage);
      }
      code.append(CCodegenUtilities.jniSetObjectArrayElement(tokensToThisPort,String.valueOf(i),tokensToOneChannelArray,targetCpp) + ""String_Node_Str"" + _eol);
      code.append(CCodegenUtilities.jniDeleteLocalRef(tokensToOneChannelArray,targetCpp) + ""String_Node_Str"" + _eol);
    }
    code.append(CCodegenUtilities.jniSetObjectArrayElement(""String_Node_Str"",String.valueOf(_portNumber),tokensToThisPort,targetCpp) + ""String_Node_Str"" + _eol);
    code.append(CCodegenUtilities.jniDeleteLocalRef(tokensToThisPort,targetCpp) + ""String_Node_Str"" + _eol);
    _portNumber++;
  }
 else {
    for (int i=0; i < outputPort.getWidthInside(); i++) {
      if (i < outputPort.getWidth()) {
        String name=outputPort.getName();
        if (outputPort.isMultiport()) {
          name=name + '#' + i;
        }
        for (int k=0; k < rate; k++) {
          code.append(CodeStream.indent(compositeActorAdapter.getReference(name + ""String_Node_Str"" + k,false)));
          code.append(""String_Node_Str"" + _eol);
          code.append(CodeStream.indent(compositeActorAdapter.getReference(""String_Node_Str"" + name + ""String_Node_Str""+ k,false)));
          code.append(""String_Node_Str"" + _eol);
        }
      }
    }
  }
}"
72903,"/** 
 * Generate code for transferring enough tokens to complete an internal iteration.
 * @param inputPort The port to transfer tokens.
 * @param code The string buffer that the generated code is appended to.
 * @exception IllegalActionException If thrown while transferring tokens.
 */
public void generateTransferInputsCode(IOPort inputPort,StringBuffer code) throws IllegalActionException {
  code.append(CodeStream.indent(getCodeGenerator().comment(""String_Node_Str"" + ""String_Node_Str"")));
  int rate=DFUtilities.getTokenConsumptionRate(inputPort);
  boolean targetCpp=((BooleanToken)getCodeGenerator().generateCpp.getToken()).booleanValue();
  CompositeActor container=(CompositeActor)getComponent().getContainer();
  TypedCompositeActor compositeActorAdapter=(TypedCompositeActor)getCodeGenerator().getAdapter(container);
  if (container instanceof CompiledCompositeActor && ((BooleanToken)getCodeGenerator().generateEmbeddedCode.getToken()).booleanValue()) {
    if (!(inputPort instanceof TypedIOPort)) {
      throw new InternalErrorException(inputPort,null,""String_Node_Str"");
    }
    Type type=((TypedIOPort)inputPort).getType();
    String portName=inputPort.getName();
    String exceptionMessage=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + portName + ""String_Node_Str""+ type+ ""String_Node_Str""+ ""String_Node_Str""+ portName+ ""String_Node_Str""+ ""String_Node_Str"";
    for (int i=0; i < inputPort.getWidth(); i++) {
      if (i < inputPort.getWidthInside()) {
        String tokensFromOneChannel=""String_Node_Str"" + portName + i;
        String pointerToTokensFromOneChannel=""String_Node_Str"" + tokensFromOneChannel;
        code.append(""String_Node_Str"" + tokensFromOneChannel + ""String_Node_Str""+ CCodegenUtilities.jniGetObjectArrayElement(portName,String.valueOf(i),targetCpp)+ ""String_Node_Str""+ _eol);
        if (type == BaseType.INT) {
          code.append(""String_Node_Str"" + pointerToTokensFromOneChannel + ""String_Node_Str""+ CCodegenUtilities.jniGetArrayElements(""String_Node_Str"",tokensFromOneChannel,targetCpp)+ ""String_Node_Str""+ _eol);
        }
 else         if (type == BaseType.DOUBLE) {
          code.append(""String_Node_Str"" + pointerToTokensFromOneChannel + ""String_Node_Str""+ CCodegenUtilities.jniGetArrayElements(""String_Node_Str"",tokensFromOneChannel,targetCpp)+ ""String_Node_Str""+ _eol);
        }
 else         if (type == PointerToken.POINTER) {
          code.append(""String_Node_Str"" + pointerToTokensFromOneChannel + ""String_Node_Str""+ CCodegenUtilities.jniGetArrayElements(""String_Node_Str"",tokensFromOneChannel,targetCpp)+ ""String_Node_Str""+ _eol);
        }
 else         if (type == BaseType.BOOLEAN) {
          code.append(""String_Node_Str"" + pointerToTokensFromOneChannel + ""String_Node_Str""+ CCodegenUtilities.jniGetArrayElements(""String_Node_Str"",tokensFromOneChannel,targetCpp)+ ""String_Node_Str""+ _eol);
        }
 else {
          throw new IllegalActionException(inputPort,exceptionMessage);
        }
        String portNameWithChannelNumber=portName;
        if (inputPort.isMultiport()) {
          portNameWithChannelNumber=portName + '#' + i;
        }
        for (int k=0; k < rate; k++) {
          code.append(_eol + ""String_Node_Str"" + portNameWithChannelNumber+ ""String_Node_Str"");
          if (type == PointerToken.POINTER) {
            code.append(""String_Node_Str"" + pointerToTokensFromOneChannel + ""String_Node_Str""+ k+ ""String_Node_Str"");
          }
 else {
            code.append(pointerToTokensFromOneChannel + ""String_Node_Str"" + k+ ""String_Node_Str"");
          }
          code.append(""String_Node_Str"" + _eol);
        }
        if (type == BaseType.INT) {
          code.append(CCodegenUtilities.jniReleaseArrayElements(""String_Node_Str"",tokensFromOneChannel,pointerToTokensFromOneChannel,targetCpp) + ""String_Node_Str"" + _eol);
        }
 else         if (type == BaseType.DOUBLE) {
          code.append(CCodegenUtilities.jniReleaseArrayElements(""String_Node_Str"",tokensFromOneChannel,pointerToTokensFromOneChannel,targetCpp) + ""String_Node_Str"" + _eol);
        }
 else         if (type == PointerToken.POINTER) {
          code.append(CCodegenUtilities.jniReleaseArrayElements(""String_Node_Str"",tokensFromOneChannel,pointerToTokensFromOneChannel,targetCpp) + ""String_Node_Str"" + _eol);
        }
 else         if (type == BaseType.BOOLEAN) {
          code.append(CCodegenUtilities.jniReleaseArrayElements(""String_Node_Str"",tokensFromOneChannel,pointerToTokensFromOneChannel,targetCpp) + ""String_Node_Str"" + _eol);
        }
 else {
          throw new IllegalActionException(inputPort,exceptionMessage);
        }
      }
    }
  }
 else {
    for (int i=0; i < inputPort.getWidth(); i++) {
      if (i < inputPort.getWidthInside()) {
        String name=inputPort.getName();
        if (inputPort.isMultiport()) {
          name=name + '#' + i;
        }
        for (int k=0; k < rate; k++) {
          code.append(compositeActorAdapter.getReference(""String_Node_Str"" + name + ""String_Node_Str""+ k,false));
          code.append(""String_Node_Str"" + _eol);
          code.append(compositeActorAdapter.getReference(name + ""String_Node_Str"" + k,false));
          code.append(""String_Node_Str"" + _eol);
        }
      }
    }
  }
  code.append(compositeActorAdapter.generateTypeConvertFireCode(true));
}","/** 
 * Generate code for transferring enough tokens to complete an internal iteration.
 * @param inputPort The port to transfer tokens.
 * @param code The string buffer that the generated code is appended to.
 * @exception IllegalActionException If thrown while transferring tokens.
 */
public void generateTransferInputsCode(IOPort inputPort,StringBuffer code) throws IllegalActionException {
  code.append(CodeStream.indent(getCodeGenerator().comment(""String_Node_Str"" + ""String_Node_Str"")));
  int rate=DFUtilities.getTokenConsumptionRate(inputPort);
  boolean targetCpp=((BooleanToken)getCodeGenerator().generateCpp.getToken()).booleanValue();
  CompositeActor container=(CompositeActor)getComponent().getContainer();
  TypedCompositeActor compositeActorAdapter=(TypedCompositeActor)getCodeGenerator().getAdapter(container);
  if (container instanceof CompiledCompositeActor && ((BooleanToken)getCodeGenerator().generateEmbeddedCode.getToken()).booleanValue()) {
    if (!(inputPort instanceof TypedIOPort)) {
      throw new InternalErrorException(inputPort,null,""String_Node_Str"");
    }
    Type type=((TypedIOPort)inputPort).getType();
    String portName=inputPort.getName();
    String exceptionMessage=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + portName + ""String_Node_Str""+ type+ ""String_Node_Str""+ ""String_Node_Str""+ portName+ ""String_Node_Str""+ ""String_Node_Str"";
    for (int i=0; i < inputPort.getWidth(); i++) {
      if (i < inputPort.getWidthInside()) {
        String tokensFromOneChannel=""String_Node_Str"" + portName + i;
        String pointerToTokensFromOneChannel=""String_Node_Str"" + tokensFromOneChannel;
        code.append(""String_Node_Str"" + tokensFromOneChannel + ""String_Node_Str""+ CCodegenUtilities.jniGetObjectArrayElement(portName,String.valueOf(i),targetCpp)+ ""String_Node_Str""+ _eol);
        if (type == BaseType.INT) {
          code.append(""String_Node_Str"" + pointerToTokensFromOneChannel + ""String_Node_Str""+ CCodegenUtilities.jniGetArrayElements(""String_Node_Str"",tokensFromOneChannel,targetCpp)+ ""String_Node_Str""+ _eol);
        }
 else         if (type == BaseType.DOUBLE) {
          code.append(""String_Node_Str"" + pointerToTokensFromOneChannel + ""String_Node_Str""+ CCodegenUtilities.jniGetArrayElements(""String_Node_Str"",tokensFromOneChannel,targetCpp)+ ""String_Node_Str""+ _eol);
        }
 else         if (type == PointerToken.POINTER) {
          code.append(""String_Node_Str"" + pointerToTokensFromOneChannel + ""String_Node_Str""+ CCodegenUtilities.jniGetArrayElements(""String_Node_Str"",tokensFromOneChannel,targetCpp)+ ""String_Node_Str""+ _eol);
        }
 else         if (type == BaseType.BOOLEAN) {
          code.append(""String_Node_Str"" + pointerToTokensFromOneChannel + ""String_Node_Str""+ CCodegenUtilities.jniGetArrayElements(""String_Node_Str"",tokensFromOneChannel,targetCpp)+ ""String_Node_Str""+ _eol);
        }
 else {
          throw new IllegalActionException(inputPort,exceptionMessage);
        }
        String portNameWithChannelNumber=portName;
        if (inputPort.isMultiport()) {
          portNameWithChannelNumber=portName + '#' + i;
        }
        for (int k=0; k < rate; k++) {
          String putString=_eol + ""String_Node_Str"" + CodeGeneratorAdapter.generateName(container)+ ""String_Node_Str""+ CodeGeneratorAdapter.generateName(container)+ ""String_Node_Str""+ inputPort.getName()+ ""String_Node_Str""+ i+ ""String_Node_Str""+ _eol;
          code.append(_eol + putString);
          if (type == PointerToken.POINTER) {
            code.append(""String_Node_Str"" + pointerToTokensFromOneChannel + ""String_Node_Str""+ k+ ""String_Node_Str"");
          }
 else           if (type == BaseType.INT) {
            code.append(""String_Node_Str"" + pointerToTokensFromOneChannel + ""String_Node_Str""+ k+ ""String_Node_Str"");
          }
 else           if (type == BaseType.DOUBLE) {
            code.append(""String_Node_Str"" + pointerToTokensFromOneChannel + ""String_Node_Str""+ k+ ""String_Node_Str"");
          }
 else           if (type == BaseType.BOOLEAN) {
            code.append(""String_Node_Str"" + pointerToTokensFromOneChannel + ""String_Node_Str""+ k+ ""String_Node_Str"");
          }
 else {
            throw new IllegalActionException(inputPort,exceptionMessage);
          }
          code.append(""String_Node_Str"" + _eol);
        }
        if (type == BaseType.INT) {
          code.append(CCodegenUtilities.jniReleaseArrayElements(""String_Node_Str"",tokensFromOneChannel,pointerToTokensFromOneChannel,targetCpp) + ""String_Node_Str"" + _eol);
        }
 else         if (type == BaseType.DOUBLE) {
          code.append(CCodegenUtilities.jniReleaseArrayElements(""String_Node_Str"",tokensFromOneChannel,pointerToTokensFromOneChannel,targetCpp) + ""String_Node_Str"" + _eol);
        }
 else         if (type == PointerToken.POINTER) {
          code.append(CCodegenUtilities.jniReleaseArrayElements(""String_Node_Str"",tokensFromOneChannel,pointerToTokensFromOneChannel,targetCpp) + ""String_Node_Str"" + _eol);
        }
 else         if (type == BaseType.BOOLEAN) {
          code.append(CCodegenUtilities.jniReleaseArrayElements(""String_Node_Str"",tokensFromOneChannel,pointerToTokensFromOneChannel,targetCpp) + ""String_Node_Str"" + _eol);
        }
 else {
          throw new IllegalActionException(inputPort,exceptionMessage);
        }
      }
    }
  }
 else {
    for (int i=0; i < inputPort.getWidth(); i++) {
      if (i < inputPort.getWidthInside()) {
        String name=inputPort.getName();
        if (inputPort.isMultiport()) {
          name=name + '#' + i;
        }
        for (int k=0; k < rate; k++) {
          code.append(compositeActorAdapter.getReference(""String_Node_Str"" + name + ""String_Node_Str""+ k,false));
          code.append(""String_Node_Str"" + _eol);
          code.append(compositeActorAdapter.getReference(name + ""String_Node_Str"" + k,false));
          code.append(""String_Node_Str"" + _eol);
        }
      }
    }
  }
  code.append(compositeActorAdapter.generateTypeConvertFireCode(true));
}"
72904,"/** 
 * Generate the initialization procedure entry point.
 * @return a string for the initialization procedure entry point.
 * @exception IllegalActionException Not thrown in this base class.
 */
public String generateInitializeEntryCode() throws IllegalActionException {
  if (_isTopLevel()) {
    return _eol + _eol + ""String_Node_Str""+ _eol;
  }
 else {
    return _eol + _eol + ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _sanitizedModelName+ ""String_Node_Str""+ ""String_Node_Str""+ _eol;
  }
}","/** 
 * Generate the initialization procedure entry point.
 * @return a string for the initialization procedure entry point.
 * @exception IllegalActionException Not thrown in this base class.
 */
public String generateInitializeEntryCode() throws IllegalActionException {
  if (_isTopLevel()) {
    return _eol + _eol + ""String_Node_Str""+ _eol;
  }
 else {
    String escapeName=_sanitizedModelName.replaceAll(""String_Node_Str"",""String_Node_Str"");
    return _eol + _eol + ""String_Node_Str""+ _eol+ ""String_Node_Str""+ escapeName+ ""String_Node_Str""+ ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _eol+ ""String_Node_Str"";
  }
}"
72905,"/** 
 * Generate the main entry point.
 * @return Return the definition of the main entry point for a program.In C, this would be defining main().
 * @exception IllegalActionException Not thrown in this base class.
 */
public String generateMainEntryCode() throws IllegalActionException {
  StringBuffer mainEntryCode=new StringBuffer();
  if (_isTopLevel()) {
    mainEntryCode.append(_eol + _eol + ""String_Node_Str""+ _eol);
    if (((BooleanToken)measureTime.getToken()).booleanValue()) {
      mainEntryCode.append(_eol + ""String_Node_Str"");
      mainEntryCode.append(_eol + ""String_Node_Str"");
      mainEntryCode.append(_eol + ""String_Node_Str"");
    }
    mainEntryCode.append(_eol + ""String_Node_Str"");
    mainEntryCode.append(_eol + _eol + ""String_Node_Str"");
    mainEntryCode.append(_eol + ""String_Node_Str"");
    mainEntryCode.append(_eol + ""String_Node_Str"");
    mainEntryCode.append(_eol + ""String_Node_Str"");
    mainEntryCode.append(_eol + ""String_Node_Str"");
    mainEntryCode.append(_eol + ""String_Node_Str"");
    mainEntryCode.append(_eol + ""String_Node_Str"");
    mainEntryCode.append(_eol + ""String_Node_Str"");
    if (((BooleanToken)measureTime.getToken()).booleanValue()) {
      mainEntryCode.append(_eol + ""String_Node_Str"");
      mainEntryCode.append(_eol + ""String_Node_Str"");
      mainEntryCode.append(_eol + ""String_Node_Str"");
      mainEntryCode.append(_eol + ""String_Node_Str"");
      mainEntryCode.append(_eol + ""String_Node_Str"");
    }
    mainEntryCode.append(_eol + ""String_Node_Str"");
  }
 else {
    mainEntryCode.append(_eol + _eol + ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _sanitizedModelName+ ""String_Node_Str""+ _eol+ ""String_Node_Str"");
    Iterator<?> inputPorts=((Actor)getContainer()).inputPortList().iterator();
    while (inputPorts.hasNext()) {
      TypedIOPort inputPort=(TypedIOPort)inputPorts.next();
      mainEntryCode.append(""String_Node_Str"" + inputPort.getName() + ""String_Node_Str"");
    }
    mainEntryCode.append(""String_Node_Str"" + _eol);
    mainEntryCode.append(_eol + ""String_Node_Str"");
    mainEntryCode.append(_eol + ""String_Node_Str"");
    inputPorts=((Actor)getContainer()).inputPortList().iterator();
    while (inputPorts.hasNext()) {
      TypedIOPort inputPort=(TypedIOPort)inputPorts.next();
      mainEntryCode.append(_eol + inputPort.getName() + ""String_Node_Str""+ inputPort.getName()+ ""String_Node_Str"");
    }
    mainEntryCode.append(_eol + _sanitizedModelName + ""String_Node_Str""+ _eol);
  }
  return mainEntryCode.toString();
}","/** 
 * Generate the main entry point.
 * @return Return the definition of the main entry point for a program.In C, this would be defining main().
 * @exception IllegalActionException Not thrown in this base class.
 */
public String generateMainEntryCode() throws IllegalActionException {
  StringBuffer mainEntryCode=new StringBuffer();
  if (_isTopLevel()) {
    mainEntryCode.append(_eol + _eol + ""String_Node_Str""+ _eol);
    if (((BooleanToken)measureTime.getToken()).booleanValue()) {
      mainEntryCode.append(_eol + ""String_Node_Str"");
      mainEntryCode.append(_eol + ""String_Node_Str"");
      mainEntryCode.append(_eol + ""String_Node_Str"");
    }
    mainEntryCode.append(_eol + ""String_Node_Str"");
    mainEntryCode.append(_eol + _eol + ""String_Node_Str"");
    mainEntryCode.append(_eol + ""String_Node_Str"");
    mainEntryCode.append(_eol + ""String_Node_Str"");
    mainEntryCode.append(_eol + ""String_Node_Str"");
    mainEntryCode.append(_eol + ""String_Node_Str"");
    mainEntryCode.append(_eol + ""String_Node_Str"");
    mainEntryCode.append(_eol + ""String_Node_Str"");
    mainEntryCode.append(_eol + ""String_Node_Str"");
    if (((BooleanToken)measureTime.getToken()).booleanValue()) {
      mainEntryCode.append(_eol + ""String_Node_Str"");
      mainEntryCode.append(_eol + ""String_Node_Str"");
      mainEntryCode.append(_eol + ""String_Node_Str"");
      mainEntryCode.append(_eol + ""String_Node_Str"");
      mainEntryCode.append(_eol + ""String_Node_Str"");
    }
    mainEntryCode.append(_eol + ""String_Node_Str"");
  }
 else {
    String escapeName=_sanitizedModelName.replaceAll(""String_Node_Str"",""String_Node_Str"");
    mainEntryCode.append(_eol + _eol + ""String_Node_Str""+ _eol+ ""String_Node_Str""+ escapeName+ ""String_Node_Str""+ _eol+ ""String_Node_Str"");
    Iterator<?> inputPorts=((Actor)getContainer()).inputPortList().iterator();
    while (inputPorts.hasNext()) {
      TypedIOPort inputPort=(TypedIOPort)inputPorts.next();
      mainEntryCode.append(""String_Node_Str"" + inputPort.getName() + ""String_Node_Str"");
    }
    mainEntryCode.append(""String_Node_Str"" + _eol);
    inputPorts=((Actor)getContainer()).inputPortList().iterator();
    while (inputPorts.hasNext()) {
      TypedIOPort inputPort=(TypedIOPort)inputPorts.next();
      mainEntryCode.append(_eol + inputPort.getName() + ""String_Node_Str""+ inputPort.getName()+ ""String_Node_Str"");
    }
    mainEntryCode.append(_eol + _sanitizedModelName + ""String_Node_Str""+ _eol);
  }
  return mainEntryCode.toString();
}"
72906,"/** 
 * Generate the postfire procedure entry point.
 * @return a string for the postfire procedure entry point.
 * @exception IllegalActionException Not thrown in this base class.
 */
public String generatePostfireEntryCode() throws IllegalActionException {
  if (_isTopLevel()) {
    return _eol + _eol + ""String_Node_Str""+ _eol;
  }
 else {
    return _eol + _eol + ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _sanitizedModelName+ ""String_Node_Str""+ ""String_Node_Str""+ _eol;
  }
}","/** 
 * Generate the postfire procedure entry point.
 * @return a string for the postfire procedure entry point.
 * @exception IllegalActionException Not thrown in this base class.
 */
public String generatePostfireEntryCode() throws IllegalActionException {
  if (_isTopLevel()) {
    return _eol + _eol + ""String_Node_Str""+ _eol;
  }
 else {
    String escapeName=_sanitizedModelName.replaceAll(""String_Node_Str"",""String_Node_Str"");
    return _eol + _eol + ""String_Node_Str""+ _eol+ ""String_Node_Str""+ escapeName+ ""String_Node_Str""+ ""String_Node_Str""+ _eol;
  }
}"
72907,"/** 
 * Generate the wrapup procedure entry point.
 * @return a string for the wrapup procedure entry point.
 * @exception IllegalActionException Not thrown in this base class.
 */
public String generateWrapupEntryCode() throws IllegalActionException {
  if (_isTopLevel()) {
    return _eol + _eol + ""String_Node_Str""+ _eol;
  }
 else {
    return _eol + _eol + ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _sanitizedModelName+ ""String_Node_Str""+ ""String_Node_Str""+ _eol;
  }
}","/** 
 * Generate the wrapup procedure entry point.
 * @return a string for the wrapup procedure entry point.
 * @exception IllegalActionException Not thrown in this base class.
 */
public String generateWrapupEntryCode() throws IllegalActionException {
  if (_isTopLevel()) {
    return _eol + _eol + ""String_Node_Str""+ _eol;
  }
 else {
    String escapeName=_sanitizedModelName.replaceAll(""String_Node_Str"",""String_Node_Str"");
    return _eol + _eol + ""String_Node_Str""+ _eol+ ""String_Node_Str""+ escapeName+ ""String_Node_Str""+ ""String_Node_Str""+ _eol;
  }
}"
72908,"/** 
 * Generate the initialization procedure name.
 * @return a string for the initialization procedure name.
 * @exception IllegalActionException Not thrown in this base class.
 */
public String generateInitializeProcedureName() throws IllegalActionException {
  if (_isTopLevel()) {
    return _eol + _eol + ""String_Node_Str""+ _eol;
  }
 else {
    return _eol + _eol + ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _sanitizedModelName+ ""String_Node_Str""+ ""String_Node_Str""+ _eol;
  }
}","/** 
 * Generate the initialization procedure name.
 * @return a string for the initialization procedure name.
 * @exception IllegalActionException Not thrown in this base class.
 */
public String generateInitializeProcedureName() throws IllegalActionException {
  if (_isTopLevel()) {
    return _eol + _eol + ""String_Node_Str""+ _eol;
  }
 else {
    String escapeName=_sanitizedModelName.replaceAll(""String_Node_Str"",""String_Node_Str"");
    return _eol + _eol + ""String_Node_Str""+ _eol+ ""String_Node_Str""+ escapeName+ ""String_Node_Str""+ ""String_Node_Str""+ _eol;
  }
}"
72909,"/** 
 * Generate the wrapup procedure name.
 * @return a string for the wrapup procedure name.
 * @exception IllegalActionException Not thrown in this base class.
 */
public String generateWrapupProcedureName() throws IllegalActionException {
  if (_isTopLevel()) {
    return _eol + ""String_Node_Str"" + _eol;
  }
 else {
    return _eol + _eol + ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _sanitizedModelName+ ""String_Node_Str""+ ""String_Node_Str""+ _eol;
  }
}","/** 
 * Generate the wrapup procedure name.
 * @return a string for the wrapup procedure name.
 * @exception IllegalActionException Not thrown in this base class.
 */
public String generateWrapupProcedureName() throws IllegalActionException {
  if (_isTopLevel()) {
    return _eol + ""String_Node_Str"" + _eol;
  }
 else {
    String escapeName=_sanitizedModelName.replaceAll(""String_Node_Str"",""String_Node_Str"");
    return _eol + _eol + ""String_Node_Str""+ _eol+ ""String_Node_Str""+ escapeName+ ""String_Node_Str""+ ""String_Node_Str""+ _eol;
  }
}"
72910,"/** 
 * Compile the Java code. The <code>javac</code> and <code>javah</code> commands are executed on the the java file.
 * @exception IllegalActionException If there is a problem readingthe <i>codeDirectory</i> parameter.
 */
protected void _compileJNICode() throws IllegalActionException {
  StringBufferExec executeCommands=new StringBufferExec(true);
  List<String> commands=new LinkedList<String>();
  commands.add(""String_Node_Str"" + _sanitizedActorName + ""String_Node_Str"");
  commands.add(""String_Node_Str"" + _sanitizedActorName);
  if (_debugging) {
    _debugAndSystemOut(""String_Node_Str"" + commands.get(0));
    _debugAndSystemOut(""String_Node_Str"" + commands.get(1));
  }
  executeCommands.setWorkingDirectory(codeDirectory.asFile());
  executeCommands.setCommands(commands);
  executeCommands.start();
  int lastSubprocessReturnCode=executeCommands.getLastSubprocessReturnCode();
  if (lastSubprocessReturnCode != 0) {
    throw new IllegalActionException(this,""String_Node_Str"" + lastSubprocessReturnCode + ""String_Node_Str""+ executeCommands.buffer.toString());
  }
}","/** 
 * Compile the Java code. The <code>javac</code> and <code>javah</code> commands are executed on the the java file.
 * @exception IllegalActionException If there is a problem readingthe <i>codeDirectory</i> parameter.
 */
protected void _compileJNICode() throws IllegalActionException {
  StringBufferExec executeCommands=new StringBufferExec(true);
  List<String> commands=new LinkedList<String>();
  commands.add(""String_Node_Str"" + _sanitizedActorName + ""String_Node_Str"");
  if (_debugging) {
    _debugAndSystemOut(""String_Node_Str"" + commands.get(0));
  }
  executeCommands.setWorkingDirectory(codeDirectory.asFile());
  executeCommands.setCommands(commands);
  executeCommands.start();
  int lastSubprocessReturnCode=executeCommands.getLastSubprocessReturnCode();
  if (lastSubprocessReturnCode != 0) {
    throw new IllegalActionException(this,""String_Node_Str"" + lastSubprocessReturnCode + ""String_Node_Str""+ executeCommands.buffer.toString());
  }
}"
72911,"/** 
 * Generate and write the code for a composite actor. This method is called recursively, for any composite actor present in the model. There are 5 phases in this method : First we initialize the parameters for the container Then we generate and write the code for the container Then we call the generation for each contained actor Then we call the generation for the director Finally we generate the makefile corresponding
 * @param container The actor that needs to be generated
 * @param containerDirectory A string describing where to write the files
 * @exception IllegalActionException If anything goes wrong during the generation.
 */
protected void _generateAndWriteCompositeActorCode(CompositeEntity container,String containerDirectory) throws IllegalActionException {
  Director director=null;
  if (container instanceof CompositeActor)   director=((CompositeActor)container).getDirector();
 else   throw new IllegalActionException(container,""String_Node_Str"" + container.getFullName());
  Attribute generateEmbeddedCode=getAttribute(""String_Node_Str"");
  if (generateEmbeddedCode instanceof Parameter) {
    ((Parameter)generateEmbeddedCode).setExpression(""String_Node_Str"");
  }
  if (container instanceof ptolemy.cg.lib.CompiledCompositeActor) {
    if (generateEmbeddedCode instanceof Parameter)     ((Parameter)generateEmbeddedCode).setExpression(""String_Node_Str"");
  }
  boolean inlineValue=((BooleanToken)inline.getToken()).booleanValue();
  if (inlineValue && director != null && director instanceof DEDirector) {
    throw new IllegalActionException(""String_Node_Str"");
  }
  String directory=codeDirectory.stringValue();
  if (!directory.endsWith(""String_Node_Str""))   directory+=""String_Node_Str"";
  String sanitizedContainerName=container.getName();
  containerDirectory+=""String_Node_Str"" + sanitizedContainerName;
  String directorySrc=directory + ""String_Node_Str"" + containerDirectory;
  String directoryIncludes=directory + ""String_Node_Str"" + containerDirectory;
  String directoryBuild=directory + ""String_Node_Str"" + containerDirectory;
  if (new File(directorySrc).mkdirs() || new File(directoryIncludes).mkdirs() || new File(directoryBuild).mkdirs()) {
    directory+=""String_Node_Str"";
  }
  if (!_includes.contains(""String_Node_Str"" + directoryIncludes))   _includes.add(""String_Node_Str"" + directoryIncludes);
  _generateAndWriteActorCode(container,(NamedProgramCodeGeneratorAdapter)getAdapter(director),container,directoryIncludes,directorySrc);
  List actorList=container.deepEntityList();
  Iterator<?> actors=actorList.iterator();
  while (actors.hasNext()) {
    NamedObj actor=(NamedObj)actors.next();
    if (actor instanceof ModalController)     continue;
 else     if (actor instanceof AtomicActor || actor instanceof FSMActor)     _generateAndWriteActorCode(actor,(NamedProgramCodeGeneratorAdapter)getAdapter(director),container,directoryIncludes,directorySrc);
 else     if (actor instanceof CompositeEntity)     _generateAndWriteCompositeActorCode((CompositeEntity)actor,containerDirectory);
 else     if (actor instanceof State)     for (    TypedActor act : ((State)actor).getRefinement()) {
      Refinement r=(Refinement)act;
      _generateAndWriteCompositeActorCode(r,containerDirectory);
    }
 else     throw new IllegalActionException(container,""String_Node_Str"" + actor.getFullName());
  }
  _generateAndWriteDirectorCode(director,directoryIncludes,directorySrc);
}","/** 
 * Generate and write the code for a composite actor. This method is called recursively, for any composite actor present in the model. There are 5 phases in this method : First we initialize the parameters for the container Then we generate and write the code for the container Then we call the generation for each contained actor Then we call the generation for the director Finally we generate the makefile corresponding
 * @param container The actor that needs to be generated
 * @param containerDirectory A string describing where to write the files
 * @exception IllegalActionException If anything goes wrong during the generation.
 */
protected void _generateAndWriteCompositeActorCode(CompositeEntity container,String containerDirectory) throws IllegalActionException {
  Director director=null;
  if (container instanceof CompositeActor)   director=((CompositeActor)container).getDirector();
 else   throw new IllegalActionException(container,""String_Node_Str"" + container.getFullName());
  Attribute generateEmbeddedCode=getAttribute(""String_Node_Str"");
  if (generateEmbeddedCode instanceof Parameter) {
    ((Parameter)generateEmbeddedCode).setExpression(""String_Node_Str"");
  }
  if (container instanceof ptolemy.cg.lib.CompiledCompositeActor) {
    if (generateEmbeddedCode instanceof Parameter)     ((Parameter)generateEmbeddedCode).setExpression(""String_Node_Str"");
  }
  boolean inlineValue=((BooleanToken)inline.getToken()).booleanValue();
  if (inlineValue && director != null && director instanceof DEDirector) {
    throw new IllegalActionException(""String_Node_Str"");
  }
  String directory=codeDirectory.stringValue();
  if (!directory.endsWith(""String_Node_Str""))   directory+=""String_Node_Str"";
  String sanitizedContainerName=container.getName();
  containerDirectory+=""String_Node_Str"" + sanitizedContainerName;
  String directorySrc=directory + ""String_Node_Str"" + containerDirectory;
  String directoryIncludes=directory + ""String_Node_Str"" + containerDirectory;
  String directoryBuild=directory + ""String_Node_Str"" + containerDirectory;
  if (new File(directorySrc).mkdirs() && new File(directoryIncludes).mkdirs() && new File(directoryBuild).mkdirs()) {
    directory+=""String_Node_Str"";
  }
  if (!_includes.contains(""String_Node_Str"" + directoryIncludes))   _includes.add(""String_Node_Str"" + directoryIncludes);
  _generateAndWriteActorCode(container,(NamedProgramCodeGeneratorAdapter)getAdapter(director),container,directoryIncludes,directorySrc);
  List actorList=container.deepEntityList();
  Iterator<?> actors=actorList.iterator();
  while (actors.hasNext()) {
    NamedObj actor=(NamedObj)actors.next();
    if (actor instanceof ModalController)     continue;
 else     if (actor instanceof AtomicActor || actor instanceof FSMActor)     _generateAndWriteActorCode(actor,(NamedProgramCodeGeneratorAdapter)getAdapter(director),container,directoryIncludes,directorySrc);
 else     if (actor instanceof CompositeEntity)     _generateAndWriteCompositeActorCode((CompositeEntity)actor,containerDirectory);
 else     if (actor instanceof State)     for (    TypedActor act : ((State)actor).getRefinement()) {
      Refinement r=(Refinement)act;
      _generateAndWriteCompositeActorCode(r,containerDirectory);
    }
 else     throw new IllegalActionException(container,""String_Node_Str"" + actor.getFullName());
  }
  _generateAndWriteDirectorCode(director,directoryIncludes,directorySrc);
}"
72912,"/** 
 * Generate code and append it to the given string buffer. Write the code to the directory specified by the codeDirectory parameter.  The file name is a sanitized version of the model name with a suffix that is based on last package name of the <i>generatorPackage</i> parameter.  Thus if the <i>codeDirectory</i> is <code>$HOME</code>, the name of the model is <code>Foo</code> and the <i>generatorPackage</i> is <code>ptolemy.codegen.c</code>, then the file that is written will be <code>$HOME/Foo.c</code> This method is the main entry point. We do not call the super method because it is too different from it. For instance, there is not only one file generated, but a few. The code generation algorithm works as followed : We generate a file with the name of the model (+ .c) and its header file. In this file we have the implementation of a ptolemy manager in C (  {@link ptolemy.actor.Manager}. Also for, each Composite Actor (including the top level container) We generate the files implementing the behavior of the director and of all the actors. (sources files are in the src directory and header files in includes directory) Moreover, for each folder a makefile is generated.
 * @param code The given string buffer.
 * @return The return value of the last subprocess that was executed.or -1 if no commands were executed.
 * @exception KernelException If the target file cannot be overwrittenor write-to-file throw any exception.
 */
protected int _generateCode(StringBuffer code) throws KernelException {
  long startTime=new Date().getTime();
  long overallStartTime=startTime;
  StringBuffer codeMainH=new StringBuffer();
  StringBuffer codeTypesH=new StringBuffer();
  StringBuffer codeTypesC=new StringBuffer();
  _reset();
  _sanitizedModelName=CodeGeneratorAdapter.generateName(_model);
  _analyzeTypeConversions();
  startTime=_printTimeAndMemory(startTime,""String_Node_Str"");
  String directory=codeDirectory.stringValue();
  if (!directory.endsWith(""String_Node_Str""))   directory+=""String_Node_Str"";
  String directorySrc=directory + ""String_Node_Str"";
  String directoryIncludes=directory + ""String_Node_Str"";
  String directoryBuild=directory + ""String_Node_Str"";
  _deleteDirectory(directorySrc);
  if (!_includes.contains(""String_Node_Str"" + directoryIncludes))   _includes.add(""String_Node_Str"" + directoryIncludes);
  if (new File(directorySrc).mkdirs() || new File(directoryIncludes).mkdirs() || new File(directoryBuild).mkdirs()) {
    directory+=""String_Node_Str"";
  }
  CompositeActor container=(CompositeActor)getContainer();
  String sanitizedNameContainer=CodeGeneratorAdapter.generateName(container);
  _generateAndWriteCompositeActorCode(container,""String_Node_Str"");
  String sharedCode=_generateSharedCode();
  String declareSharedCode=_generateDeclareSharedCode();
  String[] typeResolutionCode=generateTypeConvertCodeCandH();
  startTime=_printTimeAndMemory(startTime,""String_Node_Str"");
  code.append(generateCopyright());
  codeMainH.append(generateCopyright());
  codeTypesH.append(generateCopyright());
  codeTypesC.append(generateCopyright());
  codeMainH.append(""String_Node_Str"" + _sanitizedModelName.toUpperCase() + ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _sanitizedModelName.toUpperCase()+ ""String_Node_Str""+ _eol);
  codeMainH.append(_eol + ""String_Node_Str"" + _sanitizedModelName+ ""String_Node_Str"");
  codeMainH.append(_eol + ""String_Node_Str"" + sanitizedNameContainer+ ""String_Node_Str"");
  code.append(_eol + ""String_Node_Str"" + _sanitizedModelName+ ""String_Node_Str"");
  if (((BooleanToken)measureTime.getToken()).booleanValue()) {
    code.append(_eol + ""String_Node_Str"");
    code.append(_eol + ""String_Node_Str"");
  }
  codeMainH.append(_eol + _eol + ""String_Node_Str"");
  code.append(generateMainEntryCode());
  code.append(generateMainExitCode());
  codeMainH.append(_eol + ""String_Node_Str"");
  codeMainH.append(_eol + ""String_Node_Str"");
  code.append(_eol + ""String_Node_Str"");
  code.append(_eol + ""String_Node_Str"");
  code.append(_eol + ""String_Node_Str"" + sanitizedNameContainer+ ""String_Node_Str"");
  code.append(_eol + sanitizedNameContainer + ""String_Node_Str"");
  code.append(_eol + ""String_Node_Str"");
  codeMainH.append(generateInitializeProcedureName());
  code.append(generateInitializeEntryCode());
  code.append(_eol + ""String_Node_Str"");
  code.append(_eol + sanitizedNameContainer + ""String_Node_Str""+ _eol);
  code.append(generateInitializeExitCode());
  codeMainH.append(_eol + ""String_Node_Str"");
  code.append(_eol + ""String_Node_Str"");
  code.append(_eol + ""String_Node_Str"");
  code.append(_eol + ""String_Node_Str"");
  code.append(_eol + ""String_Node_Str"" + sanitizedNameContainer+ ""String_Node_Str"");
  code.append(_eol + sanitizedNameContainer + ""String_Node_Str"");
  code.append(_eol + ""String_Node_Str"" + sanitizedNameContainer+ ""String_Node_Str"");
  code.append(_eol + ""String_Node_Str"");
  code.append(_eol + ""String_Node_Str"");
  code.append(_eol + ""String_Node_Str"");
  codeMainH.append(generateWrapupProcedureName());
  code.append(generateWrapupEntryCode());
  code.append(_eol + sanitizedNameContainer + ""String_Node_Str"");
  code.append(generateWrapupExitCode());
  codeMainH.append(_eol + ""String_Node_Str"");
  codeTypesH.append(""String_Node_Str"" + _sanitizedModelName.toUpperCase() + ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _sanitizedModelName.toUpperCase()+ ""String_Node_Str""+ _eol);
  codeTypesH.append(_eol + typeResolutionCode[0]);
  typeResolutionCode[0]=null;
  codeTypesH.append(comment(""String_Node_Str""));
  codeTypesC.append(typeResolutionCode[1]);
  typeResolutionCode[1]=null;
  codeTypesC.append(comment(""String_Node_Str""));
  codeTypesC.append(sharedCode);
  sharedCode=null;
  codeTypesH.append(declareSharedCode);
  declareSharedCode=null;
  codeTypesH.append(comment(""String_Node_Str""));
  codeTypesH.append(""String_Node_Str"");
  startTime=_printTimeAndMemory(startTime,""String_Node_Str"");
  code=_finalPassOverCode(code);
  codeMainH=_finalPassOverCode(codeMainH);
  codeTypesH=_finalPassOverCode(codeTypesH);
  codeTypesC=_finalPassOverCode(codeTypesC);
  startTime=_printTimeAndMemory(startTime,""String_Node_Str"");
  _writeCodeFileName(code,_sanitizedModelName + ""String_Node_Str"",true,false);
  _writeCodeFileName(codeMainH,""String_Node_Str"" + _sanitizedModelName + ""String_Node_Str"",true,false);
  _writeCodeFileName(codeTypesH,""String_Node_Str"" + _sanitizedModelName + ""String_Node_Str"",true,false);
  _writeCodeFileName(codeTypesC,""String_Node_Str"" + _sanitizedModelName + ""String_Node_Str"",true,false);
  _copyCFileTosrc(""String_Node_Str"",directoryIncludes,""String_Node_Str"");
  _copyCFileTosrc(""String_Node_Str"",directorySrc,""String_Node_Str"");
  _copyCFileTosrc(""String_Node_Str"",directoryIncludes,""String_Node_Str"");
  _copyCFileTosrc(""String_Node_Str"",directorySrc,""String_Node_Str"");
  _copyCFileTosrc(""String_Node_Str"",directoryIncludes,""String_Node_Str"");
  _copyCFileTosrc(""String_Node_Str"",directorySrc,""String_Node_Str"");
  _copyCFileTosrc(""String_Node_Str"",directorySrc,""String_Node_Str"");
  _copyCFileTosrc(""String_Node_Str"",directoryIncludes,""String_Node_Str"");
  _copyCFileTosrc(""String_Node_Str"",directorySrc,""String_Node_Str"");
  _copyCFileTosrc(""String_Node_Str"",directoryIncludes,""String_Node_Str"");
  _copyCFileTosrc(""String_Node_Str"",directoryIncludes,""String_Node_Str"");
  _copyCFileTosrc(""String_Node_Str"",directoryIncludes,""String_Node_Str"");
  _copyCFileTosrc(""String_Node_Str"",directorySrc,""String_Node_Str"");
  _copyCFileTosrc(""String_Node_Str"",directoryIncludes,""String_Node_Str"");
  _copyCFileTosrc(""String_Node_Str"",directorySrc,""String_Node_Str"");
  code=null;
  codeMainH=null;
  codeTypesH=null;
  codeTypesC=null;
  _writeMakefile(container,directory);
  _printTimeAndMemory(startTime,""String_Node_Str"");
  if (_executeCommands == null) {
    _executeCommands=new StreamExec();
  }
  _printTimeAndMemory(overallStartTime,""String_Node_Str"");
  return _executeCommands();
}","/** 
 * Generate code and append it to the given string buffer. Write the code to the directory specified by the codeDirectory parameter.  The file name is a sanitized version of the model name with a suffix that is based on last package name of the <i>generatorPackage</i> parameter.  Thus if the <i>codeDirectory</i> is <code>$HOME</code>, the name of the model is <code>Foo</code> and the <i>generatorPackage</i> is <code>ptolemy.codegen.c</code>, then the file that is written will be <code>$HOME/Foo.c</code> This method is the main entry point. We do not call the super method because it is too different from it. For instance, there is not only one file generated, but a few. The code generation algorithm works as followed : We generate a file with the name of the model (+ .c) and its header file. In this file we have the implementation of a ptolemy manager in C (  {@link ptolemy.actor.Manager}. Also for, each Composite Actor (including the top level container) We generate the files implementing the behavior of the director and of all the actors. (sources files are in the src directory and header files in includes directory) Moreover, for each folder a makefile is generated.
 * @param code The given string buffer.
 * @return The return value of the last subprocess that was executed.or -1 if no commands were executed.
 * @exception KernelException If the target file cannot be overwrittenor write-to-file throw any exception.
 */
protected int _generateCode(StringBuffer code) throws KernelException {
  long startTime=new Date().getTime();
  long overallStartTime=startTime;
  StringBuffer codeMainH=new StringBuffer();
  StringBuffer codeTypesH=new StringBuffer();
  StringBuffer codeTypesC=new StringBuffer();
  _reset();
  _sanitizedModelName=CodeGeneratorAdapter.generateName(_model);
  _analyzeTypeConversions();
  startTime=_printTimeAndMemory(startTime,""String_Node_Str"");
  String directory=codeDirectory.stringValue();
  if (!directory.endsWith(""String_Node_Str""))   directory+=""String_Node_Str"";
  String directorySrc=directory + ""String_Node_Str"";
  String directoryIncludes=directory + ""String_Node_Str"";
  String directoryBuild=directory + ""String_Node_Str"";
  _deleteDirectory(directorySrc);
  if (!_includes.contains(""String_Node_Str"" + directoryIncludes))   _includes.add(""String_Node_Str"" + directoryIncludes);
  if (new File(directorySrc).mkdirs() && new File(directoryIncludes).mkdirs() && new File(directoryBuild).mkdirs()) {
    directory+=""String_Node_Str"";
  }
  CompositeActor container=(CompositeActor)getContainer();
  String sanitizedNameContainer=CodeGeneratorAdapter.generateName(container);
  _generateAndWriteCompositeActorCode(container,""String_Node_Str"");
  String sharedCode=_generateSharedCode();
  String declareSharedCode=_generateDeclareSharedCode();
  String[] typeResolutionCode=generateTypeConvertCodeCandH();
  startTime=_printTimeAndMemory(startTime,""String_Node_Str"");
  code.append(generateCopyright());
  codeMainH.append(generateCopyright());
  codeTypesH.append(generateCopyright());
  codeTypesC.append(generateCopyright());
  codeMainH.append(""String_Node_Str"" + _sanitizedModelName.toUpperCase() + ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _sanitizedModelName.toUpperCase()+ ""String_Node_Str""+ _eol);
  codeMainH.append(_eol + ""String_Node_Str"" + _sanitizedModelName+ ""String_Node_Str"");
  codeMainH.append(_eol + ""String_Node_Str"" + sanitizedNameContainer+ ""String_Node_Str"");
  code.append(_eol + ""String_Node_Str"" + _sanitizedModelName+ ""String_Node_Str"");
  if (((BooleanToken)measureTime.getToken()).booleanValue()) {
    code.append(_eol + ""String_Node_Str"");
    code.append(_eol + ""String_Node_Str"");
  }
  codeMainH.append(_eol + _eol + ""String_Node_Str"");
  code.append(generateMainEntryCode());
  code.append(generateMainExitCode());
  codeMainH.append(_eol + ""String_Node_Str"");
  codeMainH.append(_eol + ""String_Node_Str"");
  code.append(_eol + ""String_Node_Str"");
  code.append(_eol + ""String_Node_Str"");
  code.append(_eol + ""String_Node_Str"" + sanitizedNameContainer+ ""String_Node_Str"");
  code.append(_eol + sanitizedNameContainer + ""String_Node_Str"");
  code.append(_eol + ""String_Node_Str"");
  codeMainH.append(generateInitializeProcedureName());
  code.append(generateInitializeEntryCode());
  code.append(_eol + ""String_Node_Str"");
  code.append(_eol + sanitizedNameContainer + ""String_Node_Str""+ _eol);
  code.append(generateInitializeExitCode());
  codeMainH.append(_eol + ""String_Node_Str"");
  code.append(_eol + ""String_Node_Str"");
  code.append(_eol + ""String_Node_Str"");
  code.append(_eol + ""String_Node_Str"");
  code.append(_eol + ""String_Node_Str"" + sanitizedNameContainer+ ""String_Node_Str"");
  code.append(_eol + sanitizedNameContainer + ""String_Node_Str"");
  code.append(_eol + ""String_Node_Str"" + sanitizedNameContainer+ ""String_Node_Str"");
  code.append(_eol + ""String_Node_Str"");
  code.append(_eol + ""String_Node_Str"");
  code.append(_eol + ""String_Node_Str"");
  codeMainH.append(generateWrapupProcedureName());
  code.append(generateWrapupEntryCode());
  code.append(_eol + sanitizedNameContainer + ""String_Node_Str"");
  code.append(generateWrapupExitCode());
  codeMainH.append(_eol + ""String_Node_Str"");
  codeTypesH.append(""String_Node_Str"" + _sanitizedModelName.toUpperCase() + ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _sanitizedModelName.toUpperCase()+ ""String_Node_Str""+ _eol);
  codeTypesH.append(_eol + typeResolutionCode[0]);
  typeResolutionCode[0]=null;
  codeTypesH.append(comment(""String_Node_Str""));
  codeTypesC.append(typeResolutionCode[1]);
  typeResolutionCode[1]=null;
  codeTypesC.append(comment(""String_Node_Str""));
  codeTypesC.append(sharedCode);
  sharedCode=null;
  codeTypesH.append(declareSharedCode);
  declareSharedCode=null;
  codeTypesH.append(comment(""String_Node_Str""));
  codeTypesH.append(""String_Node_Str"");
  startTime=_printTimeAndMemory(startTime,""String_Node_Str"");
  code=_finalPassOverCode(code);
  codeMainH=_finalPassOverCode(codeMainH);
  codeTypesH=_finalPassOverCode(codeTypesH);
  codeTypesC=_finalPassOverCode(codeTypesC);
  startTime=_printTimeAndMemory(startTime,""String_Node_Str"");
  _writeCodeFileName(code,_sanitizedModelName + ""String_Node_Str"",true,false);
  _writeCodeFileName(codeMainH,""String_Node_Str"" + _sanitizedModelName + ""String_Node_Str"",true,false);
  _writeCodeFileName(codeTypesH,""String_Node_Str"" + _sanitizedModelName + ""String_Node_Str"",true,false);
  _writeCodeFileName(codeTypesC,""String_Node_Str"" + _sanitizedModelName + ""String_Node_Str"",true,false);
  _copyCFileTosrc(""String_Node_Str"",directoryIncludes,""String_Node_Str"");
  _copyCFileTosrc(""String_Node_Str"",directorySrc,""String_Node_Str"");
  _copyCFileTosrc(""String_Node_Str"",directoryIncludes,""String_Node_Str"");
  _copyCFileTosrc(""String_Node_Str"",directorySrc,""String_Node_Str"");
  _copyCFileTosrc(""String_Node_Str"",directoryIncludes,""String_Node_Str"");
  _copyCFileTosrc(""String_Node_Str"",directorySrc,""String_Node_Str"");
  _copyCFileTosrc(""String_Node_Str"",directorySrc,""String_Node_Str"");
  _copyCFileTosrc(""String_Node_Str"",directoryIncludes,""String_Node_Str"");
  _copyCFileTosrc(""String_Node_Str"",directorySrc,""String_Node_Str"");
  _copyCFileTosrc(""String_Node_Str"",directoryIncludes,""String_Node_Str"");
  _copyCFileTosrc(""String_Node_Str"",directoryIncludes,""String_Node_Str"");
  _copyCFileTosrc(""String_Node_Str"",directoryIncludes,""String_Node_Str"");
  _copyCFileTosrc(""String_Node_Str"",directorySrc,""String_Node_Str"");
  _copyCFileTosrc(""String_Node_Str"",directoryIncludes,""String_Node_Str"");
  _copyCFileTosrc(""String_Node_Str"",directorySrc,""String_Node_Str"");
  code=null;
  codeMainH=null;
  codeTypesH=null;
  codeTypesC=null;
  _writeMakefile(container,directory);
  _printTimeAndMemory(startTime,""String_Node_Str"");
  if (_executeCommands == null) {
    _executeCommands=new StreamExec();
  }
  _printTimeAndMemory(overallStartTime,""String_Node_Str"");
  return _executeCommands();
}"
72913,"public String generateInitializeCode() throws IllegalActionException {
  CodeStream codeStream=_templateParser.getCodeStream();
  codeStream.clear();
  LinkedList args=new LinkedList();
  Parameter stopTime=((ptolemy.actor.lib.DiscreteClock)getComponent()).stopTime;
  double doubleStopTime=((DoubleToken)stopTime.getToken()).doubleValue();
  ptolemy.actor.lib.DiscreteClock actor=(ptolemy.actor.lib.DiscreteClock)getComponent();
  ptolemy.actor.CompositeActor container=(ptolemy.actor.CompositeActor)actor.getContainer();
  ptolemy.actor.Director director=container.getDirector();
  double modelStopTime=director.getModelStopTime().getDoubleValue();
  if (doubleStopTime > modelStopTime)   doubleStopTime=modelStopTime;
  Parameter period=((ptolemy.actor.lib.DiscreteClock)getComponent()).period;
  double doublePeriod=((DoubleToken)period.getToken()).doubleValue();
  args.add(Double.toString(doubleStopTime));
  args.add(Double.toString(doublePeriod));
  Parameter offsetPar=((ptolemy.actor.lib.DiscreteClock)getComponent()).offsets;
  Token offsetToken=offsetPar.getToken();
  Token[] offsets;
  double[] offsetsDouble=null;
  int size=0;
  if (offsetToken instanceof ArrayToken) {
    offsets=((ArrayToken)offsetToken).arrayValue();
    size=offsets.length;
    args.add(Integer.toString(size));
    int i=0;
    if (size > 0) {
      if (offsets[0] instanceof DoubleToken) {
        offsetsDouble=new double[size];
      }
 else {
        throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
      }
    }
    for (    Token t : offsets) {
      if (t instanceof DoubleToken) {
        offsetsDouble[i++]=((DoubleToken)t).doubleValue();
      }
 else {
        throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
      }
    }
  }
 else {
    throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
  }
  StringBuffer offsetsString=new StringBuffer();
  int i=0;
  for (  double offset : offsetsDouble)   offsetsString.append(""String_Node_Str"" + i++ + ""String_Node_Str""+ Double.toString(offset)+ ""String_Node_Str""+ _eol);
  args.add(offsetsString);
  Parameter valuesPar=((ptolemy.actor.lib.DiscreteClock)getComponent()).values;
  Token valuesToken=valuesPar.getToken();
  Token[] values;
  double[] valuesDouble=null;
  int[] valuesInt=null;
  boolean[] valuesBool=null;
  size=0;
  if (valuesToken instanceof ArrayToken) {
    values=((ArrayToken)valuesToken).arrayValue();
    size=values.length;
    args.add(Integer.toString(size));
    i=0;
    if (size > 0) {
      if (values[0] instanceof DoubleToken) {
        valuesDouble=new double[size];
      }
 else       if (values[0] instanceof IntToken) {
        valuesInt=new int[size];
      }
 else       if (values[0] instanceof BooleanToken) {
        valuesBool=new boolean[size];
      }
 else {
        throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
      }
    }
    for (    Token t : values) {
      if (t instanceof DoubleToken) {
        valuesDouble[i++]=((DoubleToken)t).doubleValue();
      }
 else       if (t instanceof IntToken) {
        valuesInt[i++]=((IntToken)t).intValue();
      }
 else       if (t instanceof BooleanToken) {
        valuesBool[i++]=((BooleanToken)t).booleanValue();
      }
 else {
        throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
      }
    }
  }
 else {
    throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
  }
  String valuesString=""String_Node_Str"";
  i=0;
  if (valuesDouble != null)   for (  double value : valuesDouble)   valuesString+=""String_Node_Str"" + i++ + ""String_Node_Str""+ Double.toString(value)+ ""String_Node_Str"";
 else   if (valuesInt != null)   for (  int value : valuesInt)   valuesString+=""String_Node_Str"" + i++ + ""String_Node_Str""+ Integer.toString(value)+ ""String_Node_Str"";
 else   if (valuesBool != null)   for (  boolean value : valuesBool)   valuesString+=""String_Node_Str"" + i++ + ""String_Node_Str""+ Boolean.toString(value)+ ""String_Node_Str"";
  args.add(valuesString);
  codeStream.appendCodeBlock(""String_Node_Str"",args);
  if (((ptolemy.actor.lib.DiscreteClock)getComponent()).start.isOutsideConnected()) {
    codeStream.appendCodeBlock(""String_Node_Str"");
  }
  return processCode(codeStream.toString());
}","public String generateInitializeCode() throws IllegalActionException {
  CodeStream codeStream=_templateParser.getCodeStream();
  codeStream.clear();
  LinkedList args=new LinkedList();
  Parameter stopTime=((ptolemy.actor.lib.DiscreteClock)getComponent()).stopTime;
  double doubleStopTime=((DoubleToken)stopTime.getToken()).doubleValue();
  ptolemy.actor.lib.DiscreteClock actor=(ptolemy.actor.lib.DiscreteClock)getComponent();
  ptolemy.actor.CompositeActor container=(ptolemy.actor.CompositeActor)actor.getContainer();
  ptolemy.actor.Director director=container.getDirector();
  double modelStopTime=director.getModelStopTime().getDoubleValue();
  if (doubleStopTime > modelStopTime)   doubleStopTime=modelStopTime;
  Parameter period=((ptolemy.actor.lib.DiscreteClock)getComponent()).period;
  double doublePeriod=((DoubleToken)period.getToken()).doubleValue();
  args.add(Double.toString(doubleStopTime));
  args.add(Double.toString(doublePeriod));
  Parameter offsetPar=((ptolemy.actor.lib.DiscreteClock)getComponent()).offsets;
  Token offsetToken=offsetPar.getToken();
  Token[] offsets;
  double[] offsetsDouble=null;
  int size=0;
  if (offsetToken instanceof ArrayToken) {
    offsets=((ArrayToken)offsetToken).arrayValue();
    size=offsets.length;
    args.add(Integer.toString(size));
    int i=0;
    if (size > 0) {
      if (offsets[0] instanceof DoubleToken) {
        offsetsDouble=new double[size];
      }
 else {
        throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
      }
    }
    for (    Token t : offsets) {
      if (t instanceof DoubleToken) {
        offsetsDouble[i++]=((DoubleToken)t).doubleValue();
      }
 else {
        throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
      }
    }
  }
 else {
    throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
  }
  StringBuffer offsetsString=new StringBuffer();
  int i=0;
  for (  double offset : offsetsDouble)   offsetsString.append(""String_Node_Str"" + i++ + ""String_Node_Str""+ Double.toString(offset)+ ""String_Node_Str"");
  args.add(offsetsString.toString());
  Parameter valuesPar=((ptolemy.actor.lib.DiscreteClock)getComponent()).values;
  Token valuesToken=valuesPar.getToken();
  Token[] values;
  double[] valuesDouble=null;
  int[] valuesInt=null;
  boolean[] valuesBool=null;
  size=0;
  if (valuesToken instanceof ArrayToken) {
    values=((ArrayToken)valuesToken).arrayValue();
    size=values.length;
    args.add(Integer.toString(size));
    i=0;
    if (size > 0) {
      if (values[0] instanceof DoubleToken) {
        valuesDouble=new double[size];
      }
 else       if (values[0] instanceof IntToken) {
        valuesInt=new int[size];
      }
 else       if (values[0] instanceof BooleanToken) {
        valuesBool=new boolean[size];
      }
 else {
        throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
      }
    }
    for (    Token t : values) {
      if (t instanceof DoubleToken) {
        valuesDouble[i++]=((DoubleToken)t).doubleValue();
      }
 else       if (t instanceof IntToken) {
        valuesInt[i++]=((IntToken)t).intValue();
      }
 else       if (t instanceof BooleanToken) {
        valuesBool[i++]=((BooleanToken)t).booleanValue();
      }
 else {
        throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
      }
    }
  }
 else {
    throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
  }
  String valuesString=""String_Node_Str"";
  i=0;
  if (valuesDouble != null)   for (  double value : valuesDouble)   valuesString+=""String_Node_Str"" + i++ + ""String_Node_Str""+ Double.toString(value)+ ""String_Node_Str"";
 else   if (valuesInt != null)   for (  int value : valuesInt)   valuesString+=""String_Node_Str"" + i++ + ""String_Node_Str""+ Integer.toString(value)+ ""String_Node_Str"";
 else   if (valuesBool != null)   for (  boolean value : valuesBool)   valuesString+=""String_Node_Str"" + i++ + ""String_Node_Str""+ Boolean.toString(value)+ ""String_Node_Str"";
  args.add(valuesString);
  codeStream.appendCodeBlock(""String_Node_Str"",args);
  if (((ptolemy.actor.lib.DiscreteClock)getComponent()).start.isOutsideConnected()) {
    codeStream.appendCodeBlock(""String_Node_Str"");
  }
  return processCode(codeStream.toString());
}"
72914,"public String generateInitializeCode() throws IllegalActionException {
  CodeStream codeStream=_templateParser.getCodeStream();
  codeStream.clear();
  LinkedList args=new LinkedList();
  Parameter stopTime=((ptolemy.actor.lib.PoissonClock)getComponent()).stopTime;
  double doubleStopTime=((DoubleToken)stopTime.getToken()).doubleValue();
  ptolemy.actor.lib.PoissonClock actor=(ptolemy.actor.lib.PoissonClock)getComponent();
  ptolemy.actor.CompositeActor container=(ptolemy.actor.CompositeActor)actor.getContainer();
  ptolemy.actor.Director director=container.getDirector();
  double modelStopTime=director.getModelStopTime().getDoubleValue();
  if (doubleStopTime > modelStopTime)   doubleStopTime=modelStopTime;
  Parameter meanTime=((ptolemy.actor.lib.PoissonClock)getComponent()).meanTime;
  double doubleMeanTime=((DoubleToken)meanTime.getToken()).doubleValue();
  Parameter fireAtStart=((ptolemy.actor.lib.PoissonClock)getComponent()).fireAtStart;
  boolean boolFireAtStart=((BooleanToken)fireAtStart.getToken()).booleanValue();
  args.add(Double.toString(doubleStopTime));
  args.add(Double.toString(doubleMeanTime));
  args.add(Boolean.toString(boolFireAtStart));
  Parameter valuesPar=((ptolemy.actor.lib.PoissonClock)getComponent()).values;
  Token valuesToken=valuesPar.getToken();
  Token[] values;
  double[] valuesDouble=null;
  int[] valuesInt=null;
  int size=0;
  if (valuesToken instanceof ArrayToken) {
    values=((ArrayToken)valuesToken).arrayValue();
    size=values.length;
    args.add(Integer.toString(size));
    int i=0;
    if (size > 0) {
      if (values[0] instanceof DoubleToken) {
        valuesDouble=new double[size];
      }
 else       if (values[0] instanceof IntToken) {
        valuesInt=new int[size];
      }
 else {
        throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
      }
    }
    for (    Token t : values) {
      if (t instanceof DoubleToken) {
        valuesDouble[i++]=((DoubleToken)t).doubleValue();
      }
 else       if (t instanceof IntToken) {
        valuesInt[i++]=((IntToken)t).intValue();
      }
 else {
        throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
      }
    }
  }
 else {
    throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
  }
  StringBuffer valuesString=new StringBuffer();
  int i=0;
  if (valuesDouble != null)   for (  double value : valuesDouble)   valuesString.append(""String_Node_Str"" + i++ + ""String_Node_Str""+ Double.toString(value)+ ""String_Node_Str""+ _eol);
 else   if (valuesInt != null)   for (  int value : valuesInt)   valuesString.append(""String_Node_Str"" + i++ + ""String_Node_Str""+ Integer.toString(value)+ ""String_Node_Str""+ _eol);
  args.add(valuesString);
  long longPrivateSeed=0;
  Parameter privateSeed=((ptolemy.actor.lib.PoissonClock)getComponent()).privateSeed;
  if (privateSeed.getToken() instanceof LongToken)   longPrivateSeed=((LongToken)privateSeed.getToken()).longValue();
  args.add(Long.toString(longPrivateSeed));
  long longSeed=0;
  Parameter seed=((ptolemy.actor.lib.PoissonClock)getComponent()).seed;
  if (seed.getToken() instanceof LongToken)   longSeed=((LongToken)seed.getToken()).longValue() + ((ptolemy.actor.lib.PoissonClock)getComponent()).getFullName().hashCode();
  args.add(Long.toString(longSeed));
  codeStream.appendCodeBlock(""String_Node_Str"",args);
  return processCode(codeStream.toString());
}","public String generateInitializeCode() throws IllegalActionException {
  CodeStream codeStream=_templateParser.getCodeStream();
  codeStream.clear();
  LinkedList args=new LinkedList();
  Parameter stopTime=((ptolemy.actor.lib.PoissonClock)getComponent()).stopTime;
  double doubleStopTime=((DoubleToken)stopTime.getToken()).doubleValue();
  ptolemy.actor.lib.PoissonClock actor=(ptolemy.actor.lib.PoissonClock)getComponent();
  ptolemy.actor.CompositeActor container=(ptolemy.actor.CompositeActor)actor.getContainer();
  ptolemy.actor.Director director=container.getDirector();
  double modelStopTime=director.getModelStopTime().getDoubleValue();
  if (doubleStopTime > modelStopTime)   doubleStopTime=modelStopTime;
  Parameter meanTime=((ptolemy.actor.lib.PoissonClock)getComponent()).meanTime;
  double doubleMeanTime=((DoubleToken)meanTime.getToken()).doubleValue();
  Parameter fireAtStart=((ptolemy.actor.lib.PoissonClock)getComponent()).fireAtStart;
  boolean boolFireAtStart=((BooleanToken)fireAtStart.getToken()).booleanValue();
  args.add(Double.toString(doubleStopTime));
  args.add(Double.toString(doubleMeanTime));
  args.add(Boolean.toString(boolFireAtStart));
  Parameter valuesPar=((ptolemy.actor.lib.PoissonClock)getComponent()).values;
  Token valuesToken=valuesPar.getToken();
  Token[] values;
  double[] valuesDouble=null;
  int[] valuesInt=null;
  int size=0;
  if (valuesToken instanceof ArrayToken) {
    values=((ArrayToken)valuesToken).arrayValue();
    size=values.length;
    args.add(Integer.toString(size));
    int i=0;
    if (size > 0) {
      if (values[0] instanceof DoubleToken) {
        valuesDouble=new double[size];
      }
 else       if (values[0] instanceof IntToken) {
        valuesInt=new int[size];
      }
 else {
        throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
      }
    }
    for (    Token t : values) {
      if (t instanceof DoubleToken) {
        valuesDouble[i++]=((DoubleToken)t).doubleValue();
      }
 else       if (t instanceof IntToken) {
        valuesInt[i++]=((IntToken)t).intValue();
      }
 else {
        throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
      }
    }
  }
 else {
    throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
  }
  StringBuffer valuesString=new StringBuffer();
  int i=0;
  if (valuesDouble != null)   for (  double value : valuesDouble)   valuesString.append(""String_Node_Str"" + i++ + ""String_Node_Str""+ Double.toString(value)+ ""String_Node_Str"");
 else   if (valuesInt != null)   for (  int value : valuesInt)   valuesString.append(""String_Node_Str"" + i++ + ""String_Node_Str""+ Integer.toString(value)+ ""String_Node_Str"");
  args.add(valuesString);
  long longPrivateSeed=0;
  Parameter privateSeed=((ptolemy.actor.lib.PoissonClock)getComponent()).privateSeed;
  if (privateSeed.getToken() instanceof LongToken)   longPrivateSeed=((LongToken)privateSeed.getToken()).longValue();
  args.add(Long.toString(longPrivateSeed));
  long longSeed=0;
  Parameter seed=((ptolemy.actor.lib.PoissonClock)getComponent()).seed;
  if (seed.getToken() instanceof LongToken)   longSeed=((LongToken)seed.getToken()).longValue() + ((ptolemy.actor.lib.PoissonClock)getComponent()).getFullName().hashCode();
  args.add(Long.toString(longSeed));
  codeStream.appendCodeBlock(""String_Node_Str"",args);
  return processCode(codeStream.toString());
}"
72915,"/** 
 * In this function we generate the code for the construction of the receivers within the C Code. It generates the calls to RemoteReceiverSet and RemoteFarReceiverSet recursively.
 * @return The generated code.
 * @exception IllegalActionException If thrown while appending to thethe block or processing the macros.
 */
public String generateConstructorReceiversFunction() throws IllegalActionException {
  CodeStream codeStream=_templateParser.getCodeStream();
  codeStream.clear();
  LinkedList args=new LinkedList();
  ptolemy.actor.CompositeActor TopActor=(ptolemy.actor.CompositeActor)getComponent();
  String sanitizedContainerName=CodeGeneratorAdapter.generateName(TopActor);
  String sanitizedContainerNameForArgs=""String_Node_Str"" + sanitizedContainerName + ""String_Node_Str"";
  codeStream.append(_eol + ""String_Node_Str"" + sanitizedContainerName+ ""String_Node_Str""+ _eol);
  List inputPortList=TopActor.inputPortList();
  List outputPortList=TopActor.outputPortList();
  Iterator<?> ports=inputPortList.iterator();
  int i=0;
  while (ports.hasNext()) {
    TypedIOPort port=(TypedIOPort)ports.next();
    if (!port.isOutsideConnected())     continue;
    Receiver[][] farReceivers=port.getRemoteReceivers();
    for (int j=0; j < farReceivers.length; j++) {
      args.clear();
      args.add(sanitizedContainerNameForArgs);
      args.add(Integer.toString(i));
      args.add(Integer.toString(j));
      codeStream.appendCodeBlock(""String_Node_Str"",args,true);
    }
    Receiver[][] receivers=port.deepGetReceivers();
    int cpt=0;
    for (int j=0; j < receivers.length; j++) {
      for (int k=0; k < receivers[j].length; k++) {
        Receiver r=receivers[j][k];
        if (r.getContainer().getContainer() instanceof ModalController) {
          continue;
        }
        args.clear();
        args.add(sanitizedContainerNameForArgs);
        args.add(Integer.toString(i));
        args.add(Integer.toString(cpt++));
        String farActorName=CodeGeneratorAdapter.generateName(r.getContainer().getContainer());
        String farActorNameForArgs=farActorName;
        if (r.getContainer().getContainer() instanceof CompositeActor)         farActorNameForArgs=""String_Node_Str"" + farActorName + ""String_Node_Str"";
        args.add(farActorName);
        args.add(farActorNameForArgs);
        args.add(r.getContainer().getName());
        int farChannelNumber=r.getContainer().getChannelForReceiver(r);
        args.add(Integer.toString(farChannelNumber));
        codeStream.appendCodeBlock(""String_Node_Str"",args,true);
      }
    }
    i++;
  }
  ports=outputPortList.iterator();
  while (ports.hasNext()) {
    TypedIOPort port=(TypedIOPort)ports.next();
    if (!port.isOutsideConnected())     continue;
    Receiver[][] farReceivers=port.getRemoteReceivers();
    String enumFarReceivers=_eol + ""String_Node_Str"";
    int channel=0;
    for (int k=0; k < farReceivers.length; k++) {
      if (TopActor instanceof ptolemy.cg.lib.CompiledCompositeActor)       break;
      for (int j=0; j < farReceivers[k].length; j++) {
        Receiver r=farReceivers[k][j];
        if (r.getContainer().getContainer() instanceof ModalController) {
          continue;
        }
        args.clear();
        args.add(sanitizedContainerNameForArgs);
        args.add(Integer.toString(i));
        args.add(Integer.toString(channel++));
        NamedObj farActor=r.getContainer().getContainer();
        String farActorName=CodeGeneratorAdapter.generateName(farActor);
        String farActorNameForArgs;
        if (farActor instanceof CompositeActor)         farActorNameForArgs=""String_Node_Str"" + farActorName + ""String_Node_Str"";
 else         farActorNameForArgs=farActorName;
        args.add(farActorName);
        args.add(farActorNameForArgs);
        args.add(r.getContainer().getName());
        int farChannelNumber=r.getContainer().getChannelForReceiver(r);
        args.add(Integer.toString(farChannelNumber));
        codeStream.appendCodeBlock(""String_Node_Str"",args,true);
        enumFarReceivers+=sanitizedContainerName + ""String_Node_Str"" + port.getName()+ ""String_Node_Str""+ farActorName+ ""String_Node_Str""+ r.getContainer().getName()+ ""String_Node_Str""+ farChannelNumber+ ""String_Node_Str"";
      }
    }
    if (enumFarReceivers.length() > 7) {
      enumFarReceivers=enumFarReceivers.substring(0,enumFarReceivers.length() - 2);
      enumFarReceivers+=""String_Node_Str"" + _eol;
      _enumPortNumbersDefinition+=enumFarReceivers;
    }
    Receiver[][] insideReceivers=port.getInsideReceivers();
    for (int j=0; j < insideReceivers.length; j++) {
      args.clear();
      args.add(sanitizedContainerNameForArgs);
      args.add(Integer.toString(i));
      args.add(Integer.toString(j));
      codeStream.appendCodeBlock(""String_Node_Str"",args,true);
    }
    i++;
  }
  List actorList=TopActor.deepEntityList();
  Iterator<?> actors=actorList.iterator();
  actors=actorList.iterator();
  while (actors.hasNext()) {
    NamedObj actor=(NamedObj)actors.next();
    String sanitizedActorName=CodeGeneratorAdapter.generateName(actor);
    Actor act=(Actor)actor;
    if (act instanceof CompositeActor) {
      codeStream.append(_eol + sanitizedActorName + ""String_Node_Str"");
      continue;
    }
    if (act instanceof ModalController) {
      continue;
    }
    args.clear();
    inputPortList=act.inputPortList();
    outputPortList=act.outputPortList();
    ports=inputPortList.iterator();
    i=0;
    while (ports.hasNext()) {
      TypedIOPort port=(TypedIOPort)ports.next();
      if (!port.isOutsideConnected())       continue;
      Receiver[][] farReceivers=port.getRemoteReceivers();
      for (int j=0; j < farReceivers.length; j++) {
        args.clear();
        args.add(sanitizedActorName);
        args.add(Integer.toString(i));
        args.add(Integer.toString(j));
        codeStream.appendCodeBlock(""String_Node_Str"",args,true);
      }
      if (act instanceof CompositeActor) {
        Receiver[][] insideReceivers=port.getInsideReceivers();
        int cpt=0;
        for (int j=0; j < insideReceivers.length; j++) {
          for (int k=0; k < insideReceivers[j].length; k++) {
            Receiver r=insideReceivers[j][k];
            args.clear();
            args.add(sanitizedActorName);
            args.add(Integer.toString(i));
            args.add(Integer.toString(cpt++));
            String farActorName=CodeGeneratorAdapter.generateName(r.getContainer().getContainer());
            String farActorNameForArgs=""String_Node_Str"" + farActorName + ""String_Node_Str"";
            args.add(farActorName);
            args.add(farActorNameForArgs);
            args.add(r.getContainer().getName());
            int farChannelNumber=r.getContainer().getChannelForReceiver(r);
            args.add(Integer.toString(farChannelNumber));
            codeStream.appendCodeBlock(""String_Node_Str"",args,true);
          }
        }
      }
      i++;
    }
    ports=outputPortList.iterator();
    while (ports.hasNext()) {
      TypedIOPort port=(TypedIOPort)ports.next();
      if (!port.isOutsideConnected())       continue;
      Receiver[][] farReceivers=port.getRemoteReceivers();
      String enumFarReceivers=_eol + ""String_Node_Str"";
      int channel=0;
      for (int k=0; k < farReceivers.length; k++) {
        if (farReceivers[k] == null)         continue;
        for (int j=0; j < farReceivers[k].length; j++) {
          Receiver r=farReceivers[k][j];
          args.clear();
          args.add(sanitizedActorName);
          args.add(Integer.toString(i));
          args.add(Integer.toString(channel++));
          NamedObj farActor=r.getContainer().getContainer();
          String farActorName=CodeGeneratorAdapter.generateName(farActor);
          String farActorNameForArgs;
          if (farActor instanceof CompositeActor)           farActorNameForArgs=""String_Node_Str"" + farActorName + ""String_Node_Str"";
 else           farActorNameForArgs=farActorName;
          args.add(farActorName);
          args.add(farActorNameForArgs);
          args.add(r.getContainer().getName());
          int farChannelNumber=r.getContainer().getChannelForReceiver(r);
          args.add(Integer.toString(farChannelNumber));
          codeStream.appendCodeBlock(""String_Node_Str"",args,true);
          enumFarReceivers+=sanitizedActorName + ""String_Node_Str"" + port.getName()+ ""String_Node_Str""+ farActorName+ ""String_Node_Str""+ r.getContainer().getName()+ ""String_Node_Str""+ farChannelNumber+ ""String_Node_Str"";
        }
      }
      if (enumFarReceivers.length() > 7) {
        enumFarReceivers=enumFarReceivers.substring(0,enumFarReceivers.length() - 2);
        enumFarReceivers+=""String_Node_Str"" + _eol;
        _enumPortNumbersDefinition+=enumFarReceivers;
      }
      if (act instanceof CompositeActor) {
        Receiver[][] insideReceivers=port.getInsideReceivers();
        for (int j=0; j < insideReceivers.length; j++) {
          args.clear();
          args.add(sanitizedActorName);
          args.add(Integer.toString(i));
          args.add(Integer.toString(j));
          codeStream.appendCodeBlock(""String_Node_Str"",args,true);
        }
      }
      i++;
    }
  }
  codeStream.append(_eol + ""String_Node_Str"" + _eol);
  return codeStream.toString();
}","/** 
 * In this function we generate the code for the construction of the receivers within the C Code. It generates the calls to RemoteReceiverSet and RemoteFarReceiverSet recursively.
 * @return The generated code.
 * @exception IllegalActionException If thrown while appending to thethe block or processing the macros.
 */
public String generateConstructorReceiversFunction() throws IllegalActionException {
  CodeStream codeStream=_templateParser.getCodeStream();
  codeStream.clear();
  LinkedList args=new LinkedList();
  ptolemy.actor.CompositeActor TopActor=(ptolemy.actor.CompositeActor)getComponent();
  String sanitizedContainerName=CodeGeneratorAdapter.generateName(TopActor);
  String sanitizedContainerNameForArgs=""String_Node_Str"" + sanitizedContainerName + ""String_Node_Str"";
  codeStream.append(_eol + ""String_Node_Str"" + sanitizedContainerName+ ""String_Node_Str""+ _eol);
  List inputPortList=TopActor.inputPortList();
  List outputPortList=TopActor.outputPortList();
  Iterator<?> ports=inputPortList.iterator();
  int i=0;
  while (ports.hasNext()) {
    TypedIOPort port=(TypedIOPort)ports.next();
    if (!port.isOutsideConnected())     continue;
    Receiver[][] farReceivers=port.getRemoteReceivers();
    for (int j=0; j < farReceivers.length; j++) {
      args.clear();
      args.add(sanitizedContainerNameForArgs);
      args.add(Integer.toString(i));
      args.add(Integer.toString(j));
      codeStream.appendCodeBlock(""String_Node_Str"",args,true);
    }
    Receiver[][] receivers=port.deepGetReceivers();
    int cpt=0;
    for (int j=0; j < receivers.length; j++) {
      for (int k=0; k < receivers[j].length; k++) {
        Receiver r=receivers[j][k];
        if (r.getContainer().getContainer() instanceof ModalController) {
          continue;
        }
        args.clear();
        args.add(sanitizedContainerNameForArgs);
        args.add(Integer.toString(i));
        args.add(Integer.toString(cpt++));
        String farActorName=CodeGeneratorAdapter.generateName(r.getContainer().getContainer());
        String farActorNameForArgs=farActorName;
        if (r.getContainer().getContainer() instanceof CompositeActor)         farActorNameForArgs=""String_Node_Str"" + farActorName + ""String_Node_Str"";
        args.add(farActorName);
        args.add(farActorNameForArgs);
        args.add(r.getContainer().getName());
        int farChannelNumber=r.getContainer().getChannelForReceiver(r);
        args.add(Integer.toString(farChannelNumber));
        codeStream.appendCodeBlock(""String_Node_Str"",args,true);
      }
    }
    i++;
  }
  ports=outputPortList.iterator();
  while (ports.hasNext()) {
    TypedIOPort port=(TypedIOPort)ports.next();
    if (!port.isOutsideConnected())     continue;
    Receiver[][] farReceivers=port.getRemoteReceivers();
    StringBuffer enumFarReceivers=new StringBuffer(_eol + ""String_Node_Str"");
    int channel=0;
    for (int k=0; k < farReceivers.length; k++) {
      if (TopActor instanceof ptolemy.cg.lib.CompiledCompositeActor)       break;
      for (int j=0; j < farReceivers[k].length; j++) {
        Receiver r=farReceivers[k][j];
        if (r.getContainer().getContainer() instanceof ModalController) {
          continue;
        }
        args.clear();
        args.add(sanitizedContainerNameForArgs);
        args.add(Integer.toString(i));
        args.add(Integer.toString(channel++));
        NamedObj farActor=r.getContainer().getContainer();
        String farActorName=CodeGeneratorAdapter.generateName(farActor);
        String farActorNameForArgs;
        if (farActor instanceof CompositeActor)         farActorNameForArgs=""String_Node_Str"" + farActorName + ""String_Node_Str"";
 else         farActorNameForArgs=farActorName;
        args.add(farActorName);
        args.add(farActorNameForArgs);
        args.add(r.getContainer().getName());
        int farChannelNumber=r.getContainer().getChannelForReceiver(r);
        args.add(Integer.toString(farChannelNumber));
        codeStream.appendCodeBlock(""String_Node_Str"",args,true);
        enumFarReceivers.append(sanitizedContainerName + ""String_Node_Str"" + port.getName()+ ""String_Node_Str""+ farActorName+ ""String_Node_Str""+ r.getContainer().getName()+ ""String_Node_Str""+ farChannelNumber+ ""String_Node_Str"");
      }
    }
    if (enumFarReceivers.length() > 7) {
      enumFarReceivers.delete(enumFarReceivers.length() - 2,enumFarReceivers.length());
      enumFarReceivers.append(""String_Node_Str"" + _eol);
      _enumPortNumbersDefinition+=enumFarReceivers.toString();
    }
    Receiver[][] insideReceivers=port.getInsideReceivers();
    for (int j=0; j < insideReceivers.length; j++) {
      args.clear();
      args.add(sanitizedContainerNameForArgs);
      args.add(Integer.toString(i));
      args.add(Integer.toString(j));
      codeStream.appendCodeBlock(""String_Node_Str"",args,true);
    }
    i++;
  }
  List actorList=TopActor.deepEntityList();
  Iterator<?> actors=actorList.iterator();
  actors=actorList.iterator();
  while (actors.hasNext()) {
    NamedObj actor=(NamedObj)actors.next();
    String sanitizedActorName=CodeGeneratorAdapter.generateName(actor);
    Actor act=(Actor)actor;
    if (act instanceof CompositeActor) {
      codeStream.append(_eol + sanitizedActorName + ""String_Node_Str"");
      continue;
    }
    if (act instanceof ModalController) {
      continue;
    }
    args.clear();
    inputPortList=act.inputPortList();
    outputPortList=act.outputPortList();
    ports=inputPortList.iterator();
    i=0;
    while (ports.hasNext()) {
      TypedIOPort port=(TypedIOPort)ports.next();
      if (!port.isOutsideConnected())       continue;
      Receiver[][] farReceivers=port.getRemoteReceivers();
      for (int j=0; j < farReceivers.length; j++) {
        args.clear();
        args.add(sanitizedActorName);
        args.add(Integer.toString(i));
        args.add(Integer.toString(j));
        codeStream.appendCodeBlock(""String_Node_Str"",args,true);
      }
      if (act instanceof CompositeActor) {
        Receiver[][] insideReceivers=port.getInsideReceivers();
        int cpt=0;
        for (int j=0; j < insideReceivers.length; j++) {
          for (int k=0; k < insideReceivers[j].length; k++) {
            Receiver r=insideReceivers[j][k];
            args.clear();
            args.add(sanitizedActorName);
            args.add(Integer.toString(i));
            args.add(Integer.toString(cpt++));
            String farActorName=CodeGeneratorAdapter.generateName(r.getContainer().getContainer());
            String farActorNameForArgs=""String_Node_Str"" + farActorName + ""String_Node_Str"";
            args.add(farActorName);
            args.add(farActorNameForArgs);
            args.add(r.getContainer().getName());
            int farChannelNumber=r.getContainer().getChannelForReceiver(r);
            args.add(Integer.toString(farChannelNumber));
            codeStream.appendCodeBlock(""String_Node_Str"",args,true);
          }
        }
      }
      i++;
    }
    ports=outputPortList.iterator();
    while (ports.hasNext()) {
      TypedIOPort port=(TypedIOPort)ports.next();
      if (!port.isOutsideConnected())       continue;
      Receiver[][] farReceivers=port.getRemoteReceivers();
      String enumFarReceivers=_eol + ""String_Node_Str"";
      int channel=0;
      for (int k=0; k < farReceivers.length; k++) {
        if (farReceivers[k] == null)         continue;
        for (int j=0; j < farReceivers[k].length; j++) {
          Receiver r=farReceivers[k][j];
          args.clear();
          args.add(sanitizedActorName);
          args.add(Integer.toString(i));
          args.add(Integer.toString(channel++));
          NamedObj farActor=r.getContainer().getContainer();
          String farActorName=CodeGeneratorAdapter.generateName(farActor);
          String farActorNameForArgs;
          if (farActor instanceof CompositeActor)           farActorNameForArgs=""String_Node_Str"" + farActorName + ""String_Node_Str"";
 else           farActorNameForArgs=farActorName;
          args.add(farActorName);
          args.add(farActorNameForArgs);
          args.add(r.getContainer().getName());
          int farChannelNumber=r.getContainer().getChannelForReceiver(r);
          args.add(Integer.toString(farChannelNumber));
          codeStream.appendCodeBlock(""String_Node_Str"",args,true);
          enumFarReceivers+=sanitizedActorName + ""String_Node_Str"" + port.getName()+ ""String_Node_Str""+ farActorName+ ""String_Node_Str""+ r.getContainer().getName()+ ""String_Node_Str""+ farChannelNumber+ ""String_Node_Str"";
        }
      }
      if (enumFarReceivers.length() > 7) {
        enumFarReceivers=enumFarReceivers.substring(0,enumFarReceivers.length() - 2);
        enumFarReceivers+=""String_Node_Str"" + _eol;
        _enumPortNumbersDefinition+=enumFarReceivers;
      }
      if (act instanceof CompositeActor) {
        Receiver[][] insideReceivers=port.getInsideReceivers();
        for (int j=0; j < insideReceivers.length; j++) {
          args.clear();
          args.add(sanitizedActorName);
          args.add(Integer.toString(i));
          args.add(Integer.toString(j));
          codeStream.appendCodeBlock(""String_Node_Str"",args,true);
        }
      }
      i++;
    }
  }
  codeStream.append(_eol + ""String_Node_Str"" + _eol);
  return codeStream.toString();
}"
72916,"/** 
 * In this function we generate the code for the construction of the ports within the C Code. It generates the calls to IOPortSet recursively.
 * @return The generated code.
 * @exception IllegalActionException If thrown while appending to thethe block or processing the macros.
 */
public String generateConstructorPortsFunction() throws IllegalActionException {
  CodeStream codeStream=_templateParser.getCodeStream();
  codeStream.clear();
  LinkedList args=new LinkedList();
  ptolemy.actor.CompositeActor TopActor=(ptolemy.actor.CompositeActor)getComponent();
  String sanitizedContainerName=CodeGeneratorAdapter.generateName(TopActor);
  String sanitizedContainerNameForArgs=""String_Node_Str"" + sanitizedContainerName + ""String_Node_Str"";
  codeStream.append(_eol + ""String_Node_Str"" + sanitizedContainerName+ ""String_Node_Str""+ _eol);
  String enumString=_eol + ""String_Node_Str"";
  List inputPortList=TopActor.inputPortList();
  List outputPortList=TopActor.outputPortList();
  Iterator<?> ports=inputPortList.iterator();
  int j=0;
  while (ports.hasNext()) {
    TypedIOPort port=(TypedIOPort)ports.next();
    if (!port.isOutsideConnected())     continue;
    args.clear();
    args.add(sanitizedContainerNameForArgs);
    args.add(Integer.toString(j++));
    args.add(""String_Node_Str"" + port.getName() + ""String_Node_Str"");
    args.add(""String_Node_Str"" + getCodeGenerator().codeGenType(port.getType()) + ""String_Node_Str"");
    args.add(Boolean.toString(port.isInput()));
    args.add(Boolean.toString(port.isOutput()));
    args.add(Boolean.toString(port.isMultiport()));
    int widthInside=port.getWidthInside();
    int widthOutside=0;
    Receiver[][] receivers=port.deepGetReceivers();
    for (int cpt=0; cpt < receivers.length; cpt++) {
      widthOutside+=receivers[cpt].length;
    }
    args.add(Integer.toString(widthInside));
    args.add(Integer.toString(widthOutside));
    codeStream.appendCodeBlock(""String_Node_Str"",args,true);
    enumString+=""String_Node_Str"" + sanitizedContainerName + ""String_Node_Str""+ port.getName()+ ""String_Node_Str"";
  }
  ports=outputPortList.iterator();
  while (ports.hasNext()) {
    TypedIOPort port=(TypedIOPort)ports.next();
    if (!port.isOutsideConnected())     continue;
    args.clear();
    args.add(sanitizedContainerNameForArgs);
    args.add(Integer.toString(j++));
    args.add(""String_Node_Str"" + port.getName() + ""String_Node_Str"");
    args.add(""String_Node_Str"" + getCodeGenerator().codeGenType(port.getType()) + ""String_Node_Str"");
    args.add(Boolean.toString(port.isInput()));
    args.add(Boolean.toString(port.isOutput()));
    args.add(Boolean.toString(port.isMultiport()));
    args.add(Integer.toString(port.getWidth()));
    int widthOutside=0;
    for (    Receiver[] r : port.getRemoteReceivers()) {
      if (TopActor instanceof ptolemy.cg.lib.CompiledCompositeActor)       break;
      if (r != null)       widthOutside+=r.length;
    }
    args.add(Integer.toString(widthOutside));
    codeStream.appendCodeBlock(""String_Node_Str"",args,true);
    enumString+=""String_Node_Str"" + sanitizedContainerName + ""String_Node_Str""+ port.getName()+ ""String_Node_Str"";
  }
  if (enumString.length() > 7) {
    enumString=enumString.substring(0,enumString.length() - 2);
    enumString+=""String_Node_Str"" + _eol;
    _enumPortNumbersDefinition+=enumString;
  }
  List actorList=TopActor.deepEntityList();
  Iterator<?> actors=actorList.iterator();
  actors=actorList.iterator();
  while (actors.hasNext()) {
    NamedObj actor=(NamedObj)actors.next();
    String sanitizedActorName=CodeGeneratorAdapter.generateName(actor);
    String sanitizedActorNameForArgs=sanitizedActorName;
    Actor act=(Actor)actor;
    if (act instanceof CompositeActor)     codeStream.append(_eol + sanitizedActorName + ""String_Node_Str"");
 else     if (act instanceof ModalController) {
      continue;
    }
 else {
      args.clear();
      enumString=_eol + ""String_Node_Str"";
      inputPortList=act.inputPortList();
      outputPortList=act.outputPortList();
      ports=inputPortList.iterator();
      j=0;
      while (ports.hasNext()) {
        TypedIOPort port=(TypedIOPort)ports.next();
        if (!port.isOutsideConnected())         continue;
        args.clear();
        args.add(sanitizedActorNameForArgs);
        args.add(Integer.toString(j++));
        args.add(""String_Node_Str"" + port.getName() + ""String_Node_Str"");
        args.add(""String_Node_Str"" + getCodeGenerator().codeGenType(port.getType()) + ""String_Node_Str"");
        args.add(Boolean.toString(port.isInput()));
        args.add(Boolean.toString(port.isOutput()));
        args.add(Boolean.toString(port.isMultiport()));
        args.add(Integer.toString(port.getWidth()));
        args.add(Integer.toString(0));
        codeStream.appendCodeBlock(""String_Node_Str"",args,true);
        enumString+=""String_Node_Str"" + sanitizedActorName + ""String_Node_Str""+ port.getName()+ ""String_Node_Str"";
      }
      ports=outputPortList.iterator();
      while (ports.hasNext()) {
        TypedIOPort port=(TypedIOPort)ports.next();
        if (!port.isOutsideConnected())         continue;
        args.clear();
        args.add(sanitizedActorNameForArgs);
        args.add(Integer.toString(j++));
        args.add(""String_Node_Str"" + port.getName() + ""String_Node_Str"");
        args.add(""String_Node_Str"" + getCodeGenerator().codeGenType(port.getType()) + ""String_Node_Str"");
        args.add(Boolean.toString(port.isInput()));
        args.add(Boolean.toString(port.isOutput()));
        args.add(Boolean.toString(port.isMultiport()));
        args.add(Integer.toString(0));
        int widthOutside=0;
        for (        Receiver[] r : port.getRemoteReceivers())         if (r != null)         widthOutside+=r.length;
        args.add(Integer.toString(widthOutside));
        codeStream.appendCodeBlock(""String_Node_Str"",args,true);
        enumString+=""String_Node_Str"" + sanitizedActorName + ""String_Node_Str""+ port.getName()+ ""String_Node_Str"";
      }
      if (enumString.length() > 7) {
        enumString=enumString.substring(0,enumString.length() - 2);
        enumString+=""String_Node_Str"" + _eol;
        _enumPortNumbersDefinition+=enumString;
      }
    }
  }
  codeStream.append(_eol + ""String_Node_Str"" + _eol);
  return codeStream.toString();
}","/** 
 * In this function we generate the code for the construction of the ports within the C Code. It generates the calls to IOPortSet recursively.
 * @return The generated code.
 * @exception IllegalActionException If thrown while appending to thethe block or processing the macros.
 */
public String generateConstructorPortsFunction() throws IllegalActionException {
  CodeStream codeStream=_templateParser.getCodeStream();
  codeStream.clear();
  LinkedList args=new LinkedList();
  ptolemy.actor.CompositeActor TopActor=(ptolemy.actor.CompositeActor)getComponent();
  String sanitizedContainerName=CodeGeneratorAdapter.generateName(TopActor);
  String sanitizedContainerNameForArgs=""String_Node_Str"" + sanitizedContainerName + ""String_Node_Str"";
  codeStream.append(_eol + ""String_Node_Str"" + sanitizedContainerName+ ""String_Node_Str""+ _eol);
  StringBuffer enumString=new StringBuffer(_eol + ""String_Node_Str"");
  List inputPortList=TopActor.inputPortList();
  List outputPortList=TopActor.outputPortList();
  Iterator<?> ports=inputPortList.iterator();
  int j=0;
  while (ports.hasNext()) {
    TypedIOPort port=(TypedIOPort)ports.next();
    if (!port.isOutsideConnected())     continue;
    args.clear();
    args.add(sanitizedContainerNameForArgs);
    args.add(Integer.toString(j++));
    args.add(""String_Node_Str"" + port.getName() + ""String_Node_Str"");
    args.add(""String_Node_Str"" + getCodeGenerator().codeGenType(port.getType()) + ""String_Node_Str"");
    args.add(Boolean.toString(port.isInput()));
    args.add(Boolean.toString(port.isOutput()));
    args.add(Boolean.toString(port.isMultiport()));
    int widthInside=port.getWidthInside();
    int widthOutside=0;
    Receiver[][] receivers=port.deepGetReceivers();
    for (int cpt=0; cpt < receivers.length; cpt++) {
      widthOutside+=receivers[cpt].length;
    }
    args.add(Integer.toString(widthInside));
    args.add(Integer.toString(widthOutside));
    codeStream.appendCodeBlock(""String_Node_Str"",args,true);
    enumString.append(""String_Node_Str"" + sanitizedContainerName + ""String_Node_Str""+ port.getName()+ ""String_Node_Str"");
  }
  ports=outputPortList.iterator();
  while (ports.hasNext()) {
    TypedIOPort port=(TypedIOPort)ports.next();
    if (!port.isOutsideConnected())     continue;
    args.clear();
    args.add(sanitizedContainerNameForArgs);
    args.add(Integer.toString(j++));
    args.add(""String_Node_Str"" + port.getName() + ""String_Node_Str"");
    args.add(""String_Node_Str"" + getCodeGenerator().codeGenType(port.getType()) + ""String_Node_Str"");
    args.add(Boolean.toString(port.isInput()));
    args.add(Boolean.toString(port.isOutput()));
    args.add(Boolean.toString(port.isMultiport()));
    args.add(Integer.toString(port.getWidth()));
    int widthOutside=0;
    for (    Receiver[] r : port.getRemoteReceivers()) {
      if (TopActor instanceof ptolemy.cg.lib.CompiledCompositeActor)       break;
      if (r != null)       widthOutside+=r.length;
    }
    args.add(Integer.toString(widthOutside));
    codeStream.appendCodeBlock(""String_Node_Str"",args,true);
    enumString.append(""String_Node_Str"" + sanitizedContainerName + ""String_Node_Str""+ port.getName()+ ""String_Node_Str"");
  }
  if (enumString.length() > 7) {
    enumString.delete(enumString.length() - 2,enumString.length());
    enumString.append(""String_Node_Str"" + _eol);
    _enumPortNumbersDefinition+=enumString.toString();
  }
  List actorList=TopActor.deepEntityList();
  Iterator<?> actors=actorList.iterator();
  actors=actorList.iterator();
  while (actors.hasNext()) {
    NamedObj actor=(NamedObj)actors.next();
    String sanitizedActorName=CodeGeneratorAdapter.generateName(actor);
    String sanitizedActorNameForArgs=sanitizedActorName;
    Actor act=(Actor)actor;
    if (act instanceof CompositeActor)     codeStream.append(_eol + sanitizedActorName + ""String_Node_Str"");
 else     if (act instanceof ModalController) {
      continue;
    }
 else {
      args.clear();
      enumString=new StringBuffer(_eol + ""String_Node_Str"");
      inputPortList=act.inputPortList();
      outputPortList=act.outputPortList();
      ports=inputPortList.iterator();
      j=0;
      while (ports.hasNext()) {
        TypedIOPort port=(TypedIOPort)ports.next();
        if (!port.isOutsideConnected())         continue;
        args.clear();
        args.add(sanitizedActorNameForArgs);
        args.add(Integer.toString(j++));
        args.add(""String_Node_Str"" + port.getName() + ""String_Node_Str"");
        args.add(""String_Node_Str"" + getCodeGenerator().codeGenType(port.getType()) + ""String_Node_Str"");
        args.add(Boolean.toString(port.isInput()));
        args.add(Boolean.toString(port.isOutput()));
        args.add(Boolean.toString(port.isMultiport()));
        args.add(Integer.toString(port.getWidth()));
        args.add(Integer.toString(0));
        codeStream.appendCodeBlock(""String_Node_Str"",args,true);
        enumString.append(""String_Node_Str"" + sanitizedActorName + ""String_Node_Str""+ port.getName()+ ""String_Node_Str"");
      }
      ports=outputPortList.iterator();
      while (ports.hasNext()) {
        TypedIOPort port=(TypedIOPort)ports.next();
        if (!port.isOutsideConnected())         continue;
        args.clear();
        args.add(sanitizedActorNameForArgs);
        args.add(Integer.toString(j++));
        args.add(""String_Node_Str"" + port.getName() + ""String_Node_Str"");
        args.add(""String_Node_Str"" + getCodeGenerator().codeGenType(port.getType()) + ""String_Node_Str"");
        args.add(Boolean.toString(port.isInput()));
        args.add(Boolean.toString(port.isOutput()));
        args.add(Boolean.toString(port.isMultiport()));
        args.add(Integer.toString(0));
        int widthOutside=0;
        for (        Receiver[] r : port.getRemoteReceivers())         if (r != null)         widthOutside+=r.length;
        args.add(Integer.toString(widthOutside));
        codeStream.appendCodeBlock(""String_Node_Str"",args,true);
        enumString.append(""String_Node_Str"" + sanitizedActorName + ""String_Node_Str""+ port.getName()+ ""String_Node_Str"");
      }
      if (enumString.length() > 7) {
        enumString.delete(enumString.length() - 2,enumString.length());
        enumString.append(""String_Node_Str"" + _eol);
        _enumPortNumbersDefinition+=enumString.toString();
      }
    }
  }
  codeStream.append(_eol + ""String_Node_Str"" + _eol);
  return codeStream.toString();
}"
72917,"/** 
 * Generate the transfer inputs code. This is to ensure compatibility between different directors.
 * @return The generated code.
 * @exception IllegalActionException If thrown while appending to thethe block or processing the macros.
 */
public String generateTransfersCode() throws IllegalActionException {
  CodeStream codeStream=_templateParser.getCodeStream();
  codeStream.clear();
  ptolemy.actor.CompositeActor container=(ptolemy.actor.CompositeActor)getComponent();
  String sanitizedContainerName=CodeGeneratorAdapter.generateName(container);
  Director director=container.getDirector();
  ptolemy.cg.adapter.generic.adapters.ptolemy.actor.Director directorAdapter=(ptolemy.cg.adapter.generic.adapters.ptolemy.actor.Director)getAdapter(director);
  StringBuffer code=new StringBuffer();
  codeStream.append(_eol + ""String_Node_Str"" + sanitizedContainerName+ ""String_Node_Str""+ _eol);
  Iterator<?> inputPorts=container.inputPortList().iterator();
  while (inputPorts.hasNext()) {
    TypedIOPort inputPort=(TypedIOPort)inputPorts.next();
    if (!inputPort.isInsideConnected())     continue;
    if (container instanceof CompiledCompositeActor) {
      directorAdapter.generateTransferInputsCode(inputPort,code);
      codeStream.append(code.toString());
      code=new StringBuffer();
    }
 else {
      Receiver[][] receivers=inputPort.deepGetReceivers();
      for (int channel=0; channel < inputPort.getWidth(); channel++) {
        String hasTokenString=""String_Node_Str"" + sanitizedContainerName + ""String_Node_Str""+ sanitizedContainerName+ ""String_Node_Str""+ inputPort.getName()+ ""String_Node_Str""+ channel+ ""String_Node_Str""+ _eol;
        String getString=""String_Node_Str"" + sanitizedContainerName + ""String_Node_Str""+ sanitizedContainerName+ ""String_Node_Str""+ inputPort.getName()+ ""String_Node_Str""+ channel+ ""String_Node_Str"";
        String putString=_eol + ""String_Node_Str"" + getString+ ""String_Node_Str"";
        if (receivers[channel].length > 1) {
          int foo=0;
          for (int cpt=0; cpt < receivers[channel].length; cpt++) {
            if (!(receivers[channel][cpt].getContainer().getContainer() instanceof ModalController)) {
              putString+=_eol + ""String_Node_Str"" + sanitizedContainerName+ ""String_Node_Str""+ sanitizedContainerName+ ""String_Node_Str""+ inputPort.getName()+ ""String_Node_Str""+ foo+++ ""String_Node_Str"";
            }
          }
        }
 else         putString+=_eol + ""String_Node_Str"" + sanitizedContainerName+ ""String_Node_Str""+ sanitizedContainerName+ ""String_Node_Str""+ inputPort.getName()+ ""String_Node_Str""+ channel+ ""String_Node_Str""+ _eol;
        if (container.getDirector() instanceof ptolemy.domains.modal.kernel.FSMDirector) {
          List actorList=container.deepEntityList();
          Iterator<?> actors=actorList.iterator();
          while (actors.hasNext()) {
            NamedObj actor=(NamedObj)actors.next();
            if (actor instanceof ModalController) {
              String actorName=CodeGeneratorAdapter.generateName(actor);
              String type=inputPort.getType().toString().substring(0,1).toUpperCase() + inputPort.getType().toString().substring(1);
              putString+=_eol + actorName + ""String_Node_Str""+ inputPort.getName()+ ""String_Node_Str""+ type+ ""String_Node_Str""+ _eol;
            }
          }
        }
        String fireAtString=""String_Node_Str"";
        if (container.getDirector() instanceof DEDirector) {
          NamedObj insideActor=inputPort.deepGetReceivers()[channel][0].getContainer().getContainer();
          String sanitizedNameInsideActor=CodeGeneratorAdapter.generateName(insideActor);
          if (insideActor instanceof CompositeActor)           sanitizedNameInsideActor=""String_Node_Str"" + sanitizedNameInsideActor + ""String_Node_Str"";
          fireAtString=_eol + ""String_Node_Str"" + sanitizedContainerName+ ""String_Node_Str""+ sanitizedNameInsideActor+ ""String_Node_Str""+ sanitizedContainerName+ ""String_Node_Str""+ sanitizedContainerName+ ""String_Node_Str""+ _eol;
        }
        codeStream.append(_eol + hasTokenString + putString+ fireAtString+ _eol+ ""String_Node_Str""+ _eol);
      }
    }
  }
  codeStream.append(_eol + ""String_Node_Str"" + _eol);
  codeStream.append(_eol + ""String_Node_Str"" + sanitizedContainerName+ ""String_Node_Str""+ _eol);
  Iterator<?> outputPorts=container.outputPortList().iterator();
  while (outputPorts.hasNext()) {
    TypedIOPort outputPort=(TypedIOPort)outputPorts.next();
    if (!outputPort.isOutsideConnected())     continue;
    if (container instanceof CompiledCompositeActor) {
      directorAdapter.generateTransferOutputsCode(outputPort,code);
      codeStream.append(code.toString());
      code=new StringBuffer();
    }
 else {
      for (int channel=0; channel < outputPort.getWidth(); channel++) {
        String hasTokenString=""String_Node_Str"" + sanitizedContainerName + ""String_Node_Str""+ sanitizedContainerName+ ""String_Node_Str""+ outputPort.getName()+ ""String_Node_Str""+ channel+ ""String_Node_Str""+ _eol;
        String getString=""String_Node_Str"" + sanitizedContainerName + ""String_Node_Str""+ sanitizedContainerName+ ""String_Node_Str""+ outputPort.getName()+ ""String_Node_Str""+ channel+ ""String_Node_Str"";
        String putString=""String_Node_Str"" + sanitizedContainerName + ""String_Node_Str""+ sanitizedContainerName+ ""String_Node_Str""+ outputPort.getName()+ ""String_Node_Str""+ channel+ ""String_Node_Str""+ getString+ ""String_Node_Str""+ _eol;
        String fireAtString=""String_Node_Str"";
        CompositeActor topContainer=((CompositeActor)container.getContainer());
        String sanitizedTopContainerName=CodeGeneratorAdapter.generateName(topContainer);
        if (topContainer.getDirector() instanceof DEDirector) {
          NamedObj outsideActor=outputPort.getRemoteReceivers()[channel][0].getContainer().getContainer();
          String sanitizedNameOutsideActor=CodeGeneratorAdapter.generateName(outsideActor);
          if (outsideActor instanceof CompositeActor)           sanitizedNameOutsideActor=""String_Node_Str"" + sanitizedNameOutsideActor + ""String_Node_Str"";
          fireAtString=_eol + ""String_Node_Str"" + sanitizedTopContainerName+ ""String_Node_Str""+ sanitizedNameOutsideActor+ ""String_Node_Str""+ sanitizedTopContainerName+ ""String_Node_Str""+ sanitizedTopContainerName+ ""String_Node_Str""+ _eol;
        }
        codeStream.append(_eol + hasTokenString + putString+ fireAtString+ _eol+ ""String_Node_Str""+ _eol);
      }
    }
  }
  if (container.getDirector() instanceof ptolemy.domains.modal.kernel.FSMDirector) {
    inputPorts=container.inputPortList().iterator();
    while (inputPorts.hasNext()) {
      TypedIOPort inputPort=(TypedIOPort)inputPorts.next();
      if (!inputPort.isInsideConnected())       continue;
      Receiver[][] receivers=inputPort.deepGetReceivers();
      for (int channel=0; channel < inputPort.getWidth(); channel++) {
        int foo=0;
        for (int cpt=0; cpt < receivers[channel].length; cpt++) {
          if (!(receivers[channel][cpt].getContainer().getContainer() instanceof ModalController)) {
            String hasTokenString=""String_Node_Str"" + sanitizedContainerName + ""String_Node_Str""+ sanitizedContainerName+ ""String_Node_Str""+ inputPort.getName()+ ""String_Node_Str""+ foo+ ""String_Node_Str""+ _eol;
            String putString=_eol + ""String_Node_Str"" + sanitizedContainerName+ ""String_Node_Str""+ sanitizedContainerName+ ""String_Node_Str""+ inputPort.getName()+ ""String_Node_Str""+ foo+++ ""String_Node_Str"";
            codeStream.append(_eol + hasTokenString + putString+ _eol+ ""String_Node_Str""+ _eol);
          }
        }
      }
    }
  }
  codeStream.append(_eol + ""String_Node_Str"" + _eol);
  return processCode(codeStream.toString());
}","/** 
 * Generate the transfer inputs code. This is to ensure compatibility between different directors.
 * @return The generated code.
 * @exception IllegalActionException If thrown while appending to thethe block or processing the macros.
 */
public String generateTransfersCode() throws IllegalActionException {
  CodeStream codeStream=_templateParser.getCodeStream();
  codeStream.clear();
  ptolemy.actor.CompositeActor container=(ptolemy.actor.CompositeActor)getComponent();
  String sanitizedContainerName=CodeGeneratorAdapter.generateName(container);
  Director director=container.getDirector();
  ptolemy.cg.adapter.generic.adapters.ptolemy.actor.Director directorAdapter=(ptolemy.cg.adapter.generic.adapters.ptolemy.actor.Director)getAdapter(director);
  StringBuffer code=new StringBuffer();
  codeStream.append(_eol + ""String_Node_Str"" + sanitizedContainerName+ ""String_Node_Str""+ _eol);
  Iterator<?> inputPorts=container.inputPortList().iterator();
  while (inputPorts.hasNext()) {
    TypedIOPort inputPort=(TypedIOPort)inputPorts.next();
    if (!inputPort.isInsideConnected())     continue;
    if (container instanceof CompiledCompositeActor) {
      directorAdapter.generateTransferInputsCode(inputPort,code);
      codeStream.append(code.toString());
      code=new StringBuffer();
    }
 else {
      Receiver[][] receivers=inputPort.deepGetReceivers();
      for (int channel=0; channel < inputPort.getWidth(); channel++) {
        String hasTokenString=""String_Node_Str"" + sanitizedContainerName + ""String_Node_Str""+ sanitizedContainerName+ ""String_Node_Str""+ inputPort.getName()+ ""String_Node_Str""+ channel+ ""String_Node_Str""+ _eol;
        String getString=""String_Node_Str"" + sanitizedContainerName + ""String_Node_Str""+ sanitizedContainerName+ ""String_Node_Str""+ inputPort.getName()+ ""String_Node_Str""+ channel+ ""String_Node_Str"";
        StringBuffer putString=new StringBuffer(_eol + ""String_Node_Str"" + getString+ ""String_Node_Str"");
        if (receivers[channel].length > 1) {
          int foo=0;
          for (int cpt=0; cpt < receivers[channel].length; cpt++) {
            if (!(receivers[channel][cpt].getContainer().getContainer() instanceof ModalController)) {
              putString.append(_eol + ""String_Node_Str"" + sanitizedContainerName+ ""String_Node_Str""+ sanitizedContainerName+ ""String_Node_Str""+ inputPort.getName()+ ""String_Node_Str""+ foo+++ ""String_Node_Str"");
            }
          }
        }
 else         putString.append(_eol + ""String_Node_Str"" + sanitizedContainerName+ ""String_Node_Str""+ sanitizedContainerName+ ""String_Node_Str""+ inputPort.getName()+ ""String_Node_Str""+ channel+ ""String_Node_Str""+ _eol);
        if (container.getDirector() instanceof ptolemy.domains.modal.kernel.FSMDirector) {
          List actorList=container.deepEntityList();
          Iterator<?> actors=actorList.iterator();
          while (actors.hasNext()) {
            NamedObj actor=(NamedObj)actors.next();
            if (actor instanceof ModalController) {
              String actorName=CodeGeneratorAdapter.generateName(actor);
              String type=inputPort.getType().toString().substring(0,1).toUpperCase() + inputPort.getType().toString().substring(1);
              putString.append(_eol + actorName + ""String_Node_Str""+ inputPort.getName()+ ""String_Node_Str""+ type+ ""String_Node_Str""+ _eol);
            }
          }
        }
        String fireAtString=""String_Node_Str"";
        if (container.getDirector() instanceof DEDirector) {
          NamedObj insideActor=inputPort.deepGetReceivers()[channel][0].getContainer().getContainer();
          String sanitizedNameInsideActor=CodeGeneratorAdapter.generateName(insideActor);
          if (insideActor instanceof CompositeActor)           sanitizedNameInsideActor=""String_Node_Str"" + sanitizedNameInsideActor + ""String_Node_Str"";
          fireAtString=_eol + ""String_Node_Str"" + sanitizedContainerName+ ""String_Node_Str""+ sanitizedNameInsideActor+ ""String_Node_Str""+ sanitizedContainerName+ ""String_Node_Str""+ sanitizedContainerName+ ""String_Node_Str""+ _eol;
        }
        codeStream.append(_eol + hasTokenString + putString.toString()+ fireAtString+ _eol+ ""String_Node_Str""+ _eol);
      }
    }
  }
  codeStream.append(_eol + ""String_Node_Str"" + _eol);
  codeStream.append(_eol + ""String_Node_Str"" + sanitizedContainerName+ ""String_Node_Str""+ _eol);
  Iterator<?> outputPorts=container.outputPortList().iterator();
  while (outputPorts.hasNext()) {
    TypedIOPort outputPort=(TypedIOPort)outputPorts.next();
    if (!outputPort.isOutsideConnected())     continue;
    if (container instanceof CompiledCompositeActor) {
      directorAdapter.generateTransferOutputsCode(outputPort,code);
      codeStream.append(code.toString());
      code=new StringBuffer();
    }
 else {
      for (int channel=0; channel < outputPort.getWidth(); channel++) {
        String hasTokenString=""String_Node_Str"" + sanitizedContainerName + ""String_Node_Str""+ sanitizedContainerName+ ""String_Node_Str""+ outputPort.getName()+ ""String_Node_Str""+ channel+ ""String_Node_Str""+ _eol;
        String getString=""String_Node_Str"" + sanitizedContainerName + ""String_Node_Str""+ sanitizedContainerName+ ""String_Node_Str""+ outputPort.getName()+ ""String_Node_Str""+ channel+ ""String_Node_Str"";
        String putString=""String_Node_Str"" + sanitizedContainerName + ""String_Node_Str""+ sanitizedContainerName+ ""String_Node_Str""+ outputPort.getName()+ ""String_Node_Str""+ channel+ ""String_Node_Str""+ getString+ ""String_Node_Str""+ _eol;
        String fireAtString=""String_Node_Str"";
        CompositeActor topContainer=((CompositeActor)container.getContainer());
        String sanitizedTopContainerName=CodeGeneratorAdapter.generateName(topContainer);
        if (topContainer.getDirector() instanceof DEDirector) {
          NamedObj outsideActor=outputPort.getRemoteReceivers()[channel][0].getContainer().getContainer();
          String sanitizedNameOutsideActor=CodeGeneratorAdapter.generateName(outsideActor);
          if (outsideActor instanceof CompositeActor)           sanitizedNameOutsideActor=""String_Node_Str"" + sanitizedNameOutsideActor + ""String_Node_Str"";
          fireAtString=_eol + ""String_Node_Str"" + sanitizedTopContainerName+ ""String_Node_Str""+ sanitizedNameOutsideActor+ ""String_Node_Str""+ sanitizedTopContainerName+ ""String_Node_Str""+ sanitizedTopContainerName+ ""String_Node_Str""+ _eol;
        }
        codeStream.append(_eol + hasTokenString + putString+ fireAtString+ _eol+ ""String_Node_Str""+ _eol);
      }
    }
  }
  if (container.getDirector() instanceof ptolemy.domains.modal.kernel.FSMDirector) {
    inputPorts=container.inputPortList().iterator();
    while (inputPorts.hasNext()) {
      TypedIOPort inputPort=(TypedIOPort)inputPorts.next();
      if (!inputPort.isInsideConnected())       continue;
      Receiver[][] receivers=inputPort.deepGetReceivers();
      for (int channel=0; channel < inputPort.getWidth(); channel++) {
        int foo=0;
        for (int cpt=0; cpt < receivers[channel].length; cpt++) {
          if (!(receivers[channel][cpt].getContainer().getContainer() instanceof ModalController)) {
            String hasTokenString=""String_Node_Str"" + sanitizedContainerName + ""String_Node_Str""+ sanitizedContainerName+ ""String_Node_Str""+ inputPort.getName()+ ""String_Node_Str""+ foo+ ""String_Node_Str""+ _eol;
            String putString=_eol + ""String_Node_Str"" + sanitizedContainerName+ ""String_Node_Str""+ sanitizedContainerName+ ""String_Node_Str""+ inputPort.getName()+ ""String_Node_Str""+ foo+++ ""String_Node_Str"";
            codeStream.append(_eol + hasTokenString + putString+ _eol+ ""String_Node_Str""+ _eol);
          }
        }
      }
    }
  }
  codeStream.append(_eol + ""String_Node_Str"" + _eol);
  return processCode(codeStream.toString());
}"
72918,"public String generateInitializeCode() throws IllegalActionException {
  CodeStream codeStream=_templateParser.getCodeStream();
  codeStream.clear();
  LinkedList args=new LinkedList();
  Parameter stopTime=((ptolemy.actor.lib.DiscreteClock)getComponent()).stopTime;
  double doubleStopTime=((DoubleToken)stopTime.getToken()).doubleValue();
  ptolemy.actor.lib.DiscreteClock actor=(ptolemy.actor.lib.DiscreteClock)getComponent();
  ptolemy.actor.CompositeActor container=(ptolemy.actor.CompositeActor)actor.getContainer();
  ptolemy.actor.Director director=container.getDirector();
  double modelStopTime=director.getModelStopTime().getDoubleValue();
  if (doubleStopTime > modelStopTime)   doubleStopTime=modelStopTime;
  Parameter period=((ptolemy.actor.lib.DiscreteClock)getComponent()).period;
  double doublePeriod=((DoubleToken)period.getToken()).doubleValue();
  args.add(Double.toString(doubleStopTime));
  args.add(Double.toString(doublePeriod));
  Parameter offsetPar=((ptolemy.actor.lib.DiscreteClock)getComponent()).offsets;
  Token offsetToken=offsetPar.getToken();
  Token[] offsets;
  double[] offsetsDouble=null;
  int size=0;
  if (offsetToken instanceof ArrayToken) {
    offsets=((ArrayToken)offsetToken).arrayValue();
    size=offsets.length;
    args.add(Integer.toString(size));
    int i=0;
    if (size > 0) {
      if (offsets[0] instanceof DoubleToken) {
        offsetsDouble=new double[size];
      }
 else {
        throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
      }
    }
    for (    Token t : offsets) {
      if (t instanceof DoubleToken) {
        offsetsDouble[i++]=((DoubleToken)t).doubleValue();
      }
 else {
        throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
      }
    }
  }
 else {
    throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
  }
  String offsetsString=""String_Node_Str"";
  int i=0;
  for (  double offset : offsetsDouble)   offsetsString+=""String_Node_Str"" + i++ + ""String_Node_Str""+ Double.toString(offset)+ ""String_Node_Str"";
  args.add(offsetsString);
  Parameter valuesPar=((ptolemy.actor.lib.DiscreteClock)getComponent()).values;
  Token valuesToken=valuesPar.getToken();
  Token[] values;
  double[] valuesDouble=null;
  int[] valuesInt=null;
  boolean[] valuesBool=null;
  size=0;
  if (valuesToken instanceof ArrayToken) {
    values=((ArrayToken)valuesToken).arrayValue();
    size=values.length;
    args.add(Integer.toString(size));
    i=0;
    if (size > 0) {
      if (values[0] instanceof DoubleToken) {
        valuesDouble=new double[size];
      }
 else       if (values[0] instanceof IntToken) {
        valuesInt=new int[size];
      }
 else       if (values[0] instanceof BooleanToken) {
        valuesBool=new boolean[size];
      }
 else {
        throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
      }
    }
    for (    Token t : values) {
      if (t instanceof DoubleToken) {
        valuesDouble[i++]=((DoubleToken)t).doubleValue();
      }
 else       if (t instanceof IntToken) {
        valuesInt[i++]=((IntToken)t).intValue();
      }
 else       if (t instanceof BooleanToken) {
        valuesBool[i++]=((BooleanToken)t).booleanValue();
      }
 else {
        throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
      }
    }
  }
 else {
    throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
  }
  String valuesString=""String_Node_Str"";
  i=0;
  if (valuesDouble != null)   for (  double value : valuesDouble)   valuesString+=""String_Node_Str"" + i++ + ""String_Node_Str""+ Double.toString(value)+ ""String_Node_Str"";
 else   if (valuesInt != null)   for (  int value : valuesInt)   valuesString+=""String_Node_Str"" + i++ + ""String_Node_Str""+ Integer.toString(value)+ ""String_Node_Str"";
 else   if (valuesBool != null)   for (  boolean value : valuesBool)   valuesString+=""String_Node_Str"" + i++ + ""String_Node_Str""+ Boolean.toString(value)+ ""String_Node_Str"";
  args.add(valuesString);
  codeStream.appendCodeBlock(""String_Node_Str"",args);
  if (((ptolemy.actor.lib.DiscreteClock)getComponent()).start.isOutsideConnected()) {
    codeStream.appendCodeBlock(""String_Node_Str"");
  }
  return processCode(codeStream.toString());
}","public String generateInitializeCode() throws IllegalActionException {
  CodeStream codeStream=_templateParser.getCodeStream();
  codeStream.clear();
  LinkedList args=new LinkedList();
  Parameter stopTime=((ptolemy.actor.lib.DiscreteClock)getComponent()).stopTime;
  double doubleStopTime=((DoubleToken)stopTime.getToken()).doubleValue();
  ptolemy.actor.lib.DiscreteClock actor=(ptolemy.actor.lib.DiscreteClock)getComponent();
  ptolemy.actor.CompositeActor container=(ptolemy.actor.CompositeActor)actor.getContainer();
  ptolemy.actor.Director director=container.getDirector();
  double modelStopTime=director.getModelStopTime().getDoubleValue();
  if (doubleStopTime > modelStopTime)   doubleStopTime=modelStopTime;
  Parameter period=((ptolemy.actor.lib.DiscreteClock)getComponent()).period;
  double doublePeriod=((DoubleToken)period.getToken()).doubleValue();
  args.add(Double.toString(doubleStopTime));
  args.add(Double.toString(doublePeriod));
  Parameter offsetPar=((ptolemy.actor.lib.DiscreteClock)getComponent()).offsets;
  Token offsetToken=offsetPar.getToken();
  Token[] offsets;
  double[] offsetsDouble=null;
  int size=0;
  if (offsetToken instanceof ArrayToken) {
    offsets=((ArrayToken)offsetToken).arrayValue();
    size=offsets.length;
    args.add(Integer.toString(size));
    int i=0;
    if (size > 0) {
      if (offsets[0] instanceof DoubleToken) {
        offsetsDouble=new double[size];
      }
 else {
        throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
      }
    }
    for (    Token t : offsets) {
      if (t instanceof DoubleToken) {
        offsetsDouble[i++]=((DoubleToken)t).doubleValue();
      }
 else {
        throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
      }
    }
  }
 else {
    throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
  }
  StringBuffer offsetsString=new StringBuffer();
  int i=0;
  for (  double offset : offsetsDouble)   offsetsString.append(""String_Node_Str"" + i++ + ""String_Node_Str""+ Double.toString(offset)+ ""String_Node_Str""+ _eol);
  args.add(offsetsString);
  Parameter valuesPar=((ptolemy.actor.lib.DiscreteClock)getComponent()).values;
  Token valuesToken=valuesPar.getToken();
  Token[] values;
  double[] valuesDouble=null;
  int[] valuesInt=null;
  boolean[] valuesBool=null;
  size=0;
  if (valuesToken instanceof ArrayToken) {
    values=((ArrayToken)valuesToken).arrayValue();
    size=values.length;
    args.add(Integer.toString(size));
    i=0;
    if (size > 0) {
      if (values[0] instanceof DoubleToken) {
        valuesDouble=new double[size];
      }
 else       if (values[0] instanceof IntToken) {
        valuesInt=new int[size];
      }
 else       if (values[0] instanceof BooleanToken) {
        valuesBool=new boolean[size];
      }
 else {
        throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
      }
    }
    for (    Token t : values) {
      if (t instanceof DoubleToken) {
        valuesDouble[i++]=((DoubleToken)t).doubleValue();
      }
 else       if (t instanceof IntToken) {
        valuesInt[i++]=((IntToken)t).intValue();
      }
 else       if (t instanceof BooleanToken) {
        valuesBool[i++]=((BooleanToken)t).booleanValue();
      }
 else {
        throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
      }
    }
  }
 else {
    throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
  }
  String valuesString=""String_Node_Str"";
  i=0;
  if (valuesDouble != null)   for (  double value : valuesDouble)   valuesString+=""String_Node_Str"" + i++ + ""String_Node_Str""+ Double.toString(value)+ ""String_Node_Str"";
 else   if (valuesInt != null)   for (  int value : valuesInt)   valuesString+=""String_Node_Str"" + i++ + ""String_Node_Str""+ Integer.toString(value)+ ""String_Node_Str"";
 else   if (valuesBool != null)   for (  boolean value : valuesBool)   valuesString+=""String_Node_Str"" + i++ + ""String_Node_Str""+ Boolean.toString(value)+ ""String_Node_Str"";
  args.add(valuesString);
  codeStream.appendCodeBlock(""String_Node_Str"",args);
  if (((ptolemy.actor.lib.DiscreteClock)getComponent()).start.isOutsideConnected()) {
    codeStream.appendCodeBlock(""String_Node_Str"");
  }
  return processCode(codeStream.toString());
}"
72919,"public String generateInitializeCode() throws IllegalActionException {
  CodeStream codeStream=_templateParser.getCodeStream();
  codeStream.clear();
  LinkedList args=new LinkedList();
  Parameter stopTime=((ptolemy.actor.lib.PoissonClock)getComponent()).stopTime;
  double doubleStopTime=((DoubleToken)stopTime.getToken()).doubleValue();
  ptolemy.actor.lib.PoissonClock actor=(ptolemy.actor.lib.PoissonClock)getComponent();
  ptolemy.actor.CompositeActor container=(ptolemy.actor.CompositeActor)actor.getContainer();
  ptolemy.actor.Director director=container.getDirector();
  double modelStopTime=director.getModelStopTime().getDoubleValue();
  if (doubleStopTime > modelStopTime)   doubleStopTime=modelStopTime;
  Parameter meanTime=((ptolemy.actor.lib.PoissonClock)getComponent()).meanTime;
  double doubleMeanTime=((DoubleToken)meanTime.getToken()).doubleValue();
  Parameter fireAtStart=((ptolemy.actor.lib.PoissonClock)getComponent()).fireAtStart;
  boolean boolFireAtStart=((BooleanToken)fireAtStart.getToken()).booleanValue();
  args.add(Double.toString(doubleStopTime));
  args.add(Double.toString(doubleMeanTime));
  args.add(Boolean.toString(boolFireAtStart));
  Parameter valuesPar=((ptolemy.actor.lib.PoissonClock)getComponent()).values;
  Token valuesToken=valuesPar.getToken();
  Token[] values;
  double[] valuesDouble=null;
  int[] valuesInt=null;
  int size=0;
  if (valuesToken instanceof ArrayToken) {
    values=((ArrayToken)valuesToken).arrayValue();
    size=values.length;
    args.add(Integer.toString(size));
    int i=0;
    if (size > 0) {
      if (values[0] instanceof DoubleToken) {
        valuesDouble=new double[size];
      }
 else       if (values[0] instanceof IntToken) {
        valuesInt=new int[size];
      }
 else {
        throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
      }
    }
    for (    Token t : values) {
      if (t instanceof DoubleToken) {
        valuesDouble[i++]=((DoubleToken)t).doubleValue();
      }
 else       if (t instanceof IntToken) {
        valuesInt[i++]=((IntToken)t).intValue();
      }
 else {
        throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
      }
    }
  }
 else {
    throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
  }
  String valuesString=""String_Node_Str"";
  int i=0;
  if (valuesDouble != null)   for (  double value : valuesDouble)   valuesString+=""String_Node_Str"" + i++ + ""String_Node_Str""+ Double.toString(value)+ ""String_Node_Str"";
 else   if (valuesInt != null)   for (  int value : valuesInt)   valuesString+=""String_Node_Str"" + i++ + ""String_Node_Str""+ Integer.toString(value)+ ""String_Node_Str"";
  args.add(valuesString);
  long longPrivateSeed=0;
  Parameter privateSeed=((ptolemy.actor.lib.PoissonClock)getComponent()).privateSeed;
  if (privateSeed.getToken() instanceof LongToken)   longPrivateSeed=((LongToken)privateSeed.getToken()).longValue();
  args.add(Long.toString(longPrivateSeed));
  long longSeed=0;
  Parameter seed=((ptolemy.actor.lib.PoissonClock)getComponent()).seed;
  if (seed.getToken() instanceof LongToken)   longSeed=((LongToken)seed.getToken()).longValue() + ((ptolemy.actor.lib.PoissonClock)getComponent()).getFullName().hashCode();
  args.add(Long.toString(longSeed));
  codeStream.appendCodeBlock(""String_Node_Str"",args);
  return processCode(codeStream.toString());
}","public String generateInitializeCode() throws IllegalActionException {
  CodeStream codeStream=_templateParser.getCodeStream();
  codeStream.clear();
  LinkedList args=new LinkedList();
  Parameter stopTime=((ptolemy.actor.lib.PoissonClock)getComponent()).stopTime;
  double doubleStopTime=((DoubleToken)stopTime.getToken()).doubleValue();
  ptolemy.actor.lib.PoissonClock actor=(ptolemy.actor.lib.PoissonClock)getComponent();
  ptolemy.actor.CompositeActor container=(ptolemy.actor.CompositeActor)actor.getContainer();
  ptolemy.actor.Director director=container.getDirector();
  double modelStopTime=director.getModelStopTime().getDoubleValue();
  if (doubleStopTime > modelStopTime)   doubleStopTime=modelStopTime;
  Parameter meanTime=((ptolemy.actor.lib.PoissonClock)getComponent()).meanTime;
  double doubleMeanTime=((DoubleToken)meanTime.getToken()).doubleValue();
  Parameter fireAtStart=((ptolemy.actor.lib.PoissonClock)getComponent()).fireAtStart;
  boolean boolFireAtStart=((BooleanToken)fireAtStart.getToken()).booleanValue();
  args.add(Double.toString(doubleStopTime));
  args.add(Double.toString(doubleMeanTime));
  args.add(Boolean.toString(boolFireAtStart));
  Parameter valuesPar=((ptolemy.actor.lib.PoissonClock)getComponent()).values;
  Token valuesToken=valuesPar.getToken();
  Token[] values;
  double[] valuesDouble=null;
  int[] valuesInt=null;
  int size=0;
  if (valuesToken instanceof ArrayToken) {
    values=((ArrayToken)valuesToken).arrayValue();
    size=values.length;
    args.add(Integer.toString(size));
    int i=0;
    if (size > 0) {
      if (values[0] instanceof DoubleToken) {
        valuesDouble=new double[size];
      }
 else       if (values[0] instanceof IntToken) {
        valuesInt=new int[size];
      }
 else {
        throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
      }
    }
    for (    Token t : values) {
      if (t instanceof DoubleToken) {
        valuesDouble[i++]=((DoubleToken)t).doubleValue();
      }
 else       if (t instanceof IntToken) {
        valuesInt[i++]=((IntToken)t).intValue();
      }
 else {
        throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
      }
    }
  }
 else {
    throw new IllegalActionException(""String_Node_Str"" + ""String_Node_Str"");
  }
  StringBuffer valuesString=new StringBuffer();
  int i=0;
  if (valuesDouble != null)   for (  double value : valuesDouble)   valuesString.append(""String_Node_Str"" + i++ + ""String_Node_Str""+ Double.toString(value)+ ""String_Node_Str""+ _eol);
 else   if (valuesInt != null)   for (  int value : valuesInt)   valuesString.append(""String_Node_Str"" + i++ + ""String_Node_Str""+ Integer.toString(value)+ ""String_Node_Str""+ _eol);
  args.add(valuesString);
  long longPrivateSeed=0;
  Parameter privateSeed=((ptolemy.actor.lib.PoissonClock)getComponent()).privateSeed;
  if (privateSeed.getToken() instanceof LongToken)   longPrivateSeed=((LongToken)privateSeed.getToken()).longValue();
  args.add(Long.toString(longPrivateSeed));
  long longSeed=0;
  Parameter seed=((ptolemy.actor.lib.PoissonClock)getComponent()).seed;
  if (seed.getToken() instanceof LongToken)   longSeed=((LongToken)seed.getToken()).longValue() + ((ptolemy.actor.lib.PoissonClock)getComponent()).getFullName().hashCode();
  args.add(Long.toString(longSeed));
  codeStream.appendCodeBlock(""String_Node_Str"",args);
  return processCode(codeStream.toString());
}"
72920,"/** 
 * Generate the initialize code for the associated DE director.
 * @return The generated initialize code.
 * @exception IllegalActionException If the adapter associated withan actor throws it while generating initialize code for the actor.
 */
public String generateInitializeFunctionCode() throws IllegalActionException {
  StringBuffer code=new StringBuffer();
  ptolemy.actor.Director director=(ptolemy.actor.Director)getComponent();
  CompositeActor container=((CompositeActor)_director.getContainer());
  List actorList=container.deepEntityList();
  String sanitizedContainerName=CodeGeneratorAdapter.generateName(container);
  ProgramCodeGenerator codeGenerator=getCodeGenerator();
  code.append(_eol + _eol + codeGenerator.comment(""String_Node_Str""));
  code.append(_eol + _sanitizedDirectorName + ""String_Node_Str"");
  code.append(_eol + _sanitizedDirectorName + ""String_Node_Str"");
  if (_director.isEmbedded()) {
    if (container instanceof CompositeActor) {
      ptolemy.actor.Director executiveDirector=container.getExecutiveDirector();
      if (executiveDirector instanceof SuperdenseTimeDirector) {
        code.append(_eol + _sanitizedDirectorName + ""String_Node_Str""+ ((SuperdenseTimeDirector)executiveDirector).getIndex()+ ""String_Node_Str"");
      }
    }
  }
  Iterator<?> actors=actorList.iterator();
  while (actors.hasNext()) {
    NamedObj actor=(NamedObj)actors.next();
    String sanitizedActorName=CodeGeneratorAdapter.generateName(actor);
    code.append(_eol + sanitizedActorName + ""String_Node_Str"");
  }
  code.append(_eol + _sanitizedDirectorName + ""String_Node_Str""+ sanitizedContainerName+ ""String_Node_Str"");
  code.append(_eol + _sanitizedDirectorName + ""String_Node_Str""+ _sanitizedDirectorName+ ""String_Node_Str"");
  Attribute stopWhenQueueIsEmpty=director.getAttribute(""String_Node_Str"");
  boolean stopWhenQueueIsEmptyBool=((BooleanToken)((Variable)stopWhenQueueIsEmpty).getToken()).booleanValue();
  code.append(_eol + _sanitizedDirectorName + ""String_Node_Str""+ stopWhenQueueIsEmptyBool+ ""String_Node_Str"");
  code.append(_eol + _sanitizedDirectorName + ""String_Node_Str"");
  if (!director.getModelStopTime().isPositiveInfinite()) {
    code.append(_eol + _sanitizedDirectorName + ""String_Node_Str""+ _sanitizedDirectorName+ ""String_Node_Str""+ ""String_Node_Str""+ _sanitizedDirectorName+ ""String_Node_Str"");
  }
  code.append(_eol + _sanitizedDirectorName + ""String_Node_Str"");
  code.append(_eol + codeGenerator.comment(""String_Node_Str""));
  return code.toString();
}","/** 
 * Generate the initialize code for the associated DE director.
 * @return The generated initialize code.
 * @exception IllegalActionException If the adapter associated withan actor throws it while generating initialize code for the actor.
 */
public String generateInitializeFunctionCode() throws IllegalActionException {
  StringBuffer code=new StringBuffer();
  ptolemy.actor.Director director=(ptolemy.actor.Director)getComponent();
  CompositeActor container=((CompositeActor)_director.getContainer());
  List actorList=container.deepEntityList();
  String sanitizedContainerName=CodeGeneratorAdapter.generateName(container);
  ProgramCodeGenerator codeGenerator=getCodeGenerator();
  code.append(_eol + _eol + codeGenerator.comment(""String_Node_Str""));
  code.append(_eol + _sanitizedDirectorName + ""String_Node_Str"");
  code.append(_eol + _sanitizedDirectorName + ""String_Node_Str"");
  if (_director.isEmbedded()) {
    ptolemy.actor.Director executiveDirector=container.getExecutiveDirector();
    if (executiveDirector instanceof SuperdenseTimeDirector) {
      code.append(_eol + _sanitizedDirectorName + ""String_Node_Str""+ ((SuperdenseTimeDirector)executiveDirector).getIndex()+ ""String_Node_Str"");
    }
  }
  Iterator<?> actors=actorList.iterator();
  while (actors.hasNext()) {
    NamedObj actor=(NamedObj)actors.next();
    String sanitizedActorName=CodeGeneratorAdapter.generateName(actor);
    code.append(_eol + sanitizedActorName + ""String_Node_Str"");
  }
  code.append(_eol + _sanitizedDirectorName + ""String_Node_Str""+ sanitizedContainerName+ ""String_Node_Str"");
  code.append(_eol + _sanitizedDirectorName + ""String_Node_Str""+ _sanitizedDirectorName+ ""String_Node_Str"");
  Attribute stopWhenQueueIsEmpty=director.getAttribute(""String_Node_Str"");
  boolean stopWhenQueueIsEmptyBool=((BooleanToken)((Variable)stopWhenQueueIsEmpty).getToken()).booleanValue();
  code.append(_eol + _sanitizedDirectorName + ""String_Node_Str""+ stopWhenQueueIsEmptyBool+ ""String_Node_Str"");
  code.append(_eol + _sanitizedDirectorName + ""String_Node_Str"");
  if (!director.getModelStopTime().isPositiveInfinite()) {
    code.append(_eol + _sanitizedDirectorName + ""String_Node_Str""+ _sanitizedDirectorName+ ""String_Node_Str""+ ""String_Node_Str""+ _sanitizedDirectorName+ ""String_Node_Str"");
  }
  code.append(_eol + _sanitizedDirectorName + ""String_Node_Str"");
  code.append(_eol + codeGenerator.comment(""String_Node_Str""));
  return code.toString();
}"
72921,"/** 
 * Generate the initialize function code for the associated FSM director.
 * @return The generated initialize code.
 * @exception IllegalActionException If the adapter associated withan actor throws it while generating initialize code for the actor.
 */
public String generateInitializeFunctionCode() throws IllegalActionException {
  StringBuffer code=new StringBuffer();
  CompositeActor container=((CompositeActor)_director.getContainer());
  List actorList=container.deepEntityList();
  String sanitizedContainerName=CodeGeneratorAdapter.generateName(container);
  ProgramCodeGenerator codeGenerator=getCodeGenerator();
  code.append(_eol + _eol + codeGenerator.comment(""String_Node_Str""));
  if (_director.isEmbedded()) {
    if (container instanceof CompositeActor) {
      ptolemy.actor.Director executiveDirector=container.getExecutiveDirector();
      if (executiveDirector instanceof SuperdenseTimeDirector) {
        code.append(_eol + _sanitizedDirectorName + ""String_Node_Str""+ ((SuperdenseTimeDirector)executiveDirector).getIndex()+ ""String_Node_Str"");
      }
    }
  }
  Iterator<?> actors=actorList.iterator();
  while (actors.hasNext()) {
    NamedObj actor=(NamedObj)actors.next();
    String sanitizedActorName=CodeGeneratorAdapter.generateName(actor);
    if (!actor.getFullName().contains(""String_Node_Str""))     code.append(_eol + sanitizedActorName + ""String_Node_Str"");
  }
  code.append(_eol + _sanitizedDirectorName + ""String_Node_Str""+ sanitizedContainerName+ ""String_Node_Str"");
  code.append(_eol + _sanitizedDirectorName + ""String_Node_Str""+ _sanitizedDirectorName+ ""String_Node_Str"");
  code.append(_eol + _sanitizedDirectorName + ""String_Node_Str"");
  code.append(_eol + _sanitizedDirectorName + ""String_Node_Str"");
  code.append(_eol + codeGenerator.comment(""String_Node_Str""));
  return code.toString();
}","/** 
 * Generate the initialize function code for the associated FSM director.
 * @return The generated initialize code.
 * @exception IllegalActionException If the adapter associated withan actor throws it while generating initialize code for the actor.
 */
public String generateInitializeFunctionCode() throws IllegalActionException {
  StringBuffer code=new StringBuffer();
  CompositeActor container=((CompositeActor)_director.getContainer());
  List actorList=container.deepEntityList();
  String sanitizedContainerName=CodeGeneratorAdapter.generateName(container);
  ProgramCodeGenerator codeGenerator=getCodeGenerator();
  code.append(_eol + _eol + codeGenerator.comment(""String_Node_Str""));
  if (_director.isEmbedded()) {
    ptolemy.actor.Director executiveDirector=container.getExecutiveDirector();
    if (executiveDirector instanceof SuperdenseTimeDirector) {
      code.append(_eol + _sanitizedDirectorName + ""String_Node_Str""+ ((SuperdenseTimeDirector)executiveDirector).getIndex()+ ""String_Node_Str"");
    }
  }
  Iterator<?> actors=actorList.iterator();
  while (actors.hasNext()) {
    NamedObj actor=(NamedObj)actors.next();
    String sanitizedActorName=CodeGeneratorAdapter.generateName(actor);
    if (!actor.getFullName().contains(""String_Node_Str""))     code.append(_eol + sanitizedActorName + ""String_Node_Str"");
  }
  code.append(_eol + _sanitizedDirectorName + ""String_Node_Str""+ sanitizedContainerName+ ""String_Node_Str"");
  code.append(_eol + _sanitizedDirectorName + ""String_Node_Str""+ _sanitizedDirectorName+ ""String_Node_Str"");
  code.append(_eol + _sanitizedDirectorName + ""String_Node_Str"");
  code.append(_eol + _sanitizedDirectorName + ""String_Node_Str"");
  code.append(_eol + codeGenerator.comment(""String_Node_Str""));
  return code.toString();
}"
72922,"public String generateVariableDeclaration() throws IllegalActionException {
  StringBuffer code=new StringBuffer();
  List<TypedIOPort> inputPorts=_myController.inputPortList();
  List<TypedIOPort> outputPorts=_myController.outputPortList();
  String name=_myController.getFullName().substring(1);
  String modalName=name.replace(""String_Node_Str"",""String_Node_Str"");
  name=name.replace('.','_');
  modalName=modalName.replace('.','_');
  TypedIOPort inputPort;
  code.append(_eol + getCodeGenerator().comment(""String_Node_Str""));
  for (int i=0; i < inputPorts.size(); i++) {
    inputPort=inputPorts.get(i);
    if (!outputPorts.contains(inputPort)) {
      int width=inputPort.getWidth();
      code.append(inputPort.getType() + ""String_Node_Str"" + name+ ""String_Node_Str""+ inputPort.getName());
      if (width > 1) {
        code.append(""String_Node_Str"" + width + ""String_Node_Str"");
      }
      code.append(""String_Node_Str"" + _eol);
    }
  }
  code.append(""String_Node_Str"" + modalName + ""String_Node_Str""+ _eol);
  String enumStates=_eol + ""String_Node_Str"" + name+ ""String_Node_Str"";
  Iterator states=_myController.entityList().iterator();
  boolean first=true;
  while (states.hasNext()) {
    if (first)     first=false;
 else     enumStates+=""String_Node_Str"";
    State state=(State)states.next();
    String stateName=CodeGeneratorAdapter.generateName(state);
    enumStates+=stateName;
  }
  enumStates+=""String_Node_Str"";
  code.append(enumStates);
  code.append(_eol + ""String_Node_Str"" + name+ ""String_Node_Str""+ name+ ""String_Node_Str"");
  code.append(_eol + getCodeGenerator().comment(""String_Node_Str""));
  return code.toString();
}","public String generateVariableDeclaration() throws IllegalActionException {
  StringBuffer code=new StringBuffer();
  List<TypedIOPort> inputPorts=_myController.inputPortList();
  List<TypedIOPort> outputPorts=_myController.outputPortList();
  String name=_myController.getFullName().substring(1);
  String modalName=name.replace(""String_Node_Str"",""String_Node_Str"");
  name=name.replace('.','_');
  modalName=modalName.replace('.','_');
  TypedIOPort inputPort;
  code.append(_eol + getCodeGenerator().comment(""String_Node_Str""));
  for (int i=0; i < inputPorts.size(); i++) {
    inputPort=inputPorts.get(i);
    if (!outputPorts.contains(inputPort)) {
      int width=inputPort.getWidth();
      code.append(inputPort.getType() + ""String_Node_Str"" + name+ ""String_Node_Str""+ inputPort.getName());
      if (width > 1) {
        code.append(""String_Node_Str"" + width + ""String_Node_Str"");
      }
      code.append(""String_Node_Str"" + _eol);
    }
  }
  code.append(""String_Node_Str"" + modalName + ""String_Node_Str""+ _eol);
  StringBuffer enumStates=new StringBuffer(_eol + ""String_Node_Str"" + name+ ""String_Node_Str"");
  Iterator states=_myController.entityList().iterator();
  boolean first=true;
  while (states.hasNext()) {
    if (first)     first=false;
 else     enumStates.append(""String_Node_Str"");
    State state=(State)states.next();
    String stateName=CodeGeneratorAdapter.generateName(state);
    enumStates.append(stateName);
  }
  enumStates.append(""String_Node_Str"");
  code.append(enumStates);
  code.append(_eol + ""String_Node_Str"" + name+ ""String_Node_Str""+ name+ ""String_Node_Str"");
  code.append(_eol + getCodeGenerator().comment(""String_Node_Str""));
  return code.toString();
}"
72923,"/** 
 * Generate the postfire code of the associated controller. We generate a switch because we only need to call the postfire method of the current state.
 * @return The postfire code of the associated controller.
 * @exception IllegalActionException If the adapter associated withan actor throws it while generating postfire code for the actor
 */
@Override public String generatePostfireCode() throws IllegalActionException {
  StringBuffer code=new StringBuffer();
  String name=_myController.getFullName().substring(1);
  String modalName=name.replace(""String_Node_Str"",""String_Node_Str"");
  name=name.replace('.','_');
  modalName=modalName.replace('.','_');
  code.append(_eol + ""String_Node_Str"" + name+ ""String_Node_Str"");
  Iterator states=_myController.entityList().iterator();
  while (states.hasNext()) {
    State state=(State)states.next();
    String stateName=CodeGeneratorAdapter.generateName(state);
    code.append(_eol + ""String_Node_Str"" + stateName+ ""String_Node_Str"");
    Actor[] actors=state.getRefinement();
    if (actors != null) {
      for (      Actor actor : actors) {
        NamedProgramCodeGeneratorAdapter actorHelper=(NamedProgramCodeGeneratorAdapter)getCodeGenerator().getAdapter(actor);
        code.append(_eol + actorHelper.generatePostfireCode());
      }
    }
    code.append(_eol + ""String_Node_Str"" + _eol+ ""String_Node_Str"");
  }
  code.append(_eol + ""String_Node_Str"" + _eol+ ""String_Node_Str"");
  return code.toString();
}","/** 
 * Generate the postfire code of the associated controller. We generate a switch because we only need to call the postfire method of the current state.
 * @return The postfire code of the associated controller.
 * @exception IllegalActionException If the adapter associated withan actor throws it while generating postfire code for the actor
 */
@Override public String generatePostfireCode() throws IllegalActionException {
  StringBuffer code=new StringBuffer();
  String name=_myController.getFullName().substring(1);
  name=name.replace('.','_');
  code.append(_eol + ""String_Node_Str"" + name+ ""String_Node_Str"");
  Iterator states=_myController.entityList().iterator();
  while (states.hasNext()) {
    State state=(State)states.next();
    String stateName=CodeGeneratorAdapter.generateName(state);
    code.append(_eol + ""String_Node_Str"" + stateName+ ""String_Node_Str"");
    Actor[] actors=state.getRefinement();
    if (actors != null) {
      for (      Actor actor : actors) {
        NamedProgramCodeGeneratorAdapter actorHelper=(NamedProgramCodeGeneratorAdapter)getCodeGenerator().getAdapter(actor);
        code.append(_eol + actorHelper.generatePostfireCode());
      }
    }
    code.append(_eol + ""String_Node_Str"" + _eol+ ""String_Node_Str"");
  }
  code.append(_eol + ""String_Node_Str"" + _eol+ ""String_Node_Str"");
  return code.toString();
}"
72924,"/** 
 * Generate code for the firing of refinements.
 * @param code The string buffer that the generated code is appended to.
 * @exception IllegalActionException If the helper associated withan actor throws it while generating fire code for the actor.
 */
protected void _generateRefinementCode(StringBuffer code) throws IllegalActionException {
  String name=_myController.getFullName().substring(1);
  String modalName=name.replace(""String_Node_Str"",""String_Node_Str"");
  name=name.replace('.','_');
  modalName=modalName.replace('.','_');
  int depth=1;
  code.append(_getIndentPrefix(depth));
  code.append(""String_Node_Str"" + name + ""String_Node_Str""+ _eol);
  Iterator states=_myController.entityList().iterator();
  depth++;
  while (states.hasNext()) {
    code.append(_getIndentPrefix(depth));
    depth++;
    State state=(State)states.next();
    code.append(""String_Node_Str"" + CodeGeneratorAdapter.generateName(state) + ""String_Node_Str""+ _eol);
    Actor[] actors=state.getRefinement();
    if (actors != null) {
      for (      Actor actor : actors) {
        NamedProgramCodeGeneratorAdapter actorHelper=(NamedProgramCodeGeneratorAdapter)getCodeGenerator().getAdapter(actor);
        code.append(actorHelper.generateFireCode());
      }
    }
    code.append(_getIndentPrefix(depth));
    code.append(""String_Node_Str"" + _eol);
    depth--;
  }
  depth--;
  code.append(_getIndentPrefix(depth));
  code.append(""String_Node_Str"" + _eol);
}","/** 
 * Generate code for the firing of refinements.
 * @param code The string buffer that the generated code is appended to.
 * @exception IllegalActionException If the helper associated withan actor throws it while generating fire code for the actor.
 */
protected void _generateRefinementCode(StringBuffer code) throws IllegalActionException {
  String name=_myController.getFullName().substring(1);
  name=name.replace('.','_');
  int depth=1;
  code.append(_getIndentPrefix(depth));
  code.append(""String_Node_Str"" + name + ""String_Node_Str""+ _eol);
  Iterator states=_myController.entityList().iterator();
  depth++;
  while (states.hasNext()) {
    code.append(_getIndentPrefix(depth));
    depth++;
    State state=(State)states.next();
    code.append(""String_Node_Str"" + CodeGeneratorAdapter.generateName(state) + ""String_Node_Str""+ _eol);
    Actor[] actors=state.getRefinement();
    if (actors != null) {
      for (      Actor actor : actors) {
        NamedProgramCodeGeneratorAdapter actorHelper=(NamedProgramCodeGeneratorAdapter)getCodeGenerator().getAdapter(actor);
        code.append(actorHelper.generateFireCode());
      }
    }
    code.append(_getIndentPrefix(depth));
    code.append(""String_Node_Str"" + _eol);
    depth--;
  }
  depth--;
  code.append(_getIndentPrefix(depth));
  code.append(""String_Node_Str"" + _eol);
}"
72925,"/** 
 * Generate the fire code of the associated controller. All the steps are described below It is slightly different from the super class in order to take into account the receivers (if embedded in a DE model)
 * @return The fire code of the associated controller.
 * @exception IllegalActionException If the adapter associated withan actor throws it while generating fire code for the actor
 */
public String generateFireCode() throws IllegalActionException {
  FSMActor controllerHelper;
  try {
    controllerHelper=new FSMActor(_myController);
    controllerHelper.setCodeGenerator(getCodeGenerator());
    controllerHelper.setTemplateParser(getTemplateParser());
  }
 catch (  NameDuplicationException ndx) {
    throw new IllegalActionException(ndx.toString());
  }
  StringBuffer code=new StringBuffer();
  String name=_myController.getFullName().substring(1);
  String modalName=name.replace(""String_Node_Str"",""String_Node_Str"");
  name=name.replace('.','_');
  modalName=modalName.replace('.','_');
  code.append(_eol + getCodeGenerator().comment(""String_Node_Str""));
  controllerHelper.generateTransitionCode(code,new PreemptiveTransitions());
  code.append(_eol);
  code.append(""String_Node_Str"" + modalName + ""String_Node_Str""+ _eol);
  _generateRefinementCode(code);
  code.append(getCodeGenerator().comment(""String_Node_Str""));
  controllerHelper.generateTransitionCode(code,new NonPreemptiveTransitions());
  code.append(""String_Node_Str"" + _eol);
  return code.toString();
}","/** 
 * Generate the fire code of the associated controller. All the steps are described below It is slightly different from the super class in order to take into account the receivers (if embedded in a DE model)
 * @return The fire code of the associated controller.
 * @exception IllegalActionException If the adapter associated withan actor throws it while generating fire code for the actor
 */
public String generateFireCode() throws IllegalActionException {
  FSMActor controllerHelper;
  try {
    controllerHelper=new FSMActor(_myController);
    controllerHelper.setCodeGenerator(getCodeGenerator());
    controllerHelper.setTemplateParser(getTemplateParser());
  }
 catch (  NameDuplicationException ndx) {
    throw new IllegalActionException(ndx.toString());
  }
  StringBuffer code=new StringBuffer();
  String name=_myController.getFullName().substring(1);
  String modalName=name.replace(""String_Node_Str"",""String_Node_Str"");
  modalName=modalName.replace('.','_');
  code.append(_eol + getCodeGenerator().comment(""String_Node_Str""));
  controllerHelper.generateTransitionCode(code,new PreemptiveTransitions());
  code.append(_eol);
  code.append(""String_Node_Str"" + modalName + ""String_Node_Str""+ _eol);
  _generateRefinementCode(code);
  code.append(getCodeGenerator().comment(""String_Node_Str""));
  controllerHelper.generateTransitionCode(code,new NonPreemptiveTransitions());
  code.append(""String_Node_Str"" + _eol);
  return code.toString();
}"
72926,"/** 
 * Generate the transfer inputs code. This is to ensure compatibility between different directors.
 * @return The generated code.
 * @exception IllegalActionException If thrown while appending to thethe block or processing the macros.
 */
public String generateTransfersCode() throws IllegalActionException {
  CodeStream codeStream=_templateParser.getCodeStream();
  codeStream.clear();
  ptolemy.actor.CompositeActor container=(ptolemy.actor.CompositeActor)getComponent();
  String sanitizedContainerName=CodeGeneratorAdapter.generateName(container);
  Director director=container.getDirector();
  ptolemy.cg.adapter.generic.adapters.ptolemy.actor.Director directorAdapter=(ptolemy.cg.adapter.generic.adapters.ptolemy.actor.Director)getAdapter(director);
  StringBuffer code=new StringBuffer();
  codeStream.append(_eol + ""String_Node_Str"" + sanitizedContainerName+ ""String_Node_Str""+ _eol);
  Iterator<?> inputPorts=container.inputPortList().iterator();
  while (inputPorts.hasNext()) {
    TypedIOPort inputPort=(TypedIOPort)inputPorts.next();
    if (!inputPort.isInsideConnected())     continue;
    if (container instanceof CompiledCompositeActor) {
      directorAdapter.generateTransferInputsCode(inputPort,code);
      codeStream.append(code.toString());
      code=new StringBuffer();
    }
 else {
      Receiver[][] receivers=inputPort.deepGetReceivers();
      for (int channel=0; channel < inputPort.getWidth(); channel++) {
        String hasTokenString=""String_Node_Str"" + sanitizedContainerName + ""String_Node_Str""+ sanitizedContainerName+ ""String_Node_Str""+ inputPort.getName()+ ""String_Node_Str""+ channel+ ""String_Node_Str""+ _eol;
        String getString=""String_Node_Str"" + sanitizedContainerName + ""String_Node_Str""+ sanitizedContainerName+ ""String_Node_Str""+ inputPort.getName()+ ""String_Node_Str""+ channel+ ""String_Node_Str"";
        String putString=_eol + ""String_Node_Str"" + getString+ ""String_Node_Str"";
        if (receivers[channel].length > 1) {
          int foo=0;
          for (int cpt=0; cpt < receivers[channel].length; cpt++) {
            if (!(receivers[channel][cpt].getContainer().getContainer() instanceof ModalController)) {
              putString+=_eol + ""String_Node_Str"" + sanitizedContainerName+ ""String_Node_Str""+ sanitizedContainerName+ ""String_Node_Str""+ inputPort.getName()+ ""String_Node_Str""+ foo+++ ""String_Node_Str"";
            }
          }
        }
 else         putString+=_eol + ""String_Node_Str"" + sanitizedContainerName+ ""String_Node_Str""+ sanitizedContainerName+ ""String_Node_Str""+ inputPort.getName()+ ""String_Node_Str""+ _eol;
        if (container.getDirector() instanceof ptolemy.domains.modal.kernel.FSMDirector) {
          List actorList=container.deepEntityList();
          Iterator<?> actors=actorList.iterator();
          while (actors.hasNext()) {
            NamedObj actor=(NamedObj)actors.next();
            if (actor instanceof ModalController) {
              String actorName=CodeGeneratorAdapter.generateName(actor);
              String type=inputPort.getType().toString().substring(0,1).toUpperCase() + inputPort.getType().toString().substring(1);
              putString+=_eol + actorName + ""String_Node_Str""+ inputPort.getName()+ ""String_Node_Str""+ type+ ""String_Node_Str""+ _eol;
            }
          }
        }
        String fireAtString=""String_Node_Str"";
        if (container.getDirector() instanceof DEDirector) {
          NamedObj insideActor=inputPort.deepGetReceivers()[channel][0].getContainer().getContainer();
          String sanitizedNameInsideActor=CodeGeneratorAdapter.generateName(insideActor);
          if (insideActor instanceof CompositeActor)           sanitizedNameInsideActor=""String_Node_Str"" + sanitizedNameInsideActor + ""String_Node_Str"";
          fireAtString=_eol + ""String_Node_Str"" + sanitizedContainerName+ ""String_Node_Str""+ sanitizedNameInsideActor+ ""String_Node_Str""+ sanitizedContainerName+ ""String_Node_Str""+ sanitizedContainerName+ ""String_Node_Str""+ _eol;
        }
        codeStream.append(_eol + hasTokenString + putString+ fireAtString+ _eol+ ""String_Node_Str""+ _eol);
      }
    }
  }
  codeStream.append(_eol + ""String_Node_Str"" + _eol);
  codeStream.append(_eol + ""String_Node_Str"" + sanitizedContainerName+ ""String_Node_Str""+ _eol);
  Iterator<?> outputPorts=container.outputPortList().iterator();
  while (outputPorts.hasNext()) {
    TypedIOPort outputPort=(TypedIOPort)outputPorts.next();
    if (!outputPort.isOutsideConnected())     continue;
    if (container instanceof CompiledCompositeActor) {
      directorAdapter.generateTransferOutputsCode(outputPort,code);
      codeStream.append(code.toString());
      code=new StringBuffer();
    }
 else {
      for (int channel=0; channel < outputPort.getWidth(); channel++) {
        String hasTokenString=""String_Node_Str"" + sanitizedContainerName + ""String_Node_Str""+ sanitizedContainerName+ ""String_Node_Str""+ outputPort.getName()+ ""String_Node_Str""+ channel+ ""String_Node_Str""+ _eol;
        String getString=""String_Node_Str"" + sanitizedContainerName + ""String_Node_Str""+ sanitizedContainerName+ ""String_Node_Str""+ outputPort.getName()+ ""String_Node_Str""+ channel+ ""String_Node_Str"";
        String putString=""String_Node_Str"" + sanitizedContainerName + ""String_Node_Str""+ sanitizedContainerName+ ""String_Node_Str""+ outputPort.getName()+ ""String_Node_Str""+ channel+ ""String_Node_Str""+ getString+ ""String_Node_Str""+ _eol;
        String fireAtString=""String_Node_Str"";
        CompositeActor topContainer=((CompositeActor)container.getContainer());
        String sanitizedTopContainerName=CodeGeneratorAdapter.generateName(topContainer);
        if (topContainer.getDirector() instanceof DEDirector) {
          NamedObj outsideActor=outputPort.getRemoteReceivers()[channel][0].getContainer().getContainer();
          String sanitizedNameOutsideActor=CodeGeneratorAdapter.generateName(outsideActor);
          if (outsideActor instanceof CompositeActor)           sanitizedNameOutsideActor=""String_Node_Str"" + sanitizedNameOutsideActor + ""String_Node_Str"";
          fireAtString=_eol + ""String_Node_Str"" + sanitizedTopContainerName+ ""String_Node_Str""+ sanitizedNameOutsideActor+ ""String_Node_Str""+ sanitizedTopContainerName+ ""String_Node_Str""+ sanitizedTopContainerName+ ""String_Node_Str""+ _eol;
        }
        codeStream.append(_eol + hasTokenString + putString+ fireAtString+ _eol+ ""String_Node_Str""+ _eol);
      }
    }
  }
  if (container.getDirector() instanceof ptolemy.domains.modal.kernel.FSMDirector) {
    inputPorts=container.inputPortList().iterator();
    while (inputPorts.hasNext()) {
      TypedIOPort inputPort=(TypedIOPort)inputPorts.next();
      if (!inputPort.isInsideConnected())       continue;
      Receiver[][] receivers=inputPort.deepGetReceivers();
      for (int channel=0; channel < inputPort.getWidth(); channel++) {
        int foo=0;
        for (int cpt=0; cpt < receivers[channel].length; cpt++) {
          if (!(receivers[channel][cpt].getContainer().getContainer() instanceof ModalController)) {
            String hasTokenString=""String_Node_Str"" + sanitizedContainerName + ""String_Node_Str""+ sanitizedContainerName+ ""String_Node_Str""+ inputPort.getName()+ ""String_Node_Str""+ foo+ ""String_Node_Str""+ _eol;
            String putString=_eol + ""String_Node_Str"" + sanitizedContainerName+ ""String_Node_Str""+ sanitizedContainerName+ ""String_Node_Str""+ inputPort.getName()+ ""String_Node_Str""+ foo+++ ""String_Node_Str"";
            codeStream.append(_eol + hasTokenString + putString+ _eol+ ""String_Node_Str""+ _eol);
          }
        }
      }
    }
  }
  codeStream.append(_eol + ""String_Node_Str"" + _eol);
  return processCode(codeStream.toString());
}","/** 
 * Generate the transfer inputs code. This is to ensure compatibility between different directors.
 * @return The generated code.
 * @exception IllegalActionException If thrown while appending to thethe block or processing the macros.
 */
public String generateTransfersCode() throws IllegalActionException {
  CodeStream codeStream=_templateParser.getCodeStream();
  codeStream.clear();
  ptolemy.actor.CompositeActor container=(ptolemy.actor.CompositeActor)getComponent();
  String sanitizedContainerName=CodeGeneratorAdapter.generateName(container);
  Director director=container.getDirector();
  ptolemy.cg.adapter.generic.adapters.ptolemy.actor.Director directorAdapter=(ptolemy.cg.adapter.generic.adapters.ptolemy.actor.Director)getAdapter(director);
  StringBuffer code=new StringBuffer();
  codeStream.append(_eol + ""String_Node_Str"" + sanitizedContainerName+ ""String_Node_Str""+ _eol);
  Iterator<?> inputPorts=container.inputPortList().iterator();
  while (inputPorts.hasNext()) {
    TypedIOPort inputPort=(TypedIOPort)inputPorts.next();
    if (!inputPort.isInsideConnected())     continue;
    if (container instanceof CompiledCompositeActor) {
      directorAdapter.generateTransferInputsCode(inputPort,code);
      codeStream.append(code.toString());
      code=new StringBuffer();
    }
 else {
      Receiver[][] receivers=inputPort.deepGetReceivers();
      for (int channel=0; channel < inputPort.getWidth(); channel++) {
        String hasTokenString=""String_Node_Str"" + sanitizedContainerName + ""String_Node_Str""+ sanitizedContainerName+ ""String_Node_Str""+ inputPort.getName()+ ""String_Node_Str""+ channel+ ""String_Node_Str""+ _eol;
        String getString=""String_Node_Str"" + sanitizedContainerName + ""String_Node_Str""+ sanitizedContainerName+ ""String_Node_Str""+ inputPort.getName()+ ""String_Node_Str""+ channel+ ""String_Node_Str"";
        String putString=_eol + ""String_Node_Str"" + getString+ ""String_Node_Str"";
        if (receivers[channel].length > 1) {
          int foo=0;
          for (int cpt=0; cpt < receivers[channel].length; cpt++) {
            if (!(receivers[channel][cpt].getContainer().getContainer() instanceof ModalController)) {
              putString+=_eol + ""String_Node_Str"" + sanitizedContainerName+ ""String_Node_Str""+ sanitizedContainerName+ ""String_Node_Str""+ inputPort.getName()+ ""String_Node_Str""+ foo+++ ""String_Node_Str"";
            }
          }
        }
 else         putString+=_eol + ""String_Node_Str"" + sanitizedContainerName+ ""String_Node_Str""+ sanitizedContainerName+ ""String_Node_Str""+ inputPort.getName()+ ""String_Node_Str""+ channel+ ""String_Node_Str""+ _eol;
        if (container.getDirector() instanceof ptolemy.domains.modal.kernel.FSMDirector) {
          List actorList=container.deepEntityList();
          Iterator<?> actors=actorList.iterator();
          while (actors.hasNext()) {
            NamedObj actor=(NamedObj)actors.next();
            if (actor instanceof ModalController) {
              String actorName=CodeGeneratorAdapter.generateName(actor);
              String type=inputPort.getType().toString().substring(0,1).toUpperCase() + inputPort.getType().toString().substring(1);
              putString+=_eol + actorName + ""String_Node_Str""+ inputPort.getName()+ ""String_Node_Str""+ type+ ""String_Node_Str""+ _eol;
            }
          }
        }
        String fireAtString=""String_Node_Str"";
        if (container.getDirector() instanceof DEDirector) {
          NamedObj insideActor=inputPort.deepGetReceivers()[channel][0].getContainer().getContainer();
          String sanitizedNameInsideActor=CodeGeneratorAdapter.generateName(insideActor);
          if (insideActor instanceof CompositeActor)           sanitizedNameInsideActor=""String_Node_Str"" + sanitizedNameInsideActor + ""String_Node_Str"";
          fireAtString=_eol + ""String_Node_Str"" + sanitizedContainerName+ ""String_Node_Str""+ sanitizedNameInsideActor+ ""String_Node_Str""+ sanitizedContainerName+ ""String_Node_Str""+ sanitizedContainerName+ ""String_Node_Str""+ _eol;
        }
        codeStream.append(_eol + hasTokenString + putString+ fireAtString+ _eol+ ""String_Node_Str""+ _eol);
      }
    }
  }
  codeStream.append(_eol + ""String_Node_Str"" + _eol);
  codeStream.append(_eol + ""String_Node_Str"" + sanitizedContainerName+ ""String_Node_Str""+ _eol);
  Iterator<?> outputPorts=container.outputPortList().iterator();
  while (outputPorts.hasNext()) {
    TypedIOPort outputPort=(TypedIOPort)outputPorts.next();
    if (!outputPort.isOutsideConnected())     continue;
    if (container instanceof CompiledCompositeActor) {
      directorAdapter.generateTransferOutputsCode(outputPort,code);
      codeStream.append(code.toString());
      code=new StringBuffer();
    }
 else {
      for (int channel=0; channel < outputPort.getWidth(); channel++) {
        String hasTokenString=""String_Node_Str"" + sanitizedContainerName + ""String_Node_Str""+ sanitizedContainerName+ ""String_Node_Str""+ outputPort.getName()+ ""String_Node_Str""+ channel+ ""String_Node_Str""+ _eol;
        String getString=""String_Node_Str"" + sanitizedContainerName + ""String_Node_Str""+ sanitizedContainerName+ ""String_Node_Str""+ outputPort.getName()+ ""String_Node_Str""+ channel+ ""String_Node_Str"";
        String putString=""String_Node_Str"" + sanitizedContainerName + ""String_Node_Str""+ sanitizedContainerName+ ""String_Node_Str""+ outputPort.getName()+ ""String_Node_Str""+ channel+ ""String_Node_Str""+ getString+ ""String_Node_Str""+ _eol;
        String fireAtString=""String_Node_Str"";
        CompositeActor topContainer=((CompositeActor)container.getContainer());
        String sanitizedTopContainerName=CodeGeneratorAdapter.generateName(topContainer);
        if (topContainer.getDirector() instanceof DEDirector) {
          NamedObj outsideActor=outputPort.getRemoteReceivers()[channel][0].getContainer().getContainer();
          String sanitizedNameOutsideActor=CodeGeneratorAdapter.generateName(outsideActor);
          if (outsideActor instanceof CompositeActor)           sanitizedNameOutsideActor=""String_Node_Str"" + sanitizedNameOutsideActor + ""String_Node_Str"";
          fireAtString=_eol + ""String_Node_Str"" + sanitizedTopContainerName+ ""String_Node_Str""+ sanitizedNameOutsideActor+ ""String_Node_Str""+ sanitizedTopContainerName+ ""String_Node_Str""+ sanitizedTopContainerName+ ""String_Node_Str""+ _eol;
        }
        codeStream.append(_eol + hasTokenString + putString+ fireAtString+ _eol+ ""String_Node_Str""+ _eol);
      }
    }
  }
  if (container.getDirector() instanceof ptolemy.domains.modal.kernel.FSMDirector) {
    inputPorts=container.inputPortList().iterator();
    while (inputPorts.hasNext()) {
      TypedIOPort inputPort=(TypedIOPort)inputPorts.next();
      if (!inputPort.isInsideConnected())       continue;
      Receiver[][] receivers=inputPort.deepGetReceivers();
      for (int channel=0; channel < inputPort.getWidth(); channel++) {
        int foo=0;
        for (int cpt=0; cpt < receivers[channel].length; cpt++) {
          if (!(receivers[channel][cpt].getContainer().getContainer() instanceof ModalController)) {
            String hasTokenString=""String_Node_Str"" + sanitizedContainerName + ""String_Node_Str""+ sanitizedContainerName+ ""String_Node_Str""+ inputPort.getName()+ ""String_Node_Str""+ foo+ ""String_Node_Str""+ _eol;
            String putString=_eol + ""String_Node_Str"" + sanitizedContainerName+ ""String_Node_Str""+ sanitizedContainerName+ ""String_Node_Str""+ inputPort.getName()+ ""String_Node_Str""+ foo+++ ""String_Node_Str"";
            codeStream.append(_eol + hasTokenString + putString+ _eol+ ""String_Node_Str""+ _eol);
          }
        }
      }
    }
  }
  codeStream.append(_eol + ""String_Node_Str"" + _eol);
  return processCode(codeStream.toString());
}"
72927,"/** 
 * Schedule an actor for execution on a ResourceScheduler. If the actor can execute this method returns true. If resources are not available this method returns false.
 * @param actor The actor.
 * @param timestamp The time the actor requests to be scheduled.
 * @return True if actor was scheduled and can be fired.
 * @exception IllegalActionException Thrown if parameters cannot be read, actor cannot bescheduled or container cannot be fired at future time.
 */
protected boolean _schedule(Actor actor,Time timestamp) throws IllegalActionException {
  ResourceScheduler scheduler=_getResourceScheduler(actor);
  Time time=null;
  Boolean finished=true;
  if (timestamp == null) {
    timestamp=getModelTime();
  }
  if (scheduler != null) {
    Time environmentTime=((CompositeActor)scheduler.getContainer()).getDirector().getEnvironmentTime();
    time=scheduler.schedule(actor,environmentTime,getDeadline(actor,timestamp));
    if (_nextScheduleTime == null) {
      _nextScheduleTime=new HashMap<ResourceScheduler,Time>();
    }
    _nextScheduleTime.put(scheduler,time);
    finished=_actorFinished(actor);
    if (time != null && time.getDoubleValue() > 0.0) {
      CompositeActor container=(CompositeActor)scheduler.getContainer();
      Time fireAtTime=environmentTime;
      if (!time.equals(Time.POSITIVE_INFINITY)) {
        fireAtTime=fireAtTime.add(time);
        container.getDirector().fireContainerAt(fireAtTime);
      }
    }
  }
 else   if (isEmbedded()) {
    return ((CompositeActor)((CompositeActor)getContainer()).getContainer()).getDirector()._schedule(actor,timestamp);
  }
  return time == null || finished;
}","/** 
 * Schedule an actor for execution on a ResourceScheduler. If the actor can execute this method returns true. If resources are not available this method returns false.
 * @param actor The actor.
 * @param timestamp The time the actor requests to be scheduled.
 * @return True if actor was scheduled and can be fired.
 * @exception IllegalActionException Thrown if parameters cannot be read, actor cannot bescheduled or container cannot be fired at future time.
 */
protected boolean _schedule(Actor actor,Time timestamp) throws IllegalActionException {
  ResourceScheduler scheduler=_getResourceScheduler(actor);
  Time time=null;
  Boolean finished=true;
  if (timestamp == null) {
    timestamp=getModelTime();
  }
  if (scheduler != null) {
    Time environmentTime=((CompositeActor)scheduler.getContainer()).getDirector().getEnvironmentTime();
    time=scheduler.schedule(actor,environmentTime,getDeadline(actor,timestamp));
    if (_nextScheduleTime == null) {
      _nextScheduleTime=new HashMap<ResourceScheduler,Time>();
    }
    _nextScheduleTime.put(scheduler,time);
    finished=_actorFinished(actor);
    if (time != null && time.getDoubleValue() > 0.0) {
      CompositeActor container=(CompositeActor)scheduler.getContainer();
      Time fireAtTime=environmentTime;
      if (!time.equals(Time.POSITIVE_INFINITY)) {
        fireAtTime=fireAtTime.add(time);
        container.getDirector().fireContainerAt(fireAtTime);
      }
    }
  }
  return time == null || finished;
}"
72928,"/** 
 * Return true to indicate that this decorator should decorate objects across opaque hierarchy boundaries.
 */
public boolean isGlobalDecorator(){
  return false;
}","/** 
 * Return true to indicate that this decorator should decorate objects across opaque hierarchy boundaries.
 */
public boolean isGlobalDecorator(){
  return true;
}"
72929,"/** 
 * Return true if the director is ready to fire. This method is called by the container of this director to determine whether the director is ready to execute. It does <i>not</i> call prefire() on the contained actors.  If this director is not at the top level of the hierarchy, and the current time of the enclosing model is greater than the current time of this director, then this base class updates current time to match that of the enclosing model.  <p> In this base class, assume that the director is always ready to be fired, and so return true.  Domain directors should probably override this method to provide domain-specific operation.  However, they should call super.prefire() if they wish to propagate time as done here.
 * @return True.
 * @exception IllegalActionException Not thrown in this base class.
 */
public boolean prefire() throws IllegalActionException {
  _postfireReturns=true;
  _prefire=super.prefire();
  if (_resourceScheduling && _prefire) {
    Iterator firings=null;
    if (_savedSchedule == null) {
      Scheduler scheduler=getScheduler();
      Schedule schedule=scheduler.getSchedule();
      _savedSchedule=schedule;
      _savedSchedulePosition=0;
      firings=schedule.firingIterator();
    }
 else {
      firings=_savedSchedule.firingIterator();
      for (int i=0; i < _savedSchedulePosition; i++) {
        firings.next();
      }
    }
    Firing firing=null;
    while ((_savedIterationCount > 0 || firings.hasNext()) && !_stopRequested) {
      if (firing == null || _savedIterationCount == 0) {
        firing=(Firing)firings.next();
      }
      Actor actor=firing.getActor();
      if (_currentlyExecuting) {
        _prefire=false;
        return false;
      }
      if (!_actorFinished) {
        boolean finished=_schedule(actor,getModelTime());
        if (!finished) {
          _currentlyExecuting=true;
          _prefire=false;
          return false;
        }
      }
      _currentlyExecuting=false;
      _actorFinished=false;
      if (_savedIterationCount == 0) {
        _savedIterationCount=firing.getIterationCount();
      }
      _savedIterationCount--;
      if (_savedIterationCount == 0) {
        _savedSchedulePosition++;
      }
    }
    if (_savedSchedule.size() <= _savedSchedulePosition) {
      _savedSchedule=null;
    }
  }
  return _prefire;
}","/** 
 * Return true if the director is ready to fire. This method is called by the container of this director to determine whether the director is ready to execute. It does <i>not</i> call prefire() on the contained actors.  If this director is not at the top level of the hierarchy, and the current time of the enclosing model is greater than the current time of this director, then this base class updates current time to match that of the enclosing model.  <p> In this base class, assume that the director is always ready to be fired, and so return true.  Domain directors should probably override this method to provide domain-specific operation.  However, they should call super.prefire() if they wish to propagate time as done here.
 * @return True.
 * @exception IllegalActionException Not thrown in this base class.
 */
public boolean prefire() throws IllegalActionException {
  _postfireReturns=true;
  _prefire=super.prefire();
  if (_resourceScheduling && _prefire) {
    Iterator firings=null;
    if (_savedSchedule == null) {
      Scheduler scheduler=getScheduler();
      Schedule schedule=scheduler.getSchedule();
      _savedSchedule=schedule;
      _savedSchedulePosition=0;
      firings=schedule.firingIterator();
    }
 else {
      firings=_savedSchedule.firingIterator();
      for (int i=0; i < _savedSchedulePosition; i++) {
        firings.next();
      }
    }
    Firing firing=null;
    while ((_savedIterationCount > 0 || firings.hasNext()) && !_stopRequested) {
      if (firing == null || _savedIterationCount == 0) {
        firing=(Firing)firings.next();
      }
      Actor actor=firing.getActor();
      if (!_actorFinished) {
        boolean finished=_schedule(actor,getModelTime());
        if (!finished) {
          _currentlyExecuting=true;
          _prefire=false;
          return false;
        }
      }
      _currentlyExecuting=false;
      _actorFinished=false;
      if (_savedIterationCount == 0) {
        _savedIterationCount=firing.getIterationCount();
      }
      _savedIterationCount--;
      if (_savedIterationCount == 0) {
        _savedSchedulePosition++;
      }
    }
    if (_savedSchedule.size() <= _savedSchedulePosition) {
      _savedSchedule=null;
    }
  }
  return _prefire;
}"
72930,"/** 
 * Schedule an actor for execution on a ResourceScheduler. If the actor can execute this method returns true. If resources are not available this method returns false.
 * @param actor The actor.
 * @param timestamp The time the actor requests to be scheduled.
 * @return True if actor was scheduled and can be fired.
 * @exception IllegalActionException Thrown if parameters cannot be read, actor cannot bescheduled or container cannot be fired at future time.
 */
protected boolean _schedule(Actor actor,Time timestamp) throws IllegalActionException {
  ResourceScheduler scheduler=_getResourceScheduler(actor);
  Time time=null;
  Boolean finished=true;
  if (timestamp == null) {
    timestamp=getModelTime();
  }
  if (scheduler != null) {
    Time environmentTime=((CompositeActor)scheduler.getContainer()).getDirector().getEnvironmentTime();
    time=scheduler.schedule(actor,environmentTime,getDeadline(actor,timestamp));
    if (_nextScheduleTime == null) {
      _nextScheduleTime=new HashMap<ResourceScheduler,Time>();
    }
    _nextScheduleTime.put(scheduler,time);
    finished=_actorFinished(actor);
    if (time != null && time.getDoubleValue() > 0.0) {
      CompositeActor container=(CompositeActor)scheduler.getContainer();
      Time fireAtTime=environmentTime;
      if (!time.equals(Time.POSITIVE_INFINITY)) {
        fireAtTime=fireAtTime.add(time);
        fireAt(actor,fireAtTime);
        container.getDirector().fireContainerAt(fireAtTime);
      }
    }
  }
 else   if (isEmbedded()) {
    return ((CompositeActor)((CompositeActor)getContainer()).getContainer()).getDirector()._schedule(actor,timestamp);
  }
  return time == null || finished;
}","/** 
 * Schedule an actor for execution on a ResourceScheduler. If the actor can execute this method returns true. If resources are not available this method returns false.
 * @param actor The actor.
 * @param timestamp The time the actor requests to be scheduled.
 * @return True if actor was scheduled and can be fired.
 * @exception IllegalActionException Thrown if parameters cannot be read, actor cannot bescheduled or container cannot be fired at future time.
 */
protected boolean _schedule(Actor actor,Time timestamp) throws IllegalActionException {
  ResourceScheduler scheduler=_getResourceScheduler(actor);
  Time time=null;
  Boolean finished=true;
  if (timestamp == null) {
    timestamp=getModelTime();
  }
  if (scheduler != null) {
    Time environmentTime=((CompositeActor)scheduler.getContainer()).getDirector().getEnvironmentTime();
    time=scheduler.schedule(actor,environmentTime,getDeadline(actor,timestamp));
    if (_nextScheduleTime == null) {
      _nextScheduleTime=new HashMap<ResourceScheduler,Time>();
    }
    _nextScheduleTime.put(scheduler,time);
    finished=_actorFinished(actor);
    if (time != null && time.getDoubleValue() > 0.0) {
      CompositeActor container=(CompositeActor)scheduler.getContainer();
      Time fireAtTime=environmentTime;
      if (!time.equals(Time.POSITIVE_INFINITY)) {
        fireAtTime=fireAtTime.add(time);
        container.getDirector().fireContainerAt(fireAtTime);
      }
    }
  }
 else   if (isEmbedded()) {
    return ((CompositeActor)((CompositeActor)getContainer()).getContainer()).getDirector()._schedule(actor,timestamp);
  }
  return time == null || finished;
}"
72931,"/** 
 * Initiate a send of the specified token to the specified receiver. This method will schedule a refiring of this actor if there is not one already scheduled.
 * @param source Sender of the token.
 * @param receiver The receiver to send to.
 * @param token The token to send.
 * @exception IllegalActionException If the refiring request fails.
 */
public void sendToken(Receiver source,Receiver receiver,Token token) throws IllegalActionException {
  String name=_cqmInputPortName.get(receiver.getContainer());
  CQMInputPort port=(CQMInputPort)getEntity(name);
  if (port == null) {
    throw new IllegalActionException(this,""String_Node_Str"" + name + ""String_Node_Str""+ receiver.getContainer()+ ""String_Node_Str"");
  }
  if (_tokens == null) {
    _tokens=new HashMap<CQMInputPort,Token>();
  }
  RecordToken recordToken=new RecordToken(new String[]{""String_Node_Str"",""String_Node_Str""},new Token[]{new ObjectToken(receiver),token});
  _tokens.put(port,recordToken);
  if (_justMonitor) {
    receiver.put(token);
  }
  ((CompositeActor)getContainer()).getDirector().fireAtCurrentTime(this);
  if (_debugging) {
    _debug(""String_Node_Str"" + getDirector().getModelTime() + ""String_Node_Str""+ receiver.getContainer().getFullName()+ ""String_Node_Str""+ token);
  }
}","/** 
 * Initiate a send of the specified token to the specified receiver. This method will schedule a refiring of this actor if there is not one already scheduled.
 * @param source Sender of the token.
 * @param receiver The receiver to send to.
 * @param token The token to send.
 * @exception IllegalActionException If the refiring request fails.
 */
public void sendToken(Receiver source,Receiver receiver,Token token) throws IllegalActionException {
  String name=_cqmInputPortName.get(receiver.getContainer());
  CQMInputPort port=(CQMInputPort)getEntity(name);
  if (port == null) {
    throw new IllegalActionException(this,""String_Node_Str"" + name + ""String_Node_Str""+ receiver.getContainer()+ ""String_Node_Str"");
  }
  if (_tokens == null) {
    _tokens=new HashMap<CQMInputPort,Token>();
  }
  if (token != null) {
    RecordToken recordToken=new RecordToken(new String[]{""String_Node_Str"",""String_Node_Str""},new Token[]{new ObjectToken(receiver),token});
    _tokens.put(port,recordToken);
    if (_justMonitor) {
      receiver.put(token);
    }
    ((CompositeActor)getContainer()).getDirector().fireAtCurrentTime(this);
    if (_debugging) {
      _debug(""String_Node_Str"" + getDirector().getModelTime() + ""String_Node_Str""+ receiver.getContainer().getFullName()+ ""String_Node_Str""+ token);
    }
  }
}"
72932,"/** 
 * Generate The postfire function code for a SDF director. 
 * @return The postfire function code.
 * @exception IllegalActionException If thrown while generating fire code.
 */
public String generatePostFireFunctionCode() throws IllegalActionException {
  StringBuffer code=new StringBuffer();
  code.append(_eol + _sanitizedDirectorName + ""String_Node_Str"");
  code.append(_eol + ""String_Node_Str"" + _sanitizedDirectorName+ ""String_Node_Str""+ _sanitizedDirectorName+ ""String_Node_Str""+ _sanitizedDirectorName+ ""String_Node_Str"");
  code.append(_eol + _sanitizedDirectorName + ""String_Node_Str"");
  code.append(_eol + ""String_Node_Str"");
  code.append(_eol + ""String_Node_Str"");
  Attribute period=_director.getAttribute(""String_Node_Str"");
  if (period != null) {
    Double periodValue=((DoubleToken)((Variable)period).getToken()).doubleValue();
    if (periodValue != 0.0) {
      code.append(_sanitizedDirectorName + ""String_Node_Str"" + periodValue+ ""String_Node_Str""+ _eol);
    }
  }
  code.append(_eol + ""String_Node_Str"");
  return code.toString();
}","/** 
 * Generate The postfire function code for a SDF director. 
 * @return The postfire function code.
 * @exception IllegalActionException If thrown while generating fire code.
 */
public String generatePostFireFunctionCode() throws IllegalActionException {
  StringBuffer code=new StringBuffer();
  code.append(_eol + _sanitizedDirectorName + ""String_Node_Str"");
  code.append(_eol + ""String_Node_Str"" + _sanitizedDirectorName+ ""String_Node_Str""+ _sanitizedDirectorName+ ""String_Node_Str"");
  code.append(_eol + _sanitizedDirectorName + ""String_Node_Str"");
  code.append(_eol + ""String_Node_Str"");
  code.append(_eol + ""String_Node_Str"");
  Attribute period=_director.getAttribute(""String_Node_Str"");
  if (period != null) {
    Double periodValue=((DoubleToken)((Variable)period).getToken()).doubleValue();
    if (periodValue != 0.0) {
      code.append(_sanitizedDirectorName + ""String_Node_Str"" + periodValue+ ""String_Node_Str""+ _eol);
    }
  }
  code.append(_eol + ""String_Node_Str"");
  return code.toString();
}"
72933,"private void populateArrays() throws IllegalActionException {
  Token transToken=new Token();
  if (_modelType == _HMM) {
    transToken=transitionMatrix.get(0);
  }
  Token meanToken=mean.get(0);
  Token stdToken=standardDeviation.get(0);
  Token priorToken=prior.get(0);
  Token observationArray=input.get(0);
  _nStates=((ArrayToken)meanToken).length();
  _meanEstimate=new double[_nStates];
  _stDeviationEstimate=new double[_nStates];
  _transitionMatrixEstimate=new double[_nStates][_nStates];
  _priors=new double[_nStates];
  _classificationLength=((ArrayToken)observationArray).length();
  _observations=new double[_classificationLength];
  for (int i=0; i < _classificationLength; i++) {
    _observations[i]=((DoubleToken)((ArrayToken)observationArray).getElement(i)).doubleValue();
  }
  for (int i=0; i < _nStates; i++) {
    _stDeviationEstimate[i]=((DoubleToken)((ArrayToken)stdToken).getElement(i)).doubleValue();
    _meanEstimate[i]=((DoubleToken)((ArrayToken)meanToken).getElement(i)).doubleValue();
    _priors[i]=((DoubleToken)((ArrayToken)priorToken).getElement(i)).doubleValue();
    if (_modelType == _HMM) {
      for (int j=0; j < _nStates; j++) {
        _transitionMatrixEstimate[i][j]=((DoubleToken)((MatrixToken)transToken).getElementAsToken(i,j)).doubleValue();
      }
    }
  }
}","private void populateArrays() throws IllegalActionException {
  Token observationArray=input.get(0);
  _classificationLength=((ArrayToken)observationArray).length();
  _observations=new double[_classificationLength];
  for (int i=0; i < _classificationLength; i++) {
    _observations[i]=((DoubleToken)((ArrayToken)observationArray).getElement(i)).doubleValue();
  }
}"
72934,"/** 
 * Construct an actor with the given container and name.
 * @param container The container.
 * @param name The name of this actor
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public ClassifyObservations(CompositeEntity container,String name) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  mean=new TypedIOPort(this,""String_Node_Str"",true,false);
  mean.setTypeEquals(new ArrayType(BaseType.DOUBLE));
  StringAttribute cardinality=new StringAttribute(mean,""String_Node_Str"");
  cardinality.setExpression(""String_Node_Str"");
  modelType=new StringParameter(this,""String_Node_Str"");
  modelType.setExpression(""String_Node_Str"");
  modelType.addChoice(""String_Node_Str"");
  modelType.addChoice(""String_Node_Str"");
  _modelType=_HMM;
  standardDeviation=new TypedIOPort(this,""String_Node_Str"",true,false);
  standardDeviation.setTypeEquals(new ArrayType(BaseType.DOUBLE));
  cardinality=new StringAttribute(standardDeviation,""String_Node_Str"");
  cardinality.setExpression(""String_Node_Str"");
  transitionMatrix=new TypedIOPort(this,""String_Node_Str"",true,false);
  transitionMatrix.setTypeEquals(BaseType.DOUBLE_MATRIX);
  cardinality=new StringAttribute(transitionMatrix,""String_Node_Str"");
  cardinality.setExpression(""String_Node_Str"");
  prior=new TypedIOPort(this,""String_Node_Str"",true,false);
  prior.setTypeEquals(new ArrayType(BaseType.DOUBLE));
  input=new TypedIOPort(this,""String_Node_Str"",true,false);
  input.setTypeEquals(new ArrayType(BaseType.DOUBLE));
  output=new TypedIOPort(this,""String_Node_Str"",false,true);
  output.setTypeEquals(new ArrayType(BaseType.INT));
  emissionDistribution=new StringParameter(this,""String_Node_Str"");
  emissionDistribution.setExpression(""String_Node_Str"");
  _distribution=_GAUSSIAN;
}","/** 
 * Construct an actor with the given container and name.
 * @param container The container.
 * @param name The name of this actor
 * @exception IllegalActionException If the actor cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public ClassifyObservations(CompositeEntity container,String name) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  mean=new PortParameter(this,""String_Node_Str"");
  mean.setExpression(""String_Node_Str"");
  mean.setTypeEquals(new ArrayType(BaseType.DOUBLE));
  StringAttribute cardinality=new StringAttribute(mean.getPort(),""String_Node_Str"");
  cardinality.setExpression(""String_Node_Str"");
  modelType=new StringParameter(this,""String_Node_Str"");
  modelType.setExpression(""String_Node_Str"");
  modelType.addChoice(""String_Node_Str"");
  modelType.addChoice(""String_Node_Str"");
  _modelType=_HMM;
  standardDeviation=new PortParameter(this,""String_Node_Str"");
  standardDeviation.setExpression(""String_Node_Str"");
  standardDeviation.setTypeEquals(new ArrayType(BaseType.DOUBLE));
  cardinality=new StringAttribute(standardDeviation.getPort(),""String_Node_Str"");
  cardinality.setExpression(""String_Node_Str"");
  transitionMatrix=new PortParameter(this,""String_Node_Str"");
  transitionMatrix.setExpression(""String_Node_Str"");
  transitionMatrix.setTypeEquals(BaseType.DOUBLE_MATRIX);
  cardinality=new StringAttribute(transitionMatrix.getPort(),""String_Node_Str"");
  cardinality.setExpression(""String_Node_Str"");
  prior=new PortParameter(this,""String_Node_Str"");
  prior.setExpression(""String_Node_Str"");
  prior.setTypeEquals(new ArrayType(BaseType.DOUBLE));
  cardinality=new StringAttribute(prior.getPort(),""String_Node_Str"");
  cardinality.setExpression(""String_Node_Str"");
  input=new TypedIOPort(this,""String_Node_Str"",true,false);
  input.setTypeEquals(new ArrayType(BaseType.DOUBLE));
  output=new TypedIOPort(this,""String_Node_Str"",false,true);
  output.setTypeEquals(new ArrayType(BaseType.INT));
  emissionDistribution=new StringParameter(this,""String_Node_Str"");
  emissionDistribution.setExpression(""String_Node_Str"");
  _distribution=_GAUSSIAN;
  _nStates=((ArrayToken)mean.getToken()).length();
  _meanEstimate=new double[_nStates];
  _stDeviationEstimate=new double[_nStates];
  _transitionMatrixEstimate=new double[_nStates][_nStates];
  _priors=new double[_nStates];
}"
72935,"/** 
 * Ensure that the order parameter is positive and recompute the size of internal buffers.
 * @param attribute The attribute that has changed.
 * @exception IllegalActionException If the parameters are out of range.
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == emissionDistribution) {
    String functionName=emissionDistribution.getExpression().trim().toLowerCase();
    if (functionName.equals(""String_Node_Str"")) {
      _distribution=_GAUSSIAN;
    }
 else     if (functionName.equals(""String_Node_Str"")) {
      _distribution=_EXPONENTIAL;
    }
 else     if (functionName.equals(""String_Node_Str"")) {
      _distribution=_RICIAN;
    }
 else     if (functionName.equals(""String_Node_Str"")) {
      _distribution=_MULTINOMIAL;
    }
 else {
      throw new IllegalActionException(this,""String_Node_Str"" + functionName + ""String_Node_Str""+ ""String_Node_Str"");
    }
  }
 else   if (attribute == modelType) {
    String modelName=modelType.getExpression().trim().toLowerCase();
    if (modelName.equals(""String_Node_Str"")) {
      _modelType=_MM;
      transitionMatrix.setTypeEquals(new ArrayType(BaseType.DOUBLE));
    }
 else     if (modelName.equals(""String_Node_Str"")) {
      _modelType=_HMM;
      transitionMatrix.setTypeEquals(BaseType.DOUBLE_MATRIX);
    }
 else {
      throw new IllegalActionException(this,""String_Node_Str"" + modelName + ""String_Node_Str"");
    }
  }
 else {
    super.attributeChanged(attribute);
  }
}","/** 
 * Ensure that the order parameter is positive and recompute the size of internal buffers.
 * @param attribute The attribute that has changed.
 * @exception IllegalActionException If the parameters are out of range.
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == emissionDistribution) {
    String functionName=emissionDistribution.getExpression().trim().toLowerCase();
    if (functionName.equals(""String_Node_Str"")) {
      _distribution=_GAUSSIAN;
    }
 else     if (functionName.equals(""String_Node_Str"")) {
      _distribution=_EXPONENTIAL;
    }
 else     if (functionName.equals(""String_Node_Str"")) {
      _distribution=_RICIAN;
    }
 else     if (functionName.equals(""String_Node_Str"")) {
      _distribution=_MULTINOMIAL;
    }
 else {
      throw new IllegalActionException(this,""String_Node_Str"" + functionName + ""String_Node_Str""+ ""String_Node_Str"");
    }
  }
 else   if (attribute == modelType) {
    String modelName=modelType.getExpression().trim().toLowerCase();
    if (modelName.equals(""String_Node_Str"")) {
      _modelType=_MM;
    }
 else     if (modelName.equals(""String_Node_Str"")) {
      _modelType=_HMM;
    }
 else {
      throw new IllegalActionException(this,""String_Node_Str"" + modelName + ""String_Node_Str"");
    }
  }
 else   if (attribute == mean) {
    _nStates=((ArrayToken)mean.getToken()).length();
    _meanEstimate=new double[_nStates];
    for (int i=0; i < _nStates; i++) {
      _meanEstimate[i]=((DoubleToken)((ArrayToken)mean.getToken()).getElement(i)).doubleValue();
    }
  }
 else   if (attribute == standardDeviation) {
    _nStates=((ArrayToken)standardDeviation.getToken()).length();
    _stDeviationEstimate=new double[_nStates];
    for (int i=0; i < _nStates; i++) {
      _stDeviationEstimate[i]=((DoubleToken)((ArrayToken)standardDeviation.getToken()).getElement(i)).doubleValue();
    }
  }
 else   if (attribute == prior) {
    _nStates=((ArrayToken)standardDeviation.getToken()).length();
    _priors=new double[_nStates];
    for (int i=0; i < _nStates; i++) {
      _priors[i]=((DoubleToken)((ArrayToken)prior.getToken()).getElement(i)).doubleValue();
    }
  }
 else   if (attribute == transitionMatrix) {
    _nStates=((ArrayToken)standardDeviation.getToken()).length();
    _transitionMatrixEstimate=new double[_nStates][_nStates];
    for (int i=0; i < _nStates; i++) {
      for (int j=0; j < _nStates; j++) {
        _transitionMatrixEstimate[i][j]=((DoubleToken)((MatrixToken)transitionMatrix.getToken()).getElementAsToken(i,j)).doubleValue();
      }
    }
  }
 else {
    super.attributeChanged(attribute);
  }
}"
72936,"public static final HashMap gaussianHMM(int startAt,double[] y,double[][] A,double[] mu,double[] sigma,double[] prior){
  int nStates=mu.length;
  double[][] alphas=new double[y.length][nStates];
  double[][] betas=new double[y.length][nStates];
  double[] Py=new double[y.length];
  double[][] gamma=new double[y.length][nStates];
  for (int t=0; t < y.length; t++) {
    for (int i=0; i < nStates; i++) {
      if (t == 0) {
        alphas[t][i]=prior[i] * gaussian(y[t],mu[i],sigma[i]);
      }
 else {
        alphas[t][i]=0;
        for (int qt=0; qt < nStates; qt++) {
          alphas[t][i]+=A[qt][i] * gaussian(y[t],mu[i],sigma[i]) * alphas[t - 1][qt];
        }
      }
    }
  }
  for (int t=y.length - 1; t >= 0; t--) {
    Py[t]=0;
    for (int i=0; i < nStates; i++) {
      gamma[t][i]=0.0;
      if (t == y.length - 1) {
        betas[t][i]=1;
      }
 else {
        betas[t][i]=0;
        for (int qtp=0; qtp < nStates; qtp++) {
          betas[t][i]+=A[i][qtp] * gaussian(y[t + 1],mu[qtp],sigma[qtp]) * betas[t + 1][qtp];
        }
      }
      Py[t]+=alphas[t][i] * betas[t][i];
    }
    for (int i=0; i < nStates; i++) {
      gamma[t][i]+=alphas[t][i] * betas[t][i] / Py[t];
    }
  }
  double[][][] psi=new double[y.length - 1][nStates][nStates];
  double[][] A_hat=new double[nStates][nStates];
  double[] mu_hat=new double[nStates];
  double[] s_hat=new double[nStates];
  for (int next=0; next < nStates; next++) {
    for (int now=0; now < nStates; now++) {
      for (int t=0; t < (y.length - 1); t++) {
        if (alphas[t + 1][next] == 0) {
          psi[t][now][next]=0;
        }
 else {
          psi[t][now][next]=alphas[t][now] * gaussian(y[t + 1],mu[next],sigma[next]) * gamma[t + 1][next]* A[now][next] / alphas[t + 1][next];
        }
        A_hat[now][next]+=psi[t][now][next];
      }
    }
    mu_hat[next]=0;
    s_hat[next]=0;
  }
  double[] rowsum=new double[nStates];
  double[] gammasum=new double[nStates];
  for (int i=0; i < nStates; i++) {
    rowsum[i]=0;
    for (int j=0; j < nStates; j++) {
      rowsum[i]+=A_hat[i][j];
    }
    for (int j=0; j < nStates; j++) {
      A_hat[i][j]/=rowsum[i];
    }
    gammasum[i]=0.0;
  }
  for (int j=0; j < nStates; j++) {
    gammasum[j]=0.0;
    for (int t=0; t < y.length; t++) {
      gammasum[j]+=gamma[t][j];
      mu_hat[j]+=gamma[t][j] * y[t];
    }
    mu_hat[j]=mu_hat[j] / gammasum[j];
    for (int t=0; t < y.length; t++) {
      s_hat[j]+=(gamma[t][j] * Math.pow((y[t] - mu_hat[j]),2));
    }
    s_hat[j]=Math.pow(s_hat[j] / gammasum[j],0.5);
  }
  HashMap estimates=new HashMap();
  estimates=sortEstimates(mu_hat,s_hat,A_hat);
  return estimates;
}","public static final HashMap gaussianHMM(int startAt,double[] y,double[][] A,double[] mu,double[] sigma,double[] prior){
  int nStates=mu.length;
  double[][] alphas=new double[y.length][nStates];
  double[][] betas=new double[y.length][nStates];
  double[] Py=new double[y.length];
  double[][] gamma=new double[y.length][nStates];
  for (int t=0; t < y.length; t++) {
    for (int i=0; i < nStates; i++) {
      if (t == 0) {
        alphas[t][i]=prior[i] * gaussian(y[t],mu[i],sigma[i]);
      }
 else {
        alphas[t][i]=0;
        for (int qt=0; qt < nStates; qt++) {
          alphas[t][i]+=A[qt][i] * gaussian(y[t],mu[i],sigma[i]) * alphas[t - 1][qt];
        }
      }
    }
  }
  for (int t=y.length - 1; t >= 0; t--) {
    Py[t]=0;
    for (int i=0; i < nStates; i++) {
      gamma[t][i]=0.0;
      if (t == y.length - 1) {
        betas[t][i]=1;
      }
 else {
        betas[t][i]=0;
        for (int qtp=0; qtp < nStates; qtp++) {
          betas[t][i]+=A[i][qtp] * gaussian(y[t + 1],mu[qtp],sigma[qtp]) * betas[t + 1][qtp];
        }
      }
      Py[t]+=alphas[t][i] * betas[t][i];
    }
    for (int i=0; i < nStates; i++) {
      gamma[t][i]+=alphas[t][i] * betas[t][i] / Py[t];
    }
  }
  double[][][] psi=new double[y.length - 1][nStates][nStates];
  double[][] A_hat=new double[nStates][nStates];
  double[] mu_hat=new double[nStates];
  double[] s_hat=new double[nStates];
  for (int next=0; next < nStates; next++) {
    for (int now=0; now < nStates; now++) {
      for (int t=0; t < (y.length - 1); t++) {
        if (alphas[t + 1][next] == 0) {
          psi[t][now][next]=0;
        }
 else {
          psi[t][now][next]=alphas[t][now] * gaussian(y[t + 1],mu[next],sigma[next]) * gamma[t + 1][next]* A[now][next] / alphas[t + 1][next];
        }
        A_hat[now][next]+=psi[t][now][next];
      }
    }
    mu_hat[next]=0;
    s_hat[next]=0;
  }
  double[] rowsum=new double[nStates];
  double[] gammasum=new double[nStates];
  for (int i=0; i < nStates; i++) {
    rowsum[i]=0;
    for (int j=0; j < nStates; j++) {
      rowsum[i]+=A_hat[i][j];
    }
    for (int j=0; j < nStates; j++) {
      A_hat[i][j]/=rowsum[i];
    }
    gammasum[i]=0.0;
  }
  for (int j=0; j < nStates; j++) {
    gammasum[j]=0.0;
    for (int t=0; t < y.length; t++) {
      gammasum[j]+=gamma[t][j];
      mu_hat[j]+=gamma[t][j] * y[t];
    }
    mu_hat[j]=mu_hat[j] / gammasum[j];
    for (int t=0; t < y.length; t++) {
      s_hat[j]+=(gamma[t][j] * Math.pow((y[t] - mu_hat[j]),2));
    }
    s_hat[j]=Math.sqrt(s_hat[j] / gammasum[j]);
  }
  HashMap estimates=new HashMap();
  estimates=sortEstimates(mu_hat,s_hat,A_hat);
  return estimates;
}"
72937,"/** 
 * Consume the inputs and produce the outputs of the FFT filter.
 * @exception IllegalActionException If a runtime type error occurs.
 */
public void fire() throws IllegalActionException {
  super.fire();
  populateArrays();
  if ((_nStates != _s0.length) || (_nStates != _A0.length) || (_nStates != _priors.length)|| (_nStates != _m0.length)) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  Token observationArray=input.get(0);
  _observationLength=((ArrayToken)observationArray).length();
  _observations=new double[_observationLength];
  if (_observationLength <= 0) {
    throw new IllegalActionException(this,""String_Node_Str"" + _observationLength + ""String_Node_Str"");
  }
  for (int i=0; i < _observationLength; i++) {
    _observations[i]=((DoubleToken)((ArrayToken)observationArray).getElement(i)).doubleValue();
  }
  HashMap newEstimates=new HashMap();
  int nStates=_m0.length;
  if (_modelType == _HMM) {
    double[][] A_new=new double[nStates][nStates];
    double[] m_new=new double[nStates];
    double[] s_new=new double[nStates];
    int asked=0;
    for (int iterations=0; iterations < _nIterations; iterations++) {
      newEstimates=gaussianHMM(0,_observations,_A0,_m0,_s0,_priors);
      m_new=(double[])newEstimates.get(""String_Node_Str"");
      s_new=(double[])newEstimates.get(""String_Node_Str"");
      A_new=(double[][])newEstimates.get(""String_Node_Str"");
      if ((m_new[0] != m_new[0]) || (s_new[0] != s_new[0]) || (A_new[0] != A_new[0])) {
        if (iterations < _nIterations - 1) {
        }
 else {
          MessageHandler.message(""String_Node_Str"");
        }
        double minO=_observations[0];
        double maxO=_observations[0];
        for (int t=0; t < _observations.length; t++) {
          if (_observations[t] < minO) {
            minO=_observations[t];
          }
          if (_observations[t] > maxO) {
            maxO=_observations[t];
          }
        }
        double L=maxO - minO;
        for (int i=0; i < nStates; i++) {
          m_new[i]=L / nStates * Math.random() + L * i / nStates + minO;
          s_new[i]=Math.abs((maxO - minO) * Math.random()) / nStates;
          for (int j=0; j < nStates; j++) {
          }
        }
        A_new=_Ainit;
        Arrays.sort(m_new);
      }
      if ((_m0[0] - m_new[0]) < mTol) {
      }
      _A0=A_new;
      _s0=s_new;
      _m0=m_new;
    }
    Token[] mTokens=new Token[nStates];
    Token[] sTokens=new Token[nStates];
    for (int i=0; i < nStates; i++) {
      mTokens[i]=new DoubleToken(m_new[i]);
      sTokens[i]=new DoubleToken(s_new[i]);
    }
    mean.send(0,new ArrayToken(mTokens));
    sigma.send(0,new ArrayToken(sTokens));
    transitionMatrix.send(0,new DoubleMatrixToken(A_new));
  }
 else   if (_modelType == _MM) {
    double[] pi_new=new double[nStates];
    double[] m_new=new double[nStates];
    double[] s_new=new double[nStates];
    for (int iterations=0; iterations < _nIterations; iterations++) {
      newEstimates=gaussianMM(0,_observations,_m0,_s0,_priors);
      m_new=(double[])newEstimates.get(""String_Node_Str"");
      s_new=(double[])newEstimates.get(""String_Node_Str"");
      pi_new=(double[])newEstimates.get(""String_Node_Str"");
      _priors=pi_new;
      _s0=s_new;
      _m0=m_new;
    }
    Token[] mTokens=new Token[nStates];
    Token[] sTokens=new Token[nStates];
    Token[] pTokens=new Token[nStates];
    for (int i=0; i < nStates; i++) {
      mTokens[i]=new DoubleToken(m_new[i]);
      sTokens[i]=new DoubleToken(s_new[i]);
      pTokens[i]=new DoubleToken(pi_new[i]);
    }
    mean.send(0,new ArrayToken(mTokens));
    sigma.send(0,new ArrayToken(sTokens));
    transitionMatrix.send(0,new ArrayToken(pTokens));
  }
}","/** 
 * Consume the inputs and produce the outputs of the FFT filter.
 * @exception IllegalActionException If a runtime type error occurs.
 */
public void fire() throws IllegalActionException {
  super.fire();
  populateArrays();
  if ((_nStates != _s0.length) || (_nStates != _A0.length) || (_nStates != _priors.length)|| (_nStates != _m0.length)) {
    throw new IllegalActionException(this,""String_Node_Str"");
  }
  Token observationArray=input.get(0);
  _observationLength=((ArrayToken)observationArray).length();
  _observations=new double[_observationLength];
  if (_observationLength <= 0) {
    throw new IllegalActionException(this,""String_Node_Str"" + _observationLength + ""String_Node_Str"");
  }
  for (int i=0; i < _observationLength; i++) {
    _observations[i]=((DoubleToken)((ArrayToken)observationArray).getElement(i)).doubleValue();
  }
  HashMap newEstimates=new HashMap();
  int nStates=_m0.length;
  if (_modelType == _HMM) {
    double[][] A_new=new double[nStates][nStates];
    double[] m_new=new double[nStates];
    double[] s_new=new double[nStates];
    for (int iterations=0; iterations < _nIterations; iterations++) {
      newEstimates=gaussianHMM(0,_observations,_A0,_m0,_s0,_priors);
      m_new=(double[])newEstimates.get(""String_Node_Str"");
      s_new=(double[])newEstimates.get(""String_Node_Str"");
      A_new=(double[][])newEstimates.get(""String_Node_Str"");
      if ((m_new[0] != m_new[0]) || (s_new[0] != s_new[0]) || (A_new[0] != A_new[0])) {
        if (iterations < _nIterations - 1) {
        }
 else {
          MessageHandler.message(""String_Node_Str"");
        }
        double minO=_observations[0];
        double maxO=_observations[0];
        for (int t=0; t < _observations.length; t++) {
          if (_observations[t] < minO) {
            minO=_observations[t];
          }
          if (_observations[t] > maxO) {
            maxO=_observations[t];
          }
        }
        double L=maxO - minO;
        for (int i=0; i < nStates; i++) {
          m_new[i]=L / nStates * Math.random() + L * i / nStates + minO;
          s_new[i]=Math.abs((maxO - minO) * Math.random()) / nStates;
          for (int j=0; j < nStates; j++) {
          }
        }
        A_new=_Ainit;
        Arrays.sort(m_new);
      }
      if ((_m0[0] - m_new[0]) < mTol) {
      }
      _A0=A_new;
      _s0=s_new;
      _m0=m_new;
    }
    Token[] mTokens=new Token[nStates];
    Token[] sTokens=new Token[nStates];
    for (int i=0; i < nStates; i++) {
      mTokens[i]=new DoubleToken(m_new[i]);
      sTokens[i]=new DoubleToken(s_new[i]);
    }
    mean.send(0,new ArrayToken(mTokens));
    sigma.send(0,new ArrayToken(sTokens));
    transitionMatrix.send(0,new DoubleMatrixToken(A_new));
  }
 else   if (_modelType == _MM) {
    double[] pi_new=new double[nStates];
    double[] m_new=new double[nStates];
    double[] s_new=new double[nStates];
    for (int iterations=0; iterations < _nIterations; iterations++) {
      newEstimates=gaussianMM(0,_observations,_m0,_s0,_priors);
      m_new=(double[])newEstimates.get(""String_Node_Str"");
      s_new=(double[])newEstimates.get(""String_Node_Str"");
      pi_new=(double[])newEstimates.get(""String_Node_Str"");
      _priors=pi_new;
      _s0=s_new;
      _m0=m_new;
    }
    Token[] mTokens=new Token[nStates];
    Token[] sTokens=new Token[nStates];
    Token[] pTokens=new Token[nStates];
    for (int i=0; i < nStates; i++) {
      mTokens[i]=new DoubleToken(m_new[i]);
      sTokens[i]=new DoubleToken(s_new[i]);
      pTokens[i]=new DoubleToken(pi_new[i]);
    }
    mean.send(0,new ArrayToken(mTokens));
    sigma.send(0,new ArrayToken(sTokens));
    transitionMatrix.send(0,new ArrayToken(pTokens));
  }
}"
72938,"/** 
 * Return true to indicate that this decorator should decorate objects across opaque hierarchy boundaries.
 */
public boolean isGlobalDecorator(){
  return true;
}","/** 
 * Return true to indicate that this decorator should decorate objects across opaque hierarchy boundaries.
 */
public boolean isGlobalDecorator(){
  return false;
}"
72939,"/** 
 * Return a list of the entities deeply contained by the container of this resource scheduler.
 * @return A list of the objects decorated by this decorator.
 */
public List<NamedObj> decoratedObjects(){
  CompositeEntity container=(CompositeEntity)getContainer();
  return container.deepEntityList();
}","/** 
 * Return a list of the entities deeply contained by the container of this resource scheduler.
 * @return A list of the objects decorated by this decorator.
 */
public List<NamedObj> decoratedObjects(){
  CompositeEntity container=(CompositeEntity)getContainer();
  return _getEntitiesToDecorate(container);
}"
72940,"/** 
 * Return the decorated attributes for the target NamedObj. If the specified target is not an Actor, return null.
 * @param target The NamedObj that will be decorated.
 * @return The decorated attributes for the target NamedObj, ornull if the specified target is not an Actor.
 */
public DecoratorAttributes createDecoratorAttributes(NamedObj target){
  if (target instanceof Actor) {
    try {
      return new ResourceAttributes(target,this);
    }
 catch (    KernelException ex) {
      throw new InternalErrorException(ex);
    }
  }
 else {
    return null;
  }
}","/** 
 * Return the decorated attributes for the target NamedObj. If the specified target is not an Actor, return null.
 * @param target The NamedObj that will be decorated.
 * @return The decorated attributes for the target NamedObj, ornull if the specified target is not an Actor.
 */
public DecoratorAttributes createDecoratorAttributes(NamedObj target){
  if (target instanceof Actor && !(target instanceof ResourceScheduler)) {
    try {
      return new ResourceAttributes(target,this);
    }
 catch (    KernelException ex) {
      throw new InternalErrorException(ex);
    }
  }
 else {
    return null;
  }
}"
72941,"/** 
 * Override the base class to first set the container, then establish a connection with any decorated objects it finds in scope in the new container.
 * @param container The container to attach this attribute to..
 * @exception IllegalActionException If this attribute is not of theexpected class for the container, or it has no name, or the attribute and container are not in the same workspace, or the proposed container would result in recursive containment.
 * @exception NameDuplicationException If the container already hasan attribute with the name of this attribute.
 * @see #getContainer()
 */
public void setContainer(NamedObj container) throws IllegalActionException, NameDuplicationException {
  super.setContainer((CompositeEntity)container);
  if (container != null) {
    List<NamedObj> decoratedObjects=decoratedObjects();
    for (    NamedObj decoratedObject : decoratedObjects) {
      decoratedObject.getDecoratorAttributes(this);
    }
  }
}","/** 
 * Override the base class to first set the container, then establish a connection with any decorated objects it finds in scope in the new container.
 * @param container The container to attach this attribute to..
 * @exception IllegalActionException If this attribute is not of theexpected class for the container, or it has no name, or the attribute and container are not in the same workspace, or the proposed container would result in recursive containment.
 * @exception NameDuplicationException If the container already hasan attribute with the name of this attribute.
 * @see #getContainer()
 */
@Override public void setContainer(CompositeEntity container) throws IllegalActionException, NameDuplicationException {
  super.setContainer((CompositeEntity)container);
  if (container != null) {
    List<NamedObj> decoratedObjects=decoratedObjects();
    for (    NamedObj decoratedObject : decoratedObjects) {
      decoratedObject.getDecoratorAttributes(this);
    }
  }
}"
72942,"/** 
 * Return a list of the entities deeply contained by the container of this resource scheduler.
 * @return A list of the objects decorated by this decorator.
 */
public List<NamedObj> decoratedObjects(){
  CompositeEntity container=(CompositeEntity)getContainer();
  return container.deepEntityList();
}","/** 
 * Return a list of the entities deeply contained by the container of this resource scheduler.
 * @return A list of the objects decorated by this decorator.
 */
public List<NamedObj> decoratedObjects(){
  CompositeEntity container=(CompositeEntity)getContainer();
  return _getEntitiesToDecorate(container);
}"
72943,"/** 
 * Return the decorated attributes for the target NamedObj. If the specified target is not an Actor, return null.
 * @param target The NamedObj that will be decorated.
 * @return The decorated attributes for the target NamedObj, ornull if the specified target is not an Actor.
 */
public DecoratorAttributes createDecoratorAttributes(NamedObj target){
  if (target instanceof Actor) {
    try {
      return new CompositeResourceSchedulerAttributes(target,this);
    }
 catch (    KernelException ex) {
      throw new InternalErrorException(ex);
    }
  }
 else {
    return null;
  }
}","/** 
 * Return the decorated attributes for the target NamedObj. If the specified target is not an Actor, return null.
 * @param target The NamedObj that will be decorated.
 * @return The decorated attributes for the target NamedObj, ornull if the specified target is not an Actor.
 */
public DecoratorAttributes createDecoratorAttributes(NamedObj target){
  if (target instanceof Actor && !_isPartOfResourceScheduler(target)) {
    try {
      return new CompositeResourceSchedulerAttributes(target,this);
    }
 catch (    KernelException ex) {
      throw new InternalErrorException(ex);
    }
  }
 else {
    return null;
  }
}"
72944,"/** 
 * If attribute is <i>messageLength</i> report the new value  to the quantity manager. 
 * @param attribute The changed parameter.
 * @exception IllegalActionException If the parameter set is not valid.Not thrown in this class.
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == requestPort) {
    Actor actor=(Actor)getContainer();
    CompositeResourceScheduler scheduler=(CompositeResourceScheduler)getDecorator();
    scheduler.setRequestPort(actor,((StringToken)((Parameter)attribute).getToken()).stringValue());
  }
 else {
    super.attributeChanged(attribute);
  }
}","/** 
 * If attribute <i>requestPort</i> report the new value  to the resource scheduler. 
 * @param attribute The changed parameter.
 * @exception IllegalActionException If the parameter set is not valid.Not thrown in this class.
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == requestPort) {
    Actor actor=(Actor)getContainer();
    CompositeResourceScheduler scheduler=(CompositeResourceScheduler)getDecorator();
    if (scheduler != null && enabled()) {
      scheduler.setRequestPort(actor,((StringToken)((Parameter)attribute).getToken()).stringValue());
    }
  }
 else {
    super.attributeChanged(attribute);
  }
}"
72945,"/** 
 * Override the base class to first set the container, then establish a connection with any decorated objects it finds in scope in the new container.
 * @param container The container to attach this attribute to..
 * @exception IllegalActionException If this attribute is not of theexpected class for the container, or it has no name, or the attribute and container are not in the same workspace, or the proposed container would result in recursive containment.
 * @exception NameDuplicationException If the container already hasan attribute with the name of this attribute.
 * @see #getContainer()
 */
public void setContainer(NamedObj container) throws IllegalActionException, NameDuplicationException {
  super.setContainer((CompositeEntity)container);
  if (container != null) {
    List<NamedObj> decoratedObjects=decoratedObjects();
    for (    NamedObj decoratedObject : decoratedObjects) {
      decoratedObject.getDecoratorAttributes(this);
    }
  }
}","/** 
 * Override the base class to first set the container, then establish a connection with any decorated objects it finds in scope in the new container.
 * @param container The container to attach this attribute to..
 * @exception IllegalActionException If this attribute is not of theexpected class for the container, or it has no name, or the attribute and container are not in the same workspace, or the proposed container would result in recursive containment.
 * @exception NameDuplicationException If the container already hasan attribute with the name of this attribute.
 * @see #getContainer()
 */
@Override public void setContainer(CompositeEntity container) throws IllegalActionException, NameDuplicationException {
  super.setContainer((CompositeEntity)container);
  if (container != null) {
    List<NamedObj> decoratedObjects=decoratedObjects();
    for (    NamedObj decoratedObject : decoratedObjects) {
      decoratedObject.getDecoratorAttributes(this);
    }
  }
}"
72946,"/** 
 * Schedule a new actor for execution. Find the const actor in the _model that is mapped to this actor and trigger a firing of that one, if the actor is not already in execution. If the actor finished execution, return zero time, otherwise return the next time the model has something to do.
 * @param actor The actor to be scheduled.
 * @param currentPlatformTime The current platform time.
 * @param deadline The deadline of the event.
 * @param executionTime The execution time of the actor.
 * @return Relative time when this Scheduler has to be executedagain.
 * @exception IllegalActionException Thrown if actor paramaters suchas execution time or priority cannot be read.
 */
protected Time _schedule(Actor actor,Time currentPlatformTime,Time deadline,Time executionTime) throws IllegalActionException {
  _lastActorFinished=false;
  getDirector().setModelTime(getExecutiveDirector().localClock.getLocalTime());
  if (!_currentlyExecuting.contains(actor)) {
    event((NamedObj)actor,getExecutiveDirector().localClock.getLocalTime().getDoubleValue(),ExecutionEventType.START);
    ResourceMappingInputPort requestPort=(ResourceMappingInputPort)getEntity(_requestPorts.get(actor));
    if (requestPort != null) {
      RecordToken recordToken=new RecordToken(new String[]{""String_Node_Str"",""String_Node_Str""},new Token[]{new ObjectToken(actor),new DoubleToken(executionTime.getDoubleValue())});
      requestPort.value.setToken(recordToken);
      getDirector().fireAtCurrentTime(requestPort);
      getExecutiveDirector().fireAt(this,getDirector().getModelTime());
      _currentlyExecuting.add(actor);
    }
 else {
      throw new IllegalActionException(this,""String_Node_Str"" + _requestPorts.get(actor));
    }
  }
  return Time.POSITIVE_INFINITY;
}","/** 
 * Schedule a new actor for execution. Find the const actor in the _model that is mapped to this actor and trigger a firing of that one, if the actor is not already in execution. If the actor finished execution, return zero time, otherwise return the next time the model has something to do.
 * @param actor The actor to be scheduled.
 * @param currentPlatformTime The current platform time.
 * @param deadline The deadline of the event.
 * @param executionTime The execution time of the actor.
 * @return Relative time when this Scheduler has to be executedagain.
 * @exception IllegalActionException Thrown if actor paramaters suchas execution time or priority cannot be read.
 */
protected Time _schedule(Actor actor,Time currentPlatformTime,Time deadline,Time executionTime) throws IllegalActionException {
  _lastActorFinished=false;
  getDirector().setModelTime(getExecutiveDirector().localClock.getLocalTime());
  if (!_currentlyExecuting.contains(actor)) {
    event((NamedObj)actor,getExecutiveDirector().localClock.getLocalTime().getDoubleValue(),ExecutionEventType.START);
    if (_requestPorts.get(actor) == null) {
      throw new IllegalActionException(this,""String_Node_Str"" + actor + ""String_Node_Str""+ ""String_Node_Str"");
    }
    ResourceMappingInputPort requestPort=(ResourceMappingInputPort)getEntity(_requestPorts.get(actor));
    if (requestPort != null) {
      RecordToken recordToken=new RecordToken(new String[]{""String_Node_Str"",""String_Node_Str""},new Token[]{new ObjectToken(actor),new DoubleToken(executionTime.getDoubleValue())});
      requestPort.value.setToken(recordToken);
      getDirector().fireAtCurrentTime(requestPort);
      getExecutiveDirector().fireAt(this,getDirector().getModelTime());
      _currentlyExecuting.add(actor);
    }
 else {
      throw new IllegalActionException(this,""String_Node_Str"" + _requestPorts.get(actor));
    }
  }
  return Time.POSITIVE_INFINITY;
}"
72947,"/** 
 * Construct a constant source with the default type set to the RecordToken used in the CompositeQM. 
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the entity cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public ResourceMappingInputPort(CompositeEntity container,String name) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  Parameter hide=(Parameter)trigger.getAttribute(""String_Node_Str"");
  if (hide == null) {
    hide=new Parameter(trigger,""String_Node_Str"",new BooleanToken(true));
  }
 else {
    hide.setToken(new BooleanToken(true));
  }
  value.setVisibility(Settable.NONE);
  value.setExpression(""String_Node_Str"");
  _beforeInitialization=true;
  RecordType type=new RecordType(new String[]{""String_Node_Str"",""String_Node_Str""},new Type[]{BaseType.OBJECT,BaseType.DOUBLE});
  value.setTypeEquals(type);
}","/** 
 * Construct a constant source with the default type set to the RecordToken used in the CompositeQM. 
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the entity cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public ResourceMappingInputPort(CompositeEntity container,String name) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  RecordType type=new RecordType(new String[]{""String_Node_Str"",""String_Node_Str""},new Type[]{BaseType.OBJECT,BaseType.DOUBLE});
  value.setTypeEquals(type);
}"
72948,"/** 
 * Construct a ResourceMappingOutputPort. The contained entities (SetVariable, Parameter and input port) are created from the XML description in the library.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the container is incompatiblewith this actor.
 * @exception NameDuplicationException If the name coincides withan actor already in the container.
 */
public ResourceMappingOutputPort(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
  input=new TypedIOPort(this,""String_Node_Str"",true,false);
  _token=null;
}","/** 
 * Construct a ResourceMappingOutputPort. The contained entities (SetVariable, Parameter and input port) are created from the XML description in the library.
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the container is incompatiblewith this actor.
 * @exception NameDuplicationException If the name coincides withan actor already in the container.
 */
public ResourceMappingOutputPort(CompositeEntity container,String name) throws IllegalActionException, NameDuplicationException {
  super(container,name);
}"
72949,"/** 
 * If attribute <i>requestPort</i> report the new value  to the resource scheduler. 
 * @param attribute The changed parameter.
 * @exception IllegalActionException If the parameter set is not valid.Not thrown in this class.
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == requestPort) {
    Actor actor=(Actor)getContainer();
    CompositeResourceScheduler scheduler=(CompositeResourceScheduler)getDecorator();
    if (scheduler != null && enabled()) {
      scheduler.setRequestPort(actor,((StringToken)((Parameter)attribute).getToken()).stringValue());
    }
  }
 else {
    super.attributeChanged(attribute);
  }
}","/** 
 * If attribute <i>requestPort</i> report the new value  to the resource scheduler. 
 * @param attribute The changed parameter.
 * @exception IllegalActionException If the parameter set is not valid.Not thrown in this class.
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == requestPort) {
    Actor actor=(Actor)getContainer();
    CompositeResourceScheduler scheduler=(CompositeResourceScheduler)getDecorator();
    String portName=((StringToken)((Parameter)attribute).getToken()).stringValue();
    if (scheduler != null && portName != ""String_Node_Str"") {
      scheduler.setRequestPort(actor,portName);
    }
  }
 else {
    super.attributeChanged(attribute);
  }
}"
72950,"/** 
 * Each iteration has two phases. In Phase 1, MetroIIDirector calls each actor (no particular order should be presumed. See Note 1). Each actor runs until it wants to propose MetroII events: the actor saves the state and returns with MetroII events. In Phase 2, MetroIIDirector calls the MappingConstraintSolver, which updates the MetroII events based on the mapping constraints.
 */
public void fire() throws IllegalActionException {
}","/** 
 * Each iteration has two phases. In Phase 1, MetroIIDirector calls each actor (no particular order should be presumed. See Note 1). Each actor runs until it wants to propose MetroII events: the actor saves the state and returns with MetroII events. In Phase 2, MetroIIDirector calls the MappingConstraintSolver, which updates the MetroII events based on the mapping constraints.
 */
public void fire() throws IllegalActionException {
  int iterationsValue=((IntToken)iterations.getToken()).intValue();
  if (iterationsValue == 0) {
    return;
  }
  if (!_stopRequested) {
    LinkedList<Event.Builder> globalMetroIIEventList=new LinkedList<Event.Builder>();
    _debugger.printTitle(getFullName() + ""String_Node_Str"" + ""String_Node_Str""+ Integer.toString(_iterationCount));
    _debugger.printText(""String_Node_Str"");
    for (    FireMachine firing : _actorList) {
      LinkedList<Event.Builder> metroIIEventList=new LinkedList<Event.Builder>();
      if (firing.getState() == FireMachine.State.START) {
        boolean result=firing.actor().prefire();
        assert result;
      }
      firing.startOrResume(metroIIEventList);
      if (firing.getState() == FireMachine.State.FINAL) {
        boolean pf=firing.actor().postfire();
        if (pf) {
          firing.reset();
          firing.startOrResume(metroIIEventList);
        }
      }
      globalMetroIIEventList.addAll(metroIIEventList);
    }
    _debugger.printText(""String_Node_Str"");
    _debugger.printMetroEvents(globalMetroIIEventList);
    _mappingConstraintSolver.resolve(globalMetroIIEventList);
    _timeScheduler.resolve(globalMetroIIEventList);
    _debugger.printText(""String_Node_Str"");
    _debugger.printMetroEvents(globalMetroIIEventList);
    _debugger.printTitle(getFullName() + ""String_Node_Str"" + ""String_Node_Str""+ Integer.toString(_iterationCount));
    if (((BooleanToken)printTrace.getToken()).booleanValue()) {
      for (      Event.Builder event : globalMetroIIEventList) {
        if (event.getStatus() == Status.NOTIFIED) {
          System.out.println(""String_Node_Str"" + event.getTime().getValue() + ""String_Node_Str""+ event.getName());
        }
      }
    }
  }
}"
72951,"public void getfire(ResultHandler<Iterable<Event.Builder>> resultHandler) throws CollectionAbortedException {
  try {
    if (_debugging) {
      _debug(""String_Node_Str"");
    }
    Schedule schedule=getScheduler().getSchedule();
    int iterationCount=0;
    do {
      Iterator firingIterator=schedule.firingIterator();
      while (firingIterator.hasNext() && !_stopRequested) {
        Actor actor=((Firing)firingIterator.next()).getActor();
        if (!_actorsFinishedExecution.contains(actor)) {
          if (_isReadyToFire(actor)) {
            Event.Builder builder=makeEventBuilder(actor.getFullName());
            _nameToActor.put(builder.getName(),actor);
            _events.add(builder);
          }
 else {
            if (_debugging) {
              if (!_actorsFinishedFiring.contains(actor) && actor.isStrict()) {
                _debug(""String_Node_Str"" + actor.getFullName());
              }
            }
          }
        }
 else {
          if (_debugging) {
            _debug(""String_Node_Str"" + actor.getFullName());
          }
          _sendAbsentToAllUnknownOutputsOf(actor);
        }
      }
      while (_events.size() > 0) {
        resultHandler.handleResult(_events);
        ArrayList<Event.Builder> tmp_events=new ArrayList<Event.Builder>();
        for (        Builder etb : _events) {
          if (etb.getName().contains(""String_Node_Str"") && etb.getStatus() == Event.Status.NOTIFIED) {
            Actor actor=_nameToActor.get(etb.getName());
            if (_debugging) {
              _debug(""String_Node_Str"" + actor.getFullName());
            }
            _fireActor(actor);
            _actorsFired.add(actor);
          }
 else {
            tmp_events.add(etb);
          }
        }
        _events=tmp_events;
      }
      iterationCount++;
    }
 while (!_hasIterationConverged() && !_stopRequested);
    if (_debugging) {
      _debug(this.getFullName() + ""String_Node_Str"" + iterationCount+ ""String_Node_Str"");
    }
  }
 catch (  IllegalActionException e1) {
    e1.printStackTrace();
  }
}","public void getfire(ResultHandler<Iterable<Event.Builder>> resultHandler) throws CollectionAbortedException {
  try {
    if (_debugging) {
      _debug(""String_Node_Str"");
    }
    Schedule schedule=getScheduler().getSchedule();
    int iterationCount=0;
    do {
      Iterator firingIterator=schedule.firingIterator();
      while (firingIterator.hasNext() && !_stopRequested) {
        Actor actor=((Firing)firingIterator.next()).getActor();
        if (!_actorsFinishedExecution.contains(actor)) {
          if (_isReadyToFire(actor)) {
            Event.Builder builder=makeEventBuilder(actor.getFullName());
            _nameToActor.put(builder.getName(),actor);
            _events.add(builder);
          }
 else {
            if (_debugging) {
              if (!_actorsFinishedFiring.contains(actor) && actor.isStrict()) {
                _debug(""String_Node_Str"" + actor.getFullName());
              }
            }
          }
        }
 else {
          if (_debugging) {
            _debug(""String_Node_Str"" + actor.getFullName());
          }
          _sendAbsentToAllUnknownOutputsOf(actor);
        }
      }
      while (_events.size() > 0) {
        resultHandler.handleResult(_events);
        ArrayList<Event.Builder> tmp_events=new ArrayList<Event.Builder>();
        for (        Builder etb : _events) {
          if (etb.getStatus() == Event.Status.NOTIFIED) {
            Actor actor=_nameToActor.get(etb.getName());
            if (_debugging) {
              _debug(""String_Node_Str"" + actor.getFullName());
            }
            _fireActor(actor);
            _actorsFired.add(actor);
          }
 else {
            tmp_events.add(etb);
          }
        }
        _events=tmp_events;
      }
      iterationCount++;
    }
 while (!_hasIterationConverged() && !_stopRequested);
    if (_debugging) {
      _debug(this.getFullName() + ""String_Node_Str"" + iterationCount+ ""String_Node_Str"");
    }
  }
 catch (  IllegalActionException e1) {
    e1.printStackTrace();
  }
}"
72952,"/** 
 * Generate the code for the firing of actors according to the SDF schedule.
 * @return The generated fire code.
 * @exception IllegalActionException If the SDF director does not have anattribute called ""iterations"" or a valid schedule, or the actor to be fired cannot find its associated adapter.
 */
public String generateFireCode() throws IllegalActionException {
  StringBuffer code=new StringBuffer();
  code.append(CodeStream.indent(getCodeGenerator().comment(""String_Node_Str"")));
  ptolemy.actor.sched.StaticSchedulingDirector director=(ptolemy.actor.sched.StaticSchedulingDirector)getComponent();
  Schedule schedule=director.getScheduler().getSchedule();
  ProgramCodeGenerator codeGenerator=getCodeGenerator();
  Iterator<?> actorsToFire=schedule.firingIterator();
  while (actorsToFire.hasNext()) {
    Firing firing=(Firing)actorsToFire.next();
    Actor actor=firing.getActor();
    NamedProgramCodeGeneratorAdapter adapter=(NamedProgramCodeGeneratorAdapter)codeGenerator.getAdapter(actor);
    boolean inline=((BooleanToken)getCodeGenerator().inline.getToken()).booleanValue();
    if (inline) {
      for (int i=0; i < firing.getIterationCount(); i++) {
        code.append(adapter.generateFireCode());
        _generateUpdatePortOffsetCode(code,actor);
      }
    }
 else {
      int count=firing.getIterationCount();
      if (count > 1) {
        code.append(""String_Node_Str"" + _eol + ""String_Node_Str""+ _eol+ ""String_Node_Str""+ count+ ""String_Node_Str""+ _eol);
      }
      code.append(codeGenerator.generateFireFunctionMethodInvocation((NamedObj)actor) + ""String_Node_Str"" + _eol);
      _generateUpdatePortOffsetCode(code,actor);
      if (count > 1) {
        code.append(""String_Node_Str"" + _eol + ""String_Node_Str""+ _eol);
      }
    }
  }
  return code.toString();
}","/** 
 * Generate the code for the firing of actors according to the SDF schedule.
 * @return The generated fire code.
 * @exception IllegalActionException If the SDF director does not have anattribute called ""iterations"" or a valid schedule, or the actor to be fired cannot find its associated adapter.
 */
public String generateFireCode() throws IllegalActionException {
  StringBuffer code=new StringBuffer();
  code.append(CodeStream.indent(getCodeGenerator().comment(""String_Node_Str"")));
  ptolemy.actor.sched.StaticSchedulingDirector director=(ptolemy.actor.sched.StaticSchedulingDirector)getComponent();
  Schedule schedule=director.getScheduler().getSchedule();
  ProgramCodeGenerator codeGenerator=getCodeGenerator();
  Iterator<?> actorsToFire=schedule.firingIterator();
  while (actorsToFire.hasNext()) {
    Firing firing=(Firing)actorsToFire.next();
    Actor actor=firing.getActor();
    NamedProgramCodeGeneratorAdapter adapter=(NamedProgramCodeGeneratorAdapter)codeGenerator.getAdapter(actor);
    boolean inline=((BooleanToken)getCodeGenerator().inline.getToken()).booleanValue();
    if (inline) {
      for (int i=0; i < firing.getIterationCount(); i++) {
        code.append(adapter.generateFireCode());
        if (!(codeGenerator instanceof CCodeGenerator))         _generateUpdatePortOffsetCode(code,actor);
      }
    }
 else {
      int count=firing.getIterationCount();
      if (count > 1) {
        code.append(""String_Node_Str"" + _eol + ""String_Node_Str""+ _eol+ ""String_Node_Str""+ count+ ""String_Node_Str""+ _eol);
      }
      code.append(codeGenerator.generateFireFunctionMethodInvocation((NamedObj)actor) + ""String_Node_Str"" + _eol);
      if (!(codeGenerator instanceof CCodeGenerator))       _generateUpdatePortOffsetCode(code,actor);
      if (count > 1) {
        code.append(""String_Node_Str"" + _eol + ""String_Node_Str""+ _eol);
      }
    }
  }
  return code.toString();
}"
72953,"/** 
 * Render a visual representation of the given node. If the StringAttribute _color of the node is set then use that color to highlight the node. If the StringAttribute _explanation of the node is set then use it to set the tooltip.
 * @see diva.graph.NodeRenderer#render(java.lang.Object)
 */
public Figure render(Object n){
  Locatable location=(Locatable)n;
  final NamedObj object=location.getContainer();
  Figure result=null;
  try {
    List iconList=object.attributeList(EditorIcon.class);
    if (iconList.size() == 0) {
      XMLIcon alreadyCreated=(XMLIcon)_iconsPendingContainer.get(object);
      if (alreadyCreated != null) {
        iconList.add(alreadyCreated);
      }
    }
    if (iconList.size() == 0) {
      final EditorIcon icon=XMLIcon.getXMLIcon(object.workspace(),""String_Node_Str"");
      icon.setContainerToBe(object);
      icon.setPersistent(false);
      result=icon.createFigure();
      _iconsPendingContainer.put(object,icon);
      GraphController controller=IconController.this.getController();
      GraphModel graphModel=controller.getGraphModel();
      ChangeRequest request=new ChangeRequest(graphModel,""String_Node_Str""){
        protected void _execute() throws KernelException {
          _iconsPendingContainer.remove(object);
          if (icon.getContainer() != null) {
            return;
          }
          if (object.getAttribute(""String_Node_Str"") != null) {
            return;
          }
          icon.setContainer(object);
        }
      }
;
      request.setPersistent(false);
      object.requestChange(request);
    }
 else     if (iconList.size() >= 1) {
      EditorIcon icon=(EditorIcon)iconList.get(iconList.size() - 1);
      result=icon.createFigure();
    }
  }
 catch (  KernelException ex) {
    throw new InternalErrorException(null,ex,""String_Node_Str"" + ""String_Node_Str"" + object + ""String_Node_Str""+ ""String_Node_Str"");
  }
  if (result == null) {
    throw new InternalErrorException(""String_Node_Str"");
  }
 else {
    result.setToolTipText(object.getClassName());
  }
  try {
    StringAttribute colorAttr=(StringAttribute)object.getAttribute(""String_Node_Str"",StringAttribute.class);
    if (colorAttr != null) {
      String color=colorAttr.getExpression();
      AnimationRenderer animationRenderer=new AnimationRenderer(SVGUtilities.getColor(color));
      animationRenderer.renderSelected(result);
    }
  }
 catch (  IllegalActionException e) {
  }
  AttributeController.renderHighlight(object,result);
  try {
    Attribute highlightColor=object.getAttribute(""String_Node_Str"");
    if (highlightColor != null) {
      object.removeAttribute(highlightColor);
      object.validateSettables();
    }
    Set<Decorator> decorators=object.decorators();
    for (    Decorator decorator : decorators) {
      DecoratorAttributes decoratorAttributes=object.getDecoratorAttributes(decorator);
      if (decoratorAttributes instanceof ResourceAttributes) {
        if (decoratorAttributes.getDecorator() != null && ((ResourceAttributes)decoratorAttributes).enabled()) {
          try {
            if (object.getAttribute(""String_Node_Str"") == null) {
              highlightColor=new ColorAttribute(object,""String_Node_Str"");
              Attribute attribute=((NamedObj)decorator).getAttribute(""String_Node_Str"");
              String colorExpression=""String_Node_Str"";
              if (attribute != null) {
                colorExpression=(((ColorAttribute)attribute).getToken()).toString();
              }
              ((ColorAttribute)highlightColor).setExpression(colorExpression);
            }
          }
 catch (          NameDuplicationException e) {
          }
        }
      }
    }
  }
 catch (  IllegalActionException e1) {
    e1.printStackTrace();
  }
  AttributeController.renderDecoratorHighlight(object,result);
  try {
    ColorAttribute shadowAttribute=(ColorAttribute)object.getAttribute(""String_Node_Str"",ColorAttribute.class);
    if (shadowAttribute != null) {
      if (!shadowAttribute.getExpression().trim().equals(""String_Node_Str"")) {
        Color color=shadowAttribute.asColor();
        ShadowRenderer animationRenderer=new ShadowRenderer(color);
        animationRenderer.renderSelected(result);
      }
    }
 else     if (object instanceof Entity) {
      NamedObj container=object.getContainer();
      if (container != null) {
        shadowAttribute=(ColorAttribute)container.getAttribute(""String_Node_Str"",ColorAttribute.class);
        if (shadowAttribute != null && !shadowAttribute.getExpression().trim().equals(""String_Node_Str"")) {
          Color color=shadowAttribute.asColor();
          ShadowRenderer animationRenderer=new ShadowRenderer(color);
          animationRenderer.renderSelected(result);
        }
      }
    }
  }
 catch (  IllegalActionException e) {
  }
  try {
    StringAttribute explanationAttribute=(StringAttribute)object.getAttribute(""String_Node_Str"",StringAttribute.class);
    if (explanationAttribute != null) {
      result.setToolTipText(explanationAttribute.getExpression());
    }
  }
 catch (  IllegalActionException e) {
  }
  return result;
}","/** 
 * Render a visual representation of the given node. If the StringAttribute _color of the node is set then use that color to highlight the node. If the StringAttribute _explanation of the node is set then use it to set the tooltip.
 * @see diva.graph.NodeRenderer#render(java.lang.Object)
 */
public Figure render(Object n){
  Locatable location=(Locatable)n;
  final NamedObj object=location.getContainer();
  Figure result=null;
  try {
    List iconList=object.attributeList(EditorIcon.class);
    if (iconList.size() == 0) {
      XMLIcon alreadyCreated=(XMLIcon)_iconsPendingContainer.get(object);
      if (alreadyCreated != null) {
        iconList.add(alreadyCreated);
      }
    }
    if (iconList.size() == 0) {
      final EditorIcon icon=XMLIcon.getXMLIcon(object.workspace(),""String_Node_Str"");
      icon.setContainerToBe(object);
      icon.setPersistent(false);
      result=icon.createFigure();
      _iconsPendingContainer.put(object,icon);
      GraphController controller=IconController.this.getController();
      GraphModel graphModel=controller.getGraphModel();
      ChangeRequest request=new ChangeRequest(graphModel,""String_Node_Str""){
        protected void _execute() throws KernelException {
          _iconsPendingContainer.remove(object);
          if (icon.getContainer() != null) {
            return;
          }
          if (object.getAttribute(""String_Node_Str"") != null) {
            return;
          }
          icon.setContainer(object);
        }
      }
;
      request.setPersistent(false);
      object.requestChange(request);
    }
 else     if (iconList.size() >= 1) {
      EditorIcon icon=(EditorIcon)iconList.get(iconList.size() - 1);
      result=icon.createFigure();
    }
  }
 catch (  KernelException ex) {
    throw new InternalErrorException(null,ex,""String_Node_Str"" + ""String_Node_Str"" + object + ""String_Node_Str""+ ""String_Node_Str"");
  }
  if (result == null) {
    throw new InternalErrorException(""String_Node_Str"");
  }
 else {
    result.setToolTipText(object.getClassName());
  }
  try {
    StringAttribute colorAttr=(StringAttribute)object.getAttribute(""String_Node_Str"",StringAttribute.class);
    if (colorAttr != null) {
      String color=colorAttr.getExpression();
      AnimationRenderer animationRenderer=new AnimationRenderer(SVGUtilities.getColor(color));
      animationRenderer.renderSelected(result);
    }
  }
 catch (  IllegalActionException e) {
  }
  AttributeController.renderHighlight(object,result);
  try {
    Attribute highlightColor=object.getAttribute(""String_Node_Str"");
    if (highlightColor != null) {
      object.removeAttribute(highlightColor);
      object.validateSettables();
    }
    List<Decorator> decorators=new ArrayList();
    decorators.addAll(object.decorators());
    for (    Decorator decorator : decorators) {
      DecoratorAttributes decoratorAttributes=object.getDecoratorAttributes(decorator);
      if (decoratorAttributes instanceof ResourceAttributes) {
        if (decoratorAttributes.getDecorator() != null && ((ResourceAttributes)decoratorAttributes).enabled()) {
          try {
            if (object.getAttribute(""String_Node_Str"") == null) {
              highlightColor=new ColorAttribute(object,""String_Node_Str"");
              Attribute attribute=((NamedObj)decorator).getAttribute(""String_Node_Str"");
              String colorExpression=""String_Node_Str"";
              if (attribute != null) {
                colorExpression=(((ColorAttribute)attribute).getToken()).toString();
              }
              ((ColorAttribute)highlightColor).setExpression(colorExpression);
            }
          }
 catch (          NameDuplicationException e) {
          }
        }
      }
    }
  }
 catch (  IllegalActionException e1) {
    e1.printStackTrace();
  }
  AttributeController.renderDecoratorHighlight(object,result);
  try {
    ColorAttribute shadowAttribute=(ColorAttribute)object.getAttribute(""String_Node_Str"",ColorAttribute.class);
    if (shadowAttribute != null) {
      if (!shadowAttribute.getExpression().trim().equals(""String_Node_Str"")) {
        Color color=shadowAttribute.asColor();
        ShadowRenderer animationRenderer=new ShadowRenderer(color);
        animationRenderer.renderSelected(result);
      }
    }
 else     if (object instanceof Entity) {
      NamedObj container=object.getContainer();
      if (container != null) {
        shadowAttribute=(ColorAttribute)container.getAttribute(""String_Node_Str"",ColorAttribute.class);
        if (shadowAttribute != null && !shadowAttribute.getExpression().trim().equals(""String_Node_Str"")) {
          Color color=shadowAttribute.asColor();
          ShadowRenderer animationRenderer=new ShadowRenderer(color);
          animationRenderer.renderSelected(result);
        }
      }
    }
  }
 catch (  IllegalActionException e) {
  }
  try {
    StringAttribute explanationAttribute=(StringAttribute)object.getAttribute(""String_Node_Str"",StringAttribute.class);
    if (explanationAttribute != null) {
      result.setToolTipText(explanationAttribute.getExpression());
    }
  }
 catch (  IllegalActionException e) {
  }
  return result;
}"
72954,"/** 
 * Return the dependency between the specified input port and the specified output port.  This is done by checking the guards and actions of all the transitions. When called for the first time since a change in the model structure, this method performs the complete analysis of the FSM and caches the result. Subsequent calls just look up the result.
 * @param input The input port.
 * @param output The output port, or null to update thedependencies (and record equivalence classes) without requiring there to be an output port.
 * @return The dependency between the specified input portand the specified output port, or null if a null output is port specified.
 * @exception IllegalActionException If a guard expression cannot be parsed.
 */
public Dependency getDependency(IOPort input,IOPort output) throws IllegalActionException {
  FSMActor actor=(FSMActor)_actor;
  long workspaceVersion=actor.workspace().getVersion();
  if (_dependencyVersion != workspaceVersion) {
    boolean stateDependentCausality=((BooleanToken)actor.stateDependentCausality.getToken()).booleanValue();
    try {
      actor.workspace().getReadAccess();
      _reverseDependencies=new HashMap<IOPort,Map<IOPort,Dependency>>();
      _forwardDependencies=new HashMap<IOPort,Map<IOPort,Dependency>>();
      _equivalenceClasses=new HashMap<IOPort,Collection<IOPort>>();
      List<IOPort> actorInputs=_actor.inputPortList();
      for (      IOPort actorInput : actorInputs) {
        Set<IOPort> equivalences=new HashSet<IOPort>();
        equivalences.add(actorInput);
        _equivalenceClasses.put(actorInput,equivalences);
      }
      Collection<IOPort> stateEquivalentPorts=new HashSet<IOPort>();
      Collection<Transition> transitions;
      if (!stateDependentCausality) {
        transitions=actor.relationList();
      }
 else {
        State currentState=actor.currentState();
        transitions=currentState.outgoingPort.linkedRelationList();
      }
      for (      Transition transition : transitions) {
        Set<IOPort> outputs=new HashSet<IOPort>();
        List<AbstractActionsAttribute> actions=transition.choiceActionList();
        for (        AbstractActionsAttribute action : actions) {
          List<String> names=action.getDestinationNameList();
          for (          String name : names) {
            NamedObj destination=action.getDestination(name);
            if (destination instanceof IOPort && ((IOPort)destination).isOutput()) {
              outputs.add((IOPort)destination);
            }
          }
        }
        Set<IOPort> inputs=new HashSet<IOPort>();
        String guard=transition.getGuardExpression();
        if (guard.trim().equals(""String_Node_Str"")) {
          continue;
        }
        PtParser parser=new PtParser();
        try {
          ASTPtRootNode guardParseTree=parser.generateParseTree(guard);
          ParseTreeFreeVariableCollector collector=new ParseTreeFreeVariableCollector();
          Set<String> freeVariables=collector.collectFreeVariables(guardParseTree);
          for (          String freeVariable : freeVariables) {
            IOPort port=actor._getPortForIdentifier(freeVariable);
            if (port != null && port.isInput()) {
              inputs.add(port);
            }
          }
        }
 catch (        IllegalActionException ex) {
          throw new IllegalActionException(actor,ex,""String_Node_Str"" + guard + ""String_Node_Str"");
        }
        if (inputs.isEmpty()) {
          continue;
        }
        stateEquivalentPorts.addAll(inputs);
        for (        IOPort writtenOutput : outputs) {
          Map<IOPort,Dependency> outputMap=_reverseDependencies.get(writtenOutput);
          if (outputMap == null) {
            outputMap=new HashMap<IOPort,Dependency>();
            _reverseDependencies.put(writtenOutput,outputMap);
          }
          for (          IOPort readInput : inputs) {
            outputMap.put(readInput,_defaultDependency.oTimesIdentity());
            Map<IOPort,Dependency> inputMap=_forwardDependencies.get(readInput);
            if (inputMap == null) {
              inputMap=new HashMap<IOPort,Dependency>();
              _forwardDependencies.put(readInput,inputMap);
            }
            inputMap.put(writtenOutput,_defaultDependency.oTimesIdentity());
          }
        }
      }
      Collection<State> states;
      if (!stateDependentCausality) {
        states=actor.entityList();
      }
 else {
        State currentState=actor.currentState();
        states=new HashSet<State>();
        states.add(currentState);
      }
      for (      State state : states) {
        TypedActor[] refinements=state.getRefinement();
        if (refinements != null && refinements.length > 0) {
          for (          TypedActor refinement : refinements) {
            if (!((CompositeActor)refinement).isOpaque()) {
              throw new IllegalActionException(refinement,""String_Node_Str"");
            }
            CausalityInterface causality=refinement.getCausalityInterface();
            Collection<IOPort> outputs=refinement.outputPortList();
            for (            IOPort refinementOutput : outputs) {
              Collection<IOPort> inputs=causality.dependentPorts(refinementOutput);
              for (              IOPort refinementInput : inputs) {
                Collection<IOPort> equivalents=causality.equivalentPorts(refinementInput);
                for (                IOPort equivalent : equivalents) {
                  IOPort port=(IOPort)actor.getPort(equivalent.getName());
                  if (port != null) {
                    stateEquivalentPorts.add(port);
                  }
                }
              }
            }
          }
        }
      }
      List<IOPort> inputs=_actor.inputPortList();
      for (      IOPort actorInput : inputs) {
        if (actorInput instanceof ParameterPort) {
          stateEquivalentPorts=inputs;
          break;
        }
      }
      for (      IOPort equivalent : stateEquivalentPorts) {
        _equivalenceClasses.put(equivalent,stateEquivalentPorts);
      }
    }
  finally {
      actor.workspace().doneReading();
    }
    _dependencyVersion=workspaceVersion;
  }
  if (output == null) {
    return null;
  }
  Map<IOPort,Dependency> inputMap=_forwardDependencies.get(input);
  if (inputMap != null) {
    Dependency result=inputMap.get(output);
    if (result != null) {
      return result;
    }
  }
  return _defaultDependency.oPlusIdentity();
}","/** 
 * Return the dependency between the specified input port and the specified output port.  This is done by checking the guards and actions of all the transitions. When called for the first time since a change in the model structure, this method performs the complete analysis of the FSM and caches the result. Subsequent calls just look up the result.
 * @param input The input port.
 * @param output The output port, or null to update thedependencies (and record equivalence classes) without requiring there to be an output port.
 * @return The dependency between the specified input portand the specified output port, or null if a null output is port specified.
 * @exception IllegalActionException If a guard expression cannot be parsed.
 */
public Dependency getDependency(IOPort input,IOPort output) throws IllegalActionException {
  FSMActor actor=(FSMActor)_actor;
  long workspaceVersion=actor.workspace().getVersion();
  if (_dependencyVersion != workspaceVersion) {
    boolean stateDependentCausality=((BooleanToken)actor.stateDependentCausality.getToken()).booleanValue();
    try {
      actor.workspace().getReadAccess();
      _reverseDependencies=new HashMap<IOPort,Map<IOPort,Dependency>>();
      _forwardDependencies=new HashMap<IOPort,Map<IOPort,Dependency>>();
      _equivalenceClasses=new HashMap<IOPort,Collection<IOPort>>();
      List<IOPort> actorInputs=_actor.inputPortList();
      for (      IOPort actorInput : actorInputs) {
        Set<IOPort> equivalences=new HashSet<IOPort>();
        equivalences.add(actorInput);
        _equivalenceClasses.put(actorInput,equivalences);
      }
      Collection<IOPort> stateEquivalentPorts=new HashSet<IOPort>();
      Collection<Transition> transitions;
      if (!stateDependentCausality) {
        transitions=actor.relationList();
      }
 else {
        State currentState=actor.currentState();
        transitions=currentState.outgoingPort.linkedRelationList();
      }
      for (      Transition transition : transitions) {
        Set<IOPort> outputs=new HashSet<IOPort>();
        List<AbstractActionsAttribute> actions=transition.choiceActionList();
        for (        AbstractActionsAttribute action : actions) {
          List<String> names=action.getDestinationNameList();
          for (          String name : names) {
            NamedObj destination=action.getDestination(name);
            if (destination instanceof IOPort && ((IOPort)destination).isOutput()) {
              outputs.add((IOPort)destination);
            }
          }
        }
        Set<IOPort> inputs=new HashSet<IOPort>();
        String guard=transition.getGuardExpression();
        if (guard.trim().equals(""String_Node_Str"")) {
          continue;
        }
        PtParser parser=new PtParser();
        try {
          ASTPtRootNode guardParseTree=parser.generateParseTree(guard);
          ParseTreeFreeVariableCollector collector=new ParseTreeFreeVariableCollector();
          Set<String> freeVariables=collector.collectFreeVariables(guardParseTree);
          for (          String freeVariable : freeVariables) {
            IOPort port=actor._getPortForIdentifier(freeVariable);
            if (port != null && port.isInput()) {
              inputs.add(port);
            }
          }
        }
 catch (        IllegalActionException ex) {
          throw new IllegalActionException(actor,ex,""String_Node_Str"" + guard + ""String_Node_Str"");
        }
        if (inputs.isEmpty()) {
          continue;
        }
        stateEquivalentPorts.addAll(inputs);
        for (        IOPort writtenOutput : outputs) {
          Map<IOPort,Dependency> outputMap=_reverseDependencies.get(writtenOutput);
          if (outputMap == null) {
            outputMap=new HashMap<IOPort,Dependency>();
            _reverseDependencies.put(writtenOutput,outputMap);
          }
          for (          IOPort readInput : inputs) {
            outputMap.put(readInput,_defaultDependency.oTimesIdentity());
            Map<IOPort,Dependency> inputMap=_forwardDependencies.get(readInput);
            if (inputMap == null) {
              inputMap=new HashMap<IOPort,Dependency>();
              _forwardDependencies.put(readInput,inputMap);
            }
            inputMap.put(writtenOutput,_defaultDependency.oTimesIdentity());
          }
        }
      }
      Collection<State> states;
      if (!stateDependentCausality) {
        states=actor.entityList();
      }
 else {
        State currentState=actor.currentState();
        states=new HashSet<State>();
        states.add(currentState);
      }
      for (      State state : states) {
        TypedActor[] refinements=state.getRefinement();
        if (refinements != null && refinements.length > 0) {
          for (          TypedActor refinement : refinements) {
            CausalityInterface causality=refinement.getCausalityInterface();
            Collection<IOPort> outputs=refinement.outputPortList();
            for (            IOPort refinementOutput : outputs) {
              Collection<IOPort> inputs=causality.dependentPorts(refinementOutput);
              for (              IOPort refinementInput : inputs) {
                Collection<IOPort> equivalents=causality.equivalentPorts(refinementInput);
                for (                IOPort equivalent : equivalents) {
                  IOPort port=(IOPort)actor.getPort(equivalent.getName());
                  if (port != null) {
                    stateEquivalentPorts.add(port);
                  }
                }
              }
            }
          }
        }
      }
      List<IOPort> inputs=_actor.inputPortList();
      for (      IOPort actorInput : inputs) {
        if (actorInput instanceof ParameterPort) {
          stateEquivalentPorts=inputs;
          break;
        }
      }
      for (      IOPort equivalent : stateEquivalentPorts) {
        _equivalenceClasses.put(equivalent,stateEquivalentPorts);
      }
    }
  finally {
      actor.workspace().doneReading();
    }
    _dependencyVersion=workspaceVersion;
  }
  if (output == null) {
    return null;
  }
  Map<IOPort,Dependency> inputMap=_forwardDependencies.get(input);
  if (inputMap != null) {
    Dependency result=inputMap.get(output);
    if (result != null) {
      return result;
    }
  }
  return _defaultDependency.oPlusIdentity();
}"
72955,"/** 
 * Open a composite entity, if it is not already open, and recursively open any composite entities or state refinements that it contains.
 * @param entity The entity to open.
 * @param tableauxToClose A list of tableaux are newly opened.
 * @param masterEffigy The top-level effigy for the modeling being exported.
 * @param graphFrame The graph frame.
 * @exception IllegalActionException If opening fails.
 * @exception NameDuplicationException Not thrown.
 */
private static void _openComposite(CompositeEntity entity,Set<Tableau> tableauxToClose,Effigy masterEffigy,BasicGraphFrame graphFrame) throws IllegalActionException {
  Configuration configuration=graphFrame.getConfiguration();
  Effigy effigy=configuration.getEffigy(entity);
  if (effigy != null) {
    List<Tableau> tableaux=effigy.entityList(Tableau.class);
    if (tableaux == null || tableaux.size() == 0) {
      tableauxToClose.add(configuration.createPrimaryTableau(effigy));
    }
  }
 else {
    Tableau tableau;
    try {
      tableau=configuration.openModel(entity);
      tableauxToClose.add(tableau);
    }
 catch (    NameDuplicationException e) {
      throw new InternalErrorException(e);
    }
  }
  List<Entity> entities=entity.entityList();
  for (  Entity inside : entities) {
    _openEntity(inside,tableauxToClose,masterEffigy,graphFrame);
  }
}","/** 
 * Open a composite entity, if it is not already open, and recursively open any composite entities or state refinements that it contains.
 * @param entity The entity to open.
 * @param tableauxToClose A list of tableaux are newly opened.
 * @param masterEffigy The top-level effigy for the modeling being exported.
 * @param graphFrame The graph frame.
 * @exception IllegalActionException If opening fails.
 * @exception NameDuplicationException Not thrown.
 */
private static void _openComposite(CompositeEntity entity,Set<Tableau> tableauxToClose,Effigy masterEffigy,BasicGraphFrame graphFrame) throws IllegalActionException {
  Configuration configuration=graphFrame.getConfiguration();
  Effigy effigy=configuration.getEffigy(entity);
  Tableau tableau;
  if (effigy != null) {
    List<Tableau> tableaux=effigy.entityList(Tableau.class);
    if (tableaux == null || tableaux.size() == 0) {
      tableau=configuration.createPrimaryTableau(effigy);
      tableauxToClose.add(tableau);
    }
 else {
      tableau=tableaux.get(0);
    }
  }
 else {
    try {
      tableau=configuration.openModel(entity);
      tableauxToClose.add(tableau);
    }
 catch (    NameDuplicationException e) {
      throw new InternalErrorException(e);
    }
  }
  CompositeEntity actualEntity=entity;
  if (tableau instanceof ActorGraphTableau) {
    PtolemyEffigy actualEffigy=(PtolemyEffigy)tableau.getContainer();
    actualEntity=(CompositeEntity)actualEffigy.getModel();
  }
  List<Entity> entities=actualEntity.entityList();
  for (  Entity inside : entities) {
    _openEntity(inside,tableauxToClose,masterEffigy,graphFrame);
  }
}"
72956,"/** 
 * Return the list of quantity managers in this port. A quantity manager is a   {@link Parameter} whose value is an{@link ObjectToken} that references an object that implementsthe  {@link QuantityManager} interface.
 * @return The list of quantity managers.
 * @exception IllegalActionException Thrown if the token of the parametercontaining the quantity manager object cannot be retrieved.
 */
public List<QuantityManager> getQuantityManagers() throws IllegalActionException {
  _qmList=new ArrayList<QuantityManager>();
  List<ResourceAttributes> list=this.attributeList(ResourceAttributes.class);
  for (  ResourceAttributes attribute : list) {
    if (attribute.enabled()) {
      _qmList.add((QuantityManager)attribute.getDecorator());
    }
  }
  _qmListValid=true;
  return _qmList;
}","/** 
 * Return the list of quantity managers in this port. A quantity manager is a   {@link Parameter} whose value is an{@link ObjectToken} that references an object that implementsthe  {@link QuantityManager} interface.
 * @return The list of quantity managers.
 * @exception IllegalActionException Thrown if the token of the parametercontaining the quantity manager object cannot be retrieved.
 */
public List<QuantityManager> getQuantityManagers() throws IllegalActionException {
  _qmList=new ArrayList<QuantityManager>();
  List<ResourceAttributes> list=this.attributeList(ResourceAttributes.class);
  for (  ResourceAttributes attribute : list) {
    if (attribute.enabled()) {
      if ((QuantityManager)attribute.getDecorator() != null) {
        _qmList.add((QuantityManager)attribute.getDecorator());
        attribute.validateSettables();
      }
    }
  }
  _qmListValid=true;
  return _qmList;
}"
72957,"@Override public boolean postfire() throws IllegalActionException {
  boolean postfire=super.postfire();
  for (  Object entity : entityList()) {
    if (entity instanceof ResourceMappingOutputPort) {
      ResourceMappingOutputPort outputPort=((ResourceMappingOutputPort)entity);
      if (outputPort.hasToken() && outputPort.getToken() instanceof RecordToken) {
        RecordToken recordToken=(RecordToken)outputPort.getToken();
        if (recordToken.get(""String_Node_Str"") != null && ((ObjectToken)recordToken.get(""String_Node_Str"")).getValue() != null) {
          Actor actor=(Actor)((ObjectToken)recordToken.get(""String_Node_Str"")).getValue();
          event((NamedObj)actor,getDirector().getModelTime().getDoubleValue(),ExecutionEventType.STOP);
          outputPort.takeToken();
          _currentlyExecuting.remove(actor);
          actor.getDirector().resumeActor(actor);
          _lastActorFinished=true;
        }
      }
    }
  }
  return postfire;
}","@Override public boolean postfire() throws IllegalActionException {
  boolean postfire=super.postfire();
  for (  Object entity : entityList()) {
    if (entity instanceof ResourceMappingOutputPort) {
      ResourceMappingOutputPort outputPort=((ResourceMappingOutputPort)entity);
      if (outputPort.hasToken() && outputPort.getToken() instanceof RecordToken) {
        RecordToken recordToken=(RecordToken)outputPort.getToken();
        if (recordToken.get(""String_Node_Str"") != null && ((ObjectToken)recordToken.get(""String_Node_Str"")).getValue() != null) {
          Actor actor=(Actor)((ObjectToken)recordToken.get(""String_Node_Str"")).getValue();
          event((NamedObj)actor,getExecutiveDirector().getModelTime().getDoubleValue(),ExecutionEventType.STOP);
          outputPort.takeToken();
          _currentlyExecuting.remove(actor);
          actor.getExecutiveDirector().resumeActor(actor);
          _lastActorFinished=true;
        }
      }
    }
  }
  return postfire;
}"
72958,"/** 
 * Schedule a new actor for execution. Find the const actor in the _model that is mapped to this actor and trigger a firing of that one, if the actor is not already in execution. If the actor finished execution, return zero time, otherwise return the next time the model has something to do.
 * @param actor The actor to be scheduled.
 * @param currentPlatformTime The current platform time.
 * @param deadline The deadline of the event.
 * @param executionTime The execution time of the actor.
 * @return Relative time when this Scheduler has to be executedagain.
 * @exception IllegalActionException Thrown if actor paramaters suchas execution time or priority cannot be read.
 */
protected Time _schedule(Actor actor,Time currentPlatformTime,Time deadline,Time executionTime) throws IllegalActionException {
  _lastActorFinished=false;
  getDirector().setModelTime(getDirector().localClock.getLocalTimeForCurrentEnvironmentTime());
  if (!_currentlyExecuting.contains(actor)) {
    event((NamedObj)actor,getDirector().getModelTime().getDoubleValue(),ExecutionEventType.START);
    ResourceMappingInputPort requestPort=(ResourceMappingInputPort)getEntity(_requestPorts.get(actor));
    if (requestPort != null) {
      RecordToken recordToken=new RecordToken(new String[]{""String_Node_Str"",""String_Node_Str""},new Token[]{new ObjectToken(actor),new DoubleToken(executionTime.getDoubleValue())});
      requestPort.value.setToken(recordToken);
      getDirector().fireAtCurrentTime(requestPort);
      getExecutiveDirector().fireAt(this,getDirector().getModelTime());
      _currentlyExecuting.add(actor);
    }
 else {
      throw new IllegalActionException(this,""String_Node_Str"" + _requestPorts.get(actor));
    }
  }
  return Time.POSITIVE_INFINITY;
}","/** 
 * Schedule a new actor for execution. Find the const actor in the _model that is mapped to this actor and trigger a firing of that one, if the actor is not already in execution. If the actor finished execution, return zero time, otherwise return the next time the model has something to do.
 * @param actor The actor to be scheduled.
 * @param currentPlatformTime The current platform time.
 * @param deadline The deadline of the event.
 * @param executionTime The execution time of the actor.
 * @return Relative time when this Scheduler has to be executedagain.
 * @exception IllegalActionException Thrown if actor paramaters suchas execution time or priority cannot be read.
 */
protected Time _schedule(Actor actor,Time currentPlatformTime,Time deadline,Time executionTime) throws IllegalActionException {
  _lastActorFinished=false;
  getDirector().setModelTime(getExecutiveDirector().localClock.getLocalTime());
  if (!_currentlyExecuting.contains(actor)) {
    event((NamedObj)actor,getExecutiveDirector().localClock.getLocalTime().getDoubleValue(),ExecutionEventType.START);
    ResourceMappingInputPort requestPort=(ResourceMappingInputPort)getEntity(_requestPorts.get(actor));
    if (requestPort != null) {
      RecordToken recordToken=new RecordToken(new String[]{""String_Node_Str"",""String_Node_Str""},new Token[]{new ObjectToken(actor),new DoubleToken(executionTime.getDoubleValue())});
      requestPort.value.setToken(recordToken);
      getDirector().fireAtCurrentTime(requestPort);
      getExecutiveDirector().fireAt(this,getDirector().getModelTime());
      _currentlyExecuting.add(actor);
    }
 else {
      throw new IllegalActionException(this,""String_Node_Str"" + _requestPorts.get(actor));
    }
  }
  return Time.POSITIVE_INFINITY;
}"
72959,"public void getfire(ResultHandler<Iterable<Event.Builder>> resultHandler) throws CollectionAbortedException {
  while (!createProcess) {
  }
  syncEvents(events);
  do {
    resultHandler.handleResult(events);
  }
 while (!atLeastOneNotified(events));
  pushEvents(events);
}","public void getfire(ResultHandler<Iterable<Event.Builder>> resultHandler) throws CollectionAbortedException {
  syncEvents(events);
  do {
    resultHandler.handleResult(events);
  }
 while (!atLeastOneNotified(events));
  pushEvents(events);
}"
72960,"/** 
 * Add names of available CQMInputPort in CompositeQM as choices to inputPort.
 * @exception InteralErrorException Thrown if CompositeQMcannot be accessed.  
 */
@Override public void updateContent() throws InternalErrorException {
  super.updateContent();
  try {
    if (getDecorator() != null) {
      List<String> choices=new ArrayList();
      if (inputPort.getChoices() != null) {
        for (int i=0; i < inputPort.getChoices().length; i++) {
          choices.add(inputPort.getChoices()[i]);
        }
      }
      List cqmInputPorts=((CompositeQM)getDecorator()).entityList(CQMInputPort.class);
      for (      Object cqmInputPort : cqmInputPorts) {
        String name=((CQMInputPort)cqmInputPort).getName();
        if (!choices.contains(name)) {
          inputPort.addChoice(name);
        }
      }
    }
  }
 catch (  IllegalActionException e) {
    throw new InternalErrorException(e);
  }
}","/** 
 * Add names of available CQMInputPort in CompositeQM as choices to inputPort.
 * @exception InteralErrorException Thrown if CompositeQMcannot be accessed.  
 */
@Override public void updateContent() throws InternalErrorException {
  super.updateContent();
  try {
    if (getDecorator() != null) {
      inputPort.removeAllChoices();
      List cqmInputPorts=((CompositeQM)getDecorator()).entityList(CQMInputPort.class);
      for (      Object cqmInputPort : cqmInputPorts) {
        String name=((CQMInputPort)cqmInputPort).getName();
        inputPort.addChoice(name);
      }
    }
  }
 catch (  IllegalActionException e) {
    throw new InternalErrorException(e);
  }
}"
72961,"/** 
 * Add names of available CQMInputPort in CompositeQM as choices to inputPort.
 * @exception InteralErrorException Thrown if CompositeQMcannot be accessed.  
 */
@Override public void updateContent() throws InternalErrorException {
  super.updateContent();
  try {
    if (getDecorator() != null) {
      List<String> choices=new ArrayList();
      if (requestPort.getChoices() != null) {
        for (int i=0; i < requestPort.getChoices().length; i++) {
          choices.add(requestPort.getChoices()[i]);
        }
      }
      List cqmInputPorts=((CompositeResourceScheduler)getDecorator()).entityList(ResourceMappingInputPort.class);
      for (      Object cqmInputPort : cqmInputPorts) {
        String name=((ResourceMappingInputPort)cqmInputPort).getName();
        if (!choices.contains(name)) {
          requestPort.addChoice(name);
        }
      }
    }
  }
 catch (  IllegalActionException e) {
    throw new InternalErrorException(e);
  }
}","/** 
 * Add names of available CQMInputPort in CompositeQM as choices to inputPort.
 * @exception InteralErrorException Thrown if CompositeQMcannot be accessed.  
 */
@Override public void updateContent() throws InternalErrorException {
  super.updateContent();
  try {
    if (getDecorator() != null) {
      requestPort.removeAllChoices();
      List cqmInputPorts=((CompositeResourceScheduler)getDecorator()).entityList(ResourceMappingInputPort.class);
      for (      Object cqmInputPort : cqmInputPorts) {
        String name=((ResourceMappingInputPort)cqmInputPort).getName();
        requestPort.addChoice(name);
      }
    }
  }
 catch (  IllegalActionException e) {
    throw new InternalErrorException(e);
  }
}"
72962,"/** 
 * Schedule an actor for execution on a ResourceScheduler. If the actor can execute this method returns true. If resources are not available this method returns false.
 * @param actor The actor.
 * @param timestamp The time the actor requests to be scheduled.
 * @return True if actor was scheduled and can be fired.
 * @exception IllegalActionException Thrown if parameters cannot be read, actor cannot bescheduled or container cannot be fired at future time.
 */
protected boolean _schedule(Actor actor,Time timestamp) throws IllegalActionException {
  ResourceScheduler scheduler=_getResourceScheduler(actor);
  Time time=null;
  Boolean finished=true;
  if (timestamp == null) {
    timestamp=getModelTime();
  }
  if (scheduler != null) {
    Time environmentTime=((CompositeActor)scheduler.getContainer()).getDirector().getEnvironmentTime();
    time=scheduler.schedule(actor,environmentTime,getDeadline(actor,timestamp));
    if (_nextScheduleTime == null) {
      _nextScheduleTime=new HashMap<ResourceScheduler,Time>();
    }
    _nextScheduleTime.put(scheduler,time);
    finished=_actorFinished(actor);
    if (time != null && time.getDoubleValue() > 0.0 && time.compareTo(Time.POSITIVE_INFINITY) != 0) {
      CompositeActor container=(CompositeActor)scheduler.getContainer();
      container.getDirector().fireContainerAt(environmentTime.add(time));
    }
  }
 else   if (isEmbedded()) {
    return ((CompositeActor)((CompositeActor)getContainer()).getContainer()).getDirector()._schedule(actor,timestamp);
  }
  return time == null || finished;
}","/** 
 * Schedule an actor for execution on a ResourceScheduler. If the actor can execute this method returns true. If resources are not available this method returns false.
 * @param actor The actor.
 * @param timestamp The time the actor requests to be scheduled.
 * @return True if actor was scheduled and can be fired.
 * @exception IllegalActionException Thrown if parameters cannot be read, actor cannot bescheduled or container cannot be fired at future time.
 */
protected boolean _schedule(Actor actor,Time timestamp) throws IllegalActionException {
  ResourceScheduler scheduler=_getResourceScheduler(actor);
  Time time=null;
  Boolean finished=true;
  if (timestamp == null) {
    timestamp=getModelTime();
  }
  if (scheduler != null) {
    Time environmentTime=((CompositeActor)scheduler.getContainer()).getDirector().getEnvironmentTime();
    time=scheduler.schedule(actor,environmentTime,getDeadline(actor,timestamp));
    if (_nextScheduleTime == null) {
      _nextScheduleTime=new HashMap<ResourceScheduler,Time>();
    }
    _nextScheduleTime.put(scheduler,time);
    finished=_actorFinished(actor);
    if (time != null && time.getDoubleValue() > 0.0) {
      CompositeActor container=(CompositeActor)scheduler.getContainer();
      Time fireAtTime=environmentTime;
      if (!time.equals(Time.POSITIVE_INFINITY)) {
        fireAtTime=fireAtTime.add(time);
      }
      container.getDirector().fireContainerAt(fireAtTime);
    }
  }
 else   if (isEmbedded()) {
    return ((CompositeActor)((CompositeActor)getContainer()).getContainer()).getDirector()._schedule(actor,timestamp);
  }
  return time == null || finished;
}"
72963,"public void resumeActor(Actor actor) throws IllegalActionException {
  _actorsFinished.add(actor);
  System.out.println(""String_Node_Str"" + actor);
}","public void resumeActor(Actor actor) throws IllegalActionException {
  _actorsFinished.add(actor);
}"
72964,"/** 
 * Get the next actor that can be fired from a specified event queue. Check whether the event is safe to process, the actors prefire returns true and the event can be scheduled. Because Ptides does not store tokens in receivers but keeps them in the event until the actor is really fired, we have to temporarily put tokens into receivers and then remove them in order for the prefire to give correct results.
 * @param queue The event queue.
 * @return The next actor to fire or null.
 * @exception IllegalActionException Thrown by safeToProcess, prefireor schedule.
 */
private Actor _getNextActorFrom(DEEventQueue queue) throws IllegalActionException {
  Object[] eventArray=queue.toArray();
  for (  Object event : eventArray) {
    System.out.println(event);
    if (_isSafeToProcess((PtidesEvent)event)) {
      PtidesEvent ptidesEvent=(PtidesEvent)event;
      Actor actor=ptidesEvent.actor();
      Time timestamp=ptidesEvent.timeStamp();
      if (queue == _pureEvents) {
        for (        Object triggeredEventObject : _eventQueue.toArray()) {
          PtidesEvent triggeredEvent=(PtidesEvent)triggeredEventObject;
          if (triggeredEvent.actor() == actor && triggeredEvent.timeStamp().compareTo(timestamp) < 0) {
            ptidesEvent=triggeredEvent;
          }
        }
      }
      actor=ptidesEvent.actor();
      timestamp=ptidesEvent.timeStamp();
      List<PtidesEvent> sameTagEvents=new ArrayList<PtidesEvent>();
      int i=0;
      while (i < queue.size()) {
        PtidesEvent eventInQueue=((PtidesListEventQueue)queue).get(i);
        if (eventInQueue.hasTheSameTagAs(ptidesEvent) && eventInQueue.actor().equals(actor)) {
          sameTagEvents.add(eventInQueue);
          if (eventInQueue.receiver() != null) {
            if (eventInQueue.receiver() instanceof PtidesReceiver) {
              ((PtidesReceiver)eventInQueue.receiver()).putToReceiver(eventInQueue.token());
            }
          }
        }
        i++;
      }
      _currentLogicalTime=timestamp;
      _currentLogicalIndex=ptidesEvent.microstep();
      _currentSourceTimestamp=ptidesEvent.sourceTimestamp();
      boolean prefire=actor.prefire();
      _currentLogicalTime=null;
      for (      PtidesEvent sameTagEvent : sameTagEvents) {
        if (sameTagEvent.receiver() != null) {
          if (sameTagEvent.receiver() instanceof PtidesReceiver) {
            ((PtidesReceiver)sameTagEvent.receiver()).remove(sameTagEvent.token());
          }
        }
      }
      if (prefire)       System.out.println(getModelTime() + ""String_Node_Str"" + actor+ ""String_Node_Str""+ timestamp);
      if (prefire && (!_resourceScheduling || ((queue != _pureEvents && actor instanceof TimeDelay) || _actorsFinished.contains(actor) || _schedule(actor,timestamp)) && (!(actor instanceof CompositeActor) || ((CompositeActor)actor).getDirector().scheduleContainedActors()))) {
        System.out.println(""String_Node_Str"");
        _currentLogicalTime=timestamp;
        _currentLogicalIndex=ptidesEvent.microstep();
        _currentSourceTimestamp=ptidesEvent.sourceTimestamp();
        _removeEventsFromQueue(_eventQueue,ptidesEvent);
        _removeEventsFromQueue(_pureEvents,ptidesEvent);
        _actorsFinished.remove(actor);
        if (_debugging) {
          _debug(""String_Node_Str"" + actor + ""String_Node_Str""+ timestamp);
        }
        return actor;
      }
    }
  }
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  return null;
}","/** 
 * Get the next actor that can be fired from a specified event queue. Check whether the event is safe to process, the actors prefire returns true and the event can be scheduled. Because Ptides does not store tokens in receivers but keeps them in the event until the actor is really fired, we have to temporarily put tokens into receivers and then remove them in order for the prefire to give correct results.
 * @param queue The event queue.
 * @return The next actor to fire or null.
 * @exception IllegalActionException Thrown by safeToProcess, prefireor schedule.
 */
private Actor _getNextActorFrom(DEEventQueue queue) throws IllegalActionException {
  Object[] eventArray=queue.toArray();
  for (  Object event : eventArray) {
    if (_isSafeToProcess((PtidesEvent)event)) {
      PtidesEvent ptidesEvent=(PtidesEvent)event;
      Actor actor=ptidesEvent.actor();
      Time timestamp=ptidesEvent.timeStamp();
      if (queue == _pureEvents) {
        for (        Object triggeredEventObject : _eventQueue.toArray()) {
          PtidesEvent triggeredEvent=(PtidesEvent)triggeredEventObject;
          if (triggeredEvent.actor() == actor && triggeredEvent.timeStamp().compareTo(timestamp) < 0) {
            ptidesEvent=triggeredEvent;
          }
        }
      }
      actor=ptidesEvent.actor();
      timestamp=ptidesEvent.timeStamp();
      List<PtidesEvent> sameTagEvents=new ArrayList<PtidesEvent>();
      int i=0;
      while (i < queue.size()) {
        PtidesEvent eventInQueue=((PtidesListEventQueue)queue).get(i);
        if (eventInQueue.hasTheSameTagAs(ptidesEvent) && eventInQueue.actor().equals(actor)) {
          sameTagEvents.add(eventInQueue);
          if (eventInQueue.receiver() != null) {
            if (eventInQueue.receiver() instanceof PtidesReceiver) {
              ((PtidesReceiver)eventInQueue.receiver()).putToReceiver(eventInQueue.token());
            }
          }
        }
        i++;
      }
      _currentLogicalTime=timestamp;
      _currentLogicalIndex=ptidesEvent.microstep();
      _currentSourceTimestamp=ptidesEvent.sourceTimestamp();
      boolean prefire=actor.prefire();
      _currentLogicalTime=null;
      for (      PtidesEvent sameTagEvent : sameTagEvents) {
        if (sameTagEvent.receiver() != null) {
          if (sameTagEvent.receiver() instanceof PtidesReceiver) {
            ((PtidesReceiver)sameTagEvent.receiver()).remove(sameTagEvent.token());
          }
        }
      }
      if (prefire && (!_resourceScheduling || ((queue != _pureEvents && actor instanceof TimeDelay) || _actorsFinished.contains(actor) || _schedule(actor,timestamp)) && (!(actor instanceof CompositeActor) || ((CompositeActor)actor).getDirector().scheduleContainedActors()))) {
        _currentLogicalTime=timestamp;
        _currentLogicalIndex=ptidesEvent.microstep();
        _currentSourceTimestamp=ptidesEvent.sourceTimestamp();
        _removeEventsFromQueue(_eventQueue,ptidesEvent);
        _removeEventsFromQueue(_pureEvents,ptidesEvent);
        _actorsFinished.remove(actor);
        if (_debugging) {
          _debug(""String_Node_Str"" + actor + ""String_Node_Str""+ timestamp);
        }
        return actor;
      }
    }
  }
  if (_debugging) {
    _debug(""String_Node_Str"");
  }
  return null;
}"
72965,"/** 
 * Provide content to the specified web exporter to be included in a web page for the container of this object.
 * @param exporter  The web exporter to write content to
 * @exception IllegalActionException If evaluating the valueof this parameter fails, or creating a web attribute fails.
 */
protected void _provideAttributes(WebExporter exporter) throws IllegalActionException {
  super._provideAttributes(exporter);
  HashMap<String,String> config=getBasicConfig();
  insertHeaderContent(false,true,""String_Node_Str"" + config.get(""String_Node_Str"") + ""String_Node_Str"");
  for (  String line : _otherLibs) {
    insertHeaderContent(false,true,line);
  }
  insertHeaderContent(true,true,""String_Node_Str"");
  insertHeaderContent(true,true,""String_Node_Str"");
  insertHeaderContent(true,true,""String_Node_Str"" + config.get(""String_Node_Str"") + ""String_Node_Str"");
  insertHeaderContent(true,true,""String_Node_Str"" + config.get(""String_Node_Str"") + ""String_Node_Str"");
  insertHeaderContent(true,true,""String_Node_Str"" + config.get(""String_Node_Str"") + ""String_Node_Str""+ ""String_Node_Str""+ config.get(""String_Node_Str"")+ ""String_Node_Str""+ config.get(""String_Node_Str"")+ ""String_Node_Str""+ ""String_Node_Str""+ config.get(""String_Node_Str"")+ ""String_Node_Str""+ ""String_Node_Str""+ config.get(""String_Node_Str"")+ ""String_Node_Str""+ config.get(""String_Node_Str"")+ ""String_Node_Str""+ config.get(""String_Node_Str"")+ ""String_Node_Str""+ config.get(""String_Node_Str"")+ ""String_Node_Str""+ config.get(""String_Node_Str"")+ ""String_Node_Str""+ config.get(""String_Node_Str"")+ ""String_Node_Str""+ config.get(""String_Node_Str"")+ ""String_Node_Str""+ ""String_Node_Str""+ config.get(""String_Node_Str"")+ ""String_Node_Str""+ config.get(""String_Node_Str"")+ ""String_Node_Str""+ ""String_Node_Str""+ config.get(""String_Node_Str"")+ ""String_Node_Str""+ ""String_Node_Str""+ config.get(""String_Node_Str"")+ ""String_Node_Str""+ config.get(""String_Node_Str"")+ ""String_Node_Str"");
  for (  String line : _plotCode) {
    insertHeaderContent(true,false,line + ""String_Node_Str"");
  }
  String widthConfig=Boolean.valueOf(config.get(""String_Node_Str"")) ? ""String_Node_Str"" : ""String_Node_Str"";
  String heightConfig=Boolean.valueOf(config.get(""String_Node_Str"")) ? ""String_Node_Str"" : ""String_Node_Str"";
  insertBodyContent(""String_Node_Str"" + widthConfig + ""String_Node_Str""+ config.get(""String_Node_Str"")+ ""String_Node_Str""+ heightConfig+ ""String_Node_Str""+ config.get(""String_Node_Str"")+ ""String_Node_Str"");
  insertBodyContent(""String_Node_Str"" + widthConfig + ""String_Node_Str""+ config.get(""String_Node_Str"")+ ""String_Node_Str"");
  for (  String line : _bodyContent) {
    insertBodyContent(line + ""String_Node_Str"");
  }
  WebElement webElement=WebElement.createWebElement(getContainer(),""String_Node_Str"",""String_Node_Str"");
  webElement.setExpression(getHTMLPageContent());
  webElement.setParent(config.get(""String_Node_Str""));
  exporter.defineElement(webElement,true);
  if (Boolean.valueOf(config.get(""String_Node_Str""))) {
    webElement=WebElement.createWebElement(getContainer(),""String_Node_Str"",""String_Node_Str"");
    webElement.setExpression(config.get(""String_Node_Str"") + ""String_Node_Str"" + config.get(""String_Node_Str""));
    webElement.setParent(config.get(""String_Node_Str""));
    exporter.defineElement(webElement,true);
  }
}","/** 
 * Provide content to the specified web exporter to be included in a web page for the container of this object.
 * @param exporter  The web exporter to write content to
 * @exception IllegalActionException If evaluating the valueof this parameter fails, or creating a web attribute fails.
 */
protected void _provideAttributes(WebExporter exporter) throws IllegalActionException {
  super._provideAttributes(exporter);
  HashMap<String,String> config=getBasicConfig();
  insertHeaderContent(false,true,""String_Node_Str"" + config.get(""String_Node_Str"") + ""String_Node_Str"");
  for (  String line : _otherLibs) {
    insertHeaderContent(false,true,line);
  }
  insertHeaderContent(true,true,""String_Node_Str"");
  insertHeaderContent(true,true,""String_Node_Str"" + config.get(""String_Node_Str"") + ""String_Node_Str"");
  insertHeaderContent(true,true,""String_Node_Str"" + config.get(""String_Node_Str"") + ""String_Node_Str"");
  insertHeaderContent(true,true,""String_Node_Str"" + config.get(""String_Node_Str"") + ""String_Node_Str""+ ""String_Node_Str""+ config.get(""String_Node_Str"")+ ""String_Node_Str""+ config.get(""String_Node_Str"")+ ""String_Node_Str""+ ""String_Node_Str""+ config.get(""String_Node_Str"")+ ""String_Node_Str""+ ""String_Node_Str""+ config.get(""String_Node_Str"")+ ""String_Node_Str""+ config.get(""String_Node_Str"")+ ""String_Node_Str""+ config.get(""String_Node_Str"")+ ""String_Node_Str""+ config.get(""String_Node_Str"")+ ""String_Node_Str""+ config.get(""String_Node_Str"")+ ""String_Node_Str""+ config.get(""String_Node_Str"")+ ""String_Node_Str""+ config.get(""String_Node_Str"")+ ""String_Node_Str""+ ""String_Node_Str""+ config.get(""String_Node_Str"")+ ""String_Node_Str""+ config.get(""String_Node_Str"")+ ""String_Node_Str""+ ""String_Node_Str""+ config.get(""String_Node_Str"")+ ""String_Node_Str""+ ""String_Node_Str""+ config.get(""String_Node_Str"")+ ""String_Node_Str""+ config.get(""String_Node_Str"")+ ""String_Node_Str"");
  for (  String line : _plotCode) {
    insertHeaderContent(true,false,line + ""String_Node_Str"");
  }
  String widthConfig=Boolean.valueOf(config.get(""String_Node_Str"")) ? ""String_Node_Str"" : ""String_Node_Str"";
  String heightConfig=Boolean.valueOf(config.get(""String_Node_Str"")) ? ""String_Node_Str"" : ""String_Node_Str"";
  insertBodyContent(""String_Node_Str"" + widthConfig + ""String_Node_Str""+ config.get(""String_Node_Str"")+ ""String_Node_Str""+ heightConfig+ ""String_Node_Str""+ config.get(""String_Node_Str"")+ ""String_Node_Str"");
  insertBodyContent(""String_Node_Str"" + widthConfig + ""String_Node_Str""+ config.get(""String_Node_Str"")+ ""String_Node_Str"");
  for (  String line : _bodyContent) {
    insertBodyContent(line + ""String_Node_Str"");
  }
  WebElement webElement=WebElement.createWebElement(getContainer(),""String_Node_Str"",""String_Node_Str"");
  webElement.setExpression(getHTMLPageContent());
  webElement.setParent(config.get(""String_Node_Str""));
  exporter.defineElement(webElement,true);
  if (Boolean.valueOf(config.get(""String_Node_Str""))) {
    webElement=WebElement.createWebElement(getContainer(),""String_Node_Str"",""String_Node_Str"");
    webElement.setExpression(config.get(""String_Node_Str"") + ""String_Node_Str"" + config.get(""String_Node_Str""));
    webElement.setParent(config.get(""String_Node_Str""));
    exporter.defineElement(webElement,true);
  }
}"
72966,"/** 
 * The postfire() counts the number of iterations and returns false when the number of iteration exceeds the parameter iterations. postfire() will always return true if the parameter iterations is less or equal to 0.
 */
public boolean postfire() throws IllegalActionException {
  _iterationCount++;
  int iterationsValue=((IntToken)iterations.getToken()).intValue();
  if (_stopRequested || iterationsValue > 0 && _iterationCount >= iterationsValue) {
    _iterationCount=0;
    for (    StartOrResumable actor : _actorList) {
      actor.reset();
    }
    return false;
  }
  return true;
}","/** 
 * The postfire() counts the number of iterations and returns false when the number of iteration exceeds the parameter iterations. postfire() will always return true if the parameter iterations is less or equal to 0.
 */
public boolean postfire() throws IllegalActionException {
  _iterationCount++;
  int iterationsValue=((IntToken)iterations.getToken()).intValue();
  if (_stopRequested || iterationsValue >= 0 && _iterationCount >= iterationsValue) {
    _iterationCount=0;
    for (    StartOrResumable actor : _actorList) {
      actor.reset();
    }
    return false;
  }
  return true;
}"
72967,"/** 
 * Schedule an actor for execution on a ResourceScheduler. If the actor can execute this method returns true. If resources are not available this method returns false.
 * @param actor The actor.
 * @param timestamp The time the actor requests to be scheduled.
 * @return True if actor was scheduled and can be fired.
 * @exception IllegalActionException Thrown if parameters cannot be read, actor cannot bescheduled or container cannot be fired at future time.
 */
protected boolean _schedule(Actor actor,Time timestamp) throws IllegalActionException {
  ResourceScheduler scheduler=_getResourceScheduler(actor);
  Time time=null;
  Boolean finished=true;
  if (timestamp == null) {
    timestamp=getModelTime();
  }
  if (scheduler != null) {
    Time environmentTime=((CompositeActor)scheduler.getContainer()).getDirector().getEnvironmentTime();
    time=scheduler.schedule(actor,environmentTime,getDeadline(actor,timestamp));
    if (_nextScheduleTime == null) {
      _nextScheduleTime=new HashMap<ResourceScheduler,Time>();
    }
    _nextScheduleTime.put(scheduler,time);
    finished=_actorFinished(actor);
    if (time != null && time.getDoubleValue() > 0.0) {
      CompositeActor container=(CompositeActor)scheduler.getContainer();
      Time fireAtTime=environmentTime;
      if (!time.equals(Time.POSITIVE_INFINITY)) {
        fireAtTime=fireAtTime.add(time);
      }
      container.getDirector().fireContainerAt(fireAtTime);
    }
  }
 else   if (isEmbedded()) {
    return ((CompositeActor)((CompositeActor)getContainer()).getContainer()).getDirector()._schedule(actor,timestamp);
  }
  return time == null || finished;
}","/** 
 * Schedule an actor for execution on a ResourceScheduler. If the actor can execute this method returns true. If resources are not available this method returns false.
 * @param actor The actor.
 * @param timestamp The time the actor requests to be scheduled.
 * @return True if actor was scheduled and can be fired.
 * @exception IllegalActionException Thrown if parameters cannot be read, actor cannot bescheduled or container cannot be fired at future time.
 */
protected boolean _schedule(Actor actor,Time timestamp) throws IllegalActionException {
  ResourceScheduler scheduler=_getResourceScheduler(actor);
  Time time=null;
  Boolean finished=true;
  if (timestamp == null) {
    timestamp=getModelTime();
  }
  if (scheduler != null) {
    Time environmentTime=((CompositeActor)scheduler.getContainer()).getDirector().getEnvironmentTime();
    time=scheduler.schedule(actor,environmentTime,getDeadline(actor,timestamp));
    if (_nextScheduleTime == null) {
      _nextScheduleTime=new HashMap<ResourceScheduler,Time>();
    }
    _nextScheduleTime.put(scheduler,time);
    finished=_actorFinished(actor);
    if (time != null && time.getDoubleValue() > 0.0) {
      CompositeActor container=(CompositeActor)scheduler.getContainer();
      Time fireAtTime=environmentTime;
      if (!time.equals(Time.POSITIVE_INFINITY)) {
        fireAtTime=fireAtTime.add(time);
        container.getDirector().fireContainerAt(fireAtTime);
      }
    }
  }
 else   if (isEmbedded()) {
    return ((CompositeActor)((CompositeActor)getContainer()).getContainer()).getDirector()._schedule(actor,timestamp);
  }
  return time == null || finished;
}"
72968,"/** 
 * If attribute is <i>messageLength</i> report the new value  to the quantity manager. 
 * @param attribute The changed parameter.
 * @exception IllegalActionException If the parameter set is not valid.Not thrown in this class.
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == messageLength) {
    IOPort port=(IOPort)getContainer();
    Bus bus=(Bus)getDecorator();
    bus.setMessageLength(port,((ScalarToken)((Parameter)attribute).getToken()).doubleValue());
  }
 else {
    super.attributeChanged(attribute);
  }
}","/** 
 * If attribute is <i>messageLength</i> report the new value  to the quantity manager. 
 * @param attribute The changed parameter.
 * @exception IllegalActionException If the parameter set is not valid.Not thrown in this class.
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == messageLength) {
    IOPort port=(IOPort)getContainer();
    Bus bus=(Bus)getDecorator();
    if (bus != null) {
      Token token=messageLength.getToken();
      if (token != null) {
        bus.setMessageLength(port,((ScalarToken)token).doubleValue());
      }
    }
  }
 else {
    super.attributeChanged(attribute);
  }
}"
72969,"/** 
 * Do not set a value before initialization.
 * @param attribute The attribute that changed.
 * @exception IllegalActionException Not thrown here.
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == value && _beforeInitialization) {
    value.setExpression(""String_Node_Str"");
  }
 else {
    super.attributeChanged(attribute);
  }
}","/** 
 * Do not set a value before initialization.
 * @param attribute The attribute that changed.
 * @exception IllegalActionException Not thrown here.
 */
public void attributeChanged(Attribute attribute) throws IllegalActionException {
  if (attribute == value && _beforeInitialization) {
  }
  super.attributeChanged(attribute);
}"
72970,"/** 
 * Initialize the iteration counter.  A derived class must call this method in its initialize() method or the <i>firingCountLimit</i> feature will not work.
 * @exception IllegalActionException If the parent class throws it,which could occur if, for example, the director will not accept sequence actors.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  value.setExpression(""String_Node_Str"");
  _beforeInitialization=false;
}","/** 
 * Initialize the iteration counter.  A derived class must call this method in its initialize() method or the <i>firingCountLimit</i> feature will not work.
 * @exception IllegalActionException If the parent class throws it,which could occur if, for example, the director will not accept sequence actors.
 */
public void initialize() throws IllegalActionException {
  super.initialize();
  _beforeInitialization=false;
}"
72971,"/** 
 * Construct a constant source with the default type set to the RecordToken used in the CompositeQM. 
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the entity cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public CQMInputPort(CompositeEntity container,String name) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  Parameter hide=(Parameter)trigger.getAttribute(""String_Node_Str"");
  if (hide == null) {
    hide=new Parameter(trigger,""String_Node_Str"",new BooleanToken(true));
  }
 else {
    hide.setToken(new BooleanToken(true));
  }
  _beforeInitialization=true;
  value.setExpression(""String_Node_Str"");
  value.setVisibility(Settable.NONE);
  firingCountLimit.setVisibility(Settable.NONE);
  output.setTypeEquals(new RecordType(new String[]{""String_Node_Str"",""String_Node_Str""},new Type[]{BaseType.OBJECT,BaseType.GENERAL}));
}","/** 
 * Construct a constant source with the default type set to the RecordToken used in the CompositeQM. 
 * @param container The container.
 * @param name The name of this actor.
 * @exception IllegalActionException If the entity cannot be containedby the proposed container.
 * @exception NameDuplicationException If the container already has anactor with this name.
 */
public CQMInputPort(CompositeEntity container,String name) throws NameDuplicationException, IllegalActionException {
  super(container,name);
  Parameter hide=(Parameter)trigger.getAttribute(""String_Node_Str"");
  if (hide == null) {
    hide=new Parameter(trigger,""String_Node_Str"",new BooleanToken(true));
  }
 else {
    hide.setToken(new BooleanToken(true));
  }
  _beforeInitialization=true;
  value.setVisibility(Settable.NONE);
  value.setExpression(""String_Node_Str"");
  firingCountLimit.setVisibility(Settable.NONE);
  value.setTypeEquals(new RecordType(new String[]{""String_Node_Str"",""String_Node_Str""},new Type[]{BaseType.OBJECT,BaseType.DOUBLE}));
}"
72972,"/** 
 * Check whether the contained parameter contains a token.
 * @return True if the contained parameter contains a token.
 * @exception IllegalActionException Thrown if token cannotbe accessed. 
 */
public boolean hasToken() throws IllegalActionException {
  return ((Parameter)getAttribute(""String_Node_Str"")).getToken() != null;
}","/** 
 * Check whether the contained parameter contains a token.
 * @return True if the contained parameter contains a token.
 * @exception IllegalActionException Thrown if token cannotbe accessed. 
 */
public boolean hasToken() throws IllegalActionException {
  Token token=((Parameter)getAttribute(""String_Node_Str"")).getToken();
  if (token != null && !(token instanceof BooleanToken)) {
    return true;
  }
  return false;
}"
72973,"/** 
 * Get token from parameter and remove it from the parameter.
 * @return The token.
 * @exception IllegalActionException Thrown if token cannotbe accessed. 
 */
public Token takeToken() throws IllegalActionException {
  Token token=((Parameter)getAttribute(""String_Node_Str"")).getToken();
  ((Parameter)getAttribute(""String_Node_Str"")).reset();
  return token;
}","/** 
 * Get token from parameter and remove it from the parameter.
 * @return The token.
 * @exception IllegalActionException Thrown if token cannotbe accessed. 
 */
public Token takeToken() throws IllegalActionException {
  Token token=((Parameter)getAttribute(""String_Node_Str"")).getToken();
  ((Parameter)getAttribute(""String_Node_Str"")).setToken(new BooleanToken(false));
  return token;
}"
72974,"/** 
 * Override the fire and change the transferring tokens from and to input/output placeholders.
 */
public void fire() throws IllegalActionException {
  if (_debugging) {
    _debug(""String_Node_Str"" + getDirector().getModelTime());
  }
  try {
    _workspace.getReadAccess();
    if (!isOpaque()) {
      throw new IllegalActionException(this,""String_Node_Str"");
    }
    if (_stopRequested) {
      return;
    }
    for (    Const mappedConst : _tokens.keySet()) {
      mappedConst.value.setToken(_tokens.get(mappedConst));
      mappedConst.fire();
      System.out.println(mappedConst);
    }
    _tokens.clear();
    getDirector().fire();
    if (_stopRequested) {
      return;
    }
    for (    Object entity : entityList()) {
      if (entity instanceof CQMOutputPort) {
        CQMOutputPort outputPort=((CQMOutputPort)entity);
        while (outputPort.hasToken()) {
          RecordToken recordToken=(RecordToken)outputPort.takeToken();
          Receiver receiver=(Receiver)((ObjectToken)recordToken.get(""String_Node_Str"")).getValue();
          Token token=recordToken.get(""String_Node_Str"");
          receiver.put(token);
        }
      }
    }
  }
  finally {
    _workspace.doneReading();
  }
}","/** 
 * Override the fire and change the transferring tokens from and to input/output placeholders.
 */
public void fire() throws IllegalActionException {
  if (_debugging) {
    _debug(""String_Node_Str"" + getDirector().getModelTime());
  }
  try {
    _workspace.getReadAccess();
    if (!isOpaque()) {
      throw new IllegalActionException(this,""String_Node_Str"");
    }
    if (_stopRequested) {
      return;
    }
    for (    Const mappedConst : _tokens.keySet()) {
      mappedConst.value.setToken(_tokens.get(mappedConst));
      mappedConst.fire();
    }
    _tokens.clear();
    getDirector().fire();
    if (_stopRequested) {
      return;
    }
    for (    Object entity : entityList()) {
      if (entity instanceof CQMOutputPort) {
        CQMOutputPort outputPort=((CQMOutputPort)entity);
        while (outputPort.hasToken()) {
          RecordToken recordToken=(RecordToken)outputPort.takeToken();
          Receiver receiver=(Receiver)((ObjectToken)recordToken.get(""String_Node_Str"")).getValue();
          Token token=recordToken.get(""String_Node_Str"");
          receiver.put(token);
        }
      }
    }
  }
  finally {
    _workspace.doneReading();
  }
}"
72975,"/** 
 * Schedule a new actor for execution. Find the const actor in the _model that is mapped to this actor and trigger a firing of that one, if the actor is not already in execution. If the actor finished execution, return zero time, otherwise return the next time the model has something to do.
 * @param actor The actor to be scheduled.
 * @param currentPlatformTime The current platform time.
 * @param deadline The deadline of the event.
 * @param executionTime The execution time of the actor.
 * @return Relative time when this Scheduler has to be executedagain.
 * @exception IllegalActionException Thrown if actor paramaters suchas execution time or priority cannot be read.
 */
protected Time _schedule(Actor actor,Time currentPlatformTime,Time deadline,Time executionTime) throws IllegalActionException {
  _lastActorFinished=false;
  getDirector().prefire();
  if (!_currentlyExecuting.contains(actor)) {
    event((NamedObj)actor,getDirector().getModelTime().getDoubleValue(),ExecutionEventType.START);
    ResourceMappingInputPort requestPort=(ResourceMappingInputPort)getEntity(_requestPorts.get(actor));
    if (requestPort != null) {
      RecordToken recordToken=new RecordToken(new String[]{""String_Node_Str"",""String_Node_Str""},new Token[]{new ObjectToken(actor),new DoubleToken(executionTime.getDoubleValue())});
      requestPort.value.setToken(recordToken);
      getDirector().fireAtCurrentTime(requestPort);
      _currentlyExecuting.add(actor);
    }
 else {
      throw new IllegalActionException(this,""String_Node_Str"" + _requestPorts.get(actor));
    }
  }
  return Time.POSITIVE_INFINITY;
}","/** 
 * Schedule a new actor for execution. Find the const actor in the _model that is mapped to this actor and trigger a firing of that one, if the actor is not already in execution. If the actor finished execution, return zero time, otherwise return the next time the model has something to do.
 * @param actor The actor to be scheduled.
 * @param currentPlatformTime The current platform time.
 * @param deadline The deadline of the event.
 * @param executionTime The execution time of the actor.
 * @return Relative time when this Scheduler has to be executedagain.
 * @exception IllegalActionException Thrown if actor paramaters suchas execution time or priority cannot be read.
 */
protected Time _schedule(Actor actor,Time currentPlatformTime,Time deadline,Time executionTime) throws IllegalActionException {
  _lastActorFinished=false;
  getDirector().prefire();
  if (!_currentlyExecuting.contains(actor)) {
    event((NamedObj)actor,getDirector().getModelTime().getDoubleValue(),ExecutionEventType.START);
    ResourceMappingInputPort requestPort=(ResourceMappingInputPort)getEntity(_requestPorts.get(actor));
    if (requestPort != null) {
      RecordToken recordToken=new RecordToken(new String[]{""String_Node_Str"",""String_Node_Str""},new Token[]{new ObjectToken(actor),new DoubleToken(executionTime.getDoubleValue())});
      requestPort.value.setToken(recordToken);
      getDirector().fireAtCurrentTime(requestPort);
      getExecutiveDirector().fireAt(this,getDirector().getModelTime());
      _currentlyExecuting.add(actor);
    }
 else {
      throw new IllegalActionException(this,""String_Node_Str"" + _requestPorts.get(actor));
    }
  }
  return Time.POSITIVE_INFINITY;
}"
72976,"@Override public void initialize() throws IllegalActionException {
  super.initialize();
  Nameable container=getContainer();
  if (container instanceof CompositeActor) {
    Iterator<?> actors=((CompositeActor)container).deepEntityList().iterator();
    _actorDictionary.clear();
    _pendingIteration.clear();
    while (actors.hasNext()) {
      Actor actor=(Actor)actors.next();
      if (actor instanceof MetroIIEventHandler) {
        _actorDictionary.put(actor.getFullName(),new ResumableFire(actor));
      }
 else {
        _actorDictionary.put(actor.getFullName(),new NonBlockingFire(actor));
      }
      _pendingIteration.put(actor.getFullName(),0);
    }
  }
  _events=new ArrayList<Event.Builder>();
  actorList=new ArrayList<Actor>();
}","@Override public void initialize() throws IllegalActionException {
  super.initialize();
  Nameable container=getContainer();
  if (container instanceof CompositeActor) {
    Iterator<?> actors=((CompositeActor)container).deepEntityList().iterator();
    _actorDictionary.clear();
    _pendingIteration.clear();
    while (actors.hasNext()) {
      Actor actor=(Actor)actors.next();
      if (actor instanceof MetroIIEventHandler) {
        _actorDictionary.put(actor.getFullName(),new ResumableFire(actor));
      }
      _pendingIteration.put(actor.getFullName(),0);
    }
  }
  _events=new ArrayList<Event.Builder>();
  actorList=new ArrayList<Actor>();
}"
72977,"public void getfire(ResultHandler<Iterable<Event.Builder>> resultHandler) throws CollectionAbortedException {
  try {
    List<PtidesEvent> list=_inputEventQueue.get(getModelTime());
    if (list != null) {
      for (      PtidesEvent event : list) {
        if (event.ioPort() != null) {
          _currentLogicalTime=event.timeStamp();
          _currentSourceTimestamp=event.sourceTimestamp();
          _currentLogicalIndex=event.microstep();
          event.receiver().put(event.token());
          _currentLogicalTime=null;
        }
      }
      _inputEventQueue.remove(getModelTime());
    }
    super.getfire(resultHandler);
    list=_outputEventQueue.get(getModelTime());
    if (list != null) {
      for (      PtidesEvent event : list) {
        _currentLogicalTime=event.timeStamp();
        _currentSourceTimestamp=event.sourceTimestamp();
        _currentLogicalIndex=event.microstep();
        if (event.ioPort() instanceof MetroIIPtidesPort) {
          double deviceDelay=_getDoubleParameterValue(event.ioPort(),""String_Node_Str"");
          Queue<PtidesEvent> ptidesOutputPortList=_ptidesOutputPortEventQueue.get(event.ioPort());
          if (ptidesOutputPortList == null) {
            ptidesOutputPortList=new LinkedList<PtidesEvent>();
          }
          PtidesEvent newEvent=new PtidesEvent(event.ioPort(),event.channel(),event.timeStamp(),event.microstep(),event.depth(),event.token(),event.receiver(),localClock.getLocalTime().add(deviceDelay),event.sourceTimestamp());
          ptidesOutputPortList.add(newEvent);
          _ptidesOutputPortEventQueue.put((MetroIIPtidesPort)event.ioPort(),ptidesOutputPortList);
        }
        _currentLogicalTime=null;
      }
      _outputEventQueue.remove(getModelTime());
    }
    for (    MetroIIPtidesPort port : _ptidesOutputPortEventQueue.keySet()) {
      Queue<PtidesEvent> ptidesOutputPortList=_ptidesOutputPortEventQueue.get(port);
      if (ptidesOutputPortList != null && ptidesOutputPortList.size() > 0) {
        PtidesEvent event=ptidesOutputPortList.peek();
        if (event.absoluteDeadline().equals(localClock.getLocalTime())) {
          _currentLogicalTime=event.timeStamp();
          _currentSourceTimestamp=event.sourceTimestamp();
          _currentLogicalIndex=event.microstep();
          event.ioPort().send(0,event.token());
          _currentLogicalTime=null;
          ptidesOutputPortList.poll();
        }
      }
    }
  }
 catch (  IllegalActionException e) {
    e.printStackTrace();
  }
}","public void getfire(ResultHandler<Iterable<Event.Builder>> resultHandler) throws CollectionAbortedException {
  try {
    List<PtidesEvent> list=_inputEventQueue.get(getModelTime());
    if (list != null) {
      for (      PtidesEvent event : list) {
        if (event.ioPort() != null) {
          _currentLogicalTime=event.timeStamp();
          _currentSourceTimestamp=event.sourceTimestamp();
          _currentLogicalIndex=event.microstep();
          event.receiver().put(event.token());
          _currentLogicalTime=null;
          if (_debugging) {
            _debug(""String_Node_Str"" + event.ioPort());
          }
        }
      }
      _inputEventQueue.remove(getModelTime());
    }
    super.getfire(resultHandler);
    list=_outputEventQueue.get(getModelTime());
    if (list != null) {
      for (      PtidesEvent event : list) {
        _currentLogicalTime=event.timeStamp();
        _currentSourceTimestamp=event.sourceTimestamp();
        _currentLogicalIndex=event.microstep();
        if (event.ioPort() instanceof MetroIIPtidesPort) {
          double deviceDelay=_getDoubleParameterValue(event.ioPort(),""String_Node_Str"");
          Queue<PtidesEvent> ptidesOutputPortList=_ptidesOutputPortEventQueue.get(event.ioPort());
          if (ptidesOutputPortList == null) {
            ptidesOutputPortList=new LinkedList<PtidesEvent>();
          }
          PtidesEvent newEvent=new PtidesEvent(event.ioPort(),event.channel(),event.timeStamp(),event.microstep(),event.depth(),event.token(),event.receiver(),localClock.getLocalTime().add(deviceDelay),event.sourceTimestamp());
          ptidesOutputPortList.add(newEvent);
          _ptidesOutputPortEventQueue.put((MetroIIPtidesPort)event.ioPort(),ptidesOutputPortList);
        }
        _currentLogicalTime=null;
      }
      _outputEventQueue.remove(getModelTime());
    }
    for (    MetroIIPtidesPort port : _ptidesOutputPortEventQueue.keySet()) {
      Queue<PtidesEvent> ptidesOutputPortList=_ptidesOutputPortEventQueue.get(port);
      if (ptidesOutputPortList != null && ptidesOutputPortList.size() > 0) {
        PtidesEvent event=ptidesOutputPortList.peek();
        if (event.absoluteDeadline().equals(localClock.getLocalTime())) {
          _currentLogicalTime=event.timeStamp();
          _currentSourceTimestamp=event.sourceTimestamp();
          _currentLogicalIndex=event.microstep();
          event.ioPort().send(0,event.token());
          _currentLogicalTime=null;
          ptidesOutputPortList.poll();
        }
      }
    }
  }
 catch (  IllegalActionException e) {
    e.printStackTrace();
  }
}"
72978,"/** 
 * Before super.fire() is called, transfer all input events that are ready are transferred. After super.fire() is called, transfer all output events that are ready are transferred.
 */
public void fire() throws IllegalActionException {
  List<PtidesEvent> list=_inputEventQueue.get(getModelTime());
  if (list != null) {
    for (    PtidesEvent event : list) {
      if (event.ioPort() != null) {
        _currentLogicalTime=event.timeStamp();
        _currentSourceTimestamp=event.sourceTimestamp();
        _currentLogicalIndex=event.microstep();
        event.receiver().put(event.token());
        _currentLogicalTime=null;
      }
    }
    _inputEventQueue.remove(getModelTime());
  }
  super.fire();
  list=_outputEventQueue.get(getModelTime());
  if (list != null) {
    for (    PtidesEvent event : list) {
      _currentLogicalTime=event.timeStamp();
      _currentSourceTimestamp=event.sourceTimestamp();
      _currentLogicalIndex=event.microstep();
      if (event.ioPort() instanceof MetroIIPtidesPort) {
        double deviceDelay=_getDoubleParameterValue(event.ioPort(),""String_Node_Str"");
        Queue<PtidesEvent> ptidesOutputPortList=_ptidesOutputPortEventQueue.get(event.ioPort());
        if (ptidesOutputPortList == null) {
          ptidesOutputPortList=new LinkedList<PtidesEvent>();
        }
        PtidesEvent newEvent=new PtidesEvent(event.ioPort(),event.channel(),event.timeStamp(),event.microstep(),event.depth(),event.token(),event.receiver(),localClock.getLocalTime().add(deviceDelay),event.sourceTimestamp());
        ptidesOutputPortList.add(newEvent);
        _ptidesOutputPortEventQueue.put((MetroIIPtidesPort)event.ioPort(),ptidesOutputPortList);
      }
      _currentLogicalTime=null;
    }
    _outputEventQueue.remove(getModelTime());
  }
  for (  MetroIIPtidesPort port : _ptidesOutputPortEventQueue.keySet()) {
    Queue<PtidesEvent> ptidesOutputPortList=_ptidesOutputPortEventQueue.get(port);
    if (ptidesOutputPortList != null && ptidesOutputPortList.size() > 0) {
      PtidesEvent event=ptidesOutputPortList.peek();
      if (event.absoluteDeadline().equals(localClock.getLocalTime())) {
        _currentLogicalTime=event.timeStamp();
        _currentSourceTimestamp=event.sourceTimestamp();
        _currentLogicalIndex=event.microstep();
        event.ioPort().send(0,event.token());
        _currentLogicalTime=null;
        ptidesOutputPortList.poll();
      }
    }
  }
}","/** 
 * Before super.fire() is called, transfer all input events that are ready are transferred. After super.fire() is called, transfer all output events that are ready are transferred.
 */
public void fire() throws IllegalActionException {
  List<PtidesEvent> list=_inputEventQueue.get(getModelTime());
  if (list != null) {
    for (    PtidesEvent event : list) {
      if (event.ioPort() != null) {
        _currentLogicalTime=event.timeStamp();
        _currentSourceTimestamp=event.sourceTimestamp();
        _currentLogicalIndex=event.microstep();
        event.receiver().put(event.token());
        _currentLogicalTime=null;
        if (_debugging) {
          _debug(""String_Node_Str"" + event.ioPort());
        }
      }
    }
    _inputEventQueue.remove(getModelTime());
  }
  super.fire();
  list=_outputEventQueue.get(getModelTime());
  if (list != null) {
    for (    PtidesEvent event : list) {
      _currentLogicalTime=event.timeStamp();
      _currentSourceTimestamp=event.sourceTimestamp();
      _currentLogicalIndex=event.microstep();
      if (event.ioPort() instanceof MetroIIPtidesPort) {
        double deviceDelay=_getDoubleParameterValue(event.ioPort(),""String_Node_Str"");
        Queue<PtidesEvent> ptidesOutputPortList=_ptidesOutputPortEventQueue.get(event.ioPort());
        if (ptidesOutputPortList == null) {
          ptidesOutputPortList=new LinkedList<PtidesEvent>();
        }
        PtidesEvent newEvent=new PtidesEvent(event.ioPort(),event.channel(),event.timeStamp(),event.microstep(),event.depth(),event.token(),event.receiver(),localClock.getLocalTime().add(deviceDelay),event.sourceTimestamp());
        ptidesOutputPortList.add(newEvent);
        _ptidesOutputPortEventQueue.put((MetroIIPtidesPort)event.ioPort(),ptidesOutputPortList);
      }
      _currentLogicalTime=null;
    }
    _outputEventQueue.remove(getModelTime());
  }
  for (  MetroIIPtidesPort port : _ptidesOutputPortEventQueue.keySet()) {
    Queue<PtidesEvent> ptidesOutputPortList=_ptidesOutputPortEventQueue.get(port);
    if (ptidesOutputPortList != null && ptidesOutputPortList.size() > 0) {
      PtidesEvent event=ptidesOutputPortList.peek();
      if (event.absoluteDeadline().equals(localClock.getLocalTime())) {
        _currentLogicalTime=event.timeStamp();
        _currentSourceTimestamp=event.sourceTimestamp();
        _currentLogicalIndex=event.microstep();
        event.ioPort().send(0,event.token());
        _currentLogicalTime=null;
        ptidesOutputPortList.poll();
      }
    }
  }
}"
72979,"/** 
 * Initiate a send of the specified token to the specified receiver. This method will schedule a refiring of this actor if there is not one already scheduled.
 * @param source Sender of the token.
 * @param receiver The receiver to send to.
 * @param token The token to send.
 * @exception IllegalActionException If the refiring request fails.
 */
public void sendToken(Receiver source,Receiver receiver,Token token) throws IllegalActionException {
  if (getDirector() instanceof DEDirector && token == null) {
    return;
  }
  Time currentTime=getDirector().getModelTime();
  if (_nextTimeFree == null || _tokens.size() == 0 || currentTime.compareTo(_nextTimeFree) != 0 || receiver != _nextReceiver) {
    if (getDirector() instanceof FixedPointDirector) {
      receiver.put(null);
    }
  }
  Token tokenToSend=_receiversAndTokensToSendTo.get(receiver);
  if (tokenToSend != null) {
    if (!tokenToSend.equals(token)) {
      throw new IllegalActionException(this,receiver.getContainer(),""String_Node_Str"" + tokenToSend + ""String_Node_Str""+ token+ ""String_Node_Str"");
    }
  }
 else {
    if (token != null) {
      _receiversAndTokensToSendTo.put(receiver,token);
      _tempReceiverQueue.put(receiver);
      if (!(getDirector() instanceof FixedPointDirector)) {
        _tokens.put(new Object[]{receiver,token});
        _tokenCount++;
        sendQMTokenEvent((Actor)source.getContainer().getContainer(),0,_tokenCount,EventType.RECEIVED);
        if (_tokens.size() == 1) {
          _scheduleRefire();
        }
      }
    }
  }
  if (_debugging) {
    _debug(""String_Node_Str"" + getDirector().getModelTime() + ""String_Node_Str""+ receiver.getContainer().getFullName()+ ""String_Node_Str""+ token);
  }
}","/** 
 * Initiate a send of the specified token to the specified receiver. This method will schedule a refiring of this actor if there is not one already scheduled.
 * @param source Sender of the token.
 * @param receiver The receiver to send to.
 * @param token The token to send.
 * @exception IllegalActionException If the refiring request fails.
 */
public void sendToken(Receiver source,Receiver receiver,Token token) throws IllegalActionException {
  if (getDirector() instanceof DEDirector && token == null) {
    return;
  }
  Time currentTime=getDirector().getModelTime();
  if (_nextTimeFree == null || _tokens.size() == 0 || currentTime.compareTo(_nextTimeFree) != 0 || receiver != _nextReceiver) {
    if (getDirector() instanceof FixedPointDirector) {
      receiver.put(null);
    }
  }
  Token tokenToSend=_receiversAndTokensToSendTo.get(receiver);
  if (tokenToSend != null) {
    if (!tokenToSend.equals(token)) {
      throw new IllegalActionException(this,receiver.getContainer(),""String_Node_Str"" + tokenToSend + ""String_Node_Str""+ token+ ""String_Node_Str"");
    }
  }
 else {
    if (token != null) {
      _receiversAndTokensToSendTo.put(receiver,token);
      _tempReceiverQueue.put(receiver);
      if (!(getDirector() instanceof FixedPointDirector)) {
        _tokens.put(new Object[]{receiver,token});
        _tokenCount++;
        sendQMTokenEvent((Actor)source.getContainer().getContainer(),0,_tokenCount,EventType.RECEIVED);
        if (_tokens.size() == 1) {
          _scheduleRefire();
        }
        _receiversAndTokensToSendTo.clear();
      }
    }
  }
  if (_debugging) {
    _debug(""String_Node_Str"" + getDirector().getModelTime() + ""String_Node_Str""+ receiver.getContainer().getFullName()+ ""String_Node_Str""+ token);
  }
}"
72980,"/** 
 * Advance the current model tag to that of the earliest event in the event queue, and fire all actors that have requested or are triggered to be fired at the current tag. If <i>synchronizeToRealTime</i> is true, then before firing, wait until real time matches or exceeds the timestamp of the event. Note that the default unit for time is seconds. <p> Each actor is fired repeatedly (prefire(), fire()), until either it has no more input tokens, or its prefire() method returns false. Note that if the actor fails to consume its inputs, then this can result in an infinite loop. Each actor that is fired is then postfired once at the conclusion of the iteration. </p><p> If there are no events in the event queue, then the behavior depends on the <i>stopWhenQueueIsEmpty</i> parameter. If it is false, then this thread will stall until events become available in the event queue. Otherwise, time will advance to the stop time and the execution will halt.</p>
 * @return 0 if firing was successful, and the next event in eventqueue should be checked for processing; -1 if there's no actor to fire, and we should not keep firing; 1 if there's no actor to fire, but the next event should be checked for processing.
 * @exception IllegalActionException If the firing actor throws it, orevent queue is not ready, or an event is missed, or time is set backwards.
 */
protected int _fire() throws IllegalActionException {
  Actor actorToFire=_getNextActorToFire();
  if (actorToFire == null) {
    if (_isTopLevel()) {
      if (_debugging) {
        _debug(""String_Node_Str"");
      }
      if (!_stopFireRequested) {
        _noMoreActorsToFire=true;
      }
    }
 else {
      if (_debugging) {
        _debug(""String_Node_Str"" + ""String_Node_Str"");
      }
    }
    _stopFireRequested=false;
    return -1;
  }
  if (actorToFire == getContainer()) {
    return 1;
  }
  if (_debugging) {
    _debug(""String_Node_Str"" + actorToFire.getFullName());
  }
  boolean refire;
  do {
    refire=false;
    if (_debugging) {
      if (!((CompositeEntity)getContainer()).deepContains((NamedObj)actorToFire)) {
        _debug(""String_Node_Str"");
        _disableActor(actorToFire);
        break;
      }
      _debug(new FiringEvent(this,actorToFire,FiringEvent.BEFORE_PREFIRE));
      if (!actorToFire.prefire()) {
        _debug(""String_Node_Str"");
        break;
      }
      _debug(new FiringEvent(this,actorToFire,FiringEvent.AFTER_PREFIRE));
      _debug(new FiringEvent(this,actorToFire,FiringEvent.BEFORE_FIRE));
      actorToFire.fire();
      _debug(new FiringEvent(this,actorToFire,FiringEvent.AFTER_FIRE));
      _debug(new FiringEvent(this,actorToFire,FiringEvent.BEFORE_POSTFIRE));
      if (!actorToFire.postfire()) {
        _debug(""String_Node_Str"",((Nameable)actorToFire).getName());
        _disableActor(actorToFire);
        break;
      }
      _debug(new FiringEvent(this,actorToFire,FiringEvent.AFTER_POSTFIRE));
    }
 else {
      if (!((CompositeEntity)getContainer()).deepContains((NamedObj)actorToFire)) {
        _disableActor(actorToFire);
        break;
      }
      if (!actorToFire.prefire()) {
        break;
      }
      actorToFire.fire();
      if (!actorToFire.postfire()) {
        _disableActor(actorToFire);
        break;
      }
    }
    Iterator<?> inputPorts=actorToFire.inputPortList().iterator();
    while (inputPorts.hasNext() && !refire) {
      IOPort port=(IOPort)inputPorts.next();
      for (int i=0; i < port.getWidth(); i++) {
        if (port.hasToken(i)) {
          if (_debugging) {
            _debug(""String_Node_Str"" + port.getName() + ""String_Node_Str""+ i+ ""String_Node_Str"");
          }
          if (_resourceScheduling && _schedule(actorToFire,getModelTime())) {
            refire=true;
            break;
          }
        }
      }
    }
  }
 while (refire);
  return 0;
}","/** 
 * Advance the current model tag to that of the earliest event in the event queue, and fire all actors that have requested or are triggered to be fired at the current tag. If <i>synchronizeToRealTime</i> is true, then before firing, wait until real time matches or exceeds the timestamp of the event. Note that the default unit for time is seconds. <p> Each actor is fired repeatedly (prefire(), fire()), until either it has no more input tokens, or its prefire() method returns false. Note that if the actor fails to consume its inputs, then this can result in an infinite loop. Each actor that is fired is then postfired once at the conclusion of the iteration. </p><p> If there are no events in the event queue, then the behavior depends on the <i>stopWhenQueueIsEmpty</i> parameter. If it is false, then this thread will stall until events become available in the event queue. Otherwise, time will advance to the stop time and the execution will halt.</p>
 * @return 0 if firing was successful, and the next event in eventqueue should be checked for processing; -1 if there's no actor to fire, and we should not keep firing; 1 if there's no actor to fire, but the next event should be checked for processing.
 * @exception IllegalActionException If the firing actor throws it, orevent queue is not ready, or an event is missed, or time is set backwards.
 */
protected int _fire() throws IllegalActionException {
  Actor actorToFire=_getNextActorToFire();
  if (actorToFire == null) {
    if (_isTopLevel()) {
      if (_debugging) {
        _debug(""String_Node_Str"");
      }
      if (!_stopFireRequested) {
        _noMoreActorsToFire=true;
      }
    }
 else {
      if (_debugging) {
        _debug(""String_Node_Str"" + ""String_Node_Str"");
      }
    }
    _stopFireRequested=false;
    return -1;
  }
  if (actorToFire == getContainer()) {
    return 1;
  }
  if (_debugging) {
    _debug(""String_Node_Str"" + actorToFire.getFullName());
  }
  boolean refire;
  do {
    refire=false;
    if (_debugging) {
      if (!((CompositeEntity)getContainer()).deepContains((NamedObj)actorToFire)) {
        _debug(""String_Node_Str"");
        _disableActor(actorToFire);
        break;
      }
      _debug(new FiringEvent(this,actorToFire,FiringEvent.BEFORE_PREFIRE));
      if (!actorToFire.prefire()) {
        _debug(""String_Node_Str"");
        break;
      }
      _debug(new FiringEvent(this,actorToFire,FiringEvent.AFTER_PREFIRE));
      _debug(new FiringEvent(this,actorToFire,FiringEvent.BEFORE_FIRE));
      actorToFire.fire();
      _debug(new FiringEvent(this,actorToFire,FiringEvent.AFTER_FIRE));
      _debug(new FiringEvent(this,actorToFire,FiringEvent.BEFORE_POSTFIRE));
      if (!actorToFire.postfire()) {
        _debug(""String_Node_Str"",((Nameable)actorToFire).getName());
        _disableActor(actorToFire);
        break;
      }
      _debug(new FiringEvent(this,actorToFire,FiringEvent.AFTER_POSTFIRE));
    }
 else {
      if (!((CompositeEntity)getContainer()).deepContains((NamedObj)actorToFire)) {
        _disableActor(actorToFire);
        break;
      }
      if (!actorToFire.prefire()) {
        break;
      }
      actorToFire.fire();
      if (!actorToFire.postfire()) {
        _disableActor(actorToFire);
        break;
      }
    }
    Iterator<?> inputPorts=actorToFire.inputPortList().iterator();
    while (inputPorts.hasNext() && !refire) {
      IOPort port=(IOPort)inputPorts.next();
      for (int i=0; i < port.getWidth(); i++) {
        if (port.hasToken(i)) {
          if (_debugging) {
            _debug(""String_Node_Str"" + port.getName() + ""String_Node_Str""+ i+ ""String_Node_Str"");
          }
          if (!_resourceScheduling || _schedule(actorToFire,getModelTime())) {
            refire=true;
            break;
          }
        }
      }
    }
  }
 while (refire);
  return 0;
}"
72981,"/** 
 * Generate a new random number.
 * @exception IllegalActionException If parameter values are incorrect.
 */
protected void _generateRandomNumber() throws IllegalActionException {
  double meanTimeValue=((DoubleToken)meanTime.getToken()).doubleValue();
  _current=-Math.log(1 - _random.nextDouble()) * meanTimeValue;
}","/** 
 * Generate a new random number.
 * @exception IllegalActionException If parameter values are incorrect.
 */
protected void _generateRandomNumber() throws IllegalActionException {
  double meanTimeValue=((DoubleToken)meanTime.getToken()).doubleValue();
  double test=_random.nextDouble();
  _current=-Math.log(1 - test) * meanTimeValue;
}"
72982,"/** 
 * Clone the actor into the specified workspace.
 * @param workspace The workspace for the new object.
 * @return A new actor.
 * @exception CloneNotSupportedException If a derived class containsan attribute that cannot be cloned.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  HlaManager newObject=(HlaManager)super.clone(workspace);
  newObject._hlaAttributesToPublish=new HashMap<String,Object[]>();
  newObject._hlaAttributesSubscribedTo=new HashMap<String,Object[]>();
  newObject._fromFederationEvents=new HashMap<String,LinkedList<TimedEvent>>();
  newObject._attributes=null;
  newObject._rtia=null;
  newObject._fedAmb=null;
  newObject._federateName=_federateName;
  newObject._federationName=_federationName;
  newObject._isTimeConstrained=_isTimeConstrained;
  newObject._isTimeRegulator=_isTimeRegulator;
  newObject._hlaStartTime=_hlaStartTime;
  newObject._hlaTimeStep=_hlaTimeStep;
  newObject._hlaLookAHead=_hlaLookAHead;
  newObject._requireSynchronization=_requireSynchronization;
  newObject._synchronizationPointName=_synchronizationPointName;
  newObject._isCreatorSyncPt=_isCreatorSyncPt;
  newObject._useNextEventRequest=_useNextEventRequest;
  newObject._useTimeAdvancedRequest=_useTimeAdvancedRequest;
  return newObject;
}","/** 
 * Clone the actor into the specified workspace.
 * @param workspace The workspace for the new object.
 * @return A new actor.
 * @exception CloneNotSupportedException If a derived class containsan attribute that cannot be cloned.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  HlaManager newObject=(HlaManager)super.clone(workspace);
  newObject._hlaAttributesToPublish=new HashMap<String,Object[]>();
  newObject._hlaAttributesSubscribedTo=new HashMap<String,Object[]>();
  newObject._fromFederationEvents=new HashMap<String,LinkedList<TimedEvent>>();
  newObject._attributes=null;
  newObject._rtia=null;
  newObject._fedAmb=null;
  newObject._federateName=_federateName;
  newObject._federationName=_federationName;
  newObject._isTimeConstrained=_isTimeConstrained;
  newObject._isTimeRegulator=_isTimeRegulator;
  try {
    newObject._hlaStartTime=((DoubleToken)hlaStartTime.getToken()).doubleValue();
    newObject._hlaTimeStep=((DoubleToken)hlaTimeStep.getToken()).doubleValue();
    newObject._hlaLookAHead=((DoubleToken)hlaLookAHead.getToken()).doubleValue();
  }
 catch (  IllegalActionException ex) {
    CloneNotSupportedException ex2=new CloneNotSupportedException(""String_Node_Str"");
    ex2.initCause(ex);
    throw ex2;
  }
  newObject._requireSynchronization=_requireSynchronization;
  newObject._synchronizationPointName=_synchronizationPointName;
  newObject._isCreatorSyncPt=_isCreatorSyncPt;
  newObject._useNextEventRequest=_useNextEventRequest;
  newObject._useTimeAdvancedRequest=_useTimeAdvancedRequest;
  return newObject;
}"
72983,"/** 
 * Return a new default widget for configuring the specified object. This is used by the Configurer for objects that do not contain an instance of EditorPaneFactory as an attribute.  The resulting component is an instance of the PtolemyQuery class that
 * @param object The object to be configured.
 * @param query The query to which new entries for the object are to beadded.
 * @return An instance of the PtolemyQuery class that is createdwith styles according to the type given in each visible attribute.
 */
public static Component createEditorPane(NamedObj object,PtolemyQuery query){
  JTabbedPane tabs=new JTabbedPane();
  boolean foundOne=false;
  List<Settable> parameters=new LinkedList<Settable>(object.attributeList(Settable.class));
  int numberOfTabs=1;
  PtolemyQuery mainTab=new PtolemyQuery(object);
  mainTab.setTextWidth(40);
  tabs.addTab(object.getDisplayName(),mainTab);
  try {
    Set<Decorator> decorators=object.decorators();
    for (    Decorator decorator : decorators) {
      DecoratorAttributes decoratorAttributes=object.getDecoratorAttributes(decorator);
      if (decoratorAttributes != null) {
        PtolemyQuery decoratorQuery=new PtolemyQuery(object);
        decoratorQuery.setAlignmentY(Component.TOP_ALIGNMENT);
        decoratorQuery.setTextWidth(40);
        decoratorQuery.addText(""String_Node_Str"" + decorator.getFullName(),Color.BLACK,0);
        boolean foundDecoratorAttribute=false;
        for (        Object attribute : decoratorAttributes.attributeList()) {
          if (attribute instanceof Settable) {
            Settable settable=(Settable)attribute;
            if (Configurer.isVisible(object,settable)) {
              foundDecoratorAttribute=true;
              decoratorQuery.addStyledEntry(settable);
            }
          }
        }
        foundOne=foundOne || foundDecoratorAttribute;
        if (foundDecoratorAttribute) {
          tabs.addTab(decorator.getName(),decoratorQuery);
          numberOfTabs+=1;
        }
      }
    }
  }
 catch (  IllegalActionException e) {
    MessageHandler.error(""String_Node_Str"",e);
  }
  if (numberOfTabs > 1) {
    query.add(tabs);
  }
  PtolemyQuery queryForMainAttributes=numberOfTabs > 1 ? mainTab : query;
  for (  Settable parameter : parameters) {
    if (Configurer.isVisible(object,parameter)) {
      foundOne=true;
      queryForMainAttributes.addStyledEntry(parameter);
    }
  }
  if (!foundOne) {
    return new JLabel(object.getName() + ""String_Node_Str"");
  }
  return query;
}","/** 
 * Return a new default widget for configuring the specified object. This is used by the Configurer for objects that do not contain an instance of EditorPaneFactory as an attribute.  The resulting component is an instance of the PtolemyQuery class that
 * @param object The object to be configured.
 * @param query The query to which new entries for the object are to beadded.
 * @return An instance of the PtolemyQuery class that is createdwith styles according to the type given in each visible attribute.
 */
public static Component createEditorPane(NamedObj object,PtolemyQuery query){
  query.setTextWidth(DEFAULT_QUERY_WIDTH);
  boolean foundOne=false;
  List<Settable> parameters=new LinkedList<Settable>(object.attributeList(Settable.class));
  for (  Settable parameter : parameters) {
    if (Configurer.isVisible(object,parameter)) {
      foundOne=true;
      query.addStyledEntry(parameter);
    }
  }
  if (!foundOne) {
    return new JLabel(object.getName() + ""String_Node_Str"");
  }
  return query;
}"
72984,"/** 
 * Generate code and append it to the given string buffer. Write the code to the directory specified by the codeDirectory parameter.  The file name is a sanitized version of the model name with a suffix that is based on last package name of the <i>generatorPackage</i> parameter.  Thus if the <i>codeDirectory</i> is <code>$HOME</code>, the name of the model is <code>Foo</code> and the <i>generatorPackage</i> is <code>ptolemy.codegen.c</code>, then the file that is written will be <code>$HOME/Foo.c</code> This method is the main entry point. We do not call the super method because it is too different from it. For instance, there is not only one file generated, but a few.
 * @param code The given string buffer.
 * @return The return value of the last subprocess that was executed.or -1 if no commands were executed.
 * @exception KernelException If the target file cannot be overwrittenor write-to-file throw any exception.
 */
protected int _generateCode(StringBuffer code) throws KernelException {
  long startTime=new Date().getTime();
  long overallStartTime=startTime;
  _reset();
  _sanitizedModelName=CodeGeneratorAdapter.generateName(_model);
  NamedObj container=getContainer();
  Director director=null;
  if (container instanceof CompositeActor)   director=((CompositeActor)container).getDirector();
  if (container instanceof ptolemy.cg.lib.CompiledCompositeActor) {
    _sanitizedModelName=((ptolemy.cg.lib.CompiledCompositeActor)container).getSanitizedName();
  }
  Attribute generateEmbeddedCode=getAttribute(""String_Node_Str"");
  if (generateEmbeddedCode instanceof Parameter) {
    ((Parameter)generateEmbeddedCode).setExpression(""String_Node_Str"");
  }
  boolean inlineValue=((BooleanToken)inline.getToken()).booleanValue();
  if (inlineValue && director != null && director instanceof DEDirector) {
    throw new IllegalActionException(""String_Node_Str"");
  }
  _analyzeTypeConversions();
  startTime=_printTimeAndMemory(startTime,""String_Node_Str"");
  _addActorIncludeDirectories();
  _addActorLibraries();
  _setupAdapter();
  String preinitializeCode=_generatePreinitializeCode();
  String preinitializeMethodEntryCode=_generatePreinitializeMethodEntryCode();
  String preinitializeMethodBodyCode=_generatePreinitializeMethodBodyCode();
  String preinitializeMethodExitCode=_generatePreinitializeMethodExitCode();
  String preinitializeProcedureName=_generatePreinitializeMethodProcedureName();
  String initializeCode=generateInitializeCode();
  String bodyCode=_generateBodyCode();
  String mainEntryCode=generateMainEntryCode();
  String mainExitCode=generateMainExitCode();
  String initializeEntryCode=generateInitializeEntryCode();
  String initializeExitCode=generateInitializeExitCode();
  String initializeProcedureName=generateInitializeProcedureName();
  String wrapupEntryCode=generateWrapupEntryCode();
  String wrapupExitCode=generateWrapupExitCode();
  String wrapupProcedureName=generateWrapupProcedureName();
  String fireFunctionCode=null;
  String[] actorsCode=new String[0];
  if (!inlineValue) {
    if (director != null && director instanceof DEDirector) {
      ptolemy.cg.adapter.generic.program.procedural.c.adapters.ptolemy.domains.de.kernel.DEDirector directorAdapter=(ptolemy.cg.adapter.generic.program.procedural.c.adapters.ptolemy.domains.de.kernel.DEDirector)getAdapter(((DEDirector)director));
      actorsCode=directorAdapter.generateActorCode();
    }
 else {
      actorsCode=new String[0];
      fireFunctionCode=generateFireFunctionCode();
    }
  }
  String wrapupCode=generateWrapupCode();
  String closingEntryCode=generateClosingEntryCode();
  String closingExitCode=generateClosingExitCode();
  String variableInitCode=generateVariableInitialization();
  String sharedCode=_generateSharedCode();
  String declareSharedCode=_generateDeclareSharedCode();
  String[] typeResolutionCode=generateTypeConvertCodeCandH();
  List<String> variableDeclareCode=_splitVariableDeclaration(""String_Node_Str"",generateVariableDeclaration());
  String includeFiles=_generateIncludeFiles();
  startTime=_printTimeAndMemory(startTime,""String_Node_Str"");
  StringBuffer codeMainH=new StringBuffer();
  StringBuffer codeTypesH=new StringBuffer();
  StringBuffer codeTypesC=new StringBuffer();
  codeTypesH.append(""String_Node_Str"" + _eol + ""String_Node_Str""+ _eol);
  code.append(generateCopyright());
  code.append(generatePackageStatement());
  code.append(variableDeclareCode.get(0));
  codeMainH.append(""String_Node_Str"" + _sanitizedModelName.toUpperCase() + ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _sanitizedModelName.toUpperCase()+ ""String_Node_Str""+ _eol);
  if (director != null && director instanceof DEDirector) {
    codeMainH.append(""String_Node_Str"" + _eol);
    codeMainH.append(""String_Node_Str"" + _eol);
    codeMainH.append(""String_Node_Str"" + _eol);
    codeMainH.append(""String_Node_Str"" + _eol);
    codeMainH.append(""String_Node_Str"" + _eol);
    codeMainH.append(""String_Node_Str"" + _eol);
    codeTypesH.append(_eol + ""String_Node_Str"");
    codeTypesH.append(_eol + ""String_Node_Str"");
    codeTypesH.append(_eol + ""String_Node_Str"");
    codeTypesH.append(_eol + ""String_Node_Str"" + _eol);
  }
  codeMainH.append(""String_Node_Str"" + _eol);
  codeMainH.append(includeFiles);
  code.append(""String_Node_Str"" + _sanitizedModelName + ""String_Node_Str""+ _eol);
  includeFiles=null;
  code.append(comment(""String_Node_Str""));
  codeTypesH.append(typeResolutionCode[0]);
  typeResolutionCode[0]=null;
  codeTypesH.append(comment(""String_Node_Str""));
  codeTypesC.append(typeResolutionCode[1]);
  typeResolutionCode[1]=null;
  codeTypesC.append(comment(""String_Node_Str""));
  codeTypesC.append(sharedCode);
  sharedCode=null;
  codeTypesH.append(declareSharedCode);
  declareSharedCode=null;
  codeTypesH.append(comment(""String_Node_Str""));
  codeMainH.append(_writeVariableDeclarations(variableDeclareCode));
  codeMainH.append(comment(""String_Node_Str""));
  codeMainH.append(preinitializeCode);
  preinitializeCode=null;
  codeMainH.append(comment(""String_Node_Str""));
  codeMainH.append(comment(""String_Node_Str""));
  String[] splitPreinitializeMethodBodyCode=_splitBody(""String_Node_Str"",preinitializeMethodBodyCode);
  codeMainH.append(comment(""String_Node_Str""));
  codeMainH.append(splitPreinitializeMethodBodyCode[0]);
  splitPreinitializeMethodBodyCode[0]=null;
  codeMainH.append(comment(""String_Node_Str""));
  codeMainH.append(preinitializeMethodEntryCode);
  codeMainH.append(splitPreinitializeMethodBodyCode[1]);
  splitPreinitializeMethodBodyCode[1]=null;
  codeMainH.append(preinitializeMethodExitCode);
  codeMainH.append(_eol + ""String_Node_Str"");
  if (!inlineValue && fireFunctionCode != null) {
    code.append(comment(""String_Node_Str""));
    code.append(fireFunctionCode);
    fireFunctionCode=null;
    code.append(comment(""String_Node_Str""));
  }
  String[] splitVariableInitCode=_splitBody(""String_Node_Str"",variableInitCode);
  code.append(comment(""String_Node_Str""));
  code.append(splitVariableInitCode[0] + ""String_Node_Str"");
  splitVariableInitCode[0]=null;
  code.append(comment(""String_Node_Str""));
  String[] splitInitializeCode=_splitBody(""String_Node_Str"",initializeCode);
  code.append(comment(""String_Node_Str""));
  code.append(splitInitializeCode[0]);
  splitInitializeCode[0]=null;
  code.append(comment(""String_Node_Str""));
  code.append(comment(""String_Node_Str""));
  code.append(initializeEntryCode);
  code.append(comment(""String_Node_Str""));
  code.append(comment(""String_Node_Str""));
  code.append(splitVariableInitCode[1]);
  splitVariableInitCode[1]=null;
  code.append(comment(""String_Node_Str""));
  code.append(comment(""String_Node_Str""));
  code.append(splitInitializeCode[1]);
  splitInitializeCode[1]=null;
  code.append(comment(""String_Node_Str""));
  code.append(comment(""String_Node_Str""));
  code.append(initializeExitCode);
  String[] splitWrapupCode=_splitBody(""String_Node_Str"",wrapupCode);
  code.append(splitWrapupCode[0]);
  splitWrapupCode[0]=null;
  code.append(wrapupEntryCode);
  code.append(splitWrapupCode[1]);
  splitWrapupCode[1]=null;
  code.append(wrapupExitCode);
  code.append(mainEntryCode);
  if (_isTopLevel()) {
    if (containsCode(preinitializeMethodBodyCode)) {
      code.append(preinitializeProcedureName);
    }
    if (containsCode(variableInitCode) || containsCode(initializeCode)) {
      code.append(initializeProcedureName);
    }
  }
  code.append(bodyCode);
  String directorySrc=codeDirectory.stringValue();
  String directoryIncludes=codeDirectory.stringValue();
  String directoryBuild=codeDirectory.stringValue();
  if (!directorySrc.endsWith(""String_Node_Str""))   directorySrc+=""String_Node_Str"";
  if (!directoryIncludes.endsWith(""String_Node_Str""))   directoryIncludes+=""String_Node_Str"";
  if (!directoryBuild.endsWith(""String_Node_Str""))   directoryBuild+=""String_Node_Str"";
  new File(directorySrc).mkdirs();
  directorySrc+=""String_Node_Str"";
  directoryIncludes+=""String_Node_Str"";
  directoryBuild+=""String_Node_Str"";
  new File(directorySrc).mkdirs();
  new File(directoryIncludes).mkdirs();
  new File(directoryBuild).mkdirs();
  _actorsToInclude=new LinkedList<String>();
  for (int i=0; i < actorsCode.length; i+=3) {
    _actorsToInclude.add(actorsCode[i]);
    StringBuffer actorCode=new StringBuffer();
    actorCode.append(actorsCode[i + 1]);
    super._writeCodeFileName(actorCode,""String_Node_Str"" + actorsCode[i] + ""String_Node_Str"",true,false);
    StringBuffer actorCodeH=new StringBuffer();
    actorCodeH.append(actorsCode[i + 2]);
    super._writeCodeFileName(actorCodeH,""String_Node_Str"" + actorsCode[i] + ""String_Node_Str"",true,false);
  }
  bodyCode=null;
  if (_isTopLevel()) {
    if (containsCode(closingEntryCode)) {
      code.append(closingEntryCode);
    }
    if (containsCode(wrapupCode)) {
      code.append(wrapupProcedureName);
    }
    code.append(closingExitCode);
  }
  code.append(mainExitCode);
  codeTypesH.append(""String_Node_Str"");
  if (_executeCommands == null) {
    _executeCommands=new StreamExec();
  }
  startTime=_printTimeAndMemory(startTime,""String_Node_Str"");
  code=_finalPassOverCode(code);
  startTime=_printTimeAndMemory(startTime,""String_Node_Str"");
  super._writeCode(code);
  super._writeCodeFileName(codeMainH,_sanitizedModelName + ""String_Node_Str"",true,false);
  super._writeCodeFileName(codeTypesH,""String_Node_Str"",true,false);
  super._writeCodeFileName(codeTypesC,""String_Node_Str"",true,false);
  if (director != null && director instanceof DEDirector) {
    _copyCFileTosrc(""String_Node_Str"",""String_Node_Str"");
    _copyCFileTosrc(""String_Node_Str"",""String_Node_Str"");
    _copyCFileTosrc(""String_Node_Str"",""String_Node_Str"");
    _copyCFileTosrc(""String_Node_Str"",""String_Node_Str"");
    _copyCFileTosrc(""String_Node_Str"",""String_Node_Str"");
    _copyCFileTosrc(""String_Node_Str"",""String_Node_Str"");
    _copyCFileTosrc(""String_Node_Str"",""String_Node_Str"");
    _copyCFileTosrc(""String_Node_Str"",""String_Node_Str"");
    _copyCFileTosrc(""String_Node_Str"",""String_Node_Str"");
    _copyCFileTosrc(""String_Node_Str"",""String_Node_Str"");
    _copyCFileTosrc(""String_Node_Str"",""String_Node_Str"");
    _copyCFileTosrc(""String_Node_Str"",""String_Node_Str"");
  }
  code=null;
  _printTimeAndMemory(startTime,""String_Node_Str"");
  _writeMakefile();
  _printTimeAndMemory(overallStartTime,""String_Node_Str"");
  return _executeCommands();
}","/** 
 * Generate code and append it to the given string buffer. Write the code to the directory specified by the codeDirectory parameter.  The file name is a sanitized version of the model name with a suffix that is based on last package name of the <i>generatorPackage</i> parameter.  Thus if the <i>codeDirectory</i> is <code>$HOME</code>, the name of the model is <code>Foo</code> and the <i>generatorPackage</i> is <code>ptolemy.codegen.c</code>, then the file that is written will be <code>$HOME/Foo.c</code> This method is the main entry point. We do not call the super method because it is too different from it. For instance, there is not only one file generated, but a few.
 * @param code The given string buffer.
 * @return The return value of the last subprocess that was executed.or -1 if no commands were executed.
 * @exception KernelException If the target file cannot be overwrittenor write-to-file throw any exception.
 */
protected int _generateCode(StringBuffer code) throws KernelException {
  long startTime=new Date().getTime();
  long overallStartTime=startTime;
  _reset();
  _sanitizedModelName=CodeGeneratorAdapter.generateName(_model);
  NamedObj container=getContainer();
  Director director=null;
  if (container instanceof CompositeActor)   director=((CompositeActor)container).getDirector();
  if (container instanceof ptolemy.cg.lib.CompiledCompositeActor) {
    _sanitizedModelName=((ptolemy.cg.lib.CompiledCompositeActor)container).getSanitizedName();
  }
  Attribute generateEmbeddedCode=getAttribute(""String_Node_Str"");
  if (generateEmbeddedCode instanceof Parameter && !(container instanceof ptolemy.cg.lib.CompiledCompositeActor)) {
    ((Parameter)generateEmbeddedCode).setExpression(""String_Node_Str"");
  }
  boolean inlineValue=((BooleanToken)inline.getToken()).booleanValue();
  if (inlineValue && director != null && director instanceof DEDirector) {
    throw new IllegalActionException(""String_Node_Str"");
  }
  _analyzeTypeConversions();
  startTime=_printTimeAndMemory(startTime,""String_Node_Str"");
  _addActorIncludeDirectories();
  _addActorLibraries();
  _setupAdapter();
  String preinitializeCode=_generatePreinitializeCode();
  String preinitializeMethodEntryCode=_generatePreinitializeMethodEntryCode();
  String preinitializeMethodBodyCode=_generatePreinitializeMethodBodyCode();
  String preinitializeMethodExitCode=_generatePreinitializeMethodExitCode();
  String preinitializeProcedureName=_generatePreinitializeMethodProcedureName();
  String initializeCode=generateInitializeCode();
  String bodyCode=_generateBodyCode();
  String mainEntryCode=generateMainEntryCode();
  String mainExitCode=generateMainExitCode();
  String initializeEntryCode=generateInitializeEntryCode();
  String initializeExitCode=generateInitializeExitCode();
  String initializeProcedureName=generateInitializeProcedureName();
  String wrapupEntryCode=generateWrapupEntryCode();
  String wrapupExitCode=generateWrapupExitCode();
  String wrapupProcedureName=generateWrapupProcedureName();
  String fireFunctionCode=null;
  String[] actorsCode=new String[0];
  if (!inlineValue) {
    if (director != null && director instanceof DEDirector) {
      ptolemy.cg.adapter.generic.program.procedural.c.adapters.ptolemy.domains.de.kernel.DEDirector directorAdapter=(ptolemy.cg.adapter.generic.program.procedural.c.adapters.ptolemy.domains.de.kernel.DEDirector)getAdapter(((DEDirector)director));
      actorsCode=directorAdapter.generateActorCode();
    }
 else {
      actorsCode=new String[0];
      fireFunctionCode=generateFireFunctionCode();
    }
  }
  String wrapupCode=generateWrapupCode();
  String closingEntryCode=generateClosingEntryCode();
  String closingExitCode=generateClosingExitCode();
  String variableInitCode=generateVariableInitialization();
  String sharedCode=_generateSharedCode();
  String declareSharedCode=_generateDeclareSharedCode();
  String[] typeResolutionCode=generateTypeConvertCodeCandH();
  List<String> variableDeclareCode=_splitVariableDeclaration(""String_Node_Str"",generateVariableDeclaration());
  String includeFiles=_generateIncludeFiles();
  startTime=_printTimeAndMemory(startTime,""String_Node_Str"");
  StringBuffer codeMainH=new StringBuffer();
  StringBuffer codeTypesH=new StringBuffer();
  StringBuffer codeTypesC=new StringBuffer();
  codeTypesH.append(""String_Node_Str"" + _eol + ""String_Node_Str""+ _eol);
  code.append(generateCopyright());
  code.append(generatePackageStatement());
  code.append(variableDeclareCode.get(0));
  codeMainH.append(""String_Node_Str"" + _sanitizedModelName.toUpperCase() + ""String_Node_Str""+ _eol+ ""String_Node_Str""+ _sanitizedModelName.toUpperCase()+ ""String_Node_Str""+ _eol);
  if (director != null && director instanceof DEDirector) {
    codeMainH.append(""String_Node_Str"" + _eol);
    codeMainH.append(""String_Node_Str"" + _eol);
    codeMainH.append(""String_Node_Str"" + _eol);
    codeMainH.append(""String_Node_Str"" + _eol);
    codeMainH.append(""String_Node_Str"" + _eol);
    codeMainH.append(""String_Node_Str"" + _eol);
    codeTypesH.append(_eol + ""String_Node_Str"");
    codeTypesH.append(_eol + ""String_Node_Str"");
    codeTypesH.append(_eol + ""String_Node_Str"");
    codeTypesH.append(_eol + ""String_Node_Str"" + _eol);
  }
  codeMainH.append(""String_Node_Str"" + _eol);
  codeMainH.append(includeFiles);
  code.append(""String_Node_Str"" + _sanitizedModelName + ""String_Node_Str""+ _eol);
  includeFiles=null;
  code.append(comment(""String_Node_Str""));
  codeTypesH.append(typeResolutionCode[0]);
  typeResolutionCode[0]=null;
  codeTypesH.append(comment(""String_Node_Str""));
  codeTypesC.append(typeResolutionCode[1]);
  typeResolutionCode[1]=null;
  codeTypesC.append(comment(""String_Node_Str""));
  codeTypesC.append(sharedCode);
  sharedCode=null;
  codeTypesH.append(declareSharedCode);
  declareSharedCode=null;
  codeTypesH.append(comment(""String_Node_Str""));
  codeMainH.append(_writeVariableDeclarations(variableDeclareCode));
  codeMainH.append(comment(""String_Node_Str""));
  codeMainH.append(preinitializeCode);
  preinitializeCode=null;
  codeMainH.append(comment(""String_Node_Str""));
  codeMainH.append(comment(""String_Node_Str""));
  String[] splitPreinitializeMethodBodyCode=_splitBody(""String_Node_Str"",preinitializeMethodBodyCode);
  codeMainH.append(comment(""String_Node_Str""));
  codeMainH.append(splitPreinitializeMethodBodyCode[0]);
  splitPreinitializeMethodBodyCode[0]=null;
  codeMainH.append(comment(""String_Node_Str""));
  codeMainH.append(preinitializeMethodEntryCode);
  codeMainH.append(splitPreinitializeMethodBodyCode[1]);
  splitPreinitializeMethodBodyCode[1]=null;
  codeMainH.append(preinitializeMethodExitCode);
  codeMainH.append(_eol + ""String_Node_Str"");
  if (!inlineValue && fireFunctionCode != null) {
    code.append(comment(""String_Node_Str""));
    code.append(fireFunctionCode);
    fireFunctionCode=null;
    code.append(comment(""String_Node_Str""));
  }
  String[] splitVariableInitCode=_splitBody(""String_Node_Str"",variableInitCode);
  code.append(comment(""String_Node_Str""));
  code.append(splitVariableInitCode[0] + ""String_Node_Str"");
  splitVariableInitCode[0]=null;
  code.append(comment(""String_Node_Str""));
  String[] splitInitializeCode=_splitBody(""String_Node_Str"",initializeCode);
  code.append(comment(""String_Node_Str""));
  code.append(splitInitializeCode[0]);
  splitInitializeCode[0]=null;
  code.append(comment(""String_Node_Str""));
  code.append(comment(""String_Node_Str""));
  code.append(initializeEntryCode);
  code.append(comment(""String_Node_Str""));
  code.append(comment(""String_Node_Str""));
  code.append(splitVariableInitCode[1]);
  splitVariableInitCode[1]=null;
  code.append(comment(""String_Node_Str""));
  code.append(comment(""String_Node_Str""));
  code.append(splitInitializeCode[1]);
  splitInitializeCode[1]=null;
  code.append(comment(""String_Node_Str""));
  code.append(comment(""String_Node_Str""));
  code.append(initializeExitCode);
  String[] splitWrapupCode=_splitBody(""String_Node_Str"",wrapupCode);
  code.append(splitWrapupCode[0]);
  splitWrapupCode[0]=null;
  code.append(wrapupEntryCode);
  code.append(splitWrapupCode[1]);
  splitWrapupCode[1]=null;
  code.append(wrapupExitCode);
  code.append(mainEntryCode);
  if (_isTopLevel()) {
    if (containsCode(preinitializeMethodBodyCode)) {
      code.append(preinitializeProcedureName);
    }
    if (containsCode(variableInitCode) || containsCode(initializeCode)) {
      code.append(initializeProcedureName);
    }
  }
  code.append(bodyCode);
  String directorySrc=codeDirectory.stringValue();
  String directoryIncludes=codeDirectory.stringValue();
  String directoryBuild=codeDirectory.stringValue();
  if (!directorySrc.endsWith(""String_Node_Str""))   directorySrc+=""String_Node_Str"";
  if (!directoryIncludes.endsWith(""String_Node_Str""))   directoryIncludes+=""String_Node_Str"";
  if (!directoryBuild.endsWith(""String_Node_Str""))   directoryBuild+=""String_Node_Str"";
  new File(directorySrc).mkdirs();
  directorySrc+=""String_Node_Str"";
  directoryIncludes+=""String_Node_Str"";
  directoryBuild+=""String_Node_Str"";
  new File(directorySrc).mkdirs();
  new File(directoryIncludes).mkdirs();
  new File(directoryBuild).mkdirs();
  _actorsToInclude=new LinkedList<String>();
  for (int i=0; i < actorsCode.length; i+=3) {
    _actorsToInclude.add(actorsCode[i]);
    StringBuffer actorCode=new StringBuffer();
    actorCode.append(actorsCode[i + 1]);
    super._writeCodeFileName(actorCode,""String_Node_Str"" + actorsCode[i] + ""String_Node_Str"",true,false);
    StringBuffer actorCodeH=new StringBuffer();
    actorCodeH.append(actorsCode[i + 2]);
    super._writeCodeFileName(actorCodeH,""String_Node_Str"" + actorsCode[i] + ""String_Node_Str"",true,false);
  }
  bodyCode=null;
  if (_isTopLevel()) {
    if (containsCode(closingEntryCode)) {
      code.append(closingEntryCode);
    }
    if (containsCode(wrapupCode)) {
      code.append(wrapupProcedureName);
    }
    code.append(closingExitCode);
  }
  code.append(mainExitCode);
  codeTypesH.append(""String_Node_Str"");
  if (_executeCommands == null) {
    _executeCommands=new StreamExec();
  }
  startTime=_printTimeAndMemory(startTime,""String_Node_Str"");
  code=_finalPassOverCode(code);
  startTime=_printTimeAndMemory(startTime,""String_Node_Str"");
  super._writeCode(code);
  super._writeCodeFileName(codeMainH,_sanitizedModelName + ""String_Node_Str"",true,false);
  super._writeCodeFileName(codeTypesH,""String_Node_Str"",true,false);
  super._writeCodeFileName(codeTypesC,""String_Node_Str"",true,false);
  if (director != null && director instanceof DEDirector) {
    _copyCFileTosrc(""String_Node_Str"",""String_Node_Str"");
    _copyCFileTosrc(""String_Node_Str"",""String_Node_Str"");
    _copyCFileTosrc(""String_Node_Str"",""String_Node_Str"");
    _copyCFileTosrc(""String_Node_Str"",""String_Node_Str"");
    _copyCFileTosrc(""String_Node_Str"",""String_Node_Str"");
    _copyCFileTosrc(""String_Node_Str"",""String_Node_Str"");
    _copyCFileTosrc(""String_Node_Str"",""String_Node_Str"");
    _copyCFileTosrc(""String_Node_Str"",""String_Node_Str"");
    _copyCFileTosrc(""String_Node_Str"",""String_Node_Str"");
    _copyCFileTosrc(""String_Node_Str"",""String_Node_Str"");
    _copyCFileTosrc(""String_Node_Str"",""String_Node_Str"");
    _copyCFileTosrc(""String_Node_Str"",""String_Node_Str"");
  }
  code=null;
  _printTimeAndMemory(startTime,""String_Node_Str"");
  _writeMakefile();
  _printTimeAndMemory(overallStartTime,""String_Node_Str"");
  return _executeCommands();
}"
72985,"/** 
 * Generate include files. FIXME: State what is included.
 * @return The #include statements, surrounded by #ifndef to ensurethat the files are included only once.
 * @exception IllegalActionException If the adapter class for some actorcannot be found.
 */
protected String _generateIncludeFiles() throws IllegalActionException {
  StringBuffer code=new StringBuffer();
  NamedProgramCodeGeneratorAdapter compositeActorAdapter=(NamedProgramCodeGeneratorAdapter)getAdapter(getContainer());
  Set<String> includingFiles=compositeActorAdapter.getHeaderFiles();
  includingFiles.add(""String_Node_Str"");
  if (_isTopLevel() && ((BooleanToken)measureTime.getToken()).booleanValue()) {
    includingFiles.add(""String_Node_Str"");
  }
  if (!_isTopLevel()) {
    includingFiles.add(""String_Node_Str"" + _sanitizedModelName + ""String_Node_Str"");
    includingFiles.addAll(_getJVMHeaderFiles());
  }
  if (((BooleanToken)generateEmbeddedCode.getToken()).booleanValue()) {
    includingFiles.addAll(_getJVMHeaderFiles());
  }
  includingFiles.add(""String_Node_Str"");
  includingFiles.add(""String_Node_Str"");
  includingFiles.add(""String_Node_Str"");
  includingFiles.add(""String_Node_Str"");
  for (  String file : includingFiles) {
    if (file.endsWith(""String_Node_Str""))     code.append(""String_Node_Str"" + file.substring(1) + _eol);
 else     code.append(""String_Node_Str"" + file + _eol);
  }
  return code.toString();
}","/** 
 * Generate include files. FIXME: State what is included.
 * @return The #include statements, surrounded by #ifndef to ensurethat the files are included only once.
 * @exception IllegalActionException If the adapter class for some actorcannot be found.
 */
protected String _generateIncludeFiles() throws IllegalActionException {
  StringBuffer code=new StringBuffer();
  NamedProgramCodeGeneratorAdapter compositeActorAdapter=(NamedProgramCodeGeneratorAdapter)getAdapter(getContainer());
  Set<String> includingFiles=compositeActorAdapter.getHeaderFiles();
  includingFiles.add(""String_Node_Str"");
  if (_isTopLevel() && ((BooleanToken)measureTime.getToken()).booleanValue()) {
    includingFiles.add(""String_Node_Str"");
  }
  if (!_isTopLevel()) {
    includingFiles.add(""String_Node_Str"" + _sanitizedModelName + ""String_Node_Str"");
    includingFiles.addAll(_getJVMHeaderFiles());
  }
  if (((BooleanToken)generateEmbeddedCode.getToken()).booleanValue()) {
    includingFiles.addAll(_getJVMHeaderFiles());
  }
  includingFiles.add(""String_Node_Str"");
  includingFiles.add(""String_Node_Str"");
  includingFiles.add(""String_Node_Str"");
  includingFiles.add(""String_Node_Str"");
  for (  String file : includingFiles) {
    if (file.endsWith(""String_Node_Str"") && _isTopLevel())     code.append(""String_Node_Str"" + file.substring(1) + _eol);
 else     code.append(""String_Node_Str"" + file + _eol);
  }
  return code.toString();
}"
72986,"/** 
 * Check if event is safe to process.
 * @param event The event to be checked.
 * @return true if the event is safe to process.
 * @exception IllegalActionException If the delayOffset aparametercannot be read.
 */
private boolean _isSafeToProcess(PtidesEvent event) throws IllegalActionException {
  Object[] eventArray=_eventQueue.toArray();
  for (  Object object : eventArray) {
    PtidesEvent ptidesEvent=(PtidesEvent)object;
    if (ptidesEvent.actor() != event.actor() && ptidesEvent.ioPort() != null && event.ioPort() != null) {
      SuperdenseDependency minDelay=_getSuperdenseDependencyPair((TypedIOPort)ptidesEvent.ioPort(),(TypedIOPort)event.ioPort());
      if (event.timeStamp().getDoubleValue() - ptidesEvent.timeStamp().getDoubleValue() >= minDelay.timeValue()) {
        return false;
      }
    }
  }
  ThrottleAttributes attributes=(ThrottleAttributes)((NamedObj)event.actor()).getDecoratorAttributes(this);
  if (attributes != null && ((BooleanToken)attributes.useMaximumFutureEvents.getToken()).booleanValue()) {
    Integer maxFutureEvents=((IntToken)attributes.maximumFutureEvents.getToken()).intValue();
    if (maxFutureEvents != null) {
      int futureEvents=_getNumberOfFutureEventsFrom(event.actor());
      return (futureEvents <= maxFutureEvents);
    }
  }
  Double delayOffset=null;
  Time eventTimestamp=event.timeStamp();
  IOPort port=event.ioPort();
  if (port != null) {
    Actor actor=(Actor)port.getContainer();
    for (    Object ioPort : actor.inputPortList()) {
      Double ioPortDelayOffset=_getDoubleParameterValue((NamedObj)ioPort,""String_Node_Str"");
      if (ioPortDelayOffset != null && (delayOffset == null || ioPortDelayOffset < delayOffset)) {
        delayOffset=ioPortDelayOffset;
      }
    }
  }
 else {
    attributes=(ThrottleAttributes)((NamedObj)event.actor()).getDecoratorAttributes(this);
    if (((BooleanToken)attributes.useMaximumFutureFiringTime.getToken()).booleanValue()) {
      delayOffset=Double.valueOf(((DoubleToken)attributes.maximumFutureFiringTime.getToken()).doubleValue());
    }
  }
  if (delayOffset == null || localClock.getLocalTime().compareTo(eventTimestamp.subtract(delayOffset).subtract(_clockSynchronizationErrorBound)) >= 0) {
    return true;
  }
  _setNextFireTime(eventTimestamp.subtract(delayOffset));
  return false;
}","/** 
 * Check if event is safe to process.
 * @param event The event to be checked.
 * @return true if the event is safe to process.
 * @exception IllegalActionException If the delayOffset aparametercannot be read.
 */
private boolean _isSafeToProcess(PtidesEvent event) throws IllegalActionException {
  Object[] eventArray=_eventQueue.toArray();
  for (  Object object : eventArray) {
    PtidesEvent ptidesEvent=(PtidesEvent)object;
    if (ptidesEvent.actor() != event.actor() && ptidesEvent.ioPort() != null && event.ioPort() != null) {
      SuperdenseDependency minDelay=_getSuperdenseDependencyPair((TypedIOPort)ptidesEvent.ioPort(),(TypedIOPort)event.ioPort());
      if (event.timeStamp().getDoubleValue() - ptidesEvent.timeStamp().getDoubleValue() >= minDelay.timeValue()) {
        return false;
      }
    }
  }
  ThrottleAttributes attributes=(ThrottleAttributes)((NamedObj)event.actor()).getDecoratorAttributes(this);
  if (attributes != null && ((BooleanToken)attributes.useMaximumFutureEvents.getToken()).booleanValue()) {
    Integer maxFutureEvents=((IntToken)attributes.maximumFutureEvents.getToken()).intValue();
    if (maxFutureEvents != null) {
      int futureEvents=_getNumberOfFutureEventsFrom(event.actor());
      return (futureEvents <= maxFutureEvents);
    }
  }
  Double delayOffset=null;
  Time eventTimestamp=event.timeStamp();
  IOPort port=event.ioPort();
  if (port != null) {
    Actor actor=(Actor)port.getContainer();
    for (    Object ioPort : actor.inputPortList()) {
      Double ioPortDelayOffset=_getDoubleParameterValue((NamedObj)ioPort,""String_Node_Str"");
      if (ioPortDelayOffset != null && (delayOffset == null || ioPortDelayOffset < delayOffset)) {
        delayOffset=ioPortDelayOffset;
      }
    }
  }
 else {
    attributes=(ThrottleAttributes)((NamedObj)event.actor()).getDecoratorAttributes(this);
    if (attributes != null && ((BooleanToken)attributes.useMaximumFutureFiringTime.getToken()).booleanValue()) {
      delayOffset=Double.valueOf(((DoubleToken)attributes.maximumFutureFiringTime.getToken()).doubleValue());
    }
  }
  if (delayOffset == null || localClock.getLocalTime().compareTo(eventTimestamp.subtract(delayOffset).subtract(_clockSynchronizationErrorBound)) >= 0) {
    return true;
  }
  _setNextFireTime(eventTimestamp.subtract(delayOffset));
  return false;
}"
72987,"/** 
 * Generate code and append it to the given string buffer. Write the code to the directory specified by the codeDirectory parameter.  The file name is a sanitized version of the model name with a suffix that is based on last package name of the <i>generatorPackage</i> parameter.  Thus if the <i>codeDirectory</i> is <code>$HOME</code>, the name of the model is <code>Foo</code> and the <i>generatorPackage</i> is <code>ptolemy.codegen.c</code>, then the file that is written will be <code>$HOME/Foo.c</code> This method is the main entry point. We do not call the super method because it is too different from it. For instance, there is not only one file generated, but a few.
 * @param code The given string buffer.
 * @return The return value of the last subprocess that was executed.or -1 if no commands were executed.
 * @exception KernelException If the target file cannot be overwrittenor write-to-file throw any exception.
 */
protected int _generateCode(StringBuffer code) throws KernelException {
  long startTime=new Date().getTime();
  long overallStartTime=startTime;
  _reset();
  _sanitizedModelName=CodeGeneratorAdapter.generateName(_model);
  NamedObj container=getContainer();
  Director director=null;
  if (container instanceof CompositeActor)   director=((CompositeActor)container).getDirector();
  if (container instanceof ptolemy.cg.lib.CompiledCompositeActor) {
    _sanitizedModelName=((ptolemy.cg.lib.CompiledCompositeActor)container).getSanitizedName();
  }
  boolean inlineValue=((BooleanToken)inline.getToken()).booleanValue();
  if (inlineValue && director != null && director instanceof DEDirector) {
    throw new IllegalActionException(""String_Node_Str"");
  }
  _analyzeTypeConversions();
  startTime=_printTimeAndMemory(startTime,""String_Node_Str"");
  _addActorIncludeDirectories();
  _addActorLibraries();
  _setupAdapter();
  String preinitializeCode=_generatePreinitializeCode();
  String preinitializeMethodEntryCode=_generatePreinitializeMethodEntryCode();
  String preinitializeMethodBodyCode=_generatePreinitializeMethodBodyCode();
  String preinitializeMethodExitCode=_generatePreinitializeMethodExitCode();
  String preinitializeProcedureName=_generatePreinitializeMethodProcedureName();
  String initializeCode=generateInitializeCode();
  String bodyCode=_generateBodyCode();
  String mainEntryCode=generateMainEntryCode();
  String mainExitCode=generateMainExitCode();
  String initializeEntryCode=generateInitializeEntryCode();
  String initializeExitCode=generateInitializeExitCode();
  String initializeProcedureName=generateInitializeProcedureName();
  String wrapupEntryCode=generateWrapupEntryCode();
  String wrapupExitCode=generateWrapupExitCode();
  String wrapupProcedureName=generateWrapupProcedureName();
  String fireFunctionCode=null;
  String[] actorsCode=new String[0];
  if (!inlineValue) {
    if (director != null && director instanceof DEDirector) {
      ptolemy.cg.adapter.generic.program.procedural.adapters.ptolemy.domains.de.kernel.DEDirector directorAdapter=(ptolemy.cg.adapter.generic.program.procedural.adapters.ptolemy.domains.de.kernel.DEDirector)getAdapter(((DEDirector)director));
      actorsCode=directorAdapter.generateActorCode();
    }
 else {
      actorsCode=new String[0];
      fireFunctionCode=generateFireFunctionCode();
    }
  }
  String wrapupCode=generateWrapupCode();
  String closingEntryCode=generateClosingEntryCode();
  String closingExitCode=generateClosingExitCode();
  String variableInitCode=generateVariableInitialization();
  String sharedCode=_generateSharedCode();
  String declareSharedCode=_generateDeclareSharedCode();
  String[] typeResolutionCode=generateTypeConvertCodeCandH();
  List<String> variableDeclareCode=_splitVariableDeclaration(""String_Node_Str"",generateVariableDeclaration());
  String includeFiles=_generateIncludeFiles();
  startTime=_printTimeAndMemory(startTime,""String_Node_Str"");
  StringBuffer codeMainH=new StringBuffer();
  StringBuffer codeTypesH=new StringBuffer();
  StringBuffer codeTypesC=new StringBuffer();
  codeTypesH.append(""String_Node_Str"" + _eol + ""String_Node_Str""+ _eol);
  code.append(generateCopyright());
  code.append(generatePackageStatement());
  code.append(variableDeclareCode.get(0));
  codeMainH.append(""String_Node_Str"" + _eol + ""String_Node_Str""+ _eol);
  if (director != null && director instanceof DEDirector) {
    codeMainH.append(""String_Node_Str"" + _eol);
    codeMainH.append(""String_Node_Str"" + _eol);
    codeMainH.append(""String_Node_Str"" + _eol);
    codeMainH.append(""String_Node_Str"" + _eol);
    codeMainH.append(""String_Node_Str"" + _eol);
    codeMainH.append(""String_Node_Str"" + _eol);
  }
  codeMainH.append(""String_Node_Str"" + _eol);
  codeMainH.append(includeFiles);
  code.append(""String_Node_Str"" + _eol);
  includeFiles=null;
  code.append(comment(""String_Node_Str""));
  codeTypesH.append(typeResolutionCode[0]);
  typeResolutionCode[0]=null;
  codeTypesH.append(comment(""String_Node_Str""));
  codeTypesC.append(typeResolutionCode[1]);
  typeResolutionCode[1]=null;
  codeTypesC.append(comment(""String_Node_Str""));
  codeTypesC.append(sharedCode);
  sharedCode=null;
  codeTypesH.append(declareSharedCode);
  declareSharedCode=null;
  codeTypesH.append(comment(""String_Node_Str""));
  codeMainH.append(_writeVariableDeclarations(variableDeclareCode));
  codeMainH.append(comment(""String_Node_Str""));
  codeMainH.append(preinitializeCode);
  preinitializeCode=null;
  codeMainH.append(comment(""String_Node_Str""));
  codeMainH.append(comment(""String_Node_Str""));
  String[] splitPreinitializeMethodBodyCode=_splitBody(""String_Node_Str"",preinitializeMethodBodyCode);
  codeMainH.append(comment(""String_Node_Str""));
  codeMainH.append(splitPreinitializeMethodBodyCode[0]);
  splitPreinitializeMethodBodyCode[0]=null;
  codeMainH.append(comment(""String_Node_Str""));
  codeMainH.append(preinitializeMethodEntryCode);
  codeMainH.append(splitPreinitializeMethodBodyCode[1]);
  splitPreinitializeMethodBodyCode[1]=null;
  codeMainH.append(preinitializeMethodExitCode);
  codeMainH.append(_eol + ""String_Node_Str"");
  if (!inlineValue && fireFunctionCode != null) {
    code.append(comment(""String_Node_Str""));
    code.append(fireFunctionCode);
    fireFunctionCode=null;
    code.append(comment(""String_Node_Str""));
  }
  String[] splitVariableInitCode=_splitBody(""String_Node_Str"",variableInitCode);
  code.append(comment(""String_Node_Str""));
  code.append(splitVariableInitCode[0] + ""String_Node_Str"");
  splitVariableInitCode[0]=null;
  code.append(comment(""String_Node_Str""));
  String[] splitInitializeCode=_splitBody(""String_Node_Str"",initializeCode);
  code.append(comment(""String_Node_Str""));
  code.append(splitInitializeCode[0]);
  splitInitializeCode[0]=null;
  code.append(comment(""String_Node_Str""));
  code.append(comment(""String_Node_Str""));
  code.append(initializeEntryCode);
  code.append(comment(""String_Node_Str""));
  code.append(comment(""String_Node_Str""));
  code.append(splitVariableInitCode[1]);
  splitVariableInitCode[1]=null;
  code.append(comment(""String_Node_Str""));
  code.append(comment(""String_Node_Str""));
  code.append(splitInitializeCode[1]);
  splitInitializeCode[1]=null;
  code.append(comment(""String_Node_Str""));
  code.append(comment(""String_Node_Str""));
  code.append(initializeExitCode);
  String[] splitWrapupCode=_splitBody(""String_Node_Str"",wrapupCode);
  code.append(splitWrapupCode[0]);
  splitWrapupCode[0]=null;
  code.append(wrapupEntryCode);
  code.append(splitWrapupCode[1]);
  splitWrapupCode[1]=null;
  code.append(wrapupExitCode);
  code.append(mainEntryCode);
  if (_isTopLevel()) {
    if (containsCode(preinitializeMethodBodyCode)) {
      code.append(preinitializeProcedureName);
    }
    if (containsCode(variableInitCode) || containsCode(initializeCode)) {
      code.append(initializeProcedureName);
    }
  }
  code.append(bodyCode);
  String directorySrc=""String_Node_Str"";
  directorySrc+=codeDirectory.stringValue();
  if (!directorySrc.endsWith(""String_Node_Str""))   directorySrc+=""String_Node_Str"";
  new File(directorySrc).mkdirs();
  directorySrc+=""String_Node_Str"";
  new File(directorySrc).mkdirs();
  _actorsToInclude=new LinkedList<String>();
  for (int i=0; i < actorsCode.length; i+=3) {
    _actorsToInclude.add(actorsCode[i]);
    StringBuffer actorCode=new StringBuffer();
    actorCode.append(actorsCode[i + 1]);
    super._writeCodeFileName(actorCode,""String_Node_Str"" + actorsCode[i] + ""String_Node_Str"",true,false);
    StringBuffer actorCodeH=new StringBuffer();
    actorCodeH.append(actorsCode[i + 2]);
    super._writeCodeFileName(actorCodeH,""String_Node_Str"" + actorsCode[i] + ""String_Node_Str"",true,false);
  }
  bodyCode=null;
  if (_isTopLevel()) {
    if (containsCode(closingEntryCode)) {
      code.append(closingEntryCode);
    }
    if (containsCode(wrapupCode)) {
      code.append(wrapupProcedureName);
    }
    code.append(closingExitCode);
  }
  code.append(mainExitCode);
  codeTypesH.append(""String_Node_Str"");
  if (_executeCommands == null) {
    _executeCommands=new StreamExec();
  }
  startTime=_printTimeAndMemory(startTime,""String_Node_Str"");
  code=_finalPassOverCode(code);
  startTime=_printTimeAndMemory(startTime,""String_Node_Str"");
  super._writeCode(code);
  super._writeCodeFileName(codeMainH,""String_Node_Str"",true,false);
  super._writeCodeFileName(codeTypesH,""String_Node_Str"",true,false);
  super._writeCodeFileName(codeTypesC,""String_Node_Str"",true,false);
  if (director != null && director instanceof DEDirector) {
    _copyCFileTosrc(""String_Node_Str"");
    _copyCFileTosrc(""String_Node_Str"");
    _copyCFileTosrc(""String_Node_Str"");
    _copyCFileTosrc(""String_Node_Str"");
    _copyCFileTosrc(""String_Node_Str"");
    _copyCFileTosrc(""String_Node_Str"");
    _copyCFileTosrc(""String_Node_Str"");
    _copyCFileTosrc(""String_Node_Str"");
    _copyCFileTosrc(""String_Node_Str"");
    _copyCFileTosrc(""String_Node_Str"");
    _copyCFileTosrc(""String_Node_Str"");
    _copyCFileTosrc(""String_Node_Str"");
  }
  code=null;
  _printTimeAndMemory(startTime,""String_Node_Str"");
  _writeMakefile();
  _printTimeAndMemory(overallStartTime,""String_Node_Str"");
  return _executeCommands();
}","/** 
 * Generate code and append it to the given string buffer. Write the code to the directory specified by the codeDirectory parameter.  The file name is a sanitized version of the model name with a suffix that is based on last package name of the <i>generatorPackage</i> parameter.  Thus if the <i>codeDirectory</i> is <code>$HOME</code>, the name of the model is <code>Foo</code> and the <i>generatorPackage</i> is <code>ptolemy.codegen.c</code>, then the file that is written will be <code>$HOME/Foo.c</code> This method is the main entry point. We do not call the super method because it is too different from it. For instance, there is not only one file generated, but a few.
 * @param code The given string buffer.
 * @return The return value of the last subprocess that was executed.or -1 if no commands were executed.
 * @exception KernelException If the target file cannot be overwrittenor write-to-file throw any exception.
 */
protected int _generateCode(StringBuffer code) throws KernelException {
  long startTime=new Date().getTime();
  long overallStartTime=startTime;
  _reset();
  _sanitizedModelName=CodeGeneratorAdapter.generateName(_model);
  NamedObj container=getContainer();
  Director director=null;
  if (container instanceof CompositeActor)   director=((CompositeActor)container).getDirector();
  if (container instanceof ptolemy.cg.lib.CompiledCompositeActor) {
    _sanitizedModelName=((ptolemy.cg.lib.CompiledCompositeActor)container).getSanitizedName();
  }
  Attribute generateEmbeddedCode=getAttribute(""String_Node_Str"");
  if (generateEmbeddedCode instanceof Parameter) {
    ((Parameter)generateEmbeddedCode).setExpression(""String_Node_Str"");
  }
  boolean inlineValue=((BooleanToken)inline.getToken()).booleanValue();
  if (inlineValue && director != null && director instanceof DEDirector) {
    throw new IllegalActionException(""String_Node_Str"");
  }
  _analyzeTypeConversions();
  startTime=_printTimeAndMemory(startTime,""String_Node_Str"");
  _addActorIncludeDirectories();
  _addActorLibraries();
  _setupAdapter();
  String preinitializeCode=_generatePreinitializeCode();
  String preinitializeMethodEntryCode=_generatePreinitializeMethodEntryCode();
  String preinitializeMethodBodyCode=_generatePreinitializeMethodBodyCode();
  String preinitializeMethodExitCode=_generatePreinitializeMethodExitCode();
  String preinitializeProcedureName=_generatePreinitializeMethodProcedureName();
  String initializeCode=generateInitializeCode();
  String bodyCode=_generateBodyCode();
  String mainEntryCode=generateMainEntryCode();
  String mainExitCode=generateMainExitCode();
  String initializeEntryCode=generateInitializeEntryCode();
  String initializeExitCode=generateInitializeExitCode();
  String initializeProcedureName=generateInitializeProcedureName();
  String wrapupEntryCode=generateWrapupEntryCode();
  String wrapupExitCode=generateWrapupExitCode();
  String wrapupProcedureName=generateWrapupProcedureName();
  String fireFunctionCode=null;
  String[] actorsCode=new String[0];
  if (!inlineValue) {
    if (director != null && director instanceof DEDirector) {
      ptolemy.cg.adapter.generic.program.procedural.adapters.ptolemy.domains.de.kernel.DEDirector directorAdapter=(ptolemy.cg.adapter.generic.program.procedural.adapters.ptolemy.domains.de.kernel.DEDirector)getAdapter(((DEDirector)director));
      actorsCode=directorAdapter.generateActorCode();
    }
 else {
      actorsCode=new String[0];
      fireFunctionCode=generateFireFunctionCode();
    }
  }
  String wrapupCode=generateWrapupCode();
  String closingEntryCode=generateClosingEntryCode();
  String closingExitCode=generateClosingExitCode();
  String variableInitCode=generateVariableInitialization();
  String sharedCode=_generateSharedCode();
  String declareSharedCode=_generateDeclareSharedCode();
  String[] typeResolutionCode=generateTypeConvertCodeCandH();
  List<String> variableDeclareCode=_splitVariableDeclaration(""String_Node_Str"",generateVariableDeclaration());
  String includeFiles=_generateIncludeFiles();
  startTime=_printTimeAndMemory(startTime,""String_Node_Str"");
  StringBuffer codeMainH=new StringBuffer();
  StringBuffer codeTypesH=new StringBuffer();
  StringBuffer codeTypesC=new StringBuffer();
  codeTypesH.append(""String_Node_Str"" + _eol + ""String_Node_Str""+ _eol);
  code.append(generateCopyright());
  code.append(generatePackageStatement());
  code.append(variableDeclareCode.get(0));
  codeMainH.append(""String_Node_Str"" + _eol + ""String_Node_Str""+ _eol);
  if (director != null && director instanceof DEDirector) {
    codeMainH.append(""String_Node_Str"" + _eol);
    codeMainH.append(""String_Node_Str"" + _eol);
    codeMainH.append(""String_Node_Str"" + _eol);
    codeMainH.append(""String_Node_Str"" + _eol);
    codeMainH.append(""String_Node_Str"" + _eol);
    codeMainH.append(""String_Node_Str"" + _eol);
  }
  codeMainH.append(""String_Node_Str"" + _eol);
  codeMainH.append(includeFiles);
  code.append(""String_Node_Str"" + _eol);
  includeFiles=null;
  code.append(comment(""String_Node_Str""));
  codeTypesH.append(typeResolutionCode[0]);
  typeResolutionCode[0]=null;
  codeTypesH.append(comment(""String_Node_Str""));
  codeTypesC.append(typeResolutionCode[1]);
  typeResolutionCode[1]=null;
  codeTypesC.append(comment(""String_Node_Str""));
  codeTypesC.append(sharedCode);
  sharedCode=null;
  codeTypesH.append(declareSharedCode);
  declareSharedCode=null;
  codeTypesH.append(comment(""String_Node_Str""));
  codeMainH.append(_writeVariableDeclarations(variableDeclareCode));
  codeMainH.append(comment(""String_Node_Str""));
  codeMainH.append(preinitializeCode);
  preinitializeCode=null;
  codeMainH.append(comment(""String_Node_Str""));
  codeMainH.append(comment(""String_Node_Str""));
  String[] splitPreinitializeMethodBodyCode=_splitBody(""String_Node_Str"",preinitializeMethodBodyCode);
  codeMainH.append(comment(""String_Node_Str""));
  codeMainH.append(splitPreinitializeMethodBodyCode[0]);
  splitPreinitializeMethodBodyCode[0]=null;
  codeMainH.append(comment(""String_Node_Str""));
  codeMainH.append(preinitializeMethodEntryCode);
  codeMainH.append(splitPreinitializeMethodBodyCode[1]);
  splitPreinitializeMethodBodyCode[1]=null;
  codeMainH.append(preinitializeMethodExitCode);
  codeMainH.append(_eol + ""String_Node_Str"");
  if (!inlineValue && fireFunctionCode != null) {
    code.append(comment(""String_Node_Str""));
    code.append(fireFunctionCode);
    fireFunctionCode=null;
    code.append(comment(""String_Node_Str""));
  }
  String[] splitVariableInitCode=_splitBody(""String_Node_Str"",variableInitCode);
  code.append(comment(""String_Node_Str""));
  code.append(splitVariableInitCode[0] + ""String_Node_Str"");
  splitVariableInitCode[0]=null;
  code.append(comment(""String_Node_Str""));
  String[] splitInitializeCode=_splitBody(""String_Node_Str"",initializeCode);
  code.append(comment(""String_Node_Str""));
  code.append(splitInitializeCode[0]);
  splitInitializeCode[0]=null;
  code.append(comment(""String_Node_Str""));
  code.append(comment(""String_Node_Str""));
  code.append(initializeEntryCode);
  code.append(comment(""String_Node_Str""));
  code.append(comment(""String_Node_Str""));
  code.append(splitVariableInitCode[1]);
  splitVariableInitCode[1]=null;
  code.append(comment(""String_Node_Str""));
  code.append(comment(""String_Node_Str""));
  code.append(splitInitializeCode[1]);
  splitInitializeCode[1]=null;
  code.append(comment(""String_Node_Str""));
  code.append(comment(""String_Node_Str""));
  code.append(initializeExitCode);
  String[] splitWrapupCode=_splitBody(""String_Node_Str"",wrapupCode);
  code.append(splitWrapupCode[0]);
  splitWrapupCode[0]=null;
  code.append(wrapupEntryCode);
  code.append(splitWrapupCode[1]);
  splitWrapupCode[1]=null;
  code.append(wrapupExitCode);
  code.append(mainEntryCode);
  if (_isTopLevel()) {
    if (containsCode(preinitializeMethodBodyCode)) {
      code.append(preinitializeProcedureName);
    }
    if (containsCode(variableInitCode) || containsCode(initializeCode)) {
      code.append(initializeProcedureName);
    }
  }
  code.append(bodyCode);
  String directorySrc=""String_Node_Str"";
  directorySrc+=codeDirectory.stringValue();
  if (!directorySrc.endsWith(""String_Node_Str""))   directorySrc+=""String_Node_Str"";
  new File(directorySrc).mkdirs();
  directorySrc+=""String_Node_Str"";
  new File(directorySrc).mkdirs();
  _actorsToInclude=new LinkedList<String>();
  for (int i=0; i < actorsCode.length; i+=3) {
    _actorsToInclude.add(actorsCode[i]);
    StringBuffer actorCode=new StringBuffer();
    actorCode.append(actorsCode[i + 1]);
    super._writeCodeFileName(actorCode,""String_Node_Str"" + actorsCode[i] + ""String_Node_Str"",true,false);
    StringBuffer actorCodeH=new StringBuffer();
    actorCodeH.append(actorsCode[i + 2]);
    super._writeCodeFileName(actorCodeH,""String_Node_Str"" + actorsCode[i] + ""String_Node_Str"",true,false);
  }
  bodyCode=null;
  if (_isTopLevel()) {
    if (containsCode(closingEntryCode)) {
      code.append(closingEntryCode);
    }
    if (containsCode(wrapupCode)) {
      code.append(wrapupProcedureName);
    }
    code.append(closingExitCode);
  }
  code.append(mainExitCode);
  codeTypesH.append(""String_Node_Str"");
  if (_executeCommands == null) {
    _executeCommands=new StreamExec();
  }
  startTime=_printTimeAndMemory(startTime,""String_Node_Str"");
  code=_finalPassOverCode(code);
  startTime=_printTimeAndMemory(startTime,""String_Node_Str"");
  super._writeCode(code);
  super._writeCodeFileName(codeMainH,""String_Node_Str"",true,false);
  super._writeCodeFileName(codeTypesH,""String_Node_Str"",true,false);
  super._writeCodeFileName(codeTypesC,""String_Node_Str"",true,false);
  if (director != null && director instanceof DEDirector) {
    _copyCFileTosrc(""String_Node_Str"");
    _copyCFileTosrc(""String_Node_Str"");
    _copyCFileTosrc(""String_Node_Str"");
    _copyCFileTosrc(""String_Node_Str"");
    _copyCFileTosrc(""String_Node_Str"");
    _copyCFileTosrc(""String_Node_Str"");
    _copyCFileTosrc(""String_Node_Str"");
    _copyCFileTosrc(""String_Node_Str"");
    _copyCFileTosrc(""String_Node_Str"");
    _copyCFileTosrc(""String_Node_Str"");
    _copyCFileTosrc(""String_Node_Str"");
    _copyCFileTosrc(""String_Node_Str"");
  }
  code=null;
  _printTimeAndMemory(startTime,""String_Node_Str"");
  _writeMakefile();
  _printTimeAndMemory(overallStartTime,""String_Node_Str"");
  return _executeCommands();
}"
72988,"/** 
 * Add a new event to the input queue. Compute the time when this input can be consumed and store in queue. The time depends on the device delay.
 * @param sourcePort the source port.
 * @param event New input event.
 * @param deviceDelay The device delay.
 * @exception IllegalActionException If device delay parameter cannot be computed.
 */
public void addInputEvent(PtidesPort sourcePort,PtidesEvent event,double deviceDelay) throws IllegalActionException {
  if (sourcePort.isNetworkReceiverPort()) {
    double networkDelayBound=PtidesDirector._getDoubleParameterValue(sourcePort,""String_Node_Str"");
    double sourcePlatformDelayBound=PtidesDirector._getDoubleParameterValue(sourcePort,""String_Node_Str"");
    double clockSynchronizationErrorBound=PtidesDirector._getDoubleParameterValue(sourcePort,""String_Node_Str"");
    if (localClock.getLocalTime().subtract(event.timeStamp()).getDoubleValue() > sourcePlatformDelayBound + networkDelayBound + clockSynchronizationErrorBound) {
      event=_handleTimingError(sourcePort,event,""String_Node_Str"" + ""String_Node_Str"" + localClock.getLocalTime() + ""String_Node_Str""+ event.timeStamp()+ ""String_Node_Str""+ sourcePlatformDelayBound+ ""String_Node_Str""+ networkDelayBound+ ""String_Node_Str"");
    }
  }
  if (event != null) {
    Time inputReady=getModelTime().add(deviceDelay);
    List<PtidesEvent> list=_inputEventQueue.get(inputReady);
    if (list == null) {
      list=new ArrayList<PtidesEvent>();
    }
    list.add(event);
    _inputEventQueue.put(inputReady,list);
  }
}","/** 
 * Add a new event to the input queue. Compute the time when this input can be consumed and store in queue. The time depends on the device delay.
 * @param sourcePort the source port.
 * @param event New input event.
 * @param deviceDelay The device delay.
 * @exception IllegalActionException If device delay parameter cannot be computed.
 */
public void addInputEvent(PtidesPort sourcePort,PtidesEvent event,double deviceDelay) throws IllegalActionException {
  if (sourcePort.isNetworkReceiverPort()) {
    double networkDelayBound=PtidesDirector._getDoubleParameterValue(sourcePort,""String_Node_Str"");
    double sourcePlatformDelayBound=PtidesDirector._getDoubleParameterValue(sourcePort,""String_Node_Str"");
    if (localClock.getLocalTime().subtract(event.timeStamp()).getDoubleValue() > sourcePlatformDelayBound + networkDelayBound + _clockSynchronizationErrorBound) {
      event=_handleTimingError(sourcePort,event,""String_Node_Str"" + ""String_Node_Str"" + localClock.getLocalTime() + ""String_Node_Str""+ event.timeStamp()+ ""String_Node_Str""+ sourcePlatformDelayBound+ ""String_Node_Str""+ networkDelayBound+ ""String_Node_Str"");
    }
  }
  if (event != null) {
    Time inputReady=getModelTime().add(deviceDelay);
    List<PtidesEvent> list=_inputEventQueue.get(inputReady);
    if (list == null) {
      list=new ArrayList<PtidesEvent>();
    }
    list.add(event);
    _inputEventQueue.put(inputReady,list);
  }
}"
72989,"public void printMetroEvent(Builder event){
  if (!_debugging) {
    return;
  }
  String buffer=""String_Node_Str"";
  if (event.hasTime()) {
    buffer=buffer.concat(""String_Node_Str"" + Long.toString(event.getTime()));
  }
  buffer=buffer.concat(""String_Node_Str"" + event.getStatus().toString());
  buffer=buffer.concat(""String_Node_Str"" + event.getName().toString());
  System.out.println(buffer);
}","public void printMetroEvent(Builder event){
  if (!_debugging) {
    return;
  }
  String buffer=""String_Node_Str"";
  if (event.hasTime()) {
    buffer=buffer.concat(""String_Node_Str"" + event.getTime());
  }
  buffer=buffer.concat(""String_Node_Str"" + event.getStatus().toString());
  buffer=buffer.concat(""String_Node_Str"" + event.getName().toString());
  System.out.println(buffer);
}"
72990,"@Override public void resolve(Iterable<Builder> metroIIEventList){
  _debugger.printTitle(""String_Node_Str"" + current_time);
  _debugger.printMetroEvents(metroIIEventList);
  long time=Long.MAX_VALUE;
  boolean hasEventWithoutTime=false;
  for (  Builder event : metroIIEventList) {
    if (event.getStatus() == Status.PROPOSED) {
      if (event.hasTime()) {
        if (event.getTime() < time) {
          time=event.getTime();
        }
      }
 else {
        hasEventWithoutTime=true;
      }
    }
  }
  if (hasEventWithoutTime) {
    for (    Builder event : metroIIEventList) {
      if (event.getStatus() == Status.PROPOSED) {
        if (event.hasTime()) {
          event.setStatus(Status.WAITING);
        }
      }
    }
  }
 else {
    for (    Builder event : metroIIEventList) {
      if (event.getStatus() == Status.PROPOSED) {
        if (event.hasTime()) {
          if (event.getTime() > time) {
            event.setStatus(Status.WAITING);
          }
        }
      }
    }
  }
  for (  Builder event : metroIIEventList) {
    if (event.getStatus() == Status.PROPOSED) {
      if (event.hasTime()) {
        if (current_time < event.getTime()) {
          current_time=event.getTime();
        }
      }
    }
  }
  for (  Builder event : metroIIEventList) {
    if (event.getStatus() == Status.PROPOSED) {
      if (!event.hasTime()) {
        event.setTime(current_time);
      }
    }
  }
  for (  Builder event : metroIIEventList) {
    if (event.getStatus() == Status.PROPOSED) {
      event.setStatus(Status.NOTIFIED);
    }
  }
  _debugger.printMetroEvents(metroIIEventList);
  _debugger.printTitle(""String_Node_Str"" + current_time);
}","@Override public void resolve(Iterable<Builder> metroIIEventList){
  _debugger.printTitle(""String_Node_Str"" + current_time);
  _debugger.printMetroEvents(metroIIEventList);
  long time=Long.MAX_VALUE;
  boolean hasEventWithoutTime=false;
  for (  Builder event : metroIIEventList) {
    if (event.getStatus() == Status.PROPOSED) {
      if (event.hasTime()) {
        if (event.getTime().getValue() < time) {
          time=event.getTime().getValue();
        }
      }
 else {
        hasEventWithoutTime=true;
      }
    }
  }
  if (hasEventWithoutTime) {
    for (    Builder event : metroIIEventList) {
      if (event.getStatus() == Status.PROPOSED) {
        if (event.hasTime()) {
          event.setStatus(Status.WAITING);
        }
      }
    }
  }
 else {
    for (    Builder event : metroIIEventList) {
      if (event.getStatus() == Status.PROPOSED) {
        if (event.hasTime()) {
          if (event.getTime().getValue() > time) {
            event.setStatus(Status.WAITING);
          }
        }
      }
    }
  }
  for (  Builder event : metroIIEventList) {
    if (event.getStatus() == Status.PROPOSED) {
      if (event.hasTime()) {
        if (current_time < event.getTime().getValue()) {
          current_time=event.getTime().getValue();
        }
      }
    }
  }
  for (  Builder event : metroIIEventList) {
    if (event.getStatus() == Status.PROPOSED) {
      if (!event.hasTime()) {
        Event.Time.Builder builder=Event.Time.newBuilder();
        builder.setValue(current_time);
        event.setTime(builder);
      }
    }
  }
  for (  Builder event : metroIIEventList) {
    if (event.getStatus() == Status.PROPOSED) {
      event.setStatus(Status.NOTIFIED);
    }
  }
  _debugger.printMetroEvents(metroIIEventList);
  _debugger.printTitle(""String_Node_Str"" + current_time);
}"
72991,"/** 
 * Clone the object into the specified workspace. The new object is <i>not</i> added to the directory of that workspace (you must do this yourself if you want it there).
 * @param workspace The workspace for the cloned object.
 * @exception CloneNotSupportedException Not thrown in this base class
 * @return The new Attribute.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  MetroIIDirector newObject=(MetroIIDirector)super.clone(workspace);
  newObject._mappingConstraintSolver=new MappingConstraintSolver();
  newObject._actorList=new LinkedList<StartOrResumable>();
  newObject._timeScheduler=new TimeScheduler();
  return newObject;
}","/** 
 * Clone the object into the specified workspace. The new object is <i>not</i> added to the directory of that workspace (you must do this yourself if you want it there).
 * @param workspace The workspace for the cloned object.
 * @exception CloneNotSupportedException Not thrown in this base class
 * @return The new Attribute.
 */
public Object clone(Workspace workspace) throws CloneNotSupportedException {
  MetroIIDirector newObject=(MetroIIDirector)super.clone(workspace);
  newObject._mappingConstraintSolver=new MappingConstraintSolver();
  newObject._actorList=new LinkedList<StartOrResumable>();
  newObject._timeScheduler=new TimeScheduler();
  newObject._debugger=new MetroDebugger();
  return newObject;
}"
72992,"public void getfire(ResultHandler<Iterable<Event.Builder>> resultHandler) throws CollectionAbortedException {
  FSMActor controller=null;
  try {
    controller=getController();
  }
 catch (  IllegalActionException e) {
    e.printStackTrace();
  }
  if (controller == null) {
  }
 else {
    State currentState=controller.currentState();
    if (_debugging) {
      _debug(""String_Node_Str"" + getFullName(),""String_Node_Str"" + getModelTime());
      _debug(""String_Node_Str"",currentState.getName());
    }
    Event.Builder eb;
    do {
      eb=makeEventBuilder(currentState.getFullName(),Event.Type.BEGIN,Event.Status.PROPOSED);
      events.add(eb);
      resultHandler.handleResult(events);
      events.remove(events.size() - 1);
    }
 while (eb.getStatus() != Event.Status.NOTIFIED);
    try {
      super.fire();
    }
 catch (    IllegalActionException e) {
      e.printStackTrace();
    }
  }
}","public void getfire(ResultHandler<Iterable<Event.Builder>> resultHandler) throws CollectionAbortedException {
  FSMActor controller=null;
  try {
    controller=getController();
  }
 catch (  IllegalActionException e) {
    e.printStackTrace();
  }
  if (controller == null) {
  }
 else {
    State currentState=controller.currentState();
    if (_debugging) {
      _debug(""String_Node_Str"" + getFullName(),""String_Node_Str"" + getModelTime());
      _debug(""String_Node_Str"",currentState.getName());
    }
    Event.Builder eb;
    do {
      eb=MetroEventBuilder.newProposedEvent(MetroEventBuilder.trimModelName(currentState.getFullName()),""String_Node_Str"");
      events.add(eb);
      resultHandler.handleResult(events);
      events.remove(events.size() - 1);
    }
 while (eb.getStatus() != Event.Status.NOTIFIED);
    try {
      super.fire();
    }
 catch (    IllegalActionException e) {
      e.printStackTrace();
    }
  }
}"
72993,"/** 
 * Return the MetroII event associated with the current state and  set the state of the event to be PROPOSED.
 * @return the MetroII event associated with the current state
 */
protected Builder proposeStateEvent(){
  Builder event=getStateEvent();
  event.setStatus(Status.PROPOSED);
  return event;
}","/** 
 * Return the MetroII event associated with the current state and  set the state of the event to be PROPOSED.
 * @return the MetroII event associated with the current state
 */
protected Builder proposeStateEvent(){
  Builder event=getStateEvent();
  event.setStatus(Status.PROPOSED);
  event.clearTime();
  return event;
}"
72994,"/** 
 * Return the MetroII event associated with the current state and  set the state of the event to be PROPOSED.
 * @return the MetroII event associated with the current state
 */
protected Builder proposeStateEvent(){
  Builder event=getStateEvent();
  event.setStatus(Status.PROPOSED);
  return event;
}","/** 
 * Return the MetroII event associated with the current state and  set the state of the event to be PROPOSED.
 * @return the MetroII event associated with the current state
 */
protected Builder proposeStateEvent(){
  Builder event=getStateEvent();
  event.setStatus(Status.PROPOSED);
  event.clearTime();
  return event;
}"
72995,"@Override public void resolve(Iterable<Builder> metroIIEventList){
  long time=Long.MAX_VALUE;
  boolean hasEventWithoutTime=false;
  for (  Builder event : metroIIEventList) {
    if (event.getStatus() == Status.NOTIFIED) {
      if (event.hasTime()) {
        if (event.getTime() < time) {
          time=event.getTime();
        }
        System.out.println(event.getName() + ""String_Node_Str"" + event.getTime());
      }
 else {
        hasEventWithoutTime=true;
      }
    }
  }
  System.out.println(""String_Node_Str"" + time);
  if (hasEventWithoutTime) {
    for (    Builder event : metroIIEventList) {
      if (event.getStatus() == Status.NOTIFIED) {
        if (event.hasTime()) {
          event.setStatus(Status.WAITING);
        }
      }
    }
  }
 else {
    for (    Builder event : metroIIEventList) {
      if (event.getStatus() == Status.NOTIFIED) {
        if (event.hasTime()) {
          if (event.getTime() > time) {
            event.setStatus(Status.WAITING);
          }
        }
      }
    }
  }
}","@Override public void resolve(Iterable<Builder> metroIIEventList){
  for (  Builder event : metroIIEventList) {
    if (event.getStatus() == Status.NOTIFIED) {
      if (event.hasTime()) {
        System.out.println(event.getTime() + ""String_Node_Str"" + event.getName());
      }
 else {
        System.out.println(current_time + ""String_Node_Str"" + event.getName());
      }
    }
  }
  long time=Long.MAX_VALUE;
  boolean hasEventWithoutTime=false;
  for (  Builder event : metroIIEventList) {
    if (event.getStatus() == Status.NOTIFIED) {
      if (event.hasTime()) {
        if (event.getTime() < time) {
          time=event.getTime();
        }
        System.out.println(event.getName() + ""String_Node_Str"" + event.getTime());
      }
 else {
        hasEventWithoutTime=true;
      }
    }
  }
  System.out.println(""String_Node_Str"" + (double)current_time / Double.valueOf(""String_Node_Str""));
  if (hasEventWithoutTime) {
    for (    Builder event : metroIIEventList) {
      if (event.getStatus() == Status.NOTIFIED) {
        if (event.hasTime()) {
          event.setStatus(Status.WAITING);
        }
      }
    }
  }
 else {
    for (    Builder event : metroIIEventList) {
      if (event.getStatus() == Status.NOTIFIED) {
        if (event.hasTime()) {
          if (event.getTime() > time) {
            event.setStatus(Status.WAITING);
          }
        }
      }
    }
  }
  for (  Builder event : metroIIEventList) {
    if (event.getStatus() == Status.NOTIFIED) {
      if (event.hasTime()) {
        System.out.println(event.getTime() + ""String_Node_Str"" + event.getName());
        if (current_time < event.getTime()) {
          current_time=event.getTime();
        }
      }
    }
  }
  for (  Builder event : metroIIEventList) {
    if (event.getStatus() == Status.NOTIFIED) {
      if (!event.hasTime()) {
        event.setTime(current_time);
        System.out.println(current_time + ""String_Node_Str"" + event.getName());
      }
    }
  }
}"
72996,"public TimeScheduler(){
}","public TimeScheduler(){
  current_time=0;
}"
72997,"public FireMachine(Actor actor){
  _actor=actor;
  reset();
}","public FireMachine(Actor actor){
  _actor=actor;
  _BeginEvent=_createMetroIIEvent(""String_Node_Str"");
  _ProcessEvent=_createMetroIIEvent(""String_Node_Str"");
  _EndEvent=_createMetroIIEvent(""String_Node_Str"");
  reset();
}"
72998,"/** 
 * Dispose the current execution.
 */
public void reset(){
  if (_iteration > 0) {
    setStatus(Status.BEGIN);
    _currentStateEvent=_createMetroIIEvent(""String_Node_Str"");
  }
 else {
    setStatus(Status.START);
    _currentStateEvent=null;
  }
}","/** 
 * Dispose the current execution.
 */
public void reset(){
  setState(State.START);
}"
72999,"/** 
 * Dispose the current execution.
 */
public void reset(){
  _state=State.PREFIRE_BEGIN;
  _currentStateEvent=_createMetroIIEvent(""String_Node_Str"");
}","/** 
 * Dispose the current execution.
 */
public void reset(){
  _state=ProcessState.PREFIRE_BEGIN;
  _currentStateEvent=_createMetroIIEvent(""String_Node_Str"");
}"
73000,"/** 
 * Stop and dispose any associated thread.
 */
@Override public void reset(){
  if (_state == State.FIRING) {
    _eventIterator.dispose();
    _actor.stop();
  }
  super.reset();
}","/** 
 * Stop and dispose any associated thread.
 */
@Override public void reset(){
  if (_state == ProcessState.FIRING) {
    _eventIterator.dispose();
    _actor.stop();
  }
  super.reset();
}"
