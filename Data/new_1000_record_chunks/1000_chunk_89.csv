record_number,buggy_code,fixed_code
88001,"/** 
 * Updates the binary representation of the data, such that it reflects the state of the currently stored fields. If the binary representation is already up to date, nothing happens. Otherwise, this function triggers the modified fields to serialize themselves into the records buffer and afterwards updates the offset table.
 */
public void updateBinaryRepresenation(){
  final int firstModified=this.firstModifiedPos;
  final int numFields=this.numFields;
  if (firstModified >= numFields) {
    return;
  }
  final int[] offsets=this.offsets;
  if (this.serializer == null) {
    this.serializer=new InternalDeSerializer();
  }
  final InternalDeSerializer serializer=this.serializer;
  int offset=firstModified <= 0 ? 0 : this.offsets[firstModified - 1] + this.lengths[firstModified - 1];
  serializer.position=offset;
  if (this.lastUnmodifiedPos < firstModified) {
    serializer.memory=this.binaryData == null ? new byte[numFields * DEFAULT_FIELD_LEN] : this.binaryData;
    try {
      for (int i=firstModified; i < numFields; i++) {
        if (offsets[i] == NULL_INDICATOR_OFFSET)         continue;
        offsets[i]=offset;
        this.fields[i].write(serializer);
        int newOffset=serializer.position;
        this.lengths[i]=newOffset - offset;
        offset=newOffset;
      }
    }
 catch (    Exception e) {
      throw new RuntimeException(""String_Node_Str"" + e.getMessage());
    }
  }
 else {
    serializer.memory=this.serializationSwitchBuffer == null ? new byte[numFields * DEFAULT_FIELD_LEN] : this.serializationSwitchBuffer;
    if (offset > 0 & this.binaryData != null) {
      System.arraycopy(this.binaryData,0,serializer.memory,0,offset);
    }
    try {
      for (int i=firstModified; i < numFields; i++) {
        final int co=offsets[i];
        if (co == NULL_INDICATOR_OFFSET)         continue;
        offsets[i]=offset;
        if (co == MODIFIED_INDICATOR_OFFSET)         this.fields[i].write(serializer);
 else         serializer.write(this.binaryData,co,this.lengths[i]);
        this.lengths[i]=serializer.position - offset;
        offset=serializer.position;
      }
    }
 catch (    Exception e) {
      throw new RuntimeException(""String_Node_Str"" + e.getMessage());
    }
    this.serializationSwitchBuffer=this.binaryData;
    this.binaryData=serializer.memory;
  }
  try {
    if (numFields <= 8) {
      int mask=0;
      for (int i=numFields - 1; i > 0; i--) {
        mask<<=1;
        if (offsets[i] != NULL_INDICATOR_OFFSET) {
          serializer.writeValLenIntBackwards(offsets[i]);
          mask|=0x1;
        }
      }
      mask<<=1;
      mask|=(offsets[0] != NULL_INDICATOR_OFFSET) ? 0x1 : 0x0;
      serializer.writeByte(mask);
    }
 else {
      for (int i=numFields - 1; i > 0; i--) {
        if (offsets[i] != NULL_INDICATOR_OFFSET) {
          serializer.writeValLenIntBackwards(offsets[i]);
        }
      }
      int col=numFields - 1;
      int mask=0;
      for (int i=numFields & 0x7; i >= 0; i--, col--) {
        mask<<=1;
        mask|=(offsets[col] != NULL_INDICATOR_OFFSET) ? 0x1 : 0x0;
      }
      serializer.writeByte(mask);
      for (int i=numFields >>> 3; i >= 0; i--) {
        mask=0;
        for (int k=0; k < 8; k++, col--) {
          mask<<=1;
          mask|=(offsets[col] != NULL_INDICATOR_OFFSET) ? 0x1 : 0x0;
        }
        serializer.writeByte(mask);
      }
    }
    serializer.writeValLenIntBackwards(numFields);
  }
 catch (  Exception e) {
    throw new RuntimeException(""String_Node_Str"" + e.getMessage(),e);
  }
  this.binaryData=serializer.memory;
  this.binaryLen=serializer.position;
  this.firstModifiedPos=Integer.MAX_VALUE;
  this.lastUnmodifiedPos=numFields - 1;
}","/** 
 * Updates the binary representation of the data, such that it reflects the state of the currently stored fields. If the binary representation is already up to date, nothing happens. Otherwise, this function triggers the modified fields to serialize themselves into the records buffer and afterwards updates the offset table.
 */
public void updateBinaryRepresenation(){
  if (!this.modified)   return;
  final int firstModified=this.firstModifiedPos;
  final int numFields=this.numFields;
  final int[] offsets=this.offsets;
  if (this.serializer == null) {
    this.serializer=new InternalDeSerializer();
  }
  final InternalDeSerializer serializer=this.serializer;
  if (numFields > 0) {
    int offset=firstModified <= 0 ? 0 : this.offsets[firstModified - 1] + this.lengths[firstModified - 1];
    serializer.position=offset;
    if (firstModified > 0) {
      serializer.memory=this.binaryData == null ? new byte[numFields * DEFAULT_FIELD_LEN] : this.binaryData;
      try {
        for (int i=firstModified; i < numFields; i++) {
          if (offsets[i] == NULL_INDICATOR_OFFSET)           continue;
          offsets[i]=offset;
          this.fields[i].write(serializer);
          int newOffset=serializer.position;
          this.lengths[i]=newOffset - offset;
          offset=newOffset;
        }
      }
 catch (      Exception e) {
        throw new RuntimeException(""String_Node_Str"" + e.getMessage());
      }
    }
 else {
      serializer.memory=this.serializationSwitchBuffer == null ? new byte[numFields * DEFAULT_FIELD_LEN] : this.serializationSwitchBuffer;
      if (offset > 0 & this.binaryData != null) {
        System.arraycopy(this.binaryData,0,serializer.memory,0,offset);
      }
      try {
        for (int i=firstModified; i < numFields; i++) {
          final int co=offsets[i];
          if (co == NULL_INDICATOR_OFFSET)           continue;
          offsets[i]=offset;
          if (co == MODIFIED_INDICATOR_OFFSET)           this.fields[i].write(serializer);
 else           serializer.write(this.binaryData,co,this.lengths[i]);
          this.lengths[i]=serializer.position - offset;
          offset=serializer.position;
        }
      }
 catch (      Exception e) {
        throw new RuntimeException(""String_Node_Str"" + e.getMessage());
      }
      this.serializationSwitchBuffer=this.binaryData;
      this.binaryData=serializer.memory;
    }
  }
  try {
    if (numFields <= 8) {
      int mask=0;
      for (int i=numFields - 1; i > 0; i--) {
        mask<<=1;
        if (offsets[i] != NULL_INDICATOR_OFFSET) {
          serializer.writeValLenIntBackwards(offsets[i]);
          mask|=0x1;
        }
      }
      mask<<=1;
      mask|=(offsets[0] != NULL_INDICATOR_OFFSET) ? 0x1 : 0x0;
      serializer.writeByte(mask);
    }
 else {
      for (int i=numFields - 1; i > 0; i--) {
        if (offsets[i] != NULL_INDICATOR_OFFSET) {
          serializer.writeValLenIntBackwards(offsets[i]);
        }
      }
      int col=numFields - 1;
      int mask=0;
      for (int i=numFields & 0x7; i >= 0; i--, col--) {
        mask<<=1;
        mask|=(offsets[col] != NULL_INDICATOR_OFFSET) ? 0x1 : 0x0;
      }
      serializer.writeByte(mask);
      for (int i=numFields >>> 3; i >= 0; i--) {
        mask=0;
        for (int k=0; k < 8; k++, col--) {
          mask<<=1;
          mask|=(offsets[col] != NULL_INDICATOR_OFFSET) ? 0x1 : 0x0;
        }
        serializer.writeByte(mask);
      }
    }
    serializer.writeValLenIntBackwards(numFields);
  }
 catch (  Exception e) {
    throw new RuntimeException(""String_Node_Str"" + e.getMessage(),e);
  }
  this.binaryData=serializer.memory;
  this.binaryLen=serializer.position;
  this.firstModifiedPos=Integer.MAX_VALUE;
  this.modified=false;
}"
88002,"/** 
 * @param target
 */
public void copyTo(PactRecord target){
  updateBinaryRepresenation();
  if (target.binaryData == null || target.binaryData.length < this.binaryLen) {
    target.binaryData=new byte[this.binaryLen];
  }
  if (target.offsets == null || target.offsets.length < this.numFields) {
    target.offsets=new int[this.numFields];
  }
  if (target.lengths == null || target.lengths.length < this.numFields) {
    target.lengths=new int[this.numFields];
  }
  if (target.fields == null || target.fields.length < this.numFields) {
    target.fields=new Value[this.numFields];
  }
  System.arraycopy(this.binaryData,0,target.binaryData,0,this.binaryLen);
  System.arraycopy(this.offsets,0,target.offsets,0,this.numFields);
  System.arraycopy(this.lengths,0,target.lengths,0,this.numFields);
  target.binaryLen=this.binaryLen;
  target.numFields=this.numFields;
  target.firstModifiedPos=Integer.MAX_VALUE;
  target.lastUnmodifiedPos=this.numFields - 1;
}","/** 
 * @param target
 */
public void copyTo(PactRecord target){
  updateBinaryRepresenation();
  if (target.binaryData == null || target.binaryData.length < this.binaryLen) {
    target.binaryData=new byte[this.binaryLen];
  }
  if (target.offsets == null || target.offsets.length < this.numFields) {
    target.offsets=new int[this.numFields];
  }
  if (target.lengths == null || target.lengths.length < this.numFields) {
    target.lengths=new int[this.numFields];
  }
  if (target.fields == null || target.fields.length < this.numFields) {
    target.fields=new Value[this.numFields];
  }
  System.arraycopy(this.binaryData,0,target.binaryData,0,this.binaryLen);
  System.arraycopy(this.offsets,0,target.offsets,0,this.numFields);
  System.arraycopy(this.lengths,0,target.lengths,0,this.numFields);
  target.binaryLen=this.binaryLen;
  target.numFields=this.numFields;
  target.firstModifiedPos=Integer.MAX_VALUE;
  target.modified=false;
}"
88003,"/** 
 * Sets the number of fields in the record. If the new number of fields is longer than the current number of fields, then null fields are appended. If the new number of fields is smaller than the current number of fields, then the last fields are truncated.
 * @param numFields The new number of fields.
 */
public void setNumFields(final int numFields){
  final int oldNumFields=this.numFields;
  if (numFields > oldNumFields) {
    makeSpace(numFields);
    for (int i=oldNumFields; i < numFields; i++) {
      this.offsets[i]=NULL_INDICATOR_OFFSET;
    }
  }
 else {
    if (this.lastUnmodifiedPos >= numFields)     this.lastUnmodifiedPos=numFields - 1;
    markModified(numFields);
  }
  this.numFields=numFields;
}","/** 
 * Sets the number of fields in the record. If the new number of fields is longer than the current number of fields, then null fields are appended. If the new number of fields is smaller than the current number of fields, then the last fields are truncated.
 * @param numFields The new number of fields.
 */
public void setNumFields(final int numFields){
  final int oldNumFields=this.numFields;
  if (numFields > oldNumFields) {
    makeSpace(numFields);
    for (int i=oldNumFields; i < numFields; i++) {
      this.offsets[i]=NULL_INDICATOR_OFFSET;
    }
  }
 else {
    markModified(numFields);
  }
  this.numFields=numFields;
}"
88004,"/** 
 * Clears the record. After this operation, the record will have zero fields.
 */
public void clear(){
  this.numFields=0;
  this.lastUnmodifiedPos=-1;
  this.firstModifiedPos=Integer.MAX_VALUE;
}","/** 
 * Clears the record. After this operation, the record will have zero fields.
 */
public void clear(){
  if (this.numFields > 0) {
    this.numFields=0;
    this.firstModifiedPos=Integer.MAX_VALUE;
    this.modified=true;
  }
}"
88005,"private final void markModified(int field){
  if (this.firstModifiedPos > field) {
    this.firstModifiedPos=field;
  }
  if (field == this.lastUnmodifiedPos) {
    this.lastUnmodifiedPos--;
  }
}","private final void markModified(int field){
  if (this.firstModifiedPos > field) {
    this.firstModifiedPos=field;
  }
  this.modified=true;
}"
88006,"private final void initFields(byte[] data,int begin,int len){
  int pos=begin + len - 2;
  int numFields=data[begin + len - 1];
  if (numFields >= MAX_BIT) {
    int shift=7;
    int curr;
    numFields=numFields & 0x7f;
    while ((curr=data[pos--]) >= MAX_BIT) {
      numFields|=(curr & 0x7f) << shift;
      shift+=7;
    }
    numFields|=curr << shift;
  }
  this.numFields=numFields;
  if (this.offsets == null || this.offsets.length < numFields) {
    this.offsets=new int[numFields];
  }
  if (this.fields == null || this.fields.length < numFields) {
    this.fields=new Value[numFields];
  }
  if (this.lengths == null || this.lengths.length < numFields) {
    this.lengths=new int[numFields];
  }
  final int beginMasks=pos;
  final int fieldsBy8=(numFields >>> 3) + ((numFields & 0x7) == 0 ? 0 : 1);
  pos=beginMasks - fieldsBy8;
  int lastNonNullField=-1;
  for (int field=0, chunk=0; chunk < fieldsBy8; chunk++) {
    int mask=data[beginMasks - chunk];
    for (int i=0; i < 8 && field < numFields; i++, field++) {
      if ((mask & 0x1) == 0x1) {
        if (lastNonNullField >= 0) {
          int start=data[pos--];
          if (start >= MAX_BIT) {
            int shift=7;
            int curr;
            start=start & 0x7f;
            while ((curr=data[pos--]) >= MAX_BIT) {
              start|=(curr & 0x7f) << shift;
              shift+=7;
            }
            start|=curr << shift;
          }
          this.offsets[field]=start + begin;
          this.lengths[lastNonNullField]=start + begin - this.offsets[lastNonNullField];
        }
 else {
          this.offsets[field]=begin;
        }
        lastNonNullField=field;
      }
 else {
        this.offsets[field]=NULL_INDICATOR_OFFSET;
      }
      mask>>=1;
    }
  }
  if (lastNonNullField >= 0) {
    this.lengths[lastNonNullField]=pos - this.offsets[lastNonNullField] + 1;
  }
  this.firstModifiedPos=Integer.MAX_VALUE;
  this.lastUnmodifiedPos=numFields - 1;
}","private final void initFields(byte[] data,int begin,int len){
  int pos=begin + len - 2;
  int numFields=data[begin + len - 1];
  if (numFields >= MAX_BIT) {
    int shift=7;
    int curr;
    numFields=numFields & 0x7f;
    while ((curr=data[pos--]) >= MAX_BIT) {
      numFields|=(curr & 0x7f) << shift;
      shift+=7;
    }
    numFields|=curr << shift;
  }
  this.numFields=numFields;
  if (this.offsets == null || this.offsets.length < numFields) {
    this.offsets=new int[numFields];
  }
  if (this.fields == null || this.fields.length < numFields) {
    this.fields=new Value[numFields];
  }
  if (this.lengths == null || this.lengths.length < numFields) {
    this.lengths=new int[numFields];
  }
  final int beginMasks=pos;
  final int fieldsBy8=(numFields >>> 3) + ((numFields & 0x7) == 0 ? 0 : 1);
  pos=beginMasks - fieldsBy8;
  int lastNonNullField=-1;
  for (int field=0, chunk=0; chunk < fieldsBy8; chunk++) {
    int mask=data[beginMasks - chunk];
    for (int i=0; i < 8 && field < numFields; i++, field++) {
      if ((mask & 0x1) == 0x1) {
        if (lastNonNullField >= 0) {
          int start=data[pos--];
          if (start >= MAX_BIT) {
            int shift=7;
            int curr;
            start=start & 0x7f;
            while ((curr=data[pos--]) >= MAX_BIT) {
              start|=(curr & 0x7f) << shift;
              shift+=7;
            }
            start|=curr << shift;
          }
          this.offsets[field]=start + begin;
          this.lengths[lastNonNullField]=start + begin - this.offsets[lastNonNullField];
        }
 else {
          this.offsets[field]=begin;
        }
        lastNonNullField=field;
      }
 else {
        this.offsets[field]=NULL_INDICATOR_OFFSET;
      }
      mask>>=1;
    }
  }
  if (lastNonNullField >= 0) {
    this.lengths[lastNonNullField]=pos - this.offsets[lastNonNullField] + 1;
  }
  this.firstModifiedPos=Integer.MAX_VALUE;
  this.modified=false;
}"
88007,"private List<ExecutionVertex> findFollowers(ExecutionVertex vertex,ArrayList<ExecutionVertex> restart){
  ArrayList<ExecutionVertex> follower=new ArrayList<ExecutionVertex>();
  for (int i=0; i < vertex.getNumberOfSuccessors(); i++) {
    ExecutionVertex successor=vertex.getSuccessor(i);
    if (!restart.contains(successor)) {
      follower.add(successor);
      if (successor.getCheckpointState() == CheckpointState.PARTIAL) {
        this.checkpoints.remove(successor);
        final List<ExecutionVertexID> checkpointsToRemove=new ArrayList<ExecutionVertexID>();
        checkpointsToRemove.add(successor.getID());
        try {
          successor.getAllocatedResource().getInstance().removeCheckpoints(checkpointsToRemove);
        }
 catch (        IOException e) {
          e.printStackTrace();
        }
      }
    }
  }
  return follower;
}","private List<ExecutionVertex> findFollowers(ExecutionVertex vertex,ArrayList<ExecutionVertex> restart){
  ArrayList<ExecutionVertex> follower=new ArrayList<ExecutionVertex>();
  for (int i=0; i < vertex.getNumberOfSuccessors(); i++) {
    ExecutionVertex successor=vertex.getSuccessor(i);
    if (!restart.contains(successor)) {
      follower.add(successor);
      if (successor.getCheckpointState() == CheckpointState.PARTIAL) {
        this.checkpoints.remove(successor);
        this.globalConsistentCheckpoint.remove(successor.getID());
        final SerializableArrayList<ExecutionVertexID> checkpointsToRemove=new SerializableArrayList<ExecutionVertexID>();
        checkpointsToRemove.add(successor.getID());
        try {
          successor.getAllocatedResource().getInstance().removeCheckpoints(checkpointsToRemove);
        }
 catch (        IOException e) {
          e.printStackTrace();
        }
      }
    }
  }
  return follower;
}"
88008,"/** 
 * {@inheritDoc}
 */
@Override public void run(){
  if (this.failedVertices.isEmpty()) {
    LOG.error(""String_Node_Str"");
  }
  Iterator<ExecutionVertex> vertexIter=this.failedVertices.iterator();
  while (vertexIter.hasNext()) {
    ExecutionVertex failed=vertexIter.next();
    LOG.info(""String_Node_Str"" + failed);
    List<ExecutionVertex> restart=findRestarts(failed);
    Iterator<ExecutionVertex> restartIterator=restart.iterator();
    while (restartIterator.hasNext()) {
      ExecutionVertex vertex=restartIterator.next();
      if (!vertex.equals(failed)) {
        LOG.info(""String_Node_Str"" + vertex.getName());
        final List<ExecutionVertexID> checkpointsToReplay=new ArrayList<ExecutionVertexID>();
        checkpointsToReplay.add(vertex.getID());
        try {
          vertex.getAllocatedResource().getInstance().replayCheckpoints(checkpointsToReplay);
        }
 catch (        Exception e) {
          LOG.info(""String_Node_Str"" + StringUtils.stringifyException(e) + ""String_Node_Str"");
        }
      }
    }
    LOG.info(""String_Node_Str"" + failed);
  }
  this.job.executionStateChanged(this.job.getJobID(),null,ExecutionState.RERUNNING,null);
  LOG.info(""String_Node_Str"");
}","/** 
 * {@inheritDoc}
 */
@Override public void run(){
  if (this.failedVertices.isEmpty()) {
    LOG.error(""String_Node_Str"");
  }
  List<CheckpointReplayResult> replayCheckpoints=new ArrayList();
  Iterator<ExecutionVertex> vertexIter=this.failedVertices.iterator();
  while (vertexIter.hasNext()) {
    ExecutionVertex failed=vertexIter.next();
    LOG.info(""String_Node_Str"" + failed);
    findRestarts(failed);
    Iterator<ExecutionVertexID> checkpointIterator=this.globalConsistentCheckpoint.iterator();
    while (checkpointIterator.hasNext()) {
      ExecutionVertexID checkpoint=checkpointIterator.next();
      AbstractInstance instance=job.getVertexByID(checkpoint).getAllocatedResource().getInstance();
      try {
        replayCheckpoints.addAll(instance.replayCheckpoints(this.globalConsistentCheckpoint));
      }
 catch (      IOException e) {
        e.printStackTrace();
      }
    }
  }
  for (  CheckpointReplayResult replayResult : replayCheckpoints) {
    if (replayResult.getReturnCode() == ReturnCode.ERROR) {
      LOG.info(""String_Node_Str"" + replayResult.getDescription());
      return;
    }
  }
  this.job.executionStateChanged(this.job.getJobID(),null,ExecutionState.RERUNNING,null);
  LOG.info(""String_Node_Str"");
}"
88009,"/** 
 * @param failed
 * @return
 */
private List<ExecutionVertex> findRestarts(ExecutionVertex failed){
  LOG.info(""String_Node_Str"");
  ArrayList<ExecutionVertex> restart=new ArrayList<ExecutionVertex>();
  Queue<ExecutionVertex> totest=new ArrayDeque<ExecutionVertex>();
  ArrayList<ExecutionVertex> visited=new ArrayList<ExecutionVertex>();
  totest.add(failed);
  int k=0;
  LOG.info(""String_Node_Str"");
  ExecutionVertex vertex=failed;
  while (!totest.isEmpty()) {
    LOG.info(""String_Node_Str"");
    if (k != 0) {
      vertex=totest.peek();
    }
    LOG.info(""String_Node_Str"" + vertex.getName());
    k++;
    totest.remove(vertex);
    if (!restart.contains(vertex)) {
      restart.add(vertex);
    }
    for (int i=0; i < vertex.getNumberOfSuccessors(); i++) {
      ExecutionVertex successor=vertex.getSuccessor(i);
      restart.add(successor);
      LOG.info(""String_Node_Str"" + successor.getName() + ""String_Node_Str"");
      if (successor.getCheckpointState() == CheckpointState.PARTIAL) {
        this.checkpoints.remove(successor);
      }
      List<ExecutionVertex> follower=findFollowers(successor,restart);
      restart.addAll(follower);
      Iterator<ExecutionVertex> iter=follower.iterator();
      while (iter.hasNext()) {
        ExecutionVertex follow=iter.next();
        if (!visited.contains(follow)) {
          LOG.info(""String_Node_Str"" + follow.getName());
          totest.add(follow);
        }
      }
    }
    for (int j=0; j < vertex.getNumberOfPredecessors(); j++) {
      ExecutionVertex predecessor=vertex.getPredecessor(j);
      if (predecessor.getCheckpointState() != CheckpointState.PARTIAL) {
        LOG.info(""String_Node_Str"" + predecessor.getName() + ""String_Node_Str"");
        restart.add(predecessor);
        if (!visited.contains(predecessor)) {
          totest.add(predecessor);
          LOG.info(""String_Node_Str"" + predecessor);
        }
      }
 else {
        if (!this.globalConsistentCheckpoint.contains(predecessor)) {
          this.globalConsistentCheckpoint.add(predecessor);
        }
        List<ExecutionVertex> follower=findFollowers(predecessor,restart);
        for (int i=0; i < follower.size(); i++) {
          LOG.info(""String_Node_Str"" + follower.get(i) + ""String_Node_Str"");
        }
        restart.addAll(follower);
        Iterator<ExecutionVertex> iter=follower.iterator();
        while (iter.hasNext()) {
          ExecutionVertex follow=iter.next();
          if (!visited.contains(follow)) {
            LOG.info(""String_Node_Str"" + follow.getName());
            totest.add(follow);
          }
        }
      }
    }
    visited.add(vertex);
  }
  LOG.info(""String_Node_Str"");
  return restart;
}","/** 
 * @param failed
 * @return
 */
private List<ExecutionVertex> findRestarts(ExecutionVertex failed){
  ArrayList<ExecutionVertex> restart=new ArrayList<ExecutionVertex>();
  Queue<ExecutionVertex> totest=new ArrayDeque<ExecutionVertex>();
  ArrayList<ExecutionVertex> visited=new ArrayList<ExecutionVertex>();
  totest.add(failed);
  ExecutionVertex vertex=failed;
  while (!totest.isEmpty()) {
    vertex=totest.peek();
    totest.remove(vertex);
    if (!restart.contains(vertex)) {
      restart.add(vertex);
    }
    for (int i=0; i < vertex.getNumberOfSuccessors(); i++) {
      ExecutionVertex successor=vertex.getSuccessor(i);
      restart.add(successor);
      if (successor.getCheckpointState() == CheckpointState.PARTIAL) {
        this.checkpoints.remove(successor);
        this.globalConsistentCheckpoint.remove(successor.getID());
      }
      List<ExecutionVertex> follower=findFollowers(successor,restart);
      restart.addAll(follower);
      Iterator<ExecutionVertex> iter=follower.iterator();
      while (iter.hasNext()) {
        ExecutionVertex follow=iter.next();
        if (!visited.contains(follow)) {
          totest.add(follow);
        }
      }
    }
    for (int j=0; j < vertex.getNumberOfPredecessors(); j++) {
      ExecutionVertex predecessor=vertex.getPredecessor(j);
      if (predecessor.getCheckpointState() != CheckpointState.PARTIAL) {
        restart.add(predecessor);
        if (!visited.contains(predecessor)) {
          totest.add(predecessor);
        }
      }
 else {
        if (!this.globalConsistentCheckpoint.contains(predecessor.getID())) {
          this.globalConsistentCheckpoint.add(predecessor.getID());
        }
        List<ExecutionVertex> follower=findFollowers(predecessor,restart);
        for (int i=0; i < follower.size(); i++) {
          LOG.info(""String_Node_Str"" + follower.get(i) + ""String_Node_Str"");
        }
        restart.addAll(follower);
        Iterator<ExecutionVertex> iter=follower.iterator();
        while (iter.hasNext()) {
          ExecutionVertex follow=iter.next();
          if (!visited.contains(follow)) {
            LOG.info(""String_Node_Str"" + follow.getName());
            totest.add(follow);
          }
        }
      }
    }
    visited.add(vertex);
  }
  LOG.info(""String_Node_Str"");
  return restart;
}"
88010,"void executionStateChanged(final JobID jobID,final ExecutionVertexID id,final Task task,final ExecutionState newExecutionState,final String optionalDescription){
  if (newExecutionState == ExecutionState.RUNNING || newExecutionState == ExecutionState.RUNNING) {
synchronized (this.runningTasks) {
      this.runningTasks.put(id,task);
    }
  }
  if (newExecutionState == ExecutionState.FINISHED || newExecutionState == ExecutionState.CANCELED) {
synchronized (this.runningTasks) {
      this.runningTasks.remove(id);
    }
    unregisterTask(id,task);
  }
synchronized (this.jobManager) {
    try {
      this.jobManager.updateTaskExecutionState(new TaskExecutionState(jobID,id,newExecutionState,optionalDescription));
    }
 catch (    IOException e) {
      LOG.error(StringUtils.stringifyException(e));
    }
  }
}","void executionStateChanged(final JobID jobID,final ExecutionVertexID id,final Task task,final ExecutionState newExecutionState,final String optionalDescription){
  if (newExecutionState == ExecutionState.RUNNING || newExecutionState == ExecutionState.RUNNING) {
synchronized (this.runningTasks) {
      this.runningTasks.put(id,task);
    }
  }
  if (newExecutionState == ExecutionState.FINISHED || newExecutionState == ExecutionState.CANCELED) {
synchronized (this.runningTasks) {
      this.runningTasks.remove(id);
    }
    unregisterTask(id,task);
  }
  if (newExecutionState == ExecutionState.FAILED) {
    this.runningTasks.remove(id);
  }
synchronized (this.jobManager) {
    try {
      this.jobManager.updateTaskExecutionState(new TaskExecutionState(jobID,id,newExecutionState,optionalDescription));
    }
 catch (    IOException e) {
      LOG.error(StringUtils.stringifyException(e));
    }
  }
}"
88011,"/** 
 * {@inheritDoc}
 */
@Override public List<CheckpointReplayResult> replayCheckpoints(final List<ExecutionVertexID> vertexIDs) throws IOException {
  final List<CheckpointReplayResult> checkpointResultList=new SerializableArrayList<CheckpointReplayResult>();
  for (  final ExecutionVertexID vertexID : vertexIDs) {
    if (!this.checkpointManager.hasCompleteCheckpointAvailable(vertexID)) {
      if (this.checkpointManager.hasPartialCheckpointAvailable(vertexID)) {
synchronized (this.runningTasks) {
          if (!this.runningTasks.containsKey(vertexID)) {
            final CheckpointReplayResult result=new CheckpointReplayResult(vertexID,ReturnCode.ERROR);
            result.setDescription(""String_Node_Str"");
            checkpointResultList.add(result);
            continue;
          }
        }
      }
 else {
        final CheckpointReplayResult result=new CheckpointReplayResult(vertexID,ReturnCode.ERROR);
        result.setDescription(""String_Node_Str"");
        checkpointResultList.add(result);
        continue;
      }
    }
    this.checkpointManager.replayCheckpoint(vertexID);
    checkpointResultList.add(new CheckpointReplayResult(vertexID,ReturnCode.SUCCESS));
  }
  return checkpointResultList;
}","/** 
 * {@inheritDoc}
 */
@Override public SerializableArrayList<CheckpointReplayResult> replayCheckpoints(final List<ExecutionVertexID> vertexIDs) throws IOException {
  final SerializableArrayList<CheckpointReplayResult> checkpointResultList=new SerializableArrayList<CheckpointReplayResult>();
  for (  final ExecutionVertexID vertexID : vertexIDs) {
    if (!this.checkpointManager.hasCompleteCheckpointAvailable(vertexID)) {
      if (this.checkpointManager.hasPartialCheckpointAvailable(vertexID)) {
synchronized (this.runningTasks) {
          if (!this.runningTasks.containsKey(vertexID)) {
            final CheckpointReplayResult result=new CheckpointReplayResult(vertexID,ReturnCode.ERROR);
            result.setDescription(""String_Node_Str"");
            checkpointResultList.add(result);
            continue;
          }
        }
      }
 else {
        final CheckpointReplayResult result=new CheckpointReplayResult(vertexID,ReturnCode.ERROR);
        result.setDescription(""String_Node_Str"");
        checkpointResultList.add(result);
        continue;
      }
    }
    this.checkpointManager.replayCheckpoint(vertexID);
    checkpointResultList.add(new CheckpointReplayResult(vertexID,ReturnCode.SUCCESS));
  }
  return checkpointResultList;
}"
88012,"/** 
 * {@inheritDoc}
 */
@Override public void processEnvelopeFromInputChannel(final TransferEnvelope transferEnvelope) throws IOException, InterruptedException {
  System.out.println(""String_Node_Str"");
  processEnvelope(transferEnvelope,false);
}","/** 
 * {@inheritDoc}
 */
@Override public void processEnvelopeFromInputChannel(final TransferEnvelope transferEnvelope) throws IOException, InterruptedException {
  processEnvelope(transferEnvelope,false);
}"
88013,"private boolean processEnvelopeEnvelopeWithoutBuffer(final TransferEnvelope transferEnvelope,final TransferEnvelopeReceiverList receiverList){
  System.out.println(""String_Node_Str"" + transferEnvelope.getEventList().size());
  final Iterator<ChannelID> localIt=receiverList.getLocalReceivers().iterator();
  while (localIt.hasNext()) {
    final ChannelID localReceiver=localIt.next();
    final ChannelContext channelContext=this.registeredChannels.get(localReceiver);
    if (channelContext == null) {
      if (LOG.isDebugEnabled()) {
        LOG.debug(""String_Node_Str"" + localReceiver + ""String_Node_Str""+ transferEnvelope.getJobID());
      }
      continue;
    }
    channelContext.queueTransferEnvelope(transferEnvelope);
  }
  final Iterator<InetSocketAddress> remoteIt=receiverList.getRemoteReceivers().iterator();
  while (remoteIt.hasNext()) {
    final InetSocketAddress remoteReceiver=remoteIt.next();
    this.networkConnectionManager.queueEnvelopeForTransfer(remoteReceiver,transferEnvelope);
  }
  return true;
}","private boolean processEnvelopeEnvelopeWithoutBuffer(final TransferEnvelope transferEnvelope,final TransferEnvelopeReceiverList receiverList){
  final Iterator<ChannelID> localIt=receiverList.getLocalReceivers().iterator();
  while (localIt.hasNext()) {
    final ChannelID localReceiver=localIt.next();
    final ChannelContext channelContext=this.registeredChannels.get(localReceiver);
    if (channelContext == null) {
      if (LOG.isDebugEnabled()) {
        LOG.debug(""String_Node_Str"" + localReceiver + ""String_Node_Str""+ transferEnvelope.getJobID());
      }
      continue;
    }
    channelContext.queueTransferEnvelope(transferEnvelope);
  }
  final Iterator<InetSocketAddress> remoteIt=receiverList.getRemoteReceivers().iterator();
  while (remoteIt.hasNext()) {
    final InetSocketAddress remoteReceiver=remoteIt.next();
    this.networkConnectionManager.queueEnvelopeForTransfer(remoteReceiver,transferEnvelope);
  }
  return true;
}"
88014,"@Override public void copyNormalizedKey(byte[] target,int offset,int len){
  if (len == 4) {
    target[offset]=(byte)((value >>> 24) & 0xff);
    target[offset + 1]=(byte)((value >>> 16) & 0xff);
    target[offset + 2]=(byte)((value >>> 8) & 0xff);
    target[offset + 3]=(byte)((value) & 0xff);
  }
 else   if (len < 4) {
    for (int i=0; len > 0; len--, i++) {
      target[offset + i]=(byte)((value >>> ((3 - i) << 3)) & 0xff);
    }
  }
 else {
    target[offset]=(byte)((value >>> 24) & 0xff);
    target[offset + 1]=(byte)((value >>> 16) & 0xff);
    target[offset + 2]=(byte)((value >>> 8) & 0xff);
    target[offset + 3]=(byte)((value) & 0xff);
    for (int i=4; i < len; i++) {
      target[offset + i]=0;
    }
  }
}","@Override public void copyNormalizedKey(byte[] target,int offset,int len){
  if (len == 4) {
    int highByte=((value >>> 24) & 0xff);
    highByte-=Byte.MIN_VALUE;
    target[offset]=(byte)highByte;
    target[offset + 1]=(byte)((value >>> 16) & 0xff);
    target[offset + 2]=(byte)((value >>> 8) & 0xff);
    target[offset + 3]=(byte)((value) & 0xff);
  }
 else   if (len <= 0) {
  }
 else   if (len < 4) {
    int highByte=((value >>> 24) & 0xff);
    highByte-=Byte.MIN_VALUE;
    target[offset]=(byte)highByte;
    len--;
    for (int i=1; len > 0; len--, i++) {
      target[offset + i]=(byte)((value >>> ((3 - i) << 3)) & 0xff);
    }
  }
 else {
    int highByte=((value >>> 24) & 0xff);
    highByte-=Byte.MIN_VALUE;
    target[offset]=(byte)highByte;
    target[offset + 1]=(byte)((value >>> 16) & 0xff);
    target[offset + 2]=(byte)((value >>> 8) & 0xff);
    target[offset + 3]=(byte)((value) & 0xff);
    for (int i=4; i < len; i++) {
      target[offset + i]=0;
    }
  }
}"
88015,"@Override public void copyNormalizedKey(byte[] target,int offset,int len){
  if (len == 8) {
    target[offset]=(byte)(value >>> 56);
    target[offset + 1]=(byte)(value >>> 48);
    target[offset + 2]=(byte)(value >>> 40);
    target[offset + 3]=(byte)(value >>> 32);
    target[offset + 4]=(byte)(value >>> 24);
    target[offset + 5]=(byte)(value >>> 16);
    target[offset + 6]=(byte)(value >>> 8);
    target[offset + 7]=(byte)(value);
  }
 else   if (len < 8) {
    for (int i=0; len > 0; len--, i++) {
      target[offset + i]=(byte)(value >>> ((7 - i) << 3));
    }
  }
 else {
    target[offset]=(byte)(value >>> 56);
    target[offset + 1]=(byte)(value >>> 48);
    target[offset + 2]=(byte)(value >>> 40);
    target[offset + 3]=(byte)(value >>> 32);
    target[offset + 4]=(byte)(value >>> 24);
    target[offset + 5]=(byte)(value >>> 16);
    target[offset + 6]=(byte)(value >>> 8);
    target[offset + 7]=(byte)(value);
    for (int i=8; i < len; i++) {
      target[offset + i]=0;
    }
  }
}","@Override public void copyNormalizedKey(byte[] target,int offset,int len){
  if (len == 8) {
    long highByte=((value >>> 56) & 0xff);
    highByte-=Byte.MIN_VALUE;
    target[offset]=(byte)highByte;
    target[offset + 1]=(byte)(value >>> 48);
    target[offset + 2]=(byte)(value >>> 40);
    target[offset + 3]=(byte)(value >>> 32);
    target[offset + 4]=(byte)(value >>> 24);
    target[offset + 5]=(byte)(value >>> 16);
    target[offset + 6]=(byte)(value >>> 8);
    target[offset + 7]=(byte)(value);
  }
 else   if (len <= 0) {
  }
 else   if (len < 8) {
    long highByte=((value >>> 56) & 0xff);
    highByte-=Byte.MIN_VALUE;
    target[offset]=(byte)highByte;
    len--;
    for (int i=1; len > 0; len--, i++) {
      target[offset + i]=(byte)(value >>> ((7 - i) << 3));
    }
  }
 else {
    long highByte=((value >>> 56) & 0xff);
    highByte-=Byte.MIN_VALUE;
    target[offset]=(byte)highByte;
    target[offset + 1]=(byte)(value >>> 48);
    target[offset + 2]=(byte)(value >>> 40);
    target[offset + 3]=(byte)(value >>> 32);
    target[offset + 4]=(byte)(value >>> 24);
    target[offset + 5]=(byte)(value >>> 16);
    target[offset + 6]=(byte)(value >>> 8);
    target[offset + 7]=(byte)(value);
    for (int i=8; i < len; i++) {
      target[offset + i]=0;
    }
  }
}"
88016,"/** 
 * Returns this PactString's internal character data.
 * @return The character data.
 */
public char[] getChars(){
  return this.value;
}","/** 
 * Returns this PactString's internal character data. The array might be larger than the string which is currently stored in the PactString.
 * @return The character data.
 */
public char[] getChars(){
  return this.value;
}"
88017,"@Override public char charAt(int index){
  return this.value[index];
}","@Override public char charAt(int index){
  if (index < len) {
    return this.value[index];
  }
 else {
    throw new IndexOutOfBoundsException();
  }
}"
88018,"@Test public void testPactNull(){
  final PactNull pn1=new PactNull();
  final PactNull pn2=new PactNull();
  assertNormalizableKey(pn1,pn2,0);
  final PactNull pn=new PactNull();
  try {
    pn.write(mOut);
    pn.read(mIn);
    assertNormalizableKey(pn,pn1,0);
  }
 catch (  IOException ioex) {
    Assert.fail(""String_Node_Str"" + ioex.getMessage());
  }
}","@Test public void testPactNull(){
  final PactNull pn1=new PactNull();
  final PactNull pn2=new PactNull();
  assertNormalizableKey(pn1,pn2,0);
}"
88019,"@Test public void testPactString(){
  PactString string0=new PactString(""String_Node_Str"");
  PactString string1=new PactString(""String_Node_Str"");
  PactString string2=new PactString(""String_Node_Str"");
  PactString string3=new PactString(""String_Node_Str"");
  PactString string4=new PactString(""String_Node_Str"");
  for (int length=5; length <= 15; length+=10) {
    assertNormalizableKey(string0,string1,length);
    assertNormalizableKey(string0,string2,length);
    assertNormalizableKey(string0,string3,length);
    assertNormalizableKey(string0,string4,length);
  }
  try {
    string0.write(mOut);
    string4.write(mOut);
    string2.write(mOut);
    string3.write(mOut);
    PactString string1n=new PactString();
    PactString string2n=new PactString();
    PactString string3n=new PactString();
    PactString string4n=new PactString();
    string1n.read(mIn);
    string4n.read(mIn);
    string2n.read(mIn);
    string3n.read(mIn);
    for (int length=5; length <= 15; length+=10) {
      assertNormalizableKey(string0,string1n,length);
      assertNormalizableKey(string0,string2n,length);
      assertNormalizableKey(string0,string3n,length);
      assertNormalizableKey(string0,string4n,length);
    }
    string2.setValue(""String_Node_Str"");
    assertNormalizableKey(string2,string3,32);
  }
 catch (  Exception e) {
    Assert.assertTrue(false);
  }
}","@Test public void testPactString(){
  PactString string0=new PactString(""String_Node_Str"");
  PactString string1=new PactString(""String_Node_Str"");
  PactString string2=new PactString(""String_Node_Str"");
  PactString string3=new PactString(""String_Node_Str"");
  PactString string4=new PactString(""String_Node_Str"");
  for (int length=5; length <= 15; length+=10) {
    assertNormalizableKey(string0,string1,length);
    assertNormalizableKey(string0,string2,length);
    assertNormalizableKey(string0,string3,length);
    assertNormalizableKey(string0,string4,length);
  }
}"
88020,"@Test public void testPactInteger(){
  PactInteger int0=new PactInteger(10);
  Assert.assertEquals(10,int0.getValue());
  PactInteger int1=new PactInteger(10);
  PactInteger int2=new PactInteger(-10);
  PactInteger int3=new PactInteger(255);
  for (int length=2; length <= 4; length++) {
    assertNormalizableKey(int0,int1,length);
    assertNormalizableKey(int0,int2,length);
    assertNormalizableKey(int0,int3,length);
  }
  try {
    int0.write(mOut);
    int2.write(mOut);
    int3.write(mOut);
    PactInteger int1n=new PactInteger();
    PactInteger int2n=new PactInteger();
    PactInteger int3n=new PactInteger();
    int1n.read(mIn);
    int2n.read(mIn);
    int3n.read(mIn);
    for (int length=2; length <= 4; length++) {
      assertNormalizableKey(int0,int1n,length);
      assertNormalizableKey(int0,int2n,length);
      assertNormalizableKey(int0,int3n,length);
    }
  }
 catch (  Exception e) {
    Assert.fail(e.getMessage());
  }
}","@Test public void testPactInteger(){
  PactInteger int0=new PactInteger(10);
  PactInteger int1=new PactInteger(10);
  PactInteger int2=new PactInteger(-10);
  PactInteger int3=new PactInteger(255);
  PactInteger int4=new PactInteger(Integer.MAX_VALUE);
  PactInteger int5=new PactInteger(Integer.MAX_VALUE & 0xff800000);
  PactInteger int6=new PactInteger(Integer.MIN_VALUE);
  PactInteger int7=new PactInteger(Integer.MIN_VALUE & 0xff800000);
  for (int length=2; length <= 4; length++) {
    assertNormalizableKey(int0,int1,length);
    assertNormalizableKey(int0,int2,length);
    assertNormalizableKey(int0,int3,length);
    assertNormalizableKey(int0,int4,length);
    assertNormalizableKey(int0,int5,length);
    assertNormalizableKey(int0,int6,length);
    assertNormalizableKey(int0,int7,length);
    assertNormalizableKey(int4,int5,length);
    assertNormalizableKey(int6,int7,length);
  }
}"
88021,"@Test public void testPactLong(){
  PactLong long0=new PactLong(10);
  Assert.assertEquals(10,long0.getValue());
  PactLong long1=new PactLong(10);
  PactLong long2=new PactLong(-10);
  PactLong long3=new PactLong(255);
  for (int length=2; length <= 8; length++) {
    assertNormalizableKey(long0,long1,length);
    assertNormalizableKey(long0,long2,length);
    assertNormalizableKey(long0,long3,length);
  }
  try {
    long0.write(mOut);
    long2.write(mOut);
    long3.write(mOut);
    PactLong long1n=new PactLong();
    PactLong long2n=new PactLong();
    PactLong long3n=new PactLong();
    long1n.read(mIn);
    long2n.read(mIn);
    long3n.read(mIn);
    for (int length=2; length <= 8; length++) {
      assertNormalizableKey(long0,long1n,length);
      assertNormalizableKey(long0,long2n,length);
      assertNormalizableKey(long0,long3n,length);
    }
  }
 catch (  Exception e) {
    Assert.fail(e.getMessage());
  }
}","@Test public void testPactLong(){
  PactLong long0=new PactLong(10);
  PactLong long1=new PactLong(10);
  PactLong long2=new PactLong(-10);
  PactLong long3=new PactLong(255);
  PactLong long4=new PactLong(Long.MAX_VALUE);
  PactLong long5=new PactLong(Long.MAX_VALUE & 0xff80000000000000L);
  PactLong long6=new PactLong(Long.MIN_VALUE);
  PactLong long7=new PactLong(Long.MIN_VALUE & 0xff80000000000000L);
  for (int length=2; length <= 8; length++) {
    assertNormalizableKey(long0,long1,length);
    assertNormalizableKey(long0,long2,length);
    assertNormalizableKey(long0,long3,length);
    assertNormalizableKey(long0,long4,length);
    assertNormalizableKey(long0,long5,length);
    assertNormalizableKey(long0,long6,length);
    assertNormalizableKey(long0,long7,length);
    assertNormalizableKey(long4,long5,length);
    assertNormalizableKey(long6,long7,length);
  }
}"
88022,"private void assertNormalizableKey(Key key1,Key key2,int len){
  byte[] normalizedKeys=new byte[2 * len];
  ((NormalizableKey)key1).copyNormalizedKey(normalizedKeys,0,len);
  ((NormalizableKey)key2).copyNormalizedKey(normalizedKeys,len,len);
  for (int i=0; i < len; i++) {
    int comp;
    if ((comp=(normalizedKeys[i] - normalizedKeys[len + i])) != 0) {
      if (Math.signum(key1.compareTo(key2)) != Math.signum(comp)) {
        Assert.fail(""String_Node_Str"");
      }
      return;
    }
  }
  if (key1.compareTo(key2) != 0 && ((NormalizableKey)key1).getMaxNormalizedKeyLen() <= len) {
    Assert.fail(""String_Node_Str"" + ""String_Node_Str"");
  }
}","private void assertNormalizableKey(NormalizableKey key1,NormalizableKey key2,int len){
  byte[] normalizedKeys=new byte[2 * len];
  key1.copyNormalizedKey(normalizedKeys,0,len);
  key2.copyNormalizedKey(normalizedKeys,len,len);
  for (int i=0; i < len; i++) {
    int comp;
    int normKey1=normalizedKeys[i] & 0xFF;
    int normKey2=normalizedKeys[len + i] & 0xFF;
    if ((comp=(normKey1 - normKey2)) != 0) {
      if (Math.signum(key1.compareTo(key2)) != Math.signum(comp)) {
        Assert.fail(""String_Node_Str"");
      }
      return;
    }
  }
  if (key1.compareTo(key2) != 0 && key1.getMaxNormalizedKeyLen() <= len) {
    Assert.fail(""String_Node_Str"" + ""String_Node_Str"");
  }
}"
88023,"/** 
 * Deserializes the next record from one of the data buffers.
 * @return the next record or <code>null</code> if all data buffers are exhausted
 * @throws ExecutionFailureException if the record cannot be deserialized
 */
private T deserializeNextRecord(final T target) throws IOException {
  if (this.bufferedRecord != null) {
    final T record=this.bufferedRecord;
    this.bufferedRecord=null;
    return record;
  }
  if (this.uncompressedDataBuffer == null) {
synchronized (this.synchronisationObject) {
      if (this.ioException != null) {
        throw this.ioException;
      }
      requestReadBuffersFromBroker();
    }
    if (this.uncompressedDataBuffer == null) {
      return null;
    }
    if (this.decompressor != null) {
      this.decompressor.decompress();
    }
  }
  final T nextRecord=this.deserializationBuffer.readData(target,this.uncompressedDataBuffer);
  if (this.uncompressedDataBuffer.remaining() == 0) {
    releasedConsumedReadBuffer();
    this.bufferedRecord=nextRecord;
    return null;
  }
  return nextRecord;
}","/** 
 * Deserializes the next record from one of the data buffers.
 * @return the next record or <code>null</code> if all data buffers are exhausted
 * @throws ExecutionFailureException if the record cannot be deserialized
 */
private T deserializeNextRecord(final T target) throws IOException {
  if (this.uncompressedDataBuffer == null) {
synchronized (this.synchronisationObject) {
      if (this.ioException != null) {
        throw this.ioException;
      }
      requestReadBuffersFromBroker();
    }
    if (this.uncompressedDataBuffer == null) {
      return null;
    }
    if (this.decompressor != null) {
      this.decompressor.decompress();
    }
  }
  final T nextRecord=this.deserializationBuffer.readData(target,this.uncompressedDataBuffer);
  if (this.uncompressedDataBuffer.remaining() == 0) {
    releasedConsumedReadBuffer();
  }
  return nextRecord;
}"
88024,"/** 
 * {@inheritDoc}
 */
@Override public boolean isClosed() throws IOException {
  if (this.bufferedRecord != null || this.uncompressedDataBuffer != null) {
    return false;
  }
synchronized (this.synchronisationObject) {
    if (this.ioException != null) {
      throw this.ioException;
    }
    if (!this.brokerAggreedToCloseChannel) {
      return false;
    }
  }
  return true;
}","/** 
 * {@inheritDoc}
 */
@Override public boolean isClosed() throws IOException {
  if (this.uncompressedDataBuffer != null) {
    return false;
  }
synchronized (this.synchronisationObject) {
    if (this.ioException != null) {
      throw this.ioException;
    }
    if (!this.brokerAggreedToCloseChannel) {
      return false;
    }
  }
  return true;
}"
88025,"/** 
 * {@inheritDoc}
 */
@Override public void close() throws IOException, InterruptedException {
  this.deserializationBuffer.clear();
  if (this.uncompressedDataBuffer != null) {
    releasedConsumedReadBuffer();
  }
  if (this.getType() == ChannelType.NETWORK) {
synchronized (this.synchronisationObject) {
      if (!this.brokerAggreedToCloseChannel) {
        while (!this.brokerAggreedToCloseChannel) {
          requestReadBuffersFromBroker();
          if (this.uncompressedDataBuffer != null || this.compressedDataBuffer != null) {
            releasedConsumedReadBuffer();
          }
          this.synchronisationObject.wait(500);
        }
        this.bufferedRecord=null;
      }
    }
  }
  final ChannelType type=getType();
  if (type == ChannelType.NETWORK || type == ChannelType.INMEMORY) {
    transferEvent(new ByteBufferedChannelCloseEvent());
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void close() throws IOException, InterruptedException {
  this.deserializationBuffer.clear();
  if (this.uncompressedDataBuffer != null) {
    releasedConsumedReadBuffer();
  }
  if (this.getType() == ChannelType.NETWORK) {
synchronized (this.synchronisationObject) {
      if (!this.brokerAggreedToCloseChannel) {
        while (!this.brokerAggreedToCloseChannel) {
          requestReadBuffersFromBroker();
          if (this.uncompressedDataBuffer != null || this.compressedDataBuffer != null) {
            releasedConsumedReadBuffer();
          }
          this.synchronisationObject.wait(500);
        }
      }
    }
  }
  final ChannelType type=getType();
  if (type == ChannelType.NETWORK || type == ChannelType.INMEMORY) {
    transferEvent(new ByteBufferedChannelCloseEvent());
  }
}"
88026,"/** 
 * {@inheritDoc}
 */
@Override public void queueTransferEnvelope(final TransferEnvelope transferEnvelope){
  final int sequenceNumber=transferEnvelope.getSequenceNumber();
synchronized (this.queuedEnvelopes) {
    if (sequenceNumber <= this.lastReceivedEnvelope) {
      final Buffer buffer=transferEnvelope.getBuffer();
      if (buffer != null) {
        buffer.recycleBuffer();
      }
      return;
    }
    this.queuedEnvelopes.add(transferEnvelope);
    this.lastReceivedEnvelope=sequenceNumber;
  }
  this.byteBufferedInputChannel.checkForNetworkEvents();
}","/** 
 * {@inheritDoc}
 */
@Override public void queueTransferEnvelope(final TransferEnvelope transferEnvelope){
  final int sequenceNumber=transferEnvelope.getSequenceNumber();
synchronized (this.queuedEnvelopes) {
    if (sequenceNumber != (this.lastReceivedEnvelope + 1)) {
      final Buffer buffer=transferEnvelope.getBuffer();
      if (buffer != null) {
        buffer.recycleBuffer();
      }
      return;
    }
    this.queuedEnvelopes.add(transferEnvelope);
    this.lastReceivedEnvelope=sequenceNumber;
  }
  this.byteBufferedInputChannel.checkForNetworkEvents();
}"
88027,"public void restartExecution(){
  this.restarting=true;
  changeExecutionState(ExecutionState.RESTARTING,null);
  LOG.info(""String_Node_Str"" + this.taskName);
  this.isCanceled=true;
  if (this.executingThread == null) {
    LOG.error(""String_Node_Str"" + this.taskName + ""String_Node_Str"");
    return;
  }
  try {
    this.invokable.cancel();
  }
 catch (  Exception e) {
    LOG.error(StringUtils.stringifyException(e));
  }
  while (this.isCanceled) {
    this.executingThread.interrupt();
  }
  LOG.info(""String_Node_Str"");
  this.isCanceled=false;
  this.executingThread=new Thread(this,this.taskName);
  this.executingThread.start();
  return;
}","public void restartExecution(){
  this.restarting=true;
  changeExecutionState(ExecutionState.RESTARTING,null);
  LOG.info(""String_Node_Str"" + this.taskName);
  this.isCanceled=true;
  if (this.executingThread == null) {
    LOG.error(""String_Node_Str"" + this.taskName + ""String_Node_Str"");
    return;
  }
  try {
    this.invokable.cancel();
  }
 catch (  Exception e) {
    LOG.error(StringUtils.stringifyException(e));
  }
  while (this.isCanceled) {
    this.executingThread.interrupt();
  }
  LOG.info(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  this.isCanceled=false;
  this.executingThread=new Thread(this,this.taskName);
  this.executingThread.start();
  return;
}"
88028,"public void changeExecutionState(final ExecutionState newExecutionState,final String optionalMessage){
  if (this.executionState == ExecutionState.CANCELED || this.executionState == ExecutionState.FINISHED) {
    return;
  }
  if (this.executionState == ExecutionState.RESTARTING && newExecutionState == ExecutionState.CANCELED) {
    this.isCanceled=false;
    return;
  }
  LOG.info(""String_Node_Str"" + executionState + ""String_Node_Str""+ newExecutionState+ ""String_Node_Str""+ this.getTaskName()+ ""String_Node_Str""+ (this.getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
  boolean unexpectedStateChange=true;
  if (this.executionState == ExecutionState.CREATED && newExecutionState == ExecutionState.SCHEDULED) {
    unexpectedStateChange=false;
  }
  if (this.executionState == ExecutionState.SCHEDULED && newExecutionState == ExecutionState.ASSIGNING) {
    unexpectedStateChange=false;
  }
  if (this.executionState == ExecutionState.ASSIGNING && newExecutionState == ExecutionState.ASSIGNED) {
    unexpectedStateChange=false;
  }
  if (this.executionState == ExecutionState.ASSIGNED && newExecutionState == ExecutionState.READY) {
    unexpectedStateChange=false;
  }
  if (this.executionState == ExecutionState.READY && newExecutionState == ExecutionState.RUNNING) {
    unexpectedStateChange=false;
  }
  if (this.executionState == ExecutionState.RUNNING && newExecutionState == ExecutionState.FINISHING) {
    unexpectedStateChange=false;
  }
  if (this.executionState == ExecutionState.FINISHING && newExecutionState == ExecutionState.FINISHED) {
    unexpectedStateChange=false;
  }
  if (this.executionState == ExecutionState.SCHEDULED && newExecutionState == ExecutionState.ASSIGNED) {
    unexpectedStateChange=false;
  }
  if (this.executionState == ExecutionState.SCHEDULED && newExecutionState == ExecutionState.CANCELED) {
    unexpectedStateChange=false;
  }
  if (this.executionState == ExecutionState.ASSIGNING && newExecutionState == ExecutionState.CANCELED) {
    unexpectedStateChange=false;
  }
  if (this.executionState == ExecutionState.ASSIGNED && newExecutionState == ExecutionState.CANCELED) {
    unexpectedStateChange=false;
  }
  if (this.executionState == ExecutionState.READY && newExecutionState == ExecutionState.CANCELED) {
    unexpectedStateChange=false;
  }
  if (this.executionState == ExecutionState.RUNNING && newExecutionState == ExecutionState.FAILED) {
    unexpectedStateChange=false;
  }
  if (this.executionState == ExecutionState.FINISHING && newExecutionState == ExecutionState.FAILED) {
    unexpectedStateChange=false;
  }
  if (this.executionState == ExecutionState.RUNNING && newExecutionState == ExecutionState.CANCELING) {
    unexpectedStateChange=false;
  }
  if (this.executionState == ExecutionState.FINISHING && newExecutionState == ExecutionState.CANCELING) {
    unexpectedStateChange=false;
  }
  if (this.executionState == ExecutionState.CANCELING && newExecutionState == ExecutionState.CANCELED) {
    unexpectedStateChange=false;
  }
  if (this.executionState == ExecutionState.RUNNING && newExecutionState == ExecutionState.RESTARTING) {
    unexpectedStateChange=false;
  }
  if (unexpectedStateChange) {
    LOG.error(""String_Node_Str"" + this.executionState + ""String_Node_Str""+ newExecutionState);
  }
  if (this.restarting && newExecutionState == ExecutionState.RUNNING) {
    this.restarting=false;
  }
  this.executionState=newExecutionState;
synchronized (this.executionListeners) {
    final Iterator<ExecutionListener> it=this.executionListeners.iterator();
    while (it.hasNext()) {
      it.next().executionStateChanged(this,newExecutionState,optionalMessage);
    }
  }
}","public void changeExecutionState(final ExecutionState newExecutionState,final String optionalMessage){
  if (this.executionState == ExecutionState.CANCELED || this.executionState == ExecutionState.FINISHED) {
    return;
  }
  if (this.executionState == ExecutionState.RESTARTING && newExecutionState == ExecutionState.CANCELED) {
    this.isCanceled=false;
    return;
  }
  LOG.info(""String_Node_Str"" + executionState + ""String_Node_Str""+ newExecutionState+ ""String_Node_Str""+ this.getTaskName()+ ""String_Node_Str""+ (this.getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
  boolean unexpectedStateChange=true;
  if (this.executionState == ExecutionState.CREATED && newExecutionState == ExecutionState.SCHEDULED) {
    unexpectedStateChange=false;
  }
  if (this.executionState == ExecutionState.SCHEDULED && newExecutionState == ExecutionState.ASSIGNING) {
    unexpectedStateChange=false;
  }
  if (this.executionState == ExecutionState.ASSIGNING && newExecutionState == ExecutionState.ASSIGNED) {
    unexpectedStateChange=false;
  }
  if (this.executionState == ExecutionState.ASSIGNED && newExecutionState == ExecutionState.READY) {
    unexpectedStateChange=false;
  }
  if (this.executionState == ExecutionState.READY && newExecutionState == ExecutionState.RUNNING) {
    unexpectedStateChange=false;
  }
  if (this.executionState == ExecutionState.RUNNING && newExecutionState == ExecutionState.FINISHING) {
    unexpectedStateChange=false;
  }
  if (this.executionState == ExecutionState.FINISHING && newExecutionState == ExecutionState.FINISHED) {
    unexpectedStateChange=false;
  }
  if (this.executionState == ExecutionState.SCHEDULED && newExecutionState == ExecutionState.ASSIGNED) {
    unexpectedStateChange=false;
  }
  if (this.executionState == ExecutionState.SCHEDULED && newExecutionState == ExecutionState.CANCELED) {
    unexpectedStateChange=false;
  }
  if (this.executionState == ExecutionState.ASSIGNING && newExecutionState == ExecutionState.CANCELED) {
    unexpectedStateChange=false;
  }
  if (this.executionState == ExecutionState.ASSIGNED && newExecutionState == ExecutionState.CANCELED) {
    unexpectedStateChange=false;
  }
  if (this.executionState == ExecutionState.READY && newExecutionState == ExecutionState.CANCELED) {
    unexpectedStateChange=false;
  }
  if (this.executionState == ExecutionState.RUNNING && newExecutionState == ExecutionState.FAILED) {
    unexpectedStateChange=false;
  }
  if (this.executionState == ExecutionState.FINISHING && newExecutionState == ExecutionState.FAILED) {
    unexpectedStateChange=false;
  }
  if (this.executionState == ExecutionState.RUNNING && newExecutionState == ExecutionState.CANCELING) {
    unexpectedStateChange=false;
  }
  if (this.executionState == ExecutionState.FINISHING && newExecutionState == ExecutionState.CANCELING) {
    unexpectedStateChange=false;
  }
  if (this.executionState == ExecutionState.CANCELING && newExecutionState == ExecutionState.CANCELED) {
    unexpectedStateChange=false;
  }
  if (this.executionState == ExecutionState.RUNNING && newExecutionState == ExecutionState.RESTARTING) {
    unexpectedStateChange=false;
  }
  if (this.executionState == ExecutionState.RESTARTING && newExecutionState == ExecutionState.RUNNING) {
    unexpectedStateChange=false;
  }
  if (unexpectedStateChange) {
    LOG.error(""String_Node_Str"" + this.executionState + ""String_Node_Str""+ newExecutionState);
  }
  if (this.restarting && newExecutionState == ExecutionState.RUNNING) {
    this.restarting=false;
  }
  this.executionState=newExecutionState;
synchronized (this.executionListeners) {
    final Iterator<ExecutionListener> it=this.executionListeners.iterator();
    while (it.hasNext()) {
      it.next().executionStateChanged(this,newExecutionState,optionalMessage);
    }
  }
}"
88029,"/** 
 * Reads data from the given byte channel and deserializes an object of type <code>T</code> from it.
 * @param readableByteChannel the byte channel to read data from
 * @return an object of type <code>T</code>
 * @throws IOException thrown if an error occurs while reading the data or deserializing the object
 */
public T readData(final ReadableByteChannel readableByteChannel) throws IOException {
  if (this.recordLength < 0) {
    if (readableByteChannel.read(this.lengthBuf) == -1 && this.propagateEndOfStream) {
      if (this.lengthBuf.position() == 0) {
        throw new EOFException();
      }
 else {
        throw new IOException(""String_Node_Str"" + this.lengthBuf.remaining() + ""String_Node_Str"");
      }
    }
    if (this.lengthBuf.hasRemaining()) {
      return null;
    }
    this.recordLength=byteArrayToInt(this.lengthBuf.array());
    if (this.tempBuffer == null) {
      this.tempBuffer=ByteBuffer.allocate(this.recordLength);
    }
    if (this.tempBuffer.capacity() < this.recordLength) {
      this.tempBuffer=ByteBuffer.allocate(this.recordLength);
    }
    this.tempBuffer.position(0);
    this.tempBuffer.limit(this.recordLength);
  }
  if (readableByteChannel.read(tempBuffer) == -1 && this.propagateEndOfStream) {
    throw new IOException(""String_Node_Str"" + this.tempBuffer.remaining() + ""String_Node_Str"");
  }
  if (this.tempBuffer.hasRemaining()) {
    return null;
  }
  this.deserializationBuffer.reset(this.tempBuffer.array(),this.recordLength);
  final T record=deserializer.deserialize(this.deserializationBuffer);
  this.recordLength=-1;
  this.lengthBuf.clear();
  return record;
}","/** 
 * Reads data from the given byte channel and deserializes an object of type <code>T</code> from it.
 * @param readableByteChannel the byte channel to read data from
 * @return an object of type <code>T</code>
 * @throws IOException thrown if an error occurs while reading the data or deserializing the object
 */
public T readData(final ReadableByteChannel readableByteChannel) throws IOException {
  if (this.recordLength < 0) {
    if (readableByteChannel.read(this.lengthBuf) == -1 && this.propagateEndOfStream) {
      if (this.lengthBuf.position() == 0) {
        throw new EOFException();
      }
 else {
        throw new IOException(""String_Node_Str"" + this.lengthBuf.remaining() + ""String_Node_Str"");
      }
    }
    if (this.lengthBuf.hasRemaining()) {
      return null;
    }
    this.recordLength=byteArrayToInt(this.lengthBuf.array());
    if (this.tempBuffer == null) {
      this.tempBuffer=ByteBuffer.allocate(this.recordLength);
    }
    if (this.tempBuffer.capacity() < this.recordLength) {
      this.tempBuffer=ByteBuffer.allocate(this.recordLength);
    }
    this.tempBuffer.position(0);
    this.tempBuffer.limit(this.recordLength);
  }
  long read=readableByteChannel.read(this.tempBuffer);
  if (read == -1 && this.propagateEndOfStream) {
    throw new IOException(""String_Node_Str"" + this.tempBuffer.remaining() + ""String_Node_Str"");
  }
  if (read == -1) {
    System.out.println(""String_Node_Str"");
    while (read == -1 && !this.propagateEndOfStream) {
      read=readableByteChannel.read(this.tempBuffer);
      try {
        Thread.sleep(20000);
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
        break;
      }
    }
  }
  if (this.tempBuffer.hasRemaining()) {
    return null;
  }
  this.deserializationBuffer.reset(this.tempBuffer.array(),this.recordLength);
  final T record=this.deserializer.deserialize(this.deserializationBuffer);
  this.recordLength=-1;
  this.lengthBuf.clear();
  return record;
}"
88030,"/** 
 * {@inheritDoc}
 */
@Override public void resourceAllocated(final JobID jobID,final AllocatedResource allocatedResource){
  if (allocatedResource == null) {
    LOG.error(""String_Node_Str"");
    return;
  }
  if (allocatedResource.getInstance() instanceof DummyInstance) {
    LOG.debug(""String_Node_Str"");
    return;
  }
synchronized (this.jobQueue) {
    final ExecutionGraph eg=getExecutionGraphByID(jobID);
    if (eg == null) {
      try {
        getInstanceManager().releaseAllocatedResource(jobID,null,allocatedResource);
      }
 catch (      InstanceException e) {
        LOG.error(e);
      }
      return;
    }
    final int indexOfCurrentStage=eg.getIndexOfCurrentExecutionStage();
    AllocatedResource resourceToBeReplaced=null;
    ExecutionGraphIterator it=new ExecutionGraphIterator(eg,indexOfCurrentStage,true,true);
    while (it.hasNext()) {
      final ExecutionVertex vertex=it.next();
      if (vertex.getExecutionState() == ExecutionState.ASSIGNING && vertex.getAllocatedResource() != null) {
        if (vertex.getAllocatedResource().getInstanceType().equals(allocatedResource.getInstanceType())) {
          resourceToBeReplaced=vertex.getAllocatedResource();
          break;
        }
      }
    }
    if (resourceToBeReplaced == null) {
      LOG.warn(""String_Node_Str"" + allocatedResource.getInstance() + ""String_Node_Str""+ eg.getJobID());
      try {
        getInstanceManager().releaseAllocatedResource(jobID,eg.getJobConfiguration(),allocatedResource);
      }
 catch (      InstanceException e) {
        LOG.error(e);
      }
      return;
    }
    it=new ExecutionGraphIterator(eg,true);
    while (it.hasNext()) {
      final ExecutionVertex vertex=it.next();
      if (vertex.getAllocatedResource().equals(resourceToBeReplaced)) {
        vertex.setAllocatedResource(allocatedResource);
        vertex.setExecutionState(ExecutionState.ASSIGNED);
      }
    }
    deployAssignedVertices(eg);
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void resourceAllocated(final JobID jobID,final AllocatedResource allocatedResource){
  if (allocatedResource == null) {
    LOG.error(""String_Node_Str"");
    return;
  }
  if (allocatedResource.getInstance() instanceof DummyInstance) {
    LOG.debug(""String_Node_Str"");
    return;
  }
synchronized (this.jobQueue) {
    final ExecutionGraph eg=getExecutionGraphByID(jobID);
    if (eg == null) {
      try {
        getInstanceManager().releaseAllocatedResource(jobID,null,allocatedResource);
      }
 catch (      InstanceException e) {
        LOG.error(e);
      }
      return;
    }
    final int indexOfCurrentStage=eg.getIndexOfCurrentExecutionStage();
    AllocatedResource resourceToBeReplaced=null;
    ExecutionGraphIterator it=new ExecutionGraphIterator(eg,indexOfCurrentStage,true,true);
    while (it.hasNext()) {
      final ExecutionVertex vertex=it.next();
      if (vertex.getExecutionState() == ExecutionState.ASSIGNING && vertex.getAllocatedResource() != null) {
        if (vertex.getAllocatedResource().getInstanceType().equals(allocatedResource.getInstanceType())) {
          resourceToBeReplaced=vertex.getAllocatedResource();
          break;
        }
      }
    }
    if (resourceToBeReplaced == null) {
      LOG.warn(""String_Node_Str"" + allocatedResource.getInstance() + ""String_Node_Str""+ eg.getJobID());
      try {
        getInstanceManager().releaseAllocatedResource(jobID,eg.getJobConfiguration(),allocatedResource);
      }
 catch (      InstanceException e) {
        LOG.error(e);
      }
      return;
    }
    it=new ExecutionGraphIterator(eg,true);
    while (it.hasNext()) {
      final ExecutionVertex vertex=it.next();
      if (vertex.getAllocatedResource().equals(resourceToBeReplaced)) {
        System.out.println(""String_Node_Str"" + allocatedResource.getInstance().getName());
        vertex.setAllocatedResource(allocatedResource);
        vertex.setExecutionState(ExecutionState.ASSIGNED);
      }
    }
    deployAssignedVertices(eg);
  }
}"
88031,"/** 
 * Returns the number of successors, i.e. the number of vertices this vertex is connected to.
 * @return the number of successors
 */
public synchronized int getNumberOfSuccessors(){
  int numberOfSuccessors=0;
  LOG.info(this.environment.getNumberOfOutputGates());
  for (int i=0; i < this.environment.getNumberOfOutputGates(); i++) {
    LOG.info(this.environment.getOutputGate(i).getNumberOfOutputChannels());
    numberOfSuccessors+=this.environment.getOutputGate(i).getNumberOfOutputChannels();
  }
  return numberOfSuccessors;
}","/** 
 * Returns the number of successors, i.e. the number of vertices this vertex is connected to.
 * @return the number of successors
 */
public synchronized int getNumberOfSuccessors(){
  int numberOfSuccessors=0;
  for (int i=0; i < this.environment.getNumberOfOutputGates(); i++) {
    numberOfSuccessors+=this.environment.getOutputGate(i).getNumberOfOutputChannels();
  }
  return numberOfSuccessors;
}"
88032,"/** 
 */
public void recover(ChannelID sourceChannelID){
  try {
    getTaskManager().recover(sourceChannelID);
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","/** 
 * recovers the given channel
 */
public void recover(ChannelID sourceChannelID){
  try {
    getTaskManager().recover(sourceChannelID);
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}"
88033,"@Override public void rewind(){
  this.byteBuffer.rewind();
}","@Override public void rewind(){
  this.byteBuffer.position(0);
}"
88034,"/** 
 * {@inheritDoc}
 */
@Override public void vertexAssignmentChanged(ExecutionVertexID id,AllocatedResource newAllocatedResource){
  final ManagementVertexID managementVertexID=id.toManagementVertexID();
  final long timestamp=System.currentTimeMillis();
  final AbstractInstance instance=newAllocatedResource.getInstance();
  VertexAssignmentEvent event;
  if (instance == null) {
    event=new VertexAssignmentEvent(timestamp,managementVertexID,""String_Node_Str"",""String_Node_Str"");
  }
 else {
    event=new VertexAssignmentEvent(timestamp,managementVertexID,instance.getName(),instance.getType().getIdentifier());
  }
  this.eventCollector.updateManagementGraph(jobID,event);
  this.eventCollector.addEvent(this.jobID,event);
}","/** 
 * {@inheritDoc}
 */
@Override public void vertexAssignmentChanged(ExecutionVertexID id,AllocatedResource newAllocatedResource){
  final ManagementVertexID managementVertexID=id.toManagementVertexID();
  final long timestamp=System.currentTimeMillis();
  final AbstractInstance instance=newAllocatedResource.getInstance();
  VertexAssignmentEvent event;
  if (instance == null) {
    event=new VertexAssignmentEvent(timestamp,managementVertexID,""String_Node_Str"",""String_Node_Str"");
  }
 else {
    event=new VertexAssignmentEvent(timestamp,managementVertexID,instance.getName(),instance.getType().getIdentifier());
  }
  this.eventCollector.updateManagementGraph(this.jobID,event);
  this.eventCollector.addEvent(this.jobID,event);
}"
88035,"/** 
 * {@inheritDoc}
 */
@Override public ConnectionInfoLookupResponse lookupConnectionInfo(JobID jobID,ChannelID sourceChannelID){
  final ExecutionGraph eg=this.scheduler.getExecutionGraphByID(jobID);
  if (eg == null) {
    LOG.error(""String_Node_Str"" + jobID);
    return ConnectionInfoLookupResponse.createReceiverNotFound();
  }
  AbstractChannel sourceChannel=eg.getOutputChannelByID(sourceChannelID);
  if (sourceChannel == null) {
    sourceChannel=eg.getInputChannelByID(sourceChannelID);
    if (sourceChannel == null) {
      LOG.error(""String_Node_Str"" + sourceChannelID);
      return ConnectionInfoLookupResponse.createReceiverNotFound();
    }
  }
  final ChannelID targetChannelID=sourceChannel.getConnectedChannelID();
  final ExecutionVertex vertex=eg.getVertexByChannelID(targetChannelID);
  if (vertex == null) {
    LOG.error(""String_Node_Str"" + targetChannelID + ""String_Node_Str""+ jobID);
    return ConnectionInfoLookupResponse.createReceiverNotFound();
  }
  final ExecutionState executionState=vertex.getExecutionState();
  if (executionState != ExecutionState.RUNNING && executionState != ExecutionState.FINISHING) {
    return ConnectionInfoLookupResponse.createReceiverNotReady();
  }
  final AbstractInstance assignedInstance=vertex.getAllocatedResource().getInstance();
  if (assignedInstance == null) {
    LOG.debug(""String_Node_Str"" + targetChannelID + ""String_Node_Str"");
    return ConnectionInfoLookupResponse.createReceiverNotReady();
  }
  return ConnectionInfoLookupResponse.createReceiverFoundAndReady(assignedInstance.getInstanceConnectionInfo());
}","/** 
 * {@inheritDoc}
 */
@Override public ConnectionInfoLookupResponse lookupConnectionInfo(JobID jobID,ChannelID sourceChannelID){
  final ExecutionGraph eg=this.scheduler.getExecutionGraphByID(jobID);
  if (eg == null) {
    LOG.error(""String_Node_Str"" + jobID);
    return ConnectionInfoLookupResponse.createReceiverNotFound();
  }
  AbstractChannel sourceChannel=eg.getOutputChannelByID(sourceChannelID);
  if (sourceChannel == null) {
    sourceChannel=eg.getInputChannelByID(sourceChannelID);
    if (sourceChannel == null) {
      LOG.error(""String_Node_Str"" + sourceChannelID);
      return ConnectionInfoLookupResponse.createReceiverNotFound();
    }
  }
  final ChannelID targetChannelID=sourceChannel.getConnectedChannelID();
  final ExecutionVertex vertex=eg.getVertexByChannelID(targetChannelID);
  if (vertex == null) {
    LOG.error(""String_Node_Str"" + targetChannelID + ""String_Node_Str""+ jobID);
    return ConnectionInfoLookupResponse.createReceiverNotFound();
  }
  final ExecutionState executionState=vertex.getExecutionState();
  if (executionState != ExecutionState.RUNNING && executionState != ExecutionState.FINISHING) {
    return ConnectionInfoLookupResponse.createReceiverNotReady();
  }
  final AbstractInstance assignedInstance=vertex.getAllocatedResource().getInstance();
  if (assignedInstance == null) {
    LOG.debug(""String_Node_Str"" + targetChannelID + ""String_Node_Str"");
    return ConnectionInfoLookupResponse.createReceiverNotReady();
  }
  LOG.info(""String_Node_Str"" + assignedInstance.getName());
  return ConnectionInfoLookupResponse.createReceiverFoundAndReady(assignedInstance.getInstanceConnectionInfo());
}"
88036,"/** 
 * {@inheritDoc}
 */
@Override public void run(){
  LOG.info(""String_Node_Str"");
  if (this.failedVertices.isEmpty()) {
    LOG.error(""String_Node_Str"");
  }
  Iterator<ExecutionVertex> vertexIter=this.failedVertices.iterator();
  while (vertexIter.hasNext()) {
    ExecutionVertex failed=vertexIter.next();
    LOG.info(""String_Node_Str"" + failed);
    List<ExecutionVertex> restart=findRestarts(failed);
    if (restart.size() < 2) {
      LOG.info(""String_Node_Str"");
    }
 else {
      LOG.info(restart.size());
    }
    Iterator<ExecutionVertex> restartIterator=restart.iterator();
    while (restartIterator.hasNext()) {
      ExecutionVertex vertex=restartIterator.next();
      if (!vertex.equals(failed)) {
        LOG.info(""String_Node_Str"");
        LOG.info(""String_Node_Str"" + vertex.getName());
        vertex.getAllocatedResource().getInstance().restart(vertex.getID(),job.getJobConfiguration());
        LOG.info(""String_Node_Str"");
      }
    }
    Iterator<ExecutionVertex> checkpointIterator=this.globalConsistentCheckpoint.iterator();
    while (checkpointIterator.hasNext()) {
      ExecutionVertex checkpoint=checkpointIterator.next();
      AbstractInstance instance=checkpoint.getAllocatedResource().getInstance();
      instance.recoverAll(checkpoint.getEnvironment().getOutputGate(0).getOutputChannel(0).getID());
    }
    LOG.info(""String_Node_Str"" + failed);
  }
  this.job.executionStateChanged(null,ExecutionState.RERUNNING,null);
  LOG.info(""String_Node_Str"");
}","/** 
 * {@inheritDoc}
 */
@Override public void run(){
  LOG.info(""String_Node_Str"");
  if (this.failedVertices.isEmpty()) {
    LOG.error(""String_Node_Str"");
  }
  Iterator<ExecutionVertex> vertexIter=this.failedVertices.iterator();
  while (vertexIter.hasNext()) {
    ExecutionVertex failed=vertexIter.next();
    LOG.info(""String_Node_Str"" + failed);
    List<ExecutionVertex> restart=findRestarts(failed);
    if (restart.size() < 2) {
      LOG.info(""String_Node_Str"");
    }
 else {
      LOG.info(restart.size());
    }
    Iterator<ExecutionVertex> restartIterator=restart.iterator();
    while (restartIterator.hasNext()) {
      ExecutionVertex vertex=restartIterator.next();
      if (!vertex.equals(failed)) {
        LOG.info(""String_Node_Str"");
        LOG.info(""String_Node_Str"" + vertex.getName());
        try {
          vertex.getAllocatedResource().getInstance().restart(vertex.getID(),job.getJobConfiguration());
        }
 catch (        Exception e) {
          LOG.info(""String_Node_Str"" + StringUtils.stringifyException(e) + ""String_Node_Str"");
        }
        System.out.println(""String_Node_Str"" + vertex.getName());
        LOG.info(""String_Node_Str"");
      }
    }
    Iterator<ExecutionVertex> checkpointIterator=this.globalConsistentCheckpoint.iterator();
    while (checkpointIterator.hasNext()) {
      ExecutionVertex checkpoint=checkpointIterator.next();
      AbstractInstance instance=checkpoint.getAllocatedResource().getInstance();
      instance.recoverAll(checkpoint.getEnvironment().getOutputGate(0).getOutputChannel(0).getID());
    }
    LOG.info(""String_Node_Str"" + failed);
  }
  this.job.executionStateChanged(null,ExecutionState.RERUNNING,null);
  LOG.info(""String_Node_Str"");
}"
88037,"/** 
 */
void recoverAll(ChannelID sourceChannelID);","/** 
 * @param sourceChannelID
 * @param address
 */
void recoverAll(ChannelID sourceChannelID);"
88038,"/** 
 */
void recover(ChannelID sourceChannelID);","/** 
 * @param sourceChannelID
 * @param instanceConnectionInfo
 */
void recover(ChannelID sourceChannelID);"
88039,"public void recoverAll(ChannelID sourceChannelID){
  this.checkpointManager.recoverAllChannelCheckpoints(sourceChannelID);
}","@Override public void recoverAll(ChannelID sourceChannelID){
  this.checkpointManager.recoverAllChannelCheckpoints(sourceChannelID);
}"
88040,"@Override public void restart(ExecutionVertexID executionVertexID,Configuration jobConfiguration){
  Environment ee=this.runningTasks.remove(executionVertexID);
  ee.restartExecution();
  for (int i=0; i < ee.getNumberOfInputGates(); i++) {
    InputGate<? extends Record> ingate=ee.getInputGate(i);
    for (int j=0; j < ingate.getNumberOfInputChannels(); j++) {
      this.byteBufferedChannelManager.clear(ingate.getInputChannel(j).getID());
    }
  }
  for (int i=0; i < ee.getNumberOfOutputGates(); i++) {
    OutputGate<? extends Record> outgate=ee.getOutputGate(i);
    for (int j=0; j < outgate.getNumberOfOutputChannels(); j++) {
      this.byteBufferedChannelManager.clear(outgate.getOutputChannel(j).getID());
    }
  }
}","@Override public void restart(ExecutionVertexID executionVertexID,Configuration jobConfiguration){
  Environment ee=this.runningTasks.remove(executionVertexID);
  ee.restartExecution();
  for (int i=0; i < ee.getNumberOfInputGates(); i++) {
    InputGate<? extends Record> ingate=ee.getInputGate(i);
    for (int j=0; j < ingate.getNumberOfInputChannels(); j++) {
      if (!(ingate.getInputChannel(j) instanceof FileInputChannel<?>)) {
        this.byteBufferedChannelManager.clear(ingate.getInputChannel(j).getID());
      }
    }
  }
  for (int i=0; i < ee.getNumberOfOutputGates(); i++) {
    OutputGate<? extends Record> outgate=ee.getOutputGate(i);
    for (int j=0; j < outgate.getNumberOfOutputChannels(); j++) {
      this.byteBufferedChannelManager.clear(outgate.getOutputChannel(j).getID());
    }
  }
}"
88041,"/** 
 * @param 
 */
public void clear(ChannelID channelID){
  ByteBufferedChannelWrapper wrapper=this.registeredChannels.get(channelID);
  wrapper.clear();
}","/** 
 * @param 
 */
public void clear(ChannelID channelID){
  ByteBufferedChannelWrapper wrapper=this.registeredChannels.get(channelID);
  wrapper.clear();
  this.incomingConnectionThread.clear();
}"
88042,"/** 
 * @param byteBufferedChannelManager
 * @param fileInputChannel
 * @param sourceChannelID 
 * @return CheckpointOutgoingConnection
 */
public CheckpointOutgoingConnection createOutgoingCheckpointConnection(ByteBufferedChannelManager byteBufferedChannelManager,FileChannel fileInputChannel,ChannelID sourceChannelID){
  try {
    final InetSocketAddress connectionAddress=getPeerConnectionAddress(sourceChannelID);
    OutgoingConnectionThread connectionThread=new OutgoingConnectionThread();
    CheckpointOutgoingConnection outgoingConnection=new CheckpointOutgoingConnection(this,connectionAddress,connectionThread,10,fileInputChannel);
    this.outgoingConnections.put(connectionAddress,outgoingConnection);
    return outgoingConnection;
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
  return null;
}","/** 
 * @param byteBufferedChannelManager
 * @param fileInputChannel
 * @param sourceChannelID 
 * @param address 
 * @return CheckpointOutgoingConnection
 */
public CheckpointOutgoingConnection createOutgoingCheckpointConnection(ByteBufferedChannelManager byteBufferedChannelManager,FileChannel fileInputChannel,ChannelID sourceChannelID){
  try {
    final InetSocketAddress connectionAddress=getPeerConnectionAddress(sourceChannelID);
    OutgoingConnectionThread connectionThread=new OutgoingConnectionThread();
    connectionThread.start();
    CheckpointOutgoingConnection outgoingConnection=new CheckpointOutgoingConnection(this,connectionAddress,connectionThread,10,fileInputChannel);
    this.outgoingConnections.put(connectionAddress,outgoingConnection);
    return outgoingConnection;
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
catch (  InterruptedException e) {
    e.printStackTrace();
  }
  return null;
}"
88043,"public void clear(){
  releaseAllResources();
  this.nextExpectedSequenceNumber=0;
}","public void clear(){
  releaseAllResources();
  this.nextExpectedSequenceNumber=0;
  this.byteBufferedInputChannel.clear();
}"
88044,"/** 
 * Called by the attached output channel wrapper to forward a   {@link TransferEnvelope} objectto its final destination. Within this method the provided transfer envelope is possibly also forwarded to the assigned ephemeral checkpoint.
 * @param channelWrapper the channel wrapper which called this method
 * @param outgoingTransferEnvelope the transfer envelope to be forwarded
 * @throws IOException thrown if an I/O error occurs while processing the envelope
 * @throws InterruptedException thrown if the thread is interrupted while waiting for the envelope to be processed
 */
public void processEnvelope(ByteBufferedOutputChannelWrapper channelWrapper,TransferEnvelope outgoingTransferEnvelope) throws IOException, InterruptedException {
  final TransferEnvelopeProcessingLog processingLog=outgoingTransferEnvelope.getProcessingLog();
  if (this.ephemeralCheckpoint != null && processingLog.mustBeWrittenToCheckpoint()) {
    this.ephemeralCheckpoint.addTransferEnvelope(outgoingTransferEnvelope);
    final EventList eventList=outgoingTransferEnvelope.getEventList();
    if (!eventList.isEmpty()) {
      final Iterator<AbstractEvent> it=eventList.iterator();
      while (it.hasNext()) {
        if (it.next() instanceof ByteBufferedChannelCloseEvent) {
          this.ephemeralCheckpoint.markChannelAsFinished(outgoingTransferEnvelope.getSource());
          if (this.ephemeralCheckpoint.isPersistent()) {
            channelWrapper.processEvent(new ByteBufferedChannelCloseEvent());
          }
          break;
        }
      }
    }
  }
  if (processingLog.mustBeSentViaNetwork() && !processingLog.isSentViaNetwork()) {
    this.byteBufferedChannelManager.queueOutgoingTransferEnvelope(outgoingTransferEnvelope);
  }
  if (outgoingTransferEnvelope.getBuffer() != null) {
    this.channelsWithWriteBuffers.remove(channelWrapper);
  }
}","/** 
 * Called by the attached output channel wrapper to forward a   {@link TransferEnvelope} objectto its final destination. Within this method the provided transfer envelope is possibly also forwarded to the assigned ephemeral checkpoint.
 * @param channelWrapper the channel wrapper which called this method
 * @param outgoingTransferEnvelope the transfer envelope to be forwarded
 * @throws IOException thrown if an I/O error occurs while processing the envelope
 * @throws InterruptedException thrown if the thread is interrupted while waiting for the envelope to be processed
 */
public void processEnvelope(ByteBufferedOutputChannelWrapper channelWrapper,TransferEnvelope outgoingTransferEnvelope) throws IOException, InterruptedException {
  final TransferEnvelopeProcessingLog processingLog=outgoingTransferEnvelope.getProcessingLog();
  if (this.ephemeralCheckpoint != null && processingLog.mustBeWrittenToCheckpoint()) {
    this.ephemeralCheckpoint.addTransferEnvelope(outgoingTransferEnvelope);
    final EventList eventList=outgoingTransferEnvelope.getEventList();
    if (!eventList.isEmpty()) {
      final Iterator<AbstractEvent> it=eventList.iterator();
      while (it.hasNext()) {
        if (it.next() instanceof ByteBufferedChannelCloseEvent && this.commonChannelType == ChannelType.FILE) {
          ;
          System.out.println(""String_Node_Str"" + outgoingTransferEnvelope.getSequenceNumber() + ""String_Node_Str""+ outgoingTransferEnvelope.getSource());
          this.ephemeralCheckpoint.markChannelAsFinished(outgoingTransferEnvelope.getSource(),outgoingTransferEnvelope.getSequenceNumber());
          if (this.ephemeralCheckpoint.isPersistent() && this.commonChannelType == ChannelType.FILE) {
            channelWrapper.processEvent(new ByteBufferedChannelCloseEvent());
          }
          break;
        }
      }
    }
  }
  if (processingLog.mustBeSentViaNetwork() && !processingLog.isSentViaNetwork()) {
    this.byteBufferedChannelManager.queueOutgoingTransferEnvelope(outgoingTransferEnvelope);
  }
  if (outgoingTransferEnvelope.getBuffer() != null) {
    this.channelsWithWriteBuffers.remove(channelWrapper);
  }
}"
88045,"public void clear(){
  if (this.outgoingTransferEnvelope != null) {
    this.outgoingTransferEnvelope.getProcessingLog().setSentViaNetwork();
    this.outgoingTransferEnvelope=null;
  }
  this.sequenceNumber=0;
  if (this.uncompressedDataBuffer != null) {
    this.uncompressedDataBuffer.recycleBuffer();
  }
}","public void clear(){
  if (this.outgoingTransferEnvelope != null) {
    this.outgoingTransferEnvelope.getProcessingLog().setSentViaNetwork();
    this.outgoingTransferEnvelope=null;
  }
  this.sequenceNumber=0;
  if (this.uncompressedDataBuffer != null) {
    this.uncompressedDataBuffer.getInternalBuffer().recycleBuffer();
  }
}"
88046,"/** 
 * Sets the number of fields in the record. If the new number of fields is longer than the current number of fields, then null fields are appended. If the new number of fields is smaller than the current number of fields, then the last fields are truncated.
 * @param numFields The new number of fields.
 */
public void setNumFields(final int numFields){
  final int oldNumFields=this.numFields;
  if (numFields > oldNumFields) {
    makeSpace(numFields);
    for (int i=oldNumFields; i < numFields; i++) {
      this.offsets[i]=NULL_INDICATOR_OFFSET;
    }
  }
 else {
    if (this.lastUnmodifiedPos >= numFields)     this.lastUnmodifiedPos=numFields - 1;
  }
  this.numFields=numFields;
}","/** 
 * Sets the number of fields in the record. If the new number of fields is longer than the current number of fields, then null fields are appended. If the new number of fields is smaller than the current number of fields, then the last fields are truncated.
 * @param numFields The new number of fields.
 */
public void setNumFields(final int numFields){
  final int oldNumFields=this.numFields;
  if (numFields > oldNumFields) {
    makeSpace(numFields);
    for (int i=oldNumFields; i < numFields; i++) {
      this.offsets[i]=NULL_INDICATOR_OFFSET;
    }
  }
 else {
    if (this.lastUnmodifiedPos >= numFields)     this.lastUnmodifiedPos=numFields - 1;
    markModified(numFields);
  }
  this.numFields=numFields;
}"
88047,"private long byteBufferToLong(final ByteBuffer byteBuffer) throws IOException {
  long l=0;
  if (SIZEOFLONG > byteBuffer.limit()) {
    throw new IOException(""String_Node_Str"" + byteBuffer.limit() + ""String_Node_Str"");
  }
  for (int i=0; i < SIZEOFLONG; ++i) {
    l|=(byteBuffer.get((SIZEOFLONG - 1) - i) & 0xff) << (i << 3);
  }
  return l;
}","private long byteBufferToLong(final ByteBuffer byteBuffer) throws IOException {
  long l=0;
  if (SIZEOFLONG > byteBuffer.limit()) {
    throw new IOException(""String_Node_Str"" + byteBuffer.limit() + ""String_Node_Str"");
  }
  for (int i=0; i < SIZEOFLONG; ++i) {
    l|=(byteBuffer.get((SIZEOFLONG - 1) - i) & 0xffL) << (i << 3);
  }
  return l;
}"
88048,"private void longToByteBuffer(long longToSerialize,ByteBuffer byteBuffer) throws IOException {
  if (SIZEOFLONG > byteBuffer.capacity()) {
    throw new IOException(""String_Node_Str"" + byteBuffer.limit() + ""String_Node_Str""+ SIZEOFLONG+ ""String_Node_Str"");
  }
  byteBuffer.limit(SIZEOFLONG);
  for (int i=0; i < SIZEOFLONG; ++i) {
    final int shift=i << 3;
    byteBuffer.put((SIZEOFLONG - 1) - i,(byte)((longToSerialize & (0xff << shift)) >>> shift));
  }
}","private void longToByteBuffer(long longToSerialize,ByteBuffer byteBuffer) throws IOException {
  if (SIZEOFLONG > byteBuffer.capacity()) {
    throw new IOException(""String_Node_Str"" + byteBuffer.limit() + ""String_Node_Str""+ SIZEOFLONG+ ""String_Node_Str"");
  }
  byteBuffer.limit(SIZEOFLONG);
  for (int i=0; i < SIZEOFLONG; ++i) {
    final int shift=i << 3;
    byteBuffer.put((SIZEOFLONG - 1) - i,(byte)((longToSerialize & (0xffL << shift)) >>> shift));
  }
}"
88049,"/** 
 * {@inheritDoc}
 */
@Override public void allocatedResourcesDied(final JobID jobID,final List<AllocatedResource> allocatedResources){
}","/** 
 * {@inheritDoc}
 */
@Override public void allocatedResourcesDied(final JobID jobID,final List<AllocatedResource> allocatedResources){
  for (  final AllocatedResource allocatedResource : allocatedResources) {
    LOG.info(""String_Node_Str"" + allocatedResource.getInstance().getName() + ""String_Node_Str""+ jobID+ ""String_Node_Str"");
    ExecutionGraph job=this.jobQueue.getFirst();
synchronized (job) {
      Iterator<ExecutionGraph> iterator=this.jobQueue.descendingIterator();
      while (job.getJobID() != jobID) {
        if (iterator.hasNext()) {
          job=iterator.next();
        }
 else {
          LOG.error(""String_Node_Str"" + jobID + ""String_Node_Str"");
          return;
        }
      }
      List<ExecutionVertex> vertices=job.getVerticesAssignedToResource(allocatedResource);
      Iterator<ExecutionVertex> vertexIter=vertices.iterator();
      while (vertexIter.hasNext()) {
        ExecutionVertex vertex=vertexIter.next();
        vertex.updateExecutionState(ExecutionState.FAILED,""String_Node_Str"" + allocatedResource.getInstance().getName() + ""String_Node_Str""+ vertex.getEnvironment().getTaskName()+ ""String_Node_Str"");
        if (vertex.getExecutionState() == ExecutionState.FAILED) {
          job.executionStateChanged(jobID,vertex.getID(),ExecutionState.FAILED,""String_Node_Str"" + allocatedResource.getInstance().getName() + ""String_Node_Str""+ vertex.getEnvironment().getTaskName()+ ""String_Node_Str"");
          return;
        }
        vertex.setAllocatedResource(new AllocatedResource(DummyInstance.createDummyInstance(allocatedResource.getInstanceType()),allocatedResource.getInstanceType(),null));
      }
      try {
        LOG.info(""String_Node_Str"" + allocatedResource.getInstanceType().getIdentifier());
        final InstanceRequestMap instanceMap=new InstanceRequestMap();
        instanceMap.setMaximumNumberOfInstances(allocatedResource.getInstanceType(),1);
        instanceMap.setMinimumNumberOfInstances(allocatedResource.getInstanceType(),1);
        this.getInstanceManager().requestInstance(jobID,job.getJobConfiguration(),instanceMap,null);
      }
 catch (      InstanceException e) {
        e.printStackTrace();
      }
      job.executionStateChanged(jobID,vertices.get(0).getID(),ExecutionState.RECOVERING,null);
    }
  }
}"
88050,"/** 
 * {@inheritDoc}
 */
@Override public synchronized void executionStateChanged(final JobID jobID,final ExecutionVertexID vertexID,final ExecutionState newExecutionState,String optionalMessage){
  final InternalJobStatus oldStatus=this.jobStatus;
  checkAndUpdateJobStatus(newExecutionState);
  if (newExecutionState == ExecutionState.FINISHED) {
    if (this.isCurrentStageCompleted()) {
      ++this.indexToCurrentExecutionStage;
      if (this.indexToCurrentExecutionStage < this.stages.size()) {
        final Iterator<ExecutionStageListener> it=this.executionStageListeners.iterator();
        final ExecutionStage nextExecutionStage=getCurrentExecutionStage();
        while (it.hasNext()) {
          it.next().nextExecutionStageEntered(jobID,nextExecutionStage);
        }
      }
    }
  }
  if (this.jobStatus != oldStatus) {
    if (this.jobStatus == InternalJobStatus.FAILING) {
      this.errorDescription=optionalMessage;
    }
    if (this.jobStatus == InternalJobStatus.FAILED) {
      optionalMessage=this.errorDescription;
    }
    final Iterator<JobStatusListener> it=this.jobStatusListeners.iterator();
    while (it.hasNext()) {
      it.next().jobStatusHasChanged(this,this.jobStatus,optionalMessage);
    }
  }
}","/** 
 * {@inheritDoc}
 */
@Override public synchronized void executionStateChanged(final JobID jobID,final ExecutionVertexID vertexID,final ExecutionState newExecutionState,String optionalMessage){
  final InternalJobStatus oldStatus=this.jobStatus;
  if (newExecutionState == ExecutionState.RERUNNING) {
    this.recovering.remove(getVertexByID(vertexID));
  }
  checkAndUpdateJobStatus(newExecutionState);
  if (newExecutionState == ExecutionState.FINISHED) {
    if (this.isCurrentStageCompleted()) {
      ++this.indexToCurrentExecutionStage;
      if (this.indexToCurrentExecutionStage < this.stages.size()) {
        final Iterator<ExecutionStageListener> it=this.executionStageListeners.iterator();
        final ExecutionStage nextExecutionStage=getCurrentExecutionStage();
        while (it.hasNext()) {
          it.next().nextExecutionStageEntered(jobID,nextExecutionStage);
        }
      }
    }
  }
  if (this.jobStatus == InternalJobStatus.RECOVERING) {
    LOG.info(""String_Node_Str"");
    this.recovering.add(this.getVertexByID(vertexID));
  }
  if (this.jobStatus != oldStatus) {
    if (this.jobStatus == InternalJobStatus.FAILING) {
      this.errorDescription=optionalMessage;
    }
    if (this.jobStatus == InternalJobStatus.FAILED) {
      optionalMessage=this.errorDescription;
    }
    final Iterator<JobStatusListener> it=this.jobStatusListeners.iterator();
    while (it.hasNext()) {
      it.next().jobStatusHasChanged(this,this.jobStatus,optionalMessage);
    }
  }
}"
88051,"/** 
 * Checks and updates the current execution status of the job which is represented by this execution graph.
 * @param latestStateChange the latest execution state change which occurred
 */
public synchronized void checkAndUpdateJobStatus(final ExecutionState latestStateChange){
switch (this.jobStatus) {
case CREATED:
    if (jobHasScheduledStatus()) {
      this.jobStatus=InternalJobStatus.SCHEDULED;
    }
 else     if (latestStateChange == ExecutionState.CANCELED) {
      if (jobHasFailedOrCanceledStatus()) {
        this.jobStatus=InternalJobStatus.CANCELED;
      }
    }
  break;
case SCHEDULED:
if (latestStateChange == ExecutionState.RUNNING) {
  this.jobStatus=InternalJobStatus.RUNNING;
  return;
}
 else if (latestStateChange == ExecutionState.CANCELED) {
  if (jobHasFailedOrCanceledStatus()) {
    this.jobStatus=InternalJobStatus.CANCELED;
  }
}
break;
case RUNNING:
if (latestStateChange == ExecutionState.CANCELING || latestStateChange == ExecutionState.CANCELED) {
this.jobStatus=InternalJobStatus.CANCELING;
return;
}
if (latestStateChange == ExecutionState.FAILED) {
final Iterator<ExecutionVertex> it=new ExecutionGraphIterator(this,true);
while (it.hasNext()) {
final ExecutionVertex vertex=it.next();
if (vertex.getExecutionState() == ExecutionState.FAILED && !vertex.hasRetriesLeft()) {
this.jobStatus=InternalJobStatus.FAILING;
return;
}
}
}
if (jobHasFinishedStatus()) {
this.jobStatus=InternalJobStatus.FINISHED;
}
break;
case FAILING:
if (jobHasFailedOrCanceledStatus()) {
this.jobStatus=InternalJobStatus.FAILED;
}
break;
case FAILED:
LOG.error(""String_Node_Str"");
break;
case CANCELING:
if (jobHasFailedOrCanceledStatus()) {
this.jobStatus=InternalJobStatus.CANCELED;
}
break;
case CANCELED:
LOG.error(""String_Node_Str"");
break;
case FINISHED:
LOG.error(""String_Node_Str"");
break;
}
}","/** 
 * Checks and updates the current execution status of the job which is represented by this execution graph.
 * @param latestStateChange the latest execution state change which occurred
 */
public synchronized void checkAndUpdateJobStatus(final ExecutionState latestStateChange){
switch (this.jobStatus) {
case CREATED:
    if (jobHasScheduledStatus()) {
      this.jobStatus=InternalJobStatus.SCHEDULED;
    }
 else     if (latestStateChange == ExecutionState.CANCELED) {
      if (jobHasFailedOrCanceledStatus()) {
        this.jobStatus=InternalJobStatus.CANCELED;
      }
    }
  break;
case SCHEDULED:
if (latestStateChange == ExecutionState.RUNNING) {
  this.jobStatus=InternalJobStatus.RUNNING;
  return;
}
 else if (latestStateChange == ExecutionState.CANCELED) {
  if (jobHasFailedOrCanceledStatus()) {
    this.jobStatus=InternalJobStatus.CANCELED;
  }
}
break;
case RUNNING:
if (latestStateChange == ExecutionState.CANCELING || latestStateChange == ExecutionState.CANCELED) {
this.jobStatus=InternalJobStatus.CANCELING;
return;
}
if (latestStateChange == ExecutionState.FAILED) {
final Iterator<ExecutionVertex> it=new ExecutionGraphIterator(this,true);
while (it.hasNext()) {
final ExecutionVertex vertex=it.next();
if (vertex.getExecutionState() == ExecutionState.FAILED && !vertex.hasRetriesLeft()) {
this.jobStatus=InternalJobStatus.FAILING;
return;
}
}
}
if (latestStateChange == ExecutionState.RECOVERING) {
this.jobStatus=InternalJobStatus.RECOVERING;
return;
}
if (jobHasFinishedStatus()) {
this.jobStatus=InternalJobStatus.FINISHED;
}
break;
case RECOVERING:
if (latestStateChange == ExecutionState.RERUNNING) {
this.recovering.clear();
this.jobStatus=InternalJobStatus.RUNNING;
}
break;
case FAILING:
if (jobHasFailedOrCanceledStatus()) {
this.jobStatus=InternalJobStatus.FAILED;
}
break;
case FAILED:
LOG.error(""String_Node_Str"");
break;
case CANCELING:
if (jobHasFailedOrCanceledStatus()) {
this.jobStatus=InternalJobStatus.CANCELED;
}
break;
case CANCELED:
LOG.error(""String_Node_Str"");
break;
case FINISHED:
LOG.error(""String_Node_Str"");
break;
}
}"
88052,"/** 
 * {@inheritDoc}
 */
@Override public void jobStatusHasChanged(final ExecutionGraph executionGraph,final InternalJobStatus newJobStatus,final String optionalMessage){
synchronized (executionGraph) {
    LOG.info(""String_Node_Str"" + executionGraph.getJobName() + ""String_Node_Str""+ executionGraph.getJobID()+ ""String_Node_Str""+ ""String_Node_Str""+ newJobStatus);
  }
  if (newJobStatus == InternalJobStatus.CANCELING || newJobStatus == InternalJobStatus.FAILING) {
    cancelJob(executionGraph);
  }
  if (newJobStatus == InternalJobStatus.FINISHED) {
    removeAllCheckpoints(executionGraph);
  }
  if (newJobStatus == InternalJobStatus.CANCELED || newJobStatus == InternalJobStatus.FAILED || newJobStatus == InternalJobStatus.FINISHED) {
    unregisterJob(executionGraph);
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void jobStatusHasChanged(final ExecutionGraph executionGraph,final InternalJobStatus newJobStatus,final String optionalMessage){
synchronized (executionGraph) {
    LOG.info(""String_Node_Str"" + executionGraph.getJobName() + ""String_Node_Str""+ executionGraph.getJobID()+ ""String_Node_Str""+ ""String_Node_Str""+ newJobStatus);
  }
  if (newJobStatus == InternalJobStatus.CANCELING || newJobStatus == InternalJobStatus.FAILING) {
    cancelJob(executionGraph);
  }
  if (newJobStatus == InternalJobStatus.FINISHED) {
    removeAllCheckpoints(executionGraph);
  }
  if (newJobStatus == InternalJobStatus.CANCELED || newJobStatus == InternalJobStatus.FAILED || newJobStatus == InternalJobStatus.FINISHED) {
    unregisterJob(executionGraph);
  }
  if (newJobStatus == InternalJobStatus.RECOVERING) {
    try {
      RecoveryThread recoverythread=new RecoveryThread(executionGraph,this);
      recoverythread.start();
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
}"
88053,"private List<ExecutionVertex> findFollowers(ExecutionVertex vertex,ArrayList<ExecutionVertex> restart){
  ArrayList<ExecutionVertex> follower=new ArrayList<ExecutionVertex>();
  for (int i=0; i < vertex.getNumberOfSuccessors(); i++) {
    ExecutionVertex successor=vertex.getSuccessor(i);
    if (!restart.contains(successor)) {
      follower.add(successor);
      if (successor.getCheckpointState() == CheckpointState.COMPLETE) {
        this.checkpoints.remove(successor);
        final List<ExecutionVertexID> checkpointsToRemove=new ArrayList<ExecutionVertexID>();
        checkpointsToRemove.add(successor.getID());
        try {
          successor.getAllocatedResource().getInstance().removeCheckpoints(checkpointsToRemove);
        }
 catch (        IOException e) {
          e.printStackTrace();
        }
      }
    }
  }
  return follower;
}","private List<ExecutionVertex> findFollowers(ExecutionVertex vertex,ArrayList<ExecutionVertex> restart){
  ArrayList<ExecutionVertex> follower=new ArrayList<ExecutionVertex>();
  for (int i=0; i < vertex.getNumberOfSuccessors(); i++) {
    ExecutionVertex successor=vertex.getSuccessor(i);
    if (!restart.contains(successor)) {
      follower.add(successor);
      if (successor.getCheckpointState() == CheckpointState.PARTIAL) {
        this.checkpoints.remove(successor);
        final List<ExecutionVertexID> checkpointsToRemove=new ArrayList<ExecutionVertexID>();
        checkpointsToRemove.add(successor.getID());
        try {
          successor.getAllocatedResource().getInstance().removeCheckpoints(checkpointsToRemove);
        }
 catch (        IOException e) {
          e.printStackTrace();
        }
      }
    }
  }
  return follower;
}"
88054,"/** 
 * @param failed
 * @return
 */
private List<ExecutionVertex> findRestarts(ExecutionVertex failed){
  LOG.info(""String_Node_Str"");
  ArrayList<ExecutionVertex> restart=new ArrayList<ExecutionVertex>();
  Queue<ExecutionVertex> totest=new ArrayDeque<ExecutionVertex>();
  ArrayList<ExecutionVertex> visited=new ArrayList<ExecutionVertex>();
  totest.add(failed);
  int k=0;
  LOG.info(""String_Node_Str"");
  ExecutionVertex vertex=failed;
  while (!totest.isEmpty()) {
    LOG.info(""String_Node_Str"");
    if (k != 0) {
      vertex=totest.peek();
    }
    LOG.info(""String_Node_Str"" + vertex.getName());
    k++;
    totest.remove(vertex);
    if (!restart.contains(vertex)) {
      restart.add(vertex);
    }
    for (int i=0; i < vertex.getNumberOfSuccessors(); i++) {
      ExecutionVertex successor=vertex.getSuccessor(i);
      restart.add(successor);
      LOG.info(""String_Node_Str"" + successor.getName() + ""String_Node_Str"");
      if (successor.getCheckpointState() == CheckpointState.COMPLETE) {
        this.checkpoints.remove(successor);
      }
      List<ExecutionVertex> follower=findFollowers(successor,restart);
      restart.addAll(follower);
      Iterator<ExecutionVertex> iter=follower.iterator();
      while (iter.hasNext()) {
        ExecutionVertex follow=iter.next();
        if (!visited.contains(follow)) {
          LOG.info(""String_Node_Str"" + follow.getName());
          totest.add(follow);
        }
      }
    }
    for (int j=0; j < vertex.getNumberOfPredecessors(); j++) {
      ExecutionVertex predecessor=vertex.getPredecessor(j);
      if (predecessor.getCheckpointState() != CheckpointState.COMPLETE) {
        LOG.info(""String_Node_Str"" + predecessor.getName() + ""String_Node_Str"");
        restart.add(predecessor);
        if (!visited.contains(predecessor)) {
          totest.add(predecessor);
          LOG.info(""String_Node_Str"" + predecessor);
        }
      }
 else {
        if (!this.globalConsistentCheckpoint.contains(predecessor)) {
          this.globalConsistentCheckpoint.add(predecessor);
        }
        List<ExecutionVertex> follower=findFollowers(predecessor,restart);
        for (int i=0; i < follower.size(); i++) {
          LOG.info(""String_Node_Str"" + follower.get(i) + ""String_Node_Str"");
        }
        restart.addAll(follower);
        Iterator<ExecutionVertex> iter=follower.iterator();
        while (iter.hasNext()) {
          ExecutionVertex follow=iter.next();
          if (!visited.contains(follow)) {
            LOG.info(""String_Node_Str"" + follow.getName());
            totest.add(follow);
          }
        }
      }
    }
    visited.add(vertex);
  }
  LOG.info(""String_Node_Str"");
  return restart;
}","/** 
 * @param failed
 * @return
 */
private List<ExecutionVertex> findRestarts(ExecutionVertex failed){
  LOG.info(""String_Node_Str"");
  ArrayList<ExecutionVertex> restart=new ArrayList<ExecutionVertex>();
  Queue<ExecutionVertex> totest=new ArrayDeque<ExecutionVertex>();
  ArrayList<ExecutionVertex> visited=new ArrayList<ExecutionVertex>();
  totest.add(failed);
  int k=0;
  LOG.info(""String_Node_Str"");
  ExecutionVertex vertex=failed;
  while (!totest.isEmpty()) {
    LOG.info(""String_Node_Str"");
    if (k != 0) {
      vertex=totest.peek();
    }
    LOG.info(""String_Node_Str"" + vertex.getName());
    k++;
    totest.remove(vertex);
    if (!restart.contains(vertex)) {
      restart.add(vertex);
    }
    for (int i=0; i < vertex.getNumberOfSuccessors(); i++) {
      ExecutionVertex successor=vertex.getSuccessor(i);
      restart.add(successor);
      LOG.info(""String_Node_Str"" + successor.getName() + ""String_Node_Str"");
      if (successor.getCheckpointState() == CheckpointState.PARTIAL) {
        this.checkpoints.remove(successor);
      }
      List<ExecutionVertex> follower=findFollowers(successor,restart);
      restart.addAll(follower);
      Iterator<ExecutionVertex> iter=follower.iterator();
      while (iter.hasNext()) {
        ExecutionVertex follow=iter.next();
        if (!visited.contains(follow)) {
          LOG.info(""String_Node_Str"" + follow.getName());
          totest.add(follow);
        }
      }
    }
    for (int j=0; j < vertex.getNumberOfPredecessors(); j++) {
      ExecutionVertex predecessor=vertex.getPredecessor(j);
      if (predecessor.getCheckpointState() != CheckpointState.PARTIAL) {
        LOG.info(""String_Node_Str"" + predecessor.getName() + ""String_Node_Str"");
        restart.add(predecessor);
        if (!visited.contains(predecessor)) {
          totest.add(predecessor);
          LOG.info(""String_Node_Str"" + predecessor);
        }
      }
 else {
        if (!this.globalConsistentCheckpoint.contains(predecessor)) {
          this.globalConsistentCheckpoint.add(predecessor);
        }
        List<ExecutionVertex> follower=findFollowers(predecessor,restart);
        for (int i=0; i < follower.size(); i++) {
          LOG.info(""String_Node_Str"" + follower.get(i) + ""String_Node_Str"");
        }
        restart.addAll(follower);
        Iterator<ExecutionVertex> iter=follower.iterator();
        while (iter.hasNext()) {
          ExecutionVertex follow=iter.next();
          if (!visited.contains(follow)) {
            LOG.info(""String_Node_Str"" + follow.getName());
            totest.add(follow);
          }
        }
      }
    }
    visited.add(vertex);
  }
  LOG.info(""String_Node_Str"");
  return restart;
}"
88055,"void executionStateChanged(final JobID jobID,final ExecutionVertexID id,final Task task,final ExecutionState newExecutionState,final String optionalDescription){
  if (newExecutionState == ExecutionState.RUNNING) {
synchronized (this.runningTasks) {
      this.runningTasks.put(id,task);
    }
  }
  if (newExecutionState == ExecutionState.FINISHED || newExecutionState == ExecutionState.CANCELED || newExecutionState == ExecutionState.FAILED) {
synchronized (this.runningTasks) {
      this.runningTasks.remove(id);
    }
    unregisterTask(id,task);
  }
synchronized (this.jobManager) {
    try {
      this.jobManager.updateTaskExecutionState(new TaskExecutionState(jobID,id,newExecutionState,optionalDescription));
    }
 catch (    IOException e) {
      LOG.error(StringUtils.stringifyException(e));
    }
  }
}","void executionStateChanged(final JobID jobID,final ExecutionVertexID id,final Task task,final ExecutionState newExecutionState,final String optionalDescription){
  if (newExecutionState == ExecutionState.RUNNING || newExecutionState == ExecutionState.RUNNING) {
synchronized (this.runningTasks) {
      this.runningTasks.put(id,task);
    }
  }
  if (newExecutionState == ExecutionState.FINISHED || newExecutionState == ExecutionState.CANCELED || newExecutionState == ExecutionState.FAILED) {
synchronized (this.runningTasks) {
      this.runningTasks.remove(id);
    }
    unregisterTask(id,task);
  }
synchronized (this.jobManager) {
    try {
      this.jobManager.updateTaskExecutionState(new TaskExecutionState(jobID,id,newExecutionState,optionalDescription));
    }
 catch (    IOException e) {
      LOG.error(StringUtils.stringifyException(e));
    }
  }
}"
88056,"/** 
 * Initializes the PactString to a sub-string of the given PactString. 
 * @param value The string containing the substring.
 * @param offset The offset of the substring.
 * @param len The length of the substring.
 */
public PactString(final PactString value,final int offset,final int len){
  setValue(value,offset,len);
}","/** 
 * Initializes the PactString to a sub-string of the given PactString. 
 * @param value The string containing the substring.
 * @param offset The offset of the substring.
 * @param len The length of the substring.
 */
public PactString(final PactString value,final int offset,final int len){
  this.value=EMPTY_STRING;
  setValue(value,offset,len);
}"
88057,"/** 
 * Writes this buffer completely to the given writer.
 * @param writer The writer to write the segment to.
 * @throws IOException Thrown, if the writer caused an I/O exception.
 */
public void writeToChannel(final Writer writer) throws IOException {
  int recordsLeft=this.numRecords;
  int currentMemSeg=0;
  while (recordsLeft > 0) {
    final MemorySegment currentIndexSegment=this.sortIndex.get(currentMemSeg++);
    int offset=0;
    if (recordsLeft >= this.indexEntriesPerSegment) {
      for (; offset <= this.lastIndexEntryOffset; offset+=this.indexEntrySize) {
        final long pointer=currentIndexSegment.getLong(offset);
      }
      recordsLeft-=this.indexEntriesPerSegment;
    }
 else {
      for (; recordsLeft > 0; recordsLeft--, offset+=this.indexEntrySize) {
        final long pointer=currentIndexSegment.getLong(offset);
      }
    }
  }
}","/** 
 * Writes this buffer completely to the given writer.
 * @param writer The writer to write the segment to.
 * @throws IOException Thrown, if the writer caused an I/O exception.
 */
public void writeToChannel(final Writer writer) throws IOException {
  throw new UnsupportedOperationException();
}"
88058,"public void setKey(int key){
  this.key=key;
}","public void setKey(int key){
  setValue(key);
}"
88059,"public int getKey(){
  return key;
}","public int getKey(){
  return getValue();
}"
88060,"public Key(int k){
  key=k;
}","public Key(int k){
  super(k);
}"
88061,"public int compare(int i,int j){
  final int bufferNumI=i / this.indexEntriesPerSegment;
  final int segmentOffsetI=(i % this.indexEntriesPerSegment) * this.indexEntrySize;
  final int bufferNumJ=j / this.indexEntriesPerSegment;
  final int segmentOffsetJ=(j % this.indexEntriesPerSegment) * this.indexEntrySize;
  final MemorySegment segI=this.sortIndex.get(bufferNumI);
  final MemorySegment segJ=this.sortIndex.get(bufferNumJ);
  final byte[] bI=segI.getBackingArray();
  final byte[] bJ=segJ.getBackingArray();
  int val=0;
  for (int pos=0, posI=segI.translateOffset(segmentOffsetI + OFFSET_LEN), posJ=segJ.translateOffset(segmentOffsetJ + OFFSET_LEN); pos < this.numKeyBytes & (val=(bI[posI] & 0xff) - (bJ[posJ] & 0xff)) == 0; pos++, posI++, posJ++)   ;
  if (val != 0 || this.normalizedKeyFullyDetermines) {
    return val;
  }
  final long pointerI=segI.getLong(segmentOffsetI);
  final long pointerJ=segJ.getLong(segmentOffsetJ);
  return compareRecords(pointerI,pointerJ);
}","public int compare(int i,int j){
  final int bufferNumI=i / this.indexEntriesPerSegment;
  final int segmentOffsetI=(i % this.indexEntriesPerSegment) * this.indexEntrySize;
  final int bufferNumJ=j / this.indexEntriesPerSegment;
  final int segmentOffsetJ=(j % this.indexEntriesPerSegment) * this.indexEntrySize;
  final MemorySegment segI=this.sortIndex.get(bufferNumI);
  final MemorySegment segJ=this.sortIndex.get(bufferNumJ);
  final byte[] bI=segI.getBackingArray();
  final byte[] bJ=segJ.getBackingArray();
  int val=0;
  for (int pos=0, posI=segI.translateOffset(segmentOffsetI + OFFSET_LEN), posJ=segJ.translateOffset(segmentOffsetJ + OFFSET_LEN); pos < this.numKeyBytes && (val=(bI[posI] & 0xff) - (bJ[posJ] & 0xff)) == 0; pos++, posI++, posJ++)   ;
  if (val != 0 || this.normalizedKeyFullyDetermines) {
    return val;
  }
  final long pointerI=segI.getLong(segmentOffsetI);
  final long pointerJ=segJ.getLong(segmentOffsetJ);
  return compareRecords(pointerI,pointerJ);
}"
88062,"public List<MemorySegment> dispose(){
  this.freeMemory.addAll(this.sortIndex);
  this.freeMemory.addAll(this.recordBuffers);
  this.recordBuffers.clear();
  this.sortIndex.clear();
  return this.freeMemory;
}","/** 
 * Collects all memory segments from this sorter.
 * @return All memory segments from this sorter.
 */
public List<MemorySegment> dispose(){
  this.freeMemory.addAll(this.sortIndex);
  this.freeMemory.addAll(this.recordBuffers);
  this.recordBuffers.clear();
  this.sortIndex.clear();
  return this.freeMemory;
}"
88063,"@Test public void testSort() throws Exception {
  final int numSegments=MEMORY_SIZE / MEMORY_SEGMENT_SIZE;
  final List<MemorySegment> memory=this.memoryManager.allocate(new DummyInvokable(),numSegments,MEMORY_SEGMENT_SIZE);
  NormalizedKeySorter<PactRecord> sorter=newSortBuffer(memory);
  TestData.Generator generator=new TestData.Generator(SEED,KEY_MAX,VALUE_LENGTH,KeyMode.RANDOM,ValueMode.RANDOM_LENGTH);
  long writeStart=System.nanoTime();
  PactRecord record=new PactRecord();
  do {
    generator.next(record);
  }
 while (sorter.write(record));
  long writeStop=System.nanoTime();
  System.out.println(""String_Node_Str"" + (writeStop - writeStart) / 1000000 + ""String_Node_Str"");
  long sortStart=System.nanoTime();
  QuickSort qs=new QuickSort();
  qs.sort(sorter);
  long sortStop=System.nanoTime();
  System.out.println(""String_Node_Str"" + (sortStop - sortStart) / 1000000 + ""String_Node_Str"");
  MutableObjectIterator<PactRecord> iter=sorter.getIterator();
  PactRecord readTarget=new PactRecord();
  Key current=new Key();
  Key last=new Key();
  iter.next(readTarget);
  readTarget.getFieldInto(0,last);
  while (iter.next(readTarget)) {
    readTarget.getFieldInto(0,current);
    final int cmp=last.compareTo(current);
    if (cmp > 0)     Assert.fail(""String_Node_Str"");
    Key tmp=current;
    current=last;
    last=tmp;
  }
  this.memoryManager.release(sorter.dispose());
}","@Test public void testSort() throws Exception {
  final int numSegments=MEMORY_SIZE / MEMORY_SEGMENT_SIZE;
  final List<MemorySegment> memory=this.memoryManager.allocate(new DummyInvokable(),numSegments,MEMORY_SEGMENT_SIZE);
  NormalizedKeySorter<PactRecord> sorter=newSortBuffer(memory);
  TestData.Generator generator=new TestData.Generator(SEED,KEY_MAX,VALUE_LENGTH,KeyMode.RANDOM,ValueMode.RANDOM_LENGTH);
  PactRecord record=new PactRecord();
  do {
    generator.next(record);
  }
 while (sorter.write(record));
  QuickSort qs=new QuickSort();
  qs.sort(sorter);
  MutableObjectIterator<PactRecord> iter=sorter.getIterator();
  PactRecord readTarget=new PactRecord();
  Key current=new Key();
  Key last=new Key();
  iter.next(readTarget);
  readTarget.getFieldInto(0,last);
  while (iter.next(readTarget)) {
    readTarget.getFieldInto(0,current);
    final int cmp=last.compareTo(current);
    if (cmp > 0)     Assert.fail(""String_Node_Str"");
    Key tmp=current;
    current=last;
    last=tmp;
  }
  this.memoryManager.release(sorter.dispose());
}"
88064,"/** 
 * Emit the candidate.
 * @param left
 * @param right
 */
protected void emitCandidate(KeyValuePair<JsonNode,JsonNode> left,KeyValuePair<JsonNode,JsonNode> right){
  EvaluationExpression resultProjection1=this.resultProjection1, resultProjection2=this.resultProjection2;
  if (resultProjection1 == null)   resultProjection1=EvaluationExpression.VALUE;
  if (resultProjection2 == null)   resultProjection2=EvaluationExpression.VALUE;
  final EvaluationContext context=this.getContext();
  this.sopremoTestPlan.getExpectedOutput(0).add(createPactJsonArray(resultProjection1.evaluate(left.getValue(),context),resultProjection2.evaluate(right.getValue(),context)));
}","/** 
 * Emit the candidate.
 * @param left
 * @param right
 */
protected void emitCandidate(KeyValuePair<JsonNode,JsonNode> left,KeyValuePair<JsonNode,JsonNode> right){
  EvaluationExpression resultProjection1=this.resultProjection1, resultProjection2=this.resultProjection2;
  if (resultProjection1 == null)   resultProjection1=EvaluationExpression.VALUE;
  if (resultProjection2 == null)   resultProjection2=EvaluationExpression.VALUE;
  final EvaluationContext context=this.getContext();
  this.sopremoTestPlan.getExpectedOutput(0).add(new ArrayNode(resultProjection1.evaluate(left.getValue(),context),resultProjection2.evaluate(right.getValue(),context)));
}"
88065,"private JsonNode flatArrayOfElements(SopremoTestPlan testPlan,int[]... ids){
  ArrayNode array=new ArrayNode();
  for (int sourceIndex=0; sourceIndex < ids.length; sourceIndex++) {
    EvaluationExpression resultProjection=this.resultProjections[sourceIndex];
    if (resultProjection == null)     resultProjection=EvaluationExpression.VALUE;
    for (int tupleIndex=0; tupleIndex < ids[sourceIndex].length; tupleIndex++)     array.add(resultProjection.evaluate(this.findTuple(testPlan,sourceIndex,ids[sourceIndex][tupleIndex]),testPlan.getEvaluationContext()));
  }
  return new JsonNode(array);
}","private JsonNode flatArrayOfElements(SopremoTestPlan testPlan,int[]... ids){
  ArrayNode array=new ArrayNode();
  for (int sourceIndex=0; sourceIndex < ids.length; sourceIndex++) {
    EvaluationExpression resultProjection=this.resultProjections[sourceIndex];
    if (resultProjection == null)     resultProjection=EvaluationExpression.VALUE;
    for (int tupleIndex=0; tupleIndex < ids[sourceIndex].length; tupleIndex++)     array.add(resultProjection.evaluate(this.findTuple(testPlan,sourceIndex,ids[sourceIndex][tupleIndex]),testPlan.getEvaluationContext()));
  }
  return new ArrayNode(array);
}"
88066,"private void writeObject(final ObjectOutputStream oos) throws IOException {
  oos.defaultWriteObject();
  new JsonNode(this.initialAggregate).write(oos);
}","private void writeObject(final ObjectOutputStream oos) throws IOException {
  oos.defaultWriteObject();
  this.initialAggregate.write(oos);
}"
88067,"@Override public void initialize(){
  try {
    final ByteArrayOutputStream cloneBuffer=new ByteArrayOutputStream();
    final JsonNode cloner=new JsonNode(this.initialAggregate);
    cloner.write(new DataOutputStream(cloneBuffer));
    cloner.read(new DataInputStream(new ByteArrayInputStream(cloneBuffer.toByteArray())));
    this.aggregate=cloner;
  }
 catch (  final IOException e) {
    throw new IllegalStateException(""String_Node_Str"");
  }
}","@Override public void initialize(){
  try {
    final ByteArrayOutputStream cloneBuffer=new ByteArrayOutputStream();
    final JsonNode cloner=this.initialAggregate;
    cloner.write(new DataOutputStream(cloneBuffer));
    cloner.read(new DataInputStream(new ByteArrayInputStream(cloneBuffer.toByteArray())));
    this.aggregate=cloner;
  }
 catch (  final IOException e) {
    throw new IllegalStateException(""String_Node_Str"");
  }
}"
88068,"private void readObject(final ObjectInputStream ois) throws IOException, ClassNotFoundException {
  ois.defaultReadObject();
  final JsonNode pactJsonObject=new JsonNode();
  pactJsonObject.read(ois);
  this.initialAggregate=pactJsonObject;
}","private void readObject(final ObjectInputStream ois) throws IOException, ClassNotFoundException {
  ois.defaultReadObject();
  final JsonNode jsonObject=new ObjectNode();
  jsonObject.read(ois);
  this.initialAggregate=jsonObject;
}"
88069,"public void writeTree(JsonNode value) throws IOException {
  if (value != null) {
    this.writer.write(value.toString());
    this.writer.flush();
  }
}","public void writeTree(JsonNode value) throws IOException {
  if (value != null) {
    if (!this.isFirst) {
      this.writer.write(""String_Node_Str"");
    }
    this.writer.write(value.toString());
    this.writer.flush();
    this.isFirst=false;
  }
}"
88070,"public void writeEndArray() throws IOException {
  JsonToken.END_ARRAY.write(this.writer);
}","public void writeEndArray() throws IOException {
  JsonToken.END_ARRAY.write(this.writer);
  this.writer.flush();
}"
88071,"public void writeStartArray() throws IOException {
  JsonToken.START_ARRAY.write(this.writer);
}","public void writeStartArray() throws IOException {
  JsonToken.START_ARRAY.write(this.writer);
  this.writer.flush();
}"
88072,"@Override public int compareTo(Key o){
  return 0;
}","@Override public int compareTo(Key other){
  ArrayNode node=(ArrayNode)other;
  if (node.size() != this.size()) {
    return 1;
  }
  for (int i=0; i < this.size(); i++) {
    int comp=this.get(i).compareTo(node.get(i));
    if (comp != 0) {
      return comp;
    }
  }
  return 0;
}"
88073,"@Override public KeyValuePair<JsonNode,JsonNode> createPair(){
  return new KeyValuePair<JsonNode,JsonNode>(NullNode.getInstance(),new PactJsonObject());
}","@Override public KeyValuePair<JsonNode,JsonNode> createPair(){
  return new KeyValuePair<JsonNode,JsonNode>(NullNode.getInstance(),new ObjectNode());
}"
88074,"@Parameters public static List<Object[]> combinations(){
  return Arrays.asList(new Object[][]{{""String_Node_Str"",IntNode.valueOf(42),1},{""String_Node_Str"",IntNode.valueOf(42),1},{""String_Node_Str"",NullNode.getInstance(),1},{""String_Node_Str"",BooleanNode.TRUE,1},{""String_Node_Str"",BooleanNode.FALSE,1},{""String_Node_Str"",DecimalNode.valueOf(BigDecimal.valueOf(42.42)),1},{String.valueOf(""String_Node_Str"" + String.valueOf(Long.valueOf(Integer.MAX_VALUE) + 1) + ""String_Node_Str""),LongNode.valueOf(Long.valueOf(Integer.MAX_VALUE) + 1),1},{String.valueOf(""String_Node_Str"" + BigInteger.valueOf(Long.MAX_VALUE).add(BigInteger.ONE) + ""String_Node_Str""),BigIntegerNode.valueOf(BigInteger.valueOf(Long.MAX_VALUE).add(BigInteger.ONE)),1},{""String_Node_Str"",TextNode.valueOf(""String_Node_Str""),1},{""String_Node_Str"",IntNode.valueOf(23),2},{""String_Node_Str"",new ArrayNode().add(IntNode.valueOf(23)).add(new ArrayNode().add(new ArrayNode().add(IntNode.valueOf(24)).add(IntNode.valueOf(55))).add(IntNode.valueOf(12)).add(IntNode.valueOf(17))),2},{""String_Node_Str"",TextNode.valueOf(""String_Node_Str""),1},{""String_Node_Str"",TextNode.valueOf(""String_Node_Str""),1},{""String_Node_Str"",new ArrayNode().add(IntNode.valueOf(23)).add(new ArrayNode().add(new ArrayNode().add(IntNode.valueOf(24)).add(TextNode.valueOf(""String_Node_Str""))).add(IntNode.valueOf(12)).add(TextNode.valueOf(""String_Node_Str""))),2},{""String_Node_Str"",IntNode.valueOf(42),2},{""String_Node_Str"",new ObjectNode().put(""String_Node_Str"",IntNode.valueOf(42)),1},{""String_Node_Str"",new ObjectNode().put(""String_Node_Str"",new ArrayNode().add(IntNode.valueOf(1)).add(IntNode.valueOf(3)).add(TextNode.valueOf(""String_Node_Str""))).put(""String_Node_Str"",new ObjectNode().put(""String_Node_Str"",IntNode.valueOf(23))),1},{""String_Node_Str"",IntNode.valueOf(5),5}});
}","@Parameters public static List<Object[]> combinations(){
  return Arrays.asList(new Object[][]{{""String_Node_Str"",IntNode.valueOf(42),1},{""String_Node_Str"",IntNode.valueOf(42),1},{""String_Node_Str"",NullNode.getInstance(),1},{""String_Node_Str"",NullNode.getInstance(),1},{""String_Node_Str"",NullNode.getInstance(),2},{""String_Node_Str"",BooleanNode.TRUE,1},{""String_Node_Str"",BooleanNode.FALSE,1},{""String_Node_Str"",DecimalNode.valueOf(BigDecimal.valueOf(42.42)),1},{String.valueOf(""String_Node_Str"" + String.valueOf(Long.valueOf(Integer.MAX_VALUE) + 1) + ""String_Node_Str""),LongNode.valueOf(Long.valueOf(Integer.MAX_VALUE) + 1),1},{String.valueOf(""String_Node_Str"" + BigInteger.valueOf(Long.MAX_VALUE).add(BigInteger.ONE) + ""String_Node_Str""),BigIntegerNode.valueOf(BigInteger.valueOf(Long.MAX_VALUE).add(BigInteger.ONE)),1},{""String_Node_Str"",TextNode.valueOf(""String_Node_Str""),1},{""String_Node_Str"",IntNode.valueOf(23),2},{""String_Node_Str"",new ArrayNode().add(IntNode.valueOf(23)).add(new ArrayNode().add(new ArrayNode().add(IntNode.valueOf(24)).add(IntNode.valueOf(55))).add(IntNode.valueOf(12)).add(IntNode.valueOf(17))),2},{""String_Node_Str"",TextNode.valueOf(""String_Node_Str""),1},{""String_Node_Str"",TextNode.valueOf(""String_Node_Str""),1},{""String_Node_Str"",new ArrayNode().add(IntNode.valueOf(23)).add(new ArrayNode().add(new ArrayNode().add(IntNode.valueOf(24)).add(TextNode.valueOf(""String_Node_Str""))).add(IntNode.valueOf(12)).add(TextNode.valueOf(""String_Node_Str""))),2},{""String_Node_Str"",IntNode.valueOf(42),2},{""String_Node_Str"",new ObjectNode().put(""String_Node_Str"",IntNode.valueOf(42)),1},{""String_Node_Str"",new ObjectNode().put(""String_Node_Str"",NullNode.getInstance()),1},{""String_Node_Str"",new ObjectNode().put(""String_Node_Str"",new ArrayNode().add(IntNode.valueOf(1)).add(IntNode.valueOf(3)).add(TextNode.valueOf(""String_Node_Str""))).put(""String_Node_Str"",new ObjectNode().put(""String_Node_Str"",IntNode.valueOf(23))),1},{""String_Node_Str"",NullNode.getInstance(),5}});
}"
88075,"/** 
 * @param pair
 * @param hashCode
 * @throws IOException
 */
protected final void insertIntoTable(final PactRecord record,final int hashCode) throws IOException {
  final int posHashCode=hashCode % this.numBuckets;
  final int bucketArrayPos=posHashCode >> this.bucketsPerSegmentBits;
  final int bucketInSegmentPos=(posHashCode & this.bucketsPerSegmentMask) << NUM_INTRA_BUCKET_BITS;
  final MemorySegment bucket=this.buckets[bucketArrayPos];
  final int partitionNumber=bucket.get(bucketInSegmentPos + HEADER_PARTITION_OFFSET);
  if (partitionNumber < 0 || partitionNumber >= this.partitionsBeingBuilt.size()) {
    throw new RuntimeException(""String_Node_Str"");
  }
  final Partition p=this.partitionsBeingBuilt.get(partitionNumber);
  long pointer=p.insertIntoBuildBuffer(record);
  if (pointer == -1) {
    MemorySegment nextSeg=getNextBuffer();
    if (nextSeg == null) {
      spillPartition();
      nextSeg=getNextBuffer();
      if (nextSeg == null) {
        throw new RuntimeException(""String_Node_Str"");
      }
    }
    p.addBuildSideBuffer(nextSeg);
    pointer=p.insertIntoBuildBuffer(record);
    if (pointer == -1) {
      throw new IOException(""String_Node_Str"");
    }
  }
  if (p.isInMemory()) {
    insertBucketEntry(p,bucket,bucketInSegmentPos,hashCode,pointer);
  }
 else {
    return;
  }
}","/** 
 * @param pair
 * @param hashCode
 * @throws IOException
 */
protected final void insertIntoTable(final PactRecord record,final int hashCode) throws IOException {
  final int posHashCode=hashCode % this.numBuckets;
  final int bucketArrayPos=posHashCode >> this.bucketsPerSegmentBits;
  final int bucketInSegmentPos=(posHashCode & this.bucketsPerSegmentMask) << NUM_INTRA_BUCKET_BITS;
  final MemorySegment bucket=this.buckets[bucketArrayPos];
  final int partitionNumber=bucket.get(bucketInSegmentPos + HEADER_PARTITION_OFFSET);
  if (partitionNumber < 0 || partitionNumber >= this.partitionsBeingBuilt.size()) {
    throw new RuntimeException(""String_Node_Str"");
  }
  final Partition p=this.partitionsBeingBuilt.get(partitionNumber);
  long pointer=p.insertIntoBuildBuffer(record);
  if (pointer == -1) {
    MemorySegment nextSeg=getNextBuffer();
    if (nextSeg == null) {
      int spilledPartitionNum=spillPartition();
      if (spilledPartitionNum != partitionNumber) {
        nextSeg=getNextBuffer();
        if (nextSeg == null) {
          throw new RuntimeException(""String_Node_Str"");
        }
        p.addBuildSideBuffer(nextSeg);
      }
    }
 else {
      p.addBuildSideBuffer(nextSeg);
    }
    pointer=p.insertIntoBuildBuffer(record);
    if (pointer == -1) {
      throw new IOException(""String_Node_Str"");
    }
  }
  if (p.isInMemory()) {
    insertBucketEntry(p,bucket,bucketInSegmentPos,hashCode,pointer);
  }
 else {
    return;
  }
}"
88076,"/** 
 * Checks whether there is a floating instance with the specific type. If there are instances available, they will be removed from the list and returned...
 * @param awsAccessId the access ID into AWS
 * @param awsSecretKey the secret key used to generate signatures for authentication
 * @param type the type of the floating instance, which is checked
 * @return a list of suitable floating instances.
 * @throws InstanceException something wrong happens to the global configuration
 */
private LinkedList<FloatingInstance> anyFloatingInstancesAvailable(final String awsAccessId,final String awsSecretKey,final InstanceType type,final int count) throws InstanceException {
  LOG.info(""String_Node_Str"" + count + ""String_Node_Str""+ type.getIdentifier());
  final LinkedList<FloatingInstance> foundfloatinginstances=new LinkedList<FloatingInstance>();
synchronized (this.floatingInstances) {
    final Iterator<Map.Entry<InstanceConnectionInfo,FloatingInstance>> it=this.floatingInstances.entrySet().iterator();
    while (it.hasNext()) {
      final FloatingInstance i=it.next().getValue();
      if (i.isFromThisOwner(awsAccessId,awsSecretKey)) {
        if (i.getType().equals(type)) {
          it.remove();
          foundfloatinginstances.add(i);
        }
      }
    }
  }
  LOG.info(""String_Node_Str"" + foundfloatinginstances.size() + ""String_Node_Str"");
  return foundfloatinginstances;
}","/** 
 * Checks whether there is a floating instance with the specific type. If there are instances available, they will be removed from the list and returned...
 * @param awsAccessId the access ID into AWS
 * @param awsSecretKey the secret key used to generate signatures for authentication
 * @param type the type of the floating instance, which is checked
 * @return a list of suitable floating instances.
 * @throws InstanceException something wrong happens to the global configuration
 */
private LinkedList<FloatingInstance> anyFloatingInstancesAvailable(final String awsAccessId,final String awsSecretKey,final InstanceType type,final int count) throws InstanceException {
  LOG.info(""String_Node_Str"" + count + ""String_Node_Str""+ type.getIdentifier());
  final LinkedList<FloatingInstance> foundfloatinginstances=new LinkedList<FloatingInstance>();
synchronized (this.floatingInstances) {
    final Iterator<Map.Entry<InstanceConnectionInfo,FloatingInstance>> it=this.floatingInstances.entrySet().iterator();
    while (it.hasNext()) {
      final FloatingInstance i=it.next().getValue();
      if (i.isFromThisOwner(awsAccessId,awsSecretKey)) {
        if (i.getType().equals(type)) {
          it.remove();
          foundfloatinginstances.add(i);
          if (foundfloatinginstances.size() >= count) {
            break;
          }
        }
      }
    }
  }
  LOG.info(""String_Node_Str"" + foundfloatinginstances.size() + ""String_Node_Str"");
  return foundfloatinginstances;
}"
88077,"void flushQueuedOutgoingEnvelopes() throws IOException, InterruptedException {
  System.out.println(""String_Node_Str"" + this.queuedOutgoingEnvelopes.size() + ""String_Node_Str"");
  while (!this.queuedOutgoingEnvelopes.isEmpty()) {
    this.outputGateContext.processEnvelope(this,this.queuedOutgoingEnvelopes.poll());
  }
}","void flushQueuedOutgoingEnvelopes() throws IOException, InterruptedException {
  while (!this.queuedOutgoingEnvelopes.isEmpty()) {
    this.outputGateContext.processEnvelope(this,this.queuedOutgoingEnvelopes.poll());
  }
}"
88078,"public FSDataOutputStream getFSDataOutputStream() throws Exception {
  long start=System.currentTimeMillis();
  long remaining=this.timeoutMillies;
  if (this.exception != null) {
    throw this.exception;
  }
  if (this.fdos != null) {
    return this.fdos;
  }
synchronized (this.lock) {
    do {
      try {
        this.lock.wait(remaining);
      }
 catch (      InterruptedException iex) {
        this.canceled=true;
        if (this.fdos != null) {
          try {
            this.fdos.close();
          }
 catch (          Throwable t) {
          }
        }
        throw new Exception(""String_Node_Str"");
      }
    }
 while (this.exception == null && this.fdos == null && (remaining=this.timeoutMillies + start - System.currentTimeMillis()) > 0);
    if (this.exception != null) {
      if (this.fdos != null) {
        try {
          this.fdos.close();
        }
 catch (        Throwable t) {
        }
      }
      throw this.exception;
    }
    if (this.fdos != null) {
      return this.fdos;
    }
  }
  throw new Exception(""String_Node_Str"");
}","public FSDataOutputStream getFSDataOutputStream() throws Exception {
  long start=System.currentTimeMillis();
  long remaining=this.timeoutMillies;
synchronized (this.lock) {
    boolean success=false;
    try {
      while (this.exception == null && this.fdos == null && (remaining=this.timeoutMillies + start - System.currentTimeMillis()) > 0) {
        this.lock.wait(remaining);
      }
      if (this.exception != null) {
        throw this.exception;
      }
      if (this.fdos != null) {
        success=true;
        return this.fdos;
      }
    }
  finally {
      if (!success) {
        this.canceled=true;
      }
    }
  }
  throw new Exception(""String_Node_Str"");
}"
88079,"@Override public void run(){
  try {
    final FileSystem fs=path.getFileSystem();
    Path p=this.path;
    if (fs.exists(this.path) && fs.getFileStatus(this.path).isDir()) {
      p=this.path.suffix(""String_Node_Str"" + this.taskIndex);
    }
    final FSDataOutputStream stream=fs.create(p,true);
synchronized (this.lock) {
      this.lock.notifyAll();
      if (!this.canceled) {
        this.fdos=stream;
      }
 else {
        this.fdos=null;
        stream.close();
      }
    }
  }
 catch (  Exception t) {
synchronized (this.lock) {
      this.canceled=true;
      this.exception=t;
    }
  }
}","@Override public void run(){
  try {
    final FileSystem fs=path.getFileSystem();
    Path p=this.path;
    if (fs.exists(this.path) && fs.getFileStatus(this.path).isDir()) {
      p=this.path.suffix(""String_Node_Str"" + this.taskIndex);
    }
    final FSDataOutputStream stream=fs.create(p,true);
synchronized (this.lock) {
      if (canceled) {
        try {
          stream.close();
        }
 catch (        Throwable t) {
        }
      }
 else {
        this.fdos=stream;
      }
      this.lock.notifyAll();
    }
  }
 catch (  Exception t) {
synchronized (this.lock) {
      this.exception=t;
      this.lock.notifyAll();
    }
  }
catch (  Throwable t) {
synchronized (this.lock) {
      this.exception=new Exception(t);
      this.lock.notifyAll();
    }
  }
}"
88080,"/** 
 * {@inheritDoc}
 */
@Override public synchronized void requestInstance(JobID jobID,Configuration conf,Map<InstanceType,Integer> instanceMap,List<String> splitAffinityList) throws InstanceException {
  final Iterator<Map.Entry<InstanceType,Integer>> it=instanceMap.entrySet().iterator();
  while (it.hasNext()) {
    final Map.Entry<InstanceType,Integer> entry=it.next();
    for (int i=0; i < entry.getValue().intValue(); i++) {
      LOG.info(""String_Node_Str"" + entry.getKey().getIdentifier());
      AllocatedSlice slice=null;
      for (      final ClusterInstance host : this.registeredHosts.values()) {
        if (host.getType().equals(entry.getKey())) {
          slice=host.createSlice(entry.getKey(),jobID);
          if (slice != null) {
            break;
          }
        }
      }
      if (slice == null) {
        for (        final ClusterInstance host : this.registeredHosts.values()) {
          slice=host.createSlice(entry.getKey(),jobID);
          if (slice != null) {
            break;
          }
        }
      }
      if (slice == null) {
        throw new InstanceException(""String_Node_Str"");
      }
      List<AllocatedSlice> allocatedSlices=this.slicesOfJobs.get(jobID);
      if (allocatedSlices == null) {
        allocatedSlices=new ArrayList<AllocatedSlice>();
        this.slicesOfJobs.put(jobID,allocatedSlices);
      }
      allocatedSlices.add(slice);
      if (this.instanceListener != null) {
        ClusterInstanceNotifier clusterInstanceNotifier=new ClusterInstanceNotifier(this.instanceListener,slice);
        clusterInstanceNotifier.start();
      }
      LOG.info(""String_Node_Str"" + host.getName());
      return;
    }
  }
}","/** 
 * {@inheritDoc}
 */
@Override public synchronized void requestInstance(JobID jobID,Configuration conf,Map<InstanceType,Integer> instanceMap,List<String> splitAffinityList) throws InstanceException {
  final Iterator<Map.Entry<InstanceType,Integer>> it=instanceMap.entrySet().iterator();
  while (it.hasNext()) {
    final Map.Entry<InstanceType,Integer> entry=it.next();
    for (int i=0; i < entry.getValue().intValue(); i++) {
      LOG.info(""String_Node_Str"" + entry.getKey().getIdentifier());
      AllocatedSlice slice=null;
      for (      final ClusterInstance host : this.registeredHosts.values()) {
        if (host.getType().equals(entry.getKey())) {
          slice=host.createSlice(entry.getKey(),jobID);
          if (slice != null) {
            break;
          }
        }
      }
      if (slice == null) {
        for (        final ClusterInstance host : this.registeredHosts.values()) {
          slice=host.createSlice(entry.getKey(),jobID);
          if (slice != null) {
            break;
          }
        }
      }
      if (slice == null) {
        throw new InstanceException(""String_Node_Str"");
      }
      List<AllocatedSlice> allocatedSlices=this.slicesOfJobs.get(jobID);
      if (allocatedSlices == null) {
        allocatedSlices=new ArrayList<AllocatedSlice>();
        this.slicesOfJobs.put(jobID,allocatedSlices);
      }
      allocatedSlices.add(slice);
      if (this.instanceListener != null) {
        ClusterInstanceNotifier clusterInstanceNotifier=new ClusterInstanceNotifier(this.instanceListener,slice);
        clusterInstanceNotifier.start();
      }
      return;
    }
  }
}"
88081,"/** 
 * {@inheritDoc}
 */
@Override public void allocatedResourceDied(final JobID jobID,final AllocatedResource allocatedResource){
  LOG.info(""String_Node_Str"" + allocatedResource.getInstance().getName() + ""String_Node_Str""+ jobID+ ""String_Node_Str"");
  ExecutionGraph job=this.jobQueue.getFirst();
  Iterator<ExecutionGraph> iterator=this.jobQueue.descendingIterator();
  while (job.getJobID() != jobID) {
    if (iterator.hasNext()) {
      job=iterator.next();
    }
 else {
      LOG.error(""String_Node_Str"" + jobID + ""String_Node_Str"");
      return;
    }
  }
  List<ExecutionVertex> vertices=job.getVerticesAssignedToResource(allocatedResource);
  Iterator<ExecutionVertex> vertexIter=vertices.iterator();
  while (vertexIter.hasNext()) {
    ExecutionVertex vertex=vertexIter.next();
    vertex.getEnvironment().changeExecutionState(ExecutionState.FAILED,""String_Node_Str"" + allocatedResource.getInstance().getName() + ""String_Node_Str""+ vertex.getEnvironment().getTaskName()+ ""String_Node_Str"");
    if (vertex.getExecutionState() == ExecutionState.FAILED) {
      job.executionStateChanged(vertex.getEnvironment(),ExecutionState.FAILED,""String_Node_Str"" + allocatedResource.getInstance().getName() + ""String_Node_Str""+ vertex.getEnvironment().getTaskName()+ ""String_Node_Str"");
      return;
    }
    vertex.setAllocatedResource(new AllocatedResource(DummyInstance.createDummyInstance(allocatedResource.getInstanceType()),allocatedResource.getInstanceType(),null));
    vertex.getEnvironment().changeExecutionState(ExecutionState.ASSIGNING,null);
  }
  try {
    LOG.info(""String_Node_Str"" + allocatedResource.getInstanceType().getIdentifier());
    this.instanceManager.requestInstance(jobID,job.getJobConfiguration(),allocatedResource.getInstanceType());
  }
 catch (  InstanceException e) {
    e.printStackTrace();
  }
  job.executionStateChanged(vertices.get(0).getEnvironment(),ExecutionState.RECOVERING,null);
}","/** 
 * {@inheritDoc}
 */
@Override public void allocatedResourceDied(final JobID jobID,final AllocatedResource allocatedResource){
  LOG.info(""String_Node_Str"" + allocatedResource.getInstance().getName() + ""String_Node_Str""+ jobID+ ""String_Node_Str"");
  ExecutionGraph job=this.jobQueue.getFirst();
  Iterator<ExecutionGraph> iterator=this.jobQueue.descendingIterator();
  while (job.getJobID() != jobID) {
    if (iterator.hasNext()) {
      job=iterator.next();
    }
 else {
      LOG.error(""String_Node_Str"" + jobID + ""String_Node_Str"");
      return;
    }
  }
  List<ExecutionVertex> vertices=job.getVerticesAssignedToResource(allocatedResource);
  Iterator<ExecutionVertex> vertexIter=vertices.iterator();
  while (vertexIter.hasNext()) {
    ExecutionVertex vertex=vertexIter.next();
    vertex.getEnvironment().changeExecutionState(ExecutionState.FAILED,""String_Node_Str"" + allocatedResource.getInstance().getName() + ""String_Node_Str""+ vertex.getEnvironment().getTaskName()+ ""String_Node_Str"");
    if (vertex.getExecutionState() == ExecutionState.FAILED) {
      job.executionStateChanged(vertex.getEnvironment(),ExecutionState.FAILED,""String_Node_Str"" + allocatedResource.getInstance().getName() + ""String_Node_Str""+ vertex.getEnvironment().getTaskName()+ ""String_Node_Str"");
      return;
    }
    vertex.setAllocatedResource(new AllocatedResource(DummyInstance.createDummyInstance(allocatedResource.getInstanceType()),allocatedResource.getInstanceType(),null));
    vertex.getEnvironment().changeExecutionState(ExecutionState.ASSIGNING,null);
  }
  try {
    LOG.info(""String_Node_Str"" + allocatedResource.getInstanceType().getIdentifier());
    Map<InstanceType,Integer> instanceMap=new HashMap<InstanceType,Integer>();
    instanceMap.put(allocatedResource.getInstanceType(),1);
    this.getInstanceManager().requestInstance(jobID,job.getJobConfiguration(),instanceMap,null);
  }
 catch (  InstanceException e) {
    e.printStackTrace();
  }
  job.executionStateChanged(vertices.get(0).getEnvironment(),ExecutionState.RECOVERING,null);
}"
88082,"@Override public void reportPersistenCheckpoint(ExecutionVertexID executionVertexID,JobID jobID){
}","@Override public void reportPersistenCheckpoint(ExecutionVertexID executionVertexID,JobID jobID){
  getExecutionGraphByID(jobID).getVertexByID(executionVertexID).setCheckpoint();
}"
88083,"@Override public void reportPersistenCheckpoint(ExecutionVertexID executionVertexID,JobID jobID){
}","@Override public void reportPersistenCheckpoint(ExecutionVertexID executionVertexID,JobID jobID){
  this.scheduler.reportPersistenCheckpoint(executionVertexID,jobID);
}"
88084,"@Override public void reportPersistenCheckpoint(ExecutionVertexID executionVertexID,JobID jobID){
}","@Override public void reportPersistenCheckpoint(ExecutionVertexID executionVertexID,JobID jobID){
  getExecutionGraphByID(jobID).getVertexByID(executionVertexID).setCheckpoint();
}"
88085,"/** 
 * Private constructor used to duplicate execution vertices.
 * @param vertexID the ID of the new execution vertex.
 * @param invokableClass the task that is assigned to this execution vertex
 * @param executionGraph the execution graph the new vertex belongs to
 * @param groupVertex the group vertex the new vertex belongs to
 */
private ExecutionVertex(ExecutionVertexID vertexID,Class<? extends AbstractInvokable> invokableClass,ExecutionGraph executionGraph,ExecutionGroupVertex groupVertex){
  this.vertexID=vertexID;
  this.invokableClass=invokableClass;
  this.executionGraph=executionGraph;
  this.groupVertex=groupVertex;
}","/** 
 * Private constructor used to duplicate execution vertices.
 * @param vertexID the ID of the new execution vertex.
 * @param invokableClass the task that is assigned to this execution vertex
 * @param executionGraph the execution graph the new vertex belongs to
 * @param groupVertex the group vertex the new vertex belongs to
 */
private ExecutionVertex(ExecutionVertexID vertexID,Class<? extends AbstractInvokable> invokableClass,ExecutionGraph executionGraph,ExecutionGroupVertex groupVertex){
  this.vertexID=vertexID;
  this.invokableClass=invokableClass;
  this.executionGraph=executionGraph;
  this.groupVertex=groupVertex;
  registerExecutionListener(this.executionGraph);
}"
88086,"/** 
 * Updates the vertex's current execution state.
 * @param newExecutionState the new execution state
 * @param optionalMessage an optional message related to the state change
 */
public synchronized void updateExecutionState(final ExecutionState newExecutionState,final String optionalMessage){
  if (this.executionState == newExecutionState) {
    return;
  }
  ExecutionStateTransition.checkTransition(getName(),this.executionState,newExecutionState);
  final Iterator<ExecutionListener> it=this.executionListeners.iterator();
  while (it.hasNext()) {
    it.next().executionStateChanged(this.executionGraph.getJobID(),this.vertexID,newExecutionState,optionalMessage);
  }
  this.executionState=newExecutionState;
}","/** 
 * Updates the vertex's current execution state.
 * @param newExecutionState the new execution state
 * @param optionalMessage an optional message related to the state change
 */
public synchronized void updateExecutionState(final ExecutionState newExecutionState,final String optionalMessage){
  if (this.executionState == newExecutionState) {
    return;
  }
  ExecutionStateTransition.checkTransition(getName(),this.executionState,newExecutionState);
  this.executionState=newExecutionState;
  final Iterator<ExecutionListener> it=this.executionListeners.iterator();
  while (it.hasNext()) {
    it.next().executionStateChanged(this.executionGraph.getJobID(),this.vertexID,newExecutionState,optionalMessage);
  }
}"
88087,"@Test public void testConvertJobGraphToExecutionGraph4(){
  File inputFile1=null;
  File inputFile2=null;
  JobID jobID=null;
  try {
    inputFile1=ServerTestUtils.createInputFile(0);
    inputFile2=ServerTestUtils.createInputFile(0);
    final JobGraph jg=new JobGraph(""String_Node_Str"");
    jobID=jg.getJobID();
    final JobFileInputVertex i1=new JobFileInputVertex(""String_Node_Str"",jg);
    i1.setFileInputClass(FileLineReader.class);
    i1.setFilePath(new Path(""String_Node_Str"" + inputFile1.getAbsolutePath()));
    i1.setNumberOfSubtasks(4);
    i1.setNumberOfSubtasksPerInstance(2);
    final JobFileInputVertex i2=new JobFileInputVertex(""String_Node_Str"",jg);
    i2.setFileInputClass(FileLineReader.class);
    i2.setFilePath(new Path(""String_Node_Str"" + inputFile2.getAbsolutePath()));
    i2.setNumberOfSubtasks(4);
    i2.setNumberOfSubtasksPerInstance(2);
    final JobTaskVertex t1=new JobTaskVertex(""String_Node_Str"",jg);
    t1.setTaskClass(ForwardTask1Input1Output.class);
    t1.setNumberOfSubtasks(4);
    t1.setNumberOfSubtasksPerInstance(2);
    final JobTaskVertex t2=new JobTaskVertex(""String_Node_Str"",jg);
    t2.setTaskClass(ForwardTask1Input1Output.class);
    t2.setNumberOfSubtasks(4);
    t2.setNumberOfSubtasksPerInstance(2);
    final JobTaskVertex t3=new JobTaskVertex(""String_Node_Str"",jg);
    t3.setTaskClass(ForwardTask2Inputs1Output.class);
    t3.setNumberOfSubtasks(8);
    t3.setNumberOfSubtasksPerInstance(4);
    final JobTaskVertex t4=new JobTaskVertex(""String_Node_Str"",jg);
    t4.setTaskClass(ForwardTask1Input2Outputs.class);
    t4.setNumberOfSubtasks(8);
    t4.setNumberOfSubtasksPerInstance(4);
    final JobFileOutputVertex o1=new JobFileOutputVertex(""String_Node_Str"",jg);
    o1.setFileOutputClass(FileLineWriter.class);
    o1.setFilePath(new Path(""String_Node_Str"" + ServerTestUtils.getRandomFilename()));
    o1.setNumberOfSubtasks(4);
    o1.setNumberOfSubtasksPerInstance(2);
    final JobFileOutputVertex o2=new JobFileOutputVertex(""String_Node_Str"",jg);
    o2.setFileOutputClass(FileLineWriter.class);
    o2.setFilePath(new Path(""String_Node_Str"" + ServerTestUtils.getRandomFilename()));
    o2.setNumberOfSubtasks(4);
    o2.setNumberOfSubtasksPerInstance(2);
    o1.setVertexToShareInstancesWith(o2);
    i1.connectTo(t1,ChannelType.FILE,CompressionLevel.NO_COMPRESSION);
    i2.connectTo(t2,ChannelType.FILE,CompressionLevel.NO_COMPRESSION);
    t1.connectTo(t3,ChannelType.NETWORK,CompressionLevel.NO_COMPRESSION);
    t2.connectTo(t3,ChannelType.NETWORK,CompressionLevel.NO_COMPRESSION);
    t3.connectTo(t4,ChannelType.INMEMORY,CompressionLevel.NO_COMPRESSION);
    t4.connectTo(o1,ChannelType.NETWORK,CompressionLevel.NO_COMPRESSION);
    t4.connectTo(o2,ChannelType.NETWORK,CompressionLevel.NO_COMPRESSION);
    LibraryCacheManager.register(jobID,new String[0]);
    final ExecutionGraph eg=new ExecutionGraph(jg,INSTANCE_MANAGER);
    final InstanceRequestMap instanceRequestMap=new InstanceRequestMap();
    ExecutionStage executionStage=eg.getCurrentExecutionStage();
    executionStage.collectRequiredInstanceTypes(instanceRequestMap,ExecutionState.CREATED);
    assertEquals(1,instanceRequestMap.size());
    assertEquals(4,(int)instanceRequestMap.getMaximumNumberOfInstances(INSTANCE_MANAGER.getInstanceTypeByName(DEFAULT_INSTANCE_TYPE_NAME)));
    final Iterator<ExecutionVertex> it=new ExecutionGraphIterator(eg,eg.getIndexOfCurrentExecutionStage(),true,true);
    while (it.hasNext()) {
      final ExecutionVertex ev=it.next();
      ev.updateExecutionState(ExecutionState.SCHEDULED);
      ev.updateExecutionState(ExecutionState.READY);
      ev.updateExecutionState(ExecutionState.STARTING);
      ev.updateExecutionState(ExecutionState.RUNNING);
      ev.updateExecutionState(ExecutionState.FINISHING);
      ev.updateExecutionState(ExecutionState.FINISHED);
    }
    instanceRequestMap.clear();
    executionStage=eg.getCurrentExecutionStage();
    executionStage.collectRequiredInstanceTypes(instanceRequestMap,ExecutionState.SCHEDULED);
    assertEquals(1,instanceRequestMap.size());
    assertEquals(8,(int)instanceRequestMap.getMaximumNumberOfInstances(INSTANCE_MANAGER.getInstanceTypeByName(DEFAULT_INSTANCE_TYPE_NAME)));
  }
 catch (  GraphConversionException e) {
    fail(e.getMessage());
  }
catch (  JobGraphDefinitionException e) {
    fail(e.getMessage());
  }
catch (  IOException e) {
    fail(e.getMessage());
  }
 finally {
    if (inputFile1 != null) {
      inputFile1.delete();
    }
    if (inputFile2 != null) {
      inputFile2.delete();
    }
    if (jobID != null) {
      try {
        LibraryCacheManager.unregister(jobID);
      }
 catch (      IOException e) {
      }
    }
  }
}","@Test public void testConvertJobGraphToExecutionGraph4(){
  File inputFile1=null;
  File inputFile2=null;
  JobID jobID=null;
  try {
    inputFile1=ServerTestUtils.createInputFile(0);
    inputFile2=ServerTestUtils.createInputFile(0);
    final JobGraph jg=new JobGraph(""String_Node_Str"");
    jobID=jg.getJobID();
    final JobFileInputVertex i1=new JobFileInputVertex(""String_Node_Str"",jg);
    i1.setFileInputClass(FileLineReader.class);
    i1.setFilePath(new Path(""String_Node_Str"" + inputFile1.getAbsolutePath()));
    i1.setNumberOfSubtasks(4);
    i1.setNumberOfSubtasksPerInstance(2);
    final JobFileInputVertex i2=new JobFileInputVertex(""String_Node_Str"",jg);
    i2.setFileInputClass(FileLineReader.class);
    i2.setFilePath(new Path(""String_Node_Str"" + inputFile2.getAbsolutePath()));
    i2.setNumberOfSubtasks(4);
    i2.setNumberOfSubtasksPerInstance(2);
    final JobTaskVertex t1=new JobTaskVertex(""String_Node_Str"",jg);
    t1.setTaskClass(ForwardTask1Input1Output.class);
    t1.setNumberOfSubtasks(4);
    t1.setNumberOfSubtasksPerInstance(2);
    final JobTaskVertex t2=new JobTaskVertex(""String_Node_Str"",jg);
    t2.setTaskClass(ForwardTask1Input1Output.class);
    t2.setNumberOfSubtasks(4);
    t2.setNumberOfSubtasksPerInstance(2);
    final JobTaskVertex t3=new JobTaskVertex(""String_Node_Str"",jg);
    t3.setTaskClass(ForwardTask2Inputs1Output.class);
    t3.setNumberOfSubtasks(8);
    t3.setNumberOfSubtasksPerInstance(4);
    final JobTaskVertex t4=new JobTaskVertex(""String_Node_Str"",jg);
    t4.setTaskClass(ForwardTask1Input2Outputs.class);
    t4.setNumberOfSubtasks(8);
    t4.setNumberOfSubtasksPerInstance(4);
    final JobFileOutputVertex o1=new JobFileOutputVertex(""String_Node_Str"",jg);
    o1.setFileOutputClass(FileLineWriter.class);
    o1.setFilePath(new Path(""String_Node_Str"" + ServerTestUtils.getRandomFilename()));
    o1.setNumberOfSubtasks(4);
    o1.setNumberOfSubtasksPerInstance(2);
    final JobFileOutputVertex o2=new JobFileOutputVertex(""String_Node_Str"",jg);
    o2.setFileOutputClass(FileLineWriter.class);
    o2.setFilePath(new Path(""String_Node_Str"" + ServerTestUtils.getRandomFilename()));
    o2.setNumberOfSubtasks(4);
    o2.setNumberOfSubtasksPerInstance(2);
    o1.setVertexToShareInstancesWith(o2);
    i1.connectTo(t1,ChannelType.FILE,CompressionLevel.NO_COMPRESSION);
    i2.connectTo(t2,ChannelType.FILE,CompressionLevel.NO_COMPRESSION);
    t1.connectTo(t3,ChannelType.NETWORK,CompressionLevel.NO_COMPRESSION);
    t2.connectTo(t3,ChannelType.NETWORK,CompressionLevel.NO_COMPRESSION);
    t3.connectTo(t4,ChannelType.INMEMORY,CompressionLevel.NO_COMPRESSION);
    t4.connectTo(o1,ChannelType.NETWORK,CompressionLevel.NO_COMPRESSION);
    t4.connectTo(o2,ChannelType.NETWORK,CompressionLevel.NO_COMPRESSION);
    LibraryCacheManager.register(jobID,new String[0]);
    final ExecutionGraph eg=new ExecutionGraph(jg,INSTANCE_MANAGER);
    final InstanceRequestMap instanceRequestMap=new InstanceRequestMap();
    ExecutionStage executionStage=eg.getCurrentExecutionStage();
    executionStage.collectRequiredInstanceTypes(instanceRequestMap,ExecutionState.CREATED);
    assertEquals(1,instanceRequestMap.size());
    assertEquals(4,(int)instanceRequestMap.getMaximumNumberOfInstances(INSTANCE_MANAGER.getInstanceTypeByName(DEFAULT_INSTANCE_TYPE_NAME)));
    final Iterator<ExecutionVertex> it=new ExecutionGraphIterator(eg,eg.getIndexOfCurrentExecutionStage(),true,true);
    while (it.hasNext()) {
      final ExecutionVertex ev=it.next();
      ev.updateExecutionState(ExecutionState.SCHEDULED);
      ev.updateExecutionState(ExecutionState.ASSIGNED);
      ev.updateExecutionState(ExecutionState.READY);
      ev.updateExecutionState(ExecutionState.STARTING);
      ev.updateExecutionState(ExecutionState.RUNNING);
      ev.updateExecutionState(ExecutionState.FINISHING);
      ev.updateExecutionState(ExecutionState.FINISHED);
    }
    instanceRequestMap.clear();
    executionStage=eg.getCurrentExecutionStage();
    assertEquals(1,executionStage.getStageNumber());
    executionStage.collectRequiredInstanceTypes(instanceRequestMap,ExecutionState.CREATED);
    assertEquals(1,instanceRequestMap.size());
    assertEquals(8,(int)instanceRequestMap.getMaximumNumberOfInstances(INSTANCE_MANAGER.getInstanceTypeByName(DEFAULT_INSTANCE_TYPE_NAME)));
  }
 catch (  GraphConversionException e) {
    fail(e.getMessage());
  }
catch (  JobGraphDefinitionException e) {
    fail(e.getMessage());
  }
catch (  IOException e) {
    fail(e.getMessage());
  }
 finally {
    if (inputFile1 != null) {
      inputFile1.delete();
    }
    if (inputFile2 != null) {
      inputFile2.delete();
    }
    if (jobID != null) {
      try {
        LibraryCacheManager.unregister(jobID);
      }
 catch (      IOException e) {
      }
    }
  }
}"
88088,"/** 
 * {@inheritDoc}
 */
@Override public void schedulJob(final ExecutionGraph executionGraph) throws SchedulingException {
  final Map<InstanceType,InstanceTypeDescription> availableInstances=getInstanceManager().getMapOfAvailableInstanceTypes();
  for (int i=0; i < executionGraph.getNumberOfStages(); i++) {
    final InstanceRequestMap instanceRequestMap=new InstanceRequestMap();
    final ExecutionStage stage=executionGraph.getStage(i);
    stage.collectRequiredInstanceTypes(instanceRequestMap,ExecutionState.CREATED);
    final Iterator<Map.Entry<InstanceType,Integer>> it=instanceRequestMap.getMinimumIterator();
    while (it.hasNext()) {
      final Map.Entry<InstanceType,Integer> entry=it.next();
      final InstanceTypeDescription descr=availableInstances.get(entry.getKey());
      if (descr == null) {
        throw new SchedulingException(""String_Node_Str"" + entry.getKey() + ""String_Node_Str"");
      }
      if (descr.getMaximumNumberOfAvailableInstances() != -1 && descr.getMaximumNumberOfAvailableInstances() < entry.getValue().intValue()) {
        throw new SchedulingException(""String_Node_Str"" + entry.getValue().intValue() + ""String_Node_Str""+ entry.getKey()+ ""String_Node_Str""+ descr.getMaximumNumberOfAvailableInstances()+ ""String_Node_Str"");
      }
    }
  }
  executionGraph.registerJobStatusListener(this);
  final ExecutionGraphIterator it2=new ExecutionGraphIterator(executionGraph,true);
  while (it2.hasNext()) {
    final ExecutionVertex vertex=it2.next();
    vertex.registerExecutionListener(new QueueExecutionListener(this,vertex));
  }
  executionGraph.registerExecutionStageListener(this);
synchronized (this.jobQueue) {
    this.jobQueue.add(executionGraph);
    final ExecutionStage executionStage=executionGraph.getCurrentExecutionStage();
    try {
      requestInstances(executionStage);
    }
 catch (    InstanceException e) {
      final String exceptionMessage=StringUtils.stringifyException(e);
      LOG.error(exceptionMessage);
      this.jobQueue.remove(executionGraph);
      throw new SchedulingException(exceptionMessage);
    }
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void schedulJob(final ExecutionGraph executionGraph) throws SchedulingException {
synchronized (executionGraph) {
    final Map<InstanceType,InstanceTypeDescription> availableInstances=getInstanceManager().getMapOfAvailableInstanceTypes();
    for (int i=0; i < executionGraph.getNumberOfStages(); i++) {
      final InstanceRequestMap instanceRequestMap=new InstanceRequestMap();
      final ExecutionStage stage=executionGraph.getStage(i);
      stage.collectRequiredInstanceTypes(instanceRequestMap,ExecutionState.CREATED);
      final Iterator<Map.Entry<InstanceType,Integer>> it=instanceRequestMap.getMinimumIterator();
      while (it.hasNext()) {
        final Map.Entry<InstanceType,Integer> entry=it.next();
        final InstanceTypeDescription descr=availableInstances.get(entry.getKey());
        if (descr == null) {
          throw new SchedulingException(""String_Node_Str"" + entry.getKey() + ""String_Node_Str"");
        }
        if (descr.getMaximumNumberOfAvailableInstances() != -1 && descr.getMaximumNumberOfAvailableInstances() < entry.getValue().intValue()) {
          throw new SchedulingException(""String_Node_Str"" + entry.getValue().intValue() + ""String_Node_Str""+ entry.getKey()+ ""String_Node_Str""+ descr.getMaximumNumberOfAvailableInstances()+ ""String_Node_Str"");
        }
      }
    }
    executionGraph.registerJobStatusListener(this);
    final ExecutionGraphIterator it2=new ExecutionGraphIterator(executionGraph,true);
    while (it2.hasNext()) {
      final ExecutionVertex vertex=it2.next();
      vertex.registerExecutionListener(new QueueExecutionListener(this,vertex));
    }
    executionGraph.registerExecutionStageListener(this);
  }
synchronized (this.jobQueue) {
    this.jobQueue.add(executionGraph);
  }
synchronized (executionGraph) {
    final ExecutionStage executionStage=executionGraph.getCurrentExecutionStage();
    try {
      requestInstances(executionStage);
    }
 catch (    InstanceException e) {
      final String exceptionMessage=StringUtils.stringifyException(e);
      LOG.error(exceptionMessage);
      this.jobQueue.remove(executionGraph);
      throw new SchedulingException(exceptionMessage);
    }
  }
}"
88089,"/** 
 * Sets the maximum number of members this group vertex can have.
 * @param maxSize the maximum number of members this group vertex can have
 */
void setMaxMemberSize(final int maxSize){
  if (maxSize < 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.maxMemberSize=maxSize;
}","/** 
 * Sets the maximum number of members this group vertex can have.
 * @param maxSize the maximum number of members this group vertex can have
 */
void setMaxMemberSize(final int maxSize){
  this.maxMemberSize=maxSize;
}"
88090,"/** 
 * Sets the minimum number of members this group vertex must have.
 * @param minSize the minimum number of members this group vertex must have
 */
void setMinMemberSize(final int minSize){
  if (minSize < 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.minMemberSize=minSize;
}","/** 
 * Sets the minimum number of members this group vertex must have.
 * @param minSize the minimum number of members this group vertex must have
 */
void setMinMemberSize(final int minSize){
  this.minMemberSize=minSize;
}"
88091,"/** 
 * Cancels and removes the task represented by this vertex from the instance it is currently running on. If the task is not currently running, its execution state is simply updated to <code>CANCELLED</code>.
 * @return the result of the task cancel attempt
 */
public TaskCancelResult cancelTask(){
  if (this.groupVertex.getStageNumber() != this.executionGraph.getIndexOfCurrentExecutionStage()) {
    updateExecutionState(ExecutionState.CANCELED,null);
    return new TaskCancelResult(getID(),AbstractTaskResult.ReturnCode.SUCCESS);
  }
  if (this.executionState == ExecutionState.FINISHED || this.executionState == ExecutionState.FAILED) {
    return new TaskCancelResult(getID(),AbstractTaskResult.ReturnCode.SUCCESS);
  }
  if (this.executionState != ExecutionState.RUNNING && this.executionState != ExecutionState.FINISHING) {
    updateExecutionState(ExecutionState.CANCELED,null);
    return new TaskCancelResult(getID(),AbstractTaskResult.ReturnCode.SUCCESS);
  }
  if (this.allocatedResource == null) {
    final TaskCancelResult result=new TaskCancelResult(getID(),AbstractTaskResult.ReturnCode.ERROR);
    result.setDescription(""String_Node_Str"" + this.toString() + ""String_Node_Str"");
    return result;
  }
  try {
    return this.allocatedResource.getInstance().cancelTask(this.vertexID);
  }
 catch (  IOException e) {
    final TaskCancelResult result=new TaskCancelResult(getID(),AbstractTaskResult.ReturnCode.ERROR);
    result.setDescription(StringUtils.stringifyException(e));
    return result;
  }
}","/** 
 * Cancels and removes the task represented by this vertex from the instance it is currently running on. If the task is not currently running, its execution state is simply updated to <code>CANCELLED</code>.
 * @return the result of the task cancel attempt
 */
public TaskCancelResult cancelTask(){
  if (this.groupVertex.getStageNumber() != this.executionGraph.getIndexOfCurrentExecutionStage()) {
    updateExecutionState(ExecutionState.CANCELED,null);
    return new TaskCancelResult(getID(),AbstractTaskResult.ReturnCode.SUCCESS);
  }
  if (this.executionState == ExecutionState.FINISHED || this.executionState == ExecutionState.FAILED) {
    return new TaskCancelResult(getID(),AbstractTaskResult.ReturnCode.SUCCESS);
  }
  if (this.executionState != ExecutionState.RUNNING && this.executionState != ExecutionState.STARTING && this.executionState != ExecutionState.FINISHING) {
    updateExecutionState(ExecutionState.CANCELED,null);
    return new TaskCancelResult(getID(),AbstractTaskResult.ReturnCode.SUCCESS);
  }
  if (this.allocatedResource == null) {
    final TaskCancelResult result=new TaskCancelResult(getID(),AbstractTaskResult.ReturnCode.ERROR);
    result.setDescription(""String_Node_Str"" + this.toString() + ""String_Node_Str"");
    return result;
  }
  try {
    return this.allocatedResource.getInstance().cancelTask(this.vertexID);
  }
 catch (  IOException e) {
    final TaskCancelResult result=new TaskCancelResult(getID(),AbstractTaskResult.ReturnCode.ERROR);
    result.setDescription(StringUtils.stringifyException(e));
    return result;
  }
}"
88092,"private void reassignGraphFragment(final ExecutionVertex vertex,final AllocatedResource oldResource,final AllocatedResource newResource){
  if (oldResource.equals(vertex.getAllocatedResource())) {
    vertex.setAllocatedResource(newResource);
    if (vertex.getExecutionState() == ExecutionState.SCHEDULED) {
      vertex.updateExecutionState(ExecutionState.ASSIGNED);
    }
    final int numberOfOutputGates=vertex.getEnvironment().getNumberOfOutputGates();
    for (int i=0; i < numberOfOutputGates; ++i) {
      final OutputGate<? extends Record> outputGate=vertex.getEnvironment().getOutputGate(i);
      if (outputGate.getChannelType() == ChannelType.NETWORK) {
        continue;
      }
      final int numberOfOutputChannels=outputGate.getNumberOfOutputChannels();
      for (int j=0; j < numberOfOutputChannels; ++j) {
        final AbstractOutputChannel<? extends Record> outputChannel=outputGate.getOutputChannel(j);
        final ExecutionVertex connectedVertex=vertex.getExecutionGraph().getVertexByChannelID(outputChannel.getConnectedChannelID());
        reassignGraphFragment(connectedVertex,oldResource,newResource);
      }
    }
  }
}","private void reassignGraphFragment(final ExecutionVertex vertex,final AllocatedResource oldResource,final AllocatedResource newResource){
synchronized (vertex.getExecutionGraph()) {
    if (oldResource.equals(vertex.getAllocatedResource())) {
      vertex.setAllocatedResource(newResource);
      if (vertex.getExecutionState() == ExecutionState.SCHEDULED) {
        vertex.updateExecutionState(ExecutionState.ASSIGNED);
      }
      final int numberOfOutputGates=vertex.getEnvironment().getNumberOfOutputGates();
      for (int i=0; i < numberOfOutputGates; ++i) {
        final OutputGate<? extends Record> outputGate=vertex.getEnvironment().getOutputGate(i);
        if (outputGate.getChannelType() == ChannelType.NETWORK) {
          continue;
        }
        final int numberOfOutputChannels=outputGate.getNumberOfOutputChannels();
        for (int j=0; j < numberOfOutputChannels; ++j) {
          final AbstractOutputChannel<? extends Record> outputChannel=outputGate.getOutputChannel(j);
          final ExecutionVertex connectedVertex=vertex.getExecutionGraph().getVertexByChannelID(outputChannel.getConnectedChannelID());
          reassignGraphFragment(connectedVertex,oldResource,newResource);
        }
      }
    }
  }
}"
88093,"/** 
 * {@inheritDoc}
 */
@Override public void executionStateChanged(final JobID jobID,final ExecutionVertexID vertexID,final ExecutionState newExecutionState,final String optionalMessage){
  final ExecutionGraph eg=this.executionVertex.getExecutionGraph();
  if (newExecutionState == ExecutionState.FINISHED) {
    final ExecutionGroupVertex groupVertex=this.executionVertex.getGroupVertex();
    for (int i=0; i < groupVertex.getCurrentNumberOfGroupMembers(); ++i) {
      final ExecutionVertex groupMember=groupVertex.getGroupMember(i);
      if (groupMember.getExecutionState() == ExecutionState.SCHEDULED) {
        groupMember.setAllocatedResource(this.executionVertex.getAllocatedResource());
        groupMember.updateExecutionState(ExecutionState.READY);
        this.scheduler.deployAssignedVertices(eg);
        return;
      }
    }
    final Iterator<ExecutionVertex> it=new ExecutionGraphIterator(eg,eg.getIndexOfCurrentExecutionStage(),true,true);
    while (it.hasNext()) {
      final ExecutionVertex nextVertex=it.next();
      if (nextVertex.getExecutionState() == ExecutionState.SCHEDULED) {
        if (nextVertex.getAllocatedResource().getInstanceType().equals(this.executionVertex.getAllocatedResource().getInstanceType())) {
          nextVertex.setAllocatedResource(this.executionVertex.getAllocatedResource());
          nextVertex.updateExecutionState(ExecutionState.READY);
          this.scheduler.deployAssignedVertices(eg);
          return;
        }
      }
    }
  }
  if (newExecutionState == ExecutionState.FINISHED || newExecutionState == ExecutionState.CANCELED || newExecutionState == ExecutionState.FAILED) {
    this.scheduler.checkAndReleaseAllocatedResource(eg,this.executionVertex.getAllocatedResource());
  }
  if (newExecutionState == ExecutionState.FAILED) {
    if (this.executionVertex.hasRetriesLeft()) {
      this.executionVertex.updateExecutionState(ExecutionState.SCHEDULED);
    }
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void executionStateChanged(final JobID jobID,final ExecutionVertexID vertexID,final ExecutionState newExecutionState,final String optionalMessage){
  final ExecutionGraph eg=this.executionVertex.getExecutionGraph();
synchronized (eg) {
    if (newExecutionState == ExecutionState.FINISHED) {
      final ExecutionGroupVertex groupVertex=this.executionVertex.getGroupVertex();
      for (int i=0; i < groupVertex.getCurrentNumberOfGroupMembers(); ++i) {
        final ExecutionVertex groupMember=groupVertex.getGroupMember(i);
        if (groupMember.getExecutionState() == ExecutionState.SCHEDULED) {
          groupMember.setAllocatedResource(this.executionVertex.getAllocatedResource());
          groupMember.updateExecutionState(ExecutionState.READY);
          this.scheduler.deployAssignedVertices(eg);
          return;
        }
      }
      final Iterator<ExecutionVertex> it=new ExecutionGraphIterator(eg,eg.getIndexOfCurrentExecutionStage(),true,true);
      while (it.hasNext()) {
        final ExecutionVertex nextVertex=it.next();
        if (nextVertex.getExecutionState() == ExecutionState.SCHEDULED) {
          if (nextVertex.getAllocatedResource().getInstanceType().equals(this.executionVertex.getAllocatedResource().getInstanceType())) {
            nextVertex.setAllocatedResource(this.executionVertex.getAllocatedResource());
            nextVertex.updateExecutionState(ExecutionState.READY);
            this.scheduler.deployAssignedVertices(eg);
            return;
          }
        }
      }
    }
    if (newExecutionState == ExecutionState.FINISHED || newExecutionState == ExecutionState.CANCELED || newExecutionState == ExecutionState.FAILED) {
      this.scheduler.checkAndReleaseAllocatedResource(eg,this.executionVertex.getAllocatedResource());
    }
    if (newExecutionState == ExecutionState.FAILED) {
      if (this.executionVertex.hasRetriesLeft()) {
        this.executionVertex.updateExecutionState(ExecutionState.SCHEDULED);
      }
    }
  }
}"
88094,"/** 
 * {@inheritDoc}
 */
@Override public void initialExecutionResourcesExhausted(final JobID jobID,final ExecutionVertexID vertexID,final ResourceUtilizationSnapshot resourceUtilizationSnapshot){
  final ExecutionGraph executionGraph=this.executionVertex.getExecutionGraph();
  System.out.println(this.executionVertex + ""String_Node_Str"");
  final Map<ExecutionVertex,Long> targetVertices=new HashMap<ExecutionVertex,Long>();
  final Map<AllocatedResource,Long> availableResources=new HashMap<AllocatedResource,Long>();
  final Environment ee=this.executionVertex.getEnvironment();
synchronized (executionGraph) {
    for (int i=0; i < ee.getNumberOfOutputGates(); ++i) {
      final OutputGate<? extends Record> outputGate=ee.getOutputGate(i);
      for (int j=0; j < outputGate.getNumberOfOutputChannels(); ++j) {
        final AbstractOutputChannel<? extends Record> outputChannel=outputGate.getOutputChannel(j);
        final long transmittedData=resourceUtilizationSnapshot.getAmountOfDataTransmitted(outputChannel.getID());
        final ExecutionVertex connectedVertex=executionGraph.getVertexByChannelID(outputChannel.getConnectedChannelID());
        final ExecutionState state=connectedVertex.getExecutionState();
        if (state == ExecutionState.SCHEDULED || state == ExecutionState.ASSIGNED) {
          targetVertices.put(connectedVertex,Long.valueOf(transmittedData));
          final AllocatedResource allocatedResource=connectedVertex.getAllocatedResource();
          if (!(allocatedResource.getInstance() instanceof DummyInstance)) {
            availableResources.put(allocatedResource,Long.valueOf(0L));
          }
        }
      }
    }
    if (targetVertices.isEmpty()) {
      return;
    }
    final Queue<ExecutionVertex> vertexQueue=new PriorityQueue<ExecutionVertex>(targetVertices.size(),new Comparator<ExecutionVertex>(){
      @Override public int compare(      final ExecutionVertex arg0,      final ExecutionVertex arg1){
        final Long l0=targetVertices.get(arg0);
        final Long l1=targetVertices.get(arg1);
        if (l0.longValue() == l1.longValue()) {
          return 0;
        }
        if (l0.longValue() < l1.longValue()) {
          return 1;
        }
        return -1;
      }
    }
);
    final Queue<AllocatedResource> resourceQueue=new PriorityQueue<AllocatedResource>(availableResources.size(),new Comparator<AllocatedResource>(){
      @Override public int compare(      final AllocatedResource arg0,      final AllocatedResource arg1){
        final Long l0=availableResources.get(arg0);
        final Long l1=availableResources.get(arg1);
        if (l0.longValue() == l1.longValue()) {
          return 0;
        }
        if (l0.longValue() < l1.longValue()) {
          return -1;
        }
        return 1;
      }
    }
);
    Iterator<ExecutionVertex> vertexIt=targetVertices.keySet().iterator();
    while (vertexIt.hasNext()) {
      vertexQueue.add(vertexIt.next());
    }
    final Iterator<AllocatedResource> resourceIt=availableResources.keySet().iterator();
    while (resourceIt.hasNext()) {
      resourceQueue.add(resourceIt.next());
    }
    while (!vertexQueue.isEmpty()) {
      final ExecutionVertex v=vertexQueue.poll();
      final long vertexLoad=targetVertices.get(v);
      System.out.println(v + ""String_Node_Str"" + vertexLoad);
      final AllocatedResource ar=resourceQueue.poll();
      final long resourceLoad=availableResources.get(ar).longValue();
      System.out.println(ar + ""String_Node_Str"" + resourceLoad);
      availableResources.put(ar,Long.valueOf(vertexLoad + resourceLoad));
      resourceQueue.add(ar);
      reassignGraphFragment(v,v.getAllocatedResource(),ar);
    }
    final Map<AbstractInstance,List<ExecutionVertex>> verticesToBeDeployed=new HashMap<AbstractInstance,List<ExecutionVertex>>();
    vertexIt=targetVertices.keySet().iterator();
    while (vertexIt.hasNext()) {
      this.scheduler.findVerticesToBeDeployed(vertexIt.next(),verticesToBeDeployed);
    }
    final Iterator<Map.Entry<AbstractInstance,List<ExecutionVertex>>> deploymentIt=verticesToBeDeployed.entrySet().iterator();
    while (deploymentIt.hasNext()) {
      final Map.Entry<AbstractInstance,List<ExecutionVertex>> entry=deploymentIt.next();
      this.scheduler.getDeploymentManager().deploy(executionGraph.getJobID(),entry.getKey(),entry.getValue());
    }
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void initialExecutionResourcesExhausted(final JobID jobID,final ExecutionVertexID vertexID,final ResourceUtilizationSnapshot resourceUtilizationSnapshot){
  final ExecutionGraph executionGraph=this.executionVertex.getExecutionGraph();
  System.out.println(this.executionVertex + ""String_Node_Str"");
  final Map<ExecutionVertex,Long> targetVertices=new HashMap<ExecutionVertex,Long>();
  final Map<AllocatedResource,Long> availableResources=new HashMap<AllocatedResource,Long>();
synchronized (executionGraph) {
    final Environment ee=this.executionVertex.getEnvironment();
    for (int i=0; i < ee.getNumberOfOutputGates(); ++i) {
      final OutputGate<? extends Record> outputGate=ee.getOutputGate(i);
      for (int j=0; j < outputGate.getNumberOfOutputChannels(); ++j) {
        final AbstractOutputChannel<? extends Record> outputChannel=outputGate.getOutputChannel(j);
        final long transmittedData=resourceUtilizationSnapshot.getAmountOfDataTransmitted(outputChannel.getID());
        final ExecutionVertex connectedVertex=executionGraph.getVertexByChannelID(outputChannel.getConnectedChannelID());
        final ExecutionState state=connectedVertex.getExecutionState();
        if (state == ExecutionState.SCHEDULED || state == ExecutionState.ASSIGNED) {
          targetVertices.put(connectedVertex,Long.valueOf(transmittedData));
          final AllocatedResource allocatedResource=connectedVertex.getAllocatedResource();
          if (!(allocatedResource.getInstance() instanceof DummyInstance)) {
            availableResources.put(allocatedResource,Long.valueOf(0L));
          }
        }
      }
    }
    if (targetVertices.isEmpty()) {
      return;
    }
    final Queue<ExecutionVertex> vertexQueue=new PriorityQueue<ExecutionVertex>(targetVertices.size(),new Comparator<ExecutionVertex>(){
      @Override public int compare(      final ExecutionVertex arg0,      final ExecutionVertex arg1){
        final Long l0=targetVertices.get(arg0);
        final Long l1=targetVertices.get(arg1);
        if (l0.longValue() == l1.longValue()) {
          return 0;
        }
        if (l0.longValue() < l1.longValue()) {
          return 1;
        }
        return -1;
      }
    }
);
    final Queue<AllocatedResource> resourceQueue=new PriorityQueue<AllocatedResource>(availableResources.size(),new Comparator<AllocatedResource>(){
      @Override public int compare(      final AllocatedResource arg0,      final AllocatedResource arg1){
        final Long l0=availableResources.get(arg0);
        final Long l1=availableResources.get(arg1);
        if (l0.longValue() == l1.longValue()) {
          return 0;
        }
        if (l0.longValue() < l1.longValue()) {
          return -1;
        }
        return 1;
      }
    }
);
    Iterator<ExecutionVertex> vertexIt=targetVertices.keySet().iterator();
    while (vertexIt.hasNext()) {
      vertexQueue.add(vertexIt.next());
    }
    final Iterator<AllocatedResource> resourceIt=availableResources.keySet().iterator();
    while (resourceIt.hasNext()) {
      resourceQueue.add(resourceIt.next());
    }
    while (!vertexQueue.isEmpty()) {
      final ExecutionVertex v=vertexQueue.poll();
      final long vertexLoad=targetVertices.get(v);
      System.out.println(v + ""String_Node_Str"" + vertexLoad);
      final AllocatedResource ar=resourceQueue.poll();
      final long resourceLoad=availableResources.get(ar).longValue();
      System.out.println(ar + ""String_Node_Str"" + resourceLoad);
      availableResources.put(ar,Long.valueOf(vertexLoad + resourceLoad));
      resourceQueue.add(ar);
      reassignGraphFragment(v,v.getAllocatedResource(),ar);
    }
    final Map<AbstractInstance,List<ExecutionVertex>> verticesToBeDeployed=new HashMap<AbstractInstance,List<ExecutionVertex>>();
    vertexIt=targetVertices.keySet().iterator();
    while (vertexIt.hasNext()) {
      this.scheduler.findVerticesToBeDeployed(vertexIt.next(),verticesToBeDeployed);
    }
    final Iterator<Map.Entry<AbstractInstance,List<ExecutionVertex>>> deploymentIt=verticesToBeDeployed.entrySet().iterator();
    while (deploymentIt.hasNext()) {
      final Map.Entry<AbstractInstance,List<ExecutionVertex>> entry=deploymentIt.next();
      this.scheduler.getDeploymentManager().deploy(executionGraph.getJobID(),entry.getKey(),entry.getValue());
    }
  }
}"
88095,"/** 
 * Checks if the given   {@link AllocatedResource} is still required for theexecution of the given execution graph. If the resource is no longer assigned to a vertex that is either currently running or about to run the given resource is returned to the instance manager for deallocation.
 * @param executionGraph the execution graph the provided resource has been used for so far
 * @param allocatedResource the allocated resource to check the assignment for
 */
public void checkAndReleaseAllocatedResource(ExecutionGraph executionGraph,AllocatedResource allocatedResource){
  if (allocatedResource == null) {
    LOG.error(""String_Node_Str"");
    return;
  }
  if (allocatedResource.getInstance() instanceof DummyInstance) {
    LOG.debug(""String_Node_Str"");
    return;
  }
synchronized (executionGraph) {
    final List<ExecutionVertex> assignedVertices=executionGraph.getVerticesAssignedToResource(allocatedResource);
    if (assignedVertices.isEmpty()) {
      return;
    }
    boolean instanceCanBeReleased=true;
    final Iterator<ExecutionVertex> it=assignedVertices.iterator();
    while (it.hasNext()) {
      final ExecutionVertex vertex=it.next();
      final ExecutionState state=vertex.getExecutionState();
      if (state != ExecutionState.CREATED && state != ExecutionState.FINISHED && state != ExecutionState.FAILED) {
        instanceCanBeReleased=false;
        break;
      }
    }
    if (instanceCanBeReleased) {
      LOG.info(""String_Node_Str"" + allocatedResource.getInstance());
      try {
        getInstanceManager().releaseAllocatedResource(executionGraph.getJobID(),executionGraph.getJobConfiguration(),allocatedResource);
      }
 catch (      InstanceException e) {
        LOG.error(StringUtils.stringifyException(e));
      }
    }
  }
}","/** 
 * Checks if the given   {@link AllocatedResource} is still required for theexecution of the given execution graph. If the resource is no longer assigned to a vertex that is either currently running or about to run the given resource is returned to the instance manager for deallocation.
 * @param executionGraph the execution graph the provided resource has been used for so far
 * @param allocatedResource the allocated resource to check the assignment for
 */
public void checkAndReleaseAllocatedResource(ExecutionGraph executionGraph,AllocatedResource allocatedResource){
  if (allocatedResource == null) {
    LOG.error(""String_Node_Str"");
    return;
  }
  if (allocatedResource.getInstance() instanceof DummyInstance) {
    LOG.debug(""String_Node_Str"");
    return;
  }
synchronized (executionGraph) {
    final List<ExecutionVertex> assignedVertices=executionGraph.getVerticesAssignedToResource(allocatedResource);
    if (assignedVertices.isEmpty()) {
      return;
    }
    boolean instanceCanBeReleased=true;
    final Iterator<ExecutionVertex> it=assignedVertices.iterator();
    while (it.hasNext()) {
      final ExecutionVertex vertex=it.next();
      final ExecutionState state=vertex.getExecutionState();
      if (state != ExecutionState.CREATED && state != ExecutionState.FINISHED && state != ExecutionState.FAILED && state != ExecutionState.CANCELED) {
        instanceCanBeReleased=false;
        break;
      }
    }
    if (instanceCanBeReleased) {
      LOG.info(""String_Node_Str"" + allocatedResource.getInstance());
      try {
        getInstanceManager().releaseAllocatedResource(executionGraph.getJobID(),executionGraph.getJobConfiguration(),allocatedResource);
      }
 catch (      InstanceException e) {
        LOG.error(StringUtils.stringifyException(e));
      }
    }
  }
}"
88096,"/** 
 * Checks if the given   {@link AllocatedResource} is still required for theexecution of the given execution graph. If the resource is no longer assigned to a vertex that is either currently running or about to run the given resource is returned to the instance manager for deallocation.
 * @param executionGraph the execution graph the provided resource has been used for so far
 * @param allocatedResource the allocated resource to check the assignment for
 */
public void checkAndReleaseAllocatedResource(ExecutionGraph executionGraph,AllocatedResource allocatedResource){
  if (allocatedResource == null) {
    LOG.error(""String_Node_Str"");
    return;
  }
  if (allocatedResource.getInstance() instanceof DummyInstance) {
    LOG.debug(""String_Node_Str"");
    return;
  }
synchronized (executionGraph) {
    final List<ExecutionVertex> assignedVertices=executionGraph.getVerticesAssignedToResource(allocatedResource);
    if (assignedVertices.isEmpty()) {
      return;
    }
    boolean instanceCanBeReleased=true;
    final Iterator<ExecutionVertex> it=assignedVertices.iterator();
    while (it.hasNext()) {
      final ExecutionVertex vertex=it.next();
      final ExecutionState state=vertex.getExecutionState();
      if (state == ExecutionState.SCHEDULED || state == ExecutionState.READY || state == ExecutionState.RUNNING || state == ExecutionState.FINISHING || state == ExecutionState.CANCELING) {
        instanceCanBeReleased=false;
        break;
      }
    }
    if (instanceCanBeReleased) {
      LOG.info(""String_Node_Str"" + allocatedResource.getInstance());
      try {
        getInstanceManager().releaseAllocatedResource(executionGraph.getJobID(),executionGraph.getJobConfiguration(),allocatedResource);
      }
 catch (      InstanceException e) {
        LOG.error(StringUtils.stringifyException(e));
      }
    }
  }
}","/** 
 * Checks if the given   {@link AllocatedResource} is still required for theexecution of the given execution graph. If the resource is no longer assigned to a vertex that is either currently running or about to run the given resource is returned to the instance manager for deallocation.
 * @param executionGraph the execution graph the provided resource has been used for so far
 * @param allocatedResource the allocated resource to check the assignment for
 */
public void checkAndReleaseAllocatedResource(ExecutionGraph executionGraph,AllocatedResource allocatedResource){
  if (allocatedResource == null) {
    LOG.error(""String_Node_Str"");
    return;
  }
  if (allocatedResource.getInstance() instanceof DummyInstance) {
    LOG.debug(""String_Node_Str"");
    return;
  }
synchronized (executionGraph) {
    final List<ExecutionVertex> assignedVertices=executionGraph.getVerticesAssignedToResource(allocatedResource);
    if (assignedVertices.isEmpty()) {
      return;
    }
    boolean instanceCanBeReleased=true;
    final Iterator<ExecutionVertex> it=assignedVertices.iterator();
    while (it.hasNext()) {
      final ExecutionVertex vertex=it.next();
      final ExecutionState state=vertex.getExecutionState();
      if (state != ExecutionState.CREATED && state != ExecutionState.FINISHED && state != ExecutionState.FAILED) {
        instanceCanBeReleased=false;
        break;
      }
    }
    if (instanceCanBeReleased) {
      LOG.info(""String_Node_Str"" + allocatedResource.getInstance());
      try {
        getInstanceManager().releaseAllocatedResource(executionGraph.getJobID(),executionGraph.getJobConfiguration(),allocatedResource);
      }
 catch (      InstanceException e) {
        LOG.error(StringUtils.stringifyException(e));
      }
    }
  }
}"
88097,"@Override public void run() throws Exception {
  final KeyGroupedIterator it=new KeyGroupedIterator(closeableInput.getIterator(),keyPositions,keyClasses);
  while (this.running && it.nextKey()) {
    System.out.println(""String_Node_Str"" + it.getKeys()[0]);
    crossValues(it.getValues(),output);
  }
}","@Override public void run() throws Exception {
  final KeyGroupedIterator it=new KeyGroupedIterator(closeableInput.getIterator(),keyPositions,keyClasses);
  while (this.running && it.nextKey()) {
    crossValues(it.getValues(),output);
  }
}"
88098,"/** 
 * Crosses the values of all pairs that have the same key. The   {@link MatchStub#match(Key,Iterator,Collector)} method is called for each element of the Cartesian product. 
 * @param key The key of all values in the iterator.
 * @param vals An iterator over values that share the same key.
 * @param out The collector to write the results to.
 * @throws Exception 
 */
private final void crossValues(final Iterator<PactRecord> values,final OutputCollector out) throws Exception {
  final PactRecord[] valBuffer=new PactRecord[VALUE_BUFFER_SIZE];
  int bufferValCnt;
  for (bufferValCnt=0; bufferValCnt < VALUE_BUFFER_SIZE; bufferValCnt++) {
    if (values.hasNext()) {
      valBuffer[bufferValCnt]=values.next().createCopy();
    }
 else {
      break;
    }
  }
  for (int i=0; i < bufferValCnt; i++) {
    if (!this.running)     return;
    for (int j=0; j < bufferValCnt; j++) {
      if (!this.running)       return;
      stub.match(valBuffer[i].createCopy(),valBuffer[j].createCopy(),out);
    }
  }
  if (this.running && values.hasNext()) {
    MutableObjectIterator<PactRecord> valReader=new MutableObjectIterator<PactRecord>(){
      @Override public boolean next(      PactRecord target) throws IOException {
        if (!running || !values.hasNext()) {
          return false;
        }
        values.next().copyTo(target);
        for (int i=0; i < VALUE_BUFFER_SIZE; i++) {
          try {
            stub.match(valBuffer[i].createCopy(),target.createCopy(),out);
          }
 catch (          Exception e) {
            e.printStackTrace();
          }
        }
        return true;
      }
    }
;
    SpillingResettableMutableObjectIterator outerValResettableIterator=null;
    SpillingResettableMutableObjectIterator innerValResettableIterator=null;
    try {
      outerValResettableIterator=new SpillingResettableMutableObjectIterator(memoryManager,ioManager,valReader,(long)(availableMemory * (MEMORY_SHARE_RATIO / 2)),this);
      outerValResettableIterator.open();
      BufferIncludingIterator bii=new BufferIncludingIterator(valBuffer,outerValResettableIterator);
      PactRecord outerRecord=new PactRecord();
      PactRecord innerRecord=new PactRecord();
      if (this.running && outerValResettableIterator.next(outerRecord)) {
        innerValResettableIterator=new SpillingResettableMutableObjectIterator(memoryManager,ioManager,bii,(long)(availableMemory * (MEMORY_SHARE_RATIO / 2)),this);
        innerValResettableIterator.open();
        outerValResettableIterator.reset();
        while (this.running && outerValResettableIterator.next(outerRecord)) {
          bufferValCnt=0;
          do {
            outerRecord.copyTo(valBuffer[bufferValCnt++]);
          }
 while (this.running && outerValResettableIterator.next(outerRecord) && bufferValCnt < VALUE_BUFFER_SIZE);
          if (bufferValCnt == 0)           break;
          while (this.running && innerValResettableIterator.next(innerRecord)) {
            for (int i=0; i < bufferValCnt; i++) {
              stub.match(valBuffer[i].createCopy(),innerRecord,out);
              if (i < bufferValCnt - 1)               innerValResettableIterator.repeatLast(innerRecord);
            }
          }
          innerValResettableIterator.reset();
        }
      }
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
 finally {
      if (innerValResettableIterator != null) {
        innerValResettableIterator.close();
      }
      if (outerValResettableIterator != null) {
        outerValResettableIterator.close();
      }
    }
  }
}","/** 
 * Crosses the values of all pairs that have the same key. The   {@link MatchStub#match(Key,Iterator,Collector)} method is called for each element of the Cartesian product. 
 * @param values An iterator over values that share the same key.
 * @param out The collector to write the results to.
 * @throws Exception 
 */
private final void crossValues(final Iterator<PactRecord> values,final OutputCollector out) throws Exception {
  final PactRecord[] valBuffer=new PactRecord[VALUE_BUFFER_SIZE];
  int bufferValCnt;
  for (bufferValCnt=0; bufferValCnt < VALUE_BUFFER_SIZE; bufferValCnt++) {
    if (values.hasNext()) {
      valBuffer[bufferValCnt]=values.next().createCopy();
    }
 else {
      break;
    }
  }
  for (int i=0; i < bufferValCnt; i++) {
    if (!this.running)     return;
    for (int j=0; j < bufferValCnt; j++) {
      if (!this.running)       return;
      stub.match(valBuffer[i].createCopy(),valBuffer[j].createCopy(),out);
    }
  }
  if (this.running && values.hasNext()) {
    MutableObjectIterator<PactRecord> valReader=new MutableObjectIterator<PactRecord>(){
      @Override public boolean next(      PactRecord target) throws IOException {
        if (!running || !values.hasNext()) {
          return false;
        }
        values.next().copyTo(target);
        for (int i=0; i < VALUE_BUFFER_SIZE; i++) {
          try {
            stub.match(valBuffer[i].createCopy(),target.createCopy(),out);
          }
 catch (          Exception e) {
            exceptionInMatchForValReader=e;
            return false;
          }
        }
        return true;
      }
    }
;
    SpillingResettableMutableObjectIterator outerValResettableIterator=null;
    SpillingResettableMutableObjectIterator innerValResettableIterator=null;
    try {
      outerValResettableIterator=new SpillingResettableMutableObjectIterator(memoryManager,ioManager,valReader,(long)(availableMemory * (MEMORY_SHARE_RATIO / 2)),this);
      outerValResettableIterator.open();
      if (exceptionInMatchForValReader != null) {
        throw exceptionInMatchForValReader;
      }
      BufferIncludingIterator bii=new BufferIncludingIterator(valBuffer,outerValResettableIterator);
      PactRecord outerRecord=new PactRecord();
      PactRecord innerRecord=new PactRecord();
      if (this.running) {
        innerValResettableIterator=new SpillingResettableMutableObjectIterator(memoryManager,ioManager,bii,(long)(availableMemory * (MEMORY_SHARE_RATIO / 2)),this);
        innerValResettableIterator.open();
        outerValResettableIterator.reset();
        while (this.running && outerValResettableIterator.next(outerRecord)) {
          bufferValCnt=0;
          do {
            outerRecord.copyTo(valBuffer[bufferValCnt++]);
          }
 while (this.running && bufferValCnt < VALUE_BUFFER_SIZE && outerValResettableIterator.next(outerRecord));
          if (bufferValCnt == 0)           break;
          while (this.running && innerValResettableIterator.next(innerRecord)) {
            for (int i=0; i < bufferValCnt; i++) {
              stub.match(valBuffer[i].createCopy(),innerRecord,out);
              if (i < bufferValCnt - 1)               innerValResettableIterator.repeatLast(innerRecord);
            }
          }
          innerValResettableIterator.reset();
        }
      }
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
 finally {
      if (innerValResettableIterator != null) {
        innerValResettableIterator.close();
      }
      if (outerValResettableIterator != null) {
        outerValResettableIterator.close();
      }
    }
  }
}"
88099,"@Test public void testNoneSelfMatchTask(){
  int keyCnt=100;
  int valCnt=5;
  super.initEnvironment(3 * 1024 * 1024);
  super.addInput(new RegularlyGeneratedInputGenerator(keyCnt,valCnt,true));
  super.addOutput(outList);
  SelfMatchTask testTask=new SelfMatchTask();
  super.getTaskConfig().setLocalStrategy(LocalStrategy.SELF_NESTEDLOOP);
  super.getTaskConfig().setMemorySize(3 * 1024 * 1024);
  super.getTaskConfig().setNumFilehandles(4);
  super.getTaskConfig().setLocalStrategyKeyTypes(0,new int[]{0});
  super.getTaskConfig().setLocalStrategyKeyTypes(new Class[]{PactInteger.class});
  super.registerTask(testTask,MockMatchStub.class);
  try {
    testTask.invoke();
  }
 catch (  Exception e) {
    LOG.debug(e);
    Assert.fail(""String_Node_Str"");
  }
  int expCnt=keyCnt * (valCnt * valCnt);
  Assert.assertTrue(""String_Node_Str"" + outList.size() + ""String_Node_Str""+ expCnt,outList.size() == expCnt);
  HashMap<Integer,Integer> keyValCntMap=new HashMap<Integer,Integer>(keyCnt);
  int lk=0;
  for (  PactRecord record : outList) {
    Integer key=record.getField(0,PactInteger.class).getValue();
    if (key == 0) {
      System.out.println((++lk) + ""String_Node_Str"" + record.getField(1,PactInteger.class).getValue());
    }
    if (!keyValCntMap.containsKey(key)) {
      keyValCntMap.put(key,1);
    }
 else {
      keyValCntMap.put(key,keyValCntMap.get(key) + 1);
    }
  }
  for (  Integer key : keyValCntMap.keySet()) {
    if (keyValCntMap.get(key) == (valCnt * valCnt)) {
      System.out.println(""String_Node_Str"");
    }
 else {
      System.out.println(""String_Node_Str"");
    }
    Assert.assertTrue(""String_Node_Str"" + keyValCntMap.get(key) + ""String_Node_Str""+ (valCnt * valCnt),keyValCntMap.get(key) == (valCnt * valCnt));
  }
  outList.clear();
}","@Test public void testNoneSelfMatchTask(){
  int keyCnt=100;
  int valCnt=5;
  super.initEnvironment(3 * 1024 * 1024);
  super.addInput(new RegularlyGeneratedInputGenerator(keyCnt,valCnt,true));
  super.addOutput(outList);
  SelfMatchTask testTask=new SelfMatchTask();
  super.getTaskConfig().setLocalStrategy(LocalStrategy.SELF_NESTEDLOOP);
  super.getTaskConfig().setMemorySize(3 * 1024 * 1024);
  super.getTaskConfig().setNumFilehandles(4);
  super.getTaskConfig().setLocalStrategyKeyTypes(0,new int[]{0});
  super.getTaskConfig().setLocalStrategyKeyTypes(new Class[]{PactInteger.class});
  super.registerTask(testTask,MockMatchStub.class);
  try {
    testTask.invoke();
  }
 catch (  Exception e) {
    LOG.debug(e);
    Assert.fail(""String_Node_Str"");
  }
  int expCnt=keyCnt * (valCnt * valCnt);
  Assert.assertTrue(""String_Node_Str"" + outList.size() + ""String_Node_Str""+ expCnt,outList.size() == expCnt);
  HashMap<Integer,Integer> keyValCntMap=new HashMap<Integer,Integer>(keyCnt);
  for (  PactRecord record : outList) {
    Integer key=record.getField(0,PactInteger.class).getValue();
    if (!keyValCntMap.containsKey(key)) {
      keyValCntMap.put(key,1);
    }
 else {
      keyValCntMap.put(key,keyValCntMap.get(key) + 1);
    }
  }
  for (  Integer key : keyValCntMap.keySet()) {
    Assert.assertTrue(""String_Node_Str"" + keyValCntMap.get(key) + ""String_Node_Str""+ (valCnt * valCnt),keyValCntMap.get(key) == (valCnt * valCnt));
  }
  outList.clear();
}"
88100,"/** 
 * {@inheritDoc}
 */
@Override public void close() throws IOException, InterruptedException {
  this.deserializationBuffer.clear();
  if (this.uncompressedDataBuffer != null) {
    releasedConsumedReadBuffer();
  }
  if (this.getType() == ChannelType.NETWORK) {
synchronized (this.synchronisationObject) {
      if (!this.brokerAggreedToCloseChannel) {
        while (!this.brokerAggreedToCloseChannel) {
          requestReadBuffersFromBroker();
          if (this.uncompressedDataBuffer != null || this.compressedDataBuffer != null) {
            releasedConsumedReadBuffer();
          }
          this.synchronisationObject.wait(500);
        }
        this.bufferedRecord=null;
      }
    }
  }
  if (getType() == ChannelType.NETWORK) {
    transferEvent(new ByteBufferedChannelCloseEvent());
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void close() throws IOException, InterruptedException {
  this.deserializationBuffer.clear();
  if (this.uncompressedDataBuffer != null) {
    releasedConsumedReadBuffer();
  }
  if (this.getType() == ChannelType.NETWORK) {
synchronized (this.synchronisationObject) {
      if (!this.brokerAggreedToCloseChannel) {
        while (!this.brokerAggreedToCloseChannel) {
          requestReadBuffersFromBroker();
          if (this.uncompressedDataBuffer != null || this.compressedDataBuffer != null) {
            releasedConsumedReadBuffer();
          }
          this.synchronisationObject.wait(500);
        }
        this.bufferedRecord=null;
      }
    }
  }
  final ChannelType type=getType();
  if (type == ChannelType.NETWORK || type == ChannelType.INMEMORY) {
    transferEvent(new ByteBufferedChannelCloseEvent());
  }
}"
88101,"public void wire(ExecutionGroupVertex source,int indexOfOutputGate,ExecutionGroupVertex target,int indexOfInputGate,ChannelType channelType,CompressionLevel compressionLevel) throws GraphConversionException {
  for (int i=0; i < source.getCurrentNumberOfGroupMembers(); i++) {
    final ExecutionVertex sourceVertex=source.getGroupMember(i);
    final OutputGate<? extends Record> outputGate=sourceVertex.getEnvironment().getOutputGate(indexOfOutputGate);
    if (outputGate == null) {
      throw new GraphConversionException(""String_Node_Str"" + sourceVertex.getName() + ""String_Node_Str""+ indexOfOutputGate);
    }
    if (outputGate.getNumberOfOutputChannels() > 0) {
      throw new GraphConversionException(""String_Node_Str"" + sourceVertex.getName() + ""String_Node_Str""+ i+ ""String_Node_Str""+ outputGate.getNumberOfOutputChannels()+ ""String_Node_Str"");
    }
    for (int j=0; j < target.getCurrentNumberOfGroupMembers(); j++) {
      final ExecutionVertex targetVertex=target.getGroupMember(j);
      final InputGate<? extends Record> inputGate=targetVertex.getEnvironment().getInputGate(indexOfInputGate);
      if (inputGate == null) {
        throw new GraphConversionException(""String_Node_Str"" + targetVertex.getName() + ""String_Node_Str""+ indexOfInputGate);
      }
      if (inputGate.getNumberOfInputChannels() > 0 && i == 0) {
        throw new GraphConversionException(""String_Node_Str"" + targetVertex.getName() + ""String_Node_Str""+ j+ ""String_Node_Str""+ inputGate.getNumberOfInputChannels()+ ""String_Node_Str"");
      }
      if (inputGate.getDistributionPattern().createWire(i,j,source.getCurrentNumberOfGroupMembers(),target.getCurrentNumberOfGroupMembers())) {
        createChannel(sourceVertex,outputGate,targetVertex,inputGate,channelType,compressionLevel);
      }
    }
  }
}","public void wire(ExecutionGroupVertex source,int indexOfOutputGate,ExecutionGroupVertex target,int indexOfInputGate,ChannelType channelType,CompressionLevel compressionLevel) throws GraphConversionException {
  for (int i=0; i < source.getCurrentNumberOfGroupMembers(); i++) {
    final ExecutionVertex sourceVertex=source.getGroupMember(i);
    final OutputGate<? extends Record> outputGate=sourceVertex.getEnvironment().getOutputGate(indexOfOutputGate);
    if (outputGate == null) {
      throw new GraphConversionException(""String_Node_Str"" + sourceVertex.getName() + ""String_Node_Str""+ indexOfOutputGate);
    }
    if (outputGate.getNumberOfOutputChannels() > 0) {
      throw new GraphConversionException(""String_Node_Str"" + sourceVertex.getName() + ""String_Node_Str""+ i+ ""String_Node_Str""+ outputGate.getNumberOfOutputChannels()+ ""String_Node_Str"");
    }
    for (int j=0; j < target.getCurrentNumberOfGroupMembers(); j++) {
      final ExecutionVertex targetVertex=target.getGroupMember(j);
      final InputGate<? extends Record> inputGate=targetVertex.getEnvironment().getInputGate(indexOfInputGate);
      if (inputGate == null) {
        throw new GraphConversionException(""String_Node_Str"" + targetVertex.getName() + ""String_Node_Str""+ indexOfInputGate);
      }
      if (inputGate.getNumberOfInputChannels() > 0 && i == 0) {
        throw new GraphConversionException(""String_Node_Str"" + targetVertex.getName() + ""String_Node_Str""+ j+ ""String_Node_Str""+ inputGate.getNumberOfInputChannels()+ ""String_Node_Str"");
      }
      if (inputGate.getDistributionPattern().createWire(i,j,source.getCurrentNumberOfGroupMembers(),target.getCurrentNumberOfGroupMembers())) {
        createChannel(sourceVertex,outputGate,targetVertex,inputGate,channelType,compressionLevel);
      }
      inputGate.setChannelType(channelType);
    }
    outputGate.setChannelType(channelType);
  }
}"
88102,"public SerializableHashSet<ChannelID> constructInitialActiveOutputChannelsSet(){
  final SerializableHashSet<ChannelID> activeOutputChannels=new SerializableHashSet<ChannelID>();
synchronized (this) {
    final int numberOfOutputGates=this.environment.getNumberOfOutputGates();
    for (int i=0; i < numberOfOutputGates; ++i) {
      final OutputGate<? extends Record> outputGate=this.environment.getOutputGate(i);
      final ChannelType channelType=outputGate.getChannelType();
      final int numberOfOutputChannels=outputGate.getNumberOfOutputChannels();
      for (int j=0; j < numberOfOutputChannels; ++j) {
        final AbstractOutputChannel<? extends Record> outputChannel=outputGate.getOutputChannel(j);
        if (channelType == ChannelType.FILE) {
          continue;
        }
        if (channelType == ChannelType.INMEMORY) {
          activeOutputChannels.add(outputChannel.getID());
          continue;
        }
        if (channelType == ChannelType.NETWORK) {
          final ExecutionVertex connectedVertex=this.executionGraph.getVertexByChannelID(outputChannel.getConnectedChannelID());
          final ExecutionState state=connectedVertex.getExecutionState();
          if (state == ExecutionState.READY || state == ExecutionState.STARTING || state == ExecutionState.RUNNING) {
            activeOutputChannels.add(outputChannel.getID());
          }
        }
      }
    }
  }
  return activeOutputChannels;
}","public SerializableHashSet<ChannelID> constructInitialActiveOutputChannelsSet(){
  final SerializableHashSet<ChannelID> activeOutputChannels=new SerializableHashSet<ChannelID>();
synchronized (this) {
    final int numberOfOutputGates=this.environment.getNumberOfOutputGates();
    for (int i=0; i < numberOfOutputGates; ++i) {
      final OutputGate<? extends Record> outputGate=this.environment.getOutputGate(i);
      final ChannelType channelType=outputGate.getChannelType();
      final int numberOfOutputChannels=outputGate.getNumberOfOutputChannels();
      for (int j=0; j < numberOfOutputChannels; ++j) {
        final AbstractOutputChannel<? extends Record> outputChannel=outputGate.getOutputChannel(j);
        if (channelType == ChannelType.FILE) {
          activeOutputChannels.add(outputChannel.getID());
          continue;
        }
        if (channelType == ChannelType.INMEMORY) {
          activeOutputChannels.add(outputChannel.getID());
          continue;
        }
        if (channelType == ChannelType.NETWORK) {
          final ExecutionVertex connectedVertex=this.executionGraph.getVertexByChannelID(outputChannel.getConnectedChannelID());
          final ExecutionState state=connectedVertex.getExecutionState();
          if (state == ExecutionState.READY || state == ExecutionState.STARTING || state == ExecutionState.RUNNING) {
            activeOutputChannels.add(outputChannel.getID());
          }
        }
      }
    }
  }
  return activeOutputChannels;
}"
88103,"public InstanceSummaryProfilingEvent getInstanceSummaryProfilingData(long timestamp){
  final Set<AbstractInstance> tempSet=new HashSet<AbstractInstance>();
  final ExecutionGroupVertexIterator it=new ExecutionGroupVertexIterator(this.executionGraph,true,this.executionGraph.getIndexOfCurrentExecutionStage());
  while (it.hasNext()) {
    final ExecutionGroupVertex groupVertex=it.next();
    for (int i=0; i < groupVertex.getCurrentNumberOfGroupMembers(); i++) {
      final ExecutionVertex executionVertex=groupVertex.getGroupMember(i);
      tempSet.add(executionVertex.getAllocatedResource().getInstance());
    }
  }
  if (tempSet.size() != this.collectedInstanceProfilingData.size()) {
    return null;
  }
  return constructInstanceSummary(timestamp);
}","public InstanceSummaryProfilingEvent getInstanceSummaryProfilingData(long timestamp){
  final Set<AbstractInstance> tempSet=new HashSet<AbstractInstance>();
  final ExecutionGroupVertexIterator it=new ExecutionGroupVertexIterator(this.executionGraph,true,this.executionGraph.getIndexOfCurrentExecutionStage());
  while (it.hasNext()) {
    final ExecutionGroupVertex groupVertex=it.next();
    for (int i=0; i < groupVertex.getCurrentNumberOfGroupMembers(); i++) {
      final ExecutionVertex executionVertex=groupVertex.getGroupMember(i);
      final AbstractInstance instance=executionVertex.getAllocatedResource().getInstance();
      if (!(instance instanceof DummyInstance)) {
        tempSet.add(instance);
      }
    }
  }
  if (tempSet.size() != this.collectedInstanceProfilingData.size()) {
    return null;
  }
  return constructInstanceSummary(timestamp);
}"
88104,"public SerializableHashSet<ChannelID> constructInitialActiveOutputChannelsSet(){
  final SerializableHashSet<ChannelID> activeOutputChannels=new SerializableHashSet<ChannelID>();
synchronized (this) {
    final int numberOfOutputGates=this.environment.getNumberOfOutputGates();
    for (int i=0; i < numberOfOutputGates; ++i) {
      final OutputGate<? extends Record> outputGate=this.environment.getOutputGate(i);
      final ChannelType channelType=outputGate.getChannelType();
      final int numberOfOutputChannels=outputGate.getNumberOfOutputChannels();
      for (int j=0; j < numberOfOutputChannels; ++j) {
        final AbstractOutputChannel<? extends Record> outputChannel=outputGate.getOutputChannel(j);
        if (channelType == ChannelType.FILE) {
          continue;
        }
        if (channelType == ChannelType.INMEMORY) {
          activeOutputChannels.add(outputChannel.getID());
          continue;
        }
        if (channelType == ChannelType.NETWORK) {
          final ExecutionVertex connectedVertex=this.executionGraph.getVertexByChannelID(outputChannel.getConnectedChannelID());
          final ExecutionState state=connectedVertex.getExecutionState();
          if (state == ExecutionState.READY || state == ExecutionState.RUNNING) {
            activeOutputChannels.add(outputChannel.getID());
          }
        }
      }
    }
  }
  return activeOutputChannels;
}","public SerializableHashSet<ChannelID> constructInitialActiveOutputChannelsSet(){
  final SerializableHashSet<ChannelID> activeOutputChannels=new SerializableHashSet<ChannelID>();
synchronized (this) {
    final int numberOfOutputGates=this.environment.getNumberOfOutputGates();
    for (int i=0; i < numberOfOutputGates; ++i) {
      final OutputGate<? extends Record> outputGate=this.environment.getOutputGate(i);
      final ChannelType channelType=outputGate.getChannelType();
      final int numberOfOutputChannels=outputGate.getNumberOfOutputChannels();
      for (int j=0; j < numberOfOutputChannels; ++j) {
        final AbstractOutputChannel<? extends Record> outputChannel=outputGate.getOutputChannel(j);
        if (channelType == ChannelType.FILE) {
          continue;
        }
        if (channelType == ChannelType.INMEMORY) {
          activeOutputChannels.add(outputChannel.getID());
          continue;
        }
        if (channelType == ChannelType.NETWORK) {
          final ExecutionVertex connectedVertex=this.executionGraph.getVertexByChannelID(outputChannel.getConnectedChannelID());
          final ExecutionState state=connectedVertex.getExecutionState();
          if (state == ExecutionState.READY || state == ExecutionState.STARTING || state == ExecutionState.RUNNING) {
            activeOutputChannels.add(outputChannel.getID());
          }
        }
      }
    }
  }
  return activeOutputChannels;
}"
88105,"/** 
 * {@inheritDoc}
 */
@Override public void userThreadFinished(Environment ee,Thread userThread){
}","/** 
 * {@inheritDoc}
 */
@Override public void userThreadFinished(final Environment ee,final Thread userThread){
}"
88106,"/** 
 * {@inheritDoc}
 */
@Override public void userThreadStarted(Environment ee,Thread userThread){
}","/** 
 * {@inheritDoc}
 */
@Override public void userThreadStarted(final Environment ee,final Thread userThread){
}"
88107,"/** 
 * Runs a blocked nested loop strategy to build the Cartesian product and call the <code>cross()</code> method of the CrossStub implementation. The outer side is read using a BlockResettableIterator. The inner side is read using a SpillingResettableIterator.
 * @see eu.stratosphere.pact.runtime.resettable.SpillingResettableIterator
 * @see eu.stratosphere.pact.runtime.resettable.BlockResettableIterator
 * @param memoryManager The task manager's memory manager.
 * @param ioManager The task manager's IO manager
 * @param innerReader The inner reader of the nested loops.
 * @param outerReader The outer reader of the nested loops.
 * @throws RuntimeException Throws a RuntimeException if something fails during execution.
 */
private void runBlocked(MemoryManager memoryManager,IOManager ioManager,Iterator<KeyValuePair<Key,Value>> innerReader,Iterator<KeyValuePair<Key,Value>> outerReader) throws Exception {
  SpillingResettableIterator<KeyValuePair<Key,Value>> innerInput=null;
  BlockResettableIterator<KeyValuePair<Key,Value>> outerInput=null;
  try {
    final boolean firstInputIsOuter;
    if (this.config.getLocalStrategy() == LocalStrategy.NESTEDLOOP_BLOCKED_OUTER_SECOND) {
      try {
        innerInput=new SpillingResettableIterator<KeyValuePair<Key,Value>>(memoryManager,ioManager,innerReader,this.availableMemory / 2,new KeyValuePairDeserializer<Key,Value>(stub.getFirstInKeyType(),stub.getFirstInValueType()),this);
        this.spillingResetIt=innerInput;
      }
 catch (      MemoryAllocationException mae) {
        throw new RuntimeException(""String_Node_Str"",mae);
      }
      try {
        outerInput=new BlockResettableIterator<KeyValuePair<Key,Value>>(memoryManager,outerReader,this.availableMemory / 2,1,new KeyValuePairDeserializer<Key,Value>(stub.getSecondInKeyType(),stub.getSecondInValueType()),this);
        this.blockResetIt=outerInput;
      }
 catch (      MemoryAllocationException mae) {
        throw new RuntimeException(""String_Node_Str"",mae);
      }
      firstInputIsOuter=false;
    }
 else     if (this.config.getLocalStrategy() == LocalStrategy.NESTEDLOOP_BLOCKED_OUTER_FIRST) {
      try {
        innerInput=new SpillingResettableIterator<KeyValuePair<Key,Value>>(memoryManager,ioManager,innerReader,this.availableMemory / 2,new KeyValuePairDeserializer<Key,Value>(stub.getSecondInKeyType(),stub.getSecondInValueType()),this);
        this.spillingResetIt=innerInput;
      }
 catch (      MemoryAllocationException mae) {
        throw new RuntimeException(""String_Node_Str"",mae);
      }
      try {
        outerInput=new BlockResettableIterator<KeyValuePair<Key,Value>>(memoryManager,outerReader,this.availableMemory / 2,1,new KeyValuePairDeserializer<Key,Value>(stub.getFirstInKeyType(),stub.getFirstInValueType()),this);
        this.blockResetIt=outerInput;
      }
 catch (      MemoryAllocationException mae) {
        throw new RuntimeException(""String_Node_Str"",mae);
      }
      firstInputIsOuter=true;
    }
 else {
      throw new RuntimeException(""String_Node_Str"" + config.getLocalStrategy());
    }
    try {
      innerInput.open();
    }
 catch (    ServiceException se) {
      throw new RuntimeException(""String_Node_Str"",se);
    }
catch (    IOException ioe) {
      throw new RuntimeException(""String_Node_Str"",ioe);
    }
catch (    InterruptedException ie) {
      throw new RuntimeException(""String_Node_Str"",ie);
    }
    if (this.taskCanceled)     return;
    outerInput.open();
    if (LOG.isDebugEnabled()) {
      LOG.debug(getLogString(""String_Node_Str""));
      LOG.debug(getLogString(""String_Node_Str""));
    }
    this.stub.open();
    boolean moreOuterBlocks=false;
    if (innerInput.hasNext()) {
      do {
        while (!this.taskCanceled && innerInput.hasNext()) {
          KeyValuePair<Key,Value> innerPair=innerInput.next();
          while (!this.taskCanceled && outerInput.hasNext()) {
            KeyValuePair<Key,Value> outerPair=outerInput.next();
            if (firstInputIsOuter) {
              stub.cross(outerPair.getKey(),outerPair.getValue(),innerPair.getKey(),innerPair.getValue(),output);
            }
 else {
              stub.cross(innerPair.getKey(),innerPair.getValue(),outerPair.getKey(),outerPair.getValue(),output);
            }
            innerPair=innerInput.repeatLast();
          }
          outerInput.reset();
        }
        moreOuterBlocks=outerInput.nextBlock();
        if (moreOuterBlocks) {
          innerInput.reset();
        }
      }
 while (!this.taskCanceled && moreOuterBlocks);
    }
    this.stub.close();
  }
 catch (  Exception ex) {
    if (!this.taskCanceled) {
      LOG.error(getLogString(""String_Node_Str""));
      throw ex;
    }
  }
 finally {
    Throwable t1=null, t2=null;
    try {
      if (innerInput != null) {
        innerInput.close();
      }
    }
 catch (    Throwable t) {
      LOG.warn(t);
      t1=t;
    }
    try {
      if (outerInput != null) {
        outerInput.close();
      }
    }
 catch (    Throwable t) {
      LOG.warn(t);
      t2=t;
    }
    if (t1 != null)     throw new RuntimeException(""String_Node_Str"",t1);
    if (t2 != null)     throw new RuntimeException(""String_Node_Str"",t2);
  }
}","/** 
 * Runs a blocked nested loop strategy to build the Cartesian product and call the <code>cross()</code> method of the CrossStub implementation. The outer side is read using a BlockResettableIterator. The inner side is read using a SpillingResettableIterator.
 * @see eu.stratosphere.pact.runtime.resettable.SpillingResettableIterator
 * @see eu.stratosphere.pact.runtime.resettable.BlockResettableIterator
 * @param memoryManager The task manager's memory manager.
 * @param ioManager The task manager's IO manager
 * @param innerReader The inner reader of the nested loops.
 * @param outerReader The outer reader of the nested loops.
 * @throws RuntimeException Throws a RuntimeException if something fails during execution.
 */
private void runBlocked(MemoryManager memoryManager,IOManager ioManager,Iterator<KeyValuePair<Key,Value>> innerReader,Iterator<KeyValuePair<Key,Value>> outerReader) throws Exception {
  SpillingResettableIterator<KeyValuePair<Key,Value>> innerInput=null;
  BlockResettableIterator<KeyValuePair<Key,Value>> outerInput=null;
  try {
    final boolean firstInputIsOuter;
    if (this.config.getLocalStrategy() == LocalStrategy.NESTEDLOOP_BLOCKED_OUTER_SECOND) {
      try {
        innerInput=new SpillingResettableIterator<KeyValuePair<Key,Value>>(memoryManager,ioManager,innerReader,this.availableMemory / 2,new KeyValuePairDeserializer<Key,Value>(stub.getFirstInKeyType(),stub.getFirstInValueType()),this);
        this.spillingResetIt=innerInput;
      }
 catch (      MemoryAllocationException mae) {
        throw new RuntimeException(""String_Node_Str"",mae);
      }
      try {
        outerInput=new BlockResettableIterator<KeyValuePair<Key,Value>>(memoryManager,outerReader,this.availableMemory / 2,1,new KeyValuePairDeserializer<Key,Value>(stub.getSecondInKeyType(),stub.getSecondInValueType()),this);
        this.blockResetIt=outerInput;
      }
 catch (      MemoryAllocationException mae) {
        throw new RuntimeException(""String_Node_Str"",mae);
      }
      firstInputIsOuter=false;
    }
 else     if (this.config.getLocalStrategy() == LocalStrategy.NESTEDLOOP_BLOCKED_OUTER_FIRST) {
      try {
        innerInput=new SpillingResettableIterator<KeyValuePair<Key,Value>>(memoryManager,ioManager,innerReader,this.availableMemory / 2,new KeyValuePairDeserializer<Key,Value>(stub.getSecondInKeyType(),stub.getSecondInValueType()),this);
        this.spillingResetIt=innerInput;
      }
 catch (      MemoryAllocationException mae) {
        throw new RuntimeException(""String_Node_Str"",mae);
      }
      try {
        outerInput=new BlockResettableIterator<KeyValuePair<Key,Value>>(memoryManager,outerReader,this.availableMemory / 2,1,new KeyValuePairDeserializer<Key,Value>(stub.getFirstInKeyType(),stub.getFirstInValueType()),this);
        this.blockResetIt=outerInput;
      }
 catch (      MemoryAllocationException mae) {
        throw new RuntimeException(""String_Node_Str"",mae);
      }
      firstInputIsOuter=true;
    }
 else {
      throw new RuntimeException(""String_Node_Str"" + config.getLocalStrategy());
    }
    try {
      innerInput.open();
    }
 catch (    ServiceException se) {
      throw new RuntimeException(""String_Node_Str"",se);
    }
catch (    IOException ioe) {
      throw new RuntimeException(""String_Node_Str"",ioe);
    }
catch (    InterruptedException ie) {
      throw new RuntimeException(""String_Node_Str"",ie);
    }
    if (this.taskCanceled)     return;
    outerInput.open();
    if (LOG.isDebugEnabled()) {
      LOG.debug(getLogString(""String_Node_Str""));
      LOG.debug(getLogString(""String_Node_Str""));
    }
    this.stub.open();
    boolean moreOuterBlocks=false;
    if (innerInput.hasNext()) {
      do {
        while (!this.taskCanceled && innerInput.hasNext()) {
          KeyValuePair<Key,Value> innerPair=innerInput.next();
          while (!this.taskCanceled && outerInput.hasNext()) {
            KeyValuePair<Key,Value> outerPair=outerInput.next();
            if (firstInputIsOuter) {
              stub.cross(outerPair.getKey(),outerPair.getValue(),innerPair.getKey(),innerPair.getValue(),output);
            }
 else {
              stub.cross(innerPair.getKey(),innerPair.getValue(),outerPair.getKey(),outerPair.getValue(),output);
            }
            innerPair=innerInput.repeatLast();
          }
          outerInput.reset();
        }
        moreOuterBlocks=outerInput.nextBlock();
        if (moreOuterBlocks) {
          innerInput.reset();
        }
      }
 while (!this.taskCanceled && moreOuterBlocks);
    }
 else {
      LOG.debug(""String_Node_Str"");
      do {
        while (outerInput.hasNext()) {
          outerInput.next();
        }
      }
 while (outerInput.nextBlock());
    }
    this.stub.close();
  }
 catch (  Exception ex) {
    if (!this.taskCanceled) {
      LOG.error(getLogString(""String_Node_Str""));
      throw ex;
    }
  }
 finally {
    Throwable t1=null, t2=null;
    try {
      if (innerInput != null) {
        innerInput.close();
      }
    }
 catch (    Throwable t) {
      LOG.warn(t);
      t1=t;
    }
    try {
      if (outerInput != null) {
        outerInput.close();
      }
    }
 catch (    Throwable t) {
      LOG.warn(t);
      t2=t;
    }
    if (t1 != null)     throw new RuntimeException(""String_Node_Str"",t1);
    if (t2 != null)     throw new RuntimeException(""String_Node_Str"",t2);
  }
}"
88108,"/** 
 * Adds the necessary vertexes for sampling & histogram creation etc for range partitioning
 * @param connection
 * @param outputVertex
 * @param inputVertex
 * @throws JobGraphDefinitionException 
 */
private void connectWithSamplingPartitionRangeStrategy(PactConnection connection,AbstractJobVertex outputVertex,AbstractJobVertex inputVertex) throws JobGraphDefinitionException {
  TaskConfig inputConfig=new TaskConfig(inputVertex.getConfiguration());
  TaskConfig outputConfig=new TaskConfig(outputVertex.getConfiguration());
  int sourceDOP=connection.getSourcePact().getDegreeOfParallelism();
  int sourceIPM=connection.getSourcePact().getInstancesPerMachine();
  int targetDOP=connection.getTargetPact().getDegreeOfParallelism();
  int targetIPM=connection.getTargetPact().getInstancesPerMachine();
  Class<?> sourceStub=connection.getSourcePact().getPactContract().getUserCodeClass();
  if (targetDOP == 1) {
    if (sourceDOP == 1) {
      outputVertex.connectTo(inputVertex,ChannelType.INMEMORY,CompressionLevel.NO_COMPRESSION);
    }
 else {
      outputVertex.connectTo(inputVertex,ChannelType.NETWORK,CompressionLevel.NO_COMPRESSION);
    }
    outputConfig.addOutputShipStrategy(ShipStrategy.FORWARD);
    inputConfig.addInputShipStrategy(ShipStrategy.FORWARD);
    return;
  }
  JobTaskVertex sampleVertex=new JobTaskVertex(""String_Node_Str"",this.jobGraph);
  auxVertices.add(sampleVertex);
  sampleVertex.setTaskClass(SampleTask.class);
  TaskConfig sampleConfig=new TaskConfig(sampleVertex.getConfiguration());
  sampleVertex.setNumberOfSubtasks(sourceDOP);
  if (sourceIPM >= 1) {
    sampleVertex.setNumberOfSubtasksPerInstance(sourceIPM);
  }
  sampleConfig.setStubClass(sourceStub);
  outputVertex.connectTo(sampleVertex,ChannelType.INMEMORY,CompressionLevel.NO_COMPRESSION);
  outputConfig.addOutputShipStrategy(ShipStrategy.FORWARD);
  sampleConfig.addInputShipStrategy(ShipStrategy.FORWARD);
  JobTaskVertex histogramVertex=new JobTaskVertex(""String_Node_Str"",this.jobGraph);
  auxVertices.add(histogramVertex);
  histogramVertex.setTaskClass(HistogramTask.class);
  histogramVertex.setNumberOfSubtasks(1);
  TaskConfig histogramConfig=new TaskConfig(histogramVertex.getConfiguration());
  histogramConfig.setStubClass(sourceStub);
  histogramConfig.setLocalStrategy(LocalStrategy.SORT);
  Configuration histogramStubConfig=new Configuration();
  histogramStubConfig.setInteger(HistogramTask.NUMBER_OF_BUCKETS,targetDOP);
  histogramConfig.setStubParameters(histogramStubConfig);
  assignMemory(histogramConfig,outputConfig.getStubParameters().getInteger(HistogramTask.HISTOGRAM_MEMORY,-1));
  histogramConfig.addInputShipStrategy(ShipStrategy.FORWARD);
  sampleConfig.addOutputShipStrategy(ShipStrategy.FORWARD);
  sampleVertex.connectTo(histogramVertex,ChannelType.NETWORK,CompressionLevel.NO_COMPRESSION);
  JobTaskVertex partitionVertex=new JobTaskVertex(""String_Node_Str"",this.jobGraph);
  auxVertices.add(partitionVertex);
  partitionVertex.setTaskClass(PartitionTask.class);
  partitionVertex.setNumberOfSubtasks(sourceDOP);
  if (sourceIPM >= 1) {
    partitionVertex.setNumberOfSubtasksPerInstance(sourceIPM);
  }
  TaskConfig partitionConfig=new TaskConfig(partitionVertex.getConfiguration());
  partitionConfig.setStubClass(sourceStub);
  Configuration partitionStubConfig=new Configuration();
  partitionStubConfig.setString(PartitionTask.GLOBAL_PARTITIONING_ORDER,connection.getTargetPact().getGlobalProperties().getKeyOrder().name());
  partitionConfig.setStubParameters(partitionStubConfig);
  JobTaskVertex tempVertex=generateTempVertex(connection.getSourcePact().getPactContract().getUserCodeClass(),sourceDOP);
  tempVertex.setVertexToShareInstancesWith(outputVertex);
  TaskConfig tempConfig=new TaskConfig(tempVertex.getConfiguration());
  outputVertex.connectTo(tempVertex,ChannelType.INMEMORY,CompressionLevel.NO_COMPRESSION);
  tempConfig.addInputShipStrategy(ShipStrategy.FORWARD);
  outputConfig.addOutputShipStrategy(ShipStrategy.FORWARD);
  tempVertex.connectTo(partitionVertex,ChannelType.INMEMORY,CompressionLevel.NO_COMPRESSION);
  partitionConfig.addInputShipStrategy(ShipStrategy.FORWARD);
  tempConfig.addOutputShipStrategy(ShipStrategy.FORWARD);
  histogramVertex.connectTo(partitionVertex,ChannelType.NETWORK,CompressionLevel.NO_COMPRESSION);
  partitionConfig.addInputShipStrategy(ShipStrategy.BROADCAST);
  histogramConfig.addOutputShipStrategy(ShipStrategy.BROADCAST);
  partitionVertex.connectTo(inputVertex,ChannelType.NETWORK,CompressionLevel.NO_COMPRESSION);
  inputConfig.addInputShipStrategy(ShipStrategy.PARTITION_RANGE);
  partitionConfig.addOutputShipStrategy(ShipStrategy.PARTITION_RANGE);
}","/** 
 * Adds the necessary vertexes for sampling & histogram creation etc for range partitioning
 * @param connection
 * @param outputVertex
 * @param inputVertex
 * @throws JobGraphDefinitionException 
 */
private void connectWithSamplingPartitionRangeStrategy(PactConnection connection,AbstractJobVertex outputVertex,AbstractJobVertex inputVertex) throws JobGraphDefinitionException {
  TaskConfig inputConfig=new TaskConfig(inputVertex.getConfiguration());
  TaskConfig outputConfig=new TaskConfig(outputVertex.getConfiguration());
  int sourceDOP=connection.getSourcePact().getDegreeOfParallelism();
  int sourceIPM=connection.getSourcePact().getInstancesPerMachine();
  int targetDOP=connection.getTargetPact().getDegreeOfParallelism();
  int targetIPM=connection.getTargetPact().getInstancesPerMachine();
  Class<?> sourceStub=connection.getSourcePact().getPactContract().getUserCodeClass();
  if (targetDOP == 1) {
    if (sourceDOP == 1) {
      outputVertex.connectTo(inputVertex,ChannelType.INMEMORY,CompressionLevel.NO_COMPRESSION);
    }
 else {
      outputVertex.connectTo(inputVertex,ChannelType.NETWORK,CompressionLevel.NO_COMPRESSION);
    }
    outputConfig.addOutputShipStrategy(ShipStrategy.FORWARD);
    inputConfig.addInputShipStrategy(ShipStrategy.FORWARD);
    return;
  }
  JobTaskVertex sampleVertex=new JobTaskVertex(""String_Node_Str"",this.jobGraph);
  auxVertices.add(sampleVertex);
  sampleVertex.setTaskClass(SampleTask.class);
  TaskConfig sampleConfig=new TaskConfig(sampleVertex.getConfiguration());
  sampleVertex.setNumberOfSubtasks(sourceDOP);
  if (sourceIPM >= 1) {
    sampleVertex.setNumberOfSubtasksPerInstance(sourceIPM);
  }
  sampleConfig.setStubClass(sourceStub);
  outputVertex.connectTo(sampleVertex,ChannelType.INMEMORY,CompressionLevel.NO_COMPRESSION);
  outputConfig.addOutputShipStrategy(ShipStrategy.FORWARD);
  sampleConfig.addInputShipStrategy(ShipStrategy.FORWARD);
  JobTaskVertex histogramVertex=new JobTaskVertex(""String_Node_Str"",this.jobGraph);
  auxVertices.add(histogramVertex);
  histogramVertex.setTaskClass(HistogramTask.class);
  histogramVertex.setNumberOfSubtasks(1);
  TaskConfig histogramConfig=new TaskConfig(histogramVertex.getConfiguration());
  histogramConfig.setStubClass(sourceStub);
  histogramConfig.setLocalStrategy(LocalStrategy.SORT);
  Configuration histogramStubConfig=new Configuration();
  histogramStubConfig.setInteger(HistogramTask.NUMBER_OF_BUCKETS,targetDOP);
  histogramConfig.setStubParameters(histogramStubConfig);
  assignMemory(histogramConfig,outputConfig.getStubParameters().getInteger(HistogramTask.HISTOGRAM_MEMORY,-1));
  histogramConfig.addInputShipStrategy(ShipStrategy.FORWARD);
  sampleConfig.addOutputShipStrategy(ShipStrategy.FORWARD);
  sampleVertex.connectTo(histogramVertex,ChannelType.NETWORK,CompressionLevel.NO_COMPRESSION);
  JobTaskVertex partitionVertex=new JobTaskVertex(""String_Node_Str"",this.jobGraph);
  auxVertices.add(partitionVertex);
  partitionVertex.setTaskClass(PartitionTask.class);
  partitionVertex.setNumberOfSubtasks(sourceDOP);
  if (sourceIPM >= 1) {
    partitionVertex.setNumberOfSubtasksPerInstance(sourceIPM);
  }
  TaskConfig partitionConfig=new TaskConfig(partitionVertex.getConfiguration());
  partitionConfig.setStubClass(sourceStub);
  Configuration partitionStubConfig=new Configuration();
  partitionStubConfig.setString(PartitionTask.GLOBAL_PARTITIONING_ORDER,connection.getTargetPact().getGlobalProperties().getKeyOrder().name());
  partitionConfig.setStubParameters(partitionStubConfig);
  JobTaskVertex tempVertex=generateTempVertex(connection.getSourcePact().getPactContract().getUserCodeClass(),sourceDOP,sourceIPM);
  tempVertex.setVertexToShareInstancesWith(outputVertex);
  TaskConfig tempConfig=new TaskConfig(tempVertex.getConfiguration());
  outputVertex.connectTo(tempVertex,ChannelType.INMEMORY,CompressionLevel.NO_COMPRESSION);
  tempConfig.addInputShipStrategy(ShipStrategy.FORWARD);
  outputConfig.addOutputShipStrategy(ShipStrategy.FORWARD);
  tempVertex.connectTo(partitionVertex,ChannelType.INMEMORY,CompressionLevel.NO_COMPRESSION);
  partitionConfig.addInputShipStrategy(ShipStrategy.FORWARD);
  tempConfig.addOutputShipStrategy(ShipStrategy.FORWARD);
  histogramVertex.connectTo(partitionVertex,ChannelType.NETWORK,CompressionLevel.NO_COMPRESSION);
  partitionConfig.addInputShipStrategy(ShipStrategy.BROADCAST);
  histogramConfig.addOutputShipStrategy(ShipStrategy.BROADCAST);
  partitionVertex.connectTo(inputVertex,ChannelType.NETWORK,CompressionLevel.NO_COMPRESSION);
  inputConfig.addInputShipStrategy(ShipStrategy.PARTITION_RANGE);
  partitionConfig.addOutputShipStrategy(ShipStrategy.PARTITION_RANGE);
}"
88109,"/** 
 * @param connection
 * @param outputVertex
 * @param inputVertex
 * @throws JobGraphDefinitionException
 * @throws CompilerException
 */
private void connectJobVertices(PactConnection connection,AbstractJobVertex outputVertex,AbstractJobVertex inputVertex) throws JobGraphDefinitionException, CompilerException {
  ChannelType channelType=null;
switch (connection.getShipStrategy()) {
case FORWARD:
case PARTITION_LOCAL_HASH:
    int sourceDOP=connection.getSourcePact().getDegreeOfParallelism();
  int sourceInnerDOP=connection.getSourcePact().getInstancesPerMachine();
int sourceNumInstances=(int)Math.ceil((double)sourceDOP / (double)sourceInnerDOP);
int targetDOP=connection.getTargetPact().getDegreeOfParallelism();
int targetInnerDOP=connection.getTargetPact().getInstancesPerMachine();
int targetNumInstances=(int)Math.ceil((double)targetDOP / (double)targetInnerDOP);
channelType=sourceNumInstances == targetNumInstances ? ChannelType.INMEMORY : ChannelType.NETWORK;
break;
case PARTITION_HASH:
case BROADCAST:
case SFR:
channelType=ChannelType.NETWORK;
break;
default :
throw new IllegalArgumentException(""String_Node_Str"" + connection.getShipStrategy().name());
}
TaskConfig outputConfig=new TaskConfig(outputVertex.getConfiguration());
TaskConfig inputConfig=new TaskConfig(inputVertex.getConfiguration());
TaskConfig tempConfig=null;
switch (connection.getTempMode()) {
case NONE:
outputVertex.connectTo(inputVertex,channelType,CompressionLevel.NO_COMPRESSION);
outputConfig.addOutputShipStrategy(connection.getShipStrategy());
inputConfig.addInputShipStrategy(connection.getShipStrategy());
break;
case TEMP_SENDER_SIDE:
int pd=connection.getSourcePact().getDegreeOfParallelism();
JobTaskVertex tempVertex=generateTempVertex(connection.getSourcePact().getPactContract().getUserCodeClass(),pd);
outputVertex.connectTo(tempVertex,ChannelType.INMEMORY,CompressionLevel.NO_COMPRESSION);
tempVertex.connectTo(inputVertex,channelType,CompressionLevel.NO_COMPRESSION);
tempVertex.setVertexToShareInstancesWith(outputVertex);
tempConfig=new TaskConfig(tempVertex.getConfiguration());
outputConfig.addOutputShipStrategy(ShipStrategy.FORWARD);
tempConfig.addInputShipStrategy(ShipStrategy.FORWARD);
tempConfig.addOutputShipStrategy(connection.getShipStrategy());
inputConfig.addInputShipStrategy(connection.getShipStrategy());
break;
case TEMP_RECEIVER_SIDE:
int pdr=connection.getTargetPact().getDegreeOfParallelism();
tempVertex=generateTempVertex(connection.getSourcePact().getPactContract().getUserCodeClass(),pdr);
outputVertex.connectTo(tempVertex,channelType,CompressionLevel.NO_COMPRESSION);
tempVertex.connectTo(inputVertex,ChannelType.INMEMORY,CompressionLevel.NO_COMPRESSION);
tempVertex.setVertexToShareInstancesWith(inputVertex);
tempConfig=new TaskConfig(tempVertex.getConfiguration());
outputConfig.addOutputShipStrategy(connection.getShipStrategy());
tempConfig.addInputShipStrategy(connection.getShipStrategy());
tempConfig.addOutputShipStrategy(ShipStrategy.FORWARD);
inputConfig.addInputShipStrategy(ShipStrategy.FORWARD);
break;
default :
throw new CompilerException(""String_Node_Str"" + connection.getTempMode());
}
}","/** 
 * @param connection
 * @param outputVertex
 * @param inputVertex
 * @throws JobGraphDefinitionException
 * @throws CompilerException
 */
private void connectJobVertices(PactConnection connection,AbstractJobVertex outputVertex,AbstractJobVertex inputVertex) throws JobGraphDefinitionException, CompilerException {
  ChannelType channelType=null;
switch (connection.getShipStrategy()) {
case FORWARD:
case PARTITION_LOCAL_HASH:
    int sourceDOP=connection.getSourcePact().getDegreeOfParallelism();
  int sourceInnerDOP=connection.getSourcePact().getInstancesPerMachine();
int sourceNumInstances=(int)Math.ceil((double)sourceDOP / (double)sourceInnerDOP);
int targetDOP=connection.getTargetPact().getDegreeOfParallelism();
int targetInnerDOP=connection.getTargetPact().getInstancesPerMachine();
int targetNumInstances=(int)Math.ceil((double)targetDOP / (double)targetInnerDOP);
channelType=sourceNumInstances == targetNumInstances ? ChannelType.INMEMORY : ChannelType.NETWORK;
break;
case PARTITION_HASH:
case BROADCAST:
case SFR:
channelType=ChannelType.NETWORK;
break;
default :
throw new IllegalArgumentException(""String_Node_Str"" + connection.getShipStrategy().name());
}
TaskConfig outputConfig=new TaskConfig(outputVertex.getConfiguration());
TaskConfig inputConfig=new TaskConfig(inputVertex.getConfiguration());
TaskConfig tempConfig=null;
switch (connection.getTempMode()) {
case NONE:
outputVertex.connectTo(inputVertex,channelType,CompressionLevel.NO_COMPRESSION);
outputConfig.addOutputShipStrategy(connection.getShipStrategy());
inputConfig.addInputShipStrategy(connection.getShipStrategy());
break;
case TEMP_SENDER_SIDE:
int degreeOfParallelism=connection.getSourcePact().getDegreeOfParallelism();
int instancesPerMachine=connection.getSourcePact().getInstancesPerMachine();
JobTaskVertex tempVertex=generateTempVertex(connection.getSourcePact().getPactContract().getUserCodeClass(),degreeOfParallelism,instancesPerMachine);
outputVertex.connectTo(tempVertex,ChannelType.INMEMORY,CompressionLevel.NO_COMPRESSION);
tempVertex.connectTo(inputVertex,channelType,CompressionLevel.NO_COMPRESSION);
tempVertex.setVertexToShareInstancesWith(outputVertex);
tempConfig=new TaskConfig(tempVertex.getConfiguration());
outputConfig.addOutputShipStrategy(ShipStrategy.FORWARD);
tempConfig.addInputShipStrategy(ShipStrategy.FORWARD);
tempConfig.addOutputShipStrategy(connection.getShipStrategy());
inputConfig.addInputShipStrategy(connection.getShipStrategy());
break;
case TEMP_RECEIVER_SIDE:
degreeOfParallelism=connection.getTargetPact().getDegreeOfParallelism();
instancesPerMachine=connection.getTargetPact().getInstancesPerMachine();
tempVertex=generateTempVertex(connection.getSourcePact().getPactContract().getUserCodeClass(),degreeOfParallelism,instancesPerMachine);
outputVertex.connectTo(tempVertex,channelType,CompressionLevel.NO_COMPRESSION);
tempVertex.connectTo(inputVertex,ChannelType.INMEMORY,CompressionLevel.NO_COMPRESSION);
tempVertex.setVertexToShareInstancesWith(inputVertex);
tempConfig=new TaskConfig(tempVertex.getConfiguration());
outputConfig.addOutputShipStrategy(connection.getShipStrategy());
tempConfig.addInputShipStrategy(connection.getShipStrategy());
tempConfig.addOutputShipStrategy(ShipStrategy.FORWARD);
inputConfig.addInputShipStrategy(ShipStrategy.FORWARD);
break;
default :
throw new CompilerException(""String_Node_Str"" + connection.getTempMode());
}
}"
88110,"/** 
 * @param stubClass
 * @param dop
 * @return
 */
private JobTaskVertex generateTempVertex(Class<?> stubClass,int dop){
  JobTaskVertex tempVertex=new JobTaskVertex(""String_Node_Str"",this.jobGraph);
  tempVertex.setTaskClass(TempTask.class);
  TaskConfig tempConfig=new TaskConfig(tempVertex.getConfiguration());
  tempConfig.setStubClass(stubClass);
  assignMemory(tempConfig,PactCompiler.DEFAULT_TEMP_TASK_MEMORY);
  tempVertex.setNumberOfSubtasks(dop);
  return tempVertex;
}","/** 
 * @param stubClass
 * @param dop
 * @return
 */
private JobTaskVertex generateTempVertex(Class<?> stubClass,int dop,int instancesPerMachine){
  JobTaskVertex tempVertex=new JobTaskVertex(""String_Node_Str"",this.jobGraph);
  tempVertex.setTaskClass(TempTask.class);
  TaskConfig tempConfig=new TaskConfig(tempVertex.getConfiguration());
  tempConfig.setStubClass(stubClass);
  assignMemory(tempConfig,PactCompiler.DEFAULT_TEMP_TASK_MEMORY);
  tempVertex.setNumberOfSubtasks(dop);
  tempVertex.setNumberOfSubtasksPerInstance(instancesPerMachine);
  return tempVertex;
}"
88111,"/** 
 * Unregisters the given job represented by its   {@link ExecutionGraph} with the input split manager.
 * @param executionGraph the job to be unregistered
 */
public void unregisterJob(final ExecutionGraph executionGraph){
  final Iterator<ExecutionGroupVertex> it=new ExecutionGroupVertexIterator(executionGraph,true,-1);
  while (it.hasNext()) {
    final ExecutionGroupVertex groupVertex=it.next();
    final InputSplitAssigner assigner=this.assignerCache.remove(groupVertex);
    if (assigner == null) {
      LOG.error(""String_Node_Str"" + groupVertex.getName() + ""String_Node_Str"");
      continue;
    }
    assigner.unregisterGroupVertex(groupVertex);
  }
}","/** 
 * Unregisters the given job represented by its   {@link ExecutionGraph} with the input split manager.
 * @param executionGraph the job to be unregistered
 */
public void unregisterJob(final ExecutionGraph executionGraph){
  final Iterator<ExecutionGroupVertex> it=new ExecutionGroupVertexIterator(executionGraph,true,-1);
  while (it.hasNext()) {
    final ExecutionGroupVertex groupVertex=it.next();
    final InputSplit[] inputSplits=groupVertex.getInputSplits();
    if (inputSplits == null) {
      continue;
    }
    if (inputSplits.length == 0) {
      continue;
    }
    final InputSplitAssigner assigner=this.assignerCache.remove(groupVertex);
    if (assigner == null) {
      LOG.error(""String_Node_Str"" + groupVertex.getName() + ""String_Node_Str"");
      continue;
    }
    assigner.unregisterGroupVertex(groupVertex);
  }
}"
88112,"/** 
 * {@inheritDoc}
 */
@Override public void close() throws IOException, InterruptedException {
  this.deserializationBuffer.clear();
  if (this.uncompressedDataBuffer != null) {
    releasedConsumedReadBuffer();
  }
synchronized (this.synchronisationObject) {
    if (!this.brokerAggreedToCloseChannel) {
      while (!this.brokerAggreedToCloseChannel) {
        requestReadBuffersFromBroker();
        if (this.uncompressedDataBuffer != null || this.compressedDataBuffer != null) {
          releasedConsumedReadBuffer();
        }
        this.synchronisationObject.wait(500);
      }
      this.bufferedRecord=null;
    }
  }
  if (getType() == ChannelType.NETWORK) {
    transferEvent(new ByteBufferedChannelCloseEvent());
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void close() throws IOException, InterruptedException {
  this.deserializationBuffer.clear();
  if (this.uncompressedDataBuffer != null) {
    releasedConsumedReadBuffer();
  }
  if (this.getType() == ChannelType.NETWORK) {
synchronized (this.synchronisationObject) {
      if (!this.brokerAggreedToCloseChannel) {
        while (!this.brokerAggreedToCloseChannel) {
          requestReadBuffersFromBroker();
          if (this.uncompressedDataBuffer != null || this.compressedDataBuffer != null) {
            releasedConsumedReadBuffer();
          }
          this.synchronisationObject.wait(500);
        }
        this.bufferedRecord=null;
      }
    }
  }
  if (getType() == ChannelType.NETWORK) {
    transferEvent(new ByteBufferedChannelCloseEvent());
  }
}"
88113,"/** 
 * {@inheritDoc}
 */
@Override public void close() throws IOException, InterruptedException {
  this.deserializationBuffer.clear();
  if (this.uncompressedDataBuffer != null) {
    releasedConsumedReadBuffer();
  }
  if (getType() == ChannelType.NETWORK) {
    transferEvent(new ByteBufferedChannelCloseEvent());
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void close() throws IOException, InterruptedException {
  this.deserializationBuffer.clear();
  if (this.uncompressedDataBuffer != null) {
    releasedConsumedReadBuffer();
  }
synchronized (this.synchronisationObject) {
    if (!this.brokerAggreedToCloseChannel) {
      while (!this.brokerAggreedToCloseChannel) {
        requestReadBuffersFromBroker();
        if (this.uncompressedDataBuffer != null || this.compressedDataBuffer != null) {
          releasedConsumedReadBuffer();
        }
        this.synchronisationObject.wait(500);
      }
      this.bufferedRecord=null;
    }
  }
  if (getType() == ChannelType.NETWORK) {
    transferEvent(new ByteBufferedChannelCloseEvent());
  }
}"
88114,"@Override public void copyToBuffer(final Buffer destinationBuffer) throws IOException {
  if (destinationBuffer.isBackedByMemory()) {
    final long tbr=this.totalBytesRead;
    if (this.fileChannel != null) {
      this.fileBufferManager.releaseFileChannelForReading(this.gateID,this.fileID);
    }
    this.totalBytesRead=0;
    destinationBuffer.write(this);
    destinationBuffer.finishWritePhase();
    if (this.fileChannel != null) {
      this.fileBufferManager.releaseFileChannelForReading(this.gateID,this.fileID);
    }
    this.fileChannel=null;
    this.totalBytesRead=tbr;
    return;
  }
  throw new UnsupportedOperationException(""String_Node_Str"");
}","@Override public void copyToBuffer(final Buffer destinationBuffer) throws IOException {
  if (destinationBuffer.isBackedByMemory()) {
    final long tbr=this.totalBytesRead;
    if (this.fileChannel != null) {
      this.fileBufferManager.releaseFileChannelForReading(this.gateID,this.fileID);
    }
    this.totalBytesRead=0;
    while (remaining() > 0) {
      destinationBuffer.write(this);
    }
    destinationBuffer.finishWritePhase();
    if (this.fileChannel != null) {
      this.fileBufferManager.releaseFileChannelForReading(this.gateID,this.fileID);
    }
    this.fileChannel=null;
    this.totalBytesRead=tbr;
    return;
  }
  throw new UnsupportedOperationException(""String_Node_Str"");
}"
88115,"@Override public void copyToBuffer(Buffer destinationBuffer) throws IOException {
  final int oldPos=this.byteBuffer.position();
  while (remaining() > 0) {
    destinationBuffer.write(this);
  }
  this.byteBuffer.position(oldPos);
  if (!this.writeMode) {
    destinationBuffer.finishWritePhase();
  }
}","@Override public void copyToBuffer(Buffer destinationBuffer) throws IOException {
  final int oldPos=this.byteBuffer.position();
  this.byteBuffer.position(0);
  while (remaining() > 0) {
    destinationBuffer.write(this);
  }
  this.byteBuffer.position(oldPos);
  destinationBuffer.finishWritePhase();
}"
88116,"@Override public InternalBuffer duplicate() throws IOException, InterruptedException {
  this.fileBufferManager.increaseFileCounter(this.gateID,this.fileID);
  final FileBuffer dup=new FileBuffer((int)this.bufferSize,this.gateID,this.fileBufferManager);
  dup.writeMode=this.writeMode;
  dup.fileID=this.fileID;
  dup.offset=this.offset;
  return dup;
}","@Override public InternalBuffer duplicate() throws IOException, InterruptedException {
  this.fileBufferManager.increaseBufferCounter(this.gateID,this.fileID);
  final FileBuffer dup=new FileBuffer((int)this.bufferSize,this.gateID,this.fileBufferManager);
  dup.writeMode=this.writeMode;
  dup.fileID=this.fileID;
  dup.offset=this.offset;
  return dup;
}"
88117,"@Override public void recycleBuffer(){
  this.fileBufferManager.releaseFileChannelForReading(this.gateID,this.fileID,true);
}","@Override public void recycleBuffer(){
  try {
    if (this.fileChannel != null) {
      this.fileBufferManager.releaseFileChannelForReading(this.gateID,this.fileID);
      this.fileChannel=null;
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  this.fileBufferManager.decreaseBufferCounter(this.gateID,this.fileID);
}"
88118,"@Override public void copyToBuffer(final Buffer destinationBuffer) throws IOException {
  if (destinationBuffer.isBackedByMemory()) {
    final long tbr=this.totalBytesRead;
    if (this.fileChannel != null) {
      this.fileBufferManager.releaseFileChannelForReading(this.gateID,this.fileID,false);
    }
    this.totalBytesRead=0;
    destinationBuffer.write(this);
    destinationBuffer.finishWritePhase();
    this.fileBufferManager.releaseFileChannelForReading(this.gateID,this.fileID,false);
    this.fileChannel=null;
    this.totalBytesRead=tbr;
    return;
  }
  throw new UnsupportedOperationException(""String_Node_Str"");
}","@Override public void copyToBuffer(final Buffer destinationBuffer) throws IOException {
  if (destinationBuffer.isBackedByMemory()) {
    final long tbr=this.totalBytesRead;
    if (this.fileChannel != null) {
      this.fileBufferManager.releaseFileChannelForReading(this.gateID,this.fileID);
    }
    this.totalBytesRead=0;
    destinationBuffer.write(this);
    destinationBuffer.finishWritePhase();
    if (this.fileChannel != null) {
      this.fileBufferManager.releaseFileChannelForReading(this.gateID,this.fileID);
    }
    this.fileChannel=null;
    this.totalBytesRead=tbr;
    return;
  }
  throw new UnsupportedOperationException(""String_Node_Str"");
}"
88119,"@Override public int read(ByteBuffer dst) throws IOException {
  if (this.writeMode) {
    throw new IOException(""String_Node_Str"");
  }
  if (this.fileChannel == null) {
    try {
      this.fileChannel=this.fileBufferManager.getFileChannelForReading(this.gateID,this.fileID);
    }
 catch (    InterruptedException e) {
      return -1;
    }
    if (this.fileChannel.position() != this.offset) {
      this.fileChannel.position(this.offset);
    }
  }
  if (this.totalBytesRead >= this.bufferSize) {
    return -1;
  }
  final int rem=remaining();
  int bytesRead;
  if (dst.remaining() > rem) {
    final int excess=dst.remaining() - rem;
    dst.limit(dst.limit() - excess);
    bytesRead=this.fileChannel.read(dst);
    dst.limit(dst.limit() + excess);
  }
 else {
    bytesRead=this.fileChannel.read(dst);
  }
  if (bytesRead < 0) {
    return -1;
  }
  this.totalBytesRead+=bytesRead;
  return bytesRead;
}","@Override public int read(ByteBuffer dst) throws IOException {
  if (this.writeMode) {
    throw new IOException(""String_Node_Str"");
  }
  if (this.fileChannel == null) {
    try {
      this.fileChannel=this.fileBufferManager.getFileChannelForReading(this.gateID,this.fileID);
    }
 catch (    InterruptedException e) {
      return -1;
    }
    if (this.fileChannel.position() != (this.offset + this.totalBytesRead)) {
      this.fileChannel.position(this.offset + this.totalBytesRead);
    }
  }
  if (this.totalBytesRead >= this.bufferSize) {
    return -1;
  }
  final int rem=remaining();
  int bytesRead;
  if (dst.remaining() > rem) {
    final int excess=dst.remaining() - rem;
    dst.limit(dst.limit() - excess);
    bytesRead=this.fileChannel.read(dst);
    dst.limit(dst.limit() + excess);
  }
 else {
    bytesRead=this.fileChannel.read(dst);
  }
  if (bytesRead < 0) {
    return -1;
  }
  this.totalBytesRead+=bytesRead;
  return bytesRead;
}"
88120,"@Override public void finishWritePhase() throws IOException {
  if (this.writeMode) {
    final long currentFileSize=this.offset + this.totalBytesWritten;
    this.fileChannel=null;
    this.bufferSize=this.totalBytesWritten;
    this.writeMode=false;
    this.fileID=this.fileBufferManager.reportEndOfWritePhase(this.gateID,currentFileSize);
  }
}","@Override public void finishWritePhase() throws IOException {
  if (this.writeMode) {
    final long currentFileSize=this.offset + this.totalBytesWritten;
    if (this.fileChannel != null) {
      this.fileChannel.position(currentFileSize);
    }
    this.fileChannel=null;
    this.bufferSize=this.totalBytesWritten;
    this.writeMode=false;
    this.fileID=this.fileBufferManager.reportEndOfWritePhase(this.gateID,currentFileSize);
  }
}"
88121,"@Override public void recycleBuffer(){
  this.fileBufferManager.reportFileBufferAsConsumed(this.gateID,this.fileID);
}","@Override public void recycleBuffer(){
  this.fileBufferManager.releaseFileChannelForReading(this.gateID,this.fileID,true);
}"
88122,"@Override public void copyToBuffer(final Buffer destinationBuffer) throws IOException {
  if (destinationBuffer.isBackedByMemory()) {
    destinationBuffer.write(this);
    destinationBuffer.finishWritePhase();
    return;
  }
  throw new UnsupportedOperationException(""String_Node_Str"");
}","@Override public void copyToBuffer(final Buffer destinationBuffer) throws IOException {
  if (destinationBuffer.isBackedByMemory()) {
    final long tbr=this.totalBytesRead;
    if (this.fileChannel != null) {
      this.fileBufferManager.releaseFileChannelForReading(this.gateID,this.fileID,false);
    }
    this.totalBytesRead=0;
    destinationBuffer.write(this);
    destinationBuffer.finishWritePhase();
    this.fileBufferManager.releaseFileChannelForReading(this.gateID,this.fileID,false);
    this.fileChannel=null;
    this.totalBytesRead=tbr;
    return;
  }
  throw new UnsupportedOperationException(""String_Node_Str"");
}"
88123,"/** 
 * Returns the lock for a file channel of a   {@link WritableSpillingFile}.
 * @param gateID the ID of the gate the lock has been acquired for
 * @param currentFileSize the size of the file after the last write operation using the locked file channel
 * @throws IOException thrown if the lock could not be released
 */
public FileID reportEndOfWritePhase(final GateID gateID,final long currentFileSize) throws IOException {
  WritableSpillingFile writableSpillingFile=null;
  boolean removed=false;
synchronized (this.writableSpillingFileMap) {
    writableSpillingFile=this.writableSpillingFileMap.get(gateID);
    if (writableSpillingFile == null) {
      throw new IOException(""String_Node_Str"" + gateID);
    }
    writableSpillingFile.unlockWritableFileChannel(currentFileSize);
    if (writableSpillingFile.isReadRequested() && writableSpillingFile.isSafeToClose()) {
      this.writableSpillingFileMap.remove(gateID);
      removed=true;
    }
  }
  if (removed) {
    writableSpillingFile.close();
    Map<FileID,ReadableSpillingFile> map=null;
synchronized (this.readableSpillingFileMap) {
      map=this.readableSpillingFileMap.get(gateID);
      if (map == null) {
        map=new HashMap<FileID,ReadableSpillingFile>();
        this.readableSpillingFileMap.put(gateID,map);
      }
    }
synchronized (map) {
      map.put(writableSpillingFile.getFileID(),new ReadableSpillingFile(writableSpillingFile.getPhysicalFile()));
      map.notify();
    }
  }
  return writableSpillingFile.getFileID();
}","/** 
 * Returns the lock for a file channel of a   {@link WritableSpillingFile}.
 * @param gateID the ID of the gate the lock has been acquired for
 * @param currentFileSize the size of the file after the last write operation using the locked file channel
 * @throws IOException thrown if the lock could not be released
 */
public FileID reportEndOfWritePhase(final GateID gateID,final long currentFileSize) throws IOException {
  WritableSpillingFile writableSpillingFile=null;
  boolean removed=false;
synchronized (this.writableSpillingFileMap) {
    writableSpillingFile=this.writableSpillingFileMap.get(gateID);
    if (writableSpillingFile == null) {
      throw new IOException(""String_Node_Str"" + gateID);
    }
    writableSpillingFile.unlockWritableFileChannel(currentFileSize);
    if (writableSpillingFile.isReadRequested() && writableSpillingFile.isSafeToClose()) {
      this.writableSpillingFileMap.remove(gateID);
      removed=true;
    }
  }
  if (removed) {
    writableSpillingFile.close();
    Map<FileID,ReadableSpillingFile> map=null;
synchronized (this.readableSpillingFileMap) {
      map=this.readableSpillingFileMap.get(gateID);
      if (map == null) {
        map=new HashMap<FileID,ReadableSpillingFile>();
        this.readableSpillingFileMap.put(gateID,map);
      }
    }
synchronized (map) {
      map.put(writableSpillingFile.getFileID(),writableSpillingFile.toReadableSpillingFile());
      map.notify();
    }
  }
  return writableSpillingFile.getFileID();
}"
88124,"private ReadableSpillingFile getReadableSpillingFile(final GateID gateID,final FileID fileID) throws IOException, InterruptedException {
  if (gateID == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (fileID == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  Map<FileID,ReadableSpillingFile> map=null;
synchronized (this.readableSpillingFileMap) {
    map=this.readableSpillingFileMap.get(gateID);
    if (map == null) {
      map=new HashMap<FileID,ReadableSpillingFile>();
      this.readableSpillingFileMap.put(gateID,map);
    }
  }
synchronized (map) {
    while (!map.containsKey(fileID)) {
synchronized (this.writableSpillingFileMap) {
        WritableSpillingFile writableSpillingFile=this.writableSpillingFileMap.get(gateID);
        if (writableSpillingFile != null) {
          writableSpillingFile.requestReadAccess();
          if (writableSpillingFile.isSafeToClose()) {
            writableSpillingFile.close();
            this.writableSpillingFileMap.remove(gateID);
            map.put(writableSpillingFile.getFileID(),new ReadableSpillingFile(writableSpillingFile.getPhysicalFile()));
          }
        }
      }
      if (!map.containsKey(fileID)) {
        map.wait(WritableSpillingFile.MAXIMUM_TIME_WITHOUT_WRITE_ACCESS);
      }
    }
    return map.get(fileID);
  }
}","private ReadableSpillingFile getReadableSpillingFile(final GateID gateID,final FileID fileID) throws IOException, InterruptedException {
  if (gateID == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (fileID == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  Map<FileID,ReadableSpillingFile> map=null;
synchronized (this.readableSpillingFileMap) {
    map=this.readableSpillingFileMap.get(gateID);
    if (map == null) {
      map=new HashMap<FileID,ReadableSpillingFile>();
      this.readableSpillingFileMap.put(gateID,map);
    }
  }
synchronized (map) {
    while (!map.containsKey(fileID)) {
synchronized (this.writableSpillingFileMap) {
        WritableSpillingFile writableSpillingFile=this.writableSpillingFileMap.get(gateID);
        if (writableSpillingFile != null) {
          writableSpillingFile.requestReadAccess();
          if (writableSpillingFile.isSafeToClose()) {
            writableSpillingFile.close();
            this.writableSpillingFileMap.remove(gateID);
            map.put(writableSpillingFile.getFileID(),writableSpillingFile.toReadableSpillingFile());
          }
        }
      }
      if (!map.containsKey(fileID)) {
        map.wait(WritableSpillingFile.MAXIMUM_TIME_WITHOUT_WRITE_ACCESS);
      }
    }
    return map.get(fileID);
  }
}"
88125,"public void increaseFileCounter(final GateID gateID,final FileID fileID) throws IOException, InterruptedException {
  getReadableSpillingFile(gateID,fileID).increaseLeaseCounter();
}","public void increaseFileCounter(final GateID gateID,final FileID fileID) throws IOException, InterruptedException {
  getReadableSpillingFile(gateID,fileID).increaseNumberOfBuffers();
}"
88126,"public synchronized boolean checkForEndOfFile() throws IOException {
  --this.leaseCounter;
  if (this.leaseCounter == 0) {
    this.readableFileChannel.close();
    this.physicalFile.delete();
    return true;
  }
  return false;
}","public synchronized boolean checkForEndOfFile() throws IOException {
  --this.numberOfBuffers;
  if (this.numberOfBuffers == 0) {
    this.readableFileChannel.close();
    this.physicalFile.delete();
    return true;
  }
  return false;
}"
88127,"public ReadableSpillingFile(final File physicalFile) throws IOException {
  this.physicalFile=physicalFile;
  this.readableFileChannel=new FileInputStream(this.physicalFile).getChannel();
}","public ReadableSpillingFile(final File physicalFile,int numberOfBuffers) throws IOException {
  this.physicalFile=physicalFile;
  this.numberOfBuffers=numberOfBuffers;
  this.readableFileChannel=new FileInputStream(this.physicalFile).getChannel();
}"
88128,"/** 
 * Releases the lock on the spilling file's   {@link WritableByteChannel}.
 * @param currentFileSize the current size of the spilling file in bytes
 */
void unlockWritableFileChannel(final long currentFileSize){
  this.writableChannelLocked=false;
  this.currentFileSize=currentFileSize;
  this.lastUnlockTime=System.currentTimeMillis();
}","/** 
 * Releases the lock on the spilling file's   {@link WritableByteChannel}.
 * @param currentFileSize the current size of the spilling file in bytes
 */
void unlockWritableFileChannel(final long currentFileSize){
  this.writableChannelLocked=false;
  this.currentFileSize=currentFileSize;
  this.lastUnlockTime=System.currentTimeMillis();
  ++this.numberOfBuffers;
}"
88129,"/** 
 * Requests an empty buffer with a minimum size of <code>minimumSizeOfBuffer</code>. The method returns immediately, even if the request could not be fulfilled. Note that <code>minimumSizeOfBuffer</code> must not exceed the value returned by the method <code>getMaximumBufferSize()</code>.
 * @param minimumSizeOfBuffer the minimum size of the requested read buffer in bytes
 * @return the buffer with at least the requested size or <code>null</code> if no such buffer is currently available
 * @throws IOException thrown if an I/O error occurs while allocating the buffer
 */
Buffer requestEmptyBuffer(int minimumSizeOfBuffer) throws IOException ;","/** 
 * Requests an empty buffer with a minimum size of <code>minimumSizeOfBuffer</code>. The method returns immediately, even if the request could not be fulfilled. Note that <code>minimumSizeOfBuffer</code> must not exceed the value returned by the method <code>getMaximumBufferSize()</code>.
 * @param minimumSizeOfBuffer the minimum size of the requested read buffer in bytes
 * @param minimumReserve the minimum buffer reserve that must be kept by the buffer provider
 * @return the buffer with at least the requested size or <code>null</code> if no such buffer is currently available
 * @throws IOException thrown if an I/O error occurs while allocating the buffer
 */
Buffer requestEmptyBuffer(int minimumSizeOfBuffer,int minimumReserve) throws IOException ;"
88130,"/** 
 * Requests an empty buffer with a minimum size of <code>minimumSizeOfBuffer</code>. The method blocks until the request can be fulfilled. Note that <code>minimumSizeOfBuffer</code> must not exceed the value returned by the method <code>getMaximumBufferSize()</code>.
 * @param minimumSizeOfBuffer the minimum size of the requested read buffer in bytes
 * @return the buffer with at least the requested size
 * @throws IOException thrown if an I/O error occurs while allocating the buffer
 * @throws InterruptedException thrown if the thread waiting for the buffer is interrupted
 */
Buffer requestEmptyBufferBlocking(int minimumSizeOfBuffer) throws IOException, InterruptedException ;","/** 
 * Requests an empty buffer with a minimum size of <code>minimumSizeOfBuffer</code>. The method blocks until the request can be fulfilled. Note that <code>minimumSizeOfBuffer</code> must not exceed the value returned by the method <code>getMaximumBufferSize()</code>.
 * @param minimumSizeOfBuffer the minimum size of the requested read buffer in bytes
 * @param minimumReserve the minimum buffer reserve that must be kept by the buffer provider
 * @return the buffer with at least the requested size
 * @throws IOException thrown if an I/O error occurs while allocating the buffer
 * @throws InterruptedException thrown if the thread waiting for the buffer is interrupted
 */
Buffer requestEmptyBufferBlocking(int minimumSizeOfBuffer,int minimumReserve) throws IOException, InterruptedException ;"
88131,"/** 
 * Sets the designated number of buffers for this local buffer cache.
 * @param designatedNumberOfBuffers the designated number of buffers for this local buffer cache
 */
public void setDesignatedNumberOfBuffers(final int designatedNumberOfBuffers){
synchronized (this.buffers) {
    this.designatedNumberOfBuffers=designatedNumberOfBuffers;
    while (this.designatedNumberOfBuffers > this.requestedNumberOfBuffers) {
      if (this.buffers.isEmpty()) {
        break;
      }
      this.globalBufferPool.releaseGlobalBuffer(this.buffers.poll());
      this.requestedNumberOfBuffers--;
    }
    this.buffers.notify();
  }
}","/** 
 * Sets the designated number of buffers for this local buffer cache.
 * @param designatedNumberOfBuffers the designated number of buffers for this local buffer cache
 */
public void setDesignatedNumberOfBuffers(final int designatedNumberOfBuffers){
synchronized (this.buffers) {
    this.designatedNumberOfBuffers=designatedNumberOfBuffers;
    while (this.requestedNumberOfBuffers > this.designatedNumberOfBuffers) {
      if (this.buffers.isEmpty()) {
        break;
      }
      this.globalBufferPool.releaseGlobalBuffer(this.buffers.poll());
      this.requestedNumberOfBuffers--;
    }
    this.buffers.notify();
  }
}"
88132,"private Buffer requestBufferInternal(final int minimumSizeOfBuffer,final boolean block) throws InterruptedException {
  if (minimumSizeOfBuffer > this.maximumBufferSize) {
    throw new IllegalArgumentException(""String_Node_Str"" + minimumSizeOfBuffer + ""String_Node_Str""+ this.maximumBufferSize);
  }
synchronized (this.buffers) {
    if (this.requestedNumberOfBuffers > this.designatedNumberOfBuffers) {
      while (this.requestedNumberOfBuffers < this.designatedNumberOfBuffers) {
        final ByteBuffer buffer=this.buffers.poll();
        if (buffer == null) {
          break;
        }
        this.globalBufferPool.releaseGlobalBuffer(buffer);
        this.requestedNumberOfBuffers--;
      }
    }
    while (this.buffers.isEmpty()) {
      if (this.requestedNumberOfBuffers < this.designatedNumberOfBuffers) {
        final ByteBuffer buffer=this.globalBufferPool.lockGlobalBuffer();
        if (buffer != null) {
          this.buffers.add(buffer);
          this.requestedNumberOfBuffers++;
          continue;
        }
      }
      if (block) {
        this.buffers.wait();
      }
 else {
        return null;
      }
    }
    final ByteBuffer byteBuffer=this.buffers.poll();
    return BufferFactory.createFromMemory(minimumSizeOfBuffer,byteBuffer,this.buffers);
  }
}","private Buffer requestBufferInternal(final int minimumSizeOfBuffer,int minimumReserve,final boolean block) throws InterruptedException {
  if (minimumSizeOfBuffer > this.maximumBufferSize) {
    throw new IllegalArgumentException(""String_Node_Str"" + minimumSizeOfBuffer + ""String_Node_Str""+ this.maximumBufferSize);
  }
synchronized (this.buffers) {
    while (this.requestedNumberOfBuffers > this.designatedNumberOfBuffers) {
      final ByteBuffer buffer=this.buffers.poll();
      if (buffer == null) {
        break;
      }
      this.globalBufferPool.releaseGlobalBuffer(buffer);
      this.requestedNumberOfBuffers--;
    }
    if (minimumReserve > this.requestedNumberOfBuffers) {
      LOG.warn(""String_Node_Str"");
      minimumReserve=this.requestedNumberOfBuffers;
    }
    while (this.buffers.size() <= minimumReserve) {
      if (this.requestedNumberOfBuffers < this.designatedNumberOfBuffers) {
        final ByteBuffer buffer=this.globalBufferPool.lockGlobalBuffer();
        if (buffer != null) {
          this.buffers.add(buffer);
          this.requestedNumberOfBuffers++;
          continue;
        }
      }
      if (block) {
        this.buffers.wait();
      }
 else {
        return null;
      }
    }
    final ByteBuffer byteBuffer=this.buffers.poll();
    return BufferFactory.createFromMemory(minimumSizeOfBuffer,byteBuffer,this.buffers);
  }
}"
88133,"/** 
 * {@inheritDoc}
 */
@Override public Buffer requestEmptyBuffer(final int minimumSizeOfBuffer) throws IOException {
  try {
    return requestBufferInternal(minimumSizeOfBuffer,false);
  }
 catch (  InterruptedException e) {
    LOG.error(""String_Node_Str"");
  }
  return null;
}","/** 
 * {@inheritDoc}
 */
@Override public Buffer requestEmptyBuffer(final int minimumSizeOfBuffer,final int minimumReserve) throws IOException {
  try {
    return requestBufferInternal(minimumSizeOfBuffer,minimumReserve,false);
  }
 catch (  InterruptedException e) {
    LOG.error(""String_Node_Str"");
  }
  return null;
}"
88134,"/** 
 * {@inheritDoc}
 */
@Override public Buffer requestEmptyBufferBlocking(int minimumSizeOfBuffer) throws IOException, InterruptedException {
  return requestBufferInternal(minimumSizeOfBuffer,true);
}","/** 
 * {@inheritDoc}
 */
@Override public Buffer requestEmptyBufferBlocking(final int minimumSizeOfBuffer,final int minimumReserve) throws IOException, InterruptedException {
  return requestBufferInternal(minimumSizeOfBuffer,minimumReserve,true);
}"
88135,"private void processEnvelopeWithBuffer(final TransferEnvelope transferEnvelope,final TransferEnvelopeReceiverList receiverList,final boolean freeSourceBuffer) throws IOException, InterruptedException {
  if (!freeSourceBuffer) {
    final List<ChannelID> localReceivers=receiverList.getLocalReceivers();
    if (localReceivers.size() != 1) {
      throw new IOException(""String_Node_Str"");
    }
    final ChannelID localReceiver=localReceivers.get(0);
    final ChannelContext cc=this.registeredChannels.get(localReceiver);
    if (cc == null) {
      throw new IOException(""String_Node_Str"" + localReceiver);
    }
    if (!cc.isInputChannel()) {
      throw new IOException(""String_Node_Str"" + localReceiver + ""String_Node_Str"");
    }
    cc.queueTransferEnvelope(transferEnvelope);
    return;
  }
  final Buffer srcBuffer=transferEnvelope.getBuffer();
  if (receiverList.hasLocalReceivers()) {
    final List<ChannelID> localReceivers=receiverList.getLocalReceivers();
    for (    final ChannelID localReceiver : localReceivers) {
      final ChannelContext cc=this.registeredChannels.get(localReceiver);
      if (cc == null) {
        throw new IOException(""String_Node_Str"" + localReceiver);
      }
      if (!cc.isInputChannel()) {
        throw new IOException(""String_Node_Str"" + localReceiver + ""String_Node_Str"");
      }
      final InputChannelContext inputChannelContext=(InputChannelContext)cc;
      final Buffer destBuffer=inputChannelContext.requestEmptyBufferBlocking(srcBuffer.size());
      srcBuffer.copyToBuffer(destBuffer);
      final TransferEnvelope dup=transferEnvelope.duplicateWithoutBuffer();
      dup.setBuffer(destBuffer);
      inputChannelContext.queueTransferEnvelope(dup);
    }
  }
  if (receiverList.hasRemoteReceivers()) {
    final List<InetSocketAddress> remoteReceivers=receiverList.getRemoteReceivers();
    for (    final InetSocketAddress remoteReceiver : remoteReceivers) {
      this.networkConnectionManager.queueEnvelopeForTransfer(remoteReceiver,transferEnvelope.duplicate());
    }
  }
  srcBuffer.recycleBuffer();
}","private void processEnvelopeWithBuffer(final TransferEnvelope transferEnvelope,final TransferEnvelopeReceiverList receiverList,final boolean freeSourceBuffer) throws IOException, InterruptedException {
  if (!freeSourceBuffer) {
    final List<ChannelID> localReceivers=receiverList.getLocalReceivers();
    if (localReceivers.size() != 1) {
      throw new IOException(""String_Node_Str"");
    }
    final ChannelID localReceiver=localReceivers.get(0);
    final ChannelContext cc=this.registeredChannels.get(localReceiver);
    if (cc == null) {
      throw new IOException(""String_Node_Str"" + localReceiver);
    }
    if (!cc.isInputChannel()) {
      throw new IOException(""String_Node_Str"" + localReceiver + ""String_Node_Str"");
    }
    cc.queueTransferEnvelope(transferEnvelope);
    return;
  }
  final Buffer srcBuffer=transferEnvelope.getBuffer();
  if (receiverList.hasLocalReceivers()) {
    final List<ChannelID> localReceivers=receiverList.getLocalReceivers();
    for (    final ChannelID localReceiver : localReceivers) {
      final ChannelContext cc=this.registeredChannels.get(localReceiver);
      if (cc == null) {
        throw new IOException(""String_Node_Str"" + localReceiver);
      }
      if (!cc.isInputChannel()) {
        throw new IOException(""String_Node_Str"" + localReceiver + ""String_Node_Str"");
      }
      final InputChannelContext inputChannelContext=(InputChannelContext)cc;
      final Buffer destBuffer=inputChannelContext.requestEmptyBufferBlocking(srcBuffer.size(),1);
      srcBuffer.copyToBuffer(destBuffer);
      final TransferEnvelope dup=transferEnvelope.duplicateWithoutBuffer();
      dup.setBuffer(destBuffer);
      inputChannelContext.queueTransferEnvelope(dup);
    }
  }
  if (receiverList.hasRemoteReceivers()) {
    final List<InetSocketAddress> remoteReceivers=receiverList.getRemoteReceivers();
    for (    final InetSocketAddress remoteReceiver : remoteReceivers) {
      this.networkConnectionManager.queueEnvelopeForTransfer(remoteReceiver,transferEnvelope.duplicate());
    }
  }
  srcBuffer.recycleBuffer();
}"
88136,"@Override public Buffer requestEmptyBuffer(int minimumSizeOfBuffer) throws IOException {
  return this.inputGateContext.requestEmptyBuffer(minimumSizeOfBuffer);
}","@Override public Buffer requestEmptyBuffer(final int minimumSizeOfBuffer,final int minimumReserve) throws IOException {
  return this.inputGateContext.requestEmptyBuffer(minimumSizeOfBuffer,minimumReserve);
}"
88137,"@Override public Buffer requestEmptyBufferBlocking(int minimumSizeOfBuffer) throws IOException, InterruptedException {
  return this.inputGateContext.requestEmptyBufferBlocking(minimumSizeOfBuffer);
}","@Override public Buffer requestEmptyBufferBlocking(final int minimumSizeOfBuffer,final int minimumReserve) throws IOException, InterruptedException {
  return this.inputGateContext.requestEmptyBufferBlocking(minimumSizeOfBuffer,minimumReserve);
}"
88138,"/** 
 * {@inheritDoc}
 */
@Override public Buffer requestEmptyBuffer(final int minimumSizeOfBuffer) throws IOException {
  return this.taskContext.requestEmptyBuffer(minimumSizeOfBuffer);
}","/** 
 * {@inheritDoc}
 */
@Override public Buffer requestEmptyBuffer(final int minimumSizeOfBuffer,final int minimumReserve) throws IOException {
  return this.taskContext.requestEmptyBuffer(minimumSizeOfBuffer,minimumReserve);
}"
88139,"/** 
 * {@inheritDoc}
 */
@Override public Buffer requestEmptyBufferBlocking(final int minimumSizeOfBuffer) throws IOException, InterruptedException {
  return this.taskContext.requestEmptyBufferBlocking(minimumSizeOfBuffer);
}","/** 
 * {@inheritDoc}
 */
@Override public Buffer requestEmptyBufferBlocking(final int minimumSizeOfBuffer,final int minimumReserve) throws IOException, InterruptedException {
  return this.taskContext.requestEmptyBufferBlocking(minimumSizeOfBuffer,minimumReserve);
}"
88140,"/** 
 * {@inheritDoc}
 */
@Override public void releaseWriteBuffers() throws IOException, InterruptedException {
  if (this.outgoingTransferEnvelope == null) {
    LOG.error(""String_Node_Str"" + this.byteBufferedOutputChannel.getID());
    return;
  }
  if (this.outgoingTransferEnvelope.getBuffer() == null) {
    LOG.error(""String_Node_Str"" + this.byteBufferedOutputChannel.getID() + ""String_Node_Str"");
    return;
  }
  try {
    this.outgoingTransferEnvelope.getBuffer().finishWritePhase();
  }
 catch (  final IOException ioe) {
    this.byteBufferedOutputChannel.reportIOException(ioe);
  }
  if (!this.isReceiverRunning) {
    final Buffer memBuffer=this.outgoingTransferEnvelope.getBuffer();
    final Buffer fileBuffer=this.outputGateContext.getFileBuffer(memBuffer.size());
    memBuffer.copyToBuffer(fileBuffer);
    this.outgoingTransferEnvelope.setBuffer(fileBuffer);
    this.queuedOutgoingEnvelopes.add(this.outgoingTransferEnvelope);
    this.outgoingTransferEnvelope=null;
    memBuffer.recycleBuffer();
    return;
  }
  while (!this.queuedOutgoingEnvelopes.isEmpty()) {
    this.outputGateContext.processEnvelope(this.queuedOutgoingEnvelopes.poll());
  }
  this.outputGateContext.processEnvelope(this.outgoingTransferEnvelope);
  this.outgoingTransferEnvelope=null;
}","/** 
 * {@inheritDoc}
 */
@Override public void releaseWriteBuffers() throws IOException, InterruptedException {
  if (this.outgoingTransferEnvelope == null) {
    LOG.error(""String_Node_Str"" + this.byteBufferedOutputChannel.getID());
    return;
  }
  if (this.outgoingTransferEnvelope.getBuffer() == null) {
    LOG.error(""String_Node_Str"" + this.byteBufferedOutputChannel.getID() + ""String_Node_Str"");
    return;
  }
  try {
    this.outgoingTransferEnvelope.getBuffer().finishWritePhase();
  }
 catch (  final IOException ioe) {
    this.byteBufferedOutputChannel.reportIOException(ioe);
  }
  if (!this.isReceiverRunning) {
    final Buffer memBuffer=this.outgoingTransferEnvelope.getBuffer();
    final Buffer fileBuffer=this.outputGateContext.getFileBuffer(memBuffer.size());
    memBuffer.copyToBuffer(fileBuffer);
    this.outgoingTransferEnvelope.setBuffer(fileBuffer);
    this.queuedOutgoingEnvelopes.add(this.outgoingTransferEnvelope);
    this.outgoingTransferEnvelope=null;
    memBuffer.recycleBuffer();
    return;
  }
  while (!this.queuedOutgoingEnvelopes.isEmpty()) {
    this.outputGateContext.processEnvelope(this,this.queuedOutgoingEnvelopes.poll());
  }
  this.outputGateContext.processEnvelope(this,this.outgoingTransferEnvelope);
  this.outgoingTransferEnvelope=null;
}"
88141,"/** 
 * {@inheritDoc}
 */
@Override public BufferPairResponse requestEmptyWriteBuffers() throws InterruptedException, IOException {
  if (this.outgoingTransferEnvelope == null) {
    this.outgoingTransferEnvelope=createNewOutgoingTransferEnvelope();
  }
 else {
    if (this.outgoingTransferEnvelope.getBuffer() != null) {
      LOG.error(""String_Node_Str"" + this.byteBufferedOutputChannel.getID() + ""String_Node_Str"");
      return null;
    }
  }
  final int uncompressedBufferSize=calculateBufferSize();
  final Buffer buffer=this.outputGateContext.requestEmptyBufferBlocking(uncompressedBufferSize);
  final BufferPairResponse bufferResponse=new BufferPairResponse(null,buffer);
  this.outgoingTransferEnvelope.setBuffer(bufferResponse.getUncompressedDataBuffer());
  return bufferResponse;
}","/** 
 * {@inheritDoc}
 */
@Override public BufferPairResponse requestEmptyWriteBuffers() throws InterruptedException, IOException {
  if (this.outgoingTransferEnvelope == null) {
    this.outgoingTransferEnvelope=createNewOutgoingTransferEnvelope();
  }
 else {
    if (this.outgoingTransferEnvelope.getBuffer() != null) {
      LOG.error(""String_Node_Str"" + this.byteBufferedOutputChannel.getID() + ""String_Node_Str"");
      return null;
    }
  }
  final int uncompressedBufferSize=calculateBufferSize();
  final Buffer buffer=this.outputGateContext.requestEmptyBufferBlocking(this,uncompressedBufferSize);
  final BufferPairResponse bufferResponse=new BufferPairResponse(null,buffer);
  this.outgoingTransferEnvelope.setBuffer(bufferResponse.getUncompressedDataBuffer());
  return bufferResponse;
}"
88142,"@Override public boolean hasDataLeftToTransmit() throws IOException, InterruptedException {
  if (!this.isReceiverRunning) {
    return true;
  }
  while (!this.queuedOutgoingEnvelopes.isEmpty()) {
    this.outputGateContext.processEnvelope(this.queuedOutgoingEnvelopes.poll());
  }
  return false;
}","@Override public boolean hasDataLeftToTransmit() throws IOException, InterruptedException {
  if (!this.isReceiverRunning) {
    return true;
  }
  while (!this.queuedOutgoingEnvelopes.isEmpty()) {
    this.outputGateContext.processEnvelope(this,this.queuedOutgoingEnvelopes.poll());
  }
  return false;
}"
88143,"/** 
 * {@inheritDoc}
 */
@Override public void transferEventToInputChannel(final AbstractEvent event) throws IOException, InterruptedException {
  if (this.outgoingTransferEnvelope != null) {
    this.outgoingTransferEnvelope.addEvent(event);
  }
 else {
    final TransferEnvelope ephemeralTransferEnvelope=createNewOutgoingTransferEnvelope();
    ephemeralTransferEnvelope.addEvent(event);
    if (!this.isReceiverRunning) {
      this.queuedOutgoingEnvelopes.add(ephemeralTransferEnvelope);
      return;
    }
    while (!this.queuedOutgoingEnvelopes.isEmpty()) {
      this.outputGateContext.processEnvelope(this.queuedOutgoingEnvelopes.poll());
    }
    this.outputGateContext.processEnvelope(ephemeralTransferEnvelope);
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void transferEventToInputChannel(final AbstractEvent event) throws IOException, InterruptedException {
  if (this.outgoingTransferEnvelope != null) {
    this.outgoingTransferEnvelope.addEvent(event);
  }
 else {
    final TransferEnvelope ephemeralTransferEnvelope=createNewOutgoingTransferEnvelope();
    ephemeralTransferEnvelope.addEvent(event);
    if (!this.isReceiverRunning) {
      this.queuedOutgoingEnvelopes.add(ephemeralTransferEnvelope);
      return;
    }
    while (!this.queuedOutgoingEnvelopes.isEmpty()) {
      this.outputGateContext.processEnvelope(this,this.queuedOutgoingEnvelopes.poll());
    }
    this.outputGateContext.processEnvelope(this,ephemeralTransferEnvelope);
  }
}"
88144,"public void releaseFileChannelForReading(final GateID gateID,final FileID fileID,boolean deleteFile){
  try {
    Map<FileID,ReadableSpillingFile> map=null;
synchronized (this.readableSpillingFileMap) {
      map=this.readableSpillingFileMap.get(gateID);
      if (map == null) {
        if (this.canceledChannels.contains(gateID)) {
          return;
        }
 else {
          throw new IOException(""String_Node_Str"" + gateID);
        }
      }
      ReadableSpillingFile readableSpillingFile=null;
synchronized (map) {
        readableSpillingFile=map.get(fileID);
        if (readableSpillingFile == null) {
          if (this.canceledChannels.contains(gateID)) {
            return;
          }
 else {
            throw new IOException(""String_Node_Str"" + gateID);
          }
        }
        try {
          readableSpillingFile.unlockReadableFileChannel();
          if (deleteFile) {
            if (readableSpillingFile.checkForEndOfFile()) {
              map.remove(fileID);
              if (map.isEmpty()) {
                this.readableSpillingFileMap.remove(gateID);
              }
            }
          }
        }
 catch (        ClosedChannelException e) {
          if (this.canceledChannels.contains(gateID)) {
            readableSpillingFile.getPhysicalFile().delete();
          }
 else {
            throw e;
          }
        }
      }
    }
  }
 catch (  IOException ioe) {
    LOG.error(StringUtils.stringifyException(ioe));
  }
}","public void releaseFileChannelForReading(final GateID gateID,final FileID fileID){
  try {
    getReadableSpillingFile(gateID,fileID).unlockReadableFileChannel();
  }
 catch (  Exception e) {
    LOG.error(StringUtils.stringifyException(e));
  }
}"
88145,"@Override public Map<InstanceType,InstanceTypeDescription> getMapOfAvailableInstanceTypes(){
  Map<InstanceType,InstanceTypeDescription> availableinstances=new HashMap<InstanceType,InstanceTypeDescription>();
  for (  InstanceType t : this.availableInstanceTypes) {
    availableinstances.put(t,InstanceTypeDescriptionFactory.construct(t,null,-1));
  }
  return availableinstances;
}","/** 
 * {@inheritDoc}
 */
@Override public Map<InstanceType,InstanceTypeDescription> getMapOfAvailableInstanceTypes(){
  final Map<InstanceType,InstanceTypeDescription> availableinstances=new SerializableHashMap<InstanceType,InstanceTypeDescription>();
  for (  InstanceType t : this.availableInstanceTypes) {
    availableinstances.put(t,InstanceTypeDescriptionFactory.construct(t,null,-1));
  }
  return availableinstances;
}"
88146,"/** 
 * Sets the designated number of buffers for this local buffer cache.
 * @param designatedNumberOfBuffers the designated number of buffers for this local buffer cache
 */
public void setDesignatedNumberOfBuffers(final int designatedNumberOfBuffers){
synchronized (this.buffers) {
    this.designatedNumberOfBuffers=designatedNumberOfBuffers;
    this.buffers.notify();
  }
}","/** 
 * Sets the designated number of buffers for this local buffer cache.
 * @param designatedNumberOfBuffers the designated number of buffers for this local buffer cache
 */
public void setDesignatedNumberOfBuffers(final int designatedNumberOfBuffers){
synchronized (this.buffers) {
    this.designatedNumberOfBuffers=designatedNumberOfBuffers;
    while (this.designatedNumberOfBuffers > this.requestedNumberOfBuffers) {
      if (this.buffers.isEmpty()) {
        break;
      }
      this.globalBufferPool.releaseGlobalBuffer(this.buffers.poll());
      this.requestedNumberOfBuffers--;
    }
    this.buffers.notify();
  }
}"
88147,"public LocalBufferCache(final int designatedNumberOfBuffers){
  this.globalBufferPool=GlobalBufferPool.getInstance();
  this.maximumBufferSize=this.globalBufferPool.getMaximumBufferSize();
  this.designatedNumberOfBuffers=designatedNumberOfBuffers;
}","public LocalBufferCache(final int designatedNumberOfBuffers,final boolean isShared){
  this.globalBufferPool=GlobalBufferPool.getInstance();
  this.maximumBufferSize=this.globalBufferPool.getMaximumBufferSize();
  this.designatedNumberOfBuffers=designatedNumberOfBuffers;
  this.isShared=isShared;
}"
88148,"/** 
 * {@inheritDoc}
 */
@Override public boolean isShared(){
  return false;
}","/** 
 * {@inheritDoc}
 */
@Override public boolean isShared(){
  return this.isShared;
}"
88149,"private void processEnvelopeWithBuffer(final TransferEnvelope transferEnvelope,final TransferEnvelopeReceiverList receiverList,final boolean freeSourceBuffer) throws IOException, InterruptedException {
  if (!freeSourceBuffer) {
    final List<ChannelID> localReceivers=receiverList.getLocalReceivers();
    if (localReceivers.size() != 1) {
      throw new IOException(""String_Node_Str"");
    }
    final ChannelID localReceiver=localReceivers.get(0);
synchronized (this.registeredChannels) {
      final ChannelContext cc=this.registeredChannels.get(localReceiver);
      if (cc == null) {
        throw new IOException(""String_Node_Str"" + localReceiver);
      }
      if (!cc.isInputChannel()) {
        throw new IOException(""String_Node_Str"" + localReceiver + ""String_Node_Str"");
      }
      cc.queueTransferEnvelope(transferEnvelope);
    }
    return;
  }
  final Buffer srcBuffer=transferEnvelope.getBuffer();
  if (receiverList.hasLocalReceivers()) {
    final List<ChannelID> localReceivers=receiverList.getLocalReceivers();
synchronized (this.registeredChannels) {
      for (      final ChannelID localReceiver : localReceivers) {
        final ChannelContext cc=this.registeredChannels.get(localReceiver);
        if (cc == null) {
          throw new IOException(""String_Node_Str"" + localReceiver);
        }
        if (!cc.isInputChannel()) {
          throw new IOException(""String_Node_Str"" + localReceiver + ""String_Node_Str"");
        }
        final InputChannelContext inputChannelContext=(InputChannelContext)cc;
        final Buffer destBuffer=inputChannelContext.requestEmptyBufferBlocking(srcBuffer.size());
        final TransferEnvelope dup=transferEnvelope.duplicateWithoutBuffer();
        dup.setBuffer(destBuffer);
        inputChannelContext.queueTransferEnvelope(dup);
      }
    }
  }
  if (receiverList.hasRemoteReceivers()) {
    final List<InetSocketAddress> remoteReceivers=receiverList.getRemoteReceivers();
    for (int i=0; i < remoteReceivers.size(); ++i) {
      this.networkConnectionManager.queueEnvelopeForTransfer(remoteReceivers.get(i),transferEnvelope.duplicate());
    }
  }
  srcBuffer.recycleBuffer();
}","private void processEnvelopeWithBuffer(final TransferEnvelope transferEnvelope,final TransferEnvelopeReceiverList receiverList,final boolean freeSourceBuffer) throws IOException, InterruptedException {
  if (!freeSourceBuffer) {
    final List<ChannelID> localReceivers=receiverList.getLocalReceivers();
    if (localReceivers.size() != 1) {
      throw new IOException(""String_Node_Str"");
    }
    final ChannelID localReceiver=localReceivers.get(0);
synchronized (this.registeredChannels) {
      final ChannelContext cc=this.registeredChannels.get(localReceiver);
      if (cc == null) {
        throw new IOException(""String_Node_Str"" + localReceiver);
      }
      if (!cc.isInputChannel()) {
        throw new IOException(""String_Node_Str"" + localReceiver + ""String_Node_Str"");
      }
      cc.queueTransferEnvelope(transferEnvelope);
    }
    return;
  }
  final Buffer srcBuffer=transferEnvelope.getBuffer();
  if (receiverList.hasLocalReceivers()) {
    final List<ChannelID> localReceivers=receiverList.getLocalReceivers();
synchronized (this.registeredChannels) {
      for (      final ChannelID localReceiver : localReceivers) {
        final ChannelContext cc=this.registeredChannels.get(localReceiver);
        if (cc == null) {
          throw new IOException(""String_Node_Str"" + localReceiver);
        }
        if (!cc.isInputChannel()) {
          throw new IOException(""String_Node_Str"" + localReceiver + ""String_Node_Str"");
        }
        final InputChannelContext inputChannelContext=(InputChannelContext)cc;
        final Buffer destBuffer=inputChannelContext.requestEmptyBufferBlocking(srcBuffer.size());
        srcBuffer.copyToBuffer(destBuffer);
        final TransferEnvelope dup=transferEnvelope.duplicateWithoutBuffer();
        dup.setBuffer(destBuffer);
        inputChannelContext.queueTransferEnvelope(dup);
      }
    }
  }
  if (receiverList.hasRemoteReceivers()) {
    final List<InetSocketAddress> remoteReceivers=receiverList.getRemoteReceivers();
    for (    final InetSocketAddress remoteReceiver : remoteReceivers) {
      this.networkConnectionManager.queueEnvelopeForTransfer(remoteReceiver,transferEnvelope.duplicate());
    }
  }
  srcBuffer.recycleBuffer();
}"
88150,"public ByteBufferedChannelManager(ChannelLookupProtocol channelLookupService,InstanceConnectionInfo localInstanceConnectionInfo) throws IOException {
  this.channelLookupService=channelLookupService;
  this.localConnectionInfo=localInstanceConnectionInfo;
  this.canceledChannelSet=new CanceledChannelSet();
  this.fileBufferManager=new FileBufferManager(this.canceledChannelSet);
  GlobalBufferPool.getInstance();
  this.transitBufferPool=TransitBufferPool.getInstance();
  this.networkConnectionManager=new NetworkConnectionManager(this,localInstanceConnectionInfo.getAddress(),localInstanceConnectionInfo.getDataPort());
}","public ByteBufferedChannelManager(ChannelLookupProtocol channelLookupService,InstanceConnectionInfo localInstanceConnectionInfo) throws IOException {
  this.channelLookupService=channelLookupService;
  this.localConnectionInfo=localInstanceConnectionInfo;
  this.canceledChannelSet=new CanceledChannelSet();
  this.fileBufferManager=new FileBufferManager(this.canceledChannelSet);
  GlobalBufferPool.getInstance();
  this.transitBufferPool=new LocalBufferCache(128,true);
  this.networkConnectionManager=new NetworkConnectionManager(this,localInstanceConnectionInfo.getAddress(),localInstanceConnectionInfo.getDataPort());
}"
88151,"private void redistributeGlobalBuffers(){
  final int totalNumberOfBuffers=GlobalBufferPool.getInstance().getTotalNumberOfBuffers();
synchronized (this.taskMap) {
    if (this.taskMap.isEmpty()) {
      return;
    }
    final int buffersPerTask=(int)Math.ceil((double)totalNumberOfBuffers / (double)this.taskMap.size());
    System.out.println(""String_Node_Str"" + buffersPerTask);
    final Iterator<TaskContext> it=this.taskMap.values().iterator();
    while (it.hasNext()) {
      it.next().setBufferLimit(buffersPerTask);
    }
  }
}","private void redistributeGlobalBuffers(){
  final int totalNumberOfBuffers=GlobalBufferPool.getInstance().getTotalNumberOfBuffers();
synchronized (this.taskMap) {
    if (this.taskMap.isEmpty()) {
      return;
    }
    final int numberOfTasks=this.taskMap.size() + (this.multicastEnabled ? 1 : 0);
    final int buffersPerTask=(int)Math.ceil((double)totalNumberOfBuffers / (double)numberOfTasks);
    System.out.println(""String_Node_Str"" + buffersPerTask);
    final Iterator<TaskContext> it=this.taskMap.values().iterator();
    while (it.hasNext()) {
      it.next().setBufferLimit(buffersPerTask);
    }
    if (this.multicastEnabled) {
      this.transitBufferPool.setDesignatedNumberOfBuffers(buffersPerTask);
    }
  }
}"
88152,"public TaskContext(){
  this.localBufferCache=new LocalBufferCache(1);
}","public TaskContext(){
  this.localBufferCache=new LocalBufferCache(1,false);
}"
88153,"/** 
 * Registers the given task with the byte buffered channel manager.
 * @param vertexID the ID of the task to be registered
 * @param environment the environment of the task
 * @param the set of output channels which are initially active
 */
public void register(final ExecutionVertexID vertexID,final Environment environment,final Set<ChannelID> activeOutputChannels){
  final TaskContext taskContext=new TaskContext();
synchronized (this.registeredChannels) {
    for (int i=0; i < environment.getNumberOfOutputGates(); ++i) {
      final OutputGate<?> outputGate=environment.getOutputGate(i);
      final OutputGateContext outputGateContext=new OutputGateContext(taskContext,outputGate,this,this.fileBufferManager);
      for (int j=0; j < outputGate.getNumberOfOutputChannels(); ++j) {
        final AbstractOutputChannel<?> outputChannel=outputGate.getOutputChannel(j);
        if (!(outputChannel instanceof AbstractByteBufferedOutputChannel)) {
          LOG.error(""String_Node_Str"" + outputChannel.getID() + ""String_Node_Str""+ environment.getJobID()+ ""String_Node_Str"");
          continue;
        }
        final AbstractByteBufferedOutputChannel<?> bboc=(AbstractByteBufferedOutputChannel<?>)outputChannel;
        if (this.registeredChannels.containsKey(bboc.getID())) {
          LOG.error(""String_Node_Str"" + bboc.getID() + ""String_Node_Str"");
          continue;
        }
        LOG.info(""String_Node_Str"" + bboc.getID());
        final OutputChannelContext outputChannelContext=new OutputChannelContext(outputGateContext,bboc,activeOutputChannels.contains(bboc.getID()));
        this.registeredChannels.put(bboc.getID(),outputChannelContext);
      }
    }
    for (int i=0; i < environment.getNumberOfInputGates(); ++i) {
      final InputGate<?> inputGate=environment.getInputGate(i);
      final InputGateContext inputGateContext=new InputGateContext(taskContext);
      for (int j=0; j < inputGate.getNumberOfInputChannels(); ++j) {
        final AbstractInputChannel<?> inputChannel=inputGate.getInputChannel(j);
        if (!(inputChannel instanceof AbstractByteBufferedInputChannel)) {
          LOG.error(""String_Node_Str"" + inputChannel.getID() + ""String_Node_Str""+ environment.getJobID()+ ""String_Node_Str"");
          continue;
        }
        final AbstractByteBufferedInputChannel<?> bbic=(AbstractByteBufferedInputChannel<?>)inputChannel;
        if (this.registeredChannels.containsKey(bbic.getID())) {
          LOG.error(""String_Node_Str"" + bbic.getID() + ""String_Node_Str"");
          continue;
        }
        LOG.info(""String_Node_Str"" + bbic.getID());
        final InputChannelContext inputChannelContext=new InputChannelContext(inputGateContext,this,bbic);
        this.registeredChannels.put(bbic.getID(),inputChannelContext);
      }
    }
  }
synchronized (this.taskMap) {
    this.taskMap.put(vertexID,taskContext);
  }
  redistributeGlobalBuffers();
}","/** 
 * Registers the given task with the byte buffered channel manager.
 * @param vertexID the ID of the task to be registered
 * @param environment the environment of the task
 * @param the set of output channels which are initially active
 */
public void register(final ExecutionVertexID vertexID,final Environment environment,final Set<ChannelID> activeOutputChannels){
  final TaskContext taskContext=new TaskContext();
synchronized (this.registeredChannels) {
    for (int i=0; i < environment.getNumberOfOutputGates(); ++i) {
      final OutputGate<?> outputGate=environment.getOutputGate(i);
      final OutputGateContext outputGateContext=new OutputGateContext(taskContext,outputGate,this,this.fileBufferManager);
      for (int j=0; j < outputGate.getNumberOfOutputChannels(); ++j) {
        final AbstractOutputChannel<?> outputChannel=outputGate.getOutputChannel(j);
        if (!(outputChannel instanceof AbstractByteBufferedOutputChannel)) {
          LOG.error(""String_Node_Str"" + outputChannel.getID() + ""String_Node_Str""+ environment.getJobID()+ ""String_Node_Str"");
          continue;
        }
        final AbstractByteBufferedOutputChannel<?> bboc=(AbstractByteBufferedOutputChannel<?>)outputChannel;
        if (this.registeredChannels.containsKey(bboc.getID())) {
          LOG.error(""String_Node_Str"" + bboc.getID() + ""String_Node_Str"");
          continue;
        }
        final boolean isActive=activeOutputChannels.contains(bboc.getID());
        LOG.info(""String_Node_Str"" + bboc.getID() + ""String_Node_Str""+ (isActive ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
        final OutputChannelContext outputChannelContext=new OutputChannelContext(outputGateContext,bboc,isActive);
        this.registeredChannels.put(bboc.getID(),outputChannelContext);
      }
    }
    for (int i=0; i < environment.getNumberOfInputGates(); ++i) {
      final InputGate<?> inputGate=environment.getInputGate(i);
      final InputGateContext inputGateContext=new InputGateContext(taskContext);
      for (int j=0; j < inputGate.getNumberOfInputChannels(); ++j) {
        final AbstractInputChannel<?> inputChannel=inputGate.getInputChannel(j);
        if (!(inputChannel instanceof AbstractByteBufferedInputChannel)) {
          LOG.error(""String_Node_Str"" + inputChannel.getID() + ""String_Node_Str""+ environment.getJobID()+ ""String_Node_Str"");
          continue;
        }
        final AbstractByteBufferedInputChannel<?> bbic=(AbstractByteBufferedInputChannel<?>)inputChannel;
        if (this.registeredChannels.containsKey(bbic.getID())) {
          LOG.error(""String_Node_Str"" + bbic.getID() + ""String_Node_Str"");
          continue;
        }
        LOG.info(""String_Node_Str"" + bbic.getID());
        final InputChannelContext inputChannelContext=new InputChannelContext(inputGateContext,this,bbic);
        this.registeredChannels.put(bbic.getID(),inputChannelContext);
      }
    }
  }
synchronized (this.taskMap) {
    this.taskMap.put(vertexID,taskContext);
  }
  redistributeGlobalBuffers();
}"
88154,"/** 
 * {@inheritDoc}
 */
@Override public void releaseWriteBuffers() throws IOException, InterruptedException {
  if (this.outgoingTransferEnvelope == null) {
    LOG.error(""String_Node_Str"" + this.byteBufferedOutputChannel.getID());
    return;
  }
  if (this.outgoingTransferEnvelope.getBuffer() == null) {
    LOG.error(""String_Node_Str"" + this.byteBufferedOutputChannel.getID() + ""String_Node_Str"");
    return;
  }
  try {
    this.outgoingTransferEnvelope.getBuffer().finishWritePhase();
  }
 catch (  final IOException ioe) {
    this.byteBufferedOutputChannel.reportIOException(ioe);
  }
  if (!this.isReceiverRunning) {
    final Buffer memBuffer=this.outgoingTransferEnvelope.getBuffer();
    final Buffer fileBuffer=this.outputGateContext.getFileBuffer(memBuffer.size());
    memBuffer.copyToBuffer(fileBuffer);
    this.outgoingTransferEnvelope.setBuffer(fileBuffer);
    this.queuedOutgoingEnvelopes.add(this.outgoingTransferEnvelope);
    memBuffer.recycleBuffer();
    return;
  }
  while (!this.queuedOutgoingEnvelopes.isEmpty()) {
    this.outputGateContext.processEnvelope(this.queuedOutgoingEnvelopes.poll());
  }
  this.outputGateContext.processEnvelope(this.outgoingTransferEnvelope);
  this.outgoingTransferEnvelope=null;
}","/** 
 * {@inheritDoc}
 */
@Override public void releaseWriteBuffers() throws IOException, InterruptedException {
  if (this.outgoingTransferEnvelope == null) {
    LOG.error(""String_Node_Str"" + this.byteBufferedOutputChannel.getID());
    return;
  }
  if (this.outgoingTransferEnvelope.getBuffer() == null) {
    LOG.error(""String_Node_Str"" + this.byteBufferedOutputChannel.getID() + ""String_Node_Str"");
    return;
  }
  try {
    this.outgoingTransferEnvelope.getBuffer().finishWritePhase();
  }
 catch (  final IOException ioe) {
    this.byteBufferedOutputChannel.reportIOException(ioe);
  }
  if (!this.isReceiverRunning) {
    final Buffer memBuffer=this.outgoingTransferEnvelope.getBuffer();
    final Buffer fileBuffer=this.outputGateContext.getFileBuffer(memBuffer.size());
    memBuffer.copyToBuffer(fileBuffer);
    this.outgoingTransferEnvelope.setBuffer(fileBuffer);
    this.queuedOutgoingEnvelopes.add(this.outgoingTransferEnvelope);
    this.outgoingTransferEnvelope=null;
    memBuffer.recycleBuffer();
    return;
  }
  while (!this.queuedOutgoingEnvelopes.isEmpty()) {
    this.outputGateContext.processEnvelope(this.queuedOutgoingEnvelopes.poll());
  }
  this.outputGateContext.processEnvelope(this.outgoingTransferEnvelope);
  this.outgoingTransferEnvelope=null;
}"
88155,"/** 
 * {@inheritDoc}
 */
public void write(DataOutput out) throws IOException {
  super.write(out);
  out.writeInt(this.getNumberOfOutputChannels());
  for (int i=0; i < getNumberOfOutputChannels(); i++) {
    getOutputChannel(i).getID().write(out);
    EnumUtils.writeEnum(out,getOutputChannel(i).getCompressionLevel());
    StringRecord.writeString(out,getOutputChannel(i).getClass().getName());
    getOutputChannel(i).write(out);
  }
}","/** 
 * {@inheritDoc}
 */
public void write(DataOutput out) throws IOException {
  super.write(out);
  out.writeInt(this.getNumberOfOutputChannels());
  for (int i=0; i < getNumberOfOutputChannels(); i++) {
    EnumUtils.writeEnum(out,getOutputChannel(i).getType());
    if (getOutputChannel(i).getType() == ChannelType.NETWORK) {
      out.writeBoolean(getOutputChannel(i).followsPushModel());
    }
    getOutputChannel(i).getID().write(out);
    EnumUtils.writeEnum(out,getOutputChannel(i).getCompressionLevel());
    StringRecord.writeString(out,getOutputChannel(i).getClass().getName());
    getOutputChannel(i).write(out);
  }
}"
88156,"/** 
 * {@inheritDoc}
 */
@SuppressWarnings(""String_Node_Str"") public void read(DataInput in) throws IOException {
  super.read(in);
  final int numOutputChannels=in.readInt();
  final Class<?>[] parameters={this.getClass(),int.class,ChannelID.class,CompressionLevel.class};
  for (int i=0; i < numOutputChannels; i++) {
    final ChannelID channelID=new ChannelID();
    channelID.read(in);
    final CompressionLevel compressionLevel=EnumUtils.readEnum(in,CompressionLevel.class);
    final String className=StringRecord.readString(in);
    Class<? extends IOReadableWritable> c=null;
    try {
      c=ClassUtils.getRecordByName(className);
    }
 catch (    ClassNotFoundException e) {
      LOG.error(e);
    }
    if (c == null) {
      throw new IOException(""String_Node_Str"");
    }
    AbstractOutputChannel<T> eoc=null;
    try {
      final Constructor<AbstractOutputChannel<T>> constructor=(Constructor<AbstractOutputChannel<T>>)c.getDeclaredConstructor(parameters);
      if (constructor == null) {
        throw new IOException(""String_Node_Str"");
      }
      constructor.setAccessible(true);
      eoc=constructor.newInstance(this,i,channelID,compressionLevel);
    }
 catch (    InstantiationException e) {
      LOG.error(e);
    }
catch (    IllegalArgumentException e) {
      LOG.error(e);
    }
catch (    IllegalAccessException e) {
      LOG.error(e);
    }
catch (    InvocationTargetException e) {
      LOG.error(e);
    }
catch (    SecurityException e) {
      LOG.error(e);
    }
catch (    NoSuchMethodException e) {
      LOG.error(e);
    }
    if (eoc == null) {
      throw new IOException(""String_Node_Str"");
    }
    eoc.read(in);
    addOutputChannel(eoc);
  }
}","/** 
 * {@inheritDoc}
 */
@SuppressWarnings(""String_Node_Str"") public void read(DataInput in) throws IOException {
  super.read(in);
  final int numOutputChannels=in.readInt();
  Class<?>[] parameters={this.getClass(),int.class,ChannelID.class,CompressionLevel.class};
  Class<?>[] networkParameters={this.getClass(),int.class,ChannelID.class,CompressionLevel.class,boolean.class};
  for (int i=0; i < numOutputChannels; i++) {
    final ChannelType channelType=EnumUtils.readEnum(in,ChannelType.class);
    boolean followsPushModel=false;
    if (channelType == ChannelType.NETWORK) {
      followsPushModel=in.readBoolean();
    }
    final ChannelID channelID=new ChannelID();
    channelID.read(in);
    final CompressionLevel compressionLevel=EnumUtils.readEnum(in,CompressionLevel.class);
    final String className=StringRecord.readString(in);
    Class<? extends IOReadableWritable> c=null;
    try {
      c=ClassUtils.getRecordByName(className);
    }
 catch (    ClassNotFoundException e) {
      LOG.error(e);
    }
    if (c == null) {
      throw new IOException(""String_Node_Str"");
    }
    AbstractOutputChannel<T> eoc=null;
    try {
      Constructor<AbstractOutputChannel<T>> constructor;
      if (channelType == ChannelType.NETWORK) {
        constructor=(Constructor<AbstractOutputChannel<T>>)c.getDeclaredConstructor(networkParameters);
      }
 else {
        constructor=(Constructor<AbstractOutputChannel<T>>)c.getDeclaredConstructor(parameters);
      }
      if (constructor == null) {
        throw new IOException(""String_Node_Str"");
      }
      constructor.setAccessible(true);
      if (channelType == ChannelType.NETWORK) {
        eoc=constructor.newInstance(this,i,channelID,compressionLevel,followsPushModel);
      }
 else {
        eoc=constructor.newInstance(this,i,channelID,compressionLevel);
      }
    }
 catch (    InstantiationException e) {
      LOG.error(e);
    }
catch (    IllegalArgumentException e) {
      LOG.error(e);
    }
catch (    IllegalAccessException e) {
      LOG.error(e);
    }
catch (    InvocationTargetException e) {
      LOG.error(e);
    }
catch (    SecurityException e) {
      LOG.error(e);
    }
catch (    NoSuchMethodException e) {
      LOG.error(e);
    }
    if (eoc == null) {
      throw new IOException(""String_Node_Str"");
    }
    eoc.read(in);
    addOutputChannel(eoc);
  }
}"
88157,"/** 
 * Creates a new output channel object.
 * @param outputGate the output gate this channel is connected to.
 * @param channelIndex the channel's index at the associated output gate
 * @param channelID the channel ID to assign to the new channel, <code>null</code> to generate a new ID
 * @param compressionLevel the level of compression to be used for this channel
 */
public AbstractOutputChannel(OutputGate<T> outputGate,int channelIndex,ChannelID channelID,CompressionLevel compressionLevel){
  super(channelIndex,channelID,compressionLevel);
  this.outputGate=outputGate;
}","/** 
 * Creates a new output channel object.
 * @param outputGate the output gate this channel is connected to.
 * @param channelIndex the channel's index at the associated output gate
 * @param channelID the channel ID to assign to the new channel, <code>null</code> to generate a new ID
 * @param compressionLevel the level of compression to be used for this channel
 */
public AbstractOutputChannel(OutputGate<T> outputGate,int channelIndex,ChannelID channelID,CompressionLevel compressionLevel,boolean followsPushModel){
  super(channelIndex,channelID,compressionLevel);
  this.outputGate=outputGate;
  this.followsPushModel=followsPushModel;
}"
88158,"/** 
 * Creates a new byte buffered output channel.
 * @param outputGate the output gate this channel is wired to
 * @param channelIndex the channel's index at the associated output gate
 * @param channelID the channel ID to assign to the new channel, <code>null</code> to generate a new ID
 * @param compressionLevel the level of compression to be used for this channel
 */
public AbstractByteBufferedOutputChannel(OutputGate<T> outputGate,int channelIndex,ChannelID channelID,CompressionLevel compressionLevel,boolean followsPushModel){
  super(outputGate,channelIndex,channelID,compressionLevel);
  this.compressor=CompressionLoader.getCompressorByCompressionLevel(compressionLevel,this);
  this.followsPushModel=followsPushModel;
}","/** 
 * Creates a new byte buffered output channel.
 * @param outputGate the output gate this channel is wired to
 * @param channelIndex the channel's index at the associated output gate
 * @param channelID the channel ID to assign to the new channel, <code>null</code> to generate a new ID
 * @param compressionLevel the level of compression to be used for this channel
 */
public AbstractByteBufferedOutputChannel(OutputGate<T> outputGate,int channelIndex,ChannelID channelID,CompressionLevel compressionLevel,boolean followsPushModel){
  super(outputGate,channelIndex,channelID,compressionLevel,followsPushModel);
  this.compressor=CompressionLoader.getCompressorByCompressionLevel(compressionLevel,this);
}"
88159,"/** 
 * Registers the given task with the byte buffered channel manager.
 * @param vertexID the ID of the task to be registered
 * @param environment the environment of the task
 */
public void register(final ExecutionVertexID vertexID,final Environment environment){
  final TaskContext taskContext=new TaskContext();
  for (int i=0; i < environment.getNumberOfOutputGates(); ++i) {
    final OutputGate<?> outputGate=environment.getOutputGate(i);
    final OutputGateContext outputGateContext=new OutputGateContext(taskContext,outputGate,this,this.fileBufferManager);
    for (int j=0; j < outputGate.getNumberOfOutputChannels(); ++j) {
      final AbstractOutputChannel<?> outputChannel=outputGate.getOutputChannel(j);
      if (outputChannel instanceof AbstractByteBufferedOutputChannel) {
        LOG.error(""String_Node_Str"" + outputChannel.getID() + ""String_Node_Str""+ environment.getJobID()+ ""String_Node_Str"");
        continue;
      }
      final AbstractByteBufferedOutputChannel<?> bboc=(AbstractByteBufferedOutputChannel<?>)outputChannel;
      if (this.registeredChannels.containsKey(bboc.getID())) {
        LOG.error(""String_Node_Str"" + bboc.getID() + ""String_Node_Str"");
        continue;
      }
      LOG.info(""String_Node_Str"" + bboc.getID());
      final OutputChannelContext outputChannelContext=new OutputChannelContext(outputGateContext,bboc);
      this.registeredChannels.put(bboc.getID(),outputChannelContext);
    }
  }
  for (int i=0; i < environment.getNumberOfInputGates(); ++i) {
    final InputGate<?> inputGate=environment.getInputGate(i);
    final InputGateContext inputGateContext=new InputGateContext(taskContext);
    for (int j=0; j < inputGate.getNumberOfInputChannels(); ++j) {
      final AbstractInputChannel<?> inputChannel=inputGate.getInputChannel(j);
      if (inputChannel instanceof AbstractByteBufferedInputChannel) {
        LOG.error(""String_Node_Str"" + inputChannel.getID() + ""String_Node_Str""+ environment.getJobID()+ ""String_Node_Str"");
        continue;
      }
      final AbstractByteBufferedInputChannel<?> bbic=(AbstractByteBufferedInputChannel<?>)inputChannel;
      if (this.registeredChannels.containsKey(bbic.getID())) {
        LOG.error(""String_Node_Str"" + bbic.getID() + ""String_Node_Str"");
        continue;
      }
      LOG.info(""String_Node_Str"" + bbic.getID());
      final InputChannelContext inputChannelContext=new InputChannelContext(inputGateContext,this,bbic);
      this.registeredChannels.put(bbic.getID(),inputChannelContext);
    }
  }
}","/** 
 * Registers the given task with the byte buffered channel manager.
 * @param vertexID the ID of the task to be registered
 * @param environment the environment of the task
 */
public void register(final ExecutionVertexID vertexID,final Environment environment){
  final TaskContext taskContext=new TaskContext();
  for (int i=0; i < environment.getNumberOfOutputGates(); ++i) {
    final OutputGate<?> outputGate=environment.getOutputGate(i);
    final OutputGateContext outputGateContext=new OutputGateContext(taskContext,outputGate,this,this.fileBufferManager);
    for (int j=0; j < outputGate.getNumberOfOutputChannels(); ++j) {
      final AbstractOutputChannel<?> outputChannel=outputGate.getOutputChannel(j);
      if (!(outputChannel instanceof AbstractByteBufferedOutputChannel)) {
        LOG.error(""String_Node_Str"" + outputChannel.getID() + ""String_Node_Str""+ environment.getJobID()+ ""String_Node_Str"");
        continue;
      }
      final AbstractByteBufferedOutputChannel<?> bboc=(AbstractByteBufferedOutputChannel<?>)outputChannel;
      if (this.registeredChannels.containsKey(bboc.getID())) {
        LOG.error(""String_Node_Str"" + bboc.getID() + ""String_Node_Str"");
        continue;
      }
      LOG.info(""String_Node_Str"" + bboc.getID());
      final OutputChannelContext outputChannelContext=new OutputChannelContext(outputGateContext,bboc);
      this.registeredChannels.put(bboc.getID(),outputChannelContext);
    }
  }
  for (int i=0; i < environment.getNumberOfInputGates(); ++i) {
    final InputGate<?> inputGate=environment.getInputGate(i);
    final InputGateContext inputGateContext=new InputGateContext(taskContext);
    for (int j=0; j < inputGate.getNumberOfInputChannels(); ++j) {
      final AbstractInputChannel<?> inputChannel=inputGate.getInputChannel(j);
      if (!(inputChannel instanceof AbstractByteBufferedInputChannel)) {
        LOG.error(""String_Node_Str"" + inputChannel.getID() + ""String_Node_Str""+ environment.getJobID()+ ""String_Node_Str"");
        continue;
      }
      final AbstractByteBufferedInputChannel<?> bbic=(AbstractByteBufferedInputChannel<?>)inputChannel;
      if (this.registeredChannels.containsKey(bbic.getID())) {
        LOG.error(""String_Node_Str"" + bbic.getID() + ""String_Node_Str"");
        continue;
      }
      LOG.info(""String_Node_Str"" + bbic.getID());
      final InputChannelContext inputChannelContext=new InputChannelContext(inputGateContext,this,bbic);
      this.registeredChannels.put(bbic.getID(),inputChannelContext);
    }
  }
}"
88160,"/** 
 * Entry point for the program.
 * @param args arguments from the command line
 */
@SuppressWarnings(""String_Node_Str"") public static void main(String[] args){
  Option configDirOpt=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Options options=new Options();
  options.addOption(configDirOpt);
  CommandLineParser parser=new GnuParser();
  CommandLine line=null;
  try {
    line=parser.parse(options,args);
  }
 catch (  ParseException e) {
    System.err.println(""String_Node_Str"" + e.getMessage());
    System.exit(FAILURERETURNCODE);
  }
  String configDir=line.getOptionValue(configDirOpt.getOpt(),null);
  TaskManager taskManager=null;
  try {
    taskManager=new TaskManager(configDir);
  }
 catch (  Throwable t) {
    LOG.fatal(""String_Node_Str"" + t.getMessage());
    LOG.error(System.err);
    System.exit(FAILURERETURNCODE);
  }
  taskManager.runIOLoop();
  taskManager.shutdown();
}","/** 
 * Entry point for the program.
 * @param args arguments from the command line
 */
@SuppressWarnings(""String_Node_Str"") public static void main(String[] args){
  Option configDirOpt=OptionBuilder.withArgName(""String_Node_Str"").hasArg().withDescription(""String_Node_Str"").create(""String_Node_Str"");
  Options options=new Options();
  options.addOption(configDirOpt);
  CommandLineParser parser=new GnuParser();
  CommandLine line=null;
  try {
    line=parser.parse(options,args);
  }
 catch (  ParseException e) {
    System.err.println(""String_Node_Str"" + e.getMessage());
    System.exit(FAILURERETURNCODE);
  }
  String configDir=line.getOptionValue(configDirOpt.getOpt(),null);
  TaskManager taskManager=null;
  try {
    taskManager=new TaskManager(configDir);
  }
 catch (  Throwable t) {
    LOG.fatal(""String_Node_Str"" + t.getMessage());
    System.exit(FAILURERETURNCODE);
  }
  taskManager.runIOLoop();
  taskManager.shutdown();
}"
88161,"/** 
 * Constructs a new broadcast record writer and registers a new output gate with the application's environment.
 * @param inputBase the application that instantiated the record writer
 * @param outputClass the class of records that can be emitted with this record writer
 */
public BroadcastRecordWriter(AbstractInputTask inputBase,Class<T> outputClass){
  super(inputBase,outputClass,null,true);
}","/** 
 * Constructs a new broadcast record writer and registers a new output gate with the application's environment.
 * @param inputBase the application that instantiated the record writer
 * @param outputClass the class of records that can be emitted with this record writer
 */
public BroadcastRecordWriter(AbstractInputTask<?> inputBase,Class<T> outputClass){
  super(inputBase,outputClass,null,true);
}"
88162,"/** 
 * {@inheritDoc}
 */
@SuppressWarnings(""String_Node_Str"") public void read(DataInput in) throws IOException {
}","/** 
 * {@inheritDoc}
 */
@SuppressWarnings(""String_Node_Str"") public void read(DataInput in) throws IOException {
  super.read(in);
  final int numOutputChannels=in.readInt();
  final Class<?>[] parameters={this.getClass(),int.class,ChannelID.class,CompressionLevel.class};
  for (int i=0; i < numOutputChannels; i++) {
    final ChannelID channelID=new ChannelID();
    channelID.read(in);
    final CompressionLevel compressionLevel=EnumUtils.readEnum(in,CompressionLevel.class);
    final String className=StringRecord.readString(in);
    Class<? extends IOReadableWritable> c=null;
    try {
      c=ClassUtils.getRecordByName(className);
    }
 catch (    ClassNotFoundException e) {
      LOG.error(e);
    }
    if (c == null) {
      throw new IOException(""String_Node_Str"");
    }
    AbstractOutputChannel<T> eoc=null;
    try {
      final Constructor<AbstractOutputChannel<T>> constructor=(Constructor<AbstractOutputChannel<T>>)c.getDeclaredConstructor(parameters);
      if (constructor == null) {
        throw new IOException(""String_Node_Str"");
      }
      constructor.setAccessible(true);
      eoc=constructor.newInstance(this,i,channelID,compressionLevel);
    }
 catch (    InstantiationException e) {
      LOG.error(e);
    }
catch (    IllegalArgumentException e) {
      LOG.error(e);
    }
catch (    IllegalAccessException e) {
      LOG.error(e);
    }
catch (    InvocationTargetException e) {
      LOG.error(e);
    }
catch (    SecurityException e) {
      LOG.error(e);
    }
catch (    NoSuchMethodException e) {
      LOG.error(e);
    }
    if (eoc == null) {
      throw new IOException(""String_Node_Str"");
    }
    eoc.read(in);
    addOutputChannel(eoc);
  }
}"
88163,"/** 
 * Constructs a new record writer and registers a new output gate with the application's environment.
 * @param inputBase the application that instantiated the record writer
 * @param outputClass the class of records that can be emitted with this record writer
 * @param selector the channel selector to be used to determine the output channel to be used for a record
 */
public RecordWriter(AbstractInputTask inputBase,Class<T> outputClass,ChannelSelector<T> selector){
  super(inputBase,outputClass,selector,false);
}","/** 
 * Constructs a new record writer and registers a new output gate with the application's environment.
 * @param inputBase the application that instantiated the record writer
 * @param outputClass the class of records that can be emitted with this record writer
 * @param selector the channel selector to be used to determine the output channel to be used for a record
 */
public RecordWriter(AbstractInputTask<?> inputBase,Class<T> outputClass,ChannelSelector<T> selector){
  super(inputBase,outputClass,selector,false);
}"
88164,"/** 
 * Submits the job assigned to this job client to the job manager.
 * @return a <code>JobSubmissionResult</code> object encapsulating the results of the job submission
 * @throws IOException thrown in case of submission errors while transmitting the data to the job manager
 */
public JobSubmissionResult submitJob() throws IOException {
synchronized (this.jobSubmitClient) {
    final JobSubmissionResult result=this.jobSubmitClient.submitJob(this.jobGraph);
    if (result.getReturnCode() == ReturnCode.SUCCESS) {
      Runtime.getRuntime().addShutdownHook(this.jobCleanUp);
    }
    return result;
  }
}","/** 
 * Submits the job assigned to this job client to the job manager.
 * @return a <code>JobSubmissionResult</code> object encapsulating the results of the job submission
 * @throws IOException thrown in case of submission errors while transmitting the data to the job manager
 */
public JobSubmissionResult submitJob() throws IOException {
synchronized (this.jobSubmitClient) {
    return this.jobSubmitClient.submitJob(this.jobGraph);
  }
}"
88165,"/** 
 * Cancels the job assigned to this job client.
 * @return a <code>JobCancelResult</code> object encapsulating the result of the job cancel request
 * @throws IOException thrown if an error occurred while transmitting the request to the job manager
 */
public JobCancelResult cancelJob() throws IOException {
  Runtime.getRuntime().removeShutdownHook(this.jobCleanUp);
synchronized (this.jobSubmitClient) {
    return this.jobSubmitClient.cancelJob(this.jobGraph.getJobID());
  }
}","/** 
 * Cancels the job assigned to this job client.
 * @return a <code>JobCancelResult</code> object encapsulating the result of the job cancel request
 * @throws IOException thrown if an error occurred while transmitting the request to the job manager
 */
public JobCancelResult cancelJob() throws IOException {
synchronized (this.jobSubmitClient) {
    return this.jobSubmitClient.cancelJob(this.jobGraph.getJobID());
  }
}"
88166,"/** 
 * {@inheritDoc}
 */
@Override public void run(){
  try {
    if (this.jobClient.getConfiguration().getBoolean(ConfigConstants.JOBCLIENT_SHUTDOWN_TERMINATEJOB_KEY,ConfigConstants.DEFAULT_JOBCLIENT_SHUTDOWN_TERMINATEJOB)) {
      this.jobClient.cancelJob();
    }
    this.jobClient.close();
  }
 catch (  IOException ioe) {
    LOG.warn(StringUtils.stringifyException(ioe));
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void run(){
  try {
    if (this.jobClient.getConfiguration().getBoolean(ConfigConstants.JOBCLIENT_SHUTDOWN_TERMINATEJOB_KEY,ConfigConstants.DEFAULT_JOBCLIENT_SHUTDOWN_TERMINATEJOB)) {
      System.out.println(AbstractEvent.timestampToString(System.currentTimeMillis()) + ""String_Node_Str"");
      this.jobClient.cancelJob();
    }
    this.jobClient.close();
  }
 catch (  IOException ioe) {
    LOG.warn(StringUtils.stringifyException(ioe));
  }
}"
88167,"/** 
 * Submits the job assigned to this job client to the job manager and queries the job manager about the progress of the job until it is either finished or aborted.
 * @throws IOException thrown if an error occurred while transmitting the request
 * @throws JobExecutionException thrown if the job has been aborted either by the user or as a result of an error
 */
public void submitJobAndWait() throws IOException, JobExecutionException {
synchronized (this.jobSubmitClient) {
    final JobSubmissionResult submissionResult=this.jobSubmitClient.submitJob(this.jobGraph);
    if (submissionResult.getReturnCode() == AbstractJobResult.ReturnCode.ERROR) {
      LOG.error(""String_Node_Str"" + submissionResult.getDescription());
      throw new JobExecutionException(submissionResult.getDescription(),false);
    }
 else {
      Runtime.getRuntime().addShutdownHook(this.jobCleanUp);
    }
  }
  long sleep=0;
  try {
    final IntegerRecord interval=this.jobSubmitClient.getRecommendedPollingInterval();
    sleep=interval.getValue() * 1000;
  }
 catch (  IOException ioe) {
    logErrorAndRethrow(StringUtils.stringifyException(ioe));
  }
  try {
    Thread.sleep(sleep / 2);
  }
 catch (  InterruptedException e) {
    logErrorAndRethrow(StringUtils.stringifyException(e));
  }
  while (true) {
    if (Thread.interrupted()) {
      logErrorAndRethrow(""String_Node_Str"");
    }
    final JobProgressResult jobProgressResult=getJobProgress();
    if (jobProgressResult == null) {
      logErrorAndRethrow(""String_Node_Str"");
    }
    if (jobProgressResult.getReturnCode() == AbstractJobResult.ReturnCode.ERROR) {
      logErrorAndRethrow(""String_Node_Str"" + jobProgressResult.getDescription());
    }
    final Iterator<AbstractEvent> it=jobProgressResult.getEvents();
    while (it.hasNext()) {
      final AbstractEvent event=it.next();
      if (this.processedEvents.contains(event)) {
        continue;
      }
      System.out.println(event.toString());
      this.processedEvents.add(event);
      if (event instanceof JobEvent) {
        final JobEvent jobEvent=(JobEvent)event;
        final JobStatus jobStatus=jobEvent.getCurrentJobStatus();
        if (jobStatus == JobStatus.FINISHED) {
          Runtime.getRuntime().removeShutdownHook(this.jobCleanUp);
          return;
        }
 else         if (jobStatus == JobStatus.CANCELED || jobStatus == JobStatus.FAILED) {
          Runtime.getRuntime().removeShutdownHook(this.jobCleanUp);
          LOG.info(jobEvent.getOptionalMessage());
          throw new JobExecutionException(jobEvent.getOptionalMessage(),(jobStatus == JobStatus.CANCELED) ? true : false);
        }
      }
    }
    cleanUpOldEvents(sleep);
    try {
      Thread.sleep(sleep);
    }
 catch (    InterruptedException e) {
      logErrorAndRethrow(StringUtils.stringifyException(e));
    }
  }
}","/** 
 * Submits the job assigned to this job client to the job manager and queries the job manager about the progress of the job until it is either finished or aborted.
 * @throws IOException thrown if an error occurred while transmitting the request
 * @throws JobExecutionException thrown if the job has been aborted either by the user or as a result of an error
 */
public void submitJobAndWait() throws IOException, JobExecutionException {
synchronized (this.jobSubmitClient) {
    final JobSubmissionResult submissionResult=this.jobSubmitClient.submitJob(this.jobGraph);
    if (submissionResult.getReturnCode() == AbstractJobResult.ReturnCode.ERROR) {
      LOG.error(""String_Node_Str"" + submissionResult.getDescription());
      throw new JobExecutionException(submissionResult.getDescription(),false);
    }
    Runtime.getRuntime().addShutdownHook(this.jobCleanUp);
  }
  long sleep=0;
  try {
    final IntegerRecord interval=this.jobSubmitClient.getRecommendedPollingInterval();
    sleep=interval.getValue() * 1000;
  }
 catch (  IOException ioe) {
    logErrorAndRethrow(StringUtils.stringifyException(ioe));
  }
  try {
    Thread.sleep(sleep / 2);
  }
 catch (  InterruptedException e) {
    logErrorAndRethrow(StringUtils.stringifyException(e));
  }
  while (true) {
    if (Thread.interrupted()) {
      logErrorAndRethrow(""String_Node_Str"");
    }
    final JobProgressResult jobProgressResult=getJobProgress();
    if (jobProgressResult == null) {
      logErrorAndRethrow(""String_Node_Str"");
    }
    if (jobProgressResult.getReturnCode() == AbstractJobResult.ReturnCode.ERROR) {
      logErrorAndRethrow(""String_Node_Str"" + jobProgressResult.getDescription());
    }
    final Iterator<AbstractEvent> it=jobProgressResult.getEvents();
    while (it.hasNext()) {
      final AbstractEvent event=it.next();
      if (this.processedEvents.contains(event)) {
        continue;
      }
      System.out.println(event.toString());
      this.processedEvents.add(event);
      if (event instanceof JobEvent) {
        final JobEvent jobEvent=(JobEvent)event;
        final JobStatus jobStatus=jobEvent.getCurrentJobStatus();
        if (jobStatus == JobStatus.FINISHED) {
          Runtime.getRuntime().removeShutdownHook(this.jobCleanUp);
          return;
        }
 else         if (jobStatus == JobStatus.CANCELED || jobStatus == JobStatus.FAILED) {
          Runtime.getRuntime().removeShutdownHook(this.jobCleanUp);
          LOG.info(jobEvent.getOptionalMessage());
          throw new JobExecutionException(jobEvent.getOptionalMessage(),(jobStatus == JobStatus.CANCELED) ? true : false);
        }
      }
    }
    cleanUpOldEvents(sleep);
    try {
      Thread.sleep(sleep);
    }
 catch (    InterruptedException e) {
      logErrorAndRethrow(StringUtils.stringifyException(e));
    }
  }
}"
88168,"/** 
 * Converts the timestamp of an event from its ""milliseconds since beginning the epoch"" representation into a unified string representation.
 * @param timestamp the timestamp in milliseconds since the beginning of ""the epoch""
 * @return the string unified representation of the timestamp
 */
protected static String timestampToString(long timestamp){
  return dateFormatter.format(new Date(timestamp));
}","/** 
 * Converts the timestamp of an event from its ""milliseconds since beginning the epoch"" representation into a unified string representation.
 * @param timestamp the timestamp in milliseconds since the beginning of ""the epoch""
 * @return the string unified representation of the timestamp
 */
public static String timestampToString(long timestamp){
  return dateFormatter.format(new Date(timestamp));
}"
88169,"/** 
 * {@inheritDoc}
 */
@Override public synchronized void requestInstance(JobID jobID,Configuration conf,InstanceType instanceType) throws InstanceException {
  for (  ClusterInstance host : registeredHosts.values()) {
    final AllocatedSlice slice=host.createSlice(instanceType,jobID);
    if (slice != null) {
      List<AllocatedSlice> allocatedSlices=this.slicesOfJobs.get(jobID);
      if (allocatedSlices == null) {
        allocatedSlices=new ArrayList<AllocatedSlice>();
        this.slicesOfJobs.put(jobID,allocatedSlices);
      }
      allocatedSlices.add(slice);
      if (this.instanceListener != null) {
        ClusterInstanceNotifier clusterInstanceNotifier=new ClusterInstanceNotifier(this.instanceListener,slice);
        clusterInstanceNotifier.start();
      }
      return;
    }
  }
  throw new InstanceException(""String_Node_Str"");
}","/** 
 * {@inheritDoc}
 */
@Override public synchronized void requestInstance(JobID jobID,Configuration conf,InstanceType instanceType) throws InstanceException {
  AllocatedSlice slice=null;
  for (  final ClusterInstance host : this.registeredHosts.values()) {
    if (host.getType().equals(instanceType)) {
      slice=host.createSlice(instanceType,jobID);
      if (slice != null) {
        break;
      }
    }
  }
  if (slice == null) {
    for (    final ClusterInstance host : this.registeredHosts.values()) {
      slice=host.createSlice(instanceType,jobID);
      if (slice != null) {
        break;
      }
    }
  }
  if (slice == null) {
    throw new InstanceException(""String_Node_Str"");
  }
  List<AllocatedSlice> allocatedSlices=this.slicesOfJobs.get(jobID);
  if (allocatedSlices == null) {
    allocatedSlices=new ArrayList<AllocatedSlice>();
    this.slicesOfJobs.put(jobID,allocatedSlices);
  }
  allocatedSlices.add(slice);
  if (this.instanceListener != null) {
    ClusterInstanceNotifier clusterInstanceNotifier=new ClusterInstanceNotifier(this.instanceListener,slice);
    clusterInstanceNotifier.start();
  }
}"
88170,"/** 
 * @param connection
 * @param outputVertex
 * @param inputVertex
 * @throws JobGraphDefinitionException
 * @throws CompilerException
 */
private void connectJobVertices(PactConnection connection,AbstractJobVertex outputVertex,AbstractJobVertex inputVertex) throws JobGraphDefinitionException, CompilerException {
  ChannelType channelType=null;
switch (connection.getShipStrategy()) {
case FORWARD:
case PARTITION_LOCAL_HASH:
    int sourceDOP=connection.getSourcePact().getDegreeOfParallelism();
  int sourceInnerDOP=connection.getSourcePact().getInstancesPerMachine();
int sourceNumInstances=(int)Math.ceil((double)sourceDOP / (double)sourceInnerDOP);
int targetDOP=connection.getTargetPact().getDegreeOfParallelism();
int targetInnerDOP=connection.getTargetPact().getInstancesPerMachine();
int targetNumInstances=(int)Math.ceil((double)targetDOP / (double)targetInnerDOP);
channelType=sourceNumInstances == targetNumInstances ? ChannelType.INMEMORY : ChannelType.NETWORK;
break;
case PARTITION_HASH:
case BROADCAST:
case SFR:
channelType=ChannelType.NETWORK;
break;
default :
throw new IllegalArgumentException(""String_Node_Str"" + connection.getShipStrategy().name());
}
TaskConfig outputConfig=new TaskConfig(outputVertex.getConfiguration());
TaskConfig inputConfig=new TaskConfig(inputVertex.getConfiguration());
TaskConfig tempConfig=null;
switch (connection.getTempMode()) {
case NONE:
outputVertex.connectTo(inputVertex,channelType,CompressionLevel.NO_COMPRESSION);
outputConfig.addOutputShipStrategy(connection.getShipStrategy());
inputConfig.addInputShipStrategy(connection.getShipStrategy());
break;
case TEMP_SENDER_SIDE:
int pd=connection.getSourcePact().getDegreeOfParallelism();
JobTaskVertex tempVertex=generateTempVertex(connection.getSourcePact().getPactContract().getUserCodeClass(),pd);
outputVertex.connectTo(tempVertex,ChannelType.INMEMORY,CompressionLevel.NO_COMPRESSION);
tempVertex.connectTo(inputVertex,channelType,CompressionLevel.NO_COMPRESSION);
tempConfig=new TaskConfig(tempVertex.getConfiguration());
outputConfig.addOutputShipStrategy(ShipStrategy.FORWARD);
tempConfig.addInputShipStrategy(ShipStrategy.FORWARD);
tempConfig.addOutputShipStrategy(connection.getShipStrategy());
inputConfig.addInputShipStrategy(connection.getShipStrategy());
break;
case TEMP_RECEIVER_SIDE:
int pdr=connection.getTargetPact().getDegreeOfParallelism();
tempVertex=generateTempVertex(connection.getSourcePact().getPactContract().getUserCodeClass(),pdr);
outputVertex.connectTo(tempVertex,channelType,CompressionLevel.NO_COMPRESSION);
tempVertex.connectTo(inputVertex,ChannelType.INMEMORY,CompressionLevel.NO_COMPRESSION);
tempConfig=new TaskConfig(tempVertex.getConfiguration());
outputConfig.addOutputShipStrategy(connection.getShipStrategy());
tempConfig.addInputShipStrategy(connection.getShipStrategy());
tempConfig.addOutputShipStrategy(ShipStrategy.FORWARD);
inputConfig.addInputShipStrategy(ShipStrategy.FORWARD);
break;
default :
throw new CompilerException(""String_Node_Str"" + connection.getTempMode());
}
}","/** 
 * @param connection
 * @param outputVertex
 * @param inputVertex
 * @throws JobGraphDefinitionException
 * @throws CompilerException
 */
private void connectJobVertices(PactConnection connection,AbstractJobVertex outputVertex,AbstractJobVertex inputVertex) throws JobGraphDefinitionException, CompilerException {
  ChannelType channelType=null;
switch (connection.getShipStrategy()) {
case FORWARD:
case PARTITION_LOCAL_HASH:
    int sourceDOP=connection.getSourcePact().getDegreeOfParallelism();
  int sourceInnerDOP=connection.getSourcePact().getInstancesPerMachine();
int sourceNumInstances=(int)Math.ceil((double)sourceDOP / (double)sourceInnerDOP);
int targetDOP=connection.getTargetPact().getDegreeOfParallelism();
int targetInnerDOP=connection.getTargetPact().getInstancesPerMachine();
int targetNumInstances=(int)Math.ceil((double)targetDOP / (double)targetInnerDOP);
channelType=sourceNumInstances == targetNumInstances ? ChannelType.INMEMORY : ChannelType.NETWORK;
break;
case PARTITION_HASH:
case BROADCAST:
case SFR:
channelType=ChannelType.NETWORK;
break;
default :
throw new IllegalArgumentException(""String_Node_Str"" + connection.getShipStrategy().name());
}
TaskConfig outputConfig=new TaskConfig(outputVertex.getConfiguration());
TaskConfig inputConfig=new TaskConfig(inputVertex.getConfiguration());
TaskConfig tempConfig=null;
switch (connection.getTempMode()) {
case NONE:
outputVertex.connectTo(inputVertex,channelType,CompressionLevel.NO_COMPRESSION);
outputConfig.addOutputShipStrategy(connection.getShipStrategy());
inputConfig.addInputShipStrategy(connection.getShipStrategy());
break;
case TEMP_SENDER_SIDE:
int pd=connection.getSourcePact().getDegreeOfParallelism();
JobTaskVertex tempVertex=generateTempVertex(connection.getSourcePact().getPactContract().getUserCodeClass(),pd);
outputVertex.connectTo(tempVertex,ChannelType.INMEMORY,CompressionLevel.NO_COMPRESSION);
tempVertex.connectTo(inputVertex,channelType,CompressionLevel.NO_COMPRESSION);
tempVertex.setVertexToShareInstancesWith(outputVertex);
tempConfig=new TaskConfig(tempVertex.getConfiguration());
outputConfig.addOutputShipStrategy(ShipStrategy.FORWARD);
tempConfig.addInputShipStrategy(ShipStrategy.FORWARD);
tempConfig.addOutputShipStrategy(connection.getShipStrategy());
inputConfig.addInputShipStrategy(connection.getShipStrategy());
break;
case TEMP_RECEIVER_SIDE:
int pdr=connection.getTargetPact().getDegreeOfParallelism();
tempVertex=generateTempVertex(connection.getSourcePact().getPactContract().getUserCodeClass(),pdr);
outputVertex.connectTo(tempVertex,channelType,CompressionLevel.NO_COMPRESSION);
tempVertex.connectTo(inputVertex,ChannelType.INMEMORY,CompressionLevel.NO_COMPRESSION);
tempVertex.setVertexToShareInstancesWith(inputVertex);
tempConfig=new TaskConfig(tempVertex.getConfiguration());
outputConfig.addOutputShipStrategy(connection.getShipStrategy());
tempConfig.addInputShipStrategy(connection.getShipStrategy());
tempConfig.addOutputShipStrategy(ShipStrategy.FORWARD);
inputConfig.addInputShipStrategy(ShipStrategy.FORWARD);
break;
default :
throw new CompilerException(""String_Node_Str"" + connection.getTempMode());
}
}"
88171,"/** 
 * This method implements the post-visit during the depth-first traversal. When the post visit happens, all of the descendants have been processed, so this method connects all of the current node's predecessors to the current node.
 * @param node The node currently processed during the post-visit.
 * @see eu.stratosphere.pact.common.plan.Visitor#postVisit(eu.stratosphere.pact.common.plan.Visitable)
 */
@Override public void postVisit(OptimizerNode node){
  try {
    AbstractJobVertex inputVertex=this.vertices.get(node);
    List<PactConnection> incomingConns=node.getIncomingConnections();
    if (incomingConns == null) {
      return;
    }
    for (    PactConnection connection : node.getIncomingConnections()) {
      AbstractJobVertex outputVertex=this.vertices.get(connection.getSourcePact());
      if (outputVertex == null) {
        throw new Exception(""String_Node_Str"");
      }
switch (connection.getShipStrategy()) {
case FORWARD:
        connectWithForwardStrategy(connection,outputVertex,inputVertex);
      break;
case PARTITION_HASH:
    connectWithPartitionStrategy(connection,outputVertex,inputVertex);
  break;
case BROADCAST:
connectWithBroadcastStrategy(connection,outputVertex,inputVertex);
break;
case PARTITION_RANGE:
if (isDistributionGiven(connection)) {
connectWithGivenDistributionPartitionRangeStrategy(connection,outputVertex,inputVertex);
}
 else {
connectWithSamplingPartitionRangeStrategy(connection,outputVertex,inputVertex);
}
break;
case SFR:
connectWithSFRStrategy(connection,outputVertex,inputVertex);
default :
throw new Exception(""String_Node_Str"" + connection.getShipStrategy());
}
}
}
 catch (Exception e) {
throw new CompilerException(""String_Node_Str"" + e.getMessage(),e);
}
}","/** 
 * This method implements the post-visit during the depth-first traversal. When the post visit happens, all of the descendants have been processed, so this method connects all of the current node's predecessors to the current node.
 * @param node The node currently processed during the post-visit.
 * @see eu.stratosphere.pact.common.plan.Visitor#postVisit(eu.stratosphere.pact.common.plan.Visitable)
 */
@Override public void postVisit(OptimizerNode node){
  try {
    AbstractJobVertex inputVertex=this.vertices.get(node);
    List<PactConnection> incomingConns=node.getIncomingConnections();
    if (incomingConns == null) {
      return;
    }
    for (    PactConnection connection : node.getIncomingConnections()) {
      AbstractJobVertex outputVertex=this.vertices.get(connection.getSourcePact());
      if (outputVertex == null) {
        throw new Exception(""String_Node_Str"");
      }
switch (connection.getShipStrategy()) {
case FORWARD:
        connectWithForwardStrategy(connection,outputVertex,inputVertex);
      break;
case PARTITION_LOCAL_HASH:
case PARTITION_HASH:
    connectWithPartitionStrategy(connection,outputVertex,inputVertex);
  break;
case BROADCAST:
connectWithBroadcastStrategy(connection,outputVertex,inputVertex);
break;
case PARTITION_RANGE:
if (isDistributionGiven(connection)) {
connectWithGivenDistributionPartitionRangeStrategy(connection,outputVertex,inputVertex);
}
 else {
connectWithSamplingPartitionRangeStrategy(connection,outputVertex,inputVertex);
}
break;
case SFR:
connectWithSFRStrategy(connection,outputVertex,inputVertex);
default :
throw new Exception(""String_Node_Str"" + connection.getShipStrategy());
}
}
}
 catch (Exception e) {
throw new CompilerException(""String_Node_Str"" + e.getMessage(),e);
}
}"
88172,"/** 
 * @param sinkNode
 * @return
 * @throws CompilerException
 */
private JobOutputVertex generateDataSinkVertex(OptimizerNode sinkNode) throws CompilerException {
  DataSinkNode sNode=(DataSinkNode)sinkNode;
  GenericDataSink<?,?> sinkContract=sNode.getPactContract();
  JobGenericOutputVertex sinkVertex=new JobGenericOutputVertex(sinkNode.getPactContract().getName(),this.jobGraph);
  sinkVertex.setOutputClass(DataSinkTask.class);
  TaskConfig sinkConfig=new TaskConfig(sinkVertex.getConfiguration());
  sinkConfig.setStubClass(sinkContract.getUserCodeClass());
  sinkConfig.setStubParameters(sinkContract.getParameters());
switch (sinkNode.getLocalStrategy()) {
case NONE:
    sinkConfig.setLocalStrategy(LocalStrategy.NONE);
  break;
default :
throw new CompilerException(""String_Node_Str"" + sinkNode.getName() + ""String_Node_Str""+ sinkNode.getLocalStrategy());
}
return sinkVertex;
}","/** 
 * @param sinkNode
 * @return
 * @throws CompilerException
 */
private JobOutputVertex generateDataSinkVertex(OptimizerNode sinkNode) throws CompilerException {
  DataSinkNode sNode=(DataSinkNode)sinkNode;
  GenericDataSink<?,?> sinkContract=sNode.getPactContract();
  JobGenericOutputVertex sinkVertex=new JobGenericOutputVertex(sinkNode.getPactContract().getName(),this.jobGraph);
  sinkVertex.setOutputClass(DataSinkTask.class);
  sinkVertex.getConfiguration().setInteger(DataSinkTask.DEGREE_OF_PARALLELISM_KEY,sinkNode.getDegreeOfParallelism());
  TaskConfig sinkConfig=new TaskConfig(sinkVertex.getConfiguration());
  sinkConfig.setStubClass(sinkContract.getUserCodeClass());
  sinkConfig.setStubParameters(sinkContract.getParameters());
switch (sinkNode.getLocalStrategy()) {
case NONE:
    sinkConfig.setLocalStrategy(LocalStrategy.NONE);
  break;
default :
throw new CompilerException(""String_Node_Str"" + sinkNode.getName() + ""String_Node_Str""+ sinkNode.getLocalStrategy());
}
return sinkVertex;
}"
88173,"/** 
 * {@inheritDoc}
 */
@Override public int getMaximumNumberOfSubtasks(){
  if (!(this.format instanceof FileOutputFormat)) {
    return -1;
  }
  final String pathName=this.config.getStubParameter(FileOutputFormat.FILE_PARAMETER_KEY,null);
  final Path path;
  if (pathName == null) {
    return 0;
  }
  try {
    path=new Path(pathName);
  }
 catch (  Throwable t) {
    return 0;
  }
  try {
    final FileSystem fs=path.getFileSystem();
    try {
      final FileStatus f=fs.getFileStatus(path);
      if (f == null) {
        return 1;
      }
      if (f.isDir()) {
        return -1;
      }
 else {
        return 1;
      }
    }
 catch (    FileNotFoundException fnfex) {
      fs.mkdirs(path);
      return -1;
    }
  }
 catch (  IOException e) {
    return 1;
  }
}","/** 
 * {@inheritDoc}
 */
@Override public int getMaximumNumberOfSubtasks(){
  if (!(this.format instanceof FileOutputFormat)) {
    return -1;
  }
  final String pathName=this.config.getStubParameter(FileOutputFormat.FILE_PARAMETER_KEY,null);
  final Path path;
  if (pathName == null) {
    return 0;
  }
  try {
    path=new Path(pathName);
  }
 catch (  Throwable t) {
    return 0;
  }
  try {
    final FileSystem fs=path.getFileSystem();
    try {
      final FileStatus f=fs.getFileStatus(path);
      if (f == null) {
        return 1;
      }
      if (f.isDir())       return -1;
 else       return 1;
    }
 catch (    FileNotFoundException fnfex) {
      int dop=getRuntimeConfiguration().getInteger(DEGREE_OF_PARALLELISM_KEY,-1);
      if (dop == 1) {
        return 1;
      }
      fs.mkdirs(path);
      return -1;
    }
  }
 catch (  IOException e) {
    return 1;
  }
}"
88174,"/** 
 * Initializes the input reader of the MapTask.
 * @throws RuntimeException Thrown if no input ship strategy was provided.
 */
private void initInputReader() throws RuntimeException {
  RecordDeserializer<KeyValuePair<Key,Value>> deserializerPartition=new KeyValuePairDeserializer<Key,Value>(stub.getOutKeyType(),(Class<Value>)((Class<? extends Value>)PactNull.class));
  RecordDeserializer<KeyValuePair<Key,Value>> deserializerReader=new KeyValuePairDeserializer<Key,Value>(stub.getOutKeyType(),stub.getOutValueType());
  DistributionPattern dpPartition=null;
switch (config.getInputShipStrategy(0)) {
case FORWARD:
    dpPartition=new PointwiseDistributionPattern();
  break;
case PARTITION_HASH:
case PARTITION_RANGE:
case BROADCAST:
dpPartition=new BipartiteDistributionPattern();
break;
default :
throw new RuntimeException(""String_Node_Str"");
}
DistributionPattern dpReader=null;
switch (config.getInputShipStrategy(0)) {
case FORWARD:
dpReader=new PointwiseDistributionPattern();
break;
case PARTITION_HASH:
case PARTITION_RANGE:
case BROADCAST:
dpReader=new BipartiteDistributionPattern();
break;
default :
throw new RuntimeException(""String_Node_Str"");
}
readerPartition=new RecordReader<KeyValuePair<Key,Value>>(this,deserializerPartition,dpPartition);
readerStub=new RecordReader<KeyValuePair<Key,Value>>(this,deserializerReader,dpReader);
}","/** 
 * Initializes the input reader of the MapTask.
 * @throws RuntimeException Thrown if no input ship strategy was provided.
 */
private void initInputReader() throws RuntimeException {
  RecordDeserializer<KeyValuePair<Key,Value>> deserializerPartition=new KeyValuePairDeserializer<Key,Value>(stub.getOutKeyType(),(Class<Value>)((Class<? extends Value>)PactNull.class));
  RecordDeserializer<KeyValuePair<Key,Value>> deserializerReader=new KeyValuePairDeserializer<Key,Value>(stub.getOutKeyType(),stub.getOutValueType());
  DistributionPattern dpPartition=null;
switch (config.getInputShipStrategy(0)) {
case FORWARD:
    dpPartition=new PointwiseDistributionPattern();
  break;
case PARTITION_HASH:
case PARTITION_RANGE:
case BROADCAST:
dpPartition=new BipartiteDistributionPattern();
break;
default :
throw new RuntimeException(""String_Node_Str"");
}
DistributionPattern dpReader=null;
switch (config.getInputShipStrategy(1)) {
case FORWARD:
dpReader=new PointwiseDistributionPattern();
break;
case PARTITION_HASH:
case PARTITION_RANGE:
case BROADCAST:
dpReader=new BipartiteDistributionPattern();
break;
default :
throw new RuntimeException(""String_Node_Str"");
}
readerPartition=new RecordReader<KeyValuePair<Key,Value>>(this,deserializerPartition,dpPartition);
readerStub=new RecordReader<KeyValuePair<Key,Value>>(this,deserializerReader,dpReader);
}"
88175,"/** 
 * {@inheritDoc}
 */
@Override public ManagementVertex next(){
  if (traversalStack.isEmpty()) {
    if (numVisitedEntryVertices < 0) {
      return null;
    }
    TraversalEntry newentry;
    if (forward) {
      newentry=new TraversalEntry(managementGraph.getInputVertex(this.startStage,numVisitedEntryVertices),0,0);
    }
 else {
      newentry=new TraversalEntry(managementGraph.getOutputVertex(this.startStage,numVisitedEntryVertices),0,0);
    }
    traversalStack.push(newentry);
  }
  final ManagementVertex returnVertex=traversalStack.peek().getManagementVertex();
  do {
    final TraversalEntry te=traversalStack.peek();
    final ManagementVertex candidateVertex=getCandidateVertex(te,forward);
    if (candidateVertex == null) {
      traversalStack.pop();
    }
 else {
      final TraversalEntry newte=new TraversalEntry(candidateVertex,0,0);
      traversalStack.add(newte);
      break;
    }
  }
 while (!traversalStack.isEmpty());
  alreadyVisited.add(returnVertex);
  return returnVertex;
}","/** 
 * {@inheritDoc}
 */
@Override public ManagementVertex next(){
  if (this.traversalStack.isEmpty()) {
    if (this.numVisitedEntryVertices < 0) {
      return null;
    }
    TraversalEntry newentry;
    if (this.forward) {
      newentry=new TraversalEntry(this.managementGraph.getInputVertex(this.startStage,this.numVisitedEntryVertices),0,0);
    }
 else {
      newentry=new TraversalEntry(managementGraph.getOutputVertex(this.startStage,this.numVisitedEntryVertices),0,0);
    }
    this.traversalStack.push(newentry);
    this.alreadyVisited.add(newentry.getManagementVertex());
  }
  final ManagementVertex returnVertex=this.traversalStack.peek().getManagementVertex();
  do {
    final TraversalEntry te=this.traversalStack.peek();
    final ManagementVertex candidateVertex=getCandidateVertex(te,this.forward);
    if (candidateVertex == null) {
      this.traversalStack.pop();
    }
 else {
      final TraversalEntry newte=new TraversalEntry(candidateVertex,0,0);
      this.traversalStack.push(newte);
      this.alreadyVisited.add(candidateVertex);
      break;
    }
  }
 while (!this.traversalStack.isEmpty());
  return returnVertex;
}"
88176,"/** 
 * {@inheritDoc}
 */
@Override public boolean hasNext(){
  if (traversalStack.isEmpty()) {
    if (numVisitedEntryVertices < 0) {
      return false;
    }
    numVisitedEntryVertices++;
    if (forward) {
      if (managementGraph.getNumberOfInputVertices(this.startStage) <= numVisitedEntryVertices) {
        return false;
      }
    }
 else {
      if (managementGraph.getNumberOfOutputVertices(this.startStage) <= numVisitedEntryVertices) {
        return false;
      }
    }
  }
  return true;
}","/** 
 * {@inheritDoc}
 */
@Override public boolean hasNext(){
  if (this.traversalStack.isEmpty()) {
    if (this.numVisitedEntryVertices < 0) {
      return false;
    }
    ++this.numVisitedEntryVertices;
    if (this.forward) {
      if (this.managementGraph.getNumberOfInputVertices(this.startStage) <= this.numVisitedEntryVertices) {
        return false;
      }
    }
 else {
      if (this.managementGraph.getNumberOfOutputVertices(this.startStage) <= this.numVisitedEntryVertices) {
        return false;
      }
    }
  }
  return true;
}"
88177,"/** 
 * Returns a candidate vertex which could potentially be visited next because it is reachable from the currently considered vertex.
 * @param te the traversal entry for the current source vertex
 * @param forward <code>true</code> if the graph should be traversed in correct order, <code>false</code> to traverse it in reverse order
 * @return a candidate vertex which could potentially be visited next
 */
private ManagementVertex getCandidateVertex(final TraversalEntry te,final boolean forward){
  if (forward) {
    while (true) {
      if (this.confinedToStage && te.getCurrentChannel() == 0) {
        while (currentGateLeadsToOtherStage(te,this.forward)) {
          te.increaseCurrentGate();
        }
      }
      if (te.getCurrentGate() >= te.getManagementVertex().getNumberOfOutputGates()) {
        break;
      }
      if (te.getCurrentChannel() >= te.getManagementVertex().getOutputGate(te.getCurrentGate()).getNumberOfForwardEdges()) {
        te.increaseCurrentGate();
        te.resetCurrentChannel();
      }
 else {
        final ManagementEdge forwardEdge=te.getManagementVertex().getOutputGate(te.getCurrentGate()).getForwardEdge(te.getCurrentChannel());
        final ManagementVertex target=forwardEdge.getTarget().getVertex();
        te.increaseCurrentChannel();
        if (!alreadyVisited.contains(target)) {
          return target;
        }
      }
    }
  }
 else {
    while (true) {
      if (this.confinedToStage && te.getCurrentChannel() == 0) {
        while (currentGateLeadsToOtherStage(te,this.forward)) {
          te.increaseCurrentGate();
        }
      }
      if (te.getCurrentGate() >= te.getManagementVertex().getNumberOfInputGates()) {
        break;
      }
      if (te.getCurrentChannel() >= te.getManagementVertex().getInputGate(te.getCurrentGate()).getNumberOfBackwardEdges()) {
        te.increaseCurrentGate();
        te.resetCurrentChannel();
      }
 else {
        final ManagementEdge backwardEdge=te.getManagementVertex().getInputGate(te.getCurrentGate()).getBackwardEdge(te.getCurrentChannel());
        final ManagementVertex source=backwardEdge.getSource().getVertex();
        if (source == null) {
          LOG.error(""String_Node_Str"");
        }
        te.increaseCurrentChannel();
        if (!alreadyVisited.contains(source)) {
          return source;
        }
      }
    }
  }
  return null;
}","/** 
 * Returns a candidate vertex which could potentially be visited next because it is reachable from the currently considered vertex.
 * @param te the traversal entry for the current source vertex
 * @param forward <code>true</code> if the graph should be traversed in correct order, <code>false</code> to traverse it in reverse order
 * @return a candidate vertex which could potentially be visited next
 */
private ManagementVertex getCandidateVertex(final TraversalEntry te,final boolean forward){
  if (forward) {
    while (true) {
      if (this.confinedToStage && te.getCurrentChannel() == 0) {
        while (currentGateLeadsToOtherStage(te,this.forward)) {
          te.increaseCurrentGate();
        }
      }
      if (te.getCurrentGate() >= te.getManagementVertex().getNumberOfOutputGates()) {
        break;
      }
      if (te.getCurrentChannel() >= te.getManagementVertex().getOutputGate(te.getCurrentGate()).getNumberOfForwardEdges()) {
        te.increaseCurrentGate();
        te.resetCurrentChannel();
      }
 else {
        final ManagementEdge forwardEdge=te.getManagementVertex().getOutputGate(te.getCurrentGate()).getForwardEdge(te.getCurrentChannel());
        final ManagementVertex target=forwardEdge.getTarget().getVertex();
        te.increaseCurrentChannel();
        if (!alreadyVisited.contains(target)) {
          return target;
        }
      }
    }
  }
 else {
    while (true) {
      if (this.confinedToStage && te.getCurrentChannel() == 0) {
        while (currentGateLeadsToOtherStage(te,this.forward)) {
          te.increaseCurrentGate();
        }
      }
      if (te.getCurrentGate() >= te.getManagementVertex().getNumberOfInputGates()) {
        break;
      }
      if (te.getCurrentChannel() >= te.getManagementVertex().getInputGate(te.getCurrentGate()).getNumberOfBackwardEdges()) {
        te.increaseCurrentGate();
        te.resetCurrentChannel();
      }
 else {
        final ManagementEdge backwardEdge=te.getManagementVertex().getInputGate(te.getCurrentGate()).getBackwardEdge(te.getCurrentChannel());
        final ManagementVertex source=backwardEdge.getSource().getVertex();
        if (source == null) {
          LOG.error(""String_Node_Str"");
        }
        te.increaseCurrentChannel();
        if (!this.alreadyVisited.contains(source)) {
          return source;
        }
      }
    }
  }
  return null;
}"
88178,"/** 
 * Creates a new management graph iterator. This constructor can be used to traverse only specific parts of the graph starting at <code>startVertex</code>. The iterator will not switch to the next input/output vertex of an output/input vertex has been reached.
 * @param managementGraph the management graph that should be traversed
 * @param startVertex the vertex to start the traversal from
 * @param forward <code>true</code> if the graph should be traversed in correct order, <code>false</code> to reverse it in reverse order
 */
public ManagementGraphIterator(final ManagementGraph managementGraph,final ManagementVertex startVertex,final boolean forward){
  this.managementGraph=managementGraph;
  this.forward=forward;
  this.numVisitedEntryVertices=-1;
  this.startStage=0;
  this.confinedToStage=false;
  final TraversalEntry te=new TraversalEntry(startVertex,0,0);
  traversalStack.push(te);
}","/** 
 * Creates a new management graph iterator. This constructor can be used to traverse only specific parts of the graph starting at <code>startVertex</code>. The iterator will not switch to the next input/output vertex of an output/input vertex has been reached.
 * @param managementGraph the management graph that should be traversed
 * @param startVertex the vertex to start the traversal from
 * @param forward <code>true</code> if the graph should be traversed in correct order, <code>false</code> to reverse it in reverse order
 */
public ManagementGraphIterator(final ManagementGraph managementGraph,final ManagementVertex startVertex,final boolean forward){
  this.managementGraph=managementGraph;
  this.forward=forward;
  this.numVisitedEntryVertices=-1;
  this.startStage=0;
  this.confinedToStage=false;
  final TraversalEntry te=new TraversalEntry(startVertex,0,0);
  this.traversalStack.push(te);
  this.alreadyVisited.add(te.getManagementVertex());
}"
88179,"/** 
 * {@inheritDoc}
 */
@Override public ManagementGroupVertex next(){
  if (this.traversalStack.isEmpty()) {
    final TraversalEntry newentry=new TraversalEntry(this.entryVertices.get(this.numVisitedEntryVertices),0);
    this.traversalStack.push(newentry);
  }
  final ManagementGroupVertex returnVertex=this.traversalStack.peek().getGroupVertex();
  do {
    final TraversalEntry te=this.traversalStack.peek();
    final ManagementGroupVertex candidateVertex=getCandidateVertex(te,forward);
    if (candidateVertex == null) {
      this.traversalStack.pop();
    }
 else {
      final TraversalEntry newte=new TraversalEntry(candidateVertex,0);
      this.traversalStack.add(newte);
      break;
    }
  }
 while (!this.traversalStack.isEmpty());
  this.alreadyVisited.add(returnVertex);
  return returnVertex;
}","/** 
 * {@inheritDoc}
 */
@Override public ManagementGroupVertex next(){
  if (this.traversalStack.isEmpty()) {
    final TraversalEntry newentry=new TraversalEntry(this.entryVertices.get(this.numVisitedEntryVertices),0);
    this.traversalStack.push(newentry);
    this.alreadyVisited.add(newentry.getGroupVertex());
  }
  final ManagementGroupVertex returnVertex=this.traversalStack.peek().getGroupVertex();
  do {
    final TraversalEntry te=this.traversalStack.peek();
    final ManagementGroupVertex candidateVertex=getCandidateVertex(te,forward);
    if (candidateVertex == null) {
      this.traversalStack.pop();
    }
 else {
      final TraversalEntry newte=new TraversalEntry(candidateVertex,0);
      this.traversalStack.push(newte);
      this.alreadyVisited.add(newte.getGroupVertex());
      break;
    }
  }
 while (!this.traversalStack.isEmpty());
  return returnVertex;
}"
88180,"/** 
 * Collects all input group vertices (i.e. vertices with no incoming edge or incoming edges from other stages) in the given stage and adds them to an internal list.
 * @param stage the number of the stage whose input vertices should be collected
 */
private void collectStartVertices(final ManagementStage stage){
  for (int i=0; i < stage.getNumberOfGroupVertices(); i++) {
    final ManagementGroupVertex groupVertex=stage.getGroupVertex(i);
    if (forward) {
      if ((groupVertex.getNumberOfBackwardEdges() == 0) || ((this.stage >= 0) && allConnectionsFromOtherStage(groupVertex,true))) {
        this.entryVertices.add(groupVertex);
      }
    }
 else {
      if ((groupVertex.getNumberOfForwardEdges() == 0) || ((this.stage >= 0) && allConnectionsFromOtherStage(groupVertex,false))) {
        this.entryVertices.add(groupVertex);
      }
    }
  }
}","/** 
 * Collects all input group vertices (i.e. vertices with no incoming edge or incoming edges from other stages) in the given stage and adds them to an internal list.
 * @param stage the number of the stage whose input vertices should be collected
 */
private void collectStartVertices(final ManagementStage stage){
  for (int i=0; i < stage.getNumberOfGroupVertices(); i++) {
    final ManagementGroupVertex groupVertex=stage.getGroupVertex(i);
    if (this.forward) {
      if ((groupVertex.getNumberOfBackwardEdges() == 0) || ((this.stage >= 0) && allConnectionsFromOtherStage(groupVertex,true))) {
        this.entryVertices.add(groupVertex);
      }
    }
 else {
      if ((groupVertex.getNumberOfForwardEdges() == 0) || ((this.stage >= 0) && allConnectionsFromOtherStage(groupVertex,false))) {
        this.entryVertices.add(groupVertex);
      }
    }
  }
}"
88181,"/** 
 * Creates a new management group vertex iterator.
 * @param managementGraph the management graph that should be traversed
 * @param forward <code>true</code> if the graph should be traversed in correct order, <code>false</code> to reverse it in reverse order
 * @param stage the number of the stage whose vertices should be traversed or -1 if all stages should be included in the traversal
 */
public ManagementGroupVertexIterator(final ManagementGraph managementGraph,final boolean forward,final int stage){
  this.forward=forward;
  this.stage=stage;
  if (stage < 0) {
    for (int i=0; i < managementGraph.getNumberOfStages(); i++) {
      collectStartVertices(managementGraph.getStage(i));
    }
  }
 else {
    if (stage < managementGraph.getNumberOfStages()) {
      collectStartVertices(managementGraph.getStage(stage));
    }
  }
  if (this.entryVertices.size() > 0) {
    final TraversalEntry te=new TraversalEntry(this.entryVertices.get(0),0);
    this.traversalStack.push(te);
  }
}","/** 
 * Creates a new management group vertex iterator.
 * @param managementGraph the management graph that should be traversed
 * @param forward <code>true</code> if the graph should be traversed in correct order, <code>false</code> to reverse it in reverse order
 * @param stage the number of the stage whose vertices should be traversed or -1 if all stages should be included in the traversal
 */
public ManagementGroupVertexIterator(final ManagementGraph managementGraph,final boolean forward,final int stage){
  this.forward=forward;
  this.stage=stage;
  if (stage < 0) {
    for (int i=0; i < managementGraph.getNumberOfStages(); i++) {
      collectStartVertices(managementGraph.getStage(i));
    }
  }
 else {
    if (stage < managementGraph.getNumberOfStages()) {
      collectStartVertices(managementGraph.getStage(stage));
    }
  }
  if (this.entryVertices.size() > 0) {
    final TraversalEntry te=new TraversalEntry(this.entryVertices.get(0),0);
    this.traversalStack.push(te);
    this.alreadyVisited.add(te.getGroupVertex());
  }
}"
88182,"/** 
 * {@inheritDoc}
 */
@Override public ExecutionVertex next(){
  if (traversalStack.isEmpty()) {
    if (numVisitedEntryVertices < 0) {
      return null;
    }
    TraversalEntry newentry;
    if (forward) {
      newentry=new TraversalEntry(executionGraph.getInputVertex(this.startStage,numVisitedEntryVertices),0,0);
    }
 else {
      newentry=new TraversalEntry(executionGraph.getOutputVertex(this.startStage,numVisitedEntryVertices),0,0);
    }
    traversalStack.push(newentry);
  }
  final ExecutionVertex returnVertex=traversalStack.peek().getExecutionVertex();
  do {
    final TraversalEntry te=traversalStack.peek();
    final ExecutionVertex candidateVertex=getCandidateVertex(te,forward);
    if (candidateVertex == null) {
      traversalStack.pop();
    }
 else {
      final TraversalEntry newte=new TraversalEntry(candidateVertex,0,0);
      traversalStack.add(newte);
      break;
    }
  }
 while (!traversalStack.isEmpty());
  alreadyVisited.add(returnVertex);
  return returnVertex;
}","/** 
 * {@inheritDoc}
 */
@Override public ExecutionVertex next(){
  if (this.traversalStack.isEmpty()) {
    if (this.numVisitedEntryVertices < 0) {
      return null;
    }
    TraversalEntry newentry;
    if (this.forward) {
      newentry=new TraversalEntry(this.executionGraph.getInputVertex(this.startStage,this.numVisitedEntryVertices),0,0);
    }
 else {
      newentry=new TraversalEntry(this.executionGraph.getOutputVertex(this.startStage,this.numVisitedEntryVertices),0,0);
    }
    this.traversalStack.push(newentry);
    this.alreadyVisited.add(newentry.getExecutionVertex());
  }
  final ExecutionVertex returnVertex=this.traversalStack.peek().getExecutionVertex();
  do {
    final TraversalEntry te=this.traversalStack.peek();
    final ExecutionVertex candidateVertex=getCandidateVertex(te,forward);
    if (candidateVertex == null) {
      this.traversalStack.pop();
    }
 else {
      final TraversalEntry newte=new TraversalEntry(candidateVertex,0,0);
      this.traversalStack.push(newte);
      this.alreadyVisited.add(candidateVertex);
      break;
    }
  }
 while (!this.traversalStack.isEmpty());
  return returnVertex;
}"
88183,"/** 
 * Creates a new execution graph iterator. This constructor can be used to traverse only specific parts of the graph starting at <code>startVertex</code>. The iterator will not switch to the next input/output vertex of an output/input vertex has been reached.
 * @param executionGraph the execution graph that should be traversed
 * @param startVertex the vertex to start the traversal from
 * @param forward <code>true</code> if the graph should be traversed in correct order, <code>false</code> to reverse it in reverse order
 */
public ExecutionGraphIterator(ExecutionGraph executionGraph,ExecutionVertex startVertex,boolean forward){
  this.executionGraph=executionGraph;
  this.forward=forward;
  this.numVisitedEntryVertices=-1;
  this.startStage=0;
  this.confinedToStage=false;
  final TraversalEntry te=new TraversalEntry(startVertex,0,0);
  traversalStack.push(te);
}","/** 
 * Creates a new execution graph iterator. This constructor can be used to traverse only specific parts of the graph starting at <code>startVertex</code>. The iterator will not switch to the next input/output vertex of an output/input vertex has been reached.
 * @param executionGraph the execution graph that should be traversed
 * @param startVertex the vertex to start the traversal from
 * @param forward <code>true</code> if the graph should be traversed in correct order, <code>false</code> to reverse it in reverse order
 */
public ExecutionGraphIterator(ExecutionGraph executionGraph,ExecutionVertex startVertex,boolean forward){
  this.executionGraph=executionGraph;
  this.forward=forward;
  this.numVisitedEntryVertices=-1;
  this.startStage=0;
  this.confinedToStage=false;
  final TraversalEntry te=new TraversalEntry(startVertex,0,0);
  this.traversalStack.push(te);
  this.alreadyVisited.add(startVertex);
}"
88184,"/** 
 * {@inheritDoc}
 */
@Override public boolean hasNext(){
  if (traversalStack.isEmpty()) {
    if (numVisitedEntryVertices < 0) {
      return false;
    }
    numVisitedEntryVertices++;
    if (forward) {
      if (executionGraph.getNumberOfInputVertices(this.startStage) <= numVisitedEntryVertices) {
        return false;
      }
    }
 else {
      if (executionGraph.getNumberOfOutputVertices(this.startStage) <= numVisitedEntryVertices) {
        return false;
      }
    }
  }
  return true;
}","/** 
 * {@inheritDoc}
 */
@Override public boolean hasNext(){
  if (this.traversalStack.isEmpty()) {
    if (this.numVisitedEntryVertices < 0) {
      return false;
    }
    ++this.numVisitedEntryVertices;
    if (this.forward) {
      if (this.executionGraph.getNumberOfInputVertices(this.startStage) <= this.numVisitedEntryVertices) {
        return false;
      }
    }
 else {
      if (this.executionGraph.getNumberOfOutputVertices(this.startStage) <= this.numVisitedEntryVertices) {
        return false;
      }
    }
  }
  return true;
}"
88185,"/** 
 * Returns a candidate vertex which could potentially be visited next because it is reachable from the currently considered vertex.
 * @param te the traversal entry for the current source vertex
 * @param forward <code>true</code> if the graph should be traversed in correct order, <code>false</code> to traverse it in reverse order
 * @return a candidate vertex which could potentially be visited next
 */
private ExecutionVertex getCandidateVertex(TraversalEntry te,boolean forward){
  if (forward) {
    while (true) {
      if (this.confinedToStage && te.getCurrentChannel() == 0) {
        while (currentGateLeadsToOtherStage(te,this.forward)) {
          te.increaseCurrentGate();
        }
      }
      if (te.getCurrentGate() >= te.getExecutionVertex().getEnvironment().getNumberOfOutputGates()) {
        break;
      }
      if (te.getCurrentChannel() >= te.getExecutionVertex().getEnvironment().getOutputGate(te.getCurrentGate()).getNumberOfOutputChannels()) {
        te.increaseCurrentGate();
        te.resetCurrentChannel();
      }
 else {
        final AbstractOutputChannel<? extends Record> outputChannel=te.getExecutionVertex().getEnvironment().getOutputGate(te.getCurrentGate()).getOutputChannel(te.getCurrentChannel());
        final ExecutionVertex tmp=executionGraph.getVertexByChannelID(outputChannel.getConnectedChannelID());
        if (tmp == null) {
          LOG.error(""String_Node_Str"");
        }
        te.increaseCurrentChannel();
        if (!alreadyVisited.contains(tmp)) {
          return tmp;
        }
      }
    }
  }
 else {
    while (true) {
      if (te.getCurrentGate() >= te.getExecutionVertex().getEnvironment().getNumberOfInputGates()) {
        break;
      }
      if (te.getCurrentChannel() >= te.getExecutionVertex().getEnvironment().getInputGate(te.getCurrentGate()).getNumberOfInputChannels()) {
        te.increaseCurrentGate();
        te.resetCurrentChannel();
      }
 else {
        final AbstractInputChannel<? extends Record> inputChannel=te.getExecutionVertex().getEnvironment().getInputGate(te.getCurrentGate()).getInputChannel(te.getCurrentChannel());
        final ExecutionVertex tmp=executionGraph.getVertexByChannelID(inputChannel.getConnectedChannelID());
        if (tmp == null) {
          LOG.error(""String_Node_Str"");
        }
        te.increaseCurrentChannel();
        if (!alreadyVisited.contains(tmp)) {
          return tmp;
        }
      }
    }
  }
  return null;
}","/** 
 * Returns a candidate vertex which could potentially be visited next because it is reachable from the currently considered vertex.
 * @param te the traversal entry for the current source vertex
 * @param forward <code>true</code> if the graph should be traversed in correct order, <code>false</code> to traverse it in reverse order
 * @return a candidate vertex which could potentially be visited next
 */
private ExecutionVertex getCandidateVertex(TraversalEntry te,boolean forward){
  if (forward) {
    while (true) {
      if (this.confinedToStage && te.getCurrentChannel() == 0) {
        while (currentGateLeadsToOtherStage(te,this.forward)) {
          te.increaseCurrentGate();
        }
      }
      if (te.getCurrentGate() >= te.getExecutionVertex().getEnvironment().getNumberOfOutputGates()) {
        break;
      }
      if (te.getCurrentChannel() >= te.getExecutionVertex().getEnvironment().getOutputGate(te.getCurrentGate()).getNumberOfOutputChannels()) {
        te.increaseCurrentGate();
        te.resetCurrentChannel();
      }
 else {
        final AbstractOutputChannel<? extends Record> outputChannel=te.getExecutionVertex().getEnvironment().getOutputGate(te.getCurrentGate()).getOutputChannel(te.getCurrentChannel());
        final ExecutionVertex tmp=this.executionGraph.getVertexByChannelID(outputChannel.getConnectedChannelID());
        if (tmp == null) {
          LOG.error(""String_Node_Str"");
        }
        te.increaseCurrentChannel();
        if (!this.alreadyVisited.contains(tmp)) {
          return tmp;
        }
      }
    }
  }
 else {
    while (true) {
      if (te.getCurrentGate() >= te.getExecutionVertex().getEnvironment().getNumberOfInputGates()) {
        break;
      }
      if (te.getCurrentChannel() >= te.getExecutionVertex().getEnvironment().getInputGate(te.getCurrentGate()).getNumberOfInputChannels()) {
        te.increaseCurrentGate();
        te.resetCurrentChannel();
      }
 else {
        final AbstractInputChannel<? extends Record> inputChannel=te.getExecutionVertex().getEnvironment().getInputGate(te.getCurrentGate()).getInputChannel(te.getCurrentChannel());
        final ExecutionVertex tmp=this.executionGraph.getVertexByChannelID(inputChannel.getConnectedChannelID());
        if (tmp == null) {
          LOG.error(""String_Node_Str"");
        }
        te.increaseCurrentChannel();
        if (!this.alreadyVisited.contains(tmp)) {
          return tmp;
        }
      }
    }
  }
  return null;
}"
88186,"/** 
 * Takes all JAR files that are contained in this program's JAR file and extracts them to the system's temp directory.
 * @return The file names of the extracted temporary files.
 * @throws IOException Thrown, if the extraction process failed.
 */
public File[] extractContainedLibaries() throws IOException {
  Random rnd=new Random();
  try {
    final JarFile jar=new JarFile(jarFile);
    final List<JarEntry> containedJarFileEntries=new ArrayList<JarEntry>();
    Enumeration<JarEntry> entries=jar.entries();
    while (entries.hasMoreElements()) {
      JarEntry entry=entries.nextElement();
      String name=entry.getName();
      if (name.length() > 8 && name.startsWith(""String_Node_Str"") && name.endsWith(""String_Node_Str"")) {
        containedJarFileEntries.add(entry);
      }
    }
    if (containedJarFileEntries.isEmpty()) {
      return null;
    }
    this.extractedTempLibraries=new File[containedJarFileEntries.size()];
    for (int i=0; i < this.extractedTempLibraries.length; i++) {
      final JarEntry entry=containedJarFileEntries.get(i);
      String name=entry.getName();
      name=name.replace(File.separatorChar,'_');
      File tempFile=File.createTempFile(String.valueOf(Math.abs(rnd.nextInt()) + ""String_Node_Str""),entry.getName());
      this.extractedTempLibraries[i]=tempFile;
      OutputStream out=null;
      InputStream in=null;
      try {
        out=new FileOutputStream(tempFile);
        in=new BufferedInputStream(jar.getInputStream(entry));
        byte[] buffer=new byte[1024];
        int numRead=0;
        while ((numRead=in.read(buffer)) != -1) {
          out.write(buffer,0,numRead);
        }
      }
  finally {
        if (out != null) {
          out.close();
        }
        if (in != null) {
          in.close();
        }
      }
    }
    return this.extractedTempLibraries;
  }
 catch (  IOException ioex) {
    throw ioex;
  }
catch (  Throwable t) {
    throw new IOException(""String_Node_Str"",t);
  }
}","/** 
 * Takes all JAR files that are contained in this program's JAR file and extracts them to the system's temp directory.
 * @return The file names of the extracted temporary files.
 * @throws IOException Thrown, if the extraction process failed.
 */
public File[] extractContainedLibaries() throws IOException {
  Random rnd=new Random();
  try {
    final JarFile jar=new JarFile(jarFile);
    final List<JarEntry> containedJarFileEntries=new ArrayList<JarEntry>();
    Enumeration<JarEntry> entries=jar.entries();
    while (entries.hasMoreElements()) {
      JarEntry entry=entries.nextElement();
      String name=entry.getName();
      if (name.length() > 8 && name.startsWith(""String_Node_Str"") && name.endsWith(""String_Node_Str"")) {
        containedJarFileEntries.add(entry);
      }
    }
    if (containedJarFileEntries.isEmpty()) {
      return null;
    }
    this.extractedTempLibraries=new File[containedJarFileEntries.size()];
    for (int i=0; i < this.extractedTempLibraries.length; i++) {
      final JarEntry entry=containedJarFileEntries.get(i);
      String name=entry.getName();
      name=name.replace(File.separatorChar,'_');
      File tempFile=File.createTempFile(String.valueOf(Math.abs(rnd.nextInt()) + ""String_Node_Str""),name);
      this.extractedTempLibraries[i]=tempFile;
      OutputStream out=null;
      InputStream in=null;
      try {
        out=new FileOutputStream(tempFile);
        in=new BufferedInputStream(jar.getInputStream(entry));
        byte[] buffer=new byte[1024];
        int numRead=0;
        while ((numRead=in.read(buffer)) != -1) {
          out.write(buffer,0,numRead);
        }
      }
  finally {
        if (out != null) {
          out.close();
        }
        if (in != null) {
          in.close();
        }
      }
    }
    return this.extractedTempLibraries;
  }
 catch (  IOException ioex) {
    throw ioex;
  }
catch (  Throwable t) {
    throw new IOException(""String_Node_Str"",t);
  }
}"
88187,"@Override public boolean nextBlock(){
  if (this.closed) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (this.noMoreBlocks) {
    return false;
  }
  collectAllBuffers(this.emptySegments);
  this.bufferCurrentlyFilled=new Buffer.Output(this.emptySegments.remove(this.emptySegments.size() - 1));
  if (this.leftOverElement != null) {
    if (!this.bufferCurrentlyFilled.write(this.leftOverElement)) {
      throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"");
    }
    this.nextElement=this.leftOverElement;
    this.leftOverElement=null;
  }
  return true;
}","@Override public boolean nextBlock(){
  if (this.closed) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (this.noMoreBlocks) {
    return false;
  }
  collectAllBuffers(this.emptySegments);
  this.bufferCurrentlyFilled=new Buffer.Output(this.emptySegments.remove(this.emptySegments.size() - 1));
  T next=this.leftOverElement;
  this.leftOverElement=null;
  if (next == null) {
    if (this.input.hasNext()) {
      next=this.input.next();
    }
 else {
      this.noMoreBlocks=true;
      return false;
    }
  }
  if (!this.bufferCurrentlyFilled.write(next)) {
    throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"");
  }
  this.nextElement=next;
  return true;
}"
88188,"/** 
 * Runs a blocked nested loop strategy to build the Cartesian product and call the <code>cross()</code> method of the CrossStub implementation. The outer side is read using a BlockResettableIterator. The inner side is read using a SpillingResettableIterator.
 * @see eu.stratosphere.pact.runtime.resettable.SpillingResettableIterator
 * @see eu.stratosphere.pact.runtime.resettable.BlockResettableIterator
 * @param memoryManager The task manager's memory manager.
 * @param ioManager The task manager's IO manager
 * @param innerReader The inner reader of the nested loops.
 * @param outerReader The outer reader of the nested loops.
 * @throws RuntimeException Throws a RuntimeException if something fails during execution.
 */
private void runBlocked(MemoryManager memoryManager,IOManager ioManager,Iterator<KeyValuePair<Key,Value>> innerReader,Iterator<KeyValuePair<Key,Value>> outerReader) throws Exception {
  SpillingResettableIterator<KeyValuePair<Key,Value>> innerInput=null;
  BlockResettableIterator<KeyValuePair<Key,Value>> outerInput=null;
  try {
    final boolean firstInputIsOuter;
    if (this.config.getLocalStrategy() == LocalStrategy.NESTEDLOOP_BLOCKED_OUTER_SECOND) {
      try {
        innerInput=new SpillingResettableIterator<KeyValuePair<Key,Value>>(memoryManager,ioManager,innerReader,this.availableMemory / 2,new KeyValuePairDeserializer<Key,Value>(stub.getFirstInKeyType(),stub.getFirstInValueType()),this);
        this.spillingResetIt=innerInput;
      }
 catch (      MemoryAllocationException mae) {
        throw new RuntimeException(""String_Node_Str"",mae);
      }
      try {
        outerInput=new BlockResettableIterator<KeyValuePair<Key,Value>>(memoryManager,outerReader,this.availableMemory / 2,1,new KeyValuePairDeserializer<Key,Value>(stub.getSecondInKeyType(),stub.getSecondInValueType()),this);
        this.blockResetIt=outerInput;
      }
 catch (      MemoryAllocationException mae) {
        throw new RuntimeException(""String_Node_Str"",mae);
      }
      firstInputIsOuter=false;
    }
 else     if (this.config.getLocalStrategy() == LocalStrategy.NESTEDLOOP_BLOCKED_OUTER_FIRST) {
      try {
        innerInput=new SpillingResettableIterator<KeyValuePair<Key,Value>>(memoryManager,ioManager,innerReader,this.availableMemory / 2,new KeyValuePairDeserializer<Key,Value>(stub.getSecondInKeyType(),stub.getSecondInValueType()),this);
        this.spillingResetIt=innerInput;
      }
 catch (      MemoryAllocationException mae) {
        throw new RuntimeException(""String_Node_Str"",mae);
      }
      try {
        outerInput=new BlockResettableIterator<KeyValuePair<Key,Value>>(memoryManager,outerReader,this.availableMemory / 2,1,new KeyValuePairDeserializer<Key,Value>(stub.getFirstInKeyType(),stub.getFirstInValueType()),this);
        this.blockResetIt=outerInput;
      }
 catch (      MemoryAllocationException mae) {
        throw new RuntimeException(""String_Node_Str"",mae);
      }
      firstInputIsOuter=true;
    }
 else {
      throw new RuntimeException(""String_Node_Str"" + config.getLocalStrategy());
    }
    try {
      innerInput.open();
    }
 catch (    ServiceException se) {
      throw new RuntimeException(""String_Node_Str"",se);
    }
catch (    IOException ioe) {
      throw new RuntimeException(""String_Node_Str"",ioe);
    }
catch (    InterruptedException ie) {
      throw new RuntimeException(""String_Node_Str"",ie);
    }
    if (this.taskCanceled)     return;
    outerInput.open();
    if (LOG.isDebugEnabled()) {
      LOG.debug(getLogString(""String_Node_Str""));
      LOG.debug(getLogString(""String_Node_Str""));
    }
    this.stub.open();
    boolean moreOuterBlocks=false;
    do {
      while (!this.taskCanceled && innerInput.hasNext()) {
        KeyValuePair<Key,Value> innerPair=innerInput.next();
        while (!this.taskCanceled && outerInput.hasNext()) {
          KeyValuePair<Key,Value> outerPair=outerInput.next();
          if (firstInputIsOuter) {
            stub.cross(outerPair.getKey(),outerPair.getValue(),innerPair.getKey(),innerPair.getValue(),output);
          }
 else {
            stub.cross(innerPair.getKey(),innerPair.getValue(),outerPair.getKey(),outerPair.getValue(),output);
          }
          innerPair=innerInput.repeatLast();
        }
        outerInput.reset();
      }
      moreOuterBlocks=outerInput.nextBlock();
      if (moreOuterBlocks) {
        innerInput.reset();
      }
    }
 while (!this.taskCanceled && moreOuterBlocks);
    this.stub.close();
  }
 catch (  Exception ex) {
    if (!this.taskCanceled) {
      LOG.error(getLogString(""String_Node_Str""));
      throw ex;
    }
  }
 finally {
    Throwable t1=null, t2=null;
    try {
      if (innerInput != null) {
        innerInput.close();
      }
    }
 catch (    Throwable t) {
      LOG.warn(t);
      t1=t;
    }
    try {
      if (outerInput != null) {
        outerInput.close();
      }
    }
 catch (    Throwable t) {
      LOG.warn(t);
      t2=t;
    }
    if (t1 != null)     throw new RuntimeException(""String_Node_Str"",t1);
    if (t2 != null)     throw new RuntimeException(""String_Node_Str"",t2);
  }
}","/** 
 * Runs a blocked nested loop strategy to build the Cartesian product and call the <code>cross()</code> method of the CrossStub implementation. The outer side is read using a BlockResettableIterator. The inner side is read using a SpillingResettableIterator.
 * @see eu.stratosphere.pact.runtime.resettable.SpillingResettableIterator
 * @see eu.stratosphere.pact.runtime.resettable.BlockResettableIterator
 * @param memoryManager The task manager's memory manager.
 * @param ioManager The task manager's IO manager
 * @param innerReader The inner reader of the nested loops.
 * @param outerReader The outer reader of the nested loops.
 * @throws RuntimeException Throws a RuntimeException if something fails during execution.
 */
private void runBlocked(MemoryManager memoryManager,IOManager ioManager,Iterator<KeyValuePair<Key,Value>> innerReader,Iterator<KeyValuePair<Key,Value>> outerReader) throws Exception {
  SpillingResettableIterator<KeyValuePair<Key,Value>> innerInput=null;
  BlockResettableIterator<KeyValuePair<Key,Value>> outerInput=null;
  try {
    final boolean firstInputIsOuter;
    if (this.config.getLocalStrategy() == LocalStrategy.NESTEDLOOP_BLOCKED_OUTER_SECOND) {
      try {
        innerInput=new SpillingResettableIterator<KeyValuePair<Key,Value>>(memoryManager,ioManager,innerReader,this.availableMemory / 2,new KeyValuePairDeserializer<Key,Value>(stub.getFirstInKeyType(),stub.getFirstInValueType()),this);
        this.spillingResetIt=innerInput;
      }
 catch (      MemoryAllocationException mae) {
        throw new RuntimeException(""String_Node_Str"",mae);
      }
      try {
        outerInput=new BlockResettableIterator<KeyValuePair<Key,Value>>(memoryManager,outerReader,this.availableMemory / 2,1,new KeyValuePairDeserializer<Key,Value>(stub.getSecondInKeyType(),stub.getSecondInValueType()),this);
        this.blockResetIt=outerInput;
      }
 catch (      MemoryAllocationException mae) {
        throw new RuntimeException(""String_Node_Str"",mae);
      }
      firstInputIsOuter=false;
    }
 else     if (this.config.getLocalStrategy() == LocalStrategy.NESTEDLOOP_BLOCKED_OUTER_FIRST) {
      try {
        innerInput=new SpillingResettableIterator<KeyValuePair<Key,Value>>(memoryManager,ioManager,innerReader,this.availableMemory / 2,new KeyValuePairDeserializer<Key,Value>(stub.getSecondInKeyType(),stub.getSecondInValueType()),this);
        this.spillingResetIt=innerInput;
      }
 catch (      MemoryAllocationException mae) {
        throw new RuntimeException(""String_Node_Str"",mae);
      }
      try {
        outerInput=new BlockResettableIterator<KeyValuePair<Key,Value>>(memoryManager,outerReader,this.availableMemory / 2,1,new KeyValuePairDeserializer<Key,Value>(stub.getFirstInKeyType(),stub.getFirstInValueType()),this);
        this.blockResetIt=outerInput;
      }
 catch (      MemoryAllocationException mae) {
        throw new RuntimeException(""String_Node_Str"",mae);
      }
      firstInputIsOuter=true;
    }
 else {
      throw new RuntimeException(""String_Node_Str"" + config.getLocalStrategy());
    }
    try {
      innerInput.open();
    }
 catch (    ServiceException se) {
      throw new RuntimeException(""String_Node_Str"",se);
    }
catch (    IOException ioe) {
      throw new RuntimeException(""String_Node_Str"",ioe);
    }
catch (    InterruptedException ie) {
      throw new RuntimeException(""String_Node_Str"",ie);
    }
    if (this.taskCanceled)     return;
    outerInput.open();
    if (LOG.isDebugEnabled()) {
      LOG.debug(getLogString(""String_Node_Str""));
      LOG.debug(getLogString(""String_Node_Str""));
    }
    this.stub.open();
    boolean moreOuterBlocks=false;
    if (innerInput.hasNext()) {
      do {
        while (!this.taskCanceled && innerInput.hasNext()) {
          KeyValuePair<Key,Value> innerPair=innerInput.next();
          while (!this.taskCanceled && outerInput.hasNext()) {
            KeyValuePair<Key,Value> outerPair=outerInput.next();
            if (firstInputIsOuter) {
              stub.cross(outerPair.getKey(),outerPair.getValue(),innerPair.getKey(),innerPair.getValue(),output);
            }
 else {
              stub.cross(innerPair.getKey(),innerPair.getValue(),outerPair.getKey(),outerPair.getValue(),output);
            }
            innerPair=innerInput.repeatLast();
          }
          outerInput.reset();
        }
        moreOuterBlocks=outerInput.nextBlock();
        if (moreOuterBlocks) {
          innerInput.reset();
        }
      }
 while (!this.taskCanceled && moreOuterBlocks);
    }
    this.stub.close();
  }
 catch (  Exception ex) {
    if (!this.taskCanceled) {
      LOG.error(getLogString(""String_Node_Str""));
      throw ex;
    }
  }
 finally {
    Throwable t1=null, t2=null;
    try {
      if (innerInput != null) {
        innerInput.close();
      }
    }
 catch (    Throwable t) {
      LOG.warn(t);
      t1=t;
    }
    try {
      if (outerInput != null) {
        outerInput.close();
      }
    }
 catch (    Throwable t) {
      LOG.warn(t);
      t2=t;
    }
    if (t1 != null)     throw new RuntimeException(""String_Node_Str"",t1);
    if (t2 != null)     throw new RuntimeException(""String_Node_Str"",t2);
  }
}"
88189,"/** 
 * Move the iterator to the next memory block
 * @return true if a new memory block was loaded, false if there were no further records
 */
public boolean nextBlock();","/** 
 * Move the iterator to the next memory block. The next memory block starts at the first element that was not in the block before. A special case is when no record was in the block before, which happens when this function is invoked two times directly in a sequence, without calling hasNext() or next in between. Then the block moves one element.
 * @return true if a new memory block was loaded, false if there were no further records
 */
public boolean nextBlock();"
88190,"/** 
 * {@inheritDoc}
 */
@Override public void initialize(URI name) throws IOException {
  this.host=name.getHost();
  if (this.host == null) {
    LOG.debug(""String_Node_Str"");
    this.host=GlobalConfiguration.getString(S3_HOST_KEY,DEFAULT_S3_HOST);
  }
  this.port=name.getPort();
  if (this.port == -1) {
    LOG.debug(""String_Node_Str"");
    this.port=GlobalConfiguration.getInteger(S3_PORT_KEY,DEFAULT_S3_PORT);
  }
  final String userInfo=name.getUserInfo();
  String awsAccessKey=null;
  String awsSecretKey=null;
  if (userInfo != null) {
    final String[] splits=userInfo.split(""String_Node_Str"");
    if (splits.length > 1) {
      awsAccessKey=splits[0];
      awsSecretKey=splits[1];
    }
  }
  if (awsAccessKey == null) {
    LOG.debug(""String_Node_Str"");
    awsAccessKey=GlobalConfiguration.getString(S3_ACCESS_KEY_KEY,null);
    if (awsAccessKey == null) {
      throw new IOException(""String_Node_Str"");
    }
  }
  if (awsSecretKey == null) {
    LOG.debug(""String_Node_Str"");
    awsSecretKey=GlobalConfiguration.getString(S3_SECRET_KEY_KEY,null);
    if (awsSecretKey == null) {
      throw new IOException(""String_Node_Str"");
    }
  }
  final AWSCredentials credentials=new BasicAWSCredentials(awsAccessKey,awsSecretKey);
  this.s3Client=new AmazonS3Client(credentials);
  initializeDirectoryStructure(name);
}","/** 
 * {@inheritDoc}
 */
@Override public void initialize(URI name) throws IOException {
  this.host=name.getHost();
  if (this.host == null) {
    LOG.debug(""String_Node_Str"");
    this.host=GlobalConfiguration.getString(S3_HOST_KEY,DEFAULT_S3_HOST);
  }
  this.port=name.getPort();
  if (this.port == -1) {
    LOG.debug(""String_Node_Str"");
    this.port=GlobalConfiguration.getInteger(S3_PORT_KEY,DEFAULT_S3_PORT);
  }
  final String userInfo=name.getUserInfo();
  String awsAccessKey=null;
  String awsSecretKey=null;
  if (userInfo != null) {
    final String[] splits=userInfo.split(""String_Node_Str"");
    if (splits.length > 1) {
      awsAccessKey=URLDecoder.decode(splits[0],URL_ENCODE_CHARACTER);
      awsSecretKey=URLDecoder.decode(splits[1],URL_ENCODE_CHARACTER);
    }
  }
  if (awsAccessKey == null) {
    LOG.debug(""String_Node_Str"");
    awsAccessKey=GlobalConfiguration.getString(S3_ACCESS_KEY_KEY,null);
    if (awsAccessKey == null) {
      throw new IOException(""String_Node_Str"");
    }
  }
  if (awsSecretKey == null) {
    LOG.debug(""String_Node_Str"");
    awsSecretKey=GlobalConfiguration.getString(S3_SECRET_KEY_KEY,null);
    if (awsSecretKey == null) {
      throw new IOException(""String_Node_Str"");
    }
  }
  final AWSCredentials credentials=new BasicAWSCredentials(awsAccessKey,awsSecretKey);
  this.s3Client=new AmazonS3Client(credentials);
  initializeDirectoryStructure(name);
}"
88191,"public boolean hasAssignedChannels(){
  return (!this.assignedChannels.isEmpty());
}","boolean hasAssignedChannels(){
  return (!this.assignedChannels.isEmpty());
}"
88192,"public void removeAssignedChannel(final ChannelID channelID){
  if (!this.assignedChannels.remove(channelID)) {
    throw new IllegalStateException(channelID + ""String_Node_Str"");
  }
}","void removeAssignedChannel(final ChannelID channelID){
  if (!this.assignedChannels.remove(channelID)) {
    throw new IllegalStateException(channelID + ""String_Node_Str"");
  }
}"
88193,"protected void addAssignedChannel(final ChannelID channelID){
  this.assignedChannels.add(channelID);
}","void addAssignedChannel(final ChannelID channelID){
  if (!this.assignedChannels.add(channelID)) {
    throw new IllegalStateException(channelID + ""String_Node_Str"");
  }
}"
88194,"@Override public final synchronized Compressor getCompressor(final AbstractByteBufferedOutputChannel<?> outputChannel) throws CompressionException {
  final OutputGate<?> outputGate=outputChannel.getOutputGate();
  CompressorCacheEntry cacheEntry=this.compressorCache.get(outputGate);
  if (cacheEntry == null) {
    Compressor compressor=initNewCompressor(outputChannel);
    cacheEntry=new CompressorCacheEntry(compressor,outputGate);
    this.compressorCache.put(outputGate,cacheEntry);
    this.compressorMap.put(compressor,outputGate);
  }
  return cacheEntry.getCompressor();
}","@Override public final synchronized Compressor getCompressor(final AbstractByteBufferedOutputChannel<?> outputChannel) throws CompressionException {
  final OutputGate<?> outputGate=outputChannel.getOutputGate();
  CompressorCacheEntry cacheEntry=this.compressorCache.get(outputGate);
  if (cacheEntry == null) {
    Compressor compressor=initNewCompressor(outputChannel);
    cacheEntry=new CompressorCacheEntry(compressor);
    this.compressorCache.put(outputGate,cacheEntry);
    this.compressorMap.put(compressor,outputGate);
  }
  cacheEntry.addAssignedChannel(outputChannel.getID());
  return cacheEntry.getCompressor();
}"
88195,"@Override public final synchronized Decompressor getDecompressor(final AbstractByteBufferedInputChannel<?> inputChannel) throws CompressionException {
  final InputGate<?> inputGate=inputChannel.getInputGate();
  DecompressorCacheEntry cacheEntry=this.decompressorCache.get(inputGate);
  if (cacheEntry == null) {
    Decompressor decompressor=initNewDecompressor(inputChannel);
    cacheEntry=new DecompressorCacheEntry(decompressor,inputGate);
    this.decompressorCache.put(inputGate,cacheEntry);
    this.decompressorMap.put(decompressor,inputGate);
  }
  return cacheEntry.getDecompressor();
}","@Override public final synchronized Decompressor getDecompressor(final AbstractByteBufferedInputChannel<?> inputChannel) throws CompressionException {
  final InputGate<?> inputGate=inputChannel.getInputGate();
  DecompressorCacheEntry cacheEntry=this.decompressorCache.get(inputGate);
  if (cacheEntry == null) {
    Decompressor decompressor=initNewDecompressor(inputChannel);
    cacheEntry=new DecompressorCacheEntry(decompressor);
    this.decompressorCache.put(inputGate,cacheEntry);
    this.decompressorMap.put(decompressor,inputGate);
  }
  cacheEntry.addAssignedChannel(inputChannel.getID());
  return cacheEntry.getDecompressor();
}"
88196,"CompressorCacheEntry(final Compressor compressor,final OutputGate<?> outputGate){
  this.compressor=compressor;
  for (int i=0; i < outputGate.getNumberOfOutputChannels(); i++) {
    final AbstractOutputChannel<?> outputChannel=outputGate.getOutputChannel(i);
    addAssignedChannel(outputChannel.getID());
  }
}","CompressorCacheEntry(final Compressor compressor){
  this.compressor=compressor;
}"
88197,"DecompressorCacheEntry(final Decompressor decompressor,final InputGate<?> inputGate){
  this.decompressor=decompressor;
  for (int i=0; i < inputGate.getNumberOfInputChannels(); i++) {
    final AbstractInputChannel<?> inputChannel=inputGate.getInputChannel(i);
    addAssignedChannel(inputChannel.getID());
  }
}","DecompressorCacheEntry(final Decompressor decompressor){
  this.decompressor=decompressor;
}"
88198,"/** 
 * {@inheritDoc}
 */
@Override public void schedulJob(final ExecutionGraph executionGraph) throws SchedulingException {
  final Map<InstanceType,InstanceTypeDescription> availableInstances=getInstanceManager().getMapOfAvailableInstanceTypes();
  for (int i=0; i < executionGraph.getNumberOfStages(); i++) {
    final Map<InstanceType,Integer> requiredInstanceTypes=new HashMap<InstanceType,Integer>();
    final ExecutionStage stage=executionGraph.getStage(i);
    stage.collectRequiredInstanceTypes(requiredInstanceTypes,ExecutionState.CREATED);
    final Iterator<Map.Entry<InstanceType,Integer>> it=requiredInstanceTypes.entrySet().iterator();
    while (it.hasNext()) {
      final Map.Entry<InstanceType,Integer> entry=it.next();
      final InstanceTypeDescription descr=availableInstances.get(entry.getKey());
      if (descr == null) {
        throw new SchedulingException(""String_Node_Str"" + entry.getKey() + ""String_Node_Str"");
      }
      if (descr.getMaximumNumberOfAvailableInstances() != -1 && descr.getMaximumNumberOfAvailableInstances() < entry.getValue().intValue()) {
        throw new SchedulingException(""String_Node_Str"" + entry.getValue().intValue() + ""String_Node_Str""+ entry.getKey()+ ""String_Node_Str""+ descr.getMaximumNumberOfAvailableInstances()+ ""String_Node_Str"");
      }
    }
  }
  executionGraph.registerJobStatusListener(this);
  final ExecutionGraphIterator it2=new ExecutionGraphIterator(executionGraph,true);
  while (it2.hasNext()) {
    final ExecutionVertex vertex=it2.next();
    if (vertex.getExecutionState() != ExecutionState.CREATED) {
      LOG.error(""String_Node_Str"" + vertex + ""String_Node_Str""+ vertex.getExecutionState()+ ""String_Node_Str""+ ExecutionState.CREATED);
    }
    vertex.getEnvironment().registerExecutionListener(new QueueExecutionListener(this,vertex));
    vertex.setExecutionState(ExecutionState.SCHEDULED);
  }
  executionGraph.registerExecutionStageListener(this);
synchronized (this.jobQueue) {
    this.jobQueue.add(executionGraph);
  }
  final ExecutionStage executionStage=executionGraph.getCurrentExecutionStage();
  try {
    requestInstances(executionStage);
  }
 catch (  InstanceException e) {
    LOG.error(StringUtils.stringifyException(e));
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void schedulJob(final ExecutionGraph executionGraph) throws SchedulingException {
  final Map<InstanceType,InstanceTypeDescription> availableInstances=getInstanceManager().getMapOfAvailableInstanceTypes();
  for (int i=0; i < executionGraph.getNumberOfStages(); i++) {
    final Map<InstanceType,Integer> requiredInstanceTypes=new HashMap<InstanceType,Integer>();
    final ExecutionStage stage=executionGraph.getStage(i);
    stage.collectRequiredInstanceTypes(requiredInstanceTypes,ExecutionState.CREATED);
    final Iterator<Map.Entry<InstanceType,Integer>> it=requiredInstanceTypes.entrySet().iterator();
    while (it.hasNext()) {
      final Map.Entry<InstanceType,Integer> entry=it.next();
      final InstanceTypeDescription descr=availableInstances.get(entry.getKey());
      if (descr == null) {
        throw new SchedulingException(""String_Node_Str"" + entry.getKey() + ""String_Node_Str"");
      }
      if (descr.getMaximumNumberOfAvailableInstances() != -1 && descr.getMaximumNumberOfAvailableInstances() < entry.getValue().intValue()) {
        throw new SchedulingException(""String_Node_Str"" + entry.getValue().intValue() + ""String_Node_Str""+ entry.getKey()+ ""String_Node_Str""+ descr.getMaximumNumberOfAvailableInstances()+ ""String_Node_Str"");
      }
    }
  }
  executionGraph.registerJobStatusListener(this);
  final ExecutionGraphIterator it2=new ExecutionGraphIterator(executionGraph,true);
  while (it2.hasNext()) {
    final ExecutionVertex vertex=it2.next();
    if (vertex.getExecutionState() != ExecutionState.CREATED) {
      LOG.error(""String_Node_Str"" + vertex + ""String_Node_Str""+ vertex.getExecutionState()+ ""String_Node_Str""+ ExecutionState.CREATED);
    }
    vertex.getEnvironment().registerExecutionListener(new QueueExecutionListener(this,vertex));
    vertex.setExecutionState(ExecutionState.SCHEDULED);
  }
  executionGraph.registerExecutionStageListener(this);
synchronized (this.jobQueue) {
    this.jobQueue.add(executionGraph);
    final ExecutionStage executionStage=executionGraph.getCurrentExecutionStage();
    try {
      requestInstances(executionStage);
    }
 catch (    InstanceException e) {
      LOG.error(StringUtils.stringifyException(e));
    }
  }
}"
88199,"/** 
 * {@inheritDoc}
 */
@Override public void schedulJob(ExecutionGraph executionGraph) throws SchedulingException {
  final Map<InstanceType,InstanceTypeDescription> availableInstances=getInstanceManager().getMapOfAvailableInstanceTypes();
  for (int i=0; i < executionGraph.getNumberOfStages(); i++) {
    final Map<InstanceType,Integer> requiredInstanceTypes=new HashMap<InstanceType,Integer>();
    final ExecutionStage stage=executionGraph.getStage(i);
    stage.collectRequiredInstanceTypes(requiredInstanceTypes,ExecutionState.CREATED);
    final Iterator<Map.Entry<InstanceType,Integer>> it=requiredInstanceTypes.entrySet().iterator();
    while (it.hasNext()) {
      final Map.Entry<InstanceType,Integer> entry=it.next();
      final InstanceTypeDescription descr=availableInstances.get(entry.getKey());
      if (descr == null) {
        throw new SchedulingException(""String_Node_Str"" + entry.getKey() + ""String_Node_Str"");
      }
      if (descr.getMaximumNumberOfAvailableInstances() != -1 && descr.getMaximumNumberOfAvailableInstances() < entry.getValue().intValue()) {
        throw new SchedulingException(""String_Node_Str"" + entry.getValue().intValue() + ""String_Node_Str""+ entry.getKey()+ ""String_Node_Str""+ descr.getMaximumNumberOfAvailableInstances()+ ""String_Node_Str"");
      }
    }
  }
  executionGraph.registerJobStatusListener(this);
  final ExecutionGraphIterator it2=new ExecutionGraphIterator(executionGraph,true);
  while (it2.hasNext()) {
    final ExecutionVertex vertex=it2.next();
    if (vertex.getExecutionState() != ExecutionState.CREATED) {
      LOG.error(""String_Node_Str"" + vertex + ""String_Node_Str""+ vertex.getExecutionState()+ ""String_Node_Str""+ ExecutionState.CREATED);
    }
    vertex.getEnvironment().registerExecutionListener(new LocalExecutionListener(this,vertex));
    vertex.setExecutionState(ExecutionState.SCHEDULED);
  }
  executionGraph.registerExecutionStageListener(this);
synchronized (this.jobQueue) {
    this.jobQueue.add(executionGraph);
  }
  final ExecutionStage executionStage=executionGraph.getCurrentExecutionStage();
  try {
    requestInstances(executionStage);
  }
 catch (  InstanceException e) {
    LOG.error(StringUtils.stringifyException(e));
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void schedulJob(ExecutionGraph executionGraph) throws SchedulingException {
  final Map<InstanceType,InstanceTypeDescription> availableInstances=getInstanceManager().getMapOfAvailableInstanceTypes();
  for (int i=0; i < executionGraph.getNumberOfStages(); i++) {
    final Map<InstanceType,Integer> requiredInstanceTypes=new HashMap<InstanceType,Integer>();
    final ExecutionStage stage=executionGraph.getStage(i);
    stage.collectRequiredInstanceTypes(requiredInstanceTypes,ExecutionState.CREATED);
    final Iterator<Map.Entry<InstanceType,Integer>> it=requiredInstanceTypes.entrySet().iterator();
    while (it.hasNext()) {
      final Map.Entry<InstanceType,Integer> entry=it.next();
      final InstanceTypeDescription descr=availableInstances.get(entry.getKey());
      if (descr == null) {
        throw new SchedulingException(""String_Node_Str"" + entry.getKey() + ""String_Node_Str"");
      }
      if (descr.getMaximumNumberOfAvailableInstances() != -1 && descr.getMaximumNumberOfAvailableInstances() < entry.getValue().intValue()) {
        throw new SchedulingException(""String_Node_Str"" + entry.getValue().intValue() + ""String_Node_Str""+ entry.getKey()+ ""String_Node_Str""+ descr.getMaximumNumberOfAvailableInstances()+ ""String_Node_Str"");
      }
    }
  }
  executionGraph.registerJobStatusListener(this);
  final ExecutionGraphIterator it2=new ExecutionGraphIterator(executionGraph,true);
  while (it2.hasNext()) {
    final ExecutionVertex vertex=it2.next();
    if (vertex.getExecutionState() != ExecutionState.CREATED) {
      LOG.error(""String_Node_Str"" + vertex + ""String_Node_Str""+ vertex.getExecutionState()+ ""String_Node_Str""+ ExecutionState.CREATED);
    }
    vertex.getEnvironment().registerExecutionListener(new LocalExecutionListener(this,vertex));
    vertex.setExecutionState(ExecutionState.SCHEDULED);
  }
  executionGraph.registerExecutionStageListener(this);
synchronized (this.jobQueue) {
    this.jobQueue.add(executionGraph);
    final ExecutionStage executionStage=executionGraph.getCurrentExecutionStage();
    try {
      requestInstances(executionStage);
    }
 catch (    InstanceException e) {
      LOG.error(StringUtils.stringifyException(e));
    }
  }
}"
88200,"/** 
 * {@inheritDoc}
 */
@Override public void schedulJob(final ExecutionGraph executionGraph) throws SchedulingException {
  final Map<InstanceType,InstanceTypeDescription> availableInstances=getInstanceManager().getMapOfAvailableInstanceTypes();
  for (int i=0; i < executionGraph.getNumberOfStages(); i++) {
    final Map<InstanceType,Integer> requiredInstanceTypes=new HashMap<InstanceType,Integer>();
    final ExecutionStage stage=executionGraph.getStage(i);
    stage.collectRequiredInstanceTypes(requiredInstanceTypes,ExecutionState.CREATED);
    final Iterator<Map.Entry<InstanceType,Integer>> it=requiredInstanceTypes.entrySet().iterator();
    while (it.hasNext()) {
      final Map.Entry<InstanceType,Integer> entry=it.next();
      final InstanceTypeDescription descr=availableInstances.get(entry.getKey());
      if (descr == null) {
        throw new SchedulingException(""String_Node_Str"" + entry.getKey() + ""String_Node_Str"");
      }
      if (descr.getMaximumNumberOfAvailableInstances() != -1 && descr.getMaximumNumberOfAvailableInstances() < entry.getValue().intValue()) {
        throw new SchedulingException(""String_Node_Str"" + entry.getValue().intValue() + ""String_Node_Str""+ entry.getKey()+ ""String_Node_Str""+ descr.getMaximumNumberOfAvailableInstances()+ ""String_Node_Str"");
      }
    }
  }
  executionGraph.registerJobStatusListener(this);
  final ExecutionGraphIterator it2=new ExecutionGraphIterator(executionGraph,true);
  while (it2.hasNext()) {
    final ExecutionVertex vertex=it2.next();
    if (vertex.getExecutionState() != ExecutionState.CREATED) {
      LOG.error(""String_Node_Str"" + vertex + ""String_Node_Str""+ vertex.getExecutionState()+ ""String_Node_Str""+ ExecutionState.CREATED);
    }
    vertex.getEnvironment().registerExecutionListener(new QueueExecutionListener(this,vertex));
    vertex.setExecutionState(ExecutionState.SCHEDULED);
  }
  executionGraph.registerExecutionStageListener(this);
  final ExecutionStage executionStage=executionGraph.getCurrentExecutionStage();
  try {
    requestInstances(executionStage);
  }
 catch (  InstanceException e) {
    throw new SchedulingException(StringUtils.stringifyException(e));
  }
synchronized (this.jobQueue) {
    this.jobQueue.add(executionGraph);
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void schedulJob(final ExecutionGraph executionGraph) throws SchedulingException {
  final Map<InstanceType,InstanceTypeDescription> availableInstances=getInstanceManager().getMapOfAvailableInstanceTypes();
  for (int i=0; i < executionGraph.getNumberOfStages(); i++) {
    final Map<InstanceType,Integer> requiredInstanceTypes=new HashMap<InstanceType,Integer>();
    final ExecutionStage stage=executionGraph.getStage(i);
    stage.collectRequiredInstanceTypes(requiredInstanceTypes,ExecutionState.CREATED);
    final Iterator<Map.Entry<InstanceType,Integer>> it=requiredInstanceTypes.entrySet().iterator();
    while (it.hasNext()) {
      final Map.Entry<InstanceType,Integer> entry=it.next();
      final InstanceTypeDescription descr=availableInstances.get(entry.getKey());
      if (descr == null) {
        throw new SchedulingException(""String_Node_Str"" + entry.getKey() + ""String_Node_Str"");
      }
      if (descr.getMaximumNumberOfAvailableInstances() != -1 && descr.getMaximumNumberOfAvailableInstances() < entry.getValue().intValue()) {
        throw new SchedulingException(""String_Node_Str"" + entry.getValue().intValue() + ""String_Node_Str""+ entry.getKey()+ ""String_Node_Str""+ descr.getMaximumNumberOfAvailableInstances()+ ""String_Node_Str"");
      }
    }
  }
  executionGraph.registerJobStatusListener(this);
  final ExecutionGraphIterator it2=new ExecutionGraphIterator(executionGraph,true);
  while (it2.hasNext()) {
    final ExecutionVertex vertex=it2.next();
    if (vertex.getExecutionState() != ExecutionState.CREATED) {
      LOG.error(""String_Node_Str"" + vertex + ""String_Node_Str""+ vertex.getExecutionState()+ ""String_Node_Str""+ ExecutionState.CREATED);
    }
    vertex.getEnvironment().registerExecutionListener(new QueueExecutionListener(this,vertex));
    vertex.setExecutionState(ExecutionState.SCHEDULED);
  }
  executionGraph.registerExecutionStageListener(this);
synchronized (this.jobQueue) {
    this.jobQueue.add(executionGraph);
  }
  final ExecutionStage executionStage=executionGraph.getCurrentExecutionStage();
  try {
    requestInstances(executionStage);
  }
 catch (  InstanceException e) {
    LOG.error(StringUtils.stringifyException(e));
  }
}"
88201,"/** 
 * {@inheritDoc}
 */
@Override public void schedulJob(ExecutionGraph executionGraph) throws SchedulingException {
  final Map<InstanceType,InstanceTypeDescription> availableInstances=getInstanceManager().getMapOfAvailableInstanceTypes();
  for (int i=0; i < executionGraph.getNumberOfStages(); i++) {
    final Map<InstanceType,Integer> requiredInstanceTypes=new HashMap<InstanceType,Integer>();
    final ExecutionStage stage=executionGraph.getStage(i);
    stage.collectRequiredInstanceTypes(requiredInstanceTypes,ExecutionState.CREATED);
    final Iterator<Map.Entry<InstanceType,Integer>> it=requiredInstanceTypes.entrySet().iterator();
    while (it.hasNext()) {
      final Map.Entry<InstanceType,Integer> entry=it.next();
      final InstanceTypeDescription descr=availableInstances.get(entry.getKey());
      if (descr == null) {
        throw new SchedulingException(""String_Node_Str"" + entry.getKey() + ""String_Node_Str"");
      }
      if (descr.getMaximumNumberOfAvailableInstances() != -1 && descr.getMaximumNumberOfAvailableInstances() < entry.getValue().intValue()) {
        throw new SchedulingException(""String_Node_Str"" + entry.getValue().intValue() + ""String_Node_Str""+ entry.getKey()+ ""String_Node_Str""+ descr.getMaximumNumberOfAvailableInstances()+ ""String_Node_Str"");
      }
    }
  }
  executionGraph.registerJobStatusListener(this);
  final ExecutionGraphIterator it2=new ExecutionGraphIterator(executionGraph,true);
  while (it2.hasNext()) {
    final ExecutionVertex vertex=it2.next();
    if (vertex.getExecutionState() != ExecutionState.CREATED) {
      LOG.error(""String_Node_Str"" + vertex + ""String_Node_Str""+ vertex.getExecutionState()+ ""String_Node_Str""+ ExecutionState.CREATED);
    }
    vertex.getEnvironment().registerExecutionListener(new LocalExecutionListener(this,vertex));
    vertex.setExecutionState(ExecutionState.SCHEDULED);
  }
  executionGraph.registerExecutionStageListener(this);
  final ExecutionStage executionStage=executionGraph.getCurrentExecutionStage();
  try {
    requestInstances(executionStage);
  }
 catch (  InstanceException e) {
    throw new SchedulingException(StringUtils.stringifyException(e));
  }
synchronized (this.jobQueue) {
    this.jobQueue.add(executionGraph);
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void schedulJob(ExecutionGraph executionGraph) throws SchedulingException {
  final Map<InstanceType,InstanceTypeDescription> availableInstances=getInstanceManager().getMapOfAvailableInstanceTypes();
  for (int i=0; i < executionGraph.getNumberOfStages(); i++) {
    final Map<InstanceType,Integer> requiredInstanceTypes=new HashMap<InstanceType,Integer>();
    final ExecutionStage stage=executionGraph.getStage(i);
    stage.collectRequiredInstanceTypes(requiredInstanceTypes,ExecutionState.CREATED);
    final Iterator<Map.Entry<InstanceType,Integer>> it=requiredInstanceTypes.entrySet().iterator();
    while (it.hasNext()) {
      final Map.Entry<InstanceType,Integer> entry=it.next();
      final InstanceTypeDescription descr=availableInstances.get(entry.getKey());
      if (descr == null) {
        throw new SchedulingException(""String_Node_Str"" + entry.getKey() + ""String_Node_Str"");
      }
      if (descr.getMaximumNumberOfAvailableInstances() != -1 && descr.getMaximumNumberOfAvailableInstances() < entry.getValue().intValue()) {
        throw new SchedulingException(""String_Node_Str"" + entry.getValue().intValue() + ""String_Node_Str""+ entry.getKey()+ ""String_Node_Str""+ descr.getMaximumNumberOfAvailableInstances()+ ""String_Node_Str"");
      }
    }
  }
  executionGraph.registerJobStatusListener(this);
  final ExecutionGraphIterator it2=new ExecutionGraphIterator(executionGraph,true);
  while (it2.hasNext()) {
    final ExecutionVertex vertex=it2.next();
    if (vertex.getExecutionState() != ExecutionState.CREATED) {
      LOG.error(""String_Node_Str"" + vertex + ""String_Node_Str""+ vertex.getExecutionState()+ ""String_Node_Str""+ ExecutionState.CREATED);
    }
    vertex.getEnvironment().registerExecutionListener(new LocalExecutionListener(this,vertex));
    vertex.setExecutionState(ExecutionState.SCHEDULED);
  }
  executionGraph.registerExecutionStageListener(this);
synchronized (this.jobQueue) {
    this.jobQueue.add(executionGraph);
  }
  final ExecutionStage executionStage=executionGraph.getCurrentExecutionStage();
  try {
    requestInstances(executionStage);
  }
 catch (  InstanceException e) {
    LOG.error(StringUtils.stringifyException(e));
  }
}"
88202,"@Override public JsonNode evaluate(final JsonNode node,EvaluationContext context){
  if (node.isArray()) {
    if (node instanceof StreamArrayNode)     return new StreamArrayNode(new TransformingIterator<JsonNode,JsonNode>(node.iterator()){
      @Override protected JsonNode transform(      JsonNode inputObject){
        return inputObject.get(FieldAccess.this.field);
      }
    }
);
    ArrayNode arrayNode=new ArrayNode(NODE_FACTORY);
    for (int index=0, size=node.size(); index < size; index++)     arrayNode.add(node.get(index).get(this.field));
    return arrayNode;
  }
  return node.get(this.field);
}","@Override public JsonNode evaluate(final JsonNode node,EvaluationContext context){
  if (node.isArray()) {
    if (node instanceof StreamArrayNode)     return new StreamArrayNode(new ConversionIterator<JsonNode,JsonNode>(node.iterator()){
      @Override protected JsonNode convert(      JsonNode inputObject){
        return inputObject.get(FieldAccess.this.field);
      }
    }
);
    ArrayNode arrayNode=new ArrayNode(NODE_FACTORY);
    for (int index=0, size=node.size(); index < size; index++)     arrayNode.add(node.get(index).get(this.field));
    return arrayNode;
  }
  return node.get(this.field);
}"
88203,"@Override public Iterator<Evaluable> iterator(){
  return new TransformingIterator<Mapping,Evaluable>(mappings.iterator()){
    @Override protected Evaluable transform(    Mapping inputObject){
      return inputObject.getExpression();
    }
  }
;
}","@Override public Iterator<Evaluable> iterator(){
  return new ConversionIterator<Mapping,Evaluable>(mappings.iterator()){
    @Override protected Evaluable convert(    Mapping inputObject){
      return inputObject.getExpression();
    }
  }
;
}"
88204,"public static JsonNode union(JsonNode[] params){
  boolean hasStream=false;
  for (  JsonNode param : params) {
    if (!param.isArray())     throw new EvaluationException(""String_Node_Str"");
    hasStream|=param instanceof StreamArrayNode;
  }
  if (hasStream) {
    @SuppressWarnings(""String_Node_Str"") Iterator<JsonNode>[] iterators=new Iterator[params.length];
    for (int index=0; index < iterators.length; index++)     iterators[index]=params[index].iterator();
    return new StreamArrayNode(new ConcatenatingIterator<JsonNode>(iterators));
  }
  ArrayNode union=NODE_FACTORY.arrayNode();
  for (  JsonNode param : params)   union.addAll((ArrayNode)param);
  return union;
}","public static JsonNode union(JsonNode[] params){
  boolean hasStream=false;
  for (  JsonNode param : params) {
    if (!param.isArray())     throw new EvaluationException(""String_Node_Str"");
    hasStream|=param instanceof StreamArrayNode;
  }
  if (hasStream) {
    Iterator<?>[] iterators=new Iterator[params.length];
    for (int index=0; index < iterators.length; index++)     iterators[index]=params[index].iterator();
    return new StreamArrayNode(new ConcatenatingIterator<JsonNode>(iterators));
  }
  ArrayNode union=NODE_FACTORY.arrayNode();
  for (  JsonNode param : params)   union.addAll((ArrayNode)param);
  return union;
}"
88205,"public int getDistance(Signature actualSignature,Method method){
  Class<?>[] actualParamTypes=actualSignature.parameterTypes;
  int nonVarArgs=this.parameterTypes.length - 1;
  if (nonVarArgs > actualParamTypes.length)   return NO_MATCH;
  int distance=0;
  for (int index=0; index < nonVarArgs; index++) {
    if (!this.parameterTypes[index].isAssignableFrom(actualParamTypes[index]))     return NO_MATCH;
    distance+=ReflectUtil.getDistance(this.parameterTypes[index],actualParamTypes[index]);
  }
  if (nonVarArgs < actualParamTypes.length) {
    Class<?> varargType=this.parameterTypes[nonVarArgs].getComponentType();
    for (int index=nonVarArgs; index < actualParamTypes.length; index++) {
      if (!varargType.isAssignableFrom(actualParamTypes[index]))       return NO_MATCH;
      distance+=ReflectUtil.getDistance(varargType,actualParamTypes[index]) + 1;
    }
  }
  return distance;
}","@Override public int getDistance(Signature actualSignature){
  Class<?>[] actualParamTypes=actualSignature.parameterTypes;
  int nonVarArgs=this.parameterTypes.length - 1;
  if (nonVarArgs > actualParamTypes.length)   return NO_MATCH;
  int distance=0;
  for (int index=0; index < nonVarArgs; index++) {
    if (!this.parameterTypes[index].isAssignableFrom(actualParamTypes[index]))     return NO_MATCH;
    distance+=ReflectUtil.getDistance(this.parameterTypes[index],actualParamTypes[index]);
  }
  if (nonVarArgs < actualParamTypes.length) {
    Class<?> varargType=this.parameterTypes[nonVarArgs].getComponentType();
    for (int index=nonVarArgs; index < actualParamTypes.length; index++) {
      if (!varargType.isAssignableFrom(actualParamTypes[index]))       return NO_MATCH;
      distance+=ReflectUtil.getDistance(varargType,actualParamTypes[index]) + 1;
    }
  }
  return distance;
}"
88206,protected abstract T loadNext();,"/** 
 * Returns the next element or the result of   {@link #noMoreElements()}.
 * @return the next element
 */
protected abstract T loadNext();"
88207,"protected boolean isInitialized(){
  return this.initialized;
}","/** 
 * Return true if at least one element has been loaded.
 * @return true if at least one element has been loaded
 */
protected boolean isInitialized(){
  return this.initialized;
}"
88208,"protected T noMoreElements(){
  this.hasNext=false;
  return null;
}","/** 
 * Signal methods that should be invoked when no more elements are in the iterator.
 * @return a signal that no more elements are in this iterator
 */
protected T noMoreElements(){
  this.hasNext=false;
  return null;
}"
88209,"public ConcatenatingIterator(Iterator<T>... inputs){
  this.inputs=new LinkedList<Iterator<T>>(Arrays.asList(inputs));
}","/** 
 * Initializes a ConcatenatingIterator with an array of iterators. This constructor is not type-safe.
 * @param iterators the iterators to concatenate
 */
@SuppressWarnings(""String_Node_Str"") public ConcatenatingIterator(Iterator<?>... iterators){
  this.inputs=new LinkedList<Iterator<? extends T>>((Collection<? extends Iterator<? extends T>>)Arrays.asList(iterators));
}"
88210,"@Override protected T loadNext(){
  while (!this.inputs.isEmpty()) {
    Iterator<T> iterator=this.inputs.getFirst();
    if (!iterator.hasNext())     this.inputs.pop();
 else     return iterator.next();
  }
  return this.noMoreElements();
}","@Override protected T loadNext(){
  while (!this.inputs.isEmpty()) {
    Iterator<? extends T> iterator=this.inputs.getFirst();
    if (!iterator.hasNext())     this.inputs.pop();
 else     return iterator.next();
  }
  return this.noMoreElements();
}"
88211,"public OneElementList(E element){
  this.element=element;
}","/** 
 * Initializes OneElementList with the given element.
 * @param element the element to wrap
 */
public OneElementList(E element){
  this.element=element;
}"
88212,"@Override public void write(final DataOutput out) throws IOException {
  final int maxBit=0x1 << 7;
  int len=this.value.length();
  while (len >= maxBit) {
    out.write(len | maxBit);
    len>>=7;
  }
  out.write(len);
  for (int i=0; i < this.value.length(); i++) {
    int c=this.value.charAt(i);
    if (c < maxBit)     out.write(c);
 else     while (c >= maxBit) {
      out.write(c | maxBit);
      c>>=7;
    }
  }
}","@Override public void write(final DataOutput out) throws IOException {
  final int maxBit=0x1 << 7;
  int len=this.value.length();
  while (len >= maxBit) {
    out.write(len | maxBit);
    len>>=7;
  }
  out.write(len);
  for (int i=0; i < this.value.length(); i++) {
    int c=this.value.charAt(i);
    while (c >= maxBit) {
      out.write(c | maxBit);
      c>>=7;
    }
    out.write(c);
  }
}"
88213,"@Test public void testPactString(){
  PactString string0=new PactString(""String_Node_Str"");
  Assert.assertEquals(""String_Node_Str"",string0.toString());
  PactString string1=new PactString(""String_Node_Str"");
  PactString string2=new PactString(""String_Node_Str"");
  PactString string3=new PactString(""String_Node_Str"");
  Assert.assertTrue(string0.compareTo(string0) == 0);
  Assert.assertTrue(string0.compareTo(string1) == 0);
  Assert.assertTrue(string0.compareTo(string2) > 0);
  Assert.assertTrue(string0.compareTo(string3) < 0);
  try {
    string0.write(mOut);
    string2.write(mOut);
    string3.write(mOut);
    PactString string1n=new PactString();
    PactString string2n=new PactString();
    PactString string3n=new PactString();
    string1n.read(mIn);
    string2n.read(mIn);
    string3n.read(mIn);
    Assert.assertEquals(string0.compareTo(string1n),0);
    Assert.assertEquals(string0.toString(),string1n.toString());
    Assert.assertEquals(string2.compareTo(string2n),0);
    Assert.assertEquals(string2.toString(),string2n.toString());
    Assert.assertEquals(string3.compareTo(string3n),0);
    Assert.assertEquals(string3.toString(),string3n.toString());
  }
 catch (  Exception e) {
    Assert.assertTrue(false);
  }
}","@Test public void testPactString(){
  PactString string0=new PactString(""String_Node_Str"");
  Assert.assertEquals(""String_Node_Str"",string0.toString());
  PactString string1=new PactString(""String_Node_Str"");
  PactString string2=new PactString(""String_Node_Str"");
  PactString string3=new PactString(""String_Node_Str"");
  PactString string4=new PactString(""String_Node_Str"");
  Assert.assertTrue(string0.compareTo(string0) == 0);
  Assert.assertTrue(string0.compareTo(string1) == 0);
  Assert.assertTrue(string0.compareTo(string2) > 0);
  Assert.assertTrue(string0.compareTo(string3) < 0);
  try {
    string0.write(mOut);
    string4.write(mOut);
    string2.write(mOut);
    string3.write(mOut);
    PactString string1n=new PactString();
    PactString string2n=new PactString();
    PactString string3n=new PactString();
    PactString string4n=new PactString();
    string1n.read(mIn);
    string4n.read(mIn);
    string2n.read(mIn);
    string3n.read(mIn);
    Assert.assertEquals(string0.compareTo(string1n),0);
    Assert.assertEquals(string0.toString(),string1n.toString());
    Assert.assertEquals(string4.compareTo(string4n),0);
    Assert.assertEquals(string4.toString(),string4n.toString());
    Assert.assertEquals(string2.compareTo(string2n),0);
    Assert.assertEquals(string2.toString(),string2n.toString());
    Assert.assertEquals(string3.compareTo(string3n),0);
    Assert.assertEquals(string3.toString(),string3n.toString());
  }
 catch (  Exception e) {
    Assert.assertTrue(false);
  }
}"
88214,"@Override public InstanceType getDefaultInstanceType(){
  return DEFAULT;
}","@Override public InstanceType getDefaultInstanceType(){
  return DEFAULT_INSTANCE_TYPE;
}"
88215,"@Override public InstanceType getInstanceTypeByName(final String instanceTypeName){
  return DEFAULT;
}","@Override public InstanceType getInstanceTypeByName(final String instanceTypeName){
  return DEFAULT_INSTANCE_TYPE;
}"
88216,"@Override public InstanceType getSuitableInstanceType(final int minNumComputeUnits,final int minNumCPUCores,final int minMemorySize,final int minDiskCapacity,final int maxPricePerHour){
  return DEFAULT;
}","@Override public InstanceType getSuitableInstanceType(final int minNumComputeUnits,final int minNumCPUCores,final int minMemorySize,final int minDiskCapacity,final int maxPricePerHour){
  return DEFAULT_INSTANCE_TYPE;
}"
88217,"private void assignMemory(final TaskConfig config,final int memSize){
  config.setMemorySize(((long)memSize) * 1024L * 1024L);
  config.setNumFilehandles(DEFAUTL_MERGE_FACTOR);
}","private void assignMemory(final TaskConfig config,final int memSize){
  config.setMemorySize(memSize * 1024L * 1024L);
  config.setNumFilehandles(DEFAUTL_MERGE_FACTOR);
}"
88218,"public abstract void getStreamedNestedLoopsCosts(OptimizerNode node,PactConnection outerSide,PactConnection innerSide,Costs costs);","public abstract void getStreamedNestedLoopsCosts(OptimizerNode node,PactConnection outerSide,PactConnection innerSide,int bufferSize,Costs costs);"
88219,"/** 
 * This method computes the costs for an operator. It requires that all inputs are set and have a proper <tt>ShipStrategy</tt> set, which is not equal to <tt>NONE</tt>.
 * @param n The node to compute the costs for.
 */
public void costOperator(OptimizerNode n){
  if (n.getIncomingConnections() == null) {
    throw new CompilerException(""String_Node_Str"");
  }
  PactConnection primConn=null;
  PactConnection secConn=null;
{
    List<PactConnection> conns=n.getIncomingConnections();
    if (conns.size() > 0) {
      primConn=conns.get(0);
    }
    if (conns.size() > 1) {
      secConn=conns.get(1);
    }
  }
  Costs globCost=new Costs();
  Costs locCost=new Costs();
  if (primConn != null) {
switch (primConn.getShipStrategy()) {
case NONE:
      throw new CompilerException(""String_Node_Str"");
case FORWARD:
case PARTITION_LOCAL_HASH:
    globCost.setNetworkCost(0);
  globCost.setSecondaryStorageCost(0);
break;
case PARTITION_HASH:
getHashPartitioningCost(primConn,globCost);
break;
case PARTITION_RANGE:
getRangePartitionCost(primConn,globCost);
break;
case BROADCAST:
getBroadcastCost(primConn,globCost);
break;
case SFR:
throw new CompilerException(""String_Node_Str"");
default :
throw new CompilerException(""String_Node_Str"" + primConn.getShipStrategy().name());
}
}
 else {
globCost.setNetworkCost(0);
globCost.setSecondaryStorageCost(0);
}
if (secConn != null) {
Costs secCost=new Costs();
switch (secConn.getShipStrategy()) {
case NONE:
throw new CompilerException(""String_Node_Str"");
case FORWARD:
case PARTITION_LOCAL_HASH:
secCost.setNetworkCost(0);
secCost.setSecondaryStorageCost(0);
break;
case PARTITION_HASH:
getHashPartitioningCost(secConn,secCost);
break;
case PARTITION_RANGE:
getRangePartitionCost(secConn,secCost);
break;
case BROADCAST:
getBroadcastCost(secConn,secCost);
break;
case SFR:
throw new CompilerException(""String_Node_Str"");
default :
throw new CompilerException(""String_Node_Str"" + secConn.getShipStrategy().name());
}
globCost.addCosts(secCost);
}
locCost.setNetworkCost(0);
switch (n.getLocalStrategy()) {
case NONE:
locCost.setNetworkCost(0);
locCost.setSecondaryStorageCost(0);
break;
case COMBININGSORT:
case SORT:
getLocalSortCost(n,primConn,locCost);
break;
case SORT_BOTH_MERGE:
getLocalDoubleSortMergeCost(n,primConn,secConn,locCost);
break;
case SORT_FIRST_MERGE:
getLocalSingleSortMergeCost(n,primConn,secConn,locCost);
break;
case SORT_SECOND_MERGE:
getLocalSingleSortMergeCost(n,secConn,primConn,locCost);
break;
case MERGE:
getLocalMergeCost(n,primConn,secConn,locCost);
break;
case SORT_SELF_NESTEDLOOP:
getLocalSortSelfNestedLoopCost(n,primConn,10,locCost);
break;
case SELF_NESTEDLOOP:
getLocalSelfNestedLoopCost(n,primConn,10,locCost);
break;
case HYBRIDHASH_FIRST:
getHybridHashCosts(n,primConn,secConn,locCost);
break;
case HYBRIDHASH_SECOND:
getHybridHashCosts(n,secConn,primConn,locCost);
break;
case MMHASH_FIRST:
getMainMemHashCosts(n,primConn,secConn,locCost);
break;
case MMHASH_SECOND:
getMainMemHashCosts(n,secConn,primConn,locCost);
break;
case NESTEDLOOP_BLOCKED_OUTER_FIRST:
getBlockNestedLoopsCosts(n,primConn,secConn,2,locCost);
break;
case NESTEDLOOP_BLOCKED_OUTER_SECOND:
getBlockNestedLoopsCosts(n,secConn,primConn,2,locCost);
break;
case NESTEDLOOP_STREAMED_OUTER_FIRST:
getStreamedNestedLoopsCosts(n,primConn,secConn,locCost);
break;
case NESTEDLOOP_STREAMED_OUTER_SECOND:
getStreamedNestedLoopsCosts(n,secConn,primConn,locCost);
break;
default :
throw new CompilerException(""String_Node_Str"" + n.getLocalStrategy().name());
}
globCost.addCosts(locCost);
n.setCosts(globCost);
}","/** 
 * This method computes the costs for an operator. It requires that all inputs are set and have a proper <tt>ShipStrategy</tt> set, which is not equal to <tt>NONE</tt>.
 * @param n The node to compute the costs for.
 */
public void costOperator(OptimizerNode n){
  if (n.getIncomingConnections() == null) {
    throw new CompilerException(""String_Node_Str"");
  }
  PactConnection primConn=null;
  PactConnection secConn=null;
{
    List<PactConnection> conns=n.getIncomingConnections();
    if (conns.size() > 0) {
      primConn=conns.get(0);
    }
    if (conns.size() > 1) {
      secConn=conns.get(1);
    }
  }
  Costs globCost=new Costs();
  Costs locCost=new Costs();
  if (primConn != null) {
switch (primConn.getShipStrategy()) {
case NONE:
      throw new CompilerException(""String_Node_Str"");
case FORWARD:
case PARTITION_LOCAL_HASH:
    globCost.setNetworkCost(0);
  globCost.setSecondaryStorageCost(0);
break;
case PARTITION_HASH:
getHashPartitioningCost(primConn,globCost);
break;
case PARTITION_RANGE:
getRangePartitionCost(primConn,globCost);
break;
case BROADCAST:
getBroadcastCost(primConn,globCost);
break;
case SFR:
throw new CompilerException(""String_Node_Str"");
default :
throw new CompilerException(""String_Node_Str"" + primConn.getShipStrategy().name());
}
}
 else {
globCost.setNetworkCost(0);
globCost.setSecondaryStorageCost(0);
}
if (secConn != null) {
Costs secCost=new Costs();
switch (secConn.getShipStrategy()) {
case NONE:
throw new CompilerException(""String_Node_Str"");
case FORWARD:
case PARTITION_LOCAL_HASH:
secCost.setNetworkCost(0);
secCost.setSecondaryStorageCost(0);
break;
case PARTITION_HASH:
getHashPartitioningCost(secConn,secCost);
break;
case PARTITION_RANGE:
getRangePartitionCost(secConn,secCost);
break;
case BROADCAST:
getBroadcastCost(secConn,secCost);
break;
case SFR:
throw new CompilerException(""String_Node_Str"");
default :
throw new CompilerException(""String_Node_Str"" + secConn.getShipStrategy().name());
}
globCost.addCosts(secCost);
}
locCost.setNetworkCost(0);
switch (n.getLocalStrategy()) {
case NONE:
locCost.setNetworkCost(0);
locCost.setSecondaryStorageCost(0);
break;
case COMBININGSORT:
case SORT:
getLocalSortCost(n,primConn,locCost);
break;
case SORT_BOTH_MERGE:
getLocalDoubleSortMergeCost(n,primConn,secConn,locCost);
break;
case SORT_FIRST_MERGE:
getLocalSingleSortMergeCost(n,primConn,secConn,locCost);
break;
case SORT_SECOND_MERGE:
getLocalSingleSortMergeCost(n,secConn,primConn,locCost);
break;
case MERGE:
getLocalMergeCost(n,primConn,secConn,locCost);
break;
case SORT_SELF_NESTEDLOOP:
getLocalSortSelfNestedLoopCost(n,primConn,10,locCost);
break;
case SELF_NESTEDLOOP:
getLocalSelfNestedLoopCost(n,primConn,10,locCost);
break;
case HYBRIDHASH_FIRST:
getHybridHashCosts(n,primConn,secConn,locCost);
break;
case HYBRIDHASH_SECOND:
getHybridHashCosts(n,secConn,primConn,locCost);
break;
case MMHASH_FIRST:
getMainMemHashCosts(n,primConn,secConn,locCost);
break;
case MMHASH_SECOND:
getMainMemHashCosts(n,secConn,primConn,locCost);
break;
case NESTEDLOOP_BLOCKED_OUTER_FIRST:
getBlockNestedLoopsCosts(n,primConn,secConn,BlockResettableIterator.MIN_BUFFER_SIZE,locCost);
break;
case NESTEDLOOP_BLOCKED_OUTER_SECOND:
getBlockNestedLoopsCosts(n,secConn,primConn,BlockResettableIterator.MIN_BUFFER_SIZE,locCost);
break;
case NESTEDLOOP_STREAMED_OUTER_FIRST:
getStreamedNestedLoopsCosts(n,primConn,secConn,SpillingResettableIterator.MINIMUM_NUMBER_OF_BUFFERS * SpillingResettableIterator.MIN_BUFFER_SIZE,locCost);
break;
case NESTEDLOOP_STREAMED_OUTER_SECOND:
getStreamedNestedLoopsCosts(n,secConn,primConn,SpillingResettableIterator.MINIMUM_NUMBER_OF_BUFFERS * SpillingResettableIterator.MIN_BUFFER_SIZE,locCost);
break;
default :
throw new CompilerException(""String_Node_Str"" + n.getLocalStrategy().name());
}
globCost.addCosts(locCost);
n.setCosts(globCost);
}"
88220,"private int writeContentForCanceledChannel(final ReadableByteChannel readableByteChannel) throws IOException {
  final ByteBuffer tmpBuffer=ByteBuffer.allocate(128);
  long bytesWritten=0;
  long diff=this.bufferSize - this.totalBytesWritten;
  if (diff <= 0) {
    return 0;
  }
  while (diff > 0) {
    if (diff < tmpBuffer.remaining()) {
      tmpBuffer.limit(tmpBuffer.position() + (int)diff);
    }
    final long b=readableByteChannel.read(tmpBuffer);
    if (b == 0) {
      break;
    }
    if (b == -1) {
      throw new IOException(""String_Node_Str"");
    }
    if (!tmpBuffer.hasRemaining()) {
      tmpBuffer.clear();
    }
    bytesWritten+=b;
    this.totalBytesWritten+=bytesWritten;
    diff=this.bufferSize - this.totalBytesWritten;
  }
  return (int)bytesWritten;
}","private int writeContentForCanceledChannel(final ReadableByteChannel readableByteChannel) throws IOException {
  final ByteBuffer tmpBuffer=ByteBuffer.allocate(128);
  long bytesWritten=0;
  long diff=this.bufferSize - this.totalBytesWritten;
  if (diff <= 0) {
    return 0;
  }
  while (diff > 0) {
    if (diff < tmpBuffer.remaining()) {
      tmpBuffer.limit(tmpBuffer.position() + (int)diff);
    }
    final long b=readableByteChannel.read(tmpBuffer);
    if (b == 0) {
      break;
    }
    if (b == -1) {
      throw new IOException(""String_Node_Str"");
    }
    if (!tmpBuffer.hasRemaining()) {
      tmpBuffer.clear();
    }
    bytesWritten+=b;
    this.totalBytesWritten+=b;
    diff=this.bufferSize - this.totalBytesWritten;
  }
  return (int)bytesWritten;
}"
88221,"/** 
 * {@inheritDoc}
 */
@Override public void requestClose() throws IOException, InterruptedException {
  if (!this.closeRequested) {
    this.closeRequested=true;
    transferEvent(new ByteBufferedChannelCloseEvent());
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void requestClose() throws IOException, InterruptedException {
  if (!this.closeRequested) {
    this.closeRequested=true;
    if (!isBroadcastChannel() || getChannelIndex() == 0) {
      transferEvent(new ByteBufferedChannelCloseEvent());
    }
  }
}"
88222,"/** 
 * Executes the list action.
 * @param args Command line arguments for the list action.
 */
private void list(String[] args){
  boolean running;
  boolean scheduled;
  CommandLine line=null;
  try {
    line=parser.parse(this.options.get(ACTION_LIST),args,false);
  }
 catch (  Exception e) {
    handleError(e);
  }
  running=line.hasOption(RUNNING_OPTION.getOpt());
  scheduled=line.hasOption(SCHEDULED_OPTION.getOpt());
  if (!running && !scheduled) {
    System.err.println(""String_Node_Str"");
    printHelp();
    System.exit(1);
  }
  ExtendedManagementProtocol jmConn=null;
  try {
    jmConn=getJMConnection();
    List<RecentJobEvent> recentJobs=jmConn.getRecentJobs();
    ArrayList<RecentJobEvent> runningJobs=null;
    ArrayList<RecentJobEvent> scheduledJobs=null;
    if (running) {
      runningJobs=new ArrayList<RecentJobEvent>();
    }
    if (scheduled) {
      scheduledJobs=new ArrayList<RecentJobEvent>();
    }
    for (    RecentJobEvent rje : recentJobs) {
      if (running && rje.getJobStatus().equals(JobStatus.RUNNING)) {
        runningJobs.add(rje);
      }
      if (scheduled && rje.getJobStatus().equals(JobStatus.SCHEDULED)) {
        scheduledJobs.add(rje);
      }
    }
    SimpleDateFormat df=new SimpleDateFormat(""String_Node_Str"");
    Comparator<RecentJobEvent> njec=new Comparator<RecentJobEvent>(){
      @Override public int compare(      RecentJobEvent o1,      RecentJobEvent o2){
        return (int)(o1.getTimestamp() - o2.getTimestamp());
      }
    }
;
    if (running) {
      if (runningJobs.size() == 0) {
        System.out.println(""String_Node_Str"");
      }
 else {
        Collections.sort(runningJobs,njec);
        System.out.println(""String_Node_Str"");
        for (        RecentJobEvent je : runningJobs) {
          System.out.println(df.format(new Date(je.getTimestamp())) + ""String_Node_Str"" + je.getJobID().toString()+ ""String_Node_Str""+ je.getJobName());
        }
        System.out.println(""String_Node_Str"");
      }
    }
    if (scheduled) {
      if (scheduledJobs.size() == 0) {
        System.out.println(""String_Node_Str"");
      }
 else {
        Collections.sort(runningJobs,njec);
        System.out.println(""String_Node_Str"");
        for (        RecentJobEvent je : scheduledJobs) {
          System.out.println(df.format(new Date(je.getTimestamp())) + ""String_Node_Str"" + je.getJobID().toString()+ ""String_Node_Str""+ je.getJobName());
        }
        System.out.println(""String_Node_Str"");
      }
    }
  }
 catch (  Throwable t) {
    handleError(t);
  }
 finally {
    if (jmConn != null) {
      try {
        RPC.stopProxy(jmConn);
      }
 catch (      Throwable t) {
        System.err.println(""String_Node_Str"");
      }
    }
    jmConn=null;
  }
}","/** 
 * Executes the list action.
 * @param args Command line arguments for the list action.
 */
private void list(String[] args){
  boolean running;
  boolean scheduled;
  CommandLine line=null;
  try {
    line=parser.parse(this.options.get(ACTION_LIST),args,false);
  }
 catch (  Exception e) {
    handleError(e);
  }
  running=line.hasOption(RUNNING_OPTION.getOpt());
  scheduled=line.hasOption(SCHEDULED_OPTION.getOpt());
  if (!running && !scheduled) {
    System.err.println(""String_Node_Str"");
    printHelp();
    System.exit(1);
  }
  ExtendedManagementProtocol jmConn=null;
  try {
    jmConn=getJMConnection();
    List<RecentJobEvent> recentJobs=jmConn.getRecentJobs();
    ArrayList<RecentJobEvent> runningJobs=null;
    ArrayList<RecentJobEvent> scheduledJobs=null;
    if (running) {
      runningJobs=new ArrayList<RecentJobEvent>();
    }
    if (scheduled) {
      scheduledJobs=new ArrayList<RecentJobEvent>();
    }
    for (    RecentJobEvent rje : recentJobs) {
      if (running && rje.getJobStatus().equals(JobStatus.RUNNING)) {
        runningJobs.add(rje);
      }
      if (scheduled && rje.getJobStatus().equals(JobStatus.SCHEDULED)) {
        scheduledJobs.add(rje);
      }
    }
    SimpleDateFormat df=new SimpleDateFormat(""String_Node_Str"");
    Comparator<RecentJobEvent> njec=new Comparator<RecentJobEvent>(){
      @Override public int compare(      RecentJobEvent o1,      RecentJobEvent o2){
        return (int)(o1.getTimestamp() - o2.getTimestamp());
      }
    }
;
    if (running) {
      if (runningJobs.size() == 0) {
        System.out.println(""String_Node_Str"");
      }
 else {
        Collections.sort(runningJobs,njec);
        System.out.println(""String_Node_Str"");
        for (        RecentJobEvent je : runningJobs) {
          System.out.println(df.format(new Date(je.getTimestamp())) + ""String_Node_Str"" + je.getJobID().toString()+ ""String_Node_Str""+ je.getJobName());
        }
        System.out.println(""String_Node_Str"");
      }
    }
    if (scheduled) {
      if (scheduledJobs.size() == 0) {
        System.out.println(""String_Node_Str"");
      }
 else {
        Collections.sort(scheduledJobs,njec);
        System.out.println(""String_Node_Str"");
        for (        RecentJobEvent je : scheduledJobs) {
          System.out.println(df.format(new Date(je.getTimestamp())) + ""String_Node_Str"" + je.getJobID().toString()+ ""String_Node_Str""+ je.getJobName());
        }
        System.out.println(""String_Node_Str"");
      }
    }
  }
 catch (  Throwable t) {
    handleError(t);
  }
 finally {
    if (jmConn != null) {
      try {
        RPC.stopProxy(jmConn);
      }
 catch (      Throwable t) {
        System.err.println(""String_Node_Str"");
      }
    }
    jmConn=null;
  }
}"
88223,"/** 
 * Decreases the number of references to the physical buffer by one. If the number of references becomes zero the physical buffer is recycled.
 */
synchronized void decreaseReferenceCounter(){
  if (this.bufferAlreadyRecycled) {
    LOG.error(""String_Node_Str"");
  }
  --this.referenceCounter;
  if (this.referenceCounter <= 0) {
    this.originalBuffer.clear();
synchronized (this.queueForRecycledBuffers) {
      this.queueForRecycledBuffers.add(this.originalBuffer);
      this.queueForRecycledBuffers.notify();
    }
  }
  this.bufferAlreadyRecycled=true;
}","/** 
 * Decreases the number of references to the physical buffer by one. If the number of references becomes zero the physical buffer is recycled.
 */
synchronized void decreaseReferenceCounter(){
  if (this.bufferAlreadyRecycled) {
    LOG.error(""String_Node_Str"");
  }
  --this.referenceCounter;
  if (this.referenceCounter <= 0) {
    this.originalBuffer.clear();
synchronized (this.queueForRecycledBuffers) {
      this.queueForRecycledBuffers.add(this.originalBuffer);
      this.queueForRecycledBuffers.notify();
    }
    this.bufferAlreadyRecycled=true;
  }
}"
88224,"private boolean processEnvelopeWithBuffer(final TransferEnvelope transferEnvelope,final TransferEnvelopeReceiverList receiverList) throws IOException, InterruptedException {
  final Buffer buffer=transferEnvelope.getBuffer();
  if (buffer.isReadBuffer()) {
    if (receiverList.hasRemoteReceivers()) {
      final List<InetSocketAddress> remoteReceivers=receiverList.getRemoteReceivers();
      final Buffer writeBuffer=this.bufferProvider.requestEmptyWriteBuffer(buffer.size());
      if (writeBuffer == null) {
        return false;
      }
      transferEnvelope.getBuffer().copyToBuffer(writeBuffer);
      final TransferEnvelope remoteEnvelope=new TransferEnvelope(transferEnvelope.getSequenceNumber(),transferEnvelope.getJobID(),transferEnvelope.getSource(),transferEnvelope.getEventList());
      remoteEnvelope.setBuffer(writeBuffer);
      for (int i=1; i < remoteReceivers.size(); ++i) {
        this.networkConnectionManager.queueEnvelopeForTransfer(remoteReceivers.get(i),remoteEnvelope.duplicate());
      }
      this.networkConnectionManager.queueEnvelopeForTransfer(remoteReceivers.get(0),remoteEnvelope);
    }
    if (receiverList.hasLocalReceivers()) {
      final List<ChannelID> localReceivers=receiverList.getLocalReceivers();
synchronized (this.registeredChannels) {
        ByteBufferedChannelWrapper channelWrapper=null;
        for (int i=1; i < localReceivers.size(); ++i) {
          channelWrapper=this.registeredChannels.get(localReceivers.get(i));
          if (channelWrapper == null) {
            LOG.error(""String_Node_Str"" + localReceivers.get(i) + ""String_Node_Str""+ transferEnvelope.getJobID());
            continue;
          }
          channelWrapper.queueTransferEnvelope(transferEnvelope.duplicate());
        }
        channelWrapper=this.registeredChannels.get(localReceivers.get(0));
        if (channelWrapper == null) {
          LOG.error(""String_Node_Str"" + localReceivers.get(0) + ""String_Node_Str""+ transferEnvelope.getJobID());
        }
 else {
          channelWrapper.queueTransferEnvelope(transferEnvelope);
        }
      }
    }
 else {
      buffer.recycleBuffer();
    }
  }
 else {
    if (receiverList.hasLocalReceivers()) {
      final List<ChannelID> localReceivers=receiverList.getLocalReceivers();
      final Buffer readBuffer=this.bufferProvider.requestEmptyReadBufferAndWait(buffer.size(),localReceivers.get(0));
      transferEnvelope.getBuffer().copyToBuffer(readBuffer);
      final TransferEnvelope localEnvelope=new TransferEnvelope(transferEnvelope.getSequenceNumber(),transferEnvelope.getJobID(),transferEnvelope.getSource(),transferEnvelope.getEventList());
      localEnvelope.setBuffer(readBuffer);
synchronized (this.registeredChannels) {
        ByteBufferedChannelWrapper channelWrapper=null;
        for (int i=1; i < localReceivers.size(); ++i) {
          channelWrapper=this.registeredChannels.get(localReceivers.get(i));
          if (channelWrapper == null) {
            LOG.error(""String_Node_Str"" + localReceivers.get(i) + ""String_Node_Str""+ transferEnvelope.getJobID());
            continue;
          }
          channelWrapper.queueTransferEnvelope(localEnvelope.duplicate());
        }
        channelWrapper=this.registeredChannels.get(localReceivers.get(0));
        if (channelWrapper == null) {
          LOG.error(""String_Node_Str"" + localReceivers.get(0) + ""String_Node_Str""+ transferEnvelope.getJobID());
        }
 else {
          channelWrapper.queueTransferEnvelope(localEnvelope);
        }
      }
    }
    if (receiverList.hasRemoteReceivers()) {
      final List<InetSocketAddress> remoteReceivers=receiverList.getRemoteReceivers();
      for (int i=1; i < remoteReceivers.size(); ++i) {
        this.networkConnectionManager.queueEnvelopeForTransfer(remoteReceivers.get(i),transferEnvelope.duplicate());
      }
      this.networkConnectionManager.queueEnvelopeForTransfer(remoteReceivers.get(0),transferEnvelope);
    }
 else {
      buffer.recycleBuffer();
    }
  }
  return true;
}","private boolean processEnvelopeWithBuffer(final TransferEnvelope transferEnvelope,final TransferEnvelopeReceiverList receiverList) throws IOException, InterruptedException {
  final Buffer buffer=transferEnvelope.getBuffer();
  if (buffer.isReadBuffer()) {
    if (receiverList.hasRemoteReceivers()) {
      final List<InetSocketAddress> remoteReceivers=receiverList.getRemoteReceivers();
      final Buffer writeBuffer=this.bufferProvider.requestEmptyWriteBuffer(buffer.size());
      if (writeBuffer == null) {
        return false;
      }
      transferEnvelope.getBuffer().copyToBuffer(writeBuffer);
      final TransferEnvelope remoteEnvelope=new TransferEnvelope(transferEnvelope.getSequenceNumber(),transferEnvelope.getJobID(),transferEnvelope.getSource(),transferEnvelope.getEventList());
      remoteEnvelope.setBuffer(writeBuffer);
      TransferEnvelope[] duplicatedEnvelopes=new TransferEnvelope[remoteReceivers.size() - 1];
      for (int i=0; i < duplicatedEnvelopes.length; ++i) {
        duplicatedEnvelopes[i]=remoteEnvelope.duplicate();
      }
      for (int i=1; i < remoteReceivers.size(); ++i) {
        this.networkConnectionManager.queueEnvelopeForTransfer(remoteReceivers.get(i),duplicatedEnvelopes[i - 1]);
      }
      this.networkConnectionManager.queueEnvelopeForTransfer(remoteReceivers.get(0),remoteEnvelope);
    }
    if (receiverList.hasLocalReceivers()) {
      final List<ChannelID> localReceivers=receiverList.getLocalReceivers();
synchronized (this.registeredChannels) {
        ByteBufferedChannelWrapper channelWrapper=null;
        if (localReceivers.size() > 1) {
          TransferEnvelope[] duplicatedEnvelopes=new TransferEnvelope[localReceivers.size() - 1];
          for (int i=0; i < duplicatedEnvelopes.length; ++i) {
            duplicatedEnvelopes[i]=transferEnvelope.duplicate();
          }
          for (int i=1; i < localReceivers.size(); ++i) {
            channelWrapper=this.registeredChannels.get(localReceivers.get(i));
            if (channelWrapper == null) {
              LOG.error(""String_Node_Str"" + localReceivers.get(i) + ""String_Node_Str""+ transferEnvelope.getJobID());
              continue;
            }
            channelWrapper.queueTransferEnvelope(duplicatedEnvelopes[i - 1]);
          }
        }
        channelWrapper=this.registeredChannels.get(localReceivers.get(0));
        if (channelWrapper == null) {
          LOG.error(""String_Node_Str"" + localReceivers.get(0) + ""String_Node_Str""+ transferEnvelope.getJobID());
        }
 else {
          channelWrapper.queueTransferEnvelope(transferEnvelope);
        }
      }
    }
 else {
      buffer.recycleBuffer();
    }
  }
 else {
    if (receiverList.hasLocalReceivers()) {
      final List<ChannelID> localReceivers=receiverList.getLocalReceivers();
      final Buffer readBuffer=this.bufferProvider.requestEmptyReadBufferAndWait(buffer.size(),localReceivers.get(0));
      transferEnvelope.getBuffer().copyToBuffer(readBuffer);
      final TransferEnvelope localEnvelope=new TransferEnvelope(transferEnvelope.getSequenceNumber(),transferEnvelope.getJobID(),transferEnvelope.getSource(),transferEnvelope.getEventList());
      localEnvelope.setBuffer(readBuffer);
synchronized (this.registeredChannels) {
        ByteBufferedChannelWrapper channelWrapper=null;
        for (int i=1; i < localReceivers.size(); ++i) {
          channelWrapper=this.registeredChannels.get(localReceivers.get(i));
          if (channelWrapper == null) {
            LOG.error(""String_Node_Str"" + localReceivers.get(i) + ""String_Node_Str""+ transferEnvelope.getJobID());
            continue;
          }
          channelWrapper.queueTransferEnvelope(localEnvelope.duplicate());
        }
        channelWrapper=this.registeredChannels.get(localReceivers.get(0));
        if (channelWrapper == null) {
          LOG.error(""String_Node_Str"" + localReceivers.get(0) + ""String_Node_Str""+ transferEnvelope.getJobID());
        }
 else {
          channelWrapper.queueTransferEnvelope(localEnvelope);
        }
      }
    }
    if (receiverList.hasRemoteReceivers()) {
      final List<InetSocketAddress> remoteReceivers=receiverList.getRemoteReceivers();
      for (int i=1; i < remoteReceivers.size(); ++i) {
        this.networkConnectionManager.queueEnvelopeForTransfer(remoteReceivers.get(i),transferEnvelope.duplicate());
      }
      this.networkConnectionManager.queueEnvelopeForTransfer(remoteReceivers.get(0),transferEnvelope);
    }
 else {
      buffer.recycleBuffer();
    }
  }
  return true;
}"
88225,"/** 
 * {@inheritDoc}
 */
@Override public boolean processEnvelopeFromNetworkOrCheckpoint(final TransferEnvelope transferEnvelope) throws IOException {
  try {
    if (!processEnvelope(transferEnvelope)) {
      System.out.println(""String_Node_Str"");
    }
  }
 catch (  InterruptedException e) {
    LOG.error(""String_Node_Str"" + StringUtils.stringifyException(e));
  }
  return false;
}","/** 
 * {@inheritDoc}
 */
@Override public boolean processEnvelopeFromNetworkOrCheckpoint(final TransferEnvelope transferEnvelope) throws IOException {
  try {
    if (!processEnvelope(transferEnvelope)) {
      return false;
    }
  }
 catch (  InterruptedException e) {
    LOG.error(""String_Node_Str"" + StringUtils.stringifyException(e));
  }
  return true;
}"
88226,"private boolean readSequenceNumber(ReadableByteChannel readableByteChannel) throws IOException {
  if (!this.sequenceNumberDeserializationStarted) {
    this.lengthBuffer.clear();
    this.sequenceNumberDeserializationStarted=true;
  }
  if (readableByteChannel.read(this.lengthBuffer) == -1) {
    if (this.lengthBuffer.position() == 0) {
      throw new EOFException();
    }
 else {
      throw new IOException(""String_Node_Str"");
    }
  }
  if (!this.lengthBuffer.hasRemaining()) {
    final int sequenceNumber=byteBufferToInteger(this.lengthBuffer,0);
    if (sequenceNumber < 0) {
      throw new IOException(""String_Node_Str"" + sequenceNumber);
    }
    this.deserializationState=DeserializationState.SEQUENCENUMBERDESERIALIZED;
    this.sequenceNumberDeserializationStarted=false;
    this.transferEnvelope=null;
    this.sizeOfBuffer=-1;
    this.bufferExistanceDeserialized=false;
    this.existanceBuffer.clear();
    this.lengthBuffer.clear();
    this.jobIDDeserializationBuffer.clear();
    this.channelIDDeserializationBuffer.clear();
    this.buffer=null;
    return false;
  }
  return true;
}","private boolean readSequenceNumber(ReadableByteChannel readableByteChannel) throws IOException {
  if (!this.sequenceNumberDeserializationStarted) {
    this.lengthBuffer.clear();
    this.sequenceNumberDeserializationStarted=true;
  }
  if (readableByteChannel.read(this.lengthBuffer) == -1) {
    if (this.lengthBuffer.position() == 0) {
      throw new EOFException();
    }
 else {
      throw new IOException(""String_Node_Str"");
    }
  }
  if (!this.lengthBuffer.hasRemaining()) {
    this.deserializedSequenceNumber=byteBufferToInteger(this.lengthBuffer,0);
    if (this.deserializedSequenceNumber < 0) {
      throw new IOException(""String_Node_Str"" + this.deserializedSequenceNumber);
    }
    this.deserializationState=DeserializationState.SEQUENCENUMBERDESERIALIZED;
    this.sequenceNumberDeserializationStarted=false;
    this.transferEnvelope=null;
    this.sizeOfBuffer=-1;
    this.bufferExistanceDeserialized=false;
    this.existanceBuffer.clear();
    this.lengthBuffer.clear();
    this.jobIDDeserializationBuffer.clear();
    this.channelIDDeserializationBuffer.clear();
    this.buffer=null;
    return false;
  }
  return true;
}"
88227,"/** 
 * {@inheritDoc}
 */
@Override public void executionStateChanged(Environment ee,ExecutionState newExecutionState,String optionalMessage){
  final long timestamp=System.currentTimeMillis();
  final VertexEvent vertexEvent=new VertexEvent(timestamp,this.jobVertexID,ee.getTaskName(),ee.getCurrentNumberOfSubtasks(),ee.getIndexInSubtaskGroup(),newExecutionState,optionalMessage);
  this.eventCollector.addEvent(ee.getJobID(),vertexEvent);
  final ExecutionStateChangeEvent executionStateChangeEvent=new ExecutionStateChangeEvent(timestamp,this.managementVertexID,newExecutionState);
  this.eventCollector.addEvent(ee.getJobID(),executionStateChangeEvent);
}","/** 
 * {@inheritDoc}
 */
@Override public void executionStateChanged(Environment ee,ExecutionState newExecutionState,String optionalMessage){
  final long timestamp=System.currentTimeMillis();
  final VertexEvent vertexEvent=new VertexEvent(timestamp,this.jobVertexID,ee.getTaskName(),ee.getCurrentNumberOfSubtasks(),ee.getIndexInSubtaskGroup(),newExecutionState,optionalMessage);
  this.eventCollector.addEvent(ee.getJobID(),vertexEvent);
  final ExecutionStateChangeEvent executionStateChangeEvent=new ExecutionStateChangeEvent(timestamp,this.managementVertexID,newExecutionState);
  this.eventCollector.updateManagementGraph(ee.getJobID(),executionStateChangeEvent);
  this.eventCollector.addEvent(ee.getJobID(),executionStateChangeEvent);
}"
88228,"/** 
 * {@inheritDoc}
 */
@Override public void vertexAssignmentChanged(ExecutionVertexID id,AllocatedResource newAllocatedResource){
  final ManagementVertexID managementVertexID=id.toManagementVertexID();
  final long timestamp=System.currentTimeMillis();
  final AbstractInstance instance=newAllocatedResource.getInstance();
  VertexAssignmentEvent event;
  if (instance == null) {
    event=new VertexAssignmentEvent(timestamp,managementVertexID,""String_Node_Str"",""String_Node_Str"");
  }
 else {
    event=new VertexAssignmentEvent(timestamp,managementVertexID,instance.getName(),instance.getType().getIdentifier());
  }
  this.eventCollector.addEvent(this.jobID,event);
}","/** 
 * {@inheritDoc}
 */
@Override public void vertexAssignmentChanged(ExecutionVertexID id,AllocatedResource newAllocatedResource){
  final ManagementVertexID managementVertexID=id.toManagementVertexID();
  final long timestamp=System.currentTimeMillis();
  final AbstractInstance instance=newAllocatedResource.getInstance();
  VertexAssignmentEvent event;
  if (instance == null) {
    event=new VertexAssignmentEvent(timestamp,managementVertexID,""String_Node_Str"",""String_Node_Str"");
  }
 else {
    event=new VertexAssignmentEvent(timestamp,managementVertexID,instance.getName(),instance.getType().getIdentifier());
  }
  this.eventCollector.updateManagementGraph(jobID,event);
  this.eventCollector.addEvent(this.jobID,event);
}"
88229,"/** 
 * Executes the list action.
 * @param args Command line arguments for the list action.
 */
private void list(String[] args){
  boolean running;
  boolean scheduled;
  CommandLine line=null;
  try {
    line=parser.parse(this.options.get(ACTION_LIST),args,false);
  }
 catch (  Exception e) {
    handleError(e);
  }
  running=line.hasOption(RUNNING_OPTION.getOpt());
  scheduled=line.hasOption(SCHEDULED_OPTION.getOpt());
  if (!running && !scheduled) {
    System.err.println(""String_Node_Str"");
    printHelp();
    System.exit(1);
  }
  ExtendedManagementProtocol jmConn=null;
  try {
    jmConn=getJMConnection();
    List<NewJobEvent> recentJobs=jmConn.getRecentJobs();
    ArrayList<NewJobEvent> runningJobs=null;
    ArrayList<NewJobEvent> scheduledJobs=null;
    if (running) {
      runningJobs=new ArrayList<NewJobEvent>();
    }
    if (scheduled) {
      scheduledJobs=new ArrayList<NewJobEvent>();
    }
    for (    NewJobEvent je : recentJobs) {
      if (running) {
      }
      if (scheduled) {
        scheduledJobs.add(je);
      }
    }
    SimpleDateFormat df=new SimpleDateFormat(""String_Node_Str"");
    if (running) {
      if (runningJobs.size() == 0) {
        System.out.println(""String_Node_Str"");
      }
 else {
        Collections.sort(runningJobs,new Comparator<NewJobEvent>(){
          @Override public int compare(          NewJobEvent o1,          NewJobEvent o2){
            return (int)(o1.getTimestamp() - o2.getTimestamp());
          }
        }
);
        System.out.println(""String_Node_Str"");
        for (        NewJobEvent je : runningJobs) {
          System.out.println(df.format(new Date(je.getTimestamp())) + ""String_Node_Str"" + je.getJobID().toString()+ ""String_Node_Str""+ je.getJobName());
        }
        System.out.println(""String_Node_Str"");
      }
    }
    if (scheduled) {
      if (scheduledJobs.size() == 0) {
        System.out.println(""String_Node_Str"");
      }
 else {
        Collections.sort(scheduledJobs,new Comparator<NewJobEvent>(){
          @Override public int compare(          NewJobEvent o1,          NewJobEvent o2){
            return (int)(o1.getTimestamp() - o2.getTimestamp());
          }
        }
);
        System.out.println(""String_Node_Str"");
        for (        NewJobEvent je : scheduledJobs) {
          System.out.println(df.format(new Date(je.getTimestamp())) + ""String_Node_Str"" + je.getJobID().toString()+ ""String_Node_Str""+ je.getJobName());
        }
        System.out.println(""String_Node_Str"");
      }
    }
  }
 catch (  Throwable t) {
    handleError(t);
  }
 finally {
    if (jmConn != null) {
      try {
        RPC.stopProxy(jmConn);
      }
 catch (      Throwable t) {
        System.err.println(""String_Node_Str"");
      }
    }
    jmConn=null;
  }
}","/** 
 * Executes the list action.
 * @param args Command line arguments for the list action.
 */
private void list(String[] args){
  boolean running;
  boolean scheduled;
  CommandLine line=null;
  try {
    line=parser.parse(this.options.get(ACTION_LIST),args,false);
  }
 catch (  Exception e) {
    handleError(e);
  }
  running=line.hasOption(RUNNING_OPTION.getOpt());
  scheduled=line.hasOption(SCHEDULED_OPTION.getOpt());
  if (!running && !scheduled) {
    System.err.println(""String_Node_Str"");
    printHelp();
    System.exit(1);
  }
  ExtendedManagementProtocol jmConn=null;
  try {
    jmConn=getJMConnection();
    List<NewJobEvent> recentJobs=jmConn.getRecentJobs();
    ArrayList<NewJobEvent> runningJobs=null;
    ArrayList<NewJobEvent> scheduledJobs=null;
    if (running) {
      runningJobs=new ArrayList<NewJobEvent>();
    }
    if (scheduled) {
      scheduledJobs=new ArrayList<NewJobEvent>();
    }
    for (    NewJobEvent je : recentJobs) {
      if (running) {
      }
      if (scheduled) {
        scheduledJobs.add(je);
      }
    }
    SimpleDateFormat df=new SimpleDateFormat(""String_Node_Str"");
    Comparator<NewJobEvent> njec=new Comparator<NewJobEvent>(){
      @Override public int compare(      NewJobEvent o1,      NewJobEvent o2){
        return (int)(o1.getTimestamp() - o2.getTimestamp());
      }
    }
;
    if (running) {
      if (runningJobs.size() == 0) {
        System.out.println(""String_Node_Str"");
      }
 else {
        Collections.sort(runningJobs,njec);
        System.out.println(""String_Node_Str"");
        for (        NewJobEvent je : runningJobs) {
          System.out.println(df.format(new Date(je.getTimestamp())) + ""String_Node_Str"" + je.getJobID().toString()+ ""String_Node_Str""+ je.getJobName());
        }
        System.out.println(""String_Node_Str"");
      }
    }
    if (scheduled) {
      if (scheduledJobs.size() == 0) {
        System.out.println(""String_Node_Str"");
      }
 else {
        Collections.sort(runningJobs,njec);
        System.out.println(""String_Node_Str"");
        for (        NewJobEvent je : scheduledJobs) {
          System.out.println(df.format(new Date(je.getTimestamp())) + ""String_Node_Str"" + je.getJobID().toString()+ ""String_Node_Str""+ je.getJobName());
        }
        System.out.println(""String_Node_Str"");
      }
    }
  }
 catch (  Throwable t) {
    handleError(t);
  }
 finally {
    if (jmConn != null) {
      try {
        RPC.stopProxy(jmConn);
      }
 catch (      Throwable t) {
        System.err.println(""String_Node_Str"");
      }
    }
    jmConn=null;
  }
}"
88230,"/** 
 * Executes the info action.
 * @param args Command line arguments for the info action. 
 */
private void info(String[] args){
  File jarFile=null;
  String assemblerClass=null;
  String[] programArgs=null;
  boolean description;
  boolean plan;
  CommandLine line=null;
  try {
    line=parser.parse(this.options.get(ACTION_INFO),args,false);
  }
 catch (  Exception e) {
    handleError(e);
  }
  if (line.hasOption(JAR_OPTION.getOpt())) {
    jarFile=new File(line.getOptionValue(JAR_OPTION.getOpt()));
    if (!jarFile.exists()) {
      System.err.println(""String_Node_Str"");
      printHelp();
      System.exit(1);
    }
 else     if (!jarFile.isFile()) {
      System.err.println(""String_Node_Str"");
      printHelp();
      System.exit(1);
    }
  }
 else {
    System.err.println(""String_Node_Str"");
    printHelp();
    System.exit(1);
  }
  if (line.hasOption(CLASS_OPTION.getOpt())) {
    assemblerClass=line.getOptionValue(CLASS_OPTION.getOpt());
  }
  if (line.hasOption(ARGS_OPTION.getOpt())) {
    programArgs=line.getOptionValues(ARGS_OPTION.getOpt());
  }
  description=line.hasOption(DESCR_OPTION.getOpt());
  plan=line.hasOption(PLAN_OPTION.getOpt());
  if (!description && !plan) {
    System.err.println(""String_Node_Str"");
    printHelp();
    System.exit(1);
  }
  PactProgram program=null;
  try {
    if (assemblerClass == null) {
      program=new PactProgram(jarFile,programArgs);
    }
 else {
      program=new PactProgram(jarFile,assemblerClass,programArgs);
    }
  }
 catch (  ProgramInvocationException e) {
    handleError(e);
  }
  if (description) {
    String descr=null;
    try {
      descr=program.getTextDescription();
    }
 catch (    Exception e) {
      handleError(e);
    }
    if (descr != null) {
      System.out.println(""String_Node_Str"");
      System.out.println(descr);
      System.out.println(""String_Node_Str"");
    }
 else {
      System.out.println(""String_Node_Str"");
    }
    System.exit(0);
  }
  if (plan) {
    String jsonPlan=null;
    try {
      jsonPlan=program.getJSONPlan();
    }
 catch (    Exception e) {
      handleError(e);
    }
    if (jsonPlan != null) {
      System.out.println(""String_Node_Str"");
      System.out.println(jsonPlan);
      System.out.println(""String_Node_Str"");
    }
 else {
      System.out.println(""String_Node_Str"");
    }
  }
}","/** 
 * Executes the info action.
 * @param args Command line arguments for the info action. 
 */
private void info(String[] args){
  File jarFile=null;
  String assemblerClass=null;
  String[] programArgs=null;
  boolean description;
  boolean plan;
  CommandLine line=null;
  try {
    line=parser.parse(this.options.get(ACTION_INFO),args,false);
  }
 catch (  Exception e) {
    handleError(e);
  }
  if (line.hasOption(JAR_OPTION.getOpt())) {
    jarFile=new File(line.getOptionValue(JAR_OPTION.getOpt()));
    if (!jarFile.exists()) {
      System.err.println(""String_Node_Str"");
      printHelp();
      System.exit(1);
    }
 else     if (!jarFile.isFile()) {
      System.err.println(""String_Node_Str"");
      printHelp();
      System.exit(1);
    }
  }
 else {
    System.err.println(""String_Node_Str"");
    printHelp();
    System.exit(1);
  }
  if (line.hasOption(CLASS_OPTION.getOpt())) {
    assemblerClass=line.getOptionValue(CLASS_OPTION.getOpt());
  }
  if (line.hasOption(ARGS_OPTION.getOpt())) {
    programArgs=line.getOptionValues(ARGS_OPTION.getOpt());
  }
  description=line.hasOption(DESCR_OPTION.getOpt());
  plan=line.hasOption(PLAN_OPTION.getOpt());
  if (!description && !plan) {
    System.err.println(""String_Node_Str"");
    printHelp();
    System.exit(1);
  }
  PactProgram program=null;
  try {
    if (assemblerClass == null) {
      program=new PactProgram(jarFile,programArgs);
    }
 else {
      program=new PactProgram(jarFile,assemblerClass,programArgs);
    }
  }
 catch (  ProgramInvocationException e) {
    handleError(e);
  }
  if (description) {
    String descr=null;
    try {
      descr=program.getTextDescription();
    }
 catch (    Exception e) {
      handleError(e);
    }
    if (descr != null) {
      System.out.println(""String_Node_Str"");
      System.out.println(descr);
      System.out.println(""String_Node_Str"");
    }
 else {
      System.err.println(""String_Node_Str"");
    }
  }
  if (plan) {
    String jsonPlan=null;
    Configuration configuration=getConfiguration();
    Client client=new Client(configuration);
    try {
      jsonPlan=client.getJSONPlan(program);
    }
 catch (    ProgramInvocationException e) {
      handleError(e);
    }
catch (    ErrorInPlanAssemblerException e) {
      handleError(e);
    }
    if (jsonPlan != null) {
      System.out.println(""String_Node_Str"");
      System.out.println(jsonPlan);
      System.out.println(""String_Node_Str"");
    }
 else {
      System.err.println(""String_Node_Str"");
    }
  }
}"
88231,"/** 
 * Submits the job-graph to the nephele job-manager for execution.
 * @param prog The program to be submitted.
 * @throws ProgramInvocationException Thrown, if the submission failed. That might be either due to an I/O problem,i.e. the job-manager is unreachable, or due to the fact that the execution on the nephele system failed.
 */
public void run(JobGraph jobGraph,boolean wait) throws ProgramInvocationException {
  nepheleConfig.setBoolean(""String_Node_Str"",false);
  JobClient client;
  try {
    client=new JobClient(jobGraph,nepheleConfig);
  }
 catch (  IOException e) {
    throw new ProgramInvocationException(""String_Node_Str"" + e.getMessage());
  }
  try {
    if (wait) {
      client.submitJobAndWait();
    }
 else {
      JobSubmissionResult result=client.submitJob();
      if (result.getReturnCode() != ReturnCode.SUCCESS) {
        throw new ProgramInvocationException(""String_Node_Str"" + (result.getDescription() == null ? ""String_Node_Str"" : ""String_Node_Str"" + result.getDescription()));
      }
    }
  }
 catch (  IOException e) {
    throw new ProgramInvocationException(""String_Node_Str"" + e.getMessage());
  }
catch (  JobExecutionException jex) {
    throw new ProgramInvocationException(""String_Node_Str"" + jex.getMessage());
  }
}","/** 
 * Submits the job-graph to the nephele job-manager for execution.
 * @param prog The program to be submitted.
 * @param wait Method will block until the job execution is finished if set to true. If set to false, the method will directly return after the job is submitted. 
 * @throws ProgramInvocationException Thrown, if the submission failed. That might be either due to an I/O problem,i.e. the job-manager is unreachable, or due to the fact that the execution on the nephele system failed.
 */
public void run(JobGraph jobGraph,boolean wait) throws ProgramInvocationException {
  nepheleConfig.setBoolean(""String_Node_Str"",false);
  JobClient client;
  try {
    client=new JobClient(jobGraph,nepheleConfig);
  }
 catch (  IOException e) {
    throw new ProgramInvocationException(""String_Node_Str"" + e.getMessage());
  }
  try {
    if (wait) {
      client.submitJobAndWait();
    }
 else {
      JobSubmissionResult result=client.submitJob();
      if (result.getReturnCode() != ReturnCode.SUCCESS) {
        throw new ProgramInvocationException(""String_Node_Str"" + (result.getDescription() == null ? ""String_Node_Str"" : ""String_Node_Str"" + result.getDescription()));
      }
    }
  }
 catch (  IOException e) {
    throw new ProgramInvocationException(""String_Node_Str"" + e.getMessage());
  }
catch (  JobExecutionException jex) {
    throw new ProgramInvocationException(""String_Node_Str"" + jex.getMessage());
  }
}"
88232,"private void resolveDeadlock(PactConnection conn){
  OptimizerNode sourcePact=conn.getSourcePact();
  OptimizerNode targetPact=conn.getTargetPact();
  if (sourcePact instanceof DataSourceNode) {
    DataSourceNode duplicateDataSource=new DataSourceNode((DataSourceContract)sourcePact.getPactContract());
    PactConnection newConn=new PactConnection(conn,duplicateDataSource,targetPact);
    sourcePact.getOutgoingConnections().remove(conn);
    duplicateDataSource.addOutgoingConnection(newConn);
    if (targetPact instanceof SingleInputNode) {
      ((SingleInputNode)targetPact).setInputConnection(newConn);
    }
 else     if (targetPact instanceof TwoInputNode) {
      if (((TwoInputNode)targetPact).getFirstInputConnection() == conn) {
        ((TwoInputNode)targetPact).setFirstInputConnection(newConn);
      }
 else {
        ((TwoInputNode)targetPact).setSecondInputConnection(newConn);
      }
    }
  }
 else   if (sourcePact.getIncomingConnections().size() > 1) {
    conn.setTempMode(TempMode.TEMP_RECEIVER_SIDE);
  }
 else   if (sourcePact.getOutgoingConnections().size() > 1) {
    conn.setTempMode(TempMode.TEMP_RECEIVER_SIDE);
  }
 else {
    PactConnection predConn=sourcePact.getIncomingConnections().get(0);
    long curSize=sourcePact.getEstimatedOutputSize();
    long predSize=predConn.getSourcePact().getEstimatedOutputSize();
    if (curSize < predSize) {
      conn.setTempMode(TempMode.TEMP_RECEIVER_SIDE);
    }
 else {
      resolveDeadlock(predConn);
    }
  }
}","private void resolveDeadlock(PactConnection conn){
  OptimizerNode sourcePact=conn.getSourcePact();
  OptimizerNode targetPact=conn.getTargetPact();
  if (sourcePact instanceof DataSourceNode) {
    DataSourceNode duplicateDataSource=new DataSourceNode((DataSourceContract<?,?>)sourcePact.getPactContract());
    PactConnection newConn=new PactConnection(conn,duplicateDataSource,targetPact);
    sourcePact.getOutgoingConnections().remove(conn);
    duplicateDataSource.addOutgoingConnection(newConn);
    if (targetPact instanceof SingleInputNode) {
      ((SingleInputNode)targetPact).setInputConnection(newConn);
    }
 else     if (targetPact instanceof TwoInputNode) {
      if (((TwoInputNode)targetPact).getFirstInputConnection() == conn) {
        ((TwoInputNode)targetPact).setFirstInputConnection(newConn);
      }
 else {
        ((TwoInputNode)targetPact).setSecondInputConnection(newConn);
      }
    }
  }
 else   if (sourcePact.getIncomingConnections().size() > 1) {
    conn.setTempMode(TempMode.TEMP_RECEIVER_SIDE);
  }
 else   if (sourcePact.getOutgoingConnections().size() > 1) {
    conn.setTempMode(TempMode.TEMP_RECEIVER_SIDE);
  }
 else {
    PactConnection predConn=sourcePact.getIncomingConnections().get(0);
    long curSize=sourcePact.getEstimatedOutputSize();
    long predSize=predConn.getSourcePact().getEstimatedOutputSize();
    if (curSize < predSize) {
      conn.setTempMode(TempMode.TEMP_RECEIVER_SIDE);
    }
 else {
      resolveDeadlock(predConn);
    }
  }
}"
88233,"public CombinerNode(ReduceContract<?,?,?,?> reducer,OptimizerNode predecessor,float reducingFactor){
  super(reducer);
  this.input=new PactConnection(predecessor,this,ShipStrategy.FORWARD);
  this.setLocalStrategy(LocalStrategy.COMBININGSORT);
  this.globalProps=predecessor.globalProps;
  this.localProps=predecessor.localProps;
  this.setDegreeOfParallelism(predecessor.getDegreeOfParallelism());
  this.setInstancesPerMachine(predecessor.getInstancesPerMachine());
  this.estimatedKeyCardinality=predecessor.estimatedKeyCardinality;
  if (predecessor.estimatedNumRecords >= 1 && predecessor.estimatedKeyCardinality >= 1 && predecessor.estimatedOutputSize >= -1) {
    this.estimatedNumRecords=(long)(predecessor.estimatedNumRecords * reducingFactor);
    this.estimatedOutputSize=(long)(predecessor.estimatedOutputSize * reducingFactor);
  }
 else {
    this.estimatedNumRecords=predecessor.estimatedNumRecords;
    this.estimatedOutputSize=predecessor.estimatedOutputSize;
  }
}","public CombinerNode(ReduceContract<?,?,?,?> reducer,OptimizerNode predecessor,float reducingFactor){
  super(reducer);
  this.input=new PactConnection(predecessor,this,ShipStrategy.FORWARD);
  this.setLocalStrategy(LocalStrategy.COMBININGSORT);
  this.globalProps=predecessor.globalProps;
  this.localProps=predecessor.localProps;
  this.setDegreeOfParallelism(predecessor.getDegreeOfParallelism());
  this.setInstancesPerMachine(predecessor.getInstancesPerMachine());
  this.estimatedKeyCardinality=predecessor.estimatedKeyCardinality;
  if (predecessor.estimatedNumRecords >= 1 && predecessor.estimatedKeyCardinality >= 1 && predecessor.estimatedOutputSize >= -1) {
    this.estimatedNumRecords=(long)(predecessor.estimatedNumRecords * reducingFactor);
    this.estimatedOutputSize=(long)(predecessor.estimatedOutputSize * reducingFactor);
  }
 else {
    this.estimatedNumRecords=predecessor.estimatedNumRecords;
    this.estimatedOutputSize=predecessor.estimatedOutputSize;
  }
  if (this.branchPlan == null) {
    this.branchPlan=predecessor.branchPlan;
  }
 else   if (predecessor.branchPlan != null) {
    this.branchPlan.putAll(predecessor.branchPlan);
  }
}"
88234,"/** 
 * {@inheritDoc}
 */
@Override public void run(){
  if (invokable == null) {
    LOG.fatal(""String_Node_Str"");
  }
  changeExecutionState(ExecutionState.RUNNING,null);
  if (this.isCanceled) {
    changeExecutionState(ExecutionState.CANCELED,null);
    return;
  }
  try {
    this.invokable.invoke();
    if (this.isCanceled) {
      throw new InterruptedException();
    }
  }
 catch (  Exception e) {
    if (!this.isCanceled) {
      try {
        this.invokable.cancel();
      }
 catch (      Exception e2) {
        LOG.error(StringUtils.stringifyException(e2));
      }
    }
    if (this.isCanceled) {
      changeExecutionState(ExecutionState.CANCELED,null);
    }
 else {
      changeExecutionState(ExecutionState.FAILED,StringUtils.stringifyException(e));
    }
    return;
  }
  changeExecutionState(ExecutionState.FINISHING,null);
  try {
    closeInputGates();
    requestAllOutputGatesToClose();
    waitForInputChannelsToBeClosed();
    waitForOutputChannelsToBeClosed();
  }
 catch (  Exception e) {
    if (this.isCanceled) {
      changeExecutionState(ExecutionState.CANCELED,null);
    }
 else {
      changeExecutionState(ExecutionState.FAILED,StringUtils.stringifyException(e));
    }
    return;
  }
  changeExecutionState(ExecutionState.FINISHED,null);
}","/** 
 * {@inheritDoc}
 */
@Override public void run(){
  if (invokable == null) {
    LOG.fatal(""String_Node_Str"");
  }
  changeExecutionState(ExecutionState.RUNNING,null);
  if (this.isCanceled) {
    changeExecutionState(ExecutionState.CANCELED,null);
    return;
  }
  try {
    this.invokable.invoke();
    if (this.isCanceled) {
      throw new InterruptedException();
    }
  }
 catch (  Exception e) {
    if (!this.isCanceled) {
      try {
        this.invokable.cancel();
      }
 catch (      Exception e2) {
        LOG.error(StringUtils.stringifyException(e2));
      }
    }
    releaseAllChannelResources();
    if (this.isCanceled) {
      changeExecutionState(ExecutionState.CANCELED,null);
    }
 else {
      changeExecutionState(ExecutionState.FAILED,StringUtils.stringifyException(e));
    }
    return;
  }
  changeExecutionState(ExecutionState.FINISHING,null);
  try {
    closeInputGates();
    requestAllOutputGatesToClose();
    waitForInputChannelsToBeClosed();
    waitForOutputChannelsToBeClosed();
  }
 catch (  Exception e) {
    if (this.isCanceled) {
      changeExecutionState(ExecutionState.CANCELED,null);
    }
 else {
      changeExecutionState(ExecutionState.FAILED,StringUtils.stringifyException(e));
    }
    return;
  }
  changeExecutionState(ExecutionState.FINISHED,null);
}"
88235,"public void changeExecutionState(ExecutionState newExecutionState,String optionalMessage){
  if (this.executionState == ExecutionState.CANCELED || this.executionState == ExecutionState.FINISHED || this.executionState == ExecutionState.FAILED) {
    return;
  }
  LOG.info(""String_Node_Str"" + executionState + ""String_Node_Str""+ newExecutionState+ ""String_Node_Str""+ this.getTaskName()+ ""String_Node_Str""+ (this.getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
  boolean unexpectedStateChange=true;
  if (this.executionState == ExecutionState.CREATED && newExecutionState == ExecutionState.SCHEDULED) {
    unexpectedStateChange=false;
  }
  if (this.executionState == ExecutionState.SCHEDULED && newExecutionState == ExecutionState.ASSIGNING) {
    unexpectedStateChange=false;
  }
  if (this.executionState == ExecutionState.ASSIGNING && newExecutionState == ExecutionState.ASSIGNED) {
    unexpectedStateChange=false;
  }
  if (this.executionState == ExecutionState.ASSIGNED && newExecutionState == ExecutionState.READY) {
    unexpectedStateChange=false;
  }
  if (this.executionState == ExecutionState.READY && newExecutionState == ExecutionState.RUNNING) {
    unexpectedStateChange=false;
  }
  if (this.executionState == ExecutionState.RUNNING && newExecutionState == ExecutionState.FINISHING) {
    unexpectedStateChange=false;
  }
  if (this.executionState == ExecutionState.FINISHING && newExecutionState == ExecutionState.FINISHED) {
    unexpectedStateChange=false;
  }
  if (this.executionState == ExecutionState.SCHEDULED && newExecutionState == ExecutionState.ASSIGNED) {
    unexpectedStateChange=false;
  }
  if (this.executionState == ExecutionState.SCHEDULED && newExecutionState == ExecutionState.CANCELED) {
    unexpectedStateChange=false;
  }
  if (this.executionState == ExecutionState.ASSIGNING && newExecutionState == ExecutionState.CANCELED) {
    unexpectedStateChange=false;
  }
  if (this.executionState == ExecutionState.ASSIGNED && newExecutionState == ExecutionState.CANCELED) {
    unexpectedStateChange=false;
  }
  if (this.executionState == ExecutionState.READY && newExecutionState == ExecutionState.CANCELED) {
    unexpectedStateChange=false;
  }
  if (this.executionState == ExecutionState.RUNNING && newExecutionState == ExecutionState.FAILED) {
    unexpectedStateChange=false;
  }
  if (this.executionState == ExecutionState.FINISHING && newExecutionState == ExecutionState.FAILED) {
    unexpectedStateChange=false;
  }
  if (this.executionState == ExecutionState.RUNNING && newExecutionState == ExecutionState.CANCELING) {
    unexpectedStateChange=false;
  }
  if (this.executionState == ExecutionState.CANCELING && newExecutionState == ExecutionState.CANCELED) {
    unexpectedStateChange=false;
  }
  if (unexpectedStateChange) {
    LOG.error(""String_Node_Str"" + this.executionState + ""String_Node_Str""+ newExecutionState);
  }
  this.executionState=newExecutionState;
synchronized (this.executionListeners) {
    final Iterator<ExecutionListener> it=this.executionListeners.iterator();
    while (it.hasNext()) {
      it.next().executionStateChanged(this,newExecutionState,optionalMessage);
    }
  }
}","public void changeExecutionState(ExecutionState newExecutionState,String optionalMessage){
  if (this.executionState == ExecutionState.CANCELED || this.executionState == ExecutionState.FINISHED || this.executionState == ExecutionState.FAILED) {
    return;
  }
  LOG.info(""String_Node_Str"" + executionState + ""String_Node_Str""+ newExecutionState+ ""String_Node_Str""+ this.getTaskName()+ ""String_Node_Str""+ (this.getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
  boolean unexpectedStateChange=true;
  if (this.executionState == ExecutionState.CREATED && newExecutionState == ExecutionState.SCHEDULED) {
    unexpectedStateChange=false;
  }
  if (this.executionState == ExecutionState.SCHEDULED && newExecutionState == ExecutionState.ASSIGNING) {
    unexpectedStateChange=false;
  }
  if (this.executionState == ExecutionState.ASSIGNING && newExecutionState == ExecutionState.ASSIGNED) {
    unexpectedStateChange=false;
  }
  if (this.executionState == ExecutionState.ASSIGNED && newExecutionState == ExecutionState.READY) {
    unexpectedStateChange=false;
  }
  if (this.executionState == ExecutionState.READY && newExecutionState == ExecutionState.RUNNING) {
    unexpectedStateChange=false;
  }
  if (this.executionState == ExecutionState.RUNNING && newExecutionState == ExecutionState.FINISHING) {
    unexpectedStateChange=false;
  }
  if (this.executionState == ExecutionState.FINISHING && newExecutionState == ExecutionState.FINISHED) {
    unexpectedStateChange=false;
  }
  if (this.executionState == ExecutionState.SCHEDULED && newExecutionState == ExecutionState.ASSIGNED) {
    unexpectedStateChange=false;
  }
  if (this.executionState == ExecutionState.SCHEDULED && newExecutionState == ExecutionState.CANCELED) {
    unexpectedStateChange=false;
  }
  if (this.executionState == ExecutionState.ASSIGNING && newExecutionState == ExecutionState.CANCELED) {
    unexpectedStateChange=false;
  }
  if (this.executionState == ExecutionState.ASSIGNED && newExecutionState == ExecutionState.CANCELED) {
    unexpectedStateChange=false;
  }
  if (this.executionState == ExecutionState.READY && newExecutionState == ExecutionState.CANCELED) {
    unexpectedStateChange=false;
  }
  if (this.executionState == ExecutionState.RUNNING && newExecutionState == ExecutionState.FAILED) {
    unexpectedStateChange=false;
  }
  if (this.executionState == ExecutionState.FINISHING && newExecutionState == ExecutionState.FAILED) {
    unexpectedStateChange=false;
  }
  if (this.executionState == ExecutionState.RUNNING && newExecutionState == ExecutionState.CANCELING) {
    unexpectedStateChange=false;
  }
  if (this.executionState == ExecutionState.FINISHING && newExecutionState == ExecutionState.CANCELING) {
    unexpectedStateChange=false;
  }
  if (this.executionState == ExecutionState.CANCELING && newExecutionState == ExecutionState.CANCELED) {
    unexpectedStateChange=false;
  }
  if (unexpectedStateChange) {
    LOG.error(""String_Node_Str"" + this.executionState + ""String_Node_Str""+ newExecutionState);
  }
  this.executionState=newExecutionState;
synchronized (this.executionListeners) {
    final Iterator<ExecutionListener> it=this.executionListeners.iterator();
    while (it.hasNext()) {
      it.next().executionStateChanged(this,newExecutionState,optionalMessage);
    }
  }
}"
88236,"@Override public String toString(){
  return ""String_Node_Str"" + this.index;
}","/** 
 * {@inheritDoc}
 */
@Override public String toString(){
  return ""String_Node_Str"" + this.index;
}"
88237,"/** 
 * Publishes an event.
 * @param event the event to be published
 * @throws IOException thrown if an error occurs while transmitting the event
 * @throws InterruptedException thrown if the thread is interrupted while waiting for the event to be published
 */
public void publishEvent(AbstractTaskEvent event) throws IOException, InterruptedException {
  Iterator<AbstractInputChannel<T>> it=this.inputChannels.iterator();
  while (it.hasNext()) {
    it.next().transferEvent(event);
  }
}","/** 
 * Publishes an event.
 * @param event the event to be published
 * @throws IOException thrown if an error occurs while transmitting the event
 * @throws InterruptedException thrown if the thread is interrupted while waiting for the event to be published
 */
public void publishEvent(AbstractTaskEvent event) throws IOException, InterruptedException {
  final Iterator<AbstractInputChannel<T>> it=this.inputChannels.iterator();
  while (it.hasNext()) {
    it.next().transferEvent(event);
  }
}"
88238,"/** 
 * {@inheritDoc}
 */
@SuppressWarnings(""String_Node_Str"") @Override public void read(DataInput in) throws IOException {
  super.read(in);
  try {
    String classNameSelector=StringRecord.readString(in);
    final ClassLoader cl=LibraryCacheManager.getClassLoader(getJobID());
    channelSelector=(ChannelSelector<T>)Class.forName(classNameSelector,true,cl).newInstance();
    channelSelector.read(in);
  }
 catch (  InstantiationException e) {
    LOG.error(e);
  }
catch (  IllegalAccessException e) {
    LOG.error(e);
  }
catch (  ClassNotFoundException e) {
    LOG.error(e);
  }
  final int numOutputChannels=in.readInt();
  final Class<?>[] parameters={this.getClass(),int.class,ChannelID.class,CompressionLevel.class};
  for (int i=0; i < numOutputChannels; i++) {
    final ChannelID channelID=new ChannelID();
    channelID.read(in);
    final CompressionLevel compressionLevel=EnumUtils.readEnum(in,CompressionLevel.class);
    final String className=StringRecord.readString(in);
    Class<? extends IOReadableWritable> c=null;
    try {
      c=ClassUtils.getRecordByName(className);
    }
 catch (    ClassNotFoundException e) {
      LOG.error(e);
    }
    if (c == null) {
      throw new IOException(""String_Node_Str"");
    }
    AbstractOutputChannel<T> eoc=null;
    try {
      final Constructor<AbstractOutputChannel<T>> constructor=(Constructor<AbstractOutputChannel<T>>)c.getDeclaredConstructor(parameters);
      if (constructor == null) {
        throw new IOException(""String_Node_Str"");
      }
      constructor.setAccessible(true);
      eoc=constructor.newInstance(this,i,channelID,compressionLevel);
    }
 catch (    InstantiationException e) {
      LOG.error(e);
    }
catch (    IllegalArgumentException e) {
      LOG.error(e);
    }
catch (    IllegalAccessException e) {
      LOG.error(e);
    }
catch (    InvocationTargetException e) {
      LOG.error(e);
    }
catch (    SecurityException e) {
      LOG.error(e);
    }
catch (    NoSuchMethodException e) {
      LOG.error(e);
    }
    if (eoc == null) {
      throw new IOException(""String_Node_Str"");
    }
    eoc.read(in);
    addOutputChannel(eoc);
  }
}","/** 
 * {@inheritDoc}
 */
@SuppressWarnings(""String_Node_Str"") @Override public void read(DataInput in) throws IOException {
  super.read(in);
  try {
    final String classNameSelector=StringRecord.readString(in);
    final ClassLoader cl=LibraryCacheManager.getClassLoader(getJobID());
    this.channelSelector=(ChannelSelector<T>)Class.forName(classNameSelector,true,cl).newInstance();
    this.channelSelector.read(in);
  }
 catch (  InstantiationException e) {
    LOG.error(e);
  }
catch (  IllegalAccessException e) {
    LOG.error(e);
  }
catch (  ClassNotFoundException e) {
    LOG.error(e);
  }
  final int numOutputChannels=in.readInt();
  final Class<?>[] parameters={this.getClass(),int.class,ChannelID.class,CompressionLevel.class};
  for (int i=0; i < numOutputChannels; i++) {
    final ChannelID channelID=new ChannelID();
    channelID.read(in);
    final CompressionLevel compressionLevel=EnumUtils.readEnum(in,CompressionLevel.class);
    final String className=StringRecord.readString(in);
    Class<? extends IOReadableWritable> c=null;
    try {
      c=ClassUtils.getRecordByName(className);
    }
 catch (    ClassNotFoundException e) {
      LOG.error(e);
    }
    if (c == null) {
      throw new IOException(""String_Node_Str"");
    }
    AbstractOutputChannel<T> eoc=null;
    try {
      final Constructor<AbstractOutputChannel<T>> constructor=(Constructor<AbstractOutputChannel<T>>)c.getDeclaredConstructor(parameters);
      if (constructor == null) {
        throw new IOException(""String_Node_Str"");
      }
      constructor.setAccessible(true);
      eoc=constructor.newInstance(this,i,channelID,compressionLevel);
    }
 catch (    InstantiationException e) {
      LOG.error(e);
    }
catch (    IllegalArgumentException e) {
      LOG.error(e);
    }
catch (    IllegalAccessException e) {
      LOG.error(e);
    }
catch (    InvocationTargetException e) {
      LOG.error(e);
    }
catch (    SecurityException e) {
      LOG.error(e);
    }
catch (    NoSuchMethodException e) {
      LOG.error(e);
    }
    if (eoc == null) {
      throw new IOException(""String_Node_Str"");
    }
    eoc.read(in);
    addOutputChannel(eoc);
  }
}"
88239,public abstract boolean isInputChannel();,"/** 
 * Returns <code>true</code> if this channel is an input channel, <code>false</code> otherwise.
 * @return <code>true</code> if this channel is an input channel, <code>false</code> otherwise
 */
public abstract boolean isInputChannel();"
88240,"@Override public void transferEvent(AbstractEvent event) throws IOException {
  if (this.connectedInMemoryOutputChannel == null) {
    this.connectedInMemoryOutputChannel=getConnectedOutputChannel();
  }
  this.connectedInMemoryOutputChannel.processEvent(event);
}","/** 
 * {@inheritDoc}
 */
@Override public void transferEvent(AbstractEvent event) throws IOException {
  if (this.connectedInMemoryOutputChannel == null) {
    this.connectedInMemoryOutputChannel=getConnectedOutputChannel();
  }
  this.connectedInMemoryOutputChannel.processEvent(event);
}"
88241,"@Override public void processEvent(AbstractEvent event){
  if (AbstractTaskEvent.class.isInstance(event)) {
    getInputGate().deliverEvent((AbstractTaskEvent)event);
  }
 else {
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void processEvent(AbstractEvent event){
  if (AbstractTaskEvent.class.isInstance(event)) {
    getInputGate().deliverEvent((AbstractTaskEvent)event);
  }
 else {
  }
}"
88242,"@Override public void flush() throws IOException, InterruptedException {
  if (this.connectedDirectInputChannel == null) {
    this.connectedDirectInputChannel=getConnectedInputChannel();
  }
  this.connectedDirectInputChannel.requestFlush();
}","/** 
 * {@inheritDoc}
 */
@Override public void flush() throws IOException, InterruptedException {
  if (this.connectedDirectInputChannel == null) {
    this.connectedDirectInputChannel=getConnectedInputChannel();
  }
  this.connectedDirectInputChannel.requestFlush();
}"
88243,"@Override public void transferEvent(AbstractEvent event) throws IOException, InterruptedException {
  if (this.connectedDirectInputChannel == null) {
    this.connectedDirectInputChannel=getConnectedInputChannel();
  }
  this.connectedDirectInputChannel.processEvent(event);
}","/** 
 * {@inheritDoc}
 */
@Override public void transferEvent(AbstractEvent event) throws IOException, InterruptedException {
  if (this.connectedDirectInputChannel == null) {
    this.connectedDirectInputChannel=getConnectedInputChannel();
  }
  this.connectedDirectInputChannel.processEvent(event);
}"
88244,"@Override public V next(){
  return next.getValue();
}","@Override public V next(){
  nextCalled=true;
  return next.getValue();
}"
88245,"public Iterator<V> getValues(){
  return new Iterator<V>(){
    boolean first=true;
    boolean last=false;
    @Override public boolean hasNext(){
      if (first) {
        first=false;
        return true;
      }
 else       if (last) {
        return false;
      }
 else {
        if (!iterator.hasNext()) {
          return false;
        }
        KeyValuePair<K,V> prev=next;
        next=iterator.next();
        if (next.getKey().compareTo(prev.getKey()) == 0) {
          return true;
        }
 else {
          last=true;
          nextKey=true;
          return false;
        }
      }
    }
    @Override public V next(){
      return next.getValue();
    }
    @Override public void remove(){
    }
  }
;
}","public Iterator<V> getValues(){
  return new Iterator<V>(){
    boolean first=true;
    boolean last=false;
    boolean nextCalled=true;
    @Override public boolean hasNext(){
      if (first) {
        first=false;
        return true;
      }
 else       if (last) {
        return false;
      }
 else {
        if (nextCalled) {
          if (!iterator.hasNext()) {
            return false;
          }
          nextCalled=false;
          KeyValuePair<K,V> prev=next;
          next=iterator.next();
          if (next.getKey().compareTo(prev.getKey()) == 0) {
            return true;
          }
 else {
            last=true;
            nextKey=true;
            return false;
          }
        }
 else {
          return true;
        }
      }
    }
    @Override public V next(){
      nextCalled=true;
      return next.getValue();
    }
    @Override public void remove(){
    }
  }
;
}"
88246,"@Override public boolean hasNext(){
  if (first) {
    first=false;
    return true;
  }
 else   if (last) {
    return false;
  }
 else {
    if (!iterator.hasNext()) {
      return false;
    }
    KeyValuePair<K,V> prev=next;
    next=iterator.next();
    if (next.getKey().compareTo(prev.getKey()) == 0) {
      return true;
    }
 else {
      last=true;
      nextKey=true;
      return false;
    }
  }
}","@Override public boolean hasNext(){
  if (first) {
    first=false;
    return true;
  }
 else   if (last) {
    return false;
  }
 else {
    if (nextCalled) {
      if (!iterator.hasNext()) {
        return false;
      }
      nextCalled=false;
      KeyValuePair<K,V> prev=next;
      next=iterator.next();
      if (next.getKey().compareTo(prev.getKey()) == 0) {
        return true;
      }
 else {
        last=true;
        nextKey=true;
        return false;
      }
    }
 else {
      return true;
    }
  }
}"
88247,"/** 
 * Crosses a single value with N values all sharing a common key.
 * @param key The key shared by all values
 * @param val1 The single value
 * @param valsN Iterator over N values
 * @param firstInputNValues Set to true if the first input in N-value side, false otherwise.
 * @throws RuntimeException Forwards all exceptions thrown by the stub.
 */
private void cross1withNValues(Key key,Value val1,Iterator<Value> valsN,final boolean firstInputNValues) throws RuntimeException {
  Value v1;
  Value vN;
  keyCopier.setCopy(key);
  this.v1Copier.setCopy(val1);
  while (!this.taskCanceled && valsN.hasNext()) {
    key=this.keySerialization.newInstance();
    this.keyCopier.getCopy(key);
    v1=this.v1Serialization.newInstance();
    this.v1Copier.getCopy(v1);
    vN=valsN.next();
    if (firstInputNValues) {
      matchStub.match(key,vN,v1,output);
    }
 else {
      matchStub.match(key,v1,vN,output);
    }
  }
}","/** 
 * Crosses a single value with N values all sharing a common key.
 * @param key The key shared by all values
 * @param val1 The single value
 * @param valsN Iterator over N values
 * @param firstInputNValues Set to true if the first input in N-value side, false otherwise.
 * @throws RuntimeException Forwards all exceptions thrown by the stub.
 */
private void cross1withNValues(Key key,Value val1,Iterator<Value> valsN,final boolean firstInputNValues) throws RuntimeException {
  Value v1;
  Value vN;
  keyCopier.setCopy(key);
  this.v1Copier.setCopy(val1);
  while (!this.taskCanceled && valsN.hasNext()) {
    key=this.keySerialization.newInstance();
    this.keyCopier.getCopy(key);
    vN=valsN.next();
    if (firstInputNValues) {
      v1=this.v2Serialization.newInstance();
      this.v1Copier.getCopy(v1);
      matchStub.match(key,vN,v1,output);
    }
 else {
      v1=this.v1Serialization.newInstance();
      this.v1Copier.getCopy(v1);
      matchStub.match(key,v1,vN,output);
    }
  }
}"
88248,"@Override public KeyValuePair<Key,Value> next(){
  try {
    KeyValuePair<Key,Value> pair=outerReader.next();
    copier.setCopy(pair);
    return pair;
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
catch (  InterruptedException e) {
    throw new RuntimeException(e);
  }
}","@Override public KeyValuePair<Key,Value> next(){
  try {
    KeyValuePair<Key,Value> pair=reader.next();
    copier.setCopy(pair);
    return pair;
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
catch (  InterruptedException e) {
    throw new RuntimeException(e);
  }
}"
88249,"/** 
 * Runs a streamed nested loop strategy to build the Cartesian product and call the <code>cross()</code> method of the CrossStub implementation. The outer side is read directly from the input reader. The inner side is read and reseted using a SpillingResettableIterator.
 * @see eu.stratosphere.pact.runtime.resettable.SpillingResettableIterator
 * @param memoryManager The task manager's memory manager.
 * @param ioManager The task manager's IO manager
 * @param innerReader The inner reader of the nested loops.
 * @param outerReader The outer reader of the nested loops.
 * @throws RuntimeException Throws a RuntimeException if something fails during execution.
 */
private void runStreamed(MemoryManager memoryManager,IOManager ioManager,RecordReader<KeyValuePair<Key,Value>> innerReader,final RecordReader<KeyValuePair<Key,Value>> outerReader) throws Exception {
  LastRepeatableIterator<KeyValuePair<Key,Value>> outerInput=new LastRepeatableIterator<KeyValuePair<Key,Value>>(){
    SerializationCopier<KeyValuePair<Key,Value>> copier=new SerializationCopier<KeyValuePair<Key,Value>>();
    KeyValuePairDeserializer<Key,Value> deserializer=new KeyValuePairDeserializer<Key,Value>(stub.getSecondInKeyType(),stub.getSecondInValueType());
    @Override public boolean hasNext(){
      return outerReader.hasNext();
    }
    @Override public KeyValuePair<Key,Value> next(){
      try {
        KeyValuePair<Key,Value> pair=outerReader.next();
        copier.setCopy(pair);
        return pair;
      }
 catch (      IOException e) {
        throw new RuntimeException(e);
      }
catch (      InterruptedException e) {
        throw new RuntimeException(e);
      }
    }
    @Override public void remove(){
      throw new UnsupportedOperationException();
    }
    @Override public KeyValuePair<Key,Value> repeatLast(){
      KeyValuePair<Key,Value> pair=deserializer.getInstance();
      copier.getCopy(pair);
      return pair;
    }
  }
;
  SpillingResettableIterator<KeyValuePair<Key,Value>> innerInput=null;
  try {
    try {
      innerInput=new SpillingResettableIterator<KeyValuePair<Key,Value>>(memoryManager,ioManager,innerReader,this.availableMemory,new KeyValuePairDeserializer<Key,Value>(stub.getFirstInKeyType(),stub.getFirstInValueType()),this);
      spillingResetIt=innerInput;
    }
 catch (    MemoryAllocationException mae) {
      throw new RuntimeException(""String_Node_Str"",mae);
    }
    try {
      innerInput.open();
    }
 catch (    ServiceException se) {
      throw new RuntimeException(""String_Node_Str"",se);
    }
catch (    IOException ioe) {
      throw new RuntimeException(""String_Node_Str"",ioe);
    }
catch (    InterruptedException ie) {
      throw new RuntimeException(""String_Node_Str"",ie);
    }
    if (this.taskCanceled)     return;
    LOG.debug(""String_Node_Str"" + this.getEnvironment().getTaskName() + ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
    stub.open();
    if (config.getLocalStrategy() == LocalStrategy.NESTEDLOOP_STREAMED_OUTER_SECOND) {
      while (!this.taskCanceled && outerInput.hasNext()) {
        Pair outerPair=outerInput.next();
        while (!this.taskCanceled && innerInput.hasNext()) {
          Pair innerPair=innerInput.next();
          stub.cross(innerPair.getKey(),innerPair.getValue(),outerPair.getKey(),outerPair.getValue(),output);
          outerPair=outerInput.repeatLast();
        }
        if (!this.taskCanceled && outerInput.hasNext()) {
          innerInput.reset();
        }
      }
    }
 else {
      while (!this.taskCanceled && outerInput.hasNext()) {
        Pair outerPair=outerInput.next();
        while (!this.taskCanceled && innerInput.hasNext()) {
          Pair innerPair=innerInput.next();
          stub.cross(outerPair.getKey(),outerPair.getValue(),innerPair.getKey(),innerPair.getValue(),output);
          outerPair=outerInput.repeatLast();
        }
        if (!this.taskCanceled && outerInput.hasNext()) {
          innerInput.reset();
        }
      }
    }
    stub.close();
  }
 catch (  Exception ex) {
    if (!this.taskCanceled) {
      LOG.error(""String_Node_Str"" + this.getEnvironment().getTaskName() + ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
      throw ex;
    }
  }
 finally {
    if (innerInput != null) {
      innerInput.close();
    }
  }
}","/** 
 * Runs a streamed nested loop strategy to build the Cartesian product and call the <code>cross()</code> method of the CrossStub implementation. The outer side is read directly from the input reader. The inner side is read and reseted using a SpillingResettableIterator.
 * @see eu.stratosphere.pact.runtime.resettable.SpillingResettableIterator
 * @param memoryManager The task manager's memory manager.
 * @param ioManager The task manager's IO manager
 * @param innerReader The inner reader of the nested loops.
 * @param outerReader The outer reader of the nested loops.
 * @throws RuntimeException Throws a RuntimeException if something fails during execution.
 */
private void runStreamed(MemoryManager memoryManager,IOManager ioManager,RecordReader<KeyValuePair<Key,Value>> innerReader,final RecordReader<KeyValuePair<Key,Value>> outerReader) throws Exception {
  SpillingResettableIterator<KeyValuePair<Key,Value>> innerInput=null;
  RepeatableReaderIterator outerInput=null;
  try {
    final boolean firstInputIsOuter;
    if (config.getLocalStrategy() == LocalStrategy.NESTEDLOOP_STREAMED_OUTER_FIRST) {
      try {
        innerInput=new SpillingResettableIterator<KeyValuePair<Key,Value>>(memoryManager,ioManager,innerReader,this.availableMemory,new KeyValuePairDeserializer<Key,Value>(stub.getSecondInKeyType(),stub.getSecondInValueType()),this);
        spillingResetIt=innerInput;
      }
 catch (      MemoryAllocationException mae) {
        throw new RuntimeException(""String_Node_Str"",mae);
      }
      outerInput=new RepeatableReaderIterator(outerReader,stub.getFirstInKeyType(),stub.getFirstInValueType());
      firstInputIsOuter=true;
    }
 else     if (config.getLocalStrategy() == LocalStrategy.NESTEDLOOP_STREAMED_OUTER_SECOND) {
      try {
        innerInput=new SpillingResettableIterator<KeyValuePair<Key,Value>>(memoryManager,ioManager,innerReader,this.availableMemory,new KeyValuePairDeserializer<Key,Value>(stub.getFirstInKeyType(),stub.getFirstInValueType()),this);
        spillingResetIt=innerInput;
      }
 catch (      MemoryAllocationException mae) {
        throw new RuntimeException(""String_Node_Str"",mae);
      }
      outerInput=new RepeatableReaderIterator(outerReader,stub.getSecondInKeyType(),stub.getSecondInValueType());
      firstInputIsOuter=false;
    }
 else {
      throw new RuntimeException(""String_Node_Str"" + config.getLocalStrategy());
    }
    try {
      innerInput.open();
    }
 catch (    ServiceException se) {
      throw new RuntimeException(""String_Node_Str"",se);
    }
catch (    IOException ioe) {
      throw new RuntimeException(""String_Node_Str"",ioe);
    }
catch (    InterruptedException ie) {
      throw new RuntimeException(""String_Node_Str"",ie);
    }
    if (this.taskCanceled)     return;
    LOG.debug(""String_Node_Str"" + this.getEnvironment().getTaskName() + ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
    stub.open();
    while (!this.taskCanceled && outerInput.hasNext()) {
      Pair outerPair=outerInput.next();
      while (!this.taskCanceled && innerInput.hasNext()) {
        Pair innerPair=innerInput.next();
        if (firstInputIsOuter) {
          stub.cross(outerPair.getKey(),outerPair.getValue(),innerPair.getKey(),innerPair.getValue(),output);
        }
 else {
          stub.cross(innerPair.getKey(),innerPair.getValue(),outerPair.getKey(),outerPair.getValue(),output);
        }
        outerPair=outerInput.repeatLast();
      }
      if (!this.taskCanceled && outerInput.hasNext()) {
        innerInput.reset();
      }
    }
    stub.close();
  }
 catch (  Exception ex) {
    if (!this.taskCanceled) {
      LOG.error(""String_Node_Str"" + this.getEnvironment().getTaskName() + ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
      throw ex;
    }
  }
 finally {
    if (innerInput != null) {
      innerInput.close();
    }
  }
}"
88250,"@Override public boolean hasNext(){
  return outerReader.hasNext();
}","@Override public boolean hasNext(){
  return reader.hasNext();
}"
88251,"/** 
 * Runs a blocked nested loop strategy to build the Cartesian product and call the <code>cross()</code> method of the CrossStub implementation. The outer side is read using a BlockResettableIterator. The inner side is read using a SpillingResettableIterator.
 * @see eu.stratosphere.pact.runtime.resettable.SpillingResettableIterator
 * @see eu.stratosphere.pact.runtime.resettable.BlockResettableIterator
 * @param memoryManager The task manager's memory manager.
 * @param ioManager The task manager's IO manager
 * @param innerReader The inner reader of the nested loops.
 * @param outerReader The outer reader of the nested loops.
 * @throws RuntimeException Throws a RuntimeException if something fails during execution.
 */
private void runBlocked(MemoryManager memoryManager,IOManager ioManager,RecordReader<KeyValuePair<Key,Value>> innerReader,RecordReader<KeyValuePair<Key,Value>> outerReader) throws Exception {
  SpillingResettableIterator<KeyValuePair<Key,Value>> innerInput=null;
  BlockResettableIterator<KeyValuePair<Key,Value>> outerInput=null;
  try {
    if (config.getLocalStrategy() == LocalStrategy.NESTEDLOOP_BLOCKED_OUTER_SECOND) {
      try {
        innerInput=new SpillingResettableIterator<KeyValuePair<Key,Value>>(memoryManager,ioManager,innerReader,this.availableMemory / 2,new KeyValuePairDeserializer<Key,Value>(stub.getFirstInKeyType(),stub.getFirstInValueType()),this);
        spillingResetIt=innerInput;
      }
 catch (      MemoryAllocationException mae) {
        throw new RuntimeException(""String_Node_Str"",mae);
      }
      try {
        outerInput=new BlockResettableIterator<KeyValuePair<Key,Value>>(memoryManager,outerReader,this.availableMemory / 2,1,new KeyValuePairDeserializer<Key,Value>(stub.getSecondInKeyType(),stub.getSecondInValueType()),this);
        blockResetIt=outerInput;
      }
 catch (      MemoryAllocationException mae) {
        throw new RuntimeException(""String_Node_Str"",mae);
      }
    }
 else     if (config.getLocalStrategy() == LocalStrategy.NESTEDLOOP_BLOCKED_OUTER_FIRST) {
      try {
        innerInput=new SpillingResettableIterator<KeyValuePair<Key,Value>>(memoryManager,ioManager,innerReader,this.availableMemory / 2,new KeyValuePairDeserializer<Key,Value>(stub.getSecondInKeyType(),stub.getSecondInValueType()),this);
        spillingResetIt=innerInput;
      }
 catch (      MemoryAllocationException mae) {
        throw new RuntimeException(""String_Node_Str"",mae);
      }
      try {
        outerInput=new BlockResettableIterator<KeyValuePair<Key,Value>>(memoryManager,outerReader,this.availableMemory / 2,1,new KeyValuePairDeserializer<Key,Value>(stub.getFirstInKeyType(),stub.getFirstInValueType()),this);
        blockResetIt=outerInput;
      }
 catch (      MemoryAllocationException mae) {
        throw new RuntimeException(""String_Node_Str"",mae);
      }
    }
 else {
      throw new RuntimeException(""String_Node_Str"" + config.getLocalStrategy());
    }
    try {
      innerInput.open();
    }
 catch (    ServiceException se) {
      throw new RuntimeException(""String_Node_Str"",se);
    }
catch (    IOException ioe) {
      throw new RuntimeException(""String_Node_Str"",ioe);
    }
catch (    InterruptedException ie) {
      throw new RuntimeException(""String_Node_Str"",ie);
    }
    if (this.taskCanceled)     return;
    outerInput.open();
    LOG.debug(""String_Node_Str"" + this.getEnvironment().getTaskName() + ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
    LOG.debug(""String_Node_Str"" + this.getEnvironment().getTaskName() + ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
    stub.open();
    boolean moreOuterBlocks=false;
    if (config.getLocalStrategy() == LocalStrategy.NESTEDLOOP_BLOCKED_OUTER_SECOND) {
      do {
        while (!this.taskCanceled && innerInput.hasNext()) {
          Pair<Key,Value> innerPair=innerInput.next();
          while (!this.taskCanceled && outerInput.hasNext()) {
            Pair<Key,Value> outerPair=outerInput.next();
            stub.cross(innerPair.getKey(),innerPair.getValue(),outerPair.getKey(),outerPair.getValue(),output);
            innerPair=innerInput.repeatLast();
          }
          outerInput.reset();
        }
        moreOuterBlocks=outerInput.nextBlock();
        if (moreOuterBlocks) {
          innerInput.reset();
        }
      }
 while (!this.taskCanceled && moreOuterBlocks);
    }
 else {
      do {
        while (!this.taskCanceled && innerInput.hasNext()) {
          Pair<Key,Value> innerPair=innerInput.next();
          while (!this.taskCanceled && outerInput.hasNext()) {
            Pair<Key,Value> outerPair=outerInput.next();
            stub.cross(outerPair.getKey(),outerPair.getValue(),innerPair.getKey(),innerPair.getValue(),output);
            innerPair=innerInput.repeatLast();
          }
          outerInput.reset();
        }
        moreOuterBlocks=outerInput.nextBlock();
        if (moreOuterBlocks) {
          innerInput.reset();
        }
      }
 while (!this.taskCanceled && moreOuterBlocks);
    }
    stub.close();
  }
 catch (  Exception ex) {
    if (!this.taskCanceled) {
      LOG.error(""String_Node_Str"" + this.getEnvironment().getTaskName() + ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
      throw ex;
    }
  }
 finally {
    Throwable t1=null, t2=null;
    try {
      if (innerInput != null) {
        innerInput.close();
      }
    }
 catch (    Throwable t) {
      LOG.warn(t);
      t1=t;
    }
    try {
      if (outerInput != null) {
        outerInput.close();
      }
    }
 catch (    Throwable t) {
      LOG.warn(t);
      t2=t;
    }
    if (t1 != null)     throw new RuntimeException(""String_Node_Str"",t1);
    if (t2 != null)     throw new RuntimeException(""String_Node_Str"",t2);
  }
}","/** 
 * Runs a blocked nested loop strategy to build the Cartesian product and call the <code>cross()</code> method of the CrossStub implementation. The outer side is read using a BlockResettableIterator. The inner side is read using a SpillingResettableIterator.
 * @see eu.stratosphere.pact.runtime.resettable.SpillingResettableIterator
 * @see eu.stratosphere.pact.runtime.resettable.BlockResettableIterator
 * @param memoryManager The task manager's memory manager.
 * @param ioManager The task manager's IO manager
 * @param innerReader The inner reader of the nested loops.
 * @param outerReader The outer reader of the nested loops.
 * @throws RuntimeException Throws a RuntimeException if something fails during execution.
 */
private void runBlocked(MemoryManager memoryManager,IOManager ioManager,RecordReader<KeyValuePair<Key,Value>> innerReader,RecordReader<KeyValuePair<Key,Value>> outerReader) throws Exception {
  SpillingResettableIterator<KeyValuePair<Key,Value>> innerInput=null;
  BlockResettableIterator<KeyValuePair<Key,Value>> outerInput=null;
  try {
    final boolean firstInputIsOuter;
    if (config.getLocalStrategy() == LocalStrategy.NESTEDLOOP_BLOCKED_OUTER_SECOND) {
      try {
        innerInput=new SpillingResettableIterator<KeyValuePair<Key,Value>>(memoryManager,ioManager,innerReader,this.availableMemory / 2,new KeyValuePairDeserializer<Key,Value>(stub.getFirstInKeyType(),stub.getFirstInValueType()),this);
        spillingResetIt=innerInput;
      }
 catch (      MemoryAllocationException mae) {
        throw new RuntimeException(""String_Node_Str"",mae);
      }
      try {
        outerInput=new BlockResettableIterator<KeyValuePair<Key,Value>>(memoryManager,outerReader,this.availableMemory / 2,1,new KeyValuePairDeserializer<Key,Value>(stub.getSecondInKeyType(),stub.getSecondInValueType()),this);
        blockResetIt=outerInput;
      }
 catch (      MemoryAllocationException mae) {
        throw new RuntimeException(""String_Node_Str"",mae);
      }
      firstInputIsOuter=false;
    }
 else     if (config.getLocalStrategy() == LocalStrategy.NESTEDLOOP_BLOCKED_OUTER_FIRST) {
      try {
        innerInput=new SpillingResettableIterator<KeyValuePair<Key,Value>>(memoryManager,ioManager,innerReader,this.availableMemory / 2,new KeyValuePairDeserializer<Key,Value>(stub.getSecondInKeyType(),stub.getSecondInValueType()),this);
        spillingResetIt=innerInput;
      }
 catch (      MemoryAllocationException mae) {
        throw new RuntimeException(""String_Node_Str"",mae);
      }
      try {
        outerInput=new BlockResettableIterator<KeyValuePair<Key,Value>>(memoryManager,outerReader,this.availableMemory / 2,1,new KeyValuePairDeserializer<Key,Value>(stub.getFirstInKeyType(),stub.getFirstInValueType()),this);
        blockResetIt=outerInput;
      }
 catch (      MemoryAllocationException mae) {
        throw new RuntimeException(""String_Node_Str"",mae);
      }
      firstInputIsOuter=true;
    }
 else {
      throw new RuntimeException(""String_Node_Str"" + config.getLocalStrategy());
    }
    try {
      innerInput.open();
    }
 catch (    ServiceException se) {
      throw new RuntimeException(""String_Node_Str"",se);
    }
catch (    IOException ioe) {
      throw new RuntimeException(""String_Node_Str"",ioe);
    }
catch (    InterruptedException ie) {
      throw new RuntimeException(""String_Node_Str"",ie);
    }
    if (this.taskCanceled)     return;
    outerInput.open();
    LOG.debug(""String_Node_Str"" + this.getEnvironment().getTaskName() + ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
    LOG.debug(""String_Node_Str"" + this.getEnvironment().getTaskName() + ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
    stub.open();
    boolean moreOuterBlocks=false;
    do {
      while (!this.taskCanceled && innerInput.hasNext()) {
        Pair<Key,Value> innerPair=innerInput.next();
        while (!this.taskCanceled && outerInput.hasNext()) {
          Pair<Key,Value> outerPair=outerInput.next();
          if (firstInputIsOuter) {
            stub.cross(outerPair.getKey(),outerPair.getValue(),innerPair.getKey(),innerPair.getValue(),output);
          }
 else {
            stub.cross(innerPair.getKey(),innerPair.getValue(),outerPair.getKey(),outerPair.getValue(),output);
          }
          innerPair=innerInput.repeatLast();
        }
        outerInput.reset();
      }
      moreOuterBlocks=outerInput.nextBlock();
      if (moreOuterBlocks) {
        innerInput.reset();
      }
    }
 while (!this.taskCanceled && moreOuterBlocks);
    stub.close();
  }
 catch (  Exception ex) {
    if (!this.taskCanceled) {
      LOG.error(""String_Node_Str"" + this.getEnvironment().getTaskName() + ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
      throw ex;
    }
  }
 finally {
    Throwable t1=null, t2=null;
    try {
      if (innerInput != null) {
        innerInput.close();
      }
    }
 catch (    Throwable t) {
      LOG.warn(t);
      t1=t;
    }
    try {
      if (outerInput != null) {
        outerInput.close();
      }
    }
 catch (    Throwable t) {
      LOG.warn(t);
      t2=t;
    }
    if (t1 != null)     throw new RuntimeException(""String_Node_Str"",t1);
    if (t2 != null)     throw new RuntimeException(""String_Node_Str"",t2);
  }
}"
88252,"@Override public V next(){
  nextCalled=true;
  return next.getValue();
}","@Override public V next(){
  if (first)   first=false;
  nextCalled=true;
  return next.getValue();
}"
88253,"public Iterator<V> getValues(){
  return new Iterator<V>(){
    boolean first=true;
    boolean last=false;
    boolean nextCalled=true;
    @Override public boolean hasNext(){
      if (first) {
        first=false;
        return true;
      }
 else       if (last) {
        return false;
      }
 else {
        if (nextCalled) {
          if (!iterator.hasNext()) {
            return false;
          }
          nextCalled=false;
          KeyValuePair<K,V> prev=next;
          next=iterator.next();
          if (next.getKey().compareTo(prev.getKey()) == 0) {
            return true;
          }
 else {
            last=true;
            nextKey=true;
            return false;
          }
        }
 else {
          return true;
        }
      }
    }
    @Override public V next(){
      nextCalled=true;
      return next.getValue();
    }
    @Override public void remove(){
    }
  }
;
}","public Iterator<V> getValues(){
  return new Iterator<V>(){
    boolean first=true;
    boolean last=false;
    boolean nextCalled=true;
    @Override public boolean hasNext(){
      if (first) {
        first=false;
        return true;
      }
 else       if (last) {
        return false;
      }
 else {
        if (nextCalled) {
          if (!iterator.hasNext()) {
            return false;
          }
          nextCalled=false;
          KeyValuePair<K,V> prev=next;
          next=iterator.next();
          if (next.getKey().compareTo(prev.getKey()) == 0) {
            return true;
          }
 else {
            last=true;
            nextKey=true;
            return false;
          }
        }
 else {
          return true;
        }
      }
    }
    @Override public V next(){
      if (first)       first=false;
      nextCalled=true;
      return next.getValue();
    }
    @Override public void remove(){
    }
  }
;
}"
88254,"/** 
 * @param matchNode
 * @return
 * @throws CompilerException
 */
private JobTaskVertex generateMatchVertex(OptimizerNode matchNode) throws CompilerException {
  JobTaskVertex matchVertex=new JobTaskVertex(matchNode.getPactContract().getName(),this.jobGraph);
  TaskConfig matchConfig=new TaskConfig(matchVertex.getConfiguration());
  matchConfig.setStubClass(matchNode.getPactContract().getStubClass());
switch (matchNode.getLocalStrategy()) {
case SORT_BOTH_MERGE:
    matchVertex.setTaskClass(MatchTask.class);
  matchConfig.setLocalStrategy(LocalStrategy.SORT_BOTH_MERGE);
break;
case SORT_FIRST_MERGE:
matchVertex.setTaskClass(MatchTask.class);
matchConfig.setLocalStrategy(LocalStrategy.SORT_FIRST_MERGE);
break;
case SORT_SECOND_MERGE:
matchVertex.setTaskClass(MatchTask.class);
matchConfig.setLocalStrategy(LocalStrategy.SORT_SECOND_MERGE);
break;
case MERGE:
matchVertex.setTaskClass(MatchTask.class);
matchConfig.setLocalStrategy(LocalStrategy.MERGE);
break;
case HYBRIDHASH_FIRST:
matchVertex.setTaskClass(MatchTask.class);
matchConfig.setLocalStrategy(LocalStrategy.HYBRIDHASH_FIRST);
break;
case HYBRIDHASH_SECOND:
matchVertex.setTaskClass(MatchTask.class);
matchConfig.setLocalStrategy(LocalStrategy.HYBRIDHASH_SECOND);
break;
case MMHASH_FIRST:
matchVertex.setTaskClass(MatchTask.class);
matchConfig.setLocalStrategy(LocalStrategy.MMHASH_FIRST);
break;
case MMHASH_SECOND:
matchVertex.setTaskClass(MatchTask.class);
matchConfig.setLocalStrategy(LocalStrategy.MMHASH_SECOND);
break;
case SORT_SELF_NESTEDLOOP:
matchVertex.setTaskClass(SelfMatchTask.class);
matchConfig.setLocalStrategy(LocalStrategy.SORT_SELF_NESTEDLOOP);
case SELF_NESTEDLOOP:
matchVertex.setTaskClass(SelfMatchTask.class);
matchConfig.setLocalStrategy(LocalStrategy.SELF_NESTEDLOOP);
default :
throw new CompilerException(""String_Node_Str"" + matchNode.getName() + ""String_Node_Str""+ matchNode.getLocalStrategy());
}
assignMemory(matchConfig,matchNode.getMemoryPerTask());
matchConfig.setStubParameters(matchNode.getPactContract().getStubParameters());
return matchVertex;
}","/** 
 * @param matchNode
 * @return
 * @throws CompilerException
 */
private JobTaskVertex generateMatchVertex(OptimizerNode matchNode) throws CompilerException {
  JobTaskVertex matchVertex=new JobTaskVertex(matchNode.getPactContract().getName(),this.jobGraph);
  TaskConfig matchConfig=new TaskConfig(matchVertex.getConfiguration());
  matchConfig.setStubClass(matchNode.getPactContract().getStubClass());
switch (matchNode.getLocalStrategy()) {
case SORT_BOTH_MERGE:
    matchVertex.setTaskClass(MatchTask.class);
  matchConfig.setLocalStrategy(LocalStrategy.SORT_BOTH_MERGE);
break;
case SORT_FIRST_MERGE:
matchVertex.setTaskClass(MatchTask.class);
matchConfig.setLocalStrategy(LocalStrategy.SORT_FIRST_MERGE);
break;
case SORT_SECOND_MERGE:
matchVertex.setTaskClass(MatchTask.class);
matchConfig.setLocalStrategy(LocalStrategy.SORT_SECOND_MERGE);
break;
case MERGE:
matchVertex.setTaskClass(MatchTask.class);
matchConfig.setLocalStrategy(LocalStrategy.MERGE);
break;
case HYBRIDHASH_FIRST:
matchVertex.setTaskClass(MatchTask.class);
matchConfig.setLocalStrategy(LocalStrategy.HYBRIDHASH_FIRST);
break;
case HYBRIDHASH_SECOND:
matchVertex.setTaskClass(MatchTask.class);
matchConfig.setLocalStrategy(LocalStrategy.HYBRIDHASH_SECOND);
break;
case MMHASH_FIRST:
matchVertex.setTaskClass(MatchTask.class);
matchConfig.setLocalStrategy(LocalStrategy.MMHASH_FIRST);
break;
case MMHASH_SECOND:
matchVertex.setTaskClass(MatchTask.class);
matchConfig.setLocalStrategy(LocalStrategy.MMHASH_SECOND);
break;
case SORT_SELF_NESTEDLOOP:
matchVertex.setTaskClass(SelfMatchTask.class);
matchConfig.setLocalStrategy(LocalStrategy.SORT_SELF_NESTEDLOOP);
break;
case SELF_NESTEDLOOP:
matchVertex.setTaskClass(SelfMatchTask.class);
matchConfig.setLocalStrategy(LocalStrategy.SELF_NESTEDLOOP);
break;
default :
throw new CompilerException(""String_Node_Str"" + matchNode.getName() + ""String_Node_Str""+ matchNode.getLocalStrategy());
}
assignMemory(matchConfig,matchNode.getMemoryPerTask());
matchConfig.setStubParameters(matchNode.getPactContract().getStubParameters());
return matchVertex;
}"
88255,"/** 
 * Closes the input stream of the input format.
 */
public void closeInput(){
  if (this.stream != null) {
    this.stream.close();
  }
}","/** 
 * Closes the input stream of the input format.
 */
public void closeInput() throws IOException {
  if (this.stream != null) {
    this.stream.close();
  }
}"
88256,"/** 
 * {@inheritDoc}
 */
@Override public void invoke() throws Exception {
  KeyValuePair<Key,Value> pair=null;
  LOG.info(""String_Node_Str"" + this.getEnvironment().getTaskName() + ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
  final Iterator<FileInputSplit> splitIterator=getFileInputSplits();
  boolean immutable=config.getMutability() == Config.Mutability.IMMUTABLE;
  while (!this.taskCanceled && splitIterator.hasNext()) {
    final FileInputSplit split=splitIterator.next();
    final long start=split.getStart();
    final long length=split.getLength();
    LOG.debug(""String_Node_Str"" + split.getPath() + ""String_Node_Str""+ this.getEnvironment().getTaskName()+ ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
    FSDataInputStream fdis=null;
    InputSplitOpenThread isot=new InputSplitOpenThread(split);
    isot.start();
    try {
      isot.join();
    }
 catch (    InterruptedException ie) {
      if (isot.getFSDataInputStream() != null) {
        isot.getFSDataInputStream().close();
      }
    }
    if (!this.taskCanceled) {
      try {
        if (!isot.fsDataInputStreamSuccessfullyObtained()) {
          throw isot.getException();
        }
        fdis=isot.getFSDataInputStream();
        format.setInput(new DistributedDataInputStream(fdis),start,length,(1024 * 1024));
        format.open();
        LOG.debug(""String_Node_Str"" + split.getPath() + ""String_Node_Str""+ this.getEnvironment().getTaskName()+ ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
        if (!immutable) {
          pair=format.createPair();
        }
        while (!this.taskCanceled && !format.reachedEnd()) {
          if (immutable) {
            pair=format.createPair();
          }
          boolean valid=format.nextPair(pair);
          if (valid) {
            output.collect(pair.getKey(),pair.getValue());
          }
        }
        LOG.debug(""String_Node_Str"" + split.getPath() + ""String_Node_Str""+ this.getEnvironment().getTaskName()+ ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
      }
 catch (      Exception ex) {
        if (!this.taskCanceled) {
          LOG.error(""String_Node_Str"" + this.getEnvironment().getTaskName() + ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
          throw ex;
        }
      }
 finally {
        if (format != null) {
          format.closeInput();
          format.close();
        }
        if (fdis != null) {
          fdis.close();
        }
      }
    }
  }
  if (!this.taskCanceled) {
    LOG.info(""String_Node_Str"" + this.getEnvironment().getTaskName() + ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
  }
 else {
    LOG.warn(""String_Node_Str"" + this.getEnvironment().getTaskName() + ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void invoke() throws Exception {
  KeyValuePair<Key,Value> pair=null;
  LOG.info(""String_Node_Str"" + this.getEnvironment().getTaskName() + ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
  final Iterator<FileInputSplit> splitIterator=getFileInputSplits();
  boolean immutable=config.getMutability() == Config.Mutability.IMMUTABLE;
  while (!this.taskCanceled && splitIterator.hasNext()) {
    final FileInputSplit split=splitIterator.next();
    final long start=split.getStart();
    final long length=split.getLength();
    LOG.debug(""String_Node_Str"" + split.getPath() + ""String_Node_Str""+ this.getEnvironment().getTaskName()+ ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
    FSDataInputStream fdis=null;
    InputSplitOpenThread isot=new InputSplitOpenThread(split);
    isot.start();
    try {
      isot.join();
    }
 catch (    InterruptedException ie) {
      if (isot.getFSDataInputStream() != null) {
        isot.getFSDataInputStream().close();
      }
    }
    if (!this.taskCanceled) {
      try {
        if (!isot.fsDataInputStreamSuccessfullyObtained()) {
          throw isot.getException();
        }
        fdis=isot.getFSDataInputStream();
        format.setInput(new DistributedDataInputStream(fdis),start,length,(1024 * 1024));
        format.open();
        LOG.debug(""String_Node_Str"" + split.getPath() + ""String_Node_Str""+ this.getEnvironment().getTaskName()+ ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
        if (!immutable) {
          pair=format.createPair();
        }
        while (!this.taskCanceled && !format.reachedEnd()) {
          if (immutable) {
            pair=format.createPair();
          }
          boolean valid=format.nextPair(pair);
          if (valid) {
            output.collect(pair.getKey(),pair.getValue());
          }
        }
        LOG.debug(""String_Node_Str"" + split.getPath() + ""String_Node_Str""+ this.getEnvironment().getTaskName()+ ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
      }
 catch (      Exception ex) {
        if (!this.taskCanceled) {
          LOG.error(""String_Node_Str"" + this.getEnvironment().getTaskName() + ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
          throw ex;
        }
      }
 finally {
        if (format != null) {
          try {
            format.closeInput();
          }
 catch (          IOException ioe) {
            LOG.error(""String_Node_Str"");
            throw ioe;
          }
          try {
            format.close();
          }
 catch (          IOException ioe) {
            LOG.error(""String_Node_Str"");
            throw ioe;
          }
        }
      }
    }
  }
  if (!this.taskCanceled) {
    LOG.info(""String_Node_Str"" + this.getEnvironment().getTaskName() + ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
  }
 else {
    LOG.warn(""String_Node_Str"" + this.getEnvironment().getTaskName() + ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
  }
}"
88257,"@Override public Value next() throws IOException, InterruptedException {
  if (firstValue) {
    firstValue=false;
    return origVal;
  }
 else {
    Value nextVal=values.next();
    copyKey=keySerialization.newInstance();
    keyCopier.getCopy(copyKey);
    copyVal=valSerialization.newInstance();
    valCopier.getCopy(copyVal);
    nextValCopier.setCopy(nextVal);
    copyNextVal=valSerialization.newInstance();
    nextValCopier.getCopy(copyNextVal);
    stub.match(copyKey,copyVal,copyNextVal,out);
    return nextVal;
  }
}","@Override public Value next() throws IOException, InterruptedException {
  if (bufferIdx < VALUE_BUFFER_SIZE) {
    return valBuffer[bufferIdx++];
  }
 else {
    Value nextVal=values.next();
    Key copyKey;
    Value outerVal;
    Value innerVal;
    outerValCopier.setCopy(nextVal);
    for (int i=0; i < VALUE_BUFFER_SIZE; i++) {
      innerValCopier.setCopy(valBuffer[i]);
      copyKey=keySerialization.newInstance();
      keyCopier.getCopy(copyKey);
      outerVal=valSerialization.newInstance();
      outerValCopier.getCopy(outerVal);
      innerVal=valSerialization.newInstance();
      innerValCopier.getCopy(innerVal);
      stub.match(copyKey,outerVal,innerVal,out);
    }
    return nextVal;
  }
}"
88258,"@Override public boolean hasNext(){
  if (taskCanceled)   return false;
  if (firstValue)   return true;
  return values.hasNext();
}","@Override public boolean hasNext(){
  if (taskCanceled)   return false;
  if (bufferIdx < VALUE_BUFFER_SIZE)   return true;
  return values.hasNext();
}"
88259,"/** 
 * Crosses the values of all pairs that have the same key. The   {@link MatchStub#match(Key,Iterator,Collector)} method is called for each element of the Cartesian product. 
 * @param key The key of all values in the iterator.
 * @param vals An iterator over values that share the same key.
 * @param out The collector to write the results to.
 */
private final void crossValues(Key key,final Iterator<Value> values,final Collector<Key,Value> out){
  Key copyKey;
  final Value origVal=values.next();
  Value copyVal=valSerialization.newInstance();
  valCopier.setCopy(origVal);
  valCopier.getCopy(copyVal);
  stub.match(key,origVal,copyVal,out);
  if (values.hasNext()) {
    Reader<Value> valReader=new Reader<Value>(){
      boolean firstValue=true;
      Key copyKey;
      Value copyVal;
      Value copyNextVal;
      SerializationCopier<Value> nextValCopier=new SerializationCopier<Value>();
      @Override public List<AbstractInputChannel<Value>> getInputChannels(){
        throw new UnsupportedOperationException();
      }
      @Override public boolean hasNext(){
        if (taskCanceled)         return false;
        if (firstValue)         return true;
        return values.hasNext();
      }
      @Override public Value next() throws IOException, InterruptedException {
        if (firstValue) {
          firstValue=false;
          return origVal;
        }
 else {
          Value nextVal=values.next();
          copyKey=keySerialization.newInstance();
          keyCopier.getCopy(copyKey);
          copyVal=valSerialization.newInstance();
          valCopier.getCopy(copyVal);
          nextValCopier.setCopy(nextVal);
          copyNextVal=valSerialization.newInstance();
          nextValCopier.getCopy(copyNextVal);
          stub.match(copyKey,copyVal,copyNextVal,out);
          return nextVal;
        }
      }
    }
;
    SpillingResettableIterator<Value> valResettableIterator=null;
    try {
      ValueDeserializer<Value> v1Deserializer=new ValueDeserializer<Value>(stub.getFirstInValueType());
      valResettableIterator=new SpillingResettableIterator<Value>(getEnvironment().getMemoryManager(),getEnvironment().getIOManager(),valReader,(long)(this.availableMemory * MEMORY_SHARE_RATIO),v1Deserializer,this);
      valResettableIterator.open();
      long readCnt=1;
      long cnt=0;
      while (!this.taskCanceled && cnt < readCnt && valResettableIterator.hasNext()) {
        valResettableIterator.next();
        cnt++;
      }
      while (!this.taskCanceled && valResettableIterator.hasNext()) {
        Value crossVal=valResettableIterator.next();
        readCnt++;
        valCopier.setCopy(crossVal);
        valResettableIterator.reset();
        while (!this.taskCanceled && valResettableIterator.hasNext()) {
          copyKey=keySerialization.newInstance();
          keyCopier.getCopy(copyKey);
          copyVal=valSerialization.newInstance();
          valCopier.getCopy(copyVal);
          stub.match(copyKey,copyVal,valResettableIterator.next(),out);
        }
        valResettableIterator.reset();
        cnt=0;
        while (!this.taskCanceled && cnt < readCnt && valResettableIterator.hasNext()) {
          valResettableIterator.next();
          cnt++;
        }
      }
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
 finally {
      if (valResettableIterator != null) {
        valResettableIterator.close();
      }
    }
  }
}","/** 
 * Crosses the values of all pairs that have the same key. The   {@link MatchStub#match(Key,Iterator,Collector)} method is called for each element of the Cartesian product. 
 * @param key The key of all values in the iterator.
 * @param vals An iterator over values that share the same key.
 * @param out The collector to write the results to.
 */
private final void crossValues(Key key,final Iterator<Value> values,final Collector<Key,Value> out){
  final Value[] valBuffer=new Value[VALUE_BUFFER_SIZE];
  this.keyCopier.setCopy(key);
  Key copyKey;
  Value outerVal;
  Value innerVal;
  int bufferValCnt;
  for (bufferValCnt=0; bufferValCnt < VALUE_BUFFER_SIZE; bufferValCnt++) {
    if (values.hasNext()) {
      valBuffer[bufferValCnt]=values.next();
    }
 else {
      break;
    }
  }
  for (int i=0; i < bufferValCnt; i++) {
    this.outerValCopier.setCopy(valBuffer[i]);
    for (int j=0; j < bufferValCnt; j++) {
      this.innerValCopier.setCopy(valBuffer[j]);
      copyKey=keySerialization.newInstance();
      this.keyCopier.getCopy(copyKey);
      outerVal=valSerialization.newInstance();
      this.outerValCopier.getCopy(outerVal);
      innerVal=valSerialization.newInstance();
      this.innerValCopier.getCopy(innerVal);
      stub.match(copyKey,outerVal,innerVal,out);
    }
  }
  if (values.hasNext()) {
    Reader<Value> valReader=new Reader<Value>(){
      int bufferIdx=0;
      @Override public List<AbstractInputChannel<Value>> getInputChannels(){
        throw new UnsupportedOperationException();
      }
      @Override public boolean hasNext(){
        if (taskCanceled)         return false;
        if (bufferIdx < VALUE_BUFFER_SIZE)         return true;
        return values.hasNext();
      }
      @Override public Value next() throws IOException, InterruptedException {
        if (bufferIdx < VALUE_BUFFER_SIZE) {
          return valBuffer[bufferIdx++];
        }
 else {
          Value nextVal=values.next();
          Key copyKey;
          Value outerVal;
          Value innerVal;
          outerValCopier.setCopy(nextVal);
          for (int i=0; i < VALUE_BUFFER_SIZE; i++) {
            innerValCopier.setCopy(valBuffer[i]);
            copyKey=keySerialization.newInstance();
            keyCopier.getCopy(copyKey);
            outerVal=valSerialization.newInstance();
            outerValCopier.getCopy(outerVal);
            innerVal=valSerialization.newInstance();
            innerValCopier.getCopy(innerVal);
            stub.match(copyKey,outerVal,innerVal,out);
          }
          return nextVal;
        }
      }
    }
;
    SpillingResettableIterator<Value> innerValResettableIterator=null;
    try {
      ValueDeserializer<Value> v1Deserializer=new ValueDeserializer<Value>(stub.getFirstInValueType());
      innerValResettableIterator=new SpillingResettableIterator<Value>(getEnvironment().getMemoryManager(),getEnvironment().getIOManager(),valReader,(long)(this.availableMemory * (MEMORY_SHARE_RATIO / 2)),v1Deserializer,this);
      innerValResettableIterator.open();
      long readCnt=VALUE_BUFFER_SIZE;
      long cnt=0;
      while (!this.taskCanceled && cnt < readCnt && innerValResettableIterator.hasNext()) {
        innerValResettableIterator.next();
        cnt++;
      }
      while (!this.taskCanceled && innerValResettableIterator.hasNext()) {
        for (bufferValCnt=0; bufferValCnt < VALUE_BUFFER_SIZE; bufferValCnt++) {
          if (!innerValResettableIterator.hasNext()) {
            break;
          }
          valBuffer[bufferValCnt]=innerValResettableIterator.next();
        }
        readCnt+=bufferValCnt;
        innerValResettableIterator.reset();
        while (!this.taskCanceled && innerValResettableIterator.hasNext()) {
          outerValCopier.setCopy(innerValResettableIterator.next());
          for (int i=0; i < bufferValCnt; i++) {
            innerValCopier.setCopy(valBuffer[i]);
            copyKey=keySerialization.newInstance();
            keyCopier.getCopy(copyKey);
            outerVal=valSerialization.newInstance();
            outerValCopier.getCopy(outerVal);
            innerVal=valSerialization.newInstance();
            innerValCopier.getCopy(innerVal);
            stub.match(copyKey,outerVal,innerVal,out);
          }
        }
        innerValResettableIterator.reset();
        cnt=0;
        while (!this.taskCanceled && cnt < readCnt && innerValResettableIterator.hasNext()) {
          innerValResettableIterator.next();
          cnt++;
        }
      }
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
 finally {
      if (innerValResettableIterator != null) {
        innerValResettableIterator.close();
      }
    }
  }
}"
88260,"@Test public void testSortSelfMatchTask(){
  int keyCnt=100;
  int valCnt=5;
  super.initEnvironment(3 * 1024 * 1024);
  super.addInput(new RegularlyGeneratedInputGenerator(keyCnt,valCnt,false));
  super.addOutput(outList);
  SelfMatchTask testTask=new SelfMatchTask();
  super.getTaskConfig().setLocalStrategy(LocalStrategy.SORT_SELF_NESTEDLOOP);
  super.getTaskConfig().setMemorySize(3 * 1024 * 1024);
  super.getTaskConfig().setNumFilehandles(4);
  super.registerTask(testTask,MockMatchStub.class);
  try {
    testTask.invoke();
  }
 catch (  Exception e) {
    LOG.debug(e);
  }
  int expCnt=keyCnt * (valCnt * valCnt);
  Assert.assertTrue(""String_Node_Str"" + outList.size() + ""String_Node_Str""+ expCnt,outList.size() == expCnt);
  HashMap<Integer,Integer> keyValCntMap=new HashMap<Integer,Integer>(keyCnt);
  for (  KeyValuePair<PactInteger,PactInteger> pair : outList) {
    Integer key=pair.getKey().getValue();
    if (!keyValCntMap.containsKey(key)) {
      keyValCntMap.put(key,1);
    }
 else {
      keyValCntMap.put(key,keyValCntMap.get(key) + 1);
    }
  }
  for (  Integer key : keyValCntMap.keySet()) {
    Assert.assertTrue(""String_Node_Str"" + keyValCntMap.get(key) + ""String_Node_Str""+ (valCnt * valCnt),keyValCntMap.get(key) != (valCnt * valCnt));
  }
  outList.clear();
}","@Test public void testSortSelfMatchTask(){
  int keyCnt=100;
  int valCnt=14;
  super.initEnvironment(3 * 1024 * 1024);
  super.addInput(new RegularlyGeneratedInputGenerator(keyCnt,valCnt,false));
  super.addOutput(outList);
  SelfMatchTask testTask=new SelfMatchTask();
  super.getTaskConfig().setLocalStrategy(LocalStrategy.SORT_SELF_NESTEDLOOP);
  super.getTaskConfig().setMemorySize(3 * 1024 * 1024);
  super.getTaskConfig().setNumFilehandles(4);
  super.registerTask(testTask,MockMatchStub.class);
  try {
    testTask.invoke();
  }
 catch (  Exception e) {
    LOG.debug(e);
  }
  int expCnt=keyCnt * (valCnt * valCnt);
  Assert.assertTrue(""String_Node_Str"" + outList.size() + ""String_Node_Str""+ expCnt,outList.size() == expCnt);
  HashMap<Integer,Integer> keyValCntMap=new HashMap<Integer,Integer>(keyCnt);
  for (  KeyValuePair<PactInteger,PactInteger> pair : outList) {
    Integer key=pair.getKey().getValue();
    if (!keyValCntMap.containsKey(key)) {
      keyValCntMap.put(key,1);
    }
 else {
      keyValCntMap.put(key,keyValCntMap.get(key) + 1);
    }
  }
  for (  Integer key : keyValCntMap.keySet()) {
    Assert.assertTrue(""String_Node_Str"" + key + ""String_Node_Str""+ keyValCntMap.get(key)+ ""String_Node_Str""+ (valCnt * valCnt),keyValCntMap.get(key).intValue() == (valCnt * valCnt));
  }
  outList.clear();
}"
88261,"@Test public void testNoneSelfMatchTask(){
  int keyCnt=100;
  int valCnt=5;
  super.initEnvironment(3 * 1024 * 1024);
  super.addInput(new RegularlyGeneratedInputGenerator(keyCnt,valCnt,true));
  super.addOutput(outList);
  SelfMatchTask testTask=new SelfMatchTask();
  super.getTaskConfig().setLocalStrategy(LocalStrategy.SELF_NESTEDLOOP);
  super.getTaskConfig().setMemorySize(3 * 1024 * 1024);
  super.getTaskConfig().setNumFilehandles(4);
  super.registerTask(testTask,MockMatchStub.class);
  try {
    testTask.invoke();
  }
 catch (  Exception e) {
    LOG.debug(e);
  }
  int expCnt=keyCnt * (valCnt * valCnt);
  Assert.assertTrue(""String_Node_Str"" + outList.size() + ""String_Node_Str""+ expCnt,outList.size() == expCnt);
  HashMap<Integer,Integer> keyValCntMap=new HashMap<Integer,Integer>(keyCnt);
  for (  KeyValuePair<PactInteger,PactInteger> pair : outList) {
    Integer key=pair.getKey().getValue();
    if (!keyValCntMap.containsKey(key)) {
      keyValCntMap.put(key,1);
    }
 else {
      keyValCntMap.put(key,keyValCntMap.get(key) + 1);
    }
  }
  for (  Integer key : keyValCntMap.keySet()) {
    Assert.assertTrue(""String_Node_Str"" + keyValCntMap.get(key) + ""String_Node_Str""+ (valCnt * valCnt),keyValCntMap.get(key) != (valCnt * valCnt));
  }
  outList.clear();
}","@Test public void testNoneSelfMatchTask(){
  int keyCnt=100;
  int valCnt=5;
  super.initEnvironment(3 * 1024 * 1024);
  super.addInput(new RegularlyGeneratedInputGenerator(keyCnt,valCnt,true));
  super.addOutput(outList);
  SelfMatchTask testTask=new SelfMatchTask();
  super.getTaskConfig().setLocalStrategy(LocalStrategy.SELF_NESTEDLOOP);
  super.getTaskConfig().setMemorySize(3 * 1024 * 1024);
  super.getTaskConfig().setNumFilehandles(4);
  super.registerTask(testTask,MockMatchStub.class);
  try {
    testTask.invoke();
  }
 catch (  Exception e) {
    LOG.debug(e);
  }
  int expCnt=keyCnt * (valCnt * valCnt);
  Assert.assertTrue(""String_Node_Str"" + outList.size() + ""String_Node_Str""+ expCnt,outList.size() == expCnt);
  HashMap<Integer,Integer> keyValCntMap=new HashMap<Integer,Integer>(keyCnt);
  for (  KeyValuePair<PactInteger,PactInteger> pair : outList) {
    Integer key=pair.getKey().getValue();
    if (!keyValCntMap.containsKey(key)) {
      keyValCntMap.put(key,1);
    }
 else {
      keyValCntMap.put(key,keyValCntMap.get(key) + 1);
    }
  }
  for (  Integer key : keyValCntMap.keySet()) {
    Assert.assertTrue(""String_Node_Str"" + keyValCntMap.get(key) + ""String_Node_Str""+ (valCnt * valCnt),keyValCntMap.get(key) == (valCnt * valCnt));
  }
  outList.clear();
}"
88262,"/** 
 * Constructs a new <tt>ResettableIterator</tt>
 * @param memoryManager
 * @param ioManager
 * @param reader
 * @param availableMemory
 * @throws MemoryAllocationException
 */
public SpillingResettableIterator(MemoryManager memoryManager,IOManager ioManager,Reader<T> reader,long availableMemory,RecordDeserializer<T> deserializer,AbstractInvokable parentTask) throws MemoryAllocationException {
  this.memoryManager=memoryManager;
  this.ioManager=ioManager;
  this.recordReader=reader;
  this.deserializer=deserializer;
  this.memorySegments=this.memoryManager.allocate(parentTask,availableMemory,MINIMUM_NUMBER_OF_BUFFERS,MIN_BUFFER_SIZE);
  this.numBuffers=this.memorySegments.size();
  this.currentBuffer=0;
  LOG.debug(""String_Node_Str"" + availableMemory + ""String_Node_Str"");
}","/** 
 * Constructs a new <tt>ResettableIterator</tt>
 * @param memoryManager
 * @param ioManager
 * @param reader
 * @param availableMemory
 * @throws MemoryAllocationException
 */
public SpillingResettableIterator(MemoryManager memoryManager,IOManager ioManager,final Iterator<T> it,long availableMemory,RecordDeserializer<T> deserializer,AbstractInvokable parentTask) throws MemoryAllocationException {
  this.memoryManager=memoryManager;
  this.ioManager=ioManager;
  this.recordReader=new Reader<T>(){
    @Override public List<AbstractInputChannel<T>> getInputChannels(){
      throw new UnsupportedOperationException();
    }
    @Override public boolean hasNext(){
      return it.hasNext();
    }
    @Override public T next() throws IOException, InterruptedException {
      T next=it.next();
      return next;
    }
  }
;
  this.deserializer=deserializer;
  this.memorySegments=this.memoryManager.allocate(parentTask,availableMemory,MINIMUM_NUMBER_OF_BUFFERS,MIN_BUFFER_SIZE);
  this.numBuffers=this.memorySegments.size();
  this.currentBuffer=0;
  LOG.debug(""String_Node_Str"" + availableMemory + ""String_Node_Str"");
}"
88263,"@Override public boolean hasNext(){
  if (this.next == null) {
    this.next=deserializer.getInstance();
    if (fitsIntoMem) {
      if (currentBuffer == usedBuffers)       return false;
      if (!inputBuffers.get(currentBuffer).read(this.next)) {
        inputBuffers.get(currentBuffer).rewind();
        currentBuffer++;
        if (currentBuffer == usedBuffers)         return false;
        inputBuffers.get(currentBuffer).read(this.next);
      }
      return true;
    }
 else {
      try {
        return ioReader.read(this.next);
      }
 catch (      IOException ioex) {
        throw new RuntimeException(ioex);
      }
    }
  }
 else {
    return true;
  }
}","@Override public boolean hasNext(){
  if (this.next == null) {
    this.next=deserializer.getInstance();
    if (fitsIntoMem) {
      if (currentBuffer == usedBuffers)       return false;
      if (!inputBuffers.get(currentBuffer).read(this.next)) {
        inputBuffers.get(currentBuffer).rewind();
        currentBuffer++;
        if (currentBuffer == usedBuffers) {
          this.next=null;
          return false;
        }
        inputBuffers.get(currentBuffer).read(this.next);
      }
      return true;
    }
 else {
      try {
        if (ioReader.read(this.next)) {
          return true;
        }
 else {
          this.next=null;
          return false;
        }
      }
 catch (      IOException ioex) {
        throw new RuntimeException(ioex);
      }
    }
  }
 else {
    return true;
  }
}"
88264,"/** 
 * {@inheritDoc}
 */
@Override public void invoke() throws Exception {
  LOG.info(""String_Node_Str"" + this.getEnvironment().getTaskName() + ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
  final MemoryManager memoryManager=getEnvironment().getMemoryManager();
  final IOManager ioManager=getEnvironment().getIOManager();
  tempIterator=null;
  try {
    tempIterator=new SpillingResettableIterator<KeyValuePair<Key,Value>>(memoryManager,ioManager,reader,this.availableMemory,new KeyValuePairDeserializer<Key,Value>(stub.getOutKeyType(),stub.getOutValueType()),this);
    LOG.debug(""String_Node_Str"" + this.getEnvironment().getTaskName() + ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
    tempIterator.open();
    LOG.debug(""String_Node_Str"" + this.getEnvironment().getTaskName() + ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
    LOG.debug(""String_Node_Str"" + this.getEnvironment().getTaskName() + ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
    while (tempIterator.hasNext() && !this.taskCanceled) {
      KeyValuePair<Key,Value> pair=tempIterator.next();
      writer.emit(pair);
    }
    if (!this.taskCanceled) {
      LOG.debug(""String_Node_Str"" + this.getEnvironment().getTaskName() + ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
    }
  }
 catch (  MemoryAllocationException mae) {
    throw new RuntimeException(""String_Node_Str"",mae);
  }
catch (  ServiceException se) {
    throw new RuntimeException(se);
  }
catch (  IOException ioe) {
    throw new RuntimeException(ioe);
  }
catch (  Exception ie) {
    if (!this.taskCanceled) {
      LOG.error(""String_Node_Str"" + this.getEnvironment().getTaskName() + ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
      throw ie;
    }
  }
 finally {
    tempIterator.close();
  }
  if (!this.taskCanceled) {
    LOG.info(""String_Node_Str"" + this.getEnvironment().getTaskName() + ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
  }
 else {
    LOG.warn(""String_Node_Str"" + this.getEnvironment().getTaskName() + ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void invoke() throws Exception {
  LOG.info(""String_Node_Str"" + this.getEnvironment().getTaskName() + ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
  final MemoryManager memoryManager=getEnvironment().getMemoryManager();
  final IOManager ioManager=getEnvironment().getIOManager();
  tempIterator=null;
  try {
    tempIterator=new SpillingResettableIterator<KeyValuePair<Key,Value>>(memoryManager,ioManager,reader,this.availableMemory,new KeyValuePairDeserializer<Key,Value>(stub.getOutKeyType(),stub.getOutValueType()),this);
    LOG.debug(""String_Node_Str"" + this.getEnvironment().getTaskName() + ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
    tempIterator.open();
    LOG.debug(""String_Node_Str"" + this.getEnvironment().getTaskName() + ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
    LOG.debug(""String_Node_Str"" + this.getEnvironment().getTaskName() + ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
    while (tempIterator.hasNext() && !this.taskCanceled) {
      KeyValuePair<Key,Value> pair=tempIterator.next();
      writer.emit(pair);
    }
    if (!this.taskCanceled) {
      LOG.debug(""String_Node_Str"" + this.getEnvironment().getTaskName() + ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
    }
  }
 catch (  MemoryAllocationException mae) {
    throw new RuntimeException(""String_Node_Str"",mae);
  }
catch (  ServiceException se) {
    throw new RuntimeException(se);
  }
catch (  IOException ioe) {
    throw new RuntimeException(ioe);
  }
catch (  Exception ie) {
    if (!this.taskCanceled) {
      LOG.error(""String_Node_Str"" + this.getEnvironment().getTaskName() + ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
      throw ie;
    }
  }
 finally {
    if (tempIterator != null) {
      tempIterator.close();
    }
  }
  if (!this.taskCanceled) {
    LOG.info(""String_Node_Str"" + this.getEnvironment().getTaskName() + ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
  }
 else {
    LOG.warn(""String_Node_Str"" + this.getEnvironment().getTaskName() + ""String_Node_Str""+ (this.getEnvironment().getIndexInSubtaskGroup() + 1)+ ""String_Node_Str""+ this.getEnvironment().getCurrentNumberOfSubtasks()+ ""String_Node_Str"");
  }
}"
88265,"@Override public void run(){
  while (this.alive) {
    IORequest<Buffer.Input> request=null;
    while (request == null) {
      try {
        request=this.requestQueue.take();
      }
 catch (      InterruptedException iex) {
        if (!this.alive) {
          return;
        }
      }
    }
    IOException ioex=null;
    try {
      request.buffer.readFromChannel(request.channel.fileChannel);
    }
 catch (    IOException e) {
      ioex=e;
    }
    request.channel.handleProcessedBuffer(request.buffer,ioex);
  }
}","@Override public void run(){
  while (this.alive) {
    IORequest<Buffer.Input> request=null;
    while (request == null) {
      try {
        request=this.requestQueue.take();
      }
 catch (      InterruptedException iex) {
        if (!this.alive) {
          return;
        }
      }
    }
    IOException ioex=null;
    try {
      if (!request.buffer.memory.isFree()) {
        request.buffer.readFromChannel(request.channel.fileChannel);
      }
    }
 catch (    IOException e) {
      ioex=e;
    }
catch (    Throwable t) {
      ioex=new IOException(""String_Node_Str"" + t.getMessage(),t);
    }
    request.channel.handleProcessedBuffer(request.buffer,ioex);
  }
}"
88266,"@Override public void run(){
  while (this.alive) {
    IORequest<Buffer.Output> request=null;
    while (request == null) {
      try {
        request=requestQueue.take();
      }
 catch (      InterruptedException iex) {
        if (!this.alive) {
          return;
        }
      }
    }
    IOException ioex=null;
    try {
      request.buffer.writeToChannel(request.channel.fileChannel);
    }
 catch (    IOException e) {
      ioex=e;
    }
    request.channel.handleProcessedBuffer(request.buffer,ioex);
  }
}","@Override public void run(){
  while (this.alive) {
    IORequest<Buffer.Output> request=null;
    while (request == null) {
      try {
        request=requestQueue.take();
      }
 catch (      InterruptedException iex) {
        if (!this.alive) {
          return;
        }
      }
    }
    IOException ioex=null;
    try {
      if (!request.buffer.memory.isFree()) {
        request.buffer.writeToChannel(request.channel.fileChannel);
      }
    }
 catch (    IOException e) {
      ioex=e;
    }
catch (    Throwable t) {
      ioex=new IOException(""String_Node_Str"" + t.getMessage(),t);
    }
    request.channel.handleProcessedBuffer(request.buffer,ioex);
  }
}"
88267,"/** 
 * Skips   {@code size} memory.
 */
public DataInputView skip(int size);","/** 
 * Skips   {@code size} memory.
 */
public DataInputView skip(int size) throws EOFException ;"
88268,"@Override public DataInputView skip(int size){
  position+=size;
  return this;
}","@Override public DataInputView skip(int size) throws EOFException {
  final int newPos=this.position + size;
  if (newPos < 0 || newPos > this.end) {
    throw new EOFException();
  }
  this.position=newPos;
  return this;
}"
88269,"@Override public String readLine() throws IOException {
  if (position < this.end) {
    char curr=readChar();
    while (position < this.end && curr != '\n') {
      bld.append(curr);
      curr=readChar();
    }
    int len=bld.length();
    if (len > 0 && bld.charAt(len - 1) == '\r') {
      bld.setLength(len - 1);
    }
    String s=bld.toString();
    bld.setLength(0);
    return s;
  }
 else {
    return null;
  }
}","@Override public String readLine() throws IOException {
  if (this.position < this.end) {
    char curr=readChar();
    while (position < this.end && curr != '\n') {
      bld.append(curr);
      curr=readChar();
    }
    int len=bld.length();
    if (len > 0 && bld.charAt(len - 1) == '\r') {
      bld.setLength(len - 1);
    }
    String s=bld.toString();
    bld.setLength(0);
    return s;
  }
 else {
    return null;
  }
}"
88270,"@Override public DataInputView setPosition(int position){
  this.position=position + this.offset;
  return this;
}","@Override public DataInputView setPosition(int position){
  if (position < 0 | position > this.size) {
    throw new IndexOutOfBoundsException(""String_Node_Str"" + this.size + ""String_Node_Str"");
  }
  this.position=position + this.offset;
  return this;
}"
88271,"@Override public char readChar() throws IOException {
  if (position + 1 < this.end) {
    return (char)(((this.memory[position++] & 0xff) << 8) | ((this.memory[position++] & 0xff) << 0));
  }
 else {
    throw new EOFException();
  }
}","@Override public char readChar() throws IOException {
  if (this.position < this.end - 1) {
    return (char)(((this.memory[this.position++] & 0xff) << 8) | ((this.memory[this.position++] & 0xff) << 0));
  }
 else {
    throw new EOFException();
  }
}"
88272,"@Override public int skipBytes(int n) throws IOException {
  if (position + n <= this.end) {
    position+=n;
    return n;
  }
 else {
    n=this.end - position;
    position=this.end;
    return n;
  }
}","@Override public int skipBytes(int n) throws IOException {
  if (this.position <= this.end - n) {
    this.position+=n;
    return n;
  }
 else {
    n=this.end - this.position;
    this.position=this.end;
    return n;
  }
}"
88273,"@Override public int getPosition(){
  return position - this.offset;
}","@Override public int getPosition(){
  return this.position - this.offset;
}"
88274,"@Override public long readLong() throws IOException {
  if (position >= 0 && position + 7 < this.end) {
    return (((long)this.memory[position++] & 0xff) << 56) | (((long)this.memory[position++] & 0xff) << 48) | (((long)this.memory[position++] & 0xff) << 40)| (((long)this.memory[position++] & 0xff) << 32)| (((long)this.memory[position++] & 0xff) << 24)| (((long)this.memory[position++] & 0xff) << 16)| (((long)this.memory[position++] & 0xff) << 8)| (((long)this.memory[position++] & 0xff) << 0);
  }
 else {
    throw new EOFException();
  }
}","@Override public long readLong() throws IOException {
  if (position >= 0 && position < this.end - 7) {
    return (((long)this.memory[position++] & 0xff) << 56) | (((long)this.memory[position++] & 0xff) << 48) | (((long)this.memory[position++] & 0xff) << 40)| (((long)this.memory[position++] & 0xff) << 32)| (((long)this.memory[position++] & 0xff) << 24)| (((long)this.memory[position++] & 0xff) << 16)| (((long)this.memory[position++] & 0xff) << 8)| (((long)this.memory[position++] & 0xff) << 0);
  }
 else {
    throw new EOFException();
  }
}"
88275,"@Override public short readShort() throws IOException {
  if (position >= 0 && position + 1 < this.end) {
    return (short)((((this.memory[position++]) & 0xff) << 8) | (((this.memory[position++]) & 0xff) << 0));
  }
 else {
    throw new EOFException();
  }
}","@Override public short readShort() throws IOException {
  if (position >= 0 && position < this.end - 1) {
    return (short)((((this.memory[position++]) & 0xff) << 8) | (((this.memory[position++]) & 0xff) << 0));
  }
 else {
    throw new EOFException();
  }
}"
88276,"@Override public void readFully(byte[] b,int off,int len) throws IOException {
  if (position < this.end && position + len <= this.end && off + len <= b.length) {
    System.arraycopy(this.memory,position,b,off,len);
    position+=len;
  }
 else {
    throw new EOFException();
  }
}","@Override public void readFully(byte[] b,int off,int len) throws IOException {
  if (this.position < this.end && this.position <= this.end - len && off <= b.length - len) {
    System.arraycopy(this.memory,position,b,off,len);
    position+=len;
  }
 else {
    throw new EOFException();
  }
}"
88277,"@Override public DataInputView reset(){
  position=this.offset;
  return this;
}","@Override public DataInputView reset(){
  this.position=this.offset;
  return this;
}"
88278,"@Override public boolean readBoolean() throws IOException {
  if (position < this.end) {
    return this.memory[position++] != 0;
  }
 else {
    throw new EOFException();
  }
}","@Override public boolean readBoolean() throws IOException {
  if (this.position < this.end) {
    return this.memory[this.position++] != 0;
  }
 else {
    throw new EOFException();
  }
}"
88279,"@Override public byte readByte() throws IOException {
  if (position < this.end) {
    return this.memory[position++];
  }
 else {
    throw new EOFException();
  }
}","@Override public byte readByte() throws IOException {
  if (this.position < this.end) {
    return this.memory[this.position++];
  }
 else {
    throw new EOFException();
  }
}"
88280,"@Override public int readInt() throws IOException {
  if (position >= 0 && position + 3 < this.end) {
    return ((this.memory[position++] & 0xff) << 24) | ((this.memory[position++] & 0xff) << 16) | ((this.memory[position++] & 0xff) << 8)| ((this.memory[position++] & 0xff) << 0);
  }
 else {
    throw new EOFException();
  }
}","@Override public int readInt() throws IOException {
  if (this.position >= 0 && this.position < this.end - 3) {
    return ((this.memory[position++] & 0xff) << 24) | ((this.memory[position++] & 0xff) << 16) | ((this.memory[position++] & 0xff) << 8)| ((this.memory[position++] & 0xff) << 0);
  }
 else {
    throw new EOFException();
  }
}"
88281,"@Override public int readUnsignedByte() throws IOException {
  if (position < this.end) {
    return (this.memory[position++] & 0xff);
  }
 else {
    throw new EOFException();
  }
}","@Override public int readUnsignedByte() throws IOException {
  if (this.position < this.end) {
    return (this.memory[this.position++] & 0xff);
  }
 else {
    throw new EOFException();
  }
}"
88282,"@Override public int readUnsignedShort() throws IOException {
  if (position + 1 < this.end) {
    return ((this.memory[position++] & 0xff) << 8) | ((this.memory[position++] & 0xff) << 0);
  }
 else {
    throw new EOFException();
  }
}","@Override public int readUnsignedShort() throws IOException {
  if (this.position < this.end - 1) {
    return ((this.memory[this.position++] & 0xff) << 8) | ((this.memory[this.position++] & 0xff) << 0);
  }
 else {
    throw new EOFException();
  }
}"
88283,"@Override public void writeInt(int v) throws IOException {
  if (position + 3 < this.end) {
    this.memory[position++]=(byte)((v >> 24) & 0xff);
    this.memory[position++]=(byte)((v >> 16) & 0xff);
    this.memory[position++]=(byte)((v >> 8) & 0xff);
    this.memory[position++]=(byte)((v >> 0) & 0xff);
  }
 else {
    throw new EOFException();
  }
}","@Override public void writeInt(int v) throws IOException {
  if (position < this.end - 3) {
    this.memory[position++]=(byte)((v >> 24) & 0xff);
    this.memory[position++]=(byte)((v >> 16) & 0xff);
    this.memory[position++]=(byte)((v >> 8) & 0xff);
    this.memory[position++]=(byte)((v >> 0) & 0xff);
  }
 else {
    throw new EOFException();
  }
}"
88284,"@Override public void writeChar(int v) throws IOException {
  if (position + 1 < this.end) {
    this.memory[position++]=(byte)((v >> 8) & 0xff);
    this.memory[position++]=(byte)((v >> 0) & 0xff);
  }
 else {
    throw new EOFException();
  }
}","@Override public void writeChar(int v) throws IOException {
  if (position < this.end - 1) {
    this.memory[position++]=(byte)((v >> 8) & 0xff);
    this.memory[position++]=(byte)((v >> 0) & 0xff);
  }
 else {
    throw new EOFException();
  }
}"
88285,"@Override public void writeLong(long v) throws IOException {
  if (position + 7 < this.end) {
    this.memory[position++]=(byte)((v >> 56) & 0xff);
    this.memory[position++]=(byte)((v >> 48) & 0xff);
    this.memory[position++]=(byte)((v >> 40) & 0xff);
    this.memory[position++]=(byte)((v >> 32) & 0xff);
    this.memory[position++]=(byte)((v >> 24) & 0xff);
    this.memory[position++]=(byte)((v >> 16) & 0xff);
    this.memory[position++]=(byte)((v >> 8) & 0xff);
    this.memory[position++]=(byte)((v >> 0) & 0xff);
  }
 else {
    throw new EOFException();
  }
}","@Override public void writeLong(long v) throws IOException {
  if (position < this.end - 7) {
    this.memory[position++]=(byte)((v >> 56) & 0xff);
    this.memory[position++]=(byte)((v >> 48) & 0xff);
    this.memory[position++]=(byte)((v >> 40) & 0xff);
    this.memory[position++]=(byte)((v >> 32) & 0xff);
    this.memory[position++]=(byte)((v >> 24) & 0xff);
    this.memory[position++]=(byte)((v >> 16) & 0xff);
    this.memory[position++]=(byte)((v >> 8) & 0xff);
    this.memory[position++]=(byte)((v >> 0) & 0xff);
  }
 else {
    throw new EOFException();
  }
}"
88286,"@Override public int getPosition(){
  return position - this.offset;
}","@Override public int getPosition(){
  return this.position - this.offset;
}"
88287,"@Override public void writeBytes(String s) throws IOException {
  final int sLen=s.length();
  if (this.position + sLen < this.end) {
    for (int i=0; i < sLen; i++) {
      writeByte(s.charAt(i));
    }
    this.position+=sLen;
  }
 else {
    throw new EOFException();
  }
}","@Override public void writeBytes(String s) throws IOException {
  final int sLen=s.length();
  if (this.position < this.end - sLen) {
    for (int i=0; i < sLen; i++) {
      writeByte(s.charAt(i));
    }
    this.position+=sLen;
  }
 else {
    throw new EOFException();
  }
}"
88288,"@Override public DataOutputView reset(){
  position=this.offset;
  return this;
}","@Override public DataOutputView reset(){
  this.position=this.offset;
  return this;
}"
88289,"@Override public void writeShort(int v) throws IOException {
  if (position + 1 < this.end) {
    this.memory[position++]=(byte)((v >>> 8) & 0xff);
    this.memory[position++]=(byte)((v >>> 0) & 0xff);
  }
 else {
    throw new EOFException();
  }
}","@Override public void writeShort(int v) throws IOException {
  if (position < this.end - 1) {
    this.memory[position++]=(byte)((v >>> 8) & 0xff);
    this.memory[position++]=(byte)((v >>> 0) & 0xff);
  }
 else {
    throw new EOFException();
  }
}"
88290,"@Override public void writeChars(String s) throws IOException {
  if (position + 2 * s.length() < this.end) {
    int length=s.length();
    for (int i=0; i < length; i++) {
      writeChar(s.charAt(i));
    }
  }
 else {
    throw new EOFException();
  }
}","@Override public void writeChars(String s) throws IOException {
  if (position < this.end - (2 * s.length())) {
    int length=s.length();
    for (int i=0; i < length; i++) {
      writeChar(s.charAt(i));
    }
  }
 else {
    throw new EOFException();
  }
}"
88291,"@Override public void write(byte[] b,int off,int len) throws IOException {
  if (position < this.end && position + len <= this.end && off + len <= b.length) {
    System.arraycopy(b,off,this.memory,position,len);
    position+=len;
  }
 else {
    throw new EOFException();
  }
}","@Override public void write(byte[] b,int off,int len) throws IOException {
  if (this.position < this.end && this.position <= this.end - len && off <= b.length - len) {
    System.arraycopy(b,off,this.memory,position,len);
    this.position+=len;
  }
 else {
    throw new EOFException();
  }
}"
88292,"@Override public void writeBoolean(boolean v) throws IOException {
  if (position < this.end) {
    this.memory[position++]=(byte)(v ? 1 : 0);
  }
 else {
    throw new EOFException();
  }
}","@Override public void writeBoolean(boolean v) throws IOException {
  if (this.position < this.end) {
    this.memory[this.position++]=(byte)(v ? 1 : 0);
  }
 else {
    throw new EOFException();
  }
}"
88293,"@Override public RandomAccessView get(DataOutput out,int offset,int length) throws IOException {
  if (offset >= 0 && offset < this.size && length >= 0 && length < this.size) {
    out.write(this.memory,this.offset + offset,length);
    return this;
  }
 else {
    throw new IndexOutOfBoundsException();
  }
}","@Override public RandomAccessView get(DataOutput out,int offset,int length) throws IOException {
  if (offset >= 0 && offset < this.size && length >= 0 && offset + length < this.size) {
    out.write(this.memory,this.offset + offset,length);
    return this;
  }
 else {
    throw new IndexOutOfBoundsException();
  }
}"
88294,"/** 
 * @param connection
 * @param outputVertex
 * @param inputVertex
 * @throws JobGraphDefinitionException
 * @throws CompilerException
 */
private void connectJobVertices(PactConnection connection,AbstractJobVertex outputVertex,AbstractJobVertex inputVertex) throws JobGraphDefinitionException, CompilerException {
  ChannelType channelType=null;
switch (connection.getShipStrategy()) {
case FORWARD:
case PARTITION_LOCAL_HASH:
    channelType=ChannelType.INMEMORY;
  break;
case PARTITION_HASH:
case BROADCAST:
case SFR:
channelType=ChannelType.NETWORK;
break;
default :
throw new IllegalArgumentException(""String_Node_Str"" + connection.getShipStrategy().name());
}
TaskConfig outputConfig=new TaskConfig(outputVertex.getConfiguration());
TaskConfig inputConfig=new TaskConfig(inputVertex.getConfiguration());
TaskConfig tempConfig=null;
switch (connection.getTempMode()) {
case NONE:
outputVertex.connectTo(inputVertex,channelType,CompressionLevel.NO_COMPRESSION);
outputConfig.addOutputShipStrategy(connection.getShipStrategy());
inputConfig.addInputShipStrategy(connection.getShipStrategy());
break;
case TEMP_SENDER_SIDE:
int pd=connection.getSourcePact().getDegreeOfParallelism();
JobTaskVertex tempVertex=generateTempVertex((Class<? extends Stub<?,?>>)connection.getSourcePact().getPactContract().getStubClass(),pd);
outputVertex.connectTo(tempVertex,ChannelType.INMEMORY,CompressionLevel.NO_COMPRESSION);
tempVertex.connectTo(inputVertex,channelType,CompressionLevel.NO_COMPRESSION);
tempConfig=new TaskConfig(tempVertex.getConfiguration());
outputConfig.addOutputShipStrategy(ShipStrategy.FORWARD);
tempConfig.addInputShipStrategy(ShipStrategy.FORWARD);
tempConfig.addOutputShipStrategy(connection.getShipStrategy());
inputConfig.addInputShipStrategy(connection.getShipStrategy());
break;
case TEMP_RECEIVER_SIDE:
int pdr=connection.getTargetPact().getDegreeOfParallelism();
tempVertex=generateTempVertex((Class<? extends Stub<?,?>>)connection.getSourcePact().getPactContract().getStubClass(),pdr);
outputVertex.connectTo(tempVertex,channelType,CompressionLevel.NO_COMPRESSION);
tempVertex.connectTo(inputVertex,ChannelType.INMEMORY,CompressionLevel.NO_COMPRESSION);
tempConfig=new TaskConfig(tempVertex.getConfiguration());
outputConfig.addOutputShipStrategy(connection.getShipStrategy());
tempConfig.addInputShipStrategy(connection.getShipStrategy());
tempConfig.addOutputShipStrategy(ShipStrategy.FORWARD);
inputConfig.addInputShipStrategy(ShipStrategy.FORWARD);
break;
default :
throw new CompilerException(""String_Node_Str"" + connection.getTempMode());
}
}","/** 
 * @param connection
 * @param outputVertex
 * @param inputVertex
 * @throws JobGraphDefinitionException
 * @throws CompilerException
 */
private void connectJobVertices(PactConnection connection,AbstractJobVertex outputVertex,AbstractJobVertex inputVertex) throws JobGraphDefinitionException, CompilerException {
  ChannelType channelType=null;
switch (connection.getShipStrategy()) {
case FORWARD:
case PARTITION_LOCAL_HASH:
    int sourceDOP=connection.getSourcePact().getDegreeOfParallelism();
  int sourceInnerDOP=connection.getSourcePact().getInstancesPerMachine();
int sourceNumInstances=(int)Math.ceil((double)sourceDOP / (double)sourceInnerDOP);
int targetDOP=connection.getTargetPact().getDegreeOfParallelism();
int targetInnerDOP=connection.getTargetPact().getInstancesPerMachine();
int targetNumInstances=(int)Math.ceil((double)targetDOP / (double)targetInnerDOP);
channelType=sourceNumInstances == targetNumInstances ? ChannelType.INMEMORY : ChannelType.NETWORK;
break;
case PARTITION_HASH:
case BROADCAST:
case SFR:
channelType=ChannelType.NETWORK;
break;
default :
throw new IllegalArgumentException(""String_Node_Str"" + connection.getShipStrategy().name());
}
TaskConfig outputConfig=new TaskConfig(outputVertex.getConfiguration());
TaskConfig inputConfig=new TaskConfig(inputVertex.getConfiguration());
TaskConfig tempConfig=null;
switch (connection.getTempMode()) {
case NONE:
outputVertex.connectTo(inputVertex,channelType,CompressionLevel.NO_COMPRESSION);
outputConfig.addOutputShipStrategy(connection.getShipStrategy());
inputConfig.addInputShipStrategy(connection.getShipStrategy());
break;
case TEMP_SENDER_SIDE:
int pd=connection.getSourcePact().getDegreeOfParallelism();
JobTaskVertex tempVertex=generateTempVertex((Class<? extends Stub<?,?>>)connection.getSourcePact().getPactContract().getStubClass(),pd);
outputVertex.connectTo(tempVertex,ChannelType.INMEMORY,CompressionLevel.NO_COMPRESSION);
tempVertex.connectTo(inputVertex,channelType,CompressionLevel.NO_COMPRESSION);
tempConfig=new TaskConfig(tempVertex.getConfiguration());
outputConfig.addOutputShipStrategy(ShipStrategy.FORWARD);
tempConfig.addInputShipStrategy(ShipStrategy.FORWARD);
tempConfig.addOutputShipStrategy(connection.getShipStrategy());
inputConfig.addInputShipStrategy(connection.getShipStrategy());
break;
case TEMP_RECEIVER_SIDE:
int pdr=connection.getTargetPact().getDegreeOfParallelism();
tempVertex=generateTempVertex((Class<? extends Stub<?,?>>)connection.getSourcePact().getPactContract().getStubClass(),pdr);
outputVertex.connectTo(tempVertex,channelType,CompressionLevel.NO_COMPRESSION);
tempVertex.connectTo(inputVertex,ChannelType.INMEMORY,CompressionLevel.NO_COMPRESSION);
tempConfig=new TaskConfig(tempVertex.getConfiguration());
outputConfig.addOutputShipStrategy(connection.getShipStrategy());
tempConfig.addInputShipStrategy(connection.getShipStrategy());
tempConfig.addOutputShipStrategy(ShipStrategy.FORWARD);
inputConfig.addInputShipStrategy(ShipStrategy.FORWARD);
break;
default :
throw new CompilerException(""String_Node_Str"" + connection.getTempMode());
}
}"
88295,"/** 
 * This methods implements the pre-visiting during a depth-first traversal. It create the job vertex and sets local strategy.
 * @param node The node that is currently processed.
 * @return True, if the visitor should descend to the node's children, false if not.
 * @see eu.stratosphere.pact.common.plan.Visitor#preVisit(eu.stratosphere.pact.common.plan.Visitable)
 */
@Override public boolean preVisit(OptimizerNode node){
  if (vertices.containsKey(node)) {
    return false;
  }
  AbstractJobVertex vertex=null;
  try {
switch (node.getPactType()) {
case Map:
      vertex=generateMapVertex(node);
    break;
case Reduce:
  if (node instanceof ReduceNode) {
    vertex=generateReduceVertex((ReduceNode)node);
  }
 else   if (node instanceof CombinerNode) {
    vertex=generateCombineVertex((CombinerNode)node);
  }
 else {
    throw new CompilerException(""String_Node_Str"" + node.getClass().getName());
  }
break;
case Match:
vertex=generateMatchVertex(node);
break;
case Cross:
vertex=generateCrossVertex(node);
break;
case Cogroup:
vertex=generateCoGroupVertex(node);
break;
case DataSource:
vertex=generateDataSourceVertex(node);
break;
case DataSink:
vertex=generateDataSinkVertex(node);
break;
default :
throw new Exception(""String_Node_Str"" + node.getPactType());
}
}
 catch (NotEnoughMemoryException nemex) {
throw new CompilerException(""String_Node_Str"" + node.getMemoryPerTask() + ""String_Node_Str""+ node.toString()+ ""String_Node_Str"");
}
catch (Exception e) {
throw new CompilerException(""String_Node_Str"" + e.getMessage(),e);
}
int pd=node.getDegreeOfParallelism();
vertex.setNumberOfSubtasks(pd);
if (maxDegreeVertex == null || maxDegreeVertex.getNumberOfSubtasks() < pd) {
maxDegreeVertex=vertex;
}
if (node.getInstancesPerMachine() >= 1) {
vertex.setNumberOfSubtasksPerInstance(node.getInstancesPerMachine());
}
this.vertices.put(node,vertex);
return true;
}","/** 
 * This methods implements the pre-visiting during a depth-first traversal. It create the job vertex and sets local strategy.
 * @param node The node that is currently processed.
 * @return True, if the visitor should descend to the node's children, false if not.
 * @see eu.stratosphere.pact.common.plan.Visitor#preVisit(eu.stratosphere.pact.common.plan.Visitable)
 */
@Override public boolean preVisit(OptimizerNode node){
  if (vertices.containsKey(node)) {
    return false;
  }
  AbstractJobVertex vertex=null;
  try {
switch (node.getPactType()) {
case Map:
      vertex=generateMapVertex(node);
    break;
case Reduce:
  if (node instanceof ReduceNode) {
    vertex=generateReduceVertex((ReduceNode)node);
  }
 else   if (node instanceof CombinerNode) {
    vertex=generateCombineVertex((CombinerNode)node);
  }
 else {
    throw new CompilerException(""String_Node_Str"" + node.getClass().getName());
  }
break;
case Match:
vertex=generateMatchVertex(node);
break;
case Cross:
vertex=generateCrossVertex(node);
break;
case Cogroup:
vertex=generateCoGroupVertex(node);
break;
case DataSource:
vertex=generateDataSourceVertex(node);
break;
case DataSink:
vertex=generateDataSinkVertex(node);
break;
default :
throw new Exception(""String_Node_Str"" + node.getPactType());
}
}
 catch (Exception e) {
throw new CompilerException(""String_Node_Str"" + e.getMessage(),e);
}
int pd=node.getDegreeOfParallelism();
vertex.setNumberOfSubtasks(pd);
if (maxDegreeVertex == null || maxDegreeVertex.getNumberOfSubtasks() < pd) {
maxDegreeVertex=vertex;
}
if (node.getInstancesPerMachine() >= 1) {
vertex.setNumberOfSubtasksPerInstance(node.getInstancesPerMachine());
}
this.vertices.put(node,vertex);
return true;
}"
88296,"/** 
 * Private utility method that generates the alternative Cross nodes, given fixed shipping strategies for the inputs.
 * @param target The list to put the alternatives in.
 * @param pred1 The predecessor node for the first input.
 * @param pred2 The predecessor node for the second input.
 * @param ss1 The shipping strategy for the first input.
 * @param ss2 The shipping strategy for the second input.
 * @param estimator The cost estimator.
 */
private void createLocalAlternatives(List<CrossNode> target,OptimizerNode pred1,OptimizerNode pred2,ShipStrategy ss1,ShipStrategy ss2,CostEstimator estimator){
  LocalProperties lpDefaults=new LocalProperties();
  GlobalProperties gp=null;
  LocalProperties lp=null;
  OutputContract oc=getOutputContract();
  boolean isFirst=false;
  if (oc.appliesToFirstInput()) {
    gp=PactConnection.getGlobalPropertiesAfterConnection(pred1,this,ss1);
    lp=PactConnection.getLocalPropertiesAfterConnection(pred1,this,ss1);
    isFirst=true;
  }
 else   if (oc.appliesToSecondInput()) {
    gp=PactConnection.getGlobalPropertiesAfterConnection(pred2,this,ss2);
    lp=PactConnection.getLocalPropertiesAfterConnection(pred2,this,ss2);
  }
 else {
    gp=new GlobalProperties();
    lp=new LocalProperties();
  }
  gp.setKeyUnique(false);
  lp.setKeyUnique(false);
  GlobalProperties gpNoOrder=gp.createCopy();
  gpNoOrder.setKeyOrder(Order.NONE);
  LocalStrategy ls=getLocalStrategy();
  if (ls != LocalStrategy.NONE) {
    if (ls == LocalStrategy.NESTEDLOOP_STREAMED_OUTER_FIRST) {
      gp=isFirst ? gp : gpNoOrder;
      lp=isFirst ? lp : lpDefaults;
    }
 else     if (ls == LocalStrategy.NESTEDLOOP_STREAMED_OUTER_SECOND) {
      gp=isFirst ? gpNoOrder : gp;
      lp=isFirst ? lpDefaults : lp;
    }
 else     if (ls == LocalStrategy.NESTEDLOOP_BLOCKED_OUTER_FIRST || ls == LocalStrategy.NESTEDLOOP_BLOCKED_OUTER_SECOND) {
      gp=gpNoOrder;
      lp=lpDefaults;
    }
 else {
      return;
    }
    createCrossAlternative(target,pred1,pred2,ss1,ss2,ls,gp,lp,estimator);
  }
 else {
    if (isFirst) {
      createCrossAlternative(target,pred1,pred2,ss1,ss2,LocalStrategy.NESTEDLOOP_STREAMED_OUTER_FIRST,gp,lp,estimator);
      createCrossAlternative(target,pred1,pred2,ss1,ss2,LocalStrategy.NESTEDLOOP_STREAMED_OUTER_SECOND,gpNoOrder.createCopy(),lpDefaults.createCopy(),estimator);
    }
 else {
      createCrossAlternative(target,pred1,pred2,ss1,ss2,LocalStrategy.NESTEDLOOP_STREAMED_OUTER_SECOND,gp,lp,estimator);
      createCrossAlternative(target,pred1,pred2,ss1,ss2,LocalStrategy.NESTEDLOOP_STREAMED_OUTER_FIRST,gpNoOrder.createCopy(),lpDefaults.createCopy(),estimator);
    }
    createCrossAlternative(target,pred1,pred2,ss1,ss2,LocalStrategy.NESTEDLOOP_BLOCKED_OUTER_FIRST,gpNoOrder.createCopy(),lpDefaults.createCopy(),estimator);
    createCrossAlternative(target,pred1,pred2,ss1,ss2,LocalStrategy.NESTEDLOOP_BLOCKED_OUTER_SECOND,gpNoOrder,lpDefaults,estimator);
  }
}","/** 
 * Private utility method that generates the alternative Cross nodes, given fixed shipping strategies for the inputs.
 * @param target The list to put the alternatives in.
 * @param pred1 The predecessor node for the first input.
 * @param pred2 The predecessor node for the second input.
 * @param ss1 The shipping strategy for the first input.
 * @param ss2 The shipping strategy for the second input.
 * @param estimator The cost estimator.
 */
private void createLocalAlternatives(List<CrossNode> target,OptimizerNode pred1,OptimizerNode pred2,ShipStrategy ss1,ShipStrategy ss2,CostEstimator estimator){
  LocalProperties lpDefaults=new LocalProperties();
  GlobalProperties gp=null;
  LocalProperties lp=null;
  OutputContract oc=getOutputContract();
  boolean isFirst=false;
  if (oc.appliesToFirstInput()) {
    gp=PactConnection.getGlobalPropertiesAfterConnection(pred1,this,ss1);
    lp=PactConnection.getLocalPropertiesAfterConnection(pred1,this,ss1);
    isFirst=true;
  }
 else   if (oc.appliesToSecondInput()) {
    gp=PactConnection.getGlobalPropertiesAfterConnection(pred2,this,ss2);
    lp=PactConnection.getLocalPropertiesAfterConnection(pred2,this,ss2);
  }
 else {
    gp=new GlobalProperties();
    lp=new LocalProperties();
  }
  gp.setKeyUnique(false);
  lp.setKeyUnique(false);
  GlobalProperties gpNoOrder=gp.createCopy();
  gpNoOrder.setKeyOrder(Order.NONE);
  LocalStrategy ls=getLocalStrategy();
  if (ls != LocalStrategy.NONE) {
    if (ls == LocalStrategy.NESTEDLOOP_STREAMED_OUTER_FIRST) {
      gp=isFirst ? gp : gpNoOrder;
      lp=isFirst ? lp : lpDefaults;
    }
 else     if (ls == LocalStrategy.NESTEDLOOP_STREAMED_OUTER_SECOND) {
      gp=isFirst ? gpNoOrder : gp;
      lp=isFirst ? lpDefaults : lp;
    }
 else     if (ls == LocalStrategy.NESTEDLOOP_BLOCKED_OUTER_FIRST || ls == LocalStrategy.NESTEDLOOP_BLOCKED_OUTER_SECOND) {
      gp=gpNoOrder;
      lp=lpDefaults;
    }
 else {
      return;
    }
    createCrossAlternative(target,pred1,pred2,ss1,ss2,ls,gp,lp,estimator);
  }
 else {
    if (pred1.getEstimatedOutputSize() > 0 && pred2.getEstimatedOutputSize() > 0) {
      if (isFirst) {
        createCrossAlternative(target,pred1,pred2,ss1,ss2,LocalStrategy.NESTEDLOOP_STREAMED_OUTER_FIRST,gp,lp,estimator);
        createCrossAlternative(target,pred1,pred2,ss1,ss2,LocalStrategy.NESTEDLOOP_STREAMED_OUTER_SECOND,gpNoOrder.createCopy(),lpDefaults.createCopy(),estimator);
      }
 else {
        createCrossAlternative(target,pred1,pred2,ss1,ss2,LocalStrategy.NESTEDLOOP_STREAMED_OUTER_SECOND,gp,lp,estimator);
        createCrossAlternative(target,pred1,pred2,ss1,ss2,LocalStrategy.NESTEDLOOP_STREAMED_OUTER_FIRST,gpNoOrder.createCopy(),lpDefaults.createCopy(),estimator);
      }
    }
    createCrossAlternative(target,pred1,pred2,ss1,ss2,LocalStrategy.NESTEDLOOP_BLOCKED_OUTER_FIRST,gpNoOrder.createCopy(),lpDefaults.createCopy(),estimator);
    createCrossAlternative(target,pred1,pred2,ss1,ss2,LocalStrategy.NESTEDLOOP_BLOCKED_OUTER_SECOND,gpNoOrder,lpDefaults,estimator);
  }
}"
88297,"/** 
 * Wires this group vertex to the specified group vertex and creates a back link.
 * @param groupVertex the group vertex that should be the target of the wiring
 * @param indexOfInputGate the index of the consuming task's input gate
 * @param indexOfOutputGate the index of the producing tasks's output gate
 * @param channelType the channel type to be used for this edge
 * @param userDefinedChannelType <code>true</code> if the channel type is user defined, <code>false</code> otherwise
 * @param compressionLevel the compression level to be used for this edge
 * @param userDefinedCompressionLevel <code>true</code> if the compression level is user defined, <code>false</code> otherwise
 */
public void wireTo(ExecutionGroupVertex groupVertex,int indexOfInputGate,int indexOfOutputGate,ChannelType channelType,boolean userDefinedChannelType,CompressionLevel compressionLevel,boolean userDefinedCompressionLevel) throws GraphConversionException {
  List<ExecutionGroupEdge> edges=this.getForwardEdges(groupVertex);
  if (edges.size() > 0) {
    if (channelType != edges.get(0).getChannelType()) {
      if (userDefinedChannelType) {
        throw new GraphConversionException(""String_Node_Str"" + getName() + ""String_Node_Str""+ groupVertex+ ""String_Node_Str"");
      }
 else {
        channelType=edges.get(0).getChannelType();
      }
    }
  }
  final ExecutionGroupEdge edge=new ExecutionGroupEdge(this.executionGraph,this,indexOfOutputGate,groupVertex,indexOfInputGate,channelType,userDefinedChannelType,compressionLevel,userDefinedCompressionLevel);
synchronized (this.forwardLinks) {
    this.forwardLinks.add(edge);
  }
  groupVertex.wireBackLink(edge);
}","/** 
 * Wires this group vertex to the specified group vertex and creates a back link.
 * @param groupVertex the group vertex that should be the target of the wiring
 * @param indexOfInputGate the index of the consuming task's input gate
 * @param indexOfOutputGate the index of the producing tasks's output gate
 * @param channelType the channel type to be used for this edge
 * @param userDefinedChannelType <code>true</code> if the channel type is user defined, <code>false</code> otherwise
 * @param compressionLevel the compression level to be used for this edge
 * @param userDefinedCompressionLevel <code>true</code> if the compression level is user defined, <code>false</code> otherwise
 */
public void wireTo(ExecutionGroupVertex groupVertex,int indexOfInputGate,int indexOfOutputGate,ChannelType channelType,boolean userDefinedChannelType,CompressionLevel compressionLevel,boolean userDefinedCompressionLevel) throws GraphConversionException {
synchronized (this.forwardLinks) {
    if (indexOfOutputGate < this.forwardLinks.size()) {
      final ExecutionGroupEdge previousEdge=this.forwardLinks.get(indexOfOutputGate);
      if (previousEdge != null) {
        throw new GraphConversionException(""String_Node_Str"" + indexOfOutputGate + ""String_Node_Str""+ getName()+ ""String_Node_Str"");
      }
    }
  }
  final ExecutionGroupEdge edge=new ExecutionGroupEdge(this.executionGraph,this,indexOfOutputGate,groupVertex,indexOfInputGate,channelType,userDefinedChannelType,compressionLevel,userDefinedCompressionLevel);
synchronized (this.forwardLinks) {
    this.forwardLinks.add(edge);
  }
  groupVertex.wireBackLink(edge);
}"
88298,"/** 
 * Tests the Nephele execution with a job that has two vertices, that are connected twice with each other with different channel types.
 */
@Test public void testExecutionDoubleConnection(){
  File inputFile=null;
  File outputFile=null;
  File jarFile=new File(ServerTestUtils.getTempDir() + File.separator + ""String_Node_Str"");
  try {
    inputFile=ServerTestUtils.createInputFile(0);
    outputFile=new File(ServerTestUtils.getTempDir() + File.separator + ServerTestUtils.getRandomFilename());
    JarFileCreator jfc=new JarFileCreator(jarFile);
    jfc.addClass(DoubleSourceTask.class);
    jfc.addClass(DoubleTargetTask.class);
    jfc.createJarFile();
    final JobGraph jg=new JobGraph(""String_Node_Str"");
    final JobFileInputVertex i1=new JobFileInputVertex(""String_Node_Str"",jg);
    i1.setFileInputClass(DoubleSourceTask.class);
    i1.setFilePath(new Path(""String_Node_Str"" + inputFile.getAbsolutePath().toString()));
    final JobTaskVertex t1=new JobTaskVertex(""String_Node_Str"",jg);
    t1.setTaskClass(DoubleTargetTask.class);
    JobFileOutputVertex o1=new JobFileOutputVertex(""String_Node_Str"",jg);
    o1.setFileOutputClass(FileLineWriter.class);
    o1.setFilePath(new Path(""String_Node_Str"" + outputFile.getAbsolutePath().toString()));
    t1.setVertexToShareInstancesWith(i1);
    o1.setVertexToShareInstancesWith(i1);
    i1.connectTo(t1,ChannelType.INMEMORY,CompressionLevel.NO_COMPRESSION);
    i1.connectTo(t1,ChannelType.NETWORK,CompressionLevel.NO_COMPRESSION);
    t1.connectTo(o1,ChannelType.INMEMORY,CompressionLevel.NO_COMPRESSION);
    jg.addJar(new Path(""String_Node_Str"" + jarFile.getAbsolutePath()));
    final JobClient jobClient=new JobClient(jg,configuration);
    try {
      jobClient.submitJobAndWait();
    }
 catch (    JobExecutionException e) {
      if (e.getMessage() == null) {
        fail(""String_Node_Str"");
      }
      if (!e.getMessage().contains(RuntimeExceptionTask.RUNTIME_EXCEPTION_MESSAGE)) {
        fail(""String_Node_Str"");
      }
      return;
    }
    fail(""String_Node_Str"");
  }
 catch (  JobGraphDefinitionException jgde) {
    fail(jgde.getMessage());
  }
catch (  IOException ioe) {
    fail(ioe.getMessage());
  }
 finally {
    if (inputFile != null) {
      inputFile.delete();
    }
    if (outputFile != null) {
      outputFile.delete();
    }
    if (jarFile != null) {
      jarFile.delete();
    }
  }
}","/** 
 * Tests the Nephele execution with a job that has two vertices, that are connected twice with each other with different channel types.
 */
@Test public void testExecutionDoubleConnection(){
  File inputFile=null;
  File outputFile=null;
  File jarFile=new File(ServerTestUtils.getTempDir() + File.separator + ""String_Node_Str"");
  try {
    inputFile=ServerTestUtils.createInputFile(0);
    outputFile=new File(ServerTestUtils.getTempDir() + File.separator + ServerTestUtils.getRandomFilename());
    JarFileCreator jfc=new JarFileCreator(jarFile);
    jfc.addClass(DoubleSourceTask.class);
    jfc.addClass(DoubleTargetTask.class);
    jfc.createJarFile();
    final JobGraph jg=new JobGraph(""String_Node_Str"");
    final JobFileInputVertex i1=new JobFileInputVertex(""String_Node_Str"",jg);
    i1.setFileInputClass(DoubleSourceTask.class);
    i1.setFilePath(new Path(""String_Node_Str"" + inputFile.getAbsolutePath().toString()));
    final JobTaskVertex t1=new JobTaskVertex(""String_Node_Str"",jg);
    t1.setTaskClass(DoubleTargetTask.class);
    JobFileOutputVertex o1=new JobFileOutputVertex(""String_Node_Str"",jg);
    o1.setFileOutputClass(FileLineWriter.class);
    o1.setFilePath(new Path(""String_Node_Str"" + outputFile.getAbsolutePath().toString()));
    t1.setVertexToShareInstancesWith(i1);
    o1.setVertexToShareInstancesWith(i1);
    i1.connectTo(t1,ChannelType.INMEMORY,CompressionLevel.NO_COMPRESSION);
    i1.connectTo(t1,ChannelType.NETWORK,CompressionLevel.NO_COMPRESSION);
    t1.connectTo(o1,ChannelType.INMEMORY,CompressionLevel.NO_COMPRESSION);
    jg.addJar(new Path(""String_Node_Str"" + jarFile.getAbsolutePath()));
    final JobClient jobClient=new JobClient(jg,configuration);
    jobClient.submitJobAndWait();
  }
 catch (  JobExecutionException e) {
    fail(e.getMessage());
  }
catch (  JobGraphDefinitionException jgde) {
    fail(jgde.getMessage());
  }
catch (  IOException ioe) {
    fail(ioe.getMessage());
  }
 finally {
    if (inputFile != null) {
      inputFile.delete();
    }
    if (outputFile != null) {
      outputFile.delete();
    }
    if (jarFile != null) {
      jarFile.delete();
    }
  }
}"
88299,"/** 
 * Sets the shipping strategy for this connection.
 * @param strategy The shipping strategy to be applied to this connection.
 */
public void setShipStrategy(ShipStrategy strategy){
  if (strategy == ShipStrategy.FORWARD && sourcePact.getDegreeOfParallelism() < targetPact.getDegreeOfParallelism()) {
    for (    InterestingProperties props : this.interestingProps) {
      PartitionProperty pp=props.getGlobalProperties().getPartitioning();
      if (pp == PartitionProperty.HASH_PARTITIONED || pp == PartitionProperty.ANY) {
        strategy=ShipStrategy.PARTITION_LOCAL_HASH;
        break;
      }
 else       if (pp == PartitionProperty.RANGE_PARTITIONED) {
        throw new CompilerException(""String_Node_Str"" + ""String_Node_Str"");
      }
    }
  }
  this.shipStrategy=strategy;
}","/** 
 * Sets the shipping strategy for this connection.
 * @param strategy The shipping strategy to be applied to this connection.
 */
public void setShipStrategy(ShipStrategy strategy){
  if (strategy == ShipStrategy.FORWARD && sourcePact.getDegreeOfParallelism() < targetPact.getDegreeOfParallelism()) {
    if (this.interestingProps != null) {
      for (      InterestingProperties props : this.interestingProps) {
        PartitionProperty pp=props.getGlobalProperties().getPartitioning();
        if (pp == PartitionProperty.HASH_PARTITIONED || pp == PartitionProperty.ANY) {
          strategy=ShipStrategy.PARTITION_LOCAL_HASH;
          break;
        }
 else         if (pp == PartitionProperty.RANGE_PARTITIONED) {
          throw new CompilerException(""String_Node_Str"" + ""String_Node_Str"");
        }
      }
    }
  }
  this.shipStrategy=strategy;
}"
88300,"/** 
 * Entry point of the thread.
 */
public void go() throws IOException {
  final Channel.Enumerator enumerator=this.ioManager.createChannelEnumerator();
  final List<MemorySegment> writeBuffers;
  List<Channel.ID> channelIDs=new ArrayList<Channel.ID>();
  try {
    writeBuffers=this.memoryManager.allocate(CombiningUnilateralSortMerger.this.parent,writeMemSize,NUM_WRITE_BUFFERS,MIN_IO_BUFFER_SIZE);
    registerSegmentsToBeFreedAtShutdown(writeBuffers);
  }
 catch (  MemoryAllocationException maex) {
    throw new IOException(""String_Node_Str"",maex);
  }
  while (isRunning()) {
    CircularElement element=null;
    try {
      element=queues.spill.take();
    }
 catch (    InterruptedException iex) {
      if (isRunning()) {
        LOG.error(""String_Node_Str"" + ""String_Node_Str"");
        continue;
      }
 else {
        return;
      }
    }
    if (!isRunning()) {
      return;
    }
    if (element == SENTINEL) {
      break;
    }
    final Channel.ID channel=enumerator.next();
    channelIDs.add(channel);
    LOG.debug(""String_Node_Str"" + channel.toString() + '.');
    final ChannelWriter writer=ioManager.createChannelWriter(channel,writeBuffers);
    LOG.debug(""String_Node_Str"" + element.id + '.');
    final BufferSortableGuaranteed<K,V> buffer=element.buffer;
    final CombineValueIterator<V> iter=new CombineValueIterator<V>(buffer);
    final Collector<K,V> collector=new WriterCollector<K,V>(writer);
    int i=0;
    int stop=buffer.size() - 1;
    while (i < stop) {
      int seqStart=i;
      while (i < stop && 0 == buffer.compare(i,i + 1)) {
        i++;
      }
      if (i == seqStart) {
        buffer.writeToChannel(writer,seqStart,1);
      }
 else {
        K key=buffer.getKey(seqStart);
        iter.set(seqStart,i);
        combineStub.combine(key,iter,collector);
      }
      i++;
    }
    if (i == stop) {
      buffer.writeToChannel(writer,stop,1);
    }
    LOG.debug(""String_Node_Str"" + element.id + ""String_Node_Str"");
    writer.close();
    element.buffer.reset();
    queues.empty.add(element);
  }
  LOG.debug(""String_Node_Str"");
  LOG.debug(""String_Node_Str"");
  while (!queues.empty.isEmpty()) {
    try {
      this.memoryManager.release(queues.empty.take().buffer.unbind());
    }
 catch (    InterruptedException iex) {
      if (isRunning()) {
        LOG.error(""String_Node_Str"" + ""String_Node_Str"");
      }
 else {
        return;
      }
    }
  }
  if (CombiningUnilateralSortMerger.this.sortSegments != null) {
    unregisterSegmentsToBeFreedAtShutdown(CombiningUnilateralSortMerger.this.sortSegments);
    CombiningUnilateralSortMerger.this.sortSegments.clear();
  }
  try {
    while (channelIDs.size() > CombiningUnilateralSortMerger.this.maxNumFileHandles) {
      channelIDs=mergeChannelList(channelIDs,writeBuffers,this.readMemSize);
    }
    this.memoryManager.release(writeBuffers);
    unregisterSegmentsToBeFreedAtShutdown(writeBuffers);
    final List<List<MemorySegment>> readBuffers=new ArrayList<List<MemorySegment>>(channelIDs.size());
    final List<MemorySegment> allBuffers=getSegmentsForReaders(readBuffers,this.readMemSize,channelIDs.size());
    registerSegmentsToBeFreedAtShutdown(allBuffers);
    final List<ChannelAccess<?>> readers=new ArrayList<ChannelAccess<?>>(channelIDs.size());
    registerChannelsToBeRemovedAtShudown(readers);
    final Iterator<KeyValuePair<K,V>> mergeIterator=getMergingIterator(channelIDs,readBuffers,readers);
    if (CombiningUnilateralSortMerger.this.combineLastMerge) {
      KeyGroupedIterator<K,V> iter=new KeyGroupedIterator<K,V>(mergeIterator);
      setResultIterator(new CombiningIterator<K,V>(combineStub,iter));
    }
 else {
      setResultIterator(mergeIterator);
    }
  }
 catch (  MemoryAllocationException maex) {
    throw new IOException(""String_Node_Str"",maex);
  }
  LOG.debug(""String_Node_Str"");
}","/** 
 * Entry point of the thread.
 */
public void go() throws IOException {
  final Channel.Enumerator enumerator=this.ioManager.createChannelEnumerator();
  final List<MemorySegment> writeBuffers;
  List<Channel.ID> channelIDs=new ArrayList<Channel.ID>();
  try {
    writeBuffers=this.memoryManager.allocate(CombiningUnilateralSortMerger.this.parent,writeMemSize,NUM_WRITE_BUFFERS,MIN_IO_BUFFER_SIZE);
    registerSegmentsToBeFreedAtShutdown(writeBuffers);
  }
 catch (  MemoryAllocationException maex) {
    throw new IOException(""String_Node_Str"",maex);
  }
  while (isRunning()) {
    CircularElement element=null;
    try {
      element=queues.spill.take();
    }
 catch (    InterruptedException iex) {
      if (isRunning()) {
        LOG.error(""String_Node_Str"" + ""String_Node_Str"");
        continue;
      }
 else {
        return;
      }
    }
    if (!isRunning()) {
      return;
    }
    if (element == SENTINEL) {
      break;
    }
    final Channel.ID channel=enumerator.next();
    channelIDs.add(channel);
    LOG.debug(""String_Node_Str"" + channel.toString() + '.');
    final ChannelWriter writer=ioManager.createChannelWriter(channel,writeBuffers);
    LOG.debug(""String_Node_Str"" + element.id + '.');
    final BufferSortableGuaranteed<K,V> buffer=element.buffer;
    final CombineValueIterator<V> iter=new CombineValueIterator<V>(buffer);
    final Collector<K,V> collector=new WriterCollector<K,V>(writer);
    int i=0;
    int stop=buffer.size() - 1;
    while (i < stop) {
      int seqStart=i;
      while (i < stop && 0 == buffer.compare(i,i + 1)) {
        i++;
      }
      if (i == seqStart) {
        buffer.writeToChannel(writer,seqStart,1);
      }
 else {
        K key=buffer.getKey(seqStart);
        iter.set(seqStart,i);
        combineStub.combine(key,iter,collector);
      }
      i++;
    }
    if (i == stop) {
      buffer.writeToChannel(writer,stop,1);
    }
    LOG.debug(""String_Node_Str"" + element.id + ""String_Node_Str"");
    writer.close();
    element.buffer.reset();
    queues.empty.add(element);
  }
  LOG.debug(""String_Node_Str"");
  LOG.debug(""String_Node_Str"");
  while (!queues.empty.isEmpty()) {
    try {
      this.memoryManager.release(queues.empty.take().buffer.unbind());
    }
 catch (    InterruptedException iex) {
      if (isRunning()) {
        LOG.error(""String_Node_Str"" + ""String_Node_Str"");
      }
 else {
        return;
      }
    }
  }
  if (CombiningUnilateralSortMerger.this.sortSegments != null) {
    unregisterSegmentsToBeFreedAtShutdown(CombiningUnilateralSortMerger.this.sortSegments);
    CombiningUnilateralSortMerger.this.sortSegments.clear();
  }
  try {
    while (channelIDs.size() > CombiningUnilateralSortMerger.this.maxNumFileHandles) {
      channelIDs=mergeChannelList(channelIDs,writeBuffers,this.readMemSize);
    }
    this.memoryManager.release(writeBuffers);
    unregisterSegmentsToBeFreedAtShutdown(writeBuffers);
    if (channelIDs.isEmpty()) {
      setResultIterator(EmptyIterator.<KeyValuePair<K,V>>get());
    }
 else {
      final List<List<MemorySegment>> readBuffers=new ArrayList<List<MemorySegment>>(channelIDs.size());
      final List<MemorySegment> allBuffers=getSegmentsForReaders(readBuffers,this.readMemSize,channelIDs.size());
      registerSegmentsToBeFreedAtShutdown(allBuffers);
      final List<ChannelAccess<?>> readers=new ArrayList<ChannelAccess<?>>(channelIDs.size());
      registerChannelsToBeRemovedAtShudown(readers);
      final Iterator<KeyValuePair<K,V>> mergeIterator=getMergingIterator(channelIDs,readBuffers,readers);
      if (CombiningUnilateralSortMerger.this.combineLastMerge) {
        KeyGroupedIterator<K,V> iter=new KeyGroupedIterator<K,V>(mergeIterator);
        setResultIterator(new CombiningIterator<K,V>(combineStub,iter));
      }
 else {
        setResultIterator(mergeIterator);
      }
    }
  }
 catch (  MemoryAllocationException maex) {
    throw new IOException(""String_Node_Str"",maex);
  }
  LOG.debug(""String_Node_Str"");
}"
88301,"/** 
 * Fills the given list with collections of buffers for channels. The list will contain as many collections as the parameter <code>numReaders</code> specifies.
 * @param target The list into which the lists with buffers for the channels are put.
 * @param totalReadMemory The total amount of memory to be divided among the channels.
 * @param numChannels The number of channels for which to allocate buffers.
 * @return A list with all memory segments that were allocated.
 * @throws MemoryAllocationException Thrown, if the specified memory is insufficient to merge the channelsor if the memory manager could not provide the requested memory.
 */
protected final List<MemorySegment> getSegmentsForReaders(List<List<MemorySegment>> target,long totalReadMemory,int numChannels) throws MemoryAllocationException {
  final long ioMemoryPerChannel=totalReadMemory / numChannels;
  final int numBuffers=ioMemoryPerChannel < 2 * MIN_IO_BUFFER_SIZE ? 1 : ioMemoryPerChannel < 2 * MAX_IO_BUFFER_SIZE ? 2 : (int)(ioMemoryPerChannel / MAX_IO_BUFFER_SIZE);
  final long bufferSize=(ioMemoryPerChannel / numBuffers) & BUFFER_ALIGNMENT_MASK;
  final List<MemorySegment> memorySegments=this.memoryManager.allocate(this.parent,bufferSize * numBuffers * numChannels,numBuffers * numChannels,MIN_IO_BUFFER_SIZE);
  for (int i=0, buffer=0; i < numChannels - 1; i++) {
    List<MemorySegment> segs=new ArrayList<MemorySegment>(numBuffers);
    target.add(segs);
    for (int k=0; k < numBuffers; k++, buffer++) {
      segs.add(memorySegments.get(buffer));
    }
  }
  List<MemorySegment> segsForLast=new ArrayList<MemorySegment>(numBuffers);
  target.add(segsForLast);
  for (int i=(numChannels - 1) * numBuffers; i < memorySegments.size(); i++) {
    segsForLast.add(memorySegments.get(i));
  }
  return memorySegments;
}","/** 
 * Fills the given list with collections of buffers for channels. The list will contain as many collections as the parameter <code>numReaders</code> specifies.
 * @param target The list into which the lists with buffers for the channels are put.
 * @param totalReadMemory The total amount of memory to be divided among the channels.
 * @param numChannels The number of channels for which to allocate buffers. Must not be zero.
 * @return A list with all memory segments that were allocated.
 * @throws MemoryAllocationException Thrown, if the specified memory is insufficient to merge the channelsor if the memory manager could not provide the requested memory.
 */
protected final List<MemorySegment> getSegmentsForReaders(List<List<MemorySegment>> target,long totalReadMemory,int numChannels) throws MemoryAllocationException {
  final long ioMemoryPerChannel=totalReadMemory / numChannels;
  final int numBuffers=ioMemoryPerChannel < 2 * MIN_IO_BUFFER_SIZE ? 1 : ioMemoryPerChannel < 2 * MAX_IO_BUFFER_SIZE ? 2 : (int)(ioMemoryPerChannel / MAX_IO_BUFFER_SIZE);
  final long bufferSize=(ioMemoryPerChannel / numBuffers) & BUFFER_ALIGNMENT_MASK;
  final List<MemorySegment> memorySegments=this.memoryManager.allocate(this.parent,bufferSize * numBuffers * numChannels,numBuffers * numChannels,MIN_IO_BUFFER_SIZE);
  for (int i=0, buffer=0; i < numChannels - 1; i++) {
    List<MemorySegment> segs=new ArrayList<MemorySegment>(numBuffers);
    target.add(segs);
    for (int k=0; k < numBuffers; k++, buffer++) {
      segs.add(memorySegments.get(buffer));
    }
  }
  List<MemorySegment> segsForLast=new ArrayList<MemorySegment>(numBuffers);
  target.add(segsForLast);
  for (int i=(numChannels - 1) * numBuffers; i < memorySegments.size(); i++) {
    segsForLast.add(memorySegments.get(i));
  }
  return memorySegments;
}"
88302,"/** 
 * Entry point of the thread.
 */
public void go() throws IOException {
  final Channel.Enumerator enumerator=this.ioManager.createChannelEnumerator();
  final List<MemorySegment> writeBuffers;
  List<Channel.ID> channelIDs=new ArrayList<Channel.ID>();
  try {
    writeBuffers=this.memoryManager.allocate(UnilateralSortMerger.this.parent,writeMemSize,NUM_WRITE_BUFFERS,MIN_IO_BUFFER_SIZE);
    registerSegmentsToBeFreedAtShutdown(writeBuffers);
  }
 catch (  MemoryAllocationException maex) {
    throw new IOException(""String_Node_Str"",maex);
  }
  while (isRunning()) {
    CircularElement element=null;
    try {
      element=this.queues.spill.take();
    }
 catch (    InterruptedException iex) {
      if (isRunning()) {
        LOG.error(""String_Node_Str"" + ""String_Node_Str"");
        continue;
      }
 else {
        return;
      }
    }
    if (!isRunning()) {
      return;
    }
    if (element == SENTINEL) {
      break;
    }
    Channel.ID channel=enumerator.next();
    channelIDs.add(channel);
    ChannelWriter writer=this.ioManager.createChannelWriter(channel,writeBuffers);
    LOG.debug(""String_Node_Str"" + element.id + ""String_Node_Str"");
    element.buffer.writeToChannel(writer);
    LOG.debug(""String_Node_Str"" + element.id + ""String_Node_Str"");
    writer.close();
    element.buffer.reset();
    queues.empty.add(element);
  }
  LOG.debug(""String_Node_Str"");
  LOG.debug(""String_Node_Str"");
  while (!queues.empty.isEmpty()) {
    try {
      memoryManager.release(queues.empty.take().buffer.unbind());
    }
 catch (    InterruptedException iex) {
      if (isRunning()) {
        LOG.error(""String_Node_Str"" + ""String_Node_Str"");
      }
 else {
        return;
      }
    }
  }
  if (UnilateralSortMerger.this.sortSegments != null) {
    unregisterSegmentsToBeFreedAtShutdown(UnilateralSortMerger.this.sortSegments);
    UnilateralSortMerger.this.sortSegments.clear();
  }
  try {
    while (channelIDs.size() > UnilateralSortMerger.this.maxNumFileHandles) {
      channelIDs=mergeChannelList(channelIDs,writeBuffers,this.readMemSize);
    }
    this.memoryManager.release(writeBuffers);
    unregisterSegmentsToBeFreedAtShutdown(writeBuffers);
    writeBuffers.clear();
    List<List<MemorySegment>> readBuffers=new ArrayList<List<MemorySegment>>(channelIDs.size());
    List<MemorySegment> allBuffers=getSegmentsForReaders(readBuffers,this.readMemSize,channelIDs.size());
    registerSegmentsToBeFreedAtShutdown(allBuffers);
    List<ChannelAccess<?>> readers=new ArrayList<ChannelAccess<?>>(channelIDs.size());
    registerChannelsToBeRemovedAtShudown(readers);
    setResultIterator(getMergingIterator(channelIDs,readBuffers,readers));
  }
 catch (  MemoryAllocationException maex) {
    throw new IOException(""String_Node_Str"",maex);
  }
  LOG.debug(""String_Node_Str"");
}","/** 
 * Entry point of the thread.
 */
public void go() throws IOException {
  final Channel.Enumerator enumerator=this.ioManager.createChannelEnumerator();
  final List<MemorySegment> writeBuffers;
  List<Channel.ID> channelIDs=new ArrayList<Channel.ID>();
  try {
    writeBuffers=this.memoryManager.allocate(UnilateralSortMerger.this.parent,writeMemSize,NUM_WRITE_BUFFERS,MIN_IO_BUFFER_SIZE);
    registerSegmentsToBeFreedAtShutdown(writeBuffers);
  }
 catch (  MemoryAllocationException maex) {
    throw new IOException(""String_Node_Str"",maex);
  }
  while (isRunning()) {
    CircularElement element=null;
    try {
      element=this.queues.spill.take();
    }
 catch (    InterruptedException iex) {
      if (isRunning()) {
        LOG.error(""String_Node_Str"" + ""String_Node_Str"");
        continue;
      }
 else {
        return;
      }
    }
    if (!isRunning()) {
      return;
    }
    if (element == SENTINEL) {
      break;
    }
    Channel.ID channel=enumerator.next();
    channelIDs.add(channel);
    ChannelWriter writer=this.ioManager.createChannelWriter(channel,writeBuffers);
    LOG.debug(""String_Node_Str"" + element.id + ""String_Node_Str"");
    element.buffer.writeToChannel(writer);
    LOG.debug(""String_Node_Str"" + element.id + ""String_Node_Str"");
    writer.close();
    element.buffer.reset();
    queues.empty.add(element);
  }
  LOG.debug(""String_Node_Str"");
  LOG.debug(""String_Node_Str"");
  while (!queues.empty.isEmpty()) {
    try {
      memoryManager.release(queues.empty.take().buffer.unbind());
    }
 catch (    InterruptedException iex) {
      if (isRunning()) {
        LOG.error(""String_Node_Str"" + ""String_Node_Str"");
      }
 else {
        return;
      }
    }
  }
  if (UnilateralSortMerger.this.sortSegments != null) {
    unregisterSegmentsToBeFreedAtShutdown(UnilateralSortMerger.this.sortSegments);
    UnilateralSortMerger.this.sortSegments.clear();
  }
  try {
    while (channelIDs.size() > UnilateralSortMerger.this.maxNumFileHandles) {
      channelIDs=mergeChannelList(channelIDs,writeBuffers,this.readMemSize);
    }
    this.memoryManager.release(writeBuffers);
    unregisterSegmentsToBeFreedAtShutdown(writeBuffers);
    writeBuffers.clear();
    if (channelIDs.isEmpty()) {
      setResultIterator(EmptyIterator.<KeyValuePair<K,V>>get());
    }
 else {
      LOG.debug(""String_Node_Str"");
      List<List<MemorySegment>> readBuffers=new ArrayList<List<MemorySegment>>(channelIDs.size());
      List<MemorySegment> allBuffers=getSegmentsForReaders(readBuffers,this.readMemSize,channelIDs.size());
      registerSegmentsToBeFreedAtShutdown(allBuffers);
      List<ChannelAccess<?>> readers=new ArrayList<ChannelAccess<?>>(channelIDs.size());
      registerChannelsToBeRemovedAtShudown(readers);
      setResultIterator(getMergingIterator(channelIDs,readBuffers,readers));
    }
  }
 catch (  MemoryAllocationException maex) {
    throw new IOException(""String_Node_Str"",maex);
  }
  LOG.debug(""String_Node_Str"");
}"
88303,"/** 
 * <p> Calls the <code>MatchStub#match()</code> method for all two key-value pairs that share the same key and come from different inputs. The output of the <code>match()</code> method is forwarded. <p> This method is called with a key and two iterator (one for each input) over all values that share this key. <p>
 * @param key A key.
 * @param values1 An iterator on values of the first input that were paired with the key.
 * @param values2 An iterator on values of the second input that were paired with the key.
 * @param out A collector that collects all output pairs.
 */
private void crossValues(Key key,final Iterator<Value> values1,final Iterator<Value> values2) throws RuntimeException {
  final Value firstV1=values1.next();
  final Value firstV2=values2.next();
  if (firstV1 == null || firstV2 == null) {
    return;
  }
  boolean v1HasNext=values1.hasNext();
  boolean v2HasNext=values2.hasNext();
  if (!v1HasNext && !v2HasNext) {
    matchStub.match(key,firstV1,firstV2,output);
    return;
  }
  Value v1;
  Value v2;
  keyCopier.setCopy(key);
  if (!v1HasNext) {
    this.v1Copier.setCopy(firstV1);
    matchStub.match(key,firstV1,firstV2,output);
    while (v2HasNext && !this.taskCanceled) {
      key=this.keySerialization.newInstance();
      this.keyCopier.getCopy(key);
      v1=this.v1Serialization.newInstance();
      this.v1Copier.getCopy(v1);
      v2=values2.next();
      v2HasNext=values2.hasNext();
      matchStub.match(key,v1,v2,output);
    }
  }
 else   if (!v2HasNext && !this.taskCanceled) {
    this.v2Copier.setCopy(firstV2);
    matchStub.match(key,firstV1,firstV2,output);
    while (v1HasNext) {
      key=this.keySerialization.newInstance();
      this.keyCopier.getCopy(key);
      v2=this.v2Serialization.newInstance();
      this.v2Copier.getCopy(v2);
      v1=values1.next();
      v1HasNext=values1.hasNext();
      matchStub.match(key,v1,v2,output);
    }
  }
 else {
    Reader<Value> v1Reader=new Reader<Value>(){
      boolean firstValue=true;
      @Override public List<AbstractInputChannel<Value>> getInputChannels(){
        throw new UnsupportedOperationException();
      }
      @Override public boolean hasNext(){
        if (firstValue)         return true;
        return values1.hasNext();
      }
      @Override public Value next() throws IOException, InterruptedException {
        if (firstValue) {
          firstValue=false;
          return firstV1;
        }
        return values1.next();
      }
    }
;
    SpillingResettableIterator<Value> v1ResettableIterator=null;
    try {
      ValueDeserializer<Value> v1Deserializer=new ValueDeserializer<Value>(matchStub.getFirstInValueType());
      v1ResettableIterator=new SpillingResettableIterator<Value>(getEnvironment().getMemoryManager(),getEnvironment().getIOManager(),v1Reader,((int)(MEMORY_IO * MEMORY_SHARE_RATIO)),v1Deserializer,this);
      v1ResettableIterator.open();
      this.v2Copier.setCopy(firstV2);
      while (v1ResettableIterator.hasNext() && !this.taskCanceled) {
        key=this.keySerialization.newInstance();
        this.keyCopier.getCopy(key);
        v2=this.v2Serialization.newInstance();
        this.v2Copier.getCopy(v2);
        v1=v1ResettableIterator.next();
        matchStub.match(key,v1,v2,output);
      }
      v1ResettableIterator.reset();
      while (values2.hasNext() && !this.taskCanceled) {
        v2=values2.next();
        this.v2Copier.setCopy(v2);
        while (v1ResettableIterator.hasNext() && !this.taskCanceled) {
          key=this.keySerialization.newInstance();
          this.keyCopier.getCopy(key);
          v2=this.v2Serialization.newInstance();
          this.v2Copier.getCopy(v2);
          v1=v1ResettableIterator.next();
          matchStub.match(key,v1,v2,output);
        }
        v1ResettableIterator.reset();
      }
      v1ResettableIterator.close();
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
 finally {
      if (v1ResettableIterator != null) {
        try {
          v1ResettableIterator.close();
        }
 catch (        ServiceException e) {
          LOG.warn(e);
        }
      }
    }
  }
}","/** 
 * <p> Calls the <code>MatchStub#match()</code> method for all two key-value pairs that share the same key and come from different inputs. The output of the <code>match()</code> method is forwarded. <p> This method is called with a key and two iterator (one for each input) over all values that share this key. <p>
 * @param key A key.
 * @param values1 An iterator on values of the first input that were paired with the key.
 * @param values2 An iterator on values of the second input that were paired with the key.
 * @param out A collector that collects all output pairs.
 */
private void crossValues(Key key,final Iterator<Value> values1,final Iterator<Value> values2) throws RuntimeException {
  final Value firstV1=values1.next();
  final Value firstV2=values2.next();
  if (firstV1 == null || firstV2 == null) {
    return;
  }
  boolean v1HasNext=values1.hasNext();
  boolean v2HasNext=values2.hasNext();
  if (!v1HasNext && !v2HasNext) {
    matchStub.match(key,firstV1,firstV2,output);
    return;
  }
  Value v1;
  Value v2;
  keyCopier.setCopy(key);
  if (!v1HasNext) {
    this.v1Copier.setCopy(firstV1);
    matchStub.match(key,firstV1,firstV2,output);
    while (v2HasNext && !this.taskCanceled) {
      key=this.keySerialization.newInstance();
      this.keyCopier.getCopy(key);
      v1=this.v1Serialization.newInstance();
      this.v1Copier.getCopy(v1);
      v2=values2.next();
      v2HasNext=values2.hasNext();
      matchStub.match(key,v1,v2,output);
    }
  }
 else   if (!v2HasNext && !this.taskCanceled) {
    this.v2Copier.setCopy(firstV2);
    matchStub.match(key,firstV1,firstV2,output);
    while (v1HasNext) {
      key=this.keySerialization.newInstance();
      this.keyCopier.getCopy(key);
      v2=this.v2Serialization.newInstance();
      this.v2Copier.getCopy(v2);
      v1=values1.next();
      v1HasNext=values1.hasNext();
      matchStub.match(key,v1,v2,output);
    }
  }
 else {
    Reader<Value> v1Reader=new Reader<Value>(){
      boolean firstValue=true;
      @Override public List<AbstractInputChannel<Value>> getInputChannels(){
        throw new UnsupportedOperationException();
      }
      @Override public boolean hasNext(){
        if (firstValue)         return true;
        return values1.hasNext();
      }
      @Override public Value next() throws IOException, InterruptedException {
        if (firstValue) {
          firstValue=false;
          return firstV1;
        }
        return values1.next();
      }
    }
;
    SpillingResettableIterator<Value> v1ResettableIterator=null;
    try {
      ValueDeserializer<Value> v1Deserializer=new ValueDeserializer<Value>(matchStub.getFirstInValueType());
      v1ResettableIterator=new SpillingResettableIterator<Value>(getEnvironment().getMemoryManager(),getEnvironment().getIOManager(),v1Reader,((int)(MEMORY_IO * MEMORY_SHARE_RATIO)),v1Deserializer,this);
      v1ResettableIterator.open();
      this.v2Copier.setCopy(firstV2);
      while (v1ResettableIterator.hasNext() && !this.taskCanceled) {
        key=this.keySerialization.newInstance();
        this.keyCopier.getCopy(key);
        v2=this.v2Serialization.newInstance();
        this.v2Copier.getCopy(v2);
        v1=v1ResettableIterator.next();
        matchStub.match(key,v1,v2,output);
      }
      v1ResettableIterator.reset();
      while (values2.hasNext() && !this.taskCanceled) {
        v2=values2.next();
        this.v2Copier.setCopy(v2);
        while (v1ResettableIterator.hasNext() && !this.taskCanceled) {
          key=this.keySerialization.newInstance();
          this.keyCopier.getCopy(key);
          v2=this.v2Serialization.newInstance();
          this.v2Copier.getCopy(v2);
          v1=v1ResettableIterator.next();
          matchStub.match(key,v1,v2,output);
        }
        v1ResettableIterator.reset();
      }
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
 finally {
      if (v1ResettableIterator != null) {
        try {
          v1ResettableIterator.close();
        }
 catch (        ServiceException e) {
          LOG.warn(e);
        }
      }
    }
  }
}"
88304,"@Test public void testJob() throws Exception {
  preSubmit();
  JobGraph jobGraph=getJobGraph();
  cluster.submitJobAndWait(jobGraph,getJarFilePath());
  postSubmit();
}","@Test public void testJob() throws Exception {
  preSubmit();
  JobGraph jobGraph=null;
  try {
    jobGraph=getJobGraph();
  }
 catch (  Exception e) {
    LOG.error(e);
    Assert.fail(""String_Node_Str"");
  }
  try {
    cluster.submitJobAndWait(jobGraph,getJarFilePath());
  }
 catch (  Exception e) {
    LOG.error(e);
    Assert.fail(""String_Node_Str"");
  }
  postSubmit();
}"
88305,"@Override public boolean equals(Object o){
  return (o.getClass() == PactNull.class);
}","@Override public boolean equals(Object o){
  return (o != null && o.getClass() == PactNull.class);
}"
88306,"/** 
 * Translates the given pact plan in to an OptimizedPlan, where all nodes have their local strategy assigned and all channels have a shipping strategy assigned. The process goes through several phases: <ol> <li>Create <tt>OptimizerNode</tt> representations of the PACTs, assign parallelism and compute size estimates.</li> <li>Compute interesting properties and auxiliary structures.</li> <li>Enumerate plan alternatives. This cannot be done in the same step as the interesting property computation (as opposed to the Database approaches), because we support plans that are not trees.</li> </ol>
 * @param pactPlan The PACT plan to be translated.
 * @return The optimized plan.
 * @throws CompilerException Thrown, if the plan is invalid or the optimizer encountered an inconsistent situation during the compilation process.
 */
public OptimizedPlan compile(Plan pactPlan) throws CompilerException {
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + pactPlan.getJobName() + '\'');
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"");
  }
  Map<InstanceType,InstanceTypeDescription> instances=null;
  JobManagerConnector jmc=new JobManagerConnector(this.jobManagerAddress);
  Thread connectorThread=new Thread(jmc,""String_Node_Str"");
  connectorThread.setDaemon(true);
  connectorThread.start();
  try {
    jmc.waitForCompletion();
    instances=jmc.instances;
    if (instances == null) {
      throw new NullPointerException(""String_Node_Str"");
    }
  }
 catch (  Throwable t) {
    throw new CompilerException(""String_Node_Str"" + t.getMessage(),t);
  }
  int maxMachinesJob=pactPlan.getMaxNumberMachines();
  if (maxMachinesJob < 1) {
    maxMachinesJob=this.maxMachines;
  }
 else   if (this.maxMachines >= 1) {
    if (maxMachinesJob > this.maxMachines && LOG.isWarnEnabled()) {
      LOG.warn(""String_Node_Str"" + maxMachinesJob + ""String_Node_Str""+ this.maxMachines+ ""String_Node_Str"");
    }
    maxMachinesJob=Math.min(maxMachinesJob,this.maxMachines);
  }
  InstanceTypeDescription type=getType(instances);
  String instanceName=type.getInstanceType().getIdentifier();
  long memoryPerInstance=type.getHardwareDescription().getSizeOfFreeMemory();
  int memoryMegabytes=(int)(memoryPerInstance >>> 20);
  int numInstances=type.getMaximumNumberOfAvailableInstances();
  if (maxMachinesJob < 1) {
    maxMachinesJob=numInstances;
  }
 else   if (maxMachinesJob > numInstances) {
    maxMachinesJob=numInstances;
    if (LOG.isInfoEnabled()) {
      LOG.info(""String_Node_Str"" + maxMachinesJob + ""String_Node_Str"");
    }
  }
  int defaultParallelism=this.defaultDegreeOfParallelism;
  if (defaultParallelism < 1) {
    defaultParallelism=maxMachinesJob * defaultIntraNodeParallelism;
  }
 else   if (defaultParallelism > maxMachinesJob * defaultIntraNodeParallelism) {
    int oldParallelism=defaultParallelism;
    defaultParallelism=maxMachinesJob * defaultIntraNodeParallelism;
    if (LOG.isInfoEnabled()) {
      LOG.info(""String_Node_Str"" + oldParallelism + ""String_Node_Str""+ defaultParallelism+ ""String_Node_Str""+ maxMachinesJob+ ""String_Node_Str""+ defaultIntraNodeParallelism);
    }
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + defaultParallelism + ""String_Node_Str""+ this.defaultIntraNodeParallelism+ '.');
    if (maxMachines > 0) {
      LOG.debug(""String_Node_Str"" + maxMachines + ""String_Node_Str"");
    }
  }
  GraphCreatingVisitor graphCreator=new GraphCreatingVisitor(this.statistics,maxMachinesJob,defaultParallelism,this.defaultIntraNodeParallelism,true);
  pactPlan.accept(graphCreator);
  OptimizerNode rootNode=null;
  if (graphCreator.sinks.size() == 1) {
    rootNode=graphCreator.sinks.get(0);
  }
 else   if (graphCreator.sinks.size() > 1) {
    Iterator<DataSinkNode> iter=graphCreator.sinks.iterator();
    rootNode=iter.next();
    int id=graphCreator.getId();
    while (iter.hasNext()) {
      rootNode=new SinkJoiner(rootNode,iter.next());
      rootNode.SetId(id++);
    }
  }
 else {
    throw new CompilerException(""String_Node_Str"");
  }
  InterestingPropertyAndBranchesVisitor propsVisitor=new InterestingPropertyAndBranchesVisitor(this.costEstimator);
  rootNode.accept(propsVisitor);
  List<? extends OptimizerNode> bestPlan=rootNode.getAlternativePlans(this.costEstimator);
  if (bestPlan.size() != 1) {
    throw new CompilerException(""String_Node_Str"");
  }
  OptimizerNode bestPlanRoot=bestPlan.get(0);
  List<DataSinkNode> bestPlanSinks=new ArrayList<DataSinkNode>(4);
  if (bestPlanRoot instanceof DataSinkNode) {
    bestPlanSinks.add((DataSinkNode)bestPlanRoot);
  }
 else   if (bestPlanRoot instanceof SinkJoiner) {
    ((SinkJoiner)bestPlanRoot).getDataSinks(bestPlanSinks);
  }
  OptimizedPlan plan=new PlanFinalizer().createFinalPlan(bestPlanSinks,pactPlan.getJobName(),memoryMegabytes);
  plan.setInstanceTypeName(instanceName);
  insertTempConnection(plan);
  return plan;
}","/** 
 * Translates the given pact plan in to an OptimizedPlan, where all nodes have their local strategy assigned and all channels have a shipping strategy assigned. The process goes through several phases: <ol> <li>Create <tt>OptimizerNode</tt> representations of the PACTs, assign parallelism and compute size estimates.</li> <li>Compute interesting properties and auxiliary structures.</li> <li>Enumerate plan alternatives. This cannot be done in the same step as the interesting property computation (as opposed to the Database approaches), because we support plans that are not trees.</li> </ol>
 * @param pactPlan The PACT plan to be translated.
 * @param type The instance type to schedule the execution on. Used also to determine the amount of memoryavailable to the tasks.
 * @return The optimized plan.
 * @throws CompilerException Thrown, if the plan is invalid or the optimizer encountered an inconsistent situation during the compilation process.
 */
public OptimizedPlan compile(Plan pactPlan,InstanceTypeDescription type) throws CompilerException {
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + pactPlan.getJobName() + '\'');
  }
  String instanceName=type.getInstanceType().getIdentifier();
  long memoryPerInstance=type.getHardwareDescription().getSizeOfFreeMemory();
  int memoryMegabytes=(int)(memoryPerInstance >>> 20);
  int numInstances=type.getMaximumNumberOfAvailableInstances();
  int maxMachinesJob=pactPlan.getMaxNumberMachines();
  if (maxMachinesJob < 1) {
    maxMachinesJob=this.maxMachines;
  }
 else   if (this.maxMachines >= 1) {
    if (maxMachinesJob > this.maxMachines && LOG.isWarnEnabled()) {
      LOG.warn(""String_Node_Str"" + maxMachinesJob + ""String_Node_Str""+ this.maxMachines+ ""String_Node_Str"");
    }
    maxMachinesJob=Math.min(maxMachinesJob,this.maxMachines);
  }
  if (maxMachinesJob < 1) {
    maxMachinesJob=numInstances;
  }
 else   if (maxMachinesJob > numInstances) {
    maxMachinesJob=numInstances;
    if (LOG.isInfoEnabled()) {
      LOG.info(""String_Node_Str"" + maxMachinesJob + ""String_Node_Str"");
    }
  }
  int defaultParallelism=this.defaultDegreeOfParallelism;
  if (defaultParallelism < 1) {
    defaultParallelism=maxMachinesJob * defaultIntraNodeParallelism;
  }
 else   if (defaultParallelism > maxMachinesJob * defaultIntraNodeParallelism) {
    int oldParallelism=defaultParallelism;
    defaultParallelism=maxMachinesJob * defaultIntraNodeParallelism;
    if (LOG.isInfoEnabled()) {
      LOG.info(""String_Node_Str"" + oldParallelism + ""String_Node_Str""+ defaultParallelism+ ""String_Node_Str""+ maxMachinesJob+ ""String_Node_Str""+ defaultIntraNodeParallelism);
    }
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + defaultParallelism + ""String_Node_Str""+ this.defaultIntraNodeParallelism+ '.');
    if (maxMachines > 0) {
      LOG.debug(""String_Node_Str"" + maxMachines + ""String_Node_Str"");
    }
  }
  GraphCreatingVisitor graphCreator=new GraphCreatingVisitor(this.statistics,maxMachinesJob,defaultParallelism,this.defaultIntraNodeParallelism,true);
  pactPlan.accept(graphCreator);
  OptimizerNode rootNode=null;
  if (graphCreator.sinks.size() == 1) {
    rootNode=graphCreator.sinks.get(0);
  }
 else   if (graphCreator.sinks.size() > 1) {
    Iterator<DataSinkNode> iter=graphCreator.sinks.iterator();
    rootNode=iter.next();
    int id=graphCreator.getId();
    while (iter.hasNext()) {
      rootNode=new SinkJoiner(rootNode,iter.next());
      rootNode.SetId(id++);
    }
  }
 else {
    throw new CompilerException(""String_Node_Str"");
  }
  InterestingPropertyAndBranchesVisitor propsVisitor=new InterestingPropertyAndBranchesVisitor(this.costEstimator);
  rootNode.accept(propsVisitor);
  List<? extends OptimizerNode> bestPlan=rootNode.getAlternativePlans(this.costEstimator);
  if (bestPlan.size() != 1) {
    throw new CompilerException(""String_Node_Str"");
  }
  OptimizerNode bestPlanRoot=bestPlan.get(0);
  List<DataSinkNode> bestPlanSinks=new ArrayList<DataSinkNode>(4);
  if (bestPlanRoot instanceof DataSinkNode) {
    bestPlanSinks.add((DataSinkNode)bestPlanRoot);
  }
 else   if (bestPlanRoot instanceof SinkJoiner) {
    ((SinkJoiner)bestPlanRoot).getDataSinks(bestPlanSinks);
  }
  OptimizedPlan plan=new PlanFinalizer().createFinalPlan(bestPlanSinks,pactPlan.getJobName(),memoryMegabytes);
  plan.setInstanceTypeName(instanceName);
  insertTempConnection(plan);
  return plan;
}"
88307,"/** 
 * This method computes the costs for an operator. It requires that all inputs are set and have a proper <tt>ShipStrategy</tt> set, which is not equal to <tt>NONE</tt>.
 * @param n The node to compute the costs for.
 */
public void costOperator(OptimizerNode n){
  if (n.getIncomingConnections() == null) {
    throw new CompilerException(""String_Node_Str"");
  }
  ShipStrategy primStrat=null;
  ShipStrategy secStrat=null;
  OptimizerNode primIn=null;
  OptimizerNode secIn=null;
{
    List<PactConnection> conns=n.getIncomingConnections();
    if (conns.size() > 0) {
      primStrat=conns.get(0).getShipStrategy();
      primIn=conns.get(0).getSourcePact();
    }
    if (conns.size() > 1) {
      secStrat=conns.get(1).getShipStrategy();
      secIn=conns.get(1).getSourcePact();
    }
  }
  Costs globCost=new Costs();
  Costs locCost=new Costs();
  if (primStrat != null) {
switch (primStrat) {
case NONE:
      throw new CompilerException(""String_Node_Str"");
case FORWARD:
    globCost.setNetworkCost(0);
  globCost.setSecondaryStorageCost(0);
break;
case PARTITION_HASH:
getHashPartitioningCost(n,primIn,globCost);
break;
case PARTITION_RANGE:
getRangePartitionCost(n,primIn,globCost);
break;
case BROADCAST:
getBroadcastCost(n,primIn,globCost);
break;
case SFR:
throw new CompilerException(""String_Node_Str"");
default :
throw new CompilerException(""String_Node_Str"" + primStrat.name());
}
}
 else {
globCost.setNetworkCost(0);
globCost.setSecondaryStorageCost(0);
}
if (secStrat != null) {
Costs secCost=new Costs();
switch (secStrat) {
case NONE:
throw new CompilerException(""String_Node_Str"");
case FORWARD:
secCost.setNetworkCost(0);
secCost.setSecondaryStorageCost(0);
break;
case PARTITION_HASH:
getHashPartitioningCost(n,secIn,secCost);
break;
case PARTITION_RANGE:
getRangePartitionCost(n,secIn,secCost);
break;
case BROADCAST:
getBroadcastCost(n,secIn,secCost);
break;
case SFR:
throw new CompilerException(""String_Node_Str"");
default :
throw new CompilerException(""String_Node_Str"" + secStrat.name());
}
globCost.addCosts(secCost);
}
locCost.setNetworkCost(0);
switch (n.getLocalStrategy()) {
case NONE:
locCost.setNetworkCost(0);
locCost.setSecondaryStorageCost(0);
break;
case COMBININGSORT:
case SORT:
getLocalSortCost(n,primIn,locCost);
break;
case SORTMERGE:
getLocalSortMergeCost(n,primIn,secIn,locCost);
break;
case HYBRIDHASH_FIRST:
getHybridHashCosts(n,primIn,secIn,locCost);
break;
case HYBRIDHASH_SECOND:
getHybridHashCosts(n,secIn,primIn,locCost);
break;
case MMHASH_FIRST:
getMainMemHashCosts(n,primIn,secIn,locCost);
break;
case MMHASH_SECOND:
getMainMemHashCosts(n,secIn,primIn,locCost);
break;
case NESTEDLOOP_BLOCKED_OUTER_FIRST:
getBlockNestedLoopsCosts(n,primIn,secIn,locCost,2);
break;
case NESTEDLOOP_BLOCKED_OUTER_SECOND:
getBlockNestedLoopsCosts(n,secIn,primIn,locCost,2);
break;
case NESTEDLOOP_STREAMED_OUTER_FIRST:
getStreamedNestedLoopsCosts(n,primIn,secIn,locCost);
break;
case NESTEDLOOP_STREAMED_OUTER_SECOND:
getStreamedNestedLoopsCosts(n,secIn,primIn,locCost);
break;
default :
throw new CompilerException(""String_Node_Str"" + n.getLocalStrategy().name());
}
globCost.addCosts(locCost);
n.setCosts(globCost);
}","/** 
 * This method computes the costs for an operator. It requires that all inputs are set and have a proper <tt>ShipStrategy</tt> set, which is not equal to <tt>NONE</tt>.
 * @param n The node to compute the costs for.
 */
public void costOperator(OptimizerNode n){
  if (n.getIncomingConnections() == null) {
    throw new CompilerException(""String_Node_Str"");
  }
  ShipStrategy primStrat=null;
  ShipStrategy secStrat=null;
  OptimizerNode primIn=null;
  OptimizerNode secIn=null;
{
    List<PactConnection> conns=n.getIncomingConnections();
    if (conns.size() > 0) {
      primStrat=conns.get(0).getShipStrategy();
      primIn=conns.get(0).getSourcePact();
    }
    if (conns.size() > 1) {
      secStrat=conns.get(1).getShipStrategy();
      secIn=conns.get(1).getSourcePact();
    }
  }
  Costs globCost=new Costs();
  Costs locCost=new Costs();
  if (primStrat != null) {
switch (primStrat) {
case NONE:
      throw new CompilerException(""String_Node_Str"");
case FORWARD:
case PARTITION_LOCAL_HASH:
    globCost.setNetworkCost(0);
  globCost.setSecondaryStorageCost(0);
break;
case PARTITION_HASH:
getHashPartitioningCost(n,primIn,globCost);
break;
case PARTITION_RANGE:
getRangePartitionCost(n,primIn,globCost);
break;
case BROADCAST:
getBroadcastCost(n,primIn,globCost);
break;
case SFR:
throw new CompilerException(""String_Node_Str"");
default :
throw new CompilerException(""String_Node_Str"" + primStrat.name());
}
}
 else {
globCost.setNetworkCost(0);
globCost.setSecondaryStorageCost(0);
}
if (secStrat != null) {
Costs secCost=new Costs();
switch (secStrat) {
case NONE:
throw new CompilerException(""String_Node_Str"");
case FORWARD:
case PARTITION_LOCAL_HASH:
secCost.setNetworkCost(0);
secCost.setSecondaryStorageCost(0);
break;
case PARTITION_HASH:
getHashPartitioningCost(n,secIn,secCost);
break;
case PARTITION_RANGE:
getRangePartitionCost(n,secIn,secCost);
break;
case BROADCAST:
getBroadcastCost(n,secIn,secCost);
break;
case SFR:
throw new CompilerException(""String_Node_Str"");
default :
throw new CompilerException(""String_Node_Str"" + secStrat.name());
}
globCost.addCosts(secCost);
}
locCost.setNetworkCost(0);
switch (n.getLocalStrategy()) {
case NONE:
locCost.setNetworkCost(0);
locCost.setSecondaryStorageCost(0);
break;
case COMBININGSORT:
case SORT:
getLocalSortCost(n,primIn,locCost);
break;
case SORTMERGE:
getLocalSortMergeCost(n,primIn,secIn,locCost);
break;
case HYBRIDHASH_FIRST:
getHybridHashCosts(n,primIn,secIn,locCost);
break;
case HYBRIDHASH_SECOND:
getHybridHashCosts(n,secIn,primIn,locCost);
break;
case MMHASH_FIRST:
getMainMemHashCosts(n,primIn,secIn,locCost);
break;
case MMHASH_SECOND:
getMainMemHashCosts(n,secIn,primIn,locCost);
break;
case NESTEDLOOP_BLOCKED_OUTER_FIRST:
getBlockNestedLoopsCosts(n,primIn,secIn,locCost,2);
break;
case NESTEDLOOP_BLOCKED_OUTER_SECOND:
getBlockNestedLoopsCosts(n,secIn,primIn,locCost,2);
break;
case NESTEDLOOP_STREAMED_OUTER_FIRST:
getStreamedNestedLoopsCosts(n,primIn,secIn,locCost);
break;
case NESTEDLOOP_STREAMED_OUTER_SECOND:
getStreamedNestedLoopsCosts(n,secIn,primIn,locCost);
break;
default :
throw new CompilerException(""String_Node_Str"" + n.getLocalStrategy().name());
}
globCost.addCosts(locCost);
n.setCosts(globCost);
}"
88308,"@Override public void postVisit(OptimizerNode visitable){
  jsonString.append(""String_Node_Str"");
  jsonString.append(""String_Node_Str"" + nodeIds.get(visitable));
  String type;
switch (visitable.getPactType()) {
case DataSink:
    type=""String_Node_Str"";
  break;
case DataSource:
type=""String_Node_Str"";
break;
default :
type=""String_Node_Str"";
break;
}
jsonString.append(""String_Node_Str"" + type + ""String_Node_Str"");
if (type.equals(""String_Node_Str"")) {
jsonString.append(""String_Node_Str"" + visitable.getName() + ""String_Node_Str"");
}
String contents;
switch (visitable.getPactType()) {
case DataSink:
contents=((DataSinkContract<?,?>)visitable.getPactContract()).getFilePath();
break;
case DataSource:
contents=((DataSourceContract<?,?>)visitable.getPactContract()).getFilePath();
break;
default :
contents=visitable.getPactContract().getName();
break;
}
jsonString.append(""String_Node_Str"" + contents + ""String_Node_Str"");
OutputContract outContr=visitable.getOutputContract();
if (outContr != null && outContr != OutputContract.None) {
jsonString.append(""String_Node_Str"" + outContr.name() + ""String_Node_Str"");
}
jsonString.append(""String_Node_Str"" + (visitable.getDegreeOfParallelism() >= 1 ? visitable.getDegreeOfParallelism() : ""String_Node_Str"") + ""String_Node_Str"");
List<PactConnection> connList=visitable.getIncomingConnections();
String child1name=null, child2name=null;
if (connList != null && connList.size() > 0) {
jsonString.append(""String_Node_Str"");
int connCnt=0;
for (PactConnection conn : connList) {
jsonString.append(connCnt == 0 ? ""String_Node_Str"" : ""String_Node_Str"");
if (connCnt == 0) {
child1name=conn.getSourcePact().getPactContract().getName();
}
 else if (connCnt == 1) {
child2name=conn.getSourcePact().getPactContract().getName();
}
jsonString.append(""String_Node_Str"" + nodeIds.get(conn.getSourcePact()));
if (connList.size() == 2) {
jsonString.append(""String_Node_Str"" + (connCnt == 0 ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
}
String shipStrategy=null;
String channelType=null;
switch (conn.getShipStrategy()) {
case NONE:
break;
case FORWARD:
shipStrategy=""String_Node_Str"";
channelType=""String_Node_Str"";
break;
case BROADCAST:
shipStrategy=""String_Node_Str"";
channelType=""String_Node_Str"";
break;
case PARTITION_HASH:
shipStrategy=""String_Node_Str"";
channelType=""String_Node_Str"";
break;
case PARTITION_RANGE:
shipStrategy=""String_Node_Str"";
channelType=""String_Node_Str"";
break;
case SFR:
shipStrategy=""String_Node_Str"";
channelType=""String_Node_Str"";
break;
default :
throw new CompilerException(""String_Node_Str"" + conn.getShipStrategy().name() + ""String_Node_Str"");
}
if (shipStrategy != null) {
jsonString.append(""String_Node_Str"" + shipStrategy + ""String_Node_Str"");
}
if (channelType != null) {
jsonString.append(""String_Node_Str"" + channelType + ""String_Node_Str"");
}
if (conn.getTempMode() != TempMode.NONE) {
String tempMode=conn.getTempMode().toString();
jsonString.append(""String_Node_Str"" + tempMode + ""String_Node_Str"");
}
jsonString.append('}');
connCnt++;
}
jsonString.append(""String_Node_Str"");
}
String locString=null;
if (visitable.getLocalStrategy() != null) {
switch (visitable.getLocalStrategy()) {
case NONE:
break;
case HYBRIDHASH_FIRST:
locString=""String_Node_Str"" + child1name + ""String_Node_Str"";
break;
case HYBRIDHASH_SECOND:
locString=""String_Node_Str"" + child2name + ""String_Node_Str"";
break;
case MMHASH_FIRST:
locString=""String_Node_Str"" + child1name + ""String_Node_Str"";
break;
case MMHASH_SECOND:
locString=""String_Node_Str"" + child2name + ""String_Node_Str"";
break;
case NESTEDLOOP_BLOCKED_OUTER_FIRST:
locString=""String_Node_Str"" + child1name + ""String_Node_Str"";
break;
case NESTEDLOOP_BLOCKED_OUTER_SECOND:
locString=""String_Node_Str"" + child2name + ""String_Node_Str"";
break;
case NESTEDLOOP_STREAMED_OUTER_FIRST:
locString=""String_Node_Str"" + child1name + ""String_Node_Str"";
break;
case NESTEDLOOP_STREAMED_OUTER_SECOND:
locString=""String_Node_Str"" + child2name + ""String_Node_Str"";
break;
case SORTMERGE:
locString=""String_Node_Str"";
break;
case SORT:
locString=""String_Node_Str"";
break;
case COMBININGSORT:
locString=""String_Node_Str"";
break;
default :
throw new CompilerException(""String_Node_Str"" + visitable.getLocalStrategy().name() + ""String_Node_Str"");
}
if (locString != null) {
jsonString.append(""String_Node_Str"");
jsonString.append(locString);
jsonString.append(""String_Node_Str"");
}
}
{
GlobalProperties gp=visitable.getGlobalProperties();
jsonString.append(""String_Node_Str"");
addProperty(jsonString,""String_Node_Str"",gp.getPartitioning().name(),true);
addProperty(jsonString,""String_Node_Str"",gp.getKeyOrder().name(),false);
addProperty(jsonString,""String_Node_Str"",gp.isKeyUnique() ? ""String_Node_Str"" : ""String_Node_Str"",false);
jsonString.append(""String_Node_Str"");
}
{
LocalProperties lp=visitable.getLocalProperties();
jsonString.append(""String_Node_Str"");
addProperty(jsonString,""String_Node_Str"",lp.getKeyOrder().name(),true);
addProperty(jsonString,""String_Node_Str"",lp.isKeyUnique() ? ""String_Node_Str"" : ""String_Node_Str"",false);
addProperty(jsonString,""String_Node_Str"",lp.areKeysGrouped() ? ""String_Node_Str"" : ""String_Node_Str"",false);
jsonString.append(""String_Node_Str"");
}
jsonString.append(""String_Node_Str"");
addProperty(jsonString,""String_Node_Str"",visitable.getEstimatedNumRecords() == -1 ? ""String_Node_Str"" : formatNumber(visitable.getEstimatedNumRecords()),true);
addProperty(jsonString,""String_Node_Str"",visitable.getEstimatedKeyCardinality() == -1 ? ""String_Node_Str"" : formatNumber(visitable.getEstimatedKeyCardinality()),false);
addProperty(jsonString,""String_Node_Str"",visitable.getEstimatedOutputSize() == -1 ? ""String_Node_Str"" : formatNumber(visitable.getEstimatedOutputSize(),""String_Node_Str""),false);
jsonString.append(""String_Node_Str"");
if (visitable.getNodeCosts() != null) {
jsonString.append(""String_Node_Str"");
addProperty(jsonString,""String_Node_Str"",visitable.getNodeCosts().getNetworkCost() == -1 ? ""String_Node_Str"" : formatNumber(visitable.getNodeCosts().getNetworkCost(),""String_Node_Str""),true);
addProperty(jsonString,""String_Node_Str"",visitable.getNodeCosts().getSecondaryStorageCost() == -1 ? ""String_Node_Str"" : formatNumber(visitable.getNodeCosts().getSecondaryStorageCost(),""String_Node_Str""),false);
addProperty(jsonString,""String_Node_Str"",visitable.getCumulativeCosts().getNetworkCost() == -1 ? ""String_Node_Str"" : formatNumber(visitable.getCumulativeCosts().getNetworkCost(),""String_Node_Str""),false);
addProperty(jsonString,""String_Node_Str"",visitable.getCumulativeCosts().getSecondaryStorageCost() == -1 ? ""String_Node_Str"" : formatNumber(visitable.getCumulativeCosts().getSecondaryStorageCost(),""String_Node_Str""),false);
jsonString.append(""String_Node_Str"");
}
if (visitable.getPactContract().getCompilerHints() != null) {
CompilerHints hints=visitable.getPactContract().getCompilerHints();
CompilerHints defaults=new CompilerHints();
jsonString.append(""String_Node_Str"");
addProperty(jsonString,""String_Node_Str"",hints.getKeyCardinality() == defaults.getKeyCardinality() ? ""String_Node_Str"" : formatNumber(hints.getKeyCardinality()),true);
addProperty(jsonString,""String_Node_Str"",hints.getSelectivity() == defaults.getSelectivity() ? ""String_Node_Str"" : String.valueOf(hints.getSelectivity()),false);
addProperty(jsonString,""String_Node_Str"",hints.getAvgNumValuesPerKey() == defaults.getAvgNumValuesPerKey() ? ""String_Node_Str"" : String.valueOf(hints.getAvgNumValuesPerKey()),false);
addProperty(jsonString,""String_Node_Str"",hints.getAvgBytesPerRecord() == defaults.getAvgBytesPerRecord() ? ""String_Node_Str"" : String.valueOf(hints.getAvgBytesPerRecord()),false);
jsonString.append(""String_Node_Str"");
}
jsonString.append(""String_Node_Str"");
}","@Override public void postVisit(OptimizerNode visitable){
  jsonString.append(""String_Node_Str"");
  jsonString.append(""String_Node_Str"" + nodeIds.get(visitable));
  String type;
switch (visitable.getPactType()) {
case DataSink:
    type=""String_Node_Str"";
  break;
case DataSource:
type=""String_Node_Str"";
break;
default :
type=""String_Node_Str"";
break;
}
jsonString.append(""String_Node_Str"" + type + ""String_Node_Str"");
if (type.equals(""String_Node_Str"")) {
jsonString.append(""String_Node_Str"" + visitable.getName() + ""String_Node_Str"");
}
String contents;
switch (visitable.getPactType()) {
case DataSink:
contents=((DataSinkContract<?,?>)visitable.getPactContract()).getFilePath();
break;
case DataSource:
contents=((DataSourceContract<?,?>)visitable.getPactContract()).getFilePath();
break;
default :
contents=visitable.getPactContract().getName();
break;
}
jsonString.append(""String_Node_Str"" + contents + ""String_Node_Str"");
OutputContract outContr=visitable.getOutputContract();
if (outContr != null && outContr != OutputContract.None) {
jsonString.append(""String_Node_Str"" + outContr.name() + ""String_Node_Str"");
}
jsonString.append(""String_Node_Str"" + (visitable.getDegreeOfParallelism() >= 1 ? visitable.getDegreeOfParallelism() : ""String_Node_Str"") + ""String_Node_Str"");
List<PactConnection> connList=visitable.getIncomingConnections();
String child1name=null, child2name=null;
if (connList != null && connList.size() > 0) {
jsonString.append(""String_Node_Str"");
int connCnt=0;
for (PactConnection conn : connList) {
jsonString.append(connCnt == 0 ? ""String_Node_Str"" : ""String_Node_Str"");
if (connCnt == 0) {
child1name=conn.getSourcePact().getPactContract().getName();
}
 else if (connCnt == 1) {
child2name=conn.getSourcePact().getPactContract().getName();
}
jsonString.append(""String_Node_Str"" + nodeIds.get(conn.getSourcePact()));
if (connList.size() == 2) {
jsonString.append(""String_Node_Str"" + (connCnt == 0 ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
}
String shipStrategy=null;
String channelType=null;
switch (conn.getShipStrategy()) {
case NONE:
break;
case FORWARD:
shipStrategy=""String_Node_Str"";
channelType=""String_Node_Str"";
break;
case BROADCAST:
shipStrategy=""String_Node_Str"";
channelType=""String_Node_Str"";
break;
case PARTITION_HASH:
shipStrategy=""String_Node_Str"";
channelType=""String_Node_Str"";
break;
case PARTITION_RANGE:
shipStrategy=""String_Node_Str"";
channelType=""String_Node_Str"";
break;
case PARTITION_LOCAL_HASH:
shipStrategy=""String_Node_Str"";
channelType=""String_Node_Str"";
case SFR:
shipStrategy=""String_Node_Str"";
channelType=""String_Node_Str"";
break;
default :
throw new CompilerException(""String_Node_Str"" + conn.getShipStrategy().name() + ""String_Node_Str"");
}
if (shipStrategy != null) {
jsonString.append(""String_Node_Str"" + shipStrategy + ""String_Node_Str"");
}
if (channelType != null) {
jsonString.append(""String_Node_Str"" + channelType + ""String_Node_Str"");
}
if (conn.getTempMode() != TempMode.NONE) {
String tempMode=conn.getTempMode().toString();
jsonString.append(""String_Node_Str"" + tempMode + ""String_Node_Str"");
}
jsonString.append('}');
connCnt++;
}
jsonString.append(""String_Node_Str"");
}
String locString=null;
if (visitable.getLocalStrategy() != null) {
switch (visitable.getLocalStrategy()) {
case NONE:
break;
case HYBRIDHASH_FIRST:
locString=""String_Node_Str"" + child1name + ""String_Node_Str"";
break;
case HYBRIDHASH_SECOND:
locString=""String_Node_Str"" + child2name + ""String_Node_Str"";
break;
case MMHASH_FIRST:
locString=""String_Node_Str"" + child1name + ""String_Node_Str"";
break;
case MMHASH_SECOND:
locString=""String_Node_Str"" + child2name + ""String_Node_Str"";
break;
case NESTEDLOOP_BLOCKED_OUTER_FIRST:
locString=""String_Node_Str"" + child1name + ""String_Node_Str"";
break;
case NESTEDLOOP_BLOCKED_OUTER_SECOND:
locString=""String_Node_Str"" + child2name + ""String_Node_Str"";
break;
case NESTEDLOOP_STREAMED_OUTER_FIRST:
locString=""String_Node_Str"" + child1name + ""String_Node_Str"";
break;
case NESTEDLOOP_STREAMED_OUTER_SECOND:
locString=""String_Node_Str"" + child2name + ""String_Node_Str"";
break;
case SORTMERGE:
locString=""String_Node_Str"";
break;
case SORT:
locString=""String_Node_Str"";
break;
case COMBININGSORT:
locString=""String_Node_Str"";
break;
default :
throw new CompilerException(""String_Node_Str"" + visitable.getLocalStrategy().name() + ""String_Node_Str"");
}
if (locString != null) {
jsonString.append(""String_Node_Str"");
jsonString.append(locString);
jsonString.append(""String_Node_Str"");
}
}
{
GlobalProperties gp=visitable.getGlobalProperties();
jsonString.append(""String_Node_Str"");
addProperty(jsonString,""String_Node_Str"",gp.getPartitioning().name(),true);
addProperty(jsonString,""String_Node_Str"",gp.getKeyOrder().name(),false);
addProperty(jsonString,""String_Node_Str"",gp.isKeyUnique() ? ""String_Node_Str"" : ""String_Node_Str"",false);
jsonString.append(""String_Node_Str"");
}
{
LocalProperties lp=visitable.getLocalProperties();
jsonString.append(""String_Node_Str"");
addProperty(jsonString,""String_Node_Str"",lp.getKeyOrder().name(),true);
addProperty(jsonString,""String_Node_Str"",lp.isKeyUnique() ? ""String_Node_Str"" : ""String_Node_Str"",false);
addProperty(jsonString,""String_Node_Str"",lp.areKeysGrouped() ? ""String_Node_Str"" : ""String_Node_Str"",false);
jsonString.append(""String_Node_Str"");
}
jsonString.append(""String_Node_Str"");
addProperty(jsonString,""String_Node_Str"",visitable.getEstimatedNumRecords() == -1 ? ""String_Node_Str"" : formatNumber(visitable.getEstimatedNumRecords()),true);
addProperty(jsonString,""String_Node_Str"",visitable.getEstimatedKeyCardinality() == -1 ? ""String_Node_Str"" : formatNumber(visitable.getEstimatedKeyCardinality()),false);
addProperty(jsonString,""String_Node_Str"",visitable.getEstimatedOutputSize() == -1 ? ""String_Node_Str"" : formatNumber(visitable.getEstimatedOutputSize(),""String_Node_Str""),false);
jsonString.append(""String_Node_Str"");
if (visitable.getNodeCosts() != null) {
jsonString.append(""String_Node_Str"");
addProperty(jsonString,""String_Node_Str"",visitable.getNodeCosts().getNetworkCost() == -1 ? ""String_Node_Str"" : formatNumber(visitable.getNodeCosts().getNetworkCost(),""String_Node_Str""),true);
addProperty(jsonString,""String_Node_Str"",visitable.getNodeCosts().getSecondaryStorageCost() == -1 ? ""String_Node_Str"" : formatNumber(visitable.getNodeCosts().getSecondaryStorageCost(),""String_Node_Str""),false);
addProperty(jsonString,""String_Node_Str"",visitable.getCumulativeCosts().getNetworkCost() == -1 ? ""String_Node_Str"" : formatNumber(visitable.getCumulativeCosts().getNetworkCost(),""String_Node_Str""),false);
addProperty(jsonString,""String_Node_Str"",visitable.getCumulativeCosts().getSecondaryStorageCost() == -1 ? ""String_Node_Str"" : formatNumber(visitable.getCumulativeCosts().getSecondaryStorageCost(),""String_Node_Str""),false);
jsonString.append(""String_Node_Str"");
}
if (visitable.getPactContract().getCompilerHints() != null) {
CompilerHints hints=visitable.getPactContract().getCompilerHints();
CompilerHints defaults=new CompilerHints();
jsonString.append(""String_Node_Str"");
addProperty(jsonString,""String_Node_Str"",hints.getKeyCardinality() == defaults.getKeyCardinality() ? ""String_Node_Str"" : formatNumber(hints.getKeyCardinality()),true);
addProperty(jsonString,""String_Node_Str"",hints.getSelectivity() == defaults.getSelectivity() ? ""String_Node_Str"" : String.valueOf(hints.getSelectivity()),false);
addProperty(jsonString,""String_Node_Str"",hints.getAvgNumValuesPerKey() == defaults.getAvgNumValuesPerKey() ? ""String_Node_Str"" : String.valueOf(hints.getAvgNumValuesPerKey()),false);
addProperty(jsonString,""String_Node_Str"",hints.getAvgBytesPerRecord() == defaults.getAvgBytesPerRecord() ? ""String_Node_Str"" : String.valueOf(hints.getAvgBytesPerRecord()),false);
jsonString.append(""String_Node_Str"");
}
jsonString.append(""String_Node_Str"");
}"
88309,"/** 
 * @param connection
 * @param outputVertex
 * @param inputVertex
 * @throws JobGraphDefinitionException
 * @throws CompilerException
 */
private void connectJobVertices(PactConnection connection,AbstractJobVertex outputVertex,AbstractJobVertex inputVertex) throws JobGraphDefinitionException, CompilerException {
  ChannelType channelType=null;
switch (connection.getShipStrategy()) {
case FORWARD:
    channelType=ChannelType.INMEMORY;
  break;
case PARTITION_HASH:
channelType=ChannelType.NETWORK;
break;
case BROADCAST:
channelType=ChannelType.NETWORK;
break;
case SFR:
channelType=ChannelType.NETWORK;
break;
}
TaskConfig outputConfig=new TaskConfig(outputVertex.getConfiguration());
TaskConfig inputConfig=new TaskConfig(inputVertex.getConfiguration());
TaskConfig tempConfig=null;
switch (connection.getTempMode()) {
case NONE:
outputVertex.connectTo(inputVertex,channelType,CompressionLevel.NO_COMPRESSION);
outputConfig.addOutputShipStrategy(connection.getShipStrategy());
inputConfig.addInputShipStrategy(connection.getShipStrategy());
break;
case TEMP_SENDER_SIDE:
int pd=connection.getSourcePact().getDegreeOfParallelism();
JobTaskVertex tempVertex=generateTempVertex((Class<? extends Stub<?,?>>)connection.getSourcePact().getPactContract().getStubClass(),pd);
outputVertex.connectTo(tempVertex,ChannelType.INMEMORY,CompressionLevel.NO_COMPRESSION);
tempVertex.connectTo(inputVertex,channelType,CompressionLevel.NO_COMPRESSION);
tempConfig=new TaskConfig(tempVertex.getConfiguration());
outputConfig.addOutputShipStrategy(ShipStrategy.FORWARD);
tempConfig.addInputShipStrategy(ShipStrategy.FORWARD);
tempConfig.addOutputShipStrategy(connection.getShipStrategy());
inputConfig.addInputShipStrategy(connection.getShipStrategy());
break;
case TEMP_RECEIVER_SIDE:
int pdr=connection.getTargetPact().getDegreeOfParallelism();
tempVertex=generateTempVertex((Class<? extends Stub<?,?>>)connection.getSourcePact().getPactContract().getStubClass(),pdr);
outputVertex.connectTo(tempVertex,channelType,CompressionLevel.NO_COMPRESSION);
tempVertex.connectTo(inputVertex,ChannelType.INMEMORY,CompressionLevel.NO_COMPRESSION);
tempConfig=new TaskConfig(tempVertex.getConfiguration());
outputConfig.addOutputShipStrategy(connection.getShipStrategy());
tempConfig.addInputShipStrategy(connection.getShipStrategy());
tempConfig.addOutputShipStrategy(ShipStrategy.FORWARD);
inputConfig.addInputShipStrategy(ShipStrategy.FORWARD);
break;
default :
throw new CompilerException(""String_Node_Str"" + connection.getTempMode());
}
}","/** 
 * @param connection
 * @param outputVertex
 * @param inputVertex
 * @throws JobGraphDefinitionException
 * @throws CompilerException
 */
private void connectJobVertices(PactConnection connection,AbstractJobVertex outputVertex,AbstractJobVertex inputVertex) throws JobGraphDefinitionException, CompilerException {
  ChannelType channelType=null;
switch (connection.getShipStrategy()) {
case FORWARD:
case PARTITION_LOCAL_HASH:
    channelType=ChannelType.INMEMORY;
  break;
case PARTITION_HASH:
case BROADCAST:
case SFR:
channelType=ChannelType.NETWORK;
break;
default :
throw new IllegalArgumentException(""String_Node_Str"" + connection.getShipStrategy().name());
}
TaskConfig outputConfig=new TaskConfig(outputVertex.getConfiguration());
TaskConfig inputConfig=new TaskConfig(inputVertex.getConfiguration());
TaskConfig tempConfig=null;
switch (connection.getTempMode()) {
case NONE:
outputVertex.connectTo(inputVertex,channelType,CompressionLevel.NO_COMPRESSION);
outputConfig.addOutputShipStrategy(connection.getShipStrategy());
inputConfig.addInputShipStrategy(connection.getShipStrategy());
break;
case TEMP_SENDER_SIDE:
int pd=connection.getSourcePact().getDegreeOfParallelism();
JobTaskVertex tempVertex=generateTempVertex((Class<? extends Stub<?,?>>)connection.getSourcePact().getPactContract().getStubClass(),pd);
outputVertex.connectTo(tempVertex,ChannelType.INMEMORY,CompressionLevel.NO_COMPRESSION);
tempVertex.connectTo(inputVertex,channelType,CompressionLevel.NO_COMPRESSION);
tempConfig=new TaskConfig(tempVertex.getConfiguration());
outputConfig.addOutputShipStrategy(ShipStrategy.FORWARD);
tempConfig.addInputShipStrategy(ShipStrategy.FORWARD);
tempConfig.addOutputShipStrategy(connection.getShipStrategy());
inputConfig.addInputShipStrategy(connection.getShipStrategy());
break;
case TEMP_RECEIVER_SIDE:
int pdr=connection.getTargetPact().getDegreeOfParallelism();
tempVertex=generateTempVertex((Class<? extends Stub<?,?>>)connection.getSourcePact().getPactContract().getStubClass(),pdr);
outputVertex.connectTo(tempVertex,channelType,CompressionLevel.NO_COMPRESSION);
tempVertex.connectTo(inputVertex,ChannelType.INMEMORY,CompressionLevel.NO_COMPRESSION);
tempConfig=new TaskConfig(tempVertex.getConfiguration());
outputConfig.addOutputShipStrategy(connection.getShipStrategy());
tempConfig.addInputShipStrategy(connection.getShipStrategy());
tempConfig.addOutputShipStrategy(ShipStrategy.FORWARD);
inputConfig.addInputShipStrategy(ShipStrategy.FORWARD);
break;
default :
throw new CompilerException(""String_Node_Str"" + connection.getTempMode());
}
}"
88310,"@Override public List<CoGroupNode> getAlternativePlans(CostEstimator estimator){
  if (cachedPlans != null) {
    return cachedPlans;
  }
  List<? extends OptimizerNode> inPlans1=input1.getSourcePact().getAlternativePlans(estimator);
  List<? extends OptimizerNode> inPlans2=input2.getSourcePact().getAlternativePlans(estimator);
  List<CoGroupNode> outputPlans=new ArrayList<CoGroupNode>();
  for (  OptimizerNode pred1 : inPlans1) {
    for (    OptimizerNode pred2 : inPlans2) {
      if (!areBranchCompatible(pred1,pred2)) {
        continue;
      }
      ShipStrategy ss1=input1.getShipStrategy();
      ShipStrategy ss2=input2.getShipStrategy();
      GlobalProperties gp1;
      GlobalProperties gp2;
      if (ss1 == ShipStrategy.NONE) {
        gp1=pred1.getGlobalProperties();
        if (ss2 == ShipStrategy.NONE) {
          gp2=pred2.getGlobalProperties();
          if (gp1.getPartitioning().isComputablyPartitioned()) {
            ss1=ShipStrategy.FORWARD;
          }
          if (gp2.getPartitioning().isComputablyPartitioned()) {
            if ((!gp1.getPartitioning().isPartitioned()) || gp1.getPartitioning() == gp2.getPartitioning()) {
              ss2=ShipStrategy.FORWARD;
            }
 else {
              if (gp1.getPartitioning() == PartitionProperty.HASH_PARTITIONED && gp2.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
                createCoGroupAlternative(outputPlans,pred1,pred2,ShipStrategy.FORWARD,ShipStrategy.PARTITION_HASH,estimator);
                createCoGroupAlternative(outputPlans,pred1,pred2,ShipStrategy.PARTITION_RANGE,ShipStrategy.FORWARD,estimator);
              }
 else               if (gp1.getPartitioning() == PartitionProperty.RANGE_PARTITIONED && gp2.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
                createCoGroupAlternative(outputPlans,pred1,pred2,ShipStrategy.FORWARD,ShipStrategy.PARTITION_RANGE,estimator);
                createCoGroupAlternative(outputPlans,pred1,pred2,ShipStrategy.PARTITION_HASH,ShipStrategy.FORWARD,estimator);
              }
              continue;
            }
          }
          if (ss1 == ShipStrategy.FORWARD) {
            if (ss2 == ShipStrategy.FORWARD) {
              createCoGroupAlternative(outputPlans,pred1,pred2,ss1,ss2,estimator);
              if (gp1.getPartitioning() != PartitionProperty.RANGE_PARTITIONED) {
              }
            }
 else {
              if (gp1.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
                createCoGroupAlternative(outputPlans,pred1,pred2,ss1,ShipStrategy.PARTITION_HASH,estimator);
              }
 else               if (gp1.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
                createCoGroupAlternative(outputPlans,pred1,pred2,ss1,ShipStrategy.PARTITION_RANGE,estimator);
                createCoGroupAlternative(outputPlans,pred1,pred2,ShipStrategy.PARTITION_HASH,ShipStrategy.PARTITION_HASH,estimator);
              }
 else {
                throw new CompilerException(""String_Node_Str"" + getPactContract().getName() + ""String_Node_Str"");
              }
            }
          }
 else           if (ss2 == ShipStrategy.FORWARD) {
            if (gp2.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
              createCoGroupAlternative(outputPlans,pred1,pred2,ShipStrategy.PARTITION_HASH,ss2,estimator);
            }
 else             if (gp2.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
              createCoGroupAlternative(outputPlans,pred1,pred2,ShipStrategy.PARTITION_RANGE,ss2,estimator);
              createCoGroupAlternative(outputPlans,pred1,pred2,ShipStrategy.PARTITION_HASH,ShipStrategy.PARTITION_HASH,estimator);
            }
 else {
              throw new CompilerException(""String_Node_Str"" + getPactContract().getName() + ""String_Node_Str"");
            }
          }
 else {
            createCoGroupAlternative(outputPlans,pred1,pred2,ShipStrategy.PARTITION_HASH,ShipStrategy.PARTITION_HASH,estimator);
          }
        }
 else {
          gp2=PactConnection.getGlobalPropertiesAfterConnection(pred2,ss2);
switch (ss2) {
case FORWARD:
            if (gp2.getPartitioning().isPartitioned()) {
              if (gp2.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
                ss1=ShipStrategy.PARTITION_HASH;
              }
 else               if (gp2.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
                ss1=ShipStrategy.PARTITION_RANGE;
              }
 else {
                throw new CompilerException();
              }
            }
 else {
              continue;
            }
          break;
case PARTITION_HASH:
        ss1=(gp1.getPartitioning() == PartitionProperty.HASH_PARTITIONED) ? ShipStrategy.FORWARD : ShipStrategy.PARTITION_HASH;
      break;
case PARTITION_RANGE:
    ss1=(gp1.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) ? ShipStrategy.FORWARD : ShipStrategy.PARTITION_RANGE;
  break;
default :
throw new CompilerException(""String_Node_Str"" + ss2.name() + ""String_Node_Str""+ getPactContract().getName()+ ""String_Node_Str"");
}
createCoGroupAlternative(outputPlans,pred1,pred2,ss1,ss2,estimator);
}
}
 else if (ss2 == ShipStrategy.NONE) {
gp1=PactConnection.getGlobalPropertiesAfterConnection(pred1,ss1);
gp2=pred2.getGlobalProperties();
switch (ss1) {
case FORWARD:
if (gp1.getPartitioning().isPartitioned()) {
if (gp1.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
ss2=ShipStrategy.PARTITION_HASH;
}
 else if (gp1.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
ss2=ShipStrategy.PARTITION_RANGE;
}
 else {
throw new CompilerException();
}
}
 else {
continue;
}
break;
case PARTITION_HASH:
ss2=(gp2.getPartitioning() == PartitionProperty.HASH_PARTITIONED) ? ShipStrategy.FORWARD : ShipStrategy.PARTITION_HASH;
break;
case PARTITION_RANGE:
ss2=(gp2.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) ? ShipStrategy.FORWARD : ShipStrategy.PARTITION_RANGE;
break;
default :
throw new CompilerException(""String_Node_Str"" + ss1.name() + ""String_Node_Str""+ getPactContract().getName()+ ""String_Node_Str"");
}
createCoGroupAlternative(outputPlans,pred1,pred2,ss1,ss2,estimator);
}
 else {
gp1=PactConnection.getGlobalPropertiesAfterConnection(pred1,ss1);
gp2=PactConnection.getGlobalPropertiesAfterConnection(pred2,ss2);
if (gp1.getPartitioning().isPartitioned() && gp1.getPartitioning() == gp2.getPartitioning()) {
createCoGroupAlternative(outputPlans,pred1,pred2,ss1,ss2,estimator);
}
 else {
continue;
}
}
}
}
if (outputPlans.isEmpty()) {
throw new CompilerException(""String_Node_Str"" + getPactContract().getName() + ""String_Node_Str"");
}
prunePlanAlternatives(outputPlans);
if (isBranching()) {
this.cachedPlans=outputPlans;
}
return outputPlans;
}","@Override public List<CoGroupNode> getAlternativePlans(CostEstimator estimator){
  if (cachedPlans != null) {
    return cachedPlans;
  }
  List<? extends OptimizerNode> inPlans1=input1.getSourcePact().getAlternativePlans(estimator);
  List<? extends OptimizerNode> inPlans2=input2.getSourcePact().getAlternativePlans(estimator);
  List<CoGroupNode> outputPlans=new ArrayList<CoGroupNode>();
  for (  OptimizerNode pred1 : inPlans1) {
    for (    OptimizerNode pred2 : inPlans2) {
      if (!areBranchCompatible(pred1,pred2)) {
        continue;
      }
      ShipStrategy ss1=input1.getShipStrategy();
      ShipStrategy ss2=input2.getShipStrategy();
      GlobalProperties gp1;
      GlobalProperties gp2;
      if (ss1 == ShipStrategy.NONE) {
        gp1=pred1.getGlobalProperties();
        if (ss2 == ShipStrategy.NONE) {
          gp2=pred2.getGlobalProperties();
          if (gp1.getPartitioning().isComputablyPartitioned()) {
            ss1=ShipStrategy.FORWARD;
          }
          if (gp2.getPartitioning().isComputablyPartitioned()) {
            if ((!gp1.getPartitioning().isComputablyPartitioned()) || gp1.getPartitioning() == gp2.getPartitioning()) {
              ss2=ShipStrategy.FORWARD;
            }
 else {
              if (gp1.getPartitioning() == PartitionProperty.HASH_PARTITIONED && gp2.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
                createCoGroupAlternative(outputPlans,pred1,pred2,ShipStrategy.FORWARD,ShipStrategy.PARTITION_HASH,estimator);
                createCoGroupAlternative(outputPlans,pred1,pred2,ShipStrategy.PARTITION_RANGE,ShipStrategy.FORWARD,estimator);
              }
 else               if (gp1.getPartitioning() == PartitionProperty.RANGE_PARTITIONED && gp2.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
                createCoGroupAlternative(outputPlans,pred1,pred2,ShipStrategy.FORWARD,ShipStrategy.PARTITION_RANGE,estimator);
                createCoGroupAlternative(outputPlans,pred1,pred2,ShipStrategy.PARTITION_HASH,ShipStrategy.FORWARD,estimator);
              }
              continue;
            }
          }
          if (ss1 == ShipStrategy.FORWARD) {
            if (ss2 == ShipStrategy.FORWARD) {
              createCoGroupAlternative(outputPlans,pred1,pred2,ss1,ss2,estimator);
              if (gp1.getPartitioning() != PartitionProperty.RANGE_PARTITIONED) {
              }
            }
 else {
              if (gp1.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
                createCoGroupAlternative(outputPlans,pred1,pred2,ss1,ShipStrategy.PARTITION_HASH,estimator);
              }
 else               if (gp1.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
                createCoGroupAlternative(outputPlans,pred1,pred2,ss1,ShipStrategy.PARTITION_RANGE,estimator);
                createCoGroupAlternative(outputPlans,pred1,pred2,ShipStrategy.PARTITION_HASH,ShipStrategy.PARTITION_HASH,estimator);
              }
 else {
                throw new CompilerException(""String_Node_Str"" + getPactContract().getName() + ""String_Node_Str"");
              }
            }
          }
 else           if (ss2 == ShipStrategy.FORWARD) {
            if (gp2.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
              createCoGroupAlternative(outputPlans,pred1,pred2,ShipStrategy.PARTITION_HASH,ss2,estimator);
            }
 else             if (gp2.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
              createCoGroupAlternative(outputPlans,pred1,pred2,ShipStrategy.PARTITION_RANGE,ss2,estimator);
              createCoGroupAlternative(outputPlans,pred1,pred2,ShipStrategy.PARTITION_HASH,ShipStrategy.PARTITION_HASH,estimator);
            }
 else {
              throw new CompilerException(""String_Node_Str"" + getPactContract().getName() + ""String_Node_Str"");
            }
          }
 else {
            createCoGroupAlternative(outputPlans,pred1,pred2,ShipStrategy.PARTITION_HASH,ShipStrategy.PARTITION_HASH,estimator);
          }
        }
 else {
          gp2=PactConnection.getGlobalPropertiesAfterConnection(pred2,this,ss2);
switch (ss2) {
case FORWARD:
            if (gp2.getPartitioning().isPartitioned()) {
              if (gp2.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
                ss1=ShipStrategy.PARTITION_HASH;
              }
 else               if (gp2.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
                ss1=ShipStrategy.PARTITION_RANGE;
              }
 else {
                throw new CompilerException();
              }
            }
 else {
              continue;
            }
          break;
case PARTITION_HASH:
        ss1=(gp1.getPartitioning() == PartitionProperty.HASH_PARTITIONED) ? ShipStrategy.FORWARD : ShipStrategy.PARTITION_HASH;
      break;
case PARTITION_RANGE:
    ss1=(gp1.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) ? ShipStrategy.FORWARD : ShipStrategy.PARTITION_RANGE;
  break;
default :
throw new CompilerException(""String_Node_Str"" + ss2.name() + ""String_Node_Str""+ getPactContract().getName()+ ""String_Node_Str"");
}
createCoGroupAlternative(outputPlans,pred1,pred2,ss1,ss2,estimator);
}
}
 else if (ss2 == ShipStrategy.NONE) {
gp1=PactConnection.getGlobalPropertiesAfterConnection(pred1,this,ss1);
gp2=pred2.getGlobalProperties();
switch (ss1) {
case FORWARD:
if (gp1.getPartitioning().isPartitioned()) {
if (gp1.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
ss2=ShipStrategy.PARTITION_HASH;
}
 else if (gp1.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
ss2=ShipStrategy.PARTITION_RANGE;
}
 else {
throw new CompilerException();
}
}
 else {
continue;
}
break;
case PARTITION_HASH:
ss2=(gp2.getPartitioning() == PartitionProperty.HASH_PARTITIONED) ? ShipStrategy.FORWARD : ShipStrategy.PARTITION_HASH;
break;
case PARTITION_RANGE:
ss2=(gp2.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) ? ShipStrategy.FORWARD : ShipStrategy.PARTITION_RANGE;
break;
default :
throw new CompilerException(""String_Node_Str"" + ss1.name() + ""String_Node_Str""+ getPactContract().getName()+ ""String_Node_Str"");
}
createCoGroupAlternative(outputPlans,pred1,pred2,ss1,ss2,estimator);
}
 else {
gp1=PactConnection.getGlobalPropertiesAfterConnection(pred1,this,ss1);
gp2=PactConnection.getGlobalPropertiesAfterConnection(pred2,this,ss2);
if (gp1.getPartitioning().isComputablyPartitioned() && gp1.getPartitioning() == gp2.getPartitioning()) {
createCoGroupAlternative(outputPlans,pred1,pred2,ss1,ss2,estimator);
}
 else {
continue;
}
}
}
}
if (outputPlans.isEmpty()) {
throw new CompilerException(""String_Node_Str"" + getPactContract().getName() + ""String_Node_Str"");
}
prunePlanAlternatives(outputPlans);
if (isBranching()) {
this.cachedPlans=outputPlans;
}
return outputPlans;
}"
88311,"/** 
 * Private utility method that generates the alternative CoGroup nodes, given fixed shipping strategies for the inputs.
 * @param target The list to put the alternatives in.
 * @param pred1 The predecessor node for the first input.
 * @param pred2 The predecessor node for the second input.
 * @param ss1 The shipping strategy for the first input.
 * @param ss2 The shipping strategy for the second input.
 * @param estimator The cost estimator.
 */
private void createCoGroupAlternative(List<CoGroupNode> target,OptimizerNode pred1,OptimizerNode pred2,ShipStrategy ss1,ShipStrategy ss2,CostEstimator estimator){
  GlobalProperties gp1=PactConnection.getGlobalPropertiesAfterConnection(pred1,ss1);
  LocalProperties lp1=PactConnection.getLocalPropertiesAfterConnection(pred1,ss1);
  LocalProperties lp2=PactConnection.getLocalPropertiesAfterConnection(pred2,ss2);
  GlobalProperties outGp=new GlobalProperties();
  outGp.setPartitioning(gp1.getPartitioning());
  LocalProperties outLp=new LocalProperties();
  outLp.setKeyOrder(lp1.getKeyOrder().isOrdered() && lp1.getKeyOrder() == lp2.getKeyOrder() ? lp1.getKeyOrder() : Order.NONE);
  outLp.setKeysGrouped(outLp.getKeyOrder().isOrdered());
  CoGroupNode n=new CoGroupNode(this,pred1,pred2,input1,input2,outGp,outLp);
  n.input1.setShipStrategy(ss1);
  n.input2.setShipStrategy(ss2);
  if (outLp.getKeyOrder().isOrdered()) {
    n.setLocalStrategy(LocalStrategy.NONE);
  }
 else {
    n.setLocalStrategy(LocalStrategy.SORTMERGE);
    n.getLocalProperties().setKeyOrder(Order.ASCENDING);
    n.getLocalProperties().setKeysGrouped(true);
  }
  n.getGlobalProperties().getPreservedAfterContract(getOutputContract());
  n.getLocalProperties().getPreservedAfterContract(getOutputContract());
  estimator.costOperator(n);
  target.add(n);
}","/** 
 * Private utility method that generates the alternative CoGroup nodes, given fixed shipping strategies for the inputs.
 * @param target The list to put the alternatives in.
 * @param pred1 The predecessor node for the first input.
 * @param pred2 The predecessor node for the second input.
 * @param ss1 The shipping strategy for the first input.
 * @param ss2 The shipping strategy for the second input.
 * @param estimator The cost estimator.
 */
private void createCoGroupAlternative(List<CoGroupNode> target,OptimizerNode pred1,OptimizerNode pred2,ShipStrategy ss1,ShipStrategy ss2,CostEstimator estimator){
  GlobalProperties gp1=PactConnection.getGlobalPropertiesAfterConnection(pred1,this,ss1);
  LocalProperties lp1=PactConnection.getLocalPropertiesAfterConnection(pred1,this,ss1);
  LocalProperties lp2=PactConnection.getLocalPropertiesAfterConnection(pred2,this,ss2);
  GlobalProperties outGp=new GlobalProperties();
  outGp.setPartitioning(gp1.getPartitioning());
  LocalProperties outLp=new LocalProperties();
  outLp.setKeyOrder(lp1.getKeyOrder().isOrdered() && lp1.getKeyOrder() == lp2.getKeyOrder() ? lp1.getKeyOrder() : Order.NONE);
  outLp.setKeysGrouped(outLp.getKeyOrder().isOrdered());
  CoGroupNode n=new CoGroupNode(this,pred1,pred2,input1,input2,outGp,outLp);
  n.input1.setShipStrategy(ss1);
  n.input2.setShipStrategy(ss2);
  if (outLp.getKeyOrder().isOrdered()) {
    n.setLocalStrategy(LocalStrategy.NONE);
  }
 else {
    n.setLocalStrategy(LocalStrategy.SORTMERGE);
    n.getLocalProperties().setKeyOrder(Order.ASCENDING);
    n.getLocalProperties().setKeysGrouped(true);
  }
  n.getGlobalProperties().getPreservedAfterContract(getOutputContract());
  n.getLocalProperties().getPreservedAfterContract(getOutputContract());
  estimator.costOperator(n);
  target.add(n);
}"
88312,"/** 
 * Private utility method that generates the alternative Cross nodes, given fixed shipping strategies for the inputs.
 * @param target The list to put the alternatives in.
 * @param pred1 The predecessor node for the first input.
 * @param pred2 The predecessor node for the second input.
 * @param ss1 The shipping strategy for the first input.
 * @param ss2 The shipping strategy for the second input.
 * @param estimator The cost estimator.
 */
private void createLocalAlternatives(List<CrossNode> target,OptimizerNode pred1,OptimizerNode pred2,ShipStrategy ss1,ShipStrategy ss2,CostEstimator estimator){
  LocalProperties lpDefaults=new LocalProperties();
  GlobalProperties gp=null;
  LocalProperties lp=null;
  OutputContract oc=getOutputContract();
  boolean isFirst=false;
  if (oc.appliesToFirstInput()) {
    gp=PactConnection.getGlobalPropertiesAfterConnection(pred1,ss1);
    lp=PactConnection.getLocalPropertiesAfterConnection(pred1,ss1);
    isFirst=true;
  }
 else   if (oc.appliesToSecondInput()) {
    gp=PactConnection.getGlobalPropertiesAfterConnection(pred2,ss2);
    lp=PactConnection.getLocalPropertiesAfterConnection(pred2,ss2);
  }
 else {
    gp=new GlobalProperties();
    lp=new LocalProperties();
  }
  gp.setKeyUnique(false);
  lp.setKeyUnique(false);
  GlobalProperties gpNoOrder=gp.createCopy();
  gpNoOrder.setKeyOrder(Order.NONE);
  LocalStrategy ls=getLocalStrategy();
  if (ls != LocalStrategy.NONE) {
    if (ls == LocalStrategy.NESTEDLOOP_STREAMED_OUTER_FIRST) {
      gp=isFirst ? gp : gpNoOrder;
      lp=isFirst ? lp : lpDefaults;
    }
 else     if (ls == LocalStrategy.NESTEDLOOP_STREAMED_OUTER_SECOND) {
      gp=isFirst ? gpNoOrder : gp;
      lp=isFirst ? lpDefaults : lp;
    }
 else     if (ls == LocalStrategy.NESTEDLOOP_BLOCKED_OUTER_FIRST || ls == LocalStrategy.NESTEDLOOP_BLOCKED_OUTER_SECOND) {
      gp=gpNoOrder;
      lp=lpDefaults;
    }
 else {
      return;
    }
    createCrossAlternative(target,pred1,pred2,ss1,ss2,ls,gp,lp,estimator);
  }
 else {
    if (isFirst) {
      createCrossAlternative(target,pred1,pred2,ss1,ss2,LocalStrategy.NESTEDLOOP_STREAMED_OUTER_FIRST,gp,lp,estimator);
      createCrossAlternative(target,pred1,pred2,ss1,ss2,LocalStrategy.NESTEDLOOP_STREAMED_OUTER_SECOND,gpNoOrder.createCopy(),lpDefaults.createCopy(),estimator);
    }
 else {
      createCrossAlternative(target,pred1,pred2,ss1,ss2,LocalStrategy.NESTEDLOOP_STREAMED_OUTER_SECOND,gp,lp,estimator);
      createCrossAlternative(target,pred1,pred2,ss1,ss2,LocalStrategy.NESTEDLOOP_STREAMED_OUTER_FIRST,gpNoOrder.createCopy(),lpDefaults.createCopy(),estimator);
    }
    createCrossAlternative(target,pred1,pred2,ss1,ss2,LocalStrategy.NESTEDLOOP_BLOCKED_OUTER_FIRST,gpNoOrder.createCopy(),lpDefaults.createCopy(),estimator);
    createCrossAlternative(target,pred1,pred2,ss1,ss2,LocalStrategy.NESTEDLOOP_BLOCKED_OUTER_SECOND,gpNoOrder,lpDefaults,estimator);
  }
}","/** 
 * Private utility method that generates the alternative Cross nodes, given fixed shipping strategies for the inputs.
 * @param target The list to put the alternatives in.
 * @param pred1 The predecessor node for the first input.
 * @param pred2 The predecessor node for the second input.
 * @param ss1 The shipping strategy for the first input.
 * @param ss2 The shipping strategy for the second input.
 * @param estimator The cost estimator.
 */
private void createLocalAlternatives(List<CrossNode> target,OptimizerNode pred1,OptimizerNode pred2,ShipStrategy ss1,ShipStrategy ss2,CostEstimator estimator){
  LocalProperties lpDefaults=new LocalProperties();
  GlobalProperties gp=null;
  LocalProperties lp=null;
  OutputContract oc=getOutputContract();
  boolean isFirst=false;
  if (oc.appliesToFirstInput()) {
    gp=PactConnection.getGlobalPropertiesAfterConnection(pred1,this,ss1);
    lp=PactConnection.getLocalPropertiesAfterConnection(pred1,this,ss1);
    isFirst=true;
  }
 else   if (oc.appliesToSecondInput()) {
    gp=PactConnection.getGlobalPropertiesAfterConnection(pred2,this,ss2);
    lp=PactConnection.getLocalPropertiesAfterConnection(pred2,this,ss2);
  }
 else {
    gp=new GlobalProperties();
    lp=new LocalProperties();
  }
  gp.setKeyUnique(false);
  lp.setKeyUnique(false);
  GlobalProperties gpNoOrder=gp.createCopy();
  gpNoOrder.setKeyOrder(Order.NONE);
  LocalStrategy ls=getLocalStrategy();
  if (ls != LocalStrategy.NONE) {
    if (ls == LocalStrategy.NESTEDLOOP_STREAMED_OUTER_FIRST) {
      gp=isFirst ? gp : gpNoOrder;
      lp=isFirst ? lp : lpDefaults;
    }
 else     if (ls == LocalStrategy.NESTEDLOOP_STREAMED_OUTER_SECOND) {
      gp=isFirst ? gpNoOrder : gp;
      lp=isFirst ? lpDefaults : lp;
    }
 else     if (ls == LocalStrategy.NESTEDLOOP_BLOCKED_OUTER_FIRST || ls == LocalStrategy.NESTEDLOOP_BLOCKED_OUTER_SECOND) {
      gp=gpNoOrder;
      lp=lpDefaults;
    }
 else {
      return;
    }
    createCrossAlternative(target,pred1,pred2,ss1,ss2,ls,gp,lp,estimator);
  }
 else {
    if (isFirst) {
      createCrossAlternative(target,pred1,pred2,ss1,ss2,LocalStrategy.NESTEDLOOP_STREAMED_OUTER_FIRST,gp,lp,estimator);
      createCrossAlternative(target,pred1,pred2,ss1,ss2,LocalStrategy.NESTEDLOOP_STREAMED_OUTER_SECOND,gpNoOrder.createCopy(),lpDefaults.createCopy(),estimator);
    }
 else {
      createCrossAlternative(target,pred1,pred2,ss1,ss2,LocalStrategy.NESTEDLOOP_STREAMED_OUTER_SECOND,gp,lp,estimator);
      createCrossAlternative(target,pred1,pred2,ss1,ss2,LocalStrategy.NESTEDLOOP_STREAMED_OUTER_FIRST,gpNoOrder.createCopy(),lpDefaults.createCopy(),estimator);
    }
    createCrossAlternative(target,pred1,pred2,ss1,ss2,LocalStrategy.NESTEDLOOP_BLOCKED_OUTER_FIRST,gpNoOrder.createCopy(),lpDefaults.createCopy(),estimator);
    createCrossAlternative(target,pred1,pred2,ss1,ss2,LocalStrategy.NESTEDLOOP_BLOCKED_OUTER_SECOND,gpNoOrder,lpDefaults,estimator);
  }
}"
88313,"/** 
 * Copy constructor to create a copy of the data-source object for the process of plan enumeration.
 * @param template The node to create a copy of.
 * @param gp The global properties of this copy.
 * @param lp The local properties of this copy.
 */
protected DataSourceNode(DataSourceNode template,GlobalProperties gp,LocalProperties lp){
  super(template,gp,lp);
}","/** 
 * Copy constructor to create a copy of the data-source object for the process of plan enumeration.
 * @param template The node to create a copy of.
 * @param gp The global properties of this copy.
 * @param lp The local properties of this copy.
 */
protected DataSourceNode(DataSourceNode template,GlobalProperties gp,LocalProperties lp){
  super(template,gp,lp);
  this.fileSize=template.fileSize;
}"
88314,"@Override public List<MapNode> getAlternativePlans(CostEstimator estimator){
  if (cachedPlans != null) {
    return cachedPlans;
  }
  List<? extends OptimizerNode> inPlans=input.getSourcePact().getAlternativePlans(estimator);
  List<MapNode> outputPlans=new ArrayList<MapNode>();
  for (  OptimizerNode pred : inPlans) {
    ShipStrategy ss=input.getShipStrategy() == ShipStrategy.NONE ? ShipStrategy.FORWARD : input.getShipStrategy();
    GlobalProperties gp=PactConnection.getGlobalPropertiesAfterConnection(pred,ss);
    LocalProperties lp=PactConnection.getLocalPropertiesAfterConnection(pred,ss);
    MapNode nMap=new MapNode(this,pred,input,gp,lp);
    nMap.input.setShipStrategy(ss);
    nMap.getGlobalProperties().getPreservedAfterContract(getOutputContract());
    nMap.getLocalProperties().getPreservedAfterContract(getOutputContract());
    estimator.costOperator(nMap);
    outputPlans.add(nMap);
  }
  prunePlanAlternatives(outputPlans);
  if (this.getOutgoingConnections() != null && this.getOutgoingConnections().size() > 1) {
    this.cachedPlans=outputPlans;
  }
  return outputPlans;
}","@Override public List<MapNode> getAlternativePlans(CostEstimator estimator){
  if (cachedPlans != null) {
    return cachedPlans;
  }
  List<? extends OptimizerNode> inPlans=input.getSourcePact().getAlternativePlans(estimator);
  List<MapNode> outputPlans=new ArrayList<MapNode>();
  for (  OptimizerNode pred : inPlans) {
    ShipStrategy ss=input.getShipStrategy() == ShipStrategy.NONE ? ShipStrategy.FORWARD : input.getShipStrategy();
    GlobalProperties gp=PactConnection.getGlobalPropertiesAfterConnection(pred,this,ss);
    LocalProperties lp=PactConnection.getLocalPropertiesAfterConnection(pred,this,ss);
    MapNode nMap=new MapNode(this,pred,input,gp,lp);
    nMap.input.setShipStrategy(ss);
    nMap.getGlobalProperties().getPreservedAfterContract(getOutputContract());
    nMap.getLocalProperties().getPreservedAfterContract(getOutputContract());
    estimator.costOperator(nMap);
    outputPlans.add(nMap);
  }
  prunePlanAlternatives(outputPlans);
  if (this.getOutgoingConnections() != null && this.getOutgoingConnections().size() > 1) {
    this.cachedPlans=outputPlans;
  }
  return outputPlans;
}"
88315,"@Override public List<MatchNode> getAlternativePlans(CostEstimator estimator){
  if (cachedPlans != null) {
    return cachedPlans;
  }
  List<? extends OptimizerNode> inPlans1=input1.getSourcePact().getAlternativePlans(estimator);
  List<? extends OptimizerNode> inPlans2=input2.getSourcePact().getAlternativePlans(estimator);
  List<MatchNode> outputPlans=new ArrayList<MatchNode>();
  for (  OptimizerNode pred1 : inPlans1) {
    for (    OptimizerNode pred2 : inPlans2) {
      if (!areBranchCompatible(pred1,pred2)) {
        continue;
      }
      ShipStrategy ss1=input1.getShipStrategy();
      ShipStrategy ss2=input2.getShipStrategy();
      GlobalProperties gp1;
      GlobalProperties gp2;
      if (ss1 == ShipStrategy.NONE) {
        gp1=pred1.getGlobalProperties();
        if (ss2 == ShipStrategy.NONE) {
          gp2=pred2.getGlobalProperties();
          if (gp1.getPartitioning().isComputablyPartitioned()) {
            ss1=ShipStrategy.FORWARD;
          }
          if (gp2.getPartitioning().isComputablyPartitioned()) {
            if ((!gp1.getPartitioning().isPartitioned()) || gp1.getPartitioning().isCompatibleWith(gp2.getPartitioning())) {
              ss2=ShipStrategy.FORWARD;
            }
 else {
              if (gp1.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
                createLocalAlternatives(outputPlans,pred1,pred2,ShipStrategy.FORWARD,ShipStrategy.PARTITION_HASH,estimator);
              }
 else               if (gp1.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
                createLocalAlternatives(outputPlans,pred1,pred2,ShipStrategy.FORWARD,ShipStrategy.PARTITION_RANGE,estimator);
              }
              if (gp2.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
                createLocalAlternatives(outputPlans,pred1,pred2,ShipStrategy.PARTITION_HASH,ShipStrategy.FORWARD,estimator);
              }
 else               if (gp2.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
                createLocalAlternatives(outputPlans,pred1,pred2,ShipStrategy.PARTITION_RANGE,ShipStrategy.FORWARD,estimator);
              }
              continue;
            }
          }
          if (ss1 == ShipStrategy.FORWARD) {
            if (ss2 == ShipStrategy.FORWARD) {
              createLocalAlternatives(outputPlans,pred1,pred2,ss1,ss2,estimator);
              if (gp1.getPartitioning() != PartitionProperty.RANGE_PARTITIONED) {
                createLocalAlternatives(outputPlans,pred1,pred2,ShipStrategy.PARTITION_RANGE,ShipStrategy.PARTITION_RANGE,estimator);
              }
            }
 else {
              if (gp1.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
                createLocalAlternatives(outputPlans,pred1,pred2,ss1,ShipStrategy.PARTITION_HASH,estimator);
              }
 else               if (gp1.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
                createLocalAlternatives(outputPlans,pred1,pred2,ss1,ShipStrategy.PARTITION_RANGE,estimator);
                createLocalAlternatives(outputPlans,pred1,pred2,ShipStrategy.PARTITION_HASH,ShipStrategy.PARTITION_HASH,estimator);
              }
 else {
                throw new CompilerException(""String_Node_Str"" + getPactContract().getName() + ""String_Node_Str"");
              }
            }
          }
 else           if (ss2 == ShipStrategy.FORWARD) {
            if (gp2.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
              createLocalAlternatives(outputPlans,pred1,pred2,ShipStrategy.PARTITION_HASH,ss2,estimator);
            }
 else             if (gp2.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
              createLocalAlternatives(outputPlans,pred1,pred2,ShipStrategy.PARTITION_RANGE,ss2,estimator);
              createLocalAlternatives(outputPlans,pred1,pred2,ShipStrategy.PARTITION_HASH,ShipStrategy.PARTITION_HASH,estimator);
            }
 else {
              throw new CompilerException(""String_Node_Str"" + getPactContract().getName() + ""String_Node_Str"");
            }
          }
 else {
            createLocalAlternatives(outputPlans,pred1,pred2,ShipStrategy.PARTITION_HASH,ShipStrategy.PARTITION_HASH,estimator);
            if (pred1.getEstimatedOutputSize() != -1 && pred2.getEstimatedOutputSize() != -1) {
              createLocalAlternatives(outputPlans,pred1,pred2,ShipStrategy.BROADCAST,ShipStrategy.FORWARD,estimator);
              createLocalAlternatives(outputPlans,pred1,pred2,ShipStrategy.FORWARD,ShipStrategy.BROADCAST,estimator);
            }
          }
        }
 else {
          gp2=PactConnection.getGlobalPropertiesAfterConnection(pred2,ss2);
switch (ss2) {
case BROADCAST:
            ss1=ShipStrategy.FORWARD;
          break;
case FORWARD:
        if (gp2.getPartitioning().isPartitioned()) {
          if (gp2.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
            ss1=ShipStrategy.PARTITION_HASH;
          }
 else           if (gp2.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
            ss1=ShipStrategy.PARTITION_RANGE;
          }
 else {
            throw new CompilerException();
          }
        }
 else {
          ss1=ShipStrategy.BROADCAST;
        }
      break;
case PARTITION_HASH:
    ss1=(gp1.getPartitioning() == PartitionProperty.HASH_PARTITIONED) ? ShipStrategy.FORWARD : ShipStrategy.PARTITION_HASH;
  break;
case PARTITION_RANGE:
ss1=(gp1.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) ? ShipStrategy.FORWARD : ShipStrategy.PARTITION_RANGE;
break;
default :
throw new CompilerException(""String_Node_Str"" + ss2.name() + ""String_Node_Str""+ getPactContract().getName()+ ""String_Node_Str"");
}
createLocalAlternatives(outputPlans,pred1,pred2,ss1,ss2,estimator);
}
}
 else if (ss2 == ShipStrategy.NONE) {
gp1=PactConnection.getGlobalPropertiesAfterConnection(pred1,ss1);
gp2=pred2.getGlobalProperties();
switch (ss1) {
case BROADCAST:
ss2=ShipStrategy.FORWARD;
break;
case FORWARD:
if (gp1.getPartitioning().isPartitioned()) {
if (gp1.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
ss2=ShipStrategy.PARTITION_HASH;
}
 else if (gp1.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
ss2=ShipStrategy.PARTITION_RANGE;
}
 else {
throw new CompilerException();
}
}
 else {
ss2=ShipStrategy.BROADCAST;
}
break;
case PARTITION_HASH:
ss2=(gp2.getPartitioning() == PartitionProperty.HASH_PARTITIONED) ? ShipStrategy.FORWARD : ShipStrategy.PARTITION_HASH;
break;
case PARTITION_RANGE:
ss2=(gp2.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) ? ShipStrategy.FORWARD : ShipStrategy.PARTITION_RANGE;
break;
default :
throw new CompilerException(""String_Node_Str"" + ss1.name() + ""String_Node_Str""+ getPactContract().getName()+ ""String_Node_Str"");
}
createLocalAlternatives(outputPlans,pred1,pred2,ss1,ss2,estimator);
}
 else {
if ((ss1 == ShipStrategy.BROADCAST && ss2 != ShipStrategy.BROADCAST) || (ss1 != ShipStrategy.BROADCAST && ss2 == ShipStrategy.BROADCAST)) {
createLocalAlternatives(outputPlans,pred1,pred2,ss1,ss2,estimator);
}
 else {
gp1=PactConnection.getGlobalPropertiesAfterConnection(pred1,ss1);
gp2=PactConnection.getGlobalPropertiesAfterConnection(pred2,ss2);
if (gp1.getPartitioning().isPartitioned() && gp1.getPartitioning() == gp2.getPartitioning()) {
createLocalAlternatives(outputPlans,pred1,pred2,ss1,ss2,estimator);
}
 else {
continue;
}
}
}
}
}
if (outputPlans.isEmpty()) {
throw new CompilerException(""String_Node_Str"" + getPactContract().getName() + ""String_Node_Str"");
}
prunePlanAlternatives(outputPlans);
if (this.getOutgoingConnections() != null && this.getOutgoingConnections().size() > 1) {
this.cachedPlans=outputPlans;
}
return outputPlans;
}","@Override public List<MatchNode> getAlternativePlans(CostEstimator estimator){
  if (cachedPlans != null) {
    return cachedPlans;
  }
  List<? extends OptimizerNode> inPlans1=input1.getSourcePact().getAlternativePlans(estimator);
  List<? extends OptimizerNode> inPlans2=input2.getSourcePact().getAlternativePlans(estimator);
  List<MatchNode> outputPlans=new ArrayList<MatchNode>();
  for (  OptimizerNode pred1 : inPlans1) {
    for (    OptimizerNode pred2 : inPlans2) {
      if (!areBranchCompatible(pred1,pred2)) {
        continue;
      }
      ShipStrategy ss1=input1.getShipStrategy();
      ShipStrategy ss2=input2.getShipStrategy();
      GlobalProperties gp1;
      GlobalProperties gp2;
      if (ss1 == ShipStrategy.NONE) {
        gp1=pred1.getGlobalProperties();
        if (ss2 == ShipStrategy.NONE) {
          gp2=pred2.getGlobalProperties();
          if (gp1.getPartitioning().isComputablyPartitioned()) {
            ss1=ShipStrategy.FORWARD;
          }
          if (gp2.getPartitioning().isComputablyPartitioned()) {
            if ((!gp1.getPartitioning().isPartitioned()) || gp1.getPartitioning().isCompatibleWith(gp2.getPartitioning())) {
              ss2=ShipStrategy.FORWARD;
            }
 else {
              if (gp1.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
                createLocalAlternatives(outputPlans,pred1,pred2,ShipStrategy.FORWARD,ShipStrategy.PARTITION_HASH,estimator);
              }
 else               if (gp1.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
                createLocalAlternatives(outputPlans,pred1,pred2,ShipStrategy.FORWARD,ShipStrategy.PARTITION_RANGE,estimator);
              }
              if (gp2.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
                createLocalAlternatives(outputPlans,pred1,pred2,ShipStrategy.PARTITION_HASH,ShipStrategy.FORWARD,estimator);
              }
 else               if (gp2.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
                createLocalAlternatives(outputPlans,pred1,pred2,ShipStrategy.PARTITION_RANGE,ShipStrategy.FORWARD,estimator);
              }
              continue;
            }
          }
          if (ss1 == ShipStrategy.FORWARD) {
            if (ss2 == ShipStrategy.FORWARD) {
              createLocalAlternatives(outputPlans,pred1,pred2,ss1,ss2,estimator);
              if (gp1.getPartitioning() != PartitionProperty.RANGE_PARTITIONED) {
                createLocalAlternatives(outputPlans,pred1,pred2,ShipStrategy.PARTITION_RANGE,ShipStrategy.PARTITION_RANGE,estimator);
              }
            }
 else {
              if (gp1.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
                createLocalAlternatives(outputPlans,pred1,pred2,ss1,ShipStrategy.PARTITION_HASH,estimator);
              }
 else               if (gp1.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
                createLocalAlternatives(outputPlans,pred1,pred2,ss1,ShipStrategy.PARTITION_RANGE,estimator);
                createLocalAlternatives(outputPlans,pred1,pred2,ShipStrategy.PARTITION_HASH,ShipStrategy.PARTITION_HASH,estimator);
              }
 else {
                throw new CompilerException(""String_Node_Str"" + getPactContract().getName() + ""String_Node_Str"");
              }
            }
          }
 else           if (ss2 == ShipStrategy.FORWARD) {
            if (gp2.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
              createLocalAlternatives(outputPlans,pred1,pred2,ShipStrategy.PARTITION_HASH,ss2,estimator);
            }
 else             if (gp2.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
              createLocalAlternatives(outputPlans,pred1,pred2,ShipStrategy.PARTITION_RANGE,ss2,estimator);
              createLocalAlternatives(outputPlans,pred1,pred2,ShipStrategy.PARTITION_HASH,ShipStrategy.PARTITION_HASH,estimator);
            }
 else {
              throw new CompilerException(""String_Node_Str"" + getPactContract().getName() + ""String_Node_Str"");
            }
          }
 else {
            createLocalAlternatives(outputPlans,pred1,pred2,ShipStrategy.PARTITION_HASH,ShipStrategy.PARTITION_HASH,estimator);
            if (pred1.getEstimatedOutputSize() != -1 && pred2.getEstimatedOutputSize() != -1) {
              createLocalAlternatives(outputPlans,pred1,pred2,ShipStrategy.BROADCAST,ShipStrategy.FORWARD,estimator);
              createLocalAlternatives(outputPlans,pred1,pred2,ShipStrategy.FORWARD,ShipStrategy.BROADCAST,estimator);
            }
          }
        }
 else {
          gp2=PactConnection.getGlobalPropertiesAfterConnection(pred2,this,ss2);
switch (ss2) {
case BROADCAST:
            ss1=ShipStrategy.FORWARD;
          break;
case FORWARD:
        if (gp2.getPartitioning().isPartitioned()) {
          if (gp2.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
            ss1=ShipStrategy.PARTITION_HASH;
          }
 else           if (gp2.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
            ss1=ShipStrategy.PARTITION_RANGE;
          }
 else {
            throw new CompilerException();
          }
        }
 else {
          ss1=ShipStrategy.BROADCAST;
        }
      break;
case PARTITION_HASH:
    ss1=(gp1.getPartitioning() == PartitionProperty.HASH_PARTITIONED) ? ShipStrategy.FORWARD : ShipStrategy.PARTITION_HASH;
  break;
case PARTITION_RANGE:
ss1=(gp1.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) ? ShipStrategy.FORWARD : ShipStrategy.PARTITION_RANGE;
break;
default :
throw new CompilerException(""String_Node_Str"" + ss2.name() + ""String_Node_Str""+ getPactContract().getName()+ ""String_Node_Str"");
}
createLocalAlternatives(outputPlans,pred1,pred2,ss1,ss2,estimator);
}
}
 else if (ss2 == ShipStrategy.NONE) {
gp1=PactConnection.getGlobalPropertiesAfterConnection(pred1,this,ss1);
gp2=pred2.getGlobalProperties();
switch (ss1) {
case BROADCAST:
ss2=ShipStrategy.FORWARD;
break;
case FORWARD:
if (gp1.getPartitioning().isPartitioned()) {
if (gp1.getPartitioning() == PartitionProperty.HASH_PARTITIONED) {
ss2=ShipStrategy.PARTITION_HASH;
}
 else if (gp1.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) {
ss2=ShipStrategy.PARTITION_RANGE;
}
 else {
throw new CompilerException();
}
}
 else {
ss2=ShipStrategy.BROADCAST;
}
break;
case PARTITION_HASH:
ss2=(gp2.getPartitioning() == PartitionProperty.HASH_PARTITIONED) ? ShipStrategy.FORWARD : ShipStrategy.PARTITION_HASH;
break;
case PARTITION_RANGE:
ss2=(gp2.getPartitioning() == PartitionProperty.RANGE_PARTITIONED) ? ShipStrategy.FORWARD : ShipStrategy.PARTITION_RANGE;
break;
default :
throw new CompilerException(""String_Node_Str"" + ss1.name() + ""String_Node_Str""+ getPactContract().getName()+ ""String_Node_Str"");
}
createLocalAlternatives(outputPlans,pred1,pred2,ss1,ss2,estimator);
}
 else {
if ((ss1 == ShipStrategy.BROADCAST && ss2 != ShipStrategy.BROADCAST) || (ss1 != ShipStrategy.BROADCAST && ss2 == ShipStrategy.BROADCAST)) {
createLocalAlternatives(outputPlans,pred1,pred2,ss1,ss2,estimator);
}
 else {
gp1=PactConnection.getGlobalPropertiesAfterConnection(pred1,this,ss1);
gp2=PactConnection.getGlobalPropertiesAfterConnection(pred2,this,ss2);
if (gp1.getPartitioning().isComputablyPartitioned() && gp1.getPartitioning() == gp2.getPartitioning()) {
createLocalAlternatives(outputPlans,pred1,pred2,ss1,ss2,estimator);
}
 else {
continue;
}
}
}
}
}
if (outputPlans.isEmpty()) {
throw new CompilerException(""String_Node_Str"" + getPactContract().getName() + ""String_Node_Str"");
}
prunePlanAlternatives(outputPlans);
if (this.getOutgoingConnections() != null && this.getOutgoingConnections().size() > 1) {
this.cachedPlans=outputPlans;
}
return outputPlans;
}"
88316,"/** 
 * Private utility method that generates the alternative Match nodes, given fixed shipping strategies for the inputs.
 * @param target The list to put the alternatives in.
 * @param pred1 The predecessor node for the first input.
 * @param pred2 The predecessor node for the second input.
 * @param ss1 The shipping strategy for the first input.
 * @param ss2 The shipping strategy for the second input.
 * @param estimator The cost estimator.
 */
private void createLocalAlternatives(List<MatchNode> target,OptimizerNode pred1,OptimizerNode pred2,ShipStrategy ss1,ShipStrategy ss2,CostEstimator estimator){
  GlobalProperties gp1=PactConnection.getGlobalPropertiesAfterConnection(pred1,ss1);
  GlobalProperties gp2=PactConnection.getGlobalPropertiesAfterConnection(pred2,ss2);
  LocalProperties lp1=PactConnection.getLocalPropertiesAfterConnection(pred1,ss1);
  LocalProperties lp2=PactConnection.getLocalPropertiesAfterConnection(pred2,ss2);
  GlobalProperties outGp=new GlobalProperties();
  outGp.setPartitioning(gp1.getPartitioning().isPartitioned() ? gp1.getPartitioning() : gp2.getPartitioning());
  outGp.setKeyOrder(gp1.getKeyOrder().isOrdered() ? gp1.getKeyOrder() : gp2.getKeyOrder());
  LocalProperties outLp=new LocalProperties();
  outLp.setKeyOrder(lp1.getKeyOrder().isOrdered() && lp1.getKeyOrder() == lp2.getKeyOrder() ? lp1.getKeyOrder() : Order.NONE);
  outLp.setKeysGrouped(outLp.getKeyOrder().isOrdered());
  LocalStrategy ls=getLocalStrategy();
  if (ls != LocalStrategy.NONE) {
    if (ls == LocalStrategy.SORTMERGE) {
      outLp.setKeyOrder(Order.ASCENDING);
      outLp.setKeysGrouped(true);
    }
 else     if (ls == LocalStrategy.HYBRIDHASH_FIRST || ls == LocalStrategy.HYBRIDHASH_SECOND || ls == LocalStrategy.MMHASH_FIRST || ls == LocalStrategy.MMHASH_SECOND) {
      outLp.setKeyOrder(Order.NONE);
      outLp.setKeysGrouped(false);
    }
    createMatchAlternative(target,pred1,pred2,ss1,ss2,ls,outGp,outLp,estimator);
  }
 else   if (outLp.getKeyOrder().isOrdered()) {
    createMatchAlternative(target,pred1,pred2,ss1,ss2,LocalStrategy.NONE,outGp,outLp,estimator);
  }
 else   if (lp1.getKeyOrder().isOrdered() || lp2.getKeyOrder().isOrdered()) {
    outLp.setKeyOrder(lp1.getKeyOrder().isOrdered() ? lp1.getKeyOrder() : lp2.getKeyOrder());
    outLp.setKeysGrouped(true);
    createMatchAlternative(target,pred1,pred2,ss1,ss2,LocalStrategy.SORTMERGE,outGp,outLp,estimator);
  }
 else {
    if (pred1.estimatedOutputSize > 0 && pred2.estimatedOutputSize > 0) {
      createMatchAlternative(target,pred1,pred2,ss1,ss2,LocalStrategy.HYBRIDHASH_FIRST,outGp.createCopy(),outLp.createCopy(),estimator);
      createMatchAlternative(target,pred1,pred2,ss1,ss2,LocalStrategy.HYBRIDHASH_SECOND,outGp.createCopy(),outLp.createCopy(),estimator);
    }
    outLp.setKeyOrder(Order.ASCENDING);
    outLp.setKeysGrouped(true);
    createMatchAlternative(target,pred1,pred2,ss1,ss2,LocalStrategy.SORTMERGE,outGp,outLp,estimator);
  }
}","/** 
 * Private utility method that generates the alternative Match nodes, given fixed shipping strategies for the inputs.
 * @param target The list to put the alternatives in.
 * @param pred1 The predecessor node for the first input.
 * @param pred2 The predecessor node for the second input.
 * @param ss1 The shipping strategy for the first input.
 * @param ss2 The shipping strategy for the second input.
 * @param estimator The cost estimator.
 */
private void createLocalAlternatives(List<MatchNode> target,OptimizerNode pred1,OptimizerNode pred2,ShipStrategy ss1,ShipStrategy ss2,CostEstimator estimator){
  GlobalProperties gp1=PactConnection.getGlobalPropertiesAfterConnection(pred1,this,ss1);
  GlobalProperties gp2=PactConnection.getGlobalPropertiesAfterConnection(pred2,this,ss2);
  LocalProperties lp1=PactConnection.getLocalPropertiesAfterConnection(pred1,this,ss1);
  LocalProperties lp2=PactConnection.getLocalPropertiesAfterConnection(pred2,this,ss2);
  GlobalProperties outGp=new GlobalProperties();
  outGp.setPartitioning(gp1.getPartitioning().isComputablyPartitioned() ? gp1.getPartitioning() : gp2.getPartitioning());
  outGp.setKeyOrder(gp1.getKeyOrder().isOrdered() ? gp1.getKeyOrder() : gp2.getKeyOrder());
  LocalProperties outLp=new LocalProperties();
  outLp.setKeyOrder(lp1.getKeyOrder().isOrdered() && lp1.getKeyOrder() == lp2.getKeyOrder() ? lp1.getKeyOrder() : Order.NONE);
  outLp.setKeysGrouped(outLp.getKeyOrder().isOrdered());
  LocalStrategy ls=getLocalStrategy();
  if (ls != LocalStrategy.NONE) {
    if (ls == LocalStrategy.SORTMERGE) {
      outLp.setKeyOrder(Order.ASCENDING);
      outLp.setKeysGrouped(true);
    }
 else     if (ls == LocalStrategy.HYBRIDHASH_FIRST || ls == LocalStrategy.HYBRIDHASH_SECOND || ls == LocalStrategy.MMHASH_FIRST || ls == LocalStrategy.MMHASH_SECOND) {
      outLp.setKeyOrder(Order.NONE);
      outLp.setKeysGrouped(false);
    }
    createMatchAlternative(target,pred1,pred2,ss1,ss2,ls,outGp,outLp,estimator);
  }
 else   if (outLp.getKeyOrder().isOrdered()) {
    createMatchAlternative(target,pred1,pred2,ss1,ss2,LocalStrategy.NONE,outGp,outLp,estimator);
  }
 else   if (lp1.getKeyOrder().isOrdered() || lp2.getKeyOrder().isOrdered()) {
    outLp.setKeyOrder(lp1.getKeyOrder().isOrdered() ? lp1.getKeyOrder() : lp2.getKeyOrder());
    outLp.setKeysGrouped(true);
    createMatchAlternative(target,pred1,pred2,ss1,ss2,LocalStrategy.SORTMERGE,outGp,outLp,estimator);
  }
 else {
    if (pred1.estimatedOutputSize > 0 && pred2.estimatedOutputSize > 0) {
      createMatchAlternative(target,pred1,pred2,ss1,ss2,LocalStrategy.HYBRIDHASH_FIRST,outGp.createCopy(),outLp.createCopy(),estimator);
      createMatchAlternative(target,pred1,pred2,ss1,ss2,LocalStrategy.HYBRIDHASH_SECOND,outGp.createCopy(),outLp.createCopy(),estimator);
    }
    outLp.setKeyOrder(Order.ASCENDING);
    outLp.setKeysGrouped(true);
    createMatchAlternative(target,pred1,pred2,ss1,ss2,LocalStrategy.SORTMERGE,outGp,outLp,estimator);
  }
}"
88317,"public void read() throws IOException, EOFException {
  if (!isActiveConnection()) {
    System.out.println(""String_Node_Str"");
    return;
  }
  this.deserializer.read(this.readableByteChannel);
  final TransferEnvelope transferEnvelope=this.deserializer.getFullyDeserializedTransferEnvelope();
  if (transferEnvelope != null) {
    this.byteBufferedChannelManager.queueIncomingTransferEnvelope(transferEnvelope);
  }
}","public void read() throws IOException, EOFException {
  if (this.inactiveConnection) {
    final ByteBuffer buf=ByteBuffer.allocate(8);
    final int bytesRead=this.readableByteChannel.read(buf);
    if (bytesRead == 0) {
      return;
    }
 else     if (bytesRead == -1) {
      throw new EOFException();
    }
 else {
      throw new IOException(""String_Node_Str"" + bytesRead + ""String_Node_Str"");
    }
  }
  this.deserializer.read(this.readableByteChannel);
  final TransferEnvelope transferEnvelope=this.deserializer.getFullyDeserializedTransferEnvelope();
  if (transferEnvelope != null) {
    this.byteBufferedChannelManager.queueIncomingTransferEnvelope(transferEnvelope);
  }
}"
88318,"public void reportTransmissionProblem(SelectionKey key,IOException ioe){
  if (!this.readsFromCheckpoint) {
    final SocketChannel socketChannel=(SocketChannel)this.readableByteChannel;
    LOG.error(""String_Node_Str"" + socketChannel.socket().getRemoteSocketAddress() + ""String_Node_Str"");
  }
  LOG.error(ioe);
  try {
    this.readableByteChannel.close();
  }
 catch (  IOException e) {
    LOG.debug(""String_Node_Str"");
  }
  if (key != null) {
    key.cancel();
  }
  if (this.deserializer.getBuffer() != null) {
    this.deserializer.getBuffer().recycleBuffer();
  }
  this.deserializer.reset();
  this.byteBufferedChannelManager.unregisterIncomingConnection(this.incomingConnectionID,this.readableByteChannel);
}","public void reportTransmissionProblem(SelectionKey key,IOException ioe){
  if (!this.readsFromCheckpoint) {
    final SocketChannel socketChannel=(SocketChannel)this.readableByteChannel;
    LOG.error(""String_Node_Str"" + socketChannel.socket().getRemoteSocketAddress() + ""String_Node_Str"");
  }
  LOG.error(ioe);
  try {
    this.readableByteChannel.close();
  }
 catch (  IOException e) {
    LOG.debug(""String_Node_Str"");
  }
  if (key != null) {
    key.cancel();
  }
  if (this.deserializer.getBuffer() != null) {
    this.deserializer.getBuffer().recycleBuffer();
  }
  this.deserializer.reset();
  if (!this.inactiveConnection) {
    this.byteBufferedChannelManager.unregisterIncomingConnection(this.incomingConnectionID,this.readableByteChannel);
  }
}"
88319,"public void closeConnection(SelectionKey key){
  try {
    this.readableByteChannel.close();
  }
 catch (  IOException ioe) {
    LOG.error(""String_Node_Str"" + StringUtils.stringifyException(ioe));
  }
  if (key != null) {
    key.cancel();
  }
  this.byteBufferedChannelManager.unregisterIncomingConnection(this.incomingConnectionID,this.readableByteChannel);
}","public void closeConnection(SelectionKey key){
  try {
    this.readableByteChannel.close();
  }
 catch (  IOException ioe) {
    LOG.error(""String_Node_Str"" + StringUtils.stringifyException(ioe));
  }
  if (key != null) {
    key.cancel();
  }
  if (!this.inactiveConnection) {
    this.byteBufferedChannelManager.unregisterIncomingConnection(this.incomingConnectionID,this.readableByteChannel);
  }
}"
88320,"/** 
 * Sets the shipping strategy for this connection.
 * @param strategy The shipping strategy to be applied to this connection.
 */
public void setShipStrategy(ShipStrategy strategy){
  if (strategy == ShipStrategy.FORWARD && sourcePact.getDegreeOfParallelism() < targetPact.getDegreeOfParallelism()) {
    for (    InterestingProperties props : this.interestingProps) {
      PartitionProperty pp=props.getGlobalProperties().getPartitioning();
      if (pp == PartitionProperty.HASH_PARTITIONED || pp == PartitionProperty.ANY) {
        strategy=ShipStrategy.PARTITION_LOCAL_HASH;
        break;
      }
 else       if (pp == PartitionProperty.RANGE_PARTITIONED) {
        throw new CompilerException(""String_Node_Str"" + ""String_Node_Str"");
      }
    }
  }
  this.shipStrategy=strategy;
}","/** 
 * Sets the shipping strategy for this connection.
 * @param strategy The shipping strategy to be applied to this connection.
 */
public void setShipStrategy(ShipStrategy strategy){
  if (strategy == ShipStrategy.FORWARD && sourcePact.getDegreeOfParallelism() < targetPact.getDegreeOfParallelism()) {
    if (this.interestingProps != null) {
      for (      InterestingProperties props : this.interestingProps) {
        PartitionProperty pp=props.getGlobalProperties().getPartitioning();
        if (pp == PartitionProperty.HASH_PARTITIONED || pp == PartitionProperty.ANY) {
          strategy=ShipStrategy.PARTITION_LOCAL_HASH;
          break;
        }
 else         if (pp == PartitionProperty.RANGE_PARTITIONED) {
          throw new CompilerException(""String_Node_Str"" + ""String_Node_Str"");
        }
      }
    }
  }
  this.shipStrategy=strategy;
}"
88321,"/** 
 * {@inheritDoc}
 */
@SuppressWarnings(""String_Node_Str"") @Override public void read(DataInput in) throws IOException {
  this.jobID=new JobID();
  this.jobID.read(in);
  this.taskName=StringRecord.readString(in);
  final String[] requiredJarFiles=new String[in.readInt()];
  for (int i=0; i < requiredJarFiles.length; i++) {
    requiredJarFiles[i]=StringRecord.readString(in);
  }
  LibraryCacheManager.register(this.jobID,requiredJarFiles);
  final ClassLoader cl=LibraryCacheManager.getClassLoader(this.jobID);
  final String invokableClassName=StringRecord.readString(in);
  if (invokableClassName == null) {
    throw new IOException(""String_Node_Str"");
  }
  try {
    this.invokableClass=(Class<? extends AbstractInvokable>)Class.forName(invokableClassName,true,cl);
  }
 catch (  ClassNotFoundException cnfe) {
    throw new IOException(""String_Node_Str"" + invokableClassName + ""String_Node_Str""+ StringUtils.stringifyException(cnfe));
  }
  final int numOuputGates=in.readInt();
  for (int i=0; i < numOuputGates; i++) {
    final String typeClassName=StringRecord.readString(in);
    Class<? extends Record> type=null;
    try {
      type=(Class<? extends Record>)Class.forName(typeClassName,true,cl);
    }
 catch (    ClassNotFoundException cnfe) {
      throw new IOException(""String_Node_Str"" + typeClassName + ""String_Node_Str""+ StringUtils.stringifyException(cnfe));
    }
    final boolean isBroadcast=in.readBoolean();
    ChannelSelector<? extends Record> channelSelector=null;
    if (!isBroadcast) {
      final String channelSelectorClassName=StringRecord.readString(in);
      try {
        channelSelector=(ChannelSelector<? extends Record>)Class.forName(channelSelectorClassName,true,cl).newInstance();
      }
 catch (      InstantiationException e) {
        throw new IOException(StringUtils.stringifyException(e));
      }
catch (      IllegalAccessException e) {
        throw new IOException(StringUtils.stringifyException(e));
      }
catch (      ClassNotFoundException e) {
        throw new IOException(StringUtils.stringifyException(e));
      }
    }
    channelSelector.read(in);
    @SuppressWarnings(""String_Node_Str"") final OutputGate<? extends Record> eog=new OutputGate(this.jobID,type,i,channelSelector,isBroadcast);
    eog.read(in);
    this.outputGates.add(eog);
    this.unboundOutputGates.add(eog);
  }
  final int numInputGates=in.readInt();
  for (int i=0; i < numInputGates; i++) {
    final String deserializerClassName=StringRecord.readString(in);
    RecordDeserializer<? extends Record> recordDeserializer=null;
    Class<? extends RecordDeserializer<? extends Record>> deserializerClass=null;
    try {
      deserializerClass=(Class<? extends RecordDeserializer<? extends Record>>)cl.loadClass(deserializerClassName);
      recordDeserializer=deserializerClass.newInstance();
    }
 catch (    ClassNotFoundException e) {
      throw new IOException(StringUtils.stringifyException(e));
    }
catch (    InstantiationException e) {
      throw new IOException(StringUtils.stringifyException(e));
    }
catch (    IllegalAccessException e) {
      throw new IOException(StringUtils.stringifyException(e));
    }
    recordDeserializer.setClassLoader(cl);
    recordDeserializer.read(in);
    final String distributionPatternClassName=StringRecord.readString(in);
    DistributionPattern distributionPattern=null;
    Class<? extends DistributionPattern> distributionPatternClass=null;
    try {
      distributionPatternClass=(Class<? extends DistributionPattern>)cl.loadClass(distributionPatternClassName);
      distributionPattern=distributionPatternClass.newInstance();
    }
 catch (    ClassNotFoundException e) {
      throw new IOException(StringUtils.stringifyException(e));
    }
catch (    InstantiationException e) {
      throw new IOException(StringUtils.stringifyException(e));
    }
catch (    IllegalAccessException e) {
      throw new IOException(StringUtils.stringifyException(e));
    }
    @SuppressWarnings(""String_Node_Str"") final InputGate<? extends Record> eig=new InputGate(this.jobID,recordDeserializer,i,distributionPattern);
    eig.read(in);
    this.inputGates.add(eig);
    this.unboundInputGates.add(eig);
  }
  final int numInputSplits=in.readInt();
  for (int i=0; i < numInputSplits; i++) {
    final boolean isNotNull=in.readBoolean();
    if (isNotNull) {
      final String className=StringRecord.readString(in);
      Class<? extends IOReadableWritable> c=null;
      try {
        c=(Class<? extends IOReadableWritable>)Class.forName(className,true,cl);
      }
 catch (      ClassNotFoundException cnfe) {
        throw new IOException(""String_Node_Str"" + className + ""String_Node_Str""+ StringUtils.stringifyException(cnfe));
      }
      try {
        final InputSplit inputSplit=(InputSplit)c.newInstance();
        inputSplit.read(in);
        this.inputSplits.add(inputSplit);
      }
 catch (      InstantiationException e) {
        throw new IOException(e);
      }
catch (      IllegalAccessException e) {
        throw new IOException(e);
      }
    }
  }
  this.runtimeConfiguration=new Configuration();
  this.runtimeConfiguration.read(in);
  this.currentNumberOfSubtasks=in.readInt();
  this.indexInSubtaskGroup=in.readInt();
  this.executionState=EnumUtils.readEnum(in,ExecutionState.class);
  try {
    instantiateInvokable();
  }
 catch (  Exception e) {
    throw new IOException(StringUtils.stringifyException(e));
  }
}","/** 
 * {@inheritDoc}
 */
@SuppressWarnings(""String_Node_Str"") @Override public void read(DataInput in) throws IOException {
  this.jobID=new JobID();
  this.jobID.read(in);
  this.taskName=StringRecord.readString(in);
  final String[] requiredJarFiles=new String[in.readInt()];
  for (int i=0; i < requiredJarFiles.length; i++) {
    requiredJarFiles[i]=StringRecord.readString(in);
  }
  LibraryCacheManager.register(this.jobID,requiredJarFiles);
  final ClassLoader cl=LibraryCacheManager.getClassLoader(this.jobID);
  final String invokableClassName=StringRecord.readString(in);
  if (invokableClassName == null) {
    throw new IOException(""String_Node_Str"");
  }
  try {
    this.invokableClass=(Class<? extends AbstractInvokable>)Class.forName(invokableClassName,true,cl);
  }
 catch (  ClassNotFoundException cnfe) {
    throw new IOException(""String_Node_Str"" + invokableClassName + ""String_Node_Str""+ StringUtils.stringifyException(cnfe));
  }
  final int numOuputGates=in.readInt();
  for (int i=0; i < numOuputGates; i++) {
    final String typeClassName=StringRecord.readString(in);
    Class<? extends Record> type=null;
    try {
      type=(Class<? extends Record>)Class.forName(typeClassName,true,cl);
    }
 catch (    ClassNotFoundException cnfe) {
      throw new IOException(""String_Node_Str"" + typeClassName + ""String_Node_Str""+ StringUtils.stringifyException(cnfe));
    }
    final boolean isBroadcast=in.readBoolean();
    ChannelSelector<? extends Record> channelSelector=null;
    if (!isBroadcast) {
      final String channelSelectorClassName=StringRecord.readString(in);
      try {
        channelSelector=(ChannelSelector<? extends Record>)Class.forName(channelSelectorClassName,true,cl).newInstance();
      }
 catch (      InstantiationException e) {
        throw new IOException(StringUtils.stringifyException(e));
      }
catch (      IllegalAccessException e) {
        throw new IOException(StringUtils.stringifyException(e));
      }
catch (      ClassNotFoundException e) {
        throw new IOException(StringUtils.stringifyException(e));
      }
      channelSelector.read(in);
    }
    @SuppressWarnings(""String_Node_Str"") final OutputGate<? extends Record> eog=new OutputGate(this.jobID,type,i,channelSelector,isBroadcast);
    eog.read(in);
    this.outputGates.add(eog);
    this.unboundOutputGates.add(eog);
  }
  final int numInputGates=in.readInt();
  for (int i=0; i < numInputGates; i++) {
    final String deserializerClassName=StringRecord.readString(in);
    RecordDeserializer<? extends Record> recordDeserializer=null;
    Class<? extends RecordDeserializer<? extends Record>> deserializerClass=null;
    try {
      deserializerClass=(Class<? extends RecordDeserializer<? extends Record>>)cl.loadClass(deserializerClassName);
      recordDeserializer=deserializerClass.newInstance();
    }
 catch (    ClassNotFoundException e) {
      throw new IOException(StringUtils.stringifyException(e));
    }
catch (    InstantiationException e) {
      throw new IOException(StringUtils.stringifyException(e));
    }
catch (    IllegalAccessException e) {
      throw new IOException(StringUtils.stringifyException(e));
    }
    recordDeserializer.setClassLoader(cl);
    recordDeserializer.read(in);
    final String distributionPatternClassName=StringRecord.readString(in);
    DistributionPattern distributionPattern=null;
    Class<? extends DistributionPattern> distributionPatternClass=null;
    try {
      distributionPatternClass=(Class<? extends DistributionPattern>)cl.loadClass(distributionPatternClassName);
      distributionPattern=distributionPatternClass.newInstance();
    }
 catch (    ClassNotFoundException e) {
      throw new IOException(StringUtils.stringifyException(e));
    }
catch (    InstantiationException e) {
      throw new IOException(StringUtils.stringifyException(e));
    }
catch (    IllegalAccessException e) {
      throw new IOException(StringUtils.stringifyException(e));
    }
    @SuppressWarnings(""String_Node_Str"") final InputGate<? extends Record> eig=new InputGate(this.jobID,recordDeserializer,i,distributionPattern);
    eig.read(in);
    this.inputGates.add(eig);
    this.unboundInputGates.add(eig);
  }
  final int numInputSplits=in.readInt();
  for (int i=0; i < numInputSplits; i++) {
    final boolean isNotNull=in.readBoolean();
    if (isNotNull) {
      final String className=StringRecord.readString(in);
      Class<? extends IOReadableWritable> c=null;
      try {
        c=(Class<? extends IOReadableWritable>)Class.forName(className,true,cl);
      }
 catch (      ClassNotFoundException cnfe) {
        throw new IOException(""String_Node_Str"" + className + ""String_Node_Str""+ StringUtils.stringifyException(cnfe));
      }
      try {
        final InputSplit inputSplit=(InputSplit)c.newInstance();
        inputSplit.read(in);
        this.inputSplits.add(inputSplit);
      }
 catch (      InstantiationException e) {
        throw new IOException(e);
      }
catch (      IllegalAccessException e) {
        throw new IOException(e);
      }
    }
  }
  this.runtimeConfiguration=new Configuration();
  this.runtimeConfiguration.read(in);
  this.currentNumberOfSubtasks=in.readInt();
  this.indexInSubtaskGroup=in.readInt();
  this.executionState=EnumUtils.readEnum(in,ExecutionState.class);
  try {
    instantiateInvokable();
  }
 catch (  Exception e) {
    throw new IOException(StringUtils.stringifyException(e));
  }
}"
88322,"/** 
 * Requests all output gates to be closed.
 */
private void requestAllOutputGatesToClose() throws IOException {
  for (int i=0; i < getNumberOfOutputGates(); i++) {
    this.getOutputGate(i).requestClose();
  }
}","/** 
 * Requests all output gates to be closed.
 */
private void requestAllOutputGatesToClose() throws IOException, InterruptedException {
  for (int i=0; i < getNumberOfOutputGates(); i++) {
    this.getOutputGate(i).requestClose();
  }
}"
88323,"/** 
 * Publishes an event.
 * @param event the event to be published
 * @throws IOException thrown if an error occurs while transmitting the event
 */
public void publishEvent(AbstractTaskEvent event) throws IOException {
  Iterator<AbstractInputChannel<T>> it=this.inputChannels.iterator();
  while (it.hasNext()) {
    it.next().transferEvent(event);
  }
}","/** 
 * Publishes an event.
 * @param event the event to be published
 * @throws IOException thrown if an error occurs while transmitting the event
 * @throws InterruptedException thrown if the thread is interrupted while waiting for the event to be published
 */
public void publishEvent(AbstractTaskEvent event) throws IOException, InterruptedException {
  Iterator<AbstractInputChannel<T>> it=this.inputChannels.iterator();
  while (it.hasNext()) {
    it.next().transferEvent(event);
  }
}"
88324,"/** 
 * Requests the output gate to closed. This means the application will send no records through this gate anymore.
 */
public void requestClose() throws IOException {
  for (int i=0; i < this.getNumberOfOutputChannels(); i++) {
    final AbstractOutputChannel<T> outputChannel=this.getOutputChannel(i);
    outputChannel.requestClose();
  }
}","/** 
 * Requests the output gate to closed. This means the application will send no records through this gate anymore.
 */
public void requestClose() throws IOException, InterruptedException {
  for (int i=0; i < this.getNumberOfOutputChannels(); i++) {
    final AbstractOutputChannel<T> outputChannel=this.getOutputChannel(i);
    outputChannel.requestClose();
  }
}"
88325,"public void flush() throws IOException {
  final Iterator<AbstractOutputChannel<T>> it=this.outputChannels.iterator();
  while (it.hasNext()) {
    it.next().flush();
  }
}","public void flush() throws IOException, InterruptedException {
  final Iterator<AbstractOutputChannel<T>> it=this.outputChannels.iterator();
  while (it.hasNext()) {
    it.next().flush();
  }
}"
88326,"/** 
 * Publishes an event.
 * @param event the event to be published
 * @throws IOException thrown if an error occurs while transmitting the event
 */
public void publishEvent(AbstractTaskEvent event) throws IOException {
  final Iterator<AbstractOutputChannel<T>> it=this.outputChannels.iterator();
  while (it.hasNext()) {
    it.next().transferEvent(event);
  }
}","/** 
 * Publishes an event.
 * @param event the event to be published
 * @throws IOException thrown if an error occurs while transmitting the event
 * @throws InterruptedException thrown if the thread is interrupted while waiting for the event to be published
 */
public void publishEvent(AbstractTaskEvent event) throws IOException, InterruptedException {
  final Iterator<AbstractOutputChannel<T>> it=this.outputChannels.iterator();
  while (it.hasNext()) {
    it.next().transferEvent(event);
  }
}"
88327,"/** 
 * Publishes an event.
 * @param event the event to be published
 * @throws IOException thrown if an error occurs while transmitting the event
 */
public void publishEvent(AbstractTaskEvent event) throws IOException {
  this.inputGate.publishEvent(event);
}","/** 
 * Publishes an event.
 * @param event the event to be published
 * @throws IOException thrown if an error occurs while transmitting the event
 * @throws InterruptedException thrown if the thread is interrupted while waiting for the event to be published
 */
public void publishEvent(AbstractTaskEvent event) throws IOException, InterruptedException {
  this.inputGate.publishEvent(event);
}"
88328,"public void flush() throws IOException {
  this.outputGate.flush();
}","public void flush() throws IOException, InterruptedException {
  this.outputGate.flush();
}"
88329,"/** 
 * Publishes an event.
 * @param event the event to be published
 * @throws IOException thrown if an error occurs while transmitting the event
 */
public void publishEvent(AbstractTaskEvent event) throws IOException {
  this.outputGate.publishEvent(event);
}","/** 
 * Publishes an event.
 * @param event the event to be published
 * @throws IOException thrown if an error occurs while transmitting the event
 * @throws InterruptedException thrown if the thread is interrupted while waiting for the event to be published
 */
public void publishEvent(AbstractTaskEvent event) throws IOException, InterruptedException {
  this.outputGate.publishEvent(event);
}"
88330,"/** 
 * Connects a record writer to an output gate.
 * @param outputClass the class of the record that can be emitted with this record writer
 */
@SuppressWarnings(""String_Node_Str"") private void connectOutputGate(Class<T> outputClass,ChannelSelector selector){
  if (this.environment.hasUnboundOutputGates()) {
    final OutputGate<T> eog=(OutputGate<T>)this.environment.getUnboundOutputGate(0);
    if (!outputClass.equals(eog.getType())) {
      throw new RuntimeException(""String_Node_Str"");
    }
    this.outputGate=eog;
  }
 else {
    this.outputGate=new OutputGate<T>(outputClass,this.environment.getNumberOfOutputGates(),selector);
    this.environment.registerOutputGate(this.outputGate);
  }
}","/** 
 * Connects a record writer to an output gate.
 * @param outputClass the class of the record that can be emitted with this record writer
 */
@SuppressWarnings(""String_Node_Str"") private void connectOutputGate(Class<T> outputClass,ChannelSelector<T> selector){
  if (this.environment.hasUnboundOutputGates()) {
    final OutputGate<T> eog=(OutputGate<T>)this.environment.getUnboundOutputGate(0);
    if (!outputClass.equals(eog.getType())) {
      throw new RuntimeException(""String_Node_Str"");
    }
    this.outputGate=eog;
  }
 else {
    this.outputGate=new OutputGate<T>(outputClass,this.environment.getNumberOfOutputGates(),selector);
    this.environment.registerOutputGate(this.outputGate);
  }
}"
88331,public abstract void transferEvent(AbstractEvent event) throws IOException ;,"public abstract void transferEvent(AbstractEvent event) throws IOException, InterruptedException ;"
88332,public abstract void flush() throws IOException ;,"public abstract void flush() throws IOException, InterruptedException ;"
88333,"/** 
 * Requests the output channel to close. After calling this method no more records can be written to the channel. The channel is finally closed when all remaining data that may exist in internal buffers are written to the channel.
 */
public abstract void requestClose() throws IOException ;","/** 
 * Requests the output channel to close. After calling this method no more records can be written to the channel. The channel is finally closed when all remaining data that may exist in internal buffers are written to the channel.
 * @throws IOException thrown if an I/O error occurs while requesting the channel to close
 * @throws InterruptedException thrown if the thread is interrupted while requesting the channel to close
 */
public abstract void requestClose() throws IOException, InterruptedException ;"
88334,"@SuppressWarnings(""String_Node_Str"") private AbstractDirectInputChannel<T> getConnectedInputChannel() throws IOException {
  AbstractDirectInputChannel<T> directInputChannel=null;
  if (this.directChannelBroker == null) {
    throw new IOException(""String_Node_Str"");
  }
  for (int i=0; i < this.numberOfConnectionRetries; i++) {
    directInputChannel=(AbstractDirectInputChannel<T>)this.directChannelBroker.getDirectInputChannelByID(getConnectedChannelID());
    if (directInputChannel != null) {
      return directInputChannel;
    }
    try {
      Thread.sleep(CONNECTION_SLEEP_INTERVAL);
    }
 catch (    InterruptedException e) {
      LOG.error(e);
    }
  }
  throw new IOException(""String_Node_Str"" + getID());
}","@SuppressWarnings(""String_Node_Str"") private AbstractDirectInputChannel<T> getConnectedInputChannel() throws IOException, InterruptedException {
  AbstractDirectInputChannel<T> directInputChannel=null;
  if (this.directChannelBroker == null) {
    throw new IOException(""String_Node_Str"");
  }
  for (int i=0; i < this.numberOfConnectionRetries; i++) {
    directInputChannel=(AbstractDirectInputChannel<T>)this.directChannelBroker.getDirectInputChannelByID(getConnectedChannelID());
    if (directInputChannel != null) {
      return directInputChannel;
    }
    Thread.sleep(CONNECTION_SLEEP_INTERVAL);
  }
  throw new IOException(""String_Node_Str"" + getID());
}"
88335,"@Override public void flush() throws IOException {
  if (this.connectedDirectInputChannel == null) {
    this.connectedDirectInputChannel=getConnectedInputChannel();
  }
  this.connectedDirectInputChannel.requestFlush();
}","@Override public void flush() throws IOException, InterruptedException {
  if (this.connectedDirectInputChannel == null) {
    this.connectedDirectInputChannel=getConnectedInputChannel();
  }
  this.connectedDirectInputChannel.requestFlush();
}"
88336,"@Override public void transferEvent(AbstractEvent event) throws IOException {
  if (this.connectedDirectInputChannel == null) {
    this.connectedDirectInputChannel=getConnectedInputChannel();
  }
  this.connectedDirectInputChannel.processEvent(event);
}","@Override public void transferEvent(AbstractEvent event) throws IOException, InterruptedException {
  if (this.connectedDirectInputChannel == null) {
    this.connectedDirectInputChannel=getConnectedInputChannel();
  }
  this.connectedDirectInputChannel.processEvent(event);
}"
88337,"/** 
 * {@inheritDoc}
 */
@Override public void requestClose(){
  this.closeRequested=true;
  if (this.connectedDirectInputChannel == null) {
    try {
      this.connectedDirectInputChannel=getConnectedInputChannel();
    }
 catch (    IOException e) {
      this.connectionFailureException=e;
      return;
    }
  }
  this.connectedDirectInputChannel.requestClose();
}","/** 
 * {@inheritDoc}
 */
@Override public void requestClose() throws InterruptedException {
  this.closeRequested=true;
  if (this.connectedDirectInputChannel == null) {
    try {
      this.connectedDirectInputChannel=getConnectedInputChannel();
    }
 catch (    IOException e) {
      this.connectionFailureException=e;
      return;
    }
  }
  this.connectedDirectInputChannel.requestClose();
}"
88338,"/** 
 * This test checks the correct registration/deregistration of   {@link AbstractDirectInputChannel} and{@link AbstractDirectOutputChannel} objects.
 */
@Test public void testDirectChannelManager(){
  final DirectChannelManager dcm=new DirectChannelManager();
  when(this.deserializer.getRecordType()).thenReturn(StringRecord.class);
  final InMemoryInputChannel<StringRecord> inputChannel=new InMemoryInputChannel<StringRecord>(this.inputGate,0,this.deserializer,this.inputChannelID,CompressionLevel.NO_COMPRESSION);
  final InMemoryOutputChannel<StringRecord> outputChannel=new InMemoryOutputChannel<StringRecord>(this.outputGate,0,this.outputChannelID,CompressionLevel.NO_COMPRESSION);
  inputChannel.setConnectedChannelID(this.outputChannelID);
  outputChannel.setConnectedChannelID(this.inputChannelID);
  dcm.registerDirectInputChannel(inputChannel);
  dcm.registerDirectOutputChannel(outputChannel);
  try {
    outputChannel.transferEvent(new StringTaskEvent(""String_Node_Str""));
  }
 catch (  IOException ioe) {
    fail(ioe.getMessage());
  }
  assertEquals(inputChannel,dcm.getDirectInputChannelByID(this.inputChannelID));
  assertEquals(outputChannel,dcm.getDirectOutputChannelByID(this.outputChannelID));
  dcm.unregisterDirectInputChannel(inputChannel);
  dcm.unregisterDirectOutputChannel(outputChannel);
  assertEquals(null,dcm.getDirectInputChannelByID(this.inputChannelID));
  assertEquals(null,dcm.getDirectOutputChannelByID(this.outputChannelID));
}","/** 
 * This test checks the correct registration/deregistration of   {@link AbstractDirectInputChannel} and{@link AbstractDirectOutputChannel} objects.
 */
@Test public void testDirectChannelManager(){
  final DirectChannelManager dcm=new DirectChannelManager();
  when(this.deserializer.getRecordType()).thenReturn(StringRecord.class);
  final InMemoryInputChannel<StringRecord> inputChannel=new InMemoryInputChannel<StringRecord>(this.inputGate,0,this.deserializer,this.inputChannelID,CompressionLevel.NO_COMPRESSION);
  final InMemoryOutputChannel<StringRecord> outputChannel=new InMemoryOutputChannel<StringRecord>(this.outputGate,0,this.outputChannelID,CompressionLevel.NO_COMPRESSION);
  inputChannel.setConnectedChannelID(this.outputChannelID);
  outputChannel.setConnectedChannelID(this.inputChannelID);
  dcm.registerDirectInputChannel(inputChannel);
  dcm.registerDirectOutputChannel(outputChannel);
  try {
    outputChannel.transferEvent(new StringTaskEvent(""String_Node_Str""));
  }
 catch (  IOException ioe) {
    fail(ioe.getMessage());
  }
catch (  InterruptedException ie) {
    fail(ie.getMessage());
  }
  assertEquals(inputChannel,dcm.getDirectInputChannelByID(this.inputChannelID));
  assertEquals(outputChannel,dcm.getDirectOutputChannelByID(this.outputChannelID));
  dcm.unregisterDirectInputChannel(inputChannel);
  dcm.unregisterDirectOutputChannel(outputChannel);
  assertEquals(null,dcm.getDirectInputChannelByID(this.inputChannelID));
  assertEquals(null,dcm.getDirectOutputChannelByID(this.outputChannelID));
}"
88339,"/** 
 * Blocks until all output channels are closed.
 * @throws IOException thrown if an error occurred while closing the output channels
 */
private void waitForOutputChannelsToBeClosed() throws IOException {
  while (true) {
    boolean allClosed=true;
    for (int i=0; i < getNumberOfOutputGates(); i++) {
      final OutputGate<? extends Record> eog=getOutputGate(i);
      if (!eog.isClosed()) {
        allClosed=false;
      }
    }
    if (allClosed) {
      break;
    }
 else {
      try {
        Thread.sleep(SLEEPINTERVAL);
      }
 catch (      InterruptedException e) {
        LOG.debug(e);
      }
    }
  }
}","/** 
 * Blocks until all output channels are closed.
 * @throws IOException thrown if an error occurred while closing the output channels
 * @throws InterruptedException thrown if the thread waiting for the channels to be closed is interrupted
 */
private void waitForOutputChannelsToBeClosed() throws IOException, InterruptedException {
  while (true) {
    if (this.isCanceled) {
      throw new InterruptedException();
    }
    boolean allClosed=true;
    for (int i=0; i < getNumberOfOutputGates(); i++) {
      final OutputGate<? extends Record> eog=getOutputGate(i);
      if (!eog.isClosed()) {
        allClosed=false;
      }
    }
    if (allClosed) {
      break;
    }
 else {
      Thread.sleep(SLEEPINTERVAL);
    }
  }
}"
88340,"/** 
 * {@inheritDoc}
 */
@Override public void run(){
  if (invokable == null) {
    LOG.fatal(""String_Node_Str"");
  }
  changeExecutionState(ExecutionState.RUNNING,null);
  try {
    this.invokable.invoke();
    if (this.isCanceled) {
      throw new InterruptedException();
    }
  }
 catch (  Exception e) {
    if (!this.isCanceled) {
      try {
        this.invokable.cancel();
      }
 catch (      Exception e2) {
        LOG.error(StringUtils.stringifyException(e2));
      }
    }
    if (this.isCanceled) {
      changeExecutionState(ExecutionState.CANCELED,null);
    }
 else {
      changeExecutionState(ExecutionState.FAILED,StringUtils.stringifyException(e));
    }
    return;
  }
  changeExecutionState(ExecutionState.FINISHING,null);
  try {
    closeInputGates();
    requestAllOutputGatesToClose();
    waitForInputChannelsToBeClosed();
    waitForOutputChannelsToBeClosed();
  }
 catch (  Exception e) {
    changeExecutionState(ExecutionState.FAILED,StringUtils.stringifyException(e));
    return;
  }
  changeExecutionState(ExecutionState.FINISHED,null);
}","/** 
 * {@inheritDoc}
 */
@Override public void run(){
  if (invokable == null) {
    LOG.fatal(""String_Node_Str"");
  }
  changeExecutionState(ExecutionState.RUNNING,null);
  try {
    this.invokable.invoke();
    if (this.isCanceled) {
      throw new InterruptedException();
    }
  }
 catch (  Exception e) {
    if (!this.isCanceled) {
      try {
        this.invokable.cancel();
      }
 catch (      Exception e2) {
        LOG.error(StringUtils.stringifyException(e2));
      }
    }
    if (this.isCanceled) {
      changeExecutionState(ExecutionState.CANCELED,null);
    }
 else {
      changeExecutionState(ExecutionState.FAILED,StringUtils.stringifyException(e));
    }
    return;
  }
  changeExecutionState(ExecutionState.FINISHING,null);
  try {
    closeInputGates();
    requestAllOutputGatesToClose();
    waitForInputChannelsToBeClosed();
    waitForOutputChannelsToBeClosed();
  }
 catch (  Exception e) {
    if (this.isCanceled) {
      changeExecutionState(ExecutionState.CANCELED,null);
    }
 else {
      changeExecutionState(ExecutionState.FAILED,StringUtils.stringifyException(e));
    }
    return;
  }
  changeExecutionState(ExecutionState.FINISHED,null);
}"
88341,"/** 
 * Blocks until all input channels are closed.
 * @throws IOException thrown if an error occurred while closing the input channels
 */
private void waitForInputChannelsToBeClosed() throws IOException {
  while (true) {
    boolean allClosed=true;
    for (int i=0; i < getNumberOfInputGates(); i++) {
      final InputGate<? extends Record> eig=getInputGate(i);
      if (!eig.isClosed()) {
        allClosed=false;
      }
    }
    if (allClosed) {
      break;
    }
 else {
      try {
        Thread.sleep(SLEEPINTERVAL);
      }
 catch (      InterruptedException e) {
        LOG.debug(e);
      }
    }
  }
}","/** 
 * Blocks until all input channels are closed.
 * @throws IOException thrown if an error occurred while closing the input channels
 * @throws InterruptedException thrown if the thread waiting for the channels to be closed is interrupted
 */
private void waitForInputChannelsToBeClosed() throws IOException, InterruptedException {
  while (true) {
    if (this.isCanceled) {
      throw new InterruptedException();
    }
    boolean allClosed=true;
    for (int i=0; i < getNumberOfInputGates(); i++) {
      final InputGate<? extends Record> eig=getInputGate(i);
      if (!eig.isClosed()) {
        allClosed=false;
      }
    }
    if (allClosed) {
      break;
    }
 else {
      Thread.sleep(SLEEPINTERVAL);
    }
  }
}"
88342,"/** 
 * Entry point of the thread.
 */
public void go() throws Exception {
  final Channel.Enumerator enumerator=ioManager.createChannelEnumerator();
  List<Channel.ID> channelIDs=new ArrayList<Channel.ID>();
  outputSegments=memoryManager.allocate(UnilateralSortMerger.this.parent,2,ioMemorySize / 2);
  freeSegmentsAtShutdown(outputSegments);
  List<CircularElement> cache=new ArrayList<CircularElement>(buffersToKeepBeforeSpilling);
  CircularElement element=null;
  boolean cacheOnly=false;
  if (buffersToKeepBeforeSpilling > 0) {
    while (isRunning()) {
      if (cache.size() >= buffersToKeepBeforeSpilling) {
        cacheOnly=false;
        break;
      }
      element=queues.spill.take();
      cache.add(element);
      if (element == SENTINEL) {
        cacheOnly=true;
        break;
      }
    }
  }
  if (cacheOnly) {
    LOG.debug(""String_Node_Str"");
    List<Iterator<KeyValuePair<K,V>>> iterators=new ArrayList<Iterator<KeyValuePair<K,V>>>();
    for (    CircularElement cached : cache) {
      iterators.add(cached.buffer.getIterator());
    }
    LOG.debug(""String_Node_Str"");
    while (!queues.empty.isEmpty()) {
      memoryManager.release(queues.empty.take().buffer.unbind());
    }
    setResultIterator(new MergeIterator<K,V>(iterators,keyComparator));
  }
 else {
    LOG.debug(""String_Node_Str"");
    while (isRunning() && (element=takeNext(queues.spill,cache)) != SENTINEL) {
      Channel.ID channel=enumerator.next();
      channelIDs.add(channel);
      ChannelWriter writer=ioManager.createChannelWriter(channel,outputSegments);
      LOG.debug(""String_Node_Str"" + element.id + ""String_Node_Str"");
      element.buffer.writeToChannel(writer);
      LOG.debug(""String_Node_Str"" + element.id + ""String_Node_Str"");
      outputSegments=writer.close();
      element.buffer.reset();
      queues.empty.put(element);
    }
    LOG.debug(""String_Node_Str"");
    LOG.debug(""String_Node_Str"");
    memoryManager.release(outputSegments);
    LOG.debug(""String_Node_Str"");
    while (!queues.empty.isEmpty()) {
      memoryManager.release(queues.empty.take().buffer.unbind());
    }
    while (channelIDs.size() > maxNumFileHandles) {
      channelIDs=mergeChannelList(channelIDs,ioMemorySize);
    }
    setResultIterator(getMergingIterator(channelIDs,ioMemorySize));
  }
  LOG.debug(""String_Node_Str"");
}","/** 
 * Entry point of the thread.
 */
public void go() throws Exception {
  List<CircularElement> cache=new ArrayList<CircularElement>(buffersToKeepBeforeSpilling);
  CircularElement element=null;
  boolean cacheOnly=false;
  if (buffersToKeepBeforeSpilling > 0) {
    while (isRunning()) {
      if (cache.size() >= buffersToKeepBeforeSpilling) {
        cacheOnly=false;
        break;
      }
      element=queues.spill.take();
      cache.add(element);
      if (element == SENTINEL) {
        cacheOnly=true;
        break;
      }
    }
  }
  if (cacheOnly) {
    LOG.debug(""String_Node_Str"");
    List<Iterator<KeyValuePair<K,V>>> iterators=new ArrayList<Iterator<KeyValuePair<K,V>>>();
    Iterator<CircularElement> iter=cache.iterator();
    while (iter.hasNext()) {
      CircularElement cached=iter.next();
      if (cached != SENTINEL) {
        iterators.add(cached.buffer.getIterator());
      }
    }
    LOG.debug(""String_Node_Str"");
    while (!queues.empty.isEmpty()) {
      memoryManager.release(queues.empty.take().buffer.unbind());
    }
    setResultIterator(new MergeIterator<K,V>(iterators,keyComparator));
  }
 else {
    LOG.debug(""String_Node_Str"");
    final Channel.Enumerator enumerator=ioManager.createChannelEnumerator();
    List<Channel.ID> channelIDs=new ArrayList<Channel.ID>();
    outputSegments=memoryManager.allocate(UnilateralSortMerger.this.parent,2,ioMemorySize / 2);
    freeSegmentsAtShutdown(outputSegments);
    while (isRunning() && (element=takeNext(queues.spill,cache)) != SENTINEL) {
      Channel.ID channel=enumerator.next();
      channelIDs.add(channel);
      ChannelWriter writer=ioManager.createChannelWriter(channel,outputSegments);
      LOG.debug(""String_Node_Str"" + element.id + ""String_Node_Str"");
      element.buffer.writeToChannel(writer);
      LOG.debug(""String_Node_Str"" + element.id + ""String_Node_Str"");
      outputSegments=writer.close();
      element.buffer.reset();
      queues.empty.put(element);
    }
    LOG.debug(""String_Node_Str"");
    LOG.debug(""String_Node_Str"");
    memoryManager.release(outputSegments);
    LOG.debug(""String_Node_Str"");
    while (!queues.empty.isEmpty()) {
      memoryManager.release(queues.empty.take().buffer.unbind());
    }
    while (channelIDs.size() > maxNumFileHandles) {
      channelIDs=mergeChannelList(channelIDs,ioMemorySize);
    }
    setResultIterator(getMergingIterator(channelIDs,ioMemorySize));
  }
  LOG.debug(""String_Node_Str"");
}"
88343,"/** 
 * {@inheritDoc}
 */
@Override public boolean equals(Object obj){
  if (this.inetAddress != null) {
    return this.inetAddress.equals(obj);
  }
 else {
    return this.fileName.equals(obj);
  }
}","/** 
 * {@inheritDoc}
 */
@Override public boolean equals(Object obj){
  if (!(obj instanceof IncomingConnectionID)) {
    return false;
  }
  final IncomingConnectionID ici=(IncomingConnectionID)obj;
  if (this.inetAddress != null) {
    return this.inetAddress.equals(ici.inetAddress);
  }
 else {
    return this.fileName.equals(ici.fileName);
  }
}"
88344,"private void doWrite(SelectionKey key){
  final SocketChannel socketChannel=(SocketChannel)key.channel();
  final OutgoingConnection outgoingConnection=(OutgoingConnection)key.attachment();
  try {
    if (!outgoingConnection.write(socketChannel)) {
      outgoingConnection.closeConnection(socketChannel,key);
    }
  }
 catch (  IOException ioe) {
    outgoingConnection.reportTransmissionProblem(socketChannel,key,ioe);
  }
}","private void doWrite(SelectionKey key){
  final SocketChannel socketChannel=(SocketChannel)key.channel();
  final OutgoingConnection outgoingConnection=(OutgoingConnection)key.attachment();
  try {
    if (!outgoingConnection.write(socketChannel)) {
    }
  }
 catch (  IOException ioe) {
    outgoingConnection.reportTransmissionProblem(socketChannel,key,ioe);
  }
}"
88345,"/** 
 * Checks the behavior of the resourceAllocated() method
 * @throws Exception
 */
@Test public void testResourceAllocated() throws Exception {
  QueueScheduler toTest=spy(new QueueScheduler(this.schedulingListener,this.instanceManager));
  JobID jobid=mock(JobID.class);
  AllocatedResource resource=mock(AllocatedResource.class);
  InstanceType instanceType=new InstanceType();
  InstanceConnectionInfo instanceConnectionInfo=mock(InstanceConnectionInfo.class);
  when(instanceConnectionInfo.toString()).thenReturn(""String_Node_Str"");
  LocalInstance instance=spy(new LocalInstance(instanceType,instanceConnectionInfo,null,null,null));
  toTest.resourceAllocated(null,null);
  verify(this.loggerMock).error(Matchers.anyString());
  final Method methodToMock=MemberMatcher.method(QueueScheduler.class,JobID.class);
  PowerMockito.when(toTest,methodToMock).withArguments(Matchers.any(JobID.class)).thenReturn(null);
  when(resource.getInstance()).thenReturn(instance);
  toTest.resourceAllocated(jobid,resource);
  try {
    verify(this.instanceManager).releaseAllocatedResource(Matchers.any(JobID.class),Matchers.any(Configuration.class),Matchers.any(AllocatedResource.class));
  }
 catch (  InstanceException e1) {
    e1.printStackTrace();
  }
  PowerMockito.when(toTest,methodToMock).withArguments(Matchers.any(JobID.class)).thenReturn(this.executionGraph);
  when(this.graphIterator.next()).thenReturn(this.vertex1);
  when(this.graphIterator.hasNext()).thenReturn(true,true,true,true,false);
  when(this.graphIterator2.next()).thenReturn(this.vertex1);
  when(this.graphIterator2.hasNext()).thenReturn(true,true,true,true,false);
  when(this.vertex1.getExecutionState()).thenReturn(ExecutionState.ASSIGNING);
  try {
    whenNew(ExecutionGraphIterator.class).withArguments(Matchers.any(ExecutionGraph.class),Matchers.anyBoolean()).thenReturn(this.graphIterator);
    whenNew(ExecutionGraphIterator.class).withArguments(Matchers.any(ExecutionGraph.class),Matchers.anyInt(),Matchers.anyBoolean(),Matchers.anyBoolean()).thenReturn(this.graphIterator2);
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
  when(this.executionGraph.getJobID()).thenReturn(jobid);
  Deque<ExecutionGraph> jobQueue=Whitebox.getInternalState(toTest,""String_Node_Str"");
  jobQueue.add(this.executionGraph);
  Whitebox.setInternalState(toTest,""String_Node_Str"",jobQueue);
  when(this.vertex1.getAllocatedResource()).thenReturn(null);
  when(resource.getInstance()).thenReturn(instance);
  toTest.resourceAllocated(jobid,resource);
  verify(this.loggerMock).warn(Matchers.anyString());
  when(this.graphIterator2.hasNext()).thenReturn(true,true,true,true,false);
  when(this.graphIterator.hasNext()).thenReturn(true,true,true,true,false);
  when(this.vertex1.getAllocatedResource()).thenReturn(resource);
  toTest.resourceAllocated(jobid,resource);
  verify(this.vertex1,times(4)).setExecutionState(ExecutionState.ASSIGNED);
}","/** 
 * Checks the behavior of the resourceAllocated() method
 * @throws Exception
 */
@Test public void testResourceAllocated() throws Exception {
  QueueScheduler toTest=spy(new QueueScheduler(this.schedulingListener,this.instanceManager));
  JobID jobid=mock(JobID.class);
  AllocatedResource resource=mock(AllocatedResource.class);
  InstanceType instanceType=new InstanceType();
  InstanceConnectionInfo instanceConnectionInfo=mock(InstanceConnectionInfo.class);
  when(instanceConnectionInfo.toString()).thenReturn(""String_Node_Str"");
  LocalInstance instance=spy(new LocalInstance(instanceType,instanceConnectionInfo,null,null,null));
  toTest.resourceAllocated(null,null);
  verify(this.loggerMock).error(Matchers.anyString());
  final Method methodToMock=MemberMatcher.method(QueueScheduler.class,JobID.class);
  PowerMockito.when(toTest,methodToMock).withArguments(Matchers.any(JobID.class)).thenReturn(null);
  when(resource.getInstance()).thenReturn(instance);
  toTest.resourceAllocated(jobid,resource);
  try {
    verify(this.instanceManager).releaseAllocatedResource(Matchers.any(JobID.class),Matchers.any(Configuration.class),Matchers.any(AllocatedResource.class));
  }
 catch (  InstanceException e1) {
    e1.printStackTrace();
  }
  PowerMockito.when(toTest,methodToMock).withArguments(Matchers.any(JobID.class)).thenReturn(this.executionGraph);
  when(this.graphIterator.next()).thenReturn(this.vertex1);
  when(this.graphIterator.hasNext()).thenReturn(true,true,true,true,false);
  when(this.graphIterator2.next()).thenReturn(this.vertex1);
  when(this.graphIterator2.hasNext()).thenReturn(true,true,true,true,false);
  when(this.vertex1.getExecutionState()).thenReturn(ExecutionState.ASSIGNING);
  try {
    whenNew(ExecutionGraphIterator.class).withArguments(Matchers.any(ExecutionGraph.class),Matchers.anyBoolean()).thenReturn(this.graphIterator);
    whenNew(ExecutionGraphIterator.class).withArguments(Matchers.any(ExecutionGraph.class),Matchers.anyInt(),Matchers.anyBoolean(),Matchers.anyBoolean()).thenReturn(this.graphIterator2);
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
  when(this.executionGraph.getJobID()).thenReturn(jobid);
  Deque<ExecutionGraph> jobQueue=Whitebox.getInternalState(toTest,""String_Node_Str"");
  jobQueue.add(this.executionGraph);
  Whitebox.setInternalState(toTest,""String_Node_Str"",jobQueue);
  when(this.vertex1.getAllocatedResource()).thenReturn(null);
  when(resource.getInstance()).thenReturn(instance);
  toTest.resourceAllocated(jobid,resource);
  verify(this.loggerMock).warn(Matchers.anyString());
  when(this.graphIterator2.hasNext()).thenReturn(true,true,true,true,false);
  when(this.graphIterator.hasNext()).thenReturn(true,true,true,true,false);
  when(this.vertex1.getAllocatedResource()).thenReturn(resource);
  when(resource.getInstanceType()).thenReturn(instanceType);
  toTest.resourceAllocated(jobid,resource);
  verify(this.vertex1,times(4)).setExecutionState(ExecutionState.ASSIGNED);
}"
88346,"/** 
 * Creates a new channel to the path indicated by the given ID. The channel hands IO requests to the given request queue to be processed.
 * @param channelID The id describing the path of the file that the channel accessed.
 * @param requestQueue The queue that this channel hands its IO requests to.
 */
protected ChannelAccess(Channel.ID channelID,RequestQueue<IORequest<T>> requestQueue,Collection<T> buffers) throws IOException {
  if (channelID == null || requestQueue == null) {
    throw new NullPointerException();
  }
  this.id=channelID;
  this.numBuffers=buffers.size();
  this.requestQueue=requestQueue;
  this.returnBuffers=new ArrayBlockingQueue<T>(buffers.size(),false);
  try {
    RandomAccessFile file=new RandomAccessFile(id.getPath(),""String_Node_Str"");
    this.fileChannel=file.getChannel();
  }
 catch (  IOException e) {
    throw new IOException(""String_Node_Str"" + channelID.getPath() + ""String_Node_Str"",e);
  }
}","/** 
 * Creates a new channel to the path indicated by the given ID. The channel hands IO requests to the given request queue to be processed.
 * @param channelID The id describing the path of the file that the channel accessed.
 * @param requestQueue The queue that this channel hands its IO requests to.
 */
protected ChannelAccess(Channel.ID channelID,RequestQueue<IORequest<T>> requestQueue,Collection<T> buffers) throws IOException {
  if (channelID == null || requestQueue == null || buffers == null) {
    throw new IllegalArgumentException();
  }
  if (buffers.isEmpty()) {
    throw new IllegalArgumentException();
  }
  this.id=channelID;
  this.numBuffers=buffers.size();
  this.requestQueue=requestQueue;
  this.returnBuffers=new ArrayBlockingQueue<T>(buffers.size(),false);
  try {
    RandomAccessFile file=new RandomAccessFile(id.getPath(),""String_Node_Str"");
    this.fileChannel=file.getChannel();
  }
 catch (  IOException e) {
    throw new IOException(""String_Node_Str"" + channelID.getPath() + ""String_Node_Str"",e);
  }
}"
88347,"/** 
 * @param channelID
 * @param requestQueue
 * @param buffers
 * @param deleteWhenDone
 * @throws IOException
 */
public ChannelReader(Channel.ID channelID,RequestQueue<IORequest<Buffer.Input>> requestQueue,Collection<Buffer.Input> buffers,boolean deleteWhenDone) throws IOException {
  super(channelID,requestQueue,buffers);
  this.deleteWhenDone=deleteWhenDone;
  for (  Buffer.Input buffer : buffers) {
    this.requestQueue.add(new IORequest<Buffer.Input>(this,buffer));
  }
}","/** 
 * @param channelID
 * @param requestQueue
 * @param buffers
 * @param deleteWhenDone
 * @throws IOException
 */
protected ChannelReader(Channel.ID channelID,RequestQueue<IORequest<Buffer.Input>> requestQueue,Collection<Buffer.Input> buffers,boolean deleteWhenDone) throws IOException {
  super(channelID,requestQueue,buffers);
  this.deleteWhenDone=deleteWhenDone;
  for (  Buffer.Input buffer : buffers) {
    this.requestQueue.add(new IORequest<Buffer.Input>(this,buffer));
  }
}"
88348,"/** 
 * @param channelID
 * @param requestQueue
 * @param buffers
 * @param filledBuffers
 * @throws IOException
 */
public ChannelWriter(Channel.ID channelID,RequestQueue<IORequest<Buffer.Output>> requestQueue,Collection<Buffer.Output> buffers,boolean filledBuffers) throws IOException {
  super(channelID,requestQueue,buffers);
  try {
    this.fileChannel.truncate(0);
  }
 catch (  IOException e) {
    throw new IOException(""String_Node_Str"" + channelID.getPath() + ""String_Node_Str"",e);
  }
  if (filledBuffers) {
    for (    Buffer.Output buffer : buffers) {
      this.requestQueue.add(new IORequest<Buffer.Output>(this,buffer));
    }
  }
 else {
    this.returnBuffers.addAll(buffers);
  }
  try {
    currentBuffer=nextBuffer();
    checkErroneous();
  }
 catch (  InterruptedException iex) {
    throw new IOException(""String_Node_Str"");
  }
}","/** 
 * @param channelID
 * @param requestQueue
 * @param buffers
 * @param filledBuffers
 * @throws IOException
 */
protected ChannelWriter(Channel.ID channelID,RequestQueue<IORequest<Buffer.Output>> requestQueue,Collection<Buffer.Output> buffers,boolean filledBuffers) throws IOException {
  super(channelID,requestQueue,buffers);
  try {
    this.fileChannel.truncate(0);
  }
 catch (  IOException e) {
    throw new IOException(""String_Node_Str"" + channelID.getPath() + ""String_Node_Str"",e);
  }
  if (filledBuffers) {
    for (    Buffer.Output buffer : buffers) {
      this.requestQueue.add(new IORequest<Buffer.Output>(this,buffer));
    }
  }
 else {
    this.returnBuffers.addAll(buffers);
  }
  try {
    currentBuffer=nextBuffer();
    checkErroneous();
  }
 catch (  InterruptedException iex) {
    throw new IOException(""String_Node_Str"");
  }
}"
88349,"/** 
 * <p> Creates a ChannelWriter for the anonymous file identified by the specified   {@code channelID} using the provided{@code memorySegments} as backing memory for an internal flow of output buffers. If the boolean variable {@code filled} is set, the content of the memorySegments is flushed to the file before reusing.</p>
 * @param channelID
 * @param freeSegments
 * @param filled
 * @return
 * @throws IOException
 */
public ChannelWriter createChannelWriter(Channel.ID channelID,Collection<Buffer.Output> buffers,boolean filled) throws IOException {
  if (isClosed) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  return new ChannelWriter(channelID,writer.requestQueue,buffers,filled);
}","/** 
 * Creates a ChannelWriter for the anonymous file identified by the specified   {@code channelID} using the provided{@code memorySegments} as backing memory for an internal flow of output buffers. If the boolean variable {@code filled} is set, the content of the memorySegments is flushed to the file before reusing.
 * @param channelID
 * @param freeSegments
 * @param filled
 * @return
 * @throws IOException
 */
public ChannelWriter createChannelWriter(Channel.ID channelID,Collection<Buffer.Output> buffers,boolean filled) throws IOException {
  if (isClosed) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  return new ChannelWriter(channelID,writer.requestQueue,buffers,filled);
}"
88350,"/** 
 * <p> Creates a ChannelWriter for the anonymous file written on secondary storage and identified by the specified  {@code channelID} using the provided {@code freeSegments} as backing memory for an internal flow of inputbuffers. </p>
 * @param channelID
 * @param freeSegments
 * @return
 * @throws IOException
 */
public ChannelReader createChannelReader(Channel.ID channelID,Collection<MemorySegment> freeSegments,boolean deleteFileAfterRead) throws IOException {
  if (isClosed) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  return new ChannelReader(channelID,reader.requestQueue,createBuffer(Buffer.Type.INPUT,freeSegments),deleteFileAfterRead);
}","/** 
 * Creates a ChannelWriter for the anonymous file written on secondary storage and identified by the specified  {@code channelID} using the provided {@code freeSegments} as backing memory for an internal flow of inputbuffers.
 * @param channelID
 * @param freeSegments
 * @return
 * @throws IOException
 */
public ChannelReader createChannelReader(Channel.ID channelID,Collection<MemorySegment> freeSegments,boolean deleteFileAfterRead) throws IOException {
  if (isClosed) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  return new ChannelReader(channelID,reader.requestQueue,createBuffer(Buffer.Type.INPUT,freeSegments),deleteFileAfterRead);
}"
88351,"/** 
 * Close method. Shuts down the reader and writer threads immediately, not waiting for their pending requests to be served. This method waits until the threads have actually ceased their operation.
 */
public synchronized final void shutdown(){
  if (!isClosed) {
    isClosed=true;
    LOG.info(""String_Node_Str"");
    try {
      writer.shutdown();
    }
 catch (    Throwable t) {
      LOG.error(""String_Node_Str"",t);
    }
    try {
      reader.shutdown();
    }
 catch (    Throwable t) {
      LOG.error(""String_Node_Str"",t);
    }
    try {
      this.writer.join();
      this.reader.join();
    }
 catch (    InterruptedException iex) {
    }
  }
}","/** 
 * Close method. Shuts down the reader and writer threads immediately, not waiting for their pending requests to be served. This method waits until the threads have actually ceased their operation.
 */
public synchronized final void shutdown(){
  if (!isClosed) {
    isClosed=true;
    try {
      writer.shutdown();
    }
 catch (    Throwable t) {
      LOG.error(""String_Node_Str"",t);
    }
    try {
      reader.shutdown();
    }
 catch (    Throwable t) {
      LOG.error(""String_Node_Str"",t);
    }
    try {
      this.writer.join();
      this.reader.join();
    }
 catch (    InterruptedException iex) {
    }
  }
}"
88352,"@Override public KeyValuePair<K,V> deserialize(DataInput in){
  try {
    KeyValuePair<K,V> pair=getInstance();
    pair.read(in);
    return pair;
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}","@Override public KeyValuePair<K,V> deserialize(DataInput in){
  try {
    KeyValuePair<K,V> pair=getInstance();
    pair.read(in);
    return pair;
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}"
88353,"@Override public boolean next(){
  if (!iterator1.nextKey() || !iterator2.nextKey()) {
    return false;
  }
  K key1=iterator1.getKey();
  K key2=iterator2.getKey();
  while (key1.compareTo(key2) != 0) {
    if (key1.compareTo(key2) > 0) {
      if (!iterator2.nextKey()) {
        return false;
      }
      key2=iterator2.getKey();
    }
 else     if (key1.compareTo(key2) < 0) {
      if (!iterator1.nextKey()) {
        return false;
      }
      key1=iterator1.getKey();
    }
  }
  key=key1;
  return true;
}","@Override public V next(){
  return next.getValue();
}"
88354,"@Override public K getKey(){
  return key;
}","public K getKey(){
  return next.getKey();
}"
88355,"@Override public void open() throws IOException, MemoryAllocationException {
  final Comparator<K> keyComparator=new Comparator<K>(){
    @Override public int compare(    K k1,    K k2){
      return k1.compareTo(k2);
    }
  }
;
{
    final SerializationFactory<K> keySerialization=new WritableSerializationFactory<K>(keyClass);
    final SerializationFactory<V1> valSerialization=new WritableSerializationFactory<V1>(valueClass1);
    this.sortMerger1=new UnilateralSortMerger<K,V1>(memoryManager,ioManager,numSortBufferPerChannel,sizeSortBufferPerChannel,ioMemoryPerChannel,fileHandlesPerChannel,keySerialization,valSerialization,keyComparator,reader1,parentTask);
  }
{
    final SerializationFactory<K> keySerialization=new WritableSerializationFactory<K>(keyClass);
    final SerializationFactory<V2> valSerialization=new WritableSerializationFactory<V2>(valueClass2);
    this.sortMerger2=new UnilateralSortMerger<K,V2>(memoryManager,ioManager,numSortBufferPerChannel,sizeSortBufferPerChannel,ioMemoryPerChannel,fileHandlesPerChannel,keySerialization,valSerialization,keyComparator,reader2,parentTask);
  }
  this.iterator1=new KeyGroupedIterator<K,V1>(sortMerger1.getIterator());
  this.iterator2=new KeyGroupedIterator<K,V2>(sortMerger2.getIterator());
}","@Override public void open() throws IOException, MemoryAllocationException {
  final Comparator<K> keyComparator=new Comparator<K>(){
    @Override public int compare(    K k1,    K k2){
      return k1.compareTo(k2);
    }
  }
;
{
    final SerializationFactory<K> keySerialization=new WritableSerializationFactory<K>(keyClass);
    final SerializationFactory<V1> valSerialization=new WritableSerializationFactory<V1>(valueClass1);
    this.sortMerger1=new UnilateralSortMerger<K,V1>(memoryManager,ioManager,numSortBufferPerChannel,sizeSortBufferPerChannel,ioMemoryPerChannel,fileHandlesPerChannel,keySerialization,valSerialization,keyComparator,reader1,parentTask);
  }
{
    final SerializationFactory<K> keySerialization=new WritableSerializationFactory<K>(keyClass);
    final SerializationFactory<V2> valSerialization=new WritableSerializationFactory<V2>(valueClass2);
    this.sortMerger2=new UnilateralSortMerger<K,V2>(memoryManager,ioManager,numSortBufferPerChannel,sizeSortBufferPerChannel,ioMemoryPerChannel,fileHandlesPerChannel,keySerialization,valSerialization,keyComparator,reader2,parentTask);
  }
  this.iterator1=new KeyValueIterator<V1>(sortMerger1.getIterator());
  this.iterator2=new KeyValueIterator<V2>(sortMerger2.getIterator());
}"
88356,"@Override public byte[] writeLine(KeyValuePair<PactInteger,CoordVector> pair){
  StringBuilder line=new StringBuilder();
  DecimalFormat df=new DecimalFormat(""String_Node_Str"");
  line.append(pair.getKey().getValue());
  for (  double coord : pair.getValue().getCoordinates()) {
    line.append('|');
    line.append(df.format(coord));
  }
  line.append('|');
  line.append('\n');
  return line.toString().getBytes();
}","@Override public byte[] writeLine(KeyValuePair<PactInteger,CoordVector> pair){
  StringBuilder line=new StringBuilder();
  line.append(pair.getKey().getValue());
  for (  double coord : pair.getValue().getCoordinates()) {
    line.append('|');
    line.append(df.format(coord));
  }
  line.append('|');
  line.append('\n');
  return line.toString().getBytes();
}"
88357,"/** 
 * This method is periodically called by the framework to check the state of the task threads. If any task thread has unexpectedly switch to TERMINATED, this indicates that an   {@link Error} has occurredduring its execution.
 */
private void checkTaskExecution(){
synchronized (this.runningTasks) {
    final Iterator<ExecutionVertexID> it=this.runningTasks.keySet().iterator();
    while (it.hasNext()) {
      final ExecutionVertexID executionVertexID=it.next();
      final Environment environment=this.runningTasks.get(executionVertexID);
      if (environment.getExecutingThread().getState() == Thread.State.TERMINATED) {
        it.remove();
        environment.changeExecutionState(ExecutionState.FAILED,""String_Node_Str"");
      }
    }
  }
}","/** 
 * This method is periodically called by the framework to check the state of the task threads. If any task thread has unexpectedly switch to TERMINATED, this indicates that an   {@link Error} has occurredduring its execution.
 */
private void checkTaskExecution(){
  final List<Environment> crashEnvironments=new LinkedList<Environment>();
synchronized (this.runningTasks) {
    final Iterator<ExecutionVertexID> it=this.runningTasks.keySet().iterator();
    while (it.hasNext()) {
      final ExecutionVertexID executionVertexID=it.next();
      final Environment environment=this.runningTasks.get(executionVertexID);
      if (environment.getExecutingThread().getState() == Thread.State.TERMINATED) {
        it.remove();
        crashEnvironments.add(environment);
      }
    }
  }
  final Iterator<Environment> it2=crashEnvironments.iterator();
  while (it2.hasNext()) {
    it2.next().changeExecutionState(ExecutionState.FAILED,""String_Node_Str"");
  }
}"
88358,"/** 
 * {@inheritDoc}
 */
@Override public TaskCancelResult cancelTask(ExecutionVertexID id) throws IOException {
  Environment tmpEnvironment;
synchronized (this.runningTasks) {
    tmpEnvironment=this.runningTasks.get(id);
    if (tmpEnvironment == null) {
      final TaskCancelResult taskCancelResult=new TaskCancelResult(id,AbstractTaskResult.ReturnCode.ERROR);
      taskCancelResult.setDescription(""String_Node_Str"" + id + ""String_Node_Str"");
      return taskCancelResult;
    }
  }
  final Environment environment=tmpEnvironment;
  Thread tmpThread=new Thread(new Runnable(){
    @Override public void run(){
      environment.cancelExecution();
    }
  }
);
  tmpThread.start();
  return new TaskCancelResult(id,AbstractTaskResult.ReturnCode.SUCCESS);
}","/** 
 * {@inheritDoc}
 */
@Override public TaskCancelResult cancelTask(ExecutionVertexID id) throws IOException {
  Environment tmpEnvironment;
synchronized (this.runningTasks) {
    tmpEnvironment=this.runningTasks.get(id);
    if (tmpEnvironment == null) {
      final TaskCancelResult taskCancelResult=new TaskCancelResult(id,AbstractTaskResult.ReturnCode.ERROR);
      taskCancelResult.setDescription(""String_Node_Str"" + id + ""String_Node_Str"");
      return taskCancelResult;
    }
  }
  final Environment environment=tmpEnvironment;
  final Thread tmpThread=new Thread(new Runnable(){
    @Override public void run(){
      environment.cancelExecution();
    }
  }
);
  tmpThread.start();
  return new TaskCancelResult(id,AbstractTaskResult.ReturnCode.SUCCESS);
}"
88359,"public ChannelReader(Channel.ID channelID,RequestQueue<IORequest<Buffer.Input>> requestQueue,Collection<Buffer.Input> buffers) throws IOException {
  super(channelID,requestQueue,buffers);
  for (  Buffer.Input buffer : buffers) {
    this.requestQueue.add(new IORequest<Buffer.Input>(this,buffer));
  }
}","public ChannelReader(Channel.ID channelID,RequestQueue<IORequest<Buffer.Input>> requestQueue,Collection<Buffer.Input> buffers,boolean deleteWhenDone) throws IOException {
  super(channelID,requestQueue,buffers);
  this.deleteWhenDone=deleteWhenDone;
  for (  Buffer.Input buffer : buffers) {
    this.requestQueue.add(new IORequest<Buffer.Input>(this,buffer));
  }
}"
88360,"/** 
 * <p> Creates a ChannelWriter for the anonymous file identified by the specified   {@code channelID} using the provided{@code memorySegments} as backing memory for an internal flow of output buffers. If the boolean variable {@code filled} is set, the content of the memorySegments is flushed to the file before reusing.</p>
 * @param channelID
 * @param freeSegments
 * @param filled
 * @return
 * @throws ServiceException
 */
public ChannelWriter createChannelWriter(Channel.ID channelID,Collection<Buffer.Output> buffers,boolean filled) throws IOException {
  if (isClosed) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  return new ChannelWriter(channelID,writer.requestQueue,buffers,filled);
}","/** 
 * <p> Creates a ChannelWriter for the anonymous file identified by the specified   {@code channelID} using the provided{@code memorySegments} as backing memory for an internal flow of output buffers. If the boolean variable {@code filled} is set, the content of the memorySegments is flushed to the file before reusing.</p>
 * @param channelID
 * @param freeSegments
 * @param filled
 * @return
 * @throws IOException
 */
public ChannelWriter createChannelWriter(Channel.ID channelID,Collection<Buffer.Output> buffers,boolean filled) throws IOException {
  if (isClosed) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  return new ChannelWriter(channelID,writer.requestQueue,buffers,filled);
}"
88361,"/** 
 * <p> Creates a ChannelWriter for the anonymous file written on secondary storage and identified by the specified  {@code channelID} using the provided {@code freeSegments} as backing memory for an internal flow of inputbuffers. </p>
 * @param channelID
 * @param freeSegments
 * @return
 * @throws ServiceException
 */
public ChannelReader createChannelReader(Channel.ID channelID,Collection<MemorySegment> freeSegments) throws IOException {
  if (isClosed) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  return new ChannelReader(channelID,reader.requestQueue,createBuffer(Buffer.Type.INPUT,freeSegments));
}","/** 
 * <p> Creates a ChannelWriter for the anonymous file written on secondary storage and identified by the specified  {@code channelID} using the provided {@code freeSegments} as backing memory for an internal flow of inputbuffers. </p>
 * @param channelID
 * @param freeSegments
 * @return
 * @throws IOException
 */
public ChannelReader createChannelReader(Channel.ID channelID,Collection<MemorySegment> freeSegments,boolean deleteFileAfterRead) throws IOException {
  if (isClosed) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  return new ChannelReader(channelID,reader.requestQueue,createBuffer(Buffer.Type.INPUT,freeSegments),deleteFileAfterRead);
}"
88362,"/** 
 * Generic factory method for typed initialized collections of different buffer types.
 * @param < T >
 * @param bufferType
 * @param numberOfBuffers
 * @return Collection<T> an unsynchronized collection of initialized buffers
 * @throws ServiceException
 */
public static <T extends Buffer>Collection<T> createBuffer(Buffer.Type<T> bufferType,Collection<MemorySegment> freeSegments){
  ArrayList<T> buffers=new ArrayList<T>(freeSegments.size());
  for (  MemorySegment segment : freeSegments) {
    T buffer=createBuffer(bufferType);
    buffer.bind(segment);
    buffers.add(buffer);
  }
  return buffers;
}","/** 
 * Generic factory method for typed initialized collections of different buffer types.
 * @param < T >
 * @param bufferType
 * @param numberOfBuffers
 * @return Collection<T> an unsynchronized collection of initialized buffers
 */
public static <T extends Buffer>Collection<T> createBuffer(Buffer.Type<T> bufferType,Collection<MemorySegment> freeSegments){
  ArrayList<T> buffers=new ArrayList<T>(freeSegments.size());
  for (  MemorySegment segment : freeSegments) {
    T buffer=createBuffer(bufferType);
    buffer.bind(segment);
    buffers.add(buffer);
  }
  return buffers;
}"
88363,"/** 
 * Close method.
 */
public synchronized final void shutdown(){
  if (!isClosed) {
    isClosed=true;
    LOG.info(""String_Node_Str"");
    try {
      writer.shutdown();
    }
 catch (    Throwable t) {
      LOG.error(""String_Node_Str"",t);
    }
    try {
      reader.shutdown();
    }
 catch (    Throwable t) {
      LOG.error(""String_Node_Str"",t);
    }
    try {
      this.writer.join();
      this.reader.join();
    }
 catch (    InterruptedException iex) {
    }
  }
}","/** 
 * Close method. Shuts down the reader and writer threads immediately, not waiting for their pending requests to be served. This method waits until the threads have actually ceased their operation.
 */
public synchronized final void shutdown(){
  if (!isClosed) {
    isClosed=true;
    LOG.info(""String_Node_Str"");
    try {
      writer.shutdown();
    }
 catch (    Throwable t) {
      LOG.error(""String_Node_Str"",t);
    }
    try {
      reader.shutdown();
    }
 catch (    Throwable t) {
      LOG.error(""String_Node_Str"",t);
    }
    try {
      this.writer.join();
      this.reader.join();
    }
 catch (    InterruptedException iex) {
    }
  }
}"
88364,"public boolean isProperlyShutDown(){
  return isClosed && (this.writer.getState() == Thread.State.TERMINATED) && (this.reader.getState() == Thread.State.TERMINATED);
}","/** 
 * Utility method to check whether the IO manager has been properly shut down. The IO manager is considered to be properly shut down when it is closed and its threads have ceased operation.
 * @return True, if the IO manager has properly shut down, false otherwise.
 */
public boolean isProperlyShutDown(){
  return isClosed && (this.writer.getState() == Thread.State.TERMINATED) && (this.reader.getState() == Thread.State.TERMINATED);
}"
88365,"private int readFromChannel(Channel.ID channelID) throws IOException, MemoryAllocationException {
  Collection<MemorySegment> freeSegments=memoryManager.allocate(new DummyInvokable(),NUMBER_OF_SEGMENTS,SEGMENT_SIZE);
  ChannelReader channelReader=ioManager.createChannelReader(channelID,freeSegments);
  generator.reset();
  Value value=new Value();
  int readCounter=0;
  while (channelReader.read(value)) {
    Assert.assertEquals(""String_Node_Str"",generator.next(),value);
    readCounter++;
  }
  memoryManager.release(channelReader.close());
  return readCounter;
}","private int readFromChannel(Channel.ID channelID) throws IOException, MemoryAllocationException {
  Collection<MemorySegment> freeSegments=memoryManager.allocate(new DummyInvokable(),NUMBER_OF_SEGMENTS,SEGMENT_SIZE);
  ChannelReader channelReader=ioManager.createChannelReader(channelID,freeSegments,true);
  generator.reset();
  Value value=new Value();
  int readCounter=0;
  while (channelReader.read(value)) {
    Assert.assertEquals(""String_Node_Str"",generator.next(),value);
    readCounter++;
  }
  memoryManager.release(channelReader.close());
  return readCounter;
}"
88366,"/** 
 * This utility method picks the instance type to be used for scheduling PACT processor instances.
 * @param types The available types.
 * @return The type to be used for scheduling.
 */
private InstanceTypeDescription getType(Map<InstanceType,InstanceTypeDescription> types){
  if (types == null || types.size() < 1) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  long minMemory=0;
  int minCPUCores=Integer.MAX_VALUE;
  InstanceTypeDescription retValue=null;
  final Iterator<InstanceTypeDescription> it=types.values().iterator();
  while (it.hasNext()) {
    final InstanceTypeDescription descr=it.next();
    if (retValue == null) {
      retValue=descr;
    }
    if (descr.getInstanceType().getNumberOfCores() < minCPUCores && descr.getHardwareDescription().getSizeOfFreeMemory() > minMemory) {
      minCPUCores=descr.getInstanceType().getNumberOfCores();
      minMemory=descr.getHardwareDescription().getSizeOfFreeMemory();
      retValue=descr;
    }
  }
  return retValue;
}","/** 
 * This utility method picks the instance type to be used for scheduling PACT processor instances. <p>
 * @param types The available types.
 * @return The type to be used for scheduling.
 * @throws CompilerException
 * @throws IllegalArgumentException
 */
private InstanceTypeDescription getType(Map<InstanceType,InstanceTypeDescription> types) throws CompilerException {
  if (types == null || types.size() < 1) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  InstanceTypeDescription retValue=null;
  long totalMemory=0;
  int numInstances=0;
  final Iterator<InstanceTypeDescription> it=types.values().iterator();
  while (it.hasNext()) {
    final InstanceTypeDescription descr=it.next();
    if (descr.getHardwareDescription() == null || descr.getInstanceType() == null) {
      continue;
    }
    final int curInstances=descr.getMaximumNumberOfAvailableInstances();
    final long curMemory=curInstances * descr.getHardwareDescription().getSizeOfFreeMemory();
    if ((retValue == null) || (curInstances > numInstances && (int)(curMemory * 1.2f) > totalMemory) || (curInstances * retValue.getInstanceType().getNumberOfCores() >= numInstances && (int)(curMemory * 1.5f) > totalMemory)) {
      retValue=descr;
      numInstances=curInstances;
      totalMemory=curMemory;
    }
  }
  if (retValue == null) {
    throw new CompilerException(""String_Node_Str"" + ""String_Node_Str"");
  }
  return retValue;
}"
88367,"@Override public boolean next() throws IOException, InterruptedException {
  KeyValuePair<K,VP> pair=probePairSerialization.newInstance();
  while (currentProbePartitionReader.read(pair)) {
    K key=pair.getKey();
    if (hashMap.contains(key)) {
      currentKey=key;
      currentBuildValuesIterable=hashMap.get(currentKey);
      currentProbeValuesIterable.value=pair.getValue();
      return true;
    }
  }
  if (currentPartition >= numberOfPartitions - 1) {
    return false;
  }
  try {
    currentProbePartitionReader.close();
    currentPartition++;
    LOG.debug(""String_Node_Str"" + currentPartition);
    hashMap.clear();
    currentBuildPartitionReader=ioManager.createChannelReader(buildPartitionIDs.get(currentPartition),freeSegments);
    KeyValuePair<K,VB> tmp=buildPairSerialization.newInstance();
    while (currentBuildPartitionReader.read(tmp)) {
      hashMap.put(tmp.getKey(),tmp.getValue());
      tmp=buildPairSerialization.newInstance();
    }
    currentBuildPartitionReader.close();
    currentProbePartitionReader=ioManager.createChannelReader(probePartitionIDs.get(currentPartition),freeSegments);
    return next();
  }
 catch (  ServiceException e) {
    throw new IOException(e);
  }
catch (  Exception e) {
    throw new IOException(e);
  }
}","@Override public boolean next() throws IOException, InterruptedException {
  KeyValuePair<K,VP> pair=probePairSerialization.newInstance();
  while (currentProbePartitionReader.read(pair)) {
    K key=pair.getKey();
    if (hashMap.contains(key)) {
      currentKey=key;
      currentBuildValuesIterable=hashMap.get(currentKey);
      currentProbeValuesIterable.value=pair.getValue();
      return true;
    }
  }
  if (currentPartition >= numberOfPartitions - 1) {
    return false;
  }
  try {
    currentProbePartitionReader.close();
    currentPartition++;
    LOG.debug(""String_Node_Str"" + currentPartition);
    hashMap.clear();
    currentBuildPartitionReader=ioManager.createChannelReader(buildPartitionIDs.get(currentPartition),freeSegments,false);
    KeyValuePair<K,VB> tmp=buildPairSerialization.newInstance();
    while (currentBuildPartitionReader.read(tmp)) {
      hashMap.put(tmp.getKey(),tmp.getValue());
      tmp=buildPairSerialization.newInstance();
    }
    currentBuildPartitionReader.close();
    currentProbePartitionReader=ioManager.createChannelReader(probePartitionIDs.get(currentPartition),freeSegments,false);
    return next();
  }
 catch (  ServiceException e) {
    throw new IOException(e);
  }
catch (  Exception e) {
    throw new IOException(e);
  }
}"
88368,"/** 
 * Repartitions the build side.
 * @throws IOException
 * @throws InterruptedException
 * @throws ServiceException
 */
private void repartitionBuildSide() throws IOException, InterruptedException, ServiceException {
  LOG.debug(""String_Node_Str"");
  KeyValuePair<K,VB> pair=buildPairSerialization.newInstance();
  int partition;
  for (  K key : hashMap.keys()) {
    partition=partitioner.getPartition(key);
    for (    VB value : hashMap.get(key)) {
      partitionWriters.get(partition).write(new KeyValuePair<K,VB>(key,value));
    }
  }
  hashMap.clear();
  ChannelReader partitionZeroReader=ioManager.createChannelReader(buildPartitionIDs.get(0),partitionWriters.get(0).close());
  while (partitionZeroReader.read(pair)) {
    hashMap.put(pair.getKey(),pair.getValue());
  }
  partitionWriters.set(0,ioManager.createChannelWriter(buildPartitionIDs.get(0),partitionZeroReader.close()));
  LOG.debug(""String_Node_Str"");
  pair=overflowCause;
  partition=partitioner.getPartition(pair.getKey());
  if (partition == 0) {
    hashMap.put(pair.getKey(),pair.getValue());
  }
 else {
    partitionWriters.get(partition).write(pair);
  }
  LOG.debug(""String_Node_Str"");
  while (readerBuild.hasNext()) {
    pair=readerBuild.next();
    partition=partitioner.getPartition(pair.getKey());
    if (partition == 0) {
      hashMap.put(pair.getKey(),pair.getValue());
    }
 else {
      partitionWriters.get(partition).write(pair);
    }
  }
}","/** 
 * Repartitions the build side.
 * @throws IOException
 * @throws InterruptedException
 * @throws ServiceException
 */
private void repartitionBuildSide() throws IOException, InterruptedException, ServiceException {
  LOG.debug(""String_Node_Str"");
  KeyValuePair<K,VB> pair=buildPairSerialization.newInstance();
  int partition;
  for (  K key : hashMap.keys()) {
    partition=partitioner.getPartition(key);
    for (    VB value : hashMap.get(key)) {
      partitionWriters.get(partition).write(new KeyValuePair<K,VB>(key,value));
    }
  }
  hashMap.clear();
  ChannelReader partitionZeroReader=ioManager.createChannelReader(buildPartitionIDs.get(0),partitionWriters.get(0).close(),false);
  while (partitionZeroReader.read(pair)) {
    hashMap.put(pair.getKey(),pair.getValue());
  }
  partitionWriters.set(0,ioManager.createChannelWriter(buildPartitionIDs.get(0),partitionZeroReader.close()));
  LOG.debug(""String_Node_Str"");
  pair=overflowCause;
  partition=partitioner.getPartition(pair.getKey());
  if (partition == 0) {
    hashMap.put(pair.getKey(),pair.getValue());
  }
 else {
    partitionWriters.get(partition).write(pair);
  }
  LOG.debug(""String_Node_Str"");
  while (readerBuild.hasNext()) {
    pair=readerBuild.next();
    partition=partitioner.getPartition(pair.getKey());
    if (partition == 0) {
      hashMap.put(pair.getKey(),pair.getValue());
    }
 else {
      partitionWriters.get(partition).write(pair);
    }
  }
}"
88369,"@Override public void initialize() throws ServiceException, IOException, InterruptedException {
  LOG.debug(""String_Node_Str"");
  numberOfPartitions=freeSegments.size() / 2;
  partitioner=new Partitioner(numberOfPartitions);
  partitionWriters=new ArrayList<ChannelWriter>(numberOfPartitions);
  buildPartitionIDs=new ArrayList<Channel.ID>(numberOfPartitions);
  probePartitionIDs=new ArrayList<Channel.ID>(numberOfPartitions);
  LOG.debug(""String_Node_Str"" + numberOfPartitions + ""String_Node_Str"");
  LOG.debug(""String_Node_Str"");
  Channel.Enumerator buildEnumerator=ioManager.createChannelEnumerator();
  allocatePartitionWriters(buildEnumerator,buildPartitionIDs);
  repartitionBuildSide();
  closePartitionWriters();
  LOG.debug(""String_Node_Str"");
  Channel.Enumerator probeEnumerator=ioManager.createChannelEnumerator();
  allocatePartitionWriters(probeEnumerator,probePartitionIDs);
  repartitionProbeSide();
  closePartitionWriters();
  currentPartition=0;
  currentBuildPartitionReader=ioManager.createChannelReader(buildPartitionIDs.get(currentPartition),freeSegments);
  KeyValuePair<K,VB> pair=buildPairSerialization.newInstance();
  while (currentBuildPartitionReader.read(pair)) {
    hashMap.put(pair.getKey(),pair.getValue());
  }
  currentBuildPartitionReader.close();
  currentProbePartitionReader=ioManager.createChannelReader(probePartitionIDs.get(currentPartition),freeSegments);
}","@Override public void initialize() throws ServiceException, IOException, InterruptedException {
  LOG.debug(""String_Node_Str"");
  numberOfPartitions=freeSegments.size() / 2;
  partitioner=new Partitioner(numberOfPartitions);
  partitionWriters=new ArrayList<ChannelWriter>(numberOfPartitions);
  buildPartitionIDs=new ArrayList<Channel.ID>(numberOfPartitions);
  probePartitionIDs=new ArrayList<Channel.ID>(numberOfPartitions);
  LOG.debug(""String_Node_Str"" + numberOfPartitions + ""String_Node_Str"");
  LOG.debug(""String_Node_Str"");
  Channel.Enumerator buildEnumerator=ioManager.createChannelEnumerator();
  allocatePartitionWriters(buildEnumerator,buildPartitionIDs);
  repartitionBuildSide();
  closePartitionWriters();
  LOG.debug(""String_Node_Str"");
  Channel.Enumerator probeEnumerator=ioManager.createChannelEnumerator();
  allocatePartitionWriters(probeEnumerator,probePartitionIDs);
  repartitionProbeSide();
  closePartitionWriters();
  currentPartition=0;
  currentBuildPartitionReader=ioManager.createChannelReader(buildPartitionIDs.get(currentPartition),freeSegments,false);
  KeyValuePair<K,VB> pair=buildPairSerialization.newInstance();
  while (currentBuildPartitionReader.read(pair)) {
    hashMap.put(pair.getKey(),pair.getValue());
  }
  currentBuildPartitionReader.close();
  currentProbePartitionReader=ioManager.createChannelReader(probePartitionIDs.get(currentPartition),freeSegments,false);
}"
88370,"public void reset(){
  try {
    next=null;
    if (fitsIntoMem) {
      if (currentBuffer != usedBuffers)       inputBuffers.get(currentBuffer).reset();
      currentBuffer=0;
    }
 else {
      ioReader.close();
      ioReader=ioManager.createChannelReader(bufferID,memorySegments);
    }
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
  LOG.debug(""String_Node_Str"" + count + ""String_Node_Str"");
  count=0;
}","public void reset(){
  try {
    next=null;
    if (fitsIntoMem) {
      if (currentBuffer != usedBuffers)       inputBuffers.get(currentBuffer).reset();
      currentBuffer=0;
    }
 else {
      ioReader.close();
      ioReader=ioManager.createChannelReader(bufferID,memorySegments,false);
    }
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
  LOG.debug(""String_Node_Str"" + count + ""String_Node_Str"");
  count=0;
}"
88371,"/** 
 * Open the iterator. This will serialize the complete content of the specified Reader<T> into a file and initialize the ResettableIterator to this File.
 * @throws ServiceException
 * @throws InterruptedException
 * @throws IOException
 */
public void open() throws ServiceException, IOException, InterruptedException {
  fitsIntoMem=true;
  ArrayList<Buffer.Output> outputBuffers=new ArrayList<Buffer.Output>(nrOfBuffers);
  for (  MemorySegment segment : memorySegments) {
    Buffer.Output out=new Buffer.Output();
    out.bind(segment);
    outputBuffers.add(out);
  }
  while (recordReader.hasNext()) {
    next=recordReader.next();
    count++;
    if (!outputBuffers.get(currentBuffer).write(next)) {
      currentBuffer++;
      if (currentBuffer == nrOfBuffers) {
        fitsIntoMem=false;
        break;
      }
      outputBuffers.get(currentBuffer).write(next);
    }
  }
  if (!fitsIntoMem) {
    bufferID=this.ioManager.createChannel();
    ChannelWriter writer=ioManager.createChannelWriter(bufferID,outputBuffers,true);
    writer.write(next);
    while (recordReader.hasNext()) {
      count++;
      writer.write(recordReader.next());
    }
    writer.close();
    ioReader=ioManager.createChannelReader(bufferID,memorySegments);
    LOG.debug(""String_Node_Str"" + count + ""String_Node_Str"");
  }
 else {
    usedBuffers=currentBuffer + 1;
    inputBuffers=new ArrayList<Buffer.Input>(nrOfBuffers);
    for (    Buffer.Output out : outputBuffers) {
      int offset=out.getPosition();
      MemorySegment segment=out.unbind();
      Buffer.Input in=new Buffer.Input();
      in.bind(segment);
      in.reset(offset);
      inputBuffers.add(in);
    }
    currentBuffer=0;
    LOG.debug(""String_Node_Str"" + count + ""String_Node_Str"");
  }
  count=0;
  next=null;
}","/** 
 * Open the iterator. This will serialize the complete content of the specified Reader<T> into a file and initialize the ResettableIterator to this File.
 * @throws ServiceException
 * @throws InterruptedException
 * @throws IOException
 */
public void open() throws ServiceException, IOException, InterruptedException {
  fitsIntoMem=true;
  ArrayList<Buffer.Output> outputBuffers=new ArrayList<Buffer.Output>(nrOfBuffers);
  for (  MemorySegment segment : memorySegments) {
    Buffer.Output out=new Buffer.Output();
    out.bind(segment);
    outputBuffers.add(out);
  }
  while (recordReader.hasNext()) {
    next=recordReader.next();
    count++;
    if (!outputBuffers.get(currentBuffer).write(next)) {
      currentBuffer++;
      if (currentBuffer == nrOfBuffers) {
        fitsIntoMem=false;
        break;
      }
      outputBuffers.get(currentBuffer).write(next);
    }
  }
  if (!fitsIntoMem) {
    bufferID=this.ioManager.createChannel();
    ChannelWriter writer=ioManager.createChannelWriter(bufferID,outputBuffers,true);
    writer.write(next);
    while (recordReader.hasNext()) {
      count++;
      writer.write(recordReader.next());
    }
    writer.close();
    ioReader=ioManager.createChannelReader(bufferID,memorySegments,false);
    LOG.debug(""String_Node_Str"" + count + ""String_Node_Str"");
  }
 else {
    usedBuffers=currentBuffer + 1;
    inputBuffers=new ArrayList<Buffer.Input>(nrOfBuffers);
    for (    Buffer.Output out : outputBuffers) {
      int offset=out.getPosition();
      MemorySegment segment=out.unbind();
      Buffer.Input in=new Buffer.Input();
      in.bind(segment);
      in.reset(offset);
      inputBuffers.add(in);
    }
    currentBuffer=0;
    LOG.debug(""String_Node_Str"" + count + ""String_Node_Str"");
  }
  count=0;
  next=null;
}"
88372,"/** 
 * Entry point of the thread.
 */
public void go() throws Exception {
  final Channel.Enumerator enumerator=ioManager.createChannelEnumerator();
  List<Channel.ID> channelIDs=new ArrayList<Channel.ID>();
  outputSegments=memoryManager.allocate(CombiningUnilateralSortMerger.this.parent,2,ioMemorySize / 2);
  CircularElement element=null;
  while (isRunning() && (element=queues.spill.take()) != SENTINEL) {
    Channel.ID channel=enumerator.next();
    channelIDs.add(channel);
    LOG.debug(""String_Node_Str"" + channel.toString() + '.');
    ChannelWriter writer=ioManager.createChannelWriter(channel,outputSegments);
    LOG.debug(""String_Node_Str"" + element.id + '.');
    final BufferSortable<K,V> buffer=element.buffer;
    final CombineValueIterator<V> iter=new CombineValueIterator<V>(buffer);
    final Collector<K,V> collector=new WriterCollector<K,V>(writer);
    int i=0;
    int stop=buffer.size() - 1;
    while (i < stop) {
      int seqStart=i;
      while (i < stop && 0 == buffer.compare(i,i + 1)) {
        i++;
      }
      if (i == seqStart) {
        buffer.writeToChannel(writer,seqStart,1);
      }
 else {
        K key=buffer.getKey(seqStart);
        iter.set(seqStart,i);
        combineStub.combine(key,iter,collector);
      }
      i++;
    }
    if (i == stop) {
      buffer.writeToChannel(writer,stop,1);
    }
    LOG.debug(""String_Node_Str"" + element.id + ""String_Node_Str"");
    outputSegments=writer.close();
    element.buffer.reset();
    queues.empty.put(element);
  }
  LOG.debug(""String_Node_Str"");
  LOG.debug(""String_Node_Str"");
  memoryManager.release(outputSegments);
  LOG.debug(""String_Node_Str"");
  while (!queues.empty.isEmpty()) {
    memoryManager.release(queues.empty.take().buffer.unbind());
  }
  while (channelIDs.size() > maxNumFileHandles) {
    channelIDs=mergeChannelList(channelIDs,ioMemorySize);
  }
  if (CombiningUnilateralSortMerger.this.combineLastMerge) {
    KeyGroupedIterator<K,V> iter=new KeyGroupedIterator<K,V>(getMergingIterator(channelIDs,ioMemorySize));
    lazyIterator.setTarget(new CombiningIterator<K,V>(combineStub,iter));
  }
 else {
    lazyIterator.setTarget(getMergingIterator(channelIDs,ioMemorySize));
  }
  LOG.debug(""String_Node_Str"");
}","/** 
 * Entry point of the thread.
 */
public void go() throws Exception {
  final Channel.Enumerator enumerator=ioManager.createChannelEnumerator();
  List<Channel.ID> channelIDs=new ArrayList<Channel.ID>();
  outputSegments=memoryManager.allocate(CombiningUnilateralSortMerger.this.parent,2,ioMemorySize / 2);
  CircularElement element=null;
  while (isRunning() && (element=queues.spill.take()) != SENTINEL) {
    Channel.ID channel=enumerator.next();
    channelIDs.add(channel);
    LOG.debug(""String_Node_Str"" + channel.toString() + '.');
    ChannelWriter writer=ioManager.createChannelWriter(channel,outputSegments);
    LOG.debug(""String_Node_Str"" + element.id + '.');
    final BufferSortable<K,V> buffer=element.buffer;
    final CombineValueIterator<V> iter=new CombineValueIterator<V>(buffer);
    final Collector<K,V> collector=new WriterCollector<K,V>(writer);
    int i=0;
    int stop=buffer.size() - 1;
    while (i < stop) {
      int seqStart=i;
      while (i < stop && 0 == buffer.compare(i,i + 1)) {
        i++;
      }
      if (i == seqStart) {
        buffer.writeToChannel(writer,seqStart,1);
      }
 else {
        K key=buffer.getKey(seqStart);
        iter.set(seqStart,i);
        combineStub.combine(key,iter,collector);
      }
      i++;
    }
    if (i == stop) {
      buffer.writeToChannel(writer,stop,1);
    }
    LOG.debug(""String_Node_Str"" + element.id + ""String_Node_Str"");
    outputSegments=writer.close();
    element.buffer.reset();
    queues.empty.put(element);
  }
  LOG.debug(""String_Node_Str"");
  LOG.debug(""String_Node_Str"");
  memoryManager.release(outputSegments);
  LOG.debug(""String_Node_Str"");
  while (!queues.empty.isEmpty()) {
    memoryManager.release(queues.empty.take().buffer.unbind());
  }
  while (channelIDs.size() > maxNumFileHandles) {
    channelIDs=mergeChannelList(channelIDs,ioMemorySize);
  }
  if (CombiningUnilateralSortMerger.this.combineLastMerge) {
    KeyGroupedIterator<K,V> iter=new KeyGroupedIterator<K,V>(getMergingIterator(channelIDs,ioMemorySize));
    setResultIterator(new CombiningIterator<K,V>(combineStub,iter));
  }
 else {
    setResultIterator(getMergingIterator(channelIDs,ioMemorySize));
  }
  LOG.debug(""String_Node_Str"");
}"
88373,"/** 
 * @param channelIDs
 * @param ioMemorySize
 * @return The ID of the channel that holds the merged data of all input channels.
 */
protected Channel.ID mergeChannels(List<Channel.ID> channelIDs,int ioMemorySize) throws IOException, MemoryAllocationException {
  List<Iterator<KeyValuePair<K,V>>> iterators=new ArrayList<Iterator<KeyValuePair<K,V>>>(channelIDs.size());
  final int ioMemoryPerChannel=ioMemorySize / (channelIDs.size() + 2);
  for (  Channel.ID id : channelIDs) {
    inputSegments=memoryManager.allocate(this.parent,1,ioMemoryPerChannel);
    freeSegmentsAtShutdown(inputSegments);
    final ChannelReader reader=ioManager.createChannelReader(id,inputSegments);
    final Iterator<KeyValuePair<K,V>> iterator=new KVReaderIterator<K,V>(reader,keySerialization,valueSerialization,memoryManager,true);
    iterators.add(iterator);
  }
  MergeIterator<K,V> mi=new MergeIterator<K,V>(iterators,keyComparator);
  KeyGroupedIterator<K,V> groupedIter=new KeyGroupedIterator<K,V>(mi);
  final Channel.Enumerator enumerator=ioManager.createChannelEnumerator();
  final Channel.ID mergedChannelID=enumerator.next();
  outputSegments=memoryManager.allocate(this.parent,2,ioMemoryPerChannel);
  freeSegmentsAtShutdown(outputSegments);
  ChannelWriter writer=ioManager.createChannelWriter(mergedChannelID,outputSegments);
  WriterCollector<K,V> collector=new WriterCollector<K,V>(writer);
  while (groupedIter.nextKey()) {
    this.combineStub.combine(groupedIter.getKey(),groupedIter.getValues(),collector);
  }
  outputSegments=writer.close();
  memoryManager.release(outputSegments);
  return mergedChannelID;
}","/** 
 * @param channelIDs
 * @param ioMemorySize
 * @return The ID of the channel that holds the merged data of all input channels.
 */
protected Channel.ID mergeChannels(List<Channel.ID> channelIDs,int ioMemorySize) throws IOException, MemoryAllocationException {
  List<Iterator<KeyValuePair<K,V>>> iterators=new ArrayList<Iterator<KeyValuePair<K,V>>>(channelIDs.size());
  final int ioMemoryPerChannel=ioMemorySize / (channelIDs.size() + 2);
  for (  Channel.ID id : channelIDs) {
    inputSegments=memoryManager.allocate(this.parent,1,ioMemoryPerChannel);
    freeSegmentsAtShutdown(inputSegments);
    final ChannelReader reader=ioManager.createChannelReader(id,inputSegments,true);
    final Iterator<KeyValuePair<K,V>> iterator=new KVReaderIterator<K,V>(reader,keySerialization,valueSerialization,memoryManager,true);
    iterators.add(iterator);
  }
  MergeIterator<K,V> mi=new MergeIterator<K,V>(iterators,keyComparator);
  KeyGroupedIterator<K,V> groupedIter=new KeyGroupedIterator<K,V>(mi);
  final Channel.Enumerator enumerator=ioManager.createChannelEnumerator();
  final Channel.ID mergedChannelID=enumerator.next();
  outputSegments=memoryManager.allocate(this.parent,2,ioMemoryPerChannel);
  freeSegmentsAtShutdown(outputSegments);
  ChannelWriter writer=ioManager.createChannelWriter(mergedChannelID,outputSegments);
  WriterCollector<K,V> collector=new WriterCollector<K,V>(writer);
  while (groupedIter.nextKey()) {
    this.combineStub.combine(groupedIter.getKey(),groupedIter.getValues(),collector);
  }
  outputSegments=writer.close();
  memoryManager.release(outputSegments);
  return mergedChannelID;
}"
88374,"@Test public void testIterator() throws InterruptedException {
  Map<Key,Collection<Value>> expectedValuesMap1=collectData(generator1,INPUT_1_SIZE);
  Map<Key,Collection<Value>> expectedValuesMap2=collectData(generator2,INPUT_2_SIZE);
  Map<Key,Collection<Match>> expectedMatchesMap=matchValues(expectedValuesMap1,expectedValuesMap2);
  generator1.reset();
  generator2.reset();
  SortMergeMatchIterator<TestData.Key,TestData.Value,TestData.Value> iterator=new SortMergeMatchIterator<TestData.Key,TestData.Value,TestData.Value>(memoryManager,ioManager,reader1,reader2,TestData.Key.class,TestData.Value.class,TestData.Value.class,NUM_SORT_BUFFERS,SIZE_SORT_BUFFER,MEMORY_IO,128,null);
  iterator.open();
  while (iterator.next()) {
    TestData.Key key=new TestData.Key(iterator.getKey().getKey());
    Assert.assertTrue(""String_Node_Str"" + key + ""String_Node_Str"",expectedMatchesMap.containsKey(key));
    Iterator<TestData.Value> iter1=iterator.getValues1();
    Iterator<TestData.Value> iter2=iterator.getValues2();
    List<TestData.Value> values1=new ArrayList<TestData.Value>();
    while (iter1.hasNext()) {
      values1.add(new TestData.Value(iter1.next().getValue()));
    }
    List<TestData.Value> values2=new ArrayList<TestData.Value>();
    while (iter2.hasNext()) {
      values2.add(new TestData.Value(iter2.next().getValue()));
    }
    for (    Value value1 : values1) {
      for (      Value value2 : values2) {
        Collection<Match> expectedValues=expectedMatchesMap.get(key);
        Match match=new Match(value1,value2);
        Assert.assertTrue(""String_Node_Str"" + match + ""String_Node_Str""+ key,expectedValues.contains(match));
        expectedValues.remove(match);
      }
    }
  }
  iterator.close();
  for (  Entry<Key,Collection<Match>> entry : expectedMatchesMap.entrySet()) {
    Assert.assertTrue(""String_Node_Str"" + entry.getKey() + ""String_Node_Str"",entry.getValue().isEmpty());
  }
}","@Test public void testIterator() throws InterruptedException {
  Map<Key,Collection<Value>> expectedValuesMap1=collectData(generator1,INPUT_1_SIZE);
  Map<Key,Collection<Value>> expectedValuesMap2=collectData(generator2,INPUT_2_SIZE);
  Map<Key,Collection<Match>> expectedMatchesMap=matchValues(expectedValuesMap1,expectedValuesMap2);
  generator1.reset();
  generator2.reset();
  SortMergeMatchIterator<TestData.Key,TestData.Value,TestData.Value> iterator=new SortMergeMatchIterator<TestData.Key,TestData.Value,TestData.Value>(memoryManager,ioManager,reader1,reader2,TestData.Key.class,TestData.Value.class,TestData.Value.class,NUM_SORT_BUFFERS,SIZE_SORT_BUFFER,MEMORY_IO,128,parentTask);
  iterator.open();
  while (iterator.next()) {
    TestData.Key key=new TestData.Key(iterator.getKey().getKey());
    Assert.assertTrue(""String_Node_Str"" + key + ""String_Node_Str"",expectedMatchesMap.containsKey(key));
    Iterator<TestData.Value> iter1=iterator.getValues1();
    Iterator<TestData.Value> iter2=iterator.getValues2();
    List<TestData.Value> values1=new ArrayList<TestData.Value>();
    while (iter1.hasNext()) {
      values1.add(new TestData.Value(iter1.next().getValue()));
    }
    List<TestData.Value> values2=new ArrayList<TestData.Value>();
    while (iter2.hasNext()) {
      values2.add(new TestData.Value(iter2.next().getValue()));
    }
    for (    Value value1 : values1) {
      for (      Value value2 : values2) {
        Collection<Match> expectedValues=expectedMatchesMap.get(key);
        Match match=new Match(value1,value2);
        Assert.assertTrue(""String_Node_Str"" + match + ""String_Node_Str""+ key,expectedValues.contains(match));
        expectedValues.remove(match);
      }
    }
  }
  iterator.close();
  for (  Entry<Key,Collection<Match>> entry : expectedMatchesMap.entrySet()) {
    Assert.assertTrue(""String_Node_Str"" + entry.getKey() + ""String_Node_Str"",entry.getValue().isEmpty());
  }
}"
88375,"/** 
 * Entry point of the thread.
 */
public void go() throws Exception {
  final Channel.Enumerator enumerator=ioManager.createChannelEnumerator();
  List<Channel.ID> channelIDs=new ArrayList<Channel.ID>();
  Collection<MemorySegment> outputSegments=memoryManager.allocate(CombiningUnilateralSortMerger.this.parent,2,ioMemorySize / 2);
  CircularElement element=null;
  while (isRunning() && (element=queues.spill.take()) != SENTINEL) {
    Channel.ID channel=enumerator.next();
    channelIDs.add(channel);
    LOG.debug(""String_Node_Str"" + channel.toString() + '.');
    ChannelWriter writer=ioManager.createChannelWriter(channel,outputSegments);
    LOG.debug(""String_Node_Str"" + element.id + '.');
    final BufferSortable<K,V> buffer=element.buffer;
    final CombineValueIterator<V> iter=new CombineValueIterator<V>(buffer);
    final Collector<K,V> collector=new WriterCollector<K,V>(writer);
    int i=0;
    int stop=buffer.size() - 1;
    while (i < stop) {
      int seqStart=i;
      while (i < stop && 0 == buffer.compare(i,i + 1)) {
        i++;
      }
      if (i == seqStart) {
        buffer.writeToChannel(writer,seqStart,1);
      }
 else {
        K key=buffer.getKey(seqStart);
        iter.set(seqStart,i);
        combineStub.combine(key,iter,collector);
      }
      i++;
    }
    if (i == stop) {
      buffer.writeToChannel(writer,stop,1);
    }
    LOG.debug(""String_Node_Str"" + element.id + ""String_Node_Str"");
    outputSegments=writer.close();
    element.buffer.reset();
    queues.empty.put(element);
  }
  LOG.debug(""String_Node_Str"");
  LOG.debug(""String_Node_Str"");
  memoryManager.release(outputSegments);
  LOG.debug(""String_Node_Str"");
  while (!queues.empty.isEmpty()) {
    memoryManager.release(queues.empty.take().buffer.unbind());
  }
  while (channelIDs.size() > maxNumFileHandles) {
    channelIDs=mergeChannelList(channelIDs,ioMemorySize);
  }
  if (CombiningUnilateralSortMerger.this.combineLastMerge) {
    KeyGroupedIterator<K,V> iter=new KeyGroupedIterator<K,V>(getMergingIterator(channelIDs,ioMemorySize));
    lazyIterator.setTarget(new CombiningIterator<K,V>(combineStub,iter));
  }
 else {
    lazyIterator.setTarget(getMergingIterator(channelIDs,ioMemorySize));
  }
  LOG.debug(""String_Node_Str"");
}","/** 
 * Entry point of the thread.
 */
public void go() throws Exception {
  final Channel.Enumerator enumerator=ioManager.createChannelEnumerator();
  List<Channel.ID> channelIDs=new ArrayList<Channel.ID>();
  outputSegments=memoryManager.allocate(CombiningUnilateralSortMerger.this.parent,2,ioMemorySize / 2);
  CircularElement element=null;
  while (isRunning() && (element=queues.spill.take()) != SENTINEL) {
    Channel.ID channel=enumerator.next();
    channelIDs.add(channel);
    LOG.debug(""String_Node_Str"" + channel.toString() + '.');
    ChannelWriter writer=ioManager.createChannelWriter(channel,outputSegments);
    LOG.debug(""String_Node_Str"" + element.id + '.');
    final BufferSortable<K,V> buffer=element.buffer;
    final CombineValueIterator<V> iter=new CombineValueIterator<V>(buffer);
    final Collector<K,V> collector=new WriterCollector<K,V>(writer);
    int i=0;
    int stop=buffer.size() - 1;
    while (i < stop) {
      int seqStart=i;
      while (i < stop && 0 == buffer.compare(i,i + 1)) {
        i++;
      }
      if (i == seqStart) {
        buffer.writeToChannel(writer,seqStart,1);
      }
 else {
        K key=buffer.getKey(seqStart);
        iter.set(seqStart,i);
        combineStub.combine(key,iter,collector);
      }
      i++;
    }
    if (i == stop) {
      buffer.writeToChannel(writer,stop,1);
    }
    LOG.debug(""String_Node_Str"" + element.id + ""String_Node_Str"");
    outputSegments=writer.close();
    element.buffer.reset();
    queues.empty.put(element);
  }
  LOG.debug(""String_Node_Str"");
  LOG.debug(""String_Node_Str"");
  memoryManager.release(outputSegments);
  LOG.debug(""String_Node_Str"");
  while (!queues.empty.isEmpty()) {
    memoryManager.release(queues.empty.take().buffer.unbind());
  }
  while (channelIDs.size() > maxNumFileHandles) {
    channelIDs=mergeChannelList(channelIDs,ioMemorySize);
  }
  if (CombiningUnilateralSortMerger.this.combineLastMerge) {
    KeyGroupedIterator<K,V> iter=new KeyGroupedIterator<K,V>(getMergingIterator(channelIDs,ioMemorySize));
    lazyIterator.setTarget(new CombiningIterator<K,V>(combineStub,iter));
  }
 else {
    lazyIterator.setTarget(getMergingIterator(channelIDs,ioMemorySize));
  }
  LOG.debug(""String_Node_Str"");
}"
88376,"/** 
 * @param channelIDs
 * @param ioMemorySize
 * @return The ID of the channel that holds the merged data of all input channels.
 */
protected Channel.ID mergeChannels(List<Channel.ID> channelIDs,int ioMemorySize){
  List<Iterator<KeyValuePair<K,V>>> iterators=new ArrayList<Iterator<KeyValuePair<K,V>>>(channelIDs.size());
  final int ioMemoryPerChannel=ioMemorySize / (channelIDs.size() + 2);
  for (  Channel.ID id : channelIDs) {
    Collection<MemorySegment> inputSegments;
    final ChannelReader reader;
    try {
      inputSegments=memoryManager.allocate(this.parent,1,ioMemoryPerChannel);
      freeSegmentsAtShutdown(inputSegments);
      reader=ioManager.createChannelReader(id,inputSegments);
    }
 catch (    MemoryAllocationException mae) {
      throw new RuntimeException(""String_Node_Str"",mae);
    }
catch (    ServiceException se) {
      throw new RuntimeException(""String_Node_Str"",se);
    }
    final Iterator<KeyValuePair<K,V>> iterator=new KVReaderIterator<K,V>(reader,keySerialization,valueSerialization,memoryManager,true);
    iterators.add(iterator);
  }
  MergeIterator<K,V> mi=new MergeIterator<K,V>(iterators,keyComparator);
  KeyGroupedIterator<K,V> groupedIter=new KeyGroupedIterator<K,V>(mi);
  final Channel.Enumerator enumerator=ioManager.createChannelEnumerator();
  final Channel.ID mergedChannelID=enumerator.next();
  Collection<MemorySegment> outputSegments;
  ChannelWriter writer;
  try {
    outputSegments=memoryManager.allocate(this.parent,2,ioMemoryPerChannel);
    freeSegmentsAtShutdown(outputSegments);
    writer=ioManager.createChannelWriter(mergedChannelID,outputSegments);
  }
 catch (  MemoryAllocationException mae) {
    throw new RuntimeException(""String_Node_Str"",mae);
  }
catch (  ServiceException se) {
    throw new RuntimeException(""String_Node_Str"",se);
  }
  WriterCollector<K,V> collector=new WriterCollector<K,V>(writer);
  while (groupedIter.nextKey()) {
    this.combineStub.combine(groupedIter.getKey(),groupedIter.getValues(),collector);
  }
  try {
    outputSegments=writer.close();
  }
 catch (  ServiceException se) {
    throw new RuntimeException(""String_Node_Str"",se);
  }
  memoryManager.release(outputSegments);
  return mergedChannelID;
}","/** 
 * @param channelIDs
 * @param ioMemorySize
 * @return The ID of the channel that holds the merged data of all input channels.
 */
protected Channel.ID mergeChannels(List<Channel.ID> channelIDs,int ioMemorySize){
  List<Iterator<KeyValuePair<K,V>>> iterators=new ArrayList<Iterator<KeyValuePair<K,V>>>(channelIDs.size());
  final int ioMemoryPerChannel=ioMemorySize / (channelIDs.size() + 2);
  for (  Channel.ID id : channelIDs) {
    final ChannelReader reader;
    try {
      inputSegments=memoryManager.allocate(this.parent,1,ioMemoryPerChannel);
      freeSegmentsAtShutdown(inputSegments);
      reader=ioManager.createChannelReader(id,inputSegments);
    }
 catch (    MemoryAllocationException mae) {
      throw new RuntimeException(""String_Node_Str"",mae);
    }
catch (    ServiceException se) {
      throw new RuntimeException(""String_Node_Str"",se);
    }
    final Iterator<KeyValuePair<K,V>> iterator=new KVReaderIterator<K,V>(reader,keySerialization,valueSerialization,memoryManager,true);
    iterators.add(iterator);
  }
  MergeIterator<K,V> mi=new MergeIterator<K,V>(iterators,keyComparator);
  KeyGroupedIterator<K,V> groupedIter=new KeyGroupedIterator<K,V>(mi);
  final Channel.Enumerator enumerator=ioManager.createChannelEnumerator();
  final Channel.ID mergedChannelID=enumerator.next();
  ChannelWriter writer;
  try {
    outputSegments=memoryManager.allocate(this.parent,2,ioMemoryPerChannel);
    freeSegmentsAtShutdown(outputSegments);
    writer=ioManager.createChannelWriter(mergedChannelID,outputSegments);
  }
 catch (  MemoryAllocationException mae) {
    throw new RuntimeException(""String_Node_Str"",mae);
  }
catch (  ServiceException se) {
    throw new RuntimeException(""String_Node_Str"",se);
  }
  WriterCollector<K,V> collector=new WriterCollector<K,V>(writer);
  while (groupedIter.nextKey()) {
    this.combineStub.combine(groupedIter.getKey(),groupedIter.getValues(),collector);
  }
  try {
    outputSegments=writer.close();
  }
 catch (  ServiceException se) {
    throw new RuntimeException(""String_Node_Str"",se);
  }
  memoryManager.release(outputSegments);
  return mergedChannelID;
}"
88377,"/** 
 * Entry point of the thread.
 */
public void go() throws Exception {
  final Channel.Enumerator enumerator=ioManager.createChannelEnumerator();
  List<Channel.ID> channelIDs=new ArrayList<Channel.ID>();
  Collection<MemorySegment> outputSegments=memoryManager.allocate(UnilateralSortMerger.this.parent,2,ioMemorySize / 2);
  freeSegmentsAtShutdown(outputSegments);
  CircularElement element=null;
  while (isRunning() && (element=queues.spill.take()) != SENTINEL) {
    Channel.ID channel=enumerator.next();
    channelIDs.add(channel);
    ChannelWriter writer=ioManager.createChannelWriter(channel,outputSegments);
    LOG.debug(""String_Node_Str"" + element.id + ""String_Node_Str"");
    element.buffer.writeToChannel(writer);
    LOG.debug(""String_Node_Str"" + element.id + ""String_Node_Str"");
    outputSegments=writer.close();
    element.buffer.reset();
    queues.empty.put(element);
  }
  LOG.debug(""String_Node_Str"");
  LOG.debug(""String_Node_Str"");
  memoryManager.release(outputSegments);
  LOG.debug(""String_Node_Str"");
  while (!queues.empty.isEmpty()) {
    memoryManager.release(queues.empty.take().buffer.unbind());
  }
  while (channelIDs.size() > maxNumFileHandles) {
    channelIDs=mergeChannelList(channelIDs,ioMemorySize);
  }
  lazyIterator.setTarget(getMergingIterator(channelIDs,ioMemorySize));
  LOG.debug(""String_Node_Str"");
}","/** 
 * Entry point of the thread.
 */
public void go() throws Exception {
  final Channel.Enumerator enumerator=ioManager.createChannelEnumerator();
  List<Channel.ID> channelIDs=new ArrayList<Channel.ID>();
  outputSegments=memoryManager.allocate(UnilateralSortMerger.this.parent,2,ioMemorySize / 2);
  freeSegmentsAtShutdown(outputSegments);
  CircularElement element=null;
  while (isRunning() && (element=queues.spill.take()) != SENTINEL) {
    Channel.ID channel=enumerator.next();
    channelIDs.add(channel);
    ChannelWriter writer=ioManager.createChannelWriter(channel,outputSegments);
    LOG.debug(""String_Node_Str"" + element.id + ""String_Node_Str"");
    element.buffer.writeToChannel(writer);
    LOG.debug(""String_Node_Str"" + element.id + ""String_Node_Str"");
    outputSegments=writer.close();
    element.buffer.reset();
    queues.empty.put(element);
  }
  LOG.debug(""String_Node_Str"");
  LOG.debug(""String_Node_Str"");
  memoryManager.release(outputSegments);
  LOG.debug(""String_Node_Str"");
  while (!queues.empty.isEmpty()) {
    memoryManager.release(queues.empty.take().buffer.unbind());
  }
  while (channelIDs.size() > maxNumFileHandles) {
    channelIDs=mergeChannelList(channelIDs,ioMemorySize);
  }
  lazyIterator.setTarget(getMergingIterator(channelIDs,ioMemorySize));
  LOG.debug(""String_Node_Str"");
}"
88378,"/** 
 * Forces an immediate shutdown of the thread. Looses any state and all buffers that the thread is currently working on. This terminates cleanly for the JVM, but looses intermediate results.
 */
public void shutdown(){
  this.alive=false;
  this.interrupt();
}","@Override public void shutdown(){
  this.memoryManager.release(outputSegments);
  super.shutdown();
}"
88379,"/** 
 * Assigns the execution vertex with an   {@link AllocatedResource}.
 * @param allocatedResource the resources which are supposed to be allocated to this vertex
 */
public synchronized void setAllocatedResource(AllocatedResource allocatedResource){
  this.allocatedResource=allocatedResource;
}","/** 
 * Assigns the execution vertex with an   {@link AllocatedResource}.
 * @param allocatedResource the resources which are supposed to be allocated to this vertex
 */
public synchronized void setAllocatedResource(AllocatedResource allocatedResource){
  this.allocatedResource=allocatedResource;
  final Iterator<VertexAssignmentListener> it=this.vertexAssignmentListeners.iterator();
  while (it.hasNext()) {
    it.next().vertexAssignmentChanged(this.vertexID,this.allocatedResource);
  }
}"
88380,"/** 
 * Registers a job in form of its execution graph representation with the job progress collector. The collector will subscribe to state changes of the individual subtasks. A separate deregistration is not necessary since the job progress collector periodically discards outdated progress information.
 * @param executionGraph the execution graph representing the job
 * @param profilingAvailable indicates if profiling data is available for this job
 */
public void registerJob(ExecutionGraph executionGraph,boolean profilingAvailable){
  final Iterator<ExecutionVertex> it=new ExecutionGraphIterator(executionGraph,true);
  while (it.hasNext()) {
    final ExecutionVertex vertex=it.next();
    vertex.getEnvironment().registerExecutionListener(new ExecutionListenerWrapper(this,vertex.getGroupVertex().getJobVertexID(),vertex.getID()));
  }
  executionGraph.registerJobStatusListener(new JobStatusListenerWrapper(this,executionGraph.getJobName(),profilingAvailable));
}","/** 
 * Registers a job in form of its execution graph representation with the job progress collector. The collector will subscribe to state changes of the individual subtasks. A separate deregistration is not necessary since the job progress collector periodically discards outdated progress information.
 * @param executionGraph the execution graph representing the job
 * @param profilingAvailable indicates if profiling data is available for this job
 */
public void registerJob(ExecutionGraph executionGraph,boolean profilingAvailable){
  final Iterator<ExecutionVertex> it=new ExecutionGraphIterator(executionGraph,true);
  while (it.hasNext()) {
    final ExecutionVertex vertex=it.next();
    vertex.getEnvironment().registerExecutionListener(new ExecutionListenerWrapper(this,vertex.getGroupVertex().getJobVertexID(),vertex.getID()));
    vertex.registerVertexAssignmentListener(new VertexAssignmentListenerWrapper(this,executionGraph.getJobID()));
  }
  executionGraph.registerJobStatusListener(new JobStatusListenerWrapper(this,executionGraph.getJobName(),profilingAvailable));
}"
88381,"@Override public void processProfilingEvents(ProfilingEvent profilingEvent){
  addEvent(profilingEvent.getJobID(),profilingEvent);
}","/** 
 * {@inheritDoc}
 */
@Override public void processProfilingEvents(ProfilingEvent profilingEvent){
  addEvent(profilingEvent.getJobID(),profilingEvent);
}"
88382,"public void updateView(){
  if (this.threadChart != null) {
    this.threadChart.getChart().getXYPlot().configureDomainAxes();
    this.threadChart.getChart().fireChartChanged();
  }
  this.executionStateLabel.setText(this.managementVertex.getExecutionState().toString());
  final ManagementGroupVertex groupVertex=this.managementVertex.getGroupVertex();
  final GroupVertexVisualizationData groupVertexVisualizationData=(GroupVertexVisualizationData)groupVertex.getAttachment();
  if (groupVertexVisualizationData.isCPUBottleneck()) {
    if (this.warningComposite == null) {
      this.warningComposite=createWarningComposite(WARNINGTEXT,SWT.ICON_WARNING);
      Rectangle clientRect=getShell().getClientArea();
      clientRect.height+=ICONSIZE;
      getShell().setSize(clientRect.width,clientRect.height);
    }
  }
 else {
    if (this.warningComposite != null) {
      this.warningComposite.dispose();
      this.warningComposite=null;
      Rectangle clientRect=getShell().getClientArea();
      clientRect.height-=ICONSIZE;
      getShell().setSize(clientRect.width,clientRect.height);
    }
  }
}","public void updateView(){
  if (this.threadChart != null) {
    this.threadChart.getChart().getXYPlot().configureDomainAxes();
    this.threadChart.getChart().fireChartChanged();
  }
  this.executionStateLabel.setText(this.managementVertex.getExecutionState().toString());
  this.instanceIDLabel.setText(this.managementVertex.getInstanceName());
  this.instanceTypeLabel.setText(this.managementVertex.getInstanceType());
  final ManagementGroupVertex groupVertex=this.managementVertex.getGroupVertex();
  final GroupVertexVisualizationData groupVertexVisualizationData=(GroupVertexVisualizationData)groupVertex.getAttachment();
  if (groupVertexVisualizationData.isCPUBottleneck()) {
    if (this.warningComposite == null) {
      this.warningComposite=createWarningComposite(WARNINGTEXT,SWT.ICON_WARNING);
      Rectangle clientRect=getShell().getClientArea();
      clientRect.height+=ICONSIZE;
      getShell().setSize(clientRect.width,clientRect.height);
    }
  }
 else {
    if (this.warningComposite != null) {
      this.warningComposite.dispose();
      this.warningComposite=null;
      Rectangle clientRect=getShell().getClientArea();
      clientRect.height-=ICONSIZE;
      getShell().setSize(clientRect.width,clientRect.height);
    }
  }
}"
88383,"private void dispatchEvent(AbstractEvent event,GraphVisualizationData graphVisualizationData){
  if (event instanceof VertexProfilingEvent) {
    final VertexProfilingEvent vertexProfilingEvent=(VertexProfilingEvent)event;
    final ManagementGraph graph=graphVisualizationData.getManagementGraph();
    final ManagementVertex vertex=graph.getVertexByID(vertexProfilingEvent.getVertexID());
    if (vertexProfilingEvent instanceof ThreadProfilingEvent) {
      final VertexVisualizationData vertexVisualizationData=(VertexVisualizationData)vertex.getAttachment();
      vertexVisualizationData.processThreadProfilingEvent((ThreadProfilingEvent)vertexProfilingEvent);
    }
 else     if (vertexProfilingEvent instanceof OutputGateProfilingEvent) {
      final OutputGateProfilingEvent outputGateProfilingEvent=(OutputGateProfilingEvent)vertexProfilingEvent;
      final ManagementGate managementGate=vertex.getOutputGate(outputGateProfilingEvent.getGateIndex());
      final GateVisualizationData gateVisualizationData=(GateVisualizationData)managementGate.getAttachment();
      gateVisualizationData.processOutputGateProfilingEvent(outputGateProfilingEvent);
    }
 else     if (vertexProfilingEvent instanceof InputGateProfilingEvent) {
      final InputGateProfilingEvent inputGateProfilingEvent=(InputGateProfilingEvent)vertexProfilingEvent;
      final ManagementGate managementGate=vertex.getInputGate(inputGateProfilingEvent.getGateIndex());
      final GateVisualizationData gateVisualizationData=(GateVisualizationData)managementGate.getAttachment();
      gateVisualizationData.processInputGateProfilingEvent(inputGateProfilingEvent);
    }
  }
 else   if (event instanceof InstanceProfilingEvent) {
    final NetworkTopology networkTopology=graphVisualizationData.getNetworkTopology();
    if (event instanceof InstanceSummaryProfilingEvent) {
      final InstanceVisualizationData instanceVisualizationData=(InstanceVisualizationData)networkTopology.getAttachment();
      instanceVisualizationData.processInstanceProfilingEvent((InstanceSummaryProfilingEvent)event);
    }
 else {
      final SingleInstanceProfilingEvent singleInstanceProfilingEvent=(SingleInstanceProfilingEvent)event;
      final NetworkNode networkNode=networkTopology.getNodeByName(singleInstanceProfilingEvent.getInstanceName());
      final InstanceVisualizationData instanceVisualizationData=(InstanceVisualizationData)networkNode.getAttachment();
      instanceVisualizationData.processInstanceProfilingEvent(singleInstanceProfilingEvent);
    }
  }
 else   if (event instanceof ExecutionStateChangeEvent) {
    final ExecutionStateChangeEvent executionStateChangeEvent=(ExecutionStateChangeEvent)event;
    final ManagementGraph graph=graphVisualizationData.getManagementGraph();
    final ManagementVertex vertex=graph.getVertexByID(executionStateChangeEvent.getVertexID());
    vertex.setExecutionState(executionStateChangeEvent.getNewExecutionState());
  }
 else {
    System.out.println(""String_Node_Str"" + event);
  }
}","private void dispatchEvent(AbstractEvent event,GraphVisualizationData graphVisualizationData){
  if (event instanceof VertexProfilingEvent) {
    final VertexProfilingEvent vertexProfilingEvent=(VertexProfilingEvent)event;
    final ManagementGraph graph=graphVisualizationData.getManagementGraph();
    final ManagementVertex vertex=graph.getVertexByID(vertexProfilingEvent.getVertexID());
    if (vertexProfilingEvent instanceof ThreadProfilingEvent) {
      final VertexVisualizationData vertexVisualizationData=(VertexVisualizationData)vertex.getAttachment();
      vertexVisualizationData.processThreadProfilingEvent((ThreadProfilingEvent)vertexProfilingEvent);
    }
 else     if (vertexProfilingEvent instanceof OutputGateProfilingEvent) {
      final OutputGateProfilingEvent outputGateProfilingEvent=(OutputGateProfilingEvent)vertexProfilingEvent;
      final ManagementGate managementGate=vertex.getOutputGate(outputGateProfilingEvent.getGateIndex());
      final GateVisualizationData gateVisualizationData=(GateVisualizationData)managementGate.getAttachment();
      gateVisualizationData.processOutputGateProfilingEvent(outputGateProfilingEvent);
    }
 else     if (vertexProfilingEvent instanceof InputGateProfilingEvent) {
      final InputGateProfilingEvent inputGateProfilingEvent=(InputGateProfilingEvent)vertexProfilingEvent;
      final ManagementGate managementGate=vertex.getInputGate(inputGateProfilingEvent.getGateIndex());
      final GateVisualizationData gateVisualizationData=(GateVisualizationData)managementGate.getAttachment();
      gateVisualizationData.processInputGateProfilingEvent(inputGateProfilingEvent);
    }
  }
 else   if (event instanceof InstanceProfilingEvent) {
    final NetworkTopology networkTopology=graphVisualizationData.getNetworkTopology();
    if (event instanceof InstanceSummaryProfilingEvent) {
      final InstanceVisualizationData instanceVisualizationData=(InstanceVisualizationData)networkTopology.getAttachment();
      instanceVisualizationData.processInstanceProfilingEvent((InstanceSummaryProfilingEvent)event);
    }
 else {
      final SingleInstanceProfilingEvent singleInstanceProfilingEvent=(SingleInstanceProfilingEvent)event;
      final NetworkNode networkNode=networkTopology.getNodeByName(singleInstanceProfilingEvent.getInstanceName());
      final InstanceVisualizationData instanceVisualizationData=(InstanceVisualizationData)networkNode.getAttachment();
      instanceVisualizationData.processInstanceProfilingEvent(singleInstanceProfilingEvent);
    }
  }
 else   if (event instanceof ExecutionStateChangeEvent) {
    final ExecutionStateChangeEvent executionStateChangeEvent=(ExecutionStateChangeEvent)event;
    final ManagementGraph graph=graphVisualizationData.getManagementGraph();
    final ManagementVertex vertex=graph.getVertexByID(executionStateChangeEvent.getVertexID());
    vertex.setExecutionState(executionStateChangeEvent.getNewExecutionState());
  }
 else   if (event instanceof VertexAssignmentEvent) {
    final VertexAssignmentEvent vertexAssignmentEvent=(VertexAssignmentEvent)event;
    final ManagementGraph graph=graphVisualizationData.getManagementGraph();
    final ManagementVertex vertex=graph.getVertexByID(vertexAssignmentEvent.getVertexID());
    vertex.setInstanceName(vertexAssignmentEvent.getInstanceName());
    vertex.setInstanceType(vertexAssignmentEvent.getInstanceType());
  }
 else {
    System.out.println(""String_Node_Str"" + event);
  }
}"
88384,"protected JobGraph getJobGraph() throws Exception {
  JobGraph jobGraph=new JobGraph(""String_Node_Str"");
  JobFileInputVertex input=new JobFileInputVertex(""String_Node_Str"",jobGraph);
  input.setFileInputClass(FileLineReader.class);
  input.setFilePath(new Path(hdfs.getTempDirPath() + ""String_Node_Str""));
  JobTaskVertex task=new JobTaskVertex(""String_Node_Str"",jobGraph);
  task.setTaskClass(GrepTask.class);
  JobFileOutputVertex output=new JobFileOutputVertex(""String_Node_Str"",jobGraph);
  output.setFileOutputClass(FileLineWriter.class);
  output.setFilePath(new Path(hdfs.getTempDirPath() + ""String_Node_Str""));
  input.connectTo(task,ChannelType.INMEMORY,CompressionLevel.NO_COMPRESSION);
  task.connectTo(output,ChannelType.INMEMORY,CompressionLevel.NO_COMPRESSION);
  return jobGraph;
}","protected JobGraph getJobGraph() throws Exception {
  JobGraph jobGraph=new JobGraph(""String_Node_Str"");
  JobFileInputVertex input=new JobFileInputVertex(""String_Node_Str"",jobGraph);
  input.setFileInputClass(FileLineReader.class);
  input.setFilePath(new Path(hdfs.getURIPrefix() + hdfs.getTempDirPath() + ""String_Node_Str""));
  JobTaskVertex task=new JobTaskVertex(""String_Node_Str"",jobGraph);
  task.setTaskClass(GrepTask.class);
  JobFileOutputVertex output=new JobFileOutputVertex(""String_Node_Str"",jobGraph);
  output.setFileOutputClass(FileLineWriter.class);
  output.setFilePath(new Path(hdfs.getURIPrefix() + hdfs.getTempDirPath() + ""String_Node_Str""));
  input.connectTo(task,ChannelType.INMEMORY,CompressionLevel.NO_COMPRESSION);
  task.connectTo(output,ChannelType.INMEMORY,CompressionLevel.NO_COMPRESSION);
  return jobGraph;
}"
88385,"protected void preSubmit() throws Exception {
  OutputStream os=hdfs.getOutputStream(""String_Node_Str"");
  Writer wr=new OutputStreamWriter(os);
  wr.write(""String_Node_Str"");
  wr.write(""String_Node_Str"");
  wr.write(""String_Node_Str"");
  wr.close();
}","protected void preSubmit() throws Exception {
  OutputStream os=hdfs.getOutputStream(hdfs.getTempDirPath() + ""String_Node_Str"");
  Writer wr=new OutputStreamWriter(os);
  wr.write(""String_Node_Str"");
  wr.write(""String_Node_Str"");
  wr.write(""String_Node_Str"");
  wr.close();
}"
88386,"/** 
 * Verifies that at least one InputSplit was assigned to each vertex
 * @throws ExecutionFailureException
 */
private void verifyAssignments() throws ExecutionFailureException {
  while (this.vertexPrioQueue.size() > 0) {
    QueueElem topElem=this.vertexPrioQueue.poll();
    if (topElem.getNoAssignedSplits() == 0) {
      throw new ExecutionFailureException(""String_Node_Str"" + topElem.getVertex().getName() + ""String_Node_Str""+ topElem.getVertex().getAllocatedResource().getInstance().getInstanceConnectionInfo().getHostName()+ ""String_Node_Str""+ topElem.getVertex().getID()+ ""String_Node_Str"");
    }
    LOG.info(topElem.getNoAssignedSplits() + ""String_Node_Str"" + topElem.getVertex().getAllocatedResource().getInstance().getInstanceConnectionInfo().getHostName());
    for (    InputSplit is : topElem.getVertex().getEnvironment().getInputSplits()) {
      LOG.info(""String_Node_Str"" + ((FileInputSplit)is).getPath());
      for (      String hn : is.getHostNames()) {
        LOG.info(""String_Node_Str"" + hn);
      }
    }
  }
}","/** 
 * Verifies that at least one InputSplit was assigned to each vertex
 * @throws ExecutionFailureException
 */
private void verifyAssignments() throws ExecutionFailureException {
  while (this.vertexPrioQueue.size() > 0) {
    final QueueElem topElem=this.vertexPrioQueue.poll();
    if (topElem.getNoAssignedSplits() == 0) {
      continue;
    }
    LOG.info(topElem.getNoAssignedSplits() + ""String_Node_Str"" + topElem.getVertex().getAllocatedResource().getInstance().getInstanceConnectionInfo().getHostName());
    for (    InputSplit is : topElem.getVertex().getEnvironment().getInputSplits()) {
      LOG.info(""String_Node_Str"" + ((FileInputSplit)is).getPath());
      for (      String hn : is.getHostNames()) {
        LOG.info(""String_Node_Str"" + hn);
      }
    }
  }
}"
88387,"/** 
 * Assign InputSplits for a ExecutionGroupVertex
 * @param graph ExecutionGraph the ExecutionGroupVertex belongs to
 * @param groupVertex ExecutionGroupVertex who's InputSplits will be assigned
 * @return <code>false</code> if the instance assignment could not be done because at least one vertex has not beenin state <code>READY</code>, <code>true/code> otherwise
 * @throws ExecutionFailureException
 */
private boolean assignInputSplits(ExecutionGroupVertex groupVertex) throws ExecutionFailureException {
  for (int i=0; i < groupVertex.getCurrentNumberOfGroupMembers(); i++) {
    if (!groupVertex.getGroupMember(i).getExecutionState().equals(ExecutionState.READY)) {
      return false;
    }
  }
  final InputSplit[] inputSplits=groupVertex.getInputSplits();
  if (inputSplits == null) {
    throw new ExecutionFailureException(""String_Node_Str"" + groupVertex.getName() + ""String_Node_Str"");
  }
  LOG.info(""String_Node_Str"" + inputSplits.length + ""String_Node_Str""+ groupVertex.getName());
  initializePriorityQueue(groupVertex,inputSplits);
  for (int i=0; i < inputSplits.length; i++) {
    addFileSplit(inputSplits[i]);
  }
  verifyAssignments();
  vertexPrioQueue.clear();
  return true;
}","/** 
 * Assign InputSplits for a ExecutionGroupVertex
 * @param graph ExecutionGraph the ExecutionGroupVertex belongs to
 * @param groupVertex ExecutionGroupVertex who's InputSplits will be assigned
 * @return <code>false</code> if the instance assignment could not be done because at least one vertex has not yetbeen assigned to a real instance, <code>true/code> otherwise
 * @throws ExecutionFailureException
 */
private boolean assignInputSplits(ExecutionGroupVertex groupVertex) throws ExecutionFailureException {
  for (int i=0; i < groupVertex.getCurrentNumberOfGroupMembers(); i++) {
    final AllocatedResource ar=groupVertex.getGroupMember(i).getAllocatedResource();
    if (ar.getInstance() instanceof DummyInstance) {
      return false;
    }
  }
  final InputSplit[] inputSplits=groupVertex.getInputSplits();
  if (inputSplits == null) {
    throw new ExecutionFailureException(""String_Node_Str"" + groupVertex.getName() + ""String_Node_Str"");
  }
  LOG.info(""String_Node_Str"" + inputSplits.length + ""String_Node_Str""+ groupVertex.getName());
  initializePriorityQueue(groupVertex,inputSplits);
  for (int i=0; i < inputSplits.length; i++) {
    addFileSplit(inputSplits[i]);
  }
  verifyAssignments();
  vertexPrioQueue.clear();
  return true;
}"
88388,"/** 
 * {@inheritDoc}
 */
@Override public void run(){
  this.instanceListener.resourceAllocated(this.allocatedSlice.getJobID(),new AllocatedResource(this.allocatedSlice.getHostingInstance(),this.allocatedSlice.getAllocationID()));
}","/** 
 * {@inheritDoc}
 */
@Override public void run(){
  this.instanceListener.resourceAllocated(this.allocatedSlice.getJobID(),new AllocatedResource(this.allocatedSlice.getHostingInstance(),this.allocatedSlice.getType(),this.allocatedSlice.getAllocationID()));
}"
88389,"@Override public synchronized void requestInstance(JobID jobID,Configuration conf,InstanceType instanceType) throws InstanceException {
  for (  ClusterInstance host : registeredHosts.values()) {
    final AllocatedSlice slice=host.createSlice(instanceType,jobID);
    if (slice != null) {
      List<AllocatedSlice> allocatedSlices=this.slicesOfJobs.get(jobID);
      if (allocatedSlices == null) {
        allocatedSlices=new ArrayList<AllocatedSlice>();
        this.slicesOfJobs.put(jobID,allocatedSlices);
      }
      allocatedSlices.add(slice);
      if (this.instanceListener != null) {
        ClusterInstanceNotifier clusterInstanceNotifier=new ClusterInstanceNotifier(this.instanceListener,slice);
        clusterInstanceNotifier.start();
      }
      return;
    }
  }
  throw new InstanceException(""String_Node_Str"");
}","/** 
 * {@inheritDoc}
 */
@Override public synchronized void requestInstance(JobID jobID,Configuration conf,InstanceType instanceType) throws InstanceException {
  for (  ClusterInstance host : registeredHosts.values()) {
    final AllocatedSlice slice=host.createSlice(instanceType,jobID);
    if (slice != null) {
      List<AllocatedSlice> allocatedSlices=this.slicesOfJobs.get(jobID);
      if (allocatedSlices == null) {
        allocatedSlices=new ArrayList<AllocatedSlice>();
        this.slicesOfJobs.put(jobID,allocatedSlices);
      }
      allocatedSlices.add(slice);
      if (this.instanceListener != null) {
        ClusterInstanceNotifier clusterInstanceNotifier=new ClusterInstanceNotifier(this.instanceListener,slice);
        clusterInstanceNotifier.start();
      }
      return;
    }
  }
  throw new InstanceException(""String_Node_Str"");
}"
88390,"@Override public void run(){
synchronized (ClusterManager.this) {
    final List<Map.Entry<InstanceConnectionInfo,ClusterInstance>> hostsToRemove=new ArrayList<Map.Entry<InstanceConnectionInfo,ClusterInstance>>();
    for (    Map.Entry<InstanceConnectionInfo,ClusterInstance> entry : registeredHosts.entrySet()) {
      final ClusterInstance host=entry.getValue();
      if (!host.isStillAlive(cleanUpInterval)) {
        final List<AllocatedSlice> removedSlices=host.removeAllAllocatedSlices();
        for (        AllocatedSlice removedSlice : removedSlices) {
          final JobID jobID=removedSlice.getJobID();
          final List<AllocatedSlice> slicesOfJob=slicesOfJobs.get(jobID);
          if (slicesOfJob == null) {
            LOG.error(""String_Node_Str"" + jobID);
            continue;
          }
          slicesOfJob.remove(removedSlice);
          if (slicesOfJob.isEmpty()) {
            slicesOfJobs.remove(jobID);
          }
          if (instanceListener != null) {
            instanceListener.allocatedResourceDied(removedSlice.getJobID(),new AllocatedResource(removedSlice.getHostingInstance(),removedSlice.getAllocationID()));
          }
        }
        hostsToRemove.add(entry);
      }
    }
    registeredHosts.entrySet().removeAll(hostsToRemove);
    updateInstaceTypeDescriptionMap();
  }
}","@Override public void run(){
synchronized (ClusterManager.this) {
    final List<Map.Entry<InstanceConnectionInfo,ClusterInstance>> hostsToRemove=new ArrayList<Map.Entry<InstanceConnectionInfo,ClusterInstance>>();
    for (    Map.Entry<InstanceConnectionInfo,ClusterInstance> entry : registeredHosts.entrySet()) {
      final ClusterInstance host=entry.getValue();
      if (!host.isStillAlive(cleanUpInterval)) {
        final List<AllocatedSlice> removedSlices=host.removeAllAllocatedSlices();
        for (        AllocatedSlice removedSlice : removedSlices) {
          final JobID jobID=removedSlice.getJobID();
          final List<AllocatedSlice> slicesOfJob=slicesOfJobs.get(jobID);
          if (slicesOfJob == null) {
            LOG.error(""String_Node_Str"" + jobID);
            continue;
          }
          slicesOfJob.remove(removedSlice);
          if (slicesOfJob.isEmpty()) {
            slicesOfJobs.remove(jobID);
          }
          if (instanceListener != null) {
            instanceListener.allocatedResourceDied(removedSlice.getJobID(),new AllocatedResource(removedSlice.getHostingInstance(),removedSlice.getType(),removedSlice.getAllocationID()));
          }
        }
        hostsToRemove.add(entry);
      }
    }
    registeredHosts.entrySet().removeAll(hostsToRemove);
    updateInstaceTypeDescriptionMap();
  }
}"
88391,"/** 
 * Creates a new cloud instance.
 * @param instanceID the instance ID assigned by the cloud management system
 * @param type the instance type
 * @param instanceOwner the owner of the instance
 * @param instanceConnectionInfo the information required to connect to the instance's task manager
 * @param allocationTime the time the instance was allocated
 * @param parentNode the parent node in the network topology
 * @param hardwareDescription the hardware description reported by the instance itself
 */
public CloudInstance(String instanceID,InstanceType type,String instanceOwner,InstanceConnectionInfo instanceConnectionInfo,long allocationTime,NetworkNode parentNode,NetworkTopology networkTopology,HardwareDescription hardwareDescription){
  super(type,instanceConnectionInfo,parentNode,networkTopology,hardwareDescription);
  this.allocatedResource=new AllocatedResource(this,new AllocationID());
  this.instanceID=instanceID;
  this.instanceOwner=instanceOwner;
  this.allocationTime=allocationTime;
}","/** 
 * Creates a new cloud instance.
 * @param instanceID the instance ID assigned by the cloud management system
 * @param type the instance type
 * @param instanceOwner the owner of the instance
 * @param instanceConnectionInfo the information required to connect to the instance's task manager
 * @param allocationTime the time the instance was allocated
 * @param parentNode the parent node in the network topology
 * @param hardwareDescription the hardware description reported by the instance itself
 */
public CloudInstance(String instanceID,InstanceType type,String instanceOwner,InstanceConnectionInfo instanceConnectionInfo,long allocationTime,NetworkNode parentNode,NetworkTopology networkTopology,HardwareDescription hardwareDescription){
  super(type,instanceConnectionInfo,parentNode,networkTopology,hardwareDescription);
  this.allocatedResource=new AllocatedResource(this,type,new AllocationID());
  this.instanceID=instanceID;
  this.instanceOwner=instanceOwner;
  this.allocationTime=allocationTime;
}"
88392,"/** 
 * {@inheritDoc}
 */
@Override public void resourceAllocated(JobID jobID,AllocatedResource allocatedResource){
  if (allocatedResource == null) {
    LOG.error(""String_Node_Str"");
    return;
  }
  if (allocatedResource.getInstance() instanceof DummyInstance) {
    LOG.debug(""String_Node_Str"");
    return;
  }
  try {
    allocatedResource.getInstance().checkLibraryAvailability(jobID);
  }
 catch (  IOException ioe) {
    LOG.error(""String_Node_Str"" + StringUtils.stringifyException(ioe));
  }
synchronized (this.jobQueue) {
    final ExecutionGraph eg=getExecutionGraphByID(jobID);
    if (eg == null) {
      try {
        this.instanceManager.releaseAllocatedResource(jobID,null,allocatedResource);
      }
 catch (      InstanceException e) {
        LOG.error(e);
      }
      return;
    }
    AllocatedResource resourceToBeReplaced=null;
    ExecutionGraphIterator it=new ExecutionGraphIterator(eg,eg.getIndexOfCurrentExecutionStage(),true,true);
    while (it.hasNext()) {
      final ExecutionVertex vertex=it.next();
      if (vertex.getExecutionState() == ExecutionState.ASSIGNING && vertex.getAllocatedResource() != null) {
        if (vertex.getAllocatedResource().getInstance().getType().equals(allocatedResource.getInstance().getType())) {
          resourceToBeReplaced=vertex.getAllocatedResource();
          break;
        }
      }
    }
    if (resourceToBeReplaced == null) {
      LOG.warn(""String_Node_Str"" + allocatedResource.getInstance() + ""String_Node_Str""+ eg.getJobID());
      try {
        this.instanceManager.releaseAllocatedResource(jobID,eg.getJobConfiguration(),allocatedResource);
      }
 catch (      InstanceException e) {
        LOG.error(e);
      }
      return;
    }
    it=new ExecutionGraphIterator(eg,true);
    while (it.hasNext()) {
      final ExecutionVertex vertex=it.next();
      if (vertex.getAllocatedResource().equals(resourceToBeReplaced)) {
        vertex.setAllocatedResource(allocatedResource);
        vertex.setExecutionState(ExecutionState.ASSIGNED);
      }
    }
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void resourceAllocated(JobID jobID,AllocatedResource allocatedResource){
  if (allocatedResource == null) {
    LOG.error(""String_Node_Str"");
    return;
  }
  if (allocatedResource.getInstance() instanceof DummyInstance) {
    LOG.debug(""String_Node_Str"");
    return;
  }
  try {
    allocatedResource.getInstance().checkLibraryAvailability(jobID);
  }
 catch (  IOException ioe) {
    LOG.error(""String_Node_Str"" + StringUtils.stringifyException(ioe));
  }
synchronized (this.jobQueue) {
    final ExecutionGraph eg=getExecutionGraphByID(jobID);
    if (eg == null) {
      try {
        this.instanceManager.releaseAllocatedResource(jobID,null,allocatedResource);
      }
 catch (      InstanceException e) {
        LOG.error(e);
      }
      return;
    }
    AllocatedResource resourceToBeReplaced=null;
    ExecutionGraphIterator it=new ExecutionGraphIterator(eg,eg.getIndexOfCurrentExecutionStage(),true,true);
    while (it.hasNext()) {
      final ExecutionVertex vertex=it.next();
      if (vertex.getExecutionState() == ExecutionState.ASSIGNING && vertex.getAllocatedResource() != null) {
        if (vertex.getAllocatedResource().getInstanceType().equals(allocatedResource.getInstanceType())) {
          resourceToBeReplaced=vertex.getAllocatedResource();
          break;
        }
      }
    }
    if (resourceToBeReplaced == null) {
      LOG.warn(""String_Node_Str"" + allocatedResource.getInstance() + ""String_Node_Str""+ eg.getJobID());
      try {
        this.instanceManager.releaseAllocatedResource(jobID,eg.getJobConfiguration(),allocatedResource);
      }
 catch (      InstanceException e) {
        LOG.error(e);
      }
      return;
    }
    it=new ExecutionGraphIterator(eg,true);
    while (it.hasNext()) {
      final ExecutionVertex vertex=it.next();
      if (vertex.getAllocatedResource().equals(resourceToBeReplaced)) {
        vertex.setAllocatedResource(allocatedResource);
        vertex.setExecutionState(ExecutionState.ASSIGNED);
      }
    }
  }
}"
88393,"/** 
 * Creates an execution vertex from a job vertex.
 * @param jobVertex the job vertex to create the execution vertex from
 * @param instanceManager the instanceManager
 * @param initialExecutionStage the initial execution stage all group vertices are added to
 * @return the new execution vertex
 * @throws GraphConversionException thrown if the job vertex is of an unknown subclass
 */
private ExecutionVertex createVertex(AbstractJobVertex jobVertex,InstanceManager instanceManager,ExecutionStage initialExecutionStage) throws GraphConversionException {
  InstanceType instanceType=null;
  boolean userDefinedInstanceType=false;
  if (jobVertex.getInstanceType() != null) {
    userDefinedInstanceType=true;
    instanceType=instanceManager.getInstanceTypeByName(jobVertex.getInstanceType());
    if (instanceType == null) {
      throw new GraphConversionException(""String_Node_Str"" + jobVertex.getInstanceType() + ""String_Node_Str"");
    }
  }
  if (instanceType == null) {
    instanceType=instanceManager.getDefaultInstanceType();
  }
  final ExecutionSignature signature=ExecutionSignature.createSignature(jobVertex.getInvokableClass(),jobVertex.getJobGraph().getJobID());
  final ExecutionGroupVertex groupVertex=new ExecutionGroupVertex(jobVertex.getName(),jobVertex.getID(),this,jobVertex.getNumberOfSubtasks(),instanceType,userDefinedInstanceType,jobVertex.getNumberOfSubtasksPerInstance(),jobVertex.getVertexToShareInstancesWith() != null ? true : false,jobVertex.getConfiguration(),signature);
  final Class<? extends AbstractInvokable> invokableClass=jobVertex.getInvokableClass();
  if (invokableClass == null) {
    throw new GraphConversionException(""String_Node_Str"" + jobVertex.getID() + ""String_Node_Str""+ jobVertex.getName()+ ""String_Node_Str"");
  }
  initialExecutionStage.addStageMember(groupVertex);
  ExecutionVertex ev=null;
  try {
    ev=new ExecutionVertex(jobVertex.getJobGraph().getJobID(),invokableClass,this,groupVertex);
  }
 catch (  Exception e) {
    throw new GraphConversionException(StringUtils.stringifyException(e));
  }
  try {
    jobVertex.checkConfiguration(ev.getEnvironment().getInvokable());
  }
 catch (  IllegalConfigurationException e) {
    throw new GraphConversionException(StringUtils.stringifyException(e));
  }
  final int minimumNumberOfSubtasks=jobVertex.getMinimumNumberOfSubtasks(ev.getEnvironment().getInvokable());
  final int maximumNumberOfSubtasks=jobVertex.getMaximumNumberOfSubtasks(ev.getEnvironment().getInvokable());
  if (jobVertex.getNumberOfSubtasks() != -1) {
    if (jobVertex.getNumberOfSubtasks() < 1) {
      throw new GraphConversionException(""String_Node_Str"" + jobVertex.getName() + ""String_Node_Str""+ jobVertex.getNumberOfSubtasks()+ ""String_Node_Str"");
    }
    if (jobVertex.getNumberOfSubtasks() < minimumNumberOfSubtasks) {
      throw new GraphConversionException(""String_Node_Str"" + minimumNumberOfSubtasks);
    }
    if (maximumNumberOfSubtasks != -1) {
      if (jobVertex.getNumberOfSubtasks() > maximumNumberOfSubtasks) {
        throw new GraphConversionException(""String_Node_Str"" + jobVertex.getName() + ""String_Node_Str""+ maximumNumberOfSubtasks);
      }
    }
  }
  if (jobVertex.getNumberOfSubtasksPerInstance() != -1 && jobVertex.getNumberOfSubtasksPerInstance() < 1) {
    throw new GraphConversionException(""String_Node_Str"" + jobVertex.getNumberOfSubtasksPerInstance() + ""String_Node_Str""+ jobVertex.getName());
  }
  groupVertex.setMinMemberSize(minimumNumberOfSubtasks);
  groupVertex.setMaxMemberSize(maximumNumberOfSubtasks);
  ev.setAllocatedResource(new AllocatedResource(DummyInstance.createDummyInstance(instanceType),null));
  if (jobVertex instanceof JobInputVertex) {
    try {
      groupVertex.setInputSplits(((JobInputVertex)jobVertex).getInputSplits());
    }
 catch (    IllegalConfigurationException e) {
      throw new GraphConversionException(""String_Node_Str"" + groupVertex.getName() + ""String_Node_Str""+ StringUtils.stringifyException(e));
    }
  }
  if (jobVertex instanceof JobFileOutputVertex) {
    final JobFileOutputVertex jbov=(JobFileOutputVertex)jobVertex;
    jobVertex.getConfiguration().setString(""String_Node_Str"",jbov.getFilePath().toString());
  }
  return ev;
}","/** 
 * Creates an execution vertex from a job vertex.
 * @param jobVertex the job vertex to create the execution vertex from
 * @param instanceManager the instanceManager
 * @param initialExecutionStage the initial execution stage all group vertices are added to
 * @return the new execution vertex
 * @throws GraphConversionException thrown if the job vertex is of an unknown subclass
 */
private ExecutionVertex createVertex(AbstractJobVertex jobVertex,InstanceManager instanceManager,ExecutionStage initialExecutionStage) throws GraphConversionException {
  InstanceType instanceType=null;
  boolean userDefinedInstanceType=false;
  if (jobVertex.getInstanceType() != null) {
    userDefinedInstanceType=true;
    instanceType=instanceManager.getInstanceTypeByName(jobVertex.getInstanceType());
    if (instanceType == null) {
      throw new GraphConversionException(""String_Node_Str"" + jobVertex.getInstanceType() + ""String_Node_Str"");
    }
  }
  if (instanceType == null) {
    instanceType=instanceManager.getDefaultInstanceType();
  }
  final ExecutionSignature signature=ExecutionSignature.createSignature(jobVertex.getInvokableClass(),jobVertex.getJobGraph().getJobID());
  final ExecutionGroupVertex groupVertex=new ExecutionGroupVertex(jobVertex.getName(),jobVertex.getID(),this,jobVertex.getNumberOfSubtasks(),instanceType,userDefinedInstanceType,jobVertex.getNumberOfSubtasksPerInstance(),jobVertex.getVertexToShareInstancesWith() != null ? true : false,jobVertex.getConfiguration(),signature);
  final Class<? extends AbstractInvokable> invokableClass=jobVertex.getInvokableClass();
  if (invokableClass == null) {
    throw new GraphConversionException(""String_Node_Str"" + jobVertex.getID() + ""String_Node_Str""+ jobVertex.getName()+ ""String_Node_Str"");
  }
  initialExecutionStage.addStageMember(groupVertex);
  ExecutionVertex ev=null;
  try {
    ev=new ExecutionVertex(jobVertex.getJobGraph().getJobID(),invokableClass,this,groupVertex);
  }
 catch (  Exception e) {
    throw new GraphConversionException(StringUtils.stringifyException(e));
  }
  try {
    jobVertex.checkConfiguration(ev.getEnvironment().getInvokable());
  }
 catch (  IllegalConfigurationException e) {
    throw new GraphConversionException(StringUtils.stringifyException(e));
  }
  final int minimumNumberOfSubtasks=jobVertex.getMinimumNumberOfSubtasks(ev.getEnvironment().getInvokable());
  final int maximumNumberOfSubtasks=jobVertex.getMaximumNumberOfSubtasks(ev.getEnvironment().getInvokable());
  if (jobVertex.getNumberOfSubtasks() != -1) {
    if (jobVertex.getNumberOfSubtasks() < 1) {
      throw new GraphConversionException(""String_Node_Str"" + jobVertex.getName() + ""String_Node_Str""+ jobVertex.getNumberOfSubtasks()+ ""String_Node_Str"");
    }
    if (jobVertex.getNumberOfSubtasks() < minimumNumberOfSubtasks) {
      throw new GraphConversionException(""String_Node_Str"" + minimumNumberOfSubtasks);
    }
    if (maximumNumberOfSubtasks != -1) {
      if (jobVertex.getNumberOfSubtasks() > maximumNumberOfSubtasks) {
        throw new GraphConversionException(""String_Node_Str"" + jobVertex.getName() + ""String_Node_Str""+ maximumNumberOfSubtasks);
      }
    }
  }
  if (jobVertex.getNumberOfSubtasksPerInstance() != -1 && jobVertex.getNumberOfSubtasksPerInstance() < 1) {
    throw new GraphConversionException(""String_Node_Str"" + jobVertex.getNumberOfSubtasksPerInstance() + ""String_Node_Str""+ jobVertex.getName());
  }
  groupVertex.setMinMemberSize(minimumNumberOfSubtasks);
  groupVertex.setMaxMemberSize(maximumNumberOfSubtasks);
  ev.setAllocatedResource(new AllocatedResource(DummyInstance.createDummyInstance(instanceType),instanceType,null));
  if (jobVertex instanceof JobInputVertex) {
    try {
      groupVertex.setInputSplits(((JobInputVertex)jobVertex).getInputSplits());
    }
 catch (    IllegalConfigurationException e) {
      throw new GraphConversionException(""String_Node_Str"" + groupVertex.getName() + ""String_Node_Str""+ StringUtils.stringifyException(e));
    }
  }
  if (jobVertex instanceof JobFileOutputVertex) {
    final JobFileOutputVertex jbov=(JobFileOutputVertex)jobVertex;
    jobVertex.getConfiguration().setString(""String_Node_Str"",jbov.getFilePath().toString());
  }
  return ev;
}"
88394,"public synchronized void reassignInstances(){
  int numberOfRequiredInstances=0;
synchronized (this.groupMembers) {
    numberOfRequiredInstances=(this.groupMembers.size() / this.numberOfSubtasksPerInstance) + (((this.groupMembers.size() % this.numberOfSubtasksPerInstance) != 0) ? 1 : 0);
  }
  final List<AllocatedResource> availableInstances=collectAvailabbleResources();
  while (availableInstances.size() < numberOfRequiredInstances) {
    final AllocatedResource newAllocatedResource=new AllocatedResource(DummyInstance.createDummyInstance(this.instanceType),null);
    availableInstances.add(newAllocatedResource);
  }
synchronized (this.groupMembers) {
    final Iterator<ExecutionVertex> it=this.groupMembers.iterator();
    int instanceIndex=0, i=0;
    int sizeOfIndexStep=availableInstances.size() / numberOfRequiredInstances;
    while (it.hasNext()) {
      final ExecutionVertex vertex=it.next();
      vertex.setAllocatedResource(availableInstances.get(instanceIndex));
      if ((++i % this.numberOfSubtasksPerInstance) == 0) {
        instanceIndex+=sizeOfIndexStep;
      }
    }
  }
synchronized (this.verticesSharingInstances) {
    final Iterator<ExecutionGroupVertex> it2=this.verticesSharingInstances.iterator();
    while (it2.hasNext()) {
      final ExecutionGroupVertex groupVertex=it2.next();
      groupVertex.reassignInstances();
    }
  }
}","public synchronized void reassignInstances(){
  int numberOfRequiredInstances=0;
synchronized (this.groupMembers) {
    numberOfRequiredInstances=(this.groupMembers.size() / this.numberOfSubtasksPerInstance) + (((this.groupMembers.size() % this.numberOfSubtasksPerInstance) != 0) ? 1 : 0);
  }
  final List<AllocatedResource> availableInstances=collectAvailabbleResources();
  while (availableInstances.size() < numberOfRequiredInstances) {
    final AllocatedResource newAllocatedResource=new AllocatedResource(DummyInstance.createDummyInstance(this.instanceType),this.instanceType,null);
    availableInstances.add(newAllocatedResource);
  }
synchronized (this.groupMembers) {
    final Iterator<ExecutionVertex> it=this.groupMembers.iterator();
    int instanceIndex=0, i=0;
    int sizeOfIndexStep=availableInstances.size() / numberOfRequiredInstances;
    while (it.hasNext()) {
      final ExecutionVertex vertex=it.next();
      vertex.setAllocatedResource(availableInstances.get(instanceIndex));
      if ((++i % this.numberOfSubtasksPerInstance) == 0) {
        instanceIndex+=sizeOfIndexStep;
      }
    }
  }
synchronized (this.verticesSharingInstances) {
    final Iterator<ExecutionGroupVertex> it2=this.verticesSharingInstances.iterator();
    while (it2.hasNext()) {
      final ExecutionGroupVertex groupVertex=it2.next();
      groupVertex.reassignInstances();
    }
  }
}"
88395,"/** 
 * {@inheritDoc}
 */
@Override public int hashCode(){
  return this.allocationID.hashCode();
}","/** 
 * {@inheritDoc}
 */
@Override public int hashCode(){
  if (this.allocationID == null) {
    return 0;
  }
  return this.allocationID.hashCode();
}"
88396,"/** 
 * {@inheritDoc}
 */
@Override public boolean equals(Object obj){
  if (obj instanceof AllocatedResource) {
    final AllocatedResource allocatedResource=(AllocatedResource)obj;
    if (!this.instance.equals(allocatedResource.getInstance())) {
      return false;
    }
    if (this.allocationID == null) {
      if (allocatedResource.getAllocationID() == null) {
        return true;
      }
 else {
        return false;
      }
    }
    if (!this.allocationID.equals(allocatedResource.getAllocationID())) {
      return false;
    }
    return true;
  }
  return false;
}","/** 
 * {@inheritDoc}
 */
@Override public boolean equals(Object obj){
  if (obj instanceof AllocatedResource) {
    final AllocatedResource allocatedResource=(AllocatedResource)obj;
    if (!this.instance.equals(allocatedResource.getInstance())) {
      return false;
    }
    if (this.allocationID == null) {
      if (allocatedResource.getAllocationID() != null) {
        return false;
      }
    }
 else {
      if (!this.allocationID.equals(allocatedResource.getAllocationID())) {
        return false;
      }
    }
    if (this.instanceType == null) {
      if (allocatedResource.instance != null) {
        return false;
      }
    }
 else {
      if (!this.instanceType.equals(allocatedResource.getInstanceType())) {
        return false;
      }
    }
    return true;
  }
  return false;
}"
88397,"/** 
 * Constructs a new allocated resource object.
 * @param instance the instance a task is scheduled to run on.
 * @param allocationID the allocation ID identifying the allocated resources within the instance
 */
public AllocatedResource(AbstractInstance instance,AllocationID allocationID){
  this.instance=instance;
  this.allocationID=allocationID;
}","/** 
 * Constructs a new allocated resource object.
 * @param instance the instance a task is scheduled to run on.
 * @param instanceType the instance type this allocated resource represents
 * @param allocationID the allocation ID identifying the allocated resources within the instance
 */
public AllocatedResource(AbstractInstance instance,InstanceType instanceType,AllocationID allocationID){
  this.instance=instance;
  this.instanceType=instanceType;
  this.allocationID=allocationID;
}"
88398,"/** 
 * {@inheritDoc}
 */
@Override public void requestInstance(JobID jobID,Configuration conf,InstanceType instanceType) throws InstanceException {
  boolean assignmentSuccessful=false;
  AllocatedResource allocatedResource=null;
synchronized (this.synchronizationObject) {
    if (this.localInstance != null) {
      if (this.allocatedResource == null) {
        allocatedResource=new AllocatedResource(this.localInstance,new AllocationID());
        this.allocatedResource=allocatedResource;
        assignmentSuccessful=true;
      }
    }
  }
  if (assignmentSuccessful) {
    new LocalInstanceNotifier(this.instanceListener,jobID,allocatedResource).start();
  }
 else {
    throw new InstanceException(""String_Node_Str"" + instanceType + ""String_Node_Str"");
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void requestInstance(JobID jobID,Configuration conf,InstanceType instanceType) throws InstanceException {
  boolean assignmentSuccessful=false;
  AllocatedResource allocatedResource=null;
synchronized (this.synchronizationObject) {
    if (this.localInstance != null) {
      if (this.allocatedResource == null) {
        allocatedResource=new AllocatedResource(this.localInstance,instanceType,new AllocationID());
        this.allocatedResource=allocatedResource;
        assignmentSuccessful=true;
      }
    }
  }
  if (assignmentSuccessful) {
    new LocalInstanceNotifier(this.instanceListener,jobID,allocatedResource).start();
  }
 else {
    throw new InstanceException(""String_Node_Str"" + instanceType + ""String_Node_Str"");
  }
}"
88399,"/** 
 * Adds an InputSplit to the Vertex with least InputSplits assigned that can locally read the split. If the InputSplit cannot be read locally by any Vertex, it is assigned to the Vertex with least assigned InputSplits.
 * @param inputSplit InputSplit that will be assigned
 * @throws ExecutionFailureException
 */
private void addFileSplit(InputSplit inputSplit) throws ExecutionFailureException {
  String[] splitLocations=inputSplit.getHostNames();
  if (splitLocations.length == 0)   throw new ExecutionFailureException(""String_Node_Str"" + inputSplit);
  boolean added=false;
  PriorityQueue<QueueElem> newVertexPrioQueue=new PriorityQueue<QueueElem>();
  while (this.vertexPrioQueue.size() > 0) {
    QueueElem topElem=this.vertexPrioQueue.poll();
    if (topElem.hostsSplit(splitLocations)) {
      topElem.assignInputSplit(inputSplit);
      added=true;
    }
    newVertexPrioQueue.add(topElem);
    if (added) {
      break;
    }
  }
  if (added) {
    newVertexPrioQueue.addAll(this.vertexPrioQueue);
  }
 else {
    QueueElem topElem=newVertexPrioQueue.poll();
    topElem.assignInputSplit(inputSplit);
    newVertexPrioQueue.add(topElem);
  }
  this.vertexPrioQueue=newVertexPrioQueue;
}","/** 
 * Adds an InputSplit to the Vertex with least InputSplits assigned that can locally read the split. If the InputSplit cannot be read locally by any Vertex, it is assigned to the Vertex with least assigned InputSplits.
 * @param inputSplit InputSplit that will be assigned
 * @throws ExecutionFailureException
 */
private void addFileSplit(InputSplit inputSplit) throws ExecutionFailureException {
  final String[] splitLocations=inputSplit.getHostNames();
  if (splitLocations.length == 0)   throw new ExecutionFailureException(""String_Node_Str"" + inputSplit);
  boolean added=false;
  final PriorityQueue<QueueElem> newVertexPrioQueue=new PriorityQueue<QueueElem>();
  while (this.vertexPrioQueue.size() > 0) {
    QueueElem topElem=this.vertexPrioQueue.poll();
    if (topElem.hostsSplit(splitLocations)) {
      topElem.assignInputSplit(inputSplit);
      added=true;
    }
    newVertexPrioQueue.add(topElem);
    if (added) {
      break;
    }
  }
  if (added) {
    newVertexPrioQueue.addAll(this.vertexPrioQueue);
  }
 else {
    final QueueElem topElem=newVertexPrioQueue.poll();
    topElem.assignInputSplit(inputSplit);
    newVertexPrioQueue.add(topElem);
  }
  this.vertexPrioQueue=newVertexPrioQueue;
}"
88400,"/** 
 * Assign InputSplits for a ExecutionGroupVertex
 * @param graph ExecutionGraph the ExecutionGroupVertex belongs to
 * @param groupVertex ExecutionGroupVertex who's InputSplits will be assigned
 * @throws ExecutionFailureException
 */
private void assignInputSplits(ExecutionGroupVertex groupVertex) throws ExecutionFailureException {
  InputSplit[] inputSplits=groupVertex.getInputSplits();
  if (inputSplits == null) {
    throw new ExecutionFailureException(""String_Node_Str"" + groupVertex.getName() + ""String_Node_Str"");
  }
  LOG.info(""String_Node_Str"" + inputSplits.length + ""String_Node_Str""+ groupVertex.getName());
  initializePriorityQueue(groupVertex,inputSplits);
  for (int i=0; i < inputSplits.length; i++) {
    addFileSplit(inputSplits[i]);
  }
  verifyAssignments();
  vertexPrioQueue.clear();
}","/** 
 * Assign InputSplits for a ExecutionGroupVertex
 * @param graph ExecutionGraph the ExecutionGroupVertex belongs to
 * @param groupVertex ExecutionGroupVertex who's InputSplits will be assigned
 * @return <code>false</code> if the instance assignment could not be done because at least one vertex has not beenin state <code>READY</code>, <code>true/code> otherwise
 * @throws ExecutionFailureException
 */
private boolean assignInputSplits(ExecutionGroupVertex groupVertex) throws ExecutionFailureException {
  for (int i=0; i < groupVertex.getCurrentNumberOfGroupMembers(); i++) {
    if (!groupVertex.getGroupMember(i).getExecutionState().equals(ExecutionState.READY)) {
      return false;
    }
  }
  final InputSplit[] inputSplits=groupVertex.getInputSplits();
  if (inputSplits == null) {
    throw new ExecutionFailureException(""String_Node_Str"" + groupVertex.getName() + ""String_Node_Str"");
  }
  LOG.info(""String_Node_Str"" + inputSplits.length + ""String_Node_Str""+ groupVertex.getName());
  initializePriorityQueue(groupVertex,inputSplits);
  for (int i=0; i < inputSplits.length; i++) {
    addFileSplit(inputSplits[i]);
  }
  verifyAssignments();
  vertexPrioQueue.clear();
  return true;
}"
88401,"/** 
 * Searches the current execution graph for execution vertices which have become ready for execution and triggers their execution.
 */
void runVerticesReadyForExecution(){
  final Set<ExecutionVertex> readyVertices=this.scheduler.getVerticesReadyToBeExecuted();
synchronized (this.verticesReadyToRun) {
    this.verticesReadyToRun.addAll(readyVertices);
    final Iterator<ExecutionVertex> it=this.verticesReadyToRun.iterator();
    while (it.hasNext()) {
      final ExecutionVertex vertex=it.next();
      if (vertex.getExecutionState() != ExecutionState.READY) {
        LOG.error(""String_Node_Str"" + vertex + ""String_Node_Str""+ vertex.getExecutionState());
      }
      if (vertex.isInputVertex() && vertex.getEnvironment().getInputSplits().length == 0 && vertex.getGroupVertex().getStageNumber() == 0) {
        try {
          InputSplitAssigner.assignInputSplits(vertex);
        }
 catch (        ExecutionFailureException e) {
          e.printStackTrace();
        }
      }
      LOG.info(""String_Node_Str"" + vertex + ""String_Node_Str""+ vertex.getAllocatedResource().getInstance());
      final TaskSubmissionResult submissionResult=vertex.startTask();
      it.remove();
      if (submissionResult.getReturnCode() == AbstractTaskResult.ReturnCode.ERROR) {
        vertex.getEnvironment().changeExecutionState(ExecutionState.FAILED,submissionResult.getDescription());
      }
    }
  }
}","/** 
 * Searches the current execution graph for execution vertices which have become ready for execution and triggers their execution.
 */
void runVerticesReadyForExecution(){
  final Set<ExecutionVertex> readyVertices=this.scheduler.getVerticesReadyToBeExecuted();
synchronized (this.verticesReadyToRun) {
    this.verticesReadyToRun.addAll(readyVertices);
    final Iterator<ExecutionVertex> it=this.verticesReadyToRun.iterator();
    while (it.hasNext()) {
      final ExecutionVertex vertex=it.next();
      if (vertex.getExecutionState() != ExecutionState.READY) {
        LOG.error(""String_Node_Str"" + vertex + ""String_Node_Str""+ vertex.getExecutionState());
      }
      if (vertex.isInputVertex() && vertex.getEnvironment().getInputSplits().length == 0 && vertex.getGroupVertex().getStageNumber() == 0) {
        try {
          if (!InputSplitAssigner.assignInputSplits(vertex)) {
            continue;
          }
        }
 catch (        ExecutionFailureException e) {
          e.printStackTrace();
        }
      }
      LOG.info(""String_Node_Str"" + vertex + ""String_Node_Str""+ vertex.getAllocatedResource().getInstance());
      final TaskSubmissionResult submissionResult=vertex.startTask();
      it.remove();
      if (submissionResult.getReturnCode() == AbstractTaskResult.ReturnCode.ERROR) {
        vertex.getEnvironment().changeExecutionState(ExecutionState.FAILED,submissionResult.getDescription());
      }
    }
  }
}"
88402,"/** 
 * {@inheritDoc}
 */
@Override public void resourceAllocated(JobID jobID,AllocatedResource allocatedResource){
  if (allocatedResource == null) {
    LOG.error(""String_Node_Str"");
    return;
  }
  if (allocatedResource.getInstance() instanceof DummyInstance) {
    LOG.debug(""String_Node_Str"");
    return;
  }
  try {
    allocatedResource.getInstance().checkLibraryAvailability(jobID);
  }
 catch (  IOException ioe) {
    LOG.error(""String_Node_Str"" + StringUtils.stringifyException(ioe));
  }
synchronized (this.jobQueue) {
    final ExecutionGraph eg=getExecutionGraphByID(jobID);
    if (eg == null) {
      try {
        this.instanceManager.releaseAllocatedResource(jobID,null,allocatedResource);
      }
 catch (      InstanceException e) {
        LOG.error(e);
      }
      return;
    }
    AllocatedResource resourceToBeReplaced=null;
    ExecutionGraphIterator it=new ExecutionGraphIterator(eg,eg.getIndexOfCurrentExecutionStage(),true,true);
    while (it.hasNext()) {
      final ExecutionVertex vertex=it.next();
      if (vertex.getExecutionState() == ExecutionState.ASSIGNING && vertex.getAllocatedResource() != null) {
        if (vertex.getAllocatedResource().getInstance().getType().equals(allocatedResource.getInstance().getType())) {
          resourceToBeReplaced=vertex.getAllocatedResource();
          break;
        }
      }
    }
    if (resourceToBeReplaced == null) {
      LOG.error(""String_Node_Str"" + allocatedResource.getInstance() + ""String_Node_Str""+ eg.getJobID());
      try {
        this.instanceManager.releaseAllocatedResource(jobID,eg.getJobConfiguration(),allocatedResource);
      }
 catch (      InstanceException e) {
        LOG.error(e);
      }
      return;
    }
    it=new ExecutionGraphIterator(eg,true);
    while (it.hasNext()) {
      final ExecutionVertex vertex=it.next();
      if (vertex.getAllocatedResource().equals(resourceToBeReplaced)) {
        vertex.setAllocatedResource(allocatedResource);
        vertex.setExecutionState(ExecutionState.ASSIGNED);
      }
    }
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void resourceAllocated(JobID jobID,AllocatedResource allocatedResource){
  if (allocatedResource == null) {
    LOG.error(""String_Node_Str"");
    return;
  }
  if (allocatedResource.getInstance() instanceof DummyInstance) {
    LOG.debug(""String_Node_Str"");
    return;
  }
  try {
    allocatedResource.getInstance().checkLibraryAvailability(jobID);
  }
 catch (  IOException ioe) {
    LOG.error(""String_Node_Str"" + StringUtils.stringifyException(ioe));
  }
synchronized (this.jobQueue) {
    final ExecutionGraph eg=getExecutionGraphByID(jobID);
    if (eg == null) {
      try {
        this.instanceManager.releaseAllocatedResource(jobID,null,allocatedResource);
      }
 catch (      InstanceException e) {
        LOG.error(e);
      }
      return;
    }
    AllocatedResource resourceToBeReplaced=null;
    ExecutionGraphIterator it=new ExecutionGraphIterator(eg,eg.getIndexOfCurrentExecutionStage(),true,true);
    while (it.hasNext()) {
      final ExecutionVertex vertex=it.next();
      if (vertex.getExecutionState() == ExecutionState.ASSIGNING && vertex.getAllocatedResource() != null) {
        if (vertex.getAllocatedResource().getInstanceType().equals(allocatedResource.getInstanceType())) {
          resourceToBeReplaced=vertex.getAllocatedResource();
          break;
        }
      }
    }
    if (resourceToBeReplaced == null) {
      LOG.error(""String_Node_Str"" + allocatedResource.getInstance() + ""String_Node_Str""+ eg.getJobID());
      try {
        this.instanceManager.releaseAllocatedResource(jobID,eg.getJobConfiguration(),allocatedResource);
      }
 catch (      InstanceException e) {
        LOG.error(e);
      }
      return;
    }
    it=new ExecutionGraphIterator(eg,true);
    while (it.hasNext()) {
      final ExecutionVertex vertex=it.next();
      if (vertex.getAllocatedResource().equals(resourceToBeReplaced)) {
        vertex.setAllocatedResource(allocatedResource);
        vertex.setExecutionState(ExecutionState.ASSIGNED);
      }
    }
  }
}"
88403,"/** 
 * Initializes the stub implementation and configuration.
 * @throws RuntimeException Thrown if instance of stub implementation can not be obtained.
 */
private void initStub(){
  config=new TaskConfig(getRuntimeConfiguration());
  NUM_SORT_BUFFERS=config.getNumSortBuffer();
  SIZE_SORT_BUFFER=config.getSortBufferSize() * 1024 * 1024;
  MEMORY_IO=config.getIOBufferSize() * 1024 * 1024;
  MAX_NUM_FILEHANLDES=config.getMergeFactor();
  try {
    ClassLoader cl=LibraryCacheManager.getClassLoader(getEnvironment().getJobID());
    Class<? extends MatchStub> matchClass=config.getStubClass(MatchStub.class,cl);
    matchStub=matchClass.newInstance();
    matchStub.configure(config.getStubParameters());
  }
 catch (  IOException ioe) {
    throw new RuntimeException(""String_Node_Str"",ioe);
  }
catch (  ClassNotFoundException cnfe) {
    throw new RuntimeException(""String_Node_Str"",cnfe);
  }
catch (  InstantiationException ie) {
    throw new RuntimeException(""String_Node_Str"",ie);
  }
catch (  IllegalAccessException iae) {
    throw new RuntimeException(""String_Node_Str"",iae);
  }
}","/** 
 * Initializes the stub implementation and configuration.
 * @throws RuntimeException Thrown if instance of stub implementation can not be obtained.
 */
private void initStub(){
  config=new TaskConfig(getRuntimeConfiguration());
  NUM_SORT_BUFFERS=config.getNumSortBuffer();
  SIZE_SORT_BUFFER=config.getSortBufferSize() * 1024 * 1024;
  MEMORY_IO=config.getIOBufferSize() * 1024 * 1024;
  MAX_NUM_FILEHANLDES=config.getMergeFactor();
  try {
    ClassLoader cl=LibraryCacheManager.getClassLoader(getEnvironment().getJobID());
    Class<? extends MatchStub> matchClass=config.getStubClass(MatchStub.class,cl);
    matchStub=matchClass.newInstance();
    matchStub.configure(config.getStubParameters());
    this.keySerialization=new WritableSerializationFactory<Key>(matchStub.getFirstInKeyType());
    this.v1Serialization=new WritableSerializationFactory<Value>(matchStub.getFirstInValueType());
    this.v2Serialization=new WritableSerializationFactory<Value>(matchStub.getSecondInValueType());
  }
 catch (  IOException ioe) {
    throw new RuntimeException(""String_Node_Str"",ioe);
  }
catch (  ClassNotFoundException cnfe) {
    throw new RuntimeException(""String_Node_Str"",cnfe);
  }
catch (  InstantiationException ie) {
    throw new RuntimeException(""String_Node_Str"",ie);
  }
catch (  IllegalAccessException iae) {
    throw new RuntimeException(""String_Node_Str"",iae);
  }
}"
88404,"/** 
 * <p> Calls the <code>MatchStub#match()</code> method for all two key-value pairs that share the same key and come from different inputs. The output of the <code>match()</code> method is forwarded. <p> This method is called with a key and two iterator (one for each input) over all values that share this key. <p>
 * @param key A key.
 * @param values1 An iterator on values of the first input that were paired with the key.
 * @param values2 An iterator on values of the second input that were paired with the key.
 * @param out A collector that collects all output pairs.
 */
private void crossValues(Key key,final Iterator<Value> values1,final Iterator<Value> values2) throws RuntimeException {
  final Value firstV1=values1.next();
  final Value firstV2=values2.next();
  if (firstV1 == null || firstV2 == null) {
    return;
  }
  boolean v1HasNext=values1.hasNext();
  boolean v2HasNext=values2.hasNext();
  if (!v1HasNext && !v2HasNext) {
    matchStub.match(key,firstV1,firstV2,output);
    return;
  }
  Value v1;
  Value v2;
  final SerializationFactory<Key> keySerialization=new WritableSerializationFactory<Key>(matchStub.getFirstInKeyType());
  final SerializationCopier<Key> keyCopier=new SerializationCopier<Key>();
  keyCopier.setCopy(key);
  if (!v1HasNext) {
    final SerializationFactory<Value> v1Serialization=new WritableSerializationFactory<Value>(matchStub.getFirstInValueType());
    final SerializationCopier<Value> v1Copier=new SerializationCopier<Value>();
    v1Copier.setCopy(firstV1);
    matchStub.match(key,firstV1,firstV2,output);
    while (v2HasNext) {
      key=keySerialization.newInstance();
      keyCopier.getCopy(key);
      v1=v1Serialization.newInstance();
      v1Copier.getCopy(v1);
      v2=values2.next();
      v2HasNext=values2.hasNext();
      matchStub.match(key,v1,v2,output);
    }
  }
 else   if (!v2HasNext) {
    final SerializationFactory<Value> v2Serialization=new WritableSerializationFactory<Value>(matchStub.getSecondInValueType());
    final SerializationCopier<Value> v2Copier=new SerializationCopier<Value>();
    v2Copier.setCopy(firstV2);
    matchStub.match(key,firstV1,firstV2,output);
    while (v1HasNext) {
      key=keySerialization.newInstance();
      keyCopier.getCopy(key);
      v2=v2Serialization.newInstance();
      v2Copier.getCopy(v2);
      v1=values1.next();
      v1HasNext=values1.hasNext();
      matchStub.match(key,v1,v2,output);
    }
  }
 else {
    Reader<Value> v1Reader=new Reader<Value>(){
      boolean firstValue=true;
      @Override public List<AbstractInputChannel<Value>> getInputChannels(){
        throw new UnsupportedOperationException();
      }
      @Override public boolean hasNext(){
        if (firstValue)         return true;
        return values1.hasNext();
      }
      @Override public Value next() throws IOException, InterruptedException {
        if (firstValue) {
          firstValue=false;
          return firstV1;
        }
        return values1.next();
      }
    }
;
    final SpillingResettableIterator<Value> v1ResettableIterator;
    try {
      ValueDeserializer<Value> v1Deserializer=new ValueDeserializer<Value>(matchStub.getFirstInValueType());
      v1ResettableIterator=new SpillingResettableIterator<Value>(getEnvironment().getMemoryManager(),getEnvironment().getIOManager(),v1Reader,((int)(MEMORY_IO * MEMORY_SHARE_RATIO)),v1Deserializer);
      v1ResettableIterator.open();
      final SerializationFactory<Value> v2Serialization=new WritableSerializationFactory<Value>(matchStub.getSecondInValueType());
      final SerializationCopier<Value> v2Copier=new SerializationCopier<Value>();
      v2Copier.setCopy(firstV2);
      while (v1ResettableIterator.hasNext()) {
        key=keySerialization.newInstance();
        keyCopier.getCopy(key);
        v2=v2Serialization.newInstance();
        v2Copier.getCopy(v2);
        v1=v1ResettableIterator.next();
        matchStub.match(key,v1,v2,output);
      }
      v1ResettableIterator.reset();
      while (values2.hasNext()) {
        v2=values2.next();
        v2Copier.setCopy(v2);
        while (v1ResettableIterator.hasNext()) {
          key=keySerialization.newInstance();
          keyCopier.getCopy(key);
          v2=v2Serialization.newInstance();
          v2Copier.getCopy(v2);
          v1=v1ResettableIterator.next();
          matchStub.match(key,v1,v2,output);
        }
        v1ResettableIterator.reset();
      }
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
}","/** 
 * <p> Calls the <code>MatchStub#match()</code> method for all two key-value pairs that share the same key and come from different inputs. The output of the <code>match()</code> method is forwarded. <p> This method is called with a key and two iterator (one for each input) over all values that share this key. <p>
 * @param key A key.
 * @param values1 An iterator on values of the first input that were paired with the key.
 * @param values2 An iterator on values of the second input that were paired with the key.
 * @param out A collector that collects all output pairs.
 */
private void crossValues(Key key,final Iterator<Value> values1,final Iterator<Value> values2) throws RuntimeException {
  final Value firstV1=values1.next();
  final Value firstV2=values2.next();
  if (firstV1 == null || firstV2 == null) {
    return;
  }
  boolean v1HasNext=values1.hasNext();
  boolean v2HasNext=values2.hasNext();
  if (!v1HasNext && !v2HasNext) {
    matchStub.match(key,firstV1,firstV2,output);
    return;
  }
  Value v1;
  Value v2;
  keyCopier.setCopy(key);
  if (!v1HasNext) {
    this.v1Copier.setCopy(firstV1);
    matchStub.match(key,firstV1,firstV2,output);
    while (v2HasNext) {
      key=this.keySerialization.newInstance();
      this.keyCopier.getCopy(key);
      v1=this.v1Serialization.newInstance();
      this.v1Copier.getCopy(v1);
      v2=values2.next();
      v2HasNext=values2.hasNext();
      matchStub.match(key,v1,v2,output);
    }
  }
 else   if (!v2HasNext) {
    this.v2Copier.setCopy(firstV2);
    matchStub.match(key,firstV1,firstV2,output);
    while (v1HasNext) {
      key=this.keySerialization.newInstance();
      this.keyCopier.getCopy(key);
      v2=this.v2Serialization.newInstance();
      this.v2Copier.getCopy(v2);
      v1=values1.next();
      v1HasNext=values1.hasNext();
      matchStub.match(key,v1,v2,output);
    }
  }
 else {
    Reader<Value> v1Reader=new Reader<Value>(){
      boolean firstValue=true;
      @Override public List<AbstractInputChannel<Value>> getInputChannels(){
        throw new UnsupportedOperationException();
      }
      @Override public boolean hasNext(){
        if (firstValue)         return true;
        return values1.hasNext();
      }
      @Override public Value next() throws IOException, InterruptedException {
        if (firstValue) {
          firstValue=false;
          return firstV1;
        }
        return values1.next();
      }
    }
;
    final SpillingResettableIterator<Value> v1ResettableIterator;
    try {
      ValueDeserializer<Value> v1Deserializer=new ValueDeserializer<Value>(matchStub.getFirstInValueType());
      v1ResettableIterator=new SpillingResettableIterator<Value>(getEnvironment().getMemoryManager(),getEnvironment().getIOManager(),v1Reader,((int)(MEMORY_IO * MEMORY_SHARE_RATIO)),v1Deserializer);
      v1ResettableIterator.open();
      this.v2Copier.setCopy(firstV2);
      while (v1ResettableIterator.hasNext()) {
        key=this.keySerialization.newInstance();
        this.keyCopier.getCopy(key);
        v2=this.v2Serialization.newInstance();
        this.v2Copier.getCopy(v2);
        v1=v1ResettableIterator.next();
        matchStub.match(key,v1,v2,output);
      }
      v1ResettableIterator.reset();
      while (values2.hasNext()) {
        v2=values2.next();
        this.v2Copier.setCopy(v2);
        while (v1ResettableIterator.hasNext()) {
          key=this.keySerialization.newInstance();
          this.keyCopier.getCopy(key);
          v2=this.v2Serialization.newInstance();
          this.v2Copier.getCopy(v2);
          v1=v1ResettableIterator.next();
          matchStub.match(key,v1,v2,output);
        }
        v1ResettableIterator.reset();
      }
      v1ResettableIterator.close();
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
}"
88405,"public ServiceException(Throwable cause){
  super(cause);
}","public ServiceException(String message,Throwable cause){
  super(message,cause);
}"
88406,"/** 
 * Factory method for MemorySegment implementations.
 * @param descriptor
 * @return
 */
private DefaultMemorySegment factory(MemorySegmentDescriptor descriptor){
  DefaultRandomAccessView randomAccessView=new DefaultRandomAccessView(descriptor);
  DefaultDataInputView inputView=new DefaultDataInputView(descriptor);
  DefaultDataOutputView outputView=new DefaultDataOutputView(descriptor);
  return new DefaultMemorySegment(descriptor,randomAccessView,inputView,outputView);
}","/** 
 * Factory method for MemorySegment implementations.
 * @param descriptor
 * @return
 */
private static DefaultMemorySegment factory(MemorySegmentDescriptor descriptor){
  DefaultRandomAccessView randomAccessView=new DefaultRandomAccessView(descriptor);
  DefaultDataInputView inputView=new DefaultDataInputView(descriptor);
  DefaultDataOutputView outputView=new DefaultDataOutputView(descriptor);
  return new DefaultMemorySegment(descriptor,randomAccessView,inputView,outputView);
}"
88407,"@Override public void shutdown(){
  if (!isShutDown) {
    LOG.debug(""String_Node_Str"" + toString());
    isShutDown=true;
    memory=null;
    chunkSize=0L;
  }
}","@Override public void shutdown(){
synchronized (this) {
    if (!isShutDown) {
      LOG.debug(""String_Node_Str"" + toString());
      isShutDown=true;
      memory=null;
      chunkSize=0L;
    }
  }
}"
88408,"/** 
 * {@inheritDoc}
 */
@Override public Plan getPlan(String... args){
  if (args.length != 4) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  int noSubTasks=Integer.parseInt(args[0]);
  String dataPointInput=args[1];
  String clusterInput=args[2];
  String output=args[3];
  DataSourceContract<PactInteger,CoordVector> dataPoints=new DataSourceContract<PactInteger,CoordVector>(PointInFormat.class,dataPointInput,""String_Node_Str"");
  dataPoints.setFormatParameter(""String_Node_Str"",""String_Node_Str"");
  dataPoints.setDegreeOfParallelism(noSubTasks);
  dataPoints.setOutputContract(UniqueKey.class);
  DataSourceContract<PactInteger,CoordVector> clusterPoints=new DataSourceContract<PactInteger,CoordVector>(PointInFormat.class,clusterInput,""String_Node_Str"");
  clusterPoints.setFormatParameter(""String_Node_Str"",""String_Node_Str"");
  clusterPoints.setDegreeOfParallelism(1);
  clusterPoints.setOutputContract(UniqueKey.class);
  CrossContract<PactInteger,CoordVector,PactInteger,CoordVector,PactInteger,Distance> computeDistance=new CrossContract<PactInteger,CoordVector,PactInteger,CoordVector,PactInteger,Distance>(ComputeDistance.class,""String_Node_Str"");
  computeDistance.setDegreeOfParallelism(noSubTasks);
  computeDistance.getCompilerHints().setAvgBytesPerRecord(48);
  ReduceContract<PactInteger,Distance,PactInteger,CoordVectorCountSum> findNearestClusterCenters=new ReduceContract<PactInteger,Distance,PactInteger,CoordVectorCountSum>(FindNearestCenter.class,""String_Node_Str"");
  findNearestClusterCenters.setDegreeOfParallelism(noSubTasks);
  findNearestClusterCenters.getCompilerHints().setAvgBytesPerRecord(48);
  ReduceContract<PactInteger,CoordVectorCountSum,PactInteger,CoordVector> recomputeClusterCenter=new ReduceContract<PactInteger,CoordVectorCountSum,PactInteger,CoordVector>(RecomputeClusterCenter.class,""String_Node_Str"");
  recomputeClusterCenter.setDegreeOfParallelism(noSubTasks);
  recomputeClusterCenter.getCompilerHints().setAvgBytesPerRecord(36);
  DataSinkContract<PactInteger,CoordVector> newClusterPoints=new DataSinkContract<PactInteger,CoordVector>(PointOutFormat.class,output,""String_Node_Str"");
  newClusterPoints.setDegreeOfParallelism(noSubTasks);
  newClusterPoints.setInput(recomputeClusterCenter);
  recomputeClusterCenter.setInput(findNearestClusterCenters);
  findNearestClusterCenters.setInput(computeDistance);
  computeDistance.setFirstInput(dataPoints);
  computeDistance.setSecondInput(clusterPoints);
  return new Plan(newClusterPoints,""String_Node_Str"");
}","/** 
 * {@inheritDoc}
 */
@Override public Plan getPlan(String... args){
  int noSubTasks=(args.length > 0 ? Integer.parseInt(args[0]) : 1);
  String dataPointInput=(args.length > 1 ? args[1] : ""String_Node_Str"");
  String clusterInput=(args.length > 2 ? args[2] : ""String_Node_Str"");
  String output=(args.length > 3 ? args[3] : ""String_Node_Str"");
  DataSourceContract<PactInteger,CoordVector> dataPoints=new DataSourceContract<PactInteger,CoordVector>(PointInFormat.class,dataPointInput,""String_Node_Str"");
  dataPoints.setFormatParameter(""String_Node_Str"",""String_Node_Str"");
  dataPoints.setDegreeOfParallelism(noSubTasks);
  dataPoints.setOutputContract(UniqueKey.class);
  DataSourceContract<PactInteger,CoordVector> clusterPoints=new DataSourceContract<PactInteger,CoordVector>(PointInFormat.class,clusterInput,""String_Node_Str"");
  clusterPoints.setFormatParameter(""String_Node_Str"",""String_Node_Str"");
  clusterPoints.setDegreeOfParallelism(1);
  clusterPoints.setOutputContract(UniqueKey.class);
  CrossContract<PactInteger,CoordVector,PactInteger,CoordVector,PactInteger,Distance> computeDistance=new CrossContract<PactInteger,CoordVector,PactInteger,CoordVector,PactInteger,Distance>(ComputeDistance.class,""String_Node_Str"");
  computeDistance.setDegreeOfParallelism(noSubTasks);
  computeDistance.getCompilerHints().setAvgBytesPerRecord(48);
  ReduceContract<PactInteger,Distance,PactInteger,CoordVectorCountSum> findNearestClusterCenters=new ReduceContract<PactInteger,Distance,PactInteger,CoordVectorCountSum>(FindNearestCenter.class,""String_Node_Str"");
  findNearestClusterCenters.setDegreeOfParallelism(noSubTasks);
  findNearestClusterCenters.getCompilerHints().setAvgBytesPerRecord(48);
  ReduceContract<PactInteger,CoordVectorCountSum,PactInteger,CoordVector> recomputeClusterCenter=new ReduceContract<PactInteger,CoordVectorCountSum,PactInteger,CoordVector>(RecomputeClusterCenter.class,""String_Node_Str"");
  recomputeClusterCenter.setDegreeOfParallelism(noSubTasks);
  recomputeClusterCenter.getCompilerHints().setAvgBytesPerRecord(36);
  DataSinkContract<PactInteger,CoordVector> newClusterPoints=new DataSinkContract<PactInteger,CoordVector>(PointOutFormat.class,output,""String_Node_Str"");
  newClusterPoints.setDegreeOfParallelism(noSubTasks);
  newClusterPoints.setInput(recomputeClusterCenter);
  recomputeClusterCenter.setInput(findNearestClusterCenters);
  findNearestClusterCenters.setInput(computeDistance);
  computeDistance.setFirstInput(dataPoints);
  computeDistance.setSecondInput(clusterPoints);
  return new Plan(newClusterPoints,""String_Node_Str"");
}"
88409,"/** 
 * Assembles the Plan of the All-2-All Shortest Paths example Pact program. The program computes one iteration of the All-2-All Shortest Paths algorithm. For the first iteration, two input formats can be chosen: 1) RDF triples with foaf:knows predicates 2) Text-serialized paths (see PathInFormat and PathOutFormat) To choose 1) set the forth parameter to ""true"". If set to ""false"" 2) will be used.
 */
@Override public Plan getPlan(String... args){
  if (args.length != 4) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  int noSubTasks=Integer.parseInt(args[0]);
  String paths=args[1];
  String output=args[2];
  boolean rdfInput=Boolean.parseBoolean(args[3]);
  DataSourceContract<NodePair,Path> pathsInput;
  if (rdfInput) {
    pathsInput=new DataSourceContract<NodePair,Path>(RDFTripleInFormat.class,paths);
  }
 else {
    pathsInput=new DataSourceContract<NodePair,Path>(PathInFormat.class,paths);
  }
  pathsInput.setFormatParameter(""String_Node_Str"",""String_Node_Str"");
  pathsInput.setDegreeOfParallelism(noSubTasks);
  MapContract<NodePair,Path,PactString,Path> pathStarts=new MapContract<NodePair,Path,PactString,Path>(ProjectPathStart.class,""String_Node_Str"");
  pathStarts.setDegreeOfParallelism(noSubTasks);
  MapContract<NodePair,Path,PactString,Path> pathEnds=new MapContract<NodePair,Path,PactString,Path>(ProjectPathEnd.class,""String_Node_Str"");
  pathEnds.setDegreeOfParallelism(noSubTasks);
  MatchContract<PactString,Path,Path,NodePair,Path> concatPaths=new MatchContract<PactString,Path,Path,NodePair,Path>(ConcatPaths.class,""String_Node_Str"");
  concatPaths.setDegreeOfParallelism(noSubTasks);
  CoGroupContract<NodePair,Path,Path,PactNull,Path> findShortestPaths=new CoGroupContract<NodePair,Path,Path,PactNull,Path>(FindShortestPath.class,""String_Node_Str"");
  findShortestPaths.setDegreeOfParallelism(noSubTasks);
  DataSinkContract<PactNull,Path> result=new DataSinkContract<PactNull,Path>(PathOutFormat.class,output);
  result.setDegreeOfParallelism(noSubTasks);
  result.setInput(findShortestPaths);
  findShortestPaths.setFirstInput(pathsInput);
  findShortestPaths.setSecondInput(concatPaths);
  concatPaths.setFirstInput(pathStarts);
  pathStarts.setInput(pathsInput);
  concatPaths.setSecondInput(pathEnds);
  pathEnds.setInput(pathsInput);
  return new Plan(result,""String_Node_Str"");
}","/** 
 * Assembles the Plan of the All-2-All Shortest Paths example Pact program. The program computes one iteration of the All-2-All Shortest Paths algorithm. For the first iteration, two input formats can be chosen: 1) RDF triples with foaf:knows predicates 2) Text-serialized paths (see PathInFormat and PathOutFormat) To choose 1) set the forth parameter to ""true"". If set to ""false"" 2) will be used.
 */
@Override public Plan getPlan(String... args){
  int noSubTasks=(args.length > 0 ? Integer.parseInt(args[0]) : 1);
  String paths=(args.length > 1 ? args[1] : ""String_Node_Str"");
  String output=(args.length > 2 ? args[2] : ""String_Node_Str"");
  boolean rdfInput=(args.length > 3 ? Boolean.parseBoolean(args[3]) : false);
  DataSourceContract<NodePair,Path> pathsInput;
  if (rdfInput) {
    pathsInput=new DataSourceContract<NodePair,Path>(RDFTripleInFormat.class,paths);
  }
 else {
    pathsInput=new DataSourceContract<NodePair,Path>(PathInFormat.class,paths);
  }
  pathsInput.setFormatParameter(""String_Node_Str"",""String_Node_Str"");
  pathsInput.setDegreeOfParallelism(noSubTasks);
  MapContract<NodePair,Path,PactString,Path> pathStarts=new MapContract<NodePair,Path,PactString,Path>(ProjectPathStart.class,""String_Node_Str"");
  pathStarts.setDegreeOfParallelism(noSubTasks);
  MapContract<NodePair,Path,PactString,Path> pathEnds=new MapContract<NodePair,Path,PactString,Path>(ProjectPathEnd.class,""String_Node_Str"");
  pathEnds.setDegreeOfParallelism(noSubTasks);
  MatchContract<PactString,Path,Path,NodePair,Path> concatPaths=new MatchContract<PactString,Path,Path,NodePair,Path>(ConcatPaths.class,""String_Node_Str"");
  concatPaths.setDegreeOfParallelism(noSubTasks);
  CoGroupContract<NodePair,Path,Path,PactNull,Path> findShortestPaths=new CoGroupContract<NodePair,Path,Path,PactNull,Path>(FindShortestPath.class,""String_Node_Str"");
  findShortestPaths.setDegreeOfParallelism(noSubTasks);
  DataSinkContract<PactNull,Path> result=new DataSinkContract<PactNull,Path>(PathOutFormat.class,output);
  result.setDegreeOfParallelism(noSubTasks);
  result.setInput(findShortestPaths);
  findShortestPaths.setFirstInput(pathsInput);
  findShortestPaths.setSecondInput(concatPaths);
  concatPaths.setFirstInput(pathStarts);
  pathStarts.setInput(pathsInput);
  concatPaths.setSecondInput(pathEnds);
  pathEnds.setInput(pathsInput);
  return new Plan(result,""String_Node_Str"");
}"
88410,"/** 
 * Assembles the Plan of the triangle enumeration example Pact program.
 */
@Override public Plan getPlan(String... args){
  if (args.length != 3) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  int noSubTasks=Integer.parseInt(args[0]);
  String edgeInput=args[1];
  String output=args[2];
  DataSourceContract<Edge,PactNull> edges=new DataSourceContract<Edge,PactNull>(EdgeListInFormat.class,edgeInput);
  edges.setFormatParameter(""String_Node_Str"",""String_Node_Str"");
  edges.setDegreeOfParallelism(noSubTasks);
  edges.setOutputContract(UniqueKey.class);
  MapContract<Edge,PactNull,PactString,Edge> assignKeys=new MapContract<Edge,PactNull,PactString,Edge>(AssignKeys.class,""String_Node_Str"");
  assignKeys.setDegreeOfParallelism(noSubTasks);
  ReduceContract<PactString,Edge,Edge,EdgeList> buildTriads=new ReduceContract<PactString,Edge,Edge,EdgeList>(BuildTriads.class,""String_Node_Str"");
  buildTriads.setDegreeOfParallelism(noSubTasks);
  MatchContract<Edge,EdgeList,PactNull,PactNull,EdgeList> closeTriads=new MatchContract<Edge,EdgeList,PactNull,PactNull,EdgeList>(CloseTriads.class,""String_Node_Str"");
  closeTriads.setDegreeOfParallelism(noSubTasks);
  closeTriads.getStubParameters().setString(PactCompiler.HINT_LOCAL_STRATEGY,PactCompiler.HINT_LOCAL_STRATEGY_SORT);
  DataSinkContract<PactNull,EdgeList> triangles=new DataSinkContract<PactNull,EdgeList>(EdgeListOutFormat.class,output);
  triangles.setDegreeOfParallelism(noSubTasks);
  triangles.setInput(closeTriads);
  closeTriads.setSecondInput(edges);
  closeTriads.setFirstInput(buildTriads);
  buildTriads.setInput(assignKeys);
  assignKeys.setInput(edges);
  return new Plan(triangles,""String_Node_Str"");
}","/** 
 * Assembles the Plan of the triangle enumeration example Pact program.
 */
@Override public Plan getPlan(String... args){
  int noSubTasks=(args.length > 0 ? Integer.parseInt(args[0]) : 1);
  String edgeInput=(args.length > 1 ? args[1] : ""String_Node_Str"");
  String output=(args.length > 2 ? args[2] : ""String_Node_Str"");
  DataSourceContract<Edge,PactNull> edges=new DataSourceContract<Edge,PactNull>(EdgeListInFormat.class,edgeInput);
  edges.setFormatParameter(""String_Node_Str"",""String_Node_Str"");
  edges.setDegreeOfParallelism(noSubTasks);
  edges.setOutputContract(UniqueKey.class);
  MapContract<Edge,PactNull,PactString,Edge> assignKeys=new MapContract<Edge,PactNull,PactString,Edge>(AssignKeys.class,""String_Node_Str"");
  assignKeys.setDegreeOfParallelism(noSubTasks);
  ReduceContract<PactString,Edge,Edge,EdgeList> buildTriads=new ReduceContract<PactString,Edge,Edge,EdgeList>(BuildTriads.class,""String_Node_Str"");
  buildTriads.setDegreeOfParallelism(noSubTasks);
  MatchContract<Edge,EdgeList,PactNull,PactNull,EdgeList> closeTriads=new MatchContract<Edge,EdgeList,PactNull,PactNull,EdgeList>(CloseTriads.class,""String_Node_Str"");
  closeTriads.setDegreeOfParallelism(noSubTasks);
  closeTriads.getStubParameters().setString(PactCompiler.HINT_LOCAL_STRATEGY,PactCompiler.HINT_LOCAL_STRATEGY_SORT);
  DataSinkContract<PactNull,EdgeList> triangles=new DataSinkContract<PactNull,EdgeList>(EdgeListOutFormat.class,output);
  triangles.setDegreeOfParallelism(noSubTasks);
  triangles.setInput(closeTriads);
  closeTriads.setSecondInput(edges);
  closeTriads.setFirstInput(buildTriads);
  buildTriads.setInput(assignKeys);
  assignKeys.setInput(edges);
  return new Plan(triangles,""String_Node_Str"");
}"
88411,"/** 
 * {@inheritDoc}
 */
@Override public Plan getPlan(final String... args){
  int degreeOfParallelism=1;
  String ordersPath=""String_Node_Str"";
  String lineitemsPath=""String_Node_Str"";
  String resultPath=""String_Node_Str"";
  if (args.length != 4) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  degreeOfParallelism=Integer.parseInt(args[0]);
  ordersPath=args[1];
  lineitemsPath=args[2];
  resultPath=args[3];
  DataSourceContract<PactInteger,Tuple> orders=new DataSourceContract<PactInteger,Tuple>(IntTupleDataInFormat.class,ordersPath,""String_Node_Str"");
  orders.setFormatParameter(""String_Node_Str"",""String_Node_Str"");
  orders.setDegreeOfParallelism(degreeOfParallelism);
  orders.setOutputContract(UniqueKey.class);
  orders.getCompilerHints().setAvgNumValuesPerKey(1);
  DataSourceContract<PactInteger,Tuple> lineitems=new DataSourceContract<PactInteger,Tuple>(IntTupleDataInFormat.class,lineitemsPath,""String_Node_Str"");
  lineitems.setFormatParameter(""String_Node_Str"",""String_Node_Str"");
  lineitems.setDegreeOfParallelism(degreeOfParallelism);
  lineitems.getCompilerHints().setAvgNumValuesPerKey(4);
  MapContract<PactInteger,Tuple,PactInteger,Tuple> filterO=new MapContract<PactInteger,Tuple,PactInteger,Tuple>(FilterO.class,""String_Node_Str"");
  filterO.setDegreeOfParallelism(degreeOfParallelism);
  filterO.getCompilerHints().setAvgBytesPerRecord(32);
  filterO.getCompilerHints().setSelectivity(0.05f);
  filterO.getCompilerHints().setAvgNumValuesPerKey(1);
  MapContract<PactInteger,Tuple,PactInteger,Tuple> projectLi=new MapContract<PactInteger,Tuple,PactInteger,Tuple>(ProjectLi.class,""String_Node_Str"");
  projectLi.setDegreeOfParallelism(degreeOfParallelism);
  projectLi.getCompilerHints().setAvgBytesPerRecord(48);
  projectLi.getCompilerHints().setSelectivity(1.0f);
  projectLi.getCompilerHints().setAvgNumValuesPerKey(4);
  MatchContract<PactInteger,Tuple,Tuple,N_IntStringPair,Tuple> joinLiO=new MatchContract<PactInteger,Tuple,Tuple,N_IntStringPair,Tuple>(JoinLiO.class,""String_Node_Str"");
  joinLiO.setDegreeOfParallelism(degreeOfParallelism);
  joinLiO.getCompilerHints().setSelectivity(0.05f);
  joinLiO.getCompilerHints().setAvgBytesPerRecord(64);
  joinLiO.getCompilerHints().setAvgNumValuesPerKey(4);
  ReduceContract<N_IntStringPair,Tuple,PactInteger,Tuple> aggLiO=new ReduceContract<N_IntStringPair,Tuple,PactInteger,Tuple>(AggLiO.class,""String_Node_Str"");
  aggLiO.setDegreeOfParallelism(degreeOfParallelism);
  aggLiO.getCompilerHints().setAvgBytesPerRecord(64);
  aggLiO.getCompilerHints().setSelectivity(0.25f);
  aggLiO.getCompilerHints().setAvgNumValuesPerKey(1);
  DataSinkContract<PactString,Tuple> result=new DataSinkContract<PactString,Tuple>(StringTupleDataOutFormat.class,resultPath,""String_Node_Str"");
  result.setDegreeOfParallelism(degreeOfParallelism);
  result.setInput(aggLiO);
  aggLiO.setInput(joinLiO);
  joinLiO.setFirstInput(filterO);
  filterO.setInput(orders);
  joinLiO.setSecondInput(projectLi);
  projectLi.setInput(lineitems);
  return new Plan(result,""String_Node_Str"");
}","/** 
 * {@inheritDoc}
 */
@Override public Plan getPlan(final String... args){
  int noSubtasks=(args.length > 0 ? Integer.parseInt(args[0]) : 1);
  String ordersPath=(args.length > 1 ? args[1] : ""String_Node_Str"");
  String lineitemsPath=(args.length > 2 ? args[2] : ""String_Node_Str"");
  String output=(args.length > 3 ? args[3] : ""String_Node_Str"");
  DataSourceContract<PactInteger,Tuple> orders=new DataSourceContract<PactInteger,Tuple>(IntTupleDataInFormat.class,ordersPath,""String_Node_Str"");
  orders.setFormatParameter(""String_Node_Str"",""String_Node_Str"");
  orders.setDegreeOfParallelism(noSubtasks);
  orders.setOutputContract(UniqueKey.class);
  orders.getCompilerHints().setAvgNumValuesPerKey(1);
  DataSourceContract<PactInteger,Tuple> lineitems=new DataSourceContract<PactInteger,Tuple>(IntTupleDataInFormat.class,lineitemsPath,""String_Node_Str"");
  lineitems.setFormatParameter(""String_Node_Str"",""String_Node_Str"");
  lineitems.setDegreeOfParallelism(noSubtasks);
  lineitems.getCompilerHints().setAvgNumValuesPerKey(4);
  MapContract<PactInteger,Tuple,PactInteger,Tuple> filterO=new MapContract<PactInteger,Tuple,PactInteger,Tuple>(FilterO.class,""String_Node_Str"");
  filterO.setDegreeOfParallelism(noSubtasks);
  filterO.getCompilerHints().setAvgBytesPerRecord(32);
  filterO.getCompilerHints().setSelectivity(0.05f);
  filterO.getCompilerHints().setAvgNumValuesPerKey(1);
  MapContract<PactInteger,Tuple,PactInteger,Tuple> projectLi=new MapContract<PactInteger,Tuple,PactInteger,Tuple>(ProjectLi.class,""String_Node_Str"");
  projectLi.setDegreeOfParallelism(noSubtasks);
  projectLi.getCompilerHints().setAvgBytesPerRecord(48);
  projectLi.getCompilerHints().setSelectivity(1.0f);
  projectLi.getCompilerHints().setAvgNumValuesPerKey(4);
  MatchContract<PactInteger,Tuple,Tuple,N_IntStringPair,Tuple> joinLiO=new MatchContract<PactInteger,Tuple,Tuple,N_IntStringPair,Tuple>(JoinLiO.class,""String_Node_Str"");
  joinLiO.setDegreeOfParallelism(noSubtasks);
  joinLiO.getCompilerHints().setSelectivity(0.05f);
  joinLiO.getCompilerHints().setAvgBytesPerRecord(64);
  joinLiO.getCompilerHints().setAvgNumValuesPerKey(4);
  ReduceContract<N_IntStringPair,Tuple,PactInteger,Tuple> aggLiO=new ReduceContract<N_IntStringPair,Tuple,PactInteger,Tuple>(AggLiO.class,""String_Node_Str"");
  aggLiO.setDegreeOfParallelism(noSubtasks);
  aggLiO.getCompilerHints().setAvgBytesPerRecord(64);
  aggLiO.getCompilerHints().setSelectivity(0.25f);
  aggLiO.getCompilerHints().setAvgNumValuesPerKey(1);
  DataSinkContract<PactString,Tuple> result=new DataSinkContract<PactString,Tuple>(StringTupleDataOutFormat.class,output,""String_Node_Str"");
  result.setDegreeOfParallelism(noSubtasks);
  result.setInput(aggLiO);
  aggLiO.setInput(joinLiO);
  joinLiO.setFirstInput(filterO);
  filterO.setInput(orders);
  joinLiO.setSecondInput(projectLi);
  projectLi.setInput(lineitems);
  return new Plan(result,""String_Node_Str"");
}"
88412,"/** 
 * {@inheritDoc}
 */
@Override public Plan getPlan(String... args){
  if (args.length != 5) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  int noSubTasks=Integer.parseInt(args[0]);
  String docsInput=args[1];
  String ranksInput=args[2];
  String visitsInput=args[3];
  String output=args[4];
  DataSourceContract<PactString,Tuple> docs=new DataSourceContract<PactString,Tuple>(StringTupleDataInFormat.class,docsInput,""String_Node_Str"");
  docs.setFormatParameter(TextInputFormat.FORMAT_PAIR_DELIMITER,""String_Node_Str"");
  docs.setDegreeOfParallelism(noSubTasks);
  docs.setOutputContract(UniqueKey.class);
  DataSourceContract<PactString,Tuple> ranks=new DataSourceContract<PactString,Tuple>(StringTupleDataInFormat.class,ranksInput,""String_Node_Str"");
  ranks.setFormatParameter(TextInputFormat.FORMAT_PAIR_DELIMITER,""String_Node_Str"");
  ranks.setDegreeOfParallelism(noSubTasks);
  DataSourceContract<PactString,Tuple> visits=new DataSourceContract<PactString,Tuple>(StringTupleDataInFormat.class,visitsInput,""String_Node_Str"");
  visits.setFormatParameter(TextInputFormat.FORMAT_PAIR_DELIMITER,""String_Node_Str"");
  visits.setDegreeOfParallelism(noSubTasks);
  MapContract<PactString,Tuple,PactString,PactNull> filterDocs=new MapContract<PactString,Tuple,PactString,PactNull>(FilterDocs.class,""String_Node_Str"");
  filterDocs.setDegreeOfParallelism(noSubTasks);
  filterDocs.getCompilerHints().setSelectivity(0.15f);
  filterDocs.getCompilerHints().setAvgBytesPerRecord(60);
  MapContract<PactString,Tuple,PactString,Tuple> filterRanks=new MapContract<PactString,Tuple,PactString,Tuple>(FilterRanks.class,""String_Node_Str"");
  filterRanks.setDegreeOfParallelism(noSubTasks);
  filterRanks.getCompilerHints().setSelectivity(0.25f);
  MapContract<PactString,Tuple,PactString,PactNull> filterVisits=new MapContract<PactString,Tuple,PactString,PactNull>(FilterVisits.class,""String_Node_Str"");
  filterVisits.setDegreeOfParallelism(noSubTasks);
  filterVisits.getCompilerHints().setAvgBytesPerRecord(60);
  filterVisits.getCompilerHints().setSelectivity(0.2f);
  MatchContract<PactString,Tuple,PactNull,PactString,Tuple> joinDocsRanks=new MatchContract<PactString,Tuple,PactNull,PactString,Tuple>(JoinDocRanks.class,""String_Node_Str"");
  joinDocsRanks.setDegreeOfParallelism(noSubTasks);
  joinDocsRanks.getCompilerHints().setSelectivity(0.15f);
  CoGroupContract<PactString,PactNull,Tuple,PactString,Tuple> antiJoinVisits=new CoGroupContract<PactString,PactNull,Tuple,PactString,Tuple>(AntiJoinVisits.class,""String_Node_Str"");
  antiJoinVisits.setDegreeOfParallelism(noSubTasks);
  DataSinkContract<PactString,Tuple> result=new DataSinkContract<PactString,Tuple>(StringTupleDataOutFormat.class,output,""String_Node_Str"");
  result.setDegreeOfParallelism(noSubTasks);
  filterDocs.setInput(docs);
  filterRanks.setInput(ranks);
  filterVisits.setInput(visits);
  joinDocsRanks.setFirstInput(filterRanks);
  joinDocsRanks.setSecondInput(filterDocs);
  antiJoinVisits.setFirstInput(filterVisits);
  antiJoinVisits.setSecondInput(joinDocsRanks);
  result.setInput(antiJoinVisits);
  return new Plan(result,""String_Node_Str"");
}","/** 
 * {@inheritDoc}
 */
@Override public Plan getPlan(String... args){
  int noSubTasks=(args.length > 0 ? Integer.parseInt(args[0]) : 1);
  String docsInput=(args.length > 1 ? args[1] : ""String_Node_Str"");
  String ranksInput=(args.length > 2 ? args[2] : ""String_Node_Str"");
  String visitsInput=(args.length > 3 ? args[3] : ""String_Node_Str"");
  String output=(args.length > 4 ? args[4] : ""String_Node_Str"");
  DataSourceContract<PactString,Tuple> docs=new DataSourceContract<PactString,Tuple>(StringTupleDataInFormat.class,docsInput,""String_Node_Str"");
  docs.setFormatParameter(TextInputFormat.FORMAT_PAIR_DELIMITER,""String_Node_Str"");
  docs.setDegreeOfParallelism(noSubTasks);
  docs.setOutputContract(UniqueKey.class);
  DataSourceContract<PactString,Tuple> ranks=new DataSourceContract<PactString,Tuple>(StringTupleDataInFormat.class,ranksInput,""String_Node_Str"");
  ranks.setFormatParameter(TextInputFormat.FORMAT_PAIR_DELIMITER,""String_Node_Str"");
  ranks.setDegreeOfParallelism(noSubTasks);
  DataSourceContract<PactString,Tuple> visits=new DataSourceContract<PactString,Tuple>(StringTupleDataInFormat.class,visitsInput,""String_Node_Str"");
  visits.setFormatParameter(TextInputFormat.FORMAT_PAIR_DELIMITER,""String_Node_Str"");
  visits.setDegreeOfParallelism(noSubTasks);
  MapContract<PactString,Tuple,PactString,PactNull> filterDocs=new MapContract<PactString,Tuple,PactString,PactNull>(FilterDocs.class,""String_Node_Str"");
  filterDocs.setDegreeOfParallelism(noSubTasks);
  filterDocs.getCompilerHints().setSelectivity(0.15f);
  filterDocs.getCompilerHints().setAvgBytesPerRecord(60);
  MapContract<PactString,Tuple,PactString,Tuple> filterRanks=new MapContract<PactString,Tuple,PactString,Tuple>(FilterRanks.class,""String_Node_Str"");
  filterRanks.setDegreeOfParallelism(noSubTasks);
  filterRanks.getCompilerHints().setSelectivity(0.25f);
  MapContract<PactString,Tuple,PactString,PactNull> filterVisits=new MapContract<PactString,Tuple,PactString,PactNull>(FilterVisits.class,""String_Node_Str"");
  filterVisits.setDegreeOfParallelism(noSubTasks);
  filterVisits.getCompilerHints().setAvgBytesPerRecord(60);
  filterVisits.getCompilerHints().setSelectivity(0.2f);
  MatchContract<PactString,Tuple,PactNull,PactString,Tuple> joinDocsRanks=new MatchContract<PactString,Tuple,PactNull,PactString,Tuple>(JoinDocRanks.class,""String_Node_Str"");
  joinDocsRanks.setDegreeOfParallelism(noSubTasks);
  joinDocsRanks.getCompilerHints().setSelectivity(0.15f);
  CoGroupContract<PactString,PactNull,Tuple,PactString,Tuple> antiJoinVisits=new CoGroupContract<PactString,PactNull,Tuple,PactString,Tuple>(AntiJoinVisits.class,""String_Node_Str"");
  antiJoinVisits.setDegreeOfParallelism(noSubTasks);
  DataSinkContract<PactString,Tuple> result=new DataSinkContract<PactString,Tuple>(StringTupleDataOutFormat.class,output,""String_Node_Str"");
  result.setDegreeOfParallelism(noSubTasks);
  filterDocs.setInput(docs);
  filterRanks.setInput(ranks);
  filterVisits.setInput(visits);
  joinDocsRanks.setFirstInput(filterRanks);
  joinDocsRanks.setSecondInput(filterDocs);
  antiJoinVisits.setFirstInput(filterVisits);
  antiJoinVisits.setSecondInput(joinDocsRanks);
  result.setInput(antiJoinVisits);
  return new Plan(result,""String_Node_Str"");
}"
88413,"/** 
 * {@inheritDoc}
 */
@Override public Plan getPlan(String... args){
  if (args.length != 3) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  int noSubTasks=Integer.parseInt(args[0]);
  String dataInput=args[1];
  String output=args[2];
  DataSourceContract<PactNull,PactString> data=new DataSourceContract<PactNull,PactString>(LineInFormat.class,dataInput,""String_Node_Str"");
  data.setDegreeOfParallelism(noSubTasks);
  MapContract<PactNull,PactString,PactString,PactInteger> mapper=new MapContract<PactNull,PactString,PactString,PactInteger>(TokenizeLine.class,""String_Node_Str"");
  mapper.setDegreeOfParallelism(noSubTasks);
  ReduceContract<PactString,PactInteger,PactString,PactInteger> reducer=new ReduceContract<PactString,PactInteger,PactString,PactInteger>(CountWords.class,""String_Node_Str"");
  reducer.setDegreeOfParallelism(noSubTasks);
  DataSinkContract<PactString,PactInteger> out=new DataSinkContract<PactString,PactInteger>(WordCountOutFormat.class,output,""String_Node_Str"");
  out.setDegreeOfParallelism(noSubTasks);
  out.setInput(reducer);
  reducer.setInput(mapper);
  mapper.setInput(data);
  return new Plan(out,""String_Node_Str"");
}","/** 
 * {@inheritDoc}
 */
@Override public Plan getPlan(String... args){
  int noSubTasks=(args.length > 0 ? Integer.parseInt(args[0]) : 1);
  String dataInput=(args.length > 1 ? args[1] : ""String_Node_Str"");
  String output=(args.length > 2 ? args[2] : ""String_Node_Str"");
  DataSourceContract<PactNull,PactString> data=new DataSourceContract<PactNull,PactString>(LineInFormat.class,dataInput,""String_Node_Str"");
  data.setDegreeOfParallelism(noSubTasks);
  MapContract<PactNull,PactString,PactString,PactInteger> mapper=new MapContract<PactNull,PactString,PactString,PactInteger>(TokenizeLine.class,""String_Node_Str"");
  mapper.setDegreeOfParallelism(noSubTasks);
  ReduceContract<PactString,PactInteger,PactString,PactInteger> reducer=new ReduceContract<PactString,PactInteger,PactString,PactInteger>(CountWords.class,""String_Node_Str"");
  reducer.setDegreeOfParallelism(noSubTasks);
  DataSinkContract<PactString,PactInteger> out=new DataSinkContract<PactString,PactInteger>(WordCountOutFormat.class,output,""String_Node_Str"");
  out.setDegreeOfParallelism(noSubTasks);
  out.setInput(reducer);
  reducer.setInput(mapper);
  mapper.setInput(data);
  return new Plan(out,""String_Node_Str"");
}"
88414,"/** 
 * Initializes the output collector with a set of writers.  To specify for a writer that it must be fed with a deep-copy, set the bit in the copy flag bit mask to 1 that  corresponds to the position of the writer within the   {@link List}.
 * @param writers List of all writers.
 * @param fwdCopyFlags Bit mask that specifies which writer is fed with deep-copies.
 */
public OutputCollector(List<RecordWriter<KeyValuePair<K,V>>> writers,int fwdCopyFlags){
  this.writers=writers;
  this.fwdCopyFlags=fwdCopyFlags;
  this.copier=new SerializationCopier<KeyValuePair<K,V>>();
}","/** 
 * Initializes the output collector with a set of writers.  To specify for a writer that it must be fed with a deep-copy, set the bit in the copy flag bit mask to 1 that  corresponds to the position of the writer within the   {@link List}.
 * @param writers List of all writers.
 * @param fwdCopyFlags Bit mask that specifies which writer is fed with deep-copies.
 */
public OutputCollector(List<RecordWriter<KeyValuePair<K,V>>> writers,int fwdCopyFlags){
  this.writers=writers;
  this.fwdCopyFlags=fwdCopyFlags;
  this.kvpCopier=new SerializationCopier<KeyValuePair<K,V>>();
}"
88415,"/** 
 * Collects a   {@link Key} and {@link Value}, wraps them in a KeyValuePair, and emit them to all writers. Writers which require a deep-copy are fed with a copy obtained through de/serialization.
 */
@Override public void collect(K key,V value){
  try {
    final KeyValuePair<K,V> emitPair=new KeyValuePair<K,V>(key,value);
    if (fwdCopyFlags == 0) {
      for (int i=0; i < writers.size(); i++) {
        writers.get(i).emit(emitPair);
      }
    }
 else {
      copier.setCopy(emitPair);
      for (int i=0; i < writers.size(); i++) {
        if (((fwdCopyFlags >> i) & 0x1) != 0) {
          copier.getCopy(emitPair);
        }
        writers.get(i).emit(emitPair);
      }
    }
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
catch (  InterruptedException e) {
    throw new RuntimeException(e);
  }
}","/** 
 * Collects a   {@link Key} and {@link Value}, wraps them in a KeyValuePair, and emit them to all writers. Writers which require a deep-copy are fed with a copy obtained through de/serialization.
 */
@Override public void collect(K key,V value){
  try {
    KeyValuePair<K,V> emitPair=new KeyValuePair<K,V>(key,value);
    if (fwdCopyFlags == 0) {
      for (int i=0; i < writers.size(); i++) {
        writers.get(i).emit(emitPair);
      }
    }
 else {
      if (kvpSerialization == null) {
        this.kvpSerialization=new KeyValuePairSerializationFactory<K,V>(new WritableSerializationFactory<K>((Class<K>)key.getClass()),new WritableSerializationFactory<V>((Class<V>)value.getClass()));
      }
      kvpCopier.setCopy(emitPair);
      for (int i=0; i < writers.size(); i++) {
        if (((fwdCopyFlags >> i) & 0x1) != 0) {
          emitPair=kvpSerialization.newInstance();
          kvpCopier.getCopy(emitPair);
        }
        writers.get(i).emit(emitPair);
      }
    }
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
catch (  InterruptedException e) {
    throw new RuntimeException(e);
  }
}"
88416,"/** 
 * Creates a new channel selector that uses the given strategy (broadcasting, partitioning, ...), using the supplied salt to randomize hashes.
 * @param strategy The distribution strategy to be used.
 * @param salt The salt used to randomize hash values.
 */
public OutputEmitter(ShipStrategy strategy,byte[] salt){
  if (strategy != ShipStrategy.BROADCAST && strategy != ShipStrategy.PARTITION_HASH && strategy != ShipStrategy.FORWARD) {
    throw new UnsupportedOperationException(""String_Node_Str"" + strategy.name());
  }
  this.strategy=strategy;
  this.salt=salt;
}","/** 
 * Creates a new channel selector that uses the given strategy (broadcasting, partitioning, ...), using the supplied salt to randomize hashes.
 * @param strategy The distribution strategy to be used.
 * @param salt The salt used to randomize hash values.
 */
public OutputEmitter(ShipStrategy strategy,byte[] salt){
  this.strategy=strategy;
  this.salt=salt;
}"
88417,"@Override public int[] selectChannels(KeyValuePair<K,V> pair,int numberOfChannels){
switch (strategy) {
case BROADCAST:
    return broadcast(numberOfChannels);
case PARTITION_HASH:
  return partition(pair,numberOfChannels);
case FORWARD:
return robin(numberOfChannels);
default :
throw new UnsupportedOperationException();
}
}","@Override public int[] selectChannels(KeyValuePair<K,V> pair,int numberOfChannels){
switch (strategy) {
case BROADCAST:
    return broadcast(numberOfChannels);
case PARTITION_HASH:
  return partition(pair,numberOfChannels);
case FORWARD:
return robin(numberOfChannels);
default :
throw new UnsupportedOperationException(""String_Node_Str"" + strategy.name());
}
}"
88418,"/** 
 * Sets the bytes the ID consists of.
 * @param src the bytes the ID consists of
 */
private void setBytes(byte[] src){
  if (src == null) {
    return;
  }
  if (src.length != SIZE) {
    return;
  }
  System.arraycopy(bytes,0,this.bytes,0,SIZE);
}","/** 
 * Sets the bytes the ID consists of.
 * @param src the bytes the ID consists of
 */
private void setBytes(byte[] src){
  if (src == null) {
    return;
  }
  if (src.length != SIZE) {
    return;
  }
  System.arraycopy(src,0,this.bytes,0,SIZE);
}"
88419,"/** 
 * Creates a new channel selector that uses the given strategy (broadcasting, partitioning, ...), using the supplied salt to randomize hashes.
 * @param strategy The distribution strategy to be used.
 * @param salt The salt used to randomize hash values.
 */
public OutputEmitter(ShipStrategy strategy,byte[] salt){
  if (strategy != ShipStrategy.BROADCAST && strategy != ShipStrategy.PARTITION_HASH && strategy != ShipStrategy.NONE) {
    throw new UnsupportedOperationException(""String_Node_Str"" + strategy.name());
  }
  this.strategy=strategy;
  this.salt=salt;
}","/** 
 * Creates a new channel selector that uses the given strategy (broadcasting, partitioning, ...), using the supplied salt to randomize hashes.
 * @param strategy The distribution strategy to be used.
 * @param salt The salt used to randomize hash values.
 */
public OutputEmitter(ShipStrategy strategy,byte[] salt){
  if (strategy != ShipStrategy.BROADCAST && strategy != ShipStrategy.PARTITION_HASH && strategy != ShipStrategy.FORWARD) {
    throw new UnsupportedOperationException(""String_Node_Str"" + strategy.name());
  }
  this.strategy=strategy;
  this.salt=salt;
}"
88420,"@Override public int[] selectChannels(KeyValuePair<K,V> pair,int numberOfChannels){
switch (strategy) {
case BROADCAST:
    return broadcast(numberOfChannels);
case PARTITION_HASH:
  return partition(pair,numberOfChannels);
case NONE:
return robin(numberOfChannels);
default :
throw new UnsupportedOperationException();
}
}","@Override public int[] selectChannels(KeyValuePair<K,V> pair,int numberOfChannels){
switch (strategy) {
case BROADCAST:
    return broadcast(numberOfChannels);
case PARTITION_HASH:
  return partition(pair,numberOfChannels);
case FORWARD:
return robin(numberOfChannels);
default :
throw new UnsupportedOperationException();
}
}"
88421,"private void createBufferMock(BufferedReader mock,String fileString) throws FileNotFoundException, Exception {
  FileReader reader=new FileReader(fileString);
  whenNew(FileReader.class).withArguments(fileString).thenReturn(reader);
  whenNew(BufferedReader.class).withArguments(reader).thenReturn(mock);
}","private void createBufferMock(BufferedReader mock,String fileString) throws FileNotFoundException, Exception {
  whenNew(FileReader.class).withArguments(fileString).thenReturn(this.fileReaderMock);
  whenNew(BufferedReader.class).withArguments(this.fileReaderMock).thenReturn(mock);
}"
88422,"/** 
 * {@inheritDoc}
 */
@Override public void schedulJob(ExecutionGraph executionGraph) throws SchedulingException {
  final Map<InstanceType,InstanceTypeDescription> availableInstances=this.instanceManager.getMapOfAvailableInstanceTypes();
  for (int i=0; i < executionGraph.getNumberOfStages(); i++) {
    final Map<InstanceType,Integer> requiredInstanceTypes=new HashMap<InstanceType,Integer>();
    executionGraph.collectInstanceTypesRequiredForStage(i,requiredInstanceTypes,ExecutionState.CREATED);
    final Iterator<Map.Entry<InstanceType,Integer>> it=requiredInstanceTypes.entrySet().iterator();
    while (it.hasNext()) {
      final Map.Entry<InstanceType,Integer> entry=it.next();
      final InstanceTypeDescription descr=availableInstances.get(entry.getKey());
      if (descr == null) {
        throw new SchedulingException(""String_Node_Str"" + entry.getKey() + ""String_Node_Str"");
      }
      if (descr.getMaximumNumberOfAvailableInstances() != -1 && descr.getMaximumNumberOfAvailableInstances() < entry.getValue().intValue()) {
        throw new SchedulingException(""String_Node_Str"" + entry.getValue().intValue() + ""String_Node_Str""+ entry.getKey()+ ""String_Node_Str""+ descr.getMaximumNumberOfAvailableInstances()+ ""String_Node_Str"");
      }
    }
  }
synchronized (this.jobQueue) {
    this.jobQueue.add(executionGraph);
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void schedulJob(ExecutionGraph executionGraph) throws SchedulingException {
  final Map<InstanceType,InstanceTypeDescription> availableInstances=this.instanceManager.getMapOfAvailableInstanceTypes();
  for (int i=0; i < executionGraph.getNumberOfStages(); i++) {
    final Map<InstanceType,Integer> requiredInstanceTypes=new HashMap<InstanceType,Integer>();
    executionGraph.collectInstanceTypesRequiredForStage(i,requiredInstanceTypes,ExecutionState.CREATED);
    final Iterator<Map.Entry<InstanceType,Integer>> it=requiredInstanceTypes.entrySet().iterator();
    while (it.hasNext()) {
      final Map.Entry<InstanceType,Integer> entry=it.next();
      final InstanceTypeDescription descr=availableInstances.get(entry.getKey());
      if (descr == null) {
        throw new SchedulingException(""String_Node_Str"" + entry.getKey() + ""String_Node_Str"");
      }
      if (descr.getMaximumNumberOfAvailableInstances() != -1 && descr.getMaximumNumberOfAvailableInstances() < entry.getValue().intValue()) {
        throw new SchedulingException(""String_Node_Str"" + entry.getValue().intValue() + ""String_Node_Str""+ entry.getKey()+ ""String_Node_Str""+ descr.getMaximumNumberOfAvailableInstances()+ ""String_Node_Str"");
      }
    }
  }
  final ExecutionGraphIterator it2=new ExecutionGraphIterator(executionGraph,true);
  while (it2.hasNext()) {
    final ExecutionVertex vertex=it2.next();
    if (vertex.getExecutionState() != ExecutionState.CREATED) {
      LOG.error(""String_Node_Str"" + vertex + ""String_Node_Str""+ vertex.getExecutionState()+ ""String_Node_Str""+ ExecutionState.CREATED);
    }
    vertex.getEnvironment().registerExecutionListener(new QueueExecutionListener(this,vertex));
    vertex.setExecutionState(ExecutionState.SCHEDULED);
  }
synchronized (this.jobQueue) {
    this.jobQueue.add(executionGraph);
  }
}"
88423,"void removeJobFromSchedule(ExecutionGraph executionGraphToRemove){
  boolean removedFromQueue=false;
  ;
synchronized (this.jobQueue) {
    final Iterator<ExecutionGraph> it=this.jobQueue.iterator();
    while (it.hasNext()) {
      final ExecutionGraph executionGraph=it.next();
      if (executionGraph.getJobID().equals(executionGraphToRemove.getJobID())) {
        removedFromQueue=true;
        it.remove();
        break;
      }
    }
  }
  if (removedFromQueue) {
    this.schedulingListener.jobRemovedFromScheduler(executionGraphToRemove);
  }
 else {
    LOG.error(""String_Node_Str"" + executionGraphToRemove.getJobName() + ""String_Node_Str""+ executionGraphToRemove.getJobID()+ ""String_Node_Str"");
  }
}","void removeJobFromSchedule(ExecutionGraph executionGraphToRemove){
  boolean removedFromQueue=false;
synchronized (this.jobQueue) {
    final Iterator<ExecutionGraph> it=this.jobQueue.iterator();
    while (it.hasNext()) {
      final ExecutionGraph executionGraph=it.next();
      if (executionGraph.getJobID().equals(executionGraphToRemove.getJobID())) {
        removedFromQueue=true;
        it.remove();
        break;
      }
    }
  }
  if (removedFromQueue) {
    this.schedulingListener.jobRemovedFromScheduler(executionGraphToRemove);
  }
 else {
    LOG.error(""String_Node_Str"" + executionGraphToRemove.getJobName() + ""String_Node_Str""+ executionGraphToRemove.getJobID()+ ""String_Node_Str"");
  }
}"
88424,"void removeJobFromSchedule(ExecutionGraph executionGraphToRemove){
  boolean removedFromQueue=false;
  ;
synchronized (this.jobQueue) {
    final Iterator<ExecutionGraph> it=this.jobQueue.iterator();
    while (it.hasNext()) {
      final ExecutionGraph executionGraph=it.next();
      if (executionGraph.getJobID().equals(executionGraphToRemove.getJobID())) {
        removedFromQueue=true;
        it.remove();
        break;
      }
    }
  }
  if (removedFromQueue) {
    this.schedulingListener.jobRemovedFromScheduler(executionGraphToRemove);
  }
 else {
    LOG.error(""String_Node_Str"" + executionGraphToRemove.getJobName() + ""String_Node_Str""+ executionGraphToRemove.getJobID()+ ""String_Node_Str"");
  }
}","void removeJobFromSchedule(ExecutionGraph executionGraphToRemove){
  boolean removedFromQueue=false;
synchronized (this.jobQueue) {
    final Iterator<ExecutionGraph> it=this.jobQueue.iterator();
    while (it.hasNext()) {
      final ExecutionGraph executionGraph=it.next();
      if (executionGraph.getJobID().equals(executionGraphToRemove.getJobID())) {
        removedFromQueue=true;
        it.remove();
        break;
      }
    }
  }
  if (removedFromQueue) {
    this.schedulingListener.jobRemovedFromScheduler(executionGraphToRemove);
  }
 else {
    LOG.error(""String_Node_Str"" + executionGraphToRemove.getJobName() + ""String_Node_Str""+ executionGraphToRemove.getJobID()+ ""String_Node_Str"");
  }
}"
88425,"public boolean isAnySuccessorIOBottleneck(Map<ManagementGroupEdge,Boolean> successorIOBottleneckMap){
  Boolean anySuccessorIsIOBottleneck=successorIOBottleneckMap.get(this.managementGroupEdge);
  if (anySuccessorIsIOBottleneck == null) {
    final ManagementGroupVertex groupVertex=this.managementGroupEdge.getTarget();
    for (int i=0; i < groupVertex.getNumberOfForwardEdges(); i++) {
      final ManagementGroupEdge successorEdge=groupVertex.getForwardEdge(i);
      final GroupEdgeVisualizationData groupEdgeVisualizationData=(GroupEdgeVisualizationData)successorEdge.getAttachment();
      groupEdgeVisualizationData.updateIOBottleneckFlag(successorIOBottleneckMap);
      if (groupEdgeVisualizationData.isIOBottleneck() || groupEdgeVisualizationData.isAnySuccessorIOBottleneck(successorIOBottleneckMap)) {
        successorIOBottleneckMap.put(this.managementGroupEdge,new Boolean(true));
        return true;
      }
    }
    successorIOBottleneckMap.put(this.managementGroupEdge,new Boolean(false));
    return false;
  }
  return anySuccessorIsIOBottleneck.booleanValue();
}","public boolean isAnySuccessorIOBottleneck(Map<ManagementGroupEdge,Boolean> successorIOBottleneckMap){
  Boolean anySuccessorIsIOBottleneck=successorIOBottleneckMap.get(this.managementGroupEdge);
  if (anySuccessorIsIOBottleneck == null) {
    final ManagementGroupVertex groupVertex=this.managementGroupEdge.getTarget();
    for (int i=0; i < groupVertex.getNumberOfForwardEdges(); i++) {
      final ManagementGroupEdge successorEdge=groupVertex.getForwardEdge(i);
      final GroupEdgeVisualizationData groupEdgeVisualizationData=(GroupEdgeVisualizationData)successorEdge.getAttachment();
      groupEdgeVisualizationData.updateIOBottleneckFlag(successorIOBottleneckMap);
      if (groupEdgeVisualizationData.isIOBottleneck() || groupEdgeVisualizationData.isAnySuccessorIOBottleneck(successorIOBottleneckMap)) {
        successorIOBottleneckMap.put(this.managementGroupEdge,Boolean.valueOf(true));
        return true;
      }
    }
    successorIOBottleneckMap.put(this.managementGroupEdge,Boolean.valueOf(false));
    return false;
  }
  return anySuccessorIsIOBottleneck.booleanValue();
}"
88426,"public boolean isAnySuccessorCPUBottleneck(Map<ManagementGroupVertex,Boolean> successorCPUBottleneckMap){
  Boolean anySuccessorIsCPUBottleneck=successorCPUBottleneckMap.get(this.managementGroupVertex);
  if (anySuccessorIsCPUBottleneck == null) {
    for (int i=0; i < this.managementGroupVertex.getNumberOfForwardEdges(); i++) {
      final ManagementGroupVertex targetVertex=this.managementGroupVertex.getForwardEdge(i).getTarget();
      final GroupVertexVisualizationData groupVertexVisualizationData=(GroupVertexVisualizationData)targetVertex.getAttachment();
      groupVertexVisualizationData.updateCPUBottleneckFlag(successorCPUBottleneckMap);
      if (groupVertexVisualizationData.isCPUBottleneck() || groupVertexVisualizationData.isAnySuccessorCPUBottleneck(successorCPUBottleneckMap)) {
        successorCPUBottleneckMap.put(this.managementGroupVertex,new Boolean(true));
        return true;
      }
    }
    successorCPUBottleneckMap.put(this.managementGroupVertex,new Boolean(false));
    return false;
  }
  return anySuccessorIsCPUBottleneck.booleanValue();
}","public boolean isAnySuccessorCPUBottleneck(Map<ManagementGroupVertex,Boolean> successorCPUBottleneckMap){
  Boolean anySuccessorIsCPUBottleneck=successorCPUBottleneckMap.get(this.managementGroupVertex);
  if (anySuccessorIsCPUBottleneck == null) {
    for (int i=0; i < this.managementGroupVertex.getNumberOfForwardEdges(); i++) {
      final ManagementGroupVertex targetVertex=this.managementGroupVertex.getForwardEdge(i).getTarget();
      final GroupVertexVisualizationData groupVertexVisualizationData=(GroupVertexVisualizationData)targetVertex.getAttachment();
      groupVertexVisualizationData.updateCPUBottleneckFlag(successorCPUBottleneckMap);
      if (groupVertexVisualizationData.isCPUBottleneck() || groupVertexVisualizationData.isAnySuccessorCPUBottleneck(successorCPUBottleneckMap)) {
        successorCPUBottleneckMap.put(this.managementGroupVertex,Boolean.valueOf(true));
        return true;
      }
    }
    successorCPUBottleneckMap.put(this.managementGroupVertex,Boolean.valueOf(false));
    return false;
  }
  return anySuccessorIsCPUBottleneck.booleanValue();
}"
88427,"private final double toMBitPerSec(long numberOfBytes,long profilingPeriod){
  return ((double)numberOfBytes / (BYTE_TO_MEGABIT * profilingPeriod / 1000));
}","private final double toMBitPerSec(long numberOfBytes,long profilingPeriod){
  return (((double)numberOfBytes) / ((double)(BYTE_TO_MEGABIT * profilingPeriod / 1000L)));
}"
88428,"private Map<ManagementGroupVertex,SWTGroupVertex> addGroupVertices(Map<ManagementStage,SWTStage> stageMap){
  Map<ManagementGroupVertex,SWTGroupVertex> groupMap=new HashMap<ManagementGroupVertex,SWTGroupVertex>();
  Iterator<ManagementStage> iterator=stageMap.keySet().iterator();
  while (iterator.hasNext()) {
    final ManagementStage managementStage=iterator.next();
    final SWTStage parent=stageMap.get(managementStage);
    for (int i=0; i < managementStage.getNumberOfGroupVertices(); i++) {
      final ManagementGroupVertex groupVertex=managementStage.getGroupVertex(i);
      final SWTGroupVertex visualGroupVertex=new SWTGroupVertex(parent,groupVertex);
      groupMap.put(groupVertex,visualGroupVertex);
    }
  }
  iterator=stageMap.keySet().iterator();
  while (iterator.hasNext()) {
    final ManagementStage executionStage=iterator.next();
    for (int i=0; i < executionStage.getNumberOfGroupVertices(); i++) {
      final ManagementGroupVertex sourceVertex=executionStage.getGroupVertex(i);
      final SWTGroupVertex sourceGroupVertex=groupMap.get(sourceVertex);
      for (int j=0; j < sourceVertex.getNumberOfForwardEdges(); j++) {
        final ManagementGroupEdge edge=sourceVertex.getForwardEdge(j);
        final ManagementGroupVertex targetVertex=edge.getTarget();
        final SWTGroupVertex targetGroupVertex=groupMap.get(targetVertex);
        sourceGroupVertex.connectTo(targetGroupVertex);
      }
    }
  }
  return groupMap;
}","private Map<ManagementGroupVertex,SWTGroupVertex> addGroupVertices(Map<ManagementStage,SWTStage> stageMap){
  Map<ManagementGroupVertex,SWTGroupVertex> groupMap=new HashMap<ManagementGroupVertex,SWTGroupVertex>();
  Iterator<Map.Entry<ManagementStage,SWTStage>> iterator=stageMap.entrySet().iterator();
  while (iterator.hasNext()) {
    final Map.Entry<ManagementStage,SWTStage> entry=iterator.next();
    final ManagementStage managementStage=entry.getKey();
    final SWTStage parent=entry.getValue();
    for (int i=0; i < managementStage.getNumberOfGroupVertices(); i++) {
      final ManagementGroupVertex groupVertex=managementStage.getGroupVertex(i);
      final SWTGroupVertex visualGroupVertex=new SWTGroupVertex(parent,groupVertex);
      groupMap.put(groupVertex,visualGroupVertex);
    }
  }
  iterator=stageMap.entrySet().iterator();
  while (iterator.hasNext()) {
    final Map.Entry<ManagementStage,SWTStage> entry=iterator.next();
    final ManagementStage executionStage=entry.getKey();
    for (int i=0; i < executionStage.getNumberOfGroupVertices(); i++) {
      final ManagementGroupVertex sourceVertex=executionStage.getGroupVertex(i);
      final SWTGroupVertex sourceGroupVertex=groupMap.get(sourceVertex);
      for (int j=0; j < sourceVertex.getNumberOfForwardEdges(); j++) {
        final ManagementGroupEdge edge=sourceVertex.getForwardEdge(j);
        final ManagementGroupVertex targetVertex=edge.getTarget();
        final SWTGroupVertex targetGroupVertex=groupMap.get(targetVertex);
        sourceGroupVertex.connectTo(targetGroupVertex);
      }
    }
  }
  return groupMap;
}"
88429,"@Override public void layout(){
  if (this.networkNode.isLeafNode()) {
    if (LEAFNODEIMAGE != null) {
      this.imageScaleFactor=(float)(this.rect.height - TEXTBOXHEIGHT) / (float)LEAFNODEIMAGERECT.height;
    }
  }
 else {
    if (NODEIMAGE != null) {
      this.imageScaleFactor=(float)(this.rect.height - TEXTBOXHEIGHT) / (float)NODEIMAGERECT.height;
    }
  }
}","@Override public void layout(){
  if (this.networkNode.isLeafNode()) {
    if (this.leafNodeImage != null) {
      this.imageScaleFactor=(float)(this.rect.height - TEXTBOXHEIGHT) / (float)this.leafNodeImageRect.height;
    }
  }
 else {
    if (this.nodeImage != null) {
      this.imageScaleFactor=(float)(this.rect.height - TEXTBOXHEIGHT) / (float)this.nodeImageRect.height;
    }
  }
}"
88430,"@Override protected void paintInternal(GC gc,Device device){
  if (this.parentNode != null) {
    gc.drawLine(this.rect.x + (rect.width / 2),this.rect.y + (this.rect.height - TEXTBOXHEIGHT) / 2,this.parentNode.getX() + (this.parentNode.getWidth() / 2),this.parentNode.getY() + this.parentNode.getHeight());
  }
  if (this.networkNode.isLeafNode()) {
    if (LEAFNODEIMAGE != null) {
      final int destHeight=(int)((float)LEAFNODEIMAGERECT.height * imageScaleFactor);
      final int destWidth=(int)((float)LEAFNODEIMAGERECT.width * imageScaleFactor);
      final int destX=this.rect.x + (this.rect.width - destWidth) / 2;
      final int destY=this.rect.y + ((this.rect.height - TEXTBOXHEIGHT) - destHeight) / 2;
      gc.drawImage(LEAFNODEIMAGE,LEAFNODEIMAGERECT.x,LEAFNODEIMAGERECT.y,LEAFNODEIMAGERECT.width,LEAFNODEIMAGERECT.height,destX,destY,destWidth,destHeight);
    }
  }
 else {
    if (NODEIMAGE != null) {
      final int destHeight=(int)((float)NODEIMAGERECT.height * imageScaleFactor);
      final int destWidth=(int)((float)NODEIMAGERECT.width * imageScaleFactor);
      final int destX=this.rect.x + (this.rect.width - destWidth) / 2;
      final int destY=this.rect.y + ((this.rect.height - TEXTBOXHEIGHT) - destHeight) / 2;
      gc.drawImage(NODEIMAGE,NODEIMAGERECT.x,NODEIMAGERECT.y,NODEIMAGERECT.width,NODEIMAGERECT.height,destX,destY,destWidth,destHeight);
    }
  }
  String name=this.networkNode.getName();
  Point pt=gc.textExtent(name);
  boolean cropped=false;
  while (pt.x > this.rect.width) {
    cropped=true;
    name=name.substring(0,name.length() - 1);
    pt=gc.textExtent(name + ""String_Node_Str"");
  }
  if (cropped) {
    name+=""String_Node_Str"";
  }
  gc.setBackground(ColorScheme.getNetworkNodeBackgroundColor(device));
  gc.fillRectangle(this.rect.x + (this.rect.width - pt.x) / 2 - TEXTBOXSPACING,this.rect.y + this.rect.height - TEXTBOXHEIGHT,pt.x + (2 * TEXTBOXSPACING),TEXTBOXHEIGHT);
  gc.setForeground(ColorScheme.getNetworkNodeBorderColor(device));
  gc.drawRectangle(this.rect.x + (this.rect.width - pt.x) / 2 - TEXTBOXSPACING,this.rect.y + this.rect.height - TEXTBOXHEIGHT,pt.x + (2 * TEXTBOXSPACING),TEXTBOXHEIGHT);
  gc.setForeground(ColorScheme.getNetworkNodeBorderColor(device));
  final int textX=this.rect.x + ((this.rect.width - pt.x) / 2);
  final int textY=this.rect.y + this.rect.height - TEXTBOXHEIGHT + ((TEXTBOXHEIGHT - pt.y) / 2);
  gc.drawText(name,textX,textY);
}","@Override protected void paintInternal(GC gc,Device device){
  if (this.parentNode != null) {
    gc.drawLine(this.rect.x + (rect.width / 2),this.rect.y + (this.rect.height - TEXTBOXHEIGHT) / 2,this.parentNode.getX() + (this.parentNode.getWidth() / 2),this.parentNode.getY() + this.parentNode.getHeight());
  }
  if (this.networkNode.isLeafNode()) {
    if (this.leafNodeImage != null) {
      final int destHeight=(int)((float)this.leafNodeImageRect.height * imageScaleFactor);
      final int destWidth=(int)((float)this.leafNodeImageRect.width * imageScaleFactor);
      final int destX=this.rect.x + (this.rect.width - destWidth) / 2;
      final int destY=this.rect.y + ((this.rect.height - TEXTBOXHEIGHT) - destHeight) / 2;
      gc.drawImage(this.leafNodeImage,this.leafNodeImageRect.x,this.leafNodeImageRect.y,this.leafNodeImageRect.width,this.leafNodeImageRect.height,destX,destY,destWidth,destHeight);
    }
  }
 else {
    if (this.nodeImage != null) {
      final int destHeight=(int)((float)this.nodeImageRect.height * imageScaleFactor);
      final int destWidth=(int)((float)this.nodeImageRect.width * imageScaleFactor);
      final int destX=this.rect.x + (this.rect.width - destWidth) / 2;
      final int destY=this.rect.y + ((this.rect.height - TEXTBOXHEIGHT) - destHeight) / 2;
      gc.drawImage(this.nodeImage,this.nodeImageRect.x,this.nodeImageRect.y,this.nodeImageRect.width,this.nodeImageRect.height,destX,destY,destWidth,destHeight);
    }
  }
  String name=this.networkNode.getName();
  Point pt=gc.textExtent(name);
  boolean cropped=false;
  while (pt.x > this.rect.width) {
    cropped=true;
    name=name.substring(0,name.length() - 1);
    pt=gc.textExtent(name + ""String_Node_Str"");
  }
  if (cropped) {
    name+=""String_Node_Str"";
  }
  gc.setBackground(ColorScheme.getNetworkNodeBackgroundColor(device));
  gc.fillRectangle(this.rect.x + (this.rect.width - pt.x) / 2 - TEXTBOXSPACING,this.rect.y + this.rect.height - TEXTBOXHEIGHT,pt.x + (2 * TEXTBOXSPACING),TEXTBOXHEIGHT);
  gc.setForeground(ColorScheme.getNetworkNodeBorderColor(device));
  gc.drawRectangle(this.rect.x + (this.rect.width - pt.x) / 2 - TEXTBOXSPACING,this.rect.y + this.rect.height - TEXTBOXHEIGHT,pt.x + (2 * TEXTBOXSPACING),TEXTBOXHEIGHT);
  gc.setForeground(ColorScheme.getNetworkNodeBorderColor(device));
  final int textX=this.rect.x + ((this.rect.width - pt.x) / 2);
  final int textY=this.rect.y + this.rect.height - TEXTBOXHEIGHT + ((TEXTBOXHEIGHT - pt.y) / 2);
  gc.drawText(name,textX,textY);
}"
88431,"public SWTNetworkNode(Display display,AbstractSWTComponent parentComponent,NetworkNode networkNode){
  super(parentComponent);
  this.networkNode=networkNode;
  if (LEAFNODEIMAGE == null) {
    InputStream in=getClass().getResourceAsStream(""String_Node_Str"");
    try {
      LEAFNODEIMAGE=new Image(display,in);
      LEAFNODEIMAGERECT=LEAFNODEIMAGE.getBounds();
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
  if (NODEIMAGE == null) {
    InputStream in=getClass().getResourceAsStream(""String_Node_Str"");
    try {
      NODEIMAGE=new Image(display,in);
      NODEIMAGERECT=NODEIMAGE.getBounds();
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
}","public SWTNetworkNode(Display display,AbstractSWTComponent parentComponent,NetworkNode networkNode){
  super(parentComponent);
  this.networkNode=networkNode;
synchronized (SWTNetworkNode.class) {
    if (LEAFNODEIMAGE == null) {
      InputStream in=getClass().getResourceAsStream(""String_Node_Str"");
      try {
        LEAFNODEIMAGE=new Image(display,in);
        LEAFNODEIMAGERECT=LEAFNODEIMAGE.getBounds();
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
    }
    this.leafNodeImage=LEAFNODEIMAGE;
    this.leafNodeImageRect=LEAFNODEIMAGERECT;
    if (NODEIMAGE == null) {
      InputStream in=getClass().getResourceAsStream(""String_Node_Str"");
      try {
        NODEIMAGE=new Image(display,in);
        NODEIMAGERECT=NODEIMAGE.getBounds();
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
    }
    this.nodeImage=NODEIMAGE;
    this.nodeImageRect=NODEIMAGERECT;
  }
}"
88432,"private SWTNetworkTopology createSWTNetworkTopology(NetworkTopology networkTopology){
  final SWTNetworkTopology swtNetworkTopology=new SWTNetworkTopology(networkTopology);
  final Map<NetworkNode,SWTNetworkNode> nodeMap=new HashMap<NetworkNode,SWTNetworkNode>();
  Iterator<NetworkNode> it=networkTopology.iterator();
  while (it.hasNext()) {
    final NetworkNode networkNode=it.next();
    final SWTNetworkNode swtNetworkNode=new SWTNetworkNode(getDisplay(),swtNetworkTopology,networkNode);
    swtNetworkTopology.addChild(swtNetworkNode);
    nodeMap.put(networkNode,swtNetworkNode);
    if (networkNode.getParentNode() == null) {
      swtNetworkTopology.setRootNode(swtNetworkNode);
    }
  }
  it=nodeMap.keySet().iterator();
  while (it.hasNext()) {
    final NetworkNode childNode=it.next();
    final NetworkNode parentNode=childNode.getParentNode();
    if (parentNode != null) {
      final SWTNetworkNode swtChildNode=nodeMap.get(childNode);
      final SWTNetworkNode swtParentNode=nodeMap.get(parentNode);
      swtChildNode.setParentNode(swtParentNode);
    }
  }
  return swtNetworkTopology;
}","private SWTNetworkTopology createSWTNetworkTopology(NetworkTopology networkTopology){
  final SWTNetworkTopology swtNetworkTopology=new SWTNetworkTopology(networkTopology);
  final Map<NetworkNode,SWTNetworkNode> nodeMap=new HashMap<NetworkNode,SWTNetworkNode>();
  final Iterator<NetworkNode> it=networkTopology.iterator();
  while (it.hasNext()) {
    final NetworkNode networkNode=it.next();
    final SWTNetworkNode swtNetworkNode=new SWTNetworkNode(getDisplay(),swtNetworkTopology,networkNode);
    swtNetworkTopology.addChild(swtNetworkNode);
    nodeMap.put(networkNode,swtNetworkNode);
    if (networkNode.getParentNode() == null) {
      swtNetworkTopology.setRootNode(swtNetworkNode);
    }
  }
  final Iterator<Map.Entry<NetworkNode,SWTNetworkNode>> it2=nodeMap.entrySet().iterator();
  while (it2.hasNext()) {
    final Map.Entry<NetworkNode,SWTNetworkNode> entry=it2.next();
    final NetworkNode childNode=entry.getKey();
    final NetworkNode parentNode=childNode.getParentNode();
    if (parentNode != null) {
      final SWTNetworkNode swtChildNode=entry.getValue();
      final SWTNetworkNode swtParentNode=nodeMap.get(parentNode);
      swtChildNode.setParentNode(swtParentNode);
    }
  }
  return swtNetworkTopology;
}"
88433,"/** 
 * Starts a new discovery service.
 * @param ipcPort the network port that is announced for the job manager's IPC service.
 * @throws DiscoveryException thrown if the discovery service could not be started because of network difficulties
 */
public static void startDiscoveryService(int ipcPort) throws DiscoveryException {
  if (discoveryService == null) {
    discoveryService=new DiscoveryService(ipcPort);
    discoveryService.startService();
  }
}","/** 
 * Starts a new discovery service.
 * @param ipcPort the network port that is announced for the job manager's IPC service.
 * @throws DiscoveryException thrown if the discovery service could not be started because of network difficulties
 */
public static synchronized void startDiscoveryService(int ipcPort) throws DiscoveryException {
  if (discoveryService == null) {
    discoveryService=new DiscoveryService(ipcPort);
    discoveryService.startService();
  }
}"
88434,"/** 
 * Stops the discovery service.
 */
public static void stopDiscoveryService(){
  if (discoveryService != null) {
    discoveryService.stopService();
  }
}","/** 
 * Stops the discovery service.
 */
public static synchronized void stopDiscoveryService(){
  if (discoveryService != null) {
    discoveryService.stopService();
  }
}"
88435,"public void repairStages(){
  final Map<ExecutionGroupVertex,Integer> stageNumbers=new HashMap<ExecutionGroupVertex,Integer>();
  ExecutionGroupVertexIterator it=new ExecutionGroupVertexIterator(this,true,-1);
  while (it.hasNext()) {
    final ExecutionGroupVertex groupVertex=it.next();
    int precedingNumber=0;
    if (stageNumbers.containsKey(groupVertex)) {
      precedingNumber=stageNumbers.get(groupVertex).intValue();
    }
 else {
      stageNumbers.put(groupVertex,new Integer(precedingNumber));
    }
    for (int i=0; i < groupVertex.getNumberOfForwardLinks(); i++) {
      final ExecutionGroupEdge edge=groupVertex.getForwardEdge(i);
      if (!stageNumbers.containsKey(edge.getTargetVertex())) {
        if (edge.getChannelType() != ChannelType.FILE) {
          stageNumbers.put(edge.getTargetVertex(),new Integer(precedingNumber));
        }
 else {
          stageNumbers.put(edge.getTargetVertex(),new Integer(precedingNumber + 1));
        }
      }
 else {
        final int stageNumber=stageNumbers.get(edge.getTargetVertex()).intValue();
        if (edge.getChannelType() != ChannelType.FILE) {
          if (stageNumber != precedingNumber) {
            stageNumbers.put(edge.getTargetVertex(),(int)Math.max(precedingNumber,stageNumber));
          }
        }
 else {
          if (stageNumber != (precedingNumber + 1)) {
            stageNumbers.put(edge.getTargetVertex(),(int)Math.max(precedingNumber + 1,stageNumber));
          }
        }
      }
    }
  }
  it=new ExecutionGroupVertexIterator(this,false,-1);
  while (it.hasNext()) {
    final ExecutionGroupVertex groupVertex=it.next();
    final int succeedingNumber=stageNumbers.get(groupVertex);
    for (int i=0; i < groupVertex.getNumberOfBackwardLinks(); i++) {
      final ExecutionGroupEdge edge=groupVertex.getBackwardEdge(i);
      final int stageNumber=stageNumbers.get(edge.getSourceVertex());
      if (edge.getChannelType() == ChannelType.FILE) {
        if (stageNumber < (succeedingNumber - 1)) {
          stageNumbers.put(edge.getSourceVertex(),new Integer(succeedingNumber - 1));
        }
      }
 else {
        if (stageNumber != succeedingNumber) {
          LOG.error(edge.getSourceVertex() + ""String_Node_Str"" + edge.getTargetVertex()+ ""String_Node_Str"");
        }
      }
    }
  }
  this.stages.clear();
  final Iterator<ExecutionGroupVertex> it2=stageNumbers.keySet().iterator();
  while (it2.hasNext()) {
    final ExecutionGroupVertex groupVertex=it2.next();
    final int stageNumber=stageNumbers.get(groupVertex).intValue();
    while (this.stages.size() <= stageNumber) {
      this.stages.add(null);
    }
    ExecutionStage executionStage=this.stages.get(stageNumber);
    if (executionStage == null) {
      executionStage=new ExecutionStage(stageNumber);
      this.stages.set(stageNumber,executionStage);
    }
    executionStage.addStageMember(groupVertex);
    groupVertex.setExecutionStage(executionStage);
  }
}","public void repairStages(){
  final Map<ExecutionGroupVertex,Integer> stageNumbers=new HashMap<ExecutionGroupVertex,Integer>();
  ExecutionGroupVertexIterator it=new ExecutionGroupVertexIterator(this,true,-1);
  while (it.hasNext()) {
    final ExecutionGroupVertex groupVertex=it.next();
    int precedingNumber=0;
    if (stageNumbers.containsKey(groupVertex)) {
      precedingNumber=stageNumbers.get(groupVertex).intValue();
    }
 else {
      stageNumbers.put(groupVertex,Integer.valueOf(precedingNumber));
    }
    for (int i=0; i < groupVertex.getNumberOfForwardLinks(); i++) {
      final ExecutionGroupEdge edge=groupVertex.getForwardEdge(i);
      if (!stageNumbers.containsKey(edge.getTargetVertex())) {
        if (edge.getChannelType() != ChannelType.FILE) {
          stageNumbers.put(edge.getTargetVertex(),Integer.valueOf(precedingNumber));
        }
 else {
          stageNumbers.put(edge.getTargetVertex(),Integer.valueOf(precedingNumber + 1));
        }
      }
 else {
        final int stageNumber=stageNumbers.get(edge.getTargetVertex()).intValue();
        if (edge.getChannelType() != ChannelType.FILE) {
          if (stageNumber != precedingNumber) {
            stageNumbers.put(edge.getTargetVertex(),(int)Math.max(precedingNumber,stageNumber));
          }
        }
 else {
          if (stageNumber != (precedingNumber + 1)) {
            stageNumbers.put(edge.getTargetVertex(),(int)Math.max(precedingNumber + 1,stageNumber));
          }
        }
      }
    }
  }
  it=new ExecutionGroupVertexIterator(this,false,-1);
  while (it.hasNext()) {
    final ExecutionGroupVertex groupVertex=it.next();
    final int succeedingNumber=stageNumbers.get(groupVertex);
    for (int i=0; i < groupVertex.getNumberOfBackwardLinks(); i++) {
      final ExecutionGroupEdge edge=groupVertex.getBackwardEdge(i);
      final int stageNumber=stageNumbers.get(edge.getSourceVertex());
      if (edge.getChannelType() == ChannelType.FILE) {
        if (stageNumber < (succeedingNumber - 1)) {
          stageNumbers.put(edge.getSourceVertex(),Integer.valueOf(succeedingNumber - 1));
        }
      }
 else {
        if (stageNumber != succeedingNumber) {
          LOG.error(edge.getSourceVertex() + ""String_Node_Str"" + edge.getTargetVertex()+ ""String_Node_Str"");
        }
      }
    }
  }
  this.stages.clear();
  final Iterator<Map.Entry<ExecutionGroupVertex,Integer>> it2=stageNumbers.entrySet().iterator();
  while (it2.hasNext()) {
    final Map.Entry<ExecutionGroupVertex,Integer> entry=it2.next();
    final ExecutionGroupVertex groupVertex=entry.getKey();
    final int stageNumber=entry.getValue().intValue();
    while (this.stages.size() <= stageNumber) {
      this.stages.add(null);
    }
    ExecutionStage executionStage=this.stages.get(stageNumber);
    if (executionStage == null) {
      executionStage=new ExecutionStage(stageNumber);
      this.stages.set(stageNumber,executionStage);
    }
    executionStage.addStageMember(groupVertex);
    groupVertex.setExecutionStage(executionStage);
  }
}"
88436,"/** 
 * Applies the user defined settings to the execution graph.
 * @param temporaryGroupVertexMap mapping between job vertices and the corresponding group vertices.
 * @throws GraphConversionException thrown if an error occurs while applying the user settings.
 */
private void applyUserDefinedSettings(HashMap<AbstractJobVertex,ExecutionGroupVertex> temporaryGroupVertexMap) throws GraphConversionException {
  Iterator<AbstractJobVertex> it=temporaryGroupVertexMap.keySet().iterator();
  while (it.hasNext()) {
    final AbstractJobVertex jobVertex=it.next();
    if (jobVertex.getVertexToShareInstancesWith() != null) {
      final AbstractJobVertex vertexToShareInstancesWith=jobVertex.getVertexToShareInstancesWith();
      final ExecutionGroupVertex groupVertex=temporaryGroupVertexMap.get(jobVertex);
      final ExecutionGroupVertex groupVertexToShareInstancesWith=temporaryGroupVertexMap.get(vertexToShareInstancesWith);
      groupVertex.shareInstancesWith(groupVertexToShareInstancesWith);
    }
  }
  Iterator<ExecutionGroupVertex> it2=new ExecutionGroupVertexIterator(this,true,-1);
  while (it2.hasNext()) {
    final ExecutionGroupVertex groupVertex=it2.next();
    if (groupVertex.isNumberOfMembersUserDefined()) {
      groupVertex.changeNumberOfGroupMembers(groupVertex.getUserDefinedNumberOfMembers());
    }
  }
  repairInstanceAssignment();
  it2=new ExecutionGroupVertexIterator(this,true,-1);
  while (it2.hasNext()) {
    final ExecutionGroupVertex groupVertex=it2.next();
    for (int i=0; i < groupVertex.getNumberOfForwardLinks(); i++) {
      final ExecutionGroupEdge edge=groupVertex.getForwardEdge(i);
      if (edge.isChannelTypeUserDefined()) {
        edge.changeChannelType(edge.getChannelType());
      }
      if (edge.isCompressionLevelUserDefined()) {
        edge.changeCompressionLevel(edge.getCompressionLevel());
      }
    }
  }
  it2=new ExecutionGroupVertexIterator(this,true,-1);
  while (it2.hasNext()) {
    final ExecutionGroupVertex groupVertex=it2.next();
    if (groupVertex.getVertexToShareInstancesWith() == null) {
      groupVertex.reassignInstances();
      this.repairInstanceAssignment();
    }
  }
}","/** 
 * Applies the user defined settings to the execution graph.
 * @param temporaryGroupVertexMap mapping between job vertices and the corresponding group vertices.
 * @throws GraphConversionException thrown if an error occurs while applying the user settings.
 */
private void applyUserDefinedSettings(HashMap<AbstractJobVertex,ExecutionGroupVertex> temporaryGroupVertexMap) throws GraphConversionException {
  final Iterator<Map.Entry<AbstractJobVertex,ExecutionGroupVertex>> it=temporaryGroupVertexMap.entrySet().iterator();
  while (it.hasNext()) {
    final Map.Entry<AbstractJobVertex,ExecutionGroupVertex> entry=it.next();
    final AbstractJobVertex jobVertex=entry.getKey();
    if (jobVertex.getVertexToShareInstancesWith() != null) {
      final AbstractJobVertex vertexToShareInstancesWith=jobVertex.getVertexToShareInstancesWith();
      final ExecutionGroupVertex groupVertex=entry.getValue();
      final ExecutionGroupVertex groupVertexToShareInstancesWith=temporaryGroupVertexMap.get(vertexToShareInstancesWith);
      groupVertex.shareInstancesWith(groupVertexToShareInstancesWith);
    }
  }
  Iterator<ExecutionGroupVertex> it2=new ExecutionGroupVertexIterator(this,true,-1);
  while (it2.hasNext()) {
    final ExecutionGroupVertex groupVertex=it2.next();
    if (groupVertex.isNumberOfMembersUserDefined()) {
      groupVertex.changeNumberOfGroupMembers(groupVertex.getUserDefinedNumberOfMembers());
    }
  }
  repairInstanceAssignment();
  it2=new ExecutionGroupVertexIterator(this,true,-1);
  while (it2.hasNext()) {
    final ExecutionGroupVertex groupVertex=it2.next();
    for (int i=0; i < groupVertex.getNumberOfForwardLinks(); i++) {
      final ExecutionGroupEdge edge=groupVertex.getForwardEdge(i);
      if (edge.isChannelTypeUserDefined()) {
        edge.changeChannelType(edge.getChannelType());
      }
      if (edge.isCompressionLevelUserDefined()) {
        edge.changeCompressionLevel(edge.getCompressionLevel());
      }
    }
  }
  it2=new ExecutionGroupVertexIterator(this,true,-1);
  while (it2.hasNext()) {
    final ExecutionGroupVertex groupVertex=it2.next();
    if (groupVertex.getVertexToShareInstancesWith() == null) {
      groupVertex.reassignInstances();
      this.repairInstanceAssignment();
    }
  }
}"
88437,"/** 
 * Changes the channel type for this edge.
 * @param newChannelType the channel type for this edge
 * @throws GraphConversionException thrown if the new channel type violates a user setting
 */
public synchronized void changeChannelType(ChannelType newChannelType) throws GraphConversionException {
  if (!this.channelType.equals(newChannelType) && this.userDefinedChannelType) {
    throw new GraphConversionException(""String_Node_Str"");
  }
  final List<ExecutionGroupEdge> edges=this.getSourceVertex().getForwardEdges(this.getTargetVertex());
  final Iterator<ExecutionGroupEdge> it=edges.iterator();
  while (it.hasNext()) {
    final ExecutionGroupEdge edge=it.next();
    this.executionGraph.unwire(edge.sourceVertex,edge.indexOfOutputGate,edge.targetVertex,edge.indexOfInputGate);
    this.executionGraph.wire(edge.sourceVertex,edge.indexOfOutputGate,edge.targetVertex,edge.indexOfInputGate,newChannelType,edge.compressionLevel);
    edge.channelType=newChannelType;
  }
  this.executionGraph.repairStages();
  this.executionGraph.repairInstanceAssignment();
}","/** 
 * Changes the channel type for this edge.
 * @param newChannelType the channel type for this edge
 * @throws GraphConversionException thrown if the new channel type violates a user setting
 */
public synchronized void changeChannelType(ChannelType newChannelType) throws GraphConversionException {
  if (!this.channelType.equals(newChannelType) && this.userDefinedChannelType) {
    throw new GraphConversionException(""String_Node_Str"");
  }
  final List<ExecutionGroupEdge> edges=this.getSourceVertex().getForwardEdges(this.getTargetVertex());
  final Iterator<ExecutionGroupEdge> it=edges.iterator();
  while (it.hasNext()) {
    final ExecutionGroupEdge edge=it.next();
    CompressionLevel cl=null;
synchronized (edge) {
      edge.channelType=newChannelType;
      cl=edge.compressionLevel;
    }
    this.executionGraph.unwire(edge.sourceVertex,edge.indexOfOutputGate,edge.targetVertex,edge.indexOfInputGate);
    this.executionGraph.wire(edge.sourceVertex,edge.indexOfOutputGate,edge.targetVertex,edge.indexOfInputGate,newChannelType,cl);
  }
  this.executionGraph.repairStages();
  this.executionGraph.repairInstanceAssignment();
}"
88438,"/** 
 * Returns the number of the stage this group vertex belongs to.
 * @return the number of the stage this group vertex belongs to
 */
public int getStageNumber(){
  ExecutionStage executionStage=null;
synchronized (this.executionStage) {
    executionStage=this.executionStage;
  }
  return executionStage.getStageNumber();
}","/** 
 * Returns the number of the stage this group vertex belongs to.
 * @return the number of the stage this group vertex belongs to
 */
public int getStageNumber(){
  ExecutionStage executionStage=null;
synchronized (this) {
    executionStage=this.executionStage;
  }
  return executionStage.getStageNumber();
}"
88439,"/** 
 * Deploys and starts the task represented by this vertex on the assigned instance.
 * @return the result of the task submission attempt
 */
public TaskSubmissionResult startTask(){
  AllocatedResource allocatedRes=null;
synchronized (this) {
    if (this.allocatedResource == null) {
      final TaskSubmissionResult result=new TaskSubmissionResult(getID(),AbstractTaskResult.ReturnCode.ERROR);
      result.setDescription(""String_Node_Str"" + this.toString() + ""String_Node_Str"");
      return result;
    }
    try {
      prepareChannels();
    }
 catch (    ChannelSetupException e) {
      final TaskSubmissionResult result=new TaskSubmissionResult(getID(),AbstractTaskResult.ReturnCode.ERROR);
      result.setDescription(StringUtils.stringifyException(e));
      return result;
    }
    allocatedRes=this.allocatedResource;
  }
  try {
    return allocatedRes.getInstance().submitTask(this.vertexID,this.executionGraph.getJobConfiguration(),this.environment);
  }
 catch (  IOException e) {
    final TaskSubmissionResult result=new TaskSubmissionResult(getID(),AbstractTaskResult.ReturnCode.ERROR);
    result.setDescription(StringUtils.stringifyException(e));
    return result;
  }
}","/** 
 * Deploys and starts the task represented by this vertex on the assigned instance.
 * @return the result of the task submission attempt
 */
public TaskSubmissionResult startTask(){
  AllocatedResource allocatedRes=null;
  Environment env=null;
synchronized (this) {
    if (this.allocatedResource == null) {
      final TaskSubmissionResult result=new TaskSubmissionResult(getID(),AbstractTaskResult.ReturnCode.ERROR);
      result.setDescription(""String_Node_Str"" + this.toString() + ""String_Node_Str"");
      return result;
    }
    try {
      prepareChannels();
    }
 catch (    ChannelSetupException e) {
      final TaskSubmissionResult result=new TaskSubmissionResult(getID(),AbstractTaskResult.ReturnCode.ERROR);
      result.setDescription(StringUtils.stringifyException(e));
      return result;
    }
    allocatedRes=this.allocatedResource;
    env=this.environment;
  }
  try {
    return allocatedRes.getInstance().submitTask(this.vertexID,this.executionGraph.getJobConfiguration(),env);
  }
 catch (  IOException e) {
    final TaskSubmissionResult result=new TaskSubmissionResult(getID(),AbstractTaskResult.ReturnCode.ERROR);
    result.setDescription(StringUtils.stringifyException(e));
    return result;
  }
}"
88440,"/** 
 * Returns a duplicate of this execution vertex.
 * @param preserveVertexID <code>true</code> to copy the vertex's ID to the duplicated vertex, <code>false</code> to create a new ID
 * @return a duplicate of this execution vertex
 */
public synchronized ExecutionVertex duplicateVertex(boolean preserveVertexID){
  ExecutionVertexID newVertexID;
  if (preserveVertexID) {
    newVertexID=this.vertexID;
  }
 else {
    newVertexID=new ExecutionVertexID();
  }
  final ExecutionVertex duplicatedVertex=new ExecutionVertex(newVertexID,this.invokableClass,this.executionGraph,this.groupVertex);
  duplicatedVertex.environment=this.environment.duplicateEnvironment();
  duplicatedVertex.allocatedResource=this.allocatedResource;
  return duplicatedVertex;
}","/** 
 * Returns a duplicate of this execution vertex.
 * @param preserveVertexID <code>true</code> to copy the vertex's ID to the duplicated vertex, <code>false</code> to create a new ID
 * @return a duplicate of this execution vertex
 */
public synchronized ExecutionVertex duplicateVertex(boolean preserveVertexID){
  ExecutionVertexID newVertexID;
  if (preserveVertexID) {
    newVertexID=this.vertexID;
  }
 else {
    newVertexID=new ExecutionVertexID();
  }
  final ExecutionVertex duplicatedVertex=new ExecutionVertex(newVertexID,this.invokableClass,this.executionGraph,this.groupVertex);
synchronized (duplicatedVertex) {
    duplicatedVertex.environment=this.environment.duplicateEnvironment();
    duplicatedVertex.allocatedResource=this.allocatedResource;
  }
  return duplicatedVertex;
}"
88441,"private static Map<ExecutionGroupVertex,ManagementGroupVertex> addGroupVertices(Map<ExecutionStage,ManagementStage> stageMap){
  final Map<ExecutionGroupVertex,ManagementGroupVertex> groupMap=new HashMap<ExecutionGroupVertex,ManagementGroupVertex>();
  Iterator<ExecutionStage> iterator=stageMap.keySet().iterator();
  while (iterator.hasNext()) {
    final ExecutionStage executionStage=iterator.next();
    ManagementStage parent=stageMap.get(executionStage);
    for (int i=0; i < executionStage.getNumberOfStageMembers(); i++) {
      final ExecutionGroupVertex groupVertex=executionStage.getStageMember(i);
      final ManagementGroupVertex managementGroupVertex=new ManagementGroupVertex(parent,groupVertex.getName());
      groupMap.put(groupVertex,managementGroupVertex);
    }
  }
  iterator=stageMap.keySet().iterator();
  while (iterator.hasNext()) {
    final ExecutionStage executionStage=iterator.next();
    for (int i=0; i < executionStage.getNumberOfStageMembers(); i++) {
      final ExecutionGroupVertex sourceVertex=executionStage.getStageMember(i);
      final ManagementGroupVertex sourceGroupVertex=groupMap.get(sourceVertex);
      for (int j=0; j < sourceVertex.getNumberOfForwardLinks(); j++) {
        final ExecutionGroupEdge edge=sourceVertex.getForwardEdge(j);
        final ExecutionGroupVertex targetVertex=edge.getTargetVertex();
        final ManagementGroupVertex targetGroupVertex=groupMap.get(targetVertex);
        new ManagementGroupEdge(sourceGroupVertex,j,targetGroupVertex,edge.getIndexOfInputGate(),edge.getChannelType(),edge.getCompressionLevel());
      }
    }
  }
  return groupMap;
}","private static Map<ExecutionGroupVertex,ManagementGroupVertex> addGroupVertices(Map<ExecutionStage,ManagementStage> stageMap){
  final Map<ExecutionGroupVertex,ManagementGroupVertex> groupMap=new HashMap<ExecutionGroupVertex,ManagementGroupVertex>();
  Iterator<Map.Entry<ExecutionStage,ManagementStage>> iterator=stageMap.entrySet().iterator();
  while (iterator.hasNext()) {
    final Map.Entry<ExecutionStage,ManagementStage> entry=iterator.next();
    final ExecutionStage executionStage=entry.getKey();
    final ManagementStage parent=entry.getValue();
    for (int i=0; i < executionStage.getNumberOfStageMembers(); i++) {
      final ExecutionGroupVertex groupVertex=executionStage.getStageMember(i);
      final ManagementGroupVertex managementGroupVertex=new ManagementGroupVertex(parent,groupVertex.getName());
      groupMap.put(groupVertex,managementGroupVertex);
    }
  }
  iterator=stageMap.entrySet().iterator();
  while (iterator.hasNext()) {
    final Map.Entry<ExecutionStage,ManagementStage> entry=iterator.next();
    final ExecutionStage executionStage=entry.getKey();
    for (int i=0; i < executionStage.getNumberOfStageMembers(); i++) {
      final ExecutionGroupVertex sourceVertex=executionStage.getStageMember(i);
      final ManagementGroupVertex sourceGroupVertex=groupMap.get(sourceVertex);
      for (int j=0; j < sourceVertex.getNumberOfForwardLinks(); j++) {
        final ExecutionGroupEdge edge=sourceVertex.getForwardEdge(j);
        final ExecutionGroupVertex targetVertex=edge.getTargetVertex();
        final ManagementGroupVertex targetGroupVertex=groupMap.get(targetVertex);
        new ManagementGroupEdge(sourceGroupVertex,j,targetGroupVertex,edge.getIndexOfInputGate(),edge.getChannelType(),edge.getCompressionLevel());
      }
    }
  }
  return groupMap;
}"
88442,"/** 
 * Returns the size of the physical memory in bytes on a Mac OS-based operating system
 * @return the size of the physical memory in bytes or <code>-1</code> if the size could not be determined
 */
private static long getSizeOfPhysicalMemoryForMac(){
  try {
    Process proc=Runtime.getRuntime().exec(""String_Node_Str"");
    BufferedReader bi=new BufferedReader(new InputStreamReader(proc.getInputStream()));
    String line;
    while ((line=bi.readLine()) != null) {
      if (line.startsWith(""String_Node_Str"")) {
        long memsize=Long.parseLong(line.split(""String_Node_Str"")[1].trim());
        bi.close();
        proc.destroy();
        return memsize;
      }
    }
  }
 catch (  Exception e) {
    LOG.error(e);
    return -1;
  }
  return -1;
}","/** 
 * Returns the size of the physical memory in bytes on a Mac OS-based operating system
 * @return the size of the physical memory in bytes or <code>-1</code> if the size could not be determined
 */
private static long getSizeOfPhysicalMemoryForMac(){
  BufferedReader bi=null;
  try {
    Process proc=Runtime.getRuntime().exec(""String_Node_Str"");
    bi=new BufferedReader(new InputStreamReader(proc.getInputStream()));
    String line;
    while ((line=bi.readLine()) != null) {
      if (line.startsWith(""String_Node_Str"")) {
        long memsize=Long.parseLong(line.split(""String_Node_Str"")[1].trim());
        bi.close();
        proc.destroy();
        return memsize;
      }
    }
  }
 catch (  Exception e) {
    LOG.error(e);
    return -1;
  }
 finally {
    if (bi != null) {
      try {
        bi.close();
      }
 catch (      IOException ioe) {
      }
    }
  }
  return -1;
}"
88443,"/** 
 * {@inheritDoc}
 */
@Override public String toString(){
  String iaString;
  if (this.hostname != null) {
    iaString=this.hostname;
  }
 else {
    iaString=inetAddress.toString();
    iaString=iaString.replace(""String_Node_Str"",""String_Node_Str"");
  }
  return new String(iaString);
}","/** 
 * {@inheritDoc}
 */
@Override public String toString(){
  String iaString;
  if (this.hostname != null) {
    iaString=this.hostname;
  }
 else {
    iaString=inetAddress.toString();
    iaString=iaString.replace(""String_Node_Str"",""String_Node_Str"");
  }
  return iaString;
}"
88444,"/** 
 * {@inheritDoc}
 */
@Override public void resourceAllocated(JobID jobID,AllocatedResource allocatedResource){
  if (allocatedResource == null) {
    LOG.error(""String_Node_Str"");
    return;
  }
  if (allocatedResource.getInstance() instanceof DummyInstance) {
    LOG.debug(""String_Node_Str"");
    return;
  }
  try {
    allocatedResource.getInstance().checkLibraryAvailability(jobID);
  }
 catch (  IOException ioe) {
    LOG.error(""String_Node_Str"" + StringUtils.stringifyException(ioe));
  }
synchronized (this.jobQueue) {
    final ExecutionGraph eg=getExecutionGraphByID(jobID);
    if (eg == null) {
      try {
        this.instanceManager.releaseAllocatedResource(jobID,null,allocatedResource);
      }
 catch (      InstanceException e) {
        LOG.error(e);
      }
    }
    AllocatedResource resourceToBeReplaced=null;
    ExecutionGraphIterator it=new ExecutionGraphIterator(eg,eg.getIndexOfCurrentExecutionStage(),true,true);
    while (it.hasNext()) {
      final ExecutionVertex vertex=it.next();
      if (vertex.getExecutionState() == ExecutionState.ASSIGNING && vertex.getAllocatedResource() != null) {
        if (vertex.getAllocatedResource().getInstance().getType().equals(allocatedResource.getInstance().getType())) {
          resourceToBeReplaced=vertex.getAllocatedResource();
          break;
        }
      }
    }
    if (resourceToBeReplaced == null) {
      LOG.error(""String_Node_Str"" + allocatedResource.getInstance() + ""String_Node_Str""+ eg.getJobID());
      try {
        this.instanceManager.releaseAllocatedResource(jobID,eg.getJobConfiguration(),allocatedResource);
      }
 catch (      InstanceException e) {
        LOG.error(e);
      }
      return;
    }
    it=new ExecutionGraphIterator(eg,true);
    while (it.hasNext()) {
      final ExecutionVertex vertex=it.next();
      if (vertex.getAllocatedResource().equals(resourceToBeReplaced)) {
        vertex.setAllocatedResource(allocatedResource);
        vertex.setExecutionState(ExecutionState.ASSIGNED);
      }
    }
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void resourceAllocated(JobID jobID,AllocatedResource allocatedResource){
  if (allocatedResource == null) {
    LOG.error(""String_Node_Str"");
    return;
  }
  if (allocatedResource.getInstance() instanceof DummyInstance) {
    LOG.debug(""String_Node_Str"");
    return;
  }
  try {
    allocatedResource.getInstance().checkLibraryAvailability(jobID);
  }
 catch (  IOException ioe) {
    LOG.error(""String_Node_Str"" + StringUtils.stringifyException(ioe));
  }
synchronized (this.jobQueue) {
    final ExecutionGraph eg=getExecutionGraphByID(jobID);
    if (eg == null) {
      try {
        this.instanceManager.releaseAllocatedResource(jobID,null,allocatedResource);
      }
 catch (      InstanceException e) {
        LOG.error(e);
      }
      return;
    }
    AllocatedResource resourceToBeReplaced=null;
    ExecutionGraphIterator it=new ExecutionGraphIterator(eg,eg.getIndexOfCurrentExecutionStage(),true,true);
    while (it.hasNext()) {
      final ExecutionVertex vertex=it.next();
      if (vertex.getExecutionState() == ExecutionState.ASSIGNING && vertex.getAllocatedResource() != null) {
        if (vertex.getAllocatedResource().getInstance().getType().equals(allocatedResource.getInstance().getType())) {
          resourceToBeReplaced=vertex.getAllocatedResource();
          break;
        }
      }
    }
    if (resourceToBeReplaced == null) {
      LOG.error(""String_Node_Str"" + allocatedResource.getInstance() + ""String_Node_Str""+ eg.getJobID());
      try {
        this.instanceManager.releaseAllocatedResource(jobID,eg.getJobConfiguration(),allocatedResource);
      }
 catch (      InstanceException e) {
        LOG.error(e);
      }
      return;
    }
    it=new ExecutionGraphIterator(eg,true);
    while (it.hasNext()) {
      final ExecutionVertex vertex=it.next();
      if (vertex.getAllocatedResource().equals(resourceToBeReplaced)) {
        vertex.setAllocatedResource(allocatedResource);
        vertex.setExecutionState(ExecutionState.ASSIGNED);
      }
    }
  }
}"
88445,"/** 
 * Collects the instances required to run the job from the given   {@link ExecutionGraph} and requests them at theloaded instance manager.
 * @param executionGraph the execution graph to collect the required instances from
 * @throws InstanceException thrown if the given execution graph is already processing its final stage
 */
private void requestInstances(ExecutionGraph executionGraph) throws InstanceException {
  final Map<InstanceType,Integer> requiredInstanceTypes=new HashMap<InstanceType,Integer>();
  executionGraph.collectInstanceTypesRequiredForCurrentStage(requiredInstanceTypes,ExecutionState.SCHEDULED);
  if (requiredInstanceTypes.isEmpty()) {
    return;
  }
  final ExecutionGraphIterator it2=new ExecutionGraphIterator(executionGraph,executionGraph.getIndexOfCurrentExecutionStage(),true,true);
  while (it2.hasNext()) {
    final ExecutionVertex vertex=it2.next();
    if (vertex.getExecutionState() == ExecutionState.SCHEDULED) {
      vertex.setExecutionState(ExecutionState.ASSIGNING);
    }
  }
  final Iterator<InstanceType> it=requiredInstanceTypes.keySet().iterator();
  while (it.hasNext()) {
    final InstanceType type=it.next();
    for (int i=0; i < requiredInstanceTypes.get(type).intValue(); i++) {
      LOG.info(""String_Node_Str"" + type.getIdentifier());
      this.instanceManager.requestInstance(executionGraph.getJobID(),executionGraph.getJobConfiguration(),type);
    }
  }
}","/** 
 * Collects the instances required to run the job from the given   {@link ExecutionGraph} and requests them at theloaded instance manager.
 * @param executionGraph the execution graph to collect the required instances from
 * @throws InstanceException thrown if the given execution graph is already processing its final stage
 */
private void requestInstances(ExecutionGraph executionGraph) throws InstanceException {
  final Map<InstanceType,Integer> requiredInstanceTypes=new HashMap<InstanceType,Integer>();
  executionGraph.collectInstanceTypesRequiredForCurrentStage(requiredInstanceTypes,ExecutionState.SCHEDULED);
  if (requiredInstanceTypes.isEmpty()) {
    return;
  }
  final ExecutionGraphIterator it2=new ExecutionGraphIterator(executionGraph,executionGraph.getIndexOfCurrentExecutionStage(),true,true);
  while (it2.hasNext()) {
    final ExecutionVertex vertex=it2.next();
    if (vertex.getExecutionState() == ExecutionState.SCHEDULED) {
      vertex.setExecutionState(ExecutionState.ASSIGNING);
    }
  }
  final Iterator<Map.Entry<InstanceType,Integer>> it=requiredInstanceTypes.entrySet().iterator();
  while (it.hasNext()) {
    final Map.Entry<InstanceType,Integer> entry=it.next();
    final InstanceType type=entry.getKey();
    for (int i=0; i < entry.getValue().intValue(); i++) {
      LOG.info(""String_Node_Str"" + type.getIdentifier());
      this.instanceManager.requestInstance(executionGraph.getJobID(),executionGraph.getJobConfiguration(),type);
    }
  }
}"
88446,"/** 
 * Shuts the task manager down.
 */
public synchronized void shutdown(){
  if (this.isShutDown) {
    return;
  }
  LOG.info(""String_Node_Str"");
  RPC.stopProxy(this.jobManager);
  this.taskManagerServer.stop();
  if (this.profiler != null) {
    this.profiler.shutdown();
  }
  this.byteBufferedChannelManager.shutdown();
  if (this.ioManager != null) {
    this.ioManager.shutdown();
    this.ioManager=null;
  }
  if (this.memoryManager != null) {
    this.memoryManager.shutdown();
    this.memoryManager=null;
  }
  this.isShutDown=true;
}","/** 
 * Shuts the task manager down.
 */
public synchronized void shutdown(){
  if (this.isShutDown) {
    return;
  }
  LOG.info(""String_Node_Str"");
  RPC.stopProxy(this.jobManager);
  this.taskManagerServer.stop();
  if (this.profiler != null) {
    this.profiler.shutdown();
  }
  this.byteBufferedChannelManager.shutdown();
  if (this.ioManager != null) {
    this.ioManager.shutdown();
  }
  if (this.memoryManager != null) {
    this.memoryManager.shutdown();
  }
  this.isShutDown=true;
}"
88447,"public ReadBufferDumpThread(Queue<TransferEnvelope> queueOfTransferEnvelopes,Deque<ByteBuffer> emptyReadBuffers){
  this.queueOfTransferEnvelopes=queueOfTransferEnvelopes;
  this.emptyReadBuffers=emptyReadBuffers;
}","public ReadBufferDumpThread(Queue<TransferEnvelope> queueOfTransferEnvelopes,Deque<ByteBuffer> emptyReadBuffers){
  this.queueOfTransferEnvelopes=queueOfTransferEnvelopes;
}"
88448,"@Override public void run(){
synchronized (this.queueOfTransferEnvelopes) {
    if (this.queueOfTransferEnvelopes.isEmpty()) {
      return;
    }
    final TransferEnvelope queueHead=this.queueOfTransferEnvelopes.peek();
    final Iterator<TransferEnvelope> it=this.queueOfTransferEnvelopes.iterator();
    while (it.hasNext()) {
      final TransferEnvelope transferEnvelope=it.next();
    }
  }
}","@Override public void run(){
synchronized (this.queueOfTransferEnvelopes) {
    if (this.queueOfTransferEnvelopes.isEmpty()) {
      return;
    }
    final Iterator<TransferEnvelope> it=this.queueOfTransferEnvelopes.iterator();
    while (it.hasNext()) {
      it.next();
    }
  }
}"
88449,"public synchronized void discard(){
  final Iterator<TransferEnvelope> it=this.queuedEnvelopes.iterator();
  while (it.hasNext()) {
    final TransferEnvelope transferEnvelope=it.next();
    transferEnvelope.getProcessingLog().setWrittenToCheckpoint();
  }
  this.queuedEnvelopes.clear();
  final File file=new File(getFilename());
  if (file.exists()) {
    file.delete();
  }
}","public synchronized void discard(){
  final Iterator<TransferEnvelope> it=this.queuedEnvelopes.iterator();
  while (it.hasNext()) {
    final TransferEnvelope transferEnvelope=it.next();
    transferEnvelope.getProcessingLog().setWrittenToCheckpoint();
  }
  this.queuedEnvelopes.clear();
  final File file=new File(getFilename());
  if (file.exists()) {
    try {
      file.delete();
    }
 catch (    SecurityException e) {
      LOG.error(e);
    }
  }
}"
88450,"/** 
 * {@inheritDoc}
 */
@SuppressWarnings(""String_Node_Str"") @Override public void read(DataInput in) throws IOException {
  final int numberOfMapEntries=in.readInt();
  for (int i=0; i < numberOfMapEntries; i++) {
    final String keyType=StringRecord.readString(in);
    Class<K> keyClass=null;
    try {
      keyClass=(Class<K>)Class.forName(keyType);
    }
 catch (    ClassNotFoundException e) {
      throw new IOException(StringUtils.stringifyException(e));
    }
    K key=null;
    try {
      key=keyClass.newInstance();
    }
 catch (    Exception e) {
      throw new IOException(StringUtils.stringifyException(e));
    }
    key.read(in);
    final String valueType=StringRecord.readString(in);
    Class<V> valueClass=null;
    try {
      valueClass=(Class<V>)Class.forName(valueType);
    }
 catch (    ClassNotFoundException e) {
      throw new IOException(StringUtils.stringifyException(e));
    }
    V value=null;
    try {
      value=valueClass.newInstance();
    }
 catch (    Exception e) {
      throw new IOException(StringUtils.stringifyException(e));
    }
    put(key,value);
  }
}","/** 
 * {@inheritDoc}
 */
@SuppressWarnings(""String_Node_Str"") @Override public void read(DataInput in) throws IOException {
  final int numberOfMapEntries=in.readInt();
  for (int i=0; i < numberOfMapEntries; i++) {
    final String keyType=StringRecord.readString(in);
    Class<K> keyClass=null;
    try {
      keyClass=(Class<K>)Class.forName(keyType);
    }
 catch (    ClassNotFoundException e) {
      throw new IOException(StringUtils.stringifyException(e));
    }
    K key=null;
    try {
      key=keyClass.newInstance();
    }
 catch (    Exception e) {
      throw new IOException(StringUtils.stringifyException(e));
    }
    key.read(in);
    final String valueType=StringRecord.readString(in);
    Class<V> valueClass=null;
    try {
      valueClass=(Class<V>)Class.forName(valueType);
    }
 catch (    ClassNotFoundException e) {
      throw new IOException(StringUtils.stringifyException(e));
    }
    V value=null;
    try {
      value=valueClass.newInstance();
    }
 catch (    Exception e) {
      throw new IOException(StringUtils.stringifyException(e));
    }
    value.read(in);
    put(key,value);
  }
}"
88451,"/** 
 * Called by the channel wrapper to retrieve a new processing log for a transfer envelope. The processing log determines whether the envelope is later written to the checkpoint, sent via the network, or both.
 * @return the newly created processing log.
 */
public TransferEnvelopeProcessingLog getProcessingLog(){
  return new TransferEnvelopeProcessingLog((this.channelType == ChannelType.NETWORK),(this.ephemeralCheckpoint != null));
}","/** 
 * Called by the channel wrapper to retrieve a new processing log for a transfer envelope. The processing log determines whether the envelope is later written to the checkpoint, sent via the network, or both.
 * @param individualChannelType the type of the individual channel asking for the processing log
 * @return the newly created processing log.
 */
public TransferEnvelopeProcessingLog getProcessingLog(final ChannelType individualChannelType){
  return new TransferEnvelopeProcessingLog((individualChannelType == ChannelType.NETWORK),(this.ephemeralCheckpoint != null));
}"
88452,"/** 
 * Called by the attached output channel wrapper to forward a   {@link TransferEnvelope} objectto its final destination. Within this method the provided transfer envelope is possibly also forwarded to the assigned ephemeral checkpoint.
 * @param channelWrapper the channel wrapper which called this method
 * @param outgoingTransferEnvelope the transfer envelope to be forwarded
 */
public void processEnvelope(ByteBufferedOutputChannelWrapper channelWrapper,TransferEnvelope outgoingTransferEnvelope){
  final TransferEnvelopeProcessingLog processingLog=outgoingTransferEnvelope.getProcessingLog();
  if (this.ephemeralCheckpoint != null && processingLog.mustBeWrittenToCheckpoint()) {
    this.ephemeralCheckpoint.addTransferEnvelope(outgoingTransferEnvelope);
    final EventList eventList=outgoingTransferEnvelope.getEventList();
    if (!eventList.isEmpty() && this.channelType == ChannelType.FILE) {
      final Iterator<AbstractEvent> it=eventList.iterator();
      while (it.hasNext()) {
        if (it.next() instanceof ByteBufferedChannelCloseEvent) {
          this.ephemeralCheckpoint.markChannelAsFinished(outgoingTransferEnvelope.getSource());
          if (this.ephemeralCheckpoint.isPersistent()) {
            channelWrapper.processEvent(new ByteBufferedChannelCloseEvent());
          }
          break;
        }
      }
    }
  }
  if (processingLog.mustBeSentViaNetwork()) {
    this.byteBufferedChannelManager.queueOutgoingTransferEnvelope(outgoingTransferEnvelope);
  }
}","/** 
 * Called by the attached output channel wrapper to forward a   {@link TransferEnvelope} objectto its final destination. Within this method the provided transfer envelope is possibly also forwarded to the assigned ephemeral checkpoint.
 * @param channelWrapper the channel wrapper which called this method
 * @param outgoingTransferEnvelope the transfer envelope to be forwarded
 */
public void processEnvelope(ByteBufferedOutputChannelWrapper channelWrapper,TransferEnvelope outgoingTransferEnvelope){
  final TransferEnvelopeProcessingLog processingLog=outgoingTransferEnvelope.getProcessingLog();
  if (this.ephemeralCheckpoint != null && processingLog.mustBeWrittenToCheckpoint()) {
    this.ephemeralCheckpoint.addTransferEnvelope(outgoingTransferEnvelope);
    final EventList eventList=outgoingTransferEnvelope.getEventList();
    if (!eventList.isEmpty() && this.commonChannelType == ChannelType.FILE) {
      final Iterator<AbstractEvent> it=eventList.iterator();
      while (it.hasNext()) {
        if (it.next() instanceof ByteBufferedChannelCloseEvent) {
          this.ephemeralCheckpoint.markChannelAsFinished(outgoingTransferEnvelope.getSource());
          if (this.ephemeralCheckpoint.isPersistent()) {
            channelWrapper.processEvent(new ByteBufferedChannelCloseEvent());
          }
          break;
        }
      }
    }
  }
  if (processingLog.mustBeSentViaNetwork()) {
    this.byteBufferedChannelManager.queueOutgoingTransferEnvelope(outgoingTransferEnvelope);
  }
}"
88453,"/** 
 * Constructs a new byte buffered output channel group object.
 * @param byteBufferedChannelManager the byte buffered channel manager this object is attached to
 * @param checkpointManager the checkpoint manager used to create ephemeral checkpoints
 * @param channelType the channel type all of the channels attached to this group have in common, possibly <code>null</code>
 * @param executionVertexID the id of the execution vertex this channel group object belongs to
 */
public ByteBufferedOutputChannelGroup(ByteBufferedChannelManager byteBufferedChannelManager,CheckpointManager checkpointManager,ChannelType channelType,ExecutionVertexID executionVertexID){
  this.byteBufferedChannelManager=byteBufferedChannelManager;
  this.channelType=channelType;
  if (channelType == ChannelType.FILE) {
    this.ephemeralCheckpoint=EphemeralCheckpoint.forFileChannel(checkpointManager,executionVertexID);
  }
 else   if (channelType == ChannelType.NETWORK) {
    this.ephemeralCheckpoint=EphemeralCheckpoint.forNetworkChannel(checkpointManager,executionVertexID);
  }
 else {
    this.ephemeralCheckpoint=null;
  }
  if (this.ephemeralCheckpoint != null) {
    this.byteBufferedChannelManager.registerOutOfWriterBuffersListener(this.ephemeralCheckpoint);
  }
}","/** 
 * Constructs a new byte buffered output channel group object.
 * @param byteBufferedChannelManager the byte buffered channel manager this object is attached to
 * @param checkpointManager the checkpoint manager used to create ephemeral checkpoints
 * @param commonChannelType the channel type all of the channels attached to this group have in common, possibly <code>null</code>
 * @param executionVertexID the id of the execution vertex this channel group object belongs to
 */
public ByteBufferedOutputChannelGroup(ByteBufferedChannelManager byteBufferedChannelManager,CheckpointManager checkpointManager,ChannelType commonChannelType,ExecutionVertexID executionVertexID){
  this.byteBufferedChannelManager=byteBufferedChannelManager;
  this.commonChannelType=commonChannelType;
  if (commonChannelType == ChannelType.FILE) {
    this.ephemeralCheckpoint=EphemeralCheckpoint.forFileChannel(checkpointManager,executionVertexID);
  }
 else   if (commonChannelType == ChannelType.NETWORK) {
    this.ephemeralCheckpoint=EphemeralCheckpoint.forNetworkChannel(checkpointManager,executionVertexID);
  }
 else {
    this.ephemeralCheckpoint=null;
  }
  if (this.ephemeralCheckpoint != null) {
    this.byteBufferedChannelManager.registerOutOfWriterBuffersListener(this.ephemeralCheckpoint);
  }
}"
88454,"/** 
 * Creates a new   {@link TransferEnvelope} object. The method assignsand increases the sequence number.
 * @return a new {@link TransferEnvelope} object
 */
private TransferEnvelope createNewOutgoingTransferEnvelope(){
  final TransferEnvelope transferEnvelope=new TransferEnvelope(this.byteBufferedOutputChannel.getID(),this.byteBufferedOutputChannel.getConnectedChannelID(),this.byteBufferedOutputChannelGroup.getProcessingLog());
  transferEnvelope.setSequenceNumber(this.sequenceNumber++);
  return transferEnvelope;
}","/** 
 * Creates a new   {@link TransferEnvelope} object. The method assignsand increases the sequence number.
 * @return a new {@link TransferEnvelope} object
 */
private TransferEnvelope createNewOutgoingTransferEnvelope(){
  final TransferEnvelope transferEnvelope=new TransferEnvelope(this.byteBufferedOutputChannel.getID(),this.byteBufferedOutputChannel.getConnectedChannelID(),this.byteBufferedOutputChannelGroup.getProcessingLog(this.byteBufferedOutputChannel.getType()));
  transferEnvelope.setSequenceNumber(this.sequenceNumber++);
  return transferEnvelope;
}"
88455,"public void map(PactString key,PactString value,Collector<PactString,PactInteger> out){
  if (Integer.parseInt(key.toString()) + Integer.parseInt(value.toString()) < 10) {
    out.collect(value,new PactInteger(Integer.parseInt(key.toString()) + 10));
    LOG.debug(""String_Node_Str"" + key + ""String_Node_Str""+ value+ ""String_Node_Str"");
  }
}","public void map(PactString key,PactString value,Collector<PactString,PactInteger> out){
  LOG.debug(""String_Node_Str"" + key + ""String_Node_Str""+ value+ ""String_Node_Str"");
  if (Integer.parseInt(key.toString()) + Integer.parseInt(value.toString()) < 10) {
    out.collect(value,new PactInteger(Integer.parseInt(key.toString()) + 10));
  }
}"
88456,"/** 
 * {@inheritDoc}
 */
@Override public boolean equals(Object obj){
  if (!super.equals(obj)) {
    return false;
  }
  if (!(obj instanceof SingleInstanceProfilingEvent)) {
    return false;
  }
  final SingleInstanceProfilingEvent singleInstanceProfilingEvent=(SingleInstanceProfilingEvent)obj;
  if (this.instanceName.equals(singleInstanceProfilingEvent.getInstanceName())) {
    return false;
  }
  return true;
}","/** 
 * {@inheritDoc}
 */
@Override public boolean equals(Object obj){
  if (!super.equals(obj)) {
    return false;
  }
  if (!(obj instanceof SingleInstanceProfilingEvent)) {
    return false;
  }
  final SingleInstanceProfilingEvent singleInstanceProfilingEvent=(SingleInstanceProfilingEvent)obj;
  if (!this.instanceName.equals(singleInstanceProfilingEvent.getInstanceName())) {
    return false;
  }
  return true;
}"
88457,"/** 
 * {@inheritDoc}
 */
@Override public boolean equals(Object obj){
  if (super.equals(obj)) {
    return false;
  }
  if (!(obj instanceof ThreadProfilingEvent)) {
    return false;
  }
  final ThreadProfilingEvent threadProfilingEvent=(ThreadProfilingEvent)obj;
  if (this.userTime != threadProfilingEvent.getUserTime()) {
    return false;
  }
  if (this.systemTime != threadProfilingEvent.getSystemTime()) {
    return false;
  }
  if (this.blockedTime != threadProfilingEvent.getBlockedTime()) {
    return false;
  }
  if (this.waitedTime != threadProfilingEvent.getWaitedTime()) {
    return false;
  }
  return true;
}","/** 
 * {@inheritDoc}
 */
@Override public boolean equals(Object obj){
  if (!super.equals(obj)) {
    return false;
  }
  if (!(obj instanceof ThreadProfilingEvent)) {
    return false;
  }
  final ThreadProfilingEvent threadProfilingEvent=(ThreadProfilingEvent)obj;
  if (this.userTime != threadProfilingEvent.getUserTime()) {
    return false;
  }
  if (this.systemTime != threadProfilingEvent.getSystemTime()) {
    return false;
  }
  if (this.blockedTime != threadProfilingEvent.getBlockedTime()) {
    return false;
  }
  if (this.waitedTime != threadProfilingEvent.getWaitedTime()) {
    return false;
  }
  return true;
}"
88458,"public List<ManagementGroupVertex> getGroupVerticesInReverseTopologicalOrder(){
  final List<ManagementGroupVertex> reverseTopologicalSort=new ArrayList<ManagementGroupVertex>();
  final Deque<ManagementGroupVertex> noOutgoingEdges=new ArrayDeque<ManagementGroupVertex>();
  final Map<ManagementGroupVertex,Integer> outdegrees=new HashMap<ManagementGroupVertex,Integer>();
  final Iterator<ManagementGroupVertex> it=new ManagementGroupVertexIterator(this,false,-1);
  while (it.hasNext()) {
    final ManagementGroupVertex groupVertex=it.next();
    outdegrees.put(groupVertex,new Integer(groupVertex.getNumberOfForwardEdges()));
    if (groupVertex.getNumberOfForwardEdges() == 0) {
      noOutgoingEdges.add(groupVertex);
    }
  }
  while (!noOutgoingEdges.isEmpty()) {
    final ManagementGroupVertex groupVertex=noOutgoingEdges.removeFirst();
    reverseTopologicalSort.add(groupVertex);
    for (int i=0; i < groupVertex.getNumberOfBackwardEdges(); i++) {
      final ManagementGroupVertex sourceVertex=groupVertex.getBackwardEdge(i).getSource();
      Integer outdegree=outdegrees.get(sourceVertex);
      outdegree=new Integer(outdegree.intValue() - 1);
      outdegrees.put(sourceVertex,outdegree);
      if (outdegree.intValue() == 0) {
        noOutgoingEdges.add(sourceVertex);
      }
    }
  }
  return reverseTopologicalSort;
}","public List<ManagementGroupVertex> getGroupVerticesInReverseTopologicalOrder(){
  final List<ManagementGroupVertex> reverseTopologicalSort=new ArrayList<ManagementGroupVertex>();
  final Deque<ManagementGroupVertex> noOutgoingEdges=new ArrayDeque<ManagementGroupVertex>();
  final Map<ManagementGroupVertex,Integer> outdegrees=new HashMap<ManagementGroupVertex,Integer>();
  final Iterator<ManagementGroupVertex> it=new ManagementGroupVertexIterator(this,false,-1);
  while (it.hasNext()) {
    final ManagementGroupVertex groupVertex=it.next();
    outdegrees.put(groupVertex,Integer.valueOf(groupVertex.getNumberOfForwardEdges()));
    if (groupVertex.getNumberOfForwardEdges() == 0) {
      noOutgoingEdges.add(groupVertex);
    }
  }
  while (!noOutgoingEdges.isEmpty()) {
    final ManagementGroupVertex groupVertex=noOutgoingEdges.removeFirst();
    reverseTopologicalSort.add(groupVertex);
    for (int i=0; i < groupVertex.getNumberOfBackwardEdges(); i++) {
      final ManagementGroupVertex sourceVertex=groupVertex.getBackwardEdge(i).getSource();
      Integer outdegree=outdegrees.get(sourceVertex);
      outdegree=Integer.valueOf(outdegree.intValue() - 1);
      outdegrees.put(sourceVertex,outdegree);
      if (outdegree.intValue() == 0) {
        noOutgoingEdges.add(sourceVertex);
      }
    }
  }
  return reverseTopologicalSort;
}"
88459,"public List<ManagementGroupVertex> getGroupVerticesInTopologicalOrder(){
  final List<ManagementGroupVertex> topologicalSort=new ArrayList<ManagementGroupVertex>();
  final Deque<ManagementGroupVertex> noIncomingEdges=new ArrayDeque<ManagementGroupVertex>();
  final Map<ManagementGroupVertex,Integer> indegrees=new HashMap<ManagementGroupVertex,Integer>();
  final Iterator<ManagementGroupVertex> it=new ManagementGroupVertexIterator(this,true,-1);
  while (it.hasNext()) {
    final ManagementGroupVertex groupVertex=it.next();
    indegrees.put(groupVertex,new Integer(groupVertex.getNumberOfBackwardEdges()));
    if (groupVertex.getNumberOfBackwardEdges() == 0) {
      noIncomingEdges.add(groupVertex);
    }
  }
  while (!noIncomingEdges.isEmpty()) {
    final ManagementGroupVertex groupVertex=noIncomingEdges.removeFirst();
    topologicalSort.add(groupVertex);
    for (int i=0; i < groupVertex.getNumberOfForwardEdges(); i++) {
      final ManagementGroupVertex targetVertex=groupVertex.getForwardEdge(i).getTarget();
      Integer indegree=indegrees.get(targetVertex);
      indegree=new Integer(indegree.intValue() - 1);
      indegrees.put(targetVertex,indegree);
      if (indegree.intValue() == 0) {
        noIncomingEdges.add(targetVertex);
      }
    }
  }
  return topologicalSort;
}","public List<ManagementGroupVertex> getGroupVerticesInTopologicalOrder(){
  final List<ManagementGroupVertex> topologicalSort=new ArrayList<ManagementGroupVertex>();
  final Deque<ManagementGroupVertex> noIncomingEdges=new ArrayDeque<ManagementGroupVertex>();
  final Map<ManagementGroupVertex,Integer> indegrees=new HashMap<ManagementGroupVertex,Integer>();
  final Iterator<ManagementGroupVertex> it=new ManagementGroupVertexIterator(this,true,-1);
  while (it.hasNext()) {
    final ManagementGroupVertex groupVertex=it.next();
    indegrees.put(groupVertex,Integer.valueOf(groupVertex.getNumberOfBackwardEdges()));
    if (groupVertex.getNumberOfBackwardEdges() == 0) {
      noIncomingEdges.add(groupVertex);
    }
  }
  while (!noIncomingEdges.isEmpty()) {
    final ManagementGroupVertex groupVertex=noIncomingEdges.removeFirst();
    topologicalSort.add(groupVertex);
    for (int i=0; i < groupVertex.getNumberOfForwardEdges(); i++) {
      final ManagementGroupVertex targetVertex=groupVertex.getForwardEdge(i).getTarget();
      Integer indegree=indegrees.get(targetVertex);
      indegree=Integer.valueOf(indegree.intValue() - 1);
      indegrees.put(targetVertex,indegree);
      if (indegree.intValue() == 0) {
        noIncomingEdges.add(targetVertex);
      }
    }
  }
  return topologicalSort;
}"
88460,"/** 
 * {@inheritDoc}
 */
@Override public String toString(){
  String str;
  if (this.childNodes.isEmpty()) {
    str=this.name;
  }
 else {
    str=""String_Node_Str"";
    final Iterator<NetworkNode> it=this.childNodes.iterator();
    while (it.hasNext()) {
      str+=it.next().toString();
      if (it.hasNext()) {
        str+=""String_Node_Str"";
      }
    }
    str+=""String_Node_Str"";
  }
  return str;
}","/** 
 * {@inheritDoc}
 */
@Override public String toString(){
  String str;
  if (this.childNodes.isEmpty()) {
    str=this.name;
  }
 else {
    final Iterator<NetworkNode> it=this.childNodes.iterator();
    final StringBuffer buf=new StringBuffer(""String_Node_Str"");
    while (it.hasNext()) {
      buf.append(it.next().toString());
      if (it.hasNext()) {
        buf.append(""String_Node_Str"");
      }
    }
    buf.append(""String_Node_Str"");
    str=buf.toString();
  }
  return str;
}"
88461,"/** 
 * Returns a candidate vertex which could potentially be visited next because it is reachable from the currently considered vertex.
 * @param te the traversal entry for the current source vertex
 * @param forward <code>true</code> if the graph should be traversed in correct order, <code>false</code> to traverse it in reverse order
 * @return a candidate vertex which could potentially be visited next
 */
private ManagementVertex getCandidateVertex(final TraversalEntry te,final boolean forward){
  if (forward) {
    while (true) {
      if (this.confinedToStage && te.getCurrentChannel() == 0) {
        while (currentGateLeadsToOtherStage(te,this.forward)) {
          te.increaseCurrentGate();
        }
      }
      if (te.getCurrentGate() >= te.getManagementVertex().getNumberOfOutputGates()) {
        break;
      }
      if (te.getCurrentChannel() >= te.getManagementVertex().getOutputGate(te.getCurrentGate()).getNumberOfForwardEdges()) {
        te.increaseCurrentGate();
        te.resetCurrentChannel();
      }
 else {
        final ManagementEdge forwardEdge=te.getManagementVertex().getOutputGate(te.getCurrentGate()).getForwardEdge(te.getCurrentChannel());
        final ManagementVertex target=forwardEdge.getTarget().getVertex();
        te.increaseCurrentChannel();
        if (!alreadyVisited.contains(target)) {
          return target;
        }
      }
    }
  }
 else {
    while (true) {
      if (te.getCurrentGate() >= te.getManagementVertex().getNumberOfInputGates()) {
        break;
      }
      if (te.getCurrentChannel() >= te.getManagementVertex().getInputGate(te.getCurrentGate()).getNumberOfBackwardEdges()) {
        te.increaseCurrentGate();
        te.resetCurrentChannel();
      }
 else {
        final ManagementEdge backwardEdge=te.getManagementVertex().getInputGate(te.getCurrentGate()).getBackwardEdge(te.getCurrentChannel());
        final ManagementVertex source=backwardEdge.getSource().getVertex();
        if (source == null) {
          LOG.error(""String_Node_Str"");
        }
        te.increaseCurrentChannel();
        if (!alreadyVisited.contains(source)) {
          return source;
        }
      }
    }
  }
  return null;
}","/** 
 * Returns a candidate vertex which could potentially be visited next because it is reachable from the currently considered vertex.
 * @param te the traversal entry for the current source vertex
 * @param forward <code>true</code> if the graph should be traversed in correct order, <code>false</code> to traverse it in reverse order
 * @return a candidate vertex which could potentially be visited next
 */
private ManagementVertex getCandidateVertex(final TraversalEntry te,final boolean forward){
  if (forward) {
    while (true) {
      if (this.confinedToStage && te.getCurrentChannel() == 0) {
        while (currentGateLeadsToOtherStage(te,this.forward)) {
          te.increaseCurrentGate();
        }
      }
      if (te.getCurrentGate() >= te.getManagementVertex().getNumberOfOutputGates()) {
        break;
      }
      if (te.getCurrentChannel() >= te.getManagementVertex().getOutputGate(te.getCurrentGate()).getNumberOfForwardEdges()) {
        te.increaseCurrentGate();
        te.resetCurrentChannel();
      }
 else {
        final ManagementEdge forwardEdge=te.getManagementVertex().getOutputGate(te.getCurrentGate()).getForwardEdge(te.getCurrentChannel());
        final ManagementVertex target=forwardEdge.getTarget().getVertex();
        te.increaseCurrentChannel();
        if (!alreadyVisited.contains(target)) {
          return target;
        }
      }
    }
  }
 else {
    while (true) {
      if (this.confinedToStage && te.getCurrentChannel() == 0) {
        while (currentGateLeadsToOtherStage(te,this.forward)) {
          te.increaseCurrentGate();
        }
      }
      if (te.getCurrentGate() >= te.getManagementVertex().getNumberOfInputGates()) {
        break;
      }
      if (te.getCurrentChannel() >= te.getManagementVertex().getInputGate(te.getCurrentGate()).getNumberOfBackwardEdges()) {
        te.increaseCurrentGate();
        te.resetCurrentChannel();
      }
 else {
        final ManagementEdge backwardEdge=te.getManagementVertex().getInputGate(te.getCurrentGate()).getBackwardEdge(te.getCurrentChannel());
        final ManagementVertex source=backwardEdge.getSource().getVertex();
        if (source == null) {
          LOG.error(""String_Node_Str"");
        }
        te.increaseCurrentChannel();
        if (!alreadyVisited.contains(source)) {
          return source;
        }
      }
    }
  }
  return null;
}"
88462,"/** 
 * Loads the configuration files from the specified directory.
 * @param configDir the directory which contains the configuration files
 */
public static void loadConfiguration(String configDir){
  if (configDir == null) {
    if (configDir == null) {
      LOG.warn(""String_Node_Str"");
      return;
    }
  }
  final File confDirFile=new File(configDir);
  if (!(confDirFile.exists() && confDirFile.isDirectory())) {
    LOG.warn(""String_Node_Str"" + configDir + ""String_Node_Str""+ confDirFile.getAbsolutePath()+ ""String_Node_Str"");
    return;
  }
  File[] files=confDirFile.listFiles(new FilenameFilter(){
    @Override public boolean accept(    File dir,    String name){
      return dir == confDirFile && name != null && name.endsWith(""String_Node_Str"");
    }
  }
);
  if (files == null || files.length == 0) {
    LOG.warn(""String_Node_Str"" + configDir + ""String_Node_Str""+ confDirFile.getAbsolutePath()+ ""String_Node_Str"");
    return;
  }
  for (  File f : files) {
    get().loadResource(""String_Node_Str"" + f.getAbsolutePath());
  }
  if (configuration != null) {
    configuration.confData.put(CONFIGDIRKEY,configDir);
  }
}","/** 
 * Loads the configuration files from the specified directory.
 * @param configDir the directory which contains the configuration files
 */
public static void loadConfiguration(String configDir){
  if (configDir == null) {
    LOG.warn(""String_Node_Str"");
    return;
  }
  final File confDirFile=new File(configDir);
  if (!(confDirFile.exists() && confDirFile.isDirectory())) {
    LOG.warn(""String_Node_Str"" + configDir + ""String_Node_Str""+ confDirFile.getAbsolutePath()+ ""String_Node_Str"");
    return;
  }
  File[] files=confDirFile.listFiles(new FilenameFilter(){
    @Override public boolean accept(    File dir,    String name){
      return dir == confDirFile && name != null && name.endsWith(""String_Node_Str"");
    }
  }
);
  if (files == null || files.length == 0) {
    LOG.warn(""String_Node_Str"" + configDir + ""String_Node_Str""+ confDirFile.getAbsolutePath()+ ""String_Node_Str"");
    return;
  }
  for (  File f : files) {
    get().loadResource(""String_Node_Str"" + f.getAbsolutePath());
  }
  if (configuration != null) {
    configuration.confData.put(CONFIGDIRKEY,configDir);
  }
}"
88463,"@Override public boolean equals(Object obj){
  if (obj instanceof FSKey) {
    final FSKey key=(FSKey)obj;
    if (!this.scheme.equals(key.scheme)) {
      return false;
    }
    if ((this.authority == null) || (key.authority == null)) {
      if (this.authority == null && key.authority == null) {
        return true;
      }
      return false;
    }
    if (!this.authority.equals(key.authority)) {
      return false;
    }
    return true;
  }
  return false;
}","/** 
 * {@inheritDoc}
 */
@Override public boolean equals(Object obj){
  if (obj instanceof FSKey) {
    final FSKey key=(FSKey)obj;
    if (!this.scheme.equals(key.scheme)) {
      return false;
    }
    if ((this.authority == null) || (key.authority == null)) {
      if (this.authority == null && key.authority == null) {
        return true;
      }
      return false;
    }
    if (!this.authority.equals(key.authority)) {
      return false;
    }
    return true;
  }
  return false;
}"
88464,"/** 
 * {@inheritDoc}
 */
@Override public InputSplit[] getInputSplits() throws IllegalConfigurationException {
  if (this.path == null) {
    throw new IllegalConfigurationException(""String_Node_Str"");
  }
  final int numSubtasks=getNumberOfSubtasks();
  final List<FileInputSplit> inputSplits=new ArrayList<FileInputSplit>(numSubtasks);
  List<FileStatus> files=new ArrayList<FileStatus>();
  long totalLength=0;
  try {
    final FileSystem fs=this.path.getFileSystem();
    final FileStatus pathFile=fs.getFileStatus(this.path);
    if (pathFile.isDir()) {
      final FileStatus[] dir=fs.listStatus(this.path);
      for (int i=0; i < dir.length; i++) {
        if (!dir[i].isDir()) {
          files.add(dir[i]);
          totalLength+=dir[i].getLen();
        }
      }
    }
 else {
      files.add(pathFile);
      totalLength+=pathFile.getLen();
    }
    final long minSplitSize=1;
    final long maxSplitSize=totalLength / numSubtasks + (totalLength % numSubtasks == 0 ? 0 : 1);
    for (    FileStatus file : files) {
      final long len=file.getLen();
      final long blockSize=file.getBlockSize();
      final long splitSize=Math.max(minSplitSize,Math.min(maxSplitSize,blockSize));
      final long halfSplit=splitSize >>> 1;
      final long maxBytesForLastSplit=(long)(splitSize * MAX_SPLIT_SIZE_DISCREPANCY);
      BlockLocation[] blocks=fs.getFileBlockLocations(file,0,len);
      Arrays.sort(blocks);
      long bytesUnassigned=len;
      long position=0;
      int blockIndex=0;
      while (bytesUnassigned > maxBytesForLastSplit) {
        blockIndex=getBlockIndexForPosition(blocks,position,halfSplit,blockIndex);
        FileInputSplit fis=new FileInputSplit(file.getPath(),position,splitSize,blocks[blockIndex].getHosts());
        inputSplits.add(fis);
        position+=splitSize;
        bytesUnassigned-=splitSize;
      }
      if (bytesUnassigned > 0) {
        blockIndex=getBlockIndexForPosition(blocks,position,halfSplit,blockIndex);
        FileInputSplit fis=new FileInputSplit(file.getPath(),position,bytesUnassigned,blocks[blockIndex].getHosts());
        inputSplits.add(fis);
      }
    }
  }
 catch (  IOException ioe) {
    throw new IllegalConfigurationException(""String_Node_Str"" + this.path.toString() + ""String_Node_Str""+ StringUtils.stringifyException(ioe));
  }
  return inputSplits.toArray(new InputSplit[inputSplits.size()]);
}","/** 
 * {@inheritDoc}
 */
@Override public InputSplit[] getInputSplits() throws IllegalConfigurationException {
  if (this.path == null) {
    throw new IllegalConfigurationException(""String_Node_Str"");
  }
  final int numSubtasks=getNumberOfSubtasks();
  final List<FileInputSplit> inputSplits=new ArrayList<FileInputSplit>();
  List<FileStatus> files=new ArrayList<FileStatus>();
  long totalLength=0;
  try {
    final FileSystem fs=this.path.getFileSystem();
    final FileStatus pathFile=fs.getFileStatus(this.path);
    if (pathFile.isDir()) {
      final FileStatus[] dir=fs.listStatus(this.path);
      for (int i=0; i < dir.length; i++) {
        if (!dir[i].isDir()) {
          files.add(dir[i]);
          totalLength+=dir[i].getLen();
        }
      }
    }
 else {
      files.add(pathFile);
      totalLength+=pathFile.getLen();
    }
    final long minSplitSize=1;
    final long maxSplitSize=(numSubtasks < 1) ? Long.MAX_VALUE : (totalLength / numSubtasks + (totalLength % numSubtasks == 0 ? 0 : 1));
    for (    FileStatus file : files) {
      final long len=file.getLen();
      final long blockSize=file.getBlockSize();
      final long splitSize=Math.max(minSplitSize,Math.min(maxSplitSize,blockSize));
      final long halfSplit=splitSize >>> 1;
      final long maxBytesForLastSplit=(long)(splitSize * MAX_SPLIT_SIZE_DISCREPANCY);
      BlockLocation[] blocks=fs.getFileBlockLocations(file,0,len);
      Arrays.sort(blocks);
      long bytesUnassigned=len;
      long position=0;
      int blockIndex=0;
      while (bytesUnassigned > maxBytesForLastSplit) {
        blockIndex=getBlockIndexForPosition(blocks,position,halfSplit,blockIndex);
        FileInputSplit fis=new FileInputSplit(file.getPath(),position,splitSize,blocks[blockIndex].getHosts());
        inputSplits.add(fis);
        position+=splitSize;
        bytesUnassigned-=splitSize;
      }
      if (bytesUnassigned > 0) {
        blockIndex=getBlockIndexForPosition(blocks,position,halfSplit,blockIndex);
        FileInputSplit fis=new FileInputSplit(file.getPath(),position,bytesUnassigned,blocks[blockIndex].getHosts());
        inputSplits.add(fis);
      }
    }
  }
 catch (  IOException ioe) {
    throw new IllegalConfigurationException(""String_Node_Str"" + this.path.toString() + ""String_Node_Str""+ StringUtils.stringifyException(ioe));
  }
  return inputSplits.toArray(new InputSplit[inputSplits.size()]);
}"
88465,"/** 
 * Main method. accepts a single parameter, which is the config directory.
 * @param args The parameters to the entry point.
 */
public static void main(String[] args){
  try {
    String configDir=null;
    if (args.length >= 2 && args[0].equals(""String_Node_Str"")) {
      configDir=args[1];
    }
    if (configDir == null) {
      System.err.println(""String_Node_Str"");
      System.exit(1);
      return;
    }
    GlobalConfiguration.loadConfiguration(configDir);
    Configuration config=GlobalConfiguration.getConfiguration();
    int port=config.getInteger(PactConfigConstants.WEB_FRONTEND_PORT_KEY,PactConfigConstants.DEFAULT_WEB_FRONTEND_PORT);
    WebInterfaceServer server=new WebInterfaceServer(config,port);
    LOG.info(""String_Node_Str"" + port + '.');
    server.start();
    server.join();
  }
 catch (  Throwable t) {
    LOG.error(""String_Node_Str"" + t.getMessage(),t);
  }
}","/** 
 * Main method. accepts a single parameter, which is the config directory.
 * @param args The parameters to the entry point.
 */
public static void main(String[] args){
  try {
    String configDir=null;
    if (args.length >= 2 && args[0].equals(""String_Node_Str"")) {
      configDir=args[1];
    }
    if (configDir == null) {
      System.err.println(""String_Node_Str"");
      System.exit(1);
      return;
    }
    GlobalConfiguration.loadConfiguration(configDir);
    Configuration config=GlobalConfiguration.getConfiguration();
    config.setString(PactConfigConstants.STRATOSPHERE_BASE_DIR_PATH_KEY,configDir + ""String_Node_Str"");
    int port=config.getInteger(PactConfigConstants.WEB_FRONTEND_PORT_KEY,PactConfigConstants.DEFAULT_WEB_FRONTEND_PORT);
    WebInterfaceServer server=new WebInterfaceServer(config,port);
    LOG.info(""String_Node_Str"" + port + '.');
    server.start();
    server.join();
  }
 catch (  Throwable t) {
    LOG.error(""String_Node_Str"" + t.getMessage(),t);
  }
}"
88466,"/** 
 * Creates a new web interface server. The server runs the servlets that implement the logic to upload, list, delete and submit jobs, to compile them and to show the optimizer plan. It serves the asynchronous requests for the plans and all other static resources, like static web pages, stylesheets or javascript files.
 * @param nepheleConfig The configuration for the nephele job manager. All compiled jobs will be sent to the manager described by this configuration.
 * @param port The port to launch the server on.
 * @throws IOException Thrown, if the server setup failed for an I/O related reason.
 */
public WebInterfaceServer(Configuration nepheleConfig,int port) throws IOException {
  Configuration config=GlobalConfiguration.getConfiguration();
  if (nepheleConfig == null) {
    nepheleConfig=config;
  }
  File webDir=new File(config.getString(PactConfigConstants.WEB_ROOT_PATH_KEY,PactConfigConstants.DEFAULT_WEB_ROOT_DIR));
  File tmpDir=new File(config.getString(PactConfigConstants.WEB_TMP_DIR_KEY,PactConfigConstants.DEFAULT_WEB_TMP_DIR));
  File uploadDir=new File(config.getString(PactConfigConstants.WEB_JOB_UPLOAD_DIR_KEY,PactConfigConstants.DEFAULT_WEB_JOB_STORAGE_DIR));
  File planDumpDir=new File(config.getString(PactConfigConstants.WEB_PLAN_DUMP_DIR_KEY,PactConfigConstants.DEFAULT_WEB_PLAN_DUMP_DIR));
  LOG.debug(""String_Node_Str"" + webDir.getAbsolutePath() + ""String_Node_Str"");
  LOG.debug(""String_Node_Str"" + tmpDir.getAbsolutePath() + ""String_Node_Str""+ uploadDir.getAbsolutePath()+ ""String_Node_Str""+ planDumpDir.getAbsolutePath()+ ""String_Node_Str"");
  LOG.debug(""String_Node_Str"" + config.getString(ConfigConstants.JOB_MANAGER_IPC_ADDRESS_KEY,ConfigConstants.DEFAULT_JOB_MANAGER_IPC_ADDRESS) + ""String_Node_Str""+ config.getInteger(ConfigConstants.JOB_MANAGER_IPC_PORT_KEY,ConfigConstants.DEFAULT_JOB_MANAGER_IPC_PORT)+ ""String_Node_Str"");
  server=new Server(port);
  if (!webDir.exists()) {
    throw new FileNotFoundException(""String_Node_Str"" + webDir.getAbsolutePath());
  }
  checkAndCreateDirectories(tmpDir,true);
  checkAndCreateDirectories(uploadDir,true);
  checkAndCreateDirectories(planDumpDir,true);
  ServletContextHandler servletContext=new ServletContextHandler(ServletContextHandler.SESSIONS);
  servletContext.setContextPath(""String_Node_Str"");
  servletContext.addServlet(new ServletHolder(new PactJobJSONServlet(uploadDir)),""String_Node_Str"");
  servletContext.addServlet(new ServletHolder(new PlanDisplayServlet()),""String_Node_Str"");
  servletContext.addServlet(new ServletHolder(new JobsServlet(uploadDir,tmpDir,""String_Node_Str"")),""String_Node_Str"");
  servletContext.addServlet(new ServletHolder(new JobSubmissionServlet(nepheleConfig,uploadDir,planDumpDir)),""String_Node_Str"");
  ResourceHandler pactPlanHandler=new ResourceHandler();
  pactPlanHandler.setDirectoriesListed(false);
  pactPlanHandler.setResourceBase(planDumpDir.getAbsolutePath());
  ContextHandler pactPlanContext=new ContextHandler();
  pactPlanContext.setContextPath(""String_Node_Str"");
  pactPlanContext.setHandler(pactPlanHandler);
  ResourceHandler resourceHandler=new ResourceHandler();
  resourceHandler.setDirectoriesListed(false);
  resourceHandler.setResourceBase(webDir.getAbsolutePath());
  HandlerList handlers=new HandlerList();
  handlers.addHandler(servletContext);
  handlers.addHandler(pactPlanContext);
  handlers.addHandler(resourceHandler);
  File af=null;
  String authFile=config.getString(PactConfigConstants.WEB_ACCESS_FILE_KEY,PactConfigConstants.DEFAULT_WEB_ACCESS_FILE_PATH);
  if (authFile != null) {
    af=new File(authFile);
    if (!af.exists()) {
      LOG.error(""String_Node_Str"" + af.getAbsolutePath() + ""String_Node_Str"");
      af=null;
    }
  }
  if (af != null) {
    HashLoginService loginService=new HashLoginService(""String_Node_Str"",authFile);
    server.addBean(loginService);
    Constraint constraint=new Constraint();
    constraint.setName(Constraint.__BASIC_AUTH);
    constraint.setAuthenticate(true);
    constraint.setRoles(new String[]{""String_Node_Str""});
    ConstraintMapping mapping=new ConstraintMapping();
    mapping.setPathSpec(""String_Node_Str"");
    mapping.setConstraint(constraint);
    ConstraintSecurityHandler sh=new ConstraintSecurityHandler();
    sh.addConstraintMapping(mapping);
    sh.setAuthenticator(new BasicAuthenticator());
    sh.setLoginService(loginService);
    sh.setStrict(true);
    sh.setHandler(handlers);
    server.setHandler(sh);
  }
 else {
    server.setHandler(handlers);
  }
}","/** 
 * Creates a new web interface server. The server runs the servlets that implement the logic to upload, list, delete and submit jobs, to compile them and to show the optimizer plan. It serves the asynchronous requests for the plans and all other static resources, like static web pages, stylesheets or javascript files.
 * @param nepheleConfig The configuration for the nephele job manager. All compiled jobs will be sent to the manager described by this configuration.
 * @param port The port to launch the server on.
 * @throws IOException Thrown, if the server setup failed for an I/O related reason.
 */
public WebInterfaceServer(Configuration nepheleConfig,int port) throws IOException {
  Configuration config=GlobalConfiguration.getConfiguration();
  if (nepheleConfig == null) {
    nepheleConfig=config;
  }
  String basePath=nepheleConfig.getString(PactConfigConstants.STRATOSPHERE_BASE_DIR_PATH_KEY,""String_Node_Str"");
  File webDir;
  File tmpDir;
  File uploadDir;
  File planDumpDir;
  String webDirPath=config.getString(PactConfigConstants.WEB_ROOT_PATH_KEY,PactConfigConstants.DEFAULT_WEB_ROOT_DIR);
  if (webDirPath.startsWith(""String_Node_Str"")) {
    webDir=new File(webDirPath);
  }
 else {
    webDir=new File(basePath + ""String_Node_Str"" + webDirPath);
  }
  String tmpDirPath=config.getString(PactConfigConstants.WEB_TMP_DIR_KEY,PactConfigConstants.DEFAULT_WEB_TMP_DIR);
  if (tmpDirPath.startsWith(""String_Node_Str"")) {
    tmpDir=new File(tmpDirPath);
  }
 else {
    tmpDir=new File(basePath + ""String_Node_Str"" + tmpDirPath);
  }
  String uploadDirPath=config.getString(PactConfigConstants.WEB_JOB_UPLOAD_DIR_KEY,PactConfigConstants.DEFAULT_WEB_JOB_STORAGE_DIR);
  if (uploadDirPath.startsWith(""String_Node_Str"")) {
    uploadDir=new File(uploadDirPath);
  }
 else {
    uploadDir=new File(basePath + ""String_Node_Str"" + uploadDirPath);
  }
  String planDumpDirPath=config.getString(PactConfigConstants.WEB_PLAN_DUMP_DIR_KEY,PactConfigConstants.DEFAULT_WEB_PLAN_DUMP_DIR);
  if (planDumpDirPath.startsWith(""String_Node_Str"")) {
    planDumpDir=new File(planDumpDirPath);
  }
 else {
    planDumpDir=new File(basePath + ""String_Node_Str"" + planDumpDirPath);
  }
  LOG.debug(""String_Node_Str"" + webDir.getAbsolutePath() + ""String_Node_Str"");
  LOG.debug(""String_Node_Str"" + tmpDir.getAbsolutePath() + ""String_Node_Str""+ uploadDir.getAbsolutePath()+ ""String_Node_Str""+ planDumpDir.getAbsolutePath()+ ""String_Node_Str"");
  LOG.debug(""String_Node_Str"" + config.getString(ConfigConstants.JOB_MANAGER_IPC_ADDRESS_KEY,ConfigConstants.DEFAULT_JOB_MANAGER_IPC_ADDRESS) + ""String_Node_Str""+ config.getInteger(ConfigConstants.JOB_MANAGER_IPC_PORT_KEY,ConfigConstants.DEFAULT_JOB_MANAGER_IPC_PORT)+ ""String_Node_Str"");
  server=new Server(port);
  if (!webDir.exists()) {
    throw new FileNotFoundException(""String_Node_Str"" + webDir.getAbsolutePath());
  }
  checkAndCreateDirectories(tmpDir,true);
  checkAndCreateDirectories(uploadDir,true);
  checkAndCreateDirectories(planDumpDir,true);
  ServletContextHandler servletContext=new ServletContextHandler(ServletContextHandler.SESSIONS);
  servletContext.setContextPath(""String_Node_Str"");
  servletContext.addServlet(new ServletHolder(new PactJobJSONServlet(uploadDir)),""String_Node_Str"");
  servletContext.addServlet(new ServletHolder(new PlanDisplayServlet()),""String_Node_Str"");
  servletContext.addServlet(new ServletHolder(new JobsServlet(uploadDir,tmpDir,""String_Node_Str"")),""String_Node_Str"");
  servletContext.addServlet(new ServletHolder(new JobSubmissionServlet(nepheleConfig,uploadDir,planDumpDir)),""String_Node_Str"");
  ResourceHandler pactPlanHandler=new ResourceHandler();
  pactPlanHandler.setDirectoriesListed(false);
  pactPlanHandler.setResourceBase(planDumpDir.getAbsolutePath());
  ContextHandler pactPlanContext=new ContextHandler();
  pactPlanContext.setContextPath(""String_Node_Str"");
  pactPlanContext.setHandler(pactPlanHandler);
  ResourceHandler resourceHandler=new ResourceHandler();
  resourceHandler.setDirectoriesListed(false);
  resourceHandler.setResourceBase(webDir.getAbsolutePath());
  HandlerList handlers=new HandlerList();
  handlers.addHandler(servletContext);
  handlers.addHandler(pactPlanContext);
  handlers.addHandler(resourceHandler);
  File af=null;
  String authFile=config.getString(PactConfigConstants.WEB_ACCESS_FILE_KEY,PactConfigConstants.DEFAULT_WEB_ACCESS_FILE_PATH);
  if (authFile != null) {
    af=new File(authFile);
    if (!af.exists()) {
      LOG.error(""String_Node_Str"" + af.getAbsolutePath() + ""String_Node_Str"");
      af=null;
    }
  }
  if (af != null) {
    HashLoginService loginService=new HashLoginService(""String_Node_Str"",authFile);
    server.addBean(loginService);
    Constraint constraint=new Constraint();
    constraint.setName(Constraint.__BASIC_AUTH);
    constraint.setAuthenticate(true);
    constraint.setRoles(new String[]{""String_Node_Str""});
    ConstraintMapping mapping=new ConstraintMapping();
    mapping.setPathSpec(""String_Node_Str"");
    mapping.setConstraint(constraint);
    ConstraintSecurityHandler sh=new ConstraintSecurityHandler();
    sh.addConstraintMapping(mapping);
    sh.setAuthenticator(new BasicAuthenticator());
    sh.setLoginService(loginService);
    sh.setStrict(true);
    sh.setHandler(handlers);
    server.setHandler(sh);
  }
 else {
    server.setHandler(handlers);
  }
}"
88467,"/** 
 * Reads the instance types configured in the config file. The config file needs to contain a key <code>clustermgr.nrtypes</code> that indicates the number of instance types that are supported by the cluster. This is followed by entries <code>clustermgr.instancetype.X</code> where X is a number from 1 to the specified number of entries. Each entry follows the format: ""instancename,numComputeUnits,numCores,memorySize,diskCapacity,pricePerHour"" (see   {@link InstanceType}).
 * @return list of available instance types sorted by price (cheapest tomost expensive)
 */
private InstanceType[] populateInstanceTypeArray(){
  final List<InstanceType> instanceTypes=Lists.newArrayList();
  int count=1;
  while (true) {
    final String key=INSTANCE_TYPE_PREFIX_KEY + Integer.toString(count);
    String descr=GlobalConfiguration.getString(key,null);
    if (descr == null) {
      if (count == 1) {
        LOG.error(""String_Node_Str"" + DEFAULT_INSTANCE_TYPE);
        descr=DEFAULT_INSTANCE_TYPE;
      }
 else {
        break;
      }
    }
    try {
      instanceTypes.add(InstanceType.getTypeFromString(descr));
    }
 catch (    Throwable t) {
      LOG.error(""String_Node_Str"" + key + ""String_Node_Str""+ descr,t);
    }
    ++count;
  }
  Collections.sort(instanceTypes,new Comparator<InstanceType>(){
    @Override public int compare(    InstanceType o1,    InstanceType o2){
      return o1.getPricePerHour() - o2.getPricePerHour();
    }
  }
);
  return instanceTypes.toArray(new InstanceType[0]);
}","/** 
 * Reads the instance types configured in the config file. The config file needs to contain a key <code>clustermgr.nrtypes</code> that indicates the number of instance types that are supported by the cluster. This is followed by entries <code>clustermgr.instancetype.X</code> where X is a number from 1 to the specified number of entries. Each entry follows the format: ""instancename,numComputeUnits,numCores,memorySize,diskCapacity,pricePerHour"" (see   {@link InstanceType}).
 * @return list of available instance types sorted by price (cheapest tomost expensive)
 */
public static InstanceType[] populateInstanceTypeArray(Log log){
  final List<InstanceType> instanceTypes=new ArrayList<InstanceType>();
  int count=1;
  while (true) {
    final String key=ConfigConstants.INSTANCE_MANAGER_INSTANCE_TYPE_PREFIX_KEY + Integer.toString(count);
    String descr=GlobalConfiguration.getString(key,null);
    if (descr == null) {
      if (count == 1) {
        if (log != null) {
          LOG.error(""String_Node_Str"" + ""String_Node_Str"" + ConfigConstants.DEFAULT_INSTANCE_TYPE);
        }
        descr=ConfigConstants.DEFAULT_INSTANCE_TYPE;
      }
 else {
        break;
      }
    }
    try {
      instanceTypes.add(InstanceType.getTypeFromString(descr));
    }
 catch (    Throwable t) {
      if (log != null) {
        LOG.error(""String_Node_Str"" + key + ""String_Node_Str""+ descr+ ""String_Node_Str""+ ConfigConstants.DEFAULT_INSTANCE_TYPE+ ""String_Node_Str""+ count+ ""String_Node_Str"",t);
      }
      instanceTypes.add(InstanceType.getTypeFromString(ConfigConstants.DEFAULT_INSTANCE_TYPE));
    }
    ++count;
  }
  return instanceTypes.toArray(new InstanceType[instanceTypes.size()]);
}"
88468,"/** 
 * {@inheritDoc}
 */
@Override public InstanceType getDefaultInstanceType(){
  return this.availableInstanceTypes[this.defaultInstanceTypeIndex - 1];
}","/** 
 * {@inheritDoc}
 */
@Override public InstanceType getDefaultInstanceType(){
  return this.availableInstanceTypes[this.defaultInstanceTypeIndex];
}"
88469,"/** 
 * Constructor.
 */
public ClusterManager(){
  this.availableInstanceTypes=populateInstanceTypeArray();
  long tmpCleanUpInterval=(long)GlobalConfiguration.getInteger(CLEANUP_INTERVAL_KEY,DEFAULT_CLEANUP_INTERVAL) * 1000;
  if ((tmpCleanUpInterval % BASE_INTERVAL) != 0) {
    LOG.warn(""String_Node_Str"" + DEFAULT_CLEANUP_INTERVAL);
    tmpCleanUpInterval=DEFAULT_CLEANUP_INTERVAL;
  }
  this.cleanUpInterval=tmpCleanUpInterval;
  int tmpDefaultInstanceTypeIndex=GlobalConfiguration.getInteger(DEFAULT_INSTANCE_TYPE_INDEX_KEY,DEFAULT_DEFAULT_INSTANCE_TYPE_INDEX);
  if (tmpDefaultInstanceTypeIndex >= this.availableInstanceTypes.length) {
    LOG.warn(""String_Node_Str"" + DEFAULT_DEFAULT_INSTANCE_TYPE_INDEX);
    tmpDefaultInstanceTypeIndex=DEFAULT_DEFAULT_INSTANCE_TYPE_INDEX;
  }
  this.defaultInstanceTypeIndex=tmpDefaultInstanceTypeIndex;
  this.networkTopology=loadNetworkTopology();
  loadIPToInstanceTypeMapping();
  final boolean runTimerAsDaemon=true;
  new Timer(runTimerAsDaemon).schedule(cleanupStaleMachines,BASE_INTERVAL,BASE_INTERVAL);
}","/** 
 * Constructor.
 */
public ClusterManager(){
  this.availableInstanceTypes=populateInstanceTypeArray(LOG);
  long tmpCleanUpInterval=(long)GlobalConfiguration.getInteger(ConfigConstants.INSTANCE_MANAGER_CLEANUP_INTERVAL_KEY,DEFAULT_CLEANUP_INTERVAL) * 1000;
  if ((tmpCleanUpInterval % BASE_INTERVAL) != 0) {
    LOG.warn(""String_Node_Str"" + DEFAULT_CLEANUP_INTERVAL + ""String_Node_Str"");
    tmpCleanUpInterval=DEFAULT_CLEANUP_INTERVAL;
  }
  this.cleanUpInterval=tmpCleanUpInterval;
  int tmpDefaultInstanceTypeIndex=GlobalConfiguration.getInteger(ConfigConstants.INSTANCE_MANAGER_DEFAULT_INSTANCE_TYPE_INDEX_KEY,ConfigConstants.DEFAULT_DEFAULT_INSTANCE_TYPE_INDEX);
  if (tmpDefaultInstanceTypeIndex > this.availableInstanceTypes.length) {
    LOG.warn(""String_Node_Str"" + tmpDefaultInstanceTypeIndex + ""String_Node_Str""+ ConfigConstants.DEFAULT_DEFAULT_INSTANCE_TYPE_INDEX);
    tmpDefaultInstanceTypeIndex=ConfigConstants.DEFAULT_DEFAULT_INSTANCE_TYPE_INDEX;
  }
  this.defaultInstanceTypeIndex=tmpDefaultInstanceTypeIndex - 1;
  this.networkTopology=loadNetworkTopology();
  loadIPToInstanceTypeMapping();
  final boolean runTimerAsDaemon=true;
  new Timer(runTimerAsDaemon).schedule(cleanupStaleMachines,BASE_INTERVAL,BASE_INTERVAL);
}"
88470,"private void preConfigure(Object obj,String alias){
  checkNotNull(obj,""String_Node_Str"");
  serializee.setRootClass(initializer.getActualClass(obj));
  if (initializer.isProxy(obj.getClass())) {
    initializer.initialize(obj);
  }
  if (alias == null) {
    if (Collection.class.isInstance(obj) && (List.class.isInstance(obj))) {
      alias=""String_Node_Str"";
    }
 else {
      alias=extractor.nameFor(serializee.getRootClass());
    }
  }
  builder.setAlias(alias);
  setRoot(obj);
}","private void preConfigure(Object obj,String alias){
  checkNotNull(obj,""String_Node_Str"");
  serializee.setRootClass(initializer.getActualClass(obj));
  if (alias == null) {
    if (Collection.class.isInstance(obj) && (List.class.isInstance(obj))) {
      alias=""String_Node_Str"";
    }
 else {
      alias=extractor.nameFor(serializee.getRootClass());
    }
  }
  builder.setAlias(alias);
  setRoot(obj);
}"
88471,"public Gson create(){
  return builder.create();
}","public Gson create(){
  builder.registerTypeHierarchyAdapter(HibernateProxy.class,new HibernateProxySerializer());
  return builder.create();
}"
88472,"@Test public void shouldRunHibernateLazyInitialization() throws Exception {
  LazyInitializer initializer=mock(LazyInitializer.class);
  SomeProxy proxy=new SomeProxy(initializer);
  proxy.name=""String_Node_Str"";
  proxy.aField=""String_Node_Str"";
  when(initializer.getPersistentClass()).thenReturn(Client.class);
  serialization.from(proxy).serialize();
  assertThat(result(),is(""String_Node_Str""));
  verify(initializer).initialize();
}","@Test public void shouldRunHibernateLazyInitialization() throws Exception {
  LazyInitializer initializer=mock(LazyInitializer.class);
  SomeProxy proxy=new SomeProxy(initializer);
  proxy.name=""String_Node_Str"";
  proxy.aField=""String_Node_Str"";
  when(initializer.getPersistentClass()).thenReturn(Client.class);
  when(proxy.getHibernateLazyInitializer().getImplementation()).thenReturn((Client)proxy);
  serialization.from(proxy).serialize();
  assertThat(result(),is(""String_Node_Str""));
}"
88473,"public BluePrintsPersister(Kind node){
  nodeKind=node;
}","public BluePrintsPersister(Kind node){
}"
88474,"/** 
 * Update given collection by creating a set of edges/vertices for each element
 * @param p          properties to update associated vertices for
 * @param toUpdate   source object to update
 * @param rootVertex vertex associated to toUpdate
 * @param cascade    used cascade type, can be either {@link CascadeType#PERSIST} or {@link CascadeType#MERGE}
 * @category update
 */
private <DataType>void updateCollection(AbstractBluePrintsBackedFinderService<? extends Graph,DataType,?> service,Graph database,Property p,Object toUpdate,Vertex rootVertex,CascadeType cascade,Map<String,Object> objectsBeingAccessed){
  Collection<?> value=(Collection<?>)p.get(toUpdate);
  if (value != null) {
    Iterable<Edge> existingIterator=service.getStrategy().getOutEdgesFor(rootVertex,p);
    Collection<Vertex> newVertices=createCollectionVerticesFor(service,value,cascade,objectsBeingAccessed);
    Map<Vertex,Edge> oldVertices=new HashMap<Vertex,Edge>();
    for (    Edge e : existingIterator) {
      Vertex inVertex=e.getInVertex();
      if (newVertices.contains(inVertex)) {
        newVertices.remove(inVertex);
      }
 else {
        oldVertices.put(inVertex,e);
      }
    }
    for (    Map.Entry<Vertex,Edge> entry : oldVertices.entrySet()) {
      database.removeEdge(entry.getValue());
    }
    int order=0;
    for (    Vertex newVertex : newVertices) {
      Edge createdEdge=service.getDriver().createEdgeFor(rootVertex,newVertex,p);
      createdEdge.setProperty(Properties.collection_index.name(),order++);
    }
  }
}","/** 
 * Update given collection by creating a set of edges/vertices for each element
 * @param p          properties to update associated vertices for
 * @param toUpdate   source object to update
 * @param rootVertex vertex associated to toUpdate
 * @param cascade    used cascade type, can be either {@link CascadeType#PERSIST} or {@link CascadeType#MERGE}
 * @category update
 */
private <DataType>void updateCollection(AbstractBluePrintsBackedFinderService<? extends Graph,DataType,?> service,Graph database,Property p,Object toUpdate,Vertex rootVertex,CascadeType cascade,Map<String,Object> objectsBeingAccessed){
  Collection<?> value=(Collection<?>)p.get(toUpdate);
  if (value != null) {
    Iterable<Edge> existingEdges=service.getStrategy().getOutEdgesFor(rootVertex,p);
    Collection<Vertex> allVertices=createCollectionVerticesFor(service,value,cascade,objectsBeingAccessed);
    Map<Vertex,Edge> allEdges=new HashMap<Vertex,Edge>();
    Set<Edge> edgesToRemove=new HashSet<Edge>();
    for (    Edge e : existingEdges) {
      Vertex inVertex=e.getInVertex();
      if (allVertices.contains(inVertex)) {
        allEdges.put(inVertex,e);
      }
 else {
        edgesToRemove.add(e);
        allEdges.put(inVertex,null);
      }
    }
    for (    Edge edge : edgesToRemove) {
      database.removeEdge(edge);
    }
    int order=0;
    for (    Vertex vertex : allVertices) {
      Edge edgeForVertex=allEdges.get(vertex);
      if (edgeForVertex == null)       edgeForVertex=service.getDriver().createEdgeFor(rootVertex,vertex,p);
      edgeForVertex.setProperty(Properties.collection_index.name(),order++);
    }
  }
}"
88475,"@Test public void makeSureListOrderIsPreserved(){
  for (int i=posts.size() - 1; i >= 0; i--) {
    author.posts.add(posts.get(i));
  }
  getUserService().update(author);
  User user=getACopyOfTheAuthor();
  assertThat(""String_Node_Str"",user.posts.size(),is(6));
  assertThat(""String_Node_Str"",user.posts.get(0),is(posts.get(5)));
  assertThat(""String_Node_Str"",user.posts.get(1),is(posts.get(4)));
  assertThat(""String_Node_Str"",user.posts.get(2),is(posts.get(3)));
  assertThat(""String_Node_Str"",user.posts.get(3),is(posts.get(2)));
  assertThat(""String_Node_Str"",user.posts.get(4),is(posts.get(1)));
  assertThat(""String_Node_Str"",user.posts.get(5),is(posts.get(0)));
}","@Test public void makeSureListOrderIsPreserved(){
  for (int i=posts.size() - 1; i >= 0; i--) {
    author.posts.add(posts.get(i));
  }
  getUserService().update(author);
  User user=getACopyOfTheAuthor();
  final int NUM_POSTS=6;
  assertThat(""String_Node_Str"",user.posts.size(),is(NUM_POSTS));
  for (int i=0; i < NUM_POSTS; i++) {
    assertThat(""String_Node_Str"" + i + ""String_Node_Str"",user.posts.get(i),is(posts.get(NUM_POSTS - i - 1)));
  }
}"
88476,"private User getACopyOfTheAuthor(){
  User user=getUserService().find().matching(new QueryBuilder<UserInformer>(){
    @Override public QueryExpression createMatchingExpression(    UserInformer informer){
      return informer.getId().equalsTo(author.id);
    }
  }
).getFirst();
  return user;
}","/** 
 * Load this.author fresh from the database, by building a query to fetch it.
 * @return
 */
private User getACopyOfTheAuthor(){
  User user=getUserService().find().matching(new QueryBuilder<UserInformer>(){
    @Override public QueryExpression createMatchingExpression(    UserInformer informer){
      return informer.getId().equalsTo(author.id);
    }
  }
).getFirst();
  return user;
}"
88477,"@Override public int compare(Edge o1,Edge o2){
  Integer o1Idx=(Integer)o1.getProperty(Properties.collection_index.name());
  Integer o2Idx=(Integer)o2.getProperty(Properties.collection_index.name());
  if (null == o1Idx || null == o2Idx)   throw new UnableToSortException(""String_Node_Str"");
  return o1Idx.compareTo(o2Idx);
}","@Override public int compare(Edge o1,Edge o2){
  Integer o1Idx=(Integer)o1.getProperty(Properties.collection_index.name());
  Integer o2Idx=(Integer)o2.getProperty(Properties.collection_index.name());
  if (null == o1Idx && null == o2Idx)   return 0;
  if (null == o1Idx)   return -1;
  if (null == o2Idx)   return 1;
  return o1Idx.compareTo(o2Idx);
}"
88478,"private void deleteAllAuthorsPosts(){
  User u=getACopyOfTheAuthor();
  u.posts.clear();
  getUserService().update(u);
}","@After public void deleteAllAuthorsPosts(){
  User u=getACopyOfTheAuthor();
  u.posts.clear();
  getUserService().update(u);
}"
88479,"@Test public void checkListOrderWithModifications(){
  for (int i=posts.size() - 1; i >= 0; i--) {
    author.posts.add(posts.get(i));
  }
  getUserService().update(author);
  author.posts.remove(3);
  author.posts.remove(1);
  getUserService().update(author);
  User user=getACopyOfTheAuthor();
  assertThat(""String_Node_Str"",user.posts.size(),is(posts.size() - 2));
  assertThat(""String_Node_Str"",user.posts.get(0),is(posts.get(5)));
  assertThat(""String_Node_Str"",user.posts.get(1),is(posts.get(3)));
  assertThat(""String_Node_Str"",user.posts.get(2),is(posts.get(1)));
  assertThat(""String_Node_Str"",user.posts.get(3),is(posts.get(0)));
  deleteAllAuthorsPosts();
}","@Test public void checkListOrderWithModifications(){
  for (int i=posts.size() - 1; i >= 0; i--) {
    author.posts.add(posts.get(i));
  }
  getUserService().update(author);
  author.posts.remove(3);
  author.posts.remove(1);
  getUserService().update(author);
  User user=getACopyOfTheAuthor();
  assertThat(""String_Node_Str"",user.posts.size(),is(posts.size() - 2));
  assertThat(""String_Node_Str"",user.posts.get(0),is(posts.get(5)));
  assertThat(""String_Node_Str"",user.posts.get(1),is(posts.get(3)));
  assertThat(""String_Node_Str"",user.posts.get(2),is(posts.get(1)));
  assertThat(""String_Node_Str"",user.posts.get(3),is(posts.get(0)));
}"
88480,"@Test public void makeSureListOrderIsPreserved(){
  for (int i=posts.size() - 1; i >= 0; i--) {
    author.posts.add(posts.get(i));
  }
  getUserService().update(author);
  User user=getACopyOfTheAuthor();
  assertThat(""String_Node_Str"",user.posts.size(),is(6));
  assertThat(""String_Node_Str"",user.posts.get(0),is(posts.get(5)));
  assertThat(""String_Node_Str"",user.posts.get(1),is(posts.get(4)));
  assertThat(""String_Node_Str"",user.posts.get(2),is(posts.get(3)));
  assertThat(""String_Node_Str"",user.posts.get(3),is(posts.get(2)));
  assertThat(""String_Node_Str"",user.posts.get(4),is(posts.get(1)));
  assertThat(""String_Node_Str"",user.posts.get(5),is(posts.get(0)));
  deleteAllAuthorsPosts();
}","@Test public void makeSureListOrderIsPreserved(){
  for (int i=posts.size() - 1; i >= 0; i--) {
    author.posts.add(posts.get(i));
  }
  getUserService().update(author);
  User user=getACopyOfTheAuthor();
  assertThat(""String_Node_Str"",user.posts.size(),is(6));
  assertThat(""String_Node_Str"",user.posts.get(0),is(posts.get(5)));
  assertThat(""String_Node_Str"",user.posts.get(1),is(posts.get(4)));
  assertThat(""String_Node_Str"",user.posts.get(2),is(posts.get(3)));
  assertThat(""String_Node_Str"",user.posts.get(3),is(posts.get(2)));
  assertThat(""String_Node_Str"",user.posts.get(4),is(posts.get(1)));
  assertThat(""String_Node_Str"",user.posts.get(5),is(posts.get(0)));
}"
88481,"/** 
 * Transform an object type into associated primitive type
 * @param toCompareClass
 * @return
 */
public static Class primitize(Class<? extends Number> toCompareClass){
  if (Integer.class.equals(toCompareClass)) {
    return Integer.TYPE;
  }
 else   if (Long.class.equals(toCompareClass)) {
    return Long.TYPE;
  }
 else   if (Short.class.equals(toCompareClass)) {
    return Short.TYPE;
  }
 else   if (Float.class.equals(toCompareClass)) {
    return Float.TYPE;
  }
 else   if (Double.class.equals(toCompareClass)) {
    return Double.TYPE;
  }
 else   if (Byte.class.equals(toCompareClass)) {
    return Byte.TYPE;
  }
 else   if (Character.class.equals(toCompareClass)) {
    return Character.TYPE;
  }
 else   if (Boolean.class.equals(toCompareClass)) {
    return Boolean.TYPE;
  }
  return null;
}","/** 
 * Transform an object type into associated primitive type
 * @param toCompareClass
 * @return
 */
public static Class<?> primitize(Class<? extends Number> toCompareClass){
  if (Integer.class.equals(toCompareClass)) {
    return Integer.TYPE;
  }
 else   if (Long.class.equals(toCompareClass)) {
    return Long.TYPE;
  }
 else   if (Short.class.equals(toCompareClass)) {
    return Short.TYPE;
  }
 else   if (Float.class.equals(toCompareClass)) {
    return Float.TYPE;
  }
 else   if (Double.class.equals(toCompareClass)) {
    return Double.TYPE;
  }
 else   if (Byte.class.equals(toCompareClass)) {
    return Byte.TYPE;
  }
 else   if (Character.class.equals(toCompareClass)) {
    return Character.TYPE;
  }
 else   if (Boolean.class.equals(toCompareClass)) {
    return Boolean.TYPE;
  }
  return null;
}"
88482,"/** 
 * Put all classes extended or implemented by this one (including itself) in a collection
 * @param declaring
 * @return
 */
public static Collection<Class> allClassesOf(Class<?> declaring){
  Collection<Class> returned=new LinkedList<Class>();
  if (declaring != null) {
    if (!declaring.equals(Object.class)) {
      returned.add(declaring);
      returned.addAll(allClassesOf(declaring.getSuperclass()));
      for (      Class i : declaring.getInterfaces()) {
        returned.addAll(allClassesOf(i));
      }
    }
  }
  return returned;
}","/** 
 * Put all classes extended or implemented by this one (including itself) in a collection
 * @param declaring
 * @return
 */
public static Collection<Class<?>> allClassesOf(Class<?> declaring){
  Collection<Class<?>> returned=new LinkedList<Class<?>>();
  if (declaring != null) {
    if (!declaring.equals(Object.class)) {
      returned.add(declaring);
      returned.addAll(allClassesOf(declaring.getSuperclass()));
      for (      Class<?> i : declaring.getInterfaces()) {
        returned.addAll(allClassesOf(i));
      }
    }
  }
  return returned;
}"
88483,"/** 
 * Convert a string into an object of the class it is supposed to come from. This method is expected to work only for String (quite logical, isn't ?) and classes providing either a constructor using String as an argument, or a valueOf method having String as an argument. Any other case will miserably fail (ie a NoFromStringConversionExists will be thrown)
 * @param value input string value
 * @param type expected output type
 * @return an object of that type
 */
public static <Type>Type fromString(String value,Class<Type> type){
  if (String.class.equals(type)) {
    return (Type)value.toString();
  }
 else   if (type.isPrimitive()) {
    return (Type)fromString(value,objectify(type));
  }
 else   if (URI.class.equals(type)) {
    try {
      return (Type)new URI(value);
    }
 catch (    URISyntaxException e) {
      throw new UnableToBuilddURIException(""String_Node_Str"" + value + ""String_Node_Str"",e);
    }
  }
 else   if (Class.class.equals(type)) {
    return classFromString(value);
  }
 else {
    try {
      Constructor<Type> withString=type.getDeclaredConstructor(String.class);
      return withString.newInstance(value);
    }
 catch (    Exception e) {
      try {
        Method valueOf=type.getDeclaredMethod(""String_Node_Str"",String.class);
        return (Type)valueOf.invoke(null,value);
      }
 catch (      Exception e1) {
        throw new NoFromStringConversionExistsException(type,e,e1);
      }
    }
  }
}","/** 
 * Convert a string into an object of the class it is supposed to come from. This method is expected to work only for String (quite logical, isn't ?) and classes providing either a constructor using String as an argument, or a valueOf method having String as an argument. Any other case will miserably fail (ie a NoFromStringConversionExists will be thrown)
 * @param value input string value
 * @param type expected output type
 * @return an object of that type
 */
@SuppressWarnings(""String_Node_Str"") public static <Type>Type fromString(String value,Class<Type> type){
  if (String.class.equals(type)) {
    return (Type)value.toString();
  }
 else   if (type.isPrimitive()) {
    return (Type)fromString(value,objectify(type));
  }
 else   if (URI.class.equals(type)) {
    try {
      return (Type)new URI(value);
    }
 catch (    URISyntaxException e) {
      throw new UnableToBuilddURIException(""String_Node_Str"" + value + ""String_Node_Str"",e);
    }
  }
 else   if (Class.class.equals(type)) {
    return (Type)classFromString(value);
  }
 else {
    try {
      Constructor<Type> withString=type.getDeclaredConstructor(String.class);
      return withString.newInstance(value);
    }
 catch (    Exception e) {
      try {
        Method valueOf=type.getDeclaredMethod(""String_Node_Str"",String.class);
        return (Type)valueOf.invoke(null,value);
      }
 catch (      Exception e1) {
        throw new NoFromStringConversionExistsException(type,e,e1);
      }
    }
  }
}"
88484,"/** 
 * Try to load given type class
 * @param value
 * @return
 */
private static <Type>Type classFromString(String value){
  value=maybeObjectify(value);
  ClassLoader[] used=new ClassLoader[]{value.getClass().getClassLoader(),Utils.class.getClassLoader(),Thread.currentThread().getContextClassLoader()};
  for (  ClassLoader c : used) {
    if (c != null) {
      try {
        return (Type)c.loadClass(value);
      }
 catch (      ClassNotFoundException e) {
      }
    }
  }
  throw new UnableToLoadClassException(value,used);
}","/** 
 * Try to load given type class
 * @param value
 * @return
 */
@SuppressWarnings(""String_Node_Str"") private static <Type>Type classFromString(String value){
  value=maybeObjectify(value);
  ClassLoader[] used=new ClassLoader[]{value.getClass().getClassLoader(),Utils.class.getClassLoader(),Thread.currentThread().getContextClassLoader()};
  for (  ClassLoader c : used) {
    if (c != null) {
      try {
        return (Type)c.loadClass(value);
      }
 catch (      ClassNotFoundException e) {
      }
    }
  }
  throw new UnableToLoadClassException(value,used);
}"
88485,"protected abstract <Type,InformerType extends Informer<Type>>FinderCrudService<Type,InformerType> createServiceFor(Class<Type> beanClass,Class<InformerType> informerClass);","public abstract <Type,InformerType extends Informer<Type>>FinderCrudService<Type,InformerType> createServiceFor(Class<Type> beanClass,Class<InformerType> informerClass);"
88486,"@After public void unload() throws Exception {
  if (graph != null) {
    graph.shutdown();
  }
  File f=new File(GraphProvider.GRAPH_DIR);
  f.delete();
}","@After public void unload() throws Exception {
  if (graph != null) {
    graph.shutdown();
    graph=null;
  }
  File f=new File(graphPath());
  FileUtils.deleteRecursively(f);
}"
88487,"public void loadService() throws Exception {
  repository=new SimpleServiceRepository();
  provider=new FieldBackedPropertyProvider();
  locator=new CumulativeFieldInformerLocator();
  locator.add(new BasicFieldInformerLocator());
  locator.add(new ServiceBackedFieldLocator(repository));
  locator.add(new LazyInterfaceInformerLocator());
  reflectiveFactory=new ReflectionBackedInformerFactory(locator,provider);
  proxyInformerFactory=new ProxyBackedInformerFactory(reflectiveFactory);
  graph=createGraph(graphProvider);
  repository.add(createServiceFor(Tag.class,TagInformer.class));
  repository.add(createServiceFor(Post.class,PostInformer.class));
  repository.add(createServiceFor(PostSubClass.class,PostSubClassInformer.class));
  repository.add(createServiceFor(User.class,UserInformer.class));
  repository.add(createServiceFor(Theme.class,ThemeInformer.class));
  tagService=repository.get(Tag.class);
  postService=repository.get(Post.class);
  postSubService=repository.get(PostSubClass.class);
  userService=repository.get(User.class);
  themeService=repository.get(Theme.class);
}","public void loadService() throws Exception {
  serviceRrepository=new SimpleServiceRepository();
  provider=new FieldBackedPropertyProvider();
  locator=new CumulativeFieldInformerLocator();
  locator.add(new BasicFieldInformerLocator());
  locator.add(new ServiceBackedFieldLocator(serviceRrepository));
  locator.add(new LazyInterfaceInformerLocator());
  reflectiveFactory=new ReflectionBackedInformerFactory(locator,provider);
  proxyInformerFactory=new ProxyBackedInformerFactory(reflectiveFactory);
  graph=createGraph(graphProvider);
  serviceRrepository.add(createServiceFor(Tag.class,TagInformer.class));
  serviceRrepository.add(createServiceFor(Post.class,PostInformer.class));
  serviceRrepository.add(createServiceFor(PostSubClass.class,PostSubClassInformer.class));
  serviceRrepository.add(createServiceFor(User.class,UserInformer.class));
  serviceRrepository.add(createServiceFor(Theme.class,ThemeInformer.class));
  tagService=serviceRrepository.get(Tag.class);
  postService=serviceRrepository.get(Post.class);
  postSubService=serviceRrepository.get(PostSubClass.class);
  userService=serviceRrepository.get(User.class);
  themeService=serviceRrepository.get(Theme.class);
}"
88488,"protected SailRepository getRepository(){
  return environment.getRepository();
}","protected SailRepository getRepository(){
  return environment.getSailRepository();
}"
88489,"@Test @Ignore public void ensureMapCanBeEmptiedForIssue13() throws Exception {
  final String text=""String_Node_Str"";
  Post newxONe=new Post().withText(text).withAuthor(author);
  newxONe=getPostService().create(newxONe);
  try {
    newxONe.annotations.put(A,null);
    getPostService().update(newxONe);
    newxONe=getPostService().find().matching(new FindPostByText(text)).getFirst();
    assertThat(newxONe.annotations.size(),Is.is(1));
    assertThat(newxONe.annotations.containsKey(A),Is.is(true));
    newxONe.annotations.clear();
    getPostService().update(newxONe);
    newxONe=getPostService().find().matching(new FindPostByText(text)).getFirst();
    assertThat(newxONe.annotations.size(),Is.is(0));
  }
 catch (  Exception e) {
    if (logger.isLoggable(Level.SEVERE)) {
      logger.log(Level.SEVERE,""String_Node_Str"",e);
    }
    throw e;
  }
 finally {
    getPostService().delete(newxONe);
  }
}","@Test public void ensureMapCanBeEmptiedForIssue13() throws Exception {
  final String text=""String_Node_Str"";
  Post newxONe=new Post().withText(text).withAuthor(author);
  newxONe=getPostService().create(newxONe);
  try {
    newxONe.annotations.put(A,null);
    getPostService().update(newxONe);
    newxONe=getPostService().find().matching(new FindPostByText(text)).getFirst();
    assertThat(newxONe.annotations.size(),Is.is(1));
    assertThat(newxONe.annotations.containsKey(A),Is.is(true));
    newxONe.annotations.clear();
    getPostService().update(newxONe);
    newxONe=getPostService().find().matching(new FindPostByText(text)).getFirst();
    assertThat(newxONe.annotations.size(),Is.is(0));
  }
 catch (  Exception e) {
    if (logger.isLoggable(Level.SEVERE)) {
      logger.log(Level.SEVERE,""String_Node_Str"",e);
    }
    throw e;
  }
 finally {
    getPostService().delete(newxONe);
  }
}"
88490,"@Test @Ignore public void ensureMapWorksInAllCases() throws Exception {
  Post newxONe=new Post().withText(SOME_NEW_TEXT).withAuthor(author);
  final long id=newxONe.id;
  newxONe=getPostService().create(newxONe);
  try {
    newxONe.annotations.put(A,null);
    getPostService().update(newxONe);
    newxONe=getPostService().find().matching(new FindPostByText(SOME_NEW_TEXT)).getFirst();
    assertThat(newxONe.annotations.size(),Is.is(1));
    assertThat(newxONe.annotations.containsKey(A),Is.is(true));
  }
 catch (  Exception e) {
    if (logger.isLoggable(Level.SEVERE)) {
      logger.log(Level.SEVERE,""String_Node_Str"",e);
    }
    throw e;
  }
 finally {
    getPostService().delete(newxONe);
  }
}","@Test public void ensureMapWorksInAllCases() throws Exception {
  Post newxONe=new Post().withText(SOME_NEW_TEXT).withAuthor(author);
  final long id=newxONe.id;
  newxONe=getPostService().create(newxONe);
  try {
    newxONe.annotations.put(A,null);
    getPostService().update(newxONe);
    newxONe=getPostService().find().matching(new FindPostByText(SOME_NEW_TEXT)).getFirst();
    assertThat(newxONe.annotations.size(),Is.is(1));
    assertThat(newxONe.annotations.containsKey(A),Is.is(true));
  }
 catch (  Exception e) {
    if (logger.isLoggable(Level.SEVERE)) {
      logger.log(Level.SEVERE,""String_Node_Str"",e);
    }
    throw e;
  }
 finally {
    getPostService().delete(newxONe);
  }
}"
88491,"@Test @Ignore public void ensureUpdateOnCreateWorks() throws IOException, ClassNotFoundException {
  Post newxONe=new Post().withText(SOME_NEW_TEXT).withAuthor(author);
  author.setLogin(LOGIN_FOR_UPDATE_ON_CREATE);
  tag1.setText(TEST_TAG_FOR_CREATE_ON_UPDATE);
  newxONe.tags.add(tag1);
  newxONe=getPostService().create(newxONe);
  try {
    author=getUserService().find().matching(new QueryBuilder<UserInformer>(){
      @Override public QueryExpression createMatchingExpression(      UserInformer informer){
        return informer.getPassword().equalsTo(author.password);
      }
    }
).getFirst();
    assertThat(author.getLogin(),Is.is(LOGIN_FOR_UPDATE_ON_CREATE));
    Tag official=getTagService().find().matching(new QueryBuilder<TagInformer>(){
      @Override public QueryExpression createMatchingExpression(      TagInformer informer){
        return informer.getId().equalsTo(tag1.getId());
      }
    }
).getFirst();
    assertThat(official.getText(),Is.is(TEST_TAG_FOR_CREATE_ON_UPDATE));
  }
  finally {
    getPostService().delete(newxONe);
    tag1.setText(TAG_TEXT);
    getTagService().update(tag1);
  }
}","@Test public void ensureUpdateOnCreateWorks() throws IOException, ClassNotFoundException {
  Post newxONe=new Post().withText(SOME_NEW_TEXT).withAuthor(author);
  author.setLogin(LOGIN_FOR_UPDATE_ON_CREATE);
  tag1.setText(TEST_TAG_FOR_CREATE_ON_UPDATE);
  newxONe.tags.add(tag1);
  newxONe=getPostService().create(newxONe);
  try {
    author=getUserService().find().matching(new QueryBuilder<UserInformer>(){
      @Override public QueryExpression createMatchingExpression(      UserInformer informer){
        return informer.getPassword().equalsTo(author.password);
      }
    }
).getFirst();
    assertThat(author.getLogin(),Is.is(LOGIN_FOR_UPDATE_ON_CREATE));
    Tag official=getTagService().find().matching(new QueryBuilder<TagInformer>(){
      @Override public QueryExpression createMatchingExpression(      TagInformer informer){
        return informer.getId().equalsTo(tag1.getId());
      }
    }
).getFirst();
    assertThat(official.getText(),Is.is(TEST_TAG_FOR_CREATE_ON_UPDATE));
  }
  finally {
    getPostService().delete(newxONe);
    tag1.setText(TAG_TEXT);
    getTagService().update(tag1);
  }
}"
88492,"@Test @Ignore public void ensurePostIdCanBeGenerated() throws IOException, ClassNotFoundException {
  Post newOne=new Post().withText(""String_Node_Str"");
  assertThat(newOne.id,Is.is(0l));
  newOne=getPostService().create(newOne);
  assertThat(newOne.id,IsNot.not(0l));
}","@Test public void ensurePostIdCanBeGenerated() throws IOException, ClassNotFoundException {
  Post newOne=new Post().withText(""String_Node_Str"");
  assertThat(newOne.id,Is.is(0l));
  newOne=getPostService().create(newOne);
  assertThat(newOne.id,IsNot.not(0l));
}"
88493,"/** 
 * Create all required environments by replacing   {@link GraphProvider} instance with pairs
 * @param loadTestProviders
 * @return
 */
private static Collection<Object[]> environmentsFor(Collection<Object[]> providers){
  Collection<Object[]> returned=new LinkedList<Object[]>();
  for (  Object[] p : providers) {
    returned.add(covnertProviderToEnvironment(p,new EnvironmentCreator(){
      @Override public Object environmentFor(      GraphProvider o){
        return new SailGraphEnvironment(o);
      }
    }
).toArray());
  }
  return returned;
}","/** 
 * Create all required environments by replacing   {@link GraphProvider} instance with pairs
 * @param loadTestProviders
 * @return
 */
private static Collection<Object[]> environmentsFor(Collection<Object[]> providers){
  Collection<Object[]> returned=new LinkedList<Object[]>();
  for (  Object[] p : providers) {
    returned.add(covnertProviderToEnvironment(p,new EnvironmentCreator(){
      @Override public Object environmentFor(      GraphProvider o){
        return new IndexableGraphEnvironment(o);
      }
    }
).toArray());
  }
  return returned;
}"
88494,"@Override protected <Type,InformerType extends Informer<Type>>FinderCrudService<Type,InformerType> createServiceFor(Class<Type> beanClass,Class<InformerType> informerClass){
  return new IndexableGraphBackedFinderService(beanClass,informerClass,proxyInformerFactory,repository,provider,graph);
}","@Override public <Type,InformerType extends Informer<Type>>FinderCrudService<Type,InformerType> createServiceFor(Class<Type> beanClass,Class<InformerType> informerClass){
  return new IndexableGraphBackedFinderService(beanClass,informerClass,getInformerFactory(),getServiceRrepository(),getProvider(),graph);
}"
88495,"@Override public IndexableGraph get(String path){
  return new TinkerGraph(path(path));
}","@Override public IndexableGraph get(String path){
  String fullPath=path(path);
  File f=new File(fullPath);
  return new TinkerGraph(f.getAbsolutePath());
}"
88496,"protected <Type,InformerType extends Informer<Type>>FinderCrudService<Type,InformerType> createServiceFor(Class<Type> beanClass,Class<InformerType> informerClass){
  return new SailGraphBackedFinderService(beanClass,informerClass,proxyInformerFactory,repository,provider,graph);
}","public <Type,InformerType extends Informer<Type>>FinderCrudService<Type,InformerType> createServiceFor(Class<Type> beanClass,Class<InformerType> informerClass){
  return new SailGraphBackedFinderService(beanClass,informerClass,getInformerFactory(),getServiceRrepository(),getProvider(),graph);
}"
88497,"/** 
 * Get vertex associated to value. If object is managed by a service, we ask this service the value
 * @param value value we want the vertex for
 * @param cascade used cascade type, can be either {@link CascadeType#PERSIST} or {@link CascadeType#MERGE}
 * @param objectsBeingUpdated map of objects currently being updated, it avoid some loops during update, but is absolutely NOT a persistent cache
 * @return
 */
public Vertex getVertexFor(Object value,CascadeType cascade,Map<String,Object> objectsBeingUpdated){
  if (containedClass.isInstance(value)) {
    Vertex returned=getIdVertexFor(containedClass.cast(value));
    if (returned == null) {
      doUpdate(containedClass.cast(value),cascade,objectsBeingUpdated);
      returned=getIdVertexFor(containedClass.cast(value));
    }
 else {
      if (CascadeType.PERSIST == cascade || CascadeType.MERGE == cascade) {
        doUpdate(containedClass.cast(value),cascade,objectsBeingUpdated);
      }
    }
    return returned;
  }
  Class<? extends Object> valueClass=value.getClass();
  if (repository.containsKey(valueClass)) {
    FinderCrudService service=repository.get(valueClass);
    if (service instanceof BluePrintsBackedFinderService) {
      return ((BluePrintsBackedFinderService)service).getVertexFor(value,cascade,objectsBeingUpdated);
    }
 else {
      throw new IncompatibleServiceException(service,valueClass);
    }
  }
 else   if (Literals.containsKey(valueClass)) {
    return GraphUtils.getVertexForLiteral(database,value);
  }
 else   if (Tuples.containsKey(valueClass)) {
    return GraphUtils.getVertexForTuple(this,repository,value,objectsBeingUpdated);
  }
 else {
    throw new ObjectIsNotARealLiteralException(value,valueClass);
  }
}","/** 
 * Get vertex associated to value. If object is managed by a service, we ask this service the value
 * @param value value we want the vertex for
 * @param cascade used cascade type, can be either {@link CascadeType#PERSIST} or {@link CascadeType#MERGE}
 * @param objectsBeingUpdated map of objects currently being updated, it avoid some loops during update, but is absolutely NOT a persistent cache
 * @return
 */
public Vertex getVertexFor(Object value,CascadeType cascade,Map<String,Object> objectsBeingUpdated){
  boolean allowIdGeneration=CascadeType.PERSIST.equals(cascade) || CascadeType.MERGE.equals(cascade);
  if (containedClass.isInstance(value)) {
    Vertex returned=getIdVertexFor(containedClass.cast(value),allowIdGeneration);
    if (returned == null) {
      doUpdate(containedClass.cast(value),cascade,objectsBeingUpdated);
      returned=getIdVertexFor(containedClass.cast(value),allowIdGeneration);
    }
 else {
      if (CascadeType.PERSIST == cascade || CascadeType.MERGE == cascade) {
        doUpdate(containedClass.cast(value),cascade,objectsBeingUpdated);
      }
    }
    return returned;
  }
  Class<? extends Object> valueClass=value.getClass();
  if (repository.containsKey(valueClass)) {
    FinderCrudService service=repository.get(valueClass);
    if (service instanceof BluePrintsBackedFinderService) {
      return ((BluePrintsBackedFinderService)service).getVertexFor(value,cascade,objectsBeingUpdated);
    }
 else {
      throw new IncompatibleServiceException(service,valueClass);
    }
  }
 else   if (Literals.containsKey(valueClass)) {
    return GraphUtils.getVertexForLiteral(database,value);
  }
 else   if (Tuples.containsKey(valueClass)) {
    return GraphUtils.getVertexForTuple(this,repository,value,objectsBeingUpdated);
  }
 else {
    throw new ObjectIsNotARealLiteralException(value,valueClass);
  }
}"
88498,"/** 
 * Gets the id vertex for the given object (if that object exists)
 * @param object
 * @return first matching node if found, and null if not
 */
private Vertex getIdVertexFor(DataType object){
  return GraphUtils.locateVertex(database,Properties.vertexId.name(),getIdVertexId(object,idProperty,false));
}","/** 
 * Gets the id vertex for the given object (if that object exists)
 * @param object object to get id vertex for
 * @param allowIdGeneration when set to true, an id may be created for that object
 * @return first matching node if found, and null if not
 */
private Vertex getIdVertexFor(DataType object,boolean allowIdGeneration){
  return GraphUtils.locateVertex(database,Properties.vertexId.name(),getIdVertexId(object,idProperty,allowIdGeneration));
}"
88499,"/** 
 * Set id of object, and try to assign that object a vertex.
 * @param value
 * @param id
 * @return
 * @see com.dooapp.gaedo.finders.id.IdBasedService#assignId(java.lang.Object,java.lang.Object[])
 */
@Override public boolean assignId(final DataType value,Object... id){
  if (containedClass.isInstance(value)) {
    idProperty.set(value,id[0]);
    if (getIdVertexFor(value) == null) {
      try {
        TransactionalOperation<Boolean> operation=new TransactionalOperation<Boolean>(){
          @Override protected Boolean doPerform(){
            persister.createIdVertex(database,value.getClass(),getIdVertexId(value,idProperty,requiresIdGeneration));
            return true;
          }
        }
;
        return operation.perform();
      }
 catch (      Exception e) {
        return false;
      }
    }
 else {
      return false;
    }
  }
 else {
    return false;
  }
}","/** 
 * Set id of object, and try to assign that object a vertex.
 * @param value
 * @param id
 * @return
 * @see com.dooapp.gaedo.finders.id.IdBasedService#assignId(java.lang.Object,java.lang.Object[])
 */
@Override public boolean assignId(final DataType value,Object... id){
  if (containedClass.isInstance(value)) {
    idProperty.set(value,id[0]);
    if (getIdVertexFor(value,false) == null) {
      try {
        TransactionalOperation<Boolean> operation=new TransactionalOperation<Boolean>(){
          @Override protected Boolean doPerform(){
            persister.createIdVertex(database,value.getClass(),getIdVertexId(value,idProperty,requiresIdGeneration));
            return true;
          }
        }
;
        return operation.perform();
      }
 catch (      Exception e) {
        return false;
      }
    }
 else {
      return false;
    }
  }
 else {
    return false;
  }
}"
88500,"@Test public void ensureCreateOnUpdateWorks() throws IOException, ClassNotFoundException {
  Post first=postService.find().matching(new FindFirstPostByNote()).getFirst();
  assertThat(first.tags.size(),Is.is(0));
  Tag t=new Tag();
  t.setText(TEST_TAG_FOR_CREATE_ON_UPDATE);
  first.tags.add(t);
  first=postService.update(first);
  Tag inDB=tagService.find().matching(new QueryBuilder<TagInformer>(){
    @Override public QueryExpression createMatchingExpression(    TagInformer informer){
      return informer.getText().equalsTo(TEST_TAG_FOR_CREATE_ON_UPDATE);
    }
  }
).getFirst();
  assertThat(inDB.getText(),Is.is(t.getText()));
  assertThat(inDB.getId(),IsNot.not(0l));
}","@Test public void ensureCreateOnUpdateWorks() throws IOException, ClassNotFoundException {
  Post first=postService.find().matching(new FindFirstPostByNote()).getFirst();
  if (first.tags.size() > 0) {
    first.tags.clear();
    first=postService.update(first);
  }
  assertThat(first.tags.size(),Is.is(0));
  Tag t=new Tag();
  t.setText(TEST_TAG_FOR_CREATE_ON_UPDATE);
  first.tags.add(t);
  first=postService.update(first);
  Tag inDB=tagService.find().matching(new QueryBuilder<TagInformer>(){
    @Override public QueryExpression createMatchingExpression(    TagInformer informer){
      return informer.getText().equalsTo(TEST_TAG_FOR_CREATE_ON_UPDATE);
    }
  }
).getFirst();
  assertThat(inDB.getText(),Is.is(t.getText()));
  assertThat(inDB.getId(),IsNot.not(0l));
}"
88501,"@Before public void loadService() throws MalformedURLException {
  repository=new SimpleServiceRepository();
  PropertyProvider provider=new FieldBackedPropertyProvider();
  CumulativeFieldInformerLocator locator=new CumulativeFieldInformerLocator();
  locator.add(new BasicFieldInformerLocator());
  locator.add(new ServiceBackedFieldLocator(repository));
  locator.add(new LazyInterfaceInformerLocator());
  ReflectionBackedInformerFactory reflectiveFactory=new ReflectionBackedInformerFactory(locator,provider);
  InformerFactory proxyInformerFactory=new ProxyBackedInformerFactory(reflectiveFactory);
  graph=graphProvider.get();
  repository.add(new BluePrintsBackedFinderService(Tag.class,TagInformer.class,proxyInformerFactory,repository,provider,graph));
  repository.add(new BluePrintsBackedFinderService(Post.class,PostInformer.class,proxyInformerFactory,repository,provider,graph));
  repository.add(new BluePrintsBackedFinderService(User.class,UserInformer.class,proxyInformerFactory,repository,provider,graph));
  repository.add(new BluePrintsBackedFinderService(Theme.class,ThemeInformer.class,proxyInformerFactory,repository,provider,graph));
  tagService=repository.get(Tag.class);
  postService=repository.get(Post.class);
  userService=repository.get(User.class);
  author=new User().withId(1).withLogin(USER_LOGIN).withPassword(USER_PASSWORD);
  author.about=new Post(ABOUT_ID,""String_Node_Str"",5,State.PUBLIC,author);
  author=userService.create(author);
  post1=postService.create(new Post(ID_POST_1,""String_Node_Str"",1,State.PUBLIC,author,theseMappings(""String_Node_Str"",""String_Node_Str"")));
  post2=postService.create(new Post(2,""String_Node_Str"",2,State.PUBLIC,author));
  post3=postService.create(new Post(3,""String_Node_Str"",3,State.PUBLIC,author));
  author.posts.add(post1);
  author.posts.add(post2);
  author.posts.add(post3);
  author=userService.update(author);
}","@Before public void loadService() throws MalformedURLException {
  repository=new SimpleServiceRepository();
  PropertyProvider provider=new FieldBackedPropertyProvider();
  CumulativeFieldInformerLocator locator=new CumulativeFieldInformerLocator();
  locator.add(new BasicFieldInformerLocator());
  locator.add(new ServiceBackedFieldLocator(repository));
  locator.add(new LazyInterfaceInformerLocator());
  ReflectionBackedInformerFactory reflectiveFactory=new ReflectionBackedInformerFactory(locator,provider);
  InformerFactory proxyInformerFactory=new ProxyBackedInformerFactory(reflectiveFactory);
  graph=graphProvider.get();
  repository.add(new BluePrintsBackedFinderService(Tag.class,TagInformer.class,proxyInformerFactory,repository,provider,graph));
  repository.add(new BluePrintsBackedFinderService(Post.class,PostInformer.class,proxyInformerFactory,repository,provider,graph));
  repository.add(new BluePrintsBackedFinderService(User.class,UserInformer.class,proxyInformerFactory,repository,provider,graph));
  repository.add(new BluePrintsBackedFinderService(Theme.class,ThemeInformer.class,proxyInformerFactory,repository,provider,graph));
  tagService=repository.get(Tag.class);
  postService=repository.get(Post.class);
  userService=repository.get(User.class);
  author=new User().withId(1).withLogin(USER_LOGIN).withPassword(USER_PASSWORD);
  author.about=new Post(ABOUT_ID,""String_Node_Str"",5,State.PUBLIC,author);
  author=userService.create(author);
  post1=postService.create(new Post(ID_POST_1,""String_Node_Str"",1,State.PUBLIC,author,theseMappings(""String_Node_Str"",""String_Node_Str"")));
  post2=postService.create(new Post(2,""String_Node_Str"",2,State.PUBLIC,author));
  post3=postService.create(new Post(3,""String_Node_Str"",3,State.PUBLIC,author));
  tag1=tagService.create(new Tag(1,TAG_TEXT));
  author.posts.add(post1);
  author.posts.add(post2);
  author.posts.add(post3);
  author=userService.update(author);
}"
88502,"@Override public QueryExpression createMatchingExpression(TagInformer informer){
  return informer.getText().equalsTo(TEST_TAG_FOR_CREATE_ON_UPDATE);
}","@Override public QueryExpression createMatchingExpression(TagInformer informer){
  return informer.getId().equalsTo(tag1.getId());
}"
88503,"/** 
 * Set id of object, and try to assign that object a vertex.
 * @param value
 * @param id
 * @return
 * @see com.dooapp.gaedo.finders.id.IdBasedService#assignId(java.lang.Object,java.lang.Object[])
 */
@Override public boolean assignId(DataType value,Object... id){
  idProperty.set(value,id[0]);
  if (getIdVertexFor(value) == null) {
    try {
      persister.createIdVertex(database,containedClass,getIdVertexId(value,idProperty,requiresIdGeneration));
      return true;
    }
 catch (    Exception e) {
      return false;
    }
  }
 else {
    return false;
  }
}","/** 
 * Set id of object, and try to assign that object a vertex.
 * @param value
 * @param id
 * @return
 * @see com.dooapp.gaedo.finders.id.IdBasedService#assignId(java.lang.Object,java.lang.Object[])
 */
@Override public boolean assignId(DataType value,Object... id){
  if (containedClass.isInstance(value)) {
    idProperty.set(value,id[0]);
    if (getIdVertexFor(value) == null) {
      try {
        persister.createIdVertex(database,value.getClass(),getIdVertexId(value,idProperty,requiresIdGeneration));
        return true;
      }
 catch (      Exception e) {
        return false;
      }
    }
 else {
      return false;
    }
  }
 else {
    return false;
  }
}"
88504,"/** 
 * Validates that a string contains no spaces and is non-null/non-empty Throw an exception if the string contains whitespace.  Whitespace is not allowed in tagNames and attributes.
 * @param string any string
 * @throws IllegalArgumentException
 */
public static String validate(String string){
  if (string == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  int i, length=string.length();
  if (length == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  for (i=0; i < length; i+=1) {
    if (Character.isWhitespace(string.charAt(i))) {
      throw new IllegalArgumentException(""String_Node_Str"" + string + ""String_Node_Str"");
    }
  }
  return string;
}","/** 
 * Validates that a string is a valid tag or attribute name i.e. it contains no spaces and is non-null/non-empty Whitespace is not allowed in tagNames and attributes. XML elements must follow these naming rules: Names can contain letters, numbers, and other characters Names cannot start with a number or punctuation character (and a few others) Names cannot start with the letters xml (or XML, or Xml, etc) Names cannot contain spaces See http://www.w3.org/TR/REC-xml/#sec-common-syn Names beginning with the string ""xml"", or with any string which would match (('X'|'x') ('M'|'m') ('L'|'l')),  are reserved for standardization in this or future versions of this specification.
 * @param string any string
 * @param correct if true then correct any errors found (if possible)
 * @return the valid string
 * @throws IllegalArgumentException if the string is invalid (and cannot be corrected)
 */
public static String validate(String string){
  boolean correct=true;
  if (string == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  int i, length=string.length();
  if (length == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  StringBuilder sb=new StringBuilder();
  for (i=0; i < length; i+=1) {
    char c=string.charAt(i);
    if (i == 0) {
      if (!Character.isLetter(c) && '_' != c && ':' != c) {
        if (correct) {
          sb.append('_');
        }
 else {
          throw new IllegalArgumentException(""String_Node_Str"" + string + ""String_Node_Str""+ c+ ""String_Node_Str"");
        }
        continue;
      }
 else       if ('x' == c || 'X' == c) {
        if (string.toLowerCase().startsWith(""String_Node_Str"")) {
          if (correct) {
            sb.append('_');
            i+=2;
          }
 else {
            throw new IllegalArgumentException(""String_Node_Str"" + string + ""String_Node_Str"");
          }
          continue;
        }
      }
    }
    if (Character.isWhitespace(c)) {
      if (correct) {
        sb.append('_');
      }
 else {
        throw new IllegalArgumentException(""String_Node_Str"" + string + ""String_Node_Str"");
      }
    }
 else     if (!Character.isLetterOrDigit(c) && ':' != c && '-' != c && '.' != c && '_' != c) {
      if (correct) {
        sb.append('_');
      }
 else {
        throw new IllegalArgumentException(""String_Node_Str"" + string + ""String_Node_Str""+ c+ ""String_Node_Str"");
      }
    }
 else {
      sb.append(c);
    }
  }
  return sb.toString();
}"
88505,"/** 
 * By default in this provider there is no particular entity
 * @param id
 * @return
 */
public boolean entityExists(String id){
  log.info(userInfo() + ""String_Node_Str"" + id);
  if (id.equals(""String_Node_Str"")) {
    return true;
  }
  return false;
}","public boolean entityExists(String id){
  log.info(userInfo() + ""String_Node_Str"" + id);
  if (id.equals(""String_Node_Str"")) {
    return true;
  }
  return false;
}"
88506,"public Object getSampleEntity(){
  return new CollectionEntity();
}","public Object getSampleEntity(){
  return new StatsEntity();
}"
88507,"/** 
 * Here are statistical data extracted and returned as the list StatsEntity is used here to format and present data It could be done using HashMap for now it is not functioning, updates of related software needed
 * @param ref
 * @param search
 * @return
 * @see StatsEntity
 */
public List<?> getEntities(EntityReference ref,Search search){
  log.info(userInfo() + ""String_Node_Str"");
  Context context;
  try {
    context=new Context();
  }
 catch (  SQLException ex) {
    throw new EntityException(""String_Node_Str"",""String_Node_Str"",500);
  }
  refreshParams(context);
  List<Object> stat=new ArrayList<Object>();
  File reportDir=new File(ConfigurationManager.getProperty(""String_Node_Str""));
  ReportGenerator rg=new ReportGenerator();
  File[] reports=reportDir.listFiles();
  try {
    for (    File report : reports) {
      Matcher genMatcher=analysisGeneralPattern.matcher(report.getName());
      Matcher monMatcher=analysisMonthlyPattern.matcher(report.getName());
      StatReport statReport=new StatReport();
      if (genMatcher.matches()) {
        statReport.setType(""String_Node_Str"");
        rg.processReport(context,statReport,report.getAbsolutePath());
        stat.add(statReport);
      }
 else       if (monMatcher.matches()) {
        statReport.setType(""String_Node_Str"");
        rg.processReport(context,statReport,report.getAbsolutePath());
        stat.add(statReport);
      }
    }
    removeConn(context);
    return stat;
  }
 catch (  SQLException ex) {
    throw new EntityException(""String_Node_Str"",""String_Node_Str"",500);
  }
catch (  Exception ex) {
    throw new EntityException(""String_Node_Str"",""String_Node_Str"",500);
  }
}","public List<?> getEntities(EntityReference ref,Search search){
  log.info(userInfo() + ""String_Node_Str"");
  Context context;
  try {
    context=new Context();
  }
 catch (  SQLException ex) {
    throw new EntityException(""String_Node_Str"",""String_Node_Str"",500);
  }
  refreshParams(context);
  List<Object> stat=new ArrayList<Object>();
  File reportDir=new File(ConfigurationManager.getProperty(""String_Node_Str""));
  ReportGenerator rg=new ReportGenerator();
  File[] reports=reportDir.listFiles();
  try {
    for (    File report : reports) {
      Matcher genMatcher=analysisGeneralPattern.matcher(report.getName());
      Matcher monMatcher=analysisMonthlyPattern.matcher(report.getName());
      StatReport statReport=new StatReport();
      if (genMatcher.matches()) {
        statReport.setType(""String_Node_Str"");
        rg.processReport(context,statReport,report.getAbsolutePath());
        stat.add(statReport);
      }
 else       if (monMatcher.matches()) {
        statReport.setType(""String_Node_Str"");
        rg.processReport(context,statReport,report.getAbsolutePath());
        stat.add(statReport);
      }
    }
    removeConn(context);
    return stat;
  }
 catch (  SQLException ex) {
    throw new EntityException(""String_Node_Str"",""String_Node_Str"",500);
  }
catch (  Exception ex) {
    throw new EntityException(""String_Node_Str"",""String_Node_Str"",500);
  }
}"
88508,"@SuppressWarnings(""String_Node_Str"") protected static String toXML(Object object,String tagName,int level,int maxLevel,boolean humanOutput,boolean includeNulls,boolean includeClass,boolean includeClassField,Map<String,Object> properties){
  StringBuilder sb=new StringBuilder();
  if (object == null) {
    if (includeNulls) {
      tagName=validate(tagName == null ? ""String_Node_Str"" : tagName);
      makeLevelSpaces(sb,level,humanOutput);
      sb.append(LT);
      sb.append(tagName);
      sb.append(SLASH);
      sb.append(GT);
      makeEOL(sb,humanOutput);
    }
  }
 else {
    Class<?> type=ConstructorUtils.getWrapper(object.getClass());
    if (ConstructorUtils.isClassSimple(type)) {
      tagName=validate(tagName == null ? makeElementName(type) : tagName);
      String value=""String_Node_Str"";
      makeLevelSpaces(sb,level,humanOutput);
      sb.append(LT);
      sb.append(tagName);
      if (Date.class.isAssignableFrom(type) || Calendar.class.isAssignableFrom(type)) {
        Date d=null;
        if (Date.class.isAssignableFrom(type)) {
          d=(Date)object;
        }
 else {
          d=((Calendar)object).getTime();
        }
        value=d.getTime() + ""String_Node_Str"";
      }
 else       if (Number.class.isAssignableFrom(type)) {
        value=object.toString();
      }
 else       if (Boolean.class.isAssignableFrom(type)) {
        value=object.toString();
      }
 else {
        value=escapeForXML(object.toString());
      }
      sb.append(GT);
      sb.append(value);
      sb.append(LT);
      sb.append(SLASH);
      sb.append(tagName);
      sb.append(GT);
      makeEOL(sb,humanOutput);
    }
 else     if (ConstructorUtils.isClassArray(type)) {
      tagName=validate(tagName == null ? ""String_Node_Str"" : tagName);
      int length=ArrayUtils.size((Object[])object);
      Class<?> elementType=ArrayUtils.type((Object[])object);
      makeLevelSpaces(sb,level,humanOutput);
      sb.append(LT);
      sb.append(tagName);
      sb.append(GT);
      makeEOL(sb,humanOutput);
      for (int i=0; i < length; ++i) {
        sb.append(toXML(Array.get(object,i),makeElementName(elementType),level + 1,maxLevel,humanOutput,includeNulls,includeClass,includeClassField,properties));
      }
      makeLevelSpaces(sb,level,humanOutput);
      sb.append(LT);
      sb.append(SLASH);
      sb.append(tagName);
      sb.append(GT);
      makeEOL(sb,humanOutput);
    }
 else     if (ConstructorUtils.isClassCollection(type)) {
      tagName=validate(tagName == null ? ""String_Node_Str"" : tagName);
      Collection<Object> collection=(Collection)object;
      makeLevelSpaces(sb,level,humanOutput);
      sb.append(LT);
      sb.append(tagName);
      sb.append(GT);
      makeEOL(sb,humanOutput);
      for (      Object element : collection) {
        Class<?> elementType=null;
        if (element != null) {
          elementType=element.getClass();
        }
        sb.append(toXML(element,makeElementName(elementType),level + 1,maxLevel,humanOutput,includeNulls,includeClass,includeClassField,properties));
      }
      makeLevelSpaces(sb,level,humanOutput);
      sb.append(LT);
      sb.append(SLASH);
      sb.append(tagName);
      sb.append(GT);
      makeEOL(sb,humanOutput);
    }
 else {
      tagName=validate(makeElementName(type) == null ? tagName : makeElementName(type));
      if (tagName.indexOf(""String_Node_Str"") > 0) {
        tagName=tagName.substring(0,tagName.indexOf(""String_Node_Str""));
      }
      String special=TranscoderUtils.checkObjectSpecial(object);
      if (special != null) {
        if (""String_Node_Str"".equals(special)) {
        }
 else {
          makeLevelSpaces(sb,level,humanOutput);
          sb.append(LT);
          sb.append(tagName);
          sb.append(GT);
          sb.append(escapeForXML(special));
          sb.append(LT);
          sb.append(SLASH);
          sb.append(tagName);
          sb.append(GT);
          makeEOL(sb,humanOutput);
        }
      }
 else {
        if (maxLevel <= level) {
          sb.append(LT);
          sb.append(tagName);
          sb.append(GT);
          sb.append(""String_Node_Str"");
          sb.append(level);
          sb.append(""String_Node_Str"");
          sb.append(escapeForXML(object.toString()));
          sb.append(LT);
          sb.append(SLASH);
          sb.append(tagName);
          sb.append(GT);
          makeEOL(sb,humanOutput);
        }
 else {
          String xmlType=""String_Node_Str"";
          Map<String,Object> map=null;
          if (Map.class.isAssignableFrom(type)) {
            xmlType=""String_Node_Str"";
            map=(Map<String,Object>)object;
          }
 else {
            map=ReflectUtils.getInstance().getObjectValues(object,FieldsFilter.SERIALIZABLE,false);
          }
          if (level == 0 && properties != null && !properties.isEmpty()) {
            map.putAll(properties);
          }
          makeLevelSpaces(sb,level,humanOutput);
          sb.append(LT);
          sb.append(tagName);
          if (includeClass) {
            makeClassName(sb,ConstructorUtils.getTypeFromInnerCollection(type));
          }
          sb.append(GT);
          makeEOL(sb,humanOutput);
          for (          Entry<String,Object> entry : map.entrySet()) {
            if (entry.getKey() != null) {
              sb.append(toXML(entry.getValue(),entry.getKey().toString(),level + 1,maxLevel,humanOutput,includeNulls,includeClass,includeClassField,properties));
            }
          }
          makeLevelSpaces(sb,level,humanOutput);
          sb.append(LT);
          sb.append(SLASH);
          sb.append(tagName);
          sb.append(GT);
          makeEOL(sb,humanOutput);
        }
      }
    }
  }
  return sb.toString();
}","@SuppressWarnings(""String_Node_Str"") protected static String toXML(Object object,String tagName,int level,int maxLevel,boolean humanOutput,boolean includeNulls,boolean includeClass,boolean includeClassField,Map<String,Object> properties){
  StringBuilder sb=new StringBuilder();
  if (object == null) {
    if (includeNulls) {
      tagName=validate(tagName == null ? ""String_Node_Str"" : tagName);
      makeLevelSpaces(sb,level,humanOutput);
      sb.append(LT);
      sb.append(tagName);
      sb.append(SLASH);
      sb.append(GT);
      makeEOL(sb,humanOutput);
    }
  }
 else {
    Class<?> type=ConstructorUtils.getWrapper(object.getClass());
    if (ConstructorUtils.isClassSimple(type)) {
      if (level == 0) {
        tagName=""String_Node_Str"";
      }
 else {
        tagName=validate(tagName == null ? makeElementName(type) : tagName);
      }
      String value=""String_Node_Str"";
      makeLevelSpaces(sb,level,humanOutput);
      sb.append(LT);
      sb.append(tagName);
      if (Date.class.isAssignableFrom(type) || Calendar.class.isAssignableFrom(type)) {
        Date d=null;
        if (Date.class.isAssignableFrom(type)) {
          d=(Date)object;
        }
 else {
          d=((Calendar)object).getTime();
        }
        value=d.getTime() + ""String_Node_Str"";
      }
 else       if (Number.class.isAssignableFrom(type)) {
        value=object.toString();
      }
 else       if (Boolean.class.isAssignableFrom(type)) {
        value=object.toString();
      }
 else {
        value=escapeForXML(object.toString());
      }
      sb.append(GT);
      sb.append(value);
      sb.append(LT);
      sb.append(SLASH);
      sb.append(tagName);
      sb.append(GT);
      makeEOL(sb,humanOutput);
    }
 else     if (ConstructorUtils.isClassArray(type)) {
      tagName=validate(tagName == null ? ""String_Node_Str"" : tagName);
      int length=ArrayUtils.size((Object[])object);
      Class<?> elementType=ArrayUtils.type((Object[])object);
      makeLevelSpaces(sb,level,humanOutput);
      sb.append(LT);
      sb.append(tagName);
      sb.append(GT);
      makeEOL(sb,humanOutput);
      for (int i=0; i < length; ++i) {
        sb.append(toXML(Array.get(object,i),makeElementName(elementType),level + 1,maxLevel,humanOutput,includeNulls,includeClass,includeClassField,properties));
      }
      makeLevelSpaces(sb,level,humanOutput);
      sb.append(LT);
      sb.append(SLASH);
      sb.append(tagName);
      sb.append(GT);
      makeEOL(sb,humanOutput);
    }
 else     if (ConstructorUtils.isClassCollection(type)) {
      tagName=validate(tagName == null ? ""String_Node_Str"" : tagName);
      Collection<Object> collection=(Collection)object;
      makeLevelSpaces(sb,level,humanOutput);
      sb.append(LT);
      sb.append(tagName);
      sb.append(GT);
      makeEOL(sb,humanOutput);
      for (      Object element : collection) {
        Class<?> elementType=null;
        if (element != null) {
          elementType=element.getClass();
        }
        sb.append(toXML(element,makeElementName(elementType),level + 1,maxLevel,humanOutput,includeNulls,includeClass,includeClassField,properties));
      }
      makeLevelSpaces(sb,level,humanOutput);
      sb.append(LT);
      sb.append(SLASH);
      sb.append(tagName);
      sb.append(GT);
      makeEOL(sb,humanOutput);
    }
 else {
      if (level == 0) {
        String eleName=makeElementName(type);
        tagName=validate(eleName == null ? tagName : eleName);
      }
 else {
        tagName=validate(tagName == null ? makeElementName(type) : tagName);
      }
      if (tagName.indexOf(""String_Node_Str"") > 0) {
        tagName=tagName.substring(0,tagName.indexOf(""String_Node_Str""));
      }
      String special=TranscoderUtils.checkObjectSpecial(object);
      if (special != null) {
        if (""String_Node_Str"".equals(special)) {
        }
 else {
          makeLevelSpaces(sb,level,humanOutput);
          sb.append(LT);
          sb.append(tagName);
          sb.append(GT);
          sb.append(escapeForXML(special));
          sb.append(LT);
          sb.append(SLASH);
          sb.append(tagName);
          sb.append(GT);
          makeEOL(sb,humanOutput);
        }
      }
 else {
        if (maxLevel <= level) {
          sb.append(LT);
          sb.append(tagName);
          sb.append(GT);
          sb.append(""String_Node_Str"");
          sb.append(level);
          sb.append(""String_Node_Str"");
          sb.append(escapeForXML(object.toString()));
          sb.append(LT);
          sb.append(SLASH);
          sb.append(tagName);
          sb.append(GT);
          makeEOL(sb,humanOutput);
        }
 else {
          String xmlType=""String_Node_Str"";
          Map<String,Object> map=null;
          if (Map.class.isAssignableFrom(type)) {
            xmlType=""String_Node_Str"";
            map=(Map<String,Object>)object;
          }
 else {
            map=ReflectUtils.getInstance().getObjectValues(object,FieldsFilter.SERIALIZABLE,false);
          }
          if (level == 0 && properties != null && !properties.isEmpty()) {
            map.putAll(properties);
          }
          makeLevelSpaces(sb,level,humanOutput);
          sb.append(LT);
          sb.append(tagName);
          if (includeClass) {
            makeClassName(sb,ConstructorUtils.getTypeFromInnerCollection(type));
          }
          sb.append(GT);
          makeEOL(sb,humanOutput);
          for (          Entry<String,Object> entry : map.entrySet()) {
            if (entry.getKey() != null) {
              sb.append(toXML(entry.getValue(),entry.getKey().toString(),level + 1,maxLevel,humanOutput,includeNulls,includeClass,includeClassField,properties));
            }
          }
          makeLevelSpaces(sb,level,humanOutput);
          sb.append(LT);
          sb.append(SLASH);
          sb.append(tagName);
          sb.append(GT);
          makeEOL(sb,humanOutput);
        }
      }
    }
  }
  return sb.toString();
}"
88509,"public Object getAdministrators(EntityReference ref,UserRequestParams uparams,Context context){
  try {
    Community res=Community.find(context,Integer.parseInt(ref.getId()));
    AuthorizeManager.authorizeAction(context,res,Constants.READ);
    Group administrators=res.getAdministrators();
    if (administrators != null) {
      return new GroupEntityTrim(administrators);
    }
  }
 catch (  SQLException ex) {
    throw new EntityException(""String_Node_Str"",""String_Node_Str"",500);
  }
catch (  AuthorizeException ex) {
    throw new EntityException(""String_Node_Str"",""String_Node_Str"",403);
  }
  return new GroupEntity();
}","public Object getAdministrators(EntityReference ref,UserRequestParams uparams,Context context){
  try {
    Community res=Community.find(context,Integer.parseInt(ref.getId()));
    AuthorizeManager.authorizeAction(context,res,Constants.READ);
    Group administrators=res.getAdministrators();
    if (administrators != null) {
      return new GroupEntity(administrators);
    }
  }
 catch (  SQLException ex) {
    throw new EntityException(""String_Node_Str"",""String_Node_Str"",500);
  }
catch (  AuthorizeException ex) {
    throw new EntityException(""String_Node_Str"",""String_Node_Str"",403);
  }
  return new GroupEntityTrim();
}"
88510,"public GroupEntity(Group egroup){
  super(egroup);
  for (  EPerson member : egroup.getMembers()) {
    users.add(new UserEntity(member));
  }
  for (  Group group : egroup.getMemberGroups()) {
    groups.add(new GroupEntity(group));
  }
}","public GroupEntity(Group egroup){
  super(egroup);
  for (  EPerson member : egroup.getMembers()) {
    users.add(new UserEntityTrim(member));
  }
  for (  Group group : egroup.getMemberGroups()) {
    if (group.getMemberGroups().length > 0) {
      groups.add(new GroupEntity(group));
    }
 else {
      groups.add(new GroupEntityTrim(group));
    }
  }
}"
88511,"public UserEntity(int id,String firstName,String lastName,String fullName,String email){
  this.id=id;
  this.firstName=firstName;
  this.lastName=lastName;
  this.fullName=fullName;
  this.email=email;
}","public UserEntity(int id,String firstName,String lastName,String fullName,String email){
  super(id,firstName,lastName,fullName,email);
}"
88512,"public String createEntity(EntityReference ref,Object entity,Map<String,Object> params){
  System.out.println(""String_Node_Str"");
  String result=""String_Node_Str"";
  Map<String,Object> inputVar=(HashMap)entity;
  String action=""String_Node_Str"";
  String function=""String_Node_Str"";
  String[] mandatory_params={};
  if (func2actionMapPOST_rev.get(action) != null) {
    System.out.println(""String_Node_Str"" + func2actionMapPOST_rev.get(""String_Node_Str""));
    function=func2actionMapPOST_rev.get(action);
    mandatory_params=inputParamsPOST.get(function);
  }
  for (  String param : mandatory_params) {
    if (inputVar.get(param) == null) {
      throw new EntityException(""String_Node_Str"",""String_Node_Str"",400);
    }
  }
  Context context;
  try {
    context=new Context();
  }
 catch (  SQLException ex) {
    throw new EntityException(""String_Node_Str"",""String_Node_Str"",500);
  }
  UserRequestParams uparams;
  uparams=refreshParams(context);
  Object CE;
  System.out.println(""String_Node_Str"" + ref.getId());
  try {
    CE=entityConstructor.newInstance(ref.getId(),context,1,uparams);
  }
 catch (  Exception ex) {
    ex.printStackTrace();
    throw new EntityException(""String_Node_Str"",""String_Node_Str"",500);
  }
  try {
    Method method=CE.getClass().getMethod(function,funcParamsPOST.get(action));
    result=(String)method.invoke(CE,ref,inputVar,context);
  }
 catch (  InvocationTargetException ex) {
    if (ex.getCause() != null) {
      throw (RuntimeException)ex.getCause();
    }
 else {
      throw new EntityException(""String_Node_Str"",""String_Node_Str"",500);
    }
  }
catch (  NoSuchMethodException ex) {
    throw new EntityException(""String_Node_Str"",""String_Node_Str"",404);
  }
catch (  IllegalAccessException ex) {
    throw new EntityException(""String_Node_Str"",""String_Node_Str"" + function,500);
  }
  try {
    removeConn(context);
  }
 catch (  NullPointerException ex) {
  }
  return result;
}","public String createEntity(EntityReference ref,Object entity,Map<String,Object> params){
  System.out.println(""String_Node_Str"");
  String result=""String_Node_Str"";
  Map<String,Object> inputVar=(HashMap)entity;
  String action=""String_Node_Str"";
  String function=""String_Node_Str"";
  String[] mandatory_params={};
  try {
    inputVar.get(""String_Node_Str"").getClass().getName();
  }
 catch (  NullPointerException ex) {
    throw new EntityException(""String_Node_Str"",""String_Node_Str"",400);
  }
  try {
    action=(String)inputVar.get(""String_Node_Str"");
  }
 catch (  ClassCastException ex2) {
    throw new EntityException(""String_Node_Str"",""String_Node_Str"",400);
  }
  if (func2actionMapPOST_rev.get(action) != null) {
    System.out.println(""String_Node_Str"" + func2actionMapPOST_rev.get(""String_Node_Str""));
    function=func2actionMapPOST_rev.get(action);
    mandatory_params=inputParamsPOST.get(function);
  }
  for (  String param : mandatory_params) {
    if (inputVar.get(param) == null) {
      throw new EntityException(""String_Node_Str"",""String_Node_Str"",400);
    }
  }
  Context context;
  try {
    context=new Context();
  }
 catch (  SQLException ex) {
    throw new EntityException(""String_Node_Str"",""String_Node_Str"",500);
  }
  UserRequestParams uparams;
  uparams=refreshParams(context);
  Object CE;
  System.out.println(""String_Node_Str"" + ref.getId());
  try {
    CE=entityConstructor.newInstance(ref.getId(),context,1,uparams);
  }
 catch (  Exception ex) {
    ex.printStackTrace();
    throw new EntityException(""String_Node_Str"",""String_Node_Str"",500);
  }
  try {
    Method method=CE.getClass().getMethod(function,funcParamsPOST.get(action));
    result=(String)method.invoke(CE,ref,inputVar,context);
  }
 catch (  InvocationTargetException ex) {
    if (ex.getCause() != null) {
      throw (RuntimeException)ex.getCause();
    }
 else {
      throw new EntityException(""String_Node_Str"",""String_Node_Str"",500);
    }
  }
catch (  NoSuchMethodException ex) {
    throw new EntityException(""String_Node_Str"",""String_Node_Str"",404);
  }
catch (  IllegalAccessException ex) {
    throw new EntityException(""String_Node_Str"",""String_Node_Str"" + function,500);
  }
  try {
    removeConn(context);
  }
 catch (  NullPointerException ex) {
  }
  return result;
}"
88513,"public String createEntity(EntityReference ref,Object entity,Map<String,Object> params){
  System.out.println(""String_Node_Str"");
  String result=""String_Node_Str"";
  Map<String,Object> inputVar=(HashMap)entity;
  String action=""String_Node_Str"";
  String function=""String_Node_Str"";
  String[] mandatory_params={};
  try {
    inputVar.get(""String_Node_Str"").getClass().getName();
  }
 catch (  NullPointerException ex) {
    throw new EntityException(""String_Node_Str"",""String_Node_Str"",400);
  }
  try {
    action=(String)inputVar.get(""String_Node_Str"");
  }
 catch (  ClassCastException ex2) {
    throw new EntityException(""String_Node_Str"",""String_Node_Str"",400);
  }
  if (func2actionMapPOST_rev.get(action) != null) {
    System.out.println(""String_Node_Str"" + func2actionMapPOST_rev.get(""String_Node_Str""));
    function=func2actionMapPOST_rev.get(action);
    mandatory_params=inputParamsPOST.get(function);
  }
  for (  String param : mandatory_params) {
    if (inputVar.get(param) == null) {
      throw new EntityException(""String_Node_Str"",""String_Node_Str"",400);
    }
  }
  Context context;
  try {
    context=new Context();
  }
 catch (  SQLException ex) {
    throw new EntityException(""String_Node_Str"",""String_Node_Str"",500);
  }
  UserRequestParams uparams;
  uparams=refreshParams(context);
  Object CE=new Object();
  System.out.println(""String_Node_Str"" + ref.getId());
  try {
    if (ref.getId() != null) {
      CE=entityConstructor.newInstance(ref.getId(),context,1,uparams);
    }
 else {
      CE=entityConstructor2.newInstance(context,1,uparams);
    }
  }
 catch (  Exception ex) {
    ex.printStackTrace();
    throw new EntityException(""String_Node_Str"",""String_Node_Str"",500);
  }
  try {
    Method method=CE.getClass().getMethod(function,funcParamsPOST.get(action));
    result=(String)method.invoke(CE,ref,inputVar,context);
  }
 catch (  InvocationTargetException ex) {
    if (ex.getCause() != null) {
      throw (RuntimeException)ex.getCause();
    }
 else {
      throw new EntityException(""String_Node_Str"",""String_Node_Str"",500);
    }
  }
catch (  NoSuchMethodException ex) {
    throw new EntityException(""String_Node_Str"",""String_Node_Str"",404);
  }
catch (  IllegalAccessException ex) {
    throw new EntityException(""String_Node_Str"",""String_Node_Str"" + function,500);
  }
  try {
    removeConn(context);
  }
 catch (  NullPointerException ex) {
  }
  return result;
}","public String createEntity(EntityReference ref,Object entity,Map<String,Object> params){
  System.out.println(""String_Node_Str"");
  String result=""String_Node_Str"";
  Map<String,Object> inputVar=(HashMap)entity;
  String action=""String_Node_Str"";
  String function=""String_Node_Str"";
  String[] mandatory_params={};
  try {
    inputVar.get(""String_Node_Str"").getClass().getName();
  }
 catch (  NullPointerException ex) {
    throw new EntityException(""String_Node_Str"",""String_Node_Str"",400);
  }
  try {
    action=(String)inputVar.get(""String_Node_Str"");
  }
 catch (  ClassCastException ex2) {
    throw new EntityException(""String_Node_Str"",""String_Node_Str"",400);
  }
  if (func2actionMapPOST_rev.get(action) != null) {
    System.out.println(""String_Node_Str"" + func2actionMapPOST_rev.get(""String_Node_Str""));
    function=func2actionMapPOST_rev.get(action);
    mandatory_params=inputParamsPOST.get(function);
  }
  for (  String param : mandatory_params) {
    if (inputVar.get(param) == null) {
      throw new EntityException(""String_Node_Str"",""String_Node_Str"",400);
    }
  }
  Context context;
  try {
    context=new Context();
  }
 catch (  SQLException ex) {
    throw new EntityException(""String_Node_Str"",""String_Node_Str"",500);
  }
  UserRequestParams uparams;
  uparams=refreshParams(context);
  Object CE=new Object();
  System.out.println(""String_Node_Str"" + ref.getId());
  try {
    CE=entityConstructor.newInstance(ref.getId(),context,1,uparams);
  }
 catch (  Exception ex) {
    ex.printStackTrace();
    throw new EntityException(""String_Node_Str"",""String_Node_Str"",500);
  }
  try {
    Method method=CE.getClass().getMethod(function,funcParamsPOST.get(action));
    result=(String)method.invoke(CE,ref,inputVar,context);
  }
 catch (  InvocationTargetException ex) {
    if (ex.getCause() != null) {
      throw (RuntimeException)ex.getCause();
    }
 else {
      throw new EntityException(""String_Node_Str"",""String_Node_Str"",500);
    }
  }
catch (  NoSuchMethodException ex) {
    throw new EntityException(""String_Node_Str"",""String_Node_Str"",404);
  }
catch (  IllegalAccessException ex) {
    throw new EntityException(""String_Node_Str"",""String_Node_Str"" + function,500);
  }
  try {
    removeConn(context);
  }
 catch (  NullPointerException ex) {
  }
  return result;
}"
88514,"public UserProvider(EntityProviderManager entityProviderManager) throws SQLException, NoSuchMethodException {
  super(entityProviderManager);
  entityProviderManager.registerEntityProvider(this);
  processedEntity=UserEntity.class;
  func2actionMapGET.put(""String_Node_Str"",""String_Node_Str"");
  func2actionMapGET.put(""String_Node_Str"",""String_Node_Str"");
  func2actionMapGET.put(""String_Node_Str"",""String_Node_Str"");
  func2actionMapGET.put(""String_Node_Str"",""String_Node_Str"");
  func2actionMapGET.put(""String_Node_Str"",""String_Node_Str"");
  func2actionMapGET.put(""String_Node_Str"",""String_Node_Str"");
  func2actionMapGET.put(""String_Node_Str"",""String_Node_Str"");
  func2actionMapGET.put(""String_Node_Str"",""String_Node_Str"");
  func2actionMapGET.put(""String_Node_Str"",""String_Node_Str"");
  func2actionMapGET.put(""String_Node_Str"",""String_Node_Str"");
  func2actionMapGET.put(""String_Node_Str"",""String_Node_Str"");
  func2actionMapGET.put(""String_Node_Str"",""String_Node_Str"");
  func2actionMapPOST.put(""String_Node_Str"",""String_Node_Str"");
  inputParamsPOST.put(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""});
  entityConstructor=processedEntity.getDeclaredConstructor(new Class<?>[]{String.class,Context.class,Integer.TYPE,UserRequestParams.class});
  entityConstructor2=processedEntity.getDeclaredConstructor(new Class<?>[]{Context.class,Integer.TYPE,UserRequestParams.class});
  initMappings(processedEntity);
}","public UserProvider(EntityProviderManager entityProviderManager) throws SQLException, NoSuchMethodException {
  super(entityProviderManager);
  entityProviderManager.registerEntityProvider(this);
  processedEntity=UserEntity.class;
  func2actionMapGET.put(""String_Node_Str"",""String_Node_Str"");
  func2actionMapGET.put(""String_Node_Str"",""String_Node_Str"");
  func2actionMapGET.put(""String_Node_Str"",""String_Node_Str"");
  func2actionMapGET.put(""String_Node_Str"",""String_Node_Str"");
  func2actionMapGET.put(""String_Node_Str"",""String_Node_Str"");
  func2actionMapGET.put(""String_Node_Str"",""String_Node_Str"");
  func2actionMapGET.put(""String_Node_Str"",""String_Node_Str"");
  func2actionMapGET.put(""String_Node_Str"",""String_Node_Str"");
  func2actionMapGET.put(""String_Node_Str"",""String_Node_Str"");
  func2actionMapGET.put(""String_Node_Str"",""String_Node_Str"");
  func2actionMapGET.put(""String_Node_Str"",""String_Node_Str"");
  func2actionMapGET.put(""String_Node_Str"",""String_Node_Str"");
  func2actionMapPOST.put(""String_Node_Str"",""String_Node_Str"");
  inputParamsPOST.put(""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""});
  entityConstructor=processedEntity.getDeclaredConstructor(new Class<?>[]{String.class,Context.class,Integer.TYPE,UserRequestParams.class});
  initMappings(processedEntity);
}"
88515,"public List<?> getEntities(EntityReference ref,Search search){
  log.info(userInfo() + ""String_Node_Str"");
  Context context;
  try {
    context=new Context();
  }
 catch (  SQLException ex) {
    throw new EntityException(""String_Node_Str"",""String_Node_Str"",500);
  }
  UserRequestParams uparams;
  uparams=refreshParams(context);
  List<Object> entities=new ArrayList<Object>();
  try {
    QueryArgs arg=new QueryArgs();
    arg.setQuery(query);
    if (_perpage > 0) {
      arg.setPageSize(_perpage);
    }
    arg.setStart(_start);
    if ((_order.equalsIgnoreCase(""String_Node_Str"")) || (_order.equalsIgnoreCase(""String_Node_Str""))) {
      arg.setSortOrder(SortOption.DESCENDING);
    }
 else {
      arg.setSortOrder(SortOption.ASCENDING);
    }
    QueryResults qre;
    if (_community != null) {
      qre=DSQuery.doQuery(context,arg,_community);
    }
 else     if (_collection != null) {
      qre=DSQuery.doQuery(context,arg,_collection);
    }
 else {
      qre=DSQuery.doQuery(context,arg);
    }
    entities.add(new SearchResultsInfoEntity(qre.getHitCount() - 1,qre.getHitTypes(),qre.getHitHandles(),qre.getHitIds()));
    for (int x=0; x < qre.getHitTypes().size(); x++) {
switch ((Integer)(qre.getHitTypes().get(x))) {
case Constants.ITEM:
{
          entities.add(idOnly ? new ItemEntityId(qre.getHitIds().get(x).toString(),context) : new ItemEntity(qre.getHitIds().get(x).toString(),context,1,uparams));
        }
      break;
case Constants.COMMUNITY:
{
      entities.add(idOnly ? new CommunityEntityId(qre.getHitIds().get(x).toString(),context) : new CommunityEntity(qre.getHitIds().get(x).toString(),context,1,uparams));
    }
  break;
case Constants.COLLECTION:
{
  entities.add(idOnly ? new CollectionEntityId(qre.getHitIds().get(x).toString(),context) : new CollectionEntity(qre.getHitIds().get(x).toString(),context,1,uparams));
}
break;
case Constants.BITSTREAM:
{
entities.add(idOnly ? new BitstreamEntityId(qre.getHitIds().get(x).toString(),context) : new BitstreamEntity(qre.getHitIds().get(x).toString(),context,1,uparams));
}
break;
case Constants.BUNDLE:
{
entities.add(idOnly ? new BundleEntityId(qre.getHitIds().get(x).toString(),context) : new BundleEntity(qre.getHitIds().get(x).toString(),context,1,uparams));
}
break;
case Constants.EPERSON:
{
entities.add(idOnly ? new UserEntityId(qre.getHitIds().get(x).toString(),context) : new UserEntity(qre.getHitIds().get(x).toString(),context,1,uparams));
}
break;
}
}
}
 catch (SQLException sql) {
throw new EntityException(""String_Node_Str"",""String_Node_Str"",500);
}
catch (IOException io) {
throw new EntityException(""String_Node_Str"",""String_Node_Str"",500);
}
if (!idOnly && sortOptions.size() > 0) {
Collections.sort(entities,new GenComparator(sortOptions));
}
removeTrailing(entities);
return entities;
}","public List<?> getEntities(EntityReference ref,Search search){
  log.info(userInfo() + ""String_Node_Str"");
  Context context;
  try {
    context=new Context();
  }
 catch (  SQLException ex) {
    throw new EntityException(""String_Node_Str"",""String_Node_Str"",500);
  }
  UserRequestParams uparams;
  uparams=refreshParams(context);
  List<Object> entities=new ArrayList<Object>();
  try {
    QueryArgs arg=new QueryArgs();
    arg.setQuery(query);
    if (_perpage > 0) {
      arg.setPageSize(_perpage);
    }
    arg.setStart(_start);
    if ((_order.equalsIgnoreCase(""String_Node_Str"")) || (_order.equalsIgnoreCase(""String_Node_Str""))) {
      arg.setSortOrder(SortOption.DESCENDING);
    }
 else {
      arg.setSortOrder(SortOption.ASCENDING);
    }
    QueryResults qre;
    if (_community != null) {
      qre=DSQuery.doQuery(context,arg,_community);
    }
 else     if (_collection != null) {
      qre=DSQuery.doQuery(context,arg,_collection);
    }
 else {
      qre=DSQuery.doQuery(context,arg);
    }
    entities.add(new SearchResultsInfoEntity(qre.getHitCount(),qre.getHitTypes(),qre.getHitHandles(),qre.getHitIds()));
    for (int x=0; x < qre.getHitTypes().size(); x++) {
switch ((Integer)(qre.getHitTypes().get(x))) {
case Constants.ITEM:
{
          entities.add(idOnly ? new ItemEntityId(qre.getHitIds().get(x).toString(),context) : new ItemEntity(qre.getHitIds().get(x).toString(),context,1,uparams));
        }
      break;
case Constants.COMMUNITY:
{
      entities.add(idOnly ? new CommunityEntityId(qre.getHitIds().get(x).toString(),context) : new CommunityEntity(qre.getHitIds().get(x).toString(),context,1,uparams));
    }
  break;
case Constants.COLLECTION:
{
  entities.add(idOnly ? new CollectionEntityId(qre.getHitIds().get(x).toString(),context) : new CollectionEntity(qre.getHitIds().get(x).toString(),context,1,uparams));
}
break;
case Constants.BITSTREAM:
{
entities.add(idOnly ? new BitstreamEntityId(qre.getHitIds().get(x).toString(),context) : new BitstreamEntity(qre.getHitIds().get(x).toString(),context,1,uparams));
}
break;
case Constants.BUNDLE:
{
entities.add(idOnly ? new BundleEntityId(qre.getHitIds().get(x).toString(),context) : new BundleEntity(qre.getHitIds().get(x).toString(),context,1,uparams));
}
break;
case Constants.EPERSON:
{
entities.add(idOnly ? new UserEntityId(qre.getHitIds().get(x).toString(),context) : new UserEntity(qre.getHitIds().get(x).toString(),context,1,uparams));
}
break;
}
}
context.complete();
}
 catch (SQLException sql) {
throw new EntityException(""String_Node_Str"",""String_Node_Str"",500);
}
catch (IOException io) {
throw new EntityException(""String_Node_Str"",""String_Node_Str"",500);
}
if (!idOnly && sortOptions.size() > 0) {
Collections.sort(entities,new GenComparator(sortOptions));
}
return entities;
}"
88516,"@Override public String transform(String s){
  return transform(s).toLowerCase();
}","@Override public String transform(String s){
  return st.transform(s).toLowerCase();
}"
88517,"private void setLanguagePreference(String preference){
  Utility.storeUserProfileEntry(Utility.getQualifiedUsername(),""String_Node_Str"",null,Utility.getQualifiedUsername(),preference,null);
  String newURL=Window.Location.createUrlBuilder().setParameter(LocaleInfo.getLocaleQueryParam(),preference).buildString();
  Window.Location.replace(newURL);
}","private void setLanguagePreference(String preference){
  Utility.storeUserProfileEntry(Utility.getQualifiedUsername(),""String_Node_Str"",null,Utility.getQualifiedUsername(),preference,""String_Node_Str"");
  String newURL=Window.Location.createUrlBuilder().setParameter(LocaleInfo.getLocaleQueryParam(),preference).buildString();
  Window.Location.replace(newURL);
}"
88518,"@Override public void doPut(HttpServletRequest request,HttpServletResponse response) throws IOException, ServletException {
  if (!isValidRequest(request)) {
    response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR,String.format(""String_Node_Str""));
    return;
  }
  final String user=request.getParameter(""String_Node_Str"");
  final String dimension=request.getParameter(""String_Node_Str"");
  final String scope=request.getParameter(""String_Node_Str"");
  final String provider=request.getParameter(""String_Node_Str"");
  String value=request.getParameter(""String_Node_Str"");
  final String valueType=request.getParameter(""String_Node_Str"");
  Object o=null;
  try {
    if (valueType == null) {
      o=value;
    }
 else     if (""String_Node_Str"".equals(valueType)) {
      int i=Integer.parseInt(value);
      o=i;
    }
 else     if (""String_Node_Str"".equals(valueType)) {
      double d=Double.parseDouble(value);
      o=d;
    }
 else     if (""String_Node_Str"".equals(valueType)) {
      Date d=SimpleDateFormat.getDateTimeInstance().parse(value);
      o=d;
    }
  }
 catch (  Exception ex) {
    response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR,String.format(""String_Node_Str"",value,valueType,ex.toString()));
    return;
  }
  final Object typedVal=o;
  Ref<User> refu=ofy().load().type(User.class).filter(""String_Node_Str"",user).first();
  final Key<User> keyu;
  User u=refu.getValue();
  if (u != null) {
    keyu=refu.getKey();
  }
 else {
    u=new User();
    u.URI=user;
    keyu=ofy().save().entity(u).now();
  }
  ofy().transact(new VoidWork(){
    @Override public void vrun(){
      Ref<UserProfileEntry> refentry=ofy().load().type(UserProfileEntry.class).ancestor(keyu).filter(""String_Node_Str"",dimension).filter(""String_Node_Str"",scope).filter(""String_Node_Str"",provider).first();
      UserProfileEntry entry=refentry.getValue();
      if (entry == null) {
        entry=new UserProfileEntry();
        entry.user=keyu;
        entry.dimension=dimension;
        entry.provider=provider;
        entry.scope=scope;
      }
      entry.value=typedVal;
      ofy().save().entity(entry).now();
    }
  }
);
}","@Override public void doPut(HttpServletRequest request,HttpServletResponse response) throws IOException, ServletException {
  if (!isValidRequest(request)) {
    response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR,String.format(""String_Node_Str""));
    return;
  }
  final String user=request.getParameter(""String_Node_Str"");
  final String dimension=request.getParameter(""String_Node_Str"");
  final String scope=request.getParameter(""String_Node_Str"");
  final String provider=request.getParameter(""String_Node_Str"");
  String value=request.getParameter(""String_Node_Str"");
  final String valueType=request.getParameter(""String_Node_Str"");
  Object o=null;
  try {
    if (valueType == null || ""String_Node_Str"".equals(valueType)) {
      o=value;
    }
 else     if (""String_Node_Str"".equals(valueType)) {
      int i=Integer.parseInt(value);
      o=i;
    }
 else     if (""String_Node_Str"".equals(valueType)) {
      double d=Double.parseDouble(value);
      o=d;
    }
 else     if (""String_Node_Str"".equals(valueType)) {
      Date d=SimpleDateFormat.getDateTimeInstance().parse(value);
      o=d;
    }
 else {
      response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR,String.format(""String_Node_Str"",valueType));
      return;
    }
  }
 catch (  Exception ex) {
    response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR,String.format(""String_Node_Str"",value,valueType,ex.toString()));
    return;
  }
  final Object typedVal=o;
  Ref<User> refu=ofy().load().type(User.class).filter(""String_Node_Str"",user).first();
  final Key<User> keyu;
  User u=refu.getValue();
  if (u != null) {
    keyu=refu.getKey();
  }
 else {
    u=new User();
    u.URI=user;
    keyu=ofy().save().entity(u).now();
  }
  ofy().transact(new VoidWork(){
    @Override public void vrun(){
      Query<UserProfileEntry> query=ofy().load().type(UserProfileEntry.class).ancestor(keyu);
      if (dimension != null)       query=query.filter(""String_Node_Str"",dimension);
      if (scope != null)       query=query.filter(""String_Node_Str"",scope);
      if (provider != null)       query=query.filter(""String_Node_Str"",provider);
      Ref<UserProfileEntry> refentry=query.first();
      UserProfileEntry entry=refentry.getValue();
      if (entry == null) {
        entry=new UserProfileEntry();
        entry.user=keyu;
        entry.dimension=dimension;
        entry.provider=provider;
        entry.scope=scope;
      }
      entry.value=typedVal;
      ofy().save().entity(entry).now();
    }
  }
);
}"
88519,"@Override public void vrun(){
  Ref<UserProfileEntry> refentry=ofy().load().type(UserProfileEntry.class).ancestor(keyu).filter(""String_Node_Str"",dimension).filter(""String_Node_Str"",scope).filter(""String_Node_Str"",provider).first();
  UserProfileEntry entry=refentry.getValue();
  if (entry == null) {
    entry=new UserProfileEntry();
    entry.user=keyu;
    entry.dimension=dimension;
    entry.provider=provider;
    entry.scope=scope;
  }
  entry.value=typedVal;
  ofy().save().entity(entry).now();
}","@Override public void vrun(){
  Query<UserProfileEntry> query=ofy().load().type(UserProfileEntry.class).ancestor(keyu);
  if (dimension != null)   query=query.filter(""String_Node_Str"",dimension);
  if (scope != null)   query=query.filter(""String_Node_Str"",scope);
  if (provider != null)   query=query.filter(""String_Node_Str"",provider);
  Ref<UserProfileEntry> refentry=query.first();
  UserProfileEntry entry=refentry.getValue();
  if (entry == null) {
    entry=new UserProfileEntry();
    entry.user=keyu;
    entry.dimension=dimension;
    entry.provider=provider;
    entry.scope=scope;
  }
  entry.value=typedVal;
  ofy().save().entity(entry).now();
}"
88520,"public static String findRunner(IType testClass){
  IAnnotation annotation=testClass.getAnnotation(RunWith.class.getSimpleName());
  if (annotation != null && annotation.exists()) {
    try {
      for (      IMemberValuePair pair : annotation.getMemberValuePairs())       if (""String_Node_Str"".equals(pair.getMemberName()) && pair.getValue() instanceof String)       return getFQN(testClass.getCompilationUnit(),(String)pair.getValue());
    }
 catch (    JavaModelException e) {
      e.printStackTrace();
      return null;
    }
  }
  return null;
}","public static String findRunner(IType testClass){
  IAnnotation annotation=testClass.getAnnotation(RunWith.class.getSimpleName());
  if (annotation == null || !annotation.exists())   annotation=testClass.getAnnotation(RunWith.class.getName());
  if (annotation != null && annotation.exists()) {
    try {
      for (      IMemberValuePair pair : annotation.getMemberValuePairs())       if (""String_Node_Str"".equals(pair.getMemberName()) && pair.getValue() instanceof String)       return getFQN(testClass.getCompilationUnit(),(String)pair.getValue());
    }
 catch (    JavaModelException e) {
      e.printStackTrace();
      return null;
    }
  }
  return null;
}"
88521,"protected VarNode field(SootField f){
  return PaddleScene.v().nodeManager().findLocalVarNode(f);
}","protected VarNode field(SootField f){
  return PaddleScene.v().nodeManager().findGlobalVarNode(f);
}"
88522,"protected void processMethod(SootMethod source){
  MethodNodeFactory mnf=new MethodNodeFactory(source,gnf);
  final SootClass scl=source.getDeclaringClass();
  if (source.isNative() || source.isPhantom())   return;
  Body b=source.retrieveActiveBody();
  boolean warnedAlready=false;
  for (Iterator sIt=b.getUnits().iterator(); sIt.hasNext(); ) {
    final Stmt s=(Stmt)sIt.next();
    if (s.containsInvokeExpr()) {
      InvokeExpr ie=(InvokeExpr)s.getInvokeExpr();
      if (ie instanceof InstanceInvokeExpr) {
        Scene.v().getUnitNumberer().add(s);
        InstanceInvokeExpr iie=(InstanceInvokeExpr)ie;
        VarNode receiver=(VarNode)mnf.getNode(iie.getBase());
        if (ie instanceof SpecialInvokeExpr) {
          SootMethod tgt=VirtualCalls.v().resolveSpecial((SpecialInvokeExpr)ie,ie.getMethodRef().getSubSignature(),source);
          specials.add(receiver,source,s,tgt);
          change=true;
        }
 else {
          NumberedString subSig=iie.getMethodRef().getSubSignature();
          receivers.add(receiver,source,s,iie.getMethodRef().declaringClass().getType(),subSig,Edge.ieToKind(iie));
          change=true;
          if (subSig == sigStart) {
            receivers.add(receiver,source,s,iie.getMethodRef().declaringClass().getType(),sigRun,Kind.THREAD);
            change=true;
          }
        }
      }
 else {
        SootMethod tgt=((StaticInvokeExpr)ie).getMethod();
        addEdge(source,s,tgt);
        if (tgt.getSignature().equals(""String_Node_Str"") || tgt.getSignature().equals(""String_Node_Str"")) {
          VarNode receiver=(VarNode)mnf.getNode(ie.getArg(0));
          receivers.add(receiver,source,s,RefType.v(""String_Node_Str""),sigObjRun,Kind.PRIVILEGED);
          change=true;
        }
        if (tgt.getSignature().equals(""String_Node_Str"") || tgt.getSignature().equals(""String_Node_Str"")) {
          VarNode receiver=(VarNode)mnf.getNode(ie.getArg(0));
          receivers.add(receiver,source,s,RefType.v(""String_Node_Str""),sigObjRun,Kind.PRIVILEGED);
          change=true;
        }
      }
      if (ie.getMethod().getSignature().equals(""String_Node_Str"")) {
        if (!warnedAlready) {
          if (options.verbose()) {
            G.v().out.println(""String_Node_Str"" + ""String_Node_Str"" + source + ""String_Node_Str"");
          }
          warnedAlready=true;
        }
      }
      if (ie.getMethod().getSignature().equals(""String_Node_Str"")) {
        if (options.safe_newinstance()) {
          for (Iterator tgtIt=EntryPoints.v().inits().iterator(); tgtIt.hasNext(); ) {
            final SootMethod tgt=(SootMethod)tgtIt.next();
            addEdge(source,s,tgt,Kind.NEWINSTANCE);
          }
        }
 else {
          for (Iterator clsIt=Scene.v().dynamicClasses().iterator(); clsIt.hasNext(); ) {
            final SootClass cls=(SootClass)clsIt.next();
            if (cls.declaresMethod(sigInit)) {
              addEdge(source,s,cls.getMethod(sigInit),Kind.NEWINSTANCE);
            }
          }
          if (options.verbose() && Scene.v().dynamicClasses().isEmpty()) {
            G.v().out.println(""String_Node_Str"" + source + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
          }
        }
      }
      if (ie instanceof StaticInvokeExpr) {
        SootClass cl=ie.getMethodRef().declaringClass();
        for (Iterator clinitIt=EntryPoints.v().clinitsOf(cl).iterator(); clinitIt.hasNext(); ) {
          final SootMethod clinit=(SootMethod)clinitIt.next();
          addEdge(source,s,clinit,Kind.CLINIT);
        }
      }
      if (ie.getMethodRef().getSubSignature() == sigForName) {
        Value className=ie.getArg(0);
        if (className instanceof StringConstant) {
          String cls=((StringConstant)className).value;
          constantForName(cls,source,s);
        }
 else {
          VarNode constant=(VarNode)mnf.getNode(className);
          if (options.safe_forname()) {
            for (Iterator tgtIt=EntryPoints.v().clinits().iterator(); tgtIt.hasNext(); ) {
              final SootMethod tgt=(SootMethod)tgtIt.next();
              addEdge(source,s,tgt,Kind.CLINIT);
            }
          }
 else {
            receivers.add(constant,source,s,null,null,Kind.CLINIT);
            change=true;
          }
        }
      }
    }
    if (s.containsFieldRef()) {
      FieldRef fr=(FieldRef)s.getFieldRef();
      if (fr instanceof StaticFieldRef) {
        SootClass cl=fr.getFieldRef().declaringClass();
        for (Iterator clinitIt=EntryPoints.v().clinitsOf(cl).iterator(); clinitIt.hasNext(); ) {
          final SootMethod clinit=(SootMethod)clinitIt.next();
          addEdge(source,s,clinit,Kind.CLINIT);
        }
      }
    }
    if (s instanceof AssignStmt) {
      Value rhs=((AssignStmt)s).getRightOp();
      if (rhs instanceof NewExpr) {
        NewExpr r=(NewExpr)rhs;
        SootClass cl=r.getBaseType().getSootClass();
        for (Iterator clinitIt=EntryPoints.v().clinitsOf(cl).iterator(); clinitIt.hasNext(); ) {
          final SootMethod clinit=(SootMethod)clinitIt.next();
          addEdge(source,s,clinit,Kind.CLINIT);
        }
        while (true) {
          if (!cl.hasSuperclass())           break;
          if (cl.declaresMethod(sigFinalize)) {
            if (Scene.v().containsClass(""String_Node_Str"")) {
              addEdge(source,s,Scene.v().getSootClass(""String_Node_Str"").getMethod(sigRegister),Kind.FINALIZE);
            }
            break;
          }
          cl=cl.getSuperclass();
        }
      }
 else       if (rhs instanceof NewArrayExpr || rhs instanceof NewMultiArrayExpr) {
        Type t=rhs.getType();
        if (t instanceof ArrayType)         t=((ArrayType)t).baseType;
        if (t instanceof RefType) {
          SootClass cl=((RefType)t).getSootClass();
          for (Iterator clinitIt=EntryPoints.v().clinitsOf(cl).iterator(); clinitIt.hasNext(); ) {
            final SootMethod clinit=(SootMethod)clinitIt.next();
            addEdge(source,s,clinit,Kind.CLINIT);
          }
        }
      }
    }
  }
}","protected void processMethod(SootMethod source){
  MethodNodeFactory mnf=new MethodNodeFactory(source,gnf);
  final SootClass scl=source.getDeclaringClass();
  if (source.isNative() || source.isPhantom())   return;
  Body b=source.retrieveActiveBody();
  boolean warnedAlready=false;
  for (Iterator sIt=b.getUnits().iterator(); sIt.hasNext(); ) {
    final Stmt s=(Stmt)sIt.next();
    if (s.containsInvokeExpr()) {
      InvokeExpr ie=(InvokeExpr)s.getInvokeExpr();
      if (ie instanceof InstanceInvokeExpr) {
        Scene.v().getUnitNumberer().add(s);
        InstanceInvokeExpr iie=(InstanceInvokeExpr)ie;
        VarNode receiver=(VarNode)mnf.getNode(iie.getBase());
        if (ie instanceof SpecialInvokeExpr) {
          SootMethod tgt=VirtualCalls.v().resolveSpecial((SpecialInvokeExpr)ie,ie.getMethodRef().getSubSignature(),source);
          specials.add(receiver,source,s,tgt);
          change=true;
        }
 else {
          NumberedString subSig=iie.getMethodRef().getSubSignature();
          receivers.add(receiver,source,s,iie.getMethodRef().declaringClass().getType(),subSig,Edge.ieToKind(iie));
          change=true;
          if (subSig == sigStart) {
            receivers.add(receiver,source,s,iie.getMethodRef().declaringClass().getType(),sigRun,Kind.THREAD);
            change=true;
          }
        }
      }
 else {
        SootMethod tgt=((StaticInvokeExpr)ie).getMethod();
        addEdge(source,s,tgt);
        if (tgt.getSignature().equals(""String_Node_Str"") || tgt.getSignature().equals(""String_Node_Str"")) {
          VarNode receiver=(VarNode)mnf.getNode(ie.getArg(0));
          receivers.add(receiver,source,s,RefType.v(""String_Node_Str""),sigObjRun,Kind.PRIVILEGED);
          change=true;
        }
        if (tgt.getSignature().equals(""String_Node_Str"") || tgt.getSignature().equals(""String_Node_Str"")) {
          VarNode receiver=(VarNode)mnf.getNode(ie.getArg(0));
          receivers.add(receiver,source,s,RefType.v(""String_Node_Str""),sigObjRun,Kind.PRIVILEGED);
          change=true;
        }
      }
      if (ie.getMethod().getSignature().equals(""String_Node_Str"")) {
        if (!warnedAlready) {
          if (options.verbose()) {
            G.v().out.println(""String_Node_Str"" + ""String_Node_Str"" + source + ""String_Node_Str"");
          }
          warnedAlready=true;
        }
      }
      if (ie.getMethod().getSignature().equals(""String_Node_Str"")) {
        if (options.safe_newinstance()) {
          for (Iterator tgtIt=EntryPoints.v().inits().iterator(); tgtIt.hasNext(); ) {
            final SootMethod tgt=(SootMethod)tgtIt.next();
            addEdge(source,s,tgt,Kind.NEWINSTANCE);
          }
        }
 else {
          for (Iterator clsIt=Scene.v().dynamicClasses().iterator(); clsIt.hasNext(); ) {
            final SootClass cls=(SootClass)clsIt.next();
            if (cls.declaresMethod(sigInit)) {
              addEdge(source,s,cls.getMethod(sigInit),Kind.NEWINSTANCE);
            }
          }
          if (options.verbose() && Scene.v().dynamicClasses().isEmpty()) {
            G.v().out.println(""String_Node_Str"" + source + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
          }
        }
      }
      if (ie instanceof StaticInvokeExpr) {
        SootClass cl=ie.getMethodRef().declaringClass();
        for (Iterator clinitIt=EntryPoints.v().clinitsOf(cl).iterator(); clinitIt.hasNext(); ) {
          final SootMethod clinit=(SootMethod)clinitIt.next();
          addEdge(source,s,clinit,Kind.CLINIT);
        }
      }
      if (ie.getMethodRef().getSubSignature() == sigForName) {
        Value className=ie.getArg(0);
        if (className instanceof StringConstant) {
          String cls=((StringConstant)className).value;
          constantForName(cls,source,s);
        }
 else {
          VarNode constant=(VarNode)mnf.getNode(className);
          if (options.safe_forname()) {
            for (Iterator tgtIt=EntryPoints.v().clinits().iterator(); tgtIt.hasNext(); ) {
              final SootMethod tgt=(SootMethod)tgtIt.next();
              addEdge(source,s,tgt,Kind.CLINIT);
            }
          }
 else {
            receivers.add(constant,source,s,null,null,Kind.CLINIT);
            change=true;
          }
        }
      }
    }
    if (s.containsFieldRef()) {
      FieldRef fr=(FieldRef)s.getFieldRef();
      if (fr instanceof StaticFieldRef) {
        SootClass cl=fr.getFieldRef().declaringClass();
        for (Iterator clinitIt=EntryPoints.v().clinitsOf(cl).iterator(); clinitIt.hasNext(); ) {
          final SootMethod clinit=(SootMethod)clinitIt.next();
          addEdge(source,s,clinit,Kind.CLINIT);
        }
      }
    }
    if (s instanceof AssignStmt) {
      Value rhs=((AssignStmt)s).getRightOp();
      if (rhs instanceof NewExpr) {
        NewExpr r=(NewExpr)rhs;
        SootClass cl=r.getBaseType().getSootClass();
        for (Iterator clinitIt=EntryPoints.v().clinitsOf(cl).iterator(); clinitIt.hasNext(); ) {
          final SootMethod clinit=(SootMethod)clinitIt.next();
          addEdge(source,s,clinit,Kind.CLINIT);
        }
        while (true) {
          if (!cl.hasSuperclass())           break;
          if (cl.declaresMethod(sigFinalize)) {
            if (Scene.v().containsClass(""String_Node_Str"")) {
              addEdge(source,s,Scene.v().getSootClass(""String_Node_Str"").getMethod(sigRegister),Kind.FINALIZE);
            }
            break;
          }
          cl=cl.getSuperclass();
        }
      }
    }
  }
}"
88523,"final public void caseNewExpr(NewExpr ne){
  if (PaddleScene.v().options().merge_stringbuffer() && ne.getType().equals(RefType.v(""String_Node_Str""))) {
    setResult(nm.makeGlobalAllocNode(ne.getType(),ne.getType()));
  }
 else {
    setResult(makeAllocNode(ne,ne.getType(),method));
  }
}","final public void caseNewExpr(NewExpr ne){
  if (PaddleScene.v().options().merge_stringbuffer() && isStringBuffer(ne.getType())) {
    setResult(nm.makeGlobalAllocNode(ne.getType(),ne.getType()));
  }
 else {
    setResult(makeAllocNode(ne,ne.getType(),method));
  }
}"
88524,"private void handleStringConstants(Rvarc_var_objc_obj.Tuple ptpair,Rvar_srcm_stmt_dtp_signature_kind.Tuple site){
  if (!(ptpair.obj() instanceof StringConstantNode)) {
    for (Iterator clsIt=Scene.v().dynamicClasses().iterator(); clsIt.hasNext(); ) {
      final SootClass cls=(SootClass)clsIt.next();
      for (Iterator clinitIt=EntryPoints.v().clinitsOf(cls).iterator(); clinitIt.hasNext(); ) {
        final SootMethod clinit=(SootMethod)clinitIt.next();
        change=true;
        statics.add(ptpair.varc(),site.srcm(),site.stmt(),Kind.CLINIT,null,clinit);
      }
    }
    if (PaddleScene.v().options().verbose() && Scene.v().dynamicClasses().isEmpty()) {
      if (warnedAlready.add(site.srcm())) {
        G.v().out.println(""String_Node_Str"" + site.srcm() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      }
    }
  }
 else {
    StringConstantNode scn=(StringConstantNode)ptpair.obj();
    String constant=scn.getString();
    if (constant.charAt(0) == '[') {
      if (constant.length() > 1 && constant.charAt(1) == 'L' && constant.charAt(constant.length() - 1) == ';') {
        constant=constant.substring(2,constant.length() - 1);
      }
 else       return;
    }
    if (!Scene.v().containsClass(constant)) {
      if (PaddleScene.v().options().verbose()) {
        G.v().out.println(""String_Node_Str"" + constant + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      }
    }
 else {
      SootClass sootcls=Scene.v().getSootClass(constant);
      if (!sootcls.isApplicationClass()) {
        sootcls.setLibraryClass();
      }
      for (Iterator clinitIt=EntryPoints.v().clinitsOf(sootcls).iterator(); clinitIt.hasNext(); ) {
        final SootMethod clinit=(SootMethod)clinitIt.next();
        change=true;
        statics.add(ptpair.varc(),site.srcm(),site.stmt(),Kind.CLINIT,null,clinit);
      }
    }
  }
}","private void handleStringConstants(Rvarc_var_objc_obj.Tuple ptpair,Rvar_srcm_stmt_dtp_signature_kind.Tuple site){
  if (!(ptpair.obj() instanceof StringConstantNode)) {
    for (Iterator clsIt=Scene.v().dynamicClasses().iterator(); clsIt.hasNext(); ) {
      final SootClass cls=(SootClass)clsIt.next();
      for (Iterator clinitIt=EntryPoints.v().clinitsOf(cls).iterator(); clinitIt.hasNext(); ) {
        final SootMethod clinit=(SootMethod)clinitIt.next();
        change=true;
        statics.add(ptpair.varc(),site.srcm(),site.stmt(),Kind.CLINIT,null,clinit);
      }
    }
    if (PaddleScene.v().options().verbose() && Scene.v().dynamicClasses().isEmpty()) {
      if (warnedAlready.add(site.srcm())) {
        G.v().out.println(""String_Node_Str"" + site.srcm() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      }
    }
  }
 else {
    StringConstantNode scn=(StringConstantNode)ptpair.obj();
    String constant=scn.getString();
    if (constant.length() > 0 && constant.charAt(0) == '[') {
      if (constant.length() > 1 && constant.charAt(1) == 'L' && constant.charAt(constant.length() - 1) == ';') {
        constant=constant.substring(2,constant.length() - 1);
      }
 else       return;
    }
    if (!Scene.v().containsClass(constant)) {
      if (PaddleScene.v().options().verbose()) {
        G.v().out.println(""String_Node_Str"" + constant + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      }
    }
 else {
      SootClass sootcls=Scene.v().getSootClass(constant);
      if (!sootcls.isApplicationClass()) {
        sootcls.setLibraryClass();
      }
      for (Iterator clinitIt=EntryPoints.v().clinitsOf(sootcls).iterator(); clinitIt.hasNext(); ) {
        final SootMethod clinit=(SootMethod)clinitIt.next();
        change=true;
        statics.add(ptpair.varc(),site.srcm(),site.stmt(),Kind.CLINIT,null,clinit);
      }
    }
  }
}"
88525,"private void addAlloc(Context objc,AllocNode obj,Context varc,VarNode var){
  if (obj instanceof GlobalAllocNode)   objc=null;
  if (var instanceof GlobalVarNode)   varc=null;
  calloc.add(objc,obj,varc,var);
}","private void addAlloc(Context objc,AllocNode obj,Context varc,VarNode var){
  boolean contextHeap=PaddleScene.v().options().context_heap();
  if (obj instanceof GlobalAllocNode || !contextHeap)   objc=null;
  if (var instanceof GlobalVarNode)   varc=null;
  calloc.add(objc,obj,varc,var);
}"
88526,"public boolean update(){
  boolean contextHeap=PaddleScene.v().options().context_heap();
  boolean change=false;
  for (Iterator tIt=simple.iterator(); tIt.hasNext(); ) {
    final Rsrc_dst.Tuple t=(Rsrc_dst.Tuple)tIt.next();
    if (ni.global(t.src())) {
      if (ni.global(t.dst())) {
        addSimple(null,t.src(),null,t.dst());
        change=true;
      }
 else {
        mpag(ni.method(t.dst())).simple.add(t);
      }
    }
 else {
      if (ni.global(t.dst())) {
        mpag(ni.method(t.src())).simple.add(t);
      }
 else {
        SootMethod m=ni.method(t.src());
        if (m != ni.method(t.dst()))         throw new RuntimeException(t.toString());
        mpag(m).simple.add(t);
      }
    }
  }
  for (Iterator tIt=store.iterator(); tIt.hasNext(); ) {
    final Rsrc_dst_fld.Tuple t=(Rsrc_dst_fld.Tuple)tIt.next();
    if (ni.global(t.src())) {
      if (ni.global(t.dst())) {
        addStore(null,t.src(),t.fld(),null,t.dst());
        change=true;
      }
 else {
        mpag(ni.method(t.dst())).store.add(t);
      }
    }
 else {
      if (ni.global(t.dst())) {
        mpag(ni.method(t.src())).store.add(t);
      }
 else {
        SootMethod m=ni.method(t.src());
        if (m != ni.method(t.dst()))         throw new RuntimeException(t.toString());
        mpag(m).store.add(t);
      }
    }
  }
  for (Iterator tIt=load.iterator(); tIt.hasNext(); ) {
    final Rsrc_fld_dst.Tuple t=(Rsrc_fld_dst.Tuple)tIt.next();
    if (ni.global(t.src())) {
      if (ni.global(t.dst())) {
        addLoad(null,t.src(),t.fld(),null,t.dst());
        change=true;
      }
 else {
        mpag(ni.method(t.dst())).load.add(t);
      }
    }
 else {
      if (ni.global(t.dst())) {
        mpag(ni.method(t.src())).load.add(t);
      }
 else {
        SootMethod m=ni.method(t.src());
        if (m != ni.method(t.dst()))         throw new RuntimeException(t.toString());
        mpag(m).load.add(t);
      }
    }
  }
  for (Iterator tIt=alloc.iterator(); tIt.hasNext(); ) {
    final Robj_var.Tuple t=(Robj_var.Tuple)tIt.next();
    if (!contextHeap || ni.global(t.obj())) {
      if (ni.global(t.var())) {
        addAlloc(null,t.obj(),null,t.var());
        change=true;
      }
 else {
        mpag(ni.method(t.var())).alloc.add(t);
      }
    }
 else {
      if (ni.global(t.var())) {
        mpag(ni.method(t.obj())).alloc.add(t);
      }
 else {
        SootMethod m=ni.method(t.obj());
        if (m != ni.method(t.var()))         throw new RuntimeException(t.toString());
        mpag(m).alloc.add(t);
      }
    }
  }
  for (Iterator tIt=rcout.iterator(); tIt.hasNext(); ) {
    final Rctxt_method.Tuple t=(Rctxt_method.Tuple)tIt.next();
    MethodPAG mpag=mpag(t.method());
    for (Iterator eIt=mpag.rsimple.copy().iterator(); eIt.hasNext(); ) {
      final Rsrc_dst.Tuple e=(Rsrc_dst.Tuple)eIt.next();
      addSimple(t.ctxt(),e.src(),t.ctxt(),e.dst());
      change=true;
    }
    for (Iterator eIt=mpag.rstore.copy().iterator(); eIt.hasNext(); ) {
      final Rsrc_dst_fld.Tuple e=(Rsrc_dst_fld.Tuple)eIt.next();
      addStore(t.ctxt(),e.src(),e.fld(),t.ctxt(),e.dst());
      change=true;
    }
    for (Iterator eIt=mpag.rload.copy().iterator(); eIt.hasNext(); ) {
      final Rsrc_fld_dst.Tuple e=(Rsrc_fld_dst.Tuple)eIt.next();
      addLoad(t.ctxt(),e.src(),e.fld(),t.ctxt(),e.dst());
      change=true;
    }
    for (Iterator eIt=mpag.ralloc.copy().iterator(); eIt.hasNext(); ) {
      final Robj_var.Tuple e=(Robj_var.Tuple)eIt.next();
      addAlloc(t.ctxt(),e.obj(),t.ctxt(),e.var());
      change=true;
    }
  }
  return change;
}","public boolean update(){
  boolean contextHeap=PaddleScene.v().options().context_heap();
  boolean change=false;
  for (Iterator tIt=simple.iterator(); tIt.hasNext(); ) {
    final Rsrc_dst.Tuple t=(Rsrc_dst.Tuple)tIt.next();
    if (ni.global(t.src())) {
      if (ni.global(t.dst())) {
        addSimple(null,t.src(),null,t.dst());
        change=true;
      }
 else {
        mpag(ni.method(t.dst())).simple.add(t);
      }
    }
 else {
      if (ni.global(t.dst())) {
        mpag(ni.method(t.src())).simple.add(t);
      }
 else {
        SootMethod m=ni.method(t.src());
        if (m != ni.method(t.dst()))         throw new RuntimeException(t.toString());
        mpag(m).simple.add(t);
      }
    }
  }
  for (Iterator tIt=store.iterator(); tIt.hasNext(); ) {
    final Rsrc_dst_fld.Tuple t=(Rsrc_dst_fld.Tuple)tIt.next();
    if (ni.global(t.src())) {
      if (ni.global(t.dst())) {
        addStore(null,t.src(),t.fld(),null,t.dst());
        change=true;
      }
 else {
        mpag(ni.method(t.dst())).store.add(t);
      }
    }
 else {
      if (ni.global(t.dst())) {
        mpag(ni.method(t.src())).store.add(t);
      }
 else {
        SootMethod m=ni.method(t.src());
        if (m != ni.method(t.dst()))         throw new RuntimeException(t.toString());
        mpag(m).store.add(t);
      }
    }
  }
  for (Iterator tIt=load.iterator(); tIt.hasNext(); ) {
    final Rsrc_fld_dst.Tuple t=(Rsrc_fld_dst.Tuple)tIt.next();
    if (ni.global(t.src())) {
      if (ni.global(t.dst())) {
        addLoad(null,t.src(),t.fld(),null,t.dst());
        change=true;
      }
 else {
        mpag(ni.method(t.dst())).load.add(t);
      }
    }
 else {
      if (ni.global(t.dst())) {
        mpag(ni.method(t.src())).load.add(t);
      }
 else {
        SootMethod m=ni.method(t.src());
        if (m != ni.method(t.dst()))         throw new RuntimeException(t.toString());
        mpag(m).load.add(t);
      }
    }
  }
  for (Iterator tIt=alloc.iterator(); tIt.hasNext(); ) {
    final Robj_var.Tuple t=(Robj_var.Tuple)tIt.next();
    if (!contextHeap || ni.global(t.obj())) {
      if (ni.global(t.var())) {
        addAlloc(null,t.obj(),null,t.var());
        change=true;
      }
 else {
        mpag(ni.method(t.var())).alloc.add(t);
      }
    }
 else {
      if (ni.global(t.var())) {
        mpag(ni.method(t.obj())).alloc.add(t);
      }
 else {
        SootMethod m=ni.method(t.obj());
        if (m != ni.method(t.var()))         throw new RuntimeException(t.toString());
        mpag(m).alloc.add(t);
      }
    }
  }
  for (Iterator tIt=rcout.iterator(); tIt.hasNext(); ) {
    final Rctxt_method.Tuple t=(Rctxt_method.Tuple)tIt.next();
    MethodPAG mpag=mpag(t.method());
    for (Iterator eIt=mpag.rsimple.copy().iterator(); eIt.hasNext(); ) {
      final Rsrc_dst.Tuple e=(Rsrc_dst.Tuple)eIt.next();
      addSimple(t.ctxt(),e.src(),t.ctxt(),e.dst());
      change=true;
    }
    for (Iterator eIt=mpag.rstore.copy().iterator(); eIt.hasNext(); ) {
      final Rsrc_dst_fld.Tuple e=(Rsrc_dst_fld.Tuple)eIt.next();
      addStore(t.ctxt(),e.src(),e.fld(),t.ctxt(),e.dst());
      change=true;
    }
    for (Iterator eIt=mpag.rload.copy().iterator(); eIt.hasNext(); ) {
      final Rsrc_fld_dst.Tuple e=(Rsrc_fld_dst.Tuple)eIt.next();
      addLoad(t.ctxt(),e.src(),e.fld(),t.ctxt(),e.dst());
      change=true;
    }
    for (Iterator eIt=mpag.ralloc.copy().iterator(); eIt.hasNext(); ) {
      final Robj_var.Tuple e=(Robj_var.Tuple)eIt.next();
      if (contextHeap || ni.global(e.obj())) {
        addAlloc(t.ctxt(),e.obj(),t.ctxt(),e.var());
      }
 else {
        addAlloc(null,e.obj(),t.ctxt(),e.var());
      }
      change=true;
    }
  }
  return change;
}"
88527,"/** 
 * Utility method used in the construction of   {@link UnitGraph}variants which include exceptional control flow. It determines the possible exceptions which each   {@link Unit} might throwand the set of traps which might catch those exceptions.
 * @param throwAnalysis The source of information about whichexceptions each <code>Unit</code> may throw.
 * @return A {@link Map} from <code>Unit</code>s to {@link Collection}s of  {@link ExceptionDest}s. Each <code>ExceptionDest</code> associated with a <code>Unit</code> includes a   {@link ThrowableSet} specifying exceptions that the<code>Unit</code> might throw and a  {@link Trap}specifying the handler which catches those exceptions (if the <code>Trap</code> is <code>null</code>, those exceptions escape the method without being caught).
 */
protected Map buildExceptionDests(ThrowAnalysis throwAnalysis){
class TrapRecord {
    Trap trap;
    RefType caughtType;
    boolean active;
    TrapRecord(    Trap trap){
      this.trap=trap;
      this.caughtType=RefType.v(trap.getException());
      active=false;
    }
  }
  TrapRecord[] trapTable=new TrapRecord[body.getTraps().size()];
  int trapIndex=0;
  for (Iterator trapIt=body.getTraps().iterator(); trapIt.hasNext(); trapIndex++) {
    Trap trap=(Trap)trapIt.next();
    trapTable[trapIndex]=new TrapRecord(trap);
  }
  Map unitToExceptionDests=new HashMap(unitChain.size() * 2 + 1,0.7f);
  FastHierarchy hier=Scene.v().getOrMakeFastHierarchy();
  for (Iterator unitIt=unitChain.iterator(); unitIt.hasNext(); ) {
    Unit u=(Unit)unitIt.next();
    for (int i=0; i < trapTable.length; i++) {
      if (trapTable[i].trap.getBeginUnit() == u) {
        trapTable[i].active=true;
      }
      if (trapTable[i].trap.getEndUnit() == u) {
        trapTable[i].active=false;
      }
    }
    UnitDestsMap unitDests=new UnitDestsMap();
    ThrowableSet thrownSet=throwAnalysis.mightThrow(u);
    nextThrowable:     for (Iterator i=thrownSet.types().iterator(); i.hasNext(); ) {
      RefLikeType thrown=(RefLikeType)i.next();
      if (thrown instanceof RefType) {
        RefType thrownType=(RefType)thrown;
        for (int j=0; j < trapTable.length; j++) {
          if (trapTable[j].active) {
            Trap trap=trapTable[j].trap;
            RefType caughtType=trapTable[j].caughtType;
            if (hier.canStoreType(thrownType,caughtType)) {
              unitDests.add(trap,thrownType);
              continue nextThrowable;
            }
          }
        }
        unitDests.add(null,thrownType);
      }
 else       if (thrown instanceof AnySubType) {
        AnySubType thrownType=(AnySubType)thrown;
        RefType thrownBase=thrownType.getBase();
        List alreadyCaught=new ArrayList();
        for (int j=0; j < trapTable.length; j++) {
          if (trapTable[j].active) {
            Trap trap=trapTable[j].trap;
            RefType caughtType=trapTable[j].caughtType;
            if (hier.canStoreType(thrownBase,caughtType)) {
              unitDests.add(trap,AnySubType.v(thrownBase));
              continue nextThrowable;
            }
 else             if (hier.canStoreType(caughtType,thrownBase)) {
              for (Iterator k=alreadyCaught.iterator(); k.hasNext(); ) {
                RefType alreadyType=(RefType)k.next();
                if (hier.canStoreType(caughtType,alreadyType)) {
                  continue nextThrowable;
                }
              }
              unitDests.add(trap,AnySubType.v(caughtType));
              alreadyCaught.add(caughtType);
            }
          }
        }
        unitDests.add(null,thrownType);
      }
 else {
        throw new RuntimeException(""String_Node_Str"" + thrown.toString() + ""String_Node_Str"");
      }
    }
    unitToExceptionDests.put(u,unitDests.values());
  }
  return unitToExceptionDests;
}","/** 
 * Utility method used in the construction of   {@link UnitGraph}variants which include exceptional control flow. It determines the possible exceptions which each   {@link Unit} might throwand the set of traps which might catch those exceptions.
 * @param throwAnalysis The source of information about whichexceptions each <code>Unit</code> may throw.
 * @return A {@link Map} from <code>Unit</code>s to {@link Collection}s of  {@link ExceptionDest}s. Each <code>ExceptionDest</code> associated with a <code>Unit</code> includes a   {@link ThrowableSet} specifying exceptions that the<code>Unit</code> might throw and a  {@link Trap}specifying the handler which catches those exceptions (if the <code>Trap</code> is <code>null</code>, those exceptions escape the method without being caught).
 */
protected Map buildExceptionDests(ThrowAnalysis throwAnalysis){
class TrapRecord {
    Trap trap;
    RefType caughtType;
    boolean active;
    TrapRecord(    Trap trap){
      this.trap=trap;
      this.caughtType=RefType.v(trap.getException());
      active=false;
    }
  }
  TrapRecord[] trapTable=new TrapRecord[body.getTraps().size()];
  int trapIndex=0;
  for (Iterator trapIt=body.getTraps().iterator(); trapIt.hasNext(); trapIndex++) {
    Trap trap=(Trap)trapIt.next();
    trapTable[trapIndex]=new TrapRecord(trap);
  }
  Map unitToExceptionDests=new HashMap(unitChain.size() * 2 + 1,0.7f);
  FastHierarchy hier=Scene.v().getOrMakeFastHierarchy();
  for (Iterator unitIt=unitChain.iterator(); unitIt.hasNext(); ) {
    Unit u=(Unit)unitIt.next();
    for (int i=0; i < trapTable.length; i++) {
      if (trapTable[i].trap.getBeginUnit() == u) {
        trapTable[i].active=true;
      }
      if (trapTable[i].trap.getEndUnit() == u) {
        trapTable[i].active=false;
      }
    }
    UnitDestsMap unitDests=new UnitDestsMap();
    ThrowableSet thrownSet=throwAnalysis.mightThrow(u);
    nextThrowable:     for (Iterator i=thrownSet.types().iterator(); i.hasNext(); ) {
      RefLikeType thrown=(RefLikeType)i.next();
      if (thrown instanceof RefType) {
        RefType thrownType=(RefType)thrown;
        for (int j=0; j < trapTable.length; j++) {
          if (trapTable[j].active) {
            Trap trap=trapTable[j].trap;
            RefType caughtType=trapTable[j].caughtType;
            if (hier.canStoreType(thrownType,caughtType)) {
              unitDests.add(trap,thrownType);
              continue nextThrowable;
            }
          }
        }
        unitDests.add(null,thrownType);
      }
 else       if (thrown instanceof AnySubType) {
        AnySubType thrownType=(AnySubType)thrown;
        RefType thrownBase=thrownType.getBase();
        List alreadyCaught=new ArrayList();
        nextTrap:         for (int j=0; j < trapTable.length; j++) {
          if (trapTable[j].active) {
            Trap trap=trapTable[j].trap;
            RefType caughtType=trapTable[j].caughtType;
            if (hier.canStoreType(thrownBase,caughtType)) {
              unitDests.add(trap,AnySubType.v(thrownBase));
              continue nextThrowable;
            }
 else             if (hier.canStoreType(caughtType,thrownBase)) {
              for (Iterator k=alreadyCaught.iterator(); k.hasNext(); ) {
                RefType alreadyType=(RefType)k.next();
                if (hier.canStoreType(caughtType,alreadyType)) {
                  continue nextTrap;
                }
              }
              unitDests.add(trap,AnySubType.v(caughtType));
              alreadyCaught.add(caughtType);
            }
          }
        }
        unitDests.add(null,thrownType);
      }
 else {
        throw new RuntimeException(""String_Node_Str"" + thrown.toString() + ""String_Node_Str"");
      }
    }
    unitToExceptionDests.put(u,unitDests.values());
  }
  return unitToExceptionDests;
}"
88528,"/** 
 * create ArrayInit given init and the array local
 */
private soot.Local getArrayInitLocal(polyglot.ast.ArrayInit arrInit,polyglot.types.Type lhsType){
  soot.Local local=generateLocal(lhsType);
  soot.jimple.NewArrayExpr arrExpr=soot.jimple.Jimple.v().newNewArrayExpr(((soot.ArrayType)local.getType()).getElementType(),soot.jimple.IntConstant.v(arrInit.elements().size()));
  soot.jimple.Stmt assign=soot.jimple.Jimple.v().newAssignStmt(local,arrExpr);
  body.getUnits().add(assign);
  Util.addLnPosTags(assign,arrInit.position());
  Iterator it=arrInit.elements().iterator();
  int index=0;
  while (it.hasNext()) {
    polyglot.ast.Expr elemExpr=(polyglot.ast.Expr)it.next();
    soot.Value elem;
    if (elemExpr instanceof polyglot.ast.ArrayInit) {
      if (((polyglot.ast.ArrayInit)elemExpr).type() instanceof polyglot.types.NullType) {
        if (lhsType instanceof polyglot.types.ArrayType) {
          elem=getArrayInitLocal((polyglot.ast.ArrayInit)elemExpr,((polyglot.types.ArrayType)lhsType).base());
        }
 else {
          elem=getArrayInitLocal((polyglot.ast.ArrayInit)elemExpr,lhsType);
        }
      }
 else {
        elem=getArrayInitLocal((polyglot.ast.ArrayInit)elemExpr,((polyglot.ast.ArrayInit)elemExpr).type());
      }
    }
 else {
      elem=base().createExpr(elemExpr);
    }
    soot.jimple.ArrayRef arrRef=soot.jimple.Jimple.v().newArrayRef(local,soot.jimple.IntConstant.v(index));
    soot.jimple.AssignStmt elemAssign=soot.jimple.Jimple.v().newAssignStmt(arrRef,elem);
    body.getUnits().add(elemAssign);
    Util.addLnPosTags(elemAssign,elemExpr.position());
    Util.addLnPosTags(elemAssign.getRightOpBox(),elemExpr.position());
    index++;
  }
  return local;
}","/** 
 * create ArrayInit given init and the array local
 */
private soot.Local getArrayInitLocal(polyglot.ast.ArrayInit arrInit,polyglot.types.Type lhsType){
  soot.Local local=generateLocal(lhsType);
  soot.jimple.NewArrayExpr arrExpr=soot.jimple.Jimple.v().newNewArrayExpr(((soot.ArrayType)local.getType()).getElementType(),soot.jimple.IntConstant.v(arrInit.elements().size()));
  soot.jimple.Stmt assign=soot.jimple.Jimple.v().newAssignStmt(local,arrExpr);
  body.getUnits().add(assign);
  Util.addLnPosTags(assign,arrInit.position());
  Iterator it=arrInit.elements().iterator();
  int index=0;
  while (it.hasNext()) {
    polyglot.ast.Expr elemExpr=(polyglot.ast.Expr)it.next();
    soot.Value elem;
    if (elemExpr instanceof polyglot.ast.ArrayInit) {
      if (((polyglot.ast.ArrayInit)elemExpr).type() instanceof polyglot.types.NullType) {
        if (lhsType instanceof polyglot.types.ArrayType) {
          elem=getArrayInitLocal((polyglot.ast.ArrayInit)elemExpr,((polyglot.types.ArrayType)lhsType).base());
        }
 else {
          elem=getArrayInitLocal((polyglot.ast.ArrayInit)elemExpr,lhsType);
        }
      }
 else {
        elem=getArrayInitLocal((polyglot.ast.ArrayInit)elemExpr,((polyglot.types.ArrayType)lhsType).base());
      }
    }
 else {
      elem=base().createExpr(elemExpr);
    }
    soot.jimple.ArrayRef arrRef=soot.jimple.Jimple.v().newArrayRef(local,soot.jimple.IntConstant.v(index));
    soot.jimple.AssignStmt elemAssign=soot.jimple.Jimple.v().newAssignStmt(arrRef,elem);
    body.getUnits().add(elemAssign);
    Util.addLnPosTags(elemAssign,elemExpr.position());
    Util.addLnPosTags(elemAssign.getRightOpBox(),elemExpr.position());
    index++;
  }
  return local;
}"
88529,"protected void internalTransform(Body b,String phaseName,Map options){
  ReachableMethods reachableMethods=Scene.v().getReachableMethods();
  SootMethod method=b.getMethod();
  if (reachableMethods.contains(method))   return;
  JimpleBody body=(JimpleBody)method.getActiveBody();
  Chain units=body.getUnits();
  List list=new Vector();
  Local tmpRef=Jimple.v().newLocal(""String_Node_Str"",RefType.v(""String_Node_Str""));
  body.getLocals().add(tmpRef);
  list.add(Jimple.v().newAssignStmt(tmpRef,Jimple.v().newStaticFieldRef(Scene.v().getField(""String_Node_Str"").makeRef())));
  SootMethod toCall=Scene.v().getMethod(""String_Node_Str"");
  list.add(Jimple.v().newInvokeStmt(Jimple.v().newStaticInvokeExpr(toCall.makeRef())));
  toCall=Scene.v().getMethod(""String_Node_Str"");
  list.add(Jimple.v().newInvokeStmt(Jimple.v().newVirtualInvokeExpr(tmpRef,toCall.makeRef(),StringConstant.v(""String_Node_Str""))));
  list.add(Jimple.v().newInvokeStmt(Jimple.v().newVirtualInvokeExpr(tmpRef,toCall.makeRef(),StringConstant.v(""String_Node_Str"" + method.getDeclaringClass().getName() + ""String_Node_Str""+ method.getName()))));
  toCall=Scene.v().getMethod(""String_Node_Str"");
  list.add(Jimple.v().newInvokeStmt(Jimple.v().newStaticInvokeExpr(toCall.makeRef(),IntConstant.v(1))));
  if (method.getReturnType() instanceof VoidType) {
    list.add(Jimple.v().newReturnVoidStmt());
  }
 else   if (method.getReturnType() instanceof RefLikeType) {
    list.add(Jimple.v().newReturnStmt(NullConstant.v()));
  }
 else   if (method.getReturnType() instanceof PrimType) {
    if (method.getReturnType() instanceof DoubleType) {
      list.add(Jimple.v().newReturnStmt(DoubleConstant.v(0)));
    }
 else     if (method.getReturnType() instanceof LongType) {
      list.add(Jimple.v().newReturnStmt(LongConstant.v(0)));
    }
 else     if (method.getReturnType() instanceof FloatType) {
      list.add(Jimple.v().newReturnStmt(FloatConstant.v(0)));
    }
 else {
      list.add(Jimple.v().newReturnStmt(IntConstant.v(0)));
    }
  }
 else {
    System.out.println(""String_Node_Str"" + method.getReturnType());
  }
  if (method.getName().equals(""String_Node_Str"") || method.getName().equals(""String_Node_Str"")) {
    Object o=units.getFirst();
    boolean insertFirst=false;
    while (true) {
      if (o == null) {
        insertFirst=true;
        break;
      }
      if (o instanceof JInvokeStmt) {
        JInvokeStmt stmt=(JInvokeStmt)o;
        if ((stmt.getInvokeExpr() instanceof SpecialInvokeExpr)) {
          break;
        }
      }
      o=units.getSuccOf(o);
    }
    if (insertFirst) {
      units.insertBefore(list,units.getFirst());
    }
 else {
      units.insertAfter(list,o);
    }
  }
 else {
    units.insertBefore(list,units.getFirst());
  }
}","protected void internalTransform(Body b,String phaseName,Map options){
  ReachableMethods reachableMethods=Scene.v().getReachableMethods();
  SootMethod method=b.getMethod();
  if (reachableMethods.contains(method))   return;
  JimpleBody body=(JimpleBody)method.getActiveBody();
  PatchingChain units=(PatchingChain)body.getUnits();
  List list=new Vector();
  Local tmpRef=Jimple.v().newLocal(""String_Node_Str"",RefType.v(""String_Node_Str""));
  body.getLocals().add(tmpRef);
  list.add(Jimple.v().newAssignStmt(tmpRef,Jimple.v().newStaticFieldRef(Scene.v().getField(""String_Node_Str"").makeRef())));
  SootMethod toCall=Scene.v().getMethod(""String_Node_Str"");
  list.add(Jimple.v().newInvokeStmt(Jimple.v().newStaticInvokeExpr(toCall.makeRef())));
  toCall=Scene.v().getMethod(""String_Node_Str"");
  list.add(Jimple.v().newInvokeStmt(Jimple.v().newVirtualInvokeExpr(tmpRef,toCall.makeRef(),StringConstant.v(""String_Node_Str""))));
  list.add(Jimple.v().newInvokeStmt(Jimple.v().newVirtualInvokeExpr(tmpRef,toCall.makeRef(),StringConstant.v(""String_Node_Str"" + method.getDeclaringClass().getName() + ""String_Node_Str""+ method.getName()))));
  toCall=Scene.v().getMethod(""String_Node_Str"");
  list.add(Jimple.v().newInvokeStmt(Jimple.v().newStaticInvokeExpr(toCall.makeRef(),IntConstant.v(1))));
{
    units.insertBefore(list,units.getFirst());
  }
}"
88530,"public boolean update(){
  final jedd.internal.RelationContainer simpleOut=new jedd.internal.RelationContainer(new jedd.Attribute[]{srcc.v(),src.v(),dstc.v(),dst.v()},new jedd.PhysicalDomain[]{C1.v(),V1.v(),C2.v(),V2.v()},(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""),jedd.internal.Jedd.v().falseBDD());
  allParms.eqUnion(parms.get());
  allRets.eqUnion(rets.get());
  final jedd.internal.RelationContainer newCalls=new jedd.internal.RelationContainer(new jedd.Attribute[]{srcc.v(),srcm.v(),stmt.v(),kind.v(),tgtc.v(),tgtm.v()},new jedd.PhysicalDomain[]{C2.v(),MS.v(),ST.v(),KD.v(),C1.v(),MT.v()},(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""),jedd.internal.Jedd.v().replace(calls.get(),new jedd.PhysicalDomain[]{C1.v(),C2.v()},new jedd.PhysicalDomain[]{C2.v(),C1.v()}));
  simpleOut.eqUnion(jedd.internal.Jedd.v().compose(jedd.internal.Jedd.v().read(jedd.internal.Jedd.v().replace(newCalls,new jedd.PhysicalDomain[]{C2.v(),C1.v()},new jedd.PhysicalDomain[]{C1.v(),C2.v()})),allParms,new jedd.PhysicalDomain[]{MS.v(),ST.v(),KD.v(),MT.v()}));
  simpleOut.eqUnion(jedd.internal.Jedd.v().compose(jedd.internal.Jedd.v().read(newCalls),allRets,new jedd.PhysicalDomain[]{MS.v(),ST.v(),KD.v(),MT.v()}));
  final jedd.internal.RelationContainer globalDsts=new jedd.internal.RelationContainer(new jedd.Attribute[]{srcc.v(),src.v(),dstc.v(),dst.v()},new jedd.PhysicalDomain[]{C1.v(),V1.v(),C2.v(),V2.v()},(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""),jedd.internal.Jedd.v().join(jedd.internal.Jedd.v().read(simpleOut),ni.globalSet(),new jedd.PhysicalDomain[]{V2.v()}));
  simpleOut.eqMinus(globalDsts);
  simpleOut.eqUnion(jedd.internal.Jedd.v().join(jedd.internal.Jedd.v().read(jedd.internal.Jedd.v().project(globalDsts,new jedd.PhysicalDomain[]{C2.v()})),jedd.internal.Jedd.v().literal(new Object[]{null},new jedd.Attribute[]{dstc.v()},new jedd.PhysicalDomain[]{C2.v()}),new jedd.PhysicalDomain[]{}));
  final jedd.internal.RelationContainer globalSrcs=new jedd.internal.RelationContainer(new jedd.Attribute[]{srcc.v(),src.v(),dstc.v(),dst.v()},new jedd.PhysicalDomain[]{C1.v(),V1.v(),C2.v(),V2.v()},(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""),jedd.internal.Jedd.v().join(jedd.internal.Jedd.v().read(simpleOut),jedd.internal.Jedd.v().replace(ni.globalSet(),new jedd.PhysicalDomain[]{V2.v()},new jedd.PhysicalDomain[]{V1.v()}),new jedd.PhysicalDomain[]{V1.v()}));
  simpleOut.eqMinus(globalSrcs);
  simpleOut.eqUnion(jedd.internal.Jedd.v().join(jedd.internal.Jedd.v().read(jedd.internal.Jedd.v().project(globalSrcs,new jedd.PhysicalDomain[]{C1.v()})),jedd.internal.Jedd.v().literal(new Object[]{null},new jedd.Attribute[]{srcc.v()},new jedd.PhysicalDomain[]{C1.v()}),new jedd.PhysicalDomain[]{}));
  csimple.add(new jedd.internal.RelationContainer(new jedd.Attribute[]{srcc.v(),dst.v(),dstc.v(),src.v()},new jedd.PhysicalDomain[]{C1.v(),V2.v(),C2.v(),V1.v()},(""String_Node_Str"" + ""String_Node_Str""),simpleOut));
  return !jedd.internal.Jedd.v().equals(jedd.internal.Jedd.v().read(simpleOut),jedd.internal.Jedd.v().falseBDD());
}","public boolean update(){
  final jedd.internal.RelationContainer simpleOut=new jedd.internal.RelationContainer(new jedd.Attribute[]{srcc.v(),src.v(),dstc.v(),dst.v()},new jedd.PhysicalDomain[]{C2.v(),V1.v(),C1.v(),V2.v()},(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""),jedd.internal.Jedd.v().falseBDD());
  allParms.eqUnion(parms.get());
  allRets.eqUnion(rets.get());
  final jedd.internal.RelationContainer newCalls=new jedd.internal.RelationContainer(new jedd.Attribute[]{srcc.v(),srcm.v(),stmt.v(),kind.v(),tgtc.v(),tgtm.v()},new jedd.PhysicalDomain[]{C1.v(),MS.v(),ST.v(),KD.v(),C2.v(),MT.v()},(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""),calls.get());
  simpleOut.eqUnion(jedd.internal.Jedd.v().replace(jedd.internal.Jedd.v().compose(jedd.internal.Jedd.v().read(newCalls),allParms,new jedd.PhysicalDomain[]{MS.v(),ST.v(),KD.v(),MT.v()}),new jedd.PhysicalDomain[]{C1.v(),C2.v()},new jedd.PhysicalDomain[]{C2.v(),C1.v()}));
  simpleOut.eqUnion(jedd.internal.Jedd.v().compose(jedd.internal.Jedd.v().read(newCalls),allRets,new jedd.PhysicalDomain[]{MS.v(),ST.v(),KD.v(),MT.v()}));
  final jedd.internal.RelationContainer globalDsts=new jedd.internal.RelationContainer(new jedd.Attribute[]{srcc.v(),src.v(),dstc.v(),dst.v()},new jedd.PhysicalDomain[]{C2.v(),V1.v(),C1.v(),V2.v()},(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""),jedd.internal.Jedd.v().join(jedd.internal.Jedd.v().read(simpleOut),ni.globalSet(),new jedd.PhysicalDomain[]{V2.v()}));
  simpleOut.eqMinus(globalDsts);
  simpleOut.eqUnion(jedd.internal.Jedd.v().join(jedd.internal.Jedd.v().read(jedd.internal.Jedd.v().project(globalDsts,new jedd.PhysicalDomain[]{C1.v()})),jedd.internal.Jedd.v().literal(new Object[]{null},new jedd.Attribute[]{dstc.v()},new jedd.PhysicalDomain[]{C1.v()}),new jedd.PhysicalDomain[]{}));
  final jedd.internal.RelationContainer globalSrcs=new jedd.internal.RelationContainer(new jedd.Attribute[]{srcc.v(),src.v(),dstc.v(),dst.v()},new jedd.PhysicalDomain[]{C2.v(),V1.v(),C1.v(),V2.v()},(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""),jedd.internal.Jedd.v().join(jedd.internal.Jedd.v().read(simpleOut),jedd.internal.Jedd.v().replace(ni.globalSet(),new jedd.PhysicalDomain[]{V2.v()},new jedd.PhysicalDomain[]{V1.v()}),new jedd.PhysicalDomain[]{V1.v()}));
  simpleOut.eqMinus(globalSrcs);
  simpleOut.eqUnion(jedd.internal.Jedd.v().join(jedd.internal.Jedd.v().read(jedd.internal.Jedd.v().project(globalSrcs,new jedd.PhysicalDomain[]{C2.v()})),jedd.internal.Jedd.v().literal(new Object[]{null},new jedd.Attribute[]{srcc.v()},new jedd.PhysicalDomain[]{C2.v()}),new jedd.PhysicalDomain[]{}));
  csimple.add(new jedd.internal.RelationContainer(new jedd.Attribute[]{srcc.v(),dst.v(),dstc.v(),src.v()},new jedd.PhysicalDomain[]{C1.v(),V2.v(),C2.v(),V1.v()},(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""),jedd.internal.Jedd.v().replace(simpleOut,new jedd.PhysicalDomain[]{C2.v(),C1.v()},new jedd.PhysicalDomain[]{C1.v(),C2.v()})));
  return !jedd.internal.Jedd.v().equals(jedd.internal.Jedd.v().read(simpleOut),jedd.internal.Jedd.v().falseBDD());
}"
88531,"boolean hasSootClass(){
  return sootClass != null;
}","public boolean hasSootClass(){
  return sootClass != null;
}"
88532,"public void checkLevel(int level){
  if (!Scene.v().doneResolving())   return;
  if (resolvingLevel < level) {
    try {
      throw new RuntimeException(""String_Node_Str"" + levelToString(level) + ""String_Node_Str""+ name+ ""String_Node_Str""+ levelToString(resolvingLevel));
    }
 catch (    RuntimeException e) {
      System.out.println(""String_Node_Str"" + e.toString());
      e.printStackTrace();
    }
  }
}","public void checkLevel(int level){
  if (!Scene.v().doneResolving())   return;
  if (resolvingLevel < level) {
    throw new RuntimeException(""String_Node_Str"" + levelToString(level) + ""String_Node_Str""+ name+ ""String_Node_Str""+ levelToString(resolvingLevel));
  }
}"
88533,"final public void makeTypeMask(){
  RefType.v(""String_Node_Str"");
  typeMask=new LargeNumberedMap(Scene.v().getTypeNumberer());
  if (fh == null)   return;
  int numTypes=Scene.v().getTypeNumberer().size();
  if (pag.getOpts().verbose())   G.v().out.println(""String_Node_Str"" + numTypes);
  ArrayNumberer allocNodes=pag.getAllocNodeNumberer();
  for (Iterator tIt=Scene.v().getTypeNumberer().iterator(); tIt.hasNext(); ) {
    final Type t=(Type)tIt.next();
    if (!(t instanceof RefLikeType))     continue;
    if (t instanceof AnySubType)     continue;
    BitVector mask=new BitVector(allocNodes.size());
    for (Iterator nIt=allocNodes.iterator(); nIt.hasNext(); ) {
      final Node n=(Node)nIt.next();
      if (castNeverFails(n.getType(),t)) {
        mask.set(n.getNumber());
      }
    }
    typeMask.put(t,mask);
  }
  allocNodeListener=pag.allocNodeListener();
}","final public void makeTypeMask(){
  RefType.v(""String_Node_Str"");
  typeMask=new LargeNumberedMap(Scene.v().getTypeNumberer());
  if (fh == null)   return;
  int numTypes=Scene.v().getTypeNumberer().size();
  if (pag.getOpts().verbose())   G.v().out.println(""String_Node_Str"" + numTypes);
  ArrayNumberer allocNodes=pag.getAllocNodeNumberer();
  for (Iterator tIt=Scene.v().getTypeNumberer().iterator(); tIt.hasNext(); ) {
    final Type t=(Type)tIt.next();
    if (!(t instanceof RefLikeType))     continue;
    if (t instanceof AnySubType)     continue;
    if (isUnresolved(t))     continue;
    BitVector mask=new BitVector(allocNodes.size());
    for (Iterator nIt=allocNodes.iterator(); nIt.hasNext(); ) {
      final Node n=(Node)nIt.next();
      if (castNeverFails(n.getType(),t)) {
        mask.set(n.getNumber());
      }
    }
    typeMask.put(t,mask);
  }
  allocNodeListener=pag.allocNodeListener();
}"
88534,"final public BitVector get(Type type){
  if (type == null)   return null;
  while (allocNodeListener.hasNext()) {
    AllocNode n=(AllocNode)allocNodeListener.next();
    for (Iterator tIt=Scene.v().getTypeNumberer().iterator(); tIt.hasNext(); ) {
      final Type t=(Type)tIt.next();
      if (!(t instanceof RefLikeType))       continue;
      if (t instanceof AnySubType)       continue;
      if (castNeverFails(n.getType(),t)) {
        BitVector mask=(BitVector)typeMask.get(t);
        if (mask == null) {
          typeMask.put(t,mask=new BitVector());
          for (Iterator anIt=pag.getAllocNodeNumberer().iterator(); anIt.hasNext(); ) {
            final AllocNode an=(AllocNode)anIt.next();
            if (castNeverFails(an.getType(),t)) {
              mask.set(an.getNumber());
            }
          }
          continue;
        }
        mask.set(n.getNumber());
      }
    }
  }
  BitVector ret=(BitVector)typeMask.get(type);
  if (ret == null && fh != null)   throw new RuntimeException(""String_Node_Str"" + type);
  return ret;
}","final public BitVector get(Type type){
  if (type == null)   return null;
  while (allocNodeListener.hasNext()) {
    AllocNode n=(AllocNode)allocNodeListener.next();
    for (Iterator tIt=Scene.v().getTypeNumberer().iterator(); tIt.hasNext(); ) {
      final Type t=(Type)tIt.next();
      if (!(t instanceof RefLikeType))       continue;
      if (t instanceof AnySubType)       continue;
      if (isUnresolved(t))       continue;
      if (castNeverFails(n.getType(),t)) {
        BitVector mask=(BitVector)typeMask.get(t);
        if (mask == null) {
          typeMask.put(t,mask=new BitVector());
          for (Iterator anIt=pag.getAllocNodeNumberer().iterator(); anIt.hasNext(); ) {
            final AllocNode an=(AllocNode)anIt.next();
            if (castNeverFails(an.getType(),t)) {
              mask.set(an.getNumber());
            }
          }
          continue;
        }
        mask.set(n.getNumber());
      }
    }
  }
  BitVector ret=(BitVector)typeMask.get(type);
  if (ret == null && fh != null)   throw new RuntimeException(""String_Node_Str"" + type);
  return ret;
}"
88535,"/** 
 * Creates a new node of pointer assignment graph pag, with type type. 
 */
Node(PAG pag,Type type){
  this.type=type;
  this.pag=pag;
  replacement=this;
}","/** 
 * Creates a new node of pointer assignment graph pag, with type type. 
 */
Node(PAG pag,Type type){
  if (TypeManager.isUnresolved(type))   throw new RuntimeException(""String_Node_Str"" + type);
  this.type=type;
  this.pag=pag;
  replacement=this;
}"
88536,"/** 
 * Sets the declared type of this node, null for unknown. 
 */
public void setType(Type type){
  this.type=type;
}","/** 
 * Sets the declared type of this node, null for unknown. 
 */
public void setType(Type type){
  if (TypeManager.isUnresolved(type))   throw new RuntimeException(""String_Node_Str"" + type);
  this.type=type;
}"
88537,"OutFlow processFlow(Instruction ins,TypeStack typeStack,cp_info[] constant_pool){
  int x;
  x=((int)(ins.code)) & 0xff;
switch (x) {
case ByteCode.BIPUSH:
    typeStack=typeStack.push(IntType.v());
  break;
case ByteCode.SIPUSH:
typeStack=typeStack.push(IntType.v());
break;
case ByteCode.LDC1:
return processCPEntry(constant_pool,((Instruction_Ldc1)ins).arg_b,typeStack,jmethod);
case ByteCode.LDC2:
case ByteCode.LDC2W:
return processCPEntry(constant_pool,((Instruction_intindex)ins).arg_i,typeStack,jmethod);
case ByteCode.ACONST_NULL:
typeStack=typeStack.push(RefType.v(""String_Node_Str""));
break;
case ByteCode.ICONST_M1:
case ByteCode.ICONST_0:
case ByteCode.ICONST_1:
case ByteCode.ICONST_2:
case ByteCode.ICONST_3:
case ByteCode.ICONST_4:
case ByteCode.ICONST_5:
typeStack=typeStack.push(IntType.v());
break;
case ByteCode.LCONST_0:
case ByteCode.LCONST_1:
typeStack=typeStack.push(LongType.v());
typeStack=typeStack.push(Long2ndHalfType.v());
break;
case ByteCode.FCONST_0:
case ByteCode.FCONST_1:
case ByteCode.FCONST_2:
typeStack=typeStack.push(FloatType.v());
break;
case ByteCode.DCONST_0:
case ByteCode.DCONST_1:
typeStack=typeStack.push(DoubleType.v());
typeStack=typeStack.push(Double2ndHalfType.v());
break;
case ByteCode.ILOAD:
typeStack=typeStack.push(IntType.v());
break;
case ByteCode.FLOAD:
typeStack=typeStack.push(FloatType.v());
break;
case ByteCode.ALOAD:
typeStack=typeStack.push(RefType.v(""String_Node_Str""));
break;
case ByteCode.DLOAD:
typeStack=typeStack.push(DoubleType.v());
typeStack=typeStack.push(Double2ndHalfType.v());
break;
case ByteCode.LLOAD:
typeStack=typeStack.push(LongType.v());
typeStack=typeStack.push(Long2ndHalfType.v());
break;
case ByteCode.ILOAD_0:
case ByteCode.ILOAD_1:
case ByteCode.ILOAD_2:
case ByteCode.ILOAD_3:
typeStack=typeStack.push(IntType.v());
break;
case ByteCode.FLOAD_0:
case ByteCode.FLOAD_1:
case ByteCode.FLOAD_2:
case ByteCode.FLOAD_3:
typeStack=typeStack.push(FloatType.v());
break;
case ByteCode.ALOAD_0:
case ByteCode.ALOAD_1:
case ByteCode.ALOAD_2:
case ByteCode.ALOAD_3:
typeStack=typeStack.push(RefType.v(""String_Node_Str""));
break;
case ByteCode.LLOAD_0:
case ByteCode.LLOAD_1:
case ByteCode.LLOAD_2:
case ByteCode.LLOAD_3:
typeStack=typeStack.push(LongType.v());
typeStack=typeStack.push(Long2ndHalfType.v());
break;
case ByteCode.DLOAD_0:
case ByteCode.DLOAD_1:
case ByteCode.DLOAD_2:
case ByteCode.DLOAD_3:
typeStack=typeStack.push(DoubleType.v());
typeStack=typeStack.push(Double2ndHalfType.v());
break;
case ByteCode.ISTORE:
typeStack=popSafe(typeStack,IntType.v());
break;
case ByteCode.FSTORE:
typeStack=popSafe(typeStack,FloatType.v());
break;
case ByteCode.ASTORE:
typeStack=typeStack.pop();
break;
case ByteCode.LSTORE:
typeStack=popSafe(typeStack,Long2ndHalfType.v());
typeStack=popSafe(typeStack,LongType.v());
break;
case ByteCode.DSTORE:
typeStack=popSafe(typeStack,Double2ndHalfType.v());
typeStack=popSafe(typeStack,DoubleType.v());
break;
case ByteCode.ISTORE_0:
case ByteCode.ISTORE_1:
case ByteCode.ISTORE_2:
case ByteCode.ISTORE_3:
typeStack=popSafe(typeStack,IntType.v());
break;
case ByteCode.FSTORE_0:
case ByteCode.FSTORE_1:
case ByteCode.FSTORE_2:
case ByteCode.FSTORE_3:
typeStack=popSafe(typeStack,FloatType.v());
break;
case ByteCode.ASTORE_0:
case ByteCode.ASTORE_1:
case ByteCode.ASTORE_2:
case ByteCode.ASTORE_3:
if (!(typeStack.top() instanceof StmtAddressType) && !(typeStack.top() instanceof RefType) && !(typeStack.top() instanceof ArrayType)) {
throw new RuntimeException(""String_Node_Str"" + typeStack.top());
}
typeStack=typeStack.pop();
break;
case ByteCode.LSTORE_0:
case ByteCode.LSTORE_1:
case ByteCode.LSTORE_2:
case ByteCode.LSTORE_3:
typeStack=popSafe(typeStack,Long2ndHalfType.v());
typeStack=popSafe(typeStack,LongType.v());
break;
case ByteCode.DSTORE_0:
case ByteCode.DSTORE_1:
case ByteCode.DSTORE_2:
case ByteCode.DSTORE_3:
typeStack=popSafe(typeStack,Double2ndHalfType.v());
typeStack=popSafe(typeStack,DoubleType.v());
break;
case ByteCode.IINC:
break;
case ByteCode.WIDE:
throw new RuntimeException(""String_Node_Str"");
case ByteCode.NEWARRAY:
{
typeStack=popSafe(typeStack,IntType.v());
Type baseType=(Type)jimpleTypeOfAtype(((Instruction_Newarray)ins).atype);
typeStack=typeStack.push(ArrayType.v(baseType,1));
break;
}
case ByteCode.ANEWARRAY:
{
CONSTANT_Class_info c=(CONSTANT_Class_info)constant_pool[((Instruction_Anewarray)ins).arg_i];
String name=((CONSTANT_Utf8_info)(constant_pool[c.name_index])).convert();
name=name.replace('/','.');
typeStack=popSafe(typeStack,IntType.v());
typeStack=typeStack.push(ArrayType.v(RefType.v(name),1));
break;
}
case ByteCode.MULTIANEWARRAY:
{
int bdims=(int)(((Instruction_Multianewarray)ins).dims);
CONSTANT_Class_info c=(CONSTANT_Class_info)constant_pool[((Instruction_Multianewarray)ins).arg_i];
String arrayDescriptor=((CONSTANT_Utf8_info)(constant_pool[c.name_index])).convert();
ArrayType arrayType=(ArrayType)Util.v().jimpleTypeOfFieldDescriptor(arrayDescriptor);
for (int j=0; j < bdims; j++) typeStack=popSafe(typeStack,IntType.v());
typeStack=typeStack.push(arrayType);
break;
}
case ByteCode.ARRAYLENGTH:
typeStack=popSafeRefType(typeStack);
typeStack=typeStack.push(IntType.v());
break;
case ByteCode.IALOAD:
case ByteCode.BALOAD:
case ByteCode.CALOAD:
case ByteCode.SALOAD:
typeStack=popSafe(typeStack,IntType.v());
typeStack=popSafeRefType(typeStack);
typeStack=typeStack.push(IntType.v());
break;
case ByteCode.FALOAD:
typeStack=popSafe(typeStack,FloatType.v());
typeStack=popSafeRefType(typeStack);
typeStack=typeStack.push(FloatType.v());
break;
case ByteCode.AALOAD:
{
typeStack=popSafe(typeStack,IntType.v());
if (typeStack.top() instanceof ArrayType) {
ArrayType arrayType=(ArrayType)typeStack.top();
typeStack=popSafeRefType(typeStack);
if (arrayType.numDimensions == 1) typeStack=typeStack.push(arrayType.baseType);
 else typeStack=typeStack.push(ArrayType.v(arrayType.baseType,arrayType.numDimensions - 1));
}
 else {
typeStack=popSafeRefType(typeStack);
typeStack=typeStack.push(RefType.v(""String_Node_Str""));
}
break;
}
case ByteCode.LALOAD:
typeStack=popSafe(typeStack,IntType.v());
typeStack=popSafeRefType(typeStack);
typeStack=typeStack.push(LongType.v());
typeStack=typeStack.push(Long2ndHalfType.v());
break;
case ByteCode.DALOAD:
typeStack=popSafe(typeStack,IntType.v());
typeStack=popSafeRefType(typeStack);
typeStack=typeStack.push(DoubleType.v());
typeStack=typeStack.push(Double2ndHalfType.v());
break;
case ByteCode.IASTORE:
case ByteCode.BASTORE:
case ByteCode.CASTORE:
case ByteCode.SASTORE:
typeStack=popSafe(typeStack,IntType.v());
typeStack=popSafe(typeStack,IntType.v());
typeStack=popSafeRefType(typeStack);
break;
case ByteCode.AASTORE:
typeStack=popSafeRefType(typeStack);
typeStack=popSafe(typeStack,IntType.v());
typeStack=popSafeRefType(typeStack);
break;
case ByteCode.FASTORE:
typeStack=popSafe(typeStack,FloatType.v());
typeStack=popSafe(typeStack,IntType.v());
typeStack=popSafeRefType(typeStack);
break;
case ByteCode.LASTORE:
typeStack=popSafe(typeStack,Long2ndHalfType.v());
typeStack=popSafe(typeStack,LongType.v());
typeStack=popSafe(typeStack,IntType.v());
typeStack=popSafeRefType(typeStack);
break;
case ByteCode.DASTORE:
typeStack=popSafe(typeStack,Double2ndHalfType.v());
typeStack=popSafe(typeStack,DoubleType.v());
typeStack=popSafe(typeStack,IntType.v());
typeStack=popSafeRefType(typeStack);
break;
case ByteCode.NOP:
break;
case ByteCode.POP:
typeStack=typeStack.pop();
break;
case ByteCode.POP2:
typeStack=typeStack.pop();
typeStack=typeStack.pop();
break;
case ByteCode.DUP:
typeStack=typeStack.push(typeStack.top());
break;
case ByteCode.DUP2:
{
Type topType=typeStack.get(typeStack.topIndex()), secondType=typeStack.get(typeStack.topIndex() - 1);
typeStack=(typeStack.push(secondType)).push(topType);
break;
}
case ByteCode.DUP_X1:
{
Type topType=typeStack.get(typeStack.topIndex()), secondType=typeStack.get(typeStack.topIndex() - 1);
typeStack=typeStack.pop().pop();
typeStack=typeStack.push(topType).push(secondType).push(topType);
break;
}
case ByteCode.DUP_X2:
{
Type topType=typeStack.get(typeStack.topIndex()), secondType=typeStack.get(typeStack.topIndex() - 1), thirdType=typeStack.get(typeStack.topIndex() - 2);
typeStack=typeStack.pop().pop().pop();
typeStack=typeStack.push(topType).push(thirdType).push(secondType).push(topType);
break;
}
case ByteCode.DUP2_X1:
{
Type topType=typeStack.get(typeStack.topIndex()), secondType=typeStack.get(typeStack.topIndex() - 1), thirdType=typeStack.get(typeStack.topIndex() - 2);
typeStack=typeStack.pop().pop().pop();
typeStack=typeStack.push(secondType).push(topType).push(thirdType).push(secondType).push(topType);
break;
}
case ByteCode.DUP2_X2:
{
Type topType=typeStack.get(typeStack.topIndex()), secondType=typeStack.get(typeStack.topIndex() - 1), thirdType=typeStack.get(typeStack.topIndex() - 2), fourthType=typeStack.get(typeStack.topIndex() - 3);
typeStack=typeStack.pop().pop().pop().pop();
typeStack=typeStack.push(secondType).push(topType).push(fourthType).push(thirdType).push(secondType).push(topType);
break;
}
case ByteCode.SWAP:
{
Type topType=typeStack.top();
typeStack=typeStack.pop();
Type secondType=typeStack.top();
typeStack=typeStack.pop();
typeStack=typeStack.push(topType);
typeStack=typeStack.push(secondType);
break;
}
case ByteCode.IADD:
case ByteCode.ISUB:
case ByteCode.IMUL:
case ByteCode.IDIV:
case ByteCode.IREM:
case ByteCode.ISHL:
case ByteCode.ISHR:
case ByteCode.IUSHR:
case ByteCode.IAND:
case ByteCode.IOR:
case ByteCode.IXOR:
typeStack=popSafe(typeStack,IntType.v());
typeStack=popSafe(typeStack,IntType.v());
typeStack=typeStack.push(IntType.v());
break;
case ByteCode.LUSHR:
case ByteCode.LSHR:
case ByteCode.LSHL:
typeStack=popSafe(typeStack,IntType.v());
typeStack=popSafe(typeStack,Long2ndHalfType.v());
typeStack=popSafe(typeStack,LongType.v());
typeStack=typeStack.push(LongType.v());
typeStack=typeStack.push(Long2ndHalfType.v());
break;
case ByteCode.LREM:
case ByteCode.LDIV:
case ByteCode.LMUL:
case ByteCode.LSUB:
case ByteCode.LADD:
case ByteCode.LAND:
case ByteCode.LOR:
case ByteCode.LXOR:
typeStack=popSafe(typeStack,Long2ndHalfType.v());
typeStack=popSafe(typeStack,LongType.v());
typeStack=popSafe(typeStack,Long2ndHalfType.v());
typeStack=popSafe(typeStack,LongType.v());
typeStack=typeStack.push(LongType.v());
typeStack=typeStack.push(Long2ndHalfType.v());
break;
case ByteCode.FREM:
case ByteCode.FDIV:
case ByteCode.FMUL:
case ByteCode.FSUB:
case ByteCode.FADD:
typeStack=popSafe(typeStack,FloatType.v());
typeStack=popSafe(typeStack,FloatType.v());
typeStack=typeStack.push(FloatType.v());
break;
case ByteCode.DREM:
case ByteCode.DDIV:
case ByteCode.DMUL:
case ByteCode.DSUB:
case ByteCode.DADD:
typeStack=popSafe(typeStack,Double2ndHalfType.v());
typeStack=popSafe(typeStack,DoubleType.v());
typeStack=popSafe(typeStack,Double2ndHalfType.v());
typeStack=popSafe(typeStack,DoubleType.v());
typeStack=typeStack.push(DoubleType.v());
typeStack=typeStack.push(Double2ndHalfType.v());
break;
case ByteCode.INEG:
case ByteCode.LNEG:
case ByteCode.FNEG:
case ByteCode.DNEG:
break;
case ByteCode.I2L:
typeStack=popSafe(typeStack,IntType.v());
typeStack=typeStack.push(LongType.v());
typeStack=typeStack.push(Long2ndHalfType.v());
break;
case ByteCode.I2F:
typeStack=popSafe(typeStack,IntType.v());
typeStack=typeStack.push(FloatType.v());
break;
case ByteCode.I2D:
typeStack=popSafe(typeStack,IntType.v());
typeStack=typeStack.push(DoubleType.v());
typeStack=typeStack.push(Double2ndHalfType.v());
break;
case ByteCode.L2I:
typeStack=popSafe(typeStack,Long2ndHalfType.v());
typeStack=popSafe(typeStack,LongType.v());
typeStack=typeStack.push(IntType.v());
break;
case ByteCode.L2F:
typeStack=popSafe(typeStack,Long2ndHalfType.v());
typeStack=popSafe(typeStack,LongType.v());
typeStack=typeStack.push(FloatType.v());
break;
case ByteCode.L2D:
typeStack=popSafe(typeStack,Long2ndHalfType.v());
typeStack=popSafe(typeStack,LongType.v());
typeStack=typeStack.push(DoubleType.v());
typeStack=typeStack.push(Double2ndHalfType.v());
break;
case ByteCode.F2I:
typeStack=popSafe(typeStack,FloatType.v());
typeStack=typeStack.push(IntType.v());
break;
case ByteCode.F2L:
typeStack=popSafe(typeStack,FloatType.v());
typeStack=typeStack.push(LongType.v());
typeStack=typeStack.push(Long2ndHalfType.v());
break;
case ByteCode.F2D:
typeStack=popSafe(typeStack,FloatType.v());
typeStack=typeStack.push(DoubleType.v());
typeStack=typeStack.push(Double2ndHalfType.v());
break;
case ByteCode.D2I:
typeStack=popSafe(typeStack,Double2ndHalfType.v());
typeStack=popSafe(typeStack,DoubleType.v());
typeStack=typeStack.push(IntType.v());
break;
case ByteCode.D2L:
typeStack=popSafe(typeStack,Double2ndHalfType.v());
typeStack=popSafe(typeStack,DoubleType.v());
typeStack=typeStack.push(LongType.v());
typeStack=typeStack.push(Long2ndHalfType.v());
break;
case ByteCode.D2F:
typeStack=popSafe(typeStack,Double2ndHalfType.v());
typeStack=popSafe(typeStack,DoubleType.v());
typeStack=typeStack.push(FloatType.v());
break;
case ByteCode.INT2BYTE:
break;
case ByteCode.INT2CHAR:
break;
case ByteCode.INT2SHORT:
break;
case ByteCode.IFEQ:
case ByteCode.IFGT:
case ByteCode.IFLT:
case ByteCode.IFLE:
case ByteCode.IFNE:
case ByteCode.IFGE:
typeStack=popSafe(typeStack,IntType.v());
break;
case ByteCode.IFNULL:
case ByteCode.IFNONNULL:
typeStack=popSafeRefType(typeStack);
break;
case ByteCode.IF_ICMPEQ:
case ByteCode.IF_ICMPLT:
case ByteCode.IF_ICMPLE:
case ByteCode.IF_ICMPNE:
case ByteCode.IF_ICMPGT:
case ByteCode.IF_ICMPGE:
typeStack=popSafe(typeStack,IntType.v());
typeStack=popSafe(typeStack,IntType.v());
break;
case ByteCode.LCMP:
typeStack=popSafe(typeStack,Long2ndHalfType.v());
typeStack=popSafe(typeStack,LongType.v());
typeStack=popSafe(typeStack,Long2ndHalfType.v());
typeStack=popSafe(typeStack,LongType.v());
typeStack=typeStack.push(IntType.v());
break;
case ByteCode.FCMPL:
case ByteCode.FCMPG:
typeStack=popSafe(typeStack,FloatType.v());
typeStack=popSafe(typeStack,FloatType.v());
typeStack=typeStack.push(IntType.v());
break;
case ByteCode.DCMPL:
case ByteCode.DCMPG:
typeStack=popSafe(typeStack,Double2ndHalfType.v());
typeStack=popSafe(typeStack,DoubleType.v());
typeStack=popSafe(typeStack,Double2ndHalfType.v());
typeStack=popSafe(typeStack,DoubleType.v());
typeStack=typeStack.push(IntType.v());
break;
case ByteCode.IF_ACMPEQ:
case ByteCode.IF_ACMPNE:
typeStack=popSafeRefType(typeStack);
typeStack=popSafeRefType(typeStack);
break;
case ByteCode.GOTO:
case ByteCode.GOTO_W:
break;
case ByteCode.JSR:
case ByteCode.JSR_W:
typeStack=typeStack.push(StmtAddressType.v());
break;
case ByteCode.RET:
break;
case ByteCode.RET_W:
break;
case ByteCode.RETURN:
break;
case ByteCode.IRETURN:
typeStack=popSafe(typeStack,IntType.v());
break;
case ByteCode.FRETURN:
typeStack=popSafe(typeStack,FloatType.v());
break;
case ByteCode.ARETURN:
typeStack=popSafeRefType(typeStack);
break;
case ByteCode.DRETURN:
typeStack=popSafe(typeStack,Double2ndHalfType.v());
typeStack=popSafe(typeStack,DoubleType.v());
break;
case ByteCode.LRETURN:
typeStack=popSafe(typeStack,Long2ndHalfType.v());
typeStack=popSafe(typeStack,LongType.v());
break;
case ByteCode.BREAKPOINT:
break;
case ByteCode.TABLESWITCH:
typeStack=popSafe(typeStack,IntType.v());
break;
case ByteCode.LOOKUPSWITCH:
typeStack=popSafe(typeStack,IntType.v());
break;
case ByteCode.PUTFIELD:
{
Type type=byteCodeTypeOf(jimpleTypeOfFieldInFieldRef(cm,constant_pool,((Instruction_Putfield)ins).arg_i));
if (type.equals(DoubleType.v())) {
typeStack=popSafe(typeStack,Double2ndHalfType.v());
typeStack=popSafe(typeStack,DoubleType.v());
}
 else if (type.equals(LongType.v())) {
typeStack=popSafe(typeStack,Long2ndHalfType.v());
typeStack=popSafe(typeStack,LongType.v());
}
 else if (type instanceof RefType) typeStack=popSafeRefType(typeStack);
 else typeStack=popSafe(typeStack,type);
typeStack=popSafeRefType(typeStack);
break;
}
case ByteCode.GETFIELD:
{
Type type=byteCodeTypeOf(jimpleTypeOfFieldInFieldRef(cm,constant_pool,((Instruction_Getfield)ins).arg_i));
typeStack=popSafeRefType(typeStack);
if (type.equals(DoubleType.v())) {
typeStack=typeStack.push(DoubleType.v());
typeStack=typeStack.push(Double2ndHalfType.v());
}
 else if (type.equals(LongType.v())) {
typeStack=typeStack.push(LongType.v());
typeStack=typeStack.push(Long2ndHalfType.v());
}
 else typeStack=typeStack.push(type);
break;
}
case ByteCode.PUTSTATIC:
{
Type type=byteCodeTypeOf(jimpleTypeOfFieldInFieldRef(cm,constant_pool,((Instruction_Putstatic)ins).arg_i));
if (type.equals(DoubleType.v())) {
typeStack=popSafe(typeStack,Double2ndHalfType.v());
typeStack=popSafe(typeStack,DoubleType.v());
}
 else if (type.equals(LongType.v())) {
typeStack=popSafe(typeStack,Long2ndHalfType.v());
typeStack=popSafe(typeStack,LongType.v());
}
 else if (type instanceof RefType) typeStack=popSafeRefType(typeStack);
 else typeStack=popSafe(typeStack,type);
break;
}
case ByteCode.GETSTATIC:
{
Type type=byteCodeTypeOf(jimpleTypeOfFieldInFieldRef(cm,constant_pool,((Instruction_Getstatic)ins).arg_i));
if (type.equals(DoubleType.v())) {
typeStack=typeStack.push(DoubleType.v());
typeStack=typeStack.push(Double2ndHalfType.v());
}
 else if (type.equals(LongType.v())) {
typeStack=typeStack.push(LongType.v());
typeStack=typeStack.push(Long2ndHalfType.v());
}
 else typeStack=typeStack.push(type);
break;
}
case ByteCode.INVOKEVIRTUAL:
{
Instruction_Invokevirtual iv=(Instruction_Invokevirtual)ins;
int args=cp_info.countParams(constant_pool,iv.arg_i);
Type returnType=byteCodeTypeOf(jimpleReturnTypeOfMethodRef(cm,constant_pool,iv.arg_i));
for (int j=args - 1; j >= 0; j--) {
if (typeStack.top().equals(Long2ndHalfType.v())) {
typeStack=popSafe(typeStack,Long2ndHalfType.v());
typeStack=popSafe(typeStack,LongType.v());
}
 else if (typeStack.top().equals(Double2ndHalfType.v())) {
typeStack=popSafe(typeStack,Double2ndHalfType.v());
typeStack=popSafe(typeStack,DoubleType.v());
}
 else typeStack=popSafe(typeStack,typeStack.top());
}
typeStack=popSafeRefType(typeStack);
if (!returnType.equals(VoidType.v())) typeStack=smartPush(typeStack,returnType);
break;
}
case ByteCode.INVOKENONVIRTUAL:
{
Instruction_Invokenonvirtual iv=(Instruction_Invokenonvirtual)ins;
int args=cp_info.countParams(constant_pool,iv.arg_i);
Type returnType=byteCodeTypeOf(jimpleReturnTypeOfMethodRef(cm,constant_pool,iv.arg_i));
for (int j=args - 1; j >= 0; j--) {
if (typeStack.top().equals(Long2ndHalfType.v())) {
typeStack=popSafe(typeStack,Long2ndHalfType.v());
typeStack=popSafe(typeStack,LongType.v());
}
 else if (typeStack.top().equals(Double2ndHalfType.v())) {
typeStack=popSafe(typeStack,Double2ndHalfType.v());
typeStack=popSafe(typeStack,DoubleType.v());
}
 else typeStack=popSafe(typeStack,typeStack.top());
}
typeStack=popSafeRefType(typeStack);
if (!returnType.equals(VoidType.v())) typeStack=smartPush(typeStack,returnType);
break;
}
case ByteCode.INVOKESTATIC:
{
Instruction_Invokestatic iv=(Instruction_Invokestatic)ins;
int args=cp_info.countParams(constant_pool,iv.arg_i);
Type returnType=byteCodeTypeOf(jimpleReturnTypeOfMethodRef(cm,constant_pool,iv.arg_i));
for (int j=args - 1; j >= 0; j--) {
if (typeStack.top().equals(Long2ndHalfType.v())) {
typeStack=popSafe(typeStack,Long2ndHalfType.v());
typeStack=popSafe(typeStack,LongType.v());
}
 else if (typeStack.top().equals(Double2ndHalfType.v())) {
typeStack=popSafe(typeStack,Double2ndHalfType.v());
typeStack=popSafe(typeStack,DoubleType.v());
}
 else typeStack=popSafe(typeStack,typeStack.top());
}
if (!returnType.equals(VoidType.v())) typeStack=smartPush(typeStack,returnType);
break;
}
case ByteCode.INVOKEINTERFACE:
{
Instruction_Invokeinterface iv=(Instruction_Invokeinterface)ins;
int args=cp_info.countParams(constant_pool,iv.arg_i);
Type returnType=byteCodeTypeOf(jimpleReturnTypeOfInterfaceMethodRef(cm,constant_pool,iv.arg_i));
for (int j=args - 1; j >= 0; j--) {
if (typeStack.top().equals(Long2ndHalfType.v())) {
typeStack=popSafe(typeStack,Long2ndHalfType.v());
typeStack=popSafe(typeStack,LongType.v());
}
 else if (typeStack.top().equals(Double2ndHalfType.v())) {
typeStack=popSafe(typeStack,Double2ndHalfType.v());
typeStack=popSafe(typeStack,DoubleType.v());
}
 else typeStack=popSafe(typeStack,typeStack.top());
}
typeStack=popSafeRefType(typeStack);
if (!returnType.equals(VoidType.v())) typeStack=smartPush(typeStack,returnType);
break;
}
case ByteCode.ATHROW:
break;
case ByteCode.NEW:
{
Type type=RefType.v(getClassName(constant_pool,((Instruction_New)ins).arg_i));
typeStack=typeStack.push(type);
break;
}
case ByteCode.CHECKCAST:
{
String className=getClassName(constant_pool,((Instruction_Checkcast)ins).arg_i);
Type castType;
if (className.startsWith(""String_Node_Str"")) castType=Util.v().jimpleTypeOfFieldDescriptor(getClassName(constant_pool,((Instruction_Checkcast)ins).arg_i));
 else castType=RefType.v(className);
typeStack=popSafeRefType(typeStack);
typeStack=typeStack.push(castType);
break;
}
case ByteCode.INSTANCEOF:
{
typeStack=popSafeRefType(typeStack);
typeStack=typeStack.push(IntType.v());
break;
}
case ByteCode.MONITORENTER:
typeStack=popSafeRefType(typeStack);
break;
case ByteCode.MONITOREXIT:
typeStack=popSafeRefType(typeStack);
break;
default :
throw new RuntimeException(""String_Node_Str"" + x);
}
return new OutFlow(typeStack);
}","OutFlow processFlow(Instruction ins,TypeStack typeStack,cp_info[] constant_pool){
  int x;
  x=((int)(ins.code)) & 0xff;
switch (x) {
case ByteCode.BIPUSH:
    typeStack=typeStack.push(IntType.v());
  break;
case ByteCode.SIPUSH:
typeStack=typeStack.push(IntType.v());
break;
case ByteCode.LDC1:
return processCPEntry(constant_pool,((Instruction_Ldc1)ins).arg_b,typeStack,jmethod);
case ByteCode.LDC2:
case ByteCode.LDC2W:
return processCPEntry(constant_pool,((Instruction_intindex)ins).arg_i,typeStack,jmethod);
case ByteCode.ACONST_NULL:
typeStack=typeStack.push(RefType.v(""String_Node_Str""));
break;
case ByteCode.ICONST_M1:
case ByteCode.ICONST_0:
case ByteCode.ICONST_1:
case ByteCode.ICONST_2:
case ByteCode.ICONST_3:
case ByteCode.ICONST_4:
case ByteCode.ICONST_5:
typeStack=typeStack.push(IntType.v());
break;
case ByteCode.LCONST_0:
case ByteCode.LCONST_1:
typeStack=typeStack.push(LongType.v());
typeStack=typeStack.push(Long2ndHalfType.v());
break;
case ByteCode.FCONST_0:
case ByteCode.FCONST_1:
case ByteCode.FCONST_2:
typeStack=typeStack.push(FloatType.v());
break;
case ByteCode.DCONST_0:
case ByteCode.DCONST_1:
typeStack=typeStack.push(DoubleType.v());
typeStack=typeStack.push(Double2ndHalfType.v());
break;
case ByteCode.ILOAD:
typeStack=typeStack.push(IntType.v());
break;
case ByteCode.FLOAD:
typeStack=typeStack.push(FloatType.v());
break;
case ByteCode.ALOAD:
typeStack=typeStack.push(RefType.v(""String_Node_Str""));
break;
case ByteCode.DLOAD:
typeStack=typeStack.push(DoubleType.v());
typeStack=typeStack.push(Double2ndHalfType.v());
break;
case ByteCode.LLOAD:
typeStack=typeStack.push(LongType.v());
typeStack=typeStack.push(Long2ndHalfType.v());
break;
case ByteCode.ILOAD_0:
case ByteCode.ILOAD_1:
case ByteCode.ILOAD_2:
case ByteCode.ILOAD_3:
typeStack=typeStack.push(IntType.v());
break;
case ByteCode.FLOAD_0:
case ByteCode.FLOAD_1:
case ByteCode.FLOAD_2:
case ByteCode.FLOAD_3:
typeStack=typeStack.push(FloatType.v());
break;
case ByteCode.ALOAD_0:
case ByteCode.ALOAD_1:
case ByteCode.ALOAD_2:
case ByteCode.ALOAD_3:
typeStack=typeStack.push(RefType.v(""String_Node_Str""));
break;
case ByteCode.LLOAD_0:
case ByteCode.LLOAD_1:
case ByteCode.LLOAD_2:
case ByteCode.LLOAD_3:
typeStack=typeStack.push(LongType.v());
typeStack=typeStack.push(Long2ndHalfType.v());
break;
case ByteCode.DLOAD_0:
case ByteCode.DLOAD_1:
case ByteCode.DLOAD_2:
case ByteCode.DLOAD_3:
typeStack=typeStack.push(DoubleType.v());
typeStack=typeStack.push(Double2ndHalfType.v());
break;
case ByteCode.ISTORE:
typeStack=popSafe(typeStack,IntType.v());
break;
case ByteCode.FSTORE:
typeStack=popSafe(typeStack,FloatType.v());
break;
case ByteCode.ASTORE:
typeStack=typeStack.pop();
break;
case ByteCode.LSTORE:
typeStack=popSafe(typeStack,Long2ndHalfType.v());
typeStack=popSafe(typeStack,LongType.v());
break;
case ByteCode.DSTORE:
typeStack=popSafe(typeStack,Double2ndHalfType.v());
typeStack=popSafe(typeStack,DoubleType.v());
break;
case ByteCode.ISTORE_0:
case ByteCode.ISTORE_1:
case ByteCode.ISTORE_2:
case ByteCode.ISTORE_3:
typeStack=popSafe(typeStack,IntType.v());
break;
case ByteCode.FSTORE_0:
case ByteCode.FSTORE_1:
case ByteCode.FSTORE_2:
case ByteCode.FSTORE_3:
typeStack=popSafe(typeStack,FloatType.v());
break;
case ByteCode.ASTORE_0:
case ByteCode.ASTORE_1:
case ByteCode.ASTORE_2:
case ByteCode.ASTORE_3:
if (!(typeStack.top() instanceof StmtAddressType) && !(typeStack.top() instanceof RefType) && !(typeStack.top() instanceof ArrayType)) {
throw new RuntimeException(""String_Node_Str"" + typeStack.top());
}
typeStack=typeStack.pop();
break;
case ByteCode.LSTORE_0:
case ByteCode.LSTORE_1:
case ByteCode.LSTORE_2:
case ByteCode.LSTORE_3:
typeStack=popSafe(typeStack,Long2ndHalfType.v());
typeStack=popSafe(typeStack,LongType.v());
break;
case ByteCode.DSTORE_0:
case ByteCode.DSTORE_1:
case ByteCode.DSTORE_2:
case ByteCode.DSTORE_3:
typeStack=popSafe(typeStack,Double2ndHalfType.v());
typeStack=popSafe(typeStack,DoubleType.v());
break;
case ByteCode.IINC:
break;
case ByteCode.WIDE:
throw new RuntimeException(""String_Node_Str"");
case ByteCode.NEWARRAY:
{
typeStack=popSafe(typeStack,IntType.v());
Type baseType=(Type)jimpleTypeOfAtype(((Instruction_Newarray)ins).atype);
typeStack=typeStack.push(ArrayType.v(baseType,1));
break;
}
case ByteCode.ANEWARRAY:
{
CONSTANT_Class_info c=(CONSTANT_Class_info)constant_pool[((Instruction_Anewarray)ins).arg_i];
String name=((CONSTANT_Utf8_info)(constant_pool[c.name_index])).convert();
name=name.replace('/','.');
Type baseType;
if (name.startsWith(""String_Node_Str"")) {
String baseName=getClassName(constant_pool,((Instruction_Anewarray)ins).arg_i);
baseType=Util.v().jimpleTypeOfFieldDescriptor(baseName);
}
 else {
baseType=RefType.v(name);
}
typeStack=popSafe(typeStack,IntType.v());
typeStack=typeStack.push(baseType.makeArrayType());
break;
}
case ByteCode.MULTIANEWARRAY:
{
int bdims=(int)(((Instruction_Multianewarray)ins).dims);
CONSTANT_Class_info c=(CONSTANT_Class_info)constant_pool[((Instruction_Multianewarray)ins).arg_i];
String arrayDescriptor=((CONSTANT_Utf8_info)(constant_pool[c.name_index])).convert();
ArrayType arrayType=(ArrayType)Util.v().jimpleTypeOfFieldDescriptor(arrayDescriptor);
for (int j=0; j < bdims; j++) typeStack=popSafe(typeStack,IntType.v());
typeStack=typeStack.push(arrayType);
break;
}
case ByteCode.ARRAYLENGTH:
typeStack=popSafeRefType(typeStack);
typeStack=typeStack.push(IntType.v());
break;
case ByteCode.IALOAD:
case ByteCode.BALOAD:
case ByteCode.CALOAD:
case ByteCode.SALOAD:
typeStack=popSafe(typeStack,IntType.v());
typeStack=popSafeRefType(typeStack);
typeStack=typeStack.push(IntType.v());
break;
case ByteCode.FALOAD:
typeStack=popSafe(typeStack,FloatType.v());
typeStack=popSafeRefType(typeStack);
typeStack=typeStack.push(FloatType.v());
break;
case ByteCode.AALOAD:
{
typeStack=popSafe(typeStack,IntType.v());
if (typeStack.top() instanceof ArrayType) {
ArrayType arrayType=(ArrayType)typeStack.top();
typeStack=popSafeRefType(typeStack);
if (arrayType.numDimensions == 1) typeStack=typeStack.push(arrayType.baseType);
 else typeStack=typeStack.push(ArrayType.v(arrayType.baseType,arrayType.numDimensions - 1));
}
 else {
typeStack=popSafeRefType(typeStack);
typeStack=typeStack.push(RefType.v(""String_Node_Str""));
}
break;
}
case ByteCode.LALOAD:
typeStack=popSafe(typeStack,IntType.v());
typeStack=popSafeRefType(typeStack);
typeStack=typeStack.push(LongType.v());
typeStack=typeStack.push(Long2ndHalfType.v());
break;
case ByteCode.DALOAD:
typeStack=popSafe(typeStack,IntType.v());
typeStack=popSafeRefType(typeStack);
typeStack=typeStack.push(DoubleType.v());
typeStack=typeStack.push(Double2ndHalfType.v());
break;
case ByteCode.IASTORE:
case ByteCode.BASTORE:
case ByteCode.CASTORE:
case ByteCode.SASTORE:
typeStack=popSafe(typeStack,IntType.v());
typeStack=popSafe(typeStack,IntType.v());
typeStack=popSafeRefType(typeStack);
break;
case ByteCode.AASTORE:
typeStack=popSafeRefType(typeStack);
typeStack=popSafe(typeStack,IntType.v());
typeStack=popSafeRefType(typeStack);
break;
case ByteCode.FASTORE:
typeStack=popSafe(typeStack,FloatType.v());
typeStack=popSafe(typeStack,IntType.v());
typeStack=popSafeRefType(typeStack);
break;
case ByteCode.LASTORE:
typeStack=popSafe(typeStack,Long2ndHalfType.v());
typeStack=popSafe(typeStack,LongType.v());
typeStack=popSafe(typeStack,IntType.v());
typeStack=popSafeRefType(typeStack);
break;
case ByteCode.DASTORE:
typeStack=popSafe(typeStack,Double2ndHalfType.v());
typeStack=popSafe(typeStack,DoubleType.v());
typeStack=popSafe(typeStack,IntType.v());
typeStack=popSafeRefType(typeStack);
break;
case ByteCode.NOP:
break;
case ByteCode.POP:
typeStack=typeStack.pop();
break;
case ByteCode.POP2:
typeStack=typeStack.pop();
typeStack=typeStack.pop();
break;
case ByteCode.DUP:
typeStack=typeStack.push(typeStack.top());
break;
case ByteCode.DUP2:
{
Type topType=typeStack.get(typeStack.topIndex()), secondType=typeStack.get(typeStack.topIndex() - 1);
typeStack=(typeStack.push(secondType)).push(topType);
break;
}
case ByteCode.DUP_X1:
{
Type topType=typeStack.get(typeStack.topIndex()), secondType=typeStack.get(typeStack.topIndex() - 1);
typeStack=typeStack.pop().pop();
typeStack=typeStack.push(topType).push(secondType).push(topType);
break;
}
case ByteCode.DUP_X2:
{
Type topType=typeStack.get(typeStack.topIndex()), secondType=typeStack.get(typeStack.topIndex() - 1), thirdType=typeStack.get(typeStack.topIndex() - 2);
typeStack=typeStack.pop().pop().pop();
typeStack=typeStack.push(topType).push(thirdType).push(secondType).push(topType);
break;
}
case ByteCode.DUP2_X1:
{
Type topType=typeStack.get(typeStack.topIndex()), secondType=typeStack.get(typeStack.topIndex() - 1), thirdType=typeStack.get(typeStack.topIndex() - 2);
typeStack=typeStack.pop().pop().pop();
typeStack=typeStack.push(secondType).push(topType).push(thirdType).push(secondType).push(topType);
break;
}
case ByteCode.DUP2_X2:
{
Type topType=typeStack.get(typeStack.topIndex()), secondType=typeStack.get(typeStack.topIndex() - 1), thirdType=typeStack.get(typeStack.topIndex() - 2), fourthType=typeStack.get(typeStack.topIndex() - 3);
typeStack=typeStack.pop().pop().pop().pop();
typeStack=typeStack.push(secondType).push(topType).push(fourthType).push(thirdType).push(secondType).push(topType);
break;
}
case ByteCode.SWAP:
{
Type topType=typeStack.top();
typeStack=typeStack.pop();
Type secondType=typeStack.top();
typeStack=typeStack.pop();
typeStack=typeStack.push(topType);
typeStack=typeStack.push(secondType);
break;
}
case ByteCode.IADD:
case ByteCode.ISUB:
case ByteCode.IMUL:
case ByteCode.IDIV:
case ByteCode.IREM:
case ByteCode.ISHL:
case ByteCode.ISHR:
case ByteCode.IUSHR:
case ByteCode.IAND:
case ByteCode.IOR:
case ByteCode.IXOR:
typeStack=popSafe(typeStack,IntType.v());
typeStack=popSafe(typeStack,IntType.v());
typeStack=typeStack.push(IntType.v());
break;
case ByteCode.LUSHR:
case ByteCode.LSHR:
case ByteCode.LSHL:
typeStack=popSafe(typeStack,IntType.v());
typeStack=popSafe(typeStack,Long2ndHalfType.v());
typeStack=popSafe(typeStack,LongType.v());
typeStack=typeStack.push(LongType.v());
typeStack=typeStack.push(Long2ndHalfType.v());
break;
case ByteCode.LREM:
case ByteCode.LDIV:
case ByteCode.LMUL:
case ByteCode.LSUB:
case ByteCode.LADD:
case ByteCode.LAND:
case ByteCode.LOR:
case ByteCode.LXOR:
typeStack=popSafe(typeStack,Long2ndHalfType.v());
typeStack=popSafe(typeStack,LongType.v());
typeStack=popSafe(typeStack,Long2ndHalfType.v());
typeStack=popSafe(typeStack,LongType.v());
typeStack=typeStack.push(LongType.v());
typeStack=typeStack.push(Long2ndHalfType.v());
break;
case ByteCode.FREM:
case ByteCode.FDIV:
case ByteCode.FMUL:
case ByteCode.FSUB:
case ByteCode.FADD:
typeStack=popSafe(typeStack,FloatType.v());
typeStack=popSafe(typeStack,FloatType.v());
typeStack=typeStack.push(FloatType.v());
break;
case ByteCode.DREM:
case ByteCode.DDIV:
case ByteCode.DMUL:
case ByteCode.DSUB:
case ByteCode.DADD:
typeStack=popSafe(typeStack,Double2ndHalfType.v());
typeStack=popSafe(typeStack,DoubleType.v());
typeStack=popSafe(typeStack,Double2ndHalfType.v());
typeStack=popSafe(typeStack,DoubleType.v());
typeStack=typeStack.push(DoubleType.v());
typeStack=typeStack.push(Double2ndHalfType.v());
break;
case ByteCode.INEG:
case ByteCode.LNEG:
case ByteCode.FNEG:
case ByteCode.DNEG:
break;
case ByteCode.I2L:
typeStack=popSafe(typeStack,IntType.v());
typeStack=typeStack.push(LongType.v());
typeStack=typeStack.push(Long2ndHalfType.v());
break;
case ByteCode.I2F:
typeStack=popSafe(typeStack,IntType.v());
typeStack=typeStack.push(FloatType.v());
break;
case ByteCode.I2D:
typeStack=popSafe(typeStack,IntType.v());
typeStack=typeStack.push(DoubleType.v());
typeStack=typeStack.push(Double2ndHalfType.v());
break;
case ByteCode.L2I:
typeStack=popSafe(typeStack,Long2ndHalfType.v());
typeStack=popSafe(typeStack,LongType.v());
typeStack=typeStack.push(IntType.v());
break;
case ByteCode.L2F:
typeStack=popSafe(typeStack,Long2ndHalfType.v());
typeStack=popSafe(typeStack,LongType.v());
typeStack=typeStack.push(FloatType.v());
break;
case ByteCode.L2D:
typeStack=popSafe(typeStack,Long2ndHalfType.v());
typeStack=popSafe(typeStack,LongType.v());
typeStack=typeStack.push(DoubleType.v());
typeStack=typeStack.push(Double2ndHalfType.v());
break;
case ByteCode.F2I:
typeStack=popSafe(typeStack,FloatType.v());
typeStack=typeStack.push(IntType.v());
break;
case ByteCode.F2L:
typeStack=popSafe(typeStack,FloatType.v());
typeStack=typeStack.push(LongType.v());
typeStack=typeStack.push(Long2ndHalfType.v());
break;
case ByteCode.F2D:
typeStack=popSafe(typeStack,FloatType.v());
typeStack=typeStack.push(DoubleType.v());
typeStack=typeStack.push(Double2ndHalfType.v());
break;
case ByteCode.D2I:
typeStack=popSafe(typeStack,Double2ndHalfType.v());
typeStack=popSafe(typeStack,DoubleType.v());
typeStack=typeStack.push(IntType.v());
break;
case ByteCode.D2L:
typeStack=popSafe(typeStack,Double2ndHalfType.v());
typeStack=popSafe(typeStack,DoubleType.v());
typeStack=typeStack.push(LongType.v());
typeStack=typeStack.push(Long2ndHalfType.v());
break;
case ByteCode.D2F:
typeStack=popSafe(typeStack,Double2ndHalfType.v());
typeStack=popSafe(typeStack,DoubleType.v());
typeStack=typeStack.push(FloatType.v());
break;
case ByteCode.INT2BYTE:
break;
case ByteCode.INT2CHAR:
break;
case ByteCode.INT2SHORT:
break;
case ByteCode.IFEQ:
case ByteCode.IFGT:
case ByteCode.IFLT:
case ByteCode.IFLE:
case ByteCode.IFNE:
case ByteCode.IFGE:
typeStack=popSafe(typeStack,IntType.v());
break;
case ByteCode.IFNULL:
case ByteCode.IFNONNULL:
typeStack=popSafeRefType(typeStack);
break;
case ByteCode.IF_ICMPEQ:
case ByteCode.IF_ICMPLT:
case ByteCode.IF_ICMPLE:
case ByteCode.IF_ICMPNE:
case ByteCode.IF_ICMPGT:
case ByteCode.IF_ICMPGE:
typeStack=popSafe(typeStack,IntType.v());
typeStack=popSafe(typeStack,IntType.v());
break;
case ByteCode.LCMP:
typeStack=popSafe(typeStack,Long2ndHalfType.v());
typeStack=popSafe(typeStack,LongType.v());
typeStack=popSafe(typeStack,Long2ndHalfType.v());
typeStack=popSafe(typeStack,LongType.v());
typeStack=typeStack.push(IntType.v());
break;
case ByteCode.FCMPL:
case ByteCode.FCMPG:
typeStack=popSafe(typeStack,FloatType.v());
typeStack=popSafe(typeStack,FloatType.v());
typeStack=typeStack.push(IntType.v());
break;
case ByteCode.DCMPL:
case ByteCode.DCMPG:
typeStack=popSafe(typeStack,Double2ndHalfType.v());
typeStack=popSafe(typeStack,DoubleType.v());
typeStack=popSafe(typeStack,Double2ndHalfType.v());
typeStack=popSafe(typeStack,DoubleType.v());
typeStack=typeStack.push(IntType.v());
break;
case ByteCode.IF_ACMPEQ:
case ByteCode.IF_ACMPNE:
typeStack=popSafeRefType(typeStack);
typeStack=popSafeRefType(typeStack);
break;
case ByteCode.GOTO:
case ByteCode.GOTO_W:
break;
case ByteCode.JSR:
case ByteCode.JSR_W:
typeStack=typeStack.push(StmtAddressType.v());
break;
case ByteCode.RET:
break;
case ByteCode.RET_W:
break;
case ByteCode.RETURN:
break;
case ByteCode.IRETURN:
typeStack=popSafe(typeStack,IntType.v());
break;
case ByteCode.FRETURN:
typeStack=popSafe(typeStack,FloatType.v());
break;
case ByteCode.ARETURN:
typeStack=popSafeRefType(typeStack);
break;
case ByteCode.DRETURN:
typeStack=popSafe(typeStack,Double2ndHalfType.v());
typeStack=popSafe(typeStack,DoubleType.v());
break;
case ByteCode.LRETURN:
typeStack=popSafe(typeStack,Long2ndHalfType.v());
typeStack=popSafe(typeStack,LongType.v());
break;
case ByteCode.BREAKPOINT:
break;
case ByteCode.TABLESWITCH:
typeStack=popSafe(typeStack,IntType.v());
break;
case ByteCode.LOOKUPSWITCH:
typeStack=popSafe(typeStack,IntType.v());
break;
case ByteCode.PUTFIELD:
{
Type type=byteCodeTypeOf(jimpleTypeOfFieldInFieldRef(cm,constant_pool,((Instruction_Putfield)ins).arg_i));
if (type.equals(DoubleType.v())) {
typeStack=popSafe(typeStack,Double2ndHalfType.v());
typeStack=popSafe(typeStack,DoubleType.v());
}
 else if (type.equals(LongType.v())) {
typeStack=popSafe(typeStack,Long2ndHalfType.v());
typeStack=popSafe(typeStack,LongType.v());
}
 else if (type instanceof RefType) typeStack=popSafeRefType(typeStack);
 else typeStack=popSafe(typeStack,type);
typeStack=popSafeRefType(typeStack);
break;
}
case ByteCode.GETFIELD:
{
Type type=byteCodeTypeOf(jimpleTypeOfFieldInFieldRef(cm,constant_pool,((Instruction_Getfield)ins).arg_i));
typeStack=popSafeRefType(typeStack);
if (type.equals(DoubleType.v())) {
typeStack=typeStack.push(DoubleType.v());
typeStack=typeStack.push(Double2ndHalfType.v());
}
 else if (type.equals(LongType.v())) {
typeStack=typeStack.push(LongType.v());
typeStack=typeStack.push(Long2ndHalfType.v());
}
 else typeStack=typeStack.push(type);
break;
}
case ByteCode.PUTSTATIC:
{
Type type=byteCodeTypeOf(jimpleTypeOfFieldInFieldRef(cm,constant_pool,((Instruction_Putstatic)ins).arg_i));
if (type.equals(DoubleType.v())) {
typeStack=popSafe(typeStack,Double2ndHalfType.v());
typeStack=popSafe(typeStack,DoubleType.v());
}
 else if (type.equals(LongType.v())) {
typeStack=popSafe(typeStack,Long2ndHalfType.v());
typeStack=popSafe(typeStack,LongType.v());
}
 else if (type instanceof RefType) typeStack=popSafeRefType(typeStack);
 else typeStack=popSafe(typeStack,type);
break;
}
case ByteCode.GETSTATIC:
{
Type type=byteCodeTypeOf(jimpleTypeOfFieldInFieldRef(cm,constant_pool,((Instruction_Getstatic)ins).arg_i));
if (type.equals(DoubleType.v())) {
typeStack=typeStack.push(DoubleType.v());
typeStack=typeStack.push(Double2ndHalfType.v());
}
 else if (type.equals(LongType.v())) {
typeStack=typeStack.push(LongType.v());
typeStack=typeStack.push(Long2ndHalfType.v());
}
 else typeStack=typeStack.push(type);
break;
}
case ByteCode.INVOKEVIRTUAL:
{
Instruction_Invokevirtual iv=(Instruction_Invokevirtual)ins;
int args=cp_info.countParams(constant_pool,iv.arg_i);
Type returnType=byteCodeTypeOf(jimpleReturnTypeOfMethodRef(cm,constant_pool,iv.arg_i));
for (int j=args - 1; j >= 0; j--) {
if (typeStack.top().equals(Long2ndHalfType.v())) {
typeStack=popSafe(typeStack,Long2ndHalfType.v());
typeStack=popSafe(typeStack,LongType.v());
}
 else if (typeStack.top().equals(Double2ndHalfType.v())) {
typeStack=popSafe(typeStack,Double2ndHalfType.v());
typeStack=popSafe(typeStack,DoubleType.v());
}
 else typeStack=popSafe(typeStack,typeStack.top());
}
typeStack=popSafeRefType(typeStack);
if (!returnType.equals(VoidType.v())) typeStack=smartPush(typeStack,returnType);
break;
}
case ByteCode.INVOKENONVIRTUAL:
{
Instruction_Invokenonvirtual iv=(Instruction_Invokenonvirtual)ins;
int args=cp_info.countParams(constant_pool,iv.arg_i);
Type returnType=byteCodeTypeOf(jimpleReturnTypeOfMethodRef(cm,constant_pool,iv.arg_i));
for (int j=args - 1; j >= 0; j--) {
if (typeStack.top().equals(Long2ndHalfType.v())) {
typeStack=popSafe(typeStack,Long2ndHalfType.v());
typeStack=popSafe(typeStack,LongType.v());
}
 else if (typeStack.top().equals(Double2ndHalfType.v())) {
typeStack=popSafe(typeStack,Double2ndHalfType.v());
typeStack=popSafe(typeStack,DoubleType.v());
}
 else typeStack=popSafe(typeStack,typeStack.top());
}
typeStack=popSafeRefType(typeStack);
if (!returnType.equals(VoidType.v())) typeStack=smartPush(typeStack,returnType);
break;
}
case ByteCode.INVOKESTATIC:
{
Instruction_Invokestatic iv=(Instruction_Invokestatic)ins;
int args=cp_info.countParams(constant_pool,iv.arg_i);
Type returnType=byteCodeTypeOf(jimpleReturnTypeOfMethodRef(cm,constant_pool,iv.arg_i));
for (int j=args - 1; j >= 0; j--) {
if (typeStack.top().equals(Long2ndHalfType.v())) {
typeStack=popSafe(typeStack,Long2ndHalfType.v());
typeStack=popSafe(typeStack,LongType.v());
}
 else if (typeStack.top().equals(Double2ndHalfType.v())) {
typeStack=popSafe(typeStack,Double2ndHalfType.v());
typeStack=popSafe(typeStack,DoubleType.v());
}
 else typeStack=popSafe(typeStack,typeStack.top());
}
if (!returnType.equals(VoidType.v())) typeStack=smartPush(typeStack,returnType);
break;
}
case ByteCode.INVOKEINTERFACE:
{
Instruction_Invokeinterface iv=(Instruction_Invokeinterface)ins;
int args=cp_info.countParams(constant_pool,iv.arg_i);
Type returnType=byteCodeTypeOf(jimpleReturnTypeOfInterfaceMethodRef(cm,constant_pool,iv.arg_i));
for (int j=args - 1; j >= 0; j--) {
if (typeStack.top().equals(Long2ndHalfType.v())) {
typeStack=popSafe(typeStack,Long2ndHalfType.v());
typeStack=popSafe(typeStack,LongType.v());
}
 else if (typeStack.top().equals(Double2ndHalfType.v())) {
typeStack=popSafe(typeStack,Double2ndHalfType.v());
typeStack=popSafe(typeStack,DoubleType.v());
}
 else typeStack=popSafe(typeStack,typeStack.top());
}
typeStack=popSafeRefType(typeStack);
if (!returnType.equals(VoidType.v())) typeStack=smartPush(typeStack,returnType);
break;
}
case ByteCode.ATHROW:
break;
case ByteCode.NEW:
{
Type type=RefType.v(getClassName(constant_pool,((Instruction_New)ins).arg_i));
typeStack=typeStack.push(type);
break;
}
case ByteCode.CHECKCAST:
{
String className=getClassName(constant_pool,((Instruction_Checkcast)ins).arg_i);
Type castType;
if (className.startsWith(""String_Node_Str"")) castType=Util.v().jimpleTypeOfFieldDescriptor(getClassName(constant_pool,((Instruction_Checkcast)ins).arg_i));
 else castType=RefType.v(className);
typeStack=popSafeRefType(typeStack);
typeStack=typeStack.push(castType);
break;
}
case ByteCode.INSTANCEOF:
{
typeStack=popSafeRefType(typeStack);
typeStack=typeStack.push(IntType.v());
break;
}
case ByteCode.MONITORENTER:
typeStack=popSafeRefType(typeStack);
break;
case ByteCode.MONITOREXIT:
typeStack=popSafeRefType(typeStack);
break;
default :
throw new RuntimeException(""String_Node_Str"" + x);
}
return new OutFlow(typeStack);
}"
88538,"public void setup(PaddleOptions opts){
  options=opts;
switch (options.backend()) {
case PaddleOptions.backend_buddy:
    Jedd.v().setBackend(""String_Node_Str"");
  break;
case PaddleOptions.backend_cudd:
Jedd.v().setBackend(""String_Node_Str"");
break;
case PaddleOptions.backend_sable:
Jedd.v().setBackend(""String_Node_Str"");
break;
case PaddleOptions.backend_javabdd:
Jedd.v().setBackend(""String_Node_Str"");
break;
case PaddleOptions.backend_none:
break;
default :
throw new RuntimeException(""String_Node_Str"" + options.backend());
}
if (options.backend() != PaddleOptions.backend_none) {
PhysicalDomain[] vs={V1.v(),V2.v(),MS.v(),ST.v()};
PhysicalDomain[] ts={T1.v(),T2.v(),T3.v(),MT.v(),SG.v()};
PhysicalDomain[] cs={C1.v(),C2.v(),C3.v()};
Object[] order={cs,vs,FD.v(),H1.v(),H2.v(),ts,KD.v()};
Jedd.v().setOrder(order,true);
}
if (options.profile()) {
Jedd.v().enableProfiling();
}
if (options.bdd()) {
buildBDD();
}
 else {
buildTrad();
}
makeSetFactories();
depMan.addDep(scgbout,cicg);
depMan.addDep(cicgout,rm);
depMan.addDep(csout,rm);
depMan.addDep(rmout,scgb);
depMan.addDep(scmout,cg);
depMan.addDep(vcmout,cg);
depMan.addDep(cgout,cg);
depMan.addDep(rcout,cscgb);
depMan.addDep(cicgout,cscgb);
depMan.addDep(rmout,mpb);
depMan.addDep(locals,ni);
depMan.addDep(globals,ni);
depMan.addDep(localallocs,ni);
depMan.addDep(globalallocs,ni);
depMan.addDep(ni,mpb);
depMan.addDep(simple,mpc);
depMan.addDep(store,mpc);
depMan.addDep(load,mpc);
depMan.addDep(alloc,mpc);
depMan.addDep(rcout,mpc);
depMan.addDep(ni,cec);
depMan.addDep(parms,cec);
depMan.addDep(rets,cec);
depMan.addDep(cgout,cec);
depMan.addDep(cgout,ecs);
depMan.addDep(ecsout,ceh);
depMan.addDep(csimple,pag);
depMan.addDep(cload,pag);
depMan.addDep(cstore,pag);
depMan.addDep(calloc,pag);
depMan.addDep(csimple,prop);
depMan.addDep(cload,prop);
depMan.addDep(cstore,prop);
depMan.addDep(calloc,prop);
depMan.addDep(paout,vcr);
depMan.addDep(receivers,vcr);
depMan.addDep(specials,vcr);
depMan.addDep(rcout,cs);
depMan.addDep(locals,tm);
depMan.addDep(globals,tm);
depMan.addDep(localallocs,tm);
depMan.addDep(globalallocs,tm);
depMan.addDep(staticcalls,scm);
depMan.addDep(virtualcalls,vcm);
depMan.addDep(cicg,cscgb);
depMan.addDep(cicg,cg);
depMan.addDep(cicg,rm);
depMan.addDep(tm,prop);
depMan.addDep(pag,prop);
depMan.addDep(cg,rc);
depMan.addPrec(cec,globalallocs);
depMan.addPrec(cec,globals);
depMan.addPrec(cec,locals);
depMan.addPrec(cec,localallocs);
depMan.addPrec(cec,ni);
depMan.addPrec(cec,parms);
depMan.addPrec(cec,rets);
depMan.addPrec(cec,ceh);
depMan.addPrec(cec,ecsout);
depMan.addPrec(cec,ecs);
depMan.addPrec(cec,cgout);
depMan.addPrec(mpc,globalallocs);
depMan.addPrec(mpc,globals);
depMan.addPrec(mpc,locals);
depMan.addPrec(mpc,localallocs);
depMan.addPrec(mpc,ni);
depMan.addPrec(mpc,simple);
depMan.addPrec(mpc,store);
depMan.addPrec(mpc,load);
depMan.addPrec(mpc,alloc);
depMan.addPrec(mpc,mpb);
depMan.addPrec(mpc,rmout);
depMan.addPrec(mpc,rcout);
depMan.addPrec(mpc,rc);
depMan.addPrec(mpc,cs);
depMan.addPrec(mpc,csout);
depMan.addPrec(mpc,rm);
depMan.addPrec(prop,cstore);
depMan.addPrec(prop,csimple);
depMan.addPrec(prop,calloc);
depMan.addPrec(prop,cload);
depMan.addPrec(prop,pag);
}","public void setup(PaddleOptions opts){
  options=opts;
switch (options.backend()) {
case PaddleOptions.backend_buddy:
    Jedd.v().setBackend(""String_Node_Str"");
  break;
case PaddleOptions.backend_cudd:
Jedd.v().setBackend(""String_Node_Str"");
break;
case PaddleOptions.backend_sable:
Jedd.v().setBackend(""String_Node_Str"");
break;
case PaddleOptions.backend_javabdd:
Jedd.v().setBackend(""String_Node_Str"");
break;
case PaddleOptions.backend_none:
break;
default :
throw new RuntimeException(""String_Node_Str"" + options.backend());
}
if (options.backend() != PaddleOptions.backend_none) {
PhysicalDomain[] vs={V1.v(),V2.v(),MS.v(),ST.v()};
PhysicalDomain[] ts={T1.v(),T2.v(),T3.v(),MT.v(),SG.v()};
PhysicalDomain[] cs={C1.v(),C2.v(),C3.v()};
Object[] order={cs,vs,FD.v(),H1.v(),H2.v(),ts,KD.v()};
Jedd.v().setOrder(order,true);
}
if (options.profile()) {
Jedd.v().enableProfiling();
}
if (options.bdd()) {
buildBDD();
}
 else {
buildTrad();
}
makeSetFactories();
depMan.addDep(scgbout,cicg);
depMan.addDep(cicgout,rm);
depMan.addDep(csout,rm);
depMan.addDep(rmout,scgb);
depMan.addDep(scmout,cg);
depMan.addDep(vcmout,cg);
depMan.addDep(cgout,cg);
depMan.addDep(rcout,cscgb);
depMan.addDep(cicgout,cscgb);
depMan.addDep(rmout,mpb);
depMan.addDep(locals,ni);
depMan.addDep(globals,ni);
depMan.addDep(localallocs,ni);
depMan.addDep(globalallocs,ni);
depMan.addDep(ni,mpb);
depMan.addDep(simple,mpc);
depMan.addDep(store,mpc);
depMan.addDep(load,mpc);
depMan.addDep(alloc,mpc);
depMan.addDep(rcout,mpc);
depMan.addDep(ni,cec);
depMan.addDep(parms,cec);
depMan.addDep(rets,cec);
depMan.addDep(cgout,cec);
depMan.addDep(cgout,ecs);
depMan.addDep(ecsout,ceh);
depMan.addDep(csimple,pag);
depMan.addDep(cload,pag);
depMan.addDep(cstore,pag);
depMan.addDep(calloc,pag);
depMan.addDep(csimple,prop);
depMan.addDep(cload,prop);
depMan.addDep(cstore,prop);
depMan.addDep(calloc,prop);
depMan.addDep(paout,vcr);
depMan.addDep(receivers,vcr);
depMan.addDep(specials,vcr);
depMan.addDep(rcout,cs);
depMan.addDep(locals,tm);
depMan.addDep(globals,tm);
depMan.addDep(localallocs,tm);
depMan.addDep(globalallocs,tm);
depMan.addDep(staticcalls,scm);
depMan.addDep(virtualcalls,vcm);
depMan.addDep(cicg,cscgb);
depMan.addDep(cicg,cg);
depMan.addDep(cicg,rm);
depMan.addDep(tm,prop);
depMan.addDep(pag,prop);
depMan.addDep(cg,rc);
depMan.addPrec(cec,globalallocs);
depMan.addPrec(cec,globals);
depMan.addPrec(cec,locals);
depMan.addPrec(cec,localallocs);
depMan.addPrec(cec,ni);
depMan.addPrec(cec,parms);
depMan.addPrec(cec,rets);
depMan.addPrec(cec,ceh);
depMan.addPrec(cec,ecsout);
depMan.addPrec(cec,ecs);
depMan.addPrec(cec,cgout);
depMan.addPrec(mpc,globalallocs);
depMan.addPrec(mpc,globals);
depMan.addPrec(mpc,locals);
depMan.addPrec(mpc,localallocs);
depMan.addPrec(mpc,ni);
depMan.addPrec(mpc,simple);
depMan.addPrec(mpc,store);
depMan.addPrec(mpc,load);
depMan.addPrec(mpc,alloc);
depMan.addPrec(mpc,mpb);
depMan.addPrec(mpc,rmout);
depMan.addPrec(mpc,rcout);
depMan.addPrec(mpc,rc);
depMan.addPrec(mpc,cs);
depMan.addPrec(mpc,csout);
depMan.addPrec(mpc,rm);
depMan.addPrec(prop,cstore);
depMan.addPrec(prop,csimple);
depMan.addPrec(prop,calloc);
depMan.addPrec(prop,cload);
depMan.addPrec(prop,pag);
depMan.addPrec(vcr,receivers);
depMan.addPrec(vcr,specials);
depMan.addPrec(vcr,scgb);
depMan.addPrec(vcr,rmout);
}"
88539,"private boolean newEdges(){
  boolean ret=false;
  for (Iterator tIt=newSimple.iterator(); tIt.hasNext(); ) {
    final Rsrcc_src_dstc_dst.Tuple t=(Rsrcc_src_dstc_dst.Tuple)tIt.next();
    ret=true;
    if (p2setsMake(t.dstc(),t.dst()).addAll(p2setsGet(t.srcc(),t.src()),null))     addToVarNodeWorkList(ContextVarNode.make(t.dstc(),t.dst()));
  }
  for (Iterator tIt=newAlloc.iterator(); tIt.hasNext(); ) {
    final Robjc_obj_varc_var.Tuple t=(Robjc_obj_varc_var.Tuple)tIt.next();
    ret=true;
    ContextVarNode cvn=ContextVarNode.make(t.varc(),t.var());
    if (p2setsMake(cvn).add(t.objc(),t.obj()))     addToVarNodeWorkList(cvn);
  }
  for (Iterator tIt=newLoad.iterator(); tIt.hasNext(); ) {
    final Rsrcc_src_fld_dstc_dst.Tuple t=(Rsrcc_src_fld_dstc_dst.Tuple)tIt.next();
    ret=true;
    ContextVarNode srccvn=ContextVarNode.make(t.srcc(),t.src());
    if (fieldToBase.put(t.fld(),srccvn)) {
      addToAliasWorkList(srccvn);
    }
  }
  for (Iterator tIt=newStore.iterator(); tIt.hasNext(); ) {
    final Rsrcc_src_fld_dstc_dst.Tuple t=(Rsrcc_src_fld_dstc_dst.Tuple)tIt.next();
    ret=true;
    ContextVarNode dstcvn=ContextVarNode.make(t.dstc(),t.dst());
    if (fieldToBase.put(t.fld(),dstcvn)) {
      addToAliasWorkList(dstcvn);
    }
  }
  return ret;
}","private boolean newEdges(){
  boolean ret=false;
  for (Iterator tIt=newSimple.iterator(); tIt.hasNext(); ) {
    final Rsrcc_src_dstc_dst.Tuple t=(Rsrcc_src_dstc_dst.Tuple)tIt.next();
    ret=true;
    if (p2setsMake(t.dstc(),t.dst()).addAll(p2setsGet(t.srcc(),t.src()),null))     addToVarNodeWorkList(ContextVarNode.make(t.dstc(),t.dst()));
  }
  for (Iterator tIt=newAlloc.iterator(); tIt.hasNext(); ) {
    final Robjc_obj_varc_var.Tuple t=(Robjc_obj_varc_var.Tuple)tIt.next();
    ret=true;
    ContextVarNode cvn=ContextVarNode.make(t.varc(),t.var());
    if (p2setsMake(cvn).add(t.objc(),t.obj()))     addToVarNodeWorkList(cvn);
  }
  for (Iterator tIt=newLoad.iterator(); tIt.hasNext(); ) {
    final Rsrcc_src_fld_dstc_dst.Tuple t=(Rsrcc_src_fld_dstc_dst.Tuple)tIt.next();
    ret=true;
    ContextVarNode srccvn=ContextVarNode.make(t.srcc(),t.src());
    if (fieldToBase.put(t.fld(),srccvn)) {
      addToAliasWorkList(srccvn);
    }
  }
  for (Iterator tIt=newStore.iterator(); tIt.hasNext(); ) {
    final Rsrcc_src_dstc_dst_fld.Tuple t=(Rsrcc_src_dstc_dst_fld.Tuple)tIt.next();
    ret=true;
    ContextVarNode dstcvn=ContextVarNode.make(t.dstc(),t.dst());
    if (fieldToBase.put(t.fld(),dstcvn)) {
      addToAliasWorkList(dstcvn);
    }
  }
  return ret;
}"
88540,"private boolean newEdges(){
  boolean change=false;
  for (Iterator tIt=newSimple.iterator(); tIt.hasNext(); ) {
    final Rsrcc_src_dstc_dst.Tuple t=(Rsrcc_src_dstc_dst.Tuple)tIt.next();
    change=true;
    PointsToSetReadOnly p2set=p2sets.get(t.srcc(),t.src());
    if (p2set instanceof PointsToSetInternal) {
      ((PointsToSetInternal)p2set).unFlushNew();
    }
  }
  for (Iterator tIt=newLoad.iterator(); tIt.hasNext(); ) {
    final Rsrcc_src_fld_dstc_dst.Tuple t=(Rsrcc_src_fld_dstc_dst.Tuple)tIt.next();
    change=true;
  }
  for (Iterator tIt=newStore.iterator(); tIt.hasNext(); ) {
    final Rsrcc_src_fld_dstc_dst.Tuple t=(Rsrcc_src_fld_dstc_dst.Tuple)tIt.next();
    change=true;
    PointsToSetReadOnly p2set=p2sets.get(t.srcc(),t.src());
    if (p2set instanceof PointsToSetInternal) {
      ((PointsToSetInternal)p2set).unFlushNew();
    }
  }
  for (Iterator tIt=newAlloc.iterator(); tIt.hasNext(); ) {
    final Robjc_obj_varc_var.Tuple t=(Robjc_obj_varc_var.Tuple)tIt.next();
    change=true;
    p2sets.make(t.varc(),t.var()).add(t.objc(),t.obj());
  }
  return change;
}","private boolean newEdges(){
  boolean change=false;
  for (Iterator tIt=newSimple.iterator(); tIt.hasNext(); ) {
    final Rsrcc_src_dstc_dst.Tuple t=(Rsrcc_src_dstc_dst.Tuple)tIt.next();
    change=true;
    PointsToSetReadOnly p2set=p2sets.get(t.srcc(),t.src());
    if (p2set instanceof PointsToSetInternal) {
      ((PointsToSetInternal)p2set).unFlushNew();
    }
  }
  for (Iterator tIt=newLoad.iterator(); tIt.hasNext(); ) {
    final Rsrcc_src_fld_dstc_dst.Tuple t=(Rsrcc_src_fld_dstc_dst.Tuple)tIt.next();
    change=true;
  }
  for (Iterator tIt=newStore.iterator(); tIt.hasNext(); ) {
    final Rsrcc_src_dstc_dst_fld.Tuple t=(Rsrcc_src_dstc_dst_fld.Tuple)tIt.next();
    change=true;
    PointsToSetReadOnly p2set=p2sets.get(t.srcc(),t.src());
    if (p2set instanceof PointsToSetInternal) {
      ((PointsToSetInternal)p2set).unFlushNew();
    }
  }
  for (Iterator tIt=newAlloc.iterator(); tIt.hasNext(); ) {
    final Robjc_obj_varc_var.Tuple t=(Robjc_obj_varc_var.Tuple)tIt.next();
    change=true;
    p2sets.make(t.varc(),t.var()).add(t.objc(),t.obj());
  }
  return change;
}"
88541,"public soot.jimple.JimpleBody createBody(soot.SootMethod sootMethod){
  body=soot.jimple.Jimple.v().newBody(sootMethod);
  lg=new LocalGenerator(body);
  AnonClassInitMethodSource acims=(AnonClassInitMethodSource)body.getMethod().getSource();
  ArrayList fields=acims.getFinalsList();
  boolean inStaticMethod=acims.inStaticMethod();
  boolean isSubType=acims.isSubType();
  soot.Type superOuterType=acims.superOuterType();
  soot.Type thisOuterType=acims.thisOuterType();
  ArrayList fieldInits=acims.getFieldInits();
  soot.Type outerClassType=acims.outerClassType();
  polyglot.types.ClassType polyglotType=acims.polyglotType();
  boolean hasOuterRef=((AnonClassInitMethodSource)body.getMethod().getSource()).hasOuterRef();
  boolean hasQualifier=((AnonClassInitMethodSource)body.getMethod().getSource()).hasQualifier();
  soot.RefType type=sootMethod.getDeclaringClass().getType();
  specialThisLocal=soot.jimple.Jimple.v().newLocal(""String_Node_Str"",type);
  body.getLocals().add(specialThisLocal);
  soot.jimple.ThisRef thisRef=soot.jimple.Jimple.v().newThisRef(type);
  soot.jimple.Stmt thisStmt=soot.jimple.Jimple.v().newIdentityStmt(specialThisLocal,thisRef);
  body.getUnits().add(thisStmt);
  ArrayList invokeList=new ArrayList();
  ArrayList invokeTypeList=new ArrayList();
  int numParams=sootMethod.getParameterCount();
  int numFinals=0;
  if (fields != null) {
    numFinals=fields.size();
  }
  int startFinals=numParams - numFinals;
  ArrayList paramsForFinals=new ArrayList();
  soot.Local outerLocal=null;
  soot.Local qualifierLocal=null;
  Iterator fIt=sootMethod.getParameterTypes().iterator();
  int counter=0;
  while (fIt.hasNext()) {
    soot.Type fType=(soot.Type)fIt.next();
    soot.Local local=soot.jimple.Jimple.v().newLocal(""String_Node_Str"" + counter,fType);
    body.getLocals().add(local);
    soot.jimple.ParameterRef paramRef=soot.jimple.Jimple.v().newParameterRef(fType,counter);
    soot.jimple.Stmt stmt=soot.jimple.Jimple.v().newIdentityStmt(local,paramRef);
    int realArgs=0;
    if ((hasOuterRef) && (counter == 0)) {
      outerLocal=local;
      realArgs=1;
    }
    if ((hasOuterRef) && (hasQualifier) && (counter == 1)) {
      qualifierLocal=local;
      realArgs=2;
      invokeList.add(qualifierLocal);
    }
 else     if ((!hasOuterRef) && (hasQualifier) && (counter == 0)) {
      qualifierLocal=local;
      realArgs=1;
      invokeList.add(qualifierLocal);
    }
    if ((counter >= realArgs) && (counter < startFinals)) {
      invokeTypeList.add(fType);
      invokeList.add(local);
    }
 else     if (counter >= startFinals) {
      paramsForFinals.add(local);
    }
    body.getUnits().add(stmt);
    counter++;
  }
  SootClass superClass=sootMethod.getDeclaringClass().getSuperclass();
  if (needsOuterClassRef(polyglotType)) {
    invokeTypeList.add(0,superOuterType);
  }
  SootMethodRef callMethod=Scene.v().makeMethodRef(sootMethod.getDeclaringClass().getSuperclass(),""String_Node_Str"",invokeTypeList,VoidType.v(),false);
  if ((!hasQualifier) && (needsOuterClassRef(polyglotType))) {
    if (isSubType) {
      invokeList.add(0,outerLocal);
    }
 else {
      invokeList.add(0,Util.getThisGivenOuter(superOuterType,new HashMap(),body,new LocalGenerator(body),outerLocal));
    }
  }
  soot.jimple.InvokeExpr invoke=soot.jimple.Jimple.v().newSpecialInvokeExpr(specialThisLocal,callMethod,invokeList);
  soot.jimple.Stmt invokeStmt=soot.jimple.Jimple.v().newInvokeStmt(invoke);
  body.getUnits().add(invokeStmt);
  if (!inStaticMethod) {
    soot.SootFieldRef field=Scene.v().makeFieldRef(sootMethod.getDeclaringClass(),""String_Node_Str"",outerClassType,false);
    soot.jimple.InstanceFieldRef ref=soot.jimple.Jimple.v().newInstanceFieldRef(specialThisLocal,field);
    soot.jimple.AssignStmt assign=soot.jimple.Jimple.v().newAssignStmt(ref,outerLocal);
    body.getUnits().add(assign);
  }
  if (fields != null) {
    Iterator finalsIt=paramsForFinals.iterator();
    Iterator fieldsIt=fields.iterator();
    while (finalsIt.hasNext() && fieldsIt.hasNext()) {
      soot.Local pLocal=(soot.Local)finalsIt.next();
      soot.SootField pField=(soot.SootField)fieldsIt.next();
      soot.jimple.FieldRef pRef=soot.jimple.Jimple.v().newInstanceFieldRef(specialThisLocal,pField.makeRef());
      soot.jimple.AssignStmt pAssign=soot.jimple.Jimple.v().newAssignStmt(pRef,pLocal);
      body.getUnits().add(pAssign);
    }
  }
  if (fieldInits != null) {
    handleFieldInits(fieldInits);
  }
  ArrayList staticBlocks=((AnonClassInitMethodSource)body.getMethod().getSource()).getInitializerBlocks();
  if (staticBlocks != null) {
    handleStaticBlocks(staticBlocks);
  }
  soot.jimple.ReturnVoidStmt retStmt=soot.jimple.Jimple.v().newReturnVoidStmt();
  body.getUnits().add(retStmt);
  return body;
}","public soot.jimple.JimpleBody createBody(soot.SootMethod sootMethod){
  body=soot.jimple.Jimple.v().newBody(sootMethod);
  lg=new LocalGenerator(body);
  AnonClassInitMethodSource acims=(AnonClassInitMethodSource)body.getMethod().getSource();
  ArrayList fields=acims.getFinalsList();
  boolean inStaticMethod=acims.inStaticMethod();
  boolean isSubType=acims.isSubType();
  soot.Type superOuterType=acims.superOuterType();
  soot.Type thisOuterType=acims.thisOuterType();
  ArrayList fieldInits=acims.getFieldInits();
  soot.Type outerClassType=acims.outerClassType();
  polyglot.types.ClassType polyglotType=acims.polyglotType();
  polyglot.types.ClassType anonType=acims.anonType();
  boolean hasOuterRef=((AnonClassInitMethodSource)body.getMethod().getSource()).hasOuterRef();
  boolean hasQualifier=((AnonClassInitMethodSource)body.getMethod().getSource()).hasQualifier();
  soot.RefType type=sootMethod.getDeclaringClass().getType();
  specialThisLocal=soot.jimple.Jimple.v().newLocal(""String_Node_Str"",type);
  body.getLocals().add(specialThisLocal);
  soot.jimple.ThisRef thisRef=soot.jimple.Jimple.v().newThisRef(type);
  soot.jimple.Stmt thisStmt=soot.jimple.Jimple.v().newIdentityStmt(specialThisLocal,thisRef);
  body.getUnits().add(thisStmt);
  ArrayList invokeList=new ArrayList();
  ArrayList invokeTypeList=new ArrayList();
  int numParams=sootMethod.getParameterCount();
  int numFinals=0;
  if (fields != null) {
    numFinals=fields.size();
  }
  int startFinals=numParams - numFinals;
  ArrayList paramsForFinals=new ArrayList();
  soot.Local outerLocal=null;
  soot.Local qualifierLocal=null;
  Iterator fIt=sootMethod.getParameterTypes().iterator();
  int counter=0;
  while (fIt.hasNext()) {
    soot.Type fType=(soot.Type)fIt.next();
    soot.Local local=soot.jimple.Jimple.v().newLocal(""String_Node_Str"" + counter,fType);
    body.getLocals().add(local);
    soot.jimple.ParameterRef paramRef=soot.jimple.Jimple.v().newParameterRef(fType,counter);
    soot.jimple.Stmt stmt=soot.jimple.Jimple.v().newIdentityStmt(local,paramRef);
    int realArgs=0;
    if ((hasOuterRef) && (counter == 0)) {
      outerLocal=local;
      realArgs=1;
    }
    if ((hasOuterRef) && (hasQualifier) && (counter == 1)) {
      qualifierLocal=local;
      realArgs=2;
      invokeList.add(qualifierLocal);
    }
 else     if ((!hasOuterRef) && (hasQualifier) && (counter == 0)) {
      qualifierLocal=local;
      realArgs=1;
      invokeList.add(qualifierLocal);
    }
    if ((counter >= realArgs) && (counter < startFinals)) {
      invokeTypeList.add(fType);
      invokeList.add(local);
    }
 else     if (counter >= startFinals) {
      paramsForFinals.add(local);
    }
    body.getUnits().add(stmt);
    counter++;
  }
  SootClass superClass=sootMethod.getDeclaringClass().getSuperclass();
  if (needsOuterClassRef(polyglotType)) {
    invokeTypeList.add(0,superOuterType);
  }
  SootMethodRef callMethod=Scene.v().makeMethodRef(sootMethod.getDeclaringClass().getSuperclass(),""String_Node_Str"",invokeTypeList,VoidType.v(),false);
  if ((!hasQualifier) && (needsOuterClassRef(polyglotType))) {
    if (isSubType) {
      invokeList.add(0,outerLocal);
    }
 else {
      invokeList.add(0,Util.getThisGivenOuter(superOuterType,new HashMap(),body,new LocalGenerator(body),outerLocal));
    }
  }
  soot.jimple.InvokeExpr invoke=soot.jimple.Jimple.v().newSpecialInvokeExpr(specialThisLocal,callMethod,invokeList);
  soot.jimple.Stmt invokeStmt=soot.jimple.Jimple.v().newInvokeStmt(invoke);
  body.getUnits().add(invokeStmt);
  if (!inStaticMethod && needsOuterClassRef(anonType)) {
    soot.SootFieldRef field=Scene.v().makeFieldRef(sootMethod.getDeclaringClass(),""String_Node_Str"",outerClassType,false);
    soot.jimple.InstanceFieldRef ref=soot.jimple.Jimple.v().newInstanceFieldRef(specialThisLocal,field);
    soot.jimple.AssignStmt assign=soot.jimple.Jimple.v().newAssignStmt(ref,outerLocal);
    body.getUnits().add(assign);
  }
  if (fields != null) {
    Iterator finalsIt=paramsForFinals.iterator();
    Iterator fieldsIt=fields.iterator();
    while (finalsIt.hasNext() && fieldsIt.hasNext()) {
      soot.Local pLocal=(soot.Local)finalsIt.next();
      soot.SootField pField=(soot.SootField)fieldsIt.next();
      soot.jimple.FieldRef pRef=soot.jimple.Jimple.v().newInstanceFieldRef(specialThisLocal,pField.makeRef());
      soot.jimple.AssignStmt pAssign=soot.jimple.Jimple.v().newAssignStmt(pRef,pLocal);
      body.getUnits().add(pAssign);
    }
  }
  if (fieldInits != null) {
    handleFieldInits(fieldInits);
  }
  ArrayList staticBlocks=((AnonClassInitMethodSource)body.getMethod().getSource()).getInitializerBlocks();
  if (staticBlocks != null) {
    handleStaticBlocks(staticBlocks);
  }
  soot.jimple.ReturnVoidStmt retStmt=soot.jimple.Jimple.v().newReturnVoidStmt();
  body.getUnits().add(retStmt);
  return body;
}"
88542,"/** 
 * creates the Jimple for an anon class - in the AST there is no class  decl for anon classes - the revelant fields and methods are  created 
 */
private void createAnonClassDecl(polyglot.ast.New aNew){
  SootClass outerClass=((soot.RefType)Util.getSootType(aNew.anonType().outer())).getSootClass();
  if (InitialResolver.v().getInnerClassInfoMap() == null) {
    InitialResolver.v().setInnerClassInfoMap(new HashMap());
  }
  InitialResolver.v().getInnerClassInfoMap().put(sootClass,new InnerClassInfo(outerClass,""String_Node_Str"",InnerClassInfo.ANON));
  sootClass.setOuterClass(outerClass);
  soot.SootClass typeClass=((soot.RefType)Util.getSootType(aNew.objectType().type())).getSootClass();
  if (((polyglot.types.ClassType)aNew.objectType().type()).flags().isInterface()) {
    sootClass.addInterface(typeClass);
    sootClass.setSuperclass(soot.Scene.v().getSootClass(""String_Node_Str""));
  }
 else {
    sootClass.setSuperclass(typeClass);
    if (((polyglot.types.ClassType)aNew.objectType().type()).isNested()) {
      polyglot.types.ClassType superType=(polyglot.types.ClassType)aNew.objectType().type();
      Util.addInnerClassTag(sootClass,typeClass.getName(),((soot.RefType)Util.getSootType(superType.outer())).toString(),superType.name(),Util.getModifier(superType.flags()));
    }
  }
  ArrayList params=new ArrayList();
  soot.SootMethod method;
  if (((polyglot.types.ClassType)aNew.objectType().type()).flags().isInterface()) {
    method=new soot.SootMethod(""String_Node_Str"",params,soot.VoidType.v());
  }
 else {
    Iterator aIt=aNew.arguments().iterator();
    while (aIt.hasNext()) {
      polyglot.types.Type pType=((polyglot.ast.Expr)aIt.next()).type();
      params.add(Util.getSootType(pType));
    }
    method=new soot.SootMethod(""String_Node_Str"",params,soot.VoidType.v());
  }
  AnonClassInitMethodSource src=new AnonClassInitMethodSource();
  method.setSource(src);
  sootClass.addMethod(method);
  AnonLocalClassInfo info=(AnonLocalClassInfo)InitialResolver.v().finalLocalInfo().get(new polyglot.util.IdentityKey(aNew.anonType()));
  if (aNew.qualifier() != null) {
    addQualifierRefToInit(aNew.qualifier().type());
    src.hasQualifier(true);
  }
  if (info != null && !info.inStaticMethod()) {
    addOuterClassThisRefToInit(aNew.anonType().outer());
    addOuterClassThisRefField(aNew.anonType().outer());
    src.thisOuterType(Util.getSootType(aNew.anonType().outer()));
    src.hasOuterRef(true);
  }
  src.polyglotType((polyglot.types.ClassType)aNew.anonType().superType());
  src.inStaticMethod(info.inStaticMethod());
  if (info != null) {
    src.setFinalsList(addFinalLocals(aNew.body(),info.finalLocalsAvail(),(polyglot.types.ClassType)aNew.anonType(),info));
  }
  src.outerClassType(Util.getSootType(aNew.anonType().outer()));
  if (((polyglot.types.ClassType)aNew.objectType().type()).isNested()) {
    src.superOuterType(Util.getSootType(((polyglot.types.ClassType)aNew.objectType().type()).outer()));
    src.isSubType(Util.isSubType(aNew.anonType().outer(),((polyglot.types.ClassType)aNew.objectType().type()).outer()));
  }
  Util.addLnPosTags(sootClass,aNew.position().line(),aNew.body().position().endLine(),aNew.position().column(),aNew.body().position().endColumn());
}","/** 
 * creates the Jimple for an anon class - in the AST there is no class  decl for anon classes - the revelant fields and methods are  created 
 */
private void createAnonClassDecl(polyglot.ast.New aNew){
  SootClass outerClass=((soot.RefType)Util.getSootType(aNew.anonType().outer())).getSootClass();
  if (InitialResolver.v().getInnerClassInfoMap() == null) {
    InitialResolver.v().setInnerClassInfoMap(new HashMap());
  }
  InitialResolver.v().getInnerClassInfoMap().put(sootClass,new InnerClassInfo(outerClass,""String_Node_Str"",InnerClassInfo.ANON));
  sootClass.setOuterClass(outerClass);
  soot.SootClass typeClass=((soot.RefType)Util.getSootType(aNew.objectType().type())).getSootClass();
  if (((polyglot.types.ClassType)aNew.objectType().type()).flags().isInterface()) {
    sootClass.addInterface(typeClass);
    sootClass.setSuperclass(soot.Scene.v().getSootClass(""String_Node_Str""));
  }
 else {
    sootClass.setSuperclass(typeClass);
    if (((polyglot.types.ClassType)aNew.objectType().type()).isNested()) {
      polyglot.types.ClassType superType=(polyglot.types.ClassType)aNew.objectType().type();
      Util.addInnerClassTag(sootClass,typeClass.getName(),((soot.RefType)Util.getSootType(superType.outer())).toString(),superType.name(),Util.getModifier(superType.flags()));
    }
  }
  ArrayList params=new ArrayList();
  soot.SootMethod method;
  if (((polyglot.types.ClassType)aNew.objectType().type()).flags().isInterface()) {
    method=new soot.SootMethod(""String_Node_Str"",params,soot.VoidType.v());
  }
 else {
    Iterator aIt=aNew.arguments().iterator();
    while (aIt.hasNext()) {
      polyglot.types.Type pType=((polyglot.ast.Expr)aIt.next()).type();
      params.add(Util.getSootType(pType));
    }
    method=new soot.SootMethod(""String_Node_Str"",params,soot.VoidType.v());
  }
  AnonClassInitMethodSource src=new AnonClassInitMethodSource();
  method.setSource(src);
  sootClass.addMethod(method);
  AnonLocalClassInfo info=(AnonLocalClassInfo)InitialResolver.v().finalLocalInfo().get(new polyglot.util.IdentityKey(aNew.anonType()));
  if (aNew.qualifier() != null) {
    addQualifierRefToInit(aNew.qualifier().type());
    src.hasQualifier(true);
  }
  if (info != null && !info.inStaticMethod()) {
    if (!InitialResolver.v().isAnonInCCall(aNew.anonType())) {
      addOuterClassThisRefToInit(aNew.anonType().outer());
      addOuterClassThisRefField(aNew.anonType().outer());
      src.thisOuterType(Util.getSootType(aNew.anonType().outer()));
      src.hasOuterRef(true);
    }
  }
  src.polyglotType((polyglot.types.ClassType)aNew.anonType().superType());
  src.anonType((polyglot.types.ClassType)aNew.anonType());
  src.inStaticMethod(info.inStaticMethod());
  if (info != null) {
    src.setFinalsList(addFinalLocals(aNew.body(),info.finalLocalsAvail(),(polyglot.types.ClassType)aNew.anonType(),info));
  }
  src.outerClassType(Util.getSootType(aNew.anonType().outer()));
  if (((polyglot.types.ClassType)aNew.objectType().type()).isNested()) {
    src.superOuterType(Util.getSootType(((polyglot.types.ClassType)aNew.objectType().type()).outer()));
    src.isSubType(Util.isSubType(aNew.anonType().outer(),((polyglot.types.ClassType)aNew.objectType().type()).outer()));
  }
  Util.addLnPosTags(sootClass,aNew.position().line(),aNew.body().position().endLine(),aNew.position().column(),aNew.body().position().endColumn());
}"
88543,"private void handleFinalLocals(polyglot.ast.ClassMember member){
  MethodFinalsChecker mfc=new MethodFinalsChecker();
  member.visit(mfc);
  AnonLocalClassInfo alci=new AnonLocalClassInfo();
  if (member instanceof polyglot.ast.ProcedureDecl) {
    polyglot.ast.ProcedureDecl procedure=(polyglot.ast.ProcedureDecl)member;
    alci.finalLocalsAvail(mfc.finalLocals());
    if (procedure.flags().isStatic()) {
      alci.inStaticMethod(true);
    }
  }
 else   if (member instanceof polyglot.ast.FieldDecl) {
    alci.finalLocalsAvail(new ArrayList());
    if (((polyglot.ast.FieldDecl)member).flags().isStatic()) {
      alci.inStaticMethod(true);
    }
  }
 else   if (member instanceof polyglot.ast.Initializer) {
    alci.finalLocalsAvail(mfc.finalLocals());
    if (((polyglot.ast.Initializer)member).flags().isStatic()) {
      alci.inStaticMethod(true);
    }
  }
  if (finalLocalInfo == null) {
    finalLocalInfo=new HashMap();
  }
  Iterator it=mfc.inners().iterator();
  while (it.hasNext()) {
    polyglot.types.ClassType cType=(polyglot.types.ClassType)((polyglot.util.IdentityKey)it.next()).object();
    HashMap typeToLocalUsed=mfc.typeToLocalsUsed();
    ArrayList localsUsed=new ArrayList();
    if (typeToLocalUsed.containsKey(new polyglot.util.IdentityKey(cType))) {
      ArrayList localsNeeded=(ArrayList)typeToLocalUsed.get(new polyglot.util.IdentityKey(cType));
      Iterator usesIt=localsNeeded.iterator();
      while (usesIt.hasNext()) {
        polyglot.types.LocalInstance li=(polyglot.types.LocalInstance)((polyglot.util.IdentityKey)usesIt.next()).object();
        if (alci.finalLocalsAvail().contains(new polyglot.util.IdentityKey(li))) {
          localsUsed.add(new polyglot.util.IdentityKey(li));
        }
      }
    }
    AnonLocalClassInfo info=new AnonLocalClassInfo();
    info.inStaticMethod(alci.inStaticMethod());
    info.finalLocalsAvail(localsUsed);
    if (!finalLocalInfo.containsKey(new polyglot.util.IdentityKey(cType))) {
      finalLocalInfo.put(new polyglot.util.IdentityKey(cType),info);
    }
  }
}","private void handleFinalLocals(polyglot.ast.ClassMember member){
  MethodFinalsChecker mfc=new MethodFinalsChecker();
  member.visit(mfc);
  if (cCallList == null) {
    cCallList=new ArrayList();
  }
  cCallList.addAll(mfc.ccallList());
  AnonLocalClassInfo alci=new AnonLocalClassInfo();
  if (member instanceof polyglot.ast.ProcedureDecl) {
    polyglot.ast.ProcedureDecl procedure=(polyglot.ast.ProcedureDecl)member;
    alci.finalLocalsAvail(mfc.finalLocals());
    if (procedure.flags().isStatic()) {
      alci.inStaticMethod(true);
    }
  }
 else   if (member instanceof polyglot.ast.FieldDecl) {
    alci.finalLocalsAvail(new ArrayList());
    if (((polyglot.ast.FieldDecl)member).flags().isStatic()) {
      alci.inStaticMethod(true);
    }
  }
 else   if (member instanceof polyglot.ast.Initializer) {
    alci.finalLocalsAvail(mfc.finalLocals());
    if (((polyglot.ast.Initializer)member).flags().isStatic()) {
      alci.inStaticMethod(true);
    }
  }
  if (finalLocalInfo == null) {
    finalLocalInfo=new HashMap();
  }
  Iterator it=mfc.inners().iterator();
  while (it.hasNext()) {
    polyglot.types.ClassType cType=(polyglot.types.ClassType)((polyglot.util.IdentityKey)it.next()).object();
    HashMap typeToLocalUsed=mfc.typeToLocalsUsed();
    ArrayList localsUsed=new ArrayList();
    if (typeToLocalUsed.containsKey(new polyglot.util.IdentityKey(cType))) {
      ArrayList localsNeeded=(ArrayList)typeToLocalUsed.get(new polyglot.util.IdentityKey(cType));
      Iterator usesIt=localsNeeded.iterator();
      while (usesIt.hasNext()) {
        polyglot.types.LocalInstance li=(polyglot.types.LocalInstance)((polyglot.util.IdentityKey)usesIt.next()).object();
        if (alci.finalLocalsAvail().contains(new polyglot.util.IdentityKey(li))) {
          localsUsed.add(new polyglot.util.IdentityKey(li));
        }
      }
    }
    AnonLocalClassInfo info=new AnonLocalClassInfo();
    info.inStaticMethod(alci.inStaticMethod());
    info.finalLocalsAvail(localsUsed);
    if (!finalLocalInfo.containsKey(new polyglot.util.IdentityKey(cType))) {
      finalLocalInfo.put(new polyglot.util.IdentityKey(cType),info);
    }
  }
}"
88544,"protected boolean needsOuterClassRef(polyglot.types.ClassType typeToInvoke){
  AnonLocalClassInfo info=(AnonLocalClassInfo)InitialResolver.v().finalLocalInfo().get(new polyglot.util.IdentityKey(typeToInvoke));
  if ((info != null) && (!info.inStaticMethod())) {
    return true;
  }
 else   if (typeToInvoke.isNested() && !typeToInvoke.flags().isStatic() && !typeToInvoke.isAnonymous()&& !typeToInvoke.isLocal()) {
    return true;
  }
  return false;
}","protected boolean needsOuterClassRef(polyglot.types.ClassType typeToInvoke){
  AnonLocalClassInfo info=(AnonLocalClassInfo)InitialResolver.v().finalLocalInfo().get(new polyglot.util.IdentityKey(typeToInvoke));
  if (InitialResolver.v().isAnonInCCall(typeToInvoke))   return false;
  if ((info != null) && (!info.inStaticMethod())) {
    return true;
  }
 else   if (typeToInvoke.isNested() && !typeToInvoke.flags().isStatic() && !typeToInvoke.isAnonymous()&& !typeToInvoke.isLocal()) {
    return true;
  }
  return false;
}"
88545,"public MethodFinalsChecker(){
  finalLocals=new ArrayList();
  inners=new ArrayList();
  typeToLocalsUsed=new HashMap();
}","public MethodFinalsChecker(){
  finalLocals=new ArrayList();
  inners=new ArrayList();
  ccallList=new ArrayList();
  typeToLocalsUsed=new HashMap();
}"
88546,"public polyglot.visit.NodeVisitor enter(polyglot.ast.Node parent,polyglot.ast.Node n){
  if (n instanceof polyglot.ast.LocalDecl) {
    polyglot.ast.LocalDecl ld=(polyglot.ast.LocalDecl)n;
    if (ld.flags().isFinal()) {
      if (!finalLocals.contains(new polyglot.util.IdentityKey(ld.localInstance()))) {
        finalLocals.add(new polyglot.util.IdentityKey(ld.localInstance()));
      }
    }
  }
  if (n instanceof polyglot.ast.Formal) {
    polyglot.ast.Formal ld=(polyglot.ast.Formal)n;
    if (ld.flags().isFinal()) {
      if (!finalLocals.contains(new polyglot.util.IdentityKey(ld.localInstance()))) {
        finalLocals.add(new polyglot.util.IdentityKey(ld.localInstance()));
      }
    }
  }
  return enter(n);
}","public polyglot.visit.NodeVisitor enter(polyglot.ast.Node parent,polyglot.ast.Node n){
  if (n instanceof polyglot.ast.LocalDecl) {
    polyglot.ast.LocalDecl ld=(polyglot.ast.LocalDecl)n;
    if (ld.flags().isFinal()) {
      if (!finalLocals.contains(new polyglot.util.IdentityKey(ld.localInstance()))) {
        finalLocals.add(new polyglot.util.IdentityKey(ld.localInstance()));
      }
    }
  }
  if (n instanceof polyglot.ast.Formal) {
    polyglot.ast.Formal ld=(polyglot.ast.Formal)n;
    if (ld.flags().isFinal()) {
      if (!finalLocals.contains(new polyglot.util.IdentityKey(ld.localInstance()))) {
        finalLocals.add(new polyglot.util.IdentityKey(ld.localInstance()));
      }
    }
  }
  if (n instanceof polyglot.ast.ConstructorCall) {
    ccallList.add(n);
  }
  return enter(n);
}"
88547,"protected soot.Local handlePrivateFieldSet(polyglot.ast.Expr expr,soot.Value right){
  return ext().handlePrivateFieldSet(expr,right);
}","protected soot.Local handlePrivateFieldSet(polyglot.ast.Expr expr,soot.Value right,soot.Value base){
  return ext().handlePrivateFieldSet(expr,right,base);
}"
88548,"protected soot.Local handlePrivateFieldAssignSet(polyglot.ast.Assign assign){
  if (assign.left() instanceof soot.javaToJimple.jj.ast.JjAccessField_c) {
    soot.javaToJimple.jj.ast.JjAccessField_c accessField=(soot.javaToJimple.jj.ast.JjAccessField_c)assign.left();
    if (assign.operator() == polyglot.ast.Assign.ASSIGN) {
      soot.Value right=base().getSimpleAssignRightLocal(assign);
      return base().handlePrivateFieldSet(accessField,right);
    }
 else {
      soot.Local baseLocal=(soot.Local)base().getBaseLocal(accessField.field().target());
      soot.Local leftLocal=handleCall(accessField.field(),accessField.getMeth(),null,baseLocal);
      soot.Value right=base().getAssignRightLocal(assign,leftLocal);
      return handleFieldSet(accessField,right,baseLocal);
    }
  }
 else {
    return ext().handlePrivateFieldAssignSet(assign);
  }
}","protected soot.Local handlePrivateFieldAssignSet(polyglot.ast.Assign assign){
  if (assign.left() instanceof soot.javaToJimple.jj.ast.JjAccessField_c) {
    soot.javaToJimple.jj.ast.JjAccessField_c accessField=(soot.javaToJimple.jj.ast.JjAccessField_c)assign.left();
    soot.Local baseLocal=(soot.Local)base().getBaseLocal(accessField.field().target());
    if (assign.operator() == polyglot.ast.Assign.ASSIGN) {
      soot.Value right=base().getSimpleAssignRightLocal(assign);
      return base().handlePrivateFieldSet(accessField,right,baseLocal);
    }
 else {
      soot.Local leftLocal=handleCall(accessField.field(),accessField.getMeth(),null,baseLocal);
      soot.Value right=base().getAssignRightLocal(assign,leftLocal);
      return handleFieldSet(accessField,right,baseLocal);
    }
  }
 else {
    return ext().handlePrivateFieldAssignSet(assign);
  }
}"
88549,"protected soot.Local handlePrivateFieldSet(polyglot.ast.Expr expr,soot.Value right){
  if (expr instanceof soot.javaToJimple.jj.ast.JjAccessField_c) {
    soot.javaToJimple.jj.ast.JjAccessField_c accessField=(soot.javaToJimple.jj.ast.JjAccessField_c)expr;
    return handleCall(accessField.field(),accessField.setMeth(),right,null);
  }
 else {
    return ext().handlePrivateFieldSet(expr,right);
  }
}","protected soot.Local handlePrivateFieldSet(polyglot.ast.Expr expr,soot.Value right,soot.Value baseLocal){
  if (expr instanceof soot.javaToJimple.jj.ast.JjAccessField_c) {
    soot.javaToJimple.jj.ast.JjAccessField_c accessField=(soot.javaToJimple.jj.ast.JjAccessField_c)expr;
    return handleCall(accessField.field(),accessField.setMeth(),right,null);
  }
 else {
    return ext().handlePrivateFieldSet(expr,right,baseLocal);
  }
}"
88550,"private ArrayList addFinalLocals(polyglot.ast.ClassBody cBody,ArrayList finalLocalsAvail,polyglot.types.ClassType nodeKeyType,AnonLocalClassInfo info){
  ArrayList finalFields=new ArrayList();
  LocalUsesChecker luc=new LocalUsesChecker();
  cBody.visit(luc);
  Iterator localsNeededIt=luc.getLocals().iterator();
  ArrayList localsUsed=new ArrayList();
  while (localsNeededIt.hasNext()) {
    polyglot.types.LocalInstance li=(polyglot.types.LocalInstance)((polyglot.util.IdentityKey)localsNeededIt.next()).object();
    if (finalLocalsAvail.contains(new polyglot.util.IdentityKey(li)) && !luc.getLocalDecls().contains(new polyglot.util.IdentityKey(li))) {
      addFinals(li,finalFields);
      localsUsed.add(new polyglot.util.IdentityKey(li));
    }
  }
  Iterator newsIt=luc.getNews().iterator();
  while (newsIt.hasNext()) {
    polyglot.ast.New tempNew=(polyglot.ast.New)newsIt.next();
    polyglot.types.ClassType tempNewType=(polyglot.types.ClassType)tempNew.objectType().type();
    if (InitialResolver.v().finalLocalInfo().containsKey(new polyglot.util.IdentityKey(tempNewType))) {
      AnonLocalClassInfo lInfo=(AnonLocalClassInfo)InitialResolver.v().finalLocalInfo().get(new polyglot.util.IdentityKey(tempNewType));
      Iterator it=lInfo.finalLocalsAvail().iterator();
      while (it.hasNext()) {
        polyglot.types.LocalInstance li2=(polyglot.types.LocalInstance)((polyglot.util.IdentityKey)it.next()).object();
        if (!sootClass.declaresField(""String_Node_Str"" + li2.name(),Util.getSootType(li2.type()))) {
          if (!luc.getLocalDecls().contains(new polyglot.util.IdentityKey(li2))) {
            addFinals(li2,finalFields);
            localsUsed.add(new polyglot.util.IdentityKey(li2));
          }
        }
      }
    }
  }
  info.finalLocalsUsed(localsUsed);
  InitialResolver.v().finalLocalInfo().put(new polyglot.util.IdentityKey(nodeKeyType),info);
  return finalFields;
}","private ArrayList addFinalLocals(polyglot.ast.ClassBody cBody,ArrayList finalLocalsAvail,polyglot.types.ClassType nodeKeyType,AnonLocalClassInfo info){
  ArrayList finalFields=new ArrayList();
  LocalUsesChecker luc=new LocalUsesChecker();
  cBody.visit(luc);
  ArrayList localsUsed=new ArrayList();
  Iterator fieldsNeededIt=finalLocalsAvail.iterator();
  while (fieldsNeededIt.hasNext()) {
    polyglot.types.LocalInstance li=(polyglot.types.LocalInstance)((polyglot.util.IdentityKey)fieldsNeededIt.next()).object();
    if (!luc.getLocalDecls().contains(new polyglot.util.IdentityKey(li))) {
      localsUsed.add(new polyglot.util.IdentityKey(li));
      addFinals(li,finalFields);
    }
  }
  Iterator newsIt=luc.getNews().iterator();
  while (newsIt.hasNext()) {
    polyglot.ast.New tempNew=(polyglot.ast.New)newsIt.next();
    polyglot.types.ClassType tempNewType=(polyglot.types.ClassType)tempNew.objectType().type();
    if (InitialResolver.v().finalLocalInfo().containsKey(new polyglot.util.IdentityKey(tempNewType))) {
      AnonLocalClassInfo lInfo=(AnonLocalClassInfo)InitialResolver.v().finalLocalInfo().get(new polyglot.util.IdentityKey(tempNewType));
      Iterator it=lInfo.finalLocalsAvail().iterator();
      while (it.hasNext()) {
        polyglot.types.LocalInstance li2=(polyglot.types.LocalInstance)((polyglot.util.IdentityKey)it.next()).object();
        if (!sootClass.declaresField(""String_Node_Str"" + li2.name(),Util.getSootType(li2.type()))) {
          if (!luc.getLocalDecls().contains(new polyglot.util.IdentityKey(li2))) {
            addFinals(li2,finalFields);
            localsUsed.add(new polyglot.util.IdentityKey(li2));
          }
        }
      }
    }
  }
  polyglot.types.ClassType superType=(polyglot.types.ClassType)nodeKeyType.superType();
  while (!Util.getSootType(superType).equals(soot.Scene.v().getSootClass(""String_Node_Str"").getType())) {
    if (InitialResolver.v().finalLocalInfo().containsKey(new polyglot.util.IdentityKey(superType))) {
      AnonLocalClassInfo lInfo=(AnonLocalClassInfo)InitialResolver.v().finalLocalInfo().get(new polyglot.util.IdentityKey(superType));
      Iterator it=lInfo.finalLocalsAvail().iterator();
      while (it.hasNext()) {
        polyglot.types.LocalInstance li2=(polyglot.types.LocalInstance)((polyglot.util.IdentityKey)it.next()).object();
        if (!sootClass.declaresField(""String_Node_Str"" + li2.name(),Util.getSootType(li2.type()))) {
          if (!luc.getLocalDecls().contains(new polyglot.util.IdentityKey(li2))) {
            addFinals(li2,finalFields);
            localsUsed.add(new polyglot.util.IdentityKey(li2));
          }
        }
      }
    }
    superType=(polyglot.types.ClassType)superType.superType();
  }
  info.finalLocalsUsed(localsUsed);
  InitialResolver.v().finalLocalInfo().put(new polyglot.util.IdentityKey(nodeKeyType),info);
  return finalFields;
}"
88551,"private void handleFinalLocals(polyglot.ast.ClassMember member){
  MethodFinalsChecker mfc=new MethodFinalsChecker();
  member.visit(mfc);
  AnonLocalClassInfo alci=new AnonLocalClassInfo();
  if (member instanceof polyglot.ast.ProcedureDecl) {
    polyglot.ast.ProcedureDecl procedure=(polyglot.ast.ProcedureDecl)member;
    alci.finalLocalsAvail(mfc.finalLocals());
    if (procedure.flags().isStatic()) {
      alci.inStaticMethod(true);
    }
  }
 else   if (member instanceof polyglot.ast.FieldDecl) {
    alci.finalLocalsAvail(new ArrayList());
    if (((polyglot.ast.FieldDecl)member).flags().isStatic()) {
      alci.inStaticMethod(true);
    }
  }
 else   if (member instanceof polyglot.ast.Initializer) {
    alci.finalLocalsAvail(mfc.finalLocals());
    if (((polyglot.ast.Initializer)member).flags().isStatic()) {
      alci.inStaticMethod(true);
    }
  }
  if (finalLocalInfo == null) {
    finalLocalInfo=new HashMap();
  }
  Iterator it=mfc.inners().iterator();
  while (it.hasNext()) {
    polyglot.types.ClassType cType=(polyglot.types.ClassType)((polyglot.util.IdentityKey)it.next()).object();
    AnonLocalClassInfo info=new AnonLocalClassInfo();
    info.inStaticMethod(alci.inStaticMethod());
    info.finalLocalsAvail(alci.finalLocalsAvail());
    if (!finalLocalInfo.containsKey(new polyglot.util.IdentityKey(cType))) {
      finalLocalInfo.put(new polyglot.util.IdentityKey(cType),info);
    }
  }
}","private void handleFinalLocals(polyglot.ast.ClassMember member){
  MethodFinalsChecker mfc=new MethodFinalsChecker();
  member.visit(mfc);
  AnonLocalClassInfo alci=new AnonLocalClassInfo();
  if (member instanceof polyglot.ast.ProcedureDecl) {
    polyglot.ast.ProcedureDecl procedure=(polyglot.ast.ProcedureDecl)member;
    alci.finalLocalsAvail(mfc.finalLocals());
    if (procedure.flags().isStatic()) {
      alci.inStaticMethod(true);
    }
  }
 else   if (member instanceof polyglot.ast.FieldDecl) {
    alci.finalLocalsAvail(new ArrayList());
    if (((polyglot.ast.FieldDecl)member).flags().isStatic()) {
      alci.inStaticMethod(true);
    }
  }
 else   if (member instanceof polyglot.ast.Initializer) {
    alci.finalLocalsAvail(mfc.finalLocals());
    if (((polyglot.ast.Initializer)member).flags().isStatic()) {
      alci.inStaticMethod(true);
    }
  }
  if (finalLocalInfo == null) {
    finalLocalInfo=new HashMap();
  }
  Iterator it=mfc.inners().iterator();
  while (it.hasNext()) {
    polyglot.types.ClassType cType=(polyglot.types.ClassType)((polyglot.util.IdentityKey)it.next()).object();
    HashMap typeToLocalUsed=mfc.typeToLocalsUsed();
    ArrayList localsUsed=new ArrayList();
    if (typeToLocalUsed.containsKey(new polyglot.util.IdentityKey(cType))) {
      ArrayList localsNeeded=(ArrayList)typeToLocalUsed.get(new polyglot.util.IdentityKey(cType));
      Iterator usesIt=localsNeeded.iterator();
      while (usesIt.hasNext()) {
        polyglot.types.LocalInstance li=(polyglot.types.LocalInstance)((polyglot.util.IdentityKey)usesIt.next()).object();
        if (alci.finalLocalsAvail().contains(new polyglot.util.IdentityKey(li))) {
          localsUsed.add(new polyglot.util.IdentityKey(li));
        }
      }
    }
    AnonLocalClassInfo info=new AnonLocalClassInfo();
    info.inStaticMethod(alci.inStaticMethod());
    info.finalLocalsAvail(localsUsed);
    if (!finalLocalInfo.containsKey(new polyglot.util.IdentityKey(cType))) {
      finalLocalInfo.put(new polyglot.util.IdentityKey(cType),info);
    }
  }
}"
88552,"/** 
 * sets up the info needed to invoke polyglot
 */
public polyglot.frontend.ExtensionInfo initExtInfo(String fileName,List sourceLocations){
  Set source=new HashSet();
  ExtensionInfo extInfo=new soot.javaToJimple.jj.ExtensionInfo(){
    public List passes(    Job job){
      List passes=super.passes(job);
      beforePass(passes,Pass.TYPE_CHECK,new VisitorPass(polyglot.frontend.Pass.FOLD,job,new polyglot.visit.ConstantFolder(ts,nf)));
      beforePass(passes,Pass.EXIT_CHECK,new VisitorPass(CAST_INSERTION,job,new CastInsertionVisitor(job,ts,nf)));
      beforePass(passes,Pass.EXIT_CHECK,new VisitorPass(STRICTFP_PROP,job,new StrictFPPropagator(false)));
      afterPass(passes,Pass.PRE_OUTPUT_ALL,new SaveASTVisitor(SAVE_AST,job,this));
      removePass(passes,Pass.OUTPUT);
      return passes;
    }
  }
;
  polyglot.main.Options options=extInfo.getOptions();
  options.assertions=true;
  options.source_path=new LinkedList();
  Iterator it=sourceLocations.iterator();
  while (it.hasNext()) {
    Object next=it.next();
    options.source_path.add(new File(next.toString()));
  }
  options.source_ext=new String[]{""String_Node_Str""};
  options.serialize_type_info=false;
  source.add(fileName);
  options.source_path.add(new File(fileName).getParentFile());
  polyglot.main.Options.global=options;
  return extInfo;
}","/** 
 * sets up the info needed to invoke polyglot
 */
public polyglot.frontend.ExtensionInfo initExtInfo(String fileName,List sourceLocations){
  Set source=new HashSet();
  ExtensionInfo extInfo=new soot.javaToJimple.jj.ExtensionInfo(){
    public List passes(    Job job){
      List passes=super.passes(job);
      beforePass(passes,Pass.EXIT_CHECK,new VisitorPass(CAST_INSERTION,job,new CastInsertionVisitor(job,ts,nf)));
      beforePass(passes,Pass.EXIT_CHECK,new VisitorPass(STRICTFP_PROP,job,new StrictFPPropagator(false)));
      afterPass(passes,Pass.PRE_OUTPUT_ALL,new SaveASTVisitor(SAVE_AST,job,this));
      removePass(passes,Pass.OUTPUT);
      return passes;
    }
  }
;
  polyglot.main.Options options=extInfo.getOptions();
  options.assertions=true;
  options.source_path=new LinkedList();
  Iterator it=sourceLocations.iterator();
  while (it.hasNext()) {
    Object next=it.next();
    System.out.println(""String_Node_Str"" + next.toString());
    options.source_path.add(new File(next.toString()));
  }
  options.source_ext=new String[]{""String_Node_Str""};
  options.serialize_type_info=false;
  source.add(fileName);
  options.source_path.add(new File(fileName).getParentFile());
  polyglot.main.Options.global=options;
  return extInfo;
}"
88553,"public List passes(Job job){
  List passes=super.passes(job);
  beforePass(passes,Pass.TYPE_CHECK,new VisitorPass(polyglot.frontend.Pass.FOLD,job,new polyglot.visit.ConstantFolder(ts,nf)));
  beforePass(passes,Pass.EXIT_CHECK,new VisitorPass(CAST_INSERTION,job,new CastInsertionVisitor(job,ts,nf)));
  beforePass(passes,Pass.EXIT_CHECK,new VisitorPass(STRICTFP_PROP,job,new StrictFPPropagator(false)));
  afterPass(passes,Pass.PRE_OUTPUT_ALL,new SaveASTVisitor(SAVE_AST,job,this));
  removePass(passes,Pass.OUTPUT);
  return passes;
}","public List passes(Job job){
  List passes=super.passes(job);
  beforePass(passes,Pass.EXIT_CHECK,new VisitorPass(CAST_INSERTION,job,new CastInsertionVisitor(job,ts,nf)));
  beforePass(passes,Pass.EXIT_CHECK,new VisitorPass(STRICTFP_PROP,job,new StrictFPPropagator(false)));
  afterPass(passes,Pass.PRE_OUTPUT_ALL,new SaveASTVisitor(SAVE_AST,job,this));
  removePass(passes,Pass.OUTPUT);
  return passes;
}"
88554,"/** 
 * Look for the specified class. Return a ClassSource for it if found, or null if it was not found. 
 */
public ClassSource find(String className){
  String fileName=className.replace('.','/') + ""String_Node_Str"";
  SourceLocator.FoundFile file=SourceLocator.v().lookupInClassPath(fileName);
  if (file == null)   return null;
  return new JimpleClassSource(className,file.inputStream());
}","/** 
 * Look for the specified class. Return a ClassSource for it if found, or null if it was not found. 
 */
public ClassSource find(String className){
  String fileName=className + ""String_Node_Str"";
  SourceLocator.FoundFile file=SourceLocator.v().lookupInClassPath(fileName);
  if (file == null)   return null;
  return new JimpleClassSource(className,file.inputStream());
}"
88555,"/** 
 * creates the Jimple for an anon class - in the AST there is no class  decl for anon classes - the revelant fields and methods are  created 
 */
private void createAnonClassDecl(polyglot.ast.New aNew){
  SootClass outerClass=((soot.RefType)Util.getSootType(aNew.anonType().outer())).getSootClass();
  if (InitialResolver.v().getInnerClassInfoMap() == null) {
    InitialResolver.v().setInnerClassInfoMap(new HashMap());
  }
  InitialResolver.v().getInnerClassInfoMap().put(sootClass,new InnerClassInfo(outerClass,""String_Node_Str"",InnerClassInfo.ANON));
  sootClass.setOuterClass(outerClass);
  soot.SootClass typeClass=((soot.RefType)Util.getSootType(aNew.objectType().type())).getSootClass();
  if (((polyglot.types.ClassType)aNew.objectType().type()).flags().isInterface()) {
    sootClass.addInterface(typeClass);
    sootClass.setSuperclass(soot.Scene.v().getSootClass(""String_Node_Str""));
  }
 else {
    sootClass.setSuperclass(typeClass);
    if (((polyglot.types.ClassType)aNew.objectType().type()).isNested()) {
      polyglot.types.ClassType superType=(polyglot.types.ClassType)aNew.objectType().type();
      Util.addInnerClassTag(sootClass,typeClass.getName(),((soot.RefType)Util.getSootType(superType.outer())).toString(),superType.name(),Util.getModifier(superType.flags()));
    }
  }
  ArrayList params=new ArrayList();
  soot.SootMethod method;
  if (((polyglot.types.ClassType)aNew.objectType().type()).flags().isInterface()) {
    method=new soot.SootMethod(""String_Node_Str"",params,soot.VoidType.v());
  }
 else {
    Iterator aIt=aNew.arguments().iterator();
    while (aIt.hasNext()) {
      polyglot.types.Type pType=((polyglot.ast.Expr)aIt.next()).type();
      params.add(Util.getSootType(pType));
    }
    method=new soot.SootMethod(""String_Node_Str"",params,soot.VoidType.v());
  }
  AnonClassInitMethodSource src=new AnonClassInitMethodSource();
  method.setSource(src);
  sootClass.addMethod(method);
  AnonLocalClassInfo info=(AnonLocalClassInfo)InitialResolver.v().finalLocalInfo().get(new polyglot.util.IdentityKey(aNew.anonType()));
  if (aNew.qualifier() != null) {
    addQualifierRefToInit(aNew.qualifier().type());
    src.hasQualifier(true);
  }
  if (!info.inStaticMethod()) {
    addOuterClassThisRefToInit(aNew.anonType().outer());
    addOuterClassThisRefField(aNew.anonType().outer());
    src.thisOuterType(Util.getSootType(aNew.anonType().outer()));
    src.hasOuterRef(true);
  }
  src.polyglotType((polyglot.types.ClassType)aNew.anonType().superType());
  src.inStaticMethod(info.inStaticMethod());
  if (info != null) {
    src.setFinalsList(addFinalLocals(aNew.body(),info.finalLocalsAvail(),(polyglot.types.ClassType)aNew.anonType(),info));
  }
  src.outerClassType(Util.getSootType(aNew.anonType().outer()));
  if (((polyglot.types.ClassType)aNew.objectType().type()).isNested()) {
    src.superOuterType(Util.getSootType(((polyglot.types.ClassType)aNew.objectType().type()).outer()));
    src.isSubType(Util.isSubType(aNew.anonType().outer(),((polyglot.types.ClassType)aNew.objectType().type()).outer()));
  }
  Util.addLnPosTags(sootClass,aNew.position().line(),aNew.body().position().endLine(),aNew.position().column(),aNew.body().position().endColumn());
}","/** 
 * creates the Jimple for an anon class - in the AST there is no class  decl for anon classes - the revelant fields and methods are  created 
 */
private void createAnonClassDecl(polyglot.ast.New aNew){
  SootClass outerClass=((soot.RefType)Util.getSootType(aNew.anonType().outer())).getSootClass();
  if (InitialResolver.v().getInnerClassInfoMap() == null) {
    InitialResolver.v().setInnerClassInfoMap(new HashMap());
  }
  InitialResolver.v().getInnerClassInfoMap().put(sootClass,new InnerClassInfo(outerClass,""String_Node_Str"",InnerClassInfo.ANON));
  sootClass.setOuterClass(outerClass);
  soot.SootClass typeClass=((soot.RefType)Util.getSootType(aNew.objectType().type())).getSootClass();
  if (((polyglot.types.ClassType)aNew.objectType().type()).flags().isInterface()) {
    sootClass.addInterface(typeClass);
    sootClass.setSuperclass(soot.Scene.v().getSootClass(""String_Node_Str""));
  }
 else {
    sootClass.setSuperclass(typeClass);
    if (((polyglot.types.ClassType)aNew.objectType().type()).isNested()) {
      polyglot.types.ClassType superType=(polyglot.types.ClassType)aNew.objectType().type();
      Util.addInnerClassTag(sootClass,typeClass.getName(),((soot.RefType)Util.getSootType(superType.outer())).toString(),superType.name(),Util.getModifier(superType.flags()));
    }
  }
  ArrayList params=new ArrayList();
  soot.SootMethod method;
  if (((polyglot.types.ClassType)aNew.objectType().type()).flags().isInterface()) {
    method=new soot.SootMethod(""String_Node_Str"",params,soot.VoidType.v());
  }
 else {
    Iterator aIt=aNew.arguments().iterator();
    while (aIt.hasNext()) {
      polyglot.types.Type pType=((polyglot.ast.Expr)aIt.next()).type();
      params.add(Util.getSootType(pType));
    }
    method=new soot.SootMethod(""String_Node_Str"",params,soot.VoidType.v());
  }
  AnonClassInitMethodSource src=new AnonClassInitMethodSource();
  method.setSource(src);
  sootClass.addMethod(method);
  AnonLocalClassInfo info=(AnonLocalClassInfo)InitialResolver.v().finalLocalInfo().get(new polyglot.util.IdentityKey(aNew.anonType()));
  if (aNew.qualifier() != null) {
    addQualifierRefToInit(aNew.qualifier().type());
    src.hasQualifier(true);
  }
  if (info != null && !info.inStaticMethod()) {
    addOuterClassThisRefToInit(aNew.anonType().outer());
    addOuterClassThisRefField(aNew.anonType().outer());
    src.thisOuterType(Util.getSootType(aNew.anonType().outer()));
    src.hasOuterRef(true);
  }
  src.polyglotType((polyglot.types.ClassType)aNew.anonType().superType());
  src.inStaticMethod(info.inStaticMethod());
  if (info != null) {
    src.setFinalsList(addFinalLocals(aNew.body(),info.finalLocalsAvail(),(polyglot.types.ClassType)aNew.anonType(),info));
  }
  src.outerClassType(Util.getSootType(aNew.anonType().outer()));
  if (((polyglot.types.ClassType)aNew.objectType().type()).isNested()) {
    src.superOuterType(Util.getSootType(((polyglot.types.ClassType)aNew.objectType().type()).outer()));
    src.isSubType(Util.isSubType(aNew.anonType().outer(),((polyglot.types.ClassType)aNew.objectType().type()).outer()));
  }
  Util.addLnPosTags(sootClass,aNew.position().line(),aNew.body().position().endLine(),aNew.position().column(),aNew.body().position().endColumn());
}"
88556,"private int getLocalClassNum(String realName,String simpleName){
  int dIndex=realName.indexOf(""String_Node_Str"");
  int nIndex=realName.indexOf(simpleName,dIndex);
  if (nIndex == -1)   return NO_MATCH;
  if (dIndex == -1) {
    throw new RuntimeException(""String_Node_Str"" + realName);
  }
  return (new Integer(realName.substring(dIndex + 1,nIndex))).intValue();
}","private int getLocalClassNum(String realName,String simpleName){
  int dIndex=realName.indexOf(""String_Node_Str"");
  int nIndex=realName.indexOf(simpleName,dIndex);
  if (nIndex == -1)   return NO_MATCH;
  if (dIndex == -1) {
    throw new RuntimeException(""String_Node_Str"" + realName);
  }
  String numString=realName.substring(dIndex + 1,nIndex);
  for (int i=0; i < numString.length(); i++) {
    if (!Character.isDigit(numString.charAt(i)))     return NO_MATCH;
  }
  return (new Integer(numString)).intValue();
}"
88557,"/** 
 * Condition Expression Creation - can maybe merge with If
 */
private soot.Local getConditionalLocal(polyglot.ast.Conditional condExpr){
  polyglot.ast.Expr condition=condExpr.cond();
  soot.Value sootCond=base().createExpr(condition);
  boolean needIf=needSootIf(sootCond);
  if (!(sootCond instanceof soot.jimple.ConditionExpr)) {
    sootCond=soot.jimple.Jimple.v().newEqExpr(sootCond,soot.jimple.IntConstant.v(0));
  }
 else {
    sootCond=reverseCondition((soot.jimple.ConditionExpr)sootCond);
    sootCond=handleDFLCond((soot.jimple.ConditionExpr)sootCond);
  }
  soot.jimple.Stmt noop1=soot.jimple.Jimple.v().newNopStmt();
  if (needIf) {
    soot.jimple.IfStmt ifStmt=soot.jimple.Jimple.v().newIfStmt(sootCond,noop1);
    body.getUnits().add(ifStmt);
    Util.addLnPosTags(ifStmt,condExpr.position());
    Util.addLnPosTags(ifStmt.getConditionBox(),condition.position());
  }
  soot.Local retLocal=generateLocal(condExpr.type());
  polyglot.ast.Expr consequence=condExpr.consequent();
  soot.Value conseqVal=base().createExpr(consequence);
  soot.jimple.AssignStmt conseqAssignStmt=soot.jimple.Jimple.v().newAssignStmt(retLocal,conseqVal);
  body.getUnits().add(conseqAssignStmt);
  Util.addLnPosTags(conseqAssignStmt,condExpr.position());
  Util.addLnPosTags(conseqAssignStmt.getRightOpBox(),consequence.position());
  soot.jimple.Stmt noop2=soot.jimple.Jimple.v().newNopStmt();
  soot.jimple.Stmt goto1=soot.jimple.Jimple.v().newGotoStmt(noop2);
  body.getUnits().add(goto1);
  body.getUnits().add(noop1);
  polyglot.ast.Expr alternative=condExpr.alternative();
  if (alternative != null) {
    soot.Value altVal=base().createExpr(alternative);
    soot.jimple.AssignStmt altAssignStmt=soot.jimple.Jimple.v().newAssignStmt(retLocal,altVal);
    body.getUnits().add(altAssignStmt);
    Util.addLnPosTags(altAssignStmt,condExpr.position());
    Util.addLnPosTags(altAssignStmt,alternative.position());
    Util.addLnPosTags(altAssignStmt.getRightOpBox(),alternative.position());
  }
  body.getUnits().add(noop2);
  return retLocal;
}","/** 
 * Condition Expression Creation - can maybe merge with If
 */
private soot.Local getConditionalLocal(polyglot.ast.Conditional condExpr){
  polyglot.ast.Expr condition=condExpr.cond();
  soot.Value sootCond=base().createExpr(condition);
  boolean needIf=needSootIf(sootCond);
  if (!(sootCond instanceof soot.jimple.ConditionExpr)) {
    sootCond=soot.jimple.Jimple.v().newEqExpr(sootCond,soot.jimple.IntConstant.v(0));
  }
 else {
    sootCond=reverseCondition((soot.jimple.ConditionExpr)sootCond);
    sootCond=handleDFLCond((soot.jimple.ConditionExpr)sootCond);
  }
  soot.jimple.Stmt noop1=soot.jimple.Jimple.v().newNopStmt();
  if (needIf) {
    soot.jimple.IfStmt ifStmt=soot.jimple.Jimple.v().newIfStmt(sootCond,noop1);
    body.getUnits().add(ifStmt);
    Util.addLnPosTags(ifStmt,condExpr.position());
    Util.addLnPosTags(ifStmt.getConditionBox(),condition.position());
  }
  soot.Local retLocal=generateLocal(condExpr.type());
  polyglot.ast.Expr consequence=condExpr.consequent();
  soot.Value conseqVal=base().createExpr(consequence);
  if (conseqVal instanceof soot.jimple.ConditionExpr) {
    conseqVal=handleCondBinExpr((soot.jimple.ConditionExpr)conseqVal);
  }
  soot.jimple.AssignStmt conseqAssignStmt=soot.jimple.Jimple.v().newAssignStmt(retLocal,conseqVal);
  body.getUnits().add(conseqAssignStmt);
  Util.addLnPosTags(conseqAssignStmt,condExpr.position());
  Util.addLnPosTags(conseqAssignStmt.getRightOpBox(),consequence.position());
  soot.jimple.Stmt noop2=soot.jimple.Jimple.v().newNopStmt();
  soot.jimple.Stmt goto1=soot.jimple.Jimple.v().newGotoStmt(noop2);
  body.getUnits().add(goto1);
  body.getUnits().add(noop1);
  polyglot.ast.Expr alternative=condExpr.alternative();
  if (alternative != null) {
    soot.Value altVal=base().createExpr(alternative);
    if (altVal instanceof soot.jimple.ConditionExpr) {
      altVal=handleCondBinExpr((soot.jimple.ConditionExpr)altVal);
    }
    soot.jimple.AssignStmt altAssignStmt=soot.jimple.Jimple.v().newAssignStmt(retLocal,altVal);
    body.getUnits().add(altAssignStmt);
    Util.addLnPosTags(altAssignStmt,condExpr.position());
    Util.addLnPosTags(altAssignStmt,alternative.position());
    Util.addLnPosTags(altAssignStmt.getRightOpBox(),alternative.position());
  }
  body.getUnits().add(noop2);
  return retLocal;
}"
88558,"/** 
 * adds any needed static field inits
 */
private void handleStaticFieldInits(soot.SootMethod sootMethod){
  ArrayList staticFieldInits=((soot.javaToJimple.PolyglotMethodSource)sootMethod.getSource()).getStaticFieldInits();
  if (staticFieldInits != null) {
    Iterator staticFieldInitsIt=staticFieldInits.iterator();
    while (staticFieldInitsIt.hasNext()) {
      polyglot.ast.FieldDecl field=(polyglot.ast.FieldDecl)staticFieldInitsIt.next();
      String fieldName=field.name();
      polyglot.ast.Expr initExpr=field.init();
      soot.SootClass currentClass=body.getMethod().getDeclaringClass();
      soot.SootFieldRef sootField=soot.Scene.v().makeFieldRef(currentClass,fieldName,Util.getSootType(field.type().type()),field.flags().isStatic());
      soot.jimple.FieldRef fieldRef=soot.jimple.Jimple.v().newStaticFieldRef(sootField);
      soot.Value sootExpr;
      if (initExpr instanceof polyglot.ast.ArrayInit) {
        sootExpr=getArrayInitLocal((polyglot.ast.ArrayInit)initExpr,field.type().type());
      }
 else {
        sootExpr=base().createExpr(initExpr);
      }
      soot.jimple.Stmt assign=soot.jimple.Jimple.v().newAssignStmt(fieldRef,sootExpr);
      body.getUnits().add(assign);
      Util.addLnPosTags(assign,initExpr.position());
    }
  }
}","/** 
 * adds any needed static field inits
 */
private void handleStaticFieldInits(soot.SootMethod sootMethod){
  ArrayList staticFieldInits=((soot.javaToJimple.PolyglotMethodSource)sootMethod.getSource()).getStaticFieldInits();
  if (staticFieldInits != null) {
    Iterator staticFieldInitsIt=staticFieldInits.iterator();
    while (staticFieldInitsIt.hasNext()) {
      polyglot.ast.FieldDecl field=(polyglot.ast.FieldDecl)staticFieldInitsIt.next();
      String fieldName=field.name();
      polyglot.ast.Expr initExpr=field.init();
      soot.SootClass currentClass=body.getMethod().getDeclaringClass();
      soot.SootFieldRef sootField=soot.Scene.v().makeFieldRef(currentClass,fieldName,Util.getSootType(field.type().type()),field.flags().isStatic());
      soot.jimple.FieldRef fieldRef=soot.jimple.Jimple.v().newStaticFieldRef(sootField);
      soot.Value sootExpr;
      if (initExpr instanceof polyglot.ast.ArrayInit) {
        sootExpr=getArrayInitLocal((polyglot.ast.ArrayInit)initExpr,field.type().type());
      }
 else {
        sootExpr=base().createExpr(initExpr);
        if (sootExpr instanceof soot.jimple.ConditionExpr) {
          sootExpr=handleCondBinExpr((soot.jimple.ConditionExpr)sootExpr);
        }
      }
      soot.jimple.Stmt assign=soot.jimple.Jimple.v().newAssignStmt(fieldRef,sootExpr);
      body.getUnits().add(assign);
      Util.addLnPosTags(assign,initExpr.position());
    }
  }
}"
88559,"/** 
 * Assert Stmt Creation
 */
private void createAssert(polyglot.ast.Assert assertStmt){
  soot.Local testLocal=lg.generateLocal(soot.BooleanType.v());
  soot.SootFieldRef assertField=soot.Scene.v().makeFieldRef(body.getMethod().getDeclaringClass(),""String_Node_Str"",soot.BooleanType.v(),true);
  soot.jimple.FieldRef assertFieldRef=soot.jimple.Jimple.v().newStaticFieldRef(assertField);
  soot.jimple.AssignStmt fieldAssign=soot.jimple.Jimple.v().newAssignStmt(testLocal,assertFieldRef);
  body.getUnits().add(fieldAssign);
  soot.jimple.NopStmt nop1=soot.jimple.Jimple.v().newNopStmt();
  soot.jimple.ConditionExpr cond1=soot.jimple.Jimple.v().newNeExpr(testLocal,soot.jimple.IntConstant.v(0));
  soot.jimple.IfStmt testIf=soot.jimple.Jimple.v().newIfStmt(cond1,nop1);
  body.getUnits().add(testIf);
  if ((assertStmt.cond() instanceof polyglot.ast.BooleanLit) && (!((polyglot.ast.BooleanLit)assertStmt.cond()).value())) {
  }
 else {
    soot.Value sootCond=base().createExpr(assertStmt.cond());
    boolean needIf=needSootIf(sootCond);
    if (!(sootCond instanceof soot.jimple.ConditionExpr)) {
      sootCond=soot.jimple.Jimple.v().newEqExpr(sootCond,soot.jimple.IntConstant.v(1));
    }
 else {
      sootCond=handleDFLCond((soot.jimple.ConditionExpr)sootCond);
    }
    if (needIf) {
      soot.jimple.IfStmt ifStmt=soot.jimple.Jimple.v().newIfStmt(sootCond,nop1);
      body.getUnits().add(ifStmt);
      Util.addLnPosTags(ifStmt.getConditionBox(),assertStmt.cond().position());
      Util.addLnPosTags(ifStmt,assertStmt.position());
    }
  }
  soot.Local failureLocal=lg.generateLocal(soot.RefType.v(""String_Node_Str""));
  soot.jimple.NewExpr newExpr=soot.jimple.Jimple.v().newNewExpr(soot.RefType.v(""String_Node_Str""));
  soot.jimple.AssignStmt newAssign=soot.jimple.Jimple.v().newAssignStmt(failureLocal,newExpr);
  body.getUnits().add(newAssign);
  soot.SootMethodRef methToInvoke;
  ArrayList paramTypes=new ArrayList();
  ArrayList params=new ArrayList();
  if (assertStmt.errorMessage() != null) {
    soot.Value errorExpr=base().createExpr(assertStmt.errorMessage());
    soot.Type errorType=errorExpr.getType();
    if (assertStmt.errorMessage().type().isChar()) {
      errorType=soot.CharType.v();
    }
    if (errorType instanceof soot.IntType) {
      paramTypes.add(soot.IntType.v());
    }
 else     if (errorType instanceof soot.LongType) {
      paramTypes.add(soot.LongType.v());
    }
 else     if (errorType instanceof soot.FloatType) {
      paramTypes.add(soot.FloatType.v());
    }
 else     if (errorType instanceof soot.DoubleType) {
      paramTypes.add(soot.DoubleType.v());
    }
 else     if (errorType instanceof soot.CharType) {
      paramTypes.add(soot.CharType.v());
    }
 else     if (errorType instanceof soot.BooleanType) {
      paramTypes.add(soot.BooleanType.v());
    }
 else     if (errorType instanceof soot.ShortType) {
      paramTypes.add(soot.IntType.v());
    }
 else     if (errorType instanceof soot.ByteType) {
      paramTypes.add(soot.IntType.v());
    }
 else {
      paramTypes.add(soot.Scene.v().getSootClass(""String_Node_Str"").getType());
    }
    params.add(errorExpr);
  }
  methToInvoke=soot.Scene.v().makeMethodRef(soot.Scene.v().getSootClass(""String_Node_Str""),""String_Node_Str"",paramTypes,soot.VoidType.v(),false);
  soot.jimple.SpecialInvokeExpr invokeExpr=soot.jimple.Jimple.v().newSpecialInvokeExpr(failureLocal,methToInvoke,params);
  soot.jimple.InvokeStmt invokeStmt=soot.jimple.Jimple.v().newInvokeStmt(invokeExpr);
  body.getUnits().add(invokeStmt);
  if (assertStmt.errorMessage() != null) {
    Util.addLnPosTags(invokeExpr.getArgBox(0),assertStmt.errorMessage().position());
  }
  soot.jimple.ThrowStmt throwStmt=soot.jimple.Jimple.v().newThrowStmt(failureLocal);
  body.getUnits().add(throwStmt);
  body.getUnits().add(nop1);
}","/** 
 * Assert Stmt Creation
 */
private void createAssert(polyglot.ast.Assert assertStmt){
  soot.Local testLocal=lg.generateLocal(soot.BooleanType.v());
  soot.SootFieldRef assertField=soot.Scene.v().makeFieldRef(body.getMethod().getDeclaringClass(),""String_Node_Str"",soot.BooleanType.v(),true);
  soot.jimple.FieldRef assertFieldRef=soot.jimple.Jimple.v().newStaticFieldRef(assertField);
  soot.jimple.AssignStmt fieldAssign=soot.jimple.Jimple.v().newAssignStmt(testLocal,assertFieldRef);
  body.getUnits().add(fieldAssign);
  soot.jimple.NopStmt nop1=soot.jimple.Jimple.v().newNopStmt();
  soot.jimple.ConditionExpr cond1=soot.jimple.Jimple.v().newNeExpr(testLocal,soot.jimple.IntConstant.v(0));
  soot.jimple.IfStmt testIf=soot.jimple.Jimple.v().newIfStmt(cond1,nop1);
  body.getUnits().add(testIf);
  if ((assertStmt.cond() instanceof polyglot.ast.BooleanLit) && (!((polyglot.ast.BooleanLit)assertStmt.cond()).value())) {
  }
 else {
    soot.Value sootCond=base().createExpr(assertStmt.cond());
    boolean needIf=needSootIf(sootCond);
    if (!(sootCond instanceof soot.jimple.ConditionExpr)) {
      sootCond=soot.jimple.Jimple.v().newEqExpr(sootCond,soot.jimple.IntConstant.v(1));
    }
 else {
      sootCond=handleDFLCond((soot.jimple.ConditionExpr)sootCond);
    }
    if (needIf) {
      soot.jimple.IfStmt ifStmt=soot.jimple.Jimple.v().newIfStmt(sootCond,nop1);
      body.getUnits().add(ifStmt);
      Util.addLnPosTags(ifStmt.getConditionBox(),assertStmt.cond().position());
      Util.addLnPosTags(ifStmt,assertStmt.position());
    }
  }
  soot.Local failureLocal=lg.generateLocal(soot.RefType.v(""String_Node_Str""));
  soot.jimple.NewExpr newExpr=soot.jimple.Jimple.v().newNewExpr(soot.RefType.v(""String_Node_Str""));
  soot.jimple.AssignStmt newAssign=soot.jimple.Jimple.v().newAssignStmt(failureLocal,newExpr);
  body.getUnits().add(newAssign);
  soot.SootMethodRef methToInvoke;
  ArrayList paramTypes=new ArrayList();
  ArrayList params=new ArrayList();
  if (assertStmt.errorMessage() != null) {
    soot.Value errorExpr=base().createExpr(assertStmt.errorMessage());
    if (errorExpr instanceof soot.jimple.ConditionExpr) {
      errorExpr=handleCondBinExpr((soot.jimple.ConditionExpr)errorExpr);
    }
    soot.Type errorType=errorExpr.getType();
    if (assertStmt.errorMessage().type().isChar()) {
      errorType=soot.CharType.v();
    }
    if (errorType instanceof soot.IntType) {
      paramTypes.add(soot.IntType.v());
    }
 else     if (errorType instanceof soot.LongType) {
      paramTypes.add(soot.LongType.v());
    }
 else     if (errorType instanceof soot.FloatType) {
      paramTypes.add(soot.FloatType.v());
    }
 else     if (errorType instanceof soot.DoubleType) {
      paramTypes.add(soot.DoubleType.v());
    }
 else     if (errorType instanceof soot.CharType) {
      paramTypes.add(soot.CharType.v());
    }
 else     if (errorType instanceof soot.BooleanType) {
      paramTypes.add(soot.BooleanType.v());
    }
 else     if (errorType instanceof soot.ShortType) {
      paramTypes.add(soot.IntType.v());
    }
 else     if (errorType instanceof soot.ByteType) {
      paramTypes.add(soot.IntType.v());
    }
 else {
      paramTypes.add(soot.Scene.v().getSootClass(""String_Node_Str"").getType());
    }
    params.add(errorExpr);
  }
  methToInvoke=soot.Scene.v().makeMethodRef(soot.Scene.v().getSootClass(""String_Node_Str""),""String_Node_Str"",paramTypes,soot.VoidType.v(),false);
  soot.jimple.SpecialInvokeExpr invokeExpr=soot.jimple.Jimple.v().newSpecialInvokeExpr(failureLocal,methToInvoke,params);
  soot.jimple.InvokeStmt invokeStmt=soot.jimple.Jimple.v().newInvokeStmt(invokeExpr);
  body.getUnits().add(invokeStmt);
  if (assertStmt.errorMessage() != null) {
    Util.addLnPosTags(invokeExpr.getArgBox(0),assertStmt.errorMessage().position());
  }
  soot.jimple.ThrowStmt throwStmt=soot.jimple.Jimple.v().newThrowStmt(failureLocal);
  body.getUnits().add(throwStmt);
  body.getUnits().add(nop1);
}"
88560,"public polyglot.ast.Node override(polyglot.ast.Node parent,polyglot.ast.Node n){
  if (n instanceof polyglot.ast.LocalClassDecl) {
    inners.add(new polyglot.util.IdentityKey(((polyglot.ast.LocalClassDecl)n).decl().type()));
    return n;
  }
 else   if (n instanceof polyglot.ast.New) {
    if (((polyglot.ast.New)n).anonType() != null) {
      inners.add(new polyglot.util.IdentityKey(((polyglot.ast.New)n).anonType()));
      return n;
    }
  }
  return null;
}","public polyglot.ast.Node override(polyglot.ast.Node parent,polyglot.ast.Node n){
  if (n instanceof polyglot.ast.LocalClassDecl) {
    inners.add(new polyglot.util.IdentityKey(((polyglot.ast.LocalClassDecl)n).decl().type()));
    return null;
  }
 else   if (n instanceof polyglot.ast.New) {
    if (((polyglot.ast.New)n).anonType() != null) {
      inners.add(new polyglot.util.IdentityKey(((polyglot.ast.New)n).anonType()));
      return null;
    }
  }
  return null;
}"
88561,"public polyglot.ast.Node leave(polyglot.ast.Node old,polyglot.ast.Node n,polyglot.visit.NodeVisitor nodeVisitor){
  if (n instanceof polyglot.ast.MethodDecl) {
    polyglot.ast.MethodDecl decl=(polyglot.ast.MethodDecl)n;
    if (strict && !decl.flags().isAbstract() && !decl.flags().isStrictFP()) {
      System.out.println(""String_Node_Str"" + decl);
      decl=decl.flags(decl.flags().StrictFP());
      System.out.println(""String_Node_Str"" + decl);
      return decl;
    }
  }
  if (n instanceof polyglot.ast.ConstructorDecl) {
    polyglot.ast.ConstructorDecl decl=(polyglot.ast.ConstructorDecl)n;
    if (strict && !decl.flags().isAbstract() && !decl.flags().isStrictFP()) {
      return decl.flags(decl.flags().StrictFP());
    }
  }
  if (n instanceof polyglot.ast.LocalClassDecl) {
    polyglot.ast.LocalClassDecl decl=(polyglot.ast.LocalClassDecl)n;
    if (decl.decl().flags().isStrictFP()) {
      return decl.decl().flags(decl.decl().flags().clearStrictFP());
    }
  }
  if (n instanceof polyglot.ast.ClassDecl) {
    polyglot.ast.ClassDecl decl=(polyglot.ast.ClassDecl)n;
    if (decl.flags().isStrictFP()) {
      return decl.flags(decl.flags().clearStrictFP());
    }
  }
  return n;
}","public polyglot.ast.Node leave(polyglot.ast.Node old,polyglot.ast.Node n,polyglot.visit.NodeVisitor nodeVisitor){
  if (n instanceof polyglot.ast.MethodDecl) {
    polyglot.ast.MethodDecl decl=(polyglot.ast.MethodDecl)n;
    if (strict && !decl.flags().isAbstract() && !decl.flags().isStrictFP()) {
      decl=decl.flags(decl.flags().StrictFP());
      return decl;
    }
  }
  if (n instanceof polyglot.ast.ConstructorDecl) {
    polyglot.ast.ConstructorDecl decl=(polyglot.ast.ConstructorDecl)n;
    if (strict && !decl.flags().isAbstract() && !decl.flags().isStrictFP()) {
      return decl.flags(decl.flags().StrictFP());
    }
  }
  if (n instanceof polyglot.ast.LocalClassDecl) {
    polyglot.ast.LocalClassDecl decl=(polyglot.ast.LocalClassDecl)n;
    if (decl.decl().flags().isStrictFP()) {
      return decl.decl().flags(decl.decl().flags().clearStrictFP());
    }
  }
  if (n instanceof polyglot.ast.ClassDecl) {
    polyglot.ast.ClassDecl decl=(polyglot.ast.ClassDecl)n;
    if (decl.flags().isStrictFP()) {
      return decl.flags(decl.flags().clearStrictFP());
    }
  }
  return n;
}"
88562,"private static soot.Local getLocalOfType(soot.Body body,soot.Type type){
  soot.FastHierarchy fh=InitialResolver.v().hierarchy();
  Iterator it=body.getLocals().iterator();
  soot.Local correctLocal=null;
  while (it.hasNext()) {
    soot.Local l=(soot.Local)it.next();
    if (l.getType().equals(type)) {
      correctLocal=l;
    }
  }
  return correctLocal;
}","private static soot.Local getLocalOfType(soot.Body body,soot.Type type){
  soot.FastHierarchy fh=InitialResolver.v().hierarchy();
  Iterator it=body.getLocals().iterator();
  soot.Local correctLocal=null;
  while (it.hasNext()) {
    soot.Local l=(soot.Local)it.next();
    if (fh.canStoreType(type,l.getType())) {
      correctLocal=l;
    }
  }
  return correctLocal;
}"
88563,"private static boolean bodyHasLocal(soot.Body body,soot.Type type){
  soot.FastHierarchy fh=InitialResolver.v().hierarchy();
  Iterator it=body.getDefBoxes().iterator();
  while (it.hasNext()) {
    soot.ValueBox vb=(soot.ValueBox)it.next();
    if ((vb.getValue() instanceof soot.Local) && (vb.getValue().getType().equals(type))) {
      return true;
    }
  }
  return false;
}","private static boolean bodyHasLocal(soot.Body body,soot.Type type){
  soot.FastHierarchy fh=InitialResolver.v().hierarchy();
  Iterator it=body.getDefBoxes().iterator();
  while (it.hasNext()) {
    soot.ValueBox vb=(soot.ValueBox)it.next();
    if ((vb.getValue() instanceof soot.Local) && (fh.canStoreType(type,vb.getValue().getType()))) {
      return true;
    }
  }
  return false;
}"
88564,"public OnFlyCallGraph(PAG pag){
  this.pag=pag;
  callGraph=new CallGraph();
  Scene.v().setCallGraph(callGraph);
  ContextManager cm=CallGraphBuilder.makeContextManager(callGraph);
  reachableMethods=Scene.v().getReachableMethods();
  ofcgb=new OnFlyCallGraphBuilder(cm,reachableMethods);
  reachablesReader=reachableMethods.listener();
  callEdges=cm.callGraph().listener();
}","public OnFlyCallGraph(PAG pag){
  this.pag=pag;
  CGOptions options=new CGOptions(PhaseOptions.v().getPhaseOptions(""String_Node_Str""));
  if (options.all_reachable()) {
    List entryPoints=new ArrayList();
    entryPoints.addAll(EntryPoints.v().all());
    entryPoints.addAll(EntryPoints.v().methodsOfApplicationClasses());
    Scene.v().setEntryPoints(entryPoints);
  }
  callGraph=new CallGraph();
  Scene.v().setCallGraph(callGraph);
  ContextManager cm=CallGraphBuilder.makeContextManager(callGraph);
  reachableMethods=Scene.v().getReachableMethods();
  ofcgb=new OnFlyCallGraphBuilder(cm,reachableMethods);
  reachablesReader=reachableMethods.listener();
  callEdges=cm.callGraph().listener();
}"
88565,"/** 
 * Main.v() entry point for converting list of Instructions to Jimple statements; performs flow analysis, constructs Jimple statements, and fixes jumps.
 * @param constant_pool constant pool of ClassFile.
 * @param this_class constant pool index of the CONSTANT_Class_info object forthis' class.
 * @param clearStacks if <i>true</i> semantic stacks will be deleted afterthe process is complete.
 * @return <i>true</i> if all ok, <i>false</i> if there was an error.
 * @see CFG#jimplify(cp_info[],int)
 * @see Stmt
 */
void jimplify(cp_info constant_pool[],int this_class){
  Code_attribute codeAttribute=method.locate_code_attribute();
  Set handlerInstructions=new ArraySet();
  Map handlerInstructionToException=new HashMap();
  Map instructionToTypeStack;
  Map instructionToPostTypeStack;
{
    buildInsnCFGfromBBCFG();
{
      for (int i=0; i < codeAttribute.exception_table_length; i++) {
        Instruction startIns=codeAttribute.exception_table[i].start_inst;
        Instruction endIns=codeAttribute.exception_table[i].end_inst;
        Instruction handlerIns=codeAttribute.exception_table[i].handler_inst;
        handlerInstructions.add(handlerIns);
{
          int catchType=codeAttribute.exception_table[i].catch_type;
          SootClass exception;
          if (catchType != 0) {
            CONSTANT_Class_info classinfo=(CONSTANT_Class_info)constant_pool[catchType];
            String name=((CONSTANT_Utf8_info)(constant_pool[classinfo.name_index])).convert();
            name=name.replace('/','.');
            exception=cm.getSootClass(name);
          }
 else           exception=cm.getSootClass(""String_Node_Str"");
          handlerInstructionToException.put(handlerIns,exception);
        }
        if (startIns == endIns)         throw new RuntimeException(""String_Node_Str"");
        Instruction ins=startIns;
        for (; ; ) {
          Instruction[] succs=ins.succs;
          Instruction[] newsuccs=new Instruction[succs.length + 1];
          System.arraycopy(succs,0,newsuccs,0,succs.length);
          newsuccs[succs.length]=handlerIns;
          ins.succs=newsuccs;
          ins=ins.next;
          if (ins == endIns || ins == null)           break;
        }
      }
    }
  }
  Set reachableInstructions=new HashSet();
{
    LinkedList instructionsToVisit=new LinkedList();
    reachableInstructions.add(firstInstruction);
    instructionsToVisit.addLast(firstInstruction);
    while (!instructionsToVisit.isEmpty()) {
      Instruction ins=(Instruction)instructionsToVisit.removeFirst();
      Instruction[] succs=ins.succs;
      for (int i=0; i < succs.length; i++) {
        Instruction succ=succs[i];
        if (!reachableInstructions.contains(succ)) {
          reachableInstructions.add(succ);
          instructionsToVisit.addLast(succ);
        }
      }
    }
  }
{
    instructionToTypeStack=new HashMap();
    instructionToPostTypeStack=new HashMap();
    Set visitedInstructions=new HashSet();
    List changedInstructions=new ArrayList();
    TypeStack initialTypeStack;
{
      initialTypeStack=TypeStack.v();
    }
{
      instructionToTypeStack.put(firstInstruction,initialTypeStack);
      visitedInstructions.add(firstInstruction);
      changedInstructions.add(firstInstruction);
    }
{
      while (!changedInstructions.isEmpty()) {
        Instruction ins=(Instruction)changedInstructions.get(0);
        changedInstructions.remove(0);
        OutFlow ret=processFlow(ins,(TypeStack)instructionToTypeStack.get(ins),constant_pool);
        instructionToPostTypeStack.put(ins,ret.typeStack);
        Instruction[] successors=ins.succs;
        for (int i=0; i < successors.length; i++) {
          Instruction s=successors[i];
          if (!visitedInstructions.contains(s)) {
            if (handlerInstructions.contains(s)) {
              TypeStack exceptionTypeStack=(TypeStack.v()).push(RefType.v(((SootClass)handlerInstructionToException.get(s)).getName()));
              instructionToTypeStack.put(s,exceptionTypeStack);
            }
 else {
              instructionToTypeStack.put(s,ret.typeStack);
            }
            visitedInstructions.add(s);
            changedInstructions.add(s);
          }
 else {
            TypeStack newTypeStack, oldTypeStack=(TypeStack)instructionToTypeStack.get(s);
            if (handlerInstructions.contains(s)) {
              TypeStack exceptionTypeStack=(TypeStack.v()).push(RefType.v(((SootClass)handlerInstructionToException.get(s)).getName()));
              newTypeStack=exceptionTypeStack;
            }
 else {
              try {
                newTypeStack=ret.typeStack.merge(oldTypeStack);
              }
 catch (              RuntimeException re) {
                G.v().out.println(""String_Node_Str"" + s);
                throw re;
              }
            }
            if (!newTypeStack.equals(oldTypeStack)) {
              changedInstructions.add(s);
            }
            instructionToTypeStack.put(s,newTypeStack);
          }
        }
      }
    }
  }
{
    Instruction ins=firstInstruction;
    while (ins != null) {
      TypeStack typeStack=(TypeStack)instructionToTypeStack.get(ins);
      ins=ins.next;
    }
  }
{
    BasicBlock b=cfg;
    while (b != null) {
      Instruction ins=b.head;
      b.statements=new ArrayList();
      List blockStatements=b.statements;
      for (; ; ) {
        List statementsForIns=new ArrayList();
        if (reachableInstructions.contains(ins))         generateJimple(ins,(TypeStack)instructionToTypeStack.get(ins),(TypeStack)instructionToPostTypeStack.get(ins),constant_pool,statementsForIns,b);
 else         statementsForIns.add(Jimple.v().newNopStmt());
        if (!statementsForIns.isEmpty()) {
          for (int i=0; i < statementsForIns.size(); i++) {
            units.add(statementsForIns.get(i));
            blockStatements.add(statementsForIns.get(i));
          }
          instructionToFirstStmt.put(ins,statementsForIns.get(0));
          instructionToLastStmt.put(ins,statementsForIns.get(statementsForIns.size() - 1));
        }
        if (ins == b.tail)         break;
        ins=ins.next;
      }
      b=b.next;
    }
  }
  jimpleTargetFixup();
{
    Map targetToHandler=new HashMap();
    for (int i=0; i < codeAttribute.exception_table_length; i++) {
      Instruction startIns=codeAttribute.exception_table[i].start_inst;
      Instruction endIns=codeAttribute.exception_table[i].end_inst;
      Instruction targetIns=codeAttribute.exception_table[i].handler_inst;
      if (!instructionToFirstStmt.containsKey(startIns) || (endIns != null && (!instructionToLastStmt.containsKey(endIns)))) {
        throw new RuntimeException(""String_Node_Str"");
      }
      if (!instructionToFirstStmt.containsKey(targetIns)) {
        throw new RuntimeException(""String_Node_Str"");
      }
      SootClass exception;
{
        int catchType=codeAttribute.exception_table[i].catch_type;
        if (catchType != 0) {
          CONSTANT_Class_info classinfo=(CONSTANT_Class_info)constant_pool[catchType];
          String name=((CONSTANT_Utf8_info)(constant_pool[classinfo.name_index])).convert();
          name=name.replace('/','.');
          exception=cm.getSootClass(name);
        }
 else         exception=cm.getSootClass(""String_Node_Str"");
      }
      Stmt newTarget;
{
        Stmt firstTargetStmt=(Stmt)instructionToFirstStmt.get(targetIns);
        if (targetToHandler.containsKey(firstTargetStmt))         newTarget=(Stmt)targetToHandler.get(firstTargetStmt);
 else {
          Local local=Util.v().getLocalCreatingIfNecessary(listBody,""String_Node_Str"",UnknownType.v());
          newTarget=Jimple.v().newIdentityStmt(local,Jimple.v().newCaughtExceptionRef());
          units.insertBefore(newTarget,firstTargetStmt);
          targetToHandler.put(firstTargetStmt,newTarget);
        }
      }
{
        Stmt firstStmt=(Stmt)instructionToFirstStmt.get(startIns);
        Stmt afterEndStmt;
        if (endIns == null) {
          afterEndStmt=(Stmt)units.getLast();
        }
 else {
          afterEndStmt=(Stmt)instructionToLastStmt.get(endIns);
          IdentityStmt catchStart=(IdentityStmt)targetToHandler.get(afterEndStmt);
          if (catchStart != null) {
            if (catchStart != units.getPredOf(afterEndStmt)) {
              throw new IllegalStateException(""String_Node_Str"");
            }
            afterEndStmt=catchStart;
          }
        }
        Trap trap=Jimple.v().newTrap(exception,firstStmt,afterEndStmt,newTarget);
        listBody.getTraps().add(trap);
      }
    }
  }
  if (Options.v().keep_line_number()) {
    HashMap stmtstags=new HashMap();
    LinkedList startstmts=new LinkedList();
    attribute_info[] attrs=codeAttribute.attributes;
    for (int i=0; i < attrs.length; i++) {
      if (attrs[i] instanceof LineNumberTable_attribute) {
        LineNumberTable_attribute lntattr=(LineNumberTable_attribute)attrs[i];
        for (int j=0; j < lntattr.line_number_table.length; j++) {
          Stmt start_stmt=(Stmt)instructionToFirstStmt.get(lntattr.line_number_table[j].start_inst);
          if (start_stmt != null) {
            LineNumberTag lntag=new LineNumberTag(lntattr.line_number_table[j].line_number);
            stmtstags.put(start_stmt,lntag);
            startstmts.add(start_stmt);
          }
        }
      }
    }
    for (int i=0; i < startstmts.size(); i++) {
      Stmt stmt=(Stmt)startstmts.get(i);
      Tag tag=(Tag)stmtstags.get(stmt);
      stmt.addTag(tag);
      stmt=(Stmt)units.getSuccOf(stmt);
      while (stmt != null && !stmtstags.containsKey(stmt)) {
        stmt.addTag(tag);
        stmt=(Stmt)units.getSuccOf(stmt);
      }
    }
  }
}","/** 
 * Main.v() entry point for converting list of Instructions to Jimple statements; performs flow analysis, constructs Jimple statements, and fixes jumps.
 * @param constant_pool constant pool of ClassFile.
 * @param this_class constant pool index of the CONSTANT_Class_info object forthis' class.
 * @param clearStacks if <i>true</i> semantic stacks will be deleted afterthe process is complete.
 * @return <i>true</i> if all ok, <i>false</i> if there was an error.
 * @see CFG#jimplify(cp_info[],int)
 * @see Stmt
 */
void jimplify(cp_info constant_pool[],int this_class){
  Code_attribute codeAttribute=method.locate_code_attribute();
  Set handlerInstructions=new ArraySet();
  Map handlerInstructionToException=new HashMap();
  Map instructionToTypeStack;
  Map instructionToPostTypeStack;
{
    buildInsnCFGfromBBCFG();
{
      for (int i=0; i < codeAttribute.exception_table_length; i++) {
        Instruction startIns=codeAttribute.exception_table[i].start_inst;
        Instruction endIns=codeAttribute.exception_table[i].end_inst;
        Instruction handlerIns=codeAttribute.exception_table[i].handler_inst;
        handlerInstructions.add(handlerIns);
{
          int catchType=codeAttribute.exception_table[i].catch_type;
          SootClass exception;
          if (catchType != 0) {
            CONSTANT_Class_info classinfo=(CONSTANT_Class_info)constant_pool[catchType];
            String name=((CONSTANT_Utf8_info)(constant_pool[classinfo.name_index])).convert();
            name=name.replace('/','.');
            exception=cm.getSootClass(name);
          }
 else           exception=cm.getSootClass(""String_Node_Str"");
          handlerInstructionToException.put(handlerIns,exception);
        }
        if (startIns == endIns)         throw new RuntimeException(""String_Node_Str"");
        Instruction ins=startIns;
        for (; ; ) {
          Instruction[] succs=ins.succs;
          Instruction[] newsuccs=new Instruction[succs.length + 1];
          System.arraycopy(succs,0,newsuccs,0,succs.length);
          newsuccs[succs.length]=handlerIns;
          ins.succs=newsuccs;
          ins=ins.next;
          if (ins == endIns || ins == null)           break;
        }
      }
    }
  }
  Set reachableInstructions=new HashSet();
{
    LinkedList instructionsToVisit=new LinkedList();
    reachableInstructions.add(firstInstruction);
    instructionsToVisit.addLast(firstInstruction);
    while (!instructionsToVisit.isEmpty()) {
      Instruction ins=(Instruction)instructionsToVisit.removeFirst();
      Instruction[] succs=ins.succs;
      for (int i=0; i < succs.length; i++) {
        Instruction succ=succs[i];
        if (!reachableInstructions.contains(succ)) {
          reachableInstructions.add(succ);
          instructionsToVisit.addLast(succ);
        }
      }
    }
  }
{
    instructionToTypeStack=new HashMap();
    instructionToPostTypeStack=new HashMap();
    Set visitedInstructions=new HashSet();
    List changedInstructions=new ArrayList();
    TypeStack initialTypeStack;
{
      initialTypeStack=TypeStack.v();
    }
{
      instructionToTypeStack.put(firstInstruction,initialTypeStack);
      visitedInstructions.add(firstInstruction);
      changedInstructions.add(firstInstruction);
    }
{
      while (!changedInstructions.isEmpty()) {
        Instruction ins=(Instruction)changedInstructions.get(0);
        changedInstructions.remove(0);
        OutFlow ret=processFlow(ins,(TypeStack)instructionToTypeStack.get(ins),constant_pool);
        instructionToPostTypeStack.put(ins,ret.typeStack);
        Instruction[] successors=ins.succs;
        for (int i=0; i < successors.length; i++) {
          Instruction s=successors[i];
          if (!visitedInstructions.contains(s)) {
            if (handlerInstructions.contains(s)) {
              TypeStack exceptionTypeStack=(TypeStack.v()).push(RefType.v(((SootClass)handlerInstructionToException.get(s)).getName()));
              instructionToTypeStack.put(s,exceptionTypeStack);
            }
 else {
              instructionToTypeStack.put(s,ret.typeStack);
            }
            visitedInstructions.add(s);
            changedInstructions.add(s);
          }
 else {
            TypeStack newTypeStack, oldTypeStack=(TypeStack)instructionToTypeStack.get(s);
            if (handlerInstructions.contains(s)) {
              TypeStack exceptionTypeStack=(TypeStack.v()).push(RefType.v(((SootClass)handlerInstructionToException.get(s)).getName()));
              newTypeStack=exceptionTypeStack;
            }
 else {
              try {
                newTypeStack=ret.typeStack.merge(oldTypeStack);
              }
 catch (              RuntimeException re) {
                G.v().out.println(""String_Node_Str"" + s);
                throw re;
              }
            }
            if (!newTypeStack.equals(oldTypeStack)) {
              changedInstructions.add(s);
            }
            instructionToTypeStack.put(s,newTypeStack);
          }
        }
      }
    }
  }
{
    Instruction ins=firstInstruction;
    while (ins != null) {
      TypeStack typeStack=(TypeStack)instructionToTypeStack.get(ins);
      ins=ins.next;
    }
  }
{
    BasicBlock b=cfg;
    while (b != null) {
      Instruction ins=b.head;
      b.statements=new ArrayList();
      List blockStatements=b.statements;
      for (; ; ) {
        List statementsForIns=new ArrayList();
        if (reachableInstructions.contains(ins))         generateJimple(ins,(TypeStack)instructionToTypeStack.get(ins),(TypeStack)instructionToPostTypeStack.get(ins),constant_pool,statementsForIns,b);
 else         statementsForIns.add(Jimple.v().newNopStmt());
        if (!statementsForIns.isEmpty()) {
          for (int i=0; i < statementsForIns.size(); i++) {
            units.add(statementsForIns.get(i));
            blockStatements.add(statementsForIns.get(i));
          }
          instructionToFirstStmt.put(ins,statementsForIns.get(0));
          instructionToLastStmt.put(ins,statementsForIns.get(statementsForIns.size() - 1));
        }
        if (ins == b.tail)         break;
        ins=ins.next;
      }
      b=b.next;
    }
  }
  jimpleTargetFixup();
{
    Map targetToHandler=new HashMap();
    for (int i=0; i < codeAttribute.exception_table_length; i++) {
      Instruction startIns=codeAttribute.exception_table[i].start_inst;
      Instruction endIns=codeAttribute.exception_table[i].end_inst;
      Instruction targetIns=codeAttribute.exception_table[i].handler_inst;
      if (!instructionToFirstStmt.containsKey(startIns) || (endIns != null && (!instructionToLastStmt.containsKey(endIns)))) {
        throw new RuntimeException(""String_Node_Str"");
      }
      if (!instructionToFirstStmt.containsKey(targetIns)) {
        throw new RuntimeException(""String_Node_Str"");
      }
      SootClass exception;
{
        int catchType=codeAttribute.exception_table[i].catch_type;
        if (catchType != 0) {
          CONSTANT_Class_info classinfo=(CONSTANT_Class_info)constant_pool[catchType];
          String name=((CONSTANT_Utf8_info)(constant_pool[classinfo.name_index])).convert();
          name=name.replace('/','.');
          exception=cm.getSootClass(name);
        }
 else         exception=cm.getSootClass(""String_Node_Str"");
      }
      Stmt newTarget;
{
        Stmt firstTargetStmt=(Stmt)instructionToFirstStmt.get(targetIns);
        if (targetToHandler.containsKey(firstTargetStmt))         newTarget=(Stmt)targetToHandler.get(firstTargetStmt);
 else {
          Local local=Util.v().getLocalCreatingIfNecessary(listBody,""String_Node_Str"",UnknownType.v());
          newTarget=Jimple.v().newIdentityStmt(local,Jimple.v().newCaughtExceptionRef());
          units.insertBefore(newTarget,firstTargetStmt);
          instructionToFirstStmt.put(targetIns,newTarget);
          targetToHandler.put(firstTargetStmt,newTarget);
        }
      }
{
        Stmt firstStmt=(Stmt)instructionToFirstStmt.get(startIns);
        Stmt afterEndStmt;
        if (endIns == null) {
          afterEndStmt=(Stmt)units.getLast();
        }
 else {
          afterEndStmt=(Stmt)instructionToLastStmt.get(endIns);
          IdentityStmt catchStart=(IdentityStmt)targetToHandler.get(afterEndStmt);
          if (catchStart != null) {
            if (catchStart != units.getPredOf(afterEndStmt)) {
              throw new IllegalStateException(""String_Node_Str"");
            }
            afterEndStmt=catchStart;
          }
        }
        Trap trap=Jimple.v().newTrap(exception,firstStmt,afterEndStmt,newTarget);
        listBody.getTraps().add(trap);
      }
    }
  }
  if (Options.v().keep_line_number()) {
    HashMap stmtstags=new HashMap();
    LinkedList startstmts=new LinkedList();
    attribute_info[] attrs=codeAttribute.attributes;
    for (int i=0; i < attrs.length; i++) {
      if (attrs[i] instanceof LineNumberTable_attribute) {
        LineNumberTable_attribute lntattr=(LineNumberTable_attribute)attrs[i];
        for (int j=0; j < lntattr.line_number_table.length; j++) {
          Stmt start_stmt=(Stmt)instructionToFirstStmt.get(lntattr.line_number_table[j].start_inst);
          if (start_stmt != null) {
            LineNumberTag lntag=new LineNumberTag(lntattr.line_number_table[j].line_number);
            stmtstags.put(start_stmt,lntag);
            startstmts.add(start_stmt);
          }
        }
      }
    }
    for (int i=0; i < startstmts.size(); i++) {
      Stmt stmt=(Stmt)startstmts.get(i);
      Tag tag=(Tag)stmtstags.get(stmt);
      stmt.addTag(tag);
      stmt=(Stmt)units.getSuccOf(stmt);
      while (stmt != null && !stmtstags.containsKey(stmt)) {
        stmt.addTag(tag);
        stmt=(Stmt)units.getSuccOf(stmt);
      }
    }
  }
}"
88566,"protected soot.Local generateLocal(soot.Type sootType){
  return ext().generateLocal(sootType);
}","protected soot.Local generateLocal(polyglot.types.Type polyglotType){
  return ext().generateLocal(polyglotType);
}"
88567,"protected soot.Value createExpr(polyglot.ast.Expr expr){
  if (expr instanceof soot.javaToJimple.jj.ast.JjAccessField_c) {
    soot.javaToJimple.jj.ast.JjAccessField_c accessField=(soot.javaToJimple.jj.ast.JjAccessField_c)expr;
    return ext().createExpr(accessField.field());
  }
 else {
    return ext().createExpr(expr);
  }
}","protected soot.Value createExpr(polyglot.ast.Expr expr){
  if (expr instanceof soot.javaToJimple.jj.ast.JjAccessField_c) {
    soot.javaToJimple.jj.ast.JjAccessField_c accessField=(soot.javaToJimple.jj.ast.JjAccessField_c)expr;
    return handleCall(accessField.field(),accessField.getMeth(),null,null);
  }
 else {
    return ext().createExpr(expr);
  }
}"
88568,"protected soot.Local handlePrivateFieldAssignSet(polyglot.ast.Assign assign){
  if ((assign.left() instanceof soot.javaToJimple.jj.ast.JjAccessField_c) && (assign.operator() != polyglot.ast.Assign.ASSIGN)) {
    soot.javaToJimple.jj.ast.JjAccessField_c accessField=(soot.javaToJimple.jj.ast.JjAccessField_c)assign.left();
    soot.Local leftLocal=(soot.Local)base().createExpr(accessField.getMeth());
    soot.Value right=base().getAssignRightLocal(assign,leftLocal);
    return base().handlePrivateFieldSet(accessField,right);
  }
 else {
    return ext().handlePrivateFieldAssignSet(assign);
  }
}","protected soot.Local handlePrivateFieldAssignSet(polyglot.ast.Assign assign){
  if (assign.left() instanceof soot.javaToJimple.jj.ast.JjAccessField_c) {
    soot.javaToJimple.jj.ast.JjAccessField_c accessField=(soot.javaToJimple.jj.ast.JjAccessField_c)assign.left();
    if (assign.operator() == polyglot.ast.Assign.ASSIGN) {
      soot.Value right=base().getSimpleAssignRightLocal(assign);
      return base().handlePrivateFieldSet(accessField,right);
    }
 else {
      soot.Local baseLocal=(soot.Local)base().getBaseLocal(accessField.field().target());
      soot.Local leftLocal=handleCall(accessField.field(),accessField.getMeth(),null,baseLocal);
      soot.Value right=base().getAssignRightLocal(assign,leftLocal);
      return handleFieldSet(accessField,right,baseLocal);
    }
  }
 else {
    return ext().handlePrivateFieldAssignSet(assign);
  }
}"
88569,"protected soot.Local handlePrivateFieldSet(polyglot.ast.Expr expr,soot.Value right){
  if (expr instanceof soot.javaToJimple.jj.ast.JjAccessField_c) {
    soot.javaToJimple.jj.ast.JjAccessField_c accessField=(soot.javaToJimple.jj.ast.JjAccessField_c)expr;
    soot.SootMethodRef methToCall=base().getSootMethodRef(accessField.setMeth());
    ArrayList params=new ArrayList();
    if (!accessField.field().flags().isStatic()) {
      params.add(base().getThis(Util.getSootType(accessField.field().target().type())));
    }
    if (right != null) {
      params.add(right);
    }
    soot.jimple.InvokeExpr invoke;
    if (methToCall.isStatic()) {
      invoke=soot.jimple.Jimple.v().newStaticInvokeExpr(methToCall,params);
    }
 else {
      soot.Local baseLocal=(soot.Local)ext().getBaseLocal((polyglot.ast.Receiver)accessField.setMeth().target());
      invoke=soot.jimple.Jimple.v().newVirtualInvokeExpr(baseLocal,methToCall,params);
    }
    soot.Local retLocal=base().generateLocal(right.getType());
    soot.jimple.AssignStmt assignStmt=soot.jimple.Jimple.v().newAssignStmt(retLocal,invoke);
    body.getUnits().add(assignStmt);
    return retLocal;
  }
 else {
    return ext().handlePrivateFieldSet(expr,right);
  }
}","protected soot.Local handlePrivateFieldSet(polyglot.ast.Expr expr,soot.Value right){
  if (expr instanceof soot.javaToJimple.jj.ast.JjAccessField_c) {
    soot.javaToJimple.jj.ast.JjAccessField_c accessField=(soot.javaToJimple.jj.ast.JjAccessField_c)expr;
    return handleCall(accessField.field(),accessField.setMeth(),right,null);
  }
 else {
    return ext().handlePrivateFieldSet(expr,right);
  }
}"
88570,"/** 
 * Condition Expression Creation - can maybe merge with If
 */
private soot.Local getConditionalLocal(polyglot.ast.Conditional condExpr){
  polyglot.ast.Expr condition=condExpr.cond();
  soot.Value sootCond=base().createExpr(condition);
  boolean needIf=needSootIf(sootCond);
  if (!(sootCond instanceof soot.jimple.ConditionExpr)) {
    sootCond=soot.jimple.Jimple.v().newEqExpr(sootCond,soot.jimple.IntConstant.v(0));
  }
 else {
    sootCond=reverseCondition((soot.jimple.ConditionExpr)sootCond);
    sootCond=handleDFLCond((soot.jimple.ConditionExpr)sootCond);
  }
  soot.jimple.Stmt noop1=soot.jimple.Jimple.v().newNopStmt();
  if (needIf) {
    soot.jimple.IfStmt ifStmt=soot.jimple.Jimple.v().newIfStmt(sootCond,noop1);
    body.getUnits().add(ifStmt);
    Util.addLnPosTags(ifStmt,condExpr.position());
    Util.addLnPosTags(ifStmt.getConditionBox(),condition.position());
  }
  soot.Local retLocal=generateLocal(condExpr.alternative().type());
  polyglot.ast.Expr consequence=condExpr.consequent();
  soot.Value conseqVal=base().createExpr(consequence);
  soot.jimple.AssignStmt conseqAssignStmt=soot.jimple.Jimple.v().newAssignStmt(retLocal,conseqVal);
  body.getUnits().add(conseqAssignStmt);
  Util.addLnPosTags(conseqAssignStmt,condExpr.position());
  Util.addLnPosTags(conseqAssignStmt.getRightOpBox(),consequence.position());
  soot.jimple.Stmt noop2=soot.jimple.Jimple.v().newNopStmt();
  soot.jimple.Stmt goto1=soot.jimple.Jimple.v().newGotoStmt(noop2);
  body.getUnits().add(goto1);
  body.getUnits().add(noop1);
  polyglot.ast.Expr alternative=condExpr.alternative();
  if (alternative != null) {
    soot.Value altVal=base().createExpr(alternative);
    soot.jimple.AssignStmt altAssignStmt=soot.jimple.Jimple.v().newAssignStmt(retLocal,altVal);
    body.getUnits().add(altAssignStmt);
    Util.addLnPosTags(altAssignStmt,condExpr.position());
    Util.addLnPosTags(altAssignStmt,alternative.position());
    Util.addLnPosTags(altAssignStmt.getRightOpBox(),alternative.position());
  }
  body.getUnits().add(noop2);
  return retLocal;
}","/** 
 * Condition Expression Creation - can maybe merge with If
 */
private soot.Local getConditionalLocal(polyglot.ast.Conditional condExpr){
  polyglot.ast.Expr condition=condExpr.cond();
  soot.Value sootCond=base().createExpr(condition);
  boolean needIf=needSootIf(sootCond);
  if (!(sootCond instanceof soot.jimple.ConditionExpr)) {
    sootCond=soot.jimple.Jimple.v().newEqExpr(sootCond,soot.jimple.IntConstant.v(0));
  }
 else {
    sootCond=reverseCondition((soot.jimple.ConditionExpr)sootCond);
    sootCond=handleDFLCond((soot.jimple.ConditionExpr)sootCond);
  }
  soot.jimple.Stmt noop1=soot.jimple.Jimple.v().newNopStmt();
  if (needIf) {
    soot.jimple.IfStmt ifStmt=soot.jimple.Jimple.v().newIfStmt(sootCond,noop1);
    body.getUnits().add(ifStmt);
    Util.addLnPosTags(ifStmt,condExpr.position());
    Util.addLnPosTags(ifStmt.getConditionBox(),condition.position());
  }
  soot.Local retLocal=generateLocal(condExpr.type());
  polyglot.ast.Expr consequence=condExpr.consequent();
  soot.Value conseqVal=base().createExpr(consequence);
  soot.jimple.AssignStmt conseqAssignStmt=soot.jimple.Jimple.v().newAssignStmt(retLocal,conseqVal);
  body.getUnits().add(conseqAssignStmt);
  Util.addLnPosTags(conseqAssignStmt,condExpr.position());
  Util.addLnPosTags(conseqAssignStmt.getRightOpBox(),consequence.position());
  soot.jimple.Stmt noop2=soot.jimple.Jimple.v().newNopStmt();
  soot.jimple.Stmt goto1=soot.jimple.Jimple.v().newGotoStmt(noop2);
  body.getUnits().add(goto1);
  body.getUnits().add(noop1);
  polyglot.ast.Expr alternative=condExpr.alternative();
  if (alternative != null) {
    soot.Value altVal=base().createExpr(alternative);
    soot.jimple.AssignStmt altAssignStmt=soot.jimple.Jimple.v().newAssignStmt(retLocal,altVal);
    body.getUnits().add(altAssignStmt);
    Util.addLnPosTags(altAssignStmt,condExpr.position());
    Util.addLnPosTags(altAssignStmt,alternative.position());
    Util.addLnPosTags(altAssignStmt.getRightOpBox(),alternative.position());
  }
  body.getUnits().add(noop2);
  return retLocal;
}"
88571,"/** 
 * Handling for assert stmts - extra fields and methods are needed in the Jimple 
 */
private void handleAssert(polyglot.ast.ClassBody cBody){
  AssertStmtChecker asc=new AssertStmtChecker();
  cBody.visit(asc);
  if (!asc.isHasAssert())   return;
  if (!sootClass.declaresField(""String_Node_Str"",soot.BooleanType.v())) {
    sootClass.addField(new soot.SootField(""String_Node_Str"",soot.BooleanType.v(),soot.Modifier.STATIC | soot.Modifier.FINAL));
  }
  soot.SootClass addClassToClass=sootClass;
  while ((InitialResolver.v().getInnerClassInfoMap() != null) && (InitialResolver.v().getInnerClassInfoMap().containsKey(addClassToClass))) {
    addClassToClass=((InnerClassInfo)InitialResolver.v().getInnerClassInfoMap().get(addClassToClass)).getOuterClass();
  }
  if (!addClassToClass.declaresField(""String_Node_Str"" + addClassToClass.getName(),soot.RefType.v(""String_Node_Str""))) {
    addClassToClass.addField(new soot.SootField(""String_Node_Str"" + addClassToClass.getName(),soot.RefType.v(""String_Node_Str""),soot.Modifier.STATIC));
  }
  String methodName=""String_Node_Str"";
  soot.Type methodRetType=soot.RefType.v(""String_Node_Str"");
  ArrayList paramTypes=new ArrayList();
  paramTypes.add(soot.RefType.v(""String_Node_Str""));
  if (!addClassToClass.declaresMethod(methodName,paramTypes,methodRetType)) {
    soot.SootMethod sootMethod=new soot.SootMethod(methodName,paramTypes,methodRetType,soot.Modifier.STATIC);
    AssertClassMethodSource mSrc=new AssertClassMethodSource();
    sootMethod.setSource(mSrc);
    addClassToClass.addMethod(sootMethod);
  }
  methodName=""String_Node_Str"";
  methodRetType=soot.VoidType.v();
  paramTypes=new ArrayList();
  if (!sootClass.declaresMethod(methodName,paramTypes,methodRetType)) {
    soot.SootMethod sootMethod=new soot.SootMethod(methodName,paramTypes,methodRetType,soot.Modifier.STATIC);
    PolyglotMethodSource mSrc=new PolyglotMethodSource();
    mSrc.setJBB(InitialResolver.v().getJBBFactory().createJimpleBodyBuilder());
    mSrc.hasAssert(true);
    sootMethod.setSource(mSrc);
    sootClass.addMethod(sootMethod);
  }
 else {
    ((soot.javaToJimple.PolyglotMethodSource)sootClass.getMethod(methodName,paramTypes,methodRetType).getSource()).hasAssert(true);
  }
}","/** 
 * Handling for assert stmts - extra fields and methods are needed in the Jimple 
 */
private void handleAssert(polyglot.ast.ClassBody cBody){
  AssertStmtChecker asc=new AssertStmtChecker();
  cBody.visit(asc);
  if (!asc.isHasAssert())   return;
  if (!sootClass.declaresField(""String_Node_Str"",soot.BooleanType.v())) {
    sootClass.addField(new soot.SootField(""String_Node_Str"",soot.BooleanType.v(),soot.Modifier.STATIC | soot.Modifier.FINAL));
  }
  soot.SootClass addClassToClass=sootClass;
  while ((InitialResolver.v().getInnerClassInfoMap() != null) && (InitialResolver.v().getInnerClassInfoMap().containsKey(addClassToClass))) {
    addClassToClass=((InnerClassInfo)InitialResolver.v().getInnerClassInfoMap().get(addClassToClass)).getOuterClass();
  }
  if (!addClassToClass.declaresField(""String_Node_Str"" + soot.util.StringTools.replaceAll(addClassToClass.getName(),""String_Node_Str"",""String_Node_Str""),soot.RefType.v(""String_Node_Str""))) {
    addClassToClass.addField(new soot.SootField(""String_Node_Str"" + soot.util.StringTools.replaceAll(addClassToClass.getName(),""String_Node_Str"",""String_Node_Str""),soot.RefType.v(""String_Node_Str""),soot.Modifier.STATIC));
  }
  String methodName=""String_Node_Str"";
  soot.Type methodRetType=soot.RefType.v(""String_Node_Str"");
  ArrayList paramTypes=new ArrayList();
  paramTypes.add(soot.RefType.v(""String_Node_Str""));
  if (!addClassToClass.declaresMethod(methodName,paramTypes,methodRetType)) {
    soot.SootMethod sootMethod=new soot.SootMethod(methodName,paramTypes,methodRetType,soot.Modifier.STATIC);
    AssertClassMethodSource mSrc=new AssertClassMethodSource();
    sootMethod.setSource(mSrc);
    addClassToClass.addMethod(sootMethod);
  }
  methodName=""String_Node_Str"";
  methodRetType=soot.VoidType.v();
  paramTypes=new ArrayList();
  if (!sootClass.declaresMethod(methodName,paramTypes,methodRetType)) {
    soot.SootMethod sootMethod=new soot.SootMethod(methodName,paramTypes,methodRetType,soot.Modifier.STATIC);
    PolyglotMethodSource mSrc=new PolyglotMethodSource();
    mSrc.setJBB(InitialResolver.v().getJBBFactory().createJimpleBodyBuilder());
    mSrc.hasAssert(true);
    sootMethod.setSource(mSrc);
    sootClass.addMethod(sootMethod);
  }
 else {
    ((soot.javaToJimple.PolyglotMethodSource)sootClass.getMethod(methodName,paramTypes,methodRetType).getSource()).hasAssert(true);
  }
}"
88572,"public void addAssertInits(soot.Body body){
  soot.SootClass assertStatusClass=body.getMethod().getDeclaringClass();
  HashMap innerMap=soot.javaToJimple.InitialResolver.v().getInnerClassInfoMap();
  while ((innerMap != null) && (innerMap.containsKey(assertStatusClass))) {
    assertStatusClass=((InnerClassInfo)innerMap.get(assertStatusClass)).getOuterClass();
  }
  soot.SootFieldRef field=soot.Scene.v().makeFieldRef(assertStatusClass,""String_Node_Str"" + assertStatusClass.getName(),soot.RefType.v(""String_Node_Str""),true);
  soot.Local fieldLocal=soot.jimple.Jimple.v().newLocal(""String_Node_Str"",soot.RefType.v(""String_Node_Str""));
  body.getLocals().add(fieldLocal);
  soot.jimple.FieldRef fieldRef=soot.jimple.Jimple.v().newStaticFieldRef(field);
  soot.jimple.AssignStmt fieldAssignStmt=soot.jimple.Jimple.v().newAssignStmt(fieldLocal,fieldRef);
  body.getUnits().add(fieldAssignStmt);
  soot.jimple.ConditionExpr cond=soot.jimple.Jimple.v().newNeExpr(fieldLocal,soot.jimple.NullConstant.v());
  soot.jimple.NopStmt nop1=soot.jimple.Jimple.v().newNopStmt();
  soot.jimple.IfStmt ifStmt=soot.jimple.Jimple.v().newIfStmt(cond,nop1);
  body.getUnits().add(ifStmt);
  soot.Local invokeLocal=soot.jimple.Jimple.v().newLocal(""String_Node_Str"",soot.RefType.v(""String_Node_Str""));
  body.getLocals().add(invokeLocal);
  ArrayList paramTypes=new ArrayList();
  paramTypes.add(soot.RefType.v(""String_Node_Str""));
  soot.SootMethodRef methodToInvoke=soot.Scene.v().makeMethodRef(assertStatusClass,""String_Node_Str"",paramTypes,soot.RefType.v(""String_Node_Str""),true);
  ArrayList params=new ArrayList();
  params.add(soot.jimple.StringConstant.v(assertStatusClass.getName()));
  soot.jimple.StaticInvokeExpr invoke=soot.jimple.Jimple.v().newStaticInvokeExpr(methodToInvoke,params);
  soot.jimple.AssignStmt invokeAssign=soot.jimple.Jimple.v().newAssignStmt(invokeLocal,invoke);
  body.getUnits().add(invokeAssign);
  soot.jimple.AssignStmt fieldRefAssign=soot.jimple.Jimple.v().newAssignStmt(fieldRef,invokeLocal);
  body.getUnits().add(fieldRefAssign);
  soot.jimple.NopStmt nop2=soot.jimple.Jimple.v().newNopStmt();
  soot.jimple.GotoStmt goto1=soot.jimple.Jimple.v().newGotoStmt(nop2);
  body.getUnits().add(goto1);
  body.getUnits().add(nop1);
  soot.jimple.AssignStmt fieldRefAssign2=soot.jimple.Jimple.v().newAssignStmt(invokeLocal,fieldRef);
  body.getUnits().add(fieldRefAssign2);
  body.getUnits().add(nop2);
  soot.Local boolLocal1=soot.jimple.Jimple.v().newLocal(""String_Node_Str"",soot.BooleanType.v());
  body.getLocals().add(boolLocal1);
  soot.Local boolLocal2=soot.jimple.Jimple.v().newLocal(""String_Node_Str"",soot.BooleanType.v());
  body.getLocals().add(boolLocal2);
  soot.SootMethodRef vMethodToInvoke=Scene.v().makeMethodRef(soot.Scene.v().getSootClass(""String_Node_Str""),""String_Node_Str"",new ArrayList(),soot.BooleanType.v(),false);
  soot.jimple.VirtualInvokeExpr vInvoke=soot.jimple.Jimple.v().newVirtualInvokeExpr(invokeLocal,vMethodToInvoke,new ArrayList());
  soot.jimple.AssignStmt testAssign=soot.jimple.Jimple.v().newAssignStmt(boolLocal1,vInvoke);
  body.getUnits().add(testAssign);
  soot.jimple.ConditionExpr cond2=soot.jimple.Jimple.v().newNeExpr(boolLocal1,soot.jimple.IntConstant.v(0));
  soot.jimple.NopStmt nop3=soot.jimple.Jimple.v().newNopStmt();
  soot.jimple.IfStmt ifStmt2=soot.jimple.Jimple.v().newIfStmt(cond2,nop3);
  body.getUnits().add(ifStmt2);
  soot.jimple.AssignStmt altAssign=soot.jimple.Jimple.v().newAssignStmt(boolLocal2,soot.jimple.IntConstant.v(1));
  body.getUnits().add(altAssign);
  soot.jimple.NopStmt nop4=soot.jimple.Jimple.v().newNopStmt();
  soot.jimple.GotoStmt goto2=soot.jimple.Jimple.v().newGotoStmt(nop4);
  body.getUnits().add(goto2);
  body.getUnits().add(nop3);
  soot.jimple.AssignStmt conAssign=soot.jimple.Jimple.v().newAssignStmt(boolLocal2,soot.jimple.IntConstant.v(0));
  body.getUnits().add(conAssign);
  body.getUnits().add(nop4);
  soot.SootFieldRef fieldD=Scene.v().makeFieldRef(body.getMethod().getDeclaringClass(),""String_Node_Str"",soot.BooleanType.v(),true);
  soot.jimple.FieldRef fieldRefD=soot.jimple.Jimple.v().newStaticFieldRef(fieldD);
  soot.jimple.AssignStmt fAssign=soot.jimple.Jimple.v().newAssignStmt(fieldRefD,boolLocal2);
  body.getUnits().add(fAssign);
}","public void addAssertInits(soot.Body body){
  soot.SootClass assertStatusClass=body.getMethod().getDeclaringClass();
  HashMap innerMap=soot.javaToJimple.InitialResolver.v().getInnerClassInfoMap();
  while ((innerMap != null) && (innerMap.containsKey(assertStatusClass))) {
    assertStatusClass=((InnerClassInfo)innerMap.get(assertStatusClass)).getOuterClass();
  }
  soot.SootFieldRef field=soot.Scene.v().makeFieldRef(assertStatusClass,""String_Node_Str"" + soot.util.StringTools.replaceAll(assertStatusClass.getName(),""String_Node_Str"",""String_Node_Str""),soot.RefType.v(""String_Node_Str""),true);
  soot.Local fieldLocal=soot.jimple.Jimple.v().newLocal(""String_Node_Str"",soot.RefType.v(""String_Node_Str""));
  body.getLocals().add(fieldLocal);
  soot.jimple.FieldRef fieldRef=soot.jimple.Jimple.v().newStaticFieldRef(field);
  soot.jimple.AssignStmt fieldAssignStmt=soot.jimple.Jimple.v().newAssignStmt(fieldLocal,fieldRef);
  body.getUnits().add(fieldAssignStmt);
  soot.jimple.ConditionExpr cond=soot.jimple.Jimple.v().newNeExpr(fieldLocal,soot.jimple.NullConstant.v());
  soot.jimple.NopStmt nop1=soot.jimple.Jimple.v().newNopStmt();
  soot.jimple.IfStmt ifStmt=soot.jimple.Jimple.v().newIfStmt(cond,nop1);
  body.getUnits().add(ifStmt);
  soot.Local invokeLocal=soot.jimple.Jimple.v().newLocal(""String_Node_Str"",soot.RefType.v(""String_Node_Str""));
  body.getLocals().add(invokeLocal);
  ArrayList paramTypes=new ArrayList();
  paramTypes.add(soot.RefType.v(""String_Node_Str""));
  soot.SootMethodRef methodToInvoke=soot.Scene.v().makeMethodRef(assertStatusClass,""String_Node_Str"",paramTypes,soot.RefType.v(""String_Node_Str""),true);
  ArrayList params=new ArrayList();
  params.add(soot.jimple.StringConstant.v(assertStatusClass.getName()));
  soot.jimple.StaticInvokeExpr invoke=soot.jimple.Jimple.v().newStaticInvokeExpr(methodToInvoke,params);
  soot.jimple.AssignStmt invokeAssign=soot.jimple.Jimple.v().newAssignStmt(invokeLocal,invoke);
  body.getUnits().add(invokeAssign);
  soot.jimple.AssignStmt fieldRefAssign=soot.jimple.Jimple.v().newAssignStmt(fieldRef,invokeLocal);
  body.getUnits().add(fieldRefAssign);
  soot.jimple.NopStmt nop2=soot.jimple.Jimple.v().newNopStmt();
  soot.jimple.GotoStmt goto1=soot.jimple.Jimple.v().newGotoStmt(nop2);
  body.getUnits().add(goto1);
  body.getUnits().add(nop1);
  soot.jimple.AssignStmt fieldRefAssign2=soot.jimple.Jimple.v().newAssignStmt(invokeLocal,fieldRef);
  body.getUnits().add(fieldRefAssign2);
  body.getUnits().add(nop2);
  soot.Local boolLocal1=soot.jimple.Jimple.v().newLocal(""String_Node_Str"",soot.BooleanType.v());
  body.getLocals().add(boolLocal1);
  soot.Local boolLocal2=soot.jimple.Jimple.v().newLocal(""String_Node_Str"",soot.BooleanType.v());
  body.getLocals().add(boolLocal2);
  soot.SootMethodRef vMethodToInvoke=Scene.v().makeMethodRef(soot.Scene.v().getSootClass(""String_Node_Str""),""String_Node_Str"",new ArrayList(),soot.BooleanType.v(),false);
  soot.jimple.VirtualInvokeExpr vInvoke=soot.jimple.Jimple.v().newVirtualInvokeExpr(invokeLocal,vMethodToInvoke,new ArrayList());
  soot.jimple.AssignStmt testAssign=soot.jimple.Jimple.v().newAssignStmt(boolLocal1,vInvoke);
  body.getUnits().add(testAssign);
  soot.jimple.ConditionExpr cond2=soot.jimple.Jimple.v().newNeExpr(boolLocal1,soot.jimple.IntConstant.v(0));
  soot.jimple.NopStmt nop3=soot.jimple.Jimple.v().newNopStmt();
  soot.jimple.IfStmt ifStmt2=soot.jimple.Jimple.v().newIfStmt(cond2,nop3);
  body.getUnits().add(ifStmt2);
  soot.jimple.AssignStmt altAssign=soot.jimple.Jimple.v().newAssignStmt(boolLocal2,soot.jimple.IntConstant.v(1));
  body.getUnits().add(altAssign);
  soot.jimple.NopStmt nop4=soot.jimple.Jimple.v().newNopStmt();
  soot.jimple.GotoStmt goto2=soot.jimple.Jimple.v().newGotoStmt(nop4);
  body.getUnits().add(goto2);
  body.getUnits().add(nop3);
  soot.jimple.AssignStmt conAssign=soot.jimple.Jimple.v().newAssignStmt(boolLocal2,soot.jimple.IntConstant.v(0));
  body.getUnits().add(conAssign);
  body.getUnits().add(nop4);
  soot.SootFieldRef fieldD=Scene.v().makeFieldRef(body.getMethod().getDeclaringClass(),""String_Node_Str"",soot.BooleanType.v(),true);
  soot.jimple.FieldRef fieldRefD=soot.jimple.Jimple.v().newStaticFieldRef(fieldD);
  soot.jimple.AssignStmt fAssign=soot.jimple.Jimple.v().newAssignStmt(fieldRefD,boolLocal2);
  body.getUnits().add(fAssign);
}"
88573,"protected soot.Local handlePrivateFieldSet(polyglot.ast.Expr expr,soot.Value right){
  if (expr instanceof soot.javaToJimple.jj.ast.JjAccessField_c) {
    soot.javaToJimple.jj.ast.JjAccessField_c accessField=(soot.javaToJimple.jj.ast.JjAccessField_c)expr;
    soot.SootMethodRef methToCall=base().getSootMethodRef(accessField.setMeth());
    ArrayList params=new ArrayList();
    if (!accessField.field().flags().isStatic()) {
      params.add(base().getThis(Util.getSootType(accessField.field().target().type())));
    }
    params.add(right);
    soot.jimple.InvokeExpr invoke;
    if (methToCall.isStatic()) {
      invoke=soot.jimple.Jimple.v().newStaticInvokeExpr(methToCall,params);
    }
 else {
      soot.Local baseLocal=(soot.Local)ext().getBaseLocal((polyglot.ast.Receiver)accessField.setMeth().target());
      invoke=soot.jimple.Jimple.v().newVirtualInvokeExpr(baseLocal,methToCall,params);
    }
    soot.Local retLocal=base().generateLocal(right.getType());
    soot.jimple.AssignStmt assignStmt=soot.jimple.Jimple.v().newAssignStmt(retLocal,invoke);
    body.getUnits().add(assignStmt);
    return retLocal;
  }
 else {
    return ext().handlePrivateFieldSet(expr,right);
  }
}","protected soot.Local handlePrivateFieldSet(polyglot.ast.Expr expr,soot.Value right){
  if (expr instanceof soot.javaToJimple.jj.ast.JjAccessField_c) {
    soot.javaToJimple.jj.ast.JjAccessField_c accessField=(soot.javaToJimple.jj.ast.JjAccessField_c)expr;
    soot.SootMethodRef methToCall=base().getSootMethodRef(accessField.setMeth());
    ArrayList params=new ArrayList();
    if (!accessField.field().flags().isStatic()) {
      params.add(base().getThis(Util.getSootType(accessField.field().target().type())));
    }
    if (right != null) {
      params.add(right);
    }
    soot.jimple.InvokeExpr invoke;
    if (methToCall.isStatic()) {
      invoke=soot.jimple.Jimple.v().newStaticInvokeExpr(methToCall,params);
    }
 else {
      soot.Local baseLocal=(soot.Local)ext().getBaseLocal((polyglot.ast.Receiver)accessField.setMeth().target());
      invoke=soot.jimple.Jimple.v().newVirtualInvokeExpr(baseLocal,methToCall,params);
    }
    soot.Local retLocal=base().generateLocal(right.getType());
    soot.jimple.AssignStmt assignStmt=soot.jimple.Jimple.v().newAssignStmt(retLocal,invoke);
    body.getUnits().add(assignStmt);
    return retLocal;
  }
 else {
    return ext().handlePrivateFieldSet(expr,right);
  }
}"
88574,"/** 
 * Unary Expression Creation
 */
private soot.Local getUnaryLocal(polyglot.ast.Unary unary){
  polyglot.ast.Expr expr=unary.expr();
  polyglot.ast.Unary.Operator op=unary.operator();
  if (op == polyglot.ast.Unary.POST_INC) {
    soot.Local retLocal=generateLocal(expr.type());
    soot.Value sootExpr=base().createExpr(expr);
    soot.jimple.AssignStmt preStmt=soot.jimple.Jimple.v().newAssignStmt(retLocal,sootExpr);
    body.getUnits().add(preStmt);
    soot.jimple.AddExpr addExpr=soot.jimple.Jimple.v().newAddExpr(sootExpr,getConstant(retLocal.getType(),1));
    Util.addLnPosTags(addExpr.getOp1Box(),expr.position());
    soot.Local local=generateLocal(expr.type());
    soot.jimple.AssignStmt stmt=soot.jimple.Jimple.v().newAssignStmt(local,addExpr);
    body.getUnits().add(stmt);
    Util.addLnPosTags(stmt,expr.position());
    soot.jimple.AssignStmt aStmt=soot.jimple.Jimple.v().newAssignStmt(sootExpr,local);
    body.getUnits().add(aStmt);
    Util.addLnPosTags(aStmt,expr.position());
    Util.addLnPosTags(aStmt,unary.position());
    if ((expr instanceof polyglot.ast.Field) || (expr instanceof polyglot.ast.ArrayAccess)) {
      if (base().needsAccessor(expr)) {
        handlePrivateFieldSet(expr,local);
      }
 else {
        soot.Value actualUnaryExpr=createLHS(expr);
        soot.jimple.AssignStmt s=soot.jimple.Jimple.v().newAssignStmt(actualUnaryExpr,local);
        body.getUnits().add(s);
        Util.addLnPosTags(s,expr.position());
        Util.addLnPosTags(s.getLeftOpBox(),expr.position());
      }
    }
    return retLocal;
  }
 else   if (op == polyglot.ast.Unary.POST_DEC) {
    soot.Local retLocal=generateLocal(expr.type());
    soot.Value sootExpr=base().createExpr(expr);
    soot.jimple.AssignStmt preStmt=soot.jimple.Jimple.v().newAssignStmt(retLocal,sootExpr);
    body.getUnits().add(preStmt);
    soot.jimple.SubExpr subExpr=soot.jimple.Jimple.v().newSubExpr(sootExpr,getConstant(retLocal.getType(),1));
    Util.addLnPosTags(subExpr.getOp1Box(),expr.position());
    soot.Local local=generateLocal(expr.type());
    soot.jimple.AssignStmt stmt=soot.jimple.Jimple.v().newAssignStmt(local,subExpr);
    body.getUnits().add(stmt);
    Util.addLnPosTags(stmt,expr.position());
    soot.jimple.AssignStmt aStmt=soot.jimple.Jimple.v().newAssignStmt(sootExpr,local);
    body.getUnits().add(aStmt);
    Util.addLnPosTags(aStmt,expr.position());
    Util.addLnPosTags(aStmt,unary.position());
    if ((expr instanceof polyglot.ast.Field) || (expr instanceof polyglot.ast.ArrayAccess)) {
      if (base().needsAccessor(expr)) {
        handlePrivateFieldSet(expr,local);
      }
 else {
        soot.Value actualUnaryExpr=createLHS(expr);
        soot.jimple.AssignStmt s=soot.jimple.Jimple.v().newAssignStmt(actualUnaryExpr,local);
        body.getUnits().add(s);
        Util.addLnPosTags(s,expr.position());
        Util.addLnPosTags(s.getLeftOpBox(),expr.position());
      }
    }
    return retLocal;
  }
 else   if (op == polyglot.ast.Unary.PRE_INC) {
    soot.Value sootExpr=base().createExpr(expr);
    soot.jimple.AddExpr addExpr=soot.jimple.Jimple.v().newAddExpr(sootExpr,getConstant(sootExpr.getType(),1));
    Util.addLnPosTags(addExpr.getOp1Box(),expr.position());
    soot.Local local=generateLocal(expr.type());
    soot.jimple.AssignStmt stmt=soot.jimple.Jimple.v().newAssignStmt(local,addExpr);
    body.getUnits().add(stmt);
    Util.addLnPosTags(stmt,expr.position());
    if ((expr instanceof polyglot.ast.Field) || (expr instanceof polyglot.ast.ArrayAccess) || (expr instanceof polyglot.ast.Local)) {
      if (base().needsAccessor(expr)) {
        handlePrivateFieldSet(expr,local);
      }
 else {
        soot.Value actualUnaryExpr=createLHS(expr);
        body.getUnits().add(soot.jimple.Jimple.v().newAssignStmt(actualUnaryExpr,local));
      }
    }
    return local;
  }
 else   if (op == polyglot.ast.Unary.PRE_DEC) {
    soot.Value sootExpr=base().createExpr(expr);
    soot.jimple.SubExpr subExpr=soot.jimple.Jimple.v().newSubExpr(sootExpr,getConstant(sootExpr.getType(),1));
    Util.addLnPosTags(subExpr.getOp1Box(),expr.position());
    soot.Local local=generateLocal(expr.type());
    soot.jimple.AssignStmt stmt=soot.jimple.Jimple.v().newAssignStmt(local,subExpr);
    body.getUnits().add(stmt);
    Util.addLnPosTags(stmt,expr.position());
    if ((expr instanceof polyglot.ast.Field) || (expr instanceof polyglot.ast.ArrayAccess) || (expr instanceof polyglot.ast.Local)) {
      if (base().needsAccessor(expr)) {
        handlePrivateFieldSet(expr,local);
      }
 else {
        soot.Value actualUnaryExpr=createLHS(expr);
        body.getUnits().add(soot.jimple.Jimple.v().newAssignStmt(actualUnaryExpr,local));
      }
    }
    return local;
  }
 else   if (op == polyglot.ast.Unary.BIT_NOT) {
    soot.jimple.IntConstant int1=soot.jimple.IntConstant.v(-1);
    soot.Local retLocal=generateLocal(expr.type());
    soot.Value sootExpr=base().createExpr(expr);
    soot.jimple.XorExpr xor=soot.jimple.Jimple.v().newXorExpr(sootExpr,getConstant(sootExpr.getType(),-1));
    Util.addLnPosTags(xor.getOp1Box(),expr.position());
    soot.jimple.Stmt assign1=soot.jimple.Jimple.v().newAssignStmt(retLocal,xor);
    body.getUnits().add(assign1);
    Util.addLnPosTags(assign1,unary.position());
    return retLocal;
  }
 else   if (op == polyglot.ast.Unary.NEG) {
    soot.Value sootExpr;
    if (expr instanceof polyglot.ast.NumLit) {
      int intVal=(int)((polyglot.ast.NumLit)expr).longValue();
      sootExpr=soot.jimple.IntConstant.v(-intVal);
    }
 else     if (expr instanceof polyglot.ast.FloatLit) {
      double doubleVal=((polyglot.ast.FloatLit)expr).value();
      if (((polyglot.ast.FloatLit)expr).kind() == polyglot.ast.FloatLit.DOUBLE) {
        sootExpr=soot.jimple.DoubleConstant.v(-doubleVal);
      }
 else {
        sootExpr=soot.jimple.FloatConstant.v(-(float)doubleVal);
      }
    }
 else {
      soot.Value local=base().createExpr(expr);
      soot.jimple.NegExpr negExpr=soot.jimple.Jimple.v().newNegExpr(local);
      sootExpr=negExpr;
      Util.addLnPosTags(negExpr.getOpBox(),expr.position());
    }
    soot.Local retLocal=generateLocal(expr.type());
    soot.jimple.Stmt assign=soot.jimple.Jimple.v().newAssignStmt(retLocal,sootExpr);
    body.getUnits().add(assign);
    Util.addLnPosTags(assign,expr.position());
    return retLocal;
  }
 else   if (op == polyglot.ast.Unary.POS) {
    soot.Local retLocal=generateLocal(expr.type());
    soot.Value sootExpr=base().createExpr(expr);
    soot.jimple.Stmt assign=soot.jimple.Jimple.v().newAssignStmt(retLocal,sootExpr);
    body.getUnits().add(assign);
    Util.addLnPosTags(assign,expr.position());
    return retLocal;
  }
 else   if (op == polyglot.ast.Unary.NOT) {
    soot.Value local=base().createExpr(expr);
    if (local instanceof soot.jimple.ConditionExpr) {
      local=handleCondBinExpr((soot.jimple.ConditionExpr)local);
    }
    soot.jimple.NeExpr neExpr=soot.jimple.Jimple.v().newNeExpr(local,getConstant(local.getType(),0));
    soot.jimple.Stmt noop1=soot.jimple.Jimple.v().newNopStmt();
    soot.jimple.Stmt ifStmt=soot.jimple.Jimple.v().newIfStmt(neExpr,noop1);
    body.getUnits().add(ifStmt);
    Util.addLnPosTags(ifStmt,expr.position());
    soot.Local retLocal=lg.generateLocal(local.getType());
    soot.jimple.Stmt assign1=soot.jimple.Jimple.v().newAssignStmt(retLocal,getConstant(retLocal.getType(),1));
    body.getUnits().add(assign1);
    Util.addLnPosTags(assign1,expr.position());
    soot.jimple.Stmt noop2=soot.jimple.Jimple.v().newNopStmt();
    soot.jimple.Stmt goto1=soot.jimple.Jimple.v().newGotoStmt(noop2);
    body.getUnits().add(goto1);
    body.getUnits().add(noop1);
    soot.jimple.Stmt assign2=soot.jimple.Jimple.v().newAssignStmt(retLocal,getConstant(retLocal.getType(),0));
    body.getUnits().add(assign2);
    Util.addLnPosTags(assign2,expr.position());
    body.getUnits().add(noop2);
    return retLocal;
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
}","/** 
 * Unary Expression Creation
 */
private soot.Local getUnaryLocal(polyglot.ast.Unary unary){
  polyglot.ast.Expr expr=unary.expr();
  polyglot.ast.Unary.Operator op=unary.operator();
  if (op == polyglot.ast.Unary.POST_INC || op == polyglot.ast.Unary.PRE_INC || op == polyglot.ast.Unary.POST_DEC || op == polyglot.ast.Unary.PRE_DEC) {
    soot.Value left=createLHS(unary.expr());
    soot.Local tmp=lg.generateLocal(left.getType());
    soot.jimple.AssignStmt stmt1=soot.jimple.Jimple.v().newAssignStmt(tmp,left);
    body.getUnits().add(stmt1);
    Util.addLnPosTags(stmt1,unary.position());
    soot.Value incVal=getConstant(left.getType(),1);
    soot.jimple.BinopExpr binExpr;
    if (unary.operator() == polyglot.ast.Unary.PRE_INC || unary.operator() == polyglot.ast.Unary.POST_INC) {
      binExpr=soot.jimple.Jimple.v().newAddExpr(tmp,incVal);
    }
 else {
      binExpr=soot.jimple.Jimple.v().newSubExpr(tmp,incVal);
    }
    soot.Local tmp2=lg.generateLocal(left.getType());
    soot.jimple.AssignStmt assign=soot.jimple.Jimple.v().newAssignStmt(tmp2,binExpr);
    body.getUnits().add(assign);
    if (needsAccessor(unary.expr())) {
      System.out.println(""String_Node_Str"");
      handlePrivateFieldSet(unary.expr(),tmp2);
    }
 else {
      soot.jimple.AssignStmt stmt3=soot.jimple.Jimple.v().newAssignStmt(left,tmp2);
      body.getUnits().add(stmt3);
    }
    if (unary.operator() == polyglot.ast.Unary.POST_DEC || unary.operator() == polyglot.ast.Unary.POST_INC) {
      return tmp;
    }
 else {
      return tmp2;
    }
  }
 else   if (op == polyglot.ast.Unary.BIT_NOT) {
    soot.jimple.IntConstant int1=soot.jimple.IntConstant.v(-1);
    soot.Local retLocal=generateLocal(expr.type());
    soot.Value sootExpr=base().createExpr(expr);
    soot.jimple.XorExpr xor=soot.jimple.Jimple.v().newXorExpr(sootExpr,getConstant(sootExpr.getType(),-1));
    Util.addLnPosTags(xor.getOp1Box(),expr.position());
    soot.jimple.Stmt assign1=soot.jimple.Jimple.v().newAssignStmt(retLocal,xor);
    body.getUnits().add(assign1);
    Util.addLnPosTags(assign1,unary.position());
    return retLocal;
  }
 else   if (op == polyglot.ast.Unary.NEG) {
    soot.Value sootExpr;
    if (expr instanceof polyglot.ast.NumLit) {
      int intVal=(int)((polyglot.ast.NumLit)expr).longValue();
      sootExpr=soot.jimple.IntConstant.v(-intVal);
    }
 else     if (expr instanceof polyglot.ast.FloatLit) {
      double doubleVal=((polyglot.ast.FloatLit)expr).value();
      if (((polyglot.ast.FloatLit)expr).kind() == polyglot.ast.FloatLit.DOUBLE) {
        sootExpr=soot.jimple.DoubleConstant.v(-doubleVal);
      }
 else {
        sootExpr=soot.jimple.FloatConstant.v(-(float)doubleVal);
      }
    }
 else {
      soot.Value local=base().createExpr(expr);
      soot.jimple.NegExpr negExpr=soot.jimple.Jimple.v().newNegExpr(local);
      sootExpr=negExpr;
      Util.addLnPosTags(negExpr.getOpBox(),expr.position());
    }
    soot.Local retLocal=generateLocal(expr.type());
    soot.jimple.Stmt assign=soot.jimple.Jimple.v().newAssignStmt(retLocal,sootExpr);
    body.getUnits().add(assign);
    Util.addLnPosTags(assign,expr.position());
    return retLocal;
  }
 else   if (op == polyglot.ast.Unary.POS) {
    soot.Local retLocal=generateLocal(expr.type());
    soot.Value sootExpr=base().createExpr(expr);
    soot.jimple.Stmt assign=soot.jimple.Jimple.v().newAssignStmt(retLocal,sootExpr);
    body.getUnits().add(assign);
    Util.addLnPosTags(assign,expr.position());
    return retLocal;
  }
 else   if (op == polyglot.ast.Unary.NOT) {
    soot.Value local=base().createExpr(expr);
    if (local instanceof soot.jimple.ConditionExpr) {
      local=handleCondBinExpr((soot.jimple.ConditionExpr)local);
    }
    soot.jimple.NeExpr neExpr=soot.jimple.Jimple.v().newNeExpr(local,getConstant(local.getType(),0));
    soot.jimple.Stmt noop1=soot.jimple.Jimple.v().newNopStmt();
    soot.jimple.Stmt ifStmt=soot.jimple.Jimple.v().newIfStmt(neExpr,noop1);
    body.getUnits().add(ifStmt);
    Util.addLnPosTags(ifStmt,expr.position());
    soot.Local retLocal=lg.generateLocal(local.getType());
    soot.jimple.Stmt assign1=soot.jimple.Jimple.v().newAssignStmt(retLocal,getConstant(retLocal.getType(),1));
    body.getUnits().add(assign1);
    Util.addLnPosTags(assign1,expr.position());
    soot.jimple.Stmt noop2=soot.jimple.Jimple.v().newNopStmt();
    soot.jimple.Stmt goto1=soot.jimple.Jimple.v().newGotoStmt(noop2);
    body.getUnits().add(goto1);
    body.getUnits().add(noop1);
    soot.jimple.Stmt assign2=soot.jimple.Jimple.v().newAssignStmt(retLocal,getConstant(retLocal.getType(),0));
    body.getUnits().add(assign2);
    Util.addLnPosTags(assign2,expr.position());
    body.getUnits().add(noop2);
    return retLocal;
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
}"
88575,"void emitInst(Inst inst){
  inst.apply(new InstSwitch(){
    public void caseReturnVoidInst(    ReturnVoidInst i){
      emit(""String_Node_Str"");
    }
    public void caseReturnInst(    ReturnInst i){
      i.getOpType().apply(new TypeSwitch(){
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"" + t.toString());
        }
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"");
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"");
        }
        public void caseIntType(        IntType t){
          emit(""String_Node_Str"");
        }
        public void caseByteType(        ByteType t){
          emit(""String_Node_Str"");
        }
        public void caseShortType(        ShortType t){
          emit(""String_Node_Str"");
        }
        public void caseCharType(        CharType t){
          emit(""String_Node_Str"");
        }
        public void caseBooleanType(        BooleanType t){
          emit(""String_Node_Str"");
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"");
        }
        public void caseArrayType(        ArrayType t){
          emit(""String_Node_Str"");
        }
        public void caseRefType(        RefType t){
          emit(""String_Node_Str"");
        }
        public void caseNullType(        NullType t){
          emit(""String_Node_Str"");
        }
      }
);
    }
    public void caseNopInst(    NopInst i){
      emit(""String_Node_Str"");
    }
    public void caseEnterMonitorInst(    EnterMonitorInst i){
      emit(""String_Node_Str"");
    }
    public void casePopInst(    PopInst i){
      if (i.getWordCount() == 2) {
        emit(""String_Node_Str"");
      }
 else       emit(""String_Node_Str"");
    }
    public void caseExitMonitorInst(    ExitMonitorInst i){
      emit(""String_Node_Str"");
    }
    public void caseGotoInst(    GotoInst i){
      emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
    }
    public void casePushInst(    PushInst i){
      if (i.getConstant() instanceof IntConstant) {
        IntConstant v=(IntConstant)(i.getConstant());
        if (v.value == -1)         emit(""String_Node_Str"");
 else         if (v.value >= 0 && v.value <= 5)         emit(""String_Node_Str"" + v.value);
 else         if (v.value >= Byte.MIN_VALUE && v.value <= Byte.MAX_VALUE)         emit(""String_Node_Str"" + v.value);
 else         if (v.value >= Short.MIN_VALUE && v.value <= Short.MAX_VALUE)         emit(""String_Node_Str"" + v.value);
 else         emit(""String_Node_Str"" + v.toString());
      }
 else       if (i.getConstant() instanceof StringConstant) {
        emit(""String_Node_Str"" + i.getConstant().toString());
      }
 else       if (i.getConstant() instanceof DoubleConstant) {
        DoubleConstant v=(DoubleConstant)(i.getConstant());
        if ((v.value == 0) && ((1.0 / v.value) > 0.0))         emit(""String_Node_Str"");
 else         if (v.value == 1)         emit(""String_Node_Str"");
 else {
          String s=v.toString();
          if (s.equals(""String_Node_Str""))           s=""String_Node_Str"";
          if (s.equals(""String_Node_Str""))           s=""String_Node_Str"";
          if (s.equals(""String_Node_Str""))           s=""String_Node_Str"";
          emit(""String_Node_Str"" + s);
        }
      }
 else       if (i.getConstant() instanceof FloatConstant) {
        FloatConstant v=(FloatConstant)(i.getConstant());
        if ((v.value == 0) && ((1.0f / v.value) > 1.0f))         emit(""String_Node_Str"");
 else         if (v.value == 1)         emit(""String_Node_Str"");
 else         if (v.value == 2)         emit(""String_Node_Str"");
 else {
          String s=v.toString();
          if (s.equals(""String_Node_Str""))           s=""String_Node_Str"";
          if (s.equals(""String_Node_Str""))           s=""String_Node_Str"";
          if (s.equals(""String_Node_Str""))           s=""String_Node_Str"";
          emit(""String_Node_Str"" + s);
        }
      }
 else       if (i.getConstant() instanceof LongConstant) {
        LongConstant v=(LongConstant)(i.getConstant());
        if (v.value == 0)         emit(""String_Node_Str"");
 else         if (v.value == 1)         emit(""String_Node_Str"");
 else         emit(""String_Node_Str"" + v.toString());
      }
 else       if (i.getConstant() instanceof NullConstant)       emit(""String_Node_Str"");
 else       throw new RuntimeException(""String_Node_Str"");
    }
    public void caseIdentityInst(    IdentityInst i){
      if (i.getRightOp() instanceof CaughtExceptionRef && i.getLeftOp() instanceof Local) {
        int slot=((Integer)localToSlot.get(i.getLeftOp())).intValue();
        if (slot >= 0 && slot <= 3)         emit(""String_Node_Str"" + slot);
 else         emit(""String_Node_Str"" + slot);
      }
    }
    public void caseStoreInst(    StoreInst i){
      final int slot=((Integer)localToSlot.get(i.getLocal())).intValue();
      i.getOpType().apply(new TypeSwitch(){
        public void caseArrayType(        ArrayType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseDoubleType(        DoubleType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseFloatType(        FloatType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseIntType(        IntType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseByteType(        ByteType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseShortType(        ShortType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseCharType(        CharType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseBooleanType(        BooleanType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseLongType(        LongType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseRefType(        RefType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseStmtAddressType(        StmtAddressType t){
          isNextGotoAJsr=true;
          returnAddressSlot=slot;
        }
        public void caseNullType(        NullType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"" + t);
        }
      }
);
    }
    public void caseLoadInst(    LoadInst i){
      final int slot=((Integer)localToSlot.get(i.getLocal())).intValue();
      i.getOpType().apply(new TypeSwitch(){
        public void caseArrayType(        ArrayType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"" + t);
        }
        public void caseDoubleType(        DoubleType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseFloatType(        FloatType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseIntType(        IntType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseByteType(        ByteType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseShortType(        ShortType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseCharType(        CharType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseBooleanType(        BooleanType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseLongType(        LongType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseRefType(        RefType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseNullType(        NullType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
      }
);
    }
    public void caseArrayWriteInst(    ArrayWriteInst i){
      i.getOpType().apply(new TypeSwitch(){
        public void caseArrayType(        ArrayType t){
          emit(""String_Node_Str"");
        }
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"");
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"");
        }
        public void caseIntType(        IntType t){
          emit(""String_Node_Str"");
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"");
        }
        public void caseRefType(        RefType t){
          emit(""String_Node_Str"");
        }
        public void caseByteType(        ByteType t){
          emit(""String_Node_Str"");
        }
        public void caseBooleanType(        BooleanType t){
          emit(""String_Node_Str"");
        }
        public void caseCharType(        CharType t){
          emit(""String_Node_Str"");
        }
        public void caseShortType(        ShortType t){
          emit(""String_Node_Str"");
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"" + t);
        }
      }
);
    }
    public void caseArrayReadInst(    ArrayReadInst i){
      i.getOpType().apply(new TypeSwitch(){
        public void caseArrayType(        ArrayType ty){
          emit(""String_Node_Str"");
        }
        public void caseBooleanType(        BooleanType ty){
          emit(""String_Node_Str"");
        }
        public void caseByteType(        ByteType ty){
          emit(""String_Node_Str"");
        }
        public void caseCharType(        CharType ty){
          emit(""String_Node_Str"");
        }
        public void defaultCase(        Type ty){
          throw new RuntimeException(""String_Node_Str"");
        }
        public void caseDoubleType(        DoubleType ty){
          emit(""String_Node_Str"");
        }
        public void caseFloatType(        FloatType ty){
          emit(""String_Node_Str"");
        }
        public void caseIntType(        IntType ty){
          emit(""String_Node_Str"");
        }
        public void caseLongType(        LongType ty){
          emit(""String_Node_Str"");
        }
        public void caseNullType(        NullType ty){
          emit(""String_Node_Str"");
        }
        public void caseRefType(        RefType ty){
          emit(""String_Node_Str"");
        }
        public void caseShortType(        ShortType ty){
          emit(""String_Node_Str"");
        }
      }
);
    }
    public void caseIfNullInst(    IfNullInst i){
      emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
    }
    public void caseIfNonNullInst(    IfNonNullInst i){
      emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
    }
    public void caseIfEqInst(    IfEqInst i){
      emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
    }
    public void caseIfNeInst(    IfNeInst i){
      emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
    }
    public void caseIfGtInst(    IfGtInst i){
      emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
    }
    public void caseIfGeInst(    IfGeInst i){
      emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
    }
    public void caseIfLtInst(    IfLtInst i){
      emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
    }
    public void caseIfLeInst(    IfLeInst i){
      emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
    }
    public void caseIfCmpEqInst(    final IfCmpEqInst i){
      i.getOpType().apply(new TypeSwitch(){
        public void caseIntType(        IntType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseBooleanType(        BooleanType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseShortType(        ShortType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseCharType(        CharType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseByteType(        ByteType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseArrayType(        ArrayType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseRefType(        RefType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseNullType(        NullType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseIfCmpNeInst(    final IfCmpNeInst i){
      i.getOpType().apply(new TypeSwitch(){
        public void caseIntType(        IntType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseBooleanType(        BooleanType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseShortType(        ShortType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseCharType(        CharType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseByteType(        ByteType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseArrayType(        ArrayType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseRefType(        RefType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseNullType(        NullType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseIfCmpGtInst(    final IfCmpGtInst i){
      i.getOpType().apply(new TypeSwitch(){
        public void caseIntType(        IntType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseBooleanType(        BooleanType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseShortType(        ShortType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseCharType(        CharType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseByteType(        ByteType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseArrayType(        ArrayType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseRefType(        RefType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseNullType(        NullType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseIfCmpGeInst(    final IfCmpGeInst i){
      i.getOpType().apply(new TypeSwitch(){
        public void caseIntType(        IntType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseBooleanType(        BooleanType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseShortType(        ShortType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseCharType(        CharType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseByteType(        ByteType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseArrayType(        ArrayType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseRefType(        RefType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseNullType(        NullType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseIfCmpLtInst(    final IfCmpLtInst i){
      i.getOpType().apply(new TypeSwitch(){
        public void caseIntType(        IntType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseBooleanType(        BooleanType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseShortType(        ShortType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseCharType(        CharType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseByteType(        ByteType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseArrayType(        ArrayType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseRefType(        RefType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseNullType(        NullType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseIfCmpLeInst(    final IfCmpLeInst i){
      i.getOpType().apply(new TypeSwitch(){
        public void caseIntType(        IntType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseBooleanType(        BooleanType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseShortType(        ShortType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseCharType(        CharType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseByteType(        ByteType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseArrayType(        ArrayType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseRefType(        RefType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseNullType(        NullType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseStaticGetInst(    StaticGetInst i){
      SootField field=i.getField();
      emit(""String_Node_Str"" + slashify(field.getDeclaringClass().getName()) + ""String_Node_Str""+ field.getName()+ ""String_Node_Str""+ jasminDescriptorOf(field.getType()));
    }
    public void caseStaticPutInst(    StaticPutInst i){
      emit(""String_Node_Str"" + slashify(i.getField().getDeclaringClass().getName()) + ""String_Node_Str""+ i.getField().getName()+ ""String_Node_Str""+ jasminDescriptorOf(i.getField().getType()));
    }
    public void caseFieldGetInst(    FieldGetInst i){
      emit(""String_Node_Str"" + slashify(i.getField().getDeclaringClass().getName()) + ""String_Node_Str""+ i.getField().getName()+ ""String_Node_Str""+ jasminDescriptorOf(i.getField().getType()));
    }
    public void caseFieldPutInst(    FieldPutInst i){
      emit(""String_Node_Str"" + slashify(i.getField().getDeclaringClass().getName()) + ""String_Node_Str""+ i.getField().getName()+ ""String_Node_Str""+ jasminDescriptorOf(i.getField().getType()));
    }
    public void caseInstanceCastInst(    InstanceCastInst i){
      Type castType=i.getCastType();
      if (castType instanceof RefType)       emit(""String_Node_Str"" + slashify(castType.toString()));
 else       if (castType instanceof ArrayType)       emit(""String_Node_Str"" + jasminDescriptorOf(castType));
    }
    public void caseInstanceOfInst(    InstanceOfInst i){
      Type checkType=i.getCheckType();
      if (checkType instanceof RefType)       emit(""String_Node_Str"" + slashify(checkType.toString()));
 else       if (checkType instanceof ArrayType)       emit(""String_Node_Str"" + jasminDescriptorOf(checkType));
    }
    public void caseNewInst(    NewInst i){
      emit(""String_Node_Str"" + slashify(i.getBaseType().toString()));
    }
    public void casePrimitiveCastInst(    PrimitiveCastInst i){
      emit(i.toString());
    }
    public void caseStaticInvokeInst(    StaticInvokeInst i){
      SootMethodRef m=i.getMethodRef();
      emit(""String_Node_Str"" + slashify(m.declaringClass().getName()) + ""String_Node_Str""+ m.name()+ jasminDescriptorOf(m));
    }
    public void caseVirtualInvokeInst(    VirtualInvokeInst i){
      SootMethodRef m=i.getMethodRef();
      emit(""String_Node_Str"" + slashify(m.declaringClass().getName()) + ""String_Node_Str""+ m.name()+ jasminDescriptorOf(m));
    }
    public void caseInterfaceInvokeInst(    InterfaceInvokeInst i){
      SootMethodRef m=i.getMethodRef();
      emit(""String_Node_Str"" + slashify(m.declaringClass().getName()) + ""String_Node_Str""+ m.name()+ jasminDescriptorOf(m)+ ""String_Node_Str""+ (argCountOf(m) + 1));
    }
    public void caseSpecialInvokeInst(    SpecialInvokeInst i){
      SootMethodRef m=i.getMethodRef();
      emit(""String_Node_Str"" + slashify(m.declaringClass().getName()) + ""String_Node_Str""+ m.name()+ jasminDescriptorOf(m));
    }
    public void caseThrowInst(    ThrowInst i){
      emit(""String_Node_Str"");
    }
    public void caseCmpInst(    CmpInst i){
      emit(""String_Node_Str"");
    }
    public void caseCmplInst(    CmplInst i){
      if (i.getOpType().equals(FloatType.v()))       emit(""String_Node_Str"");
 else       emit(""String_Node_Str"");
    }
    public void caseCmpgInst(    CmpgInst i){
      if (i.getOpType().equals(FloatType.v()))       emit(""String_Node_Str"");
 else       emit(""String_Node_Str"");
    }
    private void emitOpTypeInst(    final String s,    final OpTypeArgInst i){
      i.getOpType().apply(new TypeSwitch(){
        private void handleIntCase(){
          emit(""String_Node_Str"" + s);
        }
        public void caseIntType(        IntType t){
          handleIntCase();
        }
        public void caseBooleanType(        BooleanType t){
          handleIntCase();
        }
        public void caseShortType(        ShortType t){
          handleIntCase();
        }
        public void caseCharType(        CharType t){
          handleIntCase();
        }
        public void caseByteType(        ByteType t){
          handleIntCase();
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"" + s);
        }
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"" + s);
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"" + s);
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseAddInst(    AddInst i){
      emitOpTypeInst(""String_Node_Str"",i);
    }
    public void caseDivInst(    DivInst i){
      emitOpTypeInst(""String_Node_Str"",i);
    }
    public void caseSubInst(    SubInst i){
      emitOpTypeInst(""String_Node_Str"",i);
    }
    public void caseMulInst(    MulInst i){
      emitOpTypeInst(""String_Node_Str"",i);
    }
    public void caseRemInst(    RemInst i){
      emitOpTypeInst(""String_Node_Str"",i);
    }
    public void caseShlInst(    ShlInst i){
      emitOpTypeInst(""String_Node_Str"",i);
    }
    public void caseAndInst(    AndInst i){
      emitOpTypeInst(""String_Node_Str"",i);
    }
    public void caseOrInst(    OrInst i){
      emitOpTypeInst(""String_Node_Str"",i);
    }
    public void caseXorInst(    XorInst i){
      emitOpTypeInst(""String_Node_Str"",i);
    }
    public void caseShrInst(    ShrInst i){
      emitOpTypeInst(""String_Node_Str"",i);
    }
    public void caseUshrInst(    UshrInst i){
      emitOpTypeInst(""String_Node_Str"",i);
    }
    public void caseIncInst(    IncInst i){
      if (((ValueBox)i.getUseBoxes().get(0)).getValue() != ((ValueBox)i.getDefBoxes().get(0)).getValue())       throw new RuntimeException(""String_Node_Str"");
      emit(""String_Node_Str"" + ((Integer)localToSlot.get(i.getLocal())) + ""String_Node_Str""+ i.getConstant());
    }
    public void caseArrayLengthInst(    ArrayLengthInst i){
      emit(""String_Node_Str"");
    }
    public void caseNegInst(    NegInst i){
      emitOpTypeInst(""String_Node_Str"",i);
    }
    public void caseNewArrayInst(    NewArrayInst i){
      if (i.getBaseType() instanceof RefType)       emit(""String_Node_Str"" + slashify(i.getBaseType().toString()));
 else       if (i.getBaseType() instanceof ArrayType)       emit(""String_Node_Str"" + jasminDescriptorOf(i.getBaseType()));
 else       emit(""String_Node_Str"" + i.getBaseType().toString());
    }
    public void caseNewMultiArrayInst(    NewMultiArrayInst i){
      emit(""String_Node_Str"" + jasminDescriptorOf(i.getBaseType()) + ""String_Node_Str""+ i.getDimensionCount());
    }
    public void caseLookupSwitchInst(    LookupSwitchInst i){
      emit(""String_Node_Str"");
      List lookupValues=i.getLookupValues();
      List targets=i.getTargets();
      for (int j=0; j < lookupValues.size(); j++)       emit(""String_Node_Str"" + lookupValues.get(j) + ""String_Node_Str""+ unitToLabel.get(targets.get(j)));
      emit(""String_Node_Str"" + unitToLabel.get(i.getDefaultTarget()));
    }
    public void caseTableSwitchInst(    TableSwitchInst i){
      emit(""String_Node_Str"" + i.getLowIndex() + ""String_Node_Str""+ i.getHighIndex());
      List targets=i.getTargets();
      for (int j=0; j < targets.size(); j++)       emit(""String_Node_Str"" + unitToLabel.get(targets.get(j)));
      emit(""String_Node_Str"" + unitToLabel.get(i.getDefaultTarget()));
    }
    private boolean isDwordType(    Type t){
      return t instanceof LongType || t instanceof DoubleType || t instanceof DoubleWordType;
    }
    public void caseDup1Inst(    Dup1Inst i){
      Type firstOpType=i.getOp1Type();
      if (isDwordType(firstOpType))       emit(""String_Node_Str"");
 else       emit(""String_Node_Str"");
    }
    public void caseDup2Inst(    Dup2Inst i){
      Type firstOpType=i.getOp1Type();
      Type secondOpType=i.getOp2Type();
      if (isDwordType(firstOpType)) {
        emit(""String_Node_Str"");
        if (isDwordType(secondOpType)) {
          emit(""String_Node_Str"");
        }
 else         emit(""String_Node_Str"");
      }
 else       if (isDwordType(secondOpType)) {
        if (isDwordType(firstOpType)) {
          emit(""String_Node_Str"");
        }
 else         emit(""String_Node_Str"");
        emit(""String_Node_Str"");
      }
 else {
        G.v().out.println(""String_Node_Str"");
        emit(""String_Node_Str"");
      }
    }
    public void caseDup1_x1Inst(    Dup1_x1Inst i){
      Type opType=i.getOp1Type();
      Type underType=i.getUnder1Type();
      if (isDwordType(opType)) {
        if (isDwordType(underType)) {
          emit(""String_Node_Str"");
        }
 else         emit(""String_Node_Str"");
      }
 else {
        if (isDwordType(underType))         emit(""String_Node_Str"");
 else         emit(""String_Node_Str"");
      }
    }
    public void caseDup1_x2Inst(    Dup1_x2Inst i){
      Type opType=i.getOp1Type();
      Type under1Type=i.getUnder1Type();
      Type under2Type=i.getUnder2Type();
      if (isDwordType(opType)) {
        if (!isDwordType(under1Type) && !isDwordType(under2Type))         emit(""String_Node_Str"");
 else         throw new RuntimeException(""String_Node_Str"");
      }
 else {
        if (isDwordType(under1Type) || isDwordType(under2Type))         throw new RuntimeException(""String_Node_Str"");
      }
      emit(""String_Node_Str"");
    }
    public void caseDup2_x1Inst(    Dup2_x1Inst i){
      Type op1Type=i.getOp1Type();
      Type op2Type=i.getOp2Type();
      Type under1Type=i.getUnder1Type();
      if (isDwordType(under1Type)) {
        if (!isDwordType(op1Type) && !isDwordType(op2Type))         throw new RuntimeException(""String_Node_Str"");
 else         emit(""String_Node_Str"");
      }
 else {
        if (isDwordType(op1Type) || isDwordType(op2Type))         throw new RuntimeException(""String_Node_Str"");
      }
      emit(""String_Node_Str"");
    }
    public void caseDup2_x2Inst(    Dup2_x2Inst i){
      Type op1Type=i.getOp1Type();
      Type op2Type=i.getOp2Type();
      Type under1Type=i.getUnder1Type();
      Type under2Type=i.getUnder2Type();
      if (isDwordType(op1Type) || isDwordType(op2Type) || isDwordType(under1Type)|| isDwordType(under1Type))       throw new RuntimeException(""String_Node_Str"");
      emit(""String_Node_Str"");
    }
    public void caseSwapInst(    SwapInst i){
      emit(""String_Node_Str"");
    }
  }
);
}","void emitInst(Inst inst){
  inst.apply(new InstSwitch(){
    public void caseReturnVoidInst(    ReturnVoidInst i){
      emit(""String_Node_Str"");
    }
    public void caseReturnInst(    ReturnInst i){
      i.getOpType().apply(new TypeSwitch(){
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"" + t.toString());
        }
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"");
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"");
        }
        public void caseIntType(        IntType t){
          emit(""String_Node_Str"");
        }
        public void caseByteType(        ByteType t){
          emit(""String_Node_Str"");
        }
        public void caseShortType(        ShortType t){
          emit(""String_Node_Str"");
        }
        public void caseCharType(        CharType t){
          emit(""String_Node_Str"");
        }
        public void caseBooleanType(        BooleanType t){
          emit(""String_Node_Str"");
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"");
        }
        public void caseArrayType(        ArrayType t){
          emit(""String_Node_Str"");
        }
        public void caseRefType(        RefType t){
          emit(""String_Node_Str"");
        }
        public void caseNullType(        NullType t){
          emit(""String_Node_Str"");
        }
      }
);
    }
    public void caseNopInst(    NopInst i){
      emit(""String_Node_Str"");
    }
    public void caseEnterMonitorInst(    EnterMonitorInst i){
      emit(""String_Node_Str"");
    }
    public void casePopInst(    PopInst i){
      if (i.getWordCount() == 2) {
        emit(""String_Node_Str"");
      }
 else       emit(""String_Node_Str"");
    }
    public void caseExitMonitorInst(    ExitMonitorInst i){
      emit(""String_Node_Str"");
    }
    public void caseGotoInst(    GotoInst i){
      emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
    }
    public void casePushInst(    PushInst i){
      if (i.getConstant() instanceof IntConstant) {
        IntConstant v=(IntConstant)(i.getConstant());
        if (v.value == -1)         emit(""String_Node_Str"");
 else         if (v.value >= 0 && v.value <= 5)         emit(""String_Node_Str"" + v.value);
 else         if (v.value >= Byte.MIN_VALUE && v.value <= Byte.MAX_VALUE)         emit(""String_Node_Str"" + v.value);
 else         if (v.value >= Short.MIN_VALUE && v.value <= Short.MAX_VALUE)         emit(""String_Node_Str"" + v.value);
 else         emit(""String_Node_Str"" + v.toString());
      }
 else       if (i.getConstant() instanceof StringConstant) {
        emit(""String_Node_Str"" + i.getConstant().toString());
      }
 else       if (i.getConstant() instanceof DoubleConstant) {
        DoubleConstant v=(DoubleConstant)(i.getConstant());
        if ((v.value == 0) && ((1.0 / v.value) > 0.0))         emit(""String_Node_Str"");
 else         if (v.value == 1)         emit(""String_Node_Str"");
 else {
          String s=v.toString();
          if (s.equals(""String_Node_Str""))           s=""String_Node_Str"";
          if (s.equals(""String_Node_Str""))           s=""String_Node_Str"";
          if (s.equals(""String_Node_Str""))           s=""String_Node_Str"";
          emit(""String_Node_Str"" + s);
        }
      }
 else       if (i.getConstant() instanceof FloatConstant) {
        FloatConstant v=(FloatConstant)(i.getConstant());
        if ((v.value == 0) && ((1.0f / v.value) > 1.0f))         emit(""String_Node_Str"");
 else         if (v.value == 1)         emit(""String_Node_Str"");
 else         if (v.value == 2)         emit(""String_Node_Str"");
 else {
          String s=v.toString();
          if (s.equals(""String_Node_Str""))           s=""String_Node_Str"";
          if (s.equals(""String_Node_Str""))           s=""String_Node_Str"";
          if (s.equals(""String_Node_Str""))           s=""String_Node_Str"";
          emit(""String_Node_Str"" + s);
        }
      }
 else       if (i.getConstant() instanceof LongConstant) {
        LongConstant v=(LongConstant)(i.getConstant());
        if (v.value == 0)         emit(""String_Node_Str"");
 else         if (v.value == 1)         emit(""String_Node_Str"");
 else         emit(""String_Node_Str"" + v.toString());
      }
 else       if (i.getConstant() instanceof NullConstant)       emit(""String_Node_Str"");
 else       throw new RuntimeException(""String_Node_Str"");
    }
    public void caseIdentityInst(    IdentityInst i){
      if (i.getRightOp() instanceof CaughtExceptionRef && i.getLeftOp() instanceof Local) {
        int slot=((Integer)localToSlot.get(i.getLeftOp())).intValue();
        if (slot >= 0 && slot <= 3)         emit(""String_Node_Str"" + slot);
 else         emit(""String_Node_Str"" + slot);
      }
    }
    public void caseStoreInst(    StoreInst i){
      final int slot=((Integer)localToSlot.get(i.getLocal())).intValue();
      i.getOpType().apply(new TypeSwitch(){
        public void caseArrayType(        ArrayType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseDoubleType(        DoubleType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseFloatType(        FloatType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseIntType(        IntType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseByteType(        ByteType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseShortType(        ShortType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseCharType(        CharType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseBooleanType(        BooleanType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseLongType(        LongType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseRefType(        RefType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseStmtAddressType(        StmtAddressType t){
          isNextGotoAJsr=true;
          returnAddressSlot=slot;
        }
        public void caseNullType(        NullType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"" + t);
        }
      }
);
    }
    public void caseLoadInst(    LoadInst i){
      final int slot=((Integer)localToSlot.get(i.getLocal())).intValue();
      i.getOpType().apply(new TypeSwitch(){
        public void caseArrayType(        ArrayType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"" + t);
        }
        public void caseDoubleType(        DoubleType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseFloatType(        FloatType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseIntType(        IntType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseByteType(        ByteType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseShortType(        ShortType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseCharType(        CharType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseBooleanType(        BooleanType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseLongType(        LongType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseRefType(        RefType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseNullType(        NullType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
      }
);
    }
    public void caseArrayWriteInst(    ArrayWriteInst i){
      i.getOpType().apply(new TypeSwitch(){
        public void caseArrayType(        ArrayType t){
          emit(""String_Node_Str"");
        }
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"");
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"");
        }
        public void caseIntType(        IntType t){
          emit(""String_Node_Str"");
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"");
        }
        public void caseRefType(        RefType t){
          emit(""String_Node_Str"");
        }
        public void caseByteType(        ByteType t){
          emit(""String_Node_Str"");
        }
        public void caseBooleanType(        BooleanType t){
          emit(""String_Node_Str"");
        }
        public void caseCharType(        CharType t){
          emit(""String_Node_Str"");
        }
        public void caseShortType(        ShortType t){
          emit(""String_Node_Str"");
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"" + t);
        }
      }
);
    }
    public void caseArrayReadInst(    ArrayReadInst i){
      i.getOpType().apply(new TypeSwitch(){
        public void caseArrayType(        ArrayType ty){
          emit(""String_Node_Str"");
        }
        public void caseBooleanType(        BooleanType ty){
          emit(""String_Node_Str"");
        }
        public void caseByteType(        ByteType ty){
          emit(""String_Node_Str"");
        }
        public void caseCharType(        CharType ty){
          emit(""String_Node_Str"");
        }
        public void defaultCase(        Type ty){
          throw new RuntimeException(""String_Node_Str"");
        }
        public void caseDoubleType(        DoubleType ty){
          emit(""String_Node_Str"");
        }
        public void caseFloatType(        FloatType ty){
          emit(""String_Node_Str"");
        }
        public void caseIntType(        IntType ty){
          emit(""String_Node_Str"");
        }
        public void caseLongType(        LongType ty){
          emit(""String_Node_Str"");
        }
        public void caseNullType(        NullType ty){
          emit(""String_Node_Str"");
        }
        public void caseRefType(        RefType ty){
          emit(""String_Node_Str"");
        }
        public void caseShortType(        ShortType ty){
          emit(""String_Node_Str"");
        }
      }
);
    }
    public void caseIfNullInst(    IfNullInst i){
      emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
    }
    public void caseIfNonNullInst(    IfNonNullInst i){
      emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
    }
    public void caseIfEqInst(    IfEqInst i){
      emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
    }
    public void caseIfNeInst(    IfNeInst i){
      emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
    }
    public void caseIfGtInst(    IfGtInst i){
      emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
    }
    public void caseIfGeInst(    IfGeInst i){
      emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
    }
    public void caseIfLtInst(    IfLtInst i){
      emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
    }
    public void caseIfLeInst(    IfLeInst i){
      emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
    }
    public void caseIfCmpEqInst(    final IfCmpEqInst i){
      i.getOpType().apply(new TypeSwitch(){
        public void caseIntType(        IntType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseBooleanType(        BooleanType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseShortType(        ShortType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseCharType(        CharType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseByteType(        ByteType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseArrayType(        ArrayType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseRefType(        RefType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseNullType(        NullType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseIfCmpNeInst(    final IfCmpNeInst i){
      i.getOpType().apply(new TypeSwitch(){
        public void caseIntType(        IntType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseBooleanType(        BooleanType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseShortType(        ShortType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseCharType(        CharType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseByteType(        ByteType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseArrayType(        ArrayType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseRefType(        RefType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseNullType(        NullType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseIfCmpGtInst(    final IfCmpGtInst i){
      i.getOpType().apply(new TypeSwitch(){
        public void caseIntType(        IntType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseBooleanType(        BooleanType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseShortType(        ShortType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseCharType(        CharType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseByteType(        ByteType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseArrayType(        ArrayType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseRefType(        RefType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseNullType(        NullType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseIfCmpGeInst(    final IfCmpGeInst i){
      i.getOpType().apply(new TypeSwitch(){
        public void caseIntType(        IntType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseBooleanType(        BooleanType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseShortType(        ShortType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseCharType(        CharType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseByteType(        ByteType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseArrayType(        ArrayType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseRefType(        RefType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseNullType(        NullType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseIfCmpLtInst(    final IfCmpLtInst i){
      i.getOpType().apply(new TypeSwitch(){
        public void caseIntType(        IntType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseBooleanType(        BooleanType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseShortType(        ShortType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseCharType(        CharType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseByteType(        ByteType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseArrayType(        ArrayType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseRefType(        RefType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseNullType(        NullType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseIfCmpLeInst(    final IfCmpLeInst i){
      i.getOpType().apply(new TypeSwitch(){
        public void caseIntType(        IntType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseBooleanType(        BooleanType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseShortType(        ShortType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseCharType(        CharType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseByteType(        ByteType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseArrayType(        ArrayType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseRefType(        RefType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseNullType(        NullType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseStaticGetInst(    StaticGetInst i){
      SootFieldRef field=i.getFieldRef();
      emit(""String_Node_Str"" + slashify(field.declaringClass().getName()) + ""String_Node_Str""+ field.name()+ ""String_Node_Str""+ jasminDescriptorOf(field.type()));
    }
    public void caseStaticPutInst(    StaticPutInst i){
      emit(""String_Node_Str"" + slashify(i.getFieldRef().declaringClass().getName()) + ""String_Node_Str""+ i.getFieldRef().name()+ ""String_Node_Str""+ jasminDescriptorOf(i.getFieldRef().type()));
    }
    public void caseFieldGetInst(    FieldGetInst i){
      emit(""String_Node_Str"" + slashify(i.getFieldRef().declaringClass().getName()) + ""String_Node_Str""+ i.getFieldRef().name()+ ""String_Node_Str""+ jasminDescriptorOf(i.getFieldRef().type()));
    }
    public void caseFieldPutInst(    FieldPutInst i){
      emit(""String_Node_Str"" + slashify(i.getFieldRef().declaringClass().getName()) + ""String_Node_Str""+ i.getFieldRef().name()+ ""String_Node_Str""+ jasminDescriptorOf(i.getFieldRef().type()));
    }
    public void caseInstanceCastInst(    InstanceCastInst i){
      Type castType=i.getCastType();
      if (castType instanceof RefType)       emit(""String_Node_Str"" + slashify(castType.toString()));
 else       if (castType instanceof ArrayType)       emit(""String_Node_Str"" + jasminDescriptorOf(castType));
    }
    public void caseInstanceOfInst(    InstanceOfInst i){
      Type checkType=i.getCheckType();
      if (checkType instanceof RefType)       emit(""String_Node_Str"" + slashify(checkType.toString()));
 else       if (checkType instanceof ArrayType)       emit(""String_Node_Str"" + jasminDescriptorOf(checkType));
    }
    public void caseNewInst(    NewInst i){
      emit(""String_Node_Str"" + slashify(i.getBaseType().toString()));
    }
    public void casePrimitiveCastInst(    PrimitiveCastInst i){
      emit(i.toString());
    }
    public void caseStaticInvokeInst(    StaticInvokeInst i){
      SootMethodRef m=i.getMethodRef();
      emit(""String_Node_Str"" + slashify(m.declaringClass().getName()) + ""String_Node_Str""+ m.name()+ jasminDescriptorOf(m));
    }
    public void caseVirtualInvokeInst(    VirtualInvokeInst i){
      SootMethodRef m=i.getMethodRef();
      emit(""String_Node_Str"" + slashify(m.declaringClass().getName()) + ""String_Node_Str""+ m.name()+ jasminDescriptorOf(m));
    }
    public void caseInterfaceInvokeInst(    InterfaceInvokeInst i){
      SootMethodRef m=i.getMethodRef();
      emit(""String_Node_Str"" + slashify(m.declaringClass().getName()) + ""String_Node_Str""+ m.name()+ jasminDescriptorOf(m)+ ""String_Node_Str""+ (argCountOf(m) + 1));
    }
    public void caseSpecialInvokeInst(    SpecialInvokeInst i){
      SootMethodRef m=i.getMethodRef();
      emit(""String_Node_Str"" + slashify(m.declaringClass().getName()) + ""String_Node_Str""+ m.name()+ jasminDescriptorOf(m));
    }
    public void caseThrowInst(    ThrowInst i){
      emit(""String_Node_Str"");
    }
    public void caseCmpInst(    CmpInst i){
      emit(""String_Node_Str"");
    }
    public void caseCmplInst(    CmplInst i){
      if (i.getOpType().equals(FloatType.v()))       emit(""String_Node_Str"");
 else       emit(""String_Node_Str"");
    }
    public void caseCmpgInst(    CmpgInst i){
      if (i.getOpType().equals(FloatType.v()))       emit(""String_Node_Str"");
 else       emit(""String_Node_Str"");
    }
    private void emitOpTypeInst(    final String s,    final OpTypeArgInst i){
      i.getOpType().apply(new TypeSwitch(){
        private void handleIntCase(){
          emit(""String_Node_Str"" + s);
        }
        public void caseIntType(        IntType t){
          handleIntCase();
        }
        public void caseBooleanType(        BooleanType t){
          handleIntCase();
        }
        public void caseShortType(        ShortType t){
          handleIntCase();
        }
        public void caseCharType(        CharType t){
          handleIntCase();
        }
        public void caseByteType(        ByteType t){
          handleIntCase();
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"" + s);
        }
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"" + s);
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"" + s);
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseAddInst(    AddInst i){
      emitOpTypeInst(""String_Node_Str"",i);
    }
    public void caseDivInst(    DivInst i){
      emitOpTypeInst(""String_Node_Str"",i);
    }
    public void caseSubInst(    SubInst i){
      emitOpTypeInst(""String_Node_Str"",i);
    }
    public void caseMulInst(    MulInst i){
      emitOpTypeInst(""String_Node_Str"",i);
    }
    public void caseRemInst(    RemInst i){
      emitOpTypeInst(""String_Node_Str"",i);
    }
    public void caseShlInst(    ShlInst i){
      emitOpTypeInst(""String_Node_Str"",i);
    }
    public void caseAndInst(    AndInst i){
      emitOpTypeInst(""String_Node_Str"",i);
    }
    public void caseOrInst(    OrInst i){
      emitOpTypeInst(""String_Node_Str"",i);
    }
    public void caseXorInst(    XorInst i){
      emitOpTypeInst(""String_Node_Str"",i);
    }
    public void caseShrInst(    ShrInst i){
      emitOpTypeInst(""String_Node_Str"",i);
    }
    public void caseUshrInst(    UshrInst i){
      emitOpTypeInst(""String_Node_Str"",i);
    }
    public void caseIncInst(    IncInst i){
      if (((ValueBox)i.getUseBoxes().get(0)).getValue() != ((ValueBox)i.getDefBoxes().get(0)).getValue())       throw new RuntimeException(""String_Node_Str"");
      emit(""String_Node_Str"" + ((Integer)localToSlot.get(i.getLocal())) + ""String_Node_Str""+ i.getConstant());
    }
    public void caseArrayLengthInst(    ArrayLengthInst i){
      emit(""String_Node_Str"");
    }
    public void caseNegInst(    NegInst i){
      emitOpTypeInst(""String_Node_Str"",i);
    }
    public void caseNewArrayInst(    NewArrayInst i){
      if (i.getBaseType() instanceof RefType)       emit(""String_Node_Str"" + slashify(i.getBaseType().toString()));
 else       if (i.getBaseType() instanceof ArrayType)       emit(""String_Node_Str"" + jasminDescriptorOf(i.getBaseType()));
 else       emit(""String_Node_Str"" + i.getBaseType().toString());
    }
    public void caseNewMultiArrayInst(    NewMultiArrayInst i){
      emit(""String_Node_Str"" + jasminDescriptorOf(i.getBaseType()) + ""String_Node_Str""+ i.getDimensionCount());
    }
    public void caseLookupSwitchInst(    LookupSwitchInst i){
      emit(""String_Node_Str"");
      List lookupValues=i.getLookupValues();
      List targets=i.getTargets();
      for (int j=0; j < lookupValues.size(); j++)       emit(""String_Node_Str"" + lookupValues.get(j) + ""String_Node_Str""+ unitToLabel.get(targets.get(j)));
      emit(""String_Node_Str"" + unitToLabel.get(i.getDefaultTarget()));
    }
    public void caseTableSwitchInst(    TableSwitchInst i){
      emit(""String_Node_Str"" + i.getLowIndex() + ""String_Node_Str""+ i.getHighIndex());
      List targets=i.getTargets();
      for (int j=0; j < targets.size(); j++)       emit(""String_Node_Str"" + unitToLabel.get(targets.get(j)));
      emit(""String_Node_Str"" + unitToLabel.get(i.getDefaultTarget()));
    }
    private boolean isDwordType(    Type t){
      return t instanceof LongType || t instanceof DoubleType || t instanceof DoubleWordType;
    }
    public void caseDup1Inst(    Dup1Inst i){
      Type firstOpType=i.getOp1Type();
      if (isDwordType(firstOpType))       emit(""String_Node_Str"");
 else       emit(""String_Node_Str"");
    }
    public void caseDup2Inst(    Dup2Inst i){
      Type firstOpType=i.getOp1Type();
      Type secondOpType=i.getOp2Type();
      if (isDwordType(firstOpType)) {
        emit(""String_Node_Str"");
        if (isDwordType(secondOpType)) {
          emit(""String_Node_Str"");
        }
 else         emit(""String_Node_Str"");
      }
 else       if (isDwordType(secondOpType)) {
        if (isDwordType(firstOpType)) {
          emit(""String_Node_Str"");
        }
 else         emit(""String_Node_Str"");
        emit(""String_Node_Str"");
      }
 else {
        G.v().out.println(""String_Node_Str"");
        emit(""String_Node_Str"");
      }
    }
    public void caseDup1_x1Inst(    Dup1_x1Inst i){
      Type opType=i.getOp1Type();
      Type underType=i.getUnder1Type();
      if (isDwordType(opType)) {
        if (isDwordType(underType)) {
          emit(""String_Node_Str"");
        }
 else         emit(""String_Node_Str"");
      }
 else {
        if (isDwordType(underType))         emit(""String_Node_Str"");
 else         emit(""String_Node_Str"");
      }
    }
    public void caseDup1_x2Inst(    Dup1_x2Inst i){
      Type opType=i.getOp1Type();
      Type under1Type=i.getUnder1Type();
      Type under2Type=i.getUnder2Type();
      if (isDwordType(opType)) {
        if (!isDwordType(under1Type) && !isDwordType(under2Type))         emit(""String_Node_Str"");
 else         throw new RuntimeException(""String_Node_Str"");
      }
 else {
        if (isDwordType(under1Type) || isDwordType(under2Type))         throw new RuntimeException(""String_Node_Str"");
      }
      emit(""String_Node_Str"");
    }
    public void caseDup2_x1Inst(    Dup2_x1Inst i){
      Type op1Type=i.getOp1Type();
      Type op2Type=i.getOp2Type();
      Type under1Type=i.getUnder1Type();
      if (isDwordType(under1Type)) {
        if (!isDwordType(op1Type) && !isDwordType(op2Type))         throw new RuntimeException(""String_Node_Str"");
 else         emit(""String_Node_Str"");
      }
 else {
        if (isDwordType(op1Type) || isDwordType(op2Type))         throw new RuntimeException(""String_Node_Str"");
      }
      emit(""String_Node_Str"");
    }
    public void caseDup2_x2Inst(    Dup2_x2Inst i){
      Type op1Type=i.getOp1Type();
      Type op2Type=i.getOp2Type();
      Type under1Type=i.getUnder1Type();
      Type under2Type=i.getUnder2Type();
      if (isDwordType(op1Type) || isDwordType(op2Type) || isDwordType(under1Type)|| isDwordType(under1Type))       throw new RuntimeException(""String_Node_Str"");
      emit(""String_Node_Str"");
    }
    public void caseSwapInst(    SwapInst i){
      emit(""String_Node_Str"");
    }
  }
);
}"
88576,"public void caseFieldPutInst(FieldPutInst i){
  emit(""String_Node_Str"" + slashify(i.getField().getDeclaringClass().getName()) + ""String_Node_Str""+ i.getField().getName()+ ""String_Node_Str""+ jasminDescriptorOf(i.getField().getType()));
}","public void caseFieldPutInst(FieldPutInst i){
  emit(""String_Node_Str"" + slashify(i.getFieldRef().declaringClass().getName()) + ""String_Node_Str""+ i.getFieldRef().name()+ ""String_Node_Str""+ jasminDescriptorOf(i.getFieldRef().type()));
}"
88577,"public void caseStaticGetInst(StaticGetInst i){
  SootField field=i.getField();
  emit(""String_Node_Str"" + slashify(field.getDeclaringClass().getName()) + ""String_Node_Str""+ field.getName()+ ""String_Node_Str""+ jasminDescriptorOf(field.getType()));
}","public void caseStaticGetInst(StaticGetInst i){
  SootFieldRef field=i.getFieldRef();
  emit(""String_Node_Str"" + slashify(field.declaringClass().getName()) + ""String_Node_Str""+ field.name()+ ""String_Node_Str""+ jasminDescriptorOf(field.type()));
}"
88578,"public void caseStaticPutInst(StaticPutInst i){
  emit(""String_Node_Str"" + slashify(i.getField().getDeclaringClass().getName()) + ""String_Node_Str""+ i.getField().getName()+ ""String_Node_Str""+ jasminDescriptorOf(i.getField().getType()));
}","public void caseStaticPutInst(StaticPutInst i){
  emit(""String_Node_Str"" + slashify(i.getFieldRef().declaringClass().getName()) + ""String_Node_Str""+ i.getFieldRef().name()+ ""String_Node_Str""+ jasminDescriptorOf(i.getFieldRef().type()));
}"
88579,"public void caseFieldGetInst(FieldGetInst i){
  emit(""String_Node_Str"" + slashify(i.getField().getDeclaringClass().getName()) + ""String_Node_Str""+ i.getField().getName()+ ""String_Node_Str""+ jasminDescriptorOf(i.getField().getType()));
}","public void caseFieldGetInst(FieldGetInst i){
  emit(""String_Node_Str"" + slashify(i.getFieldRef().declaringClass().getName()) + ""String_Node_Str""+ i.getFieldRef().name()+ ""String_Node_Str""+ jasminDescriptorOf(i.getFieldRef().type()));
}"
88580,"/** 
 * creates a field ref
 */
private soot.jimple.FieldRef getFieldRef(polyglot.ast.Field field){
  soot.SootClass receiverClass=((soot.RefType)Util.getSootType(field.fieldInstance().container())).getSootClass();
  soot.SootFieldRef receiverField=soot.Scene.v().makeFieldRef(receiverClass,field.name(),Util.getSootType(field.type()),field.flags().isStatic());
  soot.jimple.FieldRef fieldRef;
  if (field.fieldInstance().flags().isStatic()) {
    fieldRef=soot.jimple.Jimple.v().newStaticFieldRef(receiverField);
  }
 else {
    soot.Local base;
    base=(soot.Local)getBaseLocal(field.target());
    fieldRef=soot.jimple.Jimple.v().newInstanceFieldRef(base,receiverField);
  }
  if (field.target() instanceof polyglot.ast.Local && fieldRef instanceof soot.jimple.InstanceFieldRef) {
    Util.addLnPosTags(((soot.jimple.InstanceFieldRef)fieldRef).getBaseBox(),field.target().position());
  }
  return fieldRef;
}","/** 
 * creates a field ref
 */
private soot.jimple.FieldRef getFieldRef(polyglot.ast.Field field){
  soot.SootClass receiverClass=((soot.RefType)Util.getSootType(field.target().type())).getSootClass();
  soot.SootFieldRef receiverField=soot.Scene.v().makeFieldRef(receiverClass,field.name(),Util.getSootType(field.type()),field.flags().isStatic());
  soot.jimple.FieldRef fieldRef;
  if (field.fieldInstance().flags().isStatic()) {
    fieldRef=soot.jimple.Jimple.v().newStaticFieldRef(receiverField);
  }
 else {
    soot.Local base;
    base=(soot.Local)getBaseLocal(field.target());
    fieldRef=soot.jimple.Jimple.v().newInstanceFieldRef(base,receiverField);
  }
  if (field.target() instanceof polyglot.ast.Local && fieldRef instanceof soot.jimple.InstanceFieldRef) {
    Util.addLnPosTags(((soot.jimple.InstanceFieldRef)fieldRef).getBaseBox(),field.target().position());
  }
  return fieldRef;
}"
88581,"private void adjustBranchTargets(){
  Instruction insn=this.sentinel.next;
  while (insn != null) {
    if (insn instanceof Instruction_branch) {
      Instruction_branch binsn=(Instruction_branch)insn;
      Instruction newtgt=(Instruction)replacedInsns.get(binsn.target);
      if (newtgt != null) {
        binsn.target=newtgt;
        newtgt.labelled=true;
      }
    }
 else     if (insn instanceof Instruction_Lookupswitch) {
      Instruction_Lookupswitch switchinsn=(Instruction_Lookupswitch)insn;
      Instruction newdefault=(Instruction)replacedInsns.get(switchinsn.default_inst);
      if (newdefault != null) {
        switchinsn.default_inst=newdefault;
        newdefault.labelled=true;
      }
      for (int i=0; i < switchinsn.npairs; i++) {
        Instruction newtgt=(Instruction)replacedInsns.get(switchinsn.match_insts[i]);
        if (newtgt != null) {
          switchinsn.match_insts[i]=newtgt;
          newtgt.labelled=true;
        }
      }
    }
 else     if (insn instanceof Instruction_Tableswitch) {
      Instruction_Tableswitch switchinsn=(Instruction_Tableswitch)insn;
      Instruction newdefault=(Instruction)replacedInsns.get(switchinsn.default_inst);
      if (newdefault != null) {
        switchinsn.default_inst=newdefault;
        newdefault.labelled=true;
      }
      for (int i=0; i < switchinsn.high - switchinsn.low; i++) {
        Instruction newtgt=(Instruction)replacedInsns.get(switchinsn.jump_insts[i]);
        if (newtgt != null) {
          switchinsn.jump_insts[i]=newtgt;
          newtgt.labelled=true;
        }
      }
    }
    insn=insn.next;
  }
}","private void adjustBranchTargets(){
  Instruction insn=this.sentinel.next;
  while (insn != null) {
    if (insn instanceof Instruction_branch) {
      Instruction_branch binsn=(Instruction_branch)insn;
      Instruction newtgt=(Instruction)replacedInsns.get(binsn.target);
      if (newtgt != null) {
        binsn.target=newtgt;
        newtgt.labelled=true;
      }
    }
 else     if (insn instanceof Instruction_Lookupswitch) {
      Instruction_Lookupswitch switchinsn=(Instruction_Lookupswitch)insn;
      Instruction newdefault=(Instruction)replacedInsns.get(switchinsn.default_inst);
      if (newdefault != null) {
        switchinsn.default_inst=newdefault;
        newdefault.labelled=true;
      }
      for (int i=0; i < switchinsn.npairs; i++) {
        Instruction newtgt=(Instruction)replacedInsns.get(switchinsn.match_insts[i]);
        if (newtgt != null) {
          switchinsn.match_insts[i]=newtgt;
          newtgt.labelled=true;
        }
      }
    }
 else     if (insn instanceof Instruction_Tableswitch) {
      Instruction_Tableswitch switchinsn=(Instruction_Tableswitch)insn;
      Instruction newdefault=(Instruction)replacedInsns.get(switchinsn.default_inst);
      if (newdefault != null) {
        switchinsn.default_inst=newdefault;
        newdefault.labelled=true;
      }
      for (int i=0; i <= switchinsn.high - switchinsn.low; i++) {
        Instruction newtgt=(Instruction)replacedInsns.get(switchinsn.jump_insts[i]);
        if (newtgt != null) {
          switchinsn.jump_insts[i]=newtgt;
          newtgt.labelled=true;
        }
      }
    }
    insn=insn.next;
  }
}"
88582,"/** 
 * Field Expression Creation
 */
private soot.Value getFieldLocal(polyglot.ast.Field field){
  polyglot.ast.Receiver receiver=field.target();
  soot.javaToJimple.PolyglotMethodSource ms=(soot.javaToJimple.PolyglotMethodSource)body.getMethod().getSource();
  if ((field.name().equals(""String_Node_Str"")) && (receiver.type() instanceof polyglot.types.ArrayType)) {
    return getSpecialArrayLengthLocal(field);
  }
 else   if (field.name().equals(""String_Node_Str"")) {
    throw new RuntimeException(""String_Node_Str"");
  }
 else   if (field.fieldInstance().flags().isPrivate() && !Util.getSootType(field.fieldInstance().container()).equals(body.getMethod().getDeclaringClass().getType())) {
    return getPrivateAccessFieldLocal(field);
  }
  if ((field.target() instanceof polyglot.ast.Special) && (((polyglot.ast.Special)field.target()).kind() == polyglot.ast.Special.SUPER) && (((polyglot.ast.Special)field.target()).qualifier() != null)) {
    return getSpecialSuperQualifierLocal(field);
  }
 else   if (shouldReturnConstant(field)) {
    return getReturnConstant(field);
  }
 else {
    soot.jimple.FieldRef fieldRef=getFieldRef(field);
    soot.Local baseLocal=generateLocal(field.type());
    soot.jimple.AssignStmt fieldAssignStmt=soot.jimple.Jimple.v().newAssignStmt(baseLocal,fieldRef);
    body.getUnits().add(fieldAssignStmt);
    Util.addLnPosTags(fieldAssignStmt,field.position());
    return baseLocal;
  }
}","/** 
 * Field Expression Creation
 */
private soot.Value getFieldLocal(polyglot.ast.Field field){
  polyglot.ast.Receiver receiver=field.target();
  soot.javaToJimple.PolyglotMethodSource ms=(soot.javaToJimple.PolyglotMethodSource)body.getMethod().getSource();
  if ((field.name().equals(""String_Node_Str"")) && (receiver.type() instanceof polyglot.types.ArrayType)) {
    return getSpecialArrayLengthLocal(field);
  }
 else   if (field.name().equals(""String_Node_Str"")) {
    throw new RuntimeException(""String_Node_Str"");
  }
 else   if (needsPrivateAccessor(field) || needsProtectedAccessor(field)) {
    return getPrivateAccessFieldLocal(field);
  }
  if ((field.target() instanceof polyglot.ast.Special) && (((polyglot.ast.Special)field.target()).kind() == polyglot.ast.Special.SUPER) && (((polyglot.ast.Special)field.target()).qualifier() != null)) {
    return getSpecialSuperQualifierLocal(field);
  }
 else   if (shouldReturnConstant(field)) {
    return getReturnConstant(field);
  }
 else {
    soot.jimple.FieldRef fieldRef=getFieldRef(field);
    soot.Local baseLocal=generateLocal(field.type());
    soot.jimple.AssignStmt fieldAssignStmt=soot.jimple.Jimple.v().newAssignStmt(baseLocal,fieldRef);
    body.getUnits().add(fieldAssignStmt);
    Util.addLnPosTags(fieldAssignStmt,field.position());
    return baseLocal;
  }
}"
88583,"/** 
 * Assign Expression Creation
 */
private soot.Value getAssignLocal(polyglot.ast.Assign assign){
  if ((assign.left() instanceof polyglot.ast.Field) && ((polyglot.ast.Field)assign.left()).fieldInstance().flags().isPrivate() && !Util.getSootType(((polyglot.ast.Field)assign.left()).fieldInstance().container()).equals(body.getMethod().getDeclaringClass().getType())) {
    return handlePrivateFieldSet(assign);
  }
  if (assign.operator() == polyglot.ast.Assign.ASSIGN) {
    return getSimpleAssignLocal(assign);
  }
  if ((assign.operator() == polyglot.ast.Assign.ADD_ASSIGN) && assign.type().toString().equals(""String_Node_Str"")) {
    return getStrConAssignLocal(assign);
  }
  soot.jimple.AssignStmt stmt;
  soot.Value left=createLHS(assign.left());
  soot.Value left2=(soot.Value)left.clone();
  soot.Local leftLocal;
  if (left instanceof soot.Local) {
    leftLocal=(soot.Local)left;
  }
 else {
    leftLocal=lg.generateLocal(left.getType());
    soot.jimple.AssignStmt stmt1=soot.jimple.Jimple.v().newAssignStmt(leftLocal,left);
    body.getUnits().add(stmt1);
    Util.addLnPosTags(stmt1,assign.position());
  }
  soot.Value right=getAssignRightLocal(assign,leftLocal);
  soot.jimple.AssignStmt stmt2=soot.jimple.Jimple.v().newAssignStmt(leftLocal,right);
  body.getUnits().add(stmt2);
  Util.addLnPosTags(stmt2,assign.position());
  Util.addLnPosTags(stmt2.getRightOpBox(),assign.right().position());
  Util.addLnPosTags(stmt2.getLeftOpBox(),assign.left().position());
  if (!(left instanceof soot.Local)) {
    soot.jimple.AssignStmt stmt3=soot.jimple.Jimple.v().newAssignStmt(left2,leftLocal);
    body.getUnits().add(stmt3);
    Util.addLnPosTags(stmt3,assign.position());
    Util.addLnPosTags(stmt3.getRightOpBox(),assign.right().position());
    Util.addLnPosTags(stmt3.getLeftOpBox(),assign.left().position());
  }
  return leftLocal;
}","/** 
 * Assign Expression Creation
 */
private soot.Value getAssignLocal(polyglot.ast.Assign assign){
  if ((assign.left() instanceof polyglot.ast.Field) && (needsPrivateAccessor((polyglot.ast.Field)assign.left()) || needsProtectedAccessor((polyglot.ast.Field)assign.left()))) {
    return handlePrivateFieldSet(assign);
  }
  if (assign.operator() == polyglot.ast.Assign.ASSIGN) {
    return getSimpleAssignLocal(assign);
  }
  if ((assign.operator() == polyglot.ast.Assign.ADD_ASSIGN) && assign.type().toString().equals(""String_Node_Str"")) {
    return getStrConAssignLocal(assign);
  }
  soot.jimple.AssignStmt stmt;
  soot.Value left=createLHS(assign.left());
  soot.Value left2=(soot.Value)left.clone();
  soot.Local leftLocal;
  if (left instanceof soot.Local) {
    leftLocal=(soot.Local)left;
  }
 else {
    leftLocal=lg.generateLocal(left.getType());
    soot.jimple.AssignStmt stmt1=soot.jimple.Jimple.v().newAssignStmt(leftLocal,left);
    body.getUnits().add(stmt1);
    Util.addLnPosTags(stmt1,assign.position());
  }
  soot.Value right=getAssignRightLocal(assign,leftLocal);
  soot.jimple.AssignStmt stmt2=soot.jimple.Jimple.v().newAssignStmt(leftLocal,right);
  body.getUnits().add(stmt2);
  Util.addLnPosTags(stmt2,assign.position());
  Util.addLnPosTags(stmt2.getRightOpBox(),assign.right().position());
  Util.addLnPosTags(stmt2.getLeftOpBox(),assign.left().position());
  if (!(left instanceof soot.Local)) {
    soot.jimple.AssignStmt stmt3=soot.jimple.Jimple.v().newAssignStmt(left2,leftLocal);
    body.getUnits().add(stmt3);
    Util.addLnPosTags(stmt3,assign.position());
    Util.addLnPosTags(stmt3.getRightOpBox(),assign.right().position());
    Util.addLnPosTags(stmt3.getLeftOpBox(),assign.left().position());
  }
  return leftLocal;
}"
88584,"/** 
 * For Inner Classes - to access private fields of their outer class
 */
private soot.Local getPrivateAccessFieldLocal(polyglot.ast.Field field){
  soot.SootMethod toInvoke=addGetFieldAccessMeth(((soot.RefType)Util.getSootType(field.fieldInstance().container())).getSootClass(),field);
  ArrayList params=new ArrayList();
  if (!field.fieldInstance().flags().isStatic()) {
    params.add((soot.Local)getBaseLocal(field.target()));
  }
  return Util.getPrivateAccessFieldInvoke(toInvoke.makeRef(),params,body,lg);
}","/** 
 * For Inner Classes - to access private fields of their outer class
 */
private soot.Local getPrivateAccessFieldLocal(polyglot.ast.Field field){
  soot.SootMethod toInvoke;
  if (field.fieldInstance().flags().isPrivate()) {
    toInvoke=addGetFieldAccessMeth(((soot.RefType)Util.getSootType(field.fieldInstance().container())).getSootClass(),field);
  }
 else {
    if (InitialResolver.v().hierarchy() == null) {
      InitialResolver.v().hierarchy(new soot.FastHierarchy());
    }
    soot.SootClass addToClass=body.getMethod().getDeclaringClass().getOuterClass();
    soot.SootClass containingClass=((soot.RefType)Util.getSootType(field.fieldInstance().container())).getSootClass();
    while (!InitialResolver.v().hierarchy().canStoreType(containingClass.getType(),addToClass.getType())) {
      if (addToClass.hasOuterClass()) {
        addToClass=addToClass.getOuterClass();
      }
 else {
        break;
      }
    }
    toInvoke=addGetFieldAccessMeth(addToClass,field);
  }
  ArrayList params=new ArrayList();
  if (!field.fieldInstance().flags().isStatic()) {
    params.add((soot.Local)getBaseLocal(field.target()));
  }
  return Util.getPrivateAccessFieldInvoke(toInvoke.makeRef(),params,body,lg);
}"
88585,"private ArrayList addFinalLocals(polyglot.ast.ClassBody cBody,ArrayList finalLocals,polyglot.types.ClassType nodeKeyType,AnonLocalClassInfo info){
  ArrayList finalFields=new ArrayList();
  LocalUsesChecker luc=new LocalUsesChecker();
  cBody.visit(luc);
  Iterator localsNeededIt=luc.getLocals().iterator();
  ArrayList localsUsed=new ArrayList();
  while (localsNeededIt.hasNext()) {
    polyglot.types.LocalInstance li=(polyglot.types.LocalInstance)((polyglot.util.IdentityKey)localsNeededIt.next()).object();
    if (finalLocals.contains(new polyglot.util.IdentityKey(li))) {
      addFinals(li,finalFields);
      localsUsed.add(new polyglot.util.IdentityKey(li));
    }
  }
  Iterator newsIt=luc.getNews().iterator();
  while (newsIt.hasNext()) {
    polyglot.ast.New tempNew=(polyglot.ast.New)newsIt.next();
    polyglot.types.ClassType tempNewType=(polyglot.types.ClassType)tempNew.objectType().type();
    if (InitialResolver.v().finalLocalInfo().containsKey(new polyglot.util.IdentityKey(tempNewType))) {
      AnonLocalClassInfo lInfo=(AnonLocalClassInfo)InitialResolver.v().finalLocalInfo().get(new polyglot.util.IdentityKey(tempNewType));
      Iterator it=lInfo.finalLocals().iterator();
      while (it.hasNext()) {
        polyglot.types.LocalInstance li2=(polyglot.types.LocalInstance)((polyglot.util.IdentityKey)it.next()).object();
        if (!sootClass.declaresField(""String_Node_Str"" + li2.name(),Util.getSootType(li2.type()))) {
          addFinals(li2,finalFields);
          localsUsed.add(new polyglot.util.IdentityKey(li2));
        }
      }
    }
  }
  info.finalLocals(localsUsed);
  InitialResolver.v().finalLocalInfo().put(new polyglot.util.IdentityKey(nodeKeyType),info);
  return finalFields;
}","private ArrayList addFinalLocals(polyglot.ast.ClassBody cBody,ArrayList finalLocals,polyglot.types.ClassType nodeKeyType,AnonLocalClassInfo info){
  ArrayList finalFields=new ArrayList();
  LocalUsesChecker luc=new LocalUsesChecker();
  cBody.visit(luc);
  Iterator localsNeededIt=luc.getLocals().iterator();
  ArrayList localsUsed=new ArrayList();
  while (localsNeededIt.hasNext()) {
    polyglot.types.LocalInstance li=(polyglot.types.LocalInstance)((polyglot.util.IdentityKey)localsNeededIt.next()).object();
    if (finalLocals.contains(new polyglot.util.IdentityKey(li)) && !luc.getLocalDecls().contains(new polyglot.util.IdentityKey(li))) {
      addFinals(li,finalFields);
      localsUsed.add(new polyglot.util.IdentityKey(li));
    }
  }
  Iterator newsIt=luc.getNews().iterator();
  while (newsIt.hasNext()) {
    polyglot.ast.New tempNew=(polyglot.ast.New)newsIt.next();
    polyglot.types.ClassType tempNewType=(polyglot.types.ClassType)tempNew.objectType().type();
    if (InitialResolver.v().finalLocalInfo().containsKey(new polyglot.util.IdentityKey(tempNewType))) {
      AnonLocalClassInfo lInfo=(AnonLocalClassInfo)InitialResolver.v().finalLocalInfo().get(new polyglot.util.IdentityKey(tempNewType));
      Iterator it=lInfo.finalLocals().iterator();
      while (it.hasNext()) {
        polyglot.types.LocalInstance li2=(polyglot.types.LocalInstance)((polyglot.util.IdentityKey)it.next()).object();
        if (!sootClass.declaresField(""String_Node_Str"" + li2.name(),Util.getSootType(li2.type()))) {
          if (!luc.getLocalDecls().contains(new polyglot.util.IdentityKey(li2))) {
            addFinals(li2,finalFields);
            localsUsed.add(new polyglot.util.IdentityKey(li2));
          }
        }
      }
    }
  }
  info.finalLocals(localsUsed);
  InitialResolver.v().finalLocalInfo().put(new polyglot.util.IdentityKey(nodeKeyType),info);
  return finalFields;
}"
88586,"/** 
 * looks after pos tags for methods and constructors
 */
private void finishProcedure(polyglot.ast.ProcedureDecl procedure,soot.SootMethod sootMethod){
  addProcedureToClass(sootMethod);
  if (procedure.position() != null) {
    if (procedure.body() != null) {
      if (procedure.body().position() != null) {
        Util.addLnPosTags(sootMethod,procedure.position().line(),procedure.body().position().endLine(),procedure.position().column(),procedure.body().position().endColumn());
      }
    }
  }
  PolyglotMethodSource mSrc=new PolyglotMethodSource(procedure.body(),procedure.formals());
  mSrc.setJBB(InitialResolver.v().getJBBFactory().createJimpleBodyBuilder());
  sootMethod.setSource(mSrc);
}","/** 
 * looks after pos tags for methods and constructors
 */
private void finishProcedure(polyglot.ast.ProcedureDecl procedure,soot.SootMethod sootMethod){
  addProcedureToClass(sootMethod);
  if (procedure.position() != null) {
    if (procedure.body() != null) {
      if (procedure.body().position() != null) {
        Util.addLnPosTags(sootMethod,procedure.position().line(),procedure.body().position().endLine(),procedure.position().column(),procedure.body().position().endColumn());
      }
    }
 else {
      Util.addLnPosTags(sootMethod,procedure.position());
    }
  }
  PolyglotMethodSource mSrc=new PolyglotMethodSource(procedure.body(),procedure.formals());
  mSrc.setJBB(InitialResolver.v().getJBBFactory().createJimpleBodyBuilder());
  sootMethod.setSource(mSrc);
}"
88587,"/** 
 * Class Declaration Creation
 */
private void createClassDecl(polyglot.ast.ClassDecl cDecl){
  if (!cDecl.type().isTopLevel()) {
    SootClass outerClass=((soot.RefType)Util.getSootType(cDecl.type().outer())).getSootClass();
    if (InitialResolver.v().getInnerClassInfoMap() == null) {
      InitialResolver.v().setInnerClassInfoMap(new HashMap());
    }
    InitialResolver.v().getInnerClassInfoMap().put(sootClass,new InnerClassInfo(outerClass,cDecl.name(),InnerClassInfo.NESTED));
    sootClass.setOuterClass(outerClass);
  }
  polyglot.types.Flags flags=cDecl.flags();
  addModifiers(flags,cDecl);
  if (cDecl.superClass() == null) {
    soot.SootClass superClass=soot.Scene.v().getSootClass(""String_Node_Str"");
    sootClass.setSuperclass(superClass);
  }
 else {
    sootClass.setSuperclass(((soot.RefType)Util.getSootType(cDecl.superClass().type())).getSootClass());
    if (((polyglot.types.ClassType)cDecl.superClass().type()).isNested()) {
      polyglot.types.ClassType superType=(polyglot.types.ClassType)cDecl.superClass().type();
      Util.addInnerClassTag(sootClass,sootClass.getName(),((soot.RefType)Util.getSootType(superType.outer())).toString(),superType.name(),Util.getModifier(superType.flags()));
    }
  }
  Iterator interfacesIt=cDecl.interfaces().iterator();
  while (interfacesIt.hasNext()) {
    polyglot.ast.TypeNode next=(polyglot.ast.TypeNode)interfacesIt.next();
    sootClass.addInterface(((soot.RefType)Util.getSootType(next.type())).getSootClass());
  }
  findReferences(cDecl);
  createClassBody(cDecl.body());
  handleFieldInits();
  if ((staticFieldInits != null) || (staticInitializerBlocks != null)) {
    soot.SootMethod clinitMethod;
    if (!sootClass.declaresMethod(""String_Node_Str"",new ArrayList(),soot.VoidType.v())) {
      clinitMethod=new soot.SootMethod(""String_Node_Str"",new ArrayList(),soot.VoidType.v(),soot.Modifier.STATIC,new ArrayList());
      sootClass.addMethod(clinitMethod);
      PolyglotMethodSource mSource=new PolyglotMethodSource();
      mSource.setJBB(InitialResolver.v().getJBBFactory().createJimpleBodyBuilder());
      clinitMethod.setSource(mSource);
    }
 else {
      clinitMethod=sootClass.getMethod(""String_Node_Str"",new ArrayList(),soot.VoidType.v());
    }
    ((PolyglotMethodSource)clinitMethod.getSource()).setStaticFieldInits(staticFieldInits);
    ((PolyglotMethodSource)clinitMethod.getSource()).setStaticInitializerBlocks(staticInitializerBlocks);
  }
  if (cDecl.type().isLocal()) {
    AnonLocalClassInfo info=(AnonLocalClassInfo)InitialResolver.v().finalLocalInfo().get(new polyglot.util.IdentityKey(cDecl.type()));
    ArrayList finalsList=addFinalLocals(cDecl.body(),info.finalLocals(),cDecl.type(),info);
    Iterator it=sootClass.getMethods().iterator();
    while (it.hasNext()) {
      soot.SootMethod meth=(soot.SootMethod)it.next();
      if (meth.getName().equals(""String_Node_Str"")) {
        ((PolyglotMethodSource)meth.getSource()).setFinalsList(finalsList);
      }
    }
    if (!info.inStaticMethod()) {
      polyglot.types.ClassType outerType=cDecl.type().outer();
      addOuterClassThisRefToInit(outerType);
      addOuterClassThisRefField(outerType);
    }
  }
 else   if (cDecl.type().isNested() && !cDecl.flags().isStatic()) {
    polyglot.types.ClassType outerType=cDecl.type().outer();
    addOuterClassThisRefToInit(outerType);
    addOuterClassThisRefField(outerType);
  }
  Util.addLineTag(sootClass,cDecl);
}","/** 
 * Class Declaration Creation
 */
private void createClassDecl(polyglot.ast.ClassDecl cDecl){
  if (!cDecl.type().isTopLevel()) {
    SootClass outerClass=((soot.RefType)Util.getSootType(cDecl.type().outer())).getSootClass();
    if (InitialResolver.v().getInnerClassInfoMap() == null) {
      InitialResolver.v().setInnerClassInfoMap(new HashMap());
    }
    InitialResolver.v().getInnerClassInfoMap().put(sootClass,new InnerClassInfo(outerClass,cDecl.name(),InnerClassInfo.NESTED));
    sootClass.setOuterClass(outerClass);
  }
  polyglot.types.Flags flags=cDecl.flags();
  addModifiers(flags,cDecl);
  if (cDecl.superClass() == null) {
    soot.SootClass superClass=soot.Scene.v().getSootClass(""String_Node_Str"");
    sootClass.setSuperclass(superClass);
  }
 else {
    sootClass.setSuperclass(((soot.RefType)Util.getSootType(cDecl.superClass().type())).getSootClass());
    if (((polyglot.types.ClassType)cDecl.superClass().type()).isNested()) {
      polyglot.types.ClassType superType=(polyglot.types.ClassType)cDecl.superClass().type();
      Util.addInnerClassTag(sootClass,sootClass.getName(),((soot.RefType)Util.getSootType(superType.outer())).toString(),superType.name(),Util.getModifier(superType.flags()));
    }
  }
  Iterator interfacesIt=cDecl.interfaces().iterator();
  while (interfacesIt.hasNext()) {
    polyglot.ast.TypeNode next=(polyglot.ast.TypeNode)interfacesIt.next();
    sootClass.addInterface(((soot.RefType)Util.getSootType(next.type())).getSootClass());
  }
  findReferences(cDecl);
  createClassBody(cDecl.body());
  handleFieldInits();
  if ((staticFieldInits != null) || (staticInitializerBlocks != null)) {
    soot.SootMethod clinitMethod;
    if (!sootClass.declaresMethod(""String_Node_Str"",new ArrayList(),soot.VoidType.v())) {
      clinitMethod=new soot.SootMethod(""String_Node_Str"",new ArrayList(),soot.VoidType.v(),soot.Modifier.STATIC,new ArrayList());
      sootClass.addMethod(clinitMethod);
      PolyglotMethodSource mSource=new PolyglotMethodSource();
      mSource.setJBB(InitialResolver.v().getJBBFactory().createJimpleBodyBuilder());
      clinitMethod.setSource(mSource);
    }
 else {
      clinitMethod=sootClass.getMethod(""String_Node_Str"",new ArrayList(),soot.VoidType.v());
    }
    ((PolyglotMethodSource)clinitMethod.getSource()).setStaticFieldInits(staticFieldInits);
    ((PolyglotMethodSource)clinitMethod.getSource()).setStaticInitializerBlocks(staticInitializerBlocks);
  }
  if (cDecl.type().isLocal()) {
    AnonLocalClassInfo info=(AnonLocalClassInfo)InitialResolver.v().finalLocalInfo().get(new polyglot.util.IdentityKey(cDecl.type()));
    ArrayList finalsList=addFinalLocals(cDecl.body(),info.finalLocals(),cDecl.type(),info);
    Iterator it=sootClass.getMethods().iterator();
    while (it.hasNext()) {
      soot.SootMethod meth=(soot.SootMethod)it.next();
      if (meth.getName().equals(""String_Node_Str"")) {
        ((PolyglotMethodSource)meth.getSource()).setFinalsList(finalsList);
      }
    }
    if (!info.inStaticMethod()) {
      polyglot.types.ClassType outerType=cDecl.type().outer();
      addOuterClassThisRefToInit(outerType);
      addOuterClassThisRefField(outerType);
    }
  }
 else   if (cDecl.type().isNested() && !cDecl.flags().isStatic()) {
    polyglot.types.ClassType outerType=cDecl.type().outer();
    addOuterClassThisRefToInit(outerType);
    addOuterClassThisRefField(outerType);
  }
  Util.addLnPosTags(sootClass,cDecl.position());
}"
88588,"/** 
 * Synchronized Stmt Creation
 */
private void createSynchronized(polyglot.ast.Synchronized synchStmt){
  System.out.println(""String_Node_Str"" + synchStmt.position());
  soot.Value sootExpr=base().createExpr(synchStmt.expr());
  soot.jimple.EnterMonitorStmt enterMon=soot.jimple.Jimple.v().newEnterMonitorStmt(sootExpr);
  body.getUnits().add(enterMon);
  if (monitorStack == null) {
    monitorStack=new Stack();
  }
  monitorStack.push(sootExpr);
  Util.addLnPosTags(enterMon.getOpBox(),synchStmt.expr().position());
  Util.addLnPosTags(enterMon,synchStmt.expr().position());
  soot.jimple.Stmt startNoop=soot.jimple.Jimple.v().newNopStmt();
  body.getUnits().add(startNoop);
  createBlock(synchStmt.body());
  soot.jimple.ExitMonitorStmt exitMon=soot.jimple.Jimple.v().newExitMonitorStmt(sootExpr);
  body.getUnits().add(exitMon);
  monitorStack.pop();
  Util.addLnPosTags(exitMon.getOpBox(),synchStmt.expr().position());
  Util.addLnPosTags(exitMon,synchStmt.expr().position());
  soot.jimple.Stmt endSynchNoop=soot.jimple.Jimple.v().newNopStmt();
  soot.jimple.Stmt gotoEnd=soot.jimple.Jimple.v().newGotoStmt(endSynchNoop);
  soot.jimple.Stmt endNoop=soot.jimple.Jimple.v().newNopStmt();
  body.getUnits().add(endNoop);
  body.getUnits().add(gotoEnd);
  soot.jimple.Stmt catchAllBeforeNoop=soot.jimple.Jimple.v().newNopStmt();
  body.getUnits().add(catchAllBeforeNoop);
  soot.Local formalLocal=lg.generateLocal(soot.RefType.v(""String_Node_Str""));
  soot.jimple.CaughtExceptionRef exceptRef=soot.jimple.Jimple.v().newCaughtExceptionRef();
  soot.jimple.Stmt stmt=soot.jimple.Jimple.v().newIdentityStmt(formalLocal,exceptRef);
  body.getUnits().add(stmt);
  soot.jimple.Stmt catchBeforeNoop=soot.jimple.Jimple.v().newNopStmt();
  body.getUnits().add(catchBeforeNoop);
  soot.Local local=lg.generateLocal(soot.RefType.v(""String_Node_Str""));
  soot.jimple.Stmt assign=soot.jimple.Jimple.v().newAssignStmt(local,formalLocal);
  body.getUnits().add(assign);
  soot.jimple.ExitMonitorStmt catchExitMon=soot.jimple.Jimple.v().newExitMonitorStmt(sootExpr);
  body.getUnits().add(catchExitMon);
  Util.addLnPosTags(catchExitMon.getOpBox(),synchStmt.expr().position());
  soot.jimple.Stmt catchAfterNoop=soot.jimple.Jimple.v().newNopStmt();
  body.getUnits().add(catchAfterNoop);
  soot.jimple.Stmt throwStmt=soot.jimple.Jimple.v().newThrowStmt(local);
  body.getUnits().add(throwStmt);
  body.getUnits().add(endSynchNoop);
  addToExceptionList(startNoop,endNoop,catchAllBeforeNoop,soot.Scene.v().getSootClass(""String_Node_Str""));
  addToExceptionList(catchBeforeNoop,catchAfterNoop,catchAllBeforeNoop,soot.Scene.v().getSootClass(""String_Node_Str""));
}","/** 
 * Synchronized Stmt Creation
 */
private void createSynchronized(polyglot.ast.Synchronized synchStmt){
  soot.Value sootExpr=base().createExpr(synchStmt.expr());
  soot.jimple.EnterMonitorStmt enterMon=soot.jimple.Jimple.v().newEnterMonitorStmt(sootExpr);
  body.getUnits().add(enterMon);
  if (monitorStack == null) {
    monitorStack=new Stack();
  }
  monitorStack.push(sootExpr);
  Util.addLnPosTags(enterMon.getOpBox(),synchStmt.expr().position());
  Util.addLnPosTags(enterMon,synchStmt.expr().position());
  soot.jimple.Stmt startNoop=soot.jimple.Jimple.v().newNopStmt();
  body.getUnits().add(startNoop);
  createBlock(synchStmt.body());
  soot.jimple.ExitMonitorStmt exitMon=soot.jimple.Jimple.v().newExitMonitorStmt(sootExpr);
  body.getUnits().add(exitMon);
  monitorStack.pop();
  Util.addLnPosTags(exitMon.getOpBox(),synchStmt.expr().position());
  Util.addLnPosTags(exitMon,synchStmt.expr().position());
  soot.jimple.Stmt endSynchNoop=soot.jimple.Jimple.v().newNopStmt();
  soot.jimple.Stmt gotoEnd=soot.jimple.Jimple.v().newGotoStmt(endSynchNoop);
  soot.jimple.Stmt endNoop=soot.jimple.Jimple.v().newNopStmt();
  body.getUnits().add(endNoop);
  body.getUnits().add(gotoEnd);
  soot.jimple.Stmt catchAllBeforeNoop=soot.jimple.Jimple.v().newNopStmt();
  body.getUnits().add(catchAllBeforeNoop);
  soot.Local formalLocal=lg.generateLocal(soot.RefType.v(""String_Node_Str""));
  soot.jimple.CaughtExceptionRef exceptRef=soot.jimple.Jimple.v().newCaughtExceptionRef();
  soot.jimple.Stmt stmt=soot.jimple.Jimple.v().newIdentityStmt(formalLocal,exceptRef);
  body.getUnits().add(stmt);
  soot.jimple.Stmt catchBeforeNoop=soot.jimple.Jimple.v().newNopStmt();
  body.getUnits().add(catchBeforeNoop);
  soot.Local local=lg.generateLocal(soot.RefType.v(""String_Node_Str""));
  soot.jimple.Stmt assign=soot.jimple.Jimple.v().newAssignStmt(local,formalLocal);
  body.getUnits().add(assign);
  soot.jimple.ExitMonitorStmt catchExitMon=soot.jimple.Jimple.v().newExitMonitorStmt(sootExpr);
  body.getUnits().add(catchExitMon);
  Util.addLnPosTags(catchExitMon.getOpBox(),synchStmt.expr().position());
  soot.jimple.Stmt catchAfterNoop=soot.jimple.Jimple.v().newNopStmt();
  body.getUnits().add(catchAfterNoop);
  soot.jimple.Stmt throwStmt=soot.jimple.Jimple.v().newThrowStmt(local);
  body.getUnits().add(throwStmt);
  body.getUnits().add(endSynchNoop);
  addToExceptionList(startNoop,endNoop,catchAllBeforeNoop,soot.Scene.v().getSootClass(""String_Node_Str""));
  addToExceptionList(catchBeforeNoop,catchAfterNoop,catchAllBeforeNoop,soot.Scene.v().getSootClass(""String_Node_Str""));
}"
88589,"private soot.SootMethod addGetFieldAccessMeth(soot.SootClass conClass,polyglot.ast.Field field){
  if ((InitialResolver.v().getPrivateFieldGetAccessMap() != null) && (InitialResolver.v().getPrivateFieldGetAccessMap().containsKey(new polyglot.util.IdentityKey(field.fieldInstance())))) {
    return (soot.SootMethod)InitialResolver.v().getPrivateFieldGetAccessMap().get(new polyglot.util.IdentityKey(field.fieldInstance()));
  }
  String name=""String_Node_Str"" + soot.javaToJimple.InitialResolver.v().getNextPrivateAccessCounter() + ""String_Node_Str"";
  ArrayList paramTypes=new ArrayList();
  if (!field.flags().isStatic()) {
    paramTypes.add(Util.getSootType(field.target().type()));
  }
  soot.SootMethod meth=new soot.SootMethod(name,paramTypes,Util.getSootType(field.type()),soot.Modifier.STATIC);
  PrivateFieldAccMethodSource pfams=new PrivateFieldAccMethodSource(Util.getSootType(field.type()),field.name(),field.flags().isStatic(),conClass);
  conClass.addMethod(meth);
  meth.setActiveBody(pfams.getBody(meth,null));
  InitialResolver.v().addToPrivateFieldGetAccessMap(field,meth);
  return meth;
}","private soot.SootMethod addGetFieldAccessMeth(soot.SootClass conClass,polyglot.ast.Field field){
  if ((InitialResolver.v().getPrivateFieldGetAccessMap() != null) && (InitialResolver.v().getPrivateFieldGetAccessMap().containsKey(new polyglot.util.IdentityKey(field.fieldInstance())))) {
    return (soot.SootMethod)InitialResolver.v().getPrivateFieldGetAccessMap().get(new polyglot.util.IdentityKey(field.fieldInstance()));
  }
  String name=""String_Node_Str"" + soot.javaToJimple.InitialResolver.v().getNextPrivateAccessCounter() + ""String_Node_Str"";
  ArrayList paramTypes=new ArrayList();
  if (!field.flags().isStatic()) {
    paramTypes.add(conClass.getType());
  }
  soot.SootMethod meth=new soot.SootMethod(name,paramTypes,Util.getSootType(field.type()),soot.Modifier.STATIC);
  PrivateFieldAccMethodSource pfams=new PrivateFieldAccMethodSource(Util.getSootType(field.type()),field.name(),field.flags().isStatic(),conClass);
  conClass.addMethod(meth);
  meth.setActiveBody(pfams.getBody(meth,null));
  InitialResolver.v().addToPrivateFieldGetAccessMap(field,meth);
  return meth;
}"
88590,"private soot.SootMethod addGetMethodAccessMeth(soot.SootClass conClass,polyglot.ast.Call call){
  if ((InitialResolver.v().getPrivateMethodGetAccessMap() != null) && (InitialResolver.v().getPrivateMethodGetAccessMap().containsKey(new polyglot.util.IdentityKey(call.methodInstance())))) {
    return (soot.SootMethod)InitialResolver.v().getPrivateMethodGetAccessMap().get(new polyglot.util.IdentityKey(call.methodInstance()));
  }
  String name=""String_Node_Str"" + soot.javaToJimple.InitialResolver.v().getNextPrivateAccessCounter() + ""String_Node_Str"";
  ArrayList paramTypes=new ArrayList();
  if (!call.methodInstance().flags().isStatic()) {
    paramTypes.add(Util.getSootType(call.methodInstance().container()));
  }
  soot.SootMethod meth=new soot.SootMethod(name,paramTypes,Util.getSootType(call.methodInstance().returnType()),soot.Modifier.STATIC);
  PrivateMethodAccMethodSource pmams=new PrivateMethodAccMethodSource(call.methodInstance());
  conClass.addMethod(meth);
  meth.setActiveBody(pmams.getBody(meth,null));
  InitialResolver.v().addToPrivateMethodGetAccessMap(call,meth);
  return meth;
}","private soot.SootMethod addGetMethodAccessMeth(soot.SootClass conClass,polyglot.ast.Call call){
  if ((InitialResolver.v().getPrivateMethodGetAccessMap() != null) && (InitialResolver.v().getPrivateMethodGetAccessMap().containsKey(new polyglot.util.IdentityKey(call.methodInstance())))) {
    return (soot.SootMethod)InitialResolver.v().getPrivateMethodGetAccessMap().get(new polyglot.util.IdentityKey(call.methodInstance()));
  }
  String name=""String_Node_Str"" + soot.javaToJimple.InitialResolver.v().getNextPrivateAccessCounter() + ""String_Node_Str"";
  ArrayList paramTypes=new ArrayList();
  if (!call.methodInstance().flags().isStatic()) {
    paramTypes.add(Util.getSootType(call.methodInstance().container()));
  }
  ArrayList sootParamsTypes=getSootParamsTypes(call);
  paramTypes.addAll(sootParamsTypes);
  soot.SootMethod meth=new soot.SootMethod(name,paramTypes,Util.getSootType(call.methodInstance().returnType()),soot.Modifier.STATIC);
  PrivateMethodAccMethodSource pmams=new PrivateMethodAccMethodSource(call.methodInstance());
  conClass.addMethod(meth);
  meth.setActiveBody(pmams.getBody(meth,null));
  InitialResolver.v().addToPrivateMethodGetAccessMap(call,meth);
  return meth;
}"
88591,"/** 
 * For Inner Classes - to access private fields of their outer class
 */
private soot.Local getPrivateAccessFieldLocal(polyglot.ast.Field field){
  soot.SootMethod toInvoke;
  if (field.fieldInstance().flags().isPrivate()) {
    toInvoke=addGetFieldAccessMeth(((soot.RefType)Util.getSootType(field.fieldInstance().container())).getSootClass(),field);
  }
 else {
    if (InitialResolver.v().hierarchy() == null) {
      InitialResolver.v().hierarchy(new soot.FastHierarchy());
    }
    soot.SootClass addToClass=body.getMethod().getDeclaringClass().getOuterClass();
    soot.SootClass containingClass=((soot.RefType)Util.getSootType(field.fieldInstance().container())).getSootClass();
    while (!InitialResolver.v().hierarchy().canStoreType(containingClass.getType(),addToClass.getType())) {
      if (addToClass.hasOuterClass()) {
        addToClass=addToClass.getOuterClass();
      }
 else {
        break;
      }
    }
    toInvoke=addGetFieldAccessMeth(addToClass,field);
  }
  ArrayList params=new ArrayList();
  if (!field.fieldInstance().flags().isStatic()) {
    params.add((soot.Local)getBaseLocal(field.target()));
  }
  return Util.getPrivateAccessFieldInvoke(toInvoke.makeRef(),params,body,lg);
}","/** 
 * For Inner Classes - to access private fields of their outer class
 */
private soot.Local getPrivateAccessFieldLocal(polyglot.ast.Field field){
  System.out.println(""String_Node_Str"" + field);
  System.out.println(""String_Node_Str"" + field.target().getClass());
  soot.SootMethod toInvoke;
  soot.SootClass invokeClass;
  if (field.fieldInstance().flags().isPrivate()) {
    toInvoke=addGetFieldAccessMeth(((soot.RefType)Util.getSootType(field.fieldInstance().container())).getSootClass(),field);
    invokeClass=((soot.RefType)Util.getSootType(field.fieldInstance().container())).getSootClass();
  }
 else {
    if (InitialResolver.v().hierarchy() == null) {
      InitialResolver.v().hierarchy(new soot.FastHierarchy());
    }
    soot.SootClass containingClass=((soot.RefType)Util.getSootType(field.fieldInstance().container())).getSootClass();
    soot.SootClass addToClass;
    if (body.getMethod().getDeclaringClass().hasOuterClass()) {
      addToClass=body.getMethod().getDeclaringClass().getOuterClass();
      while (!InitialResolver.v().hierarchy().canStoreType(containingClass.getType(),addToClass.getType())) {
        if (addToClass.hasOuterClass()) {
          addToClass=addToClass.getOuterClass();
        }
 else {
          break;
        }
      }
    }
 else {
      addToClass=containingClass;
    }
    invokeClass=addToClass;
    toInvoke=addGetFieldAccessMeth(addToClass,field);
  }
  ArrayList params=new ArrayList();
  if (!field.fieldInstance().flags().isStatic()) {
    if (field.target() instanceof polyglot.ast.Expr) {
      params.add((soot.Local)getBaseLocal(field.target()));
    }
 else     if (body.getMethod().getDeclaringClass().declaresFieldByName(""String_Node_Str"")) {
      params.add(getThis(invokeClass.getType()));
    }
 else {
      soot.Local local=(soot.Local)getBaseLocal(field.target());
      params.add(local);
    }
  }
  return Util.getPrivateAccessFieldInvoke(toInvoke.makeRef(),params,body,lg);
}"
88592,"/** 
 * needs a protected access method if field is protected and in a super class of the outer class of the innerclass trying to access the field (ie not in self or in outer of self)
 */
private boolean needsProtectedAccessor(polyglot.ast.Field field){
  if (field.fieldInstance().flags().isProtected()) {
    if (!Util.getSootType(field.fieldInstance().container()).equals(body.getMethod().getDeclaringClass().getType())) {
      soot.SootClass checkClass=body.getMethod().getDeclaringClass();
      while (checkClass.hasOuterClass()) {
        checkClass=checkClass.getOuterClass();
        if (Util.getSootType(field.fieldInstance().container()).equals(checkClass.getType())) {
          return false;
        }
      }
      return true;
    }
  }
  return false;
}","/** 
 * needs a protected access method if field is protected and in a super class of the outer class of the innerclass trying to access the field (ie not in self or in outer of self)
 */
private boolean needsProtectedAccessor(polyglot.ast.Field field){
  if (field.fieldInstance().flags().isProtected()) {
    if (Util.getSootType(field.fieldInstance().container()).equals(body.getMethod().getDeclaringClass().getType())) {
      return false;
    }
    soot.SootClass currentClass=body.getMethod().getDeclaringClass();
    while (currentClass.hasOuterClass()) {
      currentClass=currentClass.getOuterClass();
      if (Util.getSootType(field.fieldInstance().container()).equals(currentClass.getType())) {
        return false;
      }
 else       if (Util.getSootType(field.fieldInstance().container()).equals(currentClass.getSuperclass().getType())) {
        return true;
      }
    }
    return false;
  }
  return false;
}"
88593,"/** 
 * Call Expression Creation
 */
private soot.Local getCallLocal(polyglot.ast.Call call){
  String name=call.name();
  polyglot.ast.Receiver receiver=call.target();
  soot.Local baseLocal;
  if ((receiver instanceof polyglot.ast.Special) && (((polyglot.ast.Special)receiver).kind() == polyglot.ast.Special.SUPER) && (((polyglot.ast.Special)receiver).qualifier() != null)) {
    baseLocal=getSpecialSuperQualifierLocal(call);
    return baseLocal;
  }
  baseLocal=(soot.Local)getBaseLocal(receiver);
  soot.Type sootRecType=Util.getSootType(receiver.type());
  soot.SootClass receiverTypeClass=soot.Scene.v().getSootClass(""String_Node_Str"");
  if (sootRecType instanceof soot.RefType) {
    receiverTypeClass=((soot.RefType)sootRecType).getSootClass();
  }
  polyglot.types.MethodInstance methodInstance=call.methodInstance();
  soot.Type sootRetType=Util.getSootType(methodInstance.returnType());
  ArrayList sootParamsTypes=getSootParamsTypes(call);
  ArrayList sootParams=getSootParams(call);
  soot.SootMethodRef callMethod=soot.Scene.v().makeMethodRef(receiverTypeClass,methodInstance.name(),sootParamsTypes,sootRetType,methodInstance.flags().isStatic());
  if (receiverTypeClass.isInterface()) {
    callMethod=callMethod.resolve().makeRef();
  }
  boolean isPrivateAccess=false;
  if (call.methodInstance().flags().isPrivate() && !Util.getSootType(call.methodInstance().container()).equals(body.getMethod().getDeclaringClass().getType())) {
    callMethod=addGetMethodAccessMeth(((soot.RefType)Util.getSootType(call.methodInstance().container())).getSootClass(),call).makeRef();
    if (!call.methodInstance().flags().isStatic()) {
      sootParams.add(baseLocal);
    }
    isPrivateAccess=true;
  }
  soot.jimple.InvokeExpr invokeExpr;
  if (isPrivateAccess) {
    invokeExpr=soot.jimple.Jimple.v().newStaticInvokeExpr(callMethod,sootParams);
  }
 else   if (soot.Modifier.isInterface(receiverTypeClass.getModifiers()) && methodInstance.flags().isAbstract()) {
    invokeExpr=soot.jimple.Jimple.v().newInterfaceInvokeExpr(baseLocal,callMethod,sootParams);
  }
 else   if (methodInstance.flags().isStatic()) {
    invokeExpr=soot.jimple.Jimple.v().newStaticInvokeExpr(callMethod,sootParams);
  }
 else   if (methodInstance.flags().isPrivate()) {
    invokeExpr=soot.jimple.Jimple.v().newSpecialInvokeExpr(baseLocal,callMethod,sootParams);
  }
 else   if ((receiver instanceof polyglot.ast.Special) && (((polyglot.ast.Special)receiver).kind() == polyglot.ast.Special.SUPER)) {
    invokeExpr=soot.jimple.Jimple.v().newSpecialInvokeExpr(baseLocal,callMethod,sootParams);
  }
 else {
    invokeExpr=soot.jimple.Jimple.v().newVirtualInvokeExpr(baseLocal,callMethod,sootParams);
  }
  int numParams=0;
  Iterator callParamsIt=call.arguments().iterator();
  while (callParamsIt.hasNext()) {
    Util.addLnPosTags(invokeExpr.getArgBox(numParams),((polyglot.ast.Expr)callParamsIt.next()).position());
    numParams++;
  }
  if (invokeExpr instanceof soot.jimple.InstanceInvokeExpr) {
    Util.addLnPosTags(((soot.jimple.InstanceInvokeExpr)invokeExpr).getBaseBox(),call.target().position());
  }
  if (invokeExpr.getMethodRef().returnType().equals(soot.VoidType.v())) {
    soot.jimple.Stmt invoke=soot.jimple.Jimple.v().newInvokeStmt(invokeExpr);
    body.getUnits().add(invoke);
    Util.addLnPosTags(invoke,call.position());
    return null;
  }
 else {
    soot.Local retLocal=lg.generateLocal(invokeExpr.getMethodRef().returnType());
    soot.jimple.Stmt assignStmt=soot.jimple.Jimple.v().newAssignStmt(retLocal,invokeExpr);
    body.getUnits().add(assignStmt);
    Util.addLnPosTags(assignStmt,call.position());
    return retLocal;
  }
}","/** 
 * Call Expression Creation
 */
private soot.Local getCallLocal(polyglot.ast.Call call){
  String name=call.name();
  polyglot.ast.Receiver receiver=call.target();
  soot.Local baseLocal;
  if ((receiver instanceof polyglot.ast.Special) && (((polyglot.ast.Special)receiver).kind() == polyglot.ast.Special.SUPER) && (((polyglot.ast.Special)receiver).qualifier() != null)) {
    baseLocal=getSpecialSuperQualifierLocal(call);
    return baseLocal;
  }
  baseLocal=(soot.Local)getBaseLocal(receiver);
  soot.Type sootRecType=Util.getSootType(receiver.type());
  soot.SootClass receiverTypeClass=soot.Scene.v().getSootClass(""String_Node_Str"");
  if (sootRecType instanceof soot.RefType) {
    receiverTypeClass=((soot.RefType)sootRecType).getSootClass();
  }
  polyglot.types.MethodInstance methodInstance=call.methodInstance();
  soot.Type sootRetType=Util.getSootType(methodInstance.returnType());
  ArrayList sootParamsTypes=getSootParamsTypes(call);
  ArrayList sootParams=getSootParams(call);
  soot.SootMethodRef callMethod=soot.Scene.v().makeMethodRef(receiverTypeClass,methodInstance.name(),sootParamsTypes,sootRetType,methodInstance.flags().isStatic());
  if (receiverTypeClass.isInterface()) {
    callMethod=callMethod.resolve().makeRef();
  }
  boolean isPrivateAccess=false;
  if (call.methodInstance().flags().isPrivate() && !Util.getSootType(call.methodInstance().container()).equals(body.getMethod().getDeclaringClass().getType())) {
    callMethod=addGetMethodAccessMeth(((soot.RefType)Util.getSootType(call.methodInstance().container())).getSootClass(),call).makeRef();
    if (!call.methodInstance().flags().isStatic()) {
      if (body.getMethod().getDeclaringClass().declaresFieldByName(""String_Node_Str"")) {
        sootParams.add(0,getThis(Util.getSootType(call.methodInstance().container())));
      }
 else {
        sootParams.add(0,baseLocal);
      }
    }
    isPrivateAccess=true;
  }
  soot.jimple.InvokeExpr invokeExpr;
  if (isPrivateAccess) {
    invokeExpr=soot.jimple.Jimple.v().newStaticInvokeExpr(callMethod,sootParams);
  }
 else   if (soot.Modifier.isInterface(receiverTypeClass.getModifiers()) && methodInstance.flags().isAbstract()) {
    invokeExpr=soot.jimple.Jimple.v().newInterfaceInvokeExpr(baseLocal,callMethod,sootParams);
  }
 else   if (methodInstance.flags().isStatic()) {
    invokeExpr=soot.jimple.Jimple.v().newStaticInvokeExpr(callMethod,sootParams);
  }
 else   if (methodInstance.flags().isPrivate()) {
    invokeExpr=soot.jimple.Jimple.v().newSpecialInvokeExpr(baseLocal,callMethod,sootParams);
  }
 else   if ((receiver instanceof polyglot.ast.Special) && (((polyglot.ast.Special)receiver).kind() == polyglot.ast.Special.SUPER)) {
    invokeExpr=soot.jimple.Jimple.v().newSpecialInvokeExpr(baseLocal,callMethod,sootParams);
  }
 else {
    invokeExpr=soot.jimple.Jimple.v().newVirtualInvokeExpr(baseLocal,callMethod,sootParams);
  }
  int numParams=0;
  Iterator callParamsIt=call.arguments().iterator();
  while (callParamsIt.hasNext()) {
    Util.addLnPosTags(invokeExpr.getArgBox(numParams),((polyglot.ast.Expr)callParamsIt.next()).position());
    numParams++;
  }
  if (invokeExpr instanceof soot.jimple.InstanceInvokeExpr) {
    Util.addLnPosTags(((soot.jimple.InstanceInvokeExpr)invokeExpr).getBaseBox(),call.target().position());
  }
  if (invokeExpr.getMethodRef().returnType().equals(soot.VoidType.v())) {
    soot.jimple.Stmt invoke=soot.jimple.Jimple.v().newInvokeStmt(invokeExpr);
    body.getUnits().add(invoke);
    Util.addLnPosTags(invoke,call.position());
    return null;
  }
 else {
    soot.Local retLocal=lg.generateLocal(invokeExpr.getMethodRef().returnType());
    soot.jimple.Stmt assignStmt=soot.jimple.Jimple.v().newAssignStmt(retLocal,invokeExpr);
    body.getUnits().add(assignStmt);
    Util.addLnPosTags(assignStmt,call.position());
    return retLocal;
  }
}"
88594,"private soot.SootMethod addSetAccessMeth(soot.SootClass conClass,polyglot.ast.Field field,soot.Value param){
  if ((InitialResolver.v().getPrivateFieldSetAccessMap() != null) && (InitialResolver.v().getPrivateFieldSetAccessMap().containsKey(new polyglot.util.IdentityKey(field.fieldInstance())))) {
    return (soot.SootMethod)InitialResolver.v().getPrivateFieldSetAccessMap().get(new polyglot.util.IdentityKey(field.fieldInstance()));
  }
  String name=""String_Node_Str"" + soot.javaToJimple.InitialResolver.v().getNextPrivateAccessCounter() + ""String_Node_Str"";
  ArrayList paramTypes=new ArrayList();
  if (!field.flags().isStatic()) {
    paramTypes.add(Util.getSootType(field.target().type()));
  }
  paramTypes.add(param.getType());
  soot.SootMethod meth=new soot.SootMethod(name,paramTypes,param.getType(),soot.Modifier.STATIC);
  PrivateFieldSetMethodSource pfsms=new PrivateFieldSetMethodSource(Util.getSootType(field.type()),field.name(),field.flags().isStatic());
  conClass.addMethod(meth);
  meth.setActiveBody(pfsms.getBody(meth,null));
  InitialResolver.v().addToPrivateFieldSetAccessMap(field,meth);
  return meth;
}","private soot.SootMethod addSetAccessMeth(soot.SootClass conClass,polyglot.ast.Field field,soot.Value param){
  if ((InitialResolver.v().getPrivateFieldSetAccessMap() != null) && (InitialResolver.v().getPrivateFieldSetAccessMap().containsKey(new polyglot.util.IdentityKey(field.fieldInstance())))) {
    return (soot.SootMethod)InitialResolver.v().getPrivateFieldSetAccessMap().get(new polyglot.util.IdentityKey(field.fieldInstance()));
  }
  String name=""String_Node_Str"" + soot.javaToJimple.InitialResolver.v().getNextPrivateAccessCounter() + ""String_Node_Str"";
  ArrayList paramTypes=new ArrayList();
  if (!field.flags().isStatic()) {
    paramTypes.add(conClass.getType());
  }
  paramTypes.add(param.getType());
  soot.SootMethod meth=new soot.SootMethod(name,paramTypes,param.getType(),soot.Modifier.STATIC);
  PrivateFieldSetMethodSource pfsms=new PrivateFieldSetMethodSource(Util.getSootType(field.type()),field.name(),field.flags().isStatic());
  conClass.addMethod(meth);
  meth.setActiveBody(pfsms.getBody(meth,null));
  InitialResolver.v().addToPrivateFieldSetAccessMap(field,meth);
  return meth;
}"
88595,"public LocalUsesChecker(){
  locals=new ArrayList();
  news=new ArrayList();
}","public LocalUsesChecker(){
  locals=new ArrayList();
  localDecls=new ArrayList();
  news=new ArrayList();
}"
88596,"public polyglot.ast.Node leave(polyglot.ast.Node old,polyglot.ast.Node n,polyglot.visit.NodeVisitor visitor){
  if (n instanceof polyglot.ast.Local) {
    if (!(locals.contains(new polyglot.util.IdentityKey(((polyglot.ast.Local)n).localInstance())))) {
      locals.add(new polyglot.util.IdentityKey(((polyglot.ast.Local)n).localInstance()));
    }
  }
  if (n instanceof polyglot.ast.New) {
    news.add(n);
  }
  return n;
}","public polyglot.ast.Node leave(polyglot.ast.Node old,polyglot.ast.Node n,polyglot.visit.NodeVisitor visitor){
  if (n instanceof polyglot.ast.Local) {
    if (!(locals.contains(new polyglot.util.IdentityKey(((polyglot.ast.Local)n).localInstance())))) {
      locals.add(new polyglot.util.IdentityKey(((polyglot.ast.Local)n).localInstance()));
    }
  }
  if (n instanceof polyglot.ast.LocalDecl) {
    localDecls.add(new polyglot.util.IdentityKey(((polyglot.ast.LocalDecl)n).localInstance()));
  }
  if (n instanceof polyglot.ast.Formal) {
    localDecls.add(new polyglot.util.IdentityKey(((polyglot.ast.Formal)n).localInstance()));
  }
  if (n instanceof polyglot.ast.New) {
    news.add(n);
  }
  return n;
}"
88597,"public boolean update(){
  final jedd.internal.RelationContainer newOut=new jedd.internal.RelationContainer(new jedd.Attribute[]{srcc.v(),srcm.v(),stmt.v(),kind.v(),tgtc.v(),tgtm.v()},new jedd.PhysicalDomain[]{C1.v(),MS.v(),ST.v(),KD.v(),C2.v(),MT.v()},(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""),jedd.internal.Jedd.v().copy(jedd.internal.Jedd.v().project(in.get(),new jedd.PhysicalDomain[]{C2.v()}),new jedd.PhysicalDomain[]{ST.v()},new jedd.PhysicalDomain[]{C2.v()}));
  out.add(new jedd.internal.RelationContainer(new jedd.Attribute[]{kind.v(),stmt.v(),srcm.v(),tgtm.v(),srcc.v(),tgtc.v()},new jedd.PhysicalDomain[]{KD.v(),ST.v(),MS.v(),MT.v(),C1.v(),C2.v()},(""String_Node_Str"" + ""String_Node_Str""),newOut));
  return !jedd.internal.Jedd.v().equals(jedd.internal.Jedd.v().read(newOut),jedd.internal.Jedd.v().falseBDD());
}","public boolean update(){
  final jedd.internal.RelationContainer newOut=new jedd.internal.RelationContainer(new jedd.Attribute[]{srcc.v(),srcm.v(),stmt.v(),kind.v(),tgtc.v(),tgtm.v()},new jedd.PhysicalDomain[]{C1.v(),MS.v(),ST.v(),KD.v(),C2.v(),MT.v()},(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""),jedd.internal.Jedd.v().copy(jedd.internal.Jedd.v().replace(jedd.internal.Jedd.v().project(in.get(),new jedd.PhysicalDomain[]{C2.v()}),new jedd.PhysicalDomain[]{ST.v()},new jedd.PhysicalDomain[]{C2.v()}),new jedd.PhysicalDomain[]{C2.v()},new jedd.PhysicalDomain[]{ST.v()}));
  out.add(new jedd.internal.RelationContainer(new jedd.Attribute[]{tgtm.v(),stmt.v(),srcm.v(),srcc.v(),tgtc.v(),kind.v()},new jedd.PhysicalDomain[]{MT.v(),ST.v(),MS.v(),C1.v(),C2.v(),KD.v()},(""String_Node_Str"" + ""String_Node_Str""),newOut));
  return !jedd.internal.Jedd.v().equals(jedd.internal.Jedd.v().read(newOut),jedd.internal.Jedd.v().falseBDD());
}"
88598,"public boolean update(){
  final jedd.internal.RelationContainer newOut=new jedd.internal.RelationContainer(new jedd.Attribute[]{srcc.v(),srcm.v(),stmt.v(),kind.v(),tgtc.v(),tgtm.v()},new jedd.PhysicalDomain[]{C1.v(),MS.v(),ST.v(),KD.v(),C2.v(),MT.v()},(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""),jedd.internal.Jedd.v().copy(jedd.internal.Jedd.v().replace(jedd.internal.Jedd.v().project(in.get(),new jedd.PhysicalDomain[]{V1.v(),H1.v()}),new jedd.PhysicalDomain[]{C2.v()},new jedd.PhysicalDomain[]{C1.v()}),new jedd.PhysicalDomain[]{ST.v()},new jedd.PhysicalDomain[]{C2.v()}));
  out.add(new jedd.internal.RelationContainer(new jedd.Attribute[]{kind.v(),stmt.v(),srcm.v(),tgtm.v(),srcc.v(),tgtc.v()},new jedd.PhysicalDomain[]{KD.v(),ST.v(),MS.v(),MT.v(),C1.v(),C2.v()},(""String_Node_Str"" + ""String_Node_Str""),newOut));
  return !jedd.internal.Jedd.v().equals(jedd.internal.Jedd.v().read(newOut),jedd.internal.Jedd.v().falseBDD());
}","public boolean update(){
  final jedd.internal.RelationContainer newOut=new jedd.internal.RelationContainer(new jedd.Attribute[]{srcc.v(),srcm.v(),stmt.v(),kind.v(),tgtc.v(),tgtm.v()},new jedd.PhysicalDomain[]{C1.v(),MS.v(),ST.v(),KD.v(),C2.v(),MT.v()},(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""),jedd.internal.Jedd.v().copy(jedd.internal.Jedd.v().replace(jedd.internal.Jedd.v().project(in.get(),new jedd.PhysicalDomain[]{V1.v(),H1.v()}),new jedd.PhysicalDomain[]{C2.v()},new jedd.PhysicalDomain[]{C1.v()}),new jedd.PhysicalDomain[]{ST.v()},new jedd.PhysicalDomain[]{C2.v()}));
  out.add(new jedd.internal.RelationContainer(new jedd.Attribute[]{tgtm.v(),stmt.v(),srcm.v(),srcc.v(),tgtc.v(),kind.v()},new jedd.PhysicalDomain[]{MT.v(),ST.v(),MS.v(),C1.v(),C2.v(),KD.v()},(""String_Node_Str"" + ""String_Node_Str""),newOut));
  return !jedd.internal.Jedd.v().equals(jedd.internal.Jedd.v().read(newOut),jedd.internal.Jedd.v().falseBDD());
}"
88599,"public int size(){
  return (int)new jedd.internal.RelationContainer(new jedd.Attribute[]{kind.v(),stmt.v(),srcm.v(),tgtm.v(),srcc.v(),tgtc.v()},new jedd.PhysicalDomain[]{KD.v(),ST.v(),MS.v(),MT.v(),C1.v(),C2.v()},(""String_Node_Str"" + ""String_Node_Str""),edges).size();
}","public int size(){
  return (int)new jedd.internal.RelationContainer(new jedd.Attribute[]{tgtm.v(),stmt.v(),srcm.v(),srcc.v(),tgtc.v(),kind.v()},new jedd.PhysicalDomain[]{MT.v(),ST.v(),MS.v(),C1.v(),C2.v(),KD.v()},(""String_Node_Str"" + ""String_Node_Str""),edges).size();
}"
88600,"public Rsrcc_srcm_stmt_kind_tgtc_tgtm edges(){
  return new Rsrcc_srcm_stmt_kind_tgtc_tgtmBDD(new jedd.internal.RelationContainer(new jedd.Attribute[]{kind.v(),stmt.v(),srcm.v(),tgtm.v(),srcc.v(),tgtc.v()},new jedd.PhysicalDomain[]{KD.v(),ST.v(),MS.v(),MT.v(),C1.v(),C2.v()},(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""),edges),""String_Node_Str"");
}","public Rsrcc_srcm_stmt_kind_tgtc_tgtm edges(){
  return new Rsrcc_srcm_stmt_kind_tgtc_tgtmBDD(new jedd.internal.RelationContainer(new jedd.Attribute[]{tgtm.v(),stmt.v(),srcm.v(),srcc.v(),tgtc.v(),kind.v()},new jedd.PhysicalDomain[]{MT.v(),ST.v(),MS.v(),C1.v(),C2.v(),KD.v()},(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""),edges),""String_Node_Str"");
}"
88601,"public boolean update(){
  final jedd.internal.RelationContainer newEdges=new jedd.internal.RelationContainer(new jedd.Attribute[]{srcc.v(),srcm.v(),stmt.v(),kind.v(),tgtc.v(),tgtm.v()},new jedd.PhysicalDomain[]{C1.v(),MS.v(),ST.v(),KD.v(),C2.v(),MT.v()},(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""),in.get());
  newEdges.eqMinus(edges);
  edges.eqUnion(newEdges);
  out.add(new jedd.internal.RelationContainer(new jedd.Attribute[]{kind.v(),stmt.v(),srcm.v(),tgtm.v(),srcc.v(),tgtc.v()},new jedd.PhysicalDomain[]{KD.v(),ST.v(),MS.v(),MT.v(),C1.v(),C2.v()},(""String_Node_Str"" + ""String_Node_Str""),newEdges));
  return !jedd.internal.Jedd.v().equals(jedd.internal.Jedd.v().read(newEdges),jedd.internal.Jedd.v().falseBDD());
}","public boolean update(){
  final jedd.internal.RelationContainer newEdges=new jedd.internal.RelationContainer(new jedd.Attribute[]{srcc.v(),srcm.v(),stmt.v(),kind.v(),tgtc.v(),tgtm.v()},new jedd.PhysicalDomain[]{C1.v(),MS.v(),ST.v(),KD.v(),C2.v(),MT.v()},(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""),in.get());
  newEdges.eqMinus(edges);
  edges.eqUnion(newEdges);
  out.add(new jedd.internal.RelationContainer(new jedd.Attribute[]{tgtm.v(),stmt.v(),srcm.v(),srcc.v(),tgtc.v(),kind.v()},new jedd.PhysicalDomain[]{MT.v(),ST.v(),MS.v(),C1.v(),C2.v(),KD.v()},(""String_Node_Str"" + ""String_Node_Str""),newEdges));
  return !jedd.internal.Jedd.v().equals(jedd.internal.Jedd.v().read(newEdges),jedd.internal.Jedd.v().falseBDD());
}"
88602,"public Rsrcc_srcm_stmt_kind_tgtc_tgtm edgesOutOf(MethodOrMethodContext m){
  return new Rsrcc_srcm_stmt_kind_tgtc_tgtmBDD(new jedd.internal.RelationContainer(new jedd.Attribute[]{kind.v(),srcm.v(),stmt.v(),tgtm.v(),srcc.v(),tgtc.v()},new jedd.PhysicalDomain[]{KD.v(),MS.v(),ST.v(),MT.v(),C1.v(),C2.v()},(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""),jedd.internal.Jedd.v().join(jedd.internal.Jedd.v().read(edges),jedd.internal.Jedd.v().literal(new Object[]{m.context(),m.method()},new jedd.Attribute[]{ctxt.v(),method.v()},new jedd.PhysicalDomain[]{C1.v(),MS.v()}),new jedd.PhysicalDomain[]{MS.v(),C1.v()})),""String_Node_Str"");
}","public Rsrcc_srcm_stmt_kind_tgtc_tgtm edgesOutOf(MethodOrMethodContext m){
  return new Rsrcc_srcm_stmt_kind_tgtc_tgtmBDD(new jedd.internal.RelationContainer(new jedd.Attribute[]{tgtm.v(),stmt.v(),srcm.v(),srcc.v(),tgtc.v(),kind.v()},new jedd.PhysicalDomain[]{MT.v(),ST.v(),MS.v(),C1.v(),C2.v(),KD.v()},(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""),jedd.internal.Jedd.v().join(jedd.internal.Jedd.v().read(edges),jedd.internal.Jedd.v().literal(new Object[]{m.context(),m.method()},new jedd.Attribute[]{ctxt.v(),method.v()},new jedd.PhysicalDomain[]{C1.v(),MS.v()}),new jedd.PhysicalDomain[]{MS.v(),C1.v()})),""String_Node_Str"");
}"
88603,"jedd.internal.RelationContainer callGraph(){
  return new jedd.internal.RelationContainer(new jedd.Attribute[]{stmt.v(),srcm.v(),tgtm.v()},new jedd.PhysicalDomain[]{ST.v(),MS.v(),MT.v()},(""String_Node_Str"" + ""String_Node_Str""),callGraph);
}","jedd.internal.RelationContainer callGraph(){
  return new jedd.internal.RelationContainer(new jedd.Attribute[]{tgtm.v(),stmt.v(),srcm.v()},new jedd.PhysicalDomain[]{MT.v(),ST.v(),MS.v()},(""String_Node_Str"" + ""String_Node_Str""),callGraph);
}"
88604,"jedd.internal.RelationContainer stmtMethod(){
  return new jedd.internal.RelationContainer(new jedd.Attribute[]{method.v(),stmt.v()},new jedd.PhysicalDomain[]{MT.v(),ST.v()},(""String_Node_Str"" + ""String_Node_Str""),stmtMethod);
}","jedd.internal.RelationContainer stmtMethod(){
  return new jedd.internal.RelationContainer(new jedd.Attribute[]{stmt.v(),method.v()},new jedd.PhysicalDomain[]{ST.v(),MT.v()},(""String_Node_Str"" + ""String_Node_Str""),stmtMethod);
}"
88605,"public boolean update(){
  final jedd.internal.RelationContainer newEdges=new jedd.internal.RelationContainer(new jedd.Attribute[]{srcc.v(),srcm.v(),stmt.v(),kind.v(),tgtc.v(),tgtm.v()},new jedd.PhysicalDomain[]{C1.v(),MS.v(),ST.v(),KD.v(),C2.v(),MT.v()},(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""),edgesIn.get());
  final jedd.internal.RelationContainer newOut=new jedd.internal.RelationContainer(new jedd.Attribute[]{srcc.v(),srcm.v(),stmt.v(),kind.v(),tgtc.v(),tgtm.v()},new jedd.PhysicalDomain[]{C1.v(),MS.v(),ST.v(),KD.v(),C2.v(),MT.v()},(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""),jedd.internal.Jedd.v().join(jedd.internal.Jedd.v().read(jedd.internal.Jedd.v().project(newEdges,new jedd.PhysicalDomain[]{C1.v()})),m2c,new jedd.PhysicalDomain[]{MS.v()}));
  final jedd.internal.RelationContainer methods=new jedd.internal.RelationContainer(new jedd.Attribute[]{ctxt.v(),method.v()},new jedd.PhysicalDomain[]{C1.v(),MS.v()},(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""),methodsIn.get());
  Rsrcc_srcm_stmt_kind_tgtc_tgtm edges=cicg.edgesOutOf(new Rctxt_methodBDD(new jedd.internal.RelationContainer(new jedd.Attribute[]{method.v(),ctxt.v()},new jedd.PhysicalDomain[]{MS.v(),C1.v()},(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""),jedd.internal.Jedd.v().join(jedd.internal.Jedd.v().read(jedd.internal.Jedd.v().project(methods,new jedd.PhysicalDomain[]{C1.v()})),jedd.internal.Jedd.v().literal(new Object[]{null},new jedd.Attribute[]{ctxt.v()},new jedd.PhysicalDomain[]{C1.v()}),new jedd.PhysicalDomain[]{})),""String_Node_Str""));
  newOut.eqUnion(jedd.internal.Jedd.v().join(jedd.internal.Jedd.v().read(jedd.internal.Jedd.v().project(edges.get(),new jedd.PhysicalDomain[]{C1.v()})),methods,new jedd.PhysicalDomain[]{MS.v()}));
  out.add(new jedd.internal.RelationContainer(new jedd.Attribute[]{kind.v(),stmt.v(),srcm.v(),tgtm.v(),srcc.v(),tgtc.v()},new jedd.PhysicalDomain[]{KD.v(),ST.v(),MS.v(),MT.v(),C1.v(),C2.v()},(""String_Node_Str"" + ""String_Node_Str""),newOut));
  m2c.eqUnion(methods);
  return !jedd.internal.Jedd.v().equals(jedd.internal.Jedd.v().read(newOut),jedd.internal.Jedd.v().falseBDD());
}","public boolean update(){
  final jedd.internal.RelationContainer newEdges=new jedd.internal.RelationContainer(new jedd.Attribute[]{srcc.v(),srcm.v(),stmt.v(),kind.v(),tgtc.v(),tgtm.v()},new jedd.PhysicalDomain[]{C1.v(),MS.v(),ST.v(),KD.v(),C2.v(),MT.v()},(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""),edgesIn.get());
  final jedd.internal.RelationContainer newOut=new jedd.internal.RelationContainer(new jedd.Attribute[]{srcc.v(),srcm.v(),stmt.v(),kind.v(),tgtc.v(),tgtm.v()},new jedd.PhysicalDomain[]{C1.v(),MS.v(),ST.v(),KD.v(),C2.v(),MT.v()},(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""),jedd.internal.Jedd.v().join(jedd.internal.Jedd.v().read(jedd.internal.Jedd.v().project(newEdges,new jedd.PhysicalDomain[]{C1.v()})),m2c,new jedd.PhysicalDomain[]{MS.v()}));
  final jedd.internal.RelationContainer methods=new jedd.internal.RelationContainer(new jedd.Attribute[]{ctxt.v(),method.v()},new jedd.PhysicalDomain[]{C1.v(),MS.v()},(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""),methodsIn.get());
  Rsrcc_srcm_stmt_kind_tgtc_tgtm edges=cicg.edgesOutOf(new Rctxt_methodBDD(new jedd.internal.RelationContainer(new jedd.Attribute[]{method.v(),ctxt.v()},new jedd.PhysicalDomain[]{MS.v(),C1.v()},(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""),jedd.internal.Jedd.v().join(jedd.internal.Jedd.v().read(jedd.internal.Jedd.v().project(methods,new jedd.PhysicalDomain[]{C1.v()})),jedd.internal.Jedd.v().literal(new Object[]{null},new jedd.Attribute[]{ctxt.v()},new jedd.PhysicalDomain[]{C1.v()}),new jedd.PhysicalDomain[]{})),""String_Node_Str""));
  newOut.eqUnion(jedd.internal.Jedd.v().join(jedd.internal.Jedd.v().read(jedd.internal.Jedd.v().project(edges.get(),new jedd.PhysicalDomain[]{C1.v()})),methods,new jedd.PhysicalDomain[]{MS.v()}));
  out.add(new jedd.internal.RelationContainer(new jedd.Attribute[]{tgtm.v(),stmt.v(),srcm.v(),srcc.v(),tgtc.v(),kind.v()},new jedd.PhysicalDomain[]{MT.v(),ST.v(),MS.v(),C1.v(),C2.v(),KD.v()},(""String_Node_Str"" + ""String_Node_Str""),newOut));
  m2c.eqUnion(methods);
  return !jedd.internal.Jedd.v().equals(jedd.internal.Jedd.v().read(newOut),jedd.internal.Jedd.v().falseBDD());
}"
88606,"boolean update(){
  final jedd.internal.RelationContainer newEdges=new jedd.internal.RelationContainer(new jedd.Attribute[]{srcm.v(),stmt.v(),kind.v(),tgtm.v()},new jedd.PhysicalDomain[]{MS.v(),ST.v(),KD.v(),MT.v()},(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""),jedd.internal.Jedd.v().project(in.get(),new jedd.PhysicalDomain[]{C1.v(),C2.v()}));
  newEdges.eqMinus(seen);
  seen.eqUnion(newEdges);
  out.add(new jedd.internal.RelationContainer(new jedd.Attribute[]{kind.v(),srcm.v(),stmt.v(),tgtm.v(),srcc.v(),tgtc.v()},new jedd.PhysicalDomain[]{KD.v(),MS.v(),ST.v(),MT.v(),C1.v(),C2.v()},(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""),jedd.internal.Jedd.v().join(jedd.internal.Jedd.v().read(newEdges),jedd.internal.Jedd.v().literal(new Object[]{null,null},new jedd.Attribute[]{srcc.v(),tgtc.v()},new jedd.PhysicalDomain[]{C1.v(),C2.v()}),new jedd.PhysicalDomain[]{})));
  return !jedd.internal.Jedd.v().equals(jedd.internal.Jedd.v().read(newEdges),jedd.internal.Jedd.v().falseBDD());
}","boolean update(){
  final jedd.internal.RelationContainer newEdges=new jedd.internal.RelationContainer(new jedd.Attribute[]{srcm.v(),stmt.v(),kind.v(),tgtm.v()},new jedd.PhysicalDomain[]{MS.v(),ST.v(),KD.v(),MT.v()},(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""),jedd.internal.Jedd.v().project(in.get(),new jedd.PhysicalDomain[]{C1.v(),C2.v()}));
  newEdges.eqMinus(seen);
  seen.eqUnion(newEdges);
  out.add(new jedd.internal.RelationContainer(new jedd.Attribute[]{tgtm.v(),stmt.v(),srcm.v(),kind.v(),srcc.v(),tgtc.v()},new jedd.PhysicalDomain[]{MT.v(),ST.v(),MS.v(),KD.v(),C1.v(),C2.v()},(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""),jedd.internal.Jedd.v().join(jedd.internal.Jedd.v().read(newEdges),jedd.internal.Jedd.v().literal(new Object[]{null,null},new jedd.Attribute[]{srcc.v(),tgtc.v()},new jedd.PhysicalDomain[]{C1.v(),C2.v()}),new jedd.PhysicalDomain[]{})));
  return !jedd.internal.Jedd.v().equals(jedd.internal.Jedd.v().read(newEdges),jedd.internal.Jedd.v().falseBDD());
}"
88607,"public String toString(){
  StringBuffer sb=new StringBuffer();
  sb.append(""String_Node_Str"");
  sb.append(inStaticMethod);
  sb.append(""String_Node_Str"");
  sb.append(finalLocals);
  return sb.toString();
}","public String toString(){
  StringBuffer sb=new StringBuffer();
  sb.append(""String_Node_Str"");
  sb.append(inStaticMethod);
  sb.append(""String_Node_Str"");
  sb.append(finalLocalsAvail);
  sb.append(""String_Node_Str"");
  sb.append(finalLocalsUsed);
  return sb.toString();
}"
88608,"/** 
 * creates the Jimple for an anon class - in the AST there is no class  decl for anon classes - the revelant fields and methods are  created 
 */
private void createAnonClassDecl(polyglot.ast.New aNew){
  SootClass outerClass=((soot.RefType)Util.getSootType(aNew.anonType().outer())).getSootClass();
  if (InitialResolver.v().getInnerClassInfoMap() == null) {
    InitialResolver.v().setInnerClassInfoMap(new HashMap());
  }
  InitialResolver.v().getInnerClassInfoMap().put(sootClass,new InnerClassInfo(outerClass,""String_Node_Str"",InnerClassInfo.ANON));
  sootClass.setOuterClass(outerClass);
  soot.SootClass typeClass=((soot.RefType)Util.getSootType(aNew.objectType().type())).getSootClass();
  if (((polyglot.types.ClassType)aNew.objectType().type()).flags().isInterface()) {
    sootClass.addInterface(typeClass);
    sootClass.setSuperclass(soot.Scene.v().getSootClass(""String_Node_Str""));
  }
 else {
    sootClass.setSuperclass(typeClass);
    if (((polyglot.types.ClassType)aNew.objectType().type()).isNested()) {
      polyglot.types.ClassType superType=(polyglot.types.ClassType)aNew.objectType().type();
      Util.addInnerClassTag(sootClass,typeClass.getName(),((soot.RefType)Util.getSootType(superType.outer())).toString(),superType.name(),Util.getModifier(superType.flags()));
    }
  }
  ArrayList params=new ArrayList();
  soot.SootMethod method;
  if (((polyglot.types.ClassType)aNew.objectType().type()).flags().isInterface()) {
    method=new soot.SootMethod(""String_Node_Str"",params,soot.VoidType.v());
  }
 else {
    Iterator aIt=aNew.arguments().iterator();
    while (aIt.hasNext()) {
      polyglot.types.Type pType=((polyglot.ast.Expr)aIt.next()).type();
      params.add(Util.getSootType(pType));
    }
    method=new soot.SootMethod(""String_Node_Str"",params,soot.VoidType.v());
  }
  AnonClassInitMethodSource src=new AnonClassInitMethodSource();
  method.setSource(src);
  sootClass.addMethod(method);
  AnonLocalClassInfo info=(AnonLocalClassInfo)InitialResolver.v().finalLocalInfo().get(new polyglot.util.IdentityKey(aNew.anonType()));
  if (aNew.qualifier() != null) {
    addQualifierRefToInit(aNew.qualifier().type());
    src.hasQualifier(true);
  }
  if (!info.inStaticMethod()) {
    addOuterClassThisRefToInit(aNew.anonType().outer());
    addOuterClassThisRefField(aNew.anonType().outer());
    src.thisOuterType(Util.getSootType(aNew.anonType().outer()));
    src.hasOuterRef(true);
  }
  src.inStaticMethod(info.inStaticMethod());
  if (info != null) {
    src.setFinalsList(addFinalLocals(aNew.body(),info.finalLocals(),(polyglot.types.ClassType)aNew.anonType(),info));
  }
  src.outerClassType(Util.getSootType(aNew.anonType().outer()));
  if (((polyglot.types.ClassType)aNew.objectType().type()).isNested()) {
    src.superOuterType(Util.getSootType(((polyglot.types.ClassType)aNew.objectType().type()).outer()));
    src.isSubType(Util.isSubType(aNew.anonType().outer(),((polyglot.types.ClassType)aNew.objectType().type()).outer()));
  }
}","/** 
 * creates the Jimple for an anon class - in the AST there is no class  decl for anon classes - the revelant fields and methods are  created 
 */
private void createAnonClassDecl(polyglot.ast.New aNew){
  SootClass outerClass=((soot.RefType)Util.getSootType(aNew.anonType().outer())).getSootClass();
  if (InitialResolver.v().getInnerClassInfoMap() == null) {
    InitialResolver.v().setInnerClassInfoMap(new HashMap());
  }
  InitialResolver.v().getInnerClassInfoMap().put(sootClass,new InnerClassInfo(outerClass,""String_Node_Str"",InnerClassInfo.ANON));
  sootClass.setOuterClass(outerClass);
  soot.SootClass typeClass=((soot.RefType)Util.getSootType(aNew.objectType().type())).getSootClass();
  if (((polyglot.types.ClassType)aNew.objectType().type()).flags().isInterface()) {
    sootClass.addInterface(typeClass);
    sootClass.setSuperclass(soot.Scene.v().getSootClass(""String_Node_Str""));
  }
 else {
    sootClass.setSuperclass(typeClass);
    if (((polyglot.types.ClassType)aNew.objectType().type()).isNested()) {
      polyglot.types.ClassType superType=(polyglot.types.ClassType)aNew.objectType().type();
      Util.addInnerClassTag(sootClass,typeClass.getName(),((soot.RefType)Util.getSootType(superType.outer())).toString(),superType.name(),Util.getModifier(superType.flags()));
    }
  }
  ArrayList params=new ArrayList();
  soot.SootMethod method;
  if (((polyglot.types.ClassType)aNew.objectType().type()).flags().isInterface()) {
    method=new soot.SootMethod(""String_Node_Str"",params,soot.VoidType.v());
  }
 else {
    Iterator aIt=aNew.arguments().iterator();
    while (aIt.hasNext()) {
      polyglot.types.Type pType=((polyglot.ast.Expr)aIt.next()).type();
      params.add(Util.getSootType(pType));
    }
    method=new soot.SootMethod(""String_Node_Str"",params,soot.VoidType.v());
  }
  AnonClassInitMethodSource src=new AnonClassInitMethodSource();
  method.setSource(src);
  sootClass.addMethod(method);
  AnonLocalClassInfo info=(AnonLocalClassInfo)InitialResolver.v().finalLocalInfo().get(new polyglot.util.IdentityKey(aNew.anonType()));
  if (aNew.qualifier() != null) {
    addQualifierRefToInit(aNew.qualifier().type());
    src.hasQualifier(true);
  }
  if (!info.inStaticMethod()) {
    addOuterClassThisRefToInit(aNew.anonType().outer());
    addOuterClassThisRefField(aNew.anonType().outer());
    src.thisOuterType(Util.getSootType(aNew.anonType().outer()));
    src.hasOuterRef(true);
  }
  src.inStaticMethod(info.inStaticMethod());
  if (info != null) {
    src.setFinalsList(addFinalLocals(aNew.body(),info.finalLocalsAvail(),(polyglot.types.ClassType)aNew.anonType(),info));
  }
  src.outerClassType(Util.getSootType(aNew.anonType().outer()));
  if (((polyglot.types.ClassType)aNew.objectType().type()).isNested()) {
    src.superOuterType(Util.getSootType(((polyglot.types.ClassType)aNew.objectType().type()).outer()));
    src.isSubType(Util.isSubType(aNew.anonType().outer(),((polyglot.types.ClassType)aNew.objectType().type()).outer()));
  }
}"
88609,"private ArrayList addFinalLocals(polyglot.ast.ClassBody cBody,ArrayList finalLocals,polyglot.types.ClassType nodeKeyType,AnonLocalClassInfo info){
  ArrayList finalFields=new ArrayList();
  LocalUsesChecker luc=new LocalUsesChecker();
  cBody.visit(luc);
  Iterator localsNeededIt=luc.getLocals().iterator();
  ArrayList localsUsed=new ArrayList();
  while (localsNeededIt.hasNext()) {
    polyglot.types.LocalInstance li=(polyglot.types.LocalInstance)((polyglot.util.IdentityKey)localsNeededIt.next()).object();
    if (finalLocals.contains(new polyglot.util.IdentityKey(li)) && !luc.getLocalDecls().contains(new polyglot.util.IdentityKey(li))) {
      addFinals(li,finalFields);
      localsUsed.add(new polyglot.util.IdentityKey(li));
    }
  }
  Iterator newsIt=luc.getNews().iterator();
  while (newsIt.hasNext()) {
    polyglot.ast.New tempNew=(polyglot.ast.New)newsIt.next();
    polyglot.types.ClassType tempNewType=(polyglot.types.ClassType)tempNew.objectType().type();
    if (InitialResolver.v().finalLocalInfo().containsKey(new polyglot.util.IdentityKey(tempNewType))) {
      AnonLocalClassInfo lInfo=(AnonLocalClassInfo)InitialResolver.v().finalLocalInfo().get(new polyglot.util.IdentityKey(tempNewType));
      Iterator it=lInfo.finalLocals().iterator();
      while (it.hasNext()) {
        polyglot.types.LocalInstance li2=(polyglot.types.LocalInstance)((polyglot.util.IdentityKey)it.next()).object();
        if (!sootClass.declaresField(""String_Node_Str"" + li2.name(),Util.getSootType(li2.type()))) {
          if (!luc.getLocalDecls().contains(new polyglot.util.IdentityKey(li2))) {
            addFinals(li2,finalFields);
            localsUsed.add(new polyglot.util.IdentityKey(li2));
          }
        }
      }
    }
  }
  info.finalLocals(localsUsed);
  InitialResolver.v().finalLocalInfo().put(new polyglot.util.IdentityKey(nodeKeyType),info);
  return finalFields;
}","private ArrayList addFinalLocals(polyglot.ast.ClassBody cBody,ArrayList finalLocalsAvail,polyglot.types.ClassType nodeKeyType,AnonLocalClassInfo info){
  ArrayList finalFields=new ArrayList();
  LocalUsesChecker luc=new LocalUsesChecker();
  cBody.visit(luc);
  Iterator localsNeededIt=luc.getLocals().iterator();
  ArrayList localsUsed=new ArrayList();
  while (localsNeededIt.hasNext()) {
    polyglot.types.LocalInstance li=(polyglot.types.LocalInstance)((polyglot.util.IdentityKey)localsNeededIt.next()).object();
    if (finalLocalsAvail.contains(new polyglot.util.IdentityKey(li)) && !luc.getLocalDecls().contains(new polyglot.util.IdentityKey(li))) {
      addFinals(li,finalFields);
      localsUsed.add(new polyglot.util.IdentityKey(li));
    }
  }
  Iterator newsIt=luc.getNews().iterator();
  while (newsIt.hasNext()) {
    polyglot.ast.New tempNew=(polyglot.ast.New)newsIt.next();
    polyglot.types.ClassType tempNewType=(polyglot.types.ClassType)tempNew.objectType().type();
    if (InitialResolver.v().finalLocalInfo().containsKey(new polyglot.util.IdentityKey(tempNewType))) {
      AnonLocalClassInfo lInfo=(AnonLocalClassInfo)InitialResolver.v().finalLocalInfo().get(new polyglot.util.IdentityKey(tempNewType));
      Iterator it=lInfo.finalLocalsAvail().iterator();
      while (it.hasNext()) {
        polyglot.types.LocalInstance li2=(polyglot.types.LocalInstance)((polyglot.util.IdentityKey)it.next()).object();
        if (!sootClass.declaresField(""String_Node_Str"" + li2.name(),Util.getSootType(li2.type()))) {
          if (!luc.getLocalDecls().contains(new polyglot.util.IdentityKey(li2))) {
            addFinals(li2,finalFields);
            localsUsed.add(new polyglot.util.IdentityKey(li2));
          }
        }
      }
    }
  }
  info.finalLocalsUsed(localsUsed);
  InitialResolver.v().finalLocalInfo().put(new polyglot.util.IdentityKey(nodeKeyType),info);
  return finalFields;
}"
88610,"/** 
 * Class Declaration Creation
 */
private void createClassDecl(polyglot.ast.ClassDecl cDecl){
  if (!cDecl.type().isTopLevel()) {
    SootClass outerClass=((soot.RefType)Util.getSootType(cDecl.type().outer())).getSootClass();
    if (InitialResolver.v().getInnerClassInfoMap() == null) {
      InitialResolver.v().setInnerClassInfoMap(new HashMap());
    }
    InitialResolver.v().getInnerClassInfoMap().put(sootClass,new InnerClassInfo(outerClass,cDecl.name(),InnerClassInfo.NESTED));
    sootClass.setOuterClass(outerClass);
  }
  polyglot.types.Flags flags=cDecl.flags();
  addModifiers(flags,cDecl);
  if (cDecl.superClass() == null) {
    soot.SootClass superClass=soot.Scene.v().getSootClass(""String_Node_Str"");
    sootClass.setSuperclass(superClass);
  }
 else {
    sootClass.setSuperclass(((soot.RefType)Util.getSootType(cDecl.superClass().type())).getSootClass());
    if (((polyglot.types.ClassType)cDecl.superClass().type()).isNested()) {
      polyglot.types.ClassType superType=(polyglot.types.ClassType)cDecl.superClass().type();
      Util.addInnerClassTag(sootClass,sootClass.getName(),((soot.RefType)Util.getSootType(superType.outer())).toString(),superType.name(),Util.getModifier(superType.flags()));
    }
  }
  Iterator interfacesIt=cDecl.interfaces().iterator();
  while (interfacesIt.hasNext()) {
    polyglot.ast.TypeNode next=(polyglot.ast.TypeNode)interfacesIt.next();
    sootClass.addInterface(((soot.RefType)Util.getSootType(next.type())).getSootClass());
  }
  findReferences(cDecl);
  createClassBody(cDecl.body());
  handleFieldInits();
  if ((staticFieldInits != null) || (staticInitializerBlocks != null)) {
    soot.SootMethod clinitMethod;
    if (!sootClass.declaresMethod(""String_Node_Str"",new ArrayList(),soot.VoidType.v())) {
      clinitMethod=new soot.SootMethod(""String_Node_Str"",new ArrayList(),soot.VoidType.v(),soot.Modifier.STATIC,new ArrayList());
      sootClass.addMethod(clinitMethod);
      PolyglotMethodSource mSource=new PolyglotMethodSource();
      mSource.setJBB(InitialResolver.v().getJBBFactory().createJimpleBodyBuilder());
      clinitMethod.setSource(mSource);
    }
 else {
      clinitMethod=sootClass.getMethod(""String_Node_Str"",new ArrayList(),soot.VoidType.v());
    }
    ((PolyglotMethodSource)clinitMethod.getSource()).setStaticFieldInits(staticFieldInits);
    ((PolyglotMethodSource)clinitMethod.getSource()).setStaticInitializerBlocks(staticInitializerBlocks);
  }
  if (cDecl.type().isLocal()) {
    AnonLocalClassInfo info=(AnonLocalClassInfo)InitialResolver.v().finalLocalInfo().get(new polyglot.util.IdentityKey(cDecl.type()));
    ArrayList finalsList=addFinalLocals(cDecl.body(),info.finalLocals(),cDecl.type(),info);
    Iterator it=sootClass.getMethods().iterator();
    while (it.hasNext()) {
      soot.SootMethod meth=(soot.SootMethod)it.next();
      if (meth.getName().equals(""String_Node_Str"")) {
        ((PolyglotMethodSource)meth.getSource()).setFinalsList(finalsList);
      }
    }
    if (!info.inStaticMethod()) {
      polyglot.types.ClassType outerType=cDecl.type().outer();
      addOuterClassThisRefToInit(outerType);
      addOuterClassThisRefField(outerType);
    }
  }
 else   if (cDecl.type().isNested() && !cDecl.flags().isStatic()) {
    polyglot.types.ClassType outerType=cDecl.type().outer();
    addOuterClassThisRefToInit(outerType);
    addOuterClassThisRefField(outerType);
  }
  Util.addLnPosTags(sootClass,cDecl.position());
}","/** 
 * Class Declaration Creation
 */
private void createClassDecl(polyglot.ast.ClassDecl cDecl){
  if (!cDecl.type().isTopLevel()) {
    SootClass outerClass=((soot.RefType)Util.getSootType(cDecl.type().outer())).getSootClass();
    if (InitialResolver.v().getInnerClassInfoMap() == null) {
      InitialResolver.v().setInnerClassInfoMap(new HashMap());
    }
    InitialResolver.v().getInnerClassInfoMap().put(sootClass,new InnerClassInfo(outerClass,cDecl.name(),InnerClassInfo.NESTED));
    sootClass.setOuterClass(outerClass);
  }
  polyglot.types.Flags flags=cDecl.flags();
  addModifiers(flags,cDecl);
  if (cDecl.superClass() == null) {
    soot.SootClass superClass=soot.Scene.v().getSootClass(""String_Node_Str"");
    sootClass.setSuperclass(superClass);
  }
 else {
    sootClass.setSuperclass(((soot.RefType)Util.getSootType(cDecl.superClass().type())).getSootClass());
    if (((polyglot.types.ClassType)cDecl.superClass().type()).isNested()) {
      polyglot.types.ClassType superType=(polyglot.types.ClassType)cDecl.superClass().type();
      Util.addInnerClassTag(sootClass,sootClass.getName(),((soot.RefType)Util.getSootType(superType.outer())).toString(),superType.name(),Util.getModifier(superType.flags()));
    }
  }
  Iterator interfacesIt=cDecl.interfaces().iterator();
  while (interfacesIt.hasNext()) {
    polyglot.ast.TypeNode next=(polyglot.ast.TypeNode)interfacesIt.next();
    sootClass.addInterface(((soot.RefType)Util.getSootType(next.type())).getSootClass());
  }
  findReferences(cDecl);
  createClassBody(cDecl.body());
  handleFieldInits();
  if ((staticFieldInits != null) || (staticInitializerBlocks != null)) {
    soot.SootMethod clinitMethod;
    if (!sootClass.declaresMethod(""String_Node_Str"",new ArrayList(),soot.VoidType.v())) {
      clinitMethod=new soot.SootMethod(""String_Node_Str"",new ArrayList(),soot.VoidType.v(),soot.Modifier.STATIC,new ArrayList());
      sootClass.addMethod(clinitMethod);
      PolyglotMethodSource mSource=new PolyglotMethodSource();
      mSource.setJBB(InitialResolver.v().getJBBFactory().createJimpleBodyBuilder());
      clinitMethod.setSource(mSource);
    }
 else {
      clinitMethod=sootClass.getMethod(""String_Node_Str"",new ArrayList(),soot.VoidType.v());
    }
    ((PolyglotMethodSource)clinitMethod.getSource()).setStaticFieldInits(staticFieldInits);
    ((PolyglotMethodSource)clinitMethod.getSource()).setStaticInitializerBlocks(staticInitializerBlocks);
  }
  if (cDecl.type().isLocal()) {
    AnonLocalClassInfo info=(AnonLocalClassInfo)InitialResolver.v().finalLocalInfo().get(new polyglot.util.IdentityKey(cDecl.type()));
    ArrayList finalsList=addFinalLocals(cDecl.body(),info.finalLocalsAvail(),cDecl.type(),info);
    Iterator it=sootClass.getMethods().iterator();
    while (it.hasNext()) {
      soot.SootMethod meth=(soot.SootMethod)it.next();
      if (meth.getName().equals(""String_Node_Str"")) {
        ((PolyglotMethodSource)meth.getSource()).setFinalsList(finalsList);
      }
    }
    if (!info.inStaticMethod()) {
      polyglot.types.ClassType outerType=cDecl.type().outer();
      addOuterClassThisRefToInit(outerType);
      addOuterClassThisRefField(outerType);
    }
  }
 else   if (cDecl.type().isNested() && !cDecl.flags().isStatic()) {
    polyglot.types.ClassType outerType=cDecl.type().outer();
    addOuterClassThisRefToInit(outerType);
    addOuterClassThisRefField(outerType);
  }
  Util.addLnPosTags(sootClass,cDecl.position());
}"
88611,"private void handleFinalLocals(polyglot.ast.ClassMember member){
  MethodFinalsChecker mfc=new MethodFinalsChecker();
  member.visit(mfc);
  AnonLocalClassInfo alci=new AnonLocalClassInfo();
  if (member instanceof polyglot.ast.ProcedureDecl) {
    polyglot.ast.ProcedureDecl procedure=(polyglot.ast.ProcedureDecl)member;
    alci.finalLocals(mfc.finalLocals());
    if (procedure.flags().isStatic()) {
      alci.inStaticMethod(true);
    }
  }
 else   if (member instanceof polyglot.ast.FieldDecl) {
    alci.finalLocals(new ArrayList());
    if (((polyglot.ast.FieldDecl)member).flags().isStatic()) {
      alci.inStaticMethod(true);
    }
  }
 else   if (member instanceof polyglot.ast.Initializer) {
    alci.finalLocals(mfc.finalLocals());
    if (((polyglot.ast.Initializer)member).flags().isStatic()) {
      alci.inStaticMethod(true);
    }
  }
  if (finalLocalInfo == null) {
    finalLocalInfo=new HashMap();
  }
  Iterator it=mfc.inners().iterator();
  while (it.hasNext()) {
    polyglot.types.ClassType cType=(polyglot.types.ClassType)((polyglot.util.IdentityKey)it.next()).object();
    AnonLocalClassInfo info=new AnonLocalClassInfo();
    info.inStaticMethod(alci.inStaticMethod());
    info.finalLocals(alci.finalLocals());
    finalLocalInfo.put(new polyglot.util.IdentityKey(cType),info);
  }
}","private void handleFinalLocals(polyglot.ast.ClassMember member){
  MethodFinalsChecker mfc=new MethodFinalsChecker();
  member.visit(mfc);
  AnonLocalClassInfo alci=new AnonLocalClassInfo();
  if (member instanceof polyglot.ast.ProcedureDecl) {
    polyglot.ast.ProcedureDecl procedure=(polyglot.ast.ProcedureDecl)member;
    alci.finalLocalsAvail(mfc.finalLocals());
    if (procedure.flags().isStatic()) {
      alci.inStaticMethod(true);
    }
  }
 else   if (member instanceof polyglot.ast.FieldDecl) {
    alci.finalLocalsAvail(new ArrayList());
    if (((polyglot.ast.FieldDecl)member).flags().isStatic()) {
      alci.inStaticMethod(true);
    }
  }
 else   if (member instanceof polyglot.ast.Initializer) {
    alci.finalLocalsAvail(mfc.finalLocals());
    if (((polyglot.ast.Initializer)member).flags().isStatic()) {
      alci.inStaticMethod(true);
    }
  }
  if (finalLocalInfo == null) {
    finalLocalInfo=new HashMap();
  }
  Iterator it=mfc.inners().iterator();
  while (it.hasNext()) {
    polyglot.types.ClassType cType=(polyglot.types.ClassType)((polyglot.util.IdentityKey)it.next()).object();
    AnonLocalClassInfo info=new AnonLocalClassInfo();
    info.inStaticMethod(alci.inStaticMethod());
    info.finalLocalsAvail(alci.finalLocalsAvail());
    if (!finalLocalInfo.containsKey(new polyglot.util.IdentityKey(cType))) {
      finalLocalInfo.put(new polyglot.util.IdentityKey(cType),info);
    }
  }
}"
88612,"private soot.Local handlePrivateFieldSet(polyglot.ast.Assign assign){
  polyglot.ast.Field fLeft=(polyglot.ast.Field)assign.left();
  soot.Value right;
  if (assign.operator() == polyglot.ast.Assign.ASSIGN) {
    right=getSimpleAssignRightLocal(assign);
  }
 else   if ((assign.operator() == polyglot.ast.Assign.ADD_ASSIGN) && assign.type().toString().equals(""String_Node_Str"")) {
    right=getStringConcatAssignRightLocal(assign);
  }
 else {
    soot.Local leftLocal=(soot.Local)getFieldLocal(fLeft);
    right=getAssignRightLocal(assign,leftLocal);
  }
  soot.SootClass containClass=((soot.RefType)Util.getSootType(fLeft.target().type())).getSootClass();
  soot.SootMethod methToUse=addSetAccessMeth(containClass,fLeft,right);
  ArrayList params=new ArrayList();
  if (!fLeft.flags().isStatic()) {
    params.add(getThis(Util.getSootType(fLeft.target().type())));
  }
  params.add(right);
  soot.jimple.InvokeExpr invoke=soot.jimple.Jimple.v().newStaticInvokeExpr(methToUse.makeRef(),params);
  soot.Local retLocal=lg.generateLocal(right.getType());
  soot.jimple.AssignStmt assignStmt=soot.jimple.Jimple.v().newAssignStmt(retLocal,invoke);
  body.getUnits().add(assignStmt);
  return retLocal;
}","private soot.Local handlePrivateFieldSet(polyglot.ast.Field fLeft,soot.Value right){
  soot.SootClass containClass=((soot.RefType)Util.getSootType(fLeft.target().type())).getSootClass();
  soot.SootMethod methToUse=addSetAccessMeth(containClass,fLeft,right);
  ArrayList params=new ArrayList();
  if (!fLeft.flags().isStatic()) {
    params.add(getThis(Util.getSootType(fLeft.target().type())));
  }
  params.add(right);
  soot.jimple.InvokeExpr invoke=soot.jimple.Jimple.v().newStaticInvokeExpr(methToUse.makeRef(),params);
  soot.Local retLocal=lg.generateLocal(right.getType());
  soot.jimple.AssignStmt assignStmt=soot.jimple.Jimple.v().newAssignStmt(retLocal,invoke);
  body.getUnits().add(assignStmt);
  return retLocal;
}"
88613,"/** 
 * Unary Expression Creation
 */
private soot.Local getUnaryLocal(polyglot.ast.Unary unary){
  polyglot.ast.Expr expr=unary.expr();
  polyglot.ast.Unary.Operator op=unary.operator();
  if (op == polyglot.ast.Unary.POST_INC) {
    soot.Local retLocal=generateLocal(expr.type());
    soot.Value sootExpr=base().createExpr(expr);
    soot.jimple.AssignStmt preStmt=soot.jimple.Jimple.v().newAssignStmt(retLocal,sootExpr);
    body.getUnits().add(preStmt);
    soot.jimple.AddExpr addExpr=soot.jimple.Jimple.v().newAddExpr(sootExpr,getConstant(retLocal.getType(),1));
    Util.addLnPosTags(addExpr.getOp1Box(),expr.position());
    soot.Local local=generateLocal(expr.type());
    soot.jimple.AssignStmt stmt=soot.jimple.Jimple.v().newAssignStmt(local,addExpr);
    body.getUnits().add(stmt);
    Util.addLnPosTags(stmt,expr.position());
    soot.jimple.AssignStmt aStmt=soot.jimple.Jimple.v().newAssignStmt(sootExpr,local);
    body.getUnits().add(aStmt);
    Util.addLnPosTags(aStmt,expr.position());
    Util.addLnPosTags(aStmt,unary.position());
    if ((expr instanceof polyglot.ast.Field) || (expr instanceof polyglot.ast.ArrayAccess)) {
      soot.Value actualUnaryExpr=createLHS(expr);
      soot.jimple.AssignStmt s=soot.jimple.Jimple.v().newAssignStmt(actualUnaryExpr,local);
      body.getUnits().add(s);
      Util.addLnPosTags(s,expr.position());
      Util.addLnPosTags(s.getLeftOpBox(),expr.position());
    }
    return retLocal;
  }
 else   if (op == polyglot.ast.Unary.POST_DEC) {
    soot.Local retLocal=generateLocal(expr.type());
    soot.Value sootExpr=base().createExpr(expr);
    soot.jimple.AssignStmt preStmt=soot.jimple.Jimple.v().newAssignStmt(retLocal,sootExpr);
    body.getUnits().add(preStmt);
    soot.jimple.SubExpr subExpr=soot.jimple.Jimple.v().newSubExpr(sootExpr,getConstant(retLocal.getType(),1));
    Util.addLnPosTags(subExpr.getOp1Box(),expr.position());
    soot.Local local=generateLocal(expr.type());
    soot.jimple.AssignStmt stmt=soot.jimple.Jimple.v().newAssignStmt(local,subExpr);
    body.getUnits().add(stmt);
    Util.addLnPosTags(stmt,expr.position());
    soot.jimple.AssignStmt aStmt=soot.jimple.Jimple.v().newAssignStmt(sootExpr,local);
    body.getUnits().add(aStmt);
    Util.addLnPosTags(aStmt,expr.position());
    Util.addLnPosTags(aStmt,unary.position());
    if ((expr instanceof polyglot.ast.Field) || (expr instanceof polyglot.ast.ArrayAccess)) {
      soot.Value actualUnaryExpr=createLHS(expr);
      soot.jimple.AssignStmt s=soot.jimple.Jimple.v().newAssignStmt(actualUnaryExpr,local);
      body.getUnits().add(s);
      Util.addLnPosTags(s,expr.position());
      Util.addLnPosTags(s.getLeftOpBox(),expr.position());
    }
    return retLocal;
  }
 else   if (op == polyglot.ast.Unary.PRE_INC) {
    soot.Value sootExpr=base().createExpr(expr);
    soot.jimple.AddExpr addExpr=soot.jimple.Jimple.v().newAddExpr(sootExpr,getConstant(sootExpr.getType(),1));
    Util.addLnPosTags(addExpr.getOp1Box(),expr.position());
    soot.Local local=generateLocal(expr.type());
    soot.jimple.AssignStmt stmt=soot.jimple.Jimple.v().newAssignStmt(local,addExpr);
    body.getUnits().add(stmt);
    Util.addLnPosTags(stmt,expr.position());
    if ((expr instanceof polyglot.ast.Field) || (expr instanceof polyglot.ast.ArrayAccess) || (expr instanceof polyglot.ast.Local)) {
      soot.Value actualUnaryExpr=createLHS(expr);
      body.getUnits().add(soot.jimple.Jimple.v().newAssignStmt(actualUnaryExpr,local));
    }
    return local;
  }
 else   if (op == polyglot.ast.Unary.PRE_DEC) {
    soot.Value sootExpr=base().createExpr(expr);
    soot.jimple.SubExpr subExpr=soot.jimple.Jimple.v().newSubExpr(sootExpr,getConstant(sootExpr.getType(),1));
    Util.addLnPosTags(subExpr.getOp1Box(),expr.position());
    soot.Local local=generateLocal(expr.type());
    soot.jimple.AssignStmt stmt=soot.jimple.Jimple.v().newAssignStmt(local,subExpr);
    body.getUnits().add(stmt);
    Util.addLnPosTags(stmt,expr.position());
    if ((expr instanceof polyglot.ast.Field) || (expr instanceof polyglot.ast.ArrayAccess) || (expr instanceof polyglot.ast.Local)) {
      soot.Value actualUnaryExpr=createLHS(expr);
      body.getUnits().add(soot.jimple.Jimple.v().newAssignStmt(actualUnaryExpr,local));
    }
    return local;
  }
 else   if (op == polyglot.ast.Unary.BIT_NOT) {
    soot.jimple.IntConstant int1=soot.jimple.IntConstant.v(-1);
    soot.Local retLocal=generateLocal(expr.type());
    soot.Value sootExpr=base().createExpr(expr);
    soot.jimple.XorExpr xor=soot.jimple.Jimple.v().newXorExpr(sootExpr,getConstant(sootExpr.getType(),-1));
    Util.addLnPosTags(xor.getOp1Box(),expr.position());
    soot.jimple.Stmt assign1=soot.jimple.Jimple.v().newAssignStmt(retLocal,xor);
    body.getUnits().add(assign1);
    Util.addLnPosTags(assign1,unary.position());
    return retLocal;
  }
 else   if (op == polyglot.ast.Unary.NEG) {
    soot.Value sootExpr;
    if (expr instanceof polyglot.ast.NumLit) {
      int intVal=(int)((polyglot.ast.NumLit)expr).longValue();
      sootExpr=soot.jimple.IntConstant.v(-intVal);
    }
 else     if (expr instanceof polyglot.ast.FloatLit) {
      double doubleVal=((polyglot.ast.FloatLit)expr).value();
      if (((polyglot.ast.FloatLit)expr).kind() == polyglot.ast.FloatLit.DOUBLE) {
        sootExpr=soot.jimple.DoubleConstant.v(-doubleVal);
      }
 else {
        sootExpr=soot.jimple.FloatConstant.v(-(float)doubleVal);
      }
    }
 else {
      soot.Value local=base().createExpr(expr);
      soot.jimple.NegExpr negExpr=soot.jimple.Jimple.v().newNegExpr(local);
      sootExpr=negExpr;
      Util.addLnPosTags(negExpr.getOpBox(),expr.position());
    }
    soot.Local retLocal=generateLocal(expr.type());
    soot.jimple.Stmt assign=soot.jimple.Jimple.v().newAssignStmt(retLocal,sootExpr);
    body.getUnits().add(assign);
    Util.addLnPosTags(assign,expr.position());
    return retLocal;
  }
 else   if (op == polyglot.ast.Unary.POS) {
    soot.Local retLocal=generateLocal(expr.type());
    soot.Value sootExpr=base().createExpr(expr);
    soot.jimple.Stmt assign=soot.jimple.Jimple.v().newAssignStmt(retLocal,sootExpr);
    body.getUnits().add(assign);
    Util.addLnPosTags(assign,expr.position());
    return retLocal;
  }
 else   if (op == polyglot.ast.Unary.NOT) {
    soot.Value local=base().createExpr(expr);
    if (local instanceof soot.jimple.ConditionExpr) {
      local=handleCondBinExpr((soot.jimple.ConditionExpr)local);
    }
    soot.jimple.NeExpr neExpr=soot.jimple.Jimple.v().newNeExpr(local,getConstant(local.getType(),0));
    soot.jimple.Stmt noop1=soot.jimple.Jimple.v().newNopStmt();
    soot.jimple.Stmt ifStmt=soot.jimple.Jimple.v().newIfStmt(neExpr,noop1);
    body.getUnits().add(ifStmt);
    Util.addLnPosTags(ifStmt,expr.position());
    soot.Local retLocal=lg.generateLocal(local.getType());
    soot.jimple.Stmt assign1=soot.jimple.Jimple.v().newAssignStmt(retLocal,getConstant(retLocal.getType(),1));
    body.getUnits().add(assign1);
    Util.addLnPosTags(assign1,expr.position());
    soot.jimple.Stmt noop2=soot.jimple.Jimple.v().newNopStmt();
    soot.jimple.Stmt goto1=soot.jimple.Jimple.v().newGotoStmt(noop2);
    body.getUnits().add(goto1);
    body.getUnits().add(noop1);
    soot.jimple.Stmt assign2=soot.jimple.Jimple.v().newAssignStmt(retLocal,getConstant(retLocal.getType(),0));
    body.getUnits().add(assign2);
    Util.addLnPosTags(assign2,expr.position());
    body.getUnits().add(noop2);
    return retLocal;
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
}","/** 
 * Unary Expression Creation
 */
private soot.Local getUnaryLocal(polyglot.ast.Unary unary){
  polyglot.ast.Expr expr=unary.expr();
  polyglot.ast.Unary.Operator op=unary.operator();
  if (op == polyglot.ast.Unary.POST_INC) {
    soot.Local retLocal=generateLocal(expr.type());
    soot.Value sootExpr=base().createExpr(expr);
    soot.jimple.AssignStmt preStmt=soot.jimple.Jimple.v().newAssignStmt(retLocal,sootExpr);
    body.getUnits().add(preStmt);
    soot.jimple.AddExpr addExpr=soot.jimple.Jimple.v().newAddExpr(sootExpr,getConstant(retLocal.getType(),1));
    Util.addLnPosTags(addExpr.getOp1Box(),expr.position());
    soot.Local local=generateLocal(expr.type());
    soot.jimple.AssignStmt stmt=soot.jimple.Jimple.v().newAssignStmt(local,addExpr);
    body.getUnits().add(stmt);
    Util.addLnPosTags(stmt,expr.position());
    soot.jimple.AssignStmt aStmt=soot.jimple.Jimple.v().newAssignStmt(sootExpr,local);
    body.getUnits().add(aStmt);
    Util.addLnPosTags(aStmt,expr.position());
    Util.addLnPosTags(aStmt,unary.position());
    if ((expr instanceof polyglot.ast.Field) || (expr instanceof polyglot.ast.ArrayAccess)) {
      if ((expr instanceof polyglot.ast.Field) && (needsPrivateAccessor((polyglot.ast.Field)expr) || needsProtectedAccessor((polyglot.ast.Field)expr))) {
        handlePrivateFieldSet((polyglot.ast.Field)expr,local);
      }
 else {
        soot.Value actualUnaryExpr=createLHS(expr);
        soot.jimple.AssignStmt s=soot.jimple.Jimple.v().newAssignStmt(actualUnaryExpr,local);
        body.getUnits().add(s);
        Util.addLnPosTags(s,expr.position());
        Util.addLnPosTags(s.getLeftOpBox(),expr.position());
      }
    }
    return retLocal;
  }
 else   if (op == polyglot.ast.Unary.POST_DEC) {
    soot.Local retLocal=generateLocal(expr.type());
    soot.Value sootExpr=base().createExpr(expr);
    soot.jimple.AssignStmt preStmt=soot.jimple.Jimple.v().newAssignStmt(retLocal,sootExpr);
    body.getUnits().add(preStmt);
    soot.jimple.SubExpr subExpr=soot.jimple.Jimple.v().newSubExpr(sootExpr,getConstant(retLocal.getType(),1));
    Util.addLnPosTags(subExpr.getOp1Box(),expr.position());
    soot.Local local=generateLocal(expr.type());
    soot.jimple.AssignStmt stmt=soot.jimple.Jimple.v().newAssignStmt(local,subExpr);
    body.getUnits().add(stmt);
    Util.addLnPosTags(stmt,expr.position());
    soot.jimple.AssignStmt aStmt=soot.jimple.Jimple.v().newAssignStmt(sootExpr,local);
    body.getUnits().add(aStmt);
    Util.addLnPosTags(aStmt,expr.position());
    Util.addLnPosTags(aStmt,unary.position());
    if ((expr instanceof polyglot.ast.Field) || (expr instanceof polyglot.ast.ArrayAccess)) {
      if ((expr instanceof polyglot.ast.Field) && (needsPrivateAccessor((polyglot.ast.Field)expr) || needsProtectedAccessor((polyglot.ast.Field)expr))) {
        handlePrivateFieldSet((polyglot.ast.Field)expr,local);
      }
 else {
        soot.Value actualUnaryExpr=createLHS(expr);
        soot.jimple.AssignStmt s=soot.jimple.Jimple.v().newAssignStmt(actualUnaryExpr,local);
        body.getUnits().add(s);
        Util.addLnPosTags(s,expr.position());
        Util.addLnPosTags(s.getLeftOpBox(),expr.position());
      }
    }
    return retLocal;
  }
 else   if (op == polyglot.ast.Unary.PRE_INC) {
    soot.Value sootExpr=base().createExpr(expr);
    soot.jimple.AddExpr addExpr=soot.jimple.Jimple.v().newAddExpr(sootExpr,getConstant(sootExpr.getType(),1));
    Util.addLnPosTags(addExpr.getOp1Box(),expr.position());
    soot.Local local=generateLocal(expr.type());
    soot.jimple.AssignStmt stmt=soot.jimple.Jimple.v().newAssignStmt(local,addExpr);
    body.getUnits().add(stmt);
    Util.addLnPosTags(stmt,expr.position());
    if ((expr instanceof polyglot.ast.Field) || (expr instanceof polyglot.ast.ArrayAccess) || (expr instanceof polyglot.ast.Local)) {
      if ((expr instanceof polyglot.ast.Field) && (needsPrivateAccessor((polyglot.ast.Field)expr) || needsProtectedAccessor((polyglot.ast.Field)expr))) {
        handlePrivateFieldSet((polyglot.ast.Field)expr,local);
      }
 else {
        soot.Value actualUnaryExpr=createLHS(expr);
        body.getUnits().add(soot.jimple.Jimple.v().newAssignStmt(actualUnaryExpr,local));
      }
    }
    return local;
  }
 else   if (op == polyglot.ast.Unary.PRE_DEC) {
    soot.Value sootExpr=base().createExpr(expr);
    soot.jimple.SubExpr subExpr=soot.jimple.Jimple.v().newSubExpr(sootExpr,getConstant(sootExpr.getType(),1));
    Util.addLnPosTags(subExpr.getOp1Box(),expr.position());
    soot.Local local=generateLocal(expr.type());
    soot.jimple.AssignStmt stmt=soot.jimple.Jimple.v().newAssignStmt(local,subExpr);
    body.getUnits().add(stmt);
    Util.addLnPosTags(stmt,expr.position());
    if ((expr instanceof polyglot.ast.Field) || (expr instanceof polyglot.ast.ArrayAccess) || (expr instanceof polyglot.ast.Local)) {
      if ((expr instanceof polyglot.ast.Field) && (needsPrivateAccessor((polyglot.ast.Field)expr) || needsProtectedAccessor((polyglot.ast.Field)expr))) {
        handlePrivateFieldSet((polyglot.ast.Field)expr,local);
      }
 else {
        soot.Value actualUnaryExpr=createLHS(expr);
        body.getUnits().add(soot.jimple.Jimple.v().newAssignStmt(actualUnaryExpr,local));
      }
    }
    return local;
  }
 else   if (op == polyglot.ast.Unary.BIT_NOT) {
    soot.jimple.IntConstant int1=soot.jimple.IntConstant.v(-1);
    soot.Local retLocal=generateLocal(expr.type());
    soot.Value sootExpr=base().createExpr(expr);
    soot.jimple.XorExpr xor=soot.jimple.Jimple.v().newXorExpr(sootExpr,getConstant(sootExpr.getType(),-1));
    Util.addLnPosTags(xor.getOp1Box(),expr.position());
    soot.jimple.Stmt assign1=soot.jimple.Jimple.v().newAssignStmt(retLocal,xor);
    body.getUnits().add(assign1);
    Util.addLnPosTags(assign1,unary.position());
    return retLocal;
  }
 else   if (op == polyglot.ast.Unary.NEG) {
    soot.Value sootExpr;
    if (expr instanceof polyglot.ast.NumLit) {
      int intVal=(int)((polyglot.ast.NumLit)expr).longValue();
      sootExpr=soot.jimple.IntConstant.v(-intVal);
    }
 else     if (expr instanceof polyglot.ast.FloatLit) {
      double doubleVal=((polyglot.ast.FloatLit)expr).value();
      if (((polyglot.ast.FloatLit)expr).kind() == polyglot.ast.FloatLit.DOUBLE) {
        sootExpr=soot.jimple.DoubleConstant.v(-doubleVal);
      }
 else {
        sootExpr=soot.jimple.FloatConstant.v(-(float)doubleVal);
      }
    }
 else {
      soot.Value local=base().createExpr(expr);
      soot.jimple.NegExpr negExpr=soot.jimple.Jimple.v().newNegExpr(local);
      sootExpr=negExpr;
      Util.addLnPosTags(negExpr.getOpBox(),expr.position());
    }
    soot.Local retLocal=generateLocal(expr.type());
    soot.jimple.Stmt assign=soot.jimple.Jimple.v().newAssignStmt(retLocal,sootExpr);
    body.getUnits().add(assign);
    Util.addLnPosTags(assign,expr.position());
    return retLocal;
  }
 else   if (op == polyglot.ast.Unary.POS) {
    soot.Local retLocal=generateLocal(expr.type());
    soot.Value sootExpr=base().createExpr(expr);
    soot.jimple.Stmt assign=soot.jimple.Jimple.v().newAssignStmt(retLocal,sootExpr);
    body.getUnits().add(assign);
    Util.addLnPosTags(assign,expr.position());
    return retLocal;
  }
 else   if (op == polyglot.ast.Unary.NOT) {
    soot.Value local=base().createExpr(expr);
    if (local instanceof soot.jimple.ConditionExpr) {
      local=handleCondBinExpr((soot.jimple.ConditionExpr)local);
    }
    soot.jimple.NeExpr neExpr=soot.jimple.Jimple.v().newNeExpr(local,getConstant(local.getType(),0));
    soot.jimple.Stmt noop1=soot.jimple.Jimple.v().newNopStmt();
    soot.jimple.Stmt ifStmt=soot.jimple.Jimple.v().newIfStmt(neExpr,noop1);
    body.getUnits().add(ifStmt);
    Util.addLnPosTags(ifStmt,expr.position());
    soot.Local retLocal=lg.generateLocal(local.getType());
    soot.jimple.Stmt assign1=soot.jimple.Jimple.v().newAssignStmt(retLocal,getConstant(retLocal.getType(),1));
    body.getUnits().add(assign1);
    Util.addLnPosTags(assign1,expr.position());
    soot.jimple.Stmt noop2=soot.jimple.Jimple.v().newNopStmt();
    soot.jimple.Stmt goto1=soot.jimple.Jimple.v().newGotoStmt(noop2);
    body.getUnits().add(goto1);
    body.getUnits().add(noop1);
    soot.jimple.Stmt assign2=soot.jimple.Jimple.v().newAssignStmt(retLocal,getConstant(retLocal.getType(),0));
    body.getUnits().add(assign2);
    Util.addLnPosTags(assign2,expr.position());
    body.getUnits().add(noop2);
    return retLocal;
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
}"
88614,"/** 
 * Adds extra params
 */
private void handleFinalLocalParams(ArrayList sootParams,ArrayList sootParamTypes,polyglot.types.ClassType keyType){
  HashMap finalLocalInfo=soot.javaToJimple.InitialResolver.v().finalLocalInfo();
  if (finalLocalInfo != null) {
    if (finalLocalInfo.containsKey(new polyglot.util.IdentityKey(keyType))) {
      AnonLocalClassInfo alci=(AnonLocalClassInfo)finalLocalInfo.get(new polyglot.util.IdentityKey(keyType));
      ArrayList finalLocals=alci.finalLocals();
      if (finalLocals != null) {
        Iterator it=finalLocals.iterator();
        while (it.hasNext()) {
          polyglot.types.LocalInstance li=(polyglot.types.LocalInstance)((polyglot.util.IdentityKey)it.next()).object();
          sootParamTypes.add(Util.getSootType(li.type()));
          sootParams.add(getLocal(li));
        }
      }
    }
  }
}","/** 
 * Adds extra params
 */
private void handleFinalLocalParams(ArrayList sootParams,ArrayList sootParamTypes,polyglot.types.ClassType keyType){
  HashMap finalLocalInfo=soot.javaToJimple.InitialResolver.v().finalLocalInfo();
  System.out.println(""String_Node_Str"" + finalLocalInfo);
  if (finalLocalInfo != null) {
    if (finalLocalInfo.containsKey(new polyglot.util.IdentityKey(keyType))) {
      AnonLocalClassInfo alci=(AnonLocalClassInfo)finalLocalInfo.get(new polyglot.util.IdentityKey(keyType));
      ArrayList finalLocals=alci.finalLocalsUsed();
      System.out.println(""String_Node_Str"" + Util.getSootType(keyType) + ""String_Node_Str""+ finalLocals);
      if (finalLocals != null) {
        Iterator it=finalLocals.iterator();
        while (it.hasNext()) {
          polyglot.types.LocalInstance li=(polyglot.types.LocalInstance)((polyglot.util.IdentityKey)it.next()).object();
          sootParamTypes.add(Util.getSootType(li.type()));
          sootParams.add(getLocal(li));
        }
      }
    }
  }
}"
88615,"/** 
 * New Expression Creation
 */
private soot.Local getNewLocal(polyglot.ast.New newExpr){
  ArrayList sootParams=new ArrayList();
  ArrayList sootParamsTypes=new ArrayList();
  polyglot.types.ClassType objType=(polyglot.types.ClassType)newExpr.objectType().type();
  if (newExpr.anonType() != null) {
    objType=newExpr.anonType();
    String name=Util.getSootType(objType).toString();
    polyglot.types.ClassType outerType=objType.outer();
    if (!InitialResolver.v().hasClassInnerTag(body.getMethod().getDeclaringClass(),name)) {
      Util.addInnerClassTag(body.getMethod().getDeclaringClass(),name,null,null,outerType.flags().isInterface() ? soot.Modifier.PUBLIC | soot.Modifier.STATIC : Util.getModifier(objType.flags()));
    }
  }
 else {
    if (!objType.isTopLevel()) {
      String name=Util.getSootType(objType).toString();
      polyglot.types.ClassType outerType=objType.outer();
      if (!InitialResolver.v().hasClassInnerTag(body.getMethod().getDeclaringClass(),name)) {
        Util.addInnerClassTag(body.getMethod().getDeclaringClass(),name,Util.getSootType(outerType).toString(),objType.name(),outerType.flags().isInterface() ? soot.Modifier.PUBLIC | soot.Modifier.STATIC : Util.getModifier(objType.flags()));
      }
    }
  }
  soot.RefType sootType=(soot.RefType)Util.getSootType(objType);
  soot.Local retLocal=lg.generateLocal(sootType);
  soot.jimple.NewExpr sootNew=soot.jimple.Jimple.v().newNewExpr(sootType);
  soot.jimple.Stmt stmt=soot.jimple.Jimple.v().newAssignStmt(retLocal,sootNew);
  body.getUnits().add(stmt);
  Util.addLnPosTags(stmt,newExpr.position());
  soot.SootClass classToInvoke=sootType.getSootClass();
  soot.Value qVal=null;
  if (newExpr.qualifier() != null) {
    qVal=base().createExpr(newExpr.qualifier());
  }
  handleOuterClassParams(sootParams,qVal,sootParamsTypes,objType);
  sootParams.addAll(getSootParams(newExpr));
  sootParamsTypes.addAll(getSootParamsTypes(newExpr));
  handleFinalLocalParams(sootParams,sootParamsTypes,(polyglot.types.ClassType)objType);
  soot.SootMethodRef methodToInvoke=getMethodFromClass(classToInvoke,""String_Node_Str"",sootParamsTypes,soot.VoidType.v(),false);
  soot.jimple.SpecialInvokeExpr specialInvokeExpr=soot.jimple.Jimple.v().newSpecialInvokeExpr(retLocal,methodToInvoke,sootParams);
  soot.jimple.Stmt invokeStmt=soot.jimple.Jimple.v().newInvokeStmt(specialInvokeExpr);
  body.getUnits().add(invokeStmt);
  Util.addLnPosTags(invokeStmt,newExpr.position());
  int numParams=0;
  Iterator invokeParamsIt=newExpr.arguments().iterator();
  while (invokeParamsIt.hasNext()) {
    Util.addLnPosTags(specialInvokeExpr.getArgBox(numParams),((polyglot.ast.Expr)invokeParamsIt.next()).position());
    numParams++;
  }
  return retLocal;
}","/** 
 * New Expression Creation
 */
private soot.Local getNewLocal(polyglot.ast.New newExpr){
  ArrayList sootParams=new ArrayList();
  ArrayList sootParamsTypes=new ArrayList();
  polyglot.types.ClassType objType=(polyglot.types.ClassType)newExpr.objectType().type();
  if (newExpr.anonType() != null) {
    objType=newExpr.anonType();
    String name=Util.getSootType(objType).toString();
    polyglot.types.ClassType outerType=objType.outer();
    if (!InitialResolver.v().hasClassInnerTag(body.getMethod().getDeclaringClass(),name)) {
      Util.addInnerClassTag(body.getMethod().getDeclaringClass(),name,null,null,outerType.flags().isInterface() ? soot.Modifier.PUBLIC | soot.Modifier.STATIC : Util.getModifier(objType.flags()));
    }
  }
 else {
    if (!objType.isTopLevel()) {
      String name=Util.getSootType(objType).toString();
      polyglot.types.ClassType outerType=objType.outer();
      if (!InitialResolver.v().hasClassInnerTag(body.getMethod().getDeclaringClass(),name)) {
        Util.addInnerClassTag(body.getMethod().getDeclaringClass(),name,Util.getSootType(outerType).toString(),objType.name(),outerType.flags().isInterface() ? soot.Modifier.PUBLIC | soot.Modifier.STATIC : Util.getModifier(objType.flags()));
      }
    }
  }
  soot.RefType sootType=(soot.RefType)Util.getSootType(objType);
  soot.Local retLocal=lg.generateLocal(sootType);
  soot.jimple.NewExpr sootNew=soot.jimple.Jimple.v().newNewExpr(sootType);
  soot.jimple.Stmt stmt=soot.jimple.Jimple.v().newAssignStmt(retLocal,sootNew);
  body.getUnits().add(stmt);
  Util.addLnPosTags(stmt,newExpr.position());
  soot.SootClass classToInvoke=sootType.getSootClass();
  soot.Value qVal=null;
  if (newExpr.qualifier() != null) {
    qVal=base().createExpr(newExpr.qualifier());
  }
  handleOuterClassParams(sootParams,qVal,sootParamsTypes,objType);
  sootParams.addAll(getSootParams(newExpr));
  sootParamsTypes.addAll(getSootParamsTypes(newExpr));
  handleFinalLocalParams(sootParams,sootParamsTypes,(polyglot.types.ClassType)objType);
  System.out.println(""String_Node_Str"" + classToInvoke + ""String_Node_Str""+ sootParamsTypes);
  soot.SootMethodRef methodToInvoke=getMethodFromClass(classToInvoke,""String_Node_Str"",sootParamsTypes,soot.VoidType.v(),false);
  soot.jimple.SpecialInvokeExpr specialInvokeExpr=soot.jimple.Jimple.v().newSpecialInvokeExpr(retLocal,methodToInvoke,sootParams);
  soot.jimple.Stmt invokeStmt=soot.jimple.Jimple.v().newInvokeStmt(specialInvokeExpr);
  body.getUnits().add(invokeStmt);
  Util.addLnPosTags(invokeStmt,newExpr.position());
  int numParams=0;
  Iterator invokeParamsIt=newExpr.arguments().iterator();
  while (invokeParamsIt.hasNext()) {
    Util.addLnPosTags(specialInvokeExpr.getArgBox(numParams),((polyglot.ast.Expr)invokeParamsIt.next()).position());
    numParams++;
  }
  return retLocal;
}"
88616,"/** 
 * Assign Expression Creation
 */
private soot.Value getAssignLocal(polyglot.ast.Assign assign){
  if ((assign.left() instanceof polyglot.ast.Field) && (needsPrivateAccessor((polyglot.ast.Field)assign.left()) || needsProtectedAccessor((polyglot.ast.Field)assign.left()))) {
    return handlePrivateFieldSet(assign);
  }
  if (assign.operator() == polyglot.ast.Assign.ASSIGN) {
    return getSimpleAssignLocal(assign);
  }
  if ((assign.operator() == polyglot.ast.Assign.ADD_ASSIGN) && assign.type().toString().equals(""String_Node_Str"")) {
    return getStrConAssignLocal(assign);
  }
  soot.jimple.AssignStmt stmt;
  soot.Value left=createLHS(assign.left());
  soot.Value left2=(soot.Value)left.clone();
  soot.Local leftLocal;
  if (left instanceof soot.Local) {
    leftLocal=(soot.Local)left;
  }
 else {
    leftLocal=lg.generateLocal(left.getType());
    soot.jimple.AssignStmt stmt1=soot.jimple.Jimple.v().newAssignStmt(leftLocal,left);
    body.getUnits().add(stmt1);
    Util.addLnPosTags(stmt1,assign.position());
  }
  soot.Value right=getAssignRightLocal(assign,leftLocal);
  soot.jimple.AssignStmt stmt2=soot.jimple.Jimple.v().newAssignStmt(leftLocal,right);
  body.getUnits().add(stmt2);
  Util.addLnPosTags(stmt2,assign.position());
  Util.addLnPosTags(stmt2.getRightOpBox(),assign.right().position());
  Util.addLnPosTags(stmt2.getLeftOpBox(),assign.left().position());
  if (!(left instanceof soot.Local)) {
    soot.jimple.AssignStmt stmt3=soot.jimple.Jimple.v().newAssignStmt(left2,leftLocal);
    body.getUnits().add(stmt3);
    Util.addLnPosTags(stmt3,assign.position());
    Util.addLnPosTags(stmt3.getRightOpBox(),assign.right().position());
    Util.addLnPosTags(stmt3.getLeftOpBox(),assign.left().position());
  }
  return leftLocal;
}","/** 
 * Assign Expression Creation
 */
private soot.Value getAssignLocal(polyglot.ast.Assign assign){
  if ((assign.left() instanceof polyglot.ast.Field) && (needsPrivateAccessor((polyglot.ast.Field)assign.left()) || needsProtectedAccessor((polyglot.ast.Field)assign.left()))) {
    return handlePrivateFieldAssignSet(assign);
  }
  if (assign.operator() == polyglot.ast.Assign.ASSIGN) {
    return getSimpleAssignLocal(assign);
  }
  if ((assign.operator() == polyglot.ast.Assign.ADD_ASSIGN) && assign.type().toString().equals(""String_Node_Str"")) {
    return getStrConAssignLocal(assign);
  }
  soot.jimple.AssignStmt stmt;
  soot.Value left=createLHS(assign.left());
  soot.Value left2=(soot.Value)left.clone();
  soot.Local leftLocal;
  if (left instanceof soot.Local) {
    leftLocal=(soot.Local)left;
  }
 else {
    leftLocal=lg.generateLocal(left.getType());
    soot.jimple.AssignStmt stmt1=soot.jimple.Jimple.v().newAssignStmt(leftLocal,left);
    body.getUnits().add(stmt1);
    Util.addLnPosTags(stmt1,assign.position());
  }
  soot.Value right=getAssignRightLocal(assign,leftLocal);
  soot.jimple.AssignStmt stmt2=soot.jimple.Jimple.v().newAssignStmt(leftLocal,right);
  body.getUnits().add(stmt2);
  Util.addLnPosTags(stmt2,assign.position());
  Util.addLnPosTags(stmt2.getRightOpBox(),assign.right().position());
  Util.addLnPosTags(stmt2.getLeftOpBox(),assign.left().position());
  if (!(left instanceof soot.Local)) {
    soot.jimple.AssignStmt stmt3=soot.jimple.Jimple.v().newAssignStmt(left2,leftLocal);
    body.getUnits().add(stmt3);
    Util.addLnPosTags(stmt3,assign.position());
    Util.addLnPosTags(stmt3.getRightOpBox(),assign.right().position());
    Util.addLnPosTags(stmt3.getLeftOpBox(),assign.left().position());
  }
  return leftLocal;
}"
88617,"/** 
 * creates the Jimple for an anon class - in the AST there is no class  decl for anon classes - the revelant fields and methods are  created 
 */
private void createAnonClassDecl(polyglot.ast.New aNew){
  SootClass outerClass=((soot.RefType)Util.getSootType(aNew.anonType().outer())).getSootClass();
  sootClass.addTag(new soot.tagkit.OuterClassTag(outerClass,""String_Node_Str"",true));
  soot.SootClass typeClass=((soot.RefType)Util.getSootType(aNew.objectType().type())).getSootClass();
  if (((polyglot.types.ClassType)aNew.objectType().type()).flags().isInterface()) {
    sootClass.addInterface(typeClass);
    sootClass.setSuperclass(soot.Scene.v().getSootClass(""String_Node_Str""));
  }
 else {
    sootClass.setSuperclass(typeClass);
    if (((polyglot.types.ClassType)aNew.objectType().type()).isNested()) {
      polyglot.types.ClassType superType=(polyglot.types.ClassType)aNew.objectType().type();
      Util.addInnerClassTag(sootClass,typeClass.getName(),((soot.RefType)Util.getSootType(superType.outer())).toString(),superType.name(),Util.getModifier(superType.flags()));
    }
  }
  ArrayList params=new ArrayList();
  soot.SootMethod method;
  if (((polyglot.types.ClassType)aNew.objectType().type()).flags().isInterface()) {
    method=new soot.SootMethod(""String_Node_Str"",params,soot.VoidType.v());
  }
 else {
    Iterator aIt=aNew.arguments().iterator();
    while (aIt.hasNext()) {
      polyglot.types.Type pType=((polyglot.ast.Expr)aIt.next()).type();
      params.add(Util.getSootType(pType));
    }
    method=new soot.SootMethod(""String_Node_Str"",params,soot.VoidType.v());
  }
  AnonClassInitMethodSource src=new AnonClassInitMethodSource();
  method.setSource(src);
  sootClass.addMethod(method);
  AnonLocalClassInfo info=(AnonLocalClassInfo)finalLocalInfo.get(new polyglot.util.IdentityKey(aNew.anonType()));
  if (aNew.qualifier() != null) {
    addQualifierRefToInit(aNew.qualifier().type());
    src.hasQualifier(true);
  }
  if (!info.inStaticMethod()) {
    addOuterClassThisRefToInit(aNew.anonType().outer());
    addOuterClassThisRefField(aNew.anonType().outer());
    src.thisOuterType(Util.getSootType(aNew.anonType().outer()));
    src.hasOuterRef(true);
  }
  src.inStaticMethod(info.inStaticMethod());
  if (info != null) {
    src.setFinalsList(addFinalLocals(aNew.body(),info.finalLocals(),(polyglot.types.ClassType)aNew.anonType(),info));
  }
  src.outerClassType(Util.getSootType(aNew.anonType().outer()));
  if (((polyglot.types.ClassType)aNew.objectType().type()).isNested()) {
    src.superOuterType(Util.getSootType(((polyglot.types.ClassType)aNew.objectType().type()).outer()));
    src.isSubType(Util.isSubType(aNew.anonType().outer(),((polyglot.types.ClassType)aNew.objectType().type()).outer()));
  }
}","/** 
 * creates the Jimple for an anon class - in the AST there is no class  decl for anon classes - the revelant fields and methods are  created 
 */
private void createAnonClassDecl(polyglot.ast.New aNew){
  SootClass outerClass=((soot.RefType)Util.getSootType(aNew.anonType().outer())).getSootClass();
  if (innerClassInfoMap == null) {
    innerClassInfoMap=new HashMap();
  }
  innerClassInfoMap.put(sootClass,new InnerClassInfo(outerClass,""String_Node_Str"",InnerClassInfo.ANON));
  soot.SootClass typeClass=((soot.RefType)Util.getSootType(aNew.objectType().type())).getSootClass();
  if (((polyglot.types.ClassType)aNew.objectType().type()).flags().isInterface()) {
    sootClass.addInterface(typeClass);
    sootClass.setSuperclass(soot.Scene.v().getSootClass(""String_Node_Str""));
  }
 else {
    sootClass.setSuperclass(typeClass);
    if (((polyglot.types.ClassType)aNew.objectType().type()).isNested()) {
      polyglot.types.ClassType superType=(polyglot.types.ClassType)aNew.objectType().type();
      Util.addInnerClassTag(sootClass,typeClass.getName(),((soot.RefType)Util.getSootType(superType.outer())).toString(),superType.name(),Util.getModifier(superType.flags()));
    }
  }
  ArrayList params=new ArrayList();
  soot.SootMethod method;
  if (((polyglot.types.ClassType)aNew.objectType().type()).flags().isInterface()) {
    method=new soot.SootMethod(""String_Node_Str"",params,soot.VoidType.v());
  }
 else {
    Iterator aIt=aNew.arguments().iterator();
    while (aIt.hasNext()) {
      polyglot.types.Type pType=((polyglot.ast.Expr)aIt.next()).type();
      params.add(Util.getSootType(pType));
    }
    method=new soot.SootMethod(""String_Node_Str"",params,soot.VoidType.v());
  }
  AnonClassInitMethodSource src=new AnonClassInitMethodSource();
  method.setSource(src);
  sootClass.addMethod(method);
  AnonLocalClassInfo info=(AnonLocalClassInfo)finalLocalInfo.get(new polyglot.util.IdentityKey(aNew.anonType()));
  if (aNew.qualifier() != null) {
    addQualifierRefToInit(aNew.qualifier().type());
    src.hasQualifier(true);
  }
  if (!info.inStaticMethod()) {
    addOuterClassThisRefToInit(aNew.anonType().outer());
    addOuterClassThisRefField(aNew.anonType().outer());
    src.thisOuterType(Util.getSootType(aNew.anonType().outer()));
    src.hasOuterRef(true);
  }
  src.inStaticMethod(info.inStaticMethod());
  if (info != null) {
    src.setFinalsList(addFinalLocals(aNew.body(),info.finalLocals(),(polyglot.types.ClassType)aNew.anonType(),info));
  }
  src.outerClassType(Util.getSootType(aNew.anonType().outer()));
  if (((polyglot.types.ClassType)aNew.objectType().type()).isNested()) {
    src.superOuterType(Util.getSootType(((polyglot.types.ClassType)aNew.objectType().type()).outer()));
    src.isSubType(Util.isSubType(aNew.anonType().outer(),((polyglot.types.ClassType)aNew.objectType().type()).outer()));
  }
}"
88618,"/** 
 * Class Body Creation
 */
private void createClassBody(polyglot.ast.ClassBody classBody){
  staticFieldInits=null;
  fieldInits=null;
  initializerBlocks=null;
  staticInitializerBlocks=null;
  handleClassLiteral(classBody);
  handleAssert(classBody);
  Iterator it=classBody.members().iterator();
  while (it.hasNext()) {
    Object next=it.next();
    if (next instanceof polyglot.ast.MethodDecl) {
      createMethodDecl((polyglot.ast.MethodDecl)next);
    }
 else     if (next instanceof polyglot.ast.FieldDecl) {
      createFieldDecl((polyglot.ast.FieldDecl)next);
    }
 else     if (next instanceof polyglot.ast.ConstructorDecl) {
      createConstructorDecl((polyglot.ast.ConstructorDecl)next);
    }
 else     if (next instanceof polyglot.ast.ClassDecl) {
      Util.addInnerClassTag(sootClass,Util.getSootType(((polyglot.ast.ClassDecl)next).type()).toString(),sootClass.getName(),((polyglot.ast.ClassDecl)next).name().toString(),Util.getModifier(((polyglot.ast.ClassDecl)next).flags()));
    }
 else     if (next instanceof polyglot.ast.Initializer) {
      createInitializer((polyglot.ast.Initializer)next);
    }
 else {
      throw new RuntimeException(""String_Node_Str"");
    }
  }
  handlePrivateAccessors(classBody);
  handleInnerClassTags(classBody);
}","/** 
 * Class Body Creation
 */
private void createClassBody(polyglot.ast.ClassBody classBody){
  staticFieldInits=null;
  fieldInits=null;
  initializerBlocks=null;
  staticInitializerBlocks=null;
  Iterator it=classBody.members().iterator();
  while (it.hasNext()) {
    Object next=it.next();
    if (next instanceof polyglot.ast.MethodDecl) {
      createMethodDecl((polyglot.ast.MethodDecl)next);
    }
 else     if (next instanceof polyglot.ast.FieldDecl) {
      createFieldDecl((polyglot.ast.FieldDecl)next);
    }
 else     if (next instanceof polyglot.ast.ConstructorDecl) {
      createConstructorDecl((polyglot.ast.ConstructorDecl)next);
    }
 else     if (next instanceof polyglot.ast.ClassDecl) {
      Util.addInnerClassTag(sootClass,Util.getSootType(((polyglot.ast.ClassDecl)next).type()).toString(),sootClass.getName(),((polyglot.ast.ClassDecl)next).name().toString(),Util.getModifier(((polyglot.ast.ClassDecl)next).flags()));
    }
 else     if (next instanceof polyglot.ast.Initializer) {
      createInitializer((polyglot.ast.Initializer)next);
    }
 else {
      throw new RuntimeException(""String_Node_Str"");
    }
  }
  handlePrivateAccessors(classBody);
  handleInnerClassTags(classBody);
  handleClassLiteral(classBody);
  handleAssert(classBody);
}"
88619,"/** 
 * Class Declaration Creation
 */
private void createClassDecl(polyglot.ast.ClassDecl cDecl){
  if (!cDecl.type().isTopLevel()) {
    SootClass outerClass=((soot.RefType)Util.getSootType(cDecl.type().outer())).getSootClass();
    sootClass.addTag(new soot.tagkit.OuterClassTag(outerClass,cDecl.name(),false));
  }
  polyglot.types.Flags flags=cDecl.flags();
  addModifiers(flags,cDecl);
  if (cDecl.superClass() == null) {
    soot.SootClass superClass=soot.Scene.v().getSootClass(""String_Node_Str"");
    sootClass.setSuperclass(superClass);
  }
 else {
    sootClass.setSuperclass(((soot.RefType)Util.getSootType(cDecl.superClass().type())).getSootClass());
    if (((polyglot.types.ClassType)cDecl.superClass().type()).isNested()) {
      polyglot.types.ClassType superType=(polyglot.types.ClassType)cDecl.superClass().type();
      Util.addInnerClassTag(sootClass,sootClass.getName(),((soot.RefType)Util.getSootType(superType.outer())).toString(),superType.name(),Util.getModifier(superType.flags()));
    }
  }
  Iterator interfacesIt=cDecl.interfaces().iterator();
  while (interfacesIt.hasNext()) {
    polyglot.ast.TypeNode next=(polyglot.ast.TypeNode)interfacesIt.next();
    sootClass.addInterface(((soot.RefType)Util.getSootType(next.type())).getSootClass());
  }
  currentClassDeclPos=cDecl.position();
  createClassBody(cDecl.body());
  handleFieldInits();
  if ((staticFieldInits != null) || (staticInitializerBlocks != null)) {
    soot.SootMethod clinitMethod;
    if (!sootClass.declaresMethod(""String_Node_Str"",new ArrayList(),soot.VoidType.v())) {
      clinitMethod=new soot.SootMethod(""String_Node_Str"",new ArrayList(),soot.VoidType.v(),soot.Modifier.STATIC,new ArrayList());
      sootClass.addMethod(clinitMethod);
      clinitMethod.setSource(new soot.javaToJimple.PolyglotMethodSource());
    }
 else {
      clinitMethod=sootClass.getMethod(""String_Node_Str"",new ArrayList(),soot.VoidType.v());
    }
    ((PolyglotMethodSource)clinitMethod.getSource()).setStaticFieldInits(staticFieldInits);
    ((PolyglotMethodSource)clinitMethod.getSource()).setStaticInitializerBlocks(staticInitializerBlocks);
  }
  if (cDecl.type().isLocal()) {
    AnonLocalClassInfo info=(AnonLocalClassInfo)finalLocalInfo.get(new polyglot.util.IdentityKey(cDecl.type()));
    ArrayList finalsList=addFinalLocals(cDecl.body(),info.finalLocals(),cDecl.type(),info);
    Iterator it=sootClass.getMethods().iterator();
    while (it.hasNext()) {
      soot.SootMethod meth=(soot.SootMethod)it.next();
      if (meth.getName().equals(""String_Node_Str"")) {
        ((PolyglotMethodSource)meth.getSource()).setFinalsList(finalsList);
      }
    }
    if (!info.inStaticMethod()) {
      polyglot.types.ClassType outerType=cDecl.type().outer();
      addOuterClassThisRefToInit(outerType);
      addOuterClassThisRefField(outerType);
    }
  }
 else   if (cDecl.type().isNested() && !cDecl.flags().isStatic()) {
    polyglot.types.ClassType outerType=cDecl.type().outer();
    addOuterClassThisRefToInit(outerType);
    addOuterClassThisRefField(outerType);
  }
  Util.addLineTag(sootClass,cDecl);
}","/** 
 * Class Declaration Creation
 */
private void createClassDecl(polyglot.ast.ClassDecl cDecl){
  if (!cDecl.type().isTopLevel()) {
    SootClass outerClass=((soot.RefType)Util.getSootType(cDecl.type().outer())).getSootClass();
    if (innerClassInfoMap == null) {
      innerClassInfoMap=new HashMap();
    }
    innerClassInfoMap.put(sootClass,new InnerClassInfo(outerClass,cDecl.name(),InnerClassInfo.NESTED));
  }
  polyglot.types.Flags flags=cDecl.flags();
  addModifiers(flags,cDecl);
  if (cDecl.superClass() == null) {
    soot.SootClass superClass=soot.Scene.v().getSootClass(""String_Node_Str"");
    sootClass.setSuperclass(superClass);
  }
 else {
    sootClass.setSuperclass(((soot.RefType)Util.getSootType(cDecl.superClass().type())).getSootClass());
    if (((polyglot.types.ClassType)cDecl.superClass().type()).isNested()) {
      polyglot.types.ClassType superType=(polyglot.types.ClassType)cDecl.superClass().type();
      Util.addInnerClassTag(sootClass,sootClass.getName(),((soot.RefType)Util.getSootType(superType.outer())).toString(),superType.name(),Util.getModifier(superType.flags()));
    }
  }
  Iterator interfacesIt=cDecl.interfaces().iterator();
  while (interfacesIt.hasNext()) {
    polyglot.ast.TypeNode next=(polyglot.ast.TypeNode)interfacesIt.next();
    sootClass.addInterface(((soot.RefType)Util.getSootType(next.type())).getSootClass());
  }
  currentClassDeclPos=cDecl.position();
  createClassBody(cDecl.body());
  handleFieldInits();
  if ((staticFieldInits != null) || (staticInitializerBlocks != null)) {
    soot.SootMethod clinitMethod;
    if (!sootClass.declaresMethod(""String_Node_Str"",new ArrayList(),soot.VoidType.v())) {
      clinitMethod=new soot.SootMethod(""String_Node_Str"",new ArrayList(),soot.VoidType.v(),soot.Modifier.STATIC,new ArrayList());
      sootClass.addMethod(clinitMethod);
      clinitMethod.setSource(new soot.javaToJimple.PolyglotMethodSource());
    }
 else {
      clinitMethod=sootClass.getMethod(""String_Node_Str"",new ArrayList(),soot.VoidType.v());
    }
    ((PolyglotMethodSource)clinitMethod.getSource()).setStaticFieldInits(staticFieldInits);
    ((PolyglotMethodSource)clinitMethod.getSource()).setStaticInitializerBlocks(staticInitializerBlocks);
  }
  if (cDecl.type().isLocal()) {
    AnonLocalClassInfo info=(AnonLocalClassInfo)finalLocalInfo.get(new polyglot.util.IdentityKey(cDecl.type()));
    ArrayList finalsList=addFinalLocals(cDecl.body(),info.finalLocals(),cDecl.type(),info);
    Iterator it=sootClass.getMethods().iterator();
    while (it.hasNext()) {
      soot.SootMethod meth=(soot.SootMethod)it.next();
      if (meth.getName().equals(""String_Node_Str"")) {
        ((PolyglotMethodSource)meth.getSource()).setFinalsList(finalsList);
      }
    }
    if (!info.inStaticMethod()) {
      polyglot.types.ClassType outerType=cDecl.type().outer();
      addOuterClassThisRefToInit(outerType);
      addOuterClassThisRefField(outerType);
    }
  }
 else   if (cDecl.type().isNested() && !cDecl.flags().isStatic()) {
    polyglot.types.ClassType outerType=cDecl.type().outer();
    addOuterClassThisRefToInit(outerType);
    addOuterClassThisRefField(outerType);
  }
  Util.addLineTag(sootClass,cDecl);
}"
88620,"private void handleInnerClassTags(polyglot.ast.ClassBody classBody){
  if (sootClass.hasTag(""String_Node_Str"")) {
    soot.tagkit.OuterClassTag tag=(soot.tagkit.OuterClassTag)sootClass.getTag(""String_Node_Str"");
    Util.addInnerClassTag(sootClass,sootClass.getName(),tag.isAnon() ? null : tag.getOuterClass().getName(),tag.isAnon() ? null : tag.getSimpleName(),soot.Modifier.isInterface(tag.getOuterClass().getModifiers()) ? soot.Modifier.STATIC | soot.Modifier.PUBLIC : sootClass.getModifiers());
    SootClass outerClass=tag.getOuterClass();
    while (outerClass.hasTag(""String_Node_Str"")) {
      soot.tagkit.OuterClassTag tag2=(soot.tagkit.OuterClassTag)outerClass.getTag(""String_Node_Str"");
      Util.addInnerClassTag(sootClass,outerClass.getName(),tag2.isAnon() ? null : tag2.getOuterClass().getName(),tag2.isAnon() ? null : tag2.getSimpleName(),tag2.isAnon() && soot.Modifier.isInterface(tag2.getOuterClass().getModifiers()) ? soot.Modifier.STATIC | soot.Modifier.PUBLIC : outerClass.getModifiers());
      outerClass=tag2.getOuterClass();
    }
  }
}","private void handleInnerClassTags(polyglot.ast.ClassBody classBody){
  if ((innerClassInfoMap != null) && (innerClassInfoMap.containsKey(sootClass))) {
    InnerClassInfo tag=(InnerClassInfo)innerClassInfoMap.get(sootClass);
    Util.addInnerClassTag(sootClass,sootClass.getName(),tag.getInnerType() == InnerClassInfo.ANON ? null : tag.getOuterClass().getName(),tag.getInnerType() == InnerClassInfo.ANON ? null : tag.getSimpleName(),soot.Modifier.isInterface(tag.getOuterClass().getModifiers()) ? soot.Modifier.STATIC | soot.Modifier.PUBLIC : sootClass.getModifiers());
    SootClass outerClass=tag.getOuterClass();
    while (innerClassInfoMap.containsKey(outerClass)) {
      InnerClassInfo tag2=(InnerClassInfo)innerClassInfoMap.get(outerClass);
      Util.addInnerClassTag(sootClass,outerClass.getName(),tag2.getInnerType() == InnerClassInfo.ANON ? null : tag2.getOuterClass().getName(),tag2.getInnerType() == InnerClassInfo.ANON ? null : tag2.getSimpleName(),tag2.getInnerType() == InnerClassInfo.ANON && soot.Modifier.isInterface(tag2.getOuterClass().getModifiers()) ? soot.Modifier.STATIC | soot.Modifier.PUBLIC : outerClass.getModifiers());
      outerClass=tag2.getOuterClass();
    }
  }
}"
88621,"/** 
 * Handling for assert stmts - extra fields and methods are needed in the Jimple 
 */
private void handleAssert(polyglot.ast.ClassBody cBody){
  AssertStmtChecker asc=new AssertStmtChecker();
  cBody.visit(asc);
  if (!asc.isHasAssert())   return;
  if (!sootClass.declaresField(""String_Node_Str"",soot.BooleanType.v())) {
    sootClass.addField(new soot.SootField(""String_Node_Str"",soot.BooleanType.v(),soot.Modifier.STATIC | soot.Modifier.FINAL));
  }
  if (!sootClass.declaresField(""String_Node_Str"" + sootClass.getName(),soot.RefType.v(""String_Node_Str""))) {
    sootClass.addField(new soot.SootField(""String_Node_Str"" + sootClass.getName(),soot.RefType.v(""String_Node_Str""),soot.Modifier.STATIC));
  }
  String methodName=""String_Node_Str"";
  soot.Type methodRetType=soot.RefType.v(""String_Node_Str"");
  ArrayList paramTypes=new ArrayList();
  paramTypes.add(soot.RefType.v(""String_Node_Str""));
  if (!sootClass.declaresMethod(methodName,paramTypes,methodRetType)) {
    soot.SootMethod sootMethod=new soot.SootMethod(methodName,paramTypes,methodRetType,soot.Modifier.STATIC);
    AssertClassMethodSource mSrc=new AssertClassMethodSource();
    sootMethod.setSource(mSrc);
    sootClass.addMethod(sootMethod);
  }
  methodName=""String_Node_Str"";
  methodRetType=soot.VoidType.v();
  paramTypes=new ArrayList();
  if (!sootClass.declaresMethod(methodName,paramTypes,methodRetType)) {
    soot.SootMethod sootMethod=new soot.SootMethod(methodName,paramTypes,methodRetType,soot.Modifier.STATIC);
    PolyglotMethodSource mSrc=new PolyglotMethodSource();
    mSrc.hasAssert(true);
    sootMethod.setSource(mSrc);
    sootClass.addMethod(sootMethod);
  }
 else {
    ((soot.javaToJimple.PolyglotMethodSource)sootClass.getMethod(methodName,paramTypes,methodRetType).getSource()).hasAssert(true);
  }
}","/** 
 * Handling for assert stmts - extra fields and methods are needed in the Jimple 
 */
private void handleAssert(polyglot.ast.ClassBody cBody){
  AssertStmtChecker asc=new AssertStmtChecker();
  cBody.visit(asc);
  if (!asc.isHasAssert())   return;
  if (!sootClass.declaresField(""String_Node_Str"",soot.BooleanType.v())) {
    sootClass.addField(new soot.SootField(""String_Node_Str"",soot.BooleanType.v(),soot.Modifier.STATIC | soot.Modifier.FINAL));
  }
  soot.SootClass addClassToClass=sootClass;
  while ((innerClassInfoMap != null) && (innerClassInfoMap.containsKey(addClassToClass))) {
    addClassToClass=((InnerClassInfo)innerClassInfoMap.get(addClassToClass)).getOuterClass();
  }
  if (!addClassToClass.declaresField(""String_Node_Str"" + addClassToClass.getName(),soot.RefType.v(""String_Node_Str""))) {
    addClassToClass.addField(new soot.SootField(""String_Node_Str"" + addClassToClass.getName(),soot.RefType.v(""String_Node_Str""),soot.Modifier.STATIC));
  }
  String methodName=""String_Node_Str"";
  soot.Type methodRetType=soot.RefType.v(""String_Node_Str"");
  ArrayList paramTypes=new ArrayList();
  paramTypes.add(soot.RefType.v(""String_Node_Str""));
  if (!addClassToClass.declaresMethod(methodName,paramTypes,methodRetType)) {
    soot.SootMethod sootMethod=new soot.SootMethod(methodName,paramTypes,methodRetType,soot.Modifier.STATIC);
    AssertClassMethodSource mSrc=new AssertClassMethodSource();
    sootMethod.setSource(mSrc);
    addClassToClass.addMethod(sootMethod);
  }
  methodName=""String_Node_Str"";
  methodRetType=soot.VoidType.v();
  paramTypes=new ArrayList();
  if (!sootClass.declaresMethod(methodName,paramTypes,methodRetType)) {
    soot.SootMethod sootMethod=new soot.SootMethod(methodName,paramTypes,methodRetType,soot.Modifier.STATIC);
    PolyglotMethodSource mSrc=new PolyglotMethodSource();
    mSrc.hasAssert(true);
    sootMethod.setSource(mSrc);
    sootClass.addMethod(sootMethod);
  }
 else {
    ((soot.javaToJimple.PolyglotMethodSource)sootClass.getMethod(methodName,paramTypes,methodRetType).getSource()).hasAssert(true);
  }
}"
88622,"public boolean update(){
  final jedd.internal.RelationContainer newOut=new jedd.internal.RelationContainer(new jedd.Attribute[]{srcc.v(),srcm.v(),stmt.v(),kind.v(),tgtc.v(),tgtm.v()},new jedd.PhysicalDomain[]{V1.v(),T1.v(),ST.v(),FD.v(),V2.v(),T2.v()},(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""),jedd.internal.Jedd.v().copy(jedd.internal.Jedd.v().replace(jedd.internal.Jedd.v().project(in.get(),new jedd.PhysicalDomain[]{V2.v()}),new jedd.PhysicalDomain[]{ST.v()},new jedd.PhysicalDomain[]{V2.v()}),new jedd.PhysicalDomain[]{V2.v()},new jedd.PhysicalDomain[]{ST.v()}));
  out.add(new jedd.internal.RelationContainer(new jedd.Attribute[]{tgtm.v(),kind.v(),srcc.v(),srcm.v(),tgtc.v(),stmt.v()},new jedd.PhysicalDomain[]{T2.v(),FD.v(),V1.v(),T1.v(),V2.v(),ST.v()},(""String_Node_Str"" + ""String_Node_Str""),newOut));
  return !jedd.internal.Jedd.v().equals(jedd.internal.Jedd.v().read(newOut),jedd.internal.Jedd.v().falseBDD());
}","public boolean update(){
  final jedd.internal.RelationContainer newOut=new jedd.internal.RelationContainer(new jedd.Attribute[]{srcc.v(),srcm.v(),stmt.v(),kind.v(),tgtc.v(),tgtm.v()},new jedd.PhysicalDomain[]{V1.v(),T1.v(),ST.v(),FD.v(),V2.v(),T2.v()},(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""),jedd.internal.Jedd.v().copy(jedd.internal.Jedd.v().replace(jedd.internal.Jedd.v().project(in.get(),new jedd.PhysicalDomain[]{V2.v()}),new jedd.PhysicalDomain[]{ST.v()},new jedd.PhysicalDomain[]{V2.v()}),new jedd.PhysicalDomain[]{V2.v()},new jedd.PhysicalDomain[]{ST.v()}));
  out.add(new jedd.internal.RelationContainer(new jedd.Attribute[]{stmt.v(),srcm.v(),tgtc.v(),tgtm.v(),srcc.v(),kind.v()},new jedd.PhysicalDomain[]{ST.v(),T1.v(),V2.v(),T2.v(),V1.v(),FD.v()},(""String_Node_Str"" + ""String_Node_Str""),newOut));
  return !jedd.internal.Jedd.v().equals(jedd.internal.Jedd.v().read(newOut),jedd.internal.Jedd.v().falseBDD());
}"
88623,"public boolean update(){
  final jedd.internal.RelationContainer newOut=new jedd.internal.RelationContainer(new jedd.Attribute[]{srcc.v(),srcm.v(),stmt.v(),kind.v(),tgtc.v(),tgtm.v()},new jedd.PhysicalDomain[]{V1.v(),T1.v(),ST.v(),FD.v(),V2.v(),T2.v()},(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""),jedd.internal.Jedd.v().copy(jedd.internal.Jedd.v().replace(jedd.internal.Jedd.v().project(in.get(),new jedd.PhysicalDomain[]{H1.v(),V1.v()}),new jedd.PhysicalDomain[]{V2.v()},new jedd.PhysicalDomain[]{V1.v()}),new jedd.PhysicalDomain[]{ST.v()},new jedd.PhysicalDomain[]{V2.v()}));
  out.add(new jedd.internal.RelationContainer(new jedd.Attribute[]{tgtm.v(),kind.v(),srcc.v(),srcm.v(),tgtc.v(),stmt.v()},new jedd.PhysicalDomain[]{T2.v(),FD.v(),V1.v(),T1.v(),V2.v(),ST.v()},(""String_Node_Str"" + ""String_Node_Str""),newOut));
  return !jedd.internal.Jedd.v().equals(jedd.internal.Jedd.v().read(newOut),jedd.internal.Jedd.v().falseBDD());
}","public boolean update(){
  final jedd.internal.RelationContainer newOut=new jedd.internal.RelationContainer(new jedd.Attribute[]{srcc.v(),srcm.v(),stmt.v(),kind.v(),tgtc.v(),tgtm.v()},new jedd.PhysicalDomain[]{V1.v(),T1.v(),ST.v(),FD.v(),V2.v(),T2.v()},(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""),jedd.internal.Jedd.v().copy(jedd.internal.Jedd.v().replace(jedd.internal.Jedd.v().project(in.get(),new jedd.PhysicalDomain[]{V1.v(),H1.v()}),new jedd.PhysicalDomain[]{V2.v()},new jedd.PhysicalDomain[]{V1.v()}),new jedd.PhysicalDomain[]{ST.v()},new jedd.PhysicalDomain[]{V2.v()}));
  out.add(new jedd.internal.RelationContainer(new jedd.Attribute[]{stmt.v(),srcm.v(),tgtc.v(),tgtm.v(),srcc.v(),kind.v()},new jedd.PhysicalDomain[]{ST.v(),T1.v(),V2.v(),T2.v(),V1.v(),FD.v()},(""String_Node_Str"" + ""String_Node_Str""),newOut));
  return !jedd.internal.Jedd.v().equals(jedd.internal.Jedd.v().read(newOut),jedd.internal.Jedd.v().falseBDD());
}"
88624,"public int size(){
  return (int)new jedd.internal.RelationContainer(new jedd.Attribute[]{tgtm.v(),kind.v(),srcc.v(),srcm.v(),tgtc.v(),stmt.v()},new jedd.PhysicalDomain[]{T2.v(),FD.v(),V1.v(),T1.v(),V2.v(),ST.v()},(""String_Node_Str"" + ""String_Node_Str""),edges).size();
}","public int size(){
  return (int)new jedd.internal.RelationContainer(new jedd.Attribute[]{stmt.v(),srcm.v(),tgtc.v(),tgtm.v(),srcc.v(),kind.v()},new jedd.PhysicalDomain[]{ST.v(),T1.v(),V2.v(),T2.v(),V1.v(),FD.v()},(""String_Node_Str"" + ""String_Node_Str""),edges).size();
}"
88625,"public Rsrcc_srcm_stmt_kind_tgtc_tgtm edges(){
  return new Rsrcc_srcm_stmt_kind_tgtc_tgtmBDD(new jedd.internal.RelationContainer(new jedd.Attribute[]{tgtm.v(),kind.v(),srcc.v(),srcm.v(),tgtc.v(),stmt.v()},new jedd.PhysicalDomain[]{T2.v(),FD.v(),V1.v(),T1.v(),V2.v(),ST.v()},(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""),edges),""String_Node_Str"");
}","public Rsrcc_srcm_stmt_kind_tgtc_tgtm edges(){
  return new Rsrcc_srcm_stmt_kind_tgtc_tgtmBDD(new jedd.internal.RelationContainer(new jedd.Attribute[]{stmt.v(),srcm.v(),tgtc.v(),tgtm.v(),srcc.v(),kind.v()},new jedd.PhysicalDomain[]{ST.v(),T1.v(),V2.v(),T2.v(),V1.v(),FD.v()},(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""),edges),""String_Node_Str"");
}"
88626,"public boolean update(){
  final jedd.internal.RelationContainer newEdges=new jedd.internal.RelationContainer(new jedd.Attribute[]{srcc.v(),srcm.v(),stmt.v(),kind.v(),tgtc.v(),tgtm.v()},new jedd.PhysicalDomain[]{V1.v(),T1.v(),ST.v(),FD.v(),V2.v(),T2.v()},(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""),in.get());
  newEdges.eqMinus(edges);
  edges.eqUnion(newEdges);
  out.add(new jedd.internal.RelationContainer(new jedd.Attribute[]{tgtm.v(),kind.v(),srcc.v(),srcm.v(),tgtc.v(),stmt.v()},new jedd.PhysicalDomain[]{T2.v(),FD.v(),V1.v(),T1.v(),V2.v(),ST.v()},(""String_Node_Str"" + ""String_Node_Str""),newEdges));
  return !jedd.internal.Jedd.v().equals(jedd.internal.Jedd.v().read(newEdges),jedd.internal.Jedd.v().falseBDD());
}","public boolean update(){
  final jedd.internal.RelationContainer newEdges=new jedd.internal.RelationContainer(new jedd.Attribute[]{srcc.v(),srcm.v(),stmt.v(),kind.v(),tgtc.v(),tgtm.v()},new jedd.PhysicalDomain[]{V1.v(),T1.v(),ST.v(),FD.v(),V2.v(),T2.v()},(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""),in.get());
  newEdges.eqMinus(edges);
  edges.eqUnion(newEdges);
  out.add(new jedd.internal.RelationContainer(new jedd.Attribute[]{stmt.v(),srcm.v(),tgtc.v(),tgtm.v(),srcc.v(),kind.v()},new jedd.PhysicalDomain[]{ST.v(),T1.v(),V2.v(),T2.v(),V1.v(),FD.v()},(""String_Node_Str"" + ""String_Node_Str""),newEdges));
  return !jedd.internal.Jedd.v().equals(jedd.internal.Jedd.v().read(newEdges),jedd.internal.Jedd.v().falseBDD());
}"
88627,"public Rsrcc_srcm_stmt_kind_tgtc_tgtm edgesOutOf(MethodOrMethodContext m){
  return new Rsrcc_srcm_stmt_kind_tgtc_tgtmBDD(new jedd.internal.RelationContainer(new jedd.Attribute[]{kind.v(),tgtm.v(),srcc.v(),srcm.v(),stmt.v(),tgtc.v()},new jedd.PhysicalDomain[]{FD.v(),T2.v(),V1.v(),T1.v(),ST.v(),V2.v()},(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""),jedd.internal.Jedd.v().join(jedd.internal.Jedd.v().read(edges),jedd.internal.Jedd.v().literal(new Object[]{m.context(),m.method()},new jedd.Attribute[]{ctxt.v(),method.v()},new jedd.PhysicalDomain[]{V1.v(),T1.v()}),new jedd.PhysicalDomain[]{T1.v(),V1.v()})),""String_Node_Str"");
}","public Rsrcc_srcm_stmt_kind_tgtc_tgtm edgesOutOf(MethodOrMethodContext m){
  return new Rsrcc_srcm_stmt_kind_tgtc_tgtmBDD(new jedd.internal.RelationContainer(new jedd.Attribute[]{srcm.v(),stmt.v(),tgtc.v(),tgtm.v(),srcc.v(),kind.v()},new jedd.PhysicalDomain[]{T1.v(),ST.v(),V2.v(),T2.v(),V1.v(),FD.v()},(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""),jedd.internal.Jedd.v().join(jedd.internal.Jedd.v().read(edges),jedd.internal.Jedd.v().literal(new Object[]{m.context(),m.method()},new jedd.Attribute[]{ctxt.v(),method.v()},new jedd.PhysicalDomain[]{V1.v(),T1.v()}),new jedd.PhysicalDomain[]{T1.v(),V1.v()})),""String_Node_Str"");
}"
88628,"/** 
 * Constructs a <code>ThrowableSet.Manager</code> for inclusion in  Soot's global variable manager,   {@link G}.
 * @param g guarantees that the constructor may only be called from  {@link Singletons}.
 */
public Manager(Singletons.Global g){
  Scene.v().loadClassAndSupport(""String_Node_Str"");
  RUNTIME_EXCEPTION=Scene.v().getRefType(""String_Node_Str"");
  Scene.v().loadClassAndSupport(""String_Node_Str"");
  ARITHMETIC_EXCEPTION=Scene.v().getRefType(""String_Node_Str"");
  Scene.v().loadClassAndSupport(""String_Node_Str"");
  ARRAY_STORE_EXCEPTION=Scene.v().getRefType(""String_Node_Str"");
  Scene.v().loadClassAndSupport(""String_Node_Str"");
  CLASS_CAST_EXCEPTION=Scene.v().getRefType(""String_Node_Str"");
  Scene.v().loadClassAndSupport(""String_Node_Str"");
  ILLEGAL_MONITOR_STATE_EXCEPTION=Scene.v().getRefType(""String_Node_Str"");
  Scene.v().loadClassAndSupport(""String_Node_Str"");
  INDEX_OUT_OF_BOUNDS_EXCEPTION=Scene.v().getRefType(""String_Node_Str"");
  Scene.v().loadClassAndSupport(""String_Node_Str"");
  ARRAY_INDEX_OUT_OF_BOUNDS_EXCEPTION=Scene.v().getRefType(""String_Node_Str"");
  Scene.v().loadClassAndSupport(""String_Node_Str"");
  NEGATIVE_ARRAY_SIZE_EXCEPTION=Scene.v().getRefType(""String_Node_Str"");
  Scene.v().loadClassAndSupport(""String_Node_Str"");
  NULL_POINTER_EXCEPTION=Scene.v().getRefType(""String_Node_Str"");
  Scene.v().loadClassAndSupport(""String_Node_Str"");
  INSTANTIATION_ERROR=Scene.v().getRefType(""String_Node_Str"");
  EMPTY=registerSetIfNew(new HashSet());
  Set allThrowablesSet=new HashSet();
  Scene.v().loadClassAndSupport(""String_Node_Str"");
  allThrowablesSet.add(AnySubType.v(Scene.v().getRefType(""String_Node_Str"")));
  ALL_THROWABLES=registerSetIfNew(allThrowablesSet);
  Set vmErrorSet=new HashSet();
  Scene.v().loadClassAndSupport(""String_Node_Str"");
  vmErrorSet.add(Scene.v().getRefType(""String_Node_Str""));
  Scene.v().loadClassAndSupport(""String_Node_Str"");
  vmErrorSet.add(Scene.v().getRefType(""String_Node_Str""));
  Scene.v().loadClassAndSupport(""String_Node_Str"");
  vmErrorSet.add(Scene.v().getRefType(""String_Node_Str""));
  Scene.v().loadClassAndSupport(""String_Node_Str"");
  vmErrorSet.add(Scene.v().getRefType(""String_Node_Str""));
  Scene.v().loadClassAndSupport(""String_Node_Str"");
  vmErrorSet.add(Scene.v().getRefType(""String_Node_Str""));
  VM_ERRORS=registerSetIfNew(vmErrorSet);
  Set resolveClassErrorSet=new HashSet();
  Scene.v().loadClassAndSupport(""String_Node_Str"");
  resolveClassErrorSet.add(Scene.v().getRefType(""String_Node_Str""));
  Scene.v().loadClassAndSupport(""String_Node_Str"");
  allThrowablesSet.add(AnySubType.v(Scene.v().getRefType(""String_Node_Str"")));
  Scene.v().loadClassAndSupport(""String_Node_Str"");
  resolveClassErrorSet.add(Scene.v().getRefType(""String_Node_Str""));
  Scene.v().loadClassAndSupport(""String_Node_Str"");
  resolveClassErrorSet.add(Scene.v().getRefType(""String_Node_Str""));
  Scene.v().loadClassAndSupport(""String_Node_Str"");
  resolveClassErrorSet.add(Scene.v().getRefType(""String_Node_Str""));
  Scene.v().loadClassAndSupport(""String_Node_Str"");
  resolveClassErrorSet.add(Scene.v().getRefType(""String_Node_Str""));
  Scene.v().loadClassAndSupport(""String_Node_Str"");
  resolveClassErrorSet.add(Scene.v().getRefType(""String_Node_Str""));
  RESOLVE_CLASS_ERRORS=registerSetIfNew(resolveClassErrorSet);
  Set resolveFieldErrorSet=new HashSet(resolveClassErrorSet);
  Scene.v().loadClassAndSupport(""String_Node_Str"");
  resolveFieldErrorSet.add(Scene.v().getRefType(""String_Node_Str""));
  RESOLVE_FIELD_ERRORS=registerSetIfNew(resolveFieldErrorSet);
  Set resolveMethodErrorSet=new HashSet(resolveClassErrorSet);
  Scene.v().loadClassAndSupport(""String_Node_Str"");
  resolveMethodErrorSet.add(Scene.v().getRefType(""String_Node_Str""));
  Scene.v().loadClassAndSupport(""String_Node_Str"");
  resolveMethodErrorSet.add(Scene.v().getRefType(""String_Node_Str""));
  Scene.v().loadClassAndSupport(""String_Node_Str"");
  resolveMethodErrorSet.add(Scene.v().getRefType(""String_Node_Str""));
  RESOLVE_METHOD_ERRORS=registerSetIfNew(resolveMethodErrorSet);
  Set initializationErrorSet=new HashSet();
  Scene.v().loadClassAndSupport(""String_Node_Str"");
  initializationErrorSet.add(AnySubType.v(Scene.v().getRefType(""String_Node_Str"")));
  INITIALIZATION_ERRORS=registerSetIfNew(initializationErrorSet);
}","/** 
 * Constructs a <code>ThrowableSet.Manager</code> for inclusion in  Soot's global variable manager,   {@link G}.
 * @param g guarantees that the constructor may only be called from  {@link Singletons}.
 */
public Manager(Singletons.Global g){
  Scene.v().loadClassAndSupport(""String_Node_Str"");
  RUNTIME_EXCEPTION=Scene.v().getRefType(""String_Node_Str"");
  Scene.v().loadClassAndSupport(""String_Node_Str"");
  ARITHMETIC_EXCEPTION=Scene.v().getRefType(""String_Node_Str"");
  Scene.v().loadClassAndSupport(""String_Node_Str"");
  ARRAY_STORE_EXCEPTION=Scene.v().getRefType(""String_Node_Str"");
  Scene.v().loadClassAndSupport(""String_Node_Str"");
  CLASS_CAST_EXCEPTION=Scene.v().getRefType(""String_Node_Str"");
  Scene.v().loadClassAndSupport(""String_Node_Str"");
  ILLEGAL_MONITOR_STATE_EXCEPTION=Scene.v().getRefType(""String_Node_Str"");
  Scene.v().loadClassAndSupport(""String_Node_Str"");
  INDEX_OUT_OF_BOUNDS_EXCEPTION=Scene.v().getRefType(""String_Node_Str"");
  Scene.v().loadClassAndSupport(""String_Node_Str"");
  ARRAY_INDEX_OUT_OF_BOUNDS_EXCEPTION=Scene.v().getRefType(""String_Node_Str"");
  Scene.v().loadClassAndSupport(""String_Node_Str"");
  NEGATIVE_ARRAY_SIZE_EXCEPTION=Scene.v().getRefType(""String_Node_Str"");
  Scene.v().loadClassAndSupport(""String_Node_Str"");
  NULL_POINTER_EXCEPTION=Scene.v().getRefType(""String_Node_Str"");
  Scene.v().loadClassAndSupport(""String_Node_Str"");
  INSTANTIATION_ERROR=Scene.v().getRefType(""String_Node_Str"");
  EMPTY=registerSetIfNew(new HashSet());
  Set allThrowablesSet=new HashSet();
  Scene.v().loadClassAndSupport(""String_Node_Str"");
  allThrowablesSet.add(AnySubType.v(Scene.v().getRefType(""String_Node_Str"")));
  ALL_THROWABLES=registerSetIfNew(allThrowablesSet);
  Set vmErrorSet=new HashSet();
  Scene.v().loadClassAndSupport(""String_Node_Str"");
  vmErrorSet.add(Scene.v().getRefType(""String_Node_Str""));
  Scene.v().loadClassAndSupport(""String_Node_Str"");
  vmErrorSet.add(Scene.v().getRefType(""String_Node_Str""));
  Scene.v().loadClassAndSupport(""String_Node_Str"");
  vmErrorSet.add(Scene.v().getRefType(""String_Node_Str""));
  Scene.v().loadClassAndSupport(""String_Node_Str"");
  vmErrorSet.add(Scene.v().getRefType(""String_Node_Str""));
  Scene.v().loadClassAndSupport(""String_Node_Str"");
  vmErrorSet.add(Scene.v().getRefType(""String_Node_Str""));
  VM_ERRORS=registerSetIfNew(vmErrorSet);
  Set resolveClassErrorSet=new HashSet();
  Scene.v().loadClassAndSupport(""String_Node_Str"");
  resolveClassErrorSet.add(Scene.v().getRefType(""String_Node_Str""));
  Scene.v().loadClassAndSupport(""String_Node_Str"");
  resolveClassErrorSet.add(AnySubType.v(Scene.v().getRefType(""String_Node_Str"")));
  Scene.v().loadClassAndSupport(""String_Node_Str"");
  resolveClassErrorSet.add(Scene.v().getRefType(""String_Node_Str""));
  Scene.v().loadClassAndSupport(""String_Node_Str"");
  resolveClassErrorSet.add(Scene.v().getRefType(""String_Node_Str""));
  Scene.v().loadClassAndSupport(""String_Node_Str"");
  resolveClassErrorSet.add(Scene.v().getRefType(""String_Node_Str""));
  Scene.v().loadClassAndSupport(""String_Node_Str"");
  resolveClassErrorSet.add(Scene.v().getRefType(""String_Node_Str""));
  Scene.v().loadClassAndSupport(""String_Node_Str"");
  resolveClassErrorSet.add(Scene.v().getRefType(""String_Node_Str""));
  RESOLVE_CLASS_ERRORS=registerSetIfNew(resolveClassErrorSet);
  Set resolveFieldErrorSet=new HashSet(resolveClassErrorSet);
  Scene.v().loadClassAndSupport(""String_Node_Str"");
  resolveFieldErrorSet.add(Scene.v().getRefType(""String_Node_Str""));
  RESOLVE_FIELD_ERRORS=registerSetIfNew(resolveFieldErrorSet);
  Set resolveMethodErrorSet=new HashSet(resolveClassErrorSet);
  Scene.v().loadClassAndSupport(""String_Node_Str"");
  resolveMethodErrorSet.add(Scene.v().getRefType(""String_Node_Str""));
  Scene.v().loadClassAndSupport(""String_Node_Str"");
  resolveMethodErrorSet.add(Scene.v().getRefType(""String_Node_Str""));
  Scene.v().loadClassAndSupport(""String_Node_Str"");
  resolveMethodErrorSet.add(Scene.v().getRefType(""String_Node_Str""));
  RESOLVE_METHOD_ERRORS=registerSetIfNew(resolveMethodErrorSet);
  Set initializationErrorSet=new HashSet();
  Scene.v().loadClassAndSupport(""String_Node_Str"");
  initializationErrorSet.add(AnySubType.v(Scene.v().getRefType(""String_Node_Str"")));
  INITIALIZATION_ERRORS=registerSetIfNew(initializationErrorSet);
}"
88629,"/** 
 * Verifies the prospective name for validity as a Jimple name. In particular, first-char is alpha | _ | $, subsequent-chars  are alphanum | _ | $.  We could use isJavaIdentifier, except that Jimple's grammar doesn't support all of those, just ASCII. I'd put this in soot.Local, but that's an interface.
 * @author Patrick Lam
 */
boolean isValidJimpleName(String prospectiveName){
  for (int i=0; i < prospectiveName.length(); i++) {
    char c=prospectiveName.charAt(i);
    if (i == 0 && c >= '0' && c <= '9')     return false;
    if (!((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')|| (c == '_' || c == '$')))     return false;
  }
  return true;
}","/** 
 * Verifies the prospective name for validity as a Jimple name. In particular, first-char is alpha | _ | $, subsequent-chars  are alphanum | _ | $.  We could use isJavaIdentifier, except that Jimple's grammar doesn't support all of those, just ASCII. I'd put this in soot.Local, but that's an interface.
 * @author Patrick Lam
 */
boolean isValidJimpleName(String prospectiveName){
  if (prospectiveName == null)   return false;
  for (int i=0; i < prospectiveName.length(); i++) {
    char c=prospectiveName.charAt(i);
    if (i == 0 && c >= '0' && c <= '9')     return false;
    if (!((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')|| (c == '_' || c == '$')))     return false;
  }
  return true;
}"
88630,"public soot.jimple.JimpleBody createBody(soot.SootMethod sootMethod){
  body=soot.jimple.Jimple.v().newBody(sootMethod);
  lg=new LocalGenerator(body);
  ArrayList fields=((AnonClassInitMethodSource)body.getMethod().getSource()).getFinalsList();
  boolean inStaticMethod=((AnonClassInitMethodSource)body.getMethod().getSource()).inStaticMethod();
  boolean isSubType=((AnonClassInitMethodSource)body.getMethod().getSource()).isSubType();
  soot.Type superOuterType=((AnonClassInitMethodSource)body.getMethod().getSource()).superOuterType();
  soot.Type thisOuterType=((AnonClassInitMethodSource)body.getMethod().getSource()).thisOuterType();
  ArrayList fieldInits=((AnonClassInitMethodSource)body.getMethod().getSource()).getFieldInits();
  soot.Type outerClassType=((AnonClassInitMethodSource)body.getMethod().getSource()).outerClassType();
  soot.RefType type=sootMethod.getDeclaringClass().getType();
  specialThisLocal=soot.jimple.Jimple.v().newLocal(""String_Node_Str"",type);
  body.getLocals().add(specialThisLocal);
  soot.jimple.ThisRef thisRef=soot.jimple.Jimple.v().newThisRef(type);
  soot.jimple.Stmt thisStmt=soot.jimple.Jimple.v().newIdentityStmt(specialThisLocal,thisRef);
  body.getUnits().add(thisStmt);
  ArrayList invokeList=new ArrayList();
  ArrayList invokeTypeList=new ArrayList();
  int numParams=sootMethod.getParameterCount();
  int numFinals=0;
  if (fields != null) {
    numFinals=fields.size();
  }
  int startFinals=numParams - numFinals;
  ArrayList paramsForFinals=new ArrayList();
  soot.Local outerLocal=null;
  Iterator fIt=sootMethod.getParameterTypes().iterator();
  int counter=0;
  while (fIt.hasNext()) {
    soot.Type fType=(soot.Type)fIt.next();
    soot.Local local=soot.jimple.Jimple.v().newLocal(""String_Node_Str"" + counter,fType);
    body.getLocals().add(local);
    soot.jimple.ParameterRef paramRef=soot.jimple.Jimple.v().newParameterRef(fType,counter);
    soot.jimple.Stmt stmt=soot.jimple.Jimple.v().newIdentityStmt(local,paramRef);
    if (fType.equals(thisOuterType)) {
      outerLocal=local;
    }
    if ((counter != 0) && (counter < startFinals)) {
      invokeTypeList.add(fType);
      invokeList.add(local);
    }
 else     if ((counter == 0) && (!inStaticMethod)) {
      outerLocal=local;
    }
 else {
      paramsForFinals.add(local);
    }
    body.getUnits().add(stmt);
    counter++;
  }
  SootClass superClass=sootMethod.getDeclaringClass().getSuperclass();
  ArrayList needsRef=soot.javaToJimple.InitialResolver.v().getHasOuterRefInInit();
  if ((needsRef != null) && (needsRef.contains(superClass.getType()))) {
    invokeTypeList.add(0,superOuterType);
  }
  SootMethod callMethod=sootMethod.getDeclaringClass().getSuperclass().getMethod(""String_Node_Str"",invokeTypeList,VoidType.v());
  if ((needsRef != null) && (needsRef.contains(superClass.getType()))) {
    if (isSubType) {
      invokeList.add(0,outerLocal);
    }
 else {
      System.out.println(""String_Node_Str"" + superOuterType);
      System.out.println(""String_Node_Str"" + outerLocal);
      invokeList.add(0,Util.getThisGivenOuter(superOuterType,new HashMap(),body,new LocalGenerator(body),outerLocal));
    }
  }
  soot.jimple.InvokeExpr invoke=soot.jimple.Jimple.v().newSpecialInvokeExpr(specialThisLocal,callMethod,invokeList);
  soot.jimple.Stmt invokeStmt=soot.jimple.Jimple.v().newInvokeStmt(invoke);
  body.getUnits().add(invokeStmt);
  if (!inStaticMethod) {
    soot.SootField field=sootMethod.getDeclaringClass().getField(""String_Node_Str"",outerClassType);
    soot.jimple.InstanceFieldRef ref=soot.jimple.Jimple.v().newInstanceFieldRef(specialThisLocal,field);
    soot.jimple.AssignStmt assign=soot.jimple.Jimple.v().newAssignStmt(ref,outerLocal);
    body.getUnits().add(assign);
  }
  if (fields != null) {
    Iterator finalsIt=paramsForFinals.iterator();
    Iterator fieldsIt=fields.iterator();
    while (finalsIt.hasNext() && fieldsIt.hasNext()) {
      soot.Local pLocal=(soot.Local)finalsIt.next();
      soot.SootField pField=(soot.SootField)fieldsIt.next();
      soot.jimple.FieldRef pRef=soot.jimple.Jimple.v().newInstanceFieldRef(specialThisLocal,pField);
      soot.jimple.AssignStmt pAssign=soot.jimple.Jimple.v().newAssignStmt(pRef,pLocal);
      body.getUnits().add(pAssign);
    }
  }
  if (fieldInits != null) {
    handleFieldInits(fieldInits);
  }
  ArrayList staticBlocks=((AnonClassInitMethodSource)body.getMethod().getSource()).getInitializerBlocks();
  if (staticBlocks != null) {
    handleStaticBlocks(staticBlocks);
  }
  soot.jimple.ReturnVoidStmt retStmt=soot.jimple.Jimple.v().newReturnVoidStmt();
  body.getUnits().add(retStmt);
  return body;
}","public soot.jimple.JimpleBody createBody(soot.SootMethod sootMethod){
  body=soot.jimple.Jimple.v().newBody(sootMethod);
  lg=new LocalGenerator(body);
  ArrayList fields=((AnonClassInitMethodSource)body.getMethod().getSource()).getFinalsList();
  boolean inStaticMethod=((AnonClassInitMethodSource)body.getMethod().getSource()).inStaticMethod();
  boolean isSubType=((AnonClassInitMethodSource)body.getMethod().getSource()).isSubType();
  soot.Type superOuterType=((AnonClassInitMethodSource)body.getMethod().getSource()).superOuterType();
  soot.Type thisOuterType=((AnonClassInitMethodSource)body.getMethod().getSource()).thisOuterType();
  ArrayList fieldInits=((AnonClassInitMethodSource)body.getMethod().getSource()).getFieldInits();
  soot.Type outerClassType=((AnonClassInitMethodSource)body.getMethod().getSource()).outerClassType();
  boolean hasOuterRef=((AnonClassInitMethodSource)body.getMethod().getSource()).hasOuterRef();
  boolean hasQualifier=((AnonClassInitMethodSource)body.getMethod().getSource()).hasQualifier();
  soot.RefType type=sootMethod.getDeclaringClass().getType();
  specialThisLocal=soot.jimple.Jimple.v().newLocal(""String_Node_Str"",type);
  body.getLocals().add(specialThisLocal);
  soot.jimple.ThisRef thisRef=soot.jimple.Jimple.v().newThisRef(type);
  soot.jimple.Stmt thisStmt=soot.jimple.Jimple.v().newIdentityStmt(specialThisLocal,thisRef);
  body.getUnits().add(thisStmt);
  ArrayList invokeList=new ArrayList();
  ArrayList invokeTypeList=new ArrayList();
  int numParams=sootMethod.getParameterCount();
  int numFinals=0;
  if (fields != null) {
    numFinals=fields.size();
  }
  int startFinals=numParams - numFinals;
  ArrayList paramsForFinals=new ArrayList();
  soot.Local outerLocal=null;
  soot.Local qualifierLocal=null;
  Iterator fIt=sootMethod.getParameterTypes().iterator();
  int counter=0;
  while (fIt.hasNext()) {
    soot.Type fType=(soot.Type)fIt.next();
    soot.Local local=soot.jimple.Jimple.v().newLocal(""String_Node_Str"" + counter,fType);
    body.getLocals().add(local);
    soot.jimple.ParameterRef paramRef=soot.jimple.Jimple.v().newParameterRef(fType,counter);
    soot.jimple.Stmt stmt=soot.jimple.Jimple.v().newIdentityStmt(local,paramRef);
    int realArgs=0;
    if ((hasOuterRef) && (counter == 0)) {
      outerLocal=local;
      realArgs=1;
    }
    if ((hasOuterRef) && (hasQualifier) && (counter == 1)) {
      qualifierLocal=local;
      realArgs=2;
      invokeList.add(qualifierLocal);
    }
 else     if ((!hasOuterRef) && (hasQualifier) && (counter == 0)) {
      qualifierLocal=local;
      realArgs=1;
      invokeList.add(qualifierLocal);
    }
    if ((counter >= realArgs) && (counter < startFinals)) {
      invokeTypeList.add(fType);
      invokeList.add(local);
    }
 else     if (counter >= startFinals) {
      paramsForFinals.add(local);
    }
    body.getUnits().add(stmt);
    counter++;
  }
  SootClass superClass=sootMethod.getDeclaringClass().getSuperclass();
  ArrayList needsRef=soot.javaToJimple.InitialResolver.v().getHasOuterRefInInit();
  if ((needsRef != null) && (needsRef.contains(superClass.getType()))) {
    invokeTypeList.add(0,superOuterType);
  }
  SootMethod callMethod=sootMethod.getDeclaringClass().getSuperclass().getMethod(""String_Node_Str"",invokeTypeList,VoidType.v());
  if ((!hasQualifier) && (needsRef != null) && (needsRef.contains(superClass.getType()))) {
    if (isSubType) {
      invokeList.add(0,outerLocal);
    }
 else {
      invokeList.add(0,Util.getThisGivenOuter(superOuterType,new HashMap(),body,new LocalGenerator(body),outerLocal));
    }
  }
  soot.jimple.InvokeExpr invoke=soot.jimple.Jimple.v().newSpecialInvokeExpr(specialThisLocal,callMethod,invokeList);
  soot.jimple.Stmt invokeStmt=soot.jimple.Jimple.v().newInvokeStmt(invoke);
  body.getUnits().add(invokeStmt);
  if (!inStaticMethod) {
    soot.SootField field=sootMethod.getDeclaringClass().getField(""String_Node_Str"",outerClassType);
    soot.jimple.InstanceFieldRef ref=soot.jimple.Jimple.v().newInstanceFieldRef(specialThisLocal,field);
    soot.jimple.AssignStmt assign=soot.jimple.Jimple.v().newAssignStmt(ref,outerLocal);
    body.getUnits().add(assign);
  }
  if (fields != null) {
    Iterator finalsIt=paramsForFinals.iterator();
    Iterator fieldsIt=fields.iterator();
    while (finalsIt.hasNext() && fieldsIt.hasNext()) {
      soot.Local pLocal=(soot.Local)finalsIt.next();
      soot.SootField pField=(soot.SootField)fieldsIt.next();
      soot.jimple.FieldRef pRef=soot.jimple.Jimple.v().newInstanceFieldRef(specialThisLocal,pField);
      soot.jimple.AssignStmt pAssign=soot.jimple.Jimple.v().newAssignStmt(pRef,pLocal);
      body.getUnits().add(pAssign);
    }
  }
  if (fieldInits != null) {
    handleFieldInits(fieldInits);
  }
  ArrayList staticBlocks=((AnonClassInitMethodSource)body.getMethod().getSource()).getInitializerBlocks();
  if (staticBlocks != null) {
    handleStaticBlocks(staticBlocks);
  }
  soot.jimple.ReturnVoidStmt retStmt=soot.jimple.Jimple.v().newReturnVoidStmt();
  body.getUnits().add(retStmt);
  return body;
}"
88631,"/** 
 * creates the Jimple for an anon class - in the AST there is no class  decl for anon classes - the revelant fields and methods are  created 
 */
private void createAnonClassDecl(polyglot.ast.New aNew){
  SootClass outerClass=((soot.RefType)Util.getSootType(aNew.anonType().outer())).getSootClass();
  sootClass.addTag(new soot.tagkit.OuterClassTag(outerClass,""String_Node_Str"",true));
  soot.SootClass typeClass=((soot.RefType)Util.getSootType(aNew.objectType().type())).getSootClass();
  if (((polyglot.types.ClassType)aNew.objectType().type()).flags().isInterface()) {
    sootClass.addInterface(typeClass);
    sootClass.setSuperclass(soot.Scene.v().getSootClass(""String_Node_Str""));
  }
 else {
    sootClass.setSuperclass(typeClass);
    if (((polyglot.types.ClassType)aNew.objectType().type()).isNested()) {
      polyglot.types.ClassType superType=(polyglot.types.ClassType)aNew.objectType().type();
      Util.addInnerClassTag(sootClass,typeClass.getName(),((soot.RefType)Util.getSootType(superType.outer())).toString(),superType.name(),Util.getModifier(superType.flags()));
    }
  }
  ArrayList params=new ArrayList();
  soot.SootMethod method;
  if (((polyglot.types.ClassType)aNew.objectType().type()).flags().isInterface()) {
    method=new soot.SootMethod(""String_Node_Str"",params,soot.VoidType.v());
  }
 else {
    Iterator aIt=aNew.arguments().iterator();
    while (aIt.hasNext()) {
      polyglot.types.Type pType=((polyglot.ast.Expr)aIt.next()).type();
      params.add(Util.getSootType(pType));
    }
    method=new soot.SootMethod(""String_Node_Str"",params,soot.VoidType.v());
  }
  AnonClassInitMethodSource src=new AnonClassInitMethodSource();
  method.setSource(src);
  sootClass.addMethod(method);
  AnonLocalClassInfo info=(AnonLocalClassInfo)finalLocalInfo.get(new polyglot.util.IdentityKey(aNew.anonType()));
  if (!info.inStaticMethod()) {
    addOuterClassThisRefToInit(aNew.anonType().outer());
    addOuterClassThisRefField(aNew.anonType().outer());
    src.thisOuterType(Util.getSootType(aNew.anonType().outer()));
  }
 else   if (aNew.qualifier() != null) {
    addOuterClassThisRefToInit(aNew.qualifier().type());
    addOuterClassThisRefField(aNew.qualifier().type());
    src.thisOuterType(Util.getSootType(aNew.qualifier().type()));
  }
  src.inStaticMethod(info.inStaticMethod());
  if (info != null) {
    src.setFinalsList(addFinalLocals(aNew.body(),info.finalLocals(),(polyglot.types.ClassType)aNew.anonType(),info));
  }
  src.outerClassType(Util.getSootType(aNew.anonType().outer()));
  if (((polyglot.types.ClassType)aNew.objectType().type()).isNested()) {
    src.superOuterType(Util.getSootType(((polyglot.types.ClassType)aNew.objectType().type()).outer()));
    src.isSubType(Util.isSubType(aNew.anonType().outer(),((polyglot.types.ClassType)aNew.objectType().type()).outer()));
  }
}","/** 
 * creates the Jimple for an anon class - in the AST there is no class  decl for anon classes - the revelant fields and methods are  created 
 */
private void createAnonClassDecl(polyglot.ast.New aNew){
  SootClass outerClass=((soot.RefType)Util.getSootType(aNew.anonType().outer())).getSootClass();
  sootClass.addTag(new soot.tagkit.OuterClassTag(outerClass,""String_Node_Str"",true));
  soot.SootClass typeClass=((soot.RefType)Util.getSootType(aNew.objectType().type())).getSootClass();
  if (((polyglot.types.ClassType)aNew.objectType().type()).flags().isInterface()) {
    sootClass.addInterface(typeClass);
    sootClass.setSuperclass(soot.Scene.v().getSootClass(""String_Node_Str""));
  }
 else {
    sootClass.setSuperclass(typeClass);
    if (((polyglot.types.ClassType)aNew.objectType().type()).isNested()) {
      polyglot.types.ClassType superType=(polyglot.types.ClassType)aNew.objectType().type();
      Util.addInnerClassTag(sootClass,typeClass.getName(),((soot.RefType)Util.getSootType(superType.outer())).toString(),superType.name(),Util.getModifier(superType.flags()));
    }
  }
  ArrayList params=new ArrayList();
  soot.SootMethod method;
  if (((polyglot.types.ClassType)aNew.objectType().type()).flags().isInterface()) {
    method=new soot.SootMethod(""String_Node_Str"",params,soot.VoidType.v());
  }
 else {
    Iterator aIt=aNew.arguments().iterator();
    while (aIt.hasNext()) {
      polyglot.types.Type pType=((polyglot.ast.Expr)aIt.next()).type();
      params.add(Util.getSootType(pType));
    }
    method=new soot.SootMethod(""String_Node_Str"",params,soot.VoidType.v());
  }
  AnonClassInitMethodSource src=new AnonClassInitMethodSource();
  method.setSource(src);
  sootClass.addMethod(method);
  AnonLocalClassInfo info=(AnonLocalClassInfo)finalLocalInfo.get(new polyglot.util.IdentityKey(aNew.anonType()));
  if (aNew.qualifier() != null) {
    addQualifierRefToInit(aNew.qualifier().type());
    src.hasQualifier(true);
  }
  if (!info.inStaticMethod()) {
    addOuterClassThisRefToInit(aNew.anonType().outer());
    addOuterClassThisRefField(aNew.anonType().outer());
    src.thisOuterType(Util.getSootType(aNew.anonType().outer()));
    src.hasOuterRef(true);
  }
  src.inStaticMethod(info.inStaticMethod());
  if (info != null) {
    src.setFinalsList(addFinalLocals(aNew.body(),info.finalLocals(),(polyglot.types.ClassType)aNew.anonType(),info));
  }
  src.outerClassType(Util.getSootType(aNew.anonType().outer()));
  if (((polyglot.types.ClassType)aNew.objectType().type()).isNested()) {
    src.superOuterType(Util.getSootType(((polyglot.types.ClassType)aNew.objectType().type()).outer()));
    src.isSubType(Util.isSubType(aNew.anonType().outer(),((polyglot.types.ClassType)aNew.objectType().type()).outer()));
  }
}"
88632,"/** 
 * adds outer class params
 */
private void handleOuterClassParams(ArrayList sootParams,ArrayList sootParamsTypes,polyglot.types.ClassType typeToInvoke){
  ArrayList needsRef=soot.javaToJimple.InitialResolver.v().getHasOuterRefInInit();
  if ((needsRef != null) && (needsRef.contains(Util.getSootType(typeToInvoke)))) {
    soot.SootClass outerClass=((soot.RefType)Util.getSootType(typeToInvoke.outer())).getSootClass();
    soot.Local classToInvokeOuterParam=getThis(outerClass.getType());
    sootParamsTypes.add(outerClass.getType());
    sootParams.add(classToInvokeOuterParam);
  }
}","/** 
 * adds outer class params
 */
private void handleOuterClassParams(ArrayList sootParams,soot.Value qVal,ArrayList sootParamsTypes,polyglot.types.ClassType typeToInvoke){
  ArrayList needsRef=soot.javaToJimple.InitialResolver.v().getHasOuterRefInInit();
  boolean addRef=(needsRef != null) && (needsRef.contains(Util.getSootType(typeToInvoke)));
  if (addRef) {
    soot.SootClass outerClass=((soot.RefType)Util.getSootType(typeToInvoke.outer())).getSootClass();
    sootParamsTypes.add(outerClass.getType());
  }
  if (addRef && !typeToInvoke.isAnonymous() && (qVal != null)) {
    sootParams.add(qVal);
  }
 else   if (addRef && !typeToInvoke.isAnonymous()) {
    soot.SootClass outerClass=((soot.RefType)Util.getSootType(typeToInvoke.outer())).getSootClass();
    sootParams.add(getThis(outerClass.getType()));
  }
 else   if (addRef && typeToInvoke.isAnonymous()) {
    soot.SootClass outerClass=((soot.RefType)Util.getSootType(typeToInvoke.outer())).getSootClass();
    sootParams.add(getThis(outerClass.getType()));
  }
  if (typeToInvoke.isAnonymous() && (qVal != null)) {
    sootParamsTypes.add(qVal.getType());
    sootParams.add(qVal);
  }
}"
88633,"/** 
 * Constructor Call Creation
 */
private void createConstructorCall(polyglot.ast.ConstructorCall cCall){
  ArrayList sootParams=new ArrayList();
  ArrayList sootParamsTypes=new ArrayList();
  polyglot.types.ConstructorInstance cInst=cCall.constructorInstance();
  String containerName=null;
  if (cInst.container() instanceof polyglot.types.ClassType) {
    containerName=((polyglot.types.ClassType)cInst.container()).fullName();
  }
  soot.SootClass classToInvoke;
  if (cCall.kind() == polyglot.ast.ConstructorCall.SUPER) {
    classToInvoke=((soot.RefType)Util.getSootType(cInst.container())).getSootClass();
  }
 else   if (cCall.kind() == polyglot.ast.ConstructorCall.THIS) {
    classToInvoke=body.getMethod().getDeclaringClass();
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
  soot.Local base=specialThisLocal;
  if (cCall.qualifier() != null) {
    polyglot.types.ClassType objType=(polyglot.types.ClassType)cInst.container();
    if ((objType.outer() != null) && (body.getMethod().getDeclaringClass().equals(((soot.RefType)Util.getSootType(objType.outer())).getSootClass()))) {
      handleOuterClassParams(sootParams,sootParamsTypes,objType);
    }
 else {
      soot.Local qVal=(soot.Local)createExpr(cCall.qualifier());
      sootParams.add(qVal);
      sootParamsTypes.add(qVal.getType());
      body.getUnits().add(soot.jimple.Jimple.v().newInvokeStmt(soot.jimple.Jimple.v().newVirtualInvokeExpr(qVal,soot.Scene.v().getSootClass(""String_Node_Str"").getMethodByName(""String_Node_Str""),new ArrayList())));
    }
  }
 else {
    handleOuterClassParams(sootParams,sootParamsTypes,(polyglot.types.ClassType)cInst.container());
  }
  int index=classToInvoke.getName().lastIndexOf(""String_Node_Str"");
  sootParams.addAll(getSootParams(cCall));
  sootParamsTypes.addAll(getSootParamsTypes(cCall));
  if (index != -1) {
    handleFinalLocalParams(sootParams,sootParamsTypes,(polyglot.types.ClassType)cCall.constructorInstance().container());
  }
  soot.SootMethod methodToInvoke=getMethodFromClass(classToInvoke,""String_Node_Str"",sootParamsTypes,soot.VoidType.v());
  soot.jimple.SpecialInvokeExpr specialInvokeExpr=soot.jimple.Jimple.v().newSpecialInvokeExpr(base,methodToInvoke,sootParams);
  soot.jimple.Stmt invokeStmt=soot.jimple.Jimple.v().newInvokeStmt(specialInvokeExpr);
  body.getUnits().add(invokeStmt);
  Util.addLnPosTags(invokeStmt,cCall.position());
  int numParams=0;
  Iterator invokeParamsIt=cCall.arguments().iterator();
  while (invokeParamsIt.hasNext()) {
    Util.addLnPosTags(specialInvokeExpr.getArgBox(numParams),((polyglot.ast.Expr)invokeParamsIt.next()).position());
    numParams++;
  }
  if (body.getMethod().getName().equals(""String_Node_Str"") && (cCall.kind() == polyglot.ast.ConstructorCall.SUPER)) {
    handleOuterClassThisInit(body.getMethod());
    handleFinalLocalInits();
    handleFieldInits(body.getMethod());
    handleInitializerBlocks(body.getMethod());
  }
}","/** 
 * Constructor Call Creation
 */
private void createConstructorCall(polyglot.ast.ConstructorCall cCall){
  ArrayList sootParams=new ArrayList();
  ArrayList sootParamsTypes=new ArrayList();
  polyglot.types.ConstructorInstance cInst=cCall.constructorInstance();
  String containerName=null;
  if (cInst.container() instanceof polyglot.types.ClassType) {
    containerName=((polyglot.types.ClassType)cInst.container()).fullName();
  }
  soot.SootClass classToInvoke;
  if (cCall.kind() == polyglot.ast.ConstructorCall.SUPER) {
    classToInvoke=((soot.RefType)Util.getSootType(cInst.container())).getSootClass();
  }
 else   if (cCall.kind() == polyglot.ast.ConstructorCall.THIS) {
    classToInvoke=body.getMethod().getDeclaringClass();
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
  soot.Local base=specialThisLocal;
  polyglot.types.ClassType objType=(polyglot.types.ClassType)cInst.container();
  soot.Local qVal=null;
  if (cCall.qualifier() != null) {
    qVal=(soot.Local)createExpr(cCall.qualifier());
  }
  handleOuterClassParams(sootParams,qVal,sootParamsTypes,objType);
  int index=classToInvoke.getName().lastIndexOf(""String_Node_Str"");
  sootParams.addAll(getSootParams(cCall));
  sootParamsTypes.addAll(getSootParamsTypes(cCall));
  if (index != -1) {
    handleFinalLocalParams(sootParams,sootParamsTypes,(polyglot.types.ClassType)cCall.constructorInstance().container());
  }
  soot.SootMethod methodToInvoke=getMethodFromClass(classToInvoke,""String_Node_Str"",sootParamsTypes,soot.VoidType.v());
  soot.jimple.SpecialInvokeExpr specialInvokeExpr=soot.jimple.Jimple.v().newSpecialInvokeExpr(base,methodToInvoke,sootParams);
  soot.jimple.Stmt invokeStmt=soot.jimple.Jimple.v().newInvokeStmt(specialInvokeExpr);
  body.getUnits().add(invokeStmt);
  Util.addLnPosTags(invokeStmt,cCall.position());
  int numParams=0;
  Iterator invokeParamsIt=cCall.arguments().iterator();
  while (invokeParamsIt.hasNext()) {
    Util.addLnPosTags(specialInvokeExpr.getArgBox(numParams),((polyglot.ast.Expr)invokeParamsIt.next()).position());
    numParams++;
  }
  if (body.getMethod().getName().equals(""String_Node_Str"") && (cCall.kind() == polyglot.ast.ConstructorCall.SUPER)) {
    handleOuterClassThisInit(body.getMethod());
    handleFinalLocalInits();
    handleFieldInits(body.getMethod());
    handleInitializerBlocks(body.getMethod());
  }
}"
88634,"/** 
 * Gets the Soot Method form the given Soot Class
 */
private soot.SootMethod getMethodFromClass(soot.SootClass sootClass,String name,ArrayList paramTypes,soot.Type returnType){
  try {
    return sootClass.getMethod(name,paramTypes,returnType);
  }
 catch (  Exception e) {
    if (paramTypes != null && !paramTypes.isEmpty()) {
      soot.SootClass firstParam=((soot.RefType)paramTypes.get(0)).getSootClass();
      boolean foundMeth=false;
      while (!foundMeth) {
        paramTypes.set(0,firstParam.getSuperclass().getType());
        if (sootClass.declaresMethod(name,paramTypes,returnType)) {
          return sootClass.getMethod(name,paramTypes,returnType);
        }
        firstParam=firstParam.getSuperclass();
      }
    }
  }
  return null;
}","/** 
 * Gets the Soot Method form the given Soot Class
 */
private soot.SootMethod getMethodFromClass(soot.SootClass sootClass,String name,ArrayList paramTypes,soot.Type returnType){
  return sootClass.getMethod(name,paramTypes,returnType);
}"
88635,"/** 
 * New Expression Creation
 */
private soot.Local getNewLocal(polyglot.ast.New newExpr){
  ArrayList sootParams=new ArrayList();
  ArrayList sootParamsTypes=new ArrayList();
  polyglot.types.ClassType objType=(polyglot.types.ClassType)newExpr.objectType().type();
  if (newExpr.anonType() != null) {
    objType=newExpr.anonType();
    String name=Util.getSootType(objType).toString();
    polyglot.types.ClassType outerType=objType.outer();
    if (!InitialResolver.v().hasClassInnerTag(body.getMethod().getDeclaringClass(),name)) {
      Util.addInnerClassTag(body.getMethod().getDeclaringClass(),name,null,null,outerType.flags().isInterface() ? soot.Modifier.PUBLIC | soot.Modifier.STATIC : Util.getModifier(objType.flags()));
    }
  }
 else {
    if (!objType.isTopLevel()) {
      String name=Util.getSootType(objType).toString();
      polyglot.types.ClassType outerType=objType.outer();
      if (!InitialResolver.v().hasClassInnerTag(body.getMethod().getDeclaringClass(),name)) {
        Util.addInnerClassTag(body.getMethod().getDeclaringClass(),name,Util.getSootType(outerType).toString(),objType.name(),outerType.flags().isInterface() ? soot.Modifier.PUBLIC | soot.Modifier.STATIC : Util.getModifier(objType.flags()));
      }
    }
  }
  soot.RefType sootType=(soot.RefType)Util.getSootType(objType);
  soot.Local retLocal=lg.generateLocal(sootType);
  soot.jimple.NewExpr sootNew=soot.jimple.Jimple.v().newNewExpr(sootType);
  soot.jimple.Stmt stmt=soot.jimple.Jimple.v().newAssignStmt(retLocal,sootNew);
  body.getUnits().add(stmt);
  Util.addLnPosTags(stmt,newExpr.position());
  soot.SootClass classToInvoke=sootType.getSootClass();
  if (newExpr.qualifier() != null) {
    if ((objType.outer() != null) && (body.getMethod().getDeclaringClass().equals(((soot.RefType)Util.getSootType(objType.outer())).getSootClass())) && (!soot.Modifier.isStatic(body.getMethod().getModifiers()))) {
      handleOuterClassParams(sootParams,sootParamsTypes,objType);
    }
 else {
      soot.Value qVal=createExpr(newExpr.qualifier());
      sootParams.add(qVal);
      sootParamsTypes.add(qVal.getType());
      body.getUnits().add(soot.jimple.Jimple.v().newInvokeStmt(soot.jimple.Jimple.v().newVirtualInvokeExpr((soot.Local)qVal,soot.Scene.v().getSootClass(""String_Node_Str"").getMethodByName(""String_Node_Str""),new ArrayList())));
    }
  }
 else {
    handleOuterClassParams(sootParams,sootParamsTypes,objType);
  }
  sootParams.addAll(getSootParams(newExpr));
  sootParamsTypes.addAll(getSootParamsTypes(newExpr));
  handleFinalLocalParams(sootParams,sootParamsTypes,(polyglot.types.ClassType)objType);
  soot.SootMethod methodToInvoke=getMethodFromClass(classToInvoke,""String_Node_Str"",sootParamsTypes,soot.VoidType.v());
  if (!methodToInvoke.getDeclaringClass().getType().equals(classToInvoke.getType())) {
    throw new RuntimeException(""String_Node_Str"" + classToInvoke.getType() + ""String_Node_Str""+ methodToInvoke.getDeclaringClass().getType());
  }
  soot.jimple.SpecialInvokeExpr specialInvokeExpr=soot.jimple.Jimple.v().newSpecialInvokeExpr(retLocal,methodToInvoke,sootParams);
  soot.jimple.Stmt invokeStmt=soot.jimple.Jimple.v().newInvokeStmt(specialInvokeExpr);
  body.getUnits().add(invokeStmt);
  Util.addLnPosTags(invokeStmt,newExpr.position());
  int numParams=0;
  Iterator invokeParamsIt=newExpr.arguments().iterator();
  while (invokeParamsIt.hasNext()) {
    Util.addLnPosTags(specialInvokeExpr.getArgBox(numParams),((polyglot.ast.Expr)invokeParamsIt.next()).position());
    numParams++;
  }
  return retLocal;
}","/** 
 * New Expression Creation
 */
private soot.Local getNewLocal(polyglot.ast.New newExpr){
  ArrayList sootParams=new ArrayList();
  ArrayList sootParamsTypes=new ArrayList();
  polyglot.types.ClassType objType=(polyglot.types.ClassType)newExpr.objectType().type();
  if (newExpr.anonType() != null) {
    objType=newExpr.anonType();
    String name=Util.getSootType(objType).toString();
    polyglot.types.ClassType outerType=objType.outer();
    if (!InitialResolver.v().hasClassInnerTag(body.getMethod().getDeclaringClass(),name)) {
      Util.addInnerClassTag(body.getMethod().getDeclaringClass(),name,null,null,outerType.flags().isInterface() ? soot.Modifier.PUBLIC | soot.Modifier.STATIC : Util.getModifier(objType.flags()));
    }
  }
 else {
    if (!objType.isTopLevel()) {
      String name=Util.getSootType(objType).toString();
      polyglot.types.ClassType outerType=objType.outer();
      if (!InitialResolver.v().hasClassInnerTag(body.getMethod().getDeclaringClass(),name)) {
        Util.addInnerClassTag(body.getMethod().getDeclaringClass(),name,Util.getSootType(outerType).toString(),objType.name(),outerType.flags().isInterface() ? soot.Modifier.PUBLIC | soot.Modifier.STATIC : Util.getModifier(objType.flags()));
      }
    }
  }
  soot.RefType sootType=(soot.RefType)Util.getSootType(objType);
  soot.Local retLocal=lg.generateLocal(sootType);
  soot.jimple.NewExpr sootNew=soot.jimple.Jimple.v().newNewExpr(sootType);
  soot.jimple.Stmt stmt=soot.jimple.Jimple.v().newAssignStmt(retLocal,sootNew);
  body.getUnits().add(stmt);
  Util.addLnPosTags(stmt,newExpr.position());
  soot.SootClass classToInvoke=sootType.getSootClass();
  soot.Value qVal=null;
  if (newExpr.qualifier() != null) {
    qVal=createExpr(newExpr.qualifier());
  }
  handleOuterClassParams(sootParams,qVal,sootParamsTypes,objType);
  sootParams.addAll(getSootParams(newExpr));
  sootParamsTypes.addAll(getSootParamsTypes(newExpr));
  handleFinalLocalParams(sootParams,sootParamsTypes,(polyglot.types.ClassType)objType);
  soot.SootMethod methodToInvoke=getMethodFromClass(classToInvoke,""String_Node_Str"",sootParamsTypes,soot.VoidType.v());
  if (!methodToInvoke.getDeclaringClass().getType().equals(classToInvoke.getType())) {
    throw new RuntimeException(""String_Node_Str"" + classToInvoke.getType() + ""String_Node_Str""+ methodToInvoke.getDeclaringClass().getType());
  }
  soot.jimple.SpecialInvokeExpr specialInvokeExpr=soot.jimple.Jimple.v().newSpecialInvokeExpr(retLocal,methodToInvoke,sootParams);
  soot.jimple.Stmt invokeStmt=soot.jimple.Jimple.v().newInvokeStmt(specialInvokeExpr);
  body.getUnits().add(invokeStmt);
  Util.addLnPosTags(invokeStmt,newExpr.position());
  int numParams=0;
  Iterator invokeParamsIt=newExpr.arguments().iterator();
  while (invokeParamsIt.hasNext()) {
    Util.addLnPosTags(specialInvokeExpr.getArgBox(numParams),((polyglot.ast.Expr)invokeParamsIt.next()).position());
    numParams++;
  }
  return retLocal;
}"
88636,"void emitInst(Inst inst){
  inst.apply(new InstSwitch(){
    public void caseReturnVoidInst(    ReturnVoidInst i){
      emit(""String_Node_Str"");
    }
    public void caseReturnInst(    ReturnInst i){
      i.getOpType().apply(new TypeSwitch(){
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"" + t.toString());
        }
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"");
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"");
        }
        public void caseIntType(        IntType t){
          emit(""String_Node_Str"");
        }
        public void caseByteType(        ByteType t){
          emit(""String_Node_Str"");
        }
        public void caseShortType(        ShortType t){
          emit(""String_Node_Str"");
        }
        public void caseCharType(        CharType t){
          emit(""String_Node_Str"");
        }
        public void caseBooleanType(        BooleanType t){
          emit(""String_Node_Str"");
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"");
        }
        public void caseArrayType(        ArrayType t){
          emit(""String_Node_Str"");
        }
        public void caseRefType(        RefType t){
          emit(""String_Node_Str"");
        }
        public void caseNullType(        NullType t){
          emit(""String_Node_Str"");
        }
      }
);
    }
    public void caseNopInst(    NopInst i){
      emit(""String_Node_Str"");
    }
    public void caseEnterMonitorInst(    EnterMonitorInst i){
      emit(""String_Node_Str"");
    }
    public void casePopInst(    PopInst i){
      if (i.getWordCount() == 2) {
        emit(""String_Node_Str"");
      }
 else       emit(""String_Node_Str"");
    }
    public void caseExitMonitorInst(    ExitMonitorInst i){
      emit(""String_Node_Str"");
    }
    public void caseGotoInst(    GotoInst i){
      emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
    }
    public void casePushInst(    PushInst i){
      if (i.getConstant() instanceof IntConstant) {
        IntConstant v=(IntConstant)(i.getConstant());
        if (v.value == -1)         emit(""String_Node_Str"");
 else         if (v.value >= 0 && v.value <= 5)         emit(""String_Node_Str"" + v.value);
 else         if (v.value >= Byte.MIN_VALUE && v.value <= Byte.MAX_VALUE)         emit(""String_Node_Str"" + v.value);
 else         if (v.value >= Short.MIN_VALUE && v.value <= Short.MAX_VALUE)         emit(""String_Node_Str"" + v.value);
 else         emit(""String_Node_Str"" + v.toString());
      }
 else       if (i.getConstant() instanceof StringConstant) {
        emit(""String_Node_Str"" + i.getConstant().toString());
      }
 else       if (i.getConstant() instanceof DoubleConstant) {
        DoubleConstant v=(DoubleConstant)(i.getConstant());
        if (v.value == 0)         emit(""String_Node_Str"");
 else         if (v.value == 1)         emit(""String_Node_Str"");
 else {
          String s=v.toString();
          if (s.equals(""String_Node_Str""))           s=""String_Node_Str"";
          if (s.equals(""String_Node_Str""))           s=""String_Node_Str"";
          if (s.equals(""String_Node_Str""))           s=""String_Node_Str"";
          emit(""String_Node_Str"" + s);
        }
      }
 else       if (i.getConstant() instanceof FloatConstant) {
        FloatConstant v=(FloatConstant)(i.getConstant());
        if (v.value == 0)         emit(""String_Node_Str"");
 else         if (v.value == 1)         emit(""String_Node_Str"");
 else         if (v.value == 2)         emit(""String_Node_Str"");
 else {
          String s=v.toString();
          if (s.equals(""String_Node_Str""))           s=""String_Node_Str"";
          if (s.equals(""String_Node_Str""))           s=""String_Node_Str"";
          if (s.equals(""String_Node_Str""))           s=""String_Node_Str"";
          emit(""String_Node_Str"" + s);
        }
      }
 else       if (i.getConstant() instanceof LongConstant) {
        LongConstant v=(LongConstant)(i.getConstant());
        if (v.value == 0)         emit(""String_Node_Str"");
 else         if (v.value == 1)         emit(""String_Node_Str"");
 else         emit(""String_Node_Str"" + v.toString());
      }
 else       if (i.getConstant() instanceof NullConstant)       emit(""String_Node_Str"");
 else       throw new RuntimeException(""String_Node_Str"");
    }
    public void caseIdentityInst(    IdentityInst i){
      if (i.getRightOp() instanceof CaughtExceptionRef && i.getLeftOp() instanceof Local) {
        int slot=((Integer)localToSlot.get(i.getLeftOp())).intValue();
        if (slot >= 0 && slot <= 3)         emit(""String_Node_Str"" + slot);
 else         emit(""String_Node_Str"" + slot);
      }
    }
    public void caseStoreInst(    StoreInst i){
      final int slot=((Integer)localToSlot.get(i.getLocal())).intValue();
      i.getOpType().apply(new TypeSwitch(){
        public void caseArrayType(        ArrayType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseDoubleType(        DoubleType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseFloatType(        FloatType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseIntType(        IntType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseByteType(        ByteType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseShortType(        ShortType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseCharType(        CharType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseBooleanType(        BooleanType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseLongType(        LongType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseRefType(        RefType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseStmtAddressType(        StmtAddressType t){
          isNextGotoAJsr=true;
          returnAddressSlot=slot;
        }
        public void caseNullType(        NullType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"" + t);
        }
      }
);
    }
    public void caseLoadInst(    LoadInst i){
      final int slot=((Integer)localToSlot.get(i.getLocal())).intValue();
      i.getOpType().apply(new TypeSwitch(){
        public void caseArrayType(        ArrayType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"" + t);
        }
        public void caseDoubleType(        DoubleType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseFloatType(        FloatType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseIntType(        IntType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseByteType(        ByteType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseShortType(        ShortType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseCharType(        CharType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseBooleanType(        BooleanType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseLongType(        LongType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseRefType(        RefType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseNullType(        NullType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
      }
);
    }
    public void caseArrayWriteInst(    ArrayWriteInst i){
      i.getOpType().apply(new TypeSwitch(){
        public void caseArrayType(        ArrayType t){
          emit(""String_Node_Str"");
        }
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"");
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"");
        }
        public void caseIntType(        IntType t){
          emit(""String_Node_Str"");
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"");
        }
        public void caseRefType(        RefType t){
          emit(""String_Node_Str"");
        }
        public void caseByteType(        ByteType t){
          emit(""String_Node_Str"");
        }
        public void caseBooleanType(        BooleanType t){
          emit(""String_Node_Str"");
        }
        public void caseCharType(        CharType t){
          emit(""String_Node_Str"");
        }
        public void caseShortType(        ShortType t){
          emit(""String_Node_Str"");
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"" + t);
        }
      }
);
    }
    public void caseArrayReadInst(    ArrayReadInst i){
      i.getOpType().apply(new TypeSwitch(){
        public void caseArrayType(        ArrayType ty){
          emit(""String_Node_Str"");
        }
        public void caseBooleanType(        BooleanType ty){
          emit(""String_Node_Str"");
        }
        public void caseByteType(        ByteType ty){
          emit(""String_Node_Str"");
        }
        public void caseCharType(        CharType ty){
          emit(""String_Node_Str"");
        }
        public void defaultCase(        Type ty){
          throw new RuntimeException(""String_Node_Str"");
        }
        public void caseDoubleType(        DoubleType ty){
          emit(""String_Node_Str"");
        }
        public void caseFloatType(        FloatType ty){
          emit(""String_Node_Str"");
        }
        public void caseIntType(        IntType ty){
          emit(""String_Node_Str"");
        }
        public void caseLongType(        LongType ty){
          emit(""String_Node_Str"");
        }
        public void caseNullType(        NullType ty){
          emit(""String_Node_Str"");
        }
        public void caseRefType(        RefType ty){
          emit(""String_Node_Str"");
        }
        public void caseShortType(        ShortType ty){
          emit(""String_Node_Str"");
        }
      }
);
    }
    public void caseIfNullInst(    IfNullInst i){
      emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
    }
    public void caseIfNonNullInst(    IfNonNullInst i){
      emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
    }
    public void caseIfEqInst(    IfEqInst i){
      emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
    }
    public void caseIfNeInst(    IfNeInst i){
      emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
    }
    public void caseIfGtInst(    IfGtInst i){
      emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
    }
    public void caseIfGeInst(    IfGeInst i){
      emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
    }
    public void caseIfLtInst(    IfLtInst i){
      emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
    }
    public void caseIfLeInst(    IfLeInst i){
      emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
    }
    public void caseIfCmpEqInst(    final IfCmpEqInst i){
      i.getOpType().apply(new TypeSwitch(){
        public void caseIntType(        IntType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseBooleanType(        BooleanType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseShortType(        ShortType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseCharType(        CharType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseByteType(        ByteType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseArrayType(        ArrayType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseRefType(        RefType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseNullType(        NullType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseIfCmpNeInst(    final IfCmpNeInst i){
      i.getOpType().apply(new TypeSwitch(){
        public void caseIntType(        IntType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseBooleanType(        BooleanType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseShortType(        ShortType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseCharType(        CharType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseByteType(        ByteType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseArrayType(        ArrayType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseRefType(        RefType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseNullType(        NullType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseIfCmpGtInst(    final IfCmpGtInst i){
      i.getOpType().apply(new TypeSwitch(){
        public void caseIntType(        IntType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseBooleanType(        BooleanType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseShortType(        ShortType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseCharType(        CharType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseByteType(        ByteType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseArrayType(        ArrayType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseRefType(        RefType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseNullType(        NullType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseIfCmpGeInst(    final IfCmpGeInst i){
      i.getOpType().apply(new TypeSwitch(){
        public void caseIntType(        IntType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseBooleanType(        BooleanType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseShortType(        ShortType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseCharType(        CharType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseByteType(        ByteType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseArrayType(        ArrayType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseRefType(        RefType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseNullType(        NullType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseIfCmpLtInst(    final IfCmpLtInst i){
      i.getOpType().apply(new TypeSwitch(){
        public void caseIntType(        IntType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseBooleanType(        BooleanType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseShortType(        ShortType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseCharType(        CharType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseByteType(        ByteType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseArrayType(        ArrayType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseRefType(        RefType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseNullType(        NullType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseIfCmpLeInst(    final IfCmpLeInst i){
      i.getOpType().apply(new TypeSwitch(){
        public void caseIntType(        IntType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseBooleanType(        BooleanType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseShortType(        ShortType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseCharType(        CharType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseByteType(        ByteType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseArrayType(        ArrayType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseRefType(        RefType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseNullType(        NullType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseStaticGetInst(    StaticGetInst i){
      SootField field=i.getField();
      emit(""String_Node_Str"" + slashify(field.getDeclaringClass().getName()) + ""String_Node_Str""+ field.getName()+ ""String_Node_Str""+ jasminDescriptorOf(field.getType()));
    }
    public void caseStaticPutInst(    StaticPutInst i){
      emit(""String_Node_Str"" + slashify(i.getField().getDeclaringClass().getName()) + ""String_Node_Str""+ i.getField().getName()+ ""String_Node_Str""+ jasminDescriptorOf(i.getField().getType()));
    }
    public void caseFieldGetInst(    FieldGetInst i){
      emit(""String_Node_Str"" + slashify(i.getField().getDeclaringClass().getName()) + ""String_Node_Str""+ i.getField().getName()+ ""String_Node_Str""+ jasminDescriptorOf(i.getField().getType()));
    }
    public void caseFieldPutInst(    FieldPutInst i){
      emit(""String_Node_Str"" + slashify(i.getField().getDeclaringClass().getName()) + ""String_Node_Str""+ i.getField().getName()+ ""String_Node_Str""+ jasminDescriptorOf(i.getField().getType()));
    }
    public void caseInstanceCastInst(    InstanceCastInst i){
      Type castType=i.getCastType();
      if (castType instanceof RefType)       emit(""String_Node_Str"" + slashify(castType.toString()));
 else       if (castType instanceof ArrayType)       emit(""String_Node_Str"" + jasminDescriptorOf(castType));
    }
    public void caseInstanceOfInst(    InstanceOfInst i){
      Type checkType=i.getCheckType();
      if (checkType instanceof RefType)       emit(""String_Node_Str"" + slashify(checkType.toString()));
 else       if (checkType instanceof ArrayType)       emit(""String_Node_Str"" + jasminDescriptorOf(checkType));
    }
    public void caseNewInst(    NewInst i){
      emit(""String_Node_Str"" + slashify(i.getBaseType().toString()));
    }
    public void casePrimitiveCastInst(    PrimitiveCastInst i){
      emit(i.toString());
    }
    public void caseStaticInvokeInst(    StaticInvokeInst i){
      SootMethod m=i.getMethod();
      emit(""String_Node_Str"" + slashify(m.getDeclaringClass().getName()) + ""String_Node_Str""+ m.getName()+ jasminDescriptorOf(m));
    }
    public void caseVirtualInvokeInst(    VirtualInvokeInst i){
      SootMethod m=i.getMethod();
      emit(""String_Node_Str"" + slashify(m.getDeclaringClass().getName()) + ""String_Node_Str""+ m.getName()+ jasminDescriptorOf(m));
    }
    public void caseInterfaceInvokeInst(    InterfaceInvokeInst i){
      SootMethod m=i.getMethod();
      emit(""String_Node_Str"" + slashify(m.getDeclaringClass().getName()) + ""String_Node_Str""+ m.getName()+ jasminDescriptorOf(m)+ ""String_Node_Str""+ (argCountOf(m) + 1));
    }
    public void caseSpecialInvokeInst(    SpecialInvokeInst i){
      SootMethod m=i.getMethod();
      emit(""String_Node_Str"" + slashify(m.getDeclaringClass().getName()) + ""String_Node_Str""+ m.getName()+ jasminDescriptorOf(m));
    }
    public void caseThrowInst(    ThrowInst i){
      emit(""String_Node_Str"");
    }
    public void caseCmpInst(    CmpInst i){
      emit(""String_Node_Str"");
    }
    public void caseCmplInst(    CmplInst i){
      if (i.getOpType().equals(FloatType.v()))       emit(""String_Node_Str"");
 else       emit(""String_Node_Str"");
    }
    public void caseCmpgInst(    CmpgInst i){
      if (i.getOpType().equals(FloatType.v()))       emit(""String_Node_Str"");
 else       emit(""String_Node_Str"");
    }
    private void emitOpTypeInst(    final String s,    final OpTypeArgInst i){
      i.getOpType().apply(new TypeSwitch(){
        private void handleIntCase(){
          emit(""String_Node_Str"" + s);
        }
        public void caseIntType(        IntType t){
          handleIntCase();
        }
        public void caseBooleanType(        BooleanType t){
          handleIntCase();
        }
        public void caseShortType(        ShortType t){
          handleIntCase();
        }
        public void caseCharType(        CharType t){
          handleIntCase();
        }
        public void caseByteType(        ByteType t){
          handleIntCase();
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"" + s);
        }
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"" + s);
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"" + s);
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseAddInst(    AddInst i){
      emitOpTypeInst(""String_Node_Str"",i);
    }
    public void caseDivInst(    DivInst i){
      emitOpTypeInst(""String_Node_Str"",i);
    }
    public void caseSubInst(    SubInst i){
      emitOpTypeInst(""String_Node_Str"",i);
    }
    public void caseMulInst(    MulInst i){
      emitOpTypeInst(""String_Node_Str"",i);
    }
    public void caseRemInst(    RemInst i){
      emitOpTypeInst(""String_Node_Str"",i);
    }
    public void caseShlInst(    ShlInst i){
      emitOpTypeInst(""String_Node_Str"",i);
    }
    public void caseAndInst(    AndInst i){
      emitOpTypeInst(""String_Node_Str"",i);
    }
    public void caseOrInst(    OrInst i){
      emitOpTypeInst(""String_Node_Str"",i);
    }
    public void caseXorInst(    XorInst i){
      emitOpTypeInst(""String_Node_Str"",i);
    }
    public void caseShrInst(    ShrInst i){
      emitOpTypeInst(""String_Node_Str"",i);
    }
    public void caseUshrInst(    UshrInst i){
      emitOpTypeInst(""String_Node_Str"",i);
    }
    public void caseIncInst(    IncInst i){
      if (((ValueBox)i.getUseBoxes().get(0)).getValue() != ((ValueBox)i.getDefBoxes().get(0)).getValue())       throw new RuntimeException(""String_Node_Str"");
      emit(""String_Node_Str"" + ((Integer)localToSlot.get(i.getLocal())) + ""String_Node_Str""+ i.getConstant());
    }
    public void caseArrayLengthInst(    ArrayLengthInst i){
      emit(""String_Node_Str"");
    }
    public void caseNegInst(    NegInst i){
      emitOpTypeInst(""String_Node_Str"",i);
    }
    public void caseNewArrayInst(    NewArrayInst i){
      if (i.getBaseType() instanceof RefType)       emit(""String_Node_Str"" + slashify(i.getBaseType().toString()));
 else       if (i.getBaseType() instanceof ArrayType)       emit(""String_Node_Str"" + jasminDescriptorOf(i.getBaseType()));
 else       emit(""String_Node_Str"" + i.getBaseType().toString());
    }
    public void caseNewMultiArrayInst(    NewMultiArrayInst i){
      emit(""String_Node_Str"" + jasminDescriptorOf(i.getBaseType()) + ""String_Node_Str""+ i.getDimensionCount());
    }
    public void caseLookupSwitchInst(    LookupSwitchInst i){
      emit(""String_Node_Str"");
      List lookupValues=i.getLookupValues();
      List targets=i.getTargets();
      for (int j=0; j < lookupValues.size(); j++)       emit(""String_Node_Str"" + lookupValues.get(j) + ""String_Node_Str""+ unitToLabel.get(targets.get(j)));
      emit(""String_Node_Str"" + unitToLabel.get(i.getDefaultTarget()));
    }
    public void caseTableSwitchInst(    TableSwitchInst i){
      emit(""String_Node_Str"" + i.getLowIndex() + ""String_Node_Str""+ i.getHighIndex());
      List targets=i.getTargets();
      for (int j=0; j < targets.size(); j++)       emit(""String_Node_Str"" + unitToLabel.get(targets.get(j)));
      emit(""String_Node_Str"" + unitToLabel.get(i.getDefaultTarget()));
    }
    private boolean isDwordType(    Type t){
      return t instanceof LongType || t instanceof DoubleType || t instanceof DoubleWordType;
    }
    public void caseDup1Inst(    Dup1Inst i){
      Type firstOpType=i.getOp1Type();
      if (isDwordType(firstOpType))       emit(""String_Node_Str"");
 else       emit(""String_Node_Str"");
    }
    public void caseDup2Inst(    Dup2Inst i){
      Type firstOpType=i.getOp1Type();
      Type secondOpType=i.getOp2Type();
      if (isDwordType(firstOpType)) {
        emit(""String_Node_Str"");
        if (isDwordType(secondOpType)) {
          emit(""String_Node_Str"");
        }
 else         emit(""String_Node_Str"");
      }
 else       if (isDwordType(secondOpType)) {
        if (isDwordType(firstOpType)) {
          emit(""String_Node_Str"");
        }
 else         emit(""String_Node_Str"");
        emit(""String_Node_Str"");
      }
 else {
        G.v().out.println(""String_Node_Str"");
        emit(""String_Node_Str"");
      }
    }
    public void caseDup1_x1Inst(    Dup1_x1Inst i){
      Type opType=i.getOp1Type();
      Type underType=i.getUnder1Type();
      if (isDwordType(opType)) {
        if (isDwordType(underType)) {
          emit(""String_Node_Str"");
        }
 else         emit(""String_Node_Str"");
      }
 else {
        if (isDwordType(underType))         emit(""String_Node_Str"");
 else         emit(""String_Node_Str"");
      }
    }
    public void caseDup1_x2Inst(    Dup1_x2Inst i){
      Type opType=i.getOp1Type();
      Type under1Type=i.getUnder1Type();
      Type under2Type=i.getUnder2Type();
      if (isDwordType(opType)) {
        if (!isDwordType(under1Type) && !isDwordType(under2Type))         emit(""String_Node_Str"");
 else         throw new RuntimeException(""String_Node_Str"");
      }
 else {
        if (isDwordType(under1Type) || isDwordType(under2Type))         throw new RuntimeException(""String_Node_Str"");
      }
      emit(""String_Node_Str"");
    }
    public void caseDup2_x1Inst(    Dup2_x1Inst i){
      Type op1Type=i.getOp1Type();
      Type op2Type=i.getOp2Type();
      Type under1Type=i.getUnder1Type();
      if (isDwordType(under1Type)) {
        if (!isDwordType(op1Type) && !isDwordType(op2Type))         throw new RuntimeException(""String_Node_Str"");
 else         emit(""String_Node_Str"");
      }
 else {
        if (isDwordType(op1Type) || isDwordType(op2Type))         throw new RuntimeException(""String_Node_Str"");
      }
      emit(""String_Node_Str"");
    }
    public void caseDup2_x2Inst(    Dup2_x2Inst i){
      Type op1Type=i.getOp1Type();
      Type op2Type=i.getOp2Type();
      Type under1Type=i.getUnder1Type();
      Type under2Type=i.getUnder2Type();
      if (isDwordType(op1Type) || isDwordType(op2Type) || isDwordType(under1Type)|| isDwordType(under1Type))       throw new RuntimeException(""String_Node_Str"");
      emit(""String_Node_Str"");
    }
    public void caseSwapInst(    SwapInst i){
      emit(""String_Node_Str"");
    }
  }
);
}","void emitInst(Inst inst){
  inst.apply(new InstSwitch(){
    public void caseReturnVoidInst(    ReturnVoidInst i){
      emit(""String_Node_Str"");
    }
    public void caseReturnInst(    ReturnInst i){
      i.getOpType().apply(new TypeSwitch(){
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"" + t.toString());
        }
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"");
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"");
        }
        public void caseIntType(        IntType t){
          emit(""String_Node_Str"");
        }
        public void caseByteType(        ByteType t){
          emit(""String_Node_Str"");
        }
        public void caseShortType(        ShortType t){
          emit(""String_Node_Str"");
        }
        public void caseCharType(        CharType t){
          emit(""String_Node_Str"");
        }
        public void caseBooleanType(        BooleanType t){
          emit(""String_Node_Str"");
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"");
        }
        public void caseArrayType(        ArrayType t){
          emit(""String_Node_Str"");
        }
        public void caseRefType(        RefType t){
          emit(""String_Node_Str"");
        }
        public void caseNullType(        NullType t){
          emit(""String_Node_Str"");
        }
      }
);
    }
    public void caseNopInst(    NopInst i){
      emit(""String_Node_Str"");
    }
    public void caseEnterMonitorInst(    EnterMonitorInst i){
      emit(""String_Node_Str"");
    }
    public void casePopInst(    PopInst i){
      if (i.getWordCount() == 2) {
        emit(""String_Node_Str"");
      }
 else       emit(""String_Node_Str"");
    }
    public void caseExitMonitorInst(    ExitMonitorInst i){
      emit(""String_Node_Str"");
    }
    public void caseGotoInst(    GotoInst i){
      emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
    }
    public void casePushInst(    PushInst i){
      if (i.getConstant() instanceof IntConstant) {
        IntConstant v=(IntConstant)(i.getConstant());
        if (v.value == -1)         emit(""String_Node_Str"");
 else         if (v.value >= 0 && v.value <= 5)         emit(""String_Node_Str"" + v.value);
 else         if (v.value >= Byte.MIN_VALUE && v.value <= Byte.MAX_VALUE)         emit(""String_Node_Str"" + v.value);
 else         if (v.value >= Short.MIN_VALUE && v.value <= Short.MAX_VALUE)         emit(""String_Node_Str"" + v.value);
 else         emit(""String_Node_Str"" + v.toString());
      }
 else       if (i.getConstant() instanceof StringConstant) {
        emit(""String_Node_Str"" + i.getConstant().toString());
      }
 else       if (i.getConstant() instanceof DoubleConstant) {
        DoubleConstant v=(DoubleConstant)(i.getConstant());
        if ((v.value == 0) && ((1.0 / v.value) > 0.0))         emit(""String_Node_Str"");
 else         if (v.value == 1)         emit(""String_Node_Str"");
 else {
          String s=v.toString();
          if (s.equals(""String_Node_Str""))           s=""String_Node_Str"";
          if (s.equals(""String_Node_Str""))           s=""String_Node_Str"";
          if (s.equals(""String_Node_Str""))           s=""String_Node_Str"";
          emit(""String_Node_Str"" + s);
        }
      }
 else       if (i.getConstant() instanceof FloatConstant) {
        FloatConstant v=(FloatConstant)(i.getConstant());
        if ((v.value == 0) && ((1.0f / v.value) > 1.0f))         emit(""String_Node_Str"");
 else         if (v.value == 1)         emit(""String_Node_Str"");
 else         if (v.value == 2)         emit(""String_Node_Str"");
 else {
          String s=v.toString();
          if (s.equals(""String_Node_Str""))           s=""String_Node_Str"";
          if (s.equals(""String_Node_Str""))           s=""String_Node_Str"";
          if (s.equals(""String_Node_Str""))           s=""String_Node_Str"";
          emit(""String_Node_Str"" + s);
        }
      }
 else       if (i.getConstant() instanceof LongConstant) {
        LongConstant v=(LongConstant)(i.getConstant());
        if (v.value == 0)         emit(""String_Node_Str"");
 else         if (v.value == 1)         emit(""String_Node_Str"");
 else         emit(""String_Node_Str"" + v.toString());
      }
 else       if (i.getConstant() instanceof NullConstant)       emit(""String_Node_Str"");
 else       throw new RuntimeException(""String_Node_Str"");
    }
    public void caseIdentityInst(    IdentityInst i){
      if (i.getRightOp() instanceof CaughtExceptionRef && i.getLeftOp() instanceof Local) {
        int slot=((Integer)localToSlot.get(i.getLeftOp())).intValue();
        if (slot >= 0 && slot <= 3)         emit(""String_Node_Str"" + slot);
 else         emit(""String_Node_Str"" + slot);
      }
    }
    public void caseStoreInst(    StoreInst i){
      final int slot=((Integer)localToSlot.get(i.getLocal())).intValue();
      i.getOpType().apply(new TypeSwitch(){
        public void caseArrayType(        ArrayType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseDoubleType(        DoubleType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseFloatType(        FloatType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseIntType(        IntType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseByteType(        ByteType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseShortType(        ShortType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseCharType(        CharType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseBooleanType(        BooleanType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseLongType(        LongType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseRefType(        RefType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseStmtAddressType(        StmtAddressType t){
          isNextGotoAJsr=true;
          returnAddressSlot=slot;
        }
        public void caseNullType(        NullType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"" + t);
        }
      }
);
    }
    public void caseLoadInst(    LoadInst i){
      final int slot=((Integer)localToSlot.get(i.getLocal())).intValue();
      i.getOpType().apply(new TypeSwitch(){
        public void caseArrayType(        ArrayType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"" + t);
        }
        public void caseDoubleType(        DoubleType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseFloatType(        FloatType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseIntType(        IntType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseByteType(        ByteType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseShortType(        ShortType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseCharType(        CharType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseBooleanType(        BooleanType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseLongType(        LongType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseRefType(        RefType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseNullType(        NullType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
      }
);
    }
    public void caseArrayWriteInst(    ArrayWriteInst i){
      i.getOpType().apply(new TypeSwitch(){
        public void caseArrayType(        ArrayType t){
          emit(""String_Node_Str"");
        }
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"");
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"");
        }
        public void caseIntType(        IntType t){
          emit(""String_Node_Str"");
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"");
        }
        public void caseRefType(        RefType t){
          emit(""String_Node_Str"");
        }
        public void caseByteType(        ByteType t){
          emit(""String_Node_Str"");
        }
        public void caseBooleanType(        BooleanType t){
          emit(""String_Node_Str"");
        }
        public void caseCharType(        CharType t){
          emit(""String_Node_Str"");
        }
        public void caseShortType(        ShortType t){
          emit(""String_Node_Str"");
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"" + t);
        }
      }
);
    }
    public void caseArrayReadInst(    ArrayReadInst i){
      i.getOpType().apply(new TypeSwitch(){
        public void caseArrayType(        ArrayType ty){
          emit(""String_Node_Str"");
        }
        public void caseBooleanType(        BooleanType ty){
          emit(""String_Node_Str"");
        }
        public void caseByteType(        ByteType ty){
          emit(""String_Node_Str"");
        }
        public void caseCharType(        CharType ty){
          emit(""String_Node_Str"");
        }
        public void defaultCase(        Type ty){
          throw new RuntimeException(""String_Node_Str"");
        }
        public void caseDoubleType(        DoubleType ty){
          emit(""String_Node_Str"");
        }
        public void caseFloatType(        FloatType ty){
          emit(""String_Node_Str"");
        }
        public void caseIntType(        IntType ty){
          emit(""String_Node_Str"");
        }
        public void caseLongType(        LongType ty){
          emit(""String_Node_Str"");
        }
        public void caseNullType(        NullType ty){
          emit(""String_Node_Str"");
        }
        public void caseRefType(        RefType ty){
          emit(""String_Node_Str"");
        }
        public void caseShortType(        ShortType ty){
          emit(""String_Node_Str"");
        }
      }
);
    }
    public void caseIfNullInst(    IfNullInst i){
      emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
    }
    public void caseIfNonNullInst(    IfNonNullInst i){
      emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
    }
    public void caseIfEqInst(    IfEqInst i){
      emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
    }
    public void caseIfNeInst(    IfNeInst i){
      emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
    }
    public void caseIfGtInst(    IfGtInst i){
      emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
    }
    public void caseIfGeInst(    IfGeInst i){
      emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
    }
    public void caseIfLtInst(    IfLtInst i){
      emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
    }
    public void caseIfLeInst(    IfLeInst i){
      emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
    }
    public void caseIfCmpEqInst(    final IfCmpEqInst i){
      i.getOpType().apply(new TypeSwitch(){
        public void caseIntType(        IntType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseBooleanType(        BooleanType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseShortType(        ShortType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseCharType(        CharType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseByteType(        ByteType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseArrayType(        ArrayType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseRefType(        RefType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseNullType(        NullType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseIfCmpNeInst(    final IfCmpNeInst i){
      i.getOpType().apply(new TypeSwitch(){
        public void caseIntType(        IntType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseBooleanType(        BooleanType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseShortType(        ShortType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseCharType(        CharType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseByteType(        ByteType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseArrayType(        ArrayType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseRefType(        RefType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseNullType(        NullType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseIfCmpGtInst(    final IfCmpGtInst i){
      i.getOpType().apply(new TypeSwitch(){
        public void caseIntType(        IntType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseBooleanType(        BooleanType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseShortType(        ShortType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseCharType(        CharType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseByteType(        ByteType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseArrayType(        ArrayType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseRefType(        RefType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseNullType(        NullType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseIfCmpGeInst(    final IfCmpGeInst i){
      i.getOpType().apply(new TypeSwitch(){
        public void caseIntType(        IntType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseBooleanType(        BooleanType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseShortType(        ShortType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseCharType(        CharType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseByteType(        ByteType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseArrayType(        ArrayType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseRefType(        RefType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseNullType(        NullType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseIfCmpLtInst(    final IfCmpLtInst i){
      i.getOpType().apply(new TypeSwitch(){
        public void caseIntType(        IntType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseBooleanType(        BooleanType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseShortType(        ShortType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseCharType(        CharType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseByteType(        ByteType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseArrayType(        ArrayType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseRefType(        RefType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseNullType(        NullType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseIfCmpLeInst(    final IfCmpLeInst i){
      i.getOpType().apply(new TypeSwitch(){
        public void caseIntType(        IntType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseBooleanType(        BooleanType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseShortType(        ShortType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseCharType(        CharType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseByteType(        ByteType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseArrayType(        ArrayType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseRefType(        RefType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void caseNullType(        NullType t){
          emit(""String_Node_Str"" + unitToLabel.get(i.getTarget()));
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseStaticGetInst(    StaticGetInst i){
      SootField field=i.getField();
      emit(""String_Node_Str"" + slashify(field.getDeclaringClass().getName()) + ""String_Node_Str""+ field.getName()+ ""String_Node_Str""+ jasminDescriptorOf(field.getType()));
    }
    public void caseStaticPutInst(    StaticPutInst i){
      emit(""String_Node_Str"" + slashify(i.getField().getDeclaringClass().getName()) + ""String_Node_Str""+ i.getField().getName()+ ""String_Node_Str""+ jasminDescriptorOf(i.getField().getType()));
    }
    public void caseFieldGetInst(    FieldGetInst i){
      emit(""String_Node_Str"" + slashify(i.getField().getDeclaringClass().getName()) + ""String_Node_Str""+ i.getField().getName()+ ""String_Node_Str""+ jasminDescriptorOf(i.getField().getType()));
    }
    public void caseFieldPutInst(    FieldPutInst i){
      emit(""String_Node_Str"" + slashify(i.getField().getDeclaringClass().getName()) + ""String_Node_Str""+ i.getField().getName()+ ""String_Node_Str""+ jasminDescriptorOf(i.getField().getType()));
    }
    public void caseInstanceCastInst(    InstanceCastInst i){
      Type castType=i.getCastType();
      if (castType instanceof RefType)       emit(""String_Node_Str"" + slashify(castType.toString()));
 else       if (castType instanceof ArrayType)       emit(""String_Node_Str"" + jasminDescriptorOf(castType));
    }
    public void caseInstanceOfInst(    InstanceOfInst i){
      Type checkType=i.getCheckType();
      if (checkType instanceof RefType)       emit(""String_Node_Str"" + slashify(checkType.toString()));
 else       if (checkType instanceof ArrayType)       emit(""String_Node_Str"" + jasminDescriptorOf(checkType));
    }
    public void caseNewInst(    NewInst i){
      emit(""String_Node_Str"" + slashify(i.getBaseType().toString()));
    }
    public void casePrimitiveCastInst(    PrimitiveCastInst i){
      emit(i.toString());
    }
    public void caseStaticInvokeInst(    StaticInvokeInst i){
      SootMethod m=i.getMethod();
      emit(""String_Node_Str"" + slashify(m.getDeclaringClass().getName()) + ""String_Node_Str""+ m.getName()+ jasminDescriptorOf(m));
    }
    public void caseVirtualInvokeInst(    VirtualInvokeInst i){
      SootMethod m=i.getMethod();
      emit(""String_Node_Str"" + slashify(m.getDeclaringClass().getName()) + ""String_Node_Str""+ m.getName()+ jasminDescriptorOf(m));
    }
    public void caseInterfaceInvokeInst(    InterfaceInvokeInst i){
      SootMethod m=i.getMethod();
      emit(""String_Node_Str"" + slashify(m.getDeclaringClass().getName()) + ""String_Node_Str""+ m.getName()+ jasminDescriptorOf(m)+ ""String_Node_Str""+ (argCountOf(m) + 1));
    }
    public void caseSpecialInvokeInst(    SpecialInvokeInst i){
      SootMethod m=i.getMethod();
      emit(""String_Node_Str"" + slashify(m.getDeclaringClass().getName()) + ""String_Node_Str""+ m.getName()+ jasminDescriptorOf(m));
    }
    public void caseThrowInst(    ThrowInst i){
      emit(""String_Node_Str"");
    }
    public void caseCmpInst(    CmpInst i){
      emit(""String_Node_Str"");
    }
    public void caseCmplInst(    CmplInst i){
      if (i.getOpType().equals(FloatType.v()))       emit(""String_Node_Str"");
 else       emit(""String_Node_Str"");
    }
    public void caseCmpgInst(    CmpgInst i){
      if (i.getOpType().equals(FloatType.v()))       emit(""String_Node_Str"");
 else       emit(""String_Node_Str"");
    }
    private void emitOpTypeInst(    final String s,    final OpTypeArgInst i){
      i.getOpType().apply(new TypeSwitch(){
        private void handleIntCase(){
          emit(""String_Node_Str"" + s);
        }
        public void caseIntType(        IntType t){
          handleIntCase();
        }
        public void caseBooleanType(        BooleanType t){
          handleIntCase();
        }
        public void caseShortType(        ShortType t){
          handleIntCase();
        }
        public void caseCharType(        CharType t){
          handleIntCase();
        }
        public void caseByteType(        ByteType t){
          handleIntCase();
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"" + s);
        }
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"" + s);
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"" + s);
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseAddInst(    AddInst i){
      emitOpTypeInst(""String_Node_Str"",i);
    }
    public void caseDivInst(    DivInst i){
      emitOpTypeInst(""String_Node_Str"",i);
    }
    public void caseSubInst(    SubInst i){
      emitOpTypeInst(""String_Node_Str"",i);
    }
    public void caseMulInst(    MulInst i){
      emitOpTypeInst(""String_Node_Str"",i);
    }
    public void caseRemInst(    RemInst i){
      emitOpTypeInst(""String_Node_Str"",i);
    }
    public void caseShlInst(    ShlInst i){
      emitOpTypeInst(""String_Node_Str"",i);
    }
    public void caseAndInst(    AndInst i){
      emitOpTypeInst(""String_Node_Str"",i);
    }
    public void caseOrInst(    OrInst i){
      emitOpTypeInst(""String_Node_Str"",i);
    }
    public void caseXorInst(    XorInst i){
      emitOpTypeInst(""String_Node_Str"",i);
    }
    public void caseShrInst(    ShrInst i){
      emitOpTypeInst(""String_Node_Str"",i);
    }
    public void caseUshrInst(    UshrInst i){
      emitOpTypeInst(""String_Node_Str"",i);
    }
    public void caseIncInst(    IncInst i){
      if (((ValueBox)i.getUseBoxes().get(0)).getValue() != ((ValueBox)i.getDefBoxes().get(0)).getValue())       throw new RuntimeException(""String_Node_Str"");
      emit(""String_Node_Str"" + ((Integer)localToSlot.get(i.getLocal())) + ""String_Node_Str""+ i.getConstant());
    }
    public void caseArrayLengthInst(    ArrayLengthInst i){
      emit(""String_Node_Str"");
    }
    public void caseNegInst(    NegInst i){
      emitOpTypeInst(""String_Node_Str"",i);
    }
    public void caseNewArrayInst(    NewArrayInst i){
      if (i.getBaseType() instanceof RefType)       emit(""String_Node_Str"" + slashify(i.getBaseType().toString()));
 else       if (i.getBaseType() instanceof ArrayType)       emit(""String_Node_Str"" + jasminDescriptorOf(i.getBaseType()));
 else       emit(""String_Node_Str"" + i.getBaseType().toString());
    }
    public void caseNewMultiArrayInst(    NewMultiArrayInst i){
      emit(""String_Node_Str"" + jasminDescriptorOf(i.getBaseType()) + ""String_Node_Str""+ i.getDimensionCount());
    }
    public void caseLookupSwitchInst(    LookupSwitchInst i){
      emit(""String_Node_Str"");
      List lookupValues=i.getLookupValues();
      List targets=i.getTargets();
      for (int j=0; j < lookupValues.size(); j++)       emit(""String_Node_Str"" + lookupValues.get(j) + ""String_Node_Str""+ unitToLabel.get(targets.get(j)));
      emit(""String_Node_Str"" + unitToLabel.get(i.getDefaultTarget()));
    }
    public void caseTableSwitchInst(    TableSwitchInst i){
      emit(""String_Node_Str"" + i.getLowIndex() + ""String_Node_Str""+ i.getHighIndex());
      List targets=i.getTargets();
      for (int j=0; j < targets.size(); j++)       emit(""String_Node_Str"" + unitToLabel.get(targets.get(j)));
      emit(""String_Node_Str"" + unitToLabel.get(i.getDefaultTarget()));
    }
    private boolean isDwordType(    Type t){
      return t instanceof LongType || t instanceof DoubleType || t instanceof DoubleWordType;
    }
    public void caseDup1Inst(    Dup1Inst i){
      Type firstOpType=i.getOp1Type();
      if (isDwordType(firstOpType))       emit(""String_Node_Str"");
 else       emit(""String_Node_Str"");
    }
    public void caseDup2Inst(    Dup2Inst i){
      Type firstOpType=i.getOp1Type();
      Type secondOpType=i.getOp2Type();
      if (isDwordType(firstOpType)) {
        emit(""String_Node_Str"");
        if (isDwordType(secondOpType)) {
          emit(""String_Node_Str"");
        }
 else         emit(""String_Node_Str"");
      }
 else       if (isDwordType(secondOpType)) {
        if (isDwordType(firstOpType)) {
          emit(""String_Node_Str"");
        }
 else         emit(""String_Node_Str"");
        emit(""String_Node_Str"");
      }
 else {
        G.v().out.println(""String_Node_Str"");
        emit(""String_Node_Str"");
      }
    }
    public void caseDup1_x1Inst(    Dup1_x1Inst i){
      Type opType=i.getOp1Type();
      Type underType=i.getUnder1Type();
      if (isDwordType(opType)) {
        if (isDwordType(underType)) {
          emit(""String_Node_Str"");
        }
 else         emit(""String_Node_Str"");
      }
 else {
        if (isDwordType(underType))         emit(""String_Node_Str"");
 else         emit(""String_Node_Str"");
      }
    }
    public void caseDup1_x2Inst(    Dup1_x2Inst i){
      Type opType=i.getOp1Type();
      Type under1Type=i.getUnder1Type();
      Type under2Type=i.getUnder2Type();
      if (isDwordType(opType)) {
        if (!isDwordType(under1Type) && !isDwordType(under2Type))         emit(""String_Node_Str"");
 else         throw new RuntimeException(""String_Node_Str"");
      }
 else {
        if (isDwordType(under1Type) || isDwordType(under2Type))         throw new RuntimeException(""String_Node_Str"");
      }
      emit(""String_Node_Str"");
    }
    public void caseDup2_x1Inst(    Dup2_x1Inst i){
      Type op1Type=i.getOp1Type();
      Type op2Type=i.getOp2Type();
      Type under1Type=i.getUnder1Type();
      if (isDwordType(under1Type)) {
        if (!isDwordType(op1Type) && !isDwordType(op2Type))         throw new RuntimeException(""String_Node_Str"");
 else         emit(""String_Node_Str"");
      }
 else {
        if (isDwordType(op1Type) || isDwordType(op2Type))         throw new RuntimeException(""String_Node_Str"");
      }
      emit(""String_Node_Str"");
    }
    public void caseDup2_x2Inst(    Dup2_x2Inst i){
      Type op1Type=i.getOp1Type();
      Type op2Type=i.getOp2Type();
      Type under1Type=i.getUnder1Type();
      Type under2Type=i.getUnder2Type();
      if (isDwordType(op1Type) || isDwordType(op2Type) || isDwordType(under1Type)|| isDwordType(under1Type))       throw new RuntimeException(""String_Node_Str"");
      emit(""String_Node_Str"");
    }
    public void caseSwapInst(    SwapInst i){
      emit(""String_Node_Str"");
    }
  }
);
}"
88637,"public void casePushInst(PushInst i){
  if (i.getConstant() instanceof IntConstant) {
    IntConstant v=(IntConstant)(i.getConstant());
    if (v.value == -1)     emit(""String_Node_Str"");
 else     if (v.value >= 0 && v.value <= 5)     emit(""String_Node_Str"" + v.value);
 else     if (v.value >= Byte.MIN_VALUE && v.value <= Byte.MAX_VALUE)     emit(""String_Node_Str"" + v.value);
 else     if (v.value >= Short.MIN_VALUE && v.value <= Short.MAX_VALUE)     emit(""String_Node_Str"" + v.value);
 else     emit(""String_Node_Str"" + v.toString());
  }
 else   if (i.getConstant() instanceof StringConstant) {
    emit(""String_Node_Str"" + i.getConstant().toString());
  }
 else   if (i.getConstant() instanceof DoubleConstant) {
    DoubleConstant v=(DoubleConstant)(i.getConstant());
    if (v.value == 0)     emit(""String_Node_Str"");
 else     if (v.value == 1)     emit(""String_Node_Str"");
 else {
      String s=v.toString();
      if (s.equals(""String_Node_Str""))       s=""String_Node_Str"";
      if (s.equals(""String_Node_Str""))       s=""String_Node_Str"";
      if (s.equals(""String_Node_Str""))       s=""String_Node_Str"";
      emit(""String_Node_Str"" + s);
    }
  }
 else   if (i.getConstant() instanceof FloatConstant) {
    FloatConstant v=(FloatConstant)(i.getConstant());
    if (v.value == 0)     emit(""String_Node_Str"");
 else     if (v.value == 1)     emit(""String_Node_Str"");
 else     if (v.value == 2)     emit(""String_Node_Str"");
 else {
      String s=v.toString();
      if (s.equals(""String_Node_Str""))       s=""String_Node_Str"";
      if (s.equals(""String_Node_Str""))       s=""String_Node_Str"";
      if (s.equals(""String_Node_Str""))       s=""String_Node_Str"";
      emit(""String_Node_Str"" + s);
    }
  }
 else   if (i.getConstant() instanceof LongConstant) {
    LongConstant v=(LongConstant)(i.getConstant());
    if (v.value == 0)     emit(""String_Node_Str"");
 else     if (v.value == 1)     emit(""String_Node_Str"");
 else     emit(""String_Node_Str"" + v.toString());
  }
 else   if (i.getConstant() instanceof NullConstant)   emit(""String_Node_Str"");
 else   throw new RuntimeException(""String_Node_Str"");
}","public void casePushInst(PushInst i){
  if (i.getConstant() instanceof IntConstant) {
    IntConstant v=(IntConstant)(i.getConstant());
    if (v.value == -1)     emit(""String_Node_Str"");
 else     if (v.value >= 0 && v.value <= 5)     emit(""String_Node_Str"" + v.value);
 else     if (v.value >= Byte.MIN_VALUE && v.value <= Byte.MAX_VALUE)     emit(""String_Node_Str"" + v.value);
 else     if (v.value >= Short.MIN_VALUE && v.value <= Short.MAX_VALUE)     emit(""String_Node_Str"" + v.value);
 else     emit(""String_Node_Str"" + v.toString());
  }
 else   if (i.getConstant() instanceof StringConstant) {
    emit(""String_Node_Str"" + i.getConstant().toString());
  }
 else   if (i.getConstant() instanceof DoubleConstant) {
    DoubleConstant v=(DoubleConstant)(i.getConstant());
    if ((v.value == 0) && ((1.0 / v.value) > 0.0))     emit(""String_Node_Str"");
 else     if (v.value == 1)     emit(""String_Node_Str"");
 else {
      String s=v.toString();
      if (s.equals(""String_Node_Str""))       s=""String_Node_Str"";
      if (s.equals(""String_Node_Str""))       s=""String_Node_Str"";
      if (s.equals(""String_Node_Str""))       s=""String_Node_Str"";
      emit(""String_Node_Str"" + s);
    }
  }
 else   if (i.getConstant() instanceof FloatConstant) {
    FloatConstant v=(FloatConstant)(i.getConstant());
    if ((v.value == 0) && ((1.0f / v.value) > 1.0f))     emit(""String_Node_Str"");
 else     if (v.value == 1)     emit(""String_Node_Str"");
 else     if (v.value == 2)     emit(""String_Node_Str"");
 else {
      String s=v.toString();
      if (s.equals(""String_Node_Str""))       s=""String_Node_Str"";
      if (s.equals(""String_Node_Str""))       s=""String_Node_Str"";
      if (s.equals(""String_Node_Str""))       s=""String_Node_Str"";
      emit(""String_Node_Str"" + s);
    }
  }
 else   if (i.getConstant() instanceof LongConstant) {
    LongConstant v=(LongConstant)(i.getConstant());
    if (v.value == 0)     emit(""String_Node_Str"");
 else     if (v.value == 1)     emit(""String_Node_Str"");
 else     emit(""String_Node_Str"" + v.toString());
  }
 else   if (i.getConstant() instanceof NullConstant)   emit(""String_Node_Str"");
 else   throw new RuntimeException(""String_Node_Str"");
}"
88638,"private String createStringConstant(polyglot.ast.Node node){
  String s=null;
  if (node instanceof polyglot.ast.StringLit) {
    s=((polyglot.ast.StringLit)node).value();
  }
 else   if (node instanceof polyglot.ast.Field) {
    s=(((polyglot.ast.Field)node).fieldInstance().constantValue()).toString();
  }
 else   if (node instanceof polyglot.ast.Binary) {
    s=createStringConstantBinary((polyglot.ast.Binary)node);
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
  return s;
}","private String createStringConstant(polyglot.ast.Node node){
  String s=null;
  if (node instanceof polyglot.ast.StringLit) {
    s=((polyglot.ast.StringLit)node).value();
  }
 else   if (node instanceof polyglot.ast.Cast) {
    polyglot.ast.Cast cast=(polyglot.ast.Cast)node;
    if (cast.type().isChar()) {
      s=""String_Node_Str"" + (char)((Character)cast.constantValue()).charValue();
    }
 else {
      s=""String_Node_Str"" + cast.constantValue();
    }
  }
 else   if (node instanceof polyglot.ast.CharLit) {
    s=""String_Node_Str"" + ((polyglot.ast.CharLit)node).value();
  }
 else   if (node instanceof polyglot.ast.BooleanLit) {
    s=""String_Node_Str"" + ((polyglot.ast.BooleanLit)node).value();
  }
 else   if (node instanceof polyglot.ast.IntLit) {
    s=""String_Node_Str"" + ((polyglot.ast.IntLit)node).value();
  }
 else   if (node instanceof polyglot.ast.FloatLit) {
    s=""String_Node_Str"" + ((polyglot.ast.FloatLit)node).value();
  }
 else   if (node instanceof polyglot.ast.Field) {
    polyglot.ast.Field field=(polyglot.ast.Field)node;
    if (field.fieldInstance().constantValue() instanceof String) {
      s=(String)field.constantValue();
    }
 else     if (field.fieldInstance().constantValue() instanceof Boolean) {
      boolean val=((Boolean)field.constantValue()).booleanValue();
      int temp=val ? 1 : 0;
      s=""String_Node_Str"" + temp;
    }
 else     if (field.type().isChar()) {
      char val=(char)((Integer)field.constantValue()).intValue();
      s=""String_Node_Str"" + val;
    }
 else {
      Number num=(Number)field.fieldInstance().constantValue();
      num=createConstantCast(field.type(),num);
      if (num instanceof Long) {
        s=""String_Node_Str"" + ((Long)num).longValue();
      }
 else       if (num instanceof Double) {
        s=""String_Node_Str"" + ((Double)num).doubleValue();
      }
 else       if (num instanceof Float) {
        s=""String_Node_Str"" + ((Float)num).floatValue();
      }
 else       if (num instanceof Byte) {
        s=""String_Node_Str"" + ((Byte)num).byteValue();
      }
 else       if (num instanceof Short) {
        s=""String_Node_Str"" + ((Short)num).shortValue();
      }
 else {
        s=""String_Node_Str"" + ((Integer)num).intValue();
      }
    }
  }
 else   if (node instanceof polyglot.ast.Binary) {
    s=createStringConstantBinary((polyglot.ast.Binary)node);
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
  return s;
}"
88639,"private boolean areAllStringLits(polyglot.ast.Node node){
  if (node instanceof polyglot.ast.StringLit)   return true;
 else   if (node instanceof polyglot.ast.Field) {
    if (shouldReturnConstant((polyglot.ast.Field)node))     return true;
 else     return false;
  }
 else   if (node instanceof polyglot.ast.Binary) {
    if (areAllStringLitsBinary((polyglot.ast.Binary)node))     return true;
    return false;
  }
  return false;
}","private boolean areAllStringLits(polyglot.ast.Node node){
  if (node instanceof polyglot.ast.StringLit)   return true;
 else   if (node instanceof polyglot.ast.Field) {
    if (shouldReturnConstant((polyglot.ast.Field)node))     return true;
 else     return false;
  }
 else   if (node instanceof polyglot.ast.Binary) {
    if (areAllStringLitsBinary((polyglot.ast.Binary)node))     return true;
    return false;
  }
 else   if (node instanceof polyglot.ast.Cast) {
    polyglot.ast.Cast cast=(polyglot.ast.Cast)node;
    if (cast.isConstant()) {
      return true;
    }
    return false;
  }
 else   if (node instanceof polyglot.ast.Lit) {
    polyglot.ast.Lit lit=(polyglot.ast.Lit)node;
    if (lit.isConstant()) {
      return true;
    }
    return false;
  }
  return false;
}"
88640,"private soot.jimple.Constant getReturnConstant(polyglot.ast.Field field){
  if (field.fieldInstance().constantValue() instanceof String) {
    return soot.jimple.StringConstant.v((String)field.constantValue());
  }
 else   if (field.fieldInstance().constantValue() instanceof Boolean) {
    boolean val=((Boolean)field.constantValue()).booleanValue();
    return soot.jimple.IntConstant.v(val ? 1 : 0);
  }
 else   if (field.fieldInstance().constantValue() instanceof Character) {
    char val=((Character)field.constantValue()).charValue();
    return soot.jimple.IntConstant.v(val);
  }
 else {
    Number num=(Number)field.fieldInstance().constantValue();
    num=createConstantCast(field.type(),num);
    if (num instanceof Long) {
      return soot.jimple.LongConstant.v(((Long)num).longValue());
    }
 else     if (num instanceof Double) {
      return soot.jimple.DoubleConstant.v(((Double)num).doubleValue());
    }
 else     if (num instanceof Float) {
      return soot.jimple.FloatConstant.v(((Float)num).floatValue());
    }
 else     if (num instanceof Byte) {
      return soot.jimple.IntConstant.v(((Byte)num).byteValue());
    }
 else     if (num instanceof Short) {
      return soot.jimple.IntConstant.v(((Short)num).shortValue());
    }
 else {
      return soot.jimple.IntConstant.v(((Integer)num).intValue());
    }
  }
}","private soot.jimple.Constant getReturnConstant(polyglot.ast.Field field){
  if (field.fieldInstance().constantValue() instanceof String) {
    return soot.jimple.StringConstant.v((String)field.constantValue());
  }
 else   if (field.fieldInstance().constantValue() instanceof Boolean) {
    boolean val=((Boolean)field.constantValue()).booleanValue();
    return soot.jimple.IntConstant.v(val ? 1 : 0);
  }
 else   if (field.type().isChar()) {
    char val=(char)((Integer)field.constantValue()).intValue();
    return soot.jimple.IntConstant.v(val);
  }
 else {
    Number num=(Number)field.fieldInstance().constantValue();
    num=createConstantCast(field.type(),num);
    if (num instanceof Long) {
      return soot.jimple.LongConstant.v(((Long)num).longValue());
    }
 else     if (num instanceof Double) {
      return soot.jimple.DoubleConstant.v(((Double)num).doubleValue());
    }
 else     if (num instanceof Float) {
      return soot.jimple.FloatConstant.v(((Float)num).floatValue());
    }
 else     if (num instanceof Byte) {
      return soot.jimple.IntConstant.v(((Byte)num).byteValue());
    }
 else     if (num instanceof Short) {
      return soot.jimple.IntConstant.v(((Short)num).shortValue());
    }
 else {
      return soot.jimple.IntConstant.v(((Integer)num).intValue());
    }
  }
}"
88641,"public void caseFloatConstant(FloatConstant v){
  if (v.value == 0)   emit(""String_Node_Str"",1);
 else   if (v.value == 1)   emit(""String_Node_Str"",1);
 else   if (v.value == 2)   emit(""String_Node_Str"",1);
 else {
    String s=v.toString();
    if (s.equals(""String_Node_Str""))     s=""String_Node_Str"";
    if (s.equals(""String_Node_Str""))     s=""String_Node_Str"";
    if (s.equals(""String_Node_Str""))     s=""String_Node_Str"";
    emit(""String_Node_Str"" + s,1);
  }
}","public void caseFloatConstant(FloatConstant v){
  if ((v.value == 0) && ((1.0f / v.value) > 0.0f))   emit(""String_Node_Str"",1);
 else   if (v.value == 1)   emit(""String_Node_Str"",1);
 else   if (v.value == 2)   emit(""String_Node_Str"",1);
 else {
    String s=v.toString();
    if (s.equals(""String_Node_Str""))     s=""String_Node_Str"";
    if (s.equals(""String_Node_Str""))     s=""String_Node_Str"";
    if (s.equals(""String_Node_Str""))     s=""String_Node_Str"";
    emit(""String_Node_Str"" + s,1);
  }
}"
88642,"public void caseDoubleConstant(DoubleConstant v){
  if (v.value == 0)   emit(""String_Node_Str"",2);
 else   if (v.value == 1)   emit(""String_Node_Str"",2);
 else {
    String s=v.toString();
    if (s.equals(""String_Node_Str""))     s=""String_Node_Str"";
    if (s.equals(""String_Node_Str""))     s=""String_Node_Str"";
    if (s.equals(""String_Node_Str""))     s=""String_Node_Str"";
    emit(""String_Node_Str"" + s,2);
  }
}","public void caseDoubleConstant(DoubleConstant v){
  if ((v.value == 0) && ((1.0 / v.value) > 0.0))   emit(""String_Node_Str"",2);
 else   if (v.value == 1)   emit(""String_Node_Str"",2);
 else {
    String s=v.toString();
    if (s.equals(""String_Node_Str""))     s=""String_Node_Str"";
    if (s.equals(""String_Node_Str""))     s=""String_Node_Str"";
    if (s.equals(""String_Node_Str""))     s=""String_Node_Str"";
    emit(""String_Node_Str"" + s,2);
  }
}"
88643,"void emitValue(Value value){
  value.apply(new AbstractGrimpValueSwitch(){
    public void caseAddExpr(    AddExpr v){
      emitValue(v.getOp1());
      emitValue(v.getOp2());
      v.getType().apply(new TypeSwitch(){
        private void handleIntCase(){
          emit(""String_Node_Str"",-1);
        }
        public void caseIntType(        IntType t){
          handleIntCase();
        }
        public void caseBooleanType(        BooleanType t){
          handleIntCase();
        }
        public void caseShortType(        ShortType t){
          handleIntCase();
        }
        public void caseCharType(        CharType t){
          handleIntCase();
        }
        public void caseByteType(        ByteType t){
          handleIntCase();
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"",-2);
        }
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"",-2);
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"",-1);
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseAndExpr(    AndExpr v){
      emitValue(v.getOp1());
      emitValue(v.getOp2());
      v.getType().apply(new TypeSwitch(){
        private void handleIntCase(){
          emit(""String_Node_Str"",-1);
        }
        public void caseIntType(        IntType t){
          handleIntCase();
        }
        public void caseBooleanType(        BooleanType t){
          handleIntCase();
        }
        public void caseShortType(        ShortType t){
          handleIntCase();
        }
        public void caseCharType(        CharType t){
          handleIntCase();
        }
        public void caseByteType(        ByteType t){
          handleIntCase();
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"",-2);
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseArrayRef(    ArrayRef v){
      emitValue(v.getBase());
      emitValue(v.getIndex());
      v.getType().apply(new TypeSwitch(){
        public void caseArrayType(        ArrayType ty){
          emit(""String_Node_Str"",-1);
        }
        public void caseBooleanType(        BooleanType ty){
          emit(""String_Node_Str"",-1);
        }
        public void caseByteType(        ByteType ty){
          emit(""String_Node_Str"",-1);
        }
        public void caseCharType(        CharType ty){
          emit(""String_Node_Str"",-1);
        }
        public void defaultCase(        Type ty){
          throw new RuntimeException(""String_Node_Str"");
        }
        public void caseDoubleType(        DoubleType ty){
          emit(""String_Node_Str"",0);
        }
        public void caseFloatType(        FloatType ty){
          emit(""String_Node_Str"",-1);
        }
        public void caseIntType(        IntType ty){
          emit(""String_Node_Str"",-1);
        }
        public void caseLongType(        LongType ty){
          emit(""String_Node_Str"",0);
        }
        public void caseNullType(        NullType ty){
          emit(""String_Node_Str"",-1);
        }
        public void caseRefType(        RefType ty){
          emit(""String_Node_Str"",-1);
        }
        public void caseShortType(        ShortType ty){
          emit(""String_Node_Str"",-1);
        }
      }
);
    }
    public void caseCastExpr(    final CastExpr v){
      final Type toType=v.getCastType();
      final Type fromType=v.getOp().getType();
      emitValue(v.getOp());
      if (toType instanceof RefType)       emit(""String_Node_Str"" + slashify(toType.toString()),0);
 else       if (toType instanceof ArrayType)       emit(""String_Node_Str"" + jasminDescriptorOf(toType),0);
 else {
        fromType.apply(new TypeSwitch(){
          public void defaultCase(          Type ty){
            throw new RuntimeException(""String_Node_Str"" + fromType);
          }
          public void caseDoubleType(          DoubleType ty){
            if (toType.equals(IntType.v()))             emit(""String_Node_Str"",-1);
 else             if (toType.equals(LongType.v()))             emit(""String_Node_Str"",0);
 else             if (toType.equals(FloatType.v()))             emit(""String_Node_Str"",-1);
 else             throw new RuntimeException(""String_Node_Str"" + toType);
          }
          public void caseFloatType(          FloatType ty){
            if (toType.equals(IntType.v()))             emit(""String_Node_Str"",0);
 else             if (toType.equals(LongType.v()))             emit(""String_Node_Str"",1);
 else             if (toType.equals(DoubleType.v()))             emit(""String_Node_Str"",1);
 else             throw new RuntimeException(""String_Node_Str"" + toType);
          }
          public void caseIntType(          IntType ty){
            emitIntToTypeCast();
          }
          public void caseBooleanType(          BooleanType ty){
            emitIntToTypeCast();
          }
          public void caseByteType(          ByteType ty){
            emitIntToTypeCast();
          }
          public void caseCharType(          CharType ty){
            emitIntToTypeCast();
          }
          public void caseShortType(          ShortType ty){
            emitIntToTypeCast();
          }
          private void emitIntToTypeCast(){
            if (toType.equals(ByteType.v()))             emit(""String_Node_Str"",0);
 else             if (toType.equals(CharType.v()))             emit(""String_Node_Str"",0);
 else             if (toType.equals(ShortType.v()))             emit(""String_Node_Str"",0);
 else             if (toType.equals(FloatType.v()))             emit(""String_Node_Str"",0);
 else             if (toType.equals(LongType.v()))             emit(""String_Node_Str"",1);
 else             if (toType.equals(DoubleType.v()))             emit(""String_Node_Str"",1);
 else             if (toType.equals(IntType.v()))             ;
 else             if (toType.equals(BooleanType.v()))             ;
 else             throw new RuntimeException(""String_Node_Str"" + toType + ""String_Node_Str""+ v.toString());
          }
          public void caseLongType(          LongType ty){
            if (toType.equals(IntType.v()))             emit(""String_Node_Str"",-1);
 else             if (toType.equals(FloatType.v()))             emit(""String_Node_Str"",-1);
 else             if (toType.equals(DoubleType.v()))             emit(""String_Node_Str"",0);
 else             if (toType.equals(ByteType.v())) {
              emit(""String_Node_Str"",-1);
              emitIntToTypeCast();
            }
 else             if (toType.equals(ShortType.v())) {
              emit(""String_Node_Str"",-1);
              emitIntToTypeCast();
            }
 else             if (toType.equals(CharType.v())) {
              emit(""String_Node_Str"",-1);
              emitIntToTypeCast();
            }
 else             if (toType.equals(BooleanType.v())) {
              emit(""String_Node_Str"",-1);
              emitIntToTypeCast();
            }
 else             throw new RuntimeException(""String_Node_Str"" + toType);
          }
        }
);
      }
    }
    public void caseCmpExpr(    CmpExpr v){
      emitValue(v.getOp1());
      emitValue(v.getOp2());
      emit(""String_Node_Str"",-3);
    }
    public void caseCmpgExpr(    CmpgExpr v){
      emitValue(v.getOp1());
      emitValue(v.getOp2());
      if (v.getOp1().getType().equals(FloatType.v()))       emit(""String_Node_Str"",-1);
 else       emit(""String_Node_Str"",-3);
    }
    public void caseCmplExpr(    CmplExpr v){
      emitValue(v.getOp1());
      emitValue(v.getOp2());
      if (v.getOp1().getType().equals(FloatType.v()))       emit(""String_Node_Str"",-1);
 else       emit(""String_Node_Str"",-3);
    }
    public void defaultCase(    Value v){
      throw new RuntimeException(""String_Node_Str"" + v);
    }
    public void caseDivExpr(    DivExpr v){
      emitValue(v.getOp1());
      emitValue(v.getOp2());
      v.getType().apply(new TypeSwitch(){
        private void handleIntCase(){
          emit(""String_Node_Str"",-1);
        }
        public void caseIntType(        IntType t){
          handleIntCase();
        }
        public void caseBooleanType(        BooleanType t){
          handleIntCase();
        }
        public void caseShortType(        ShortType t){
          handleIntCase();
        }
        public void caseCharType(        CharType t){
          handleIntCase();
        }
        public void caseByteType(        ByteType t){
          handleIntCase();
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"",-2);
        }
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"",-2);
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"",-1);
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseDoubleConstant(    DoubleConstant v){
      if (v.value == 0)       emit(""String_Node_Str"",2);
 else       if (v.value == 1)       emit(""String_Node_Str"",2);
 else {
        String s=v.toString();
        if (s.equals(""String_Node_Str""))         s=""String_Node_Str"";
        if (s.equals(""String_Node_Str""))         s=""String_Node_Str"";
        if (s.equals(""String_Node_Str""))         s=""String_Node_Str"";
        emit(""String_Node_Str"" + s,2);
      }
    }
    public void caseFloatConstant(    FloatConstant v){
      if (v.value == 0)       emit(""String_Node_Str"",1);
 else       if (v.value == 1)       emit(""String_Node_Str"",1);
 else       if (v.value == 2)       emit(""String_Node_Str"",1);
 else {
        String s=v.toString();
        if (s.equals(""String_Node_Str""))         s=""String_Node_Str"";
        if (s.equals(""String_Node_Str""))         s=""String_Node_Str"";
        if (s.equals(""String_Node_Str""))         s=""String_Node_Str"";
        emit(""String_Node_Str"" + s,1);
      }
    }
    public void caseInstanceFieldRef(    InstanceFieldRef v){
      emitValue(v.getBase());
      emit(""String_Node_Str"" + slashify(v.getField().getDeclaringClass().getName()) + ""String_Node_Str""+ v.getField().getName()+ ""String_Node_Str""+ jasminDescriptorOf(v.getField().getType()),-1 + sizeOfType(v.getField().getType()));
    }
    public void caseInstanceOfExpr(    InstanceOfExpr v){
      final Type checkType;
      emitValue(v.getOp());
      checkType=v.getCheckType();
      if (checkType instanceof RefType)       emit(""String_Node_Str"" + slashify(checkType.toString()),0);
 else       if (checkType instanceof ArrayType)       emit(""String_Node_Str"" + jasminDescriptorOf(checkType),0);
    }
    public void caseIntConstant(    IntConstant v){
      if (v.value == -1)       emit(""String_Node_Str"",1);
 else       if (v.value >= 0 && v.value <= 5)       emit(""String_Node_Str"" + v.value,1);
 else       if (v.value >= Byte.MIN_VALUE && v.value <= Byte.MAX_VALUE)       emit(""String_Node_Str"" + v.value,1);
 else       if (v.value >= Short.MIN_VALUE && v.value <= Short.MAX_VALUE)       emit(""String_Node_Str"" + v.value,1);
 else       emit(""String_Node_Str"" + v.toString(),1);
    }
    public void caseInterfaceInvokeExpr(    InterfaceInvokeExpr v){
      SootMethod m=v.getMethod();
      emitValue(v.getBase());
      for (int i=0; i < m.getParameterCount(); i++)       emitValue(v.getArg(i));
      emit(""String_Node_Str"" + slashify(m.getDeclaringClass().getName()) + ""String_Node_Str""+ m.getName()+ jasminDescriptorOf(m)+ ""String_Node_Str""+ (argCountOf(m) + 1),-(argCountOf(m) + 1) + sizeOfType(m.getReturnType()));
    }
    public void caseLengthExpr(    LengthExpr v){
      emitValue(v.getOp());
      emit(""String_Node_Str"",0);
    }
    public void caseLocal(    Local v){
      emitLocal(v);
    }
    public void caseLongConstant(    LongConstant v){
      if (v.value == 0)       emit(""String_Node_Str"",2);
 else       if (v.value == 1)       emit(""String_Node_Str"",2);
 else       emit(""String_Node_Str"" + v.toString(),2);
    }
    public void caseMulExpr(    MulExpr v){
      emitValue(v.getOp1());
      emitValue(v.getOp2());
      v.getType().apply(new TypeSwitch(){
        private void handleIntCase(){
          emit(""String_Node_Str"",-1);
        }
        public void caseIntType(        IntType t){
          handleIntCase();
        }
        public void caseBooleanType(        BooleanType t){
          handleIntCase();
        }
        public void caseShortType(        ShortType t){
          handleIntCase();
        }
        public void caseCharType(        CharType t){
          handleIntCase();
        }
        public void caseByteType(        ByteType t){
          handleIntCase();
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"",-2);
        }
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"",-2);
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"",-1);
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseLtExpr(    LtExpr v){
      emitValue(v.getOp1());
      emitValue(v.getOp2());
      v.getOp1().getType().apply(new TypeSwitch(){
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"",-3);
          emitBooleanBranch(""String_Node_Str"");
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"",-1);
          emitBooleanBranch(""String_Node_Str"");
        }
        private void handleIntCase(){
          emit(""String_Node_Str"",-2);
        }
        public void caseIntType(        IntType t){
          handleIntCase();
        }
        public void caseBooleanType(        BooleanType t){
          handleIntCase();
        }
        public void caseShortType(        ShortType t){
          handleIntCase();
        }
        public void caseCharType(        CharType t){
          handleIntCase();
        }
        public void caseByteType(        ByteType t){
          handleIntCase();
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"",-3);
          emitBooleanBranch(""String_Node_Str"");
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseLeExpr(    LeExpr v){
      emitValue(v.getOp1());
      emitValue(v.getOp2());
      v.getOp1().getType().apply(new TypeSwitch(){
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"",-3);
          emitBooleanBranch(""String_Node_Str"");
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"",-1);
          emitBooleanBranch(""String_Node_Str"");
        }
        private void handleIntCase(){
          emit(""String_Node_Str"",-2);
        }
        public void caseIntType(        IntType t){
          handleIntCase();
        }
        public void caseBooleanType(        BooleanType t){
          handleIntCase();
        }
        public void caseShortType(        ShortType t){
          handleIntCase();
        }
        public void caseCharType(        CharType t){
          handleIntCase();
        }
        public void caseByteType(        ByteType t){
          handleIntCase();
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"",-3);
          emitBooleanBranch(""String_Node_Str"");
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseGtExpr(    GtExpr v){
      emitValue(v.getOp1());
      emitValue(v.getOp2());
      v.getOp1().getType().apply(new TypeSwitch(){
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"",-3);
          emitBooleanBranch(""String_Node_Str"");
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"",-1);
          emitBooleanBranch(""String_Node_Str"");
        }
        private void handleIntCase(){
          emit(""String_Node_Str"",-2);
        }
        public void caseIntType(        IntType t){
          handleIntCase();
        }
        public void caseBooleanType(        BooleanType t){
          handleIntCase();
        }
        public void caseShortType(        ShortType t){
          handleIntCase();
        }
        public void caseCharType(        CharType t){
          handleIntCase();
        }
        public void caseByteType(        ByteType t){
          handleIntCase();
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"",-3);
          emitBooleanBranch(""String_Node_Str"");
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseGeExpr(    GeExpr v){
      emitValue(v.getOp1());
      emitValue(v.getOp2());
      v.getOp1().getType().apply(new TypeSwitch(){
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"",-3);
          emitBooleanBranch(""String_Node_Str"");
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"",-1);
          emitBooleanBranch(""String_Node_Str"");
        }
        private void handleIntCase(){
          emit(""String_Node_Str"",-2);
        }
        public void caseIntType(        IntType t){
          handleIntCase();
        }
        public void caseBooleanType(        BooleanType t){
          handleIntCase();
        }
        public void caseShortType(        ShortType t){
          handleIntCase();
        }
        public void caseCharType(        CharType t){
          handleIntCase();
        }
        public void caseByteType(        ByteType t){
          handleIntCase();
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"",-3);
          emitBooleanBranch(""String_Node_Str"");
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseNeExpr(    NeExpr v){
      emitValue(v.getOp1());
      emitValue(v.getOp2());
      v.getOp1().getType().apply(new TypeSwitch(){
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"",-3);
          emit(""String_Node_Str"",1);
          emitBooleanBranch(""String_Node_Str"");
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"",-1);
          emit(""String_Node_Str"",1);
          emitBooleanBranch(""String_Node_Str"");
        }
        private void handleIntCase(){
          emit(""String_Node_Str"",-2);
        }
        public void caseIntType(        IntType t){
          handleIntCase();
        }
        public void caseBooleanType(        BooleanType t){
          handleIntCase();
        }
        public void caseShortType(        ShortType t){
          handleIntCase();
        }
        public void caseCharType(        CharType t){
          handleIntCase();
        }
        public void caseByteType(        ByteType t){
          handleIntCase();
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"",-3);
          emit(""String_Node_Str"",1);
          emitBooleanBranch(""String_Node_Str"");
        }
        public void caseArrayType(        ArrayType t){
          emitBooleanBranch(""String_Node_Str"");
        }
        public void caseRefType(        RefType t){
          emitBooleanBranch(""String_Node_Str"");
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseEqExpr(    EqExpr v){
      emitValue(v.getOp1());
      emitValue(v.getOp2());
      v.getOp1().getType().apply(new TypeSwitch(){
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"",-3);
          emit(""String_Node_Str"",1);
          emitBooleanBranch(""String_Node_Str"");
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"",-3);
          emit(""String_Node_Str"",1);
          emitBooleanBranch(""String_Node_Str"");
        }
        private void handleIntCase(){
          emit(""String_Node_Str"",-2);
        }
        public void caseIntType(        IntType t){
          handleIntCase();
        }
        public void caseBooleanType(        BooleanType t){
          handleIntCase();
        }
        public void caseShortType(        ShortType t){
          handleIntCase();
        }
        public void caseCharType(        CharType t){
          handleIntCase();
        }
        public void caseByteType(        ByteType t){
          handleIntCase();
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"",-3);
          emit(""String_Node_Str"",1);
          emitBooleanBranch(""String_Node_Str"");
        }
        public void caseArrayType(        ArrayType t){
          emitBooleanBranch(""String_Node_Str"");
        }
        public void casbeRefType(        RefType t){
          emitBooleanBranch(""String_Node_Str"");
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseNegExpr(    final NegExpr v){
      emitValue(v.getOp());
      v.getType().apply(new TypeSwitch(){
        private void handleIntCase(){
          emit(""String_Node_Str"",0);
        }
        public void caseIntType(        IntType t){
          handleIntCase();
        }
        public void caseBooleanType(        BooleanType t){
          handleIntCase();
        }
        public void caseShortType(        ShortType t){
          handleIntCase();
        }
        public void caseCharType(        CharType t){
          handleIntCase();
        }
        public void caseByteType(        ByteType t){
          handleIntCase();
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"",0);
        }
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"",0);
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"",0);
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"" + t + ""String_Node_Str""+ v);
        }
      }
);
    }
    public void caseNewArrayExpr(    NewArrayExpr v){
      Value size=v.getSize();
      emitValue(size);
      if (v.getBaseType() instanceof RefType)       emit(""String_Node_Str"" + slashify(v.getBaseType().toString()),0);
 else       if (v.getBaseType() instanceof ArrayType)       emit(""String_Node_Str"" + jasminDescriptorOf(v.getBaseType()),0);
 else       emit(""String_Node_Str"" + v.getBaseType().toString(),0);
    }
    public void caseNewMultiArrayExpr(    NewMultiArrayExpr v){
      List sizes=v.getSizes();
      for (int i=0; i < sizes.size(); i++)       emitValue((Value)sizes.get(i));
      emit(""String_Node_Str"" + jasminDescriptorOf(v.getBaseType()) + ""String_Node_Str""+ sizes.size(),-sizes.size() + 1);
    }
    public void caseNewExpr(    NewExpr v){
      emit(""String_Node_Str"" + slashify(v.getBaseType().toString()),1);
    }
    public void caseNewInvokeExpr(    NewInvokeExpr v){
      emit(""String_Node_Str"" + slashify(v.getBaseType().toString()),1);
      emit(""String_Node_Str"",1);
      SootMethod m=v.getMethod();
      for (int i=0; i < m.getParameterCount(); i++)       emitValue(v.getArg(i));
      emit(""String_Node_Str"" + slashify(m.getDeclaringClass().getName()) + ""String_Node_Str""+ m.getName()+ jasminDescriptorOf(m),-(argCountOf(m) + 1) + sizeOfType(m.getReturnType()));
    }
    public void caseNullConstant(    NullConstant v){
      emit(""String_Node_Str"",1);
    }
    public void caseOrExpr(    OrExpr v){
      emitValue(v.getOp1());
      emitValue(v.getOp2());
      v.getType().apply(new TypeSwitch(){
        private void handleIntCase(){
          emit(""String_Node_Str"",-1);
        }
        public void caseIntType(        IntType t){
          handleIntCase();
        }
        public void caseBooleanType(        BooleanType t){
          handleIntCase();
        }
        public void caseShortType(        ShortType t){
          handleIntCase();
        }
        public void caseCharType(        CharType t){
          handleIntCase();
        }
        public void caseByteType(        ByteType t){
          handleIntCase();
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"",-2);
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseRemExpr(    RemExpr v){
      emitValue(v.getOp1());
      emitValue(v.getOp2());
      v.getType().apply(new TypeSwitch(){
        private void handleIntCase(){
          emit(""String_Node_Str"",-1);
        }
        public void caseIntType(        IntType t){
          handleIntCase();
        }
        public void caseBooleanType(        BooleanType t){
          handleIntCase();
        }
        public void caseShortType(        ShortType t){
          handleIntCase();
        }
        public void caseCharType(        CharType t){
          handleIntCase();
        }
        public void caseByteType(        ByteType t){
          handleIntCase();
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"",-2);
        }
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"",-2);
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"",-1);
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseShlExpr(    ShlExpr v){
      emitValue(v.getOp1());
      emitValue(v.getOp2());
      v.getType().apply(new TypeSwitch(){
        private void handleIntCase(){
          emit(""String_Node_Str"",-1);
        }
        public void caseIntType(        IntType t){
          handleIntCase();
        }
        public void caseBooleanType(        BooleanType t){
          handleIntCase();
        }
        public void caseShortType(        ShortType t){
          handleIntCase();
        }
        public void caseCharType(        CharType t){
          handleIntCase();
        }
        public void caseByteType(        ByteType t){
          handleIntCase();
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"",-1);
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseShrExpr(    ShrExpr v){
      emitValue(v.getOp1());
      emitValue(v.getOp2());
      v.getType().apply(new TypeSwitch(){
        private void handleIntCase(){
          emit(""String_Node_Str"",-1);
        }
        public void caseIntType(        IntType t){
          handleIntCase();
        }
        public void caseBooleanType(        BooleanType t){
          handleIntCase();
        }
        public void caseShortType(        ShortType t){
          handleIntCase();
        }
        public void caseCharType(        CharType t){
          handleIntCase();
        }
        public void caseByteType(        ByteType t){
          handleIntCase();
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"",-1);
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseSpecialInvokeExpr(    SpecialInvokeExpr v){
      SootMethod m=v.getMethod();
      emitValue(v.getBase());
      for (int i=0; i < m.getParameterCount(); i++)       emitValue(v.getArg(i));
      emit(""String_Node_Str"" + slashify(m.getDeclaringClass().getName()) + ""String_Node_Str""+ m.getName()+ jasminDescriptorOf(m),-(argCountOf(m) + 1) + sizeOfType(m.getReturnType()));
    }
    public void caseStaticInvokeExpr(    StaticInvokeExpr v){
      SootMethod m=v.getMethod();
      for (int i=0; i < m.getParameterCount(); i++)       emitValue(v.getArg(i));
      emit(""String_Node_Str"" + slashify(m.getDeclaringClass().getName()) + ""String_Node_Str""+ m.getName()+ jasminDescriptorOf(m),-(argCountOf(m)) + sizeOfType(m.getReturnType()));
    }
    public void caseStaticFieldRef(    StaticFieldRef v){
      emit(""String_Node_Str"" + slashify(v.getField().getDeclaringClass().getName()) + ""String_Node_Str""+ v.getField().getName()+ ""String_Node_Str""+ jasminDescriptorOf(v.getField().getType()),sizeOfType(v.getField().getType()));
    }
    public void caseStringConstant(    StringConstant v){
      emit(""String_Node_Str"" + v.toString(),1);
    }
    public void caseSubExpr(    SubExpr v){
      emitValue(v.getOp1());
      emitValue(v.getOp2());
      v.getType().apply(new TypeSwitch(){
        private void handleIntCase(){
          emit(""String_Node_Str"",-1);
        }
        public void caseIntType(        IntType t){
          handleIntCase();
        }
        public void caseBooleanType(        BooleanType t){
          handleIntCase();
        }
        public void caseShortType(        ShortType t){
          handleIntCase();
        }
        public void caseCharType(        CharType t){
          handleIntCase();
        }
        public void caseByteType(        ByteType t){
          handleIntCase();
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"",-2);
        }
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"",-2);
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"",-1);
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseUshrExpr(    UshrExpr v){
      emitValue(v.getOp1());
      emitValue(v.getOp2());
      v.getType().apply(new TypeSwitch(){
        private void handleIntCase(){
          emit(""String_Node_Str"",-1);
        }
        public void caseIntType(        IntType t){
          handleIntCase();
        }
        public void caseBooleanType(        BooleanType t){
          handleIntCase();
        }
        public void caseShortType(        ShortType t){
          handleIntCase();
        }
        public void caseCharType(        CharType t){
          handleIntCase();
        }
        public void caseByteType(        ByteType t){
          handleIntCase();
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"",-1);
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseVirtualInvokeExpr(    VirtualInvokeExpr v){
      SootMethod m=v.getMethod();
      emitValue(v.getBase());
      for (int i=0; i < m.getParameterCount(); i++)       emitValue(v.getArg(i));
      emit(""String_Node_Str"" + slashify(m.getDeclaringClass().getName()) + ""String_Node_Str""+ m.getName()+ jasminDescriptorOf(m),-(argCountOf(m) + 1) + sizeOfType(m.getReturnType()));
    }
    public void caseXorExpr(    XorExpr v){
      emitValue(v.getOp1());
      emitValue(v.getOp2());
      v.getType().apply(new TypeSwitch(){
        private void handleIntCase(){
          emit(""String_Node_Str"",-1);
        }
        public void caseIntType(        IntType t){
          handleIntCase();
        }
        public void caseBooleanType(        BooleanType t){
          handleIntCase();
        }
        public void caseShortType(        ShortType t){
          handleIntCase();
        }
        public void caseCharType(        CharType t){
          handleIntCase();
        }
        public void caseByteType(        ByteType t){
          handleIntCase();
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"",-2);
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
  }
);
}","void emitValue(Value value){
  value.apply(new AbstractGrimpValueSwitch(){
    public void caseAddExpr(    AddExpr v){
      emitValue(v.getOp1());
      emitValue(v.getOp2());
      v.getType().apply(new TypeSwitch(){
        private void handleIntCase(){
          emit(""String_Node_Str"",-1);
        }
        public void caseIntType(        IntType t){
          handleIntCase();
        }
        public void caseBooleanType(        BooleanType t){
          handleIntCase();
        }
        public void caseShortType(        ShortType t){
          handleIntCase();
        }
        public void caseCharType(        CharType t){
          handleIntCase();
        }
        public void caseByteType(        ByteType t){
          handleIntCase();
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"",-2);
        }
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"",-2);
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"",-1);
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseAndExpr(    AndExpr v){
      emitValue(v.getOp1());
      emitValue(v.getOp2());
      v.getType().apply(new TypeSwitch(){
        private void handleIntCase(){
          emit(""String_Node_Str"",-1);
        }
        public void caseIntType(        IntType t){
          handleIntCase();
        }
        public void caseBooleanType(        BooleanType t){
          handleIntCase();
        }
        public void caseShortType(        ShortType t){
          handleIntCase();
        }
        public void caseCharType(        CharType t){
          handleIntCase();
        }
        public void caseByteType(        ByteType t){
          handleIntCase();
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"",-2);
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseArrayRef(    ArrayRef v){
      emitValue(v.getBase());
      emitValue(v.getIndex());
      v.getType().apply(new TypeSwitch(){
        public void caseArrayType(        ArrayType ty){
          emit(""String_Node_Str"",-1);
        }
        public void caseBooleanType(        BooleanType ty){
          emit(""String_Node_Str"",-1);
        }
        public void caseByteType(        ByteType ty){
          emit(""String_Node_Str"",-1);
        }
        public void caseCharType(        CharType ty){
          emit(""String_Node_Str"",-1);
        }
        public void defaultCase(        Type ty){
          throw new RuntimeException(""String_Node_Str"");
        }
        public void caseDoubleType(        DoubleType ty){
          emit(""String_Node_Str"",0);
        }
        public void caseFloatType(        FloatType ty){
          emit(""String_Node_Str"",-1);
        }
        public void caseIntType(        IntType ty){
          emit(""String_Node_Str"",-1);
        }
        public void caseLongType(        LongType ty){
          emit(""String_Node_Str"",0);
        }
        public void caseNullType(        NullType ty){
          emit(""String_Node_Str"",-1);
        }
        public void caseRefType(        RefType ty){
          emit(""String_Node_Str"",-1);
        }
        public void caseShortType(        ShortType ty){
          emit(""String_Node_Str"",-1);
        }
      }
);
    }
    public void caseCastExpr(    final CastExpr v){
      final Type toType=v.getCastType();
      final Type fromType=v.getOp().getType();
      emitValue(v.getOp());
      if (toType instanceof RefType)       emit(""String_Node_Str"" + slashify(toType.toString()),0);
 else       if (toType instanceof ArrayType)       emit(""String_Node_Str"" + jasminDescriptorOf(toType),0);
 else {
        fromType.apply(new TypeSwitch(){
          public void defaultCase(          Type ty){
            throw new RuntimeException(""String_Node_Str"" + fromType);
          }
          public void caseDoubleType(          DoubleType ty){
            if (toType.equals(IntType.v()))             emit(""String_Node_Str"",-1);
 else             if (toType.equals(LongType.v()))             emit(""String_Node_Str"",0);
 else             if (toType.equals(FloatType.v()))             emit(""String_Node_Str"",-1);
 else             throw new RuntimeException(""String_Node_Str"" + toType);
          }
          public void caseFloatType(          FloatType ty){
            if (toType.equals(IntType.v()))             emit(""String_Node_Str"",0);
 else             if (toType.equals(LongType.v()))             emit(""String_Node_Str"",1);
 else             if (toType.equals(DoubleType.v()))             emit(""String_Node_Str"",1);
 else             throw new RuntimeException(""String_Node_Str"" + toType);
          }
          public void caseIntType(          IntType ty){
            emitIntToTypeCast();
          }
          public void caseBooleanType(          BooleanType ty){
            emitIntToTypeCast();
          }
          public void caseByteType(          ByteType ty){
            emitIntToTypeCast();
          }
          public void caseCharType(          CharType ty){
            emitIntToTypeCast();
          }
          public void caseShortType(          ShortType ty){
            emitIntToTypeCast();
          }
          private void emitIntToTypeCast(){
            if (toType.equals(ByteType.v()))             emit(""String_Node_Str"",0);
 else             if (toType.equals(CharType.v()))             emit(""String_Node_Str"",0);
 else             if (toType.equals(ShortType.v()))             emit(""String_Node_Str"",0);
 else             if (toType.equals(FloatType.v()))             emit(""String_Node_Str"",0);
 else             if (toType.equals(LongType.v()))             emit(""String_Node_Str"",1);
 else             if (toType.equals(DoubleType.v()))             emit(""String_Node_Str"",1);
 else             if (toType.equals(IntType.v()))             ;
 else             if (toType.equals(BooleanType.v()))             ;
 else             throw new RuntimeException(""String_Node_Str"" + toType + ""String_Node_Str""+ v.toString());
          }
          public void caseLongType(          LongType ty){
            if (toType.equals(IntType.v()))             emit(""String_Node_Str"",-1);
 else             if (toType.equals(FloatType.v()))             emit(""String_Node_Str"",-1);
 else             if (toType.equals(DoubleType.v()))             emit(""String_Node_Str"",0);
 else             if (toType.equals(ByteType.v())) {
              emit(""String_Node_Str"",-1);
              emitIntToTypeCast();
            }
 else             if (toType.equals(ShortType.v())) {
              emit(""String_Node_Str"",-1);
              emitIntToTypeCast();
            }
 else             if (toType.equals(CharType.v())) {
              emit(""String_Node_Str"",-1);
              emitIntToTypeCast();
            }
 else             if (toType.equals(BooleanType.v())) {
              emit(""String_Node_Str"",-1);
              emitIntToTypeCast();
            }
 else             throw new RuntimeException(""String_Node_Str"" + toType);
          }
        }
);
      }
    }
    public void caseCmpExpr(    CmpExpr v){
      emitValue(v.getOp1());
      emitValue(v.getOp2());
      emit(""String_Node_Str"",-3);
    }
    public void caseCmpgExpr(    CmpgExpr v){
      emitValue(v.getOp1());
      emitValue(v.getOp2());
      if (v.getOp1().getType().equals(FloatType.v()))       emit(""String_Node_Str"",-1);
 else       emit(""String_Node_Str"",-3);
    }
    public void caseCmplExpr(    CmplExpr v){
      emitValue(v.getOp1());
      emitValue(v.getOp2());
      if (v.getOp1().getType().equals(FloatType.v()))       emit(""String_Node_Str"",-1);
 else       emit(""String_Node_Str"",-3);
    }
    public void defaultCase(    Value v){
      throw new RuntimeException(""String_Node_Str"" + v);
    }
    public void caseDivExpr(    DivExpr v){
      emitValue(v.getOp1());
      emitValue(v.getOp2());
      v.getType().apply(new TypeSwitch(){
        private void handleIntCase(){
          emit(""String_Node_Str"",-1);
        }
        public void caseIntType(        IntType t){
          handleIntCase();
        }
        public void caseBooleanType(        BooleanType t){
          handleIntCase();
        }
        public void caseShortType(        ShortType t){
          handleIntCase();
        }
        public void caseCharType(        CharType t){
          handleIntCase();
        }
        public void caseByteType(        ByteType t){
          handleIntCase();
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"",-2);
        }
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"",-2);
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"",-1);
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseDoubleConstant(    DoubleConstant v){
      if ((v.value == 0) && ((1.0 / v.value) > 0.0))       emit(""String_Node_Str"",2);
 else       if (v.value == 1)       emit(""String_Node_Str"",2);
 else {
        String s=v.toString();
        if (s.equals(""String_Node_Str""))         s=""String_Node_Str"";
        if (s.equals(""String_Node_Str""))         s=""String_Node_Str"";
        if (s.equals(""String_Node_Str""))         s=""String_Node_Str"";
        emit(""String_Node_Str"" + s,2);
      }
    }
    public void caseFloatConstant(    FloatConstant v){
      if ((v.value == 0) && ((1.0f / v.value) > 0.0f))       emit(""String_Node_Str"",1);
 else       if (v.value == 1)       emit(""String_Node_Str"",1);
 else       if (v.value == 2)       emit(""String_Node_Str"",1);
 else {
        String s=v.toString();
        if (s.equals(""String_Node_Str""))         s=""String_Node_Str"";
        if (s.equals(""String_Node_Str""))         s=""String_Node_Str"";
        if (s.equals(""String_Node_Str""))         s=""String_Node_Str"";
        emit(""String_Node_Str"" + s,1);
      }
    }
    public void caseInstanceFieldRef(    InstanceFieldRef v){
      emitValue(v.getBase());
      emit(""String_Node_Str"" + slashify(v.getField().getDeclaringClass().getName()) + ""String_Node_Str""+ v.getField().getName()+ ""String_Node_Str""+ jasminDescriptorOf(v.getField().getType()),-1 + sizeOfType(v.getField().getType()));
    }
    public void caseInstanceOfExpr(    InstanceOfExpr v){
      final Type checkType;
      emitValue(v.getOp());
      checkType=v.getCheckType();
      if (checkType instanceof RefType)       emit(""String_Node_Str"" + slashify(checkType.toString()),0);
 else       if (checkType instanceof ArrayType)       emit(""String_Node_Str"" + jasminDescriptorOf(checkType),0);
    }
    public void caseIntConstant(    IntConstant v){
      if (v.value == -1)       emit(""String_Node_Str"",1);
 else       if (v.value >= 0 && v.value <= 5)       emit(""String_Node_Str"" + v.value,1);
 else       if (v.value >= Byte.MIN_VALUE && v.value <= Byte.MAX_VALUE)       emit(""String_Node_Str"" + v.value,1);
 else       if (v.value >= Short.MIN_VALUE && v.value <= Short.MAX_VALUE)       emit(""String_Node_Str"" + v.value,1);
 else       emit(""String_Node_Str"" + v.toString(),1);
    }
    public void caseInterfaceInvokeExpr(    InterfaceInvokeExpr v){
      SootMethod m=v.getMethod();
      emitValue(v.getBase());
      for (int i=0; i < m.getParameterCount(); i++)       emitValue(v.getArg(i));
      emit(""String_Node_Str"" + slashify(m.getDeclaringClass().getName()) + ""String_Node_Str""+ m.getName()+ jasminDescriptorOf(m)+ ""String_Node_Str""+ (argCountOf(m) + 1),-(argCountOf(m) + 1) + sizeOfType(m.getReturnType()));
    }
    public void caseLengthExpr(    LengthExpr v){
      emitValue(v.getOp());
      emit(""String_Node_Str"",0);
    }
    public void caseLocal(    Local v){
      emitLocal(v);
    }
    public void caseLongConstant(    LongConstant v){
      if (v.value == 0)       emit(""String_Node_Str"",2);
 else       if (v.value == 1)       emit(""String_Node_Str"",2);
 else       emit(""String_Node_Str"" + v.toString(),2);
    }
    public void caseMulExpr(    MulExpr v){
      emitValue(v.getOp1());
      emitValue(v.getOp2());
      v.getType().apply(new TypeSwitch(){
        private void handleIntCase(){
          emit(""String_Node_Str"",-1);
        }
        public void caseIntType(        IntType t){
          handleIntCase();
        }
        public void caseBooleanType(        BooleanType t){
          handleIntCase();
        }
        public void caseShortType(        ShortType t){
          handleIntCase();
        }
        public void caseCharType(        CharType t){
          handleIntCase();
        }
        public void caseByteType(        ByteType t){
          handleIntCase();
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"",-2);
        }
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"",-2);
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"",-1);
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseLtExpr(    LtExpr v){
      emitValue(v.getOp1());
      emitValue(v.getOp2());
      v.getOp1().getType().apply(new TypeSwitch(){
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"",-3);
          emitBooleanBranch(""String_Node_Str"");
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"",-1);
          emitBooleanBranch(""String_Node_Str"");
        }
        private void handleIntCase(){
          emit(""String_Node_Str"",-2);
        }
        public void caseIntType(        IntType t){
          handleIntCase();
        }
        public void caseBooleanType(        BooleanType t){
          handleIntCase();
        }
        public void caseShortType(        ShortType t){
          handleIntCase();
        }
        public void caseCharType(        CharType t){
          handleIntCase();
        }
        public void caseByteType(        ByteType t){
          handleIntCase();
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"",-3);
          emitBooleanBranch(""String_Node_Str"");
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseLeExpr(    LeExpr v){
      emitValue(v.getOp1());
      emitValue(v.getOp2());
      v.getOp1().getType().apply(new TypeSwitch(){
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"",-3);
          emitBooleanBranch(""String_Node_Str"");
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"",-1);
          emitBooleanBranch(""String_Node_Str"");
        }
        private void handleIntCase(){
          emit(""String_Node_Str"",-2);
        }
        public void caseIntType(        IntType t){
          handleIntCase();
        }
        public void caseBooleanType(        BooleanType t){
          handleIntCase();
        }
        public void caseShortType(        ShortType t){
          handleIntCase();
        }
        public void caseCharType(        CharType t){
          handleIntCase();
        }
        public void caseByteType(        ByteType t){
          handleIntCase();
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"",-3);
          emitBooleanBranch(""String_Node_Str"");
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseGtExpr(    GtExpr v){
      emitValue(v.getOp1());
      emitValue(v.getOp2());
      v.getOp1().getType().apply(new TypeSwitch(){
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"",-3);
          emitBooleanBranch(""String_Node_Str"");
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"",-1);
          emitBooleanBranch(""String_Node_Str"");
        }
        private void handleIntCase(){
          emit(""String_Node_Str"",-2);
        }
        public void caseIntType(        IntType t){
          handleIntCase();
        }
        public void caseBooleanType(        BooleanType t){
          handleIntCase();
        }
        public void caseShortType(        ShortType t){
          handleIntCase();
        }
        public void caseCharType(        CharType t){
          handleIntCase();
        }
        public void caseByteType(        ByteType t){
          handleIntCase();
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"",-3);
          emitBooleanBranch(""String_Node_Str"");
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseGeExpr(    GeExpr v){
      emitValue(v.getOp1());
      emitValue(v.getOp2());
      v.getOp1().getType().apply(new TypeSwitch(){
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"",-3);
          emitBooleanBranch(""String_Node_Str"");
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"",-1);
          emitBooleanBranch(""String_Node_Str"");
        }
        private void handleIntCase(){
          emit(""String_Node_Str"",-2);
        }
        public void caseIntType(        IntType t){
          handleIntCase();
        }
        public void caseBooleanType(        BooleanType t){
          handleIntCase();
        }
        public void caseShortType(        ShortType t){
          handleIntCase();
        }
        public void caseCharType(        CharType t){
          handleIntCase();
        }
        public void caseByteType(        ByteType t){
          handleIntCase();
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"",-3);
          emitBooleanBranch(""String_Node_Str"");
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseNeExpr(    NeExpr v){
      emitValue(v.getOp1());
      emitValue(v.getOp2());
      v.getOp1().getType().apply(new TypeSwitch(){
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"",-3);
          emit(""String_Node_Str"",1);
          emitBooleanBranch(""String_Node_Str"");
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"",-1);
          emit(""String_Node_Str"",1);
          emitBooleanBranch(""String_Node_Str"");
        }
        private void handleIntCase(){
          emit(""String_Node_Str"",-2);
        }
        public void caseIntType(        IntType t){
          handleIntCase();
        }
        public void caseBooleanType(        BooleanType t){
          handleIntCase();
        }
        public void caseShortType(        ShortType t){
          handleIntCase();
        }
        public void caseCharType(        CharType t){
          handleIntCase();
        }
        public void caseByteType(        ByteType t){
          handleIntCase();
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"",-3);
          emit(""String_Node_Str"",1);
          emitBooleanBranch(""String_Node_Str"");
        }
        public void caseArrayType(        ArrayType t){
          emitBooleanBranch(""String_Node_Str"");
        }
        public void caseRefType(        RefType t){
          emitBooleanBranch(""String_Node_Str"");
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseEqExpr(    EqExpr v){
      emitValue(v.getOp1());
      emitValue(v.getOp2());
      v.getOp1().getType().apply(new TypeSwitch(){
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"",-3);
          emit(""String_Node_Str"",1);
          emitBooleanBranch(""String_Node_Str"");
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"",-3);
          emit(""String_Node_Str"",1);
          emitBooleanBranch(""String_Node_Str"");
        }
        private void handleIntCase(){
          emit(""String_Node_Str"",-2);
        }
        public void caseIntType(        IntType t){
          handleIntCase();
        }
        public void caseBooleanType(        BooleanType t){
          handleIntCase();
        }
        public void caseShortType(        ShortType t){
          handleIntCase();
        }
        public void caseCharType(        CharType t){
          handleIntCase();
        }
        public void caseByteType(        ByteType t){
          handleIntCase();
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"",-3);
          emit(""String_Node_Str"",1);
          emitBooleanBranch(""String_Node_Str"");
        }
        public void caseArrayType(        ArrayType t){
          emitBooleanBranch(""String_Node_Str"");
        }
        public void casbeRefType(        RefType t){
          emitBooleanBranch(""String_Node_Str"");
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseNegExpr(    final NegExpr v){
      emitValue(v.getOp());
      v.getType().apply(new TypeSwitch(){
        private void handleIntCase(){
          emit(""String_Node_Str"",0);
        }
        public void caseIntType(        IntType t){
          handleIntCase();
        }
        public void caseBooleanType(        BooleanType t){
          handleIntCase();
        }
        public void caseShortType(        ShortType t){
          handleIntCase();
        }
        public void caseCharType(        CharType t){
          handleIntCase();
        }
        public void caseByteType(        ByteType t){
          handleIntCase();
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"",0);
        }
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"",0);
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"",0);
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"" + t + ""String_Node_Str""+ v);
        }
      }
);
    }
    public void caseNewArrayExpr(    NewArrayExpr v){
      Value size=v.getSize();
      emitValue(size);
      if (v.getBaseType() instanceof RefType)       emit(""String_Node_Str"" + slashify(v.getBaseType().toString()),0);
 else       if (v.getBaseType() instanceof ArrayType)       emit(""String_Node_Str"" + jasminDescriptorOf(v.getBaseType()),0);
 else       emit(""String_Node_Str"" + v.getBaseType().toString(),0);
    }
    public void caseNewMultiArrayExpr(    NewMultiArrayExpr v){
      List sizes=v.getSizes();
      for (int i=0; i < sizes.size(); i++)       emitValue((Value)sizes.get(i));
      emit(""String_Node_Str"" + jasminDescriptorOf(v.getBaseType()) + ""String_Node_Str""+ sizes.size(),-sizes.size() + 1);
    }
    public void caseNewExpr(    NewExpr v){
      emit(""String_Node_Str"" + slashify(v.getBaseType().toString()),1);
    }
    public void caseNewInvokeExpr(    NewInvokeExpr v){
      emit(""String_Node_Str"" + slashify(v.getBaseType().toString()),1);
      emit(""String_Node_Str"",1);
      SootMethod m=v.getMethod();
      for (int i=0; i < m.getParameterCount(); i++)       emitValue(v.getArg(i));
      emit(""String_Node_Str"" + slashify(m.getDeclaringClass().getName()) + ""String_Node_Str""+ m.getName()+ jasminDescriptorOf(m),-(argCountOf(m) + 1) + sizeOfType(m.getReturnType()));
    }
    public void caseNullConstant(    NullConstant v){
      emit(""String_Node_Str"",1);
    }
    public void caseOrExpr(    OrExpr v){
      emitValue(v.getOp1());
      emitValue(v.getOp2());
      v.getType().apply(new TypeSwitch(){
        private void handleIntCase(){
          emit(""String_Node_Str"",-1);
        }
        public void caseIntType(        IntType t){
          handleIntCase();
        }
        public void caseBooleanType(        BooleanType t){
          handleIntCase();
        }
        public void caseShortType(        ShortType t){
          handleIntCase();
        }
        public void caseCharType(        CharType t){
          handleIntCase();
        }
        public void caseByteType(        ByteType t){
          handleIntCase();
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"",-2);
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseRemExpr(    RemExpr v){
      emitValue(v.getOp1());
      emitValue(v.getOp2());
      v.getType().apply(new TypeSwitch(){
        private void handleIntCase(){
          emit(""String_Node_Str"",-1);
        }
        public void caseIntType(        IntType t){
          handleIntCase();
        }
        public void caseBooleanType(        BooleanType t){
          handleIntCase();
        }
        public void caseShortType(        ShortType t){
          handleIntCase();
        }
        public void caseCharType(        CharType t){
          handleIntCase();
        }
        public void caseByteType(        ByteType t){
          handleIntCase();
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"",-2);
        }
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"",-2);
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"",-1);
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseShlExpr(    ShlExpr v){
      emitValue(v.getOp1());
      emitValue(v.getOp2());
      v.getType().apply(new TypeSwitch(){
        private void handleIntCase(){
          emit(""String_Node_Str"",-1);
        }
        public void caseIntType(        IntType t){
          handleIntCase();
        }
        public void caseBooleanType(        BooleanType t){
          handleIntCase();
        }
        public void caseShortType(        ShortType t){
          handleIntCase();
        }
        public void caseCharType(        CharType t){
          handleIntCase();
        }
        public void caseByteType(        ByteType t){
          handleIntCase();
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"",-1);
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseShrExpr(    ShrExpr v){
      emitValue(v.getOp1());
      emitValue(v.getOp2());
      v.getType().apply(new TypeSwitch(){
        private void handleIntCase(){
          emit(""String_Node_Str"",-1);
        }
        public void caseIntType(        IntType t){
          handleIntCase();
        }
        public void caseBooleanType(        BooleanType t){
          handleIntCase();
        }
        public void caseShortType(        ShortType t){
          handleIntCase();
        }
        public void caseCharType(        CharType t){
          handleIntCase();
        }
        public void caseByteType(        ByteType t){
          handleIntCase();
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"",-1);
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseSpecialInvokeExpr(    SpecialInvokeExpr v){
      SootMethod m=v.getMethod();
      emitValue(v.getBase());
      for (int i=0; i < m.getParameterCount(); i++)       emitValue(v.getArg(i));
      emit(""String_Node_Str"" + slashify(m.getDeclaringClass().getName()) + ""String_Node_Str""+ m.getName()+ jasminDescriptorOf(m),-(argCountOf(m) + 1) + sizeOfType(m.getReturnType()));
    }
    public void caseStaticInvokeExpr(    StaticInvokeExpr v){
      SootMethod m=v.getMethod();
      for (int i=0; i < m.getParameterCount(); i++)       emitValue(v.getArg(i));
      emit(""String_Node_Str"" + slashify(m.getDeclaringClass().getName()) + ""String_Node_Str""+ m.getName()+ jasminDescriptorOf(m),-(argCountOf(m)) + sizeOfType(m.getReturnType()));
    }
    public void caseStaticFieldRef(    StaticFieldRef v){
      emit(""String_Node_Str"" + slashify(v.getField().getDeclaringClass().getName()) + ""String_Node_Str""+ v.getField().getName()+ ""String_Node_Str""+ jasminDescriptorOf(v.getField().getType()),sizeOfType(v.getField().getType()));
    }
    public void caseStringConstant(    StringConstant v){
      emit(""String_Node_Str"" + v.toString(),1);
    }
    public void caseSubExpr(    SubExpr v){
      emitValue(v.getOp1());
      emitValue(v.getOp2());
      v.getType().apply(new TypeSwitch(){
        private void handleIntCase(){
          emit(""String_Node_Str"",-1);
        }
        public void caseIntType(        IntType t){
          handleIntCase();
        }
        public void caseBooleanType(        BooleanType t){
          handleIntCase();
        }
        public void caseShortType(        ShortType t){
          handleIntCase();
        }
        public void caseCharType(        CharType t){
          handleIntCase();
        }
        public void caseByteType(        ByteType t){
          handleIntCase();
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"",-2);
        }
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"",-2);
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"",-1);
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseUshrExpr(    UshrExpr v){
      emitValue(v.getOp1());
      emitValue(v.getOp2());
      v.getType().apply(new TypeSwitch(){
        private void handleIntCase(){
          emit(""String_Node_Str"",-1);
        }
        public void caseIntType(        IntType t){
          handleIntCase();
        }
        public void caseBooleanType(        BooleanType t){
          handleIntCase();
        }
        public void caseShortType(        ShortType t){
          handleIntCase();
        }
        public void caseCharType(        CharType t){
          handleIntCase();
        }
        public void caseByteType(        ByteType t){
          handleIntCase();
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"",-1);
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseVirtualInvokeExpr(    VirtualInvokeExpr v){
      SootMethod m=v.getMethod();
      emitValue(v.getBase());
      for (int i=0; i < m.getParameterCount(); i++)       emitValue(v.getArg(i));
      emit(""String_Node_Str"" + slashify(m.getDeclaringClass().getName()) + ""String_Node_Str""+ m.getName()+ jasminDescriptorOf(m),-(argCountOf(m) + 1) + sizeOfType(m.getReturnType()));
    }
    public void caseXorExpr(    XorExpr v){
      emitValue(v.getOp1());
      emitValue(v.getOp2());
      v.getType().apply(new TypeSwitch(){
        private void handleIntCase(){
          emit(""String_Node_Str"",-1);
        }
        public void caseIntType(        IntType t){
          handleIntCase();
        }
        public void caseBooleanType(        BooleanType t){
          handleIntCase();
        }
        public void caseShortType(        ShortType t){
          handleIntCase();
        }
        public void caseCharType(        CharType t){
          handleIntCase();
        }
        public void caseByteType(        ByteType t){
          handleIntCase();
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"",-2);
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
  }
);
}"
88644,"/** 
 * Return Stmts Creation
 */
private void createReturn(polyglot.ast.Return retStmt){
  polyglot.ast.Expr expr=retStmt.expr();
  soot.Value sootLocal=null;
  if (expr != null) {
    sootLocal=createExpr(expr);
  }
  if (monitorStack != null) {
    Stack putBack=new Stack();
    while (!monitorStack.isEmpty()) {
      soot.Local exitVal=(soot.Local)monitorStack.pop();
      putBack.push(exitVal);
      soot.jimple.ExitMonitorStmt emStmt=soot.jimple.Jimple.v().newExitMonitorStmt(exitVal);
      body.getUnits().add(emStmt);
    }
    while (!putBack.isEmpty()) {
      monitorStack.push(putBack.pop());
    }
  }
  if (expr == null) {
    soot.jimple.Stmt retStmtVoid=soot.jimple.Jimple.v().newReturnVoidStmt();
    body.getUnits().add(retStmtVoid);
    Util.addLnPosTags(retStmtVoid,retStmt.position());
  }
 else {
    if (sootLocal instanceof soot.jimple.ConditionExpr) {
      sootLocal=handleCondBinExpr((soot.jimple.ConditionExpr)sootLocal);
    }
    soot.jimple.ReturnStmt retStmtLocal=soot.jimple.Jimple.v().newReturnStmt(sootLocal);
    body.getUnits().add(retStmtLocal);
    Util.addLnPosTags(retStmtLocal.getOpBox(),expr.position());
    Util.addLnPosTags(retStmtLocal,retStmt.position());
  }
}","/** 
 * Return Stmts Creation
 */
private void createReturn(polyglot.ast.Return retStmt){
  polyglot.ast.Expr expr=retStmt.expr();
  soot.Value sootLocal=null;
  if (expr != null) {
    sootLocal=createExpr(expr);
  }
  if (monitorStack != null) {
    Stack putBack=new Stack();
    while (!monitorStack.isEmpty()) {
      soot.Local exitVal=(soot.Local)monitorStack.pop();
      putBack.push(exitVal);
      soot.jimple.ExitMonitorStmt emStmt=soot.jimple.Jimple.v().newExitMonitorStmt(exitVal);
      body.getUnits().add(emStmt);
    }
    while (!putBack.isEmpty()) {
      monitorStack.push(putBack.pop());
    }
  }
  if (currentTryStmt != null) {
    createBlock(currentTryStmt.finallyBlock());
  }
  if (expr == null) {
    soot.jimple.Stmt retStmtVoid=soot.jimple.Jimple.v().newReturnVoidStmt();
    body.getUnits().add(retStmtVoid);
    Util.addLnPosTags(retStmtVoid,retStmt.position());
  }
 else {
    if (sootLocal instanceof soot.jimple.ConditionExpr) {
      sootLocal=handleCondBinExpr((soot.jimple.ConditionExpr)sootLocal);
    }
    soot.jimple.ReturnStmt retStmtLocal=soot.jimple.Jimple.v().newReturnStmt(sootLocal);
    body.getUnits().add(retStmtLocal);
    Util.addLnPosTags(retStmtLocal.getOpBox(),expr.position());
    Util.addLnPosTags(retStmtLocal,retStmt.position());
  }
}"
88645,"/** 
 * handles try/catch/finally (try/catch is separate for simplicity)
 */
private void createTryCatchFinally(polyglot.ast.Try tryStmt){
  HashMap gotoMap=new HashMap();
  polyglot.ast.Block tryBlock=tryStmt.tryBlock();
  soot.jimple.Stmt noop1=soot.jimple.Jimple.v().newNopStmt();
  body.getUnits().add(noop1);
  createBlock(tryBlock);
  soot.jimple.Stmt noop2=soot.jimple.Jimple.v().newNopStmt();
  body.getUnits().add(noop2);
  soot.jimple.Stmt endNoop=soot.jimple.Jimple.v().newNopStmt();
  soot.jimple.Stmt tryGotoFinallyNoop=soot.jimple.Jimple.v().newNopStmt();
  body.getUnits().add(tryGotoFinallyNoop);
  soot.jimple.Stmt tryFinallyNoop=soot.jimple.Jimple.v().newNopStmt();
  soot.jimple.Stmt tryGotoFinally=soot.jimple.Jimple.v().newGotoStmt(tryFinallyNoop);
  body.getUnits().add(tryGotoFinally);
  soot.jimple.Stmt beforeEndGotoNoop=soot.jimple.Jimple.v().newNopStmt();
  body.getUnits().add(beforeEndGotoNoop);
  soot.jimple.Stmt tryEndGoto=soot.jimple.Jimple.v().newGotoStmt(endNoop);
  body.getUnits().add(tryEndGoto);
  gotoMap.put(tryFinallyNoop,beforeEndGotoNoop);
  soot.jimple.Stmt catchAllBeforeNoop=soot.jimple.Jimple.v().newNopStmt();
  Iterator it=tryStmt.catchBlocks().iterator();
  while (it.hasNext()) {
    soot.jimple.Stmt noop3=soot.jimple.Jimple.v().newNopStmt();
    body.getUnits().add(noop3);
    polyglot.ast.Catch catchBlock=(polyglot.ast.Catch)it.next();
    soot.jimple.Stmt catchRefNoop=soot.jimple.Jimple.v().newNopStmt();
    body.getUnits().add(catchRefNoop);
    createCatchFormal(catchBlock.formal());
    soot.jimple.Stmt catchStmtsNoop=soot.jimple.Jimple.v().newNopStmt();
    body.getUnits().add(catchStmtsNoop);
    createBlock(catchBlock.body());
    soot.jimple.Stmt catchGotoFinallyNoop=soot.jimple.Jimple.v().newNopStmt();
    body.getUnits().add(catchGotoFinallyNoop);
    soot.jimple.Stmt catchFinallyNoop=soot.jimple.Jimple.v().newNopStmt();
    soot.jimple.Stmt catchGotoFinally=soot.jimple.Jimple.v().newGotoStmt(catchFinallyNoop);
    body.getUnits().add(catchGotoFinally);
    soot.jimple.Stmt beforeCatchEndGotoNoop=soot.jimple.Jimple.v().newNopStmt();
    body.getUnits().add(beforeCatchEndGotoNoop);
    soot.jimple.Stmt catchEndGoto=soot.jimple.Jimple.v().newGotoStmt(endNoop);
    body.getUnits().add(catchEndGoto);
    gotoMap.put(catchFinallyNoop,beforeCatchEndGotoNoop);
    soot.Type sootType=Util.getSootType(catchBlock.catchType());
    addToExceptionList(noop1,noop2,noop3,soot.Scene.v().getSootClass(sootType.toString()));
    addToExceptionList(catchStmtsNoop,beforeCatchEndGotoNoop,catchAllBeforeNoop,soot.Scene.v().getSootClass(""String_Node_Str""));
  }
  soot.Local formalLocal=lg.generateLocal(soot.RefType.v(""String_Node_Str""));
  body.getUnits().add(catchAllBeforeNoop);
  soot.jimple.CaughtExceptionRef exceptRef=soot.jimple.Jimple.v().newCaughtExceptionRef();
  soot.jimple.Stmt stmt=soot.jimple.Jimple.v().newIdentityStmt(formalLocal,exceptRef);
  body.getUnits().add(stmt);
  soot.jimple.Stmt beforeCatchAllAssignNoop=soot.jimple.Jimple.v().newNopStmt();
  body.getUnits().add(beforeCatchAllAssignNoop);
  soot.Local catchAllAssignLocal=lg.generateLocal(soot.RefType.v(""String_Node_Str""));
  soot.jimple.Stmt catchAllAssign=soot.jimple.Jimple.v().newAssignStmt(catchAllAssignLocal,formalLocal);
  body.getUnits().add(catchAllAssign);
  soot.jimple.Stmt catchAllFinallyNoop=soot.jimple.Jimple.v().newNopStmt();
  soot.jimple.Stmt catchAllGotoFinally=soot.jimple.Jimple.v().newGotoStmt(catchAllFinallyNoop);
  body.getUnits().add(catchAllGotoFinally);
  soot.jimple.Stmt catchAllBeforeThrowNoop=soot.jimple.Jimple.v().newNopStmt();
  body.getUnits().add(catchAllBeforeThrowNoop);
  soot.jimple.Stmt throwStmt=soot.jimple.Jimple.v().newThrowStmt(catchAllAssignLocal);
  throwStmt.addTag(new soot.tagkit.ThrowCreatedByCompilerTag());
  body.getUnits().add(throwStmt);
  gotoMap.put(catchAllFinallyNoop,catchAllBeforeThrowNoop);
  soot.jimple.Stmt catchAllGotoEnd=soot.jimple.Jimple.v().newGotoStmt(endNoop);
  body.getUnits().add(catchAllGotoEnd);
  addToExceptionList(beforeCatchAllAssignNoop,catchAllBeforeThrowNoop,catchAllBeforeNoop,soot.Scene.v().getSootClass(""String_Node_Str""));
  Iterator finallyIt=gotoMap.keySet().iterator();
  while (finallyIt.hasNext()) {
    soot.jimple.Stmt noopStmt=(soot.jimple.Stmt)finallyIt.next();
    body.getUnits().add(noopStmt);
    createBlock(tryStmt.finallyBlock());
    soot.jimple.Stmt backToStmt=(soot.jimple.Stmt)gotoMap.get(noopStmt);
    soot.jimple.Stmt backToGoto=soot.jimple.Jimple.v().newGotoStmt(backToStmt);
    body.getUnits().add(backToGoto);
  }
  body.getUnits().add(endNoop);
  addToExceptionList(noop1,beforeEndGotoNoop,catchAllBeforeNoop,soot.Scene.v().getSootClass(""String_Node_Str""));
}","/** 
 * handles try/catch/finally (try/catch is separate for simplicity)
 */
private void createTryCatchFinally(polyglot.ast.Try tryStmt){
  HashMap gotoMap=new HashMap();
  polyglot.ast.Block tryBlock=tryStmt.tryBlock();
  soot.jimple.Stmt noop1=soot.jimple.Jimple.v().newNopStmt();
  body.getUnits().add(noop1);
  currentTryStmt=tryStmt;
  createBlock(tryBlock);
  currentTryStmt=null;
  soot.jimple.Stmt noop2=soot.jimple.Jimple.v().newNopStmt();
  body.getUnits().add(noop2);
  soot.jimple.Stmt endNoop=soot.jimple.Jimple.v().newNopStmt();
  soot.jimple.Stmt tryGotoFinallyNoop=soot.jimple.Jimple.v().newNopStmt();
  body.getUnits().add(tryGotoFinallyNoop);
  soot.jimple.Stmt tryFinallyNoop=soot.jimple.Jimple.v().newNopStmt();
  soot.jimple.Stmt tryGotoFinally=soot.jimple.Jimple.v().newGotoStmt(tryFinallyNoop);
  body.getUnits().add(tryGotoFinally);
  soot.jimple.Stmt beforeEndGotoNoop=soot.jimple.Jimple.v().newNopStmt();
  body.getUnits().add(beforeEndGotoNoop);
  soot.jimple.Stmt tryEndGoto=soot.jimple.Jimple.v().newGotoStmt(endNoop);
  body.getUnits().add(tryEndGoto);
  gotoMap.put(tryFinallyNoop,beforeEndGotoNoop);
  soot.jimple.Stmt catchAllBeforeNoop=soot.jimple.Jimple.v().newNopStmt();
  Iterator it=tryStmt.catchBlocks().iterator();
  while (it.hasNext()) {
    soot.jimple.Stmt noop3=soot.jimple.Jimple.v().newNopStmt();
    body.getUnits().add(noop3);
    polyglot.ast.Catch catchBlock=(polyglot.ast.Catch)it.next();
    soot.jimple.Stmt catchRefNoop=soot.jimple.Jimple.v().newNopStmt();
    body.getUnits().add(catchRefNoop);
    createCatchFormal(catchBlock.formal());
    soot.jimple.Stmt catchStmtsNoop=soot.jimple.Jimple.v().newNopStmt();
    body.getUnits().add(catchStmtsNoop);
    createBlock(catchBlock.body());
    soot.jimple.Stmt catchGotoFinallyNoop=soot.jimple.Jimple.v().newNopStmt();
    body.getUnits().add(catchGotoFinallyNoop);
    soot.jimple.Stmt catchFinallyNoop=soot.jimple.Jimple.v().newNopStmt();
    soot.jimple.Stmt catchGotoFinally=soot.jimple.Jimple.v().newGotoStmt(catchFinallyNoop);
    body.getUnits().add(catchGotoFinally);
    soot.jimple.Stmt beforeCatchEndGotoNoop=soot.jimple.Jimple.v().newNopStmt();
    body.getUnits().add(beforeCatchEndGotoNoop);
    soot.jimple.Stmt catchEndGoto=soot.jimple.Jimple.v().newGotoStmt(endNoop);
    body.getUnits().add(catchEndGoto);
    gotoMap.put(catchFinallyNoop,beforeCatchEndGotoNoop);
    soot.Type sootType=Util.getSootType(catchBlock.catchType());
    addToExceptionList(noop1,noop2,noop3,soot.Scene.v().getSootClass(sootType.toString()));
    addToExceptionList(catchStmtsNoop,beforeCatchEndGotoNoop,catchAllBeforeNoop,soot.Scene.v().getSootClass(""String_Node_Str""));
  }
  soot.Local formalLocal=lg.generateLocal(soot.RefType.v(""String_Node_Str""));
  body.getUnits().add(catchAllBeforeNoop);
  soot.jimple.CaughtExceptionRef exceptRef=soot.jimple.Jimple.v().newCaughtExceptionRef();
  soot.jimple.Stmt stmt=soot.jimple.Jimple.v().newIdentityStmt(formalLocal,exceptRef);
  body.getUnits().add(stmt);
  soot.jimple.Stmt beforeCatchAllAssignNoop=soot.jimple.Jimple.v().newNopStmt();
  body.getUnits().add(beforeCatchAllAssignNoop);
  soot.Local catchAllAssignLocal=lg.generateLocal(soot.RefType.v(""String_Node_Str""));
  soot.jimple.Stmt catchAllAssign=soot.jimple.Jimple.v().newAssignStmt(catchAllAssignLocal,formalLocal);
  body.getUnits().add(catchAllAssign);
  soot.jimple.Stmt catchAllFinallyNoop=soot.jimple.Jimple.v().newNopStmt();
  soot.jimple.Stmt catchAllGotoFinally=soot.jimple.Jimple.v().newGotoStmt(catchAllFinallyNoop);
  body.getUnits().add(catchAllGotoFinally);
  soot.jimple.Stmt catchAllBeforeThrowNoop=soot.jimple.Jimple.v().newNopStmt();
  body.getUnits().add(catchAllBeforeThrowNoop);
  soot.jimple.Stmt throwStmt=soot.jimple.Jimple.v().newThrowStmt(catchAllAssignLocal);
  throwStmt.addTag(new soot.tagkit.ThrowCreatedByCompilerTag());
  body.getUnits().add(throwStmt);
  gotoMap.put(catchAllFinallyNoop,catchAllBeforeThrowNoop);
  soot.jimple.Stmt catchAllGotoEnd=soot.jimple.Jimple.v().newGotoStmt(endNoop);
  body.getUnits().add(catchAllGotoEnd);
  addToExceptionList(beforeCatchAllAssignNoop,catchAllBeforeThrowNoop,catchAllBeforeNoop,soot.Scene.v().getSootClass(""String_Node_Str""));
  Iterator finallyIt=gotoMap.keySet().iterator();
  while (finallyIt.hasNext()) {
    soot.jimple.Stmt noopStmt=(soot.jimple.Stmt)finallyIt.next();
    body.getUnits().add(noopStmt);
    createBlock(tryStmt.finallyBlock());
    soot.jimple.Stmt backToStmt=(soot.jimple.Stmt)gotoMap.get(noopStmt);
    soot.jimple.Stmt backToGoto=soot.jimple.Jimple.v().newGotoStmt(backToStmt);
    body.getUnits().add(backToGoto);
  }
  body.getUnits().add(endNoop);
  addToExceptionList(noop1,beforeEndGotoNoop,catchAllBeforeNoop,soot.Scene.v().getSootClass(""String_Node_Str""));
}"
88646,"public void internalTransform(String phaseName,Map opts){
  Iterator it=Scene.v().getApplicationClasses().iterator();
  while (it.hasNext()) {
    SootClass sc=(SootClass)it.next();
    HashMap lineToMeth=new HashMap();
    Iterator methIt=sc.getMethods().iterator();
    while (methIt.hasNext()) {
      SootMethod meth=(SootMethod)methIt.next();
      Body body=meth.retrieveActiveBody();
      Stmt s=(Stmt)body.getUnits().getFirst();
      while (s instanceof IdentityStmt) {
        s=(Stmt)body.getUnits().getSuccOf(s);
      }
      if (s.hasTag(""String_Node_Str"")) {
        LineNumberTag tag=(LineNumberTag)s.getTag(""String_Node_Str"");
        lineToMeth.put(new Integer(tag.getLineNumber()),meth);
      }
    }
    Iterator methIt2=sc.getMethods().iterator();
    while (methIt2.hasNext()) {
      SootMethod meth=(SootMethod)methIt2.next();
      Body body=meth.retrieveActiveBody();
      Stmt s=(Stmt)body.getUnits().getFirst();
      while (s instanceof IdentityStmt) {
        s=(Stmt)body.getUnits().getSuccOf(s);
      }
      if (s.hasTag(""String_Node_Str"")) {
        LineNumberTag tag=(LineNumberTag)s.getTag(""String_Node_Str"");
        int line_num=tag.getLineNumber() - 1;
        if (lineToMeth.containsKey(new Integer(line_num))) {
          meth.addTag(new LineNumberTag(line_num + 1));
        }
 else {
          meth.addTag(new LineNumberTag(line_num));
        }
      }
    }
  }
}","public void internalTransform(String phaseName,Map opts){
  Iterator it=Scene.v().getApplicationClasses().iterator();
  while (it.hasNext()) {
    SootClass sc=(SootClass)it.next();
    HashMap lineToMeth=new HashMap();
    Iterator methIt=sc.getMethods().iterator();
    while (methIt.hasNext()) {
      SootMethod meth=(SootMethod)methIt.next();
      if (!meth.isConcrete())       continue;
      Body body=meth.retrieveActiveBody();
      Stmt s=(Stmt)body.getUnits().getFirst();
      while (s instanceof IdentityStmt) {
        s=(Stmt)body.getUnits().getSuccOf(s);
      }
      if (s.hasTag(""String_Node_Str"")) {
        LineNumberTag tag=(LineNumberTag)s.getTag(""String_Node_Str"");
        lineToMeth.put(new Integer(tag.getLineNumber()),meth);
      }
    }
    Iterator methIt2=sc.getMethods().iterator();
    while (methIt2.hasNext()) {
      SootMethod meth=(SootMethod)methIt2.next();
      if (!meth.isConcrete())       continue;
      Body body=meth.retrieveActiveBody();
      Stmt s=(Stmt)body.getUnits().getFirst();
      while (s instanceof IdentityStmt) {
        s=(Stmt)body.getUnits().getSuccOf(s);
      }
      if (s.hasTag(""String_Node_Str"")) {
        LineNumberTag tag=(LineNumberTag)s.getTag(""String_Node_Str"");
        int line_num=tag.getLineNumber() - 1;
        if (lineToMeth.containsKey(new Integer(line_num))) {
          meth.addTag(new LineNumberTag(line_num + 1));
        }
 else {
          meth.addTag(new LineNumberTag(line_num));
        }
      }
    }
  }
}"
88647,"/** 
 * Gets the Soot Method form the given Soot Class
 */
private soot.SootMethod getMethodFromClass(soot.SootClass sootClass,String name,ArrayList paramTypes,soot.Type returnType){
  return sootClass.getMethod(name,paramTypes,returnType);
}","/** 
 * Gets the Soot Method form the given Soot Class
 */
private soot.SootMethod getMethodFromClass(soot.SootClass sootClass,String name,ArrayList paramTypes,soot.Type returnType){
  try {
    return sootClass.getMethod(name,paramTypes,returnType);
  }
 catch (  Exception e) {
    if (paramTypes != null && !paramTypes.isEmpty()) {
      soot.SootClass firstParam=((soot.RefType)paramTypes.get(0)).getSootClass();
      boolean foundMeth=false;
      while (!foundMeth) {
        paramTypes.set(0,firstParam.getSuperclass().getType());
        if (sootClass.declaresMethod(name,paramTypes,returnType)) {
          return sootClass.getMethod(name,paramTypes,returnType);
        }
        firstParam=firstParam.getSuperclass();
      }
    }
  }
  return null;
}"
88648,"/** 
 * adds modifiers
 */
private void addModifiers(polyglot.types.Flags flags,polyglot.ast.ClassDecl cDecl){
  int modifiers=0;
  if (cDecl.type().isNested()) {
    if (flags.isPublic() || flags.isProtected() || flags.isPrivate()) {
      modifiers=soot.Modifier.PUBLIC;
    }
    if (flags.isInterface()) {
      modifiers=modifiers | soot.Modifier.INTERFACE;
    }
    if (cDecl.type().outer().flags().isInterface()) {
      modifiers=soot.Modifier.PUBLIC;
    }
  }
 else {
    modifiers=Util.getModifier(flags);
  }
  sootClass.setModifiers(modifiers);
}","/** 
 * adds modifiers
 */
private void addModifiers(polyglot.types.Flags flags,polyglot.ast.ClassDecl cDecl){
  int modifiers=0;
  if (cDecl.type().isNested()) {
    if (flags.isPublic() || flags.isProtected() || flags.isPrivate()) {
      modifiers=soot.Modifier.PUBLIC;
    }
    if (flags.isInterface()) {
      modifiers=modifiers | soot.Modifier.INTERFACE;
    }
    if (cDecl.type().outer().flags().isInterface()) {
      modifiers=modifiers | soot.Modifier.PUBLIC;
    }
  }
 else {
    modifiers=Util.getModifier(flags);
  }
  sootClass.setModifiers(modifiers);
}"
88649,"/** 
 * Return Stmts Creation
 */
private void createReturn(polyglot.ast.Return retStmt){
  polyglot.ast.Expr expr=retStmt.expr();
  soot.Value sootLocal=null;
  if (expr != null) {
    sootLocal=createExpr(expr);
  }
  if (monitorStack != null) {
    Stack putBack=new Stack();
    while (!monitorStack.isEmpty()) {
      soot.Local exitVal=(soot.Local)monitorStack.pop();
      putBack.push(exitVal);
      soot.jimple.ExitMonitorStmt emStmt=soot.jimple.Jimple.v().newExitMonitorStmt(exitVal);
      body.getUnits().add(emStmt);
    }
    while (!putBack.isEmpty()) {
      monitorStack.push(putBack.pop());
    }
  }
  if (tryStack != null && !tryStack.isEmpty()) {
    polyglot.ast.Try currentTry=(polyglot.ast.Try)tryStack.pop();
    createBlock(currentTry.finallyBlock());
    tryStack.push(currentTry);
    ReturnStmtChecker rsc=new ReturnStmtChecker();
    currentTry.finallyBlock().visit(rsc);
    if (rsc.hasRet()) {
      return;
    }
  }
  if (catchStack != null && !catchStack.isEmpty()) {
    polyglot.ast.Try currentTry=(polyglot.ast.Try)catchStack.pop();
    createBlock(currentTry.finallyBlock());
    catchStack.push(currentTry);
    ReturnStmtChecker rsc=new ReturnStmtChecker();
    currentTry.finallyBlock().visit(rsc);
    if (rsc.hasRet()) {
      return;
    }
  }
  if (expr == null) {
    soot.jimple.Stmt retStmtVoid=soot.jimple.Jimple.v().newReturnVoidStmt();
    body.getUnits().add(retStmtVoid);
    Util.addLnPosTags(retStmtVoid,retStmt.position());
  }
 else {
    if (sootLocal instanceof soot.jimple.ConditionExpr) {
      sootLocal=handleCondBinExpr((soot.jimple.ConditionExpr)sootLocal);
    }
    soot.jimple.ReturnStmt retStmtLocal=soot.jimple.Jimple.v().newReturnStmt(sootLocal);
    body.getUnits().add(retStmtLocal);
    Util.addLnPosTags(retStmtLocal.getOpBox(),expr.position());
    Util.addLnPosTags(retStmtLocal,retStmt.position());
  }
}","/** 
 * Return Stmts Creation
 */
private void createReturn(polyglot.ast.Return retStmt){
  polyglot.ast.Expr expr=retStmt.expr();
  soot.Value sootLocal=null;
  if (expr != null) {
    sootLocal=createExpr(expr);
  }
  if (monitorStack != null) {
    Stack putBack=new Stack();
    while (!monitorStack.isEmpty()) {
      soot.Local exitVal=(soot.Local)monitorStack.pop();
      putBack.push(exitVal);
      soot.jimple.ExitMonitorStmt emStmt=soot.jimple.Jimple.v().newExitMonitorStmt(exitVal);
      body.getUnits().add(emStmt);
    }
    while (!putBack.isEmpty()) {
      monitorStack.push(putBack.pop());
    }
  }
  if (tryStack != null && !tryStack.isEmpty()) {
    polyglot.ast.Try currentTry=(polyglot.ast.Try)tryStack.pop();
    if (currentTry.finallyBlock() != null) {
      createBlock(currentTry.finallyBlock());
      tryStack.push(currentTry);
      ReturnStmtChecker rsc=new ReturnStmtChecker();
      currentTry.finallyBlock().visit(rsc);
      if (rsc.hasRet()) {
        return;
      }
    }
 else {
      tryStack.push(currentTry);
    }
  }
  if (catchStack != null && !catchStack.isEmpty()) {
    polyglot.ast.Try currentTry=(polyglot.ast.Try)catchStack.pop();
    if (currentTry.finallyBlock() != null) {
      createBlock(currentTry.finallyBlock());
      catchStack.push(currentTry);
      ReturnStmtChecker rsc=new ReturnStmtChecker();
      currentTry.finallyBlock().visit(rsc);
      if (rsc.hasRet()) {
        return;
      }
    }
 else {
      catchStack.push(currentTry);
    }
  }
  if (expr == null) {
    soot.jimple.Stmt retStmtVoid=soot.jimple.Jimple.v().newReturnVoidStmt();
    body.getUnits().add(retStmtVoid);
    Util.addLnPosTags(retStmtVoid,retStmt.position());
  }
 else {
    if (sootLocal instanceof soot.jimple.ConditionExpr) {
      sootLocal=handleCondBinExpr((soot.jimple.ConditionExpr)sootLocal);
    }
    soot.jimple.ReturnStmt retStmtLocal=soot.jimple.Jimple.v().newReturnStmt(sootLocal);
    body.getUnits().add(retStmtLocal);
    Util.addLnPosTags(retStmtLocal.getOpBox(),expr.position());
    Util.addLnPosTags(retStmtLocal,retStmt.position());
  }
}"
88650,"public String toString(){
  StringBuffer ret=new StringBuffer();
  if (fields == null)   return ""String_Node_Str"";
  for (Iterator fieldIt=fields.keySet().iterator(); fieldIt.hasNext(); ) {
    final Object field=(Object)fieldIt.next();
    ret.append(""String_Node_Str"" + field + ""String_Node_Str""+ fields.get(field)+ ""String_Node_Str"");
  }
  return ret.toString();
}","public String toString(){
  boolean empty=true;
  StringBuffer ret=new StringBuffer();
  if (fields != null) {
    for (Iterator fieldIt=fields.keySet().iterator(); fieldIt.hasNext(); ) {
      final Object field=(Object)fieldIt.next();
      ret.append(""String_Node_Str"" + field + ""String_Node_Str""+ fields.get(field)+ ""String_Node_Str"");
      empty=false;
    }
  }
  if (globals != null) {
    for (Iterator globalIt=globals.iterator(); globalIt.hasNext(); ) {
      final Object global=(Object)globalIt.next();
      ret.append(""String_Node_Str"" + global + ""String_Node_Str"");
      empty=false;
    }
  }
  if (empty)   ret.append(""String_Node_Str"");
  return ret.toString();
}"
88651,"public void findNTRWSets(SootMethod method){
  if (methodToNTReadSet.containsKey(method) && methodToNTWriteSet.containsKey(method))   return;
  MethodRWSet read=new MethodRWSet();
  MethodRWSet write=new MethodRWSet();
  for (Iterator sIt=method.retrieveActiveBody().getUnits().iterator(); sIt.hasNext(); ) {
    final Stmt s=(Stmt)sIt.next();
    read.union(ntReadSet(method,s));
    write.union(ntWriteSet(method,s));
  }
  methodToNTReadSet.put(method,read);
  methodToNTWriteSet.put(method,write);
  SootClass c=method.getDeclaringClass();
}","public void findNTRWSets(SootMethod method){
  if (methodToNTReadSet.containsKey(method) && methodToNTWriteSet.containsKey(method))   return;
  MethodRWSet read=null;
  MethodRWSet write=null;
  for (Iterator sIt=method.retrieveActiveBody().getUnits().iterator(); sIt.hasNext(); ) {
    final Stmt s=(Stmt)sIt.next();
    RWSet ntr=ntReadSet(method,s);
    if (ntr != null) {
      if (read == null)       read=new MethodRWSet();
      read.union(ntr);
    }
    RWSet ntw=ntWriteSet(method,s);
    if (ntw != null) {
      if (write == null)       write=new MethodRWSet();
      write.union(ntw);
    }
  }
  methodToNTReadSet.put(method,read);
  methodToNTWriteSet.put(method,write);
  SootClass c=method.getDeclaringClass();
}"
88652,"public RWSet writeSet(SootMethod method,Stmt stmt){
  RWSet ret=null;
  Iterator targets=tt.iterator(stmt);
  while (targets.hasNext()) {
    SootMethod target=(SootMethod)targets.next();
    if (target.isNative()) {
      if (ret == null)       ret=new SiteRWSet();
      ret.setCallsNative();
    }
 else     if (target.isConcrete()) {
      if (ret == null)       ret=new SiteRWSet();
      ret.union(nonTransitiveWriteSet(target));
    }
  }
  if (ret == null)   return ntWriteSet(method,stmt);
  ret.union(ntWriteSet(method,stmt));
  return ret;
}","public RWSet writeSet(SootMethod method,Stmt stmt){
  RWSet ret=null;
  Iterator targets=tt.iterator(stmt);
  while (targets.hasNext()) {
    SootMethod target=(SootMethod)targets.next();
    if (target.isNative()) {
      if (ret == null)       ret=new SiteRWSet();
      ret.setCallsNative();
    }
 else     if (target.isConcrete()) {
      RWSet ntw=nonTransitiveWriteSet(target);
      if (ntw != null) {
        if (ret == null)         ret=new SiteRWSet();
        ret.union(ntw);
      }
    }
  }
  if (ret == null)   return ntWriteSet(method,stmt);
  ret.union(ntWriteSet(method,stmt));
  return ret;
}"
88653,"public RWSet readSet(SootMethod method,Stmt stmt){
  RWSet ret=null;
  Iterator targets=tt.iterator(stmt);
  while (targets.hasNext()) {
    SootMethod target=(SootMethod)targets.next();
    if (target.isNative()) {
      if (ret == null)       ret=new SiteRWSet();
      ret.setCallsNative();
    }
 else     if (target.isConcrete()) {
      if (ret == null)       ret=new SiteRWSet();
      ret.union(nonTransitiveReadSet(target));
    }
  }
  if (ret == null)   return ntReadSet(method,stmt);
  ret.union(ntReadSet(method,stmt));
  return ret;
}","public RWSet readSet(SootMethod method,Stmt stmt){
  RWSet ret=null;
  Iterator targets=tt.iterator(stmt);
  while (targets.hasNext()) {
    SootMethod target=(SootMethod)targets.next();
    if (target.isNative()) {
      if (ret == null)       ret=new SiteRWSet();
      ret.setCallsNative();
    }
 else     if (target.isConcrete()) {
      RWSet ntr=nonTransitiveReadSet(target);
      if (ntr != null) {
        if (ret == null)         ret=new SiteRWSet();
        ret.union(ntr);
      }
    }
  }
  if (ret == null)   return ntReadSet(method,stmt);
  ret.union(ntReadSet(method,stmt));
  return ret;
}"
88654,"public String toString(){
  final StringBuffer ret=new StringBuffer();
  for (Iterator keyIt=sets.iterator(); keyIt.hasNext(); ) {
    final Object key=(Object)keyIt.next();
    ret.append(key.toString());
  }
  return ret.toString();
}","public String toString(){
  boolean empty=true;
  final StringBuffer ret=new StringBuffer();
  ret.append(""String_Node_Str"");
  for (Iterator keyIt=sets.iterator(); keyIt.hasNext(); ) {
    final Object key=(Object)keyIt.next();
    ret.append(key.toString());
    empty=false;
  }
  if (empty)   ret.append(""String_Node_Str"");
  return ret.toString();
}"
88655,"/** 
 * Find all the locals of reference type and all the types used in casts to initialize the mapping from locals and types to bits in the bit vector in LocalTypeSet. 
 */
protected void makeInitialSet(){
  Chain locals=((UnitGraph)graph).getBody().getLocals();
  List refLocals=new ArrayList();
  for (Iterator it=locals.iterator(); it.hasNext(); ) {
    Local l=(Local)it.next();
    if (l.getType() instanceof RefType) {
      refLocals.add(l);
    }
  }
  List types=new ArrayList();
  for (Iterator it=((UnitGraph)graph).getBody().getUnits().iterator(); it.hasNext(); ) {
    Stmt s=(Stmt)it.next();
    if (s instanceof AssignStmt) {
      AssignStmt as=(AssignStmt)s;
      Value rhs=as.getRightOp();
      if (rhs instanceof CastExpr) {
        Type t=((CastExpr)rhs).getCastType();
        if (t instanceof RefType && !types.contains(t)) {
          types.add(t);
        }
      }
    }
  }
  emptySet=new LocalTypeSet(refLocals,types);
}","/** 
 * Find all the locals of reference type and all the types used in casts to initialize the mapping from locals and types to bits in the bit vector in LocalTypeSet. 
 */
protected void makeInitialSet(){
  Chain locals=((UnitGraph)graph).getBody().getLocals();
  List refLocals=new ArrayList();
  for (Iterator lIt=locals.iterator(); lIt.hasNext(); ) {
    final Local l=(Local)lIt.next();
    if (l.getType() instanceof RefType) {
      refLocals.add(l);
    }
  }
  List types=new ArrayList();
  for (Iterator sIt=((UnitGraph)graph).getBody().getUnits().iterator(); sIt.hasNext(); ) {
    final Stmt s=(Stmt)sIt.next();
    if (s instanceof AssignStmt) {
      AssignStmt as=(AssignStmt)s;
      Value rhs=as.getRightOp();
      if (rhs instanceof CastExpr) {
        Type t=((CastExpr)rhs).getCastType();
        if (t instanceof RefType && !types.contains(t)) {
          types.add(t);
        }
      }
    }
  }
  emptySet=new LocalTypeSet(refLocals,types);
}"
88656,"/** 
 * This is the flow function as described in the assignment write-up. 
 */
protected void flowThrough(Object inValue,Unit unit,List outFallValues,List outBranchValues){
  final LocalTypeSet in=(LocalTypeSet)inValue;
  final LocalTypeSet out=(LocalTypeSet)in.clone();
  LocalTypeSet outBranch=out;
  final Stmt stmt=(Stmt)unit;
  for (Iterator it=stmt.getDefBoxes().iterator(); it.hasNext(); ) {
    ValueBox b=(ValueBox)it.next();
    Value v=b.getValue();
    if (v instanceof Local && v.getType() instanceof RefType) {
      out.killLocal((Local)v);
    }
  }
  if (stmt instanceof AssignStmt) {
    AssignStmt astmt=(AssignStmt)stmt;
    Value rhs=astmt.getRightOp();
    Value lhs=astmt.getLeftOp();
    if (lhs instanceof Local && rhs.getType() instanceof RefType) {
      Local l=(Local)lhs;
      if (rhs instanceof NewExpr) {
        out.localMustBeSubtypeOf(l,(RefType)rhs.getType());
      }
 else       if (rhs instanceof CastExpr) {
        CastExpr cast=(CastExpr)rhs;
        Type castType=cast.getCastType();
        if (castType instanceof RefType) {
          out.localCopy(l,(Local)cast.getOp());
          out.localMustBeSubtypeOf(l,(RefType)castType);
          out.localMustBeSubtypeOf((Local)cast.getOp(),(RefType)castType);
        }
      }
 else       if (rhs instanceof Local) {
        out.localCopy(l,(Local)rhs);
      }
    }
  }
 else   if (stmt instanceof IfStmt) {
    IfStmt ifstmt=(IfStmt)stmt;
    do {
      if (graph.getPredsOf(stmt).size() != 1)       break;
      Object predecessor=(Stmt)graph.getPredsOf(stmt).get(0);
      if (!(predecessor instanceof AssignStmt))       break;
      AssignStmt pred=(AssignStmt)predecessor;
      if (!(pred.getRightOp() instanceof InstanceOfExpr))       break;
      InstanceOfExpr iofexpr=(InstanceOfExpr)pred.getRightOp();
      if (!(iofexpr.getCheckType() instanceof RefType))       break;
      ConditionExpr c=(ConditionExpr)ifstmt.getCondition();
      if (!c.getOp1().equals(pred.getLeftOp()))       break;
      if (!(c.getOp2() instanceof IntConstant))       break;
      if (((IntConstant)c.getOp2()).value != 0)       break;
      if (c instanceof NeExpr) {
        outBranch=(LocalTypeSet)out.clone();
        outBranch.localMustBeSubtypeOf((Local)iofexpr.getOp(),(RefType)iofexpr.getCheckType());
      }
 else       if (c instanceof EqExpr) {
        outBranch=(LocalTypeSet)out.clone();
        out.localMustBeSubtypeOf((Local)iofexpr.getOp(),(RefType)iofexpr.getCheckType());
      }
    }
 while (false);
  }
  for (Iterator it=outFallValues.iterator(); it.hasNext(); ) {
    copy(out,it.next());
  }
  for (Iterator it=outBranchValues.iterator(); it.hasNext(); ) {
    copy(outBranch,it.next());
  }
}","/** 
 * This is the flow function as described in the assignment write-up. 
 */
protected void flowThrough(Object inValue,Unit unit,List outFallValues,List outBranchValues){
  final LocalTypeSet in=(LocalTypeSet)inValue;
  final LocalTypeSet out=(LocalTypeSet)in.clone();
  LocalTypeSet outBranch=out;
  final Stmt stmt=(Stmt)unit;
  for (Iterator bIt=stmt.getDefBoxes().iterator(); bIt.hasNext(); ) {
    final ValueBox b=(ValueBox)bIt.next();
    Value v=b.getValue();
    if (v instanceof Local && v.getType() instanceof RefType) {
      out.killLocal((Local)v);
    }
  }
  if (stmt instanceof AssignStmt) {
    AssignStmt astmt=(AssignStmt)stmt;
    Value rhs=astmt.getRightOp();
    Value lhs=astmt.getLeftOp();
    if (lhs instanceof Local && rhs.getType() instanceof RefType) {
      Local l=(Local)lhs;
      if (rhs instanceof NewExpr) {
        out.localMustBeSubtypeOf(l,(RefType)rhs.getType());
      }
 else       if (rhs instanceof CastExpr) {
        CastExpr cast=(CastExpr)rhs;
        Type castType=cast.getCastType();
        if (castType instanceof RefType && cast.getOp() instanceof Local) {
          RefType refType=(RefType)castType;
          Local opLocal=(Local)cast.getOp();
          out.localCopy(l,opLocal);
          out.localMustBeSubtypeOf(l,refType);
          out.localMustBeSubtypeOf(opLocal,refType);
        }
      }
 else       if (rhs instanceof Local) {
        out.localCopy(l,(Local)rhs);
      }
    }
  }
 else   if (stmt instanceof IfStmt) {
    IfStmt ifstmt=(IfStmt)stmt;
    do {
      if (graph.getPredsOf(stmt).size() != 1)       break;
      Object predecessor=(Stmt)graph.getPredsOf(stmt).get(0);
      if (!(predecessor instanceof AssignStmt))       break;
      AssignStmt pred=(AssignStmt)predecessor;
      if (!(pred.getRightOp() instanceof InstanceOfExpr))       break;
      InstanceOfExpr iofexpr=(InstanceOfExpr)pred.getRightOp();
      if (!(iofexpr.getCheckType() instanceof RefType))       break;
      if (!(iofexpr.getOp() instanceof Local))       break;
      ConditionExpr c=(ConditionExpr)ifstmt.getCondition();
      if (!c.getOp1().equals(pred.getLeftOp()))       break;
      if (!(c.getOp2() instanceof IntConstant))       break;
      if (((IntConstant)c.getOp2()).value != 0)       break;
      if (c instanceof NeExpr) {
        outBranch=(LocalTypeSet)out.clone();
        outBranch.localMustBeSubtypeOf((Local)iofexpr.getOp(),(RefType)iofexpr.getCheckType());
      }
 else       if (c instanceof EqExpr) {
        outBranch=(LocalTypeSet)out.clone();
        out.localMustBeSubtypeOf((Local)iofexpr.getOp(),(RefType)iofexpr.getCheckType());
      }
    }
 while (false);
  }
  for (Iterator it=outFallValues.iterator(); it.hasNext(); ) {
    copy(out,it.next());
  }
  for (Iterator it=outBranchValues.iterator(); it.hasNext(); ) {
    copy(outBranch,it.next());
  }
}"
88657,"/** 
 * Put the results of the analysis into tags in cast statements. 
 */
protected void tagCasts(){
  for (Iterator it=((UnitGraph)graph).getBody().getUnits().iterator(); it.hasNext(); ) {
    Stmt s=(Stmt)it.next();
    if (s instanceof AssignStmt) {
      AssignStmt as=(AssignStmt)s;
      Value rhs=as.getRightOp();
      if (rhs instanceof CastExpr) {
        CastExpr cast=(CastExpr)rhs;
        Type t=cast.getCastType();
        if (t instanceof RefType) {
          Local l=(Local)cast.getOp();
          LocalTypeSet set=(LocalTypeSet)unitToBeforeFlow.get(s);
          s.addTag(new CastCheckTag(set.get(set.indexOf(l,(RefType)t))));
        }
      }
    }
  }
}","/** 
 * Put the results of the analysis into tags in cast statements. 
 */
protected void tagCasts(){
  for (Iterator sIt=((UnitGraph)graph).getBody().getUnits().iterator(); sIt.hasNext(); ) {
    final Stmt s=(Stmt)sIt.next();
    if (s instanceof AssignStmt) {
      AssignStmt as=(AssignStmt)s;
      Value rhs=as.getRightOp();
      if (rhs instanceof CastExpr) {
        CastExpr cast=(CastExpr)rhs;
        Type t=cast.getCastType();
        if (t instanceof RefType) {
          if (cast.getOp() instanceof Local) {
            Local l=(Local)cast.getOp();
            LocalTypeSet set=(LocalTypeSet)unitToBeforeFlow.get(s);
            s.addTag(new CastCheckTag(set.get(set.indexOf(l,(RefType)t))));
          }
 else {
            NullConstant nc=(NullConstant)cast.getOp();
            s.addTag(new CastCheckTag(true));
          }
        }
      }
    }
  }
}"
88658,"private soot.jimple.Constant getReturnConstant(polyglot.ast.Field field){
  if (field.fieldInstance().constantValue() instanceof String) {
    return soot.jimple.StringConstant.v((String)field.constantValue());
  }
 else   if (field.fieldInstance().constantValue() instanceof Boolean) {
    boolean val=((Boolean)field.constantValue()).booleanValue();
    return soot.jimple.IntConstant.v(val ? 1 : 0);
  }
 else   if (field.fieldInstance().constantValue() instanceof Character) {
    char val=((Character)field.constantValue()).charValue();
    return soot.jimple.IntConstant.v(val);
  }
 else {
    Number num=(Number)field.fieldInstance().constantValue();
    if (num instanceof Long) {
      return soot.jimple.LongConstant.v(((Long)num).longValue());
    }
 else     if (num instanceof Double) {
      return soot.jimple.DoubleConstant.v(((Double)num).doubleValue());
    }
 else     if (num instanceof Float) {
      return soot.jimple.FloatConstant.v(((Float)num).floatValue());
    }
 else {
      return soot.jimple.IntConstant.v(((Integer)num).intValue());
    }
  }
}","private soot.jimple.Constant getReturnConstant(polyglot.ast.Field field){
  System.out.println(""String_Node_Str"" + field);
  System.out.println(""String_Node_Str"" + field.type());
  System.out.println(""String_Node_Str"" + field.fieldInstance().constantValue().getClass());
  if (field.fieldInstance().constantValue() instanceof String) {
    return soot.jimple.StringConstant.v((String)field.constantValue());
  }
 else   if (field.fieldInstance().constantValue() instanceof Boolean) {
    boolean val=((Boolean)field.constantValue()).booleanValue();
    return soot.jimple.IntConstant.v(val ? 1 : 0);
  }
 else   if (field.fieldInstance().constantValue() instanceof Character) {
    char val=((Character)field.constantValue()).charValue();
    return soot.jimple.IntConstant.v(val);
  }
 else {
    Number num=(Number)field.fieldInstance().constantValue();
    num=createConstantCast(field.type(),num);
    if (num instanceof Long) {
      return soot.jimple.LongConstant.v(((Long)num).longValue());
    }
 else     if (num instanceof Double) {
      return soot.jimple.DoubleConstant.v(((Double)num).doubleValue());
    }
 else     if (num instanceof Float) {
      return soot.jimple.FloatConstant.v(((Float)num).floatValue());
    }
 else {
      return soot.jimple.IntConstant.v(((Integer)num).intValue());
    }
  }
}"
88659,"/** 
 * Cast Expression Creation
 */
private soot.Local getCastLocal(polyglot.ast.Cast castExpr){
  if (castExpr.expr().type().equals(castExpr.type())) {
    return (soot.Local)createExpr(castExpr.expr());
  }
  soot.Value val;
  if (castExpr.expr() instanceof polyglot.ast.Cast) {
    val=createExpr(((polyglot.ast.Cast)castExpr.expr()).expr());
  }
 else {
    val=createExpr(castExpr.expr());
  }
  soot.Type type=Util.getSootType(castExpr.type());
  soot.jimple.CastExpr cast=soot.jimple.Jimple.v().newCastExpr(val,type);
  Util.addLnPosTags(cast.getOpBox(),castExpr.expr().position());
  soot.Local retLocal=lg.generateLocal(cast.getCastType());
  soot.jimple.Stmt castAssign=soot.jimple.Jimple.v().newAssignStmt(retLocal,cast);
  body.getUnits().add(castAssign);
  Util.addLnPosTags(castAssign,castExpr.position());
  return retLocal;
}","/** 
 * Cast Expression Creation
 */
private soot.Value getCastLocal(polyglot.ast.Cast castExpr){
  if (castExpr.expr().type().equals(castExpr.type())) {
    return createExpr(castExpr.expr());
  }
  soot.Value val;
  if (castExpr.expr() instanceof polyglot.ast.Cast) {
    val=createExpr(((polyglot.ast.Cast)castExpr.expr()).expr());
  }
 else {
    val=createExpr(castExpr.expr());
  }
  soot.Type type=Util.getSootType(castExpr.type());
  soot.jimple.CastExpr cast=soot.jimple.Jimple.v().newCastExpr(val,type);
  Util.addLnPosTags(cast.getOpBox(),castExpr.expr().position());
  soot.Local retLocal=lg.generateLocal(cast.getCastType());
  soot.jimple.Stmt castAssign=soot.jimple.Jimple.v().newAssignStmt(retLocal,cast);
  body.getUnits().add(castAssign);
  Util.addLnPosTags(castAssign,castExpr.position());
  return retLocal;
}"
88660,"private soot.Local handlePrivateFieldSet(polyglot.ast.Assign assign){
  polyglot.ast.Field fLeft=(polyglot.ast.Field)assign.left();
  soot.Local leftLocal=(soot.Local)getFieldLocal(fLeft);
  soot.Value right=getAssignRightLocal(assign,leftLocal);
  soot.SootClass containClass=((soot.RefType)Util.getSootType(fLeft.target().type())).getSootClass();
  soot.SootMethod methToUse=addSetAccessMeth(containClass,fLeft,right);
  ArrayList params=new ArrayList();
  if (!fLeft.flags().isStatic()) {
    params.add(getThis(Util.getSootType(fLeft.target().type())));
  }
  params.add(right);
  soot.jimple.InvokeExpr invoke=soot.jimple.Jimple.v().newStaticInvokeExpr(methToUse,params);
  soot.Local retLocal=lg.generateLocal(right.getType());
  soot.jimple.AssignStmt assignStmt=soot.jimple.Jimple.v().newAssignStmt(retLocal,invoke);
  body.getUnits().add(assignStmt);
  return retLocal;
}","private soot.Local handlePrivateFieldSet(polyglot.ast.Assign assign){
  polyglot.ast.Field fLeft=(polyglot.ast.Field)assign.left();
  soot.Value right;
  if (assign.operator() == polyglot.ast.Assign.ASSIGN) {
    right=getSimpleAssignRightLocal(assign);
  }
 else   if ((assign.operator() == polyglot.ast.Assign.ADD_ASSIGN) && assign.type().toString().equals(""String_Node_Str"")) {
    right=getStringConcatAssignRightLocal(assign);
  }
 else {
    soot.Local leftLocal=(soot.Local)getFieldLocal(fLeft);
    right=getAssignRightLocal(assign,leftLocal);
  }
  soot.SootClass containClass=((soot.RefType)Util.getSootType(fLeft.target().type())).getSootClass();
  soot.SootMethod methToUse=addSetAccessMeth(containClass,fLeft,right);
  ArrayList params=new ArrayList();
  if (!fLeft.flags().isStatic()) {
    params.add(getThis(Util.getSootType(fLeft.target().type())));
  }
  params.add(right);
  soot.jimple.InvokeExpr invoke=soot.jimple.Jimple.v().newStaticInvokeExpr(methToUse,params);
  soot.Local retLocal=lg.generateLocal(right.getType());
  soot.jimple.AssignStmt assignStmt=soot.jimple.Jimple.v().newAssignStmt(retLocal,invoke);
  body.getUnits().add(assignStmt);
  return retLocal;
}"
88661,"/** 
 * Assign Expression Creation
 */
private soot.Local getAssignLocal(polyglot.ast.Assign assign){
  soot.jimple.AssignStmt stmt;
  soot.Value left=createLHS(assign.left());
  soot.Local leftLocal;
  if (left instanceof soot.Local) {
    leftLocal=(soot.Local)left;
  }
 else {
    leftLocal=lg.generateLocal(left.getType());
    stmt=soot.jimple.Jimple.v().newAssignStmt(leftLocal,left);
    body.getUnits().add(stmt);
    Util.addLnPosTags(stmt,assign.position());
  }
  HashMap accessMap=((PolyglotMethodSource)body.getMethod().getSource()).getPrivateAccessMap();
  if ((assign.left() instanceof polyglot.ast.Field) && (accessMap != null) && accessMap.containsKey(((polyglot.ast.Field)assign.left()).fieldInstance())) {
    return handlePrivateFieldSet(assign);
  }
  soot.Value right=getAssignRightLocal(assign,leftLocal);
  stmt=soot.jimple.Jimple.v().newAssignStmt(leftLocal,right);
  body.getUnits().add(stmt);
  Util.addLnPosTags(stmt,assign.position());
  Util.addLnPosTags(stmt.getRightOpBox(),assign.right().position());
  Util.addLnPosTags(stmt.getLeftOpBox(),assign.left().position());
  if (!(left instanceof soot.Local)) {
    stmt=soot.jimple.Jimple.v().newAssignStmt(left,leftLocal);
    body.getUnits().add(stmt);
    Util.addLnPosTags(stmt,assign.position());
    Util.addLnPosTags(stmt.getRightOpBox(),assign.right().position());
    Util.addLnPosTags(stmt.getLeftOpBox(),assign.left().position());
  }
  return leftLocal;
}","/** 
 * Assign Expression Creation
 */
private soot.Value getAssignLocal(polyglot.ast.Assign assign){
  HashMap accessMap=((PolyglotMethodSource)body.getMethod().getSource()).getPrivateAccessMap();
  if ((assign.left() instanceof polyglot.ast.Field) && (accessMap != null) && accessMap.containsKey(((polyglot.ast.Field)assign.left()).fieldInstance())) {
    return handlePrivateFieldSet(assign);
  }
  if (assign.operator() == polyglot.ast.Assign.ASSIGN) {
    return getSimpleAssignLocal(assign);
  }
  if ((assign.operator() == polyglot.ast.Assign.ADD_ASSIGN) && assign.type().toString().equals(""String_Node_Str"")) {
    return getStrConAssignLocal(assign);
  }
  soot.jimple.AssignStmt stmt;
  soot.Value left=createLHS(assign.left());
  soot.Local leftLocal;
  if (left instanceof soot.Local) {
    leftLocal=(soot.Local)left;
  }
 else {
    leftLocal=lg.generateLocal(left.getType());
    stmt=soot.jimple.Jimple.v().newAssignStmt(leftLocal,left);
    body.getUnits().add(stmt);
    Util.addLnPosTags(stmt,assign.position());
  }
  soot.Value right=getAssignRightLocal(assign,leftLocal);
  stmt=soot.jimple.Jimple.v().newAssignStmt(leftLocal,right);
  body.getUnits().add(stmt);
  Util.addLnPosTags(stmt,assign.position());
  Util.addLnPosTags(stmt.getRightOpBox(),assign.right().position());
  Util.addLnPosTags(stmt.getLeftOpBox(),assign.left().position());
  if (!(left instanceof soot.Local)) {
    stmt=soot.jimple.Jimple.v().newAssignStmt(left,leftLocal);
    body.getUnits().add(stmt);
    Util.addLnPosTags(stmt,assign.position());
    Util.addLnPosTags(stmt.getRightOpBox(),assign.right().position());
    Util.addLnPosTags(stmt.getLeftOpBox(),assign.left().position());
  }
  return leftLocal;
}"
88662,"public soot.Body getBody(soot.SootMethod sootMethod,String phaseName){
  soot.Body body=soot.jimple.Jimple.v().newBody(sootMethod);
  LocalGenerator lg=new LocalGenerator(body);
  soot.Local fieldBase=null;
  soot.Local assignLocal=null;
  int paramCounter=0;
  Iterator paramIt=sootMethod.getParameterTypes().iterator();
  while (paramIt.hasNext()) {
    soot.Type sootType=(soot.Type)paramIt.next();
    soot.Local paramLocal=lg.generateLocal(sootType);
    soot.jimple.ParameterRef paramRef=soot.jimple.Jimple.v().newParameterRef(sootType,paramCounter);
    soot.jimple.Stmt stmt=soot.jimple.Jimple.v().newIdentityStmt(paramLocal,paramRef);
    body.getUnits().add(stmt);
    if (paramCounter == 0) {
      fieldBase=paramLocal;
    }
    assignLocal=paramLocal;
    paramCounter++;
  }
  soot.SootField field=sootMethod.getDeclaringClass().getField(fieldName,fieldType);
  soot.jimple.FieldRef fieldRef=null;
  if (field.isStatic()) {
    fieldRef=soot.jimple.Jimple.v().newStaticFieldRef(field);
  }
 else {
    fieldRef=soot.jimple.Jimple.v().newInstanceFieldRef(fieldBase,field);
  }
  System.out.println(""String_Node_Str"" + fieldRef + ""String_Node_Str""+ assignLocal);
  soot.jimple.AssignStmt assign=soot.jimple.Jimple.v().newAssignStmt(fieldRef,assignLocal);
  body.getUnits().add(assign);
  soot.jimple.Stmt retStmt=soot.jimple.Jimple.v().newReturnStmt(assignLocal);
  body.getUnits().add(retStmt);
  return body;
}","public soot.Body getBody(soot.SootMethod sootMethod,String phaseName){
  soot.Body body=soot.jimple.Jimple.v().newBody(sootMethod);
  LocalGenerator lg=new LocalGenerator(body);
  soot.Local fieldBase=null;
  soot.Local assignLocal=null;
  int paramCounter=0;
  Iterator paramIt=sootMethod.getParameterTypes().iterator();
  while (paramIt.hasNext()) {
    soot.Type sootType=(soot.Type)paramIt.next();
    soot.Local paramLocal=lg.generateLocal(sootType);
    soot.jimple.ParameterRef paramRef=soot.jimple.Jimple.v().newParameterRef(sootType,paramCounter);
    soot.jimple.Stmt stmt=soot.jimple.Jimple.v().newIdentityStmt(paramLocal,paramRef);
    body.getUnits().add(stmt);
    if (paramCounter == 0) {
      fieldBase=paramLocal;
    }
    assignLocal=paramLocal;
    paramCounter++;
  }
  soot.SootField field=sootMethod.getDeclaringClass().getField(fieldName,fieldType);
  soot.jimple.FieldRef fieldRef=null;
  if (field.isStatic()) {
    fieldRef=soot.jimple.Jimple.v().newStaticFieldRef(field);
  }
 else {
    fieldRef=soot.jimple.Jimple.v().newInstanceFieldRef(fieldBase,field);
  }
  soot.jimple.AssignStmt assign=soot.jimple.Jimple.v().newAssignStmt(fieldRef,assignLocal);
  body.getUnits().add(assign);
  soot.jimple.Stmt retStmt=soot.jimple.Jimple.v().newReturnStmt(assignLocal);
  body.getUnits().add(retStmt);
  return body;
}"
88663,"private static soot.Local getLocalOfType(soot.Body body,soot.Type type){
  soot.FastHierarchy fh=InitialResolver.v().hierarchy();
  Iterator it=body.getLocals().iterator();
  while (it.hasNext()) {
    soot.Local l=(soot.Local)it.next();
    if (!(l.getType() instanceof soot.PrimType) && fh.canStoreType(l.getType(),type)) {
      return l;
    }
  }
  return null;
}","private static soot.Local getLocalOfType(soot.Body body,soot.Type type){
  soot.FastHierarchy fh=InitialResolver.v().hierarchy();
  Iterator it=body.getLocals().iterator();
  while (it.hasNext()) {
    soot.Local l=(soot.Local)it.next();
    if (l.getType().equals(type)) {
      return l;
    }
  }
  return null;
}"
88664,"public static soot.Local getThis(soot.Type sootType,soot.Body body,HashMap getThisMap,LocalGenerator lg){
  if (InitialResolver.v().hierarchy() == null) {
    InitialResolver.v().hierarchy(new soot.FastHierarchy());
  }
  soot.FastHierarchy fh=InitialResolver.v().hierarchy();
  if (getThisMap.containsKey(sootType)) {
    return (soot.Local)getThisMap.get(sootType);
  }
  soot.Local specialThisLocal=body.getThisLocal();
  if (fh.canStoreType(specialThisLocal.getType(),sootType)) {
    getThisMap.put(sootType,specialThisLocal);
    return specialThisLocal;
  }
  if (bodyHasLocal(body,sootType)) {
    soot.Local l=getLocalOfType(body,sootType);
    getThisMap.put(sootType,l);
    return l;
  }
  soot.SootClass classToInvoke=((soot.RefType)specialThisLocal.getType()).getSootClass();
  soot.SootField outerThisField=classToInvoke.getFieldByName(""String_Node_Str"");
  soot.Local t1=lg.generateLocal(outerThisField.getType());
  soot.jimple.FieldRef fieldRef=soot.jimple.Jimple.v().newInstanceFieldRef(specialThisLocal,outerThisField);
  soot.jimple.AssignStmt fieldAssignStmt=soot.jimple.Jimple.v().newAssignStmt(t1,fieldRef);
  body.getUnits().add(fieldAssignStmt);
  if (fh.canStoreType(t1.getType(),sootType)) {
    getThisMap.put(sootType,t1);
    return t1;
  }
  soot.Local t2=t1;
  return getThisGivenOuter(sootType,getThisMap,body,lg,t2);
}","public static soot.Local getThis(soot.Type sootType,soot.Body body,HashMap getThisMap,LocalGenerator lg){
  if (InitialResolver.v().hierarchy() == null) {
    InitialResolver.v().hierarchy(new soot.FastHierarchy());
  }
  soot.FastHierarchy fh=InitialResolver.v().hierarchy();
  if (getThisMap.containsKey(sootType)) {
    return (soot.Local)getThisMap.get(sootType);
  }
  soot.Local specialThisLocal=body.getThisLocal();
  if (specialThisLocal.getType().equals(sootType)) {
    getThisMap.put(sootType,specialThisLocal);
    return specialThisLocal;
  }
  if (bodyHasLocal(body,sootType)) {
    soot.Local l=getLocalOfType(body,sootType);
    getThisMap.put(sootType,l);
    return l;
  }
  soot.SootClass classToInvoke=((soot.RefType)specialThisLocal.getType()).getSootClass();
  soot.SootField outerThisField=classToInvoke.getFieldByName(""String_Node_Str"");
  soot.Local t1=lg.generateLocal(outerThisField.getType());
  soot.jimple.FieldRef fieldRef=soot.jimple.Jimple.v().newInstanceFieldRef(specialThisLocal,outerThisField);
  soot.jimple.AssignStmt fieldAssignStmt=soot.jimple.Jimple.v().newAssignStmt(t1,fieldRef);
  body.getUnits().add(fieldAssignStmt);
  if (fh.canStoreType(t1.getType(),sootType)) {
    getThisMap.put(sootType,t1);
    return t1;
  }
  soot.Local t2=t1;
  return getThisGivenOuter(sootType,getThisMap,body,lg,t2);
}"
88665,"private static boolean bodyHasLocal(soot.Body body,soot.Type type){
  soot.FastHierarchy fh=InitialResolver.v().hierarchy();
  Iterator it=body.getLocals().iterator();
  while (it.hasNext()) {
    soot.Local l=(soot.Local)it.next();
    System.out.println(""String_Node_Str"" + l.getType() + ""String_Node_Str""+ type);
    if (!(l.getType() instanceof soot.PrimType) && fh.canStoreType(l.getType(),type)) {
      return true;
    }
  }
  return false;
}","private static boolean bodyHasLocal(soot.Body body,soot.Type type){
  soot.FastHierarchy fh=InitialResolver.v().hierarchy();
  Iterator it=body.getLocals().iterator();
  while (it.hasNext()) {
    soot.Local l=(soot.Local)it.next();
    if (l.getType().equals(type)) {
      return true;
    }
  }
  return false;
}"
88666,"/** 
 * handles try/catch (try/catch/finally is separate for simplicity)
 */
private void createTryCatch(polyglot.ast.Try tryStmt){
  polyglot.ast.Block tryBlock=tryStmt.tryBlock();
  soot.jimple.Stmt noop1=soot.jimple.Jimple.v().newNopStmt();
  body.getUnits().add(noop1);
  createBlock(tryBlock);
  soot.jimple.Stmt noop2=soot.jimple.Jimple.v().newNopStmt();
  body.getUnits().add(noop2);
  soot.jimple.Stmt endNoop=soot.jimple.Jimple.v().newNopStmt();
  soot.jimple.Stmt tryEndGoto=soot.jimple.Jimple.v().newGotoStmt(endNoop);
  body.getUnits().add(tryEndGoto);
  Iterator it=tryStmt.catchBlocks().iterator();
  while (it.hasNext()) {
    soot.jimple.Stmt noop3=soot.jimple.Jimple.v().newNopStmt();
    body.getUnits().add(noop3);
    polyglot.ast.Catch catchBlock=(polyglot.ast.Catch)it.next();
    createCatchFormal(catchBlock.formal());
    createBlock(catchBlock.body());
    soot.jimple.Stmt catchEndGoto=soot.jimple.Jimple.v().newGotoStmt(endNoop);
    body.getUnits().add(catchEndGoto);
    soot.Type sootType=Util.getSootType(catchBlock.catchType());
    addToExceptionList(noop1,noop2,noop3,soot.Scene.v().getSootClass(sootType.toString()));
  }
  body.getUnits().add(endNoop);
}","/** 
 * handles try/catch (try/catch/finally is separate for simplicity)
 */
private void createTryCatch(polyglot.ast.Try tryStmt){
  polyglot.ast.Block tryBlock=tryStmt.tryBlock();
  soot.jimple.Stmt noop1=soot.jimple.Jimple.v().newNopStmt();
  body.getUnits().add(noop1);
  if (tryStack == null) {
    tryStack=new Stack();
  }
  tryStack.push(tryStmt);
  createBlock(tryBlock);
  tryStack.pop();
  soot.jimple.Stmt noop2=soot.jimple.Jimple.v().newNopStmt();
  body.getUnits().add(noop2);
  soot.jimple.Stmt endNoop=soot.jimple.Jimple.v().newNopStmt();
  soot.jimple.Stmt tryEndGoto=soot.jimple.Jimple.v().newGotoStmt(endNoop);
  body.getUnits().add(tryEndGoto);
  Iterator it=tryStmt.catchBlocks().iterator();
  while (it.hasNext()) {
    soot.jimple.Stmt noop3=soot.jimple.Jimple.v().newNopStmt();
    body.getUnits().add(noop3);
    polyglot.ast.Catch catchBlock=(polyglot.ast.Catch)it.next();
    createCatchFormal(catchBlock.formal());
    if (catchStack == null) {
      catchStack=new Stack();
    }
    catchStack.push(tryStmt);
    createBlock(catchBlock.body());
    catchStack.pop();
    soot.jimple.Stmt catchEndGoto=soot.jimple.Jimple.v().newGotoStmt(endNoop);
    body.getUnits().add(catchEndGoto);
    soot.Type sootType=Util.getSootType(catchBlock.catchType());
    addToExceptionList(noop1,noop2,noop3,soot.Scene.v().getSootClass(sootType.toString()));
  }
  body.getUnits().add(endNoop);
}"
88667,"/** 
 * Creates a binary expression that is not a comparison
 */
private soot.Value getBinaryExpr(soot.Value lVal,soot.Value rVal,polyglot.ast.Binary.Operator operator){
  soot.Value rValue=null;
  if (lVal instanceof soot.jimple.ConditionExpr) {
    lVal=handleCondBinExpr((soot.jimple.ConditionExpr)lVal);
  }
  if (rVal instanceof soot.jimple.ConditionExpr) {
    rVal=handleCondBinExpr((soot.jimple.ConditionExpr)rVal);
  }
  if (operator == polyglot.ast.Binary.ADD) {
    rValue=soot.jimple.Jimple.v().newAddExpr(lVal,rVal);
  }
 else   if (operator == polyglot.ast.Binary.SUB) {
    rValue=soot.jimple.Jimple.v().newSubExpr(lVal,rVal);
  }
 else   if (operator == polyglot.ast.Binary.MUL) {
    rValue=soot.jimple.Jimple.v().newMulExpr(lVal,rVal);
  }
 else   if (operator == polyglot.ast.Binary.DIV) {
    rValue=soot.jimple.Jimple.v().newDivExpr(lVal,rVal);
  }
 else   if (operator == polyglot.ast.Binary.SHR) {
    if (rVal.getType().equals(soot.LongType.v())) {
      soot.Local intVal=lg.generateLocal(soot.IntType.v());
      soot.jimple.CastExpr castExpr=soot.jimple.Jimple.v().newCastExpr(rVal,soot.IntType.v());
      soot.jimple.AssignStmt assignStmt=soot.jimple.Jimple.v().newAssignStmt(intVal,castExpr);
      body.getUnits().add(assignStmt);
      rValue=soot.jimple.Jimple.v().newUshrExpr(lVal,intVal);
    }
 else {
      rValue=soot.jimple.Jimple.v().newShrExpr(lVal,rVal);
    }
  }
 else   if (operator == polyglot.ast.Binary.USHR) {
    if (rVal.getType().equals(soot.LongType.v())) {
      soot.Local intVal=lg.generateLocal(soot.IntType.v());
      soot.jimple.CastExpr castExpr=soot.jimple.Jimple.v().newCastExpr(rVal,soot.IntType.v());
      soot.jimple.AssignStmt assignStmt=soot.jimple.Jimple.v().newAssignStmt(intVal,castExpr);
      body.getUnits().add(assignStmt);
      rValue=soot.jimple.Jimple.v().newUshrExpr(lVal,intVal);
    }
 else {
      rValue=soot.jimple.Jimple.v().newUshrExpr(lVal,rVal);
    }
  }
 else   if (operator == polyglot.ast.Binary.SHL) {
    if (rVal.getType().equals(soot.LongType.v())) {
      soot.Local intVal=lg.generateLocal(soot.IntType.v());
      soot.jimple.CastExpr castExpr=soot.jimple.Jimple.v().newCastExpr(rVal,soot.IntType.v());
      soot.jimple.AssignStmt assignStmt=soot.jimple.Jimple.v().newAssignStmt(intVal,castExpr);
      body.getUnits().add(assignStmt);
      rValue=soot.jimple.Jimple.v().newUshrExpr(lVal,intVal);
    }
 else {
      rValue=soot.jimple.Jimple.v().newShlExpr(lVal,rVal);
    }
  }
 else   if (operator == polyglot.ast.Binary.BIT_AND) {
    rValue=soot.jimple.Jimple.v().newAndExpr(lVal,rVal);
  }
 else   if (operator == polyglot.ast.Binary.BIT_OR) {
    rValue=soot.jimple.Jimple.v().newOrExpr(lVal,rVal);
  }
 else   if (operator == polyglot.ast.Binary.BIT_XOR) {
    rValue=soot.jimple.Jimple.v().newXorExpr(lVal,rVal);
  }
 else   if (operator == polyglot.ast.Binary.MOD) {
    rValue=soot.jimple.Jimple.v().newRemExpr(lVal,rVal);
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
  return rValue;
}","/** 
 * Creates a binary expression that is not a comparison
 */
private soot.Value getBinaryExpr(soot.Value lVal,soot.Value rVal,polyglot.ast.Binary.Operator operator){
  soot.Value rValue=null;
  if (lVal instanceof soot.jimple.ConditionExpr) {
    lVal=handleCondBinExpr((soot.jimple.ConditionExpr)lVal);
  }
  if (rVal instanceof soot.jimple.ConditionExpr) {
    rVal=handleCondBinExpr((soot.jimple.ConditionExpr)rVal);
  }
  if (operator == polyglot.ast.Binary.ADD) {
    rValue=soot.jimple.Jimple.v().newAddExpr(lVal,rVal);
  }
 else   if (operator == polyglot.ast.Binary.SUB) {
    rValue=soot.jimple.Jimple.v().newSubExpr(lVal,rVal);
  }
 else   if (operator == polyglot.ast.Binary.MUL) {
    rValue=soot.jimple.Jimple.v().newMulExpr(lVal,rVal);
  }
 else   if (operator == polyglot.ast.Binary.DIV) {
    rValue=soot.jimple.Jimple.v().newDivExpr(lVal,rVal);
  }
 else   if (operator == polyglot.ast.Binary.SHR) {
    if (rVal.getType().equals(soot.LongType.v())) {
      soot.Local intVal=lg.generateLocal(soot.IntType.v());
      soot.jimple.CastExpr castExpr=soot.jimple.Jimple.v().newCastExpr(rVal,soot.IntType.v());
      soot.jimple.AssignStmt assignStmt=soot.jimple.Jimple.v().newAssignStmt(intVal,castExpr);
      body.getUnits().add(assignStmt);
      rValue=soot.jimple.Jimple.v().newShrExpr(lVal,intVal);
    }
 else {
      rValue=soot.jimple.Jimple.v().newShrExpr(lVal,rVal);
    }
  }
 else   if (operator == polyglot.ast.Binary.USHR) {
    if (rVal.getType().equals(soot.LongType.v())) {
      soot.Local intVal=lg.generateLocal(soot.IntType.v());
      soot.jimple.CastExpr castExpr=soot.jimple.Jimple.v().newCastExpr(rVal,soot.IntType.v());
      soot.jimple.AssignStmt assignStmt=soot.jimple.Jimple.v().newAssignStmt(intVal,castExpr);
      body.getUnits().add(assignStmt);
      rValue=soot.jimple.Jimple.v().newUshrExpr(lVal,intVal);
    }
 else {
      rValue=soot.jimple.Jimple.v().newUshrExpr(lVal,rVal);
    }
  }
 else   if (operator == polyglot.ast.Binary.SHL) {
    if (rVal.getType().equals(soot.LongType.v())) {
      soot.Local intVal=lg.generateLocal(soot.IntType.v());
      soot.jimple.CastExpr castExpr=soot.jimple.Jimple.v().newCastExpr(rVal,soot.IntType.v());
      soot.jimple.AssignStmt assignStmt=soot.jimple.Jimple.v().newAssignStmt(intVal,castExpr);
      body.getUnits().add(assignStmt);
      rValue=soot.jimple.Jimple.v().newShlExpr(lVal,intVal);
    }
 else {
      rValue=soot.jimple.Jimple.v().newShlExpr(lVal,rVal);
    }
  }
 else   if (operator == polyglot.ast.Binary.BIT_AND) {
    rValue=soot.jimple.Jimple.v().newAndExpr(lVal,rVal);
  }
 else   if (operator == polyglot.ast.Binary.BIT_OR) {
    rValue=soot.jimple.Jimple.v().newOrExpr(lVal,rVal);
  }
 else   if (operator == polyglot.ast.Binary.BIT_XOR) {
    rValue=soot.jimple.Jimple.v().newXorExpr(lVal,rVal);
  }
 else   if (operator == polyglot.ast.Binary.MOD) {
    rValue=soot.jimple.Jimple.v().newRemExpr(lVal,rVal);
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
  return rValue;
}"
88668,"/** 
 * Return Stmts Creation
 */
private void createReturn(polyglot.ast.Return retStmt){
  polyglot.ast.Expr expr=retStmt.expr();
  soot.Value sootLocal=null;
  if (expr != null) {
    sootLocal=createExpr(expr);
  }
  if (monitorStack != null) {
    Stack putBack=new Stack();
    while (!monitorStack.isEmpty()) {
      soot.Local exitVal=(soot.Local)monitorStack.pop();
      putBack.push(exitVal);
      soot.jimple.ExitMonitorStmt emStmt=soot.jimple.Jimple.v().newExitMonitorStmt(exitVal);
      body.getUnits().add(emStmt);
    }
    while (!putBack.isEmpty()) {
      monitorStack.push(putBack.pop());
    }
  }
  if (currentTryStmt != null) {
    createBlock(currentTryStmt.finallyBlock());
  }
  if (expr == null) {
    soot.jimple.Stmt retStmtVoid=soot.jimple.Jimple.v().newReturnVoidStmt();
    body.getUnits().add(retStmtVoid);
    Util.addLnPosTags(retStmtVoid,retStmt.position());
  }
 else {
    if (sootLocal instanceof soot.jimple.ConditionExpr) {
      sootLocal=handleCondBinExpr((soot.jimple.ConditionExpr)sootLocal);
    }
    soot.jimple.ReturnStmt retStmtLocal=soot.jimple.Jimple.v().newReturnStmt(sootLocal);
    body.getUnits().add(retStmtLocal);
    Util.addLnPosTags(retStmtLocal.getOpBox(),expr.position());
    Util.addLnPosTags(retStmtLocal,retStmt.position());
  }
}","/** 
 * Return Stmts Creation
 */
private void createReturn(polyglot.ast.Return retStmt){
  polyglot.ast.Expr expr=retStmt.expr();
  soot.Value sootLocal=null;
  if (expr != null) {
    sootLocal=createExpr(expr);
  }
  if (monitorStack != null) {
    Stack putBack=new Stack();
    while (!monitorStack.isEmpty()) {
      soot.Local exitVal=(soot.Local)monitorStack.pop();
      putBack.push(exitVal);
      soot.jimple.ExitMonitorStmt emStmt=soot.jimple.Jimple.v().newExitMonitorStmt(exitVal);
      body.getUnits().add(emStmt);
    }
    while (!putBack.isEmpty()) {
      monitorStack.push(putBack.pop());
    }
  }
  if (tryStack != null && !tryStack.isEmpty()) {
    polyglot.ast.Try currentTry=(polyglot.ast.Try)tryStack.pop();
    createBlock(currentTry.finallyBlock());
    tryStack.push(currentTry);
    ReturnStmtChecker rsc=new ReturnStmtChecker();
    currentTry.finallyBlock().visit(rsc);
    if (rsc.hasRet()) {
      return;
    }
  }
  if (catchStack != null && !catchStack.isEmpty()) {
    polyglot.ast.Try currentTry=(polyglot.ast.Try)catchStack.pop();
    createBlock(currentTry.finallyBlock());
    catchStack.push(currentTry);
    ReturnStmtChecker rsc=new ReturnStmtChecker();
    currentTry.finallyBlock().visit(rsc);
    if (rsc.hasRet()) {
      return;
    }
  }
  if (expr == null) {
    soot.jimple.Stmt retStmtVoid=soot.jimple.Jimple.v().newReturnVoidStmt();
    body.getUnits().add(retStmtVoid);
    Util.addLnPosTags(retStmtVoid,retStmt.position());
  }
 else {
    if (sootLocal instanceof soot.jimple.ConditionExpr) {
      sootLocal=handleCondBinExpr((soot.jimple.ConditionExpr)sootLocal);
    }
    soot.jimple.ReturnStmt retStmtLocal=soot.jimple.Jimple.v().newReturnStmt(sootLocal);
    body.getUnits().add(retStmtLocal);
    Util.addLnPosTags(retStmtLocal.getOpBox(),expr.position());
    Util.addLnPosTags(retStmtLocal,retStmt.position());
  }
}"
88669,"/** 
 * handles try/catch/finally (try/catch is separate for simplicity)
 */
private void createTryCatchFinally(polyglot.ast.Try tryStmt){
  HashMap gotoMap=new HashMap();
  polyglot.ast.Block tryBlock=tryStmt.tryBlock();
  soot.jimple.Stmt noop1=soot.jimple.Jimple.v().newNopStmt();
  body.getUnits().add(noop1);
  currentTryStmt=tryStmt;
  createBlock(tryBlock);
  currentTryStmt=null;
  soot.jimple.Stmt noop2=soot.jimple.Jimple.v().newNopStmt();
  body.getUnits().add(noop2);
  soot.jimple.Stmt endNoop=soot.jimple.Jimple.v().newNopStmt();
  soot.jimple.Stmt tryGotoFinallyNoop=soot.jimple.Jimple.v().newNopStmt();
  body.getUnits().add(tryGotoFinallyNoop);
  soot.jimple.Stmt tryFinallyNoop=soot.jimple.Jimple.v().newNopStmt();
  soot.jimple.Stmt tryGotoFinally=soot.jimple.Jimple.v().newGotoStmt(tryFinallyNoop);
  body.getUnits().add(tryGotoFinally);
  soot.jimple.Stmt beforeEndGotoNoop=soot.jimple.Jimple.v().newNopStmt();
  body.getUnits().add(beforeEndGotoNoop);
  soot.jimple.Stmt tryEndGoto=soot.jimple.Jimple.v().newGotoStmt(endNoop);
  body.getUnits().add(tryEndGoto);
  gotoMap.put(tryFinallyNoop,beforeEndGotoNoop);
  soot.jimple.Stmt catchAllBeforeNoop=soot.jimple.Jimple.v().newNopStmt();
  Iterator it=tryStmt.catchBlocks().iterator();
  while (it.hasNext()) {
    soot.jimple.Stmt noop3=soot.jimple.Jimple.v().newNopStmt();
    body.getUnits().add(noop3);
    polyglot.ast.Catch catchBlock=(polyglot.ast.Catch)it.next();
    soot.jimple.Stmt catchRefNoop=soot.jimple.Jimple.v().newNopStmt();
    body.getUnits().add(catchRefNoop);
    createCatchFormal(catchBlock.formal());
    soot.jimple.Stmt catchStmtsNoop=soot.jimple.Jimple.v().newNopStmt();
    body.getUnits().add(catchStmtsNoop);
    createBlock(catchBlock.body());
    soot.jimple.Stmt catchGotoFinallyNoop=soot.jimple.Jimple.v().newNopStmt();
    body.getUnits().add(catchGotoFinallyNoop);
    soot.jimple.Stmt catchFinallyNoop=soot.jimple.Jimple.v().newNopStmt();
    soot.jimple.Stmt catchGotoFinally=soot.jimple.Jimple.v().newGotoStmt(catchFinallyNoop);
    body.getUnits().add(catchGotoFinally);
    soot.jimple.Stmt beforeCatchEndGotoNoop=soot.jimple.Jimple.v().newNopStmt();
    body.getUnits().add(beforeCatchEndGotoNoop);
    soot.jimple.Stmt catchEndGoto=soot.jimple.Jimple.v().newGotoStmt(endNoop);
    body.getUnits().add(catchEndGoto);
    gotoMap.put(catchFinallyNoop,beforeCatchEndGotoNoop);
    soot.Type sootType=Util.getSootType(catchBlock.catchType());
    addToExceptionList(noop1,noop2,noop3,soot.Scene.v().getSootClass(sootType.toString()));
    addToExceptionList(catchStmtsNoop,beforeCatchEndGotoNoop,catchAllBeforeNoop,soot.Scene.v().getSootClass(""String_Node_Str""));
  }
  soot.Local formalLocal=lg.generateLocal(soot.RefType.v(""String_Node_Str""));
  body.getUnits().add(catchAllBeforeNoop);
  soot.jimple.CaughtExceptionRef exceptRef=soot.jimple.Jimple.v().newCaughtExceptionRef();
  soot.jimple.Stmt stmt=soot.jimple.Jimple.v().newIdentityStmt(formalLocal,exceptRef);
  body.getUnits().add(stmt);
  soot.jimple.Stmt beforeCatchAllAssignNoop=soot.jimple.Jimple.v().newNopStmt();
  body.getUnits().add(beforeCatchAllAssignNoop);
  soot.Local catchAllAssignLocal=lg.generateLocal(soot.RefType.v(""String_Node_Str""));
  soot.jimple.Stmt catchAllAssign=soot.jimple.Jimple.v().newAssignStmt(catchAllAssignLocal,formalLocal);
  body.getUnits().add(catchAllAssign);
  soot.jimple.Stmt catchAllFinallyNoop=soot.jimple.Jimple.v().newNopStmt();
  soot.jimple.Stmt catchAllGotoFinally=soot.jimple.Jimple.v().newGotoStmt(catchAllFinallyNoop);
  body.getUnits().add(catchAllGotoFinally);
  soot.jimple.Stmt catchAllBeforeThrowNoop=soot.jimple.Jimple.v().newNopStmt();
  body.getUnits().add(catchAllBeforeThrowNoop);
  soot.jimple.Stmt throwStmt=soot.jimple.Jimple.v().newThrowStmt(catchAllAssignLocal);
  throwStmt.addTag(new soot.tagkit.ThrowCreatedByCompilerTag());
  body.getUnits().add(throwStmt);
  gotoMap.put(catchAllFinallyNoop,catchAllBeforeThrowNoop);
  soot.jimple.Stmt catchAllGotoEnd=soot.jimple.Jimple.v().newGotoStmt(endNoop);
  body.getUnits().add(catchAllGotoEnd);
  addToExceptionList(beforeCatchAllAssignNoop,catchAllBeforeThrowNoop,catchAllBeforeNoop,soot.Scene.v().getSootClass(""String_Node_Str""));
  Iterator finallyIt=gotoMap.keySet().iterator();
  while (finallyIt.hasNext()) {
    soot.jimple.Stmt noopStmt=(soot.jimple.Stmt)finallyIt.next();
    body.getUnits().add(noopStmt);
    createBlock(tryStmt.finallyBlock());
    soot.jimple.Stmt backToStmt=(soot.jimple.Stmt)gotoMap.get(noopStmt);
    soot.jimple.Stmt backToGoto=soot.jimple.Jimple.v().newGotoStmt(backToStmt);
    body.getUnits().add(backToGoto);
  }
  body.getUnits().add(endNoop);
  addToExceptionList(noop1,beforeEndGotoNoop,catchAllBeforeNoop,soot.Scene.v().getSootClass(""String_Node_Str""));
}","/** 
 * handles try/catch/finally (try/catch is separate for simplicity)
 */
private void createTryCatchFinally(polyglot.ast.Try tryStmt){
  HashMap gotoMap=new HashMap();
  polyglot.ast.Block tryBlock=tryStmt.tryBlock();
  soot.jimple.Stmt noop1=soot.jimple.Jimple.v().newNopStmt();
  body.getUnits().add(noop1);
  if (tryStack == null) {
    tryStack=new Stack();
  }
  tryStack.push(tryStmt);
  createBlock(tryBlock);
  tryStack.pop();
  soot.jimple.Stmt noop2=soot.jimple.Jimple.v().newNopStmt();
  body.getUnits().add(noop2);
  soot.jimple.Stmt endNoop=soot.jimple.Jimple.v().newNopStmt();
  soot.jimple.Stmt tryGotoFinallyNoop=soot.jimple.Jimple.v().newNopStmt();
  body.getUnits().add(tryGotoFinallyNoop);
  soot.jimple.Stmt tryFinallyNoop=soot.jimple.Jimple.v().newNopStmt();
  soot.jimple.Stmt tryGotoFinally=soot.jimple.Jimple.v().newGotoStmt(tryFinallyNoop);
  body.getUnits().add(tryGotoFinally);
  soot.jimple.Stmt beforeEndGotoNoop=soot.jimple.Jimple.v().newNopStmt();
  body.getUnits().add(beforeEndGotoNoop);
  soot.jimple.Stmt tryEndGoto=soot.jimple.Jimple.v().newGotoStmt(endNoop);
  body.getUnits().add(tryEndGoto);
  gotoMap.put(tryFinallyNoop,beforeEndGotoNoop);
  soot.jimple.Stmt catchAllBeforeNoop=soot.jimple.Jimple.v().newNopStmt();
  Iterator it=tryStmt.catchBlocks().iterator();
  while (it.hasNext()) {
    soot.jimple.Stmt noop3=soot.jimple.Jimple.v().newNopStmt();
    body.getUnits().add(noop3);
    polyglot.ast.Catch catchBlock=(polyglot.ast.Catch)it.next();
    soot.jimple.Stmt catchRefNoop=soot.jimple.Jimple.v().newNopStmt();
    body.getUnits().add(catchRefNoop);
    createCatchFormal(catchBlock.formal());
    soot.jimple.Stmt catchStmtsNoop=soot.jimple.Jimple.v().newNopStmt();
    body.getUnits().add(catchStmtsNoop);
    if (catchStack == null) {
      catchStack=new Stack();
    }
    catchStack.push(tryStmt);
    createBlock(catchBlock.body());
    catchStack.pop();
    soot.jimple.Stmt catchGotoFinallyNoop=soot.jimple.Jimple.v().newNopStmt();
    body.getUnits().add(catchGotoFinallyNoop);
    soot.jimple.Stmt catchFinallyNoop=soot.jimple.Jimple.v().newNopStmt();
    soot.jimple.Stmt catchGotoFinally=soot.jimple.Jimple.v().newGotoStmt(catchFinallyNoop);
    body.getUnits().add(catchGotoFinally);
    soot.jimple.Stmt beforeCatchEndGotoNoop=soot.jimple.Jimple.v().newNopStmt();
    body.getUnits().add(beforeCatchEndGotoNoop);
    soot.jimple.Stmt catchEndGoto=soot.jimple.Jimple.v().newGotoStmt(endNoop);
    body.getUnits().add(catchEndGoto);
    gotoMap.put(catchFinallyNoop,beforeCatchEndGotoNoop);
    soot.Type sootType=Util.getSootType(catchBlock.catchType());
    addToExceptionList(noop1,noop2,noop3,soot.Scene.v().getSootClass(sootType.toString()));
    addToExceptionList(catchStmtsNoop,beforeCatchEndGotoNoop,catchAllBeforeNoop,soot.Scene.v().getSootClass(""String_Node_Str""));
  }
  soot.Local formalLocal=lg.generateLocal(soot.RefType.v(""String_Node_Str""));
  body.getUnits().add(catchAllBeforeNoop);
  soot.jimple.CaughtExceptionRef exceptRef=soot.jimple.Jimple.v().newCaughtExceptionRef();
  soot.jimple.Stmt stmt=soot.jimple.Jimple.v().newIdentityStmt(formalLocal,exceptRef);
  body.getUnits().add(stmt);
  soot.jimple.Stmt beforeCatchAllAssignNoop=soot.jimple.Jimple.v().newNopStmt();
  body.getUnits().add(beforeCatchAllAssignNoop);
  soot.Local catchAllAssignLocal=lg.generateLocal(soot.RefType.v(""String_Node_Str""));
  soot.jimple.Stmt catchAllAssign=soot.jimple.Jimple.v().newAssignStmt(catchAllAssignLocal,formalLocal);
  body.getUnits().add(catchAllAssign);
  soot.jimple.Stmt catchAllFinallyNoop=soot.jimple.Jimple.v().newNopStmt();
  soot.jimple.Stmt catchAllGotoFinally=soot.jimple.Jimple.v().newGotoStmt(catchAllFinallyNoop);
  body.getUnits().add(catchAllGotoFinally);
  soot.jimple.Stmt catchAllBeforeThrowNoop=soot.jimple.Jimple.v().newNopStmt();
  body.getUnits().add(catchAllBeforeThrowNoop);
  soot.jimple.Stmt throwStmt=soot.jimple.Jimple.v().newThrowStmt(catchAllAssignLocal);
  throwStmt.addTag(new soot.tagkit.ThrowCreatedByCompilerTag());
  body.getUnits().add(throwStmt);
  gotoMap.put(catchAllFinallyNoop,catchAllBeforeThrowNoop);
  soot.jimple.Stmt catchAllGotoEnd=soot.jimple.Jimple.v().newGotoStmt(endNoop);
  body.getUnits().add(catchAllGotoEnd);
  addToExceptionList(beforeCatchAllAssignNoop,catchAllBeforeThrowNoop,catchAllBeforeNoop,soot.Scene.v().getSootClass(""String_Node_Str""));
  Iterator finallyIt=gotoMap.keySet().iterator();
  while (finallyIt.hasNext()) {
    soot.jimple.Stmt noopStmt=(soot.jimple.Stmt)finallyIt.next();
    body.getUnits().add(noopStmt);
    createBlock(tryStmt.finallyBlock());
    soot.jimple.Stmt backToStmt=(soot.jimple.Stmt)gotoMap.get(noopStmt);
    soot.jimple.Stmt backToGoto=soot.jimple.Jimple.v().newGotoStmt(backToStmt);
    body.getUnits().add(backToGoto);
  }
  body.getUnits().add(endNoop);
  addToExceptionList(noop1,beforeEndGotoNoop,catchAllBeforeNoop,soot.Scene.v().getSootClass(""String_Node_Str""));
}"
88670,"private soot.Local createLocal(String name,soot.Type sootType){
  if (sootType instanceof soot.CharType) {
    sootType=soot.IntType.v();
  }
  soot.Local sootLocal=soot.jimple.Jimple.v().newLocal(name,sootType);
  body.getLocals().add(sootLocal);
  return sootLocal;
}","private soot.Local createLocal(String name,soot.Type sootType){
  soot.Local sootLocal=soot.jimple.Jimple.v().newLocal(name,sootType);
  body.getLocals().add(sootLocal);
  return sootLocal;
}"
88671,"/** 
 * generates a new soot local given the type
 */
public soot.Local generateLocal(soot.Type type){
  String name=""String_Node_Str"";
  if (type instanceof soot.IntType) {
    while (true) {
      name=nextIntName();
      if (!bodyContainsLocal(name))       break;
    }
  }
 else   if (type instanceof soot.ByteType) {
    while (true) {
      name=nextByteName();
      if (!bodyContainsLocal(name))       break;
    }
  }
 else   if (type instanceof soot.ShortType) {
    while (true) {
      name=nextShortName();
      if (!bodyContainsLocal(name))       break;
    }
  }
 else   if (type instanceof soot.BooleanType) {
    while (true) {
      name=nextBooleanName();
      if (!bodyContainsLocal(name))       break;
    }
  }
 else   if (type instanceof soot.VoidType) {
    while (true) {
      name=nextVoidName();
      if (!bodyContainsLocal(name))       break;
    }
  }
 else   if (type instanceof soot.CharType) {
    while (true) {
      name=nextIntName();
      if (!bodyContainsLocal(name))       break;
    }
    type=soot.CharType.v();
  }
 else   if (type instanceof soot.DoubleType) {
    while (true) {
      name=nextDoubleName();
      if (!bodyContainsLocal(name))       break;
    }
  }
 else   if (type instanceof soot.FloatType) {
    while (true) {
      name=nextFloatName();
      if (!bodyContainsLocal(name))       break;
    }
  }
 else   if (type instanceof soot.LongType) {
    while (true) {
      name=nextLongName();
      if (!bodyContainsLocal(name))       break;
    }
  }
 else   if (type instanceof soot.RefLikeType) {
    while (true) {
      name=nextRefLikeTypeName();
      if (!bodyContainsLocal(name))       break;
    }
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
  return createLocal(name,type);
}","/** 
 * generates a new soot local given the type
 */
public soot.Local generateLocal(soot.Type type){
  String name=""String_Node_Str"";
  if (type instanceof soot.IntType) {
    while (true) {
      name=nextIntName();
      if (!bodyContainsLocal(name))       break;
    }
  }
 else   if (type instanceof soot.ByteType) {
    while (true) {
      name=nextByteName();
      if (!bodyContainsLocal(name))       break;
    }
  }
 else   if (type instanceof soot.ShortType) {
    while (true) {
      name=nextShortName();
      if (!bodyContainsLocal(name))       break;
    }
  }
 else   if (type instanceof soot.BooleanType) {
    while (true) {
      name=nextBooleanName();
      if (!bodyContainsLocal(name))       break;
    }
  }
 else   if (type instanceof soot.VoidType) {
    while (true) {
      name=nextVoidName();
      if (!bodyContainsLocal(name))       break;
    }
  }
 else   if (type instanceof soot.CharType) {
    while (true) {
      name=nextCharName();
      if (!bodyContainsLocal(name))       break;
    }
    type=soot.CharType.v();
  }
 else   if (type instanceof soot.DoubleType) {
    while (true) {
      name=nextDoubleName();
      if (!bodyContainsLocal(name))       break;
    }
  }
 else   if (type instanceof soot.FloatType) {
    while (true) {
      name=nextFloatName();
      if (!bodyContainsLocal(name))       break;
    }
  }
 else   if (type instanceof soot.LongType) {
    while (true) {
      name=nextLongName();
      if (!bodyContainsLocal(name))       break;
    }
  }
 else   if (type instanceof soot.RefLikeType) {
    while (true) {
      name=nextRefLikeTypeName();
      if (!bodyContainsLocal(name))       break;
    }
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
  return createLocal(name,type);
}"
88672,"/** 
 * Class Body Creation
 */
private void createClassBody(polyglot.ast.ClassBody classBody){
  staticFieldInits=null;
  fieldInits=null;
  initializerBlocks=null;
  staticInitializerBlocks=null;
  Iterator it=classBody.members().iterator();
  while (it.hasNext()) {
    Object next=it.next();
    if (next instanceof polyglot.ast.MethodDecl) {
      createMethodDecl((polyglot.ast.MethodDecl)next);
    }
 else     if (next instanceof polyglot.ast.FieldDecl) {
      createFieldDecl((polyglot.ast.FieldDecl)next);
    }
 else     if (next instanceof polyglot.ast.ConstructorDecl) {
      createConstructorDecl((polyglot.ast.ConstructorDecl)next);
    }
 else     if (next instanceof polyglot.ast.ClassDecl) {
    }
 else     if (next instanceof polyglot.ast.Initializer) {
      createInitializer((polyglot.ast.Initializer)next);
    }
 else {
      throw new RuntimeException(""String_Node_Str"");
    }
  }
  handlePrivateAccessors(classBody);
}","/** 
 * Class Body Creation
 */
private void createClassBody(polyglot.ast.ClassBody classBody){
  staticFieldInits=null;
  fieldInits=null;
  initializerBlocks=null;
  staticInitializerBlocks=null;
  handleClassLiteral(classBody);
  handleAssert(classBody);
  Iterator it=classBody.members().iterator();
  while (it.hasNext()) {
    Object next=it.next();
    if (next instanceof polyglot.ast.MethodDecl) {
      createMethodDecl((polyglot.ast.MethodDecl)next);
    }
 else     if (next instanceof polyglot.ast.FieldDecl) {
      createFieldDecl((polyglot.ast.FieldDecl)next);
    }
 else     if (next instanceof polyglot.ast.ConstructorDecl) {
      createConstructorDecl((polyglot.ast.ConstructorDecl)next);
    }
 else     if (next instanceof polyglot.ast.ClassDecl) {
    }
 else     if (next instanceof polyglot.ast.Initializer) {
      createInitializer((polyglot.ast.Initializer)next);
    }
 else {
      throw new RuntimeException(""String_Node_Str"");
    }
  }
  handlePrivateAccessors(classBody);
}"
88673,"public void resolveFromJavaFile(soot.SootClass sc){
  sootClass=sc;
  resolveTypes();
  makeASTMap();
  ClassLiteralChecker classLitChecker=new ClassLiteralChecker();
  astNode.visit(classLitChecker);
  ArrayList classLitList=classLitChecker.getList();
  if (!classLitList.isEmpty()) {
    String methodName=""String_Node_Str"";
    soot.Type methodRetType=soot.RefType.v(""String_Node_Str"");
    ArrayList paramTypes=new ArrayList();
    paramTypes.add(soot.RefType.v(""String_Node_Str""));
    if (!sc.declaresMethod(methodName,paramTypes,methodRetType)) {
      soot.SootMethod sootMethod=new soot.SootMethod(methodName,paramTypes,methodRetType,soot.Modifier.STATIC);
      ClassLiteralMethodSource mSrc=new ClassLiteralMethodSource();
      sootMethod.setSource(mSrc);
      sc.addMethod(sootMethod);
    }
  }
  Iterator classLitIt=classLitList.iterator();
  while (classLitIt.hasNext()) {
    polyglot.ast.ClassLit classLit=(polyglot.ast.ClassLit)classLitIt.next();
    String fieldName=""String_Node_Str"";
    String type=Util.getSootType(classLit.typeNode().type()).toString();
    type=soot.util.StringTools.replaceAll(type,""String_Node_Str"",""String_Node_Str"");
    fieldName=fieldName + type;
    soot.Type fieldType=soot.RefType.v(""String_Node_Str"");
    if (!sc.declaresField(fieldName,fieldType)) {
      soot.SootField sootField=new soot.SootField(fieldName,fieldType,soot.Modifier.STATIC);
      sc.addField(sootField);
    }
  }
  AssertStmtChecker asc=new AssertStmtChecker();
  astNode.visit(asc);
  if (asc.isHasAssert()) {
    handleAssert();
  }
  if (astNode instanceof polyglot.ast.SourceFile) {
    createClassToSourceMap((polyglot.ast.SourceFile)astNode);
    createSource((polyglot.ast.SourceFile)astNode);
  }
  addSourceFileTag(sc);
}","public void resolveFromJavaFile(soot.SootClass sc){
  sootClass=sc;
  resolveTypes();
  makeASTMap();
  if (astNode instanceof polyglot.ast.SourceFile) {
    createClassToSourceMap((polyglot.ast.SourceFile)astNode);
    createSource((polyglot.ast.SourceFile)astNode);
  }
  addSourceFileTag(sc);
}"
88674,"/** 
 * Handling for assert stmts - extra fields and methods are needed in the Jimple 
 */
private void handleAssert(){
  if (!sootClass.declaresField(""String_Node_Str"",soot.BooleanType.v())) {
    sootClass.addField(new soot.SootField(""String_Node_Str"",soot.BooleanType.v(),soot.Modifier.STATIC | soot.Modifier.FINAL));
  }
  if (!sootClass.declaresField(""String_Node_Str"" + sootClass.getName(),soot.RefType.v(""String_Node_Str""))) {
    sootClass.addField(new soot.SootField(""String_Node_Str"" + sootClass.getName(),soot.RefType.v(""String_Node_Str""),soot.Modifier.STATIC));
  }
  String methodName=""String_Node_Str"";
  soot.Type methodRetType=soot.RefType.v(""String_Node_Str"");
  ArrayList paramTypes=new ArrayList();
  paramTypes.add(soot.RefType.v(""String_Node_Str""));
  if (!sootClass.declaresMethod(methodName,paramTypes,methodRetType)) {
    soot.SootMethod sootMethod=new soot.SootMethod(methodName,paramTypes,methodRetType,soot.Modifier.STATIC);
    AssertClassMethodSource mSrc=new AssertClassMethodSource();
    sootMethod.setSource(mSrc);
    sootClass.addMethod(sootMethod);
  }
  methodName=""String_Node_Str"";
  methodRetType=soot.VoidType.v();
  paramTypes=new ArrayList();
  if (!sootClass.declaresMethod(methodName,paramTypes,methodRetType)) {
    soot.SootMethod sootMethod=new soot.SootMethod(methodName,paramTypes,methodRetType,soot.Modifier.STATIC);
    PolyglotMethodSource mSrc=new PolyglotMethodSource();
    mSrc.hasAssert(true);
    sootMethod.setSource(mSrc);
    sootClass.addMethod(sootMethod);
  }
 else {
    ((soot.javaToJimple.PolyglotMethodSource)sootClass.getMethod(methodName,paramTypes,methodRetType).getSource()).hasAssert(true);
  }
}","/** 
 * Handling for assert stmts - extra fields and methods are needed in the Jimple 
 */
private void handleAssert(polyglot.ast.ClassBody cBody){
  AssertStmtChecker asc=new AssertStmtChecker();
  cBody.visit(asc);
  if (!asc.isHasAssert())   return;
  if (!sootClass.declaresField(""String_Node_Str"",soot.BooleanType.v())) {
    sootClass.addField(new soot.SootField(""String_Node_Str"",soot.BooleanType.v(),soot.Modifier.STATIC | soot.Modifier.FINAL));
  }
  if (!sootClass.declaresField(""String_Node_Str"" + sootClass.getName(),soot.RefType.v(""String_Node_Str""))) {
    sootClass.addField(new soot.SootField(""String_Node_Str"" + sootClass.getName(),soot.RefType.v(""String_Node_Str""),soot.Modifier.STATIC));
  }
  String methodName=""String_Node_Str"";
  soot.Type methodRetType=soot.RefType.v(""String_Node_Str"");
  ArrayList paramTypes=new ArrayList();
  paramTypes.add(soot.RefType.v(""String_Node_Str""));
  if (!sootClass.declaresMethod(methodName,paramTypes,methodRetType)) {
    soot.SootMethod sootMethod=new soot.SootMethod(methodName,paramTypes,methodRetType,soot.Modifier.STATIC);
    AssertClassMethodSource mSrc=new AssertClassMethodSource();
    sootMethod.setSource(mSrc);
    sootClass.addMethod(sootMethod);
  }
  methodName=""String_Node_Str"";
  methodRetType=soot.VoidType.v();
  paramTypes=new ArrayList();
  if (!sootClass.declaresMethod(methodName,paramTypes,methodRetType)) {
    soot.SootMethod sootMethod=new soot.SootMethod(methodName,paramTypes,methodRetType,soot.Modifier.STATIC);
    PolyglotMethodSource mSrc=new PolyglotMethodSource();
    mSrc.hasAssert(true);
    sootMethod.setSource(mSrc);
    sootClass.addMethod(sootMethod);
  }
 else {
    ((soot.javaToJimple.PolyglotMethodSource)sootClass.getMethod(methodName,paramTypes,methodRetType).getSource()).hasAssert(true);
  }
}"
88675,"public void update(){
  out.add(new jedd.internal.RelationContainer(new jedd.Attribute[]{srcc.v(),srcm.v(),stmt.v(),tgtc.v(),kind.v(),tgtm.v()},new jedd.PhysicalDomain[]{V1.v(),T1.v(),ST.v(),V2.v(),FD.v(),T2.v()},(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""),jedd.internal.Jedd.v().copy(jedd.internal.Jedd.v().replace(jedd.internal.Jedd.v().project(in.get(),new jedd.PhysicalDomain[]{H1.v(),V1.v()}),new jedd.PhysicalDomain[]{V2.v()},new jedd.PhysicalDomain[]{V1.v()}),new jedd.PhysicalDomain[]{ST.v()},new jedd.PhysicalDomain[]{V2.v()})));
}","public void update(){
  out.add(new jedd.internal.RelationContainer(new jedd.Attribute[]{srcc.v(),srcm.v(),stmt.v(),tgtc.v(),kind.v(),tgtm.v()},new jedd.PhysicalDomain[]{V1.v(),T1.v(),ST.v(),V2.v(),FD.v(),T2.v()},(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""),jedd.internal.Jedd.v().copy(jedd.internal.Jedd.v().replace(jedd.internal.Jedd.v().project(in.get(),new jedd.PhysicalDomain[]{V1.v(),H1.v()}),new jedd.PhysicalDomain[]{V2.v()},new jedd.PhysicalDomain[]{V1.v()}),new jedd.PhysicalDomain[]{ST.v()},new jedd.PhysicalDomain[]{V2.v()})));
}"
88676,"public int size(){
  return (int)new jedd.internal.RelationContainer(new jedd.Attribute[]{kind.v(),stmt.v(),srcm.v(),tgtm.v(),srcc.v(),tgtc.v()},new jedd.PhysicalDomain[]{FD.v(),ST.v(),T1.v(),T2.v(),V1.v(),V2.v()},(""String_Node_Str"" + ""String_Node_Str""),edges).size();
}","public int size(){
  return (int)new jedd.internal.RelationContainer(new jedd.Attribute[]{stmt.v(),srcm.v(),tgtc.v(),srcc.v(),tgtm.v(),kind.v()},new jedd.PhysicalDomain[]{ST.v(),T1.v(),V2.v(),V1.v(),T2.v(),FD.v()},(""String_Node_Str"" + ""String_Node_Str""),edges).size();
}"
88677,"public Rsrcc_srcm_stmt_kind_tgtc_tgtm edges(){
  return new Rsrcc_srcm_stmt_kind_tgtc_tgtmBDD(new jedd.internal.RelationContainer(new jedd.Attribute[]{kind.v(),stmt.v(),srcm.v(),tgtm.v(),srcc.v(),tgtc.v()},new jedd.PhysicalDomain[]{FD.v(),ST.v(),T1.v(),T2.v(),V1.v(),V2.v()},(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""),edges),""String_Node_Str"");
}","public Rsrcc_srcm_stmt_kind_tgtc_tgtm edges(){
  return new Rsrcc_srcm_stmt_kind_tgtc_tgtmBDD(new jedd.internal.RelationContainer(new jedd.Attribute[]{stmt.v(),srcm.v(),tgtc.v(),srcc.v(),tgtm.v(),kind.v()},new jedd.PhysicalDomain[]{ST.v(),T1.v(),V2.v(),V1.v(),T2.v(),FD.v()},(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""),edges),""String_Node_Str"");
}"
88678,"public boolean update(){
  final jedd.internal.RelationContainer newEdges=new jedd.internal.RelationContainer(new jedd.Attribute[]{srcc.v(),srcm.v(),stmt.v(),kind.v(),tgtc.v(),tgtm.v()},new jedd.PhysicalDomain[]{V1.v(),T1.v(),ST.v(),FD.v(),V2.v(),T2.v()},(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""),in.get());
  newEdges.eqMinus(edges);
  edges.eqUnion(newEdges);
  out.add(new jedd.internal.RelationContainer(new jedd.Attribute[]{kind.v(),stmt.v(),srcm.v(),tgtm.v(),srcc.v(),tgtc.v()},new jedd.PhysicalDomain[]{FD.v(),ST.v(),T1.v(),T2.v(),V1.v(),V2.v()},(""String_Node_Str"" + ""String_Node_Str""),newEdges));
  return !jedd.internal.Jedd.v().equals(jedd.internal.Jedd.v().read(newEdges),jedd.internal.Jedd.v().falseBDD());
}","public boolean update(){
  final jedd.internal.RelationContainer newEdges=new jedd.internal.RelationContainer(new jedd.Attribute[]{srcc.v(),srcm.v(),stmt.v(),kind.v(),tgtc.v(),tgtm.v()},new jedd.PhysicalDomain[]{V1.v(),T1.v(),ST.v(),FD.v(),V2.v(),T2.v()},(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""),in.get());
  newEdges.eqMinus(edges);
  edges.eqUnion(newEdges);
  out.add(new jedd.internal.RelationContainer(new jedd.Attribute[]{stmt.v(),srcm.v(),tgtc.v(),srcc.v(),tgtm.v(),kind.v()},new jedd.PhysicalDomain[]{ST.v(),T1.v(),V2.v(),V1.v(),T2.v(),FD.v()},(""String_Node_Str"" + ""String_Node_Str""),newEdges));
  return !jedd.internal.Jedd.v().equals(jedd.internal.Jedd.v().read(newEdges),jedd.internal.Jedd.v().falseBDD());
}"
88679,"public Rsrcc_srcm_stmt_kind_tgtc_tgtm edgesOutOf(MethodOrMethodContext m){
  return new Rsrcc_srcm_stmt_kind_tgtc_tgtmBDD(new jedd.internal.RelationContainer(new jedd.Attribute[]{kind.v(),stmt.v(),srcm.v(),tgtm.v(),srcc.v(),tgtc.v()},new jedd.PhysicalDomain[]{FD.v(),ST.v(),T1.v(),T2.v(),V1.v(),V2.v()},(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""),jedd.internal.Jedd.v().join(jedd.internal.Jedd.v().read(edges),jedd.internal.Jedd.v().literal(new Object[]{m.context(),m.method()},new jedd.Attribute[]{ctxt.v(),method.v()},new jedd.PhysicalDomain[]{V1.v(),T1.v()}),new jedd.PhysicalDomain[]{T1.v(),V1.v()})),""String_Node_Str"");
}","public Rsrcc_srcm_stmt_kind_tgtc_tgtm edgesOutOf(MethodOrMethodContext m){
  return new Rsrcc_srcm_stmt_kind_tgtc_tgtmBDD(new jedd.internal.RelationContainer(new jedd.Attribute[]{stmt.v(),srcm.v(),tgtc.v(),srcc.v(),kind.v(),tgtm.v()},new jedd.PhysicalDomain[]{ST.v(),T1.v(),V2.v(),V1.v(),FD.v(),T2.v()},(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""),jedd.internal.Jedd.v().join(jedd.internal.Jedd.v().read(edges),jedd.internal.Jedd.v().literal(new Object[]{m.context(),m.method()},new jedd.Attribute[]{ctxt.v(),method.v()},new jedd.PhysicalDomain[]{V1.v(),T1.v()}),new jedd.PhysicalDomain[]{T1.v(),V1.v()})),""String_Node_Str"");
}"
88680,"public void addEntryPoint(MethodOrMethodContext m){
  entryPoints.eqUnion(jedd.internal.Jedd.v().literal(new Object[]{m.method()},new jedd.Attribute[]{method.v()},new jedd.PhysicalDomain[]{T1.v()}));
}","public void addEntryPoint(MethodOrMethodContext m){
  entryPoints.eqUnion(jedd.internal.Jedd.v().literal(new Object[]{m.method()},new jedd.Attribute[]{method.v()},new jedd.PhysicalDomain[]{T2.v()}));
}"
88681,"public void update(){
  cg.update();
  final jedd.internal.RelationContainer edges=new jedd.internal.RelationContainer(new jedd.Attribute[]{srcc.v(),srcm.v(),stmt.v(),kind.v(),tgtc.v(),tgtm.v()},new jedd.PhysicalDomain[]{V1.v(),T1.v(),ST.v(),FD.v(),V2.v(),T2.v()},(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""),cg.edges().get());
  final jedd.internal.RelationContainer wantedKinds=new jedd.internal.RelationContainer(new jedd.Attribute[]{kind.v()},new jedd.PhysicalDomain[]{FD.v()},(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""),jedd.internal.Jedd.v().trueBDD());
  wantedKinds.eqMinus(jedd.internal.Jedd.v().literal(new Object[]{Kind.THREAD},new jedd.Attribute[]{kind.v()},new jedd.PhysicalDomain[]{FD.v()}));
  final jedd.internal.RelationContainer wantedEdges=new jedd.internal.RelationContainer(new jedd.Attribute[]{srcm.v(),tgtm.v()},new jedd.PhysicalDomain[]{T1.v(),T2.v()},(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""),jedd.internal.Jedd.v().compose(jedd.internal.Jedd.v().read(jedd.internal.Jedd.v().project(edges,new jedd.PhysicalDomain[]{ST.v(),V1.v(),V2.v()})),wantedKinds,new jedd.PhysicalDomain[]{FD.v()}));
  final jedd.internal.RelationContainer edgeClosure=new jedd.internal.RelationContainer(new jedd.Attribute[]{srcm.v(),tgtm.v()},new jedd.PhysicalDomain[]{T2.v(),T3.v()},(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""),jedd.internal.Jedd.v().replace(wantedEdges,new jedd.PhysicalDomain[]{T1.v(),T2.v()},new jedd.PhysicalDomain[]{T2.v(),T3.v()}));
  while (true) {
    final jedd.internal.RelationContainer oldClosure=new jedd.internal.RelationContainer(new jedd.Attribute[]{srcm.v(),tgtm.v()},new jedd.PhysicalDomain[]{T2.v(),T3.v()},(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""),edgeClosure);
    edgeClosure.eqUnion(jedd.internal.Jedd.v().compose(jedd.internal.Jedd.v().read(jedd.internal.Jedd.v().replace(edgeClosure,new jedd.PhysicalDomain[]{T3.v()},new jedd.PhysicalDomain[]{T1.v()})),jedd.internal.Jedd.v().replace(edgeClosure,new jedd.PhysicalDomain[]{T2.v()},new jedd.PhysicalDomain[]{T1.v()}),new jedd.PhysicalDomain[]{T1.v()}));
    if (jedd.internal.Jedd.v().equals(jedd.internal.Jedd.v().read(edgeClosure),oldClosure))     break;
    System.out.println(""String_Node_Str"" + new jedd.internal.RelationContainer(new jedd.Attribute[]{srcm.v(),tgtm.v()},new jedd.PhysicalDomain[]{T2.v(),T3.v()},(""String_Node_Str"" + ""String_Node_Str""),edgeClosure).size());
    System.out.println(""String_Node_Str"" + new jedd.internal.RelationContainer(new jedd.Attribute[]{srcm.v(),tgtm.v()},new jedd.PhysicalDomain[]{T2.v(),T3.v()},(""String_Node_Str"" + ""String_Node_Str""),edgeClosure).numNodes());
  }
  mayCflow.eqUnion(jedd.internal.Jedd.v().replace(jedd.internal.Jedd.v().join(jedd.internal.Jedd.v().read(jedd.internal.Jedd.v().replace(edgeClosure,new jedd.PhysicalDomain[]{T2.v()},new jedd.PhysicalDomain[]{T1.v()})),entryPoints,new jedd.PhysicalDomain[]{T1.v()}),new jedd.PhysicalDomain[]{T3.v()},new jedd.PhysicalDomain[]{T2.v()}));
  while (true) {
    final jedd.internal.RelationContainer oldMayCflow=new jedd.internal.RelationContainer(new jedd.Attribute[]{srcm.v(),tgtm.v()},new jedd.PhysicalDomain[]{T1.v(),T2.v()},(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""),mayCflow);
    mayCflow.eqUnion(jedd.internal.Jedd.v().join(jedd.internal.Jedd.v().read(jedd.internal.Jedd.v().replace(edgeClosure,new jedd.PhysicalDomain[]{T2.v(),T3.v()},new jedd.PhysicalDomain[]{T1.v(),T2.v()})),jedd.internal.Jedd.v().replace(jedd.internal.Jedd.v().project(mayCflow,new jedd.PhysicalDomain[]{T1.v()}),new jedd.PhysicalDomain[]{T2.v()},new jedd.PhysicalDomain[]{T1.v()}),new jedd.PhysicalDomain[]{T1.v()}));
    if (jedd.internal.Jedd.v().equals(jedd.internal.Jedd.v().read(mayCflow),oldMayCflow))     break;
    System.out.println(""String_Node_Str"" + new jedd.internal.RelationContainer(new jedd.Attribute[]{srcm.v(),tgtm.v()},new jedd.PhysicalDomain[]{T1.v(),T2.v()},(""String_Node_Str"" + ""String_Node_Str""),mayCflow).size());
    System.out.println(""String_Node_Str"" + new jedd.internal.RelationContainer(new jedd.Attribute[]{srcm.v(),tgtm.v()},new jedd.PhysicalDomain[]{T1.v(),T2.v()},(""String_Node_Str"" + ""String_Node_Str""),mayCflow).numNodes());
  }
  final jedd.internal.RelationContainer allSources=new jedd.internal.RelationContainer(new jedd.Attribute[]{srcm.v()},new jedd.PhysicalDomain[]{T3.v()},(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""),jedd.internal.Jedd.v().trueBDD());
  final jedd.internal.RelationContainer identity=new jedd.internal.RelationContainer(new jedd.Attribute[]{srcm.v(),tgtm.v()},new jedd.PhysicalDomain[]{T1.v(),T3.v()},(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""),jedd.internal.Jedd.v().copy(allSources,new jedd.PhysicalDomain[]{T3.v()},new jedd.PhysicalDomain[]{T1.v()}));
  notMustPreds.eqUnion(jedd.internal.Jedd.v().replace(jedd.internal.Jedd.v().join(jedd.internal.Jedd.v().read(jedd.internal.Jedd.v().replace(entryPoints,new jedd.PhysicalDomain[]{T1.v()},new jedd.PhysicalDomain[]{T2.v()})),allSources,new jedd.PhysicalDomain[]{}),new jedd.PhysicalDomain[]{T3.v()},new jedd.PhysicalDomain[]{T1.v()}));
  while (true) {
    final jedd.internal.RelationContainer oldNotMustPreds=new jedd.internal.RelationContainer(new jedd.Attribute[]{srcm.v(),tgtm.v()},new jedd.PhysicalDomain[]{T1.v(),T2.v()},(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""),notMustPreds);
    notMustPreds.eqUnion(jedd.internal.Jedd.v().compose(jedd.internal.Jedd.v().read(jedd.internal.Jedd.v().replace(wantedEdges,new jedd.PhysicalDomain[]{T1.v()},new jedd.PhysicalDomain[]{T3.v()})),jedd.internal.Jedd.v().minus(jedd.internal.Jedd.v().read(jedd.internal.Jedd.v().replace(notMustPreds,new jedd.PhysicalDomain[]{T2.v()},new jedd.PhysicalDomain[]{T3.v()})),identity),new jedd.PhysicalDomain[]{T3.v()}));
    if (jedd.internal.Jedd.v().equals(jedd.internal.Jedd.v().read(oldNotMustPreds),notMustPreds))     break;
    System.out.println(""String_Node_Str"" + new jedd.internal.RelationContainer(new jedd.Attribute[]{srcm.v(),tgtm.v()},new jedd.PhysicalDomain[]{T1.v(),T2.v()},(""String_Node_Str"" + ""String_Node_Str""),notMustPreds).size());
    System.out.println(""String_Node_Str"" + new jedd.internal.RelationContainer(new jedd.Attribute[]{srcm.v(),tgtm.v()},new jedd.PhysicalDomain[]{T1.v(),T2.v()},(""String_Node_Str"" + ""String_Node_Str""),notMustPreds).numNodes());
  }
  mustCflow.eq(jedd.internal.Jedd.v().minus(jedd.internal.Jedd.v().read(jedd.internal.Jedd.v().trueBDD()),notMustPreds));
  System.out.println(""String_Node_Str"" + new jedd.internal.RelationContainer(new jedd.Attribute[]{srcm.v(),tgtm.v()},new jedd.PhysicalDomain[]{T1.v(),T2.v()},(""String_Node_Str"" + ""String_Node_Str""),mustCflow).size());
  System.out.println(""String_Node_Str"" + new jedd.internal.RelationContainer(new jedd.Attribute[]{srcm.v(),tgtm.v()},new jedd.PhysicalDomain[]{T1.v(),T2.v()},(""String_Node_Str"" + ""String_Node_Str""),mustCflow).numNodes());
}","public void update(){
  cg.update();
  final jedd.internal.RelationContainer edges=new jedd.internal.RelationContainer(new jedd.Attribute[]{srcc.v(),srcm.v(),stmt.v(),kind.v(),tgtc.v(),tgtm.v()},new jedd.PhysicalDomain[]{V1.v(),T1.v(),ST.v(),FD.v(),V2.v(),T2.v()},(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""),cg.edges().get());
  final jedd.internal.RelationContainer wantedKinds=new jedd.internal.RelationContainer(new jedd.Attribute[]{kind.v()},new jedd.PhysicalDomain[]{FD.v()},(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""),jedd.internal.Jedd.v().trueBDD());
  wantedKinds.eqMinus(jedd.internal.Jedd.v().literal(new Object[]{Kind.THREAD},new jedd.Attribute[]{kind.v()},new jedd.PhysicalDomain[]{FD.v()}));
  final jedd.internal.RelationContainer wantedEdges=new jedd.internal.RelationContainer(new jedd.Attribute[]{srcm.v(),tgtm.v()},new jedd.PhysicalDomain[]{T1.v(),T2.v()},(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""),jedd.internal.Jedd.v().compose(jedd.internal.Jedd.v().read(jedd.internal.Jedd.v().project(edges,new jedd.PhysicalDomain[]{ST.v(),V2.v(),V1.v()})),wantedKinds,new jedd.PhysicalDomain[]{FD.v()}));
  final jedd.internal.RelationContainer edgeClosure=new jedd.internal.RelationContainer(new jedd.Attribute[]{srcm.v(),tgtm.v()},new jedd.PhysicalDomain[]{T2.v(),T3.v()},(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""),jedd.internal.Jedd.v().replace(wantedEdges,new jedd.PhysicalDomain[]{T1.v(),T2.v()},new jedd.PhysicalDomain[]{T2.v(),T3.v()}));
  while (true) {
    final jedd.internal.RelationContainer oldClosure=new jedd.internal.RelationContainer(new jedd.Attribute[]{srcm.v(),tgtm.v()},new jedd.PhysicalDomain[]{T2.v(),T3.v()},(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""),edgeClosure);
    edgeClosure.eqUnion(jedd.internal.Jedd.v().compose(jedd.internal.Jedd.v().read(jedd.internal.Jedd.v().replace(edgeClosure,new jedd.PhysicalDomain[]{T3.v()},new jedd.PhysicalDomain[]{T1.v()})),jedd.internal.Jedd.v().replace(edgeClosure,new jedd.PhysicalDomain[]{T2.v()},new jedd.PhysicalDomain[]{T1.v()}),new jedd.PhysicalDomain[]{T1.v()}));
    if (jedd.internal.Jedd.v().equals(jedd.internal.Jedd.v().read(edgeClosure),oldClosure))     break;
    System.out.println(""String_Node_Str"" + new jedd.internal.RelationContainer(new jedd.Attribute[]{srcm.v(),tgtm.v()},new jedd.PhysicalDomain[]{T2.v(),T3.v()},(""String_Node_Str"" + ""String_Node_Str""),edgeClosure).size());
    System.out.println(""String_Node_Str"" + new jedd.internal.RelationContainer(new jedd.Attribute[]{srcm.v(),tgtm.v()},new jedd.PhysicalDomain[]{T2.v(),T3.v()},(""String_Node_Str"" + ""String_Node_Str""),edgeClosure).numNodes());
  }
  mayCflow.eqUnion(jedd.internal.Jedd.v().join(jedd.internal.Jedd.v().read(jedd.internal.Jedd.v().replace(edgeClosure,new jedd.PhysicalDomain[]{T2.v(),T3.v()},new jedd.PhysicalDomain[]{T1.v(),T2.v()})),jedd.internal.Jedd.v().replace(entryPoints,new jedd.PhysicalDomain[]{T2.v()},new jedd.PhysicalDomain[]{T1.v()}),new jedd.PhysicalDomain[]{T1.v()}));
  while (true) {
    final jedd.internal.RelationContainer oldMayCflow=new jedd.internal.RelationContainer(new jedd.Attribute[]{srcm.v(),tgtm.v()},new jedd.PhysicalDomain[]{T1.v(),T2.v()},(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""),mayCflow);
    mayCflow.eqUnion(jedd.internal.Jedd.v().replace(jedd.internal.Jedd.v().join(jedd.internal.Jedd.v().read(jedd.internal.Jedd.v().replace(edgeClosure,new jedd.PhysicalDomain[]{T2.v()},new jedd.PhysicalDomain[]{T1.v()})),jedd.internal.Jedd.v().replace(jedd.internal.Jedd.v().project(mayCflow,new jedd.PhysicalDomain[]{T1.v()}),new jedd.PhysicalDomain[]{T2.v()},new jedd.PhysicalDomain[]{T1.v()}),new jedd.PhysicalDomain[]{T1.v()}),new jedd.PhysicalDomain[]{T3.v()},new jedd.PhysicalDomain[]{T2.v()}));
    if (jedd.internal.Jedd.v().equals(jedd.internal.Jedd.v().read(mayCflow),oldMayCflow))     break;
    System.out.println(""String_Node_Str"" + new jedd.internal.RelationContainer(new jedd.Attribute[]{srcm.v(),tgtm.v()},new jedd.PhysicalDomain[]{T1.v(),T2.v()},(""String_Node_Str"" + ""String_Node_Str""),mayCflow).size());
    System.out.println(""String_Node_Str"" + new jedd.internal.RelationContainer(new jedd.Attribute[]{srcm.v(),tgtm.v()},new jedd.PhysicalDomain[]{T1.v(),T2.v()},(""String_Node_Str"" + ""String_Node_Str""),mayCflow).numNodes());
  }
  final jedd.internal.RelationContainer allSources=new jedd.internal.RelationContainer(new jedd.Attribute[]{srcm.v()},new jedd.PhysicalDomain[]{T1.v()},(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""),jedd.internal.Jedd.v().trueBDD());
  final jedd.internal.RelationContainer identity=new jedd.internal.RelationContainer(new jedd.Attribute[]{srcm.v(),tgtm.v()},new jedd.PhysicalDomain[]{T1.v(),T3.v()},(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""),jedd.internal.Jedd.v().copy(jedd.internal.Jedd.v().replace(allSources,new jedd.PhysicalDomain[]{T1.v()},new jedd.PhysicalDomain[]{T3.v()}),new jedd.PhysicalDomain[]{T3.v()},new jedd.PhysicalDomain[]{T1.v()}));
  notMustPreds.eqUnion(jedd.internal.Jedd.v().join(jedd.internal.Jedd.v().read(entryPoints),allSources,new jedd.PhysicalDomain[]{}));
  while (true) {
    final jedd.internal.RelationContainer oldNotMustPreds=new jedd.internal.RelationContainer(new jedd.Attribute[]{srcm.v(),tgtm.v()},new jedd.PhysicalDomain[]{T1.v(),T2.v()},(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""),notMustPreds);
    notMustPreds.eqUnion(jedd.internal.Jedd.v().compose(jedd.internal.Jedd.v().read(jedd.internal.Jedd.v().replace(wantedEdges,new jedd.PhysicalDomain[]{T1.v()},new jedd.PhysicalDomain[]{T3.v()})),jedd.internal.Jedd.v().minus(jedd.internal.Jedd.v().read(jedd.internal.Jedd.v().replace(notMustPreds,new jedd.PhysicalDomain[]{T2.v()},new jedd.PhysicalDomain[]{T3.v()})),identity),new jedd.PhysicalDomain[]{T3.v()}));
    if (jedd.internal.Jedd.v().equals(jedd.internal.Jedd.v().read(oldNotMustPreds),notMustPreds))     break;
    System.out.println(""String_Node_Str"" + new jedd.internal.RelationContainer(new jedd.Attribute[]{srcm.v(),tgtm.v()},new jedd.PhysicalDomain[]{T1.v(),T2.v()},(""String_Node_Str"" + ""String_Node_Str""),notMustPreds).size());
    System.out.println(""String_Node_Str"" + new jedd.internal.RelationContainer(new jedd.Attribute[]{srcm.v(),tgtm.v()},new jedd.PhysicalDomain[]{T1.v(),T2.v()},(""String_Node_Str"" + ""String_Node_Str""),notMustPreds).numNodes());
  }
  mustCflow.eq(jedd.internal.Jedd.v().minus(jedd.internal.Jedd.v().read(jedd.internal.Jedd.v().trueBDD()),notMustPreds));
  System.out.println(""String_Node_Str"" + new jedd.internal.RelationContainer(new jedd.Attribute[]{srcm.v(),tgtm.v()},new jedd.PhysicalDomain[]{T1.v(),T2.v()},(""String_Node_Str"" + ""String_Node_Str""),mustCflow).size());
  System.out.println(""String_Node_Str"" + new jedd.internal.RelationContainer(new jedd.Attribute[]{srcm.v(),tgtm.v()},new jedd.PhysicalDomain[]{T1.v(),T2.v()},(""String_Node_Str"" + ""String_Node_Str""),mustCflow).numNodes());
}"
88682,"public void update(){
  final jedd.internal.RelationContainer methods=new jedd.internal.RelationContainer(new jedd.Attribute[]{ctxt.v(),method.v()},new jedd.PhysicalDomain[]{V1.v(),T1.v()},(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""),in.get());
  Rsrcc_srcm_stmt_kind_tgtc_tgtm edges=cicg.edgesOutOf(new Rctxt_methodBDD(new jedd.internal.RelationContainer(new jedd.Attribute[]{method.v(),ctxt.v()},new jedd.PhysicalDomain[]{T1.v(),V1.v()},(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""),jedd.internal.Jedd.v().join(jedd.internal.Jedd.v().read(jedd.internal.Jedd.v().project(methods,new jedd.PhysicalDomain[]{V1.v()})),jedd.internal.Jedd.v().literal(new Object[]{null},new jedd.Attribute[]{ctxt.v()},new jedd.PhysicalDomain[]{V1.v()}),new jedd.PhysicalDomain[]{})),""String_Node_Str""));
  out.add(new jedd.internal.RelationContainer(new jedd.Attribute[]{kind.v(),stmt.v(),srcm.v(),tgtm.v(),tgtc.v(),srcc.v()},new jedd.PhysicalDomain[]{FD.v(),ST.v(),T1.v(),T2.v(),V2.v(),V1.v()},(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""),jedd.internal.Jedd.v().join(jedd.internal.Jedd.v().read(jedd.internal.Jedd.v().project(edges.get(),new jedd.PhysicalDomain[]{V1.v()})),methods,new jedd.PhysicalDomain[]{T1.v()})));
}","public void update(){
  final jedd.internal.RelationContainer methods=new jedd.internal.RelationContainer(new jedd.Attribute[]{ctxt.v(),method.v()},new jedd.PhysicalDomain[]{V1.v(),T1.v()},(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""),in.get());
  Rsrcc_srcm_stmt_kind_tgtc_tgtm edges=cicg.edgesOutOf(new Rctxt_methodBDD(new jedd.internal.RelationContainer(new jedd.Attribute[]{method.v(),ctxt.v()},new jedd.PhysicalDomain[]{T1.v(),V1.v()},(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""),jedd.internal.Jedd.v().join(jedd.internal.Jedd.v().read(jedd.internal.Jedd.v().project(methods,new jedd.PhysicalDomain[]{V1.v()})),jedd.internal.Jedd.v().literal(new Object[]{null},new jedd.Attribute[]{ctxt.v()},new jedd.PhysicalDomain[]{V1.v()}),new jedd.PhysicalDomain[]{})),""String_Node_Str""));
  out.add(new jedd.internal.RelationContainer(new jedd.Attribute[]{stmt.v(),srcm.v(),tgtc.v(),tgtm.v(),kind.v(),srcc.v()},new jedd.PhysicalDomain[]{ST.v(),T1.v(),V2.v(),T2.v(),FD.v(),V1.v()},(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""),jedd.internal.Jedd.v().join(jedd.internal.Jedd.v().read(jedd.internal.Jedd.v().project(edges.get(),new jedd.PhysicalDomain[]{V1.v()})),methods,new jedd.PhysicalDomain[]{T1.v()})));
}"
88683,"private void createClassToSourceMap(polyglot.ast.SourceFile src){
  String srcName=src.source().name();
  String srcFileName=null;
  if (src.package_() != null) {
    String slashedPkg=soot.util.StringTools.replaceAll(src.package_().package_().fullName(),""String_Node_Str"",System.getProperty(""String_Node_Str""));
    srcFileName=srcName.substring(srcName.lastIndexOf(slashedPkg));
  }
 else {
    srcFileName=srcName.substring(srcName.lastIndexOf(System.getProperty(""String_Node_Str"")) + 1);
  }
  ArrayList list=new ArrayList();
  Iterator it=src.decls().iterator();
  while (it.hasNext()) {
    polyglot.ast.ClassDecl nextDecl=(polyglot.ast.ClassDecl)it.next();
    addToClassToSourceMap(Util.getSootType(nextDecl.type()).toString(),srcFileName);
  }
}","private void createClassToSourceMap(polyglot.ast.SourceFile src){
  String srcName=src.source().path();
  String srcFileName=null;
  if (src.package_() != null) {
    String slashedPkg=soot.util.StringTools.replaceAll(src.package_().package_().fullName(),""String_Node_Str"",System.getProperty(""String_Node_Str""));
    srcFileName=srcName.substring(srcName.lastIndexOf(slashedPkg));
  }
 else {
    srcFileName=srcName.substring(srcName.lastIndexOf(System.getProperty(""String_Node_Str"")) + 1);
  }
  ArrayList list=new ArrayList();
  Iterator it=src.decls().iterator();
  while (it.hasNext()) {
    polyglot.ast.ClassDecl nextDecl=(polyglot.ast.ClassDecl)it.next();
    addToClassToSourceMap(Util.getSootType(nextDecl.type()).toString(),srcFileName);
  }
}"
88684,"private void createClassToSourceMap(polyglot.ast.SourceFile src){
  String srcName=src.source().name();
  String srcFileName=null;
  if (src.package_() != null) {
    srcFileName=srcName.substring(srcName.lastIndexOf(src.package_().toString()));
  }
 else {
    srcFileName=srcName.substring(srcName.lastIndexOf(System.getProperty(""String_Node_Str"")) + 1);
  }
  ArrayList list=new ArrayList();
  Iterator it=src.decls().iterator();
  while (it.hasNext()) {
    polyglot.ast.ClassDecl nextDecl=(polyglot.ast.ClassDecl)it.next();
    addToClassToSourceMap(Util.getSootType(nextDecl.type()).toString(),srcFileName);
  }
}","private void createClassToSourceMap(polyglot.ast.SourceFile src){
  String srcName=src.source().name();
  String srcFileName=null;
  if (src.package_() != null) {
    String slashedPkg=soot.util.StringTools.replaceAll(src.package_().package_().fullName(),""String_Node_Str"",System.getProperty(""String_Node_Str""));
    srcFileName=srcName.substring(srcName.lastIndexOf(slashedPkg));
  }
 else {
    srcFileName=srcName.substring(srcName.lastIndexOf(System.getProperty(""String_Node_Str"")) + 1);
  }
  ArrayList list=new ArrayList();
  Iterator it=src.decls().iterator();
  while (it.hasNext()) {
    polyglot.ast.ClassDecl nextDecl=(polyglot.ast.ClassDecl)it.next();
    addToClassToSourceMap(Util.getSootType(nextDecl.type()).toString(),srcFileName);
  }
}"
88685,"/** 
 * Type handling
 */
public static soot.Type getSootType(polyglot.types.Type type){
  soot.Type sootType=null;
  if (type.isInt()) {
    sootType=soot.IntType.v();
  }
 else   if (type.isArray()) {
    polyglot.types.Type polyglotBase=((polyglot.types.ArrayType)type).base();
    while (polyglotBase instanceof polyglot.types.ArrayType) {
      polyglotBase=((polyglot.types.ArrayType)polyglotBase).base();
    }
    soot.Type baseType=getSootType(polyglotBase);
    int dims=((polyglot.types.ArrayType)type).dims();
    sootType=soot.ArrayType.v(baseType,dims);
  }
 else   if (type.isBoolean()) {
    sootType=soot.BooleanType.v();
  }
 else   if (type.isByte()) {
    sootType=soot.ByteType.v();
  }
 else   if (type.isChar()) {
    sootType=soot.CharType.v();
  }
 else   if (type.isDouble()) {
    sootType=soot.DoubleType.v();
  }
 else   if (type.isFloat()) {
    sootType=soot.FloatType.v();
  }
 else   if (type.isLong()) {
    sootType=soot.LongType.v();
  }
 else   if (type.isShort()) {
    sootType=soot.ShortType.v();
  }
 else   if (type.isNull()) {
    sootType=soot.NullType.v();
  }
 else   if (type.isVoid()) {
    sootType=soot.VoidType.v();
  }
 else   if (type.isClass()) {
    polyglot.types.ClassType classType=(polyglot.types.ClassType)type;
    String className;
    if (classType.isNested()) {
      if (classType.isAnonymous()) {
        className=(String)soot.javaToJimple.InitialResolver.v().getAnonTypeMap().get(new polyglot.util.IdentityKey(classType));
      }
 else       if (classType.isLocal()) {
        className=(String)soot.javaToJimple.InitialResolver.v().getLocalTypeMap().get(new polyglot.util.IdentityKey(classType));
      }
 else {
        String fullName=classType.fullName();
        String pkgName=""String_Node_Str"";
        if (classType.package_() != null) {
          pkgName=classType.package_().fullName();
        }
        className=classType.name();
        if (classType.outer().isAnonymous() || classType.outer().isLocal()) {
          className=getSootType(classType.outer()).toString() + ""String_Node_Str"" + className;
        }
 else {
          while (classType.outer() != null) {
            className=classType.outer().name() + ""String_Node_Str"" + className;
            classType=classType.outer();
          }
          if (!pkgName.equals(""String_Node_Str"")) {
            className=pkgName + ""String_Node_Str"" + className;
          }
        }
      }
    }
 else {
      className=classType.fullName();
    }
    sootType=soot.RefType.v(className);
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
  return sootType;
}","/** 
 * Type handling
 */
public static soot.Type getSootType(polyglot.types.Type type){
  soot.Type sootType=null;
  if (type.isInt()) {
    sootType=soot.IntType.v();
  }
 else   if (type.isArray()) {
    polyglot.types.Type polyglotBase=((polyglot.types.ArrayType)type).base();
    while (polyglotBase instanceof polyglot.types.ArrayType) {
      polyglotBase=((polyglot.types.ArrayType)polyglotBase).base();
    }
    soot.Type baseType=getSootType(polyglotBase);
    int dims=((polyglot.types.ArrayType)type).dims();
    sootType=soot.ArrayType.v(baseType,dims);
  }
 else   if (type.isBoolean()) {
    sootType=soot.BooleanType.v();
  }
 else   if (type.isByte()) {
    sootType=soot.ByteType.v();
  }
 else   if (type.isChar()) {
    sootType=soot.CharType.v();
  }
 else   if (type.isDouble()) {
    sootType=soot.DoubleType.v();
  }
 else   if (type.isFloat()) {
    sootType=soot.FloatType.v();
  }
 else   if (type.isLong()) {
    sootType=soot.LongType.v();
  }
 else   if (type.isShort()) {
    sootType=soot.ShortType.v();
  }
 else   if (type.isNull()) {
    sootType=soot.NullType.v();
  }
 else   if (type.isVoid()) {
    sootType=soot.VoidType.v();
  }
 else   if (type.isClass()) {
    polyglot.types.ClassType classType=(polyglot.types.ClassType)type;
    String className;
    if (classType.isNested()) {
      if (classType.isAnonymous() && (soot.javaToJimple.InitialResolver.v().getAnonTypeMap() != null) && soot.javaToJimple.InitialResolver.v().getAnonTypeMap().containsKey(new polyglot.util.IdentityKey(classType))) {
        className=(String)soot.javaToJimple.InitialResolver.v().getAnonTypeMap().get(new polyglot.util.IdentityKey(classType));
      }
 else       if (classType.isLocal() && (soot.javaToJimple.InitialResolver.v().getLocalTypeMap() != null) && soot.javaToJimple.InitialResolver.v().getLocalTypeMap().containsKey(new polyglot.util.IdentityKey(classType))) {
        className=(String)soot.javaToJimple.InitialResolver.v().getLocalTypeMap().get(new polyglot.util.IdentityKey(classType));
      }
 else {
        String fullName=classType.fullName();
        String pkgName=""String_Node_Str"";
        if (classType.package_() != null) {
          pkgName=classType.package_().fullName();
        }
        className=classType.name();
        if (classType.outer().isAnonymous() || classType.outer().isLocal()) {
          className=getSootType(classType.outer()).toString() + ""String_Node_Str"" + className;
        }
 else {
          while (classType.outer() != null) {
            className=classType.outer().name() + ""String_Node_Str"" + className;
            classType=classType.outer();
          }
          if (!pkgName.equals(""String_Node_Str"")) {
            className=pkgName + ""String_Node_Str"" + className;
          }
        }
      }
    }
 else {
      className=classType.fullName();
    }
    sootType=soot.RefType.v(className);
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
  return sootType;
}"
88686,"/** 
 * ClassToSourceMap is for classes whos names don't match the source file name - ex: multiple top level classes in a single file
 */
private void addToClassToSourceMap(String className,String sourceName){
  if (sourceToClassMap == null) {
    sourceToClassMap=new HashMap();
  }
  if (soot.SourceLocator.v().getSourceToClassMap() == null) {
    soot.SourceLocator.v().setSourceToClassMap(sourceToClassMap);
  }
  if (!soot.SourceLocator.v().getSourceToClassMap().containsKey(className)) {
    soot.SourceLocator.v().addToSourceToClassMap(className,sourceName);
  }
}","/** 
 * ClassToSourceMap is for classes whos names don't match the source file name - ex: multiple top level classes in a single file
 */
private void addToClassToSourceMap(String className,String sourceName){
  if (classToSourceMap == null) {
    classToSourceMap=new HashMap();
  }
  classToSourceMap.put(className,sourceName);
}"
88687,"public void resolveFromJavaFile(soot.SootClass sc){
  sootClass=sc;
  addSourceFileTag(sc);
  resolveTypes();
  makeASTMap();
  ClassLiteralChecker classLitChecker=new ClassLiteralChecker();
  astNode.visit(classLitChecker);
  ArrayList classLitList=classLitChecker.getList();
  if (!classLitList.isEmpty()) {
    String methodName=""String_Node_Str"";
    soot.Type methodRetType=soot.RefType.v(""String_Node_Str"");
    ArrayList paramTypes=new ArrayList();
    paramTypes.add(soot.RefType.v(""String_Node_Str""));
    if (!sc.declaresMethod(methodName,paramTypes,methodRetType)) {
      soot.SootMethod sootMethod=new soot.SootMethod(methodName,paramTypes,methodRetType,soot.Modifier.STATIC);
      ClassLiteralMethodSource mSrc=new ClassLiteralMethodSource();
      sootMethod.setSource(mSrc);
      sc.addMethod(sootMethod);
    }
  }
  Iterator classLitIt=classLitList.iterator();
  while (classLitIt.hasNext()) {
    polyglot.ast.ClassLit classLit=(polyglot.ast.ClassLit)classLitIt.next();
    String fieldName=""String_Node_Str"";
    String type=Util.getSootType(classLit.typeNode().type()).toString();
    type=soot.util.StringTools.replaceAll(type,""String_Node_Str"",""String_Node_Str"");
    fieldName=fieldName + type;
    soot.Type fieldType=soot.RefType.v(""String_Node_Str"");
    if (!sc.declaresField(fieldName,fieldType)) {
      soot.SootField sootField=new soot.SootField(fieldName,fieldType,soot.Modifier.STATIC);
      sc.addField(sootField);
    }
  }
  AssertStmtChecker asc=new AssertStmtChecker();
  astNode.visit(asc);
  if (asc.isHasAssert()) {
    handleAssert();
  }
  if (astNode instanceof polyglot.ast.SourceFile) {
    createSource((polyglot.ast.SourceFile)astNode);
  }
}","public void resolveFromJavaFile(soot.SootClass sc){
  sootClass=sc;
  resolveTypes();
  makeASTMap();
  ClassLiteralChecker classLitChecker=new ClassLiteralChecker();
  astNode.visit(classLitChecker);
  ArrayList classLitList=classLitChecker.getList();
  if (!classLitList.isEmpty()) {
    String methodName=""String_Node_Str"";
    soot.Type methodRetType=soot.RefType.v(""String_Node_Str"");
    ArrayList paramTypes=new ArrayList();
    paramTypes.add(soot.RefType.v(""String_Node_Str""));
    if (!sc.declaresMethod(methodName,paramTypes,methodRetType)) {
      soot.SootMethod sootMethod=new soot.SootMethod(methodName,paramTypes,methodRetType,soot.Modifier.STATIC);
      ClassLiteralMethodSource mSrc=new ClassLiteralMethodSource();
      sootMethod.setSource(mSrc);
      sc.addMethod(sootMethod);
    }
  }
  Iterator classLitIt=classLitList.iterator();
  while (classLitIt.hasNext()) {
    polyglot.ast.ClassLit classLit=(polyglot.ast.ClassLit)classLitIt.next();
    String fieldName=""String_Node_Str"";
    String type=Util.getSootType(classLit.typeNode().type()).toString();
    type=soot.util.StringTools.replaceAll(type,""String_Node_Str"",""String_Node_Str"");
    fieldName=fieldName + type;
    soot.Type fieldType=soot.RefType.v(""String_Node_Str"");
    if (!sc.declaresField(fieldName,fieldType)) {
      soot.SootField sootField=new soot.SootField(fieldName,fieldType,soot.Modifier.STATIC);
      sc.addField(sootField);
    }
  }
  AssertStmtChecker asc=new AssertStmtChecker();
  astNode.visit(asc);
  if (asc.isHasAssert()) {
    handleAssert();
  }
  if (astNode instanceof polyglot.ast.SourceFile) {
    createClassToSourceMap((polyglot.ast.SourceFile)astNode);
    createSource((polyglot.ast.SourceFile)astNode);
  }
  addSourceFileTag(sc);
}"
88688,"/** 
 * adds source file tag to each sootclass
 */
private void addSourceFileTag(soot.SootClass sc){
  if (sc.getTag(""String_Node_Str"") != null)   return;
  String name=Util.getSourceFileOfClass(sc);
  if (soot.SourceLocator.v().getSourceToClassMap() != null) {
    if (soot.SourceLocator.v().getSourceToClassMap().get(name) != null) {
      name=(String)soot.SourceLocator.v().getSourceToClassMap().get(name);
    }
  }
  name+=""String_Node_Str"";
  sc.addTag(new soot.tagkit.SourceFileTag(name));
}","/** 
 * adds source file tag to each sootclass
 */
private void addSourceFileTag(soot.SootClass sc){
  if (sc.getTag(""String_Node_Str"") != null)   return;
  String name=Util.getSourceFileOfClass(sc);
  if (classToSourceMap != null) {
    if (classToSourceMap.containsKey(name)) {
      name=(String)classToSourceMap.get(name);
    }
  }
  name+=""String_Node_Str"";
  sc.addTag(new soot.tagkit.SourceFileTag(name));
}"
88689,"/** 
 * Source Creation 
 */
private void createSource(polyglot.ast.SourceFile source){
  String simpleName=sootClass.getName();
  Iterator declsIt=source.decls().iterator();
  boolean found=false;
  while (declsIt.hasNext()) {
    Object next=declsIt.next();
    if (next instanceof polyglot.ast.ClassDecl) {
      polyglot.types.ClassType nextType=((polyglot.ast.ClassDecl)next).type();
      if (Util.getSootType(nextType).equals(sootClass.getType())) {
        createClassDecl((polyglot.ast.ClassDecl)next);
        found=true;
      }
 else {
        if (((polyglot.ast.ClassDecl)next).type().isTopLevel() && !((polyglot.ast.ClassDecl)next).flags().isPublic()) {
          if (sootClass.getName().indexOf(""String_Node_Str"") == -1) {
            addToClassToSourceMap(((polyglot.ast.ClassDecl)next).type().fullName(),sootClass.getName());
          }
        }
      }
    }
  }
  if (!found) {
    NestedClassListBuilder nestedClassBuilder=new NestedClassListBuilder();
    source.visit(nestedClassBuilder);
    Iterator nestedDeclsIt=nestedClassBuilder.getClassDeclsList().iterator();
    while (nestedDeclsIt.hasNext() && !found) {
      polyglot.ast.ClassDecl nextDecl=(polyglot.ast.ClassDecl)nestedDeclsIt.next();
      polyglot.types.ClassType type=(polyglot.types.ClassType)nextDecl.type();
      if (type.isLocal() && !type.isAnonymous()) {
        if (localClassMap.containsVal(simpleName)) {
          createClassDecl(((polyglot.ast.LocalClassDecl)localClassMap.getKey(simpleName)).decl());
          found=true;
        }
      }
 else {
        if (Util.getSootType(type).equals(sootClass.getType())) {
          createClassDecl(nextDecl);
          found=true;
        }
      }
    }
    if (!found) {
      if (anonClassMap.containsVal(simpleName)) {
        polyglot.ast.New aNew=(polyglot.ast.New)anonClassMap.getKey(simpleName);
        createAnonClassDecl(aNew);
        createClassBody(aNew.body());
      }
    }
  }
}","/** 
 * Source Creation 
 */
private void createSource(polyglot.ast.SourceFile source){
  String simpleName=sootClass.getName();
  Iterator declsIt=source.decls().iterator();
  boolean found=false;
  while (declsIt.hasNext()) {
    Object next=declsIt.next();
    if (next instanceof polyglot.ast.ClassDecl) {
      polyglot.types.ClassType nextType=((polyglot.ast.ClassDecl)next).type();
      if (Util.getSootType(nextType).equals(sootClass.getType())) {
        createClassDecl((polyglot.ast.ClassDecl)next);
        found=true;
      }
    }
  }
  if (!found) {
    NestedClassListBuilder nestedClassBuilder=new NestedClassListBuilder();
    source.visit(nestedClassBuilder);
    Iterator nestedDeclsIt=nestedClassBuilder.getClassDeclsList().iterator();
    while (nestedDeclsIt.hasNext() && !found) {
      polyglot.ast.ClassDecl nextDecl=(polyglot.ast.ClassDecl)nestedDeclsIt.next();
      polyglot.types.ClassType type=(polyglot.types.ClassType)nextDecl.type();
      if (type.isLocal() && !type.isAnonymous()) {
        if (localClassMap.containsVal(simpleName)) {
          createClassDecl(((polyglot.ast.LocalClassDecl)localClassMap.getKey(simpleName)).decl());
          found=true;
        }
      }
 else {
        if (Util.getSootType(type).equals(sootClass.getType())) {
          createClassDecl(nextDecl);
          found=true;
        }
      }
    }
    if (!found) {
      if (anonClassMap.containsVal(simpleName)) {
        polyglot.ast.New aNew=(polyglot.ast.New)anonClassMap.getKey(simpleName);
        createAnonClassDecl(aNew);
        createClassBody(aNew.body());
      }
    }
  }
}"
88690,"public ClassDeclFinder(){
  declFound=null;
}","public ClassDeclFinder(){
  declsFound=new ArrayList();
}"
88691,"public polyglot.visit.NodeVisitor enter(polyglot.ast.Node parent,polyglot.ast.Node n){
  if (n instanceof polyglot.ast.ClassDecl) {
    if (((polyglot.ast.ClassDecl)n).type().equals(typeToFind)) {
      declFound=(polyglot.ast.ClassDecl)n;
    }
  }
  return enter(n);
}","public polyglot.visit.NodeVisitor enter(polyglot.ast.Node parent,polyglot.ast.Node n){
  if (n instanceof polyglot.ast.ClassDecl) {
    if (typesToFind.contains(((polyglot.ast.ClassDecl)n).type())) {
      declsFound.add((polyglot.ast.ClassDecl)n);
    }
  }
  return enter(n);
}"
88692,"public void resolveFromJavaFile(soot.SootClass sc){
  sootClass=sc;
  addSourceFileTag(sc);
  resolveTypes();
  ClassLiteralChecker classLitChecker=new ClassLiteralChecker();
  astNode.visit(classLitChecker);
  ArrayList classLitList=classLitChecker.getList();
  if (!classLitList.isEmpty()) {
    String methodName=""String_Node_Str"";
    soot.Type methodRetType=soot.RefType.v(""String_Node_Str"");
    ArrayList paramTypes=new ArrayList();
    paramTypes.add(soot.RefType.v(""String_Node_Str""));
    if (!sc.declaresMethod(methodName,paramTypes,methodRetType)) {
      soot.SootMethod sootMethod=new soot.SootMethod(methodName,paramTypes,methodRetType,soot.Modifier.STATIC);
      ClassLiteralMethodSource mSrc=new ClassLiteralMethodSource();
      sootMethod.setSource(mSrc);
      sc.addMethod(sootMethod);
    }
  }
  Iterator classLitIt=classLitList.iterator();
  while (classLitIt.hasNext()) {
    polyglot.ast.ClassLit classLit=(polyglot.ast.ClassLit)classLitIt.next();
    String fieldName=""String_Node_Str"";
    String type=Util.getSootType(classLit.typeNode().type()).toString();
    type=soot.util.StringTools.replaceAll(type,""String_Node_Str"",""String_Node_Str"");
    fieldName=fieldName + type;
    soot.Type fieldType=soot.RefType.v(""String_Node_Str"");
    if (!sc.declaresField(fieldName,fieldType)) {
      soot.SootField sootField=new soot.SootField(fieldName,fieldType,soot.Modifier.STATIC);
      sc.addField(sootField);
    }
  }
  AssertStmtChecker asc=new AssertStmtChecker();
  astNode.visit(asc);
  if (asc.isHasAssert()) {
    handleAssert();
  }
  if (astNode instanceof polyglot.ast.SourceFile) {
    createSource((polyglot.ast.SourceFile)astNode);
  }
}","public void resolveFromJavaFile(soot.SootClass sc){
  sootClass=sc;
  addSourceFileTag(sc);
  resolveTypes();
  makeASTMap();
  ClassLiteralChecker classLitChecker=new ClassLiteralChecker();
  astNode.visit(classLitChecker);
  ArrayList classLitList=classLitChecker.getList();
  if (!classLitList.isEmpty()) {
    String methodName=""String_Node_Str"";
    soot.Type methodRetType=soot.RefType.v(""String_Node_Str"");
    ArrayList paramTypes=new ArrayList();
    paramTypes.add(soot.RefType.v(""String_Node_Str""));
    if (!sc.declaresMethod(methodName,paramTypes,methodRetType)) {
      soot.SootMethod sootMethod=new soot.SootMethod(methodName,paramTypes,methodRetType,soot.Modifier.STATIC);
      ClassLiteralMethodSource mSrc=new ClassLiteralMethodSource();
      sootMethod.setSource(mSrc);
      sc.addMethod(sootMethod);
    }
  }
  Iterator classLitIt=classLitList.iterator();
  while (classLitIt.hasNext()) {
    polyglot.ast.ClassLit classLit=(polyglot.ast.ClassLit)classLitIt.next();
    String fieldName=""String_Node_Str"";
    String type=Util.getSootType(classLit.typeNode().type()).toString();
    type=soot.util.StringTools.replaceAll(type,""String_Node_Str"",""String_Node_Str"");
    fieldName=fieldName + type;
    soot.Type fieldType=soot.RefType.v(""String_Node_Str"");
    if (!sc.declaresField(fieldName,fieldType)) {
      soot.SootField sootField=new soot.SootField(fieldName,fieldType,soot.Modifier.STATIC);
      sc.addField(sootField);
    }
  }
  AssertStmtChecker asc=new AssertStmtChecker();
  astNode.visit(asc);
  if (asc.isHasAssert()) {
    handleAssert();
  }
  if (astNode instanceof polyglot.ast.SourceFile) {
    createSource((polyglot.ast.SourceFile)astNode);
  }
}"
88693,"/** 
 * resolve class types - recursively resolving outer class if nec.
 */
private void resolveClassType(polyglot.types.ClassType classType){
  soot.Type sootClassType;
  if (classType.isNested()) {
    resolveClassType(classType.outer());
  }
  if (classType.isLocal()) {
    resolveLocalClass(classType);
  }
  if (classType.isAnonymous()) {
    resolveAnonClass(classType);
  }
  sootClassType=Util.getSootType(classType);
  ClassDeclFinder finder=new ClassDeclFinder();
  finder.typeToFind(classType);
  astNode.visit(finder);
  if (finder.declFound() != null) {
    addNameToAST(((soot.RefType)sootClassType).getClassName());
  }
  SootResolver.v().assertResolvedClassForType(sootClassType);
}","/** 
 * resolve class types - recursively resolving outer class if nec.
 */
private void resolveClassType(polyglot.types.ClassType classType){
  soot.Type sootClassType;
  if (classType.isNested()) {
    resolveClassType(classType.outer());
  }
  if (classType.isLocal()) {
    resolveLocalClass(classType);
  }
  if (classType.isAnonymous()) {
    resolveAnonClass(classType);
  }
  sootClassType=Util.getSootType(classType);
  if (classTypesFound == null) {
    classTypesFound=new ArrayList();
  }
  classTypesFound.add(classType);
  SootResolver.v().assertResolvedClassForType(sootClassType);
}"
88694,"/** 
 * Creates a binary expression that is not a comparison
 */
private soot.Value getBinaryExpr(soot.Value lVal,soot.Value rVal,polyglot.ast.Binary.Operator operator){
  soot.Value rValue=null;
  if (lVal instanceof soot.jimple.ConditionExpr) {
    lVal=handleCondBinExpr((soot.jimple.ConditionExpr)lVal);
  }
  if (rVal instanceof soot.jimple.ConditionExpr) {
    rVal=handleCondBinExpr((soot.jimple.ConditionExpr)rVal);
  }
  if (operator == polyglot.ast.Binary.ADD) {
    rValue=soot.jimple.Jimple.v().newAddExpr(lVal,rVal);
  }
 else   if (operator == polyglot.ast.Binary.SUB) {
    rValue=soot.jimple.Jimple.v().newSubExpr(lVal,rVal);
  }
 else   if (operator == polyglot.ast.Binary.MUL) {
    rValue=soot.jimple.Jimple.v().newMulExpr(lVal,rVal);
  }
 else   if (operator == polyglot.ast.Binary.DIV) {
    rValue=soot.jimple.Jimple.v().newDivExpr(lVal,rVal);
  }
 else   if (operator == polyglot.ast.Binary.SHR) {
    rValue=soot.jimple.Jimple.v().newShrExpr(lVal,rVal);
  }
 else   if (operator == polyglot.ast.Binary.USHR) {
    rValue=soot.jimple.Jimple.v().newUshrExpr(lVal,rVal);
  }
 else   if (operator == polyglot.ast.Binary.SHL) {
    rValue=soot.jimple.Jimple.v().newShlExpr(lVal,rVal);
  }
 else   if (operator == polyglot.ast.Binary.BIT_AND) {
    rValue=soot.jimple.Jimple.v().newAndExpr(lVal,rVal);
  }
 else   if (operator == polyglot.ast.Binary.BIT_OR) {
    rValue=soot.jimple.Jimple.v().newOrExpr(lVal,rVal);
  }
 else   if (operator == polyglot.ast.Binary.BIT_XOR) {
    rValue=soot.jimple.Jimple.v().newXorExpr(lVal,rVal);
  }
 else   if (operator == polyglot.ast.Binary.MOD) {
    rValue=soot.jimple.Jimple.v().newRemExpr(lVal,rVal);
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
  return rValue;
}","/** 
 * Creates a binary expression that is not a comparison
 */
private soot.Value getBinaryExpr(soot.Value lVal,soot.Value rVal,polyglot.ast.Binary.Operator operator){
  soot.Value rValue=null;
  if (lVal instanceof soot.jimple.ConditionExpr) {
    lVal=handleCondBinExpr((soot.jimple.ConditionExpr)lVal);
  }
  if (rVal instanceof soot.jimple.ConditionExpr) {
    rVal=handleCondBinExpr((soot.jimple.ConditionExpr)rVal);
  }
  if (operator == polyglot.ast.Binary.ADD) {
    rValue=soot.jimple.Jimple.v().newAddExpr(lVal,rVal);
  }
 else   if (operator == polyglot.ast.Binary.SUB) {
    rValue=soot.jimple.Jimple.v().newSubExpr(lVal,rVal);
  }
 else   if (operator == polyglot.ast.Binary.MUL) {
    rValue=soot.jimple.Jimple.v().newMulExpr(lVal,rVal);
  }
 else   if (operator == polyglot.ast.Binary.DIV) {
    rValue=soot.jimple.Jimple.v().newDivExpr(lVal,rVal);
  }
 else   if (operator == polyglot.ast.Binary.SHR) {
    if (rVal.getType().equals(soot.LongType.v())) {
      soot.Local intVal=lg.generateLocal(soot.IntType.v());
      soot.jimple.CastExpr castExpr=soot.jimple.Jimple.v().newCastExpr(rVal,soot.IntType.v());
      soot.jimple.AssignStmt assignStmt=soot.jimple.Jimple.v().newAssignStmt(intVal,castExpr);
      body.getUnits().add(assignStmt);
      rValue=soot.jimple.Jimple.v().newUshrExpr(lVal,intVal);
    }
 else {
      rValue=soot.jimple.Jimple.v().newShrExpr(lVal,rVal);
    }
  }
 else   if (operator == polyglot.ast.Binary.USHR) {
    if (rVal.getType().equals(soot.LongType.v())) {
      soot.Local intVal=lg.generateLocal(soot.IntType.v());
      soot.jimple.CastExpr castExpr=soot.jimple.Jimple.v().newCastExpr(rVal,soot.IntType.v());
      soot.jimple.AssignStmt assignStmt=soot.jimple.Jimple.v().newAssignStmt(intVal,castExpr);
      body.getUnits().add(assignStmt);
      rValue=soot.jimple.Jimple.v().newUshrExpr(lVal,intVal);
    }
 else {
      rValue=soot.jimple.Jimple.v().newUshrExpr(lVal,rVal);
    }
  }
 else   if (operator == polyglot.ast.Binary.SHL) {
    if (rVal.getType().equals(soot.LongType.v())) {
      soot.Local intVal=lg.generateLocal(soot.IntType.v());
      soot.jimple.CastExpr castExpr=soot.jimple.Jimple.v().newCastExpr(rVal,soot.IntType.v());
      soot.jimple.AssignStmt assignStmt=soot.jimple.Jimple.v().newAssignStmt(intVal,castExpr);
      body.getUnits().add(assignStmt);
      rValue=soot.jimple.Jimple.v().newUshrExpr(lVal,intVal);
    }
 else {
      rValue=soot.jimple.Jimple.v().newShlExpr(lVal,rVal);
    }
  }
 else   if (operator == polyglot.ast.Binary.BIT_AND) {
    rValue=soot.jimple.Jimple.v().newAndExpr(lVal,rVal);
  }
 else   if (operator == polyglot.ast.Binary.BIT_OR) {
    rValue=soot.jimple.Jimple.v().newOrExpr(lVal,rVal);
  }
 else   if (operator == polyglot.ast.Binary.BIT_XOR) {
    rValue=soot.jimple.Jimple.v().newXorExpr(lVal,rVal);
  }
 else   if (operator == polyglot.ast.Binary.MOD) {
    rValue=soot.jimple.Jimple.v().newRemExpr(lVal,rVal);
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
  return rValue;
}"
88695,"/** 
 * Literal Creation
 */
private soot.Value createLiteral(polyglot.ast.Lit lit){
  if (lit instanceof polyglot.ast.IntLit) {
    polyglot.ast.IntLit intLit=(polyglot.ast.IntLit)lit;
    long litValue=intLit.value();
    if (intLit.kind() == polyglot.ast.IntLit.INT) {
      return soot.jimple.IntConstant.v((int)litValue);
    }
 else {
      return soot.jimple.LongConstant.v(litValue);
    }
  }
 else   if (lit instanceof polyglot.ast.StringLit) {
    String litValue=((polyglot.ast.StringLit)lit).value();
    return soot.jimple.StringConstant.v(litValue);
  }
 else   if (lit instanceof polyglot.ast.NullLit) {
    return soot.jimple.NullConstant.v();
  }
 else   if (lit instanceof polyglot.ast.FloatLit) {
    polyglot.ast.FloatLit floatLit=(polyglot.ast.FloatLit)lit;
    double litValue=floatLit.value();
    if (floatLit.kind() == polyglot.ast.FloatLit.DOUBLE) {
      return soot.jimple.DoubleConstant.v(floatLit.value());
    }
 else {
      return soot.jimple.FloatConstant.v((float)(floatLit.value()));
    }
  }
 else   if (lit instanceof polyglot.ast.CharLit) {
    char litValue=((polyglot.ast.CharLit)lit).value();
    return soot.jimple.IntConstant.v((int)litValue);
  }
 else   if (lit instanceof polyglot.ast.BooleanLit) {
    boolean litValue=((polyglot.ast.BooleanLit)lit).value();
    if (litValue)     return soot.jimple.IntConstant.v(1);
 else     return soot.jimple.IntConstant.v(0);
  }
 else   if (lit instanceof polyglot.ast.ClassLit) {
    return getSpecialClassLitLocal((polyglot.ast.ClassLit)lit);
  }
 else {
    throw new RuntimeException(""String_Node_Str"" + lit.getClass());
  }
}","/** 
 * Literal Creation
 */
private soot.Value createLiteral(polyglot.ast.Lit lit){
  if (lit instanceof polyglot.ast.IntLit) {
    polyglot.ast.IntLit intLit=(polyglot.ast.IntLit)lit;
    long litValue=intLit.value();
    if (intLit.kind() == polyglot.ast.IntLit.INT) {
      return soot.jimple.IntConstant.v((int)litValue);
    }
 else {
      return soot.jimple.LongConstant.v(litValue);
    }
  }
 else   if (lit instanceof polyglot.ast.StringLit) {
    String litValue=((polyglot.ast.StringLit)lit).value();
    return soot.jimple.StringConstant.v(litValue);
  }
 else   if (lit instanceof polyglot.ast.NullLit) {
    return soot.jimple.NullConstant.v();
  }
 else   if (lit instanceof polyglot.ast.FloatLit) {
    polyglot.ast.FloatLit floatLit=(polyglot.ast.FloatLit)lit;
    double litValue=floatLit.value();
    if (floatLit.kind() == polyglot.ast.FloatLit.DOUBLE) {
      return soot.jimple.DoubleConstant.v(floatLit.value());
    }
 else {
      return soot.jimple.FloatConstant.v((float)(floatLit.value()));
    }
  }
 else   if (lit instanceof polyglot.ast.CharLit) {
    char litValue=((polyglot.ast.CharLit)lit).value();
    return soot.jimple.IntConstant.v(litValue);
  }
 else   if (lit instanceof polyglot.ast.BooleanLit) {
    boolean litValue=((polyglot.ast.BooleanLit)lit).value();
    if (litValue)     return soot.jimple.IntConstant.v(1);
 else     return soot.jimple.IntConstant.v(0);
  }
 else   if (lit instanceof polyglot.ast.ClassLit) {
    return getSpecialClassLitLocal((polyglot.ast.ClassLit)lit);
  }
 else {
    throw new RuntimeException(""String_Node_Str"" + lit.getClass());
  }
}"
88696,"public polyglot.visit.NodeVisitor enter(polyglot.ast.Node parent,polyglot.ast.Node n){
  if (n instanceof polyglot.ast.LocalDecl) {
    polyglot.ast.LocalDecl ld=(polyglot.ast.LocalDecl)n;
    if (ld.flags().isFinal()) {
      if (!finalLocals.contains(new polyglot.util.IdentityKey(ld.localInstance()))) {
        finalLocals.add(new polyglot.util.IdentityKey(ld.localInstance()));
      }
    }
  }
  if (n instanceof polyglot.ast.Formal) {
    polyglot.ast.Formal ld=(polyglot.ast.Formal)n;
    if (ld.flags().isFinal()) {
      if (!finalLocals.contains(new polyglot.util.IdentityKey(ld.localInstance()))) {
        finalLocals.add(new polyglot.util.IdentityKey(ld.localInstance()));
      }
    }
  }
  if (n instanceof polyglot.ast.New) {
    if (((polyglot.ast.New)n).anonType() != null) {
      inners.add(new polyglot.util.IdentityKey(((polyglot.ast.New)n).anonType()));
    }
  }
  if (n instanceof polyglot.ast.LocalClassDecl) {
    inners.add(new polyglot.util.IdentityKey(((polyglot.ast.LocalClassDecl)n).decl().type()));
  }
  return enter(n);
}","public polyglot.visit.NodeVisitor enter(polyglot.ast.Node parent,polyglot.ast.Node n){
  if (n instanceof polyglot.ast.LocalDecl) {
    polyglot.ast.LocalDecl ld=(polyglot.ast.LocalDecl)n;
    if (ld.flags().isFinal()) {
      if (!finalLocals.contains(new polyglot.util.IdentityKey(ld.localInstance()))) {
        finalLocals.add(new polyglot.util.IdentityKey(ld.localInstance()));
      }
    }
  }
  if (n instanceof polyglot.ast.Formal) {
    polyglot.ast.Formal ld=(polyglot.ast.Formal)n;
    if (ld.flags().isFinal()) {
      if (!finalLocals.contains(new polyglot.util.IdentityKey(ld.localInstance()))) {
        finalLocals.add(new polyglot.util.IdentityKey(ld.localInstance()));
      }
    }
  }
  return enter(n);
}"
88697,"private static soot.Local getLocalOfType(soot.Body body,soot.Type type){
  Iterator it=body.getLocals().iterator();
  while (it.hasNext()) {
    soot.Local l=(soot.Local)it.next();
    if (l.getType().equals(type)) {
      return l;
    }
  }
  return null;
}","private static soot.Local getLocalOfType(soot.Body body,soot.Type type){
  soot.FastHierarchy fh=InitialResolver.v().hierarchy();
  Iterator it=body.getLocals().iterator();
  while (it.hasNext()) {
    soot.Local l=(soot.Local)it.next();
    if (fh.canStoreType(l.getType(),type)) {
      return l;
    }
  }
  return null;
}"
88698,"public static soot.Local getThis(soot.Type sootType,soot.Body body,HashMap getThisMap,LocalGenerator lg){
  if (getThisMap.containsKey(sootType)) {
    return (soot.Local)getThisMap.get(sootType);
  }
  soot.Local specialThisLocal=body.getThisLocal();
  if (specialThisLocal.getType().equals(sootType)) {
    getThisMap.put(sootType,specialThisLocal);
    return specialThisLocal;
  }
  if (bodyHasLocal(body,sootType)) {
    soot.Local l=getLocalOfType(body,sootType);
    getThisMap.put(sootType,l);
    return l;
  }
  soot.SootClass classToInvoke=((soot.RefType)specialThisLocal.getType()).getSootClass();
  soot.SootField outerThisField=classToInvoke.getFieldByName(""String_Node_Str"");
  soot.Local t1=lg.generateLocal(outerThisField.getType());
  soot.jimple.FieldRef fieldRef=soot.jimple.Jimple.v().newInstanceFieldRef(specialThisLocal,outerThisField);
  soot.jimple.AssignStmt fieldAssignStmt=soot.jimple.Jimple.v().newAssignStmt(t1,fieldRef);
  body.getUnits().add(fieldAssignStmt);
  if (t1.getType().equals(sootType)) {
    getThisMap.put(sootType,t1);
    return t1;
  }
  soot.Local t2=t1;
  return getThisGivenOuter(sootType,getThisMap,body,lg,t2);
}","public static soot.Local getThis(soot.Type sootType,soot.Body body,HashMap getThisMap,LocalGenerator lg){
  if (InitialResolver.v().hierarchy() == null) {
    InitialResolver.v().hierarchy(new soot.FastHierarchy());
  }
  soot.FastHierarchy fh=InitialResolver.v().hierarchy();
  if (getThisMap.containsKey(sootType)) {
    return (soot.Local)getThisMap.get(sootType);
  }
  soot.Local specialThisLocal=body.getThisLocal();
  if (fh.canStoreType(specialThisLocal.getType(),sootType)) {
    getThisMap.put(sootType,specialThisLocal);
    return specialThisLocal;
  }
  if (bodyHasLocal(body,sootType)) {
    soot.Local l=getLocalOfType(body,sootType);
    getThisMap.put(sootType,l);
    return l;
  }
  soot.SootClass classToInvoke=((soot.RefType)specialThisLocal.getType()).getSootClass();
  soot.SootField outerThisField=classToInvoke.getFieldByName(""String_Node_Str"");
  soot.Local t1=lg.generateLocal(outerThisField.getType());
  soot.jimple.FieldRef fieldRef=soot.jimple.Jimple.v().newInstanceFieldRef(specialThisLocal,outerThisField);
  soot.jimple.AssignStmt fieldAssignStmt=soot.jimple.Jimple.v().newAssignStmt(t1,fieldRef);
  body.getUnits().add(fieldAssignStmt);
  if (fh.canStoreType(t1.getType(),sootType)) {
    getThisMap.put(sootType,t1);
    return t1;
  }
  soot.Local t2=t1;
  return getThisGivenOuter(sootType,getThisMap,body,lg,t2);
}"
88699,"public static soot.Local getThisGivenOuter(soot.Type sootType,HashMap getThisMap,soot.Body body,LocalGenerator lg,soot.Local t2){
  while (!t2.getType().equals(sootType)) {
    soot.SootClass classToInvoke=((soot.RefType)t2.getType()).getSootClass();
    soot.SootMethod methToInvoke=makeOuterThisAccessMethod(classToInvoke);
    soot.Local t3=lg.generateLocal(methToInvoke.getReturnType());
    ArrayList methParams=new ArrayList();
    methParams.add(t2);
    soot.Local res=getPrivateAccessFieldInvoke(methToInvoke,methParams,body,lg);
    soot.jimple.AssignStmt assign=soot.jimple.Jimple.v().newAssignStmt(t3,res);
    body.getUnits().add(assign);
    t2=t3;
  }
  getThisMap.put(sootType,t2);
  return t2;
}","public static soot.Local getThisGivenOuter(soot.Type sootType,HashMap getThisMap,soot.Body body,LocalGenerator lg,soot.Local t2){
  if (InitialResolver.v().hierarchy() == null) {
    InitialResolver.v().hierarchy(new soot.FastHierarchy());
  }
  soot.FastHierarchy fh=InitialResolver.v().hierarchy();
  while (!fh.canStoreType(t2.getType(),sootType)) {
    soot.SootClass classToInvoke=((soot.RefType)t2.getType()).getSootClass();
    soot.SootMethod methToInvoke=makeOuterThisAccessMethod(classToInvoke);
    soot.Local t3=lg.generateLocal(methToInvoke.getReturnType());
    ArrayList methParams=new ArrayList();
    methParams.add(t2);
    soot.Local res=getPrivateAccessFieldInvoke(methToInvoke,methParams,body,lg);
    soot.jimple.AssignStmt assign=soot.jimple.Jimple.v().newAssignStmt(t3,res);
    body.getUnits().add(assign);
    t2=t3;
  }
  getThisMap.put(sootType,t2);
  return t2;
}"
88700,"private static boolean bodyHasLocal(soot.Body body,soot.Type type){
  Iterator it=body.getLocals().iterator();
  while (it.hasNext()) {
    soot.Local l=(soot.Local)it.next();
    if (l.getType().equals(type)) {
      return true;
    }
  }
  return false;
}","private static boolean bodyHasLocal(soot.Body body,soot.Type type){
  soot.FastHierarchy fh=InitialResolver.v().hierarchy();
  Iterator it=body.getLocals().iterator();
  while (it.hasNext()) {
    soot.Local l=(soot.Local)it.next();
    if (fh.canStoreType(l.getType(),type)) {
      return true;
    }
  }
  return false;
}"
88701,"/** 
 * Call Expression Creation
 */
private soot.Local getCallLocal(polyglot.ast.Call call){
  String name=call.name();
  polyglot.ast.Receiver receiver=call.target();
  soot.Local baseLocal=(soot.Local)getBaseLocal(receiver);
  soot.SootClass receiverTypeClass=((soot.RefType)Util.getSootType(receiver.type())).getSootClass();
  polyglot.types.MethodInstance methodInstance=call.methodInstance();
  soot.Type sootRetType=Util.getSootType(methodInstance.returnType());
  ArrayList sootParamsTypes=getSootParamsTypes(call);
  ArrayList sootParams=getSootParams(call);
  soot.SootMethod callMethod=getMethodFromClass(receiverTypeClass,methodInstance.name(),sootParamsTypes,sootRetType);
  boolean isPrivateAccess=false;
  soot.javaToJimple.PolyglotMethodSource ms=(soot.javaToJimple.PolyglotMethodSource)body.getMethod().getSource();
  if ((ms.getPrivateAccessMap() != null) && (ms.getPrivateAccessMap().containsKey(call.methodInstance()))) {
    callMethod=(soot.SootMethod)ms.getPrivateAccessMap().get(call.methodInstance());
    if (!call.methodInstance().flags().isStatic()) {
      sootParams.add(baseLocal);
    }
    isPrivateAccess=true;
  }
  soot.jimple.InvokeExpr invokeExpr;
  if (isPrivateAccess) {
    invokeExpr=soot.jimple.Jimple.v().newStaticInvokeExpr(callMethod,sootParams);
  }
 else   if (soot.Modifier.isInterface(receiverTypeClass.getModifiers())) {
    invokeExpr=soot.jimple.Jimple.v().newInterfaceInvokeExpr(baseLocal,callMethod,sootParams);
  }
 else   if (methodInstance.flags().isStatic()) {
    invokeExpr=soot.jimple.Jimple.v().newStaticInvokeExpr(callMethod,sootParams);
  }
 else   if (methodInstance.flags().isPrivate()) {
    invokeExpr=soot.jimple.Jimple.v().newSpecialInvokeExpr(baseLocal,callMethod,sootParams);
  }
 else   if ((receiver instanceof polyglot.ast.Special) && (((polyglot.ast.Special)receiver).kind() == polyglot.ast.Special.SUPER)) {
    invokeExpr=soot.jimple.Jimple.v().newSpecialInvokeExpr(baseLocal,callMethod,sootParams);
  }
 else {
    invokeExpr=soot.jimple.Jimple.v().newVirtualInvokeExpr(baseLocal,callMethod,sootParams);
  }
  int numParams=0;
  Iterator callParamsIt=call.arguments().iterator();
  while (callParamsIt.hasNext()) {
    Util.addLnPosTags(invokeExpr.getArgBox(numParams),((polyglot.ast.Expr)callParamsIt.next()).position());
    numParams++;
  }
  if (invokeExpr instanceof soot.jimple.InstanceInvokeExpr) {
    Util.addLnPosTags(((soot.jimple.InstanceInvokeExpr)invokeExpr).getBaseBox(),call.target().position());
  }
  if (invokeExpr.getMethod().getReturnType().equals(soot.VoidType.v())) {
    soot.jimple.Stmt invoke=soot.jimple.Jimple.v().newInvokeStmt(invokeExpr);
    body.getUnits().add(invoke);
    Util.addLnPosTags(invoke,call.position());
    return null;
  }
 else {
    soot.Local retLocal=lg.generateLocal(invokeExpr.getMethod().getReturnType());
    soot.jimple.Stmt assignStmt=soot.jimple.Jimple.v().newAssignStmt(retLocal,invokeExpr);
    body.getUnits().add(assignStmt);
    Util.addLnPosTags(assignStmt,call.position());
    return retLocal;
  }
}","/** 
 * Call Expression Creation
 */
private soot.Local getCallLocal(polyglot.ast.Call call){
  String name=call.name();
  polyglot.ast.Receiver receiver=call.target();
  soot.Local baseLocal=(soot.Local)getBaseLocal(receiver);
  soot.SootClass receiverTypeClass=((soot.RefType)Util.getSootType(receiver.type())).getSootClass();
  polyglot.types.MethodInstance methodInstance=call.methodInstance();
  soot.Type sootRetType=Util.getSootType(methodInstance.returnType());
  ArrayList sootParamsTypes=getSootParamsTypes(call);
  ArrayList sootParams=getSootParams(call);
  soot.SootMethod callMethod=getMethodFromClass(receiverTypeClass,methodInstance.name(),sootParamsTypes,sootRetType);
  boolean isPrivateAccess=false;
  soot.javaToJimple.PolyglotMethodSource ms=(soot.javaToJimple.PolyglotMethodSource)body.getMethod().getSource();
  if ((ms.getPrivateAccessMap() != null) && (ms.getPrivateAccessMap().containsKey(call.methodInstance()))) {
    callMethod=(soot.SootMethod)ms.getPrivateAccessMap().get(call.methodInstance());
    if (!call.methodInstance().flags().isStatic()) {
      sootParams.add(baseLocal);
    }
    isPrivateAccess=true;
  }
  System.out.println(""String_Node_Str"" + methodInstance.name() + ""String_Node_Str""+ methodInstance.flags());
  soot.jimple.InvokeExpr invokeExpr;
  if (isPrivateAccess) {
    invokeExpr=soot.jimple.Jimple.v().newStaticInvokeExpr(callMethod,sootParams);
  }
 else   if (soot.Modifier.isInterface(receiverTypeClass.getModifiers()) && methodInstance.flags().isAbstract()) {
    invokeExpr=soot.jimple.Jimple.v().newInterfaceInvokeExpr(baseLocal,callMethod,sootParams);
  }
 else   if (methodInstance.flags().isStatic()) {
    invokeExpr=soot.jimple.Jimple.v().newStaticInvokeExpr(callMethod,sootParams);
  }
 else   if (methodInstance.flags().isPrivate()) {
    invokeExpr=soot.jimple.Jimple.v().newSpecialInvokeExpr(baseLocal,callMethod,sootParams);
  }
 else   if ((receiver instanceof polyglot.ast.Special) && (((polyglot.ast.Special)receiver).kind() == polyglot.ast.Special.SUPER)) {
    invokeExpr=soot.jimple.Jimple.v().newSpecialInvokeExpr(baseLocal,callMethod,sootParams);
  }
 else {
    invokeExpr=soot.jimple.Jimple.v().newVirtualInvokeExpr(baseLocal,callMethod,sootParams);
  }
  int numParams=0;
  Iterator callParamsIt=call.arguments().iterator();
  while (callParamsIt.hasNext()) {
    Util.addLnPosTags(invokeExpr.getArgBox(numParams),((polyglot.ast.Expr)callParamsIt.next()).position());
    numParams++;
  }
  if (invokeExpr instanceof soot.jimple.InstanceInvokeExpr) {
    Util.addLnPosTags(((soot.jimple.InstanceInvokeExpr)invokeExpr).getBaseBox(),call.target().position());
  }
  if (invokeExpr.getMethod().getReturnType().equals(soot.VoidType.v())) {
    soot.jimple.Stmt invoke=soot.jimple.Jimple.v().newInvokeStmt(invokeExpr);
    body.getUnits().add(invoke);
    Util.addLnPosTags(invoke,call.position());
    return null;
  }
 else {
    soot.Local retLocal=lg.generateLocal(invokeExpr.getMethod().getReturnType());
    soot.jimple.Stmt assignStmt=soot.jimple.Jimple.v().newAssignStmt(retLocal,invokeExpr);
    body.getUnits().add(assignStmt);
    Util.addLnPosTags(assignStmt,call.position());
    return retLocal;
  }
}"
88702,"public soot.Body getBody(soot.SootMethod sootMethod,String phaseName){
  soot.Body body=soot.jimple.Jimple.v().newBody(sootMethod);
  soot.RefType type=sootMethod.getDeclaringClass().getType();
  soot.Local thisLocal=soot.jimple.Jimple.v().newLocal(""String_Node_Str"",type);
  body.getLocals().add(thisLocal);
  soot.jimple.ThisRef thisRef=soot.jimple.Jimple.v().newThisRef(type);
  soot.jimple.Stmt thisStmt=soot.jimple.Jimple.v().newIdentityStmt(thisLocal,thisRef);
  body.getUnits().add(thisStmt);
  ArrayList invokeList=new ArrayList();
  ArrayList invokeTypeList=new ArrayList();
  int numParams=sootMethod.getParameterCount();
  int numFinals=0;
  if (fields != null) {
    numFinals=fields.size();
  }
  int startFinals=numParams - numFinals;
  ArrayList paramsForFinals=new ArrayList();
  soot.Local outerLocal=null;
  Iterator fIt=sootMethod.getParameterTypes().iterator();
  int counter=0;
  while (fIt.hasNext()) {
    soot.Type fType=(soot.Type)fIt.next();
    soot.Local local=soot.jimple.Jimple.v().newLocal(""String_Node_Str"" + counter,fType);
    body.getLocals().add(local);
    soot.jimple.ParameterRef paramRef=soot.jimple.Jimple.v().newParameterRef(fType,counter);
    soot.jimple.Stmt stmt=soot.jimple.Jimple.v().newIdentityStmt(local,paramRef);
    if ((counter != 0) && (counter < startFinals)) {
      invokeTypeList.add(fType);
      invokeList.add(local);
    }
 else     if (counter == 0) {
      outerLocal=local;
    }
 else {
      paramsForFinals.add(local);
    }
    body.getUnits().add(stmt);
    counter++;
  }
  soot.SootMethod callMethod=sootMethod.getDeclaringClass().getSuperclass().getMethod(""String_Node_Str"",invokeTypeList,soot.VoidType.v());
  soot.jimple.InvokeExpr invoke=soot.jimple.Jimple.v().newSpecialInvokeExpr(thisLocal,callMethod,invokeList);
  soot.jimple.Stmt invokeStmt=soot.jimple.Jimple.v().newInvokeStmt(invoke);
  body.getUnits().add(invokeStmt);
  if (!inStaticMethod) {
    soot.SootField field=sootMethod.getDeclaringClass().getField(""String_Node_Str"",outerClassType);
    soot.jimple.InstanceFieldRef ref=soot.jimple.Jimple.v().newInstanceFieldRef(thisLocal,field);
    soot.jimple.AssignStmt assign=soot.jimple.Jimple.v().newAssignStmt(ref,outerLocal);
    body.getUnits().add(assign);
  }
  if (fields != null) {
    Iterator finalsIt=paramsForFinals.iterator();
    Iterator fieldsIt=fields.iterator();
    while (finalsIt.hasNext() && fieldsIt.hasNext()) {
      soot.Local pLocal=(soot.Local)finalsIt.next();
      soot.SootField pField=(soot.SootField)fieldsIt.next();
      soot.jimple.FieldRef pRef=soot.jimple.Jimple.v().newInstanceFieldRef(thisLocal,pField);
      soot.jimple.AssignStmt pAssign=soot.jimple.Jimple.v().newAssignStmt(pRef,pLocal);
      body.getUnits().add(pAssign);
    }
  }
  soot.jimple.ReturnVoidStmt retStmt=soot.jimple.Jimple.v().newReturnVoidStmt();
  body.getUnits().add(retStmt);
  PackManager.v().getPack(""String_Node_Str"").apply(body);
  return body;
}","public soot.Body getBody(soot.SootMethod sootMethod,String phaseName){
  soot.Body body=soot.jimple.Jimple.v().newBody(sootMethod);
  soot.RefType type=sootMethod.getDeclaringClass().getType();
  soot.Local thisLocal=soot.jimple.Jimple.v().newLocal(""String_Node_Str"",type);
  body.getLocals().add(thisLocal);
  soot.jimple.ThisRef thisRef=soot.jimple.Jimple.v().newThisRef(type);
  soot.jimple.Stmt thisStmt=soot.jimple.Jimple.v().newIdentityStmt(thisLocal,thisRef);
  body.getUnits().add(thisStmt);
  ArrayList invokeList=new ArrayList();
  ArrayList invokeTypeList=new ArrayList();
  int numParams=sootMethod.getParameterCount();
  int numFinals=0;
  if (fields != null) {
    numFinals=fields.size();
  }
  int startFinals=numParams - numFinals;
  ArrayList paramsForFinals=new ArrayList();
  soot.Local outerLocal=null;
  Iterator fIt=sootMethod.getParameterTypes().iterator();
  int counter=0;
  while (fIt.hasNext()) {
    soot.Type fType=(soot.Type)fIt.next();
    soot.Local local=soot.jimple.Jimple.v().newLocal(""String_Node_Str"" + counter,fType);
    body.getLocals().add(local);
    soot.jimple.ParameterRef paramRef=soot.jimple.Jimple.v().newParameterRef(fType,counter);
    soot.jimple.Stmt stmt=soot.jimple.Jimple.v().newIdentityStmt(local,paramRef);
    if (fType.equals(thisOuterType)) {
      outerLocal=local;
    }
    if ((counter != 0) && (counter < startFinals)) {
      invokeTypeList.add(fType);
      invokeList.add(local);
    }
 else     if ((counter == 0) && (!inStaticMethod)) {
      outerLocal=local;
    }
 else {
      paramsForFinals.add(local);
    }
    body.getUnits().add(stmt);
    counter++;
  }
  SootClass superClass=sootMethod.getDeclaringClass().getSuperclass();
  if ((superClass.getName().indexOf(""String_Node_Str"") != -1) && !soot.Modifier.isStatic(superClass.getModifiers())) {
    invokeTypeList.add(0,superOuterType);
  }
  SootMethod callMethod=sootMethod.getDeclaringClass().getSuperclass().getMethod(""String_Node_Str"",invokeTypeList,VoidType.v());
  if ((superClass.getName().indexOf(""String_Node_Str"") != -1) && !soot.Modifier.isStatic(superClass.getModifiers())) {
    if (superOuterType.equals(thisOuterType)) {
      invokeList.add(0,outerLocal);
    }
 else {
      invokeList.add(0,Util.getThisGivenOuter(superOuterType,new HashMap(),body,new LocalGenerator(body),outerLocal));
    }
  }
  soot.jimple.InvokeExpr invoke=soot.jimple.Jimple.v().newSpecialInvokeExpr(thisLocal,callMethod,invokeList);
  soot.jimple.Stmt invokeStmt=soot.jimple.Jimple.v().newInvokeStmt(invoke);
  body.getUnits().add(invokeStmt);
  if (!inStaticMethod) {
    soot.SootField field=sootMethod.getDeclaringClass().getField(""String_Node_Str"",outerClassType);
    soot.jimple.InstanceFieldRef ref=soot.jimple.Jimple.v().newInstanceFieldRef(thisLocal,field);
    soot.jimple.AssignStmt assign=soot.jimple.Jimple.v().newAssignStmt(ref,outerLocal);
    body.getUnits().add(assign);
  }
  if (fields != null) {
    Iterator finalsIt=paramsForFinals.iterator();
    Iterator fieldsIt=fields.iterator();
    while (finalsIt.hasNext() && fieldsIt.hasNext()) {
      soot.Local pLocal=(soot.Local)finalsIt.next();
      soot.SootField pField=(soot.SootField)fieldsIt.next();
      soot.jimple.FieldRef pRef=soot.jimple.Jimple.v().newInstanceFieldRef(thisLocal,pField);
      soot.jimple.AssignStmt pAssign=soot.jimple.Jimple.v().newAssignStmt(pRef,pLocal);
      body.getUnits().add(pAssign);
    }
  }
  soot.jimple.ReturnVoidStmt retStmt=soot.jimple.Jimple.v().newReturnVoidStmt();
  body.getUnits().add(retStmt);
  PackManager.v().getPack(""String_Node_Str"").apply(body);
  return body;
}"
88703,"public soot.Body getBody(soot.SootMethod sootMethod,String phaseName){
  soot.Body classBody=soot.jimple.Jimple.v().newBody(sootMethod);
  soot.jimple.ParameterRef paramRef=soot.jimple.Jimple.v().newParameterRef(soot.RefType.v(""String_Node_Str""),0);
  soot.Local paramLocal=soot.jimple.Jimple.v().newLocal(""String_Node_Str"",soot.RefType.v(""String_Node_Str""));
  classBody.getLocals().add(paramLocal);
  soot.jimple.Stmt stmt=soot.jimple.Jimple.v().newIdentityStmt(paramLocal,paramRef);
  classBody.getUnits().add(stmt);
  ArrayList paramTypes=new ArrayList();
  paramTypes.add(soot.RefType.v(""String_Node_Str""));
  soot.SootMethod methodToInvoke=soot.Scene.v().getSootClass(""String_Node_Str"").getMethod(""String_Node_Str"",paramTypes,soot.RefType.v(""String_Node_Str""));
  soot.Local invokeLocal=soot.jimple.Jimple.v().newLocal(""String_Node_Str"",soot.RefType.v(""String_Node_Str""));
  classBody.getLocals().add(invokeLocal);
  ArrayList params=new ArrayList();
  params.add(paramLocal);
  soot.jimple.Expr invokeExpr=soot.jimple.Jimple.v().newStaticInvokeExpr(methodToInvoke,params);
  soot.jimple.Stmt assign=soot.jimple.Jimple.v().newAssignStmt(invokeLocal,invokeExpr);
  classBody.getUnits().add(assign);
  soot.jimple.Stmt retStmt=soot.jimple.Jimple.v().newReturnStmt(invokeLocal);
  classBody.getUnits().add(retStmt);
  soot.Local catchRefLocal=soot.jimple.Jimple.v().newLocal(""String_Node_Str"",soot.RefType.v(""String_Node_Str""));
  classBody.getLocals().add(catchRefLocal);
  soot.jimple.CaughtExceptionRef caughtRef=soot.jimple.Jimple.v().newCaughtExceptionRef();
  soot.jimple.Stmt caughtIdentity=soot.jimple.Jimple.v().newIdentityStmt(catchRefLocal,caughtRef);
  classBody.getUnits().add(caughtIdentity);
  soot.Local noClassDefLocal=soot.jimple.Jimple.v().newLocal(""String_Node_Str"",soot.RefType.v(""String_Node_Str""));
  classBody.getLocals().add(noClassDefLocal);
  soot.jimple.Expr newExpr=soot.jimple.Jimple.v().newNewExpr(soot.RefType.v(""String_Node_Str""));
  soot.jimple.Stmt noClassDefAssign=soot.jimple.Jimple.v().newAssignStmt(noClassDefLocal,newExpr);
  classBody.getUnits().add(noClassDefAssign);
  paramTypes=new ArrayList();
  soot.SootMethod initMethToInvoke=soot.Scene.v().getSootClass(""String_Node_Str"").getMethod(""String_Node_Str"",paramTypes,soot.VoidType.v());
  params=new ArrayList();
  soot.jimple.Expr initInvoke=soot.jimple.Jimple.v().newSpecialInvokeExpr(noClassDefLocal,initMethToInvoke,params);
  soot.jimple.Stmt initStmt=soot.jimple.Jimple.v().newInvokeStmt(initInvoke);
  classBody.getUnits().add(initStmt);
  soot.Local throwLocal=soot.jimple.Jimple.v().newLocal(""String_Node_Str"",soot.RefType.v(""String_Node_Str""));
  classBody.getLocals().add(throwLocal);
  paramTypes=new ArrayList();
  paramTypes.add(soot.RefType.v(""String_Node_Str""));
  params=new ArrayList();
  params.add(catchRefLocal);
  soot.SootMethod messageMethToInvoke=soot.Scene.v().getSootClass(""String_Node_Str"").getMethod(""String_Node_Str"",paramTypes,soot.RefType.v(""String_Node_Str""));
  soot.jimple.Expr messageInvoke=soot.jimple.Jimple.v().newVirtualInvokeExpr(noClassDefLocal,messageMethToInvoke,params);
  soot.jimple.Stmt messageAssign=soot.jimple.Jimple.v().newAssignStmt(throwLocal,messageInvoke);
  classBody.getUnits().add(messageAssign);
  soot.jimple.Stmt throwStmt=soot.jimple.Jimple.v().newThrowStmt(throwLocal);
  classBody.getUnits().add(throwStmt);
  soot.Trap trap=soot.jimple.Jimple.v().newTrap(soot.Scene.v().getSootClass(""String_Node_Str""),assign,retStmt,caughtIdentity);
  classBody.getTraps().add(trap);
  return classBody;
}","public soot.Body getBody(soot.SootMethod sootMethod,String phaseName){
  soot.Body classBody=soot.jimple.Jimple.v().newBody(sootMethod);
  soot.jimple.ParameterRef paramRef=soot.jimple.Jimple.v().newParameterRef(soot.RefType.v(""String_Node_Str""),0);
  soot.Local paramLocal=soot.jimple.Jimple.v().newLocal(""String_Node_Str"",soot.RefType.v(""String_Node_Str""));
  classBody.getLocals().add(paramLocal);
  soot.jimple.Stmt stmt=soot.jimple.Jimple.v().newIdentityStmt(paramLocal,paramRef);
  classBody.getUnits().add(stmt);
  ArrayList paramTypes=new ArrayList();
  paramTypes.add(soot.RefType.v(""String_Node_Str""));
  soot.SootMethod methodToInvoke=soot.Scene.v().getSootClass(""String_Node_Str"").getMethod(""String_Node_Str"",paramTypes,soot.RefType.v(""String_Node_Str""));
  soot.Local invokeLocal=soot.jimple.Jimple.v().newLocal(""String_Node_Str"",soot.RefType.v(""String_Node_Str""));
  classBody.getLocals().add(invokeLocal);
  ArrayList params=new ArrayList();
  params.add(paramLocal);
  soot.jimple.Expr invokeExpr=soot.jimple.Jimple.v().newStaticInvokeExpr(methodToInvoke,params);
  soot.jimple.Stmt assign=soot.jimple.Jimple.v().newAssignStmt(invokeLocal,invokeExpr);
  classBody.getUnits().add(assign);
  soot.jimple.Stmt retStmt=soot.jimple.Jimple.v().newReturnStmt(invokeLocal);
  classBody.getUnits().add(retStmt);
  soot.Local catchRefLocal=soot.jimple.Jimple.v().newLocal(""String_Node_Str"",soot.RefType.v(""String_Node_Str""));
  classBody.getLocals().add(catchRefLocal);
  soot.jimple.CaughtExceptionRef caughtRef=soot.jimple.Jimple.v().newCaughtExceptionRef();
  soot.jimple.Stmt caughtIdentity=soot.jimple.Jimple.v().newIdentityStmt(catchRefLocal,caughtRef);
  classBody.getUnits().add(caughtIdentity);
  soot.Local noClassDefLocal=soot.jimple.Jimple.v().newLocal(""String_Node_Str"",soot.RefType.v(""String_Node_Str""));
  classBody.getLocals().add(noClassDefLocal);
  soot.jimple.Expr newExpr=soot.jimple.Jimple.v().newNewExpr(soot.RefType.v(""String_Node_Str""));
  soot.jimple.Stmt noClassDefAssign=soot.jimple.Jimple.v().newAssignStmt(noClassDefLocal,newExpr);
  classBody.getUnits().add(noClassDefAssign);
  paramTypes=new ArrayList();
  soot.SootMethod initMethToInvoke=soot.Scene.v().getSootClass(""String_Node_Str"").getMethod(""String_Node_Str"",paramTypes,soot.VoidType.v());
  params=new ArrayList();
  soot.jimple.Expr initInvoke=soot.jimple.Jimple.v().newSpecialInvokeExpr(noClassDefLocal,initMethToInvoke,params);
  soot.jimple.Stmt initStmt=soot.jimple.Jimple.v().newInvokeStmt(initInvoke);
  classBody.getUnits().add(initStmt);
  soot.Local throwLocal=soot.jimple.Jimple.v().newLocal(""String_Node_Str"",soot.RefType.v(""String_Node_Str""));
  classBody.getLocals().add(throwLocal);
  paramTypes=new ArrayList();
  paramTypes.add(soot.RefType.v(""String_Node_Str""));
  params=new ArrayList();
  params.add(catchRefLocal);
  soot.SootMethod messageMethToInvoke=soot.Scene.v().getSootClass(""String_Node_Str"").getMethod(""String_Node_Str"",paramTypes,soot.RefType.v(""String_Node_Str""));
  soot.jimple.Expr messageInvoke=soot.jimple.Jimple.v().newVirtualInvokeExpr(noClassDefLocal,messageMethToInvoke,params);
  soot.jimple.Stmt messageAssign=soot.jimple.Jimple.v().newAssignStmt(throwLocal,messageInvoke);
  classBody.getUnits().add(messageAssign);
  soot.jimple.Stmt throwStmt=soot.jimple.Jimple.v().newThrowStmt(throwLocal);
  throwStmt.addTag(new soot.tagkit.ThrowCreatedByCompilerTag());
  classBody.getUnits().add(throwStmt);
  soot.Trap trap=soot.jimple.Jimple.v().newTrap(soot.Scene.v().getSootClass(""String_Node_Str""),assign,retStmt,caughtIdentity);
  classBody.getTraps().add(trap);
  return classBody;
}"
88704,"public soot.Body getBody(soot.SootMethod sootMethod,String phaseName){
  soot.Body classBody=soot.jimple.Jimple.v().newBody(sootMethod);
  soot.jimple.ParameterRef paramRef=soot.jimple.Jimple.v().newParameterRef(soot.RefType.v(""String_Node_Str""),0);
  soot.Local paramLocal=soot.jimple.Jimple.v().newLocal(""String_Node_Str"",soot.RefType.v(""String_Node_Str""));
  classBody.getLocals().add(paramLocal);
  soot.jimple.Stmt stmt=soot.jimple.Jimple.v().newIdentityStmt(paramLocal,paramRef);
  classBody.getUnits().add(stmt);
  ArrayList paramTypes=new ArrayList();
  paramTypes.add(soot.RefType.v(""String_Node_Str""));
  soot.SootMethod methodToInvoke=soot.Scene.v().getSootClass(""String_Node_Str"").getMethod(""String_Node_Str"",paramTypes,soot.RefType.v(""String_Node_Str""));
  soot.Local invokeLocal=soot.jimple.Jimple.v().newLocal(""String_Node_Str"",soot.RefType.v(""String_Node_Str""));
  classBody.getLocals().add(invokeLocal);
  ArrayList params=new ArrayList();
  params.add(paramLocal);
  soot.jimple.Expr invokeExpr=soot.jimple.Jimple.v().newStaticInvokeExpr(methodToInvoke,params);
  soot.jimple.Stmt assign=soot.jimple.Jimple.v().newAssignStmt(invokeLocal,invokeExpr);
  classBody.getUnits().add(assign);
  soot.jimple.Stmt retStmt=soot.jimple.Jimple.v().newReturnStmt(invokeLocal);
  classBody.getUnits().add(retStmt);
  soot.Local catchRefLocal=soot.jimple.Jimple.v().newLocal(""String_Node_Str"",soot.RefType.v(""String_Node_Str""));
  classBody.getLocals().add(catchRefLocal);
  soot.jimple.CaughtExceptionRef caughtRef=soot.jimple.Jimple.v().newCaughtExceptionRef();
  soot.jimple.Stmt caughtIdentity=soot.jimple.Jimple.v().newIdentityStmt(catchRefLocal,caughtRef);
  classBody.getUnits().add(caughtIdentity);
  soot.Local throwLocal=soot.jimple.Jimple.v().newLocal(""String_Node_Str"",soot.RefType.v(""String_Node_Str""));
  classBody.getLocals().add(throwLocal);
  soot.jimple.Expr newExpr=soot.jimple.Jimple.v().newNewExpr(soot.RefType.v(""String_Node_Str""));
  soot.jimple.Stmt throwAssign=soot.jimple.Jimple.v().newAssignStmt(throwLocal,newExpr);
  classBody.getUnits().add(throwAssign);
  soot.Local messageLocal=soot.jimple.Jimple.v().newLocal(""String_Node_Str"",soot.RefType.v(""String_Node_Str""));
  classBody.getLocals().add(messageLocal);
  soot.SootMethod messageMethToInvoke=soot.Scene.v().getSootClass(""String_Node_Str"").getMethod(""String_Node_Str"",new ArrayList(),soot.RefType.v(""String_Node_Str""));
  soot.jimple.Expr messageInvoke=soot.jimple.Jimple.v().newVirtualInvokeExpr(catchRefLocal,messageMethToInvoke,new ArrayList());
  soot.jimple.Stmt messageAssign=soot.jimple.Jimple.v().newAssignStmt(messageLocal,messageInvoke);
  classBody.getUnits().add(messageAssign);
  paramTypes=new ArrayList();
  paramTypes.add(soot.RefType.v(""String_Node_Str""));
  soot.SootMethod initMethToInvoke=soot.Scene.v().getSootClass(""String_Node_Str"").getMethod(""String_Node_Str"",paramTypes,soot.VoidType.v());
  params=new ArrayList();
  params.add(messageLocal);
  soot.jimple.Expr initInvoke=soot.jimple.Jimple.v().newSpecialInvokeExpr(throwLocal,initMethToInvoke,params);
  soot.jimple.Stmt initStmt=soot.jimple.Jimple.v().newInvokeStmt(initInvoke);
  classBody.getUnits().add(initStmt);
  soot.jimple.Stmt throwStmt=soot.jimple.Jimple.v().newThrowStmt(throwLocal);
  classBody.getUnits().add(throwStmt);
  soot.Trap trap=soot.jimple.Jimple.v().newTrap(soot.Scene.v().getSootClass(""String_Node_Str""),assign,retStmt,caughtIdentity);
  classBody.getTraps().add(trap);
  return classBody;
}","public soot.Body getBody(soot.SootMethod sootMethod,String phaseName){
  soot.Body classBody=soot.jimple.Jimple.v().newBody(sootMethod);
  soot.jimple.ParameterRef paramRef=soot.jimple.Jimple.v().newParameterRef(soot.RefType.v(""String_Node_Str""),0);
  soot.Local paramLocal=soot.jimple.Jimple.v().newLocal(""String_Node_Str"",soot.RefType.v(""String_Node_Str""));
  classBody.getLocals().add(paramLocal);
  soot.jimple.Stmt stmt=soot.jimple.Jimple.v().newIdentityStmt(paramLocal,paramRef);
  classBody.getUnits().add(stmt);
  ArrayList paramTypes=new ArrayList();
  paramTypes.add(soot.RefType.v(""String_Node_Str""));
  soot.SootMethod methodToInvoke=soot.Scene.v().getSootClass(""String_Node_Str"").getMethod(""String_Node_Str"",paramTypes,soot.RefType.v(""String_Node_Str""));
  soot.Local invokeLocal=soot.jimple.Jimple.v().newLocal(""String_Node_Str"",soot.RefType.v(""String_Node_Str""));
  classBody.getLocals().add(invokeLocal);
  ArrayList params=new ArrayList();
  params.add(paramLocal);
  soot.jimple.Expr invokeExpr=soot.jimple.Jimple.v().newStaticInvokeExpr(methodToInvoke,params);
  soot.jimple.Stmt assign=soot.jimple.Jimple.v().newAssignStmt(invokeLocal,invokeExpr);
  classBody.getUnits().add(assign);
  soot.jimple.Stmt retStmt=soot.jimple.Jimple.v().newReturnStmt(invokeLocal);
  classBody.getUnits().add(retStmt);
  soot.Local catchRefLocal=soot.jimple.Jimple.v().newLocal(""String_Node_Str"",soot.RefType.v(""String_Node_Str""));
  classBody.getLocals().add(catchRefLocal);
  soot.jimple.CaughtExceptionRef caughtRef=soot.jimple.Jimple.v().newCaughtExceptionRef();
  soot.jimple.Stmt caughtIdentity=soot.jimple.Jimple.v().newIdentityStmt(catchRefLocal,caughtRef);
  classBody.getUnits().add(caughtIdentity);
  soot.Local throwLocal=soot.jimple.Jimple.v().newLocal(""String_Node_Str"",soot.RefType.v(""String_Node_Str""));
  classBody.getLocals().add(throwLocal);
  soot.jimple.Expr newExpr=soot.jimple.Jimple.v().newNewExpr(soot.RefType.v(""String_Node_Str""));
  soot.jimple.Stmt throwAssign=soot.jimple.Jimple.v().newAssignStmt(throwLocal,newExpr);
  classBody.getUnits().add(throwAssign);
  soot.Local messageLocal=soot.jimple.Jimple.v().newLocal(""String_Node_Str"",soot.RefType.v(""String_Node_Str""));
  classBody.getLocals().add(messageLocal);
  soot.SootMethod messageMethToInvoke=soot.Scene.v().getSootClass(""String_Node_Str"").getMethod(""String_Node_Str"",new ArrayList(),soot.RefType.v(""String_Node_Str""));
  soot.jimple.Expr messageInvoke=soot.jimple.Jimple.v().newVirtualInvokeExpr(catchRefLocal,messageMethToInvoke,new ArrayList());
  soot.jimple.Stmt messageAssign=soot.jimple.Jimple.v().newAssignStmt(messageLocal,messageInvoke);
  classBody.getUnits().add(messageAssign);
  paramTypes=new ArrayList();
  paramTypes.add(soot.RefType.v(""String_Node_Str""));
  soot.SootMethod initMethToInvoke=soot.Scene.v().getSootClass(""String_Node_Str"").getMethod(""String_Node_Str"",paramTypes,soot.VoidType.v());
  params=new ArrayList();
  params.add(messageLocal);
  soot.jimple.Expr initInvoke=soot.jimple.Jimple.v().newSpecialInvokeExpr(throwLocal,initMethToInvoke,params);
  soot.jimple.Stmt initStmt=soot.jimple.Jimple.v().newInvokeStmt(initInvoke);
  classBody.getUnits().add(initStmt);
  soot.jimple.Stmt throwStmt=soot.jimple.Jimple.v().newThrowStmt(throwLocal);
  throwStmt.addTag(new soot.tagkit.ThrowCreatedByCompilerTag());
  classBody.getUnits().add(throwStmt);
  soot.Trap trap=soot.jimple.Jimple.v().newTrap(soot.Scene.v().getSootClass(""String_Node_Str""),assign,retStmt,caughtIdentity);
  classBody.getTraps().add(trap);
  return classBody;
}"
88705,"/** 
 * Used to add an edge to the call graph. Returns true iff the edge was not already present. 
 */
public boolean addEdge(Edge e){
  if (!edges.add(e))   return false;
  stream.add(e);
  Edge position=null;
  if (e.srcUnit() != null) {
    position=(Edge)srcUnitToEdge.get(e.srcUnit());
    if (position == null) {
      srcUnitToEdge.put(e.srcUnit(),e);
      position=(Edge)srcMethodToEdge.get(e.getSrc());
      if (position == null) {
        srcMethodToEdge.put(e.getSrc(),e);
        position=dummy;
      }
    }
  }
 else {
    position=(Edge)srcMethodToEdge.get(e.getSrc());
    if (position == null) {
      srcMethodToEdge.put(e.getSrc(),e);
      position=dummy;
    }
  }
  e.insertAfterBySrc(position);
  position=(Edge)tgtToEdge.get(e.getTgt());
  if (position == null) {
    tgtToEdge.put(e.getTgt(),e);
    position=dummy;
  }
  e.insertAfterByTgt(position);
  return true;
}","/** 
 * Used to add an edge to the call graph. Returns true iff the edge was not already present. 
 */
public boolean addEdge(Edge e){
  if (!edges.add(e))   return false;
  stream.add(e);
  Edge position=null;
  if (e.srcUnit() != null) {
    position=(Edge)srcUnitToEdge.get(e.srcUnit());
    if (position == null) {
      srcUnitToEdge.put(e.srcUnit(),e);
      position=(Edge)srcMethodToEdge.get(e.getSrc());
      if (position == null) {
        srcMethodToEdge.put(e.getSrc(),e);
        position=dummy;
      }
 else {
        while (position.nextBySrc().getSrc() == e.getSrc()) {
          position=position.nextBySrc();
        }
      }
    }
  }
 else {
    position=(Edge)srcMethodToEdge.get(e.getSrc());
    if (position == null) {
      srcMethodToEdge.put(e.getSrc(),e);
      position=dummy;
    }
 else {
      while (position.nextBySrc().getSrc() == e.getSrc()) {
        position=position.nextBySrc();
      }
    }
  }
  e.insertAfterBySrc(position);
  position=(Edge)tgtToEdge.get(e.getTgt());
  if (position == null) {
    tgtToEdge.put(e.getTgt(),e);
    position=dummy;
  }
  e.insertAfterByTgt(position);
  return true;
}"
88706,"/** 
 * Returns only the application entry points, not including entry points invoked implicitly by the VM. 
 */
public List application(){
  List ret=new ArrayList();
  addMethod(ret,Scene.v().getMainClass(),sigMain);
  addMethod(ret,Scene.v().getMainClass(),sigClinit);
  return ret;
}","/** 
 * Returns only the application entry points, not including entry points invoked implicitly by the VM. 
 */
public List application(){
  List ret=new ArrayList();
  addMethod(ret,Scene.v().getMainClass(),sigMain);
  for (Iterator clinitIt=clinitsOf(Scene.v().getMainClass()).iterator(); clinitIt.hasNext(); ) {
    final SootMethod clinit=(SootMethod)clinitIt.next();
    ret.add(clinit);
  }
  return ret;
}"
88707,"public void addStringConstant(Local l,Object srcContext,String constant){
  for (Iterator siteIt=((Collection)stringConstToSites.get(l)).iterator(); siteIt.hasNext(); ) {
    final VirtualCallSite site=(VirtualCallSite)siteIt.next();
    if (constant == null) {
      if (options.verbose()) {
        G.v().out.println(""String_Node_Str"" + site.getContainer() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      }
    }
 else {
      if (constant.charAt(0) == '[') {
        if (constant.length() > 1 && constant.charAt(1) == 'L' && constant.charAt(constant.length() - 1) == ';') {
          constant=constant.substring(2,constant.length() - 1);
        }
 else         continue;
      }
      if (!Scene.v().containsClass(constant)) {
        if (options.verbose()) {
          G.v().out.println(""String_Node_Str"" + constant + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
        }
      }
 else {
        SootClass sootcls=Scene.v().getSootClass(constant);
        if (!sootcls.isApplicationClass()) {
          sootcls.setLibraryClass();
        }
        if (sootcls.declaresMethod(sigClinit)) {
          cm.addStaticEdge(MethodContext.v(site.getContainer(),srcContext),site.getStmt(),sootcls.getMethod(sigClinit),Edge.CLINIT);
        }
      }
    }
  }
}","public void addStringConstant(Local l,Object srcContext,String constant){
  for (Iterator siteIt=((Collection)stringConstToSites.get(l)).iterator(); siteIt.hasNext(); ) {
    final VirtualCallSite site=(VirtualCallSite)siteIt.next();
    if (constant == null) {
      if (options.verbose()) {
        G.v().out.println(""String_Node_Str"" + site.getContainer() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      }
    }
 else {
      if (constant.charAt(0) == '[') {
        if (constant.length() > 1 && constant.charAt(1) == 'L' && constant.charAt(constant.length() - 1) == ';') {
          constant=constant.substring(2,constant.length() - 1);
        }
 else         continue;
      }
      if (!Scene.v().containsClass(constant)) {
        if (options.verbose()) {
          G.v().out.println(""String_Node_Str"" + constant + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
        }
      }
 else {
        SootClass sootcls=Scene.v().getSootClass(constant);
        if (!sootcls.isApplicationClass()) {
          sootcls.setLibraryClass();
        }
        for (Iterator clinitIt=EntryPoints.v().clinitsOf(sootcls).iterator(); clinitIt.hasNext(); ) {
          final SootMethod clinit=(SootMethod)clinitIt.next();
          cm.addStaticEdge(MethodContext.v(site.getContainer(),srcContext),site.getStmt(),clinit,Edge.CLINIT);
        }
      }
    }
  }
}"
88708,"private void getImplicitTargets(SootMethod source){
  List stringConstants=(List)methodToStringConstants.get(source);
  if (stringConstants == null)   methodToStringConstants.put(source,stringConstants=new ArrayList());
  final SootClass scl=source.getDeclaringClass();
  if (source.isNative() || source.isPhantom())   return;
  if (source.getSubSignature().indexOf(""String_Node_Str"") >= 0) {
    handleInit(source,scl);
  }
  Body b=source.retrieveActiveBody();
  boolean warnedAlready=false;
  for (Iterator sIt=b.getUnits().iterator(); sIt.hasNext(); ) {
    final Stmt s=(Stmt)sIt.next();
    if (s.containsInvokeExpr()) {
      InvokeExpr ie=(InvokeExpr)s.getInvokeExpr();
      if (ie.getMethod().getSignature().equals(""String_Node_Str"")) {
        if (!warnedAlready) {
          if (options.verbose()) {
            G.v().out.println(""String_Node_Str"" + ""String_Node_Str"" + source + ""String_Node_Str"");
          }
          warnedAlready=true;
        }
      }
      if (ie.getMethod().getSignature().equals(""String_Node_Str"")) {
        if (options.safe_newinstance()) {
          for (Iterator tgtIt=EntryPoints.v().inits().iterator(); tgtIt.hasNext(); ) {
            final SootMethod tgt=(SootMethod)tgtIt.next();
            cicg.addEdge(new Edge(source,s,tgt,Edge.NEWINSTANCE));
          }
        }
 else {
          if (options.verbose()) {
            G.v().out.println(""String_Node_Str"" + source + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
          }
        }
      }
      if (ie instanceof StaticInvokeExpr) {
        addEdge(source,s,ie.getMethod().getDeclaringClass(),sigClinit,Edge.CLINIT);
      }
      if (ie.getMethod().getNumberedSubSignature() == sigForName) {
        Value className=ie.getArg(0);
        if (className instanceof StringConstant) {
          String cls=((StringConstant)className).value;
          constantForName(cls,source,s);
        }
 else {
          Local constant=(Local)className;
          if (options.safe_forname()) {
            for (Iterator tgtIt=EntryPoints.v().clinits().iterator(); tgtIt.hasNext(); ) {
              final SootMethod tgt=(SootMethod)tgtIt.next();
              cicg.addEdge(new Edge(source,s,tgt,Edge.CLINIT));
            }
          }
 else {
            VirtualCallSite site=new VirtualCallSite(s,source);
            List sites=(List)stringConstToSites.get(constant);
            if (sites == null) {
              stringConstToSites.put(constant,sites=new ArrayList());
              stringConstants.add(constant);
            }
            sites.add(site);
          }
        }
      }
    }
    if (s.containsFieldRef()) {
      FieldRef fr=(FieldRef)s.getFieldRef();
      if (fr instanceof StaticFieldRef) {
        SootClass cl=fr.getField().getDeclaringClass();
        addEdge(source,s,cl,sigClinit,Edge.CLINIT);
      }
    }
    if (s instanceof AssignStmt) {
      Value rhs=((AssignStmt)s).getRightOp();
      if (rhs instanceof NewExpr) {
        NewExpr r=(NewExpr)rhs;
        addEdge(source,s,r.getBaseType().getSootClass(),sigClinit,Edge.CLINIT);
      }
 else       if (rhs instanceof NewArrayExpr || rhs instanceof NewMultiArrayExpr) {
        Type t=rhs.getType();
        if (t instanceof ArrayType)         t=((ArrayType)t).baseType;
        if (t instanceof RefType) {
          addEdge(source,s,((RefType)t).getSootClass(),sigClinit,Edge.CLINIT);
        }
      }
    }
  }
}","private void getImplicitTargets(SootMethod source){
  List stringConstants=(List)methodToStringConstants.get(source);
  if (stringConstants == null)   methodToStringConstants.put(source,stringConstants=new ArrayList());
  final SootClass scl=source.getDeclaringClass();
  if (source.isNative() || source.isPhantom())   return;
  if (source.getSubSignature().indexOf(""String_Node_Str"") >= 0) {
    handleInit(source,scl);
  }
  Body b=source.retrieveActiveBody();
  boolean warnedAlready=false;
  for (Iterator sIt=b.getUnits().iterator(); sIt.hasNext(); ) {
    final Stmt s=(Stmt)sIt.next();
    if (s.containsInvokeExpr()) {
      InvokeExpr ie=(InvokeExpr)s.getInvokeExpr();
      if (ie.getMethod().getSignature().equals(""String_Node_Str"")) {
        if (!warnedAlready) {
          if (options.verbose()) {
            G.v().out.println(""String_Node_Str"" + ""String_Node_Str"" + source + ""String_Node_Str"");
          }
          warnedAlready=true;
        }
      }
      if (ie.getMethod().getSignature().equals(""String_Node_Str"")) {
        if (options.safe_newinstance()) {
          for (Iterator tgtIt=EntryPoints.v().inits().iterator(); tgtIt.hasNext(); ) {
            final SootMethod tgt=(SootMethod)tgtIt.next();
            cicg.addEdge(new Edge(source,s,tgt,Edge.NEWINSTANCE));
          }
        }
 else {
          if (options.verbose()) {
            G.v().out.println(""String_Node_Str"" + source + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
          }
        }
      }
      if (ie instanceof StaticInvokeExpr) {
        SootClass cl=ie.getMethod().getDeclaringClass();
        for (Iterator clinitIt=EntryPoints.v().clinitsOf(cl).iterator(); clinitIt.hasNext(); ) {
          final SootMethod clinit=(SootMethod)clinitIt.next();
          cicg.addEdge(new Edge(source,s,clinit,Edge.CLINIT));
        }
      }
      if (ie.getMethod().getNumberedSubSignature() == sigForName) {
        Value className=ie.getArg(0);
        if (className instanceof StringConstant) {
          String cls=((StringConstant)className).value;
          constantForName(cls,source,s);
        }
 else {
          Local constant=(Local)className;
          if (options.safe_forname()) {
            for (Iterator tgtIt=EntryPoints.v().clinits().iterator(); tgtIt.hasNext(); ) {
              final SootMethod tgt=(SootMethod)tgtIt.next();
              cicg.addEdge(new Edge(source,s,tgt,Edge.CLINIT));
            }
          }
 else {
            VirtualCallSite site=new VirtualCallSite(s,source);
            List sites=(List)stringConstToSites.get(constant);
            if (sites == null) {
              stringConstToSites.put(constant,sites=new ArrayList());
              stringConstants.add(constant);
            }
            sites.add(site);
          }
        }
      }
    }
    if (s.containsFieldRef()) {
      FieldRef fr=(FieldRef)s.getFieldRef();
      if (fr instanceof StaticFieldRef) {
        SootClass cl=fr.getField().getDeclaringClass();
        for (Iterator clinitIt=EntryPoints.v().clinitsOf(cl).iterator(); clinitIt.hasNext(); ) {
          final SootMethod clinit=(SootMethod)clinitIt.next();
          cicg.addEdge(new Edge(source,s,clinit,Edge.CLINIT));
        }
      }
    }
    if (s instanceof AssignStmt) {
      Value rhs=((AssignStmt)s).getRightOp();
      if (rhs instanceof NewExpr) {
        NewExpr r=(NewExpr)rhs;
        SootClass cl=r.getBaseType().getSootClass();
        for (Iterator clinitIt=EntryPoints.v().clinitsOf(cl).iterator(); clinitIt.hasNext(); ) {
          final SootMethod clinit=(SootMethod)clinitIt.next();
          cicg.addEdge(new Edge(source,s,clinit,Edge.CLINIT));
        }
      }
 else       if (rhs instanceof NewArrayExpr || rhs instanceof NewMultiArrayExpr) {
        Type t=rhs.getType();
        if (t instanceof ArrayType)         t=((ArrayType)t).baseType;
        if (t instanceof RefType) {
          SootClass cl=((RefType)t).getSootClass();
          for (Iterator clinitIt=EntryPoints.v().clinitsOf(cl).iterator(); clinitIt.hasNext(); ) {
            final SootMethod clinit=(SootMethod)clinitIt.next();
            cicg.addEdge(new Edge(source,s,clinit,Edge.CLINIT));
          }
        }
      }
    }
  }
}"
88709,"private void constantForName(String cls,SootMethod src,Stmt srcUnit){
  if (cls.charAt(0) == '[') {
    if (cls.charAt(1) == 'L' && cls.charAt(cls.length() - 1) == ';') {
      cls=cls.substring(2,cls.length() - 1);
      constantForName(cls,src,srcUnit);
    }
  }
 else {
    if (!Scene.v().containsClass(cls)) {
      if (options.verbose()) {
        G.v().out.println(""String_Node_Str"" + cls + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      }
    }
 else {
      SootClass sootcls=Scene.v().getSootClass(cls);
      if (!sootcls.isApplicationClass()) {
        sootcls.setLibraryClass();
      }
      addEdge(src,srcUnit,sootcls,sigClinit,Edge.CLINIT);
    }
  }
}","private void constantForName(String cls,SootMethod src,Stmt srcUnit){
  if (cls.charAt(0) == '[') {
    if (cls.charAt(1) == 'L' && cls.charAt(cls.length() - 1) == ';') {
      cls=cls.substring(2,cls.length() - 1);
      constantForName(cls,src,srcUnit);
    }
  }
 else {
    if (!Scene.v().containsClass(cls)) {
      if (options.verbose()) {
        G.v().out.println(""String_Node_Str"" + cls + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      }
    }
 else {
      SootClass sootcls=Scene.v().getSootClass(cls);
      if (!sootcls.isApplicationClass()) {
        sootcls.setLibraryClass();
      }
      for (Iterator clinitIt=EntryPoints.v().clinitsOf(sootcls).iterator(); clinitIt.hasNext(); ) {
        final SootMethod clinit=(SootMethod)clinitIt.next();
        cicg.addEdge(new Edge(src,srcUnit,clinit,Edge.CLINIT));
      }
    }
  }
}"
88710,"/** 
 * Look for the specified class. Return a ClassSource for it if found, or null if it was not found. 
 */
public ClassSource find(String className){
  String fileName=className.replace('.',File.separatorChar) + ""String_Node_Str"";
  SourceLocator.FoundFile file=SourceLocator.v().lookupInClassPath(className);
  if (file == null)   return null;
  return new CoffiClassSource(className,file.inputStream());
}","/** 
 * Look for the specified class. Return a ClassSource for it if found, or null if it was not found. 
 */
public ClassSource find(String className){
  String fileName=className.replace('.',File.separatorChar) + ""String_Node_Str"";
  SourceLocator.FoundFile file=SourceLocator.v().lookupInClassPath(fileName);
  if (file == null)   return null;
  return new CoffiClassSource(className,file.inputStream());
}"
88711,"/** 
 * Look for the specified class. Return a ClassSource for it if found, or null if it was not found. 
 */
public ClassSource find(String className){
  String javaClassName=className;
  if (className.indexOf(""String_Node_Str"") != -1) {
    javaClassName=className.substring(0,className.indexOf(""String_Node_Str""));
  }
  if (SourceLocator.v().getSourceToClassMap() != null) {
    if (SourceLocator.v().getSourceToClassMap().get(javaClassName) != null) {
      javaClassName=(String)SourceLocator.v().getSourceToClassMap().get(javaClassName);
    }
  }
  String fileName=javaClassName.replace('.',File.separatorChar) + ""String_Node_Str"";
  SourceLocator.FoundFile file=SourceLocator.v().lookupInClassPath(className);
  if (file == null)   return null;
  if (file.file == null) {
    throw new RuntimeException(""String_Node_Str"" + className + ""String_Node_Str"");
  }
  return new JavaClassSource(className,file.file);
}","/** 
 * Look for the specified class. Return a ClassSource for it if found, or null if it was not found. 
 */
public ClassSource find(String className){
  String javaClassName=className;
  if (className.indexOf(""String_Node_Str"") != -1) {
    javaClassName=className.substring(0,className.indexOf(""String_Node_Str""));
  }
  if (SourceLocator.v().getSourceToClassMap() != null) {
    if (SourceLocator.v().getSourceToClassMap().get(javaClassName) != null) {
      javaClassName=(String)SourceLocator.v().getSourceToClassMap().get(javaClassName);
    }
  }
  String fileName=javaClassName.replace('.',File.separatorChar) + ""String_Node_Str"";
  SourceLocator.FoundFile file=SourceLocator.v().lookupInClassPath(fileName);
  if (file == null)   return null;
  if (file.file == null) {
    throw new RuntimeException(""String_Node_Str"" + className + ""String_Node_Str"");
  }
  return new JavaClassSource(className,file.file);
}"
88712,"public void resolve(SootClass sc){
  if (Options.v().verbose())   G.v().out.println(""String_Node_Str"" + className);
  SootResolver.v().getInitSourceResolver().formAst(fullPath.getPath(),SourceLocator.v().classPath());
  SootResolver.v().getInitSourceResolver().resolveFromJavaFile(sc);
}","public void resolve(SootClass sc){
  if (Options.v().verbose())   G.v().out.println(""String_Node_Str"" + className);
  SootResolver.v().getInitSourceResolver().formAst(fullPath.getPath(),SourceLocator.v().sourcePath());
  SootResolver.v().getInitSourceResolver().resolveFromJavaFile(sc);
}"
88713,"/** 
 * Look for the specified class. Return a ClassSource for it if found, or null if it was not found. 
 */
public ClassSource find(String className){
  String fileName=className.replace('.',File.separatorChar) + ""String_Node_Str"";
  SourceLocator.FoundFile file=SourceLocator.v().lookupInClassPath(className);
  if (file == null)   return null;
  return new JimpleClassSource(className,file.inputStream());
}","/** 
 * Look for the specified class. Return a ClassSource for it if found, or null if it was not found. 
 */
public ClassSource find(String className){
  String fileName=className.replace('.',File.separatorChar) + ""String_Node_Str"";
  SourceLocator.FoundFile file=SourceLocator.v().lookupInClassPath(fileName);
  if (file == null)   return null;
  return new JimpleClassSource(className,file.inputStream());
}"
88714,"private FoundFile lookupInDir(String dir,String fileName){
  File f=new File(dir + fileName);
  if (f.canRead()) {
    return new FoundFile(f);
  }
  return null;
}","private FoundFile lookupInDir(String dir,String fileName){
  File f=new File(dir + File.separatorChar + fileName);
  if (f.canRead()) {
    return new FoundFile(f);
  }
  return null;
}"
88715,"public InputStream inputStream(){
  try {
    if (file != null)     return new FileInputStream(file);
    return zipFile.getInputStream(entry);
  }
 catch (  IOException e) {
    throw new RuntimeException(""String_Node_Str"" + e);
  }
}","public InputStream inputStream(){
  try {
    if (file != null)     return new FileInputStream(file);
    return doJDKBugWorkaround(zipFile.getInputStream(entry),entry.getSize());
  }
 catch (  IOException e) {
    throw new RuntimeException(""String_Node_Str"" + e);
  }
}"
88716,"public soot.Body getBody(soot.SootMethod sootMethod,String phaseName){
  soot.Body body=soot.jimple.Jimple.v().newBody(sootMethod);
  soot.RefType type=sootMethod.getDeclaringClass().getType();
  soot.Local thisLocal=soot.jimple.Jimple.v().newLocal(""String_Node_Str"",type);
  body.getLocals().add(thisLocal);
  soot.jimple.ThisRef thisRef=soot.jimple.Jimple.v().newThisRef(type);
  soot.jimple.Stmt thisStmt=soot.jimple.Jimple.v().newIdentityStmt(thisLocal,thisRef);
  body.getUnits().add(thisStmt);
  ArrayList invokeList=new ArrayList();
  ArrayList invokeTypeList=new ArrayList();
  soot.Local outerLocal=null;
  int numParams=sootMethod.getParameterCount();
  int numFinals=0;
  if (fields != null) {
    numFinals=fields.size();
  }
  int startFinals=numParams - numFinals;
  ArrayList paramsForFinals=new ArrayList();
  Iterator fIt=sootMethod.getParameterTypes().iterator();
  int counter=0;
  while (fIt.hasNext()) {
    soot.Type fType=(soot.Type)fIt.next();
    soot.Local local=soot.jimple.Jimple.v().newLocal(""String_Node_Str"" + counter,fType);
    body.getLocals().add(local);
    soot.jimple.ParameterRef paramRef=soot.jimple.Jimple.v().newParameterRef(fType,counter);
    soot.jimple.Stmt stmt=soot.jimple.Jimple.v().newIdentityStmt(local,paramRef);
    if ((counter != 0) && (counter < startFinals)) {
      invokeTypeList.add(fType);
      invokeList.add(local);
    }
 else     if (counter == 0) {
      outerLocal=local;
    }
 else {
      paramsForFinals.add(local);
    }
    body.getUnits().add(stmt);
    counter++;
  }
  soot.SootMethod callMethod=sootMethod.getDeclaringClass().getSuperclass().getMethod(""String_Node_Str"",invokeTypeList,soot.VoidType.v());
  soot.jimple.InvokeExpr invoke=soot.jimple.Jimple.v().newSpecialInvokeExpr(thisLocal,callMethod,invokeList);
  soot.jimple.Stmt invokeStmt=soot.jimple.Jimple.v().newInvokeStmt(invoke);
  body.getUnits().add(invokeStmt);
  soot.SootField field=sootMethod.getDeclaringClass().getField(""String_Node_Str"",outerClassType);
  soot.jimple.InstanceFieldRef ref=soot.jimple.Jimple.v().newInstanceFieldRef(thisLocal,field);
  soot.jimple.AssignStmt assign=soot.jimple.Jimple.v().newAssignStmt(ref,outerLocal);
  body.getUnits().add(assign);
  if (fields != null) {
    Iterator finalsIt=paramsForFinals.iterator();
    Iterator fieldsIt=fields.iterator();
    while (finalsIt.hasNext() && fieldsIt.hasNext()) {
      soot.Local pLocal=(soot.Local)finalsIt.next();
      soot.SootField pField=(soot.SootField)fieldsIt.next();
      soot.jimple.FieldRef pRef=soot.jimple.Jimple.v().newInstanceFieldRef(thisLocal,pField);
      soot.jimple.AssignStmt pAssign=soot.jimple.Jimple.v().newAssignStmt(pRef,pLocal);
      body.getUnits().add(pAssign);
    }
  }
  soot.jimple.ReturnVoidStmt retStmt=soot.jimple.Jimple.v().newReturnVoidStmt();
  body.getUnits().add(retStmt);
  PackManager.v().getPack(""String_Node_Str"").apply(body);
  return body;
}","public soot.Body getBody(soot.SootMethod sootMethod,String phaseName){
  soot.Body body=soot.jimple.Jimple.v().newBody(sootMethod);
  soot.RefType type=sootMethod.getDeclaringClass().getType();
  soot.Local thisLocal=soot.jimple.Jimple.v().newLocal(""String_Node_Str"",type);
  body.getLocals().add(thisLocal);
  soot.jimple.ThisRef thisRef=soot.jimple.Jimple.v().newThisRef(type);
  soot.jimple.Stmt thisStmt=soot.jimple.Jimple.v().newIdentityStmt(thisLocal,thisRef);
  body.getUnits().add(thisStmt);
  ArrayList invokeList=new ArrayList();
  ArrayList invokeTypeList=new ArrayList();
  soot.Local outerLocal=null;
  int numParams=sootMethod.getParameterCount();
  int numFinals=0;
  if (fields != null) {
    numFinals=fields.size();
  }
  int startFinals=numParams - numFinals;
  ArrayList paramsForFinals=new ArrayList();
  Iterator fIt=sootMethod.getParameterTypes().iterator();
  int counter=0;
  while (fIt.hasNext()) {
    soot.Type fType=(soot.Type)fIt.next();
    soot.Local local=soot.jimple.Jimple.v().newLocal(""String_Node_Str"" + counter,fType);
    body.getLocals().add(local);
    soot.jimple.ParameterRef paramRef=soot.jimple.Jimple.v().newParameterRef(fType,counter);
    soot.jimple.Stmt stmt=soot.jimple.Jimple.v().newIdentityStmt(local,paramRef);
    if ((counter != 0) && (counter < startFinals)) {
      invokeTypeList.add(fType);
      invokeList.add(local);
    }
 else     if (counter == 0) {
      outerLocal=local;
    }
 else {
      paramsForFinals.add(local);
    }
    body.getUnits().add(stmt);
    counter++;
  }
  soot.SootMethod callMethod=sootMethod.getDeclaringClass().getSuperclass().getMethod(""String_Node_Str"",invokeTypeList,soot.VoidType.v());
  soot.jimple.InvokeExpr invoke=soot.jimple.Jimple.v().newSpecialInvokeExpr(thisLocal,callMethod,invokeList);
  soot.jimple.Stmt invokeStmt=soot.jimple.Jimple.v().newInvokeStmt(invoke);
  body.getUnits().add(invokeStmt);
  if (!inStaticMethod) {
    soot.SootField field=sootMethod.getDeclaringClass().getField(""String_Node_Str"",outerClassType);
    soot.jimple.InstanceFieldRef ref=soot.jimple.Jimple.v().newInstanceFieldRef(thisLocal,field);
    soot.jimple.AssignStmt assign=soot.jimple.Jimple.v().newAssignStmt(ref,outerLocal);
    body.getUnits().add(assign);
  }
  if (fields != null) {
    Iterator finalsIt=paramsForFinals.iterator();
    Iterator fieldsIt=fields.iterator();
    while (finalsIt.hasNext() && fieldsIt.hasNext()) {
      soot.Local pLocal=(soot.Local)finalsIt.next();
      soot.SootField pField=(soot.SootField)fieldsIt.next();
      soot.jimple.FieldRef pRef=soot.jimple.Jimple.v().newInstanceFieldRef(thisLocal,pField);
      soot.jimple.AssignStmt pAssign=soot.jimple.Jimple.v().newAssignStmt(pRef,pLocal);
      body.getUnits().add(pAssign);
    }
  }
  soot.jimple.ReturnVoidStmt retStmt=soot.jimple.Jimple.v().newReturnVoidStmt();
  body.getUnits().add(retStmt);
  PackManager.v().getPack(""String_Node_Str"").apply(body);
  return body;
}"
88717,"/** 
 * creates the Jimple for an anon class - in the AST there is no class  decl for anon classes - the revelant fields and methods are  created 
 */
private void createAnonClassDecl(polyglot.types.Type type,String outerName,polyglot.ast.New next){
  soot.SootClass typeClass=soot.Scene.v().getSootClass(type.toString());
  if (typeClass.isInterface()) {
    sootClass.addInterface(typeClass);
    sootClass.setSuperclass(soot.Scene.v().getSootClass(""String_Node_Str""));
  }
 else {
    sootClass.setSuperclass(typeClass);
  }
  soot.SootField field=new soot.SootField(""String_Node_Str"",soot.Scene.v().getSootClass(outerName).getType(),soot.Modifier.FINAL | soot.Modifier.PRIVATE);
  sootClass.addField(field);
  ArrayList finalLocalsFields=new ArrayList();
  if (finalsMap != null) {
    if (finalsMap.containsKey(next)) {
      ArrayList finalLocals=(ArrayList)finalsMap.get(next);
      Iterator fIt=finalLocals.iterator();
      while (fIt.hasNext()) {
        polyglot.types.LocalInstance li=(polyglot.types.LocalInstance)((polyglot.util.IdentityKey)fIt.next()).object();
        soot.SootField sf=new soot.SootField(""String_Node_Str"" + li.name(),Util.getSootType(li.type()),soot.Modifier.FINAL | soot.Modifier.PRIVATE);
        finalLocalsFields.add(sf);
        sootClass.addField(sf);
      }
    }
  }
  ArrayList params=new ArrayList();
  params.add(soot.Scene.v().getSootClass(outerName).getType());
  if (finalsMap != null) {
    if (finalsMap.containsKey(next)) {
      ArrayList finalLocals=(ArrayList)finalsMap.get(next);
      Iterator fIt=finalLocals.iterator();
      while (fIt.hasNext()) {
        params.add(Util.getSootType(((polyglot.types.LocalInstance)((polyglot.util.IdentityKey)fIt.next()).object()).type()));
      }
    }
  }
  if (typeClass.isInterface()) {
    soot.SootMethod method=new soot.SootMethod(""String_Node_Str"",params,soot.VoidType.v());
    AnonClassInitMethodSource src=new AnonClassInitMethodSource();
    src.outerClassType(soot.Scene.v().getSootClass(outerName).getType());
    method.setSource(src);
    sootClass.addMethod(method);
  }
 else {
    ArrayList allParams=new ArrayList();
    allParams.add(soot.Scene.v().getSootClass(outerName).getType());
    Iterator aIt=next.arguments().iterator();
    while (aIt.hasNext()) {
      polyglot.types.Type pType=((polyglot.ast.Expr)aIt.next()).type();
      allParams.add(Util.getSootType(pType));
    }
    if (finalsMap != null) {
      if (finalsMap.containsKey(next)) {
        ArrayList finalLocals=(ArrayList)finalsMap.get(next);
        Iterator fIt=finalLocals.iterator();
        while (fIt.hasNext()) {
          allParams.add(Util.getSootType(((polyglot.types.LocalInstance)((polyglot.util.IdentityKey)fIt.next()).object()).type()));
        }
      }
    }
    soot.SootMethod method=new soot.SootMethod(""String_Node_Str"",allParams,soot.VoidType.v());
    AnonClassInitMethodSource src=new AnonClassInitMethodSource();
    src.outerClassType(soot.Scene.v().getSootClass(outerName).getType());
    src.setFieldList(finalLocalsFields);
    method.setSource(src);
    sootClass.addMethod(method);
  }
}","/** 
 * creates the Jimple for an anon class - in the AST there is no class  decl for anon classes - the revelant fields and methods are  created 
 */
private void createAnonClassDecl(polyglot.types.Type type,String outerName,polyglot.ast.New next){
  soot.SootClass typeClass=soot.Scene.v().getSootClass(type.toString());
  if (typeClass.isInterface()) {
    sootClass.addInterface(typeClass);
    sootClass.setSuperclass(soot.Scene.v().getSootClass(""String_Node_Str""));
  }
 else {
    sootClass.setSuperclass(typeClass);
  }
  ArrayList finalLocalsFields=new ArrayList();
  ArrayList params=new ArrayList();
  ArrayList allParams=new ArrayList();
  if (finalsMap != null) {
    if (finalsMap.containsKey(next)) {
      AnonLocalClassInfo info=(AnonLocalClassInfo)finalsMap.get(next);
      if (!info.inStaticMethod()) {
        soot.SootField field=new soot.SootField(""String_Node_Str"",soot.Scene.v().getSootClass(outerName).getType(),soot.Modifier.FINAL | soot.Modifier.PRIVATE);
        sootClass.addField(field);
      }
      Iterator fIt=info.finalFields().iterator();
      while (fIt.hasNext()) {
        polyglot.types.LocalInstance li=(polyglot.types.LocalInstance)((polyglot.util.IdentityKey)fIt.next()).object();
        soot.SootField sf=new soot.SootField(""String_Node_Str"" + li.name(),Util.getSootType(li.type()),soot.Modifier.FINAL | soot.Modifier.PRIVATE);
        finalLocalsFields.add(sf);
        sootClass.addField(sf);
      }
      if (!info.inStaticMethod()) {
        params.add(soot.Scene.v().getSootClass(outerName).getType());
      }
      ArrayList finalLocals=info.finalFields();
      Iterator fIt2=finalLocals.iterator();
      while (fIt2.hasNext()) {
        params.add(Util.getSootType(((polyglot.types.LocalInstance)((polyglot.util.IdentityKey)fIt2.next()).object()).type()));
      }
    }
  }
  if (typeClass.isInterface()) {
    soot.SootMethod method=new soot.SootMethod(""String_Node_Str"",params,soot.VoidType.v());
    AnonClassInitMethodSource src=new AnonClassInitMethodSource();
    src.outerClassType(soot.Scene.v().getSootClass(outerName).getType());
    method.setSource(src);
    sootClass.addMethod(method);
  }
 else {
    if (finalsMap != null) {
      if (finalsMap.containsKey(next)) {
        AnonLocalClassInfo info=(AnonLocalClassInfo)finalsMap.get(next);
        if (!info.inStaticMethod()) {
          allParams.add(soot.Scene.v().getSootClass(outerName).getType());
        }
        Iterator aIt=next.arguments().iterator();
        while (aIt.hasNext()) {
          polyglot.types.Type pType=((polyglot.ast.Expr)aIt.next()).type();
          allParams.add(Util.getSootType(pType));
        }
        ArrayList finalLocals=info.finalFields();
        Iterator fIt=finalLocals.iterator();
        while (fIt.hasNext()) {
          allParams.add(Util.getSootType(((polyglot.types.LocalInstance)((polyglot.util.IdentityKey)fIt.next()).object()).type()));
        }
      }
    }
    soot.SootMethod method=new soot.SootMethod(""String_Node_Str"",allParams,soot.VoidType.v());
    AnonClassInitMethodSource src=new AnonClassInitMethodSource();
    src.outerClassType(soot.Scene.v().getSootClass(outerName).getType());
    src.setFieldList(finalLocalsFields);
    if (finalsMap != null) {
      if (finalsMap.containsKey(next)) {
        AnonLocalClassInfo info=(AnonLocalClassInfo)finalsMap.get(next);
        src.inStaticMethod(info.inStaticMethod());
      }
    }
    method.setSource(src);
    sootClass.addMethod(method);
  }
}"
88718,"/** 
 * looks after pos tags for methods and constructors
 */
private void finishProcedure(polyglot.ast.ProcedureDecl procedure,soot.SootMethod sootMethod){
  addProcedureToClass(sootMethod);
  if (procedure.position() != null) {
    if (procedure.body() != null) {
      if (procedure.body().position() != null) {
        Util.addLnPosTags(sootMethod,procedure.position().line(),procedure.body().position().endLine(),procedure.position().column(),procedure.body().position().endColumn());
      }
    }
  }
  MethodFinalsChecker mfc=new MethodFinalsChecker();
  mfc.setCurrentSootClass(sootClass.getName());
  if (procedure.body() != null) {
    procedure.body().visit(mfc);
  }
  if (newToOuterMap == null) {
    newToOuterMap=new HashMap();
  }
  if (mfc.getNewToOuter().keySet() != null) {
    Iterator newIt=mfc.getNewToOuter().keySet().iterator();
    while (newIt.hasNext()) {
      Object next=newIt.next();
      newToOuterMap.put(next,mfc.getNewToOuter().get(next));
    }
  }
  if ((mfc.getLocals() != null) && (mfc.getClassNames() != null)) {
    if (finalsMap == null) {
      finalsMap=new HashMap();
    }
    Iterator it=mfc.getClassNames().iterator();
    while (it.hasNext()) {
      ArrayList finalLocals=new ArrayList();
      polyglot.ast.New key=(polyglot.ast.New)it.next();
      LocalUsesChecker luc=new LocalUsesChecker();
      key.body().visit(luc);
      Iterator localsIt=luc.getLocals().iterator();
      while (localsIt.hasNext()) {
        polyglot.types.LocalInstance testLocal=(polyglot.types.LocalInstance)((polyglot.util.IdentityKey)localsIt.next()).object();
        if (!luc.getLocalDecls().contains(new polyglot.util.IdentityKey(testLocal))) {
          finalLocals.add(new polyglot.util.IdentityKey(testLocal));
        }
      }
      finalsMap.put(key,finalLocals);
    }
  }
  PolyglotMethodSource mSrc=new PolyglotMethodSource(procedure.body(),procedure.formals());
  mSrc.setFinalsMap(finalsMap);
  mSrc.setNewToOuterMap(newToOuterMap);
  mSrc.setPrivateAccessMap(privateAccessMap);
  if (localClassMap != null) {
    mSrc.setLocalClassMap(localClassMap);
  }
  if (anonClassMap != null) {
    mSrc.setAnonClassMap(anonClassMap);
  }
  sootMethod.setSource(mSrc);
}","/** 
 * looks after pos tags for methods and constructors
 */
private void finishProcedure(polyglot.ast.ProcedureDecl procedure,soot.SootMethod sootMethod){
  addProcedureToClass(sootMethod);
  if (procedure.position() != null) {
    if (procedure.body() != null) {
      if (procedure.body().position() != null) {
        Util.addLnPosTags(sootMethod,procedure.position().line(),procedure.body().position().endLine(),procedure.position().column(),procedure.body().position().endColumn());
      }
    }
  }
  MethodFinalsChecker mfc=new MethodFinalsChecker();
  mfc.setCurrentSootClass(sootClass.getName());
  if (procedure.body() != null) {
    procedure.body().visit(mfc);
  }
  if (newToOuterMap == null) {
    newToOuterMap=new HashMap();
  }
  if (mfc.getNewToOuter().keySet() != null) {
    Iterator newIt=mfc.getNewToOuter().keySet().iterator();
    while (newIt.hasNext()) {
      Object next=newIt.next();
      newToOuterMap.put(next,mfc.getNewToOuter().get(next));
    }
  }
  if ((mfc.getLocals() != null) && (mfc.getClassNames() != null)) {
    if (finalsMap == null) {
      finalsMap=new HashMap();
    }
    Iterator it=mfc.getClassNames().iterator();
    while (it.hasNext()) {
      AnonLocalClassInfo alci=new AnonLocalClassInfo();
      ArrayList finalLocals=new ArrayList();
      if (soot.Modifier.isStatic(sootMethod.getModifiers())) {
        alci.inStaticMethod(true);
      }
      polyglot.ast.New key=(polyglot.ast.New)it.next();
      LocalUsesChecker luc=new LocalUsesChecker();
      key.body().visit(luc);
      Iterator localsIt=luc.getLocals().iterator();
      while (localsIt.hasNext()) {
        polyglot.types.LocalInstance testLocal=(polyglot.types.LocalInstance)((polyglot.util.IdentityKey)localsIt.next()).object();
        if (!luc.getLocalDecls().contains(new polyglot.util.IdentityKey(testLocal))) {
          finalLocals.add(new polyglot.util.IdentityKey(testLocal));
        }
      }
      alci.finalFields(finalLocals);
      finalsMap.put(key,alci);
    }
  }
  PolyglotMethodSource mSrc=new PolyglotMethodSource(procedure.body(),procedure.formals());
  mSrc.setFinalsMap(finalsMap);
  mSrc.setNewToOuterMap(newToOuterMap);
  mSrc.setPrivateAccessMap(privateAccessMap);
  if (localClassMap != null) {
    mSrc.setLocalClassMap(localClassMap);
  }
  if (anonClassMap != null) {
    mSrc.setAnonClassMap(anonClassMap);
  }
  sootMethod.setSource(mSrc);
}"
88719,"/** 
 * Adds extra params
 */
private void handleFinalLocalParams(ArrayList sootParams,ArrayList sootParamTypes,soot.SootClass classToInvoke,polyglot.ast.ProcedureCall call){
  HashMap finalsMap=((soot.javaToJimple.PolyglotMethodSource)body.getMethod().getSource()).getFinalsMap();
  if (finalsMap != null) {
    if (finalsMap.containsKey(call)) {
      ArrayList finals=(ArrayList)finalsMap.get(call);
      if (finals != null) {
        Iterator it=finals.iterator();
        while (it.hasNext()) {
          polyglot.types.LocalInstance li=(polyglot.types.LocalInstance)((polyglot.util.IdentityKey)it.next()).object();
          sootParamTypes.add(Util.getSootType(li.type()));
          sootParams.add(getLocal(li));
        }
      }
    }
  }
}","/** 
 * Adds extra params
 */
private void handleFinalLocalParams(ArrayList sootParams,ArrayList sootParamTypes,soot.SootClass classToInvoke,polyglot.ast.ProcedureCall call){
  HashMap finalsMap=((soot.javaToJimple.PolyglotMethodSource)body.getMethod().getSource()).getFinalsMap();
  if (finalsMap != null) {
    if (finalsMap.containsKey(call)) {
      AnonLocalClassInfo info=(AnonLocalClassInfo)finalsMap.get(call);
      ArrayList finals=info.finalFields();
      if (finals != null) {
        Iterator it=finals.iterator();
        while (it.hasNext()) {
          polyglot.types.LocalInstance li=(polyglot.types.LocalInstance)((polyglot.util.IdentityKey)it.next()).object();
          sootParamTypes.add(Util.getSootType(li.type()));
          sootParams.add(getLocal(li));
        }
      }
    }
  }
}"
88720,"public polyglot.ast.Node leave(polyglot.ast.Node old,polyglot.ast.Node n,polyglot.visit.NodeVisitor visitor){
  if (n instanceof polyglot.ast.LocalDecl) {
    localDecls.add(new polyglot.util.IdentityKey(((polyglot.ast.LocalDecl)n).localInstance()));
  }
  if (n instanceof polyglot.ast.Local) {
    locals.add(new polyglot.util.IdentityKey(((polyglot.ast.Local)n).localInstance()));
  }
  if (n instanceof polyglot.ast.Formal) {
    localDecls.add(new polyglot.util.IdentityKey(((polyglot.ast.Formal)n).localInstance()));
  }
  return n;
}","public polyglot.ast.Node leave(polyglot.ast.Node old,polyglot.ast.Node n,polyglot.visit.NodeVisitor visitor){
  if (n instanceof polyglot.ast.LocalDecl) {
    localDecls.add(new polyglot.util.IdentityKey(((polyglot.ast.LocalDecl)n).localInstance()));
  }
  if (n instanceof polyglot.ast.Local) {
    if (!(locals.contains(new polyglot.util.IdentityKey(((polyglot.ast.Local)n).localInstance())))) {
      locals.add(new polyglot.util.IdentityKey(((polyglot.ast.Local)n).localInstance()));
    }
  }
  if (n instanceof polyglot.ast.Formal) {
    localDecls.add(new polyglot.util.IdentityKey(((polyglot.ast.Formal)n).localInstance()));
  }
  return n;
}"
88721,"/** 
 * Expression Creation
 */
private soot.Value createExpr(polyglot.ast.Expr expr){
  if (expr instanceof polyglot.ast.Assign) {
    return getAssignLocal((polyglot.ast.Assign)expr);
  }
 else   if (expr instanceof polyglot.ast.Lit) {
    return createLiteral((polyglot.ast.Lit)expr);
  }
 else   if (expr instanceof polyglot.ast.Local) {
    return getLocal((polyglot.ast.Local)expr);
  }
 else   if (expr instanceof polyglot.ast.Binary) {
    return getBinaryLocal((polyglot.ast.Binary)expr);
  }
 else   if (expr instanceof polyglot.ast.Unary) {
    return getUnaryLocal((polyglot.ast.Unary)expr);
  }
 else   if (expr instanceof polyglot.ast.Cast) {
    return getCastLocal((polyglot.ast.Cast)expr);
  }
 else   if (expr instanceof polyglot.ast.ArrayAccess) {
    return getArrayRefLocal((polyglot.ast.ArrayAccess)expr);
  }
 else   if (expr instanceof polyglot.ast.NewArray) {
    return getNewArrayLocal((polyglot.ast.NewArray)expr);
  }
 else   if (expr instanceof polyglot.ast.Call) {
    return getCallLocal((polyglot.ast.Call)expr);
  }
 else   if (expr instanceof polyglot.ast.New) {
    return getNewLocal((polyglot.ast.New)expr);
  }
 else   if (expr instanceof polyglot.ast.Special) {
    return getSpecialLocal((polyglot.ast.Special)expr);
  }
 else   if (expr instanceof polyglot.ast.Instanceof) {
    return getInstanceOfLocal((polyglot.ast.Instanceof)expr);
  }
 else   if (expr instanceof polyglot.ast.Conditional) {
    return getConditionalLocal((polyglot.ast.Conditional)expr);
  }
 else   if (expr instanceof polyglot.ast.Field) {
    return getFieldLocal((polyglot.ast.Field)expr);
  }
 else {
    throw new RuntimeException(""String_Node_Str"");
  }
}","/** 
 * Expression Creation
 */
private soot.Value createExpr(polyglot.ast.Expr expr){
  if (expr instanceof polyglot.ast.Assign) {
    return getAssignLocal((polyglot.ast.Assign)expr);
  }
 else   if (expr instanceof polyglot.ast.Lit) {
    return createLiteral((polyglot.ast.Lit)expr);
  }
 else   if (expr instanceof polyglot.ast.Local) {
    return getLocal((polyglot.ast.Local)expr);
  }
 else   if (expr instanceof polyglot.ast.Binary) {
    return getBinaryLocal((polyglot.ast.Binary)expr);
  }
 else   if (expr instanceof polyglot.ast.Unary) {
    return getUnaryLocal((polyglot.ast.Unary)expr);
  }
 else   if (expr instanceof polyglot.ast.Cast) {
    return getCastLocal((polyglot.ast.Cast)expr);
  }
 else   if (expr instanceof polyglot.ast.ArrayAccess) {
    return getArrayRefLocal((polyglot.ast.ArrayAccess)expr);
  }
 else   if (expr instanceof polyglot.ast.NewArray) {
    return getNewArrayLocal((polyglot.ast.NewArray)expr);
  }
 else   if (expr instanceof polyglot.ast.Call) {
    return getCallLocal((polyglot.ast.Call)expr);
  }
 else   if (expr instanceof polyglot.ast.New) {
    return getNewLocal((polyglot.ast.New)expr);
  }
 else   if (expr instanceof polyglot.ast.Special) {
    return getSpecialLocal((polyglot.ast.Special)expr);
  }
 else   if (expr instanceof polyglot.ast.Instanceof) {
    return getInstanceOfLocal((polyglot.ast.Instanceof)expr);
  }
 else   if (expr instanceof polyglot.ast.Conditional) {
    return getConditionalLocal((polyglot.ast.Conditional)expr);
  }
 else   if (expr instanceof polyglot.ast.Field) {
    return getFieldLocal((polyglot.ast.Field)expr);
  }
 else {
    System.out.println(""String_Node_Str"" + expr);
    throw new RuntimeException(""String_Node_Str"");
  }
}"
88722,"/** 
 * Given a class name and class-path, returns an input stream for the given class. 
 */
public InputStream getInputStreamOf(String classPath,String className) throws ClassNotFoundException {
  List locations=null;
  if (classPath == previousCP || previousCP.equals(classPath)) {
    locations=previousLocations;
  }
 else {
    previousCP=classPath;
    locations=new ArrayList();
    int sepIndex;
    boolean absolutePath;
    if (classPath == null) {
      classPath=System.getProperty(""String_Node_Str"") + pathSeparator + System.getProperty(""String_Node_Str"")+ fileSeparator+ ""String_Node_Str""+ fileSeparator+ ""String_Node_Str"";
    }
    String userDir=System.getProperty(""String_Node_Str"");
    for (boolean done=false; !done; ) {
      if (classPath.indexOf(fileSeparator) == 0 || (isRunningUnderBraindeadOS && classPath.length() >= 2 && classPath.charAt(1) == ':'))       absolutePath=true;
 else       absolutePath=false;
      sepIndex=classPath.indexOf(pathSeparator);
      String candidate=null;
      if (sepIndex == -1) {
        candidate=classPath;
        done=true;
      }
 else       candidate=classPath.substring(0,sepIndex);
      if (candidate.startsWith(""String_Node_Str"")) {
        if (candidate.startsWith(""String_Node_Str"" + System.getProperty(""String_Node_Str"") + fileSeparator))         candidate=""String_Node_Str"" + fileSeparator + candidate.substring(candidate.indexOf(fileSeparator));
        if (!candidate.startsWith(""String_Node_Str"" + fileSeparator))         throw new RuntimeException(""String_Node_Str"");
        candidate=System.getProperty(""String_Node_Str"") + fileSeparator + candidate.substring(2);
      }
 else       if (!absolutePath)       candidate=userDir + fileSeparator + candidate;
      if (isArchive(candidate)) {
        addArchive(candidate);
      }
 else {
        locations.add(candidate);
      }
      classPath=classPath.substring(sepIndex + 1);
    }
    previousLocations=locations;
  }
  setLocationsFound(locations);
  InputStream res=null;
{
    List jimple=new SingletonList(JimpleInputRep.v());
    List java=new SingletonList(JavaInputRep.v());
    List clss=new SingletonList(ClassInputRep.v());
    String javaClassName=className;
    if (className.indexOf(""String_Node_Str"") != -1) {
      javaClassName=className.substring(0,className.indexOf(""String_Node_Str""));
    }
 else     if (sourceToClassMap != null) {
      if (sourceToClassMap.get(javaClassName) != null) {
        javaClassName=(String)sourceToClassMap.get(javaClassName);
      }
    }
switch (Options.v().src_prec()) {
case Options.src_prec_class:
      if ((res=getFileInputStream(locations,clss,className)) != null)       return res;
    if ((res=getFileInputStream(locations,jimple,className)) != null)     return res;
  if ((res=getFileInputStream(locations,java,javaClassName)) != null)   return res;
break;
case Options.src_prec_java:
if ((res=getFileInputStream(locations,java,javaClassName)) != null) return res;
if ((res=getFileInputStream(locations,clss,className)) != null) return res;
if ((res=getFileInputStream(locations,jimple,className)) != null) return res;
break;
case Options.src_prec_jimple:
if ((res=getFileInputStream(locations,jimple,className)) != null) return res;
if ((res=getFileInputStream(locations,clss,className)) != null) return res;
if ((res=getFileInputStream(locations,java,javaClassName)) != null) return res;
break;
default :
throw new RuntimeException(""String_Node_Str"");
}
throw new ClassNotFoundException();
}
}","/** 
 * Given a class name and class-path, returns an input stream for the given class. 
 */
public InputStream getInputStreamOf(String classPath,String className) throws ClassNotFoundException {
  List locations=null;
  if (classPath == previousCP || previousCP.equals(classPath)) {
    locations=previousLocations;
  }
 else {
    previousCP=classPath;
    locations=new ArrayList();
    int sepIndex;
    boolean absolutePath;
    if (classPath == null) {
      classPath=System.getProperty(""String_Node_Str"") + pathSeparator + System.getProperty(""String_Node_Str"")+ fileSeparator+ ""String_Node_Str""+ fileSeparator+ ""String_Node_Str"";
    }
    String userDir=System.getProperty(""String_Node_Str"");
    for (boolean done=false; !done; ) {
      if (classPath.indexOf(fileSeparator) == 0 || (isRunningUnderBraindeadOS && classPath.length() >= 2 && classPath.charAt(1) == ':'))       absolutePath=true;
 else       absolutePath=false;
      sepIndex=classPath.indexOf(pathSeparator);
      String candidate=null;
      if (sepIndex == -1) {
        candidate=classPath;
        done=true;
      }
 else       candidate=classPath.substring(0,sepIndex);
      if (candidate.startsWith(""String_Node_Str"")) {
        if (candidate.startsWith(""String_Node_Str"" + System.getProperty(""String_Node_Str"") + fileSeparator))         candidate=""String_Node_Str"" + fileSeparator + candidate.substring(candidate.indexOf(fileSeparator));
        if (!candidate.startsWith(""String_Node_Str"" + fileSeparator))         throw new RuntimeException(""String_Node_Str"");
        candidate=System.getProperty(""String_Node_Str"") + fileSeparator + candidate.substring(2);
      }
 else       if (!absolutePath)       candidate=userDir + fileSeparator + candidate;
      if (isArchive(candidate)) {
        addArchive(candidate);
      }
 else {
        locations.add(candidate);
      }
      classPath=classPath.substring(sepIndex + 1);
    }
    previousLocations=locations;
  }
  setLocationsFound(locations);
  InputStream res=null;
{
    List jimple=new SingletonList(JimpleInputRep.v());
    List java=new SingletonList(JavaInputRep.v());
    List clss=new SingletonList(ClassInputRep.v());
    String javaClassName=className;
    if (className.indexOf(""String_Node_Str"") != -1) {
      javaClassName=className.substring(0,className.indexOf(""String_Node_Str""));
    }
    if (sourceToClassMap != null) {
      if (sourceToClassMap.get(javaClassName) != null) {
        javaClassName=(String)sourceToClassMap.get(javaClassName);
      }
    }
switch (Options.v().src_prec()) {
case Options.src_prec_class:
      if ((res=getFileInputStream(locations,clss,className)) != null)       return res;
    if ((res=getFileInputStream(locations,jimple,className)) != null)     return res;
  if ((res=getFileInputStream(locations,java,javaClassName)) != null)   return res;
break;
case Options.src_prec_java:
if ((res=getFileInputStream(locations,java,javaClassName)) != null) return res;
if ((res=getFileInputStream(locations,clss,className)) != null) return res;
if ((res=getFileInputStream(locations,jimple,className)) != null) return res;
break;
case Options.src_prec_jimple:
if ((res=getFileInputStream(locations,jimple,className)) != null) return res;
if ((res=getFileInputStream(locations,clss,className)) != null) return res;
if ((res=getFileInputStream(locations,java,javaClassName)) != null) return res;
break;
default :
throw new RuntimeException(""String_Node_Str"");
}
throw new ClassNotFoundException();
}
}"
88723,"/** 
 * Eliminates dead code in a linear fashion.  Complexity is linear  with respect to the statements. Does not work on grimp code because of the check on the right hand side for side effects. 
 */
protected void internalTransform(Body b,String phaseName,Map options){
  boolean eliminateOnlyStackLocals=PhaseOptions.getBoolean(options,""String_Node_Str"");
  if (Options.v().verbose())   G.v().out.println(""String_Node_Str"" + b.getMethod().getName() + ""String_Node_Str"");
  if (Options.v().time())   Timers.v().deadCodeTimer.start();
  Set essentialStmts=new HashSet();
  LinkedList toVisit=new LinkedList();
  Chain units=b.getUnits();
{
    Iterator stmtIt=units.iterator();
    while (stmtIt.hasNext()) {
      Stmt s=(Stmt)stmtIt.next();
      boolean isEssential=true;
      if (s instanceof NopStmt)       isEssential=false;
      if (s instanceof AssignStmt) {
        AssignStmt as=(AssignStmt)s;
        if (as.getLeftOp() instanceof Local && (!eliminateOnlyStackLocals || ((Local)as.getLeftOp()).getName().startsWith(""String_Node_Str""))) {
          Value rhs=as.getRightOp();
          isEssential=false;
          if (rhs instanceof InvokeExpr || rhs instanceof ArrayRef) {
            isEssential=true;
          }
          if (rhs instanceof InstanceFieldRef && !(!b.getMethod().isStatic() && ((InstanceFieldRef)rhs).getBase() == b.getThisLocal())) {
            isEssential=true;
          }
 else           if (rhs instanceof DivExpr || rhs instanceof RemExpr) {
            BinopExpr expr=(BinopExpr)rhs;
            if (expr.getOp1().getType().equals(IntType.v()) || expr.getOp2().getType().equals(IntType.v()) || expr.getOp1().getType().equals(LongType.v())|| expr.getOp2().getType().equals(LongType.v())) {
              isEssential=true;
            }
          }
        }
      }
      if (isEssential) {
        essentialStmts.add(s);
        toVisit.addLast(s);
      }
    }
  }
  ExceptionalUnitGraph graph=new ExceptionalUnitGraph(b);
  LocalDefs defs=new SimpleLocalDefs(graph);
  LocalUses uses=new SimpleLocalUses(graph,defs);
{
    while (!toVisit.isEmpty()) {
      Stmt s=(Stmt)toVisit.removeFirst();
      Iterator boxIt=s.getUseBoxes().iterator();
      while (boxIt.hasNext()) {
        ValueBox box=(ValueBox)boxIt.next();
        if (box.getValue() instanceof Local) {
          Iterator defIt=defs.getDefsOfAt((Local)box.getValue(),s).iterator();
          while (defIt.hasNext()) {
            Stmt def=(Stmt)defIt.next();
            if (!essentialStmts.contains(def)) {
              essentialStmts.add(def);
              toVisit.addLast(def);
            }
          }
        }
      }
    }
  }
{
    Iterator stmtIt=units.iterator();
    while (stmtIt.hasNext()) {
      Stmt s=(Stmt)stmtIt.next();
      if (!essentialStmts.contains(s)) {
        stmtIt.remove();
        s.clearUnitBoxes();
      }
 else       if (s instanceof AssignStmt && ((AssignStmt)s).getLeftOp() == ((AssignStmt)s).getRightOp() && ((AssignStmt)s).getLeftOp() instanceof Local) {
        stmtIt.remove();
        s.clearUnitBoxes();
      }
    }
  }
{
    Iterator stmtIt=units.snapshotIterator();
    while (stmtIt.hasNext()) {
      Stmt s=(Stmt)stmtIt.next();
      if (s instanceof AssignStmt && s.containsInvokeExpr()) {
        Local l=(Local)((AssignStmt)s).getLeftOp();
        InvokeExpr e=(InvokeExpr)s.getInvokeExpr();
{
          Iterator useIt=uses.getUsesOf(s).iterator();
          boolean isEssential=false;
          while (useIt.hasNext()) {
            UnitValueBoxPair pair=(UnitValueBoxPair)useIt.next();
            if (essentialStmts.contains(pair.unit)) {
              isEssential=true;
              break;
            }
          }
          if (!isEssential) {
            Stmt newInvoke=Jimple.v().newInvokeStmt(e);
            units.swapWith(s,newInvoke);
          }
        }
      }
    }
  }
  if (Options.v().time())   Timers.v().deadCodeTimer.end();
}","/** 
 * Eliminates dead code in a linear fashion.  Complexity is linear  with respect to the statements. Does not work on grimp code because of the check on the right hand side for side effects. 
 */
protected void internalTransform(Body b,String phaseName,Map options){
  boolean eliminateOnlyStackLocals=PhaseOptions.getBoolean(options,""String_Node_Str"");
  if (Options.v().verbose())   G.v().out.println(""String_Node_Str"" + b.getMethod().getName() + ""String_Node_Str"");
  if (Options.v().time())   Timers.v().deadCodeTimer.start();
  Set essentialStmts=new HashSet();
  LinkedList toVisit=new LinkedList();
  Chain units=b.getUnits();
{
    Iterator stmtIt=units.iterator();
    while (stmtIt.hasNext()) {
      Stmt s=(Stmt)stmtIt.next();
      boolean isEssential=true;
      if (s instanceof NopStmt)       isEssential=false;
      if (s instanceof AssignStmt) {
        AssignStmt as=(AssignStmt)s;
        if (as.getLeftOp() instanceof Local && (!eliminateOnlyStackLocals || ((Local)as.getLeftOp()).getName().startsWith(""String_Node_Str""))) {
          Value rhs=as.getRightOp();
          isEssential=false;
          if (rhs instanceof InvokeExpr || rhs instanceof ArrayRef) {
            isEssential=true;
          }
          if (rhs instanceof InstanceFieldRef && !(!b.getMethod().isStatic() && ((InstanceFieldRef)rhs).getBase() == b.getThisLocal())) {
            isEssential=true;
          }
 else           if (rhs instanceof DivExpr || rhs instanceof RemExpr) {
            BinopExpr expr=(BinopExpr)rhs;
            if (expr.getOp1().getType().equals(IntType.v()) || expr.getOp2().getType().equals(IntType.v()) || expr.getOp1().getType().equals(LongType.v())|| expr.getOp2().getType().equals(LongType.v())) {
              isEssential=true;
            }
          }
        }
      }
      if (isEssential) {
        essentialStmts.add(s);
        toVisit.addLast(s);
      }
    }
  }
  ExceptionalUnitGraph graph=new ExceptionalUnitGraph(b);
  LocalDefs defs=new SimpleLocalDefs(graph);
  LocalUses uses=new SimpleLocalUses(graph,defs);
{
    while (!toVisit.isEmpty()) {
      Stmt s=(Stmt)toVisit.removeFirst();
      Iterator boxIt=s.getUseBoxes().iterator();
      while (boxIt.hasNext()) {
        ValueBox box=(ValueBox)boxIt.next();
        if (box.getValue() instanceof Local) {
          Iterator defIt=defs.getDefsOfAt((Local)box.getValue(),s).iterator();
          while (defIt.hasNext()) {
            Stmt def=(Stmt)defIt.next();
            if (!essentialStmts.contains(def)) {
              essentialStmts.add(def);
              toVisit.addLast(def);
            }
          }
        }
      }
    }
  }
{
    Iterator stmtIt=units.iterator();
    while (stmtIt.hasNext()) {
      Stmt s=(Stmt)stmtIt.next();
      if (!essentialStmts.contains(s)) {
        stmtIt.remove();
        s.clearUnitBoxes();
      }
 else       if (s instanceof AssignStmt && ((AssignStmt)s).getLeftOp() == ((AssignStmt)s).getRightOp() && ((AssignStmt)s).getLeftOp() instanceof Local) {
        stmtIt.remove();
        s.clearUnitBoxes();
      }
    }
  }
{
    Iterator stmtIt=units.snapshotIterator();
    while (stmtIt.hasNext()) {
      Stmt s=(Stmt)stmtIt.next();
      if (s instanceof AssignStmt && s.containsInvokeExpr()) {
        Local l=(Local)((AssignStmt)s).getLeftOp();
        InvokeExpr e=(InvokeExpr)s.getInvokeExpr();
{
          Iterator useIt=uses.getUsesOf(s).iterator();
          boolean isEssential=false;
          while (useIt.hasNext()) {
            UnitValueBoxPair pair=(UnitValueBoxPair)useIt.next();
            if (essentialStmts.contains(pair.unit)) {
              isEssential=true;
              break;
            }
          }
          if (!isEssential) {
            Stmt newInvoke=Jimple.v().newInvokeStmt(e);
            newInvoke.addAllTagsOf(s);
            units.swapWith(s,newInvoke);
          }
        }
      }
    }
  }
  if (Options.v().time())   Timers.v().deadCodeTimer.end();
}"
88724,"/** 
 * Method to compute the edges corresponding to exceptional control flow.
 * @param unitToDests A <tt>Map</tt> from {@link Unit}s to   {@link Collection}s of   {@link ExceptionalUnitGraph.ExceptionDest ExceptionDest}s which represent the handlers that might catch exceptions thrown by the <tt>Unit</tt>. This is an ``in parameter''.
 * @param unitToSuccs A <tt>Map</tt> from <tt>Unit</tt>s to {@link List}s of <tt>Unit</tt>s. This is an ``out parameter''; <tt>buildExceptionalEdges</tt> will add a mapping from every <tt>Unit</tt> in the body that may throw an exception that could be caught by a   {@link Trap} in the body to alist of its exceptional successors.
 * @param unitToPreds A <tt>Map</tt> from <tt>Unit</tt>s to <tt>List</tt>s of <tt>Unit</tt>s. This is an ``out parameter''; <tt>buildExceptionalEdges</tt> will add a mapping from each handler unit that may catch an exception to the list of <tt>Unit</tt>s whose exceptions it may catch.
 * @param omitExceptingUnitEdges Indicates whether to omitexceptional edges from excepting units which lack side effects
 * @return a {@link Set} of trap <tt>Unit</tt>s that might catch exceptions thrown by the first <tt>Unit</tt> in the  {@link Body}associated with the graph being constructed.  Such trap <tt>Unit</tt>s may need to be added to the list of heads (depending on your definition of heads), since they can be the first <tt>Unit</tt> in the <tt>Body</tt> which actually completes execution.
 */
protected Set buildExceptionalEdges(Map unitToDests,Map unitToSuccs,Map unitToPreds,boolean omitExceptingUnitEdges){
  Set trapsThatAreHeads=new ArraySet();
  for (Iterator it=unitToDests.entrySet().iterator(); it.hasNext(); ) {
    Map.Entry entry=(Map.Entry)it.next();
    Unit thrower=(Unit)entry.getKey();
    Collection dests=(Collection)entry.getValue();
    for (Iterator destIt=dests.iterator(); destIt.hasNext(); ) {
      ExceptionDest dest=(ExceptionDest)destIt.next();
      if (dest.trap() != null) {
        Unit catcher=dest.trap().getHandlerUnit();
        List throwersPreds=getUnexceptionalPredsOf(thrower);
        if (throwersPreds.size() == 0) {
          trapsThatAreHeads.add(catcher);
        }
 else {
          for (Iterator j=throwersPreds.iterator(); j.hasNext(); ) {
            Unit pred=(Unit)j.next();
            addEdge(unitToSuccs,unitToPreds,pred,catcher);
          }
        }
        if ((!omitExceptingUnitEdges) || thrower instanceof ThrowInst || thrower instanceof ThrowStmt|| mightHaveSideEffects(thrower)) {
          addEdge(unitToSuccs,unitToPreds,thrower,catcher);
        }
      }
    }
  }
class CFGEdge {
    Unit head;
    Unit tail;
    CFGEdge(    Unit head,    Unit tail){
      if (tail == null)       throw new RuntimeException(""String_Node_Str"" + head.toString() + ','+ tail.toString()+ ')');
      this.head=head;
      this.tail=tail;
    }
    public boolean equals(    Object rhs){
      if (rhs == this) {
        return true;
      }
      if (!(rhs instanceof CFGEdge)) {
        return false;
      }
      CFGEdge rhsEdge=(CFGEdge)rhs;
      return ((this.head == rhsEdge.head) && (this.tail == rhsEdge.tail));
    }
    public int hashCode(){
      int result=17;
      result=37 * result + this.head.hashCode();
      result=37 * result + this.tail.hashCode();
      return result;
    }
  }
  LinkedList workList=new LinkedList();
  for (Iterator trapIt=body.getTraps().iterator(); trapIt.hasNext(); ) {
    Trap trap=(Trap)trapIt.next();
    Unit handlerStart=trap.getHandlerUnit();
    if (mightThrowToIntraproceduralCatcher(handlerStart)) {
      List handlerPreds=getUnexceptionalPredsOf(handlerStart);
      for (Iterator it=handlerPreds.iterator(); it.hasNext(); ) {
        Unit pred=(Unit)it.next();
        workList.addLast(new CFGEdge(pred,handlerStart));
      }
      handlerPreds=getExceptionalPredsOf(handlerStart);
      for (Iterator it=handlerPreds.iterator(); it.hasNext(); ) {
        Unit pred=(Unit)it.next();
        workList.addLast(new CFGEdge(pred,handlerStart));
      }
      if (trapsThatAreHeads.contains(handlerStart)) {
        workList.addLast(new CFGEdge(null,handlerStart));
      }
    }
  }
  while (workList.size() > 0) {
    CFGEdge edgeToThrower=(CFGEdge)workList.removeFirst();
    Unit pred=edgeToThrower.head;
    Unit thrower=edgeToThrower.tail;
    Collection throwerDests=getExceptionDests(thrower);
    for (Iterator i=throwerDests.iterator(); i.hasNext(); ) {
      ExceptionDest dest=(ExceptionDest)i.next();
      if (dest.trap() != null) {
        Unit handlerStart=dest.trap().getHandlerUnit();
        boolean edgeAdded=false;
        if (pred == null) {
          if (!trapsThatAreHeads.contains(handlerStart)) {
            trapsThatAreHeads.add(handlerStart);
            edgeAdded=true;
          }
        }
 else {
          if (!getExceptionalSuccsOf(pred).contains(handlerStart)) {
            addEdge(unitToSuccs,unitToPreds,pred,handlerStart);
            edgeAdded=true;
          }
        }
        if (edgeAdded && mightThrowToIntraproceduralCatcher(handlerStart)) {
          workList.addLast(new CFGEdge(pred,handlerStart));
        }
      }
    }
  }
  return trapsThatAreHeads;
}","/** 
 * Method to compute the edges corresponding to exceptional control flow.
 * @param unitToDests A <tt>Map</tt> from {@link Unit}s to   {@link Collection}s of   {@link ExceptionalUnitGraph.ExceptionDest ExceptionDest}s which represent the handlers that might catch exceptions thrown by the <tt>Unit</tt>. This is an ``in parameter''.
 * @param unitToSuccs A <tt>Map</tt> from <tt>Unit</tt>s to {@link List}s of <tt>Unit</tt>s. This is an ``out parameter''; <tt>buildExceptionalEdges</tt> will add a mapping from every <tt>Unit</tt> in the body that may throw an exception that could be caught by a   {@link Trap} in the body to alist of its exceptional successors.
 * @param unitToPreds A <tt>Map</tt> from <tt>Unit</tt>s to <tt>List</tt>s of <tt>Unit</tt>s. This is an ``out parameter''; <tt>buildExceptionalEdges</tt> will add a mapping from each handler unit that may catch an exception to the list of <tt>Unit</tt>s whose exceptions it may catch.
 * @param omitExceptingUnitEdges Indicates whether to omitexceptional edges from excepting units which lack side effects
 * @return a {@link Set} of trap <tt>Unit</tt>s that might catch exceptions thrown by the first <tt>Unit</tt> in the  {@link Body}associated with the graph being constructed.  Such trap <tt>Unit</tt>s may need to be added to the list of heads (depending on your definition of heads), since they can be the first <tt>Unit</tt> in the <tt>Body</tt> which actually completes execution.
 */
protected Set buildExceptionalEdges(Map unitToDests,Map unitToSuccs,Map unitToPreds,boolean omitExceptingUnitEdges){
  Set trapsThatAreHeads=new ArraySet();
  Unit entryPoint=(Unit)unitChain.getFirst();
  for (Iterator it=unitToDests.entrySet().iterator(); it.hasNext(); ) {
    Map.Entry entry=(Map.Entry)it.next();
    Unit thrower=(Unit)entry.getKey();
    Collection dests=(Collection)entry.getValue();
    for (Iterator destIt=dests.iterator(); destIt.hasNext(); ) {
      ExceptionDest dest=(ExceptionDest)destIt.next();
      if (dest.trap() != null) {
        Unit catcher=dest.trap().getHandlerUnit();
        List throwersPreds=getUnexceptionalPredsOf(thrower);
        if (thrower == entryPoint) {
          trapsThatAreHeads.add(catcher);
        }
 else {
          for (Iterator j=throwersPreds.iterator(); j.hasNext(); ) {
            Unit pred=(Unit)j.next();
            addEdge(unitToSuccs,unitToPreds,pred,catcher);
          }
        }
        if ((!omitExceptingUnitEdges) || thrower instanceof ThrowInst || thrower instanceof ThrowStmt|| mightHaveSideEffects(thrower)) {
          addEdge(unitToSuccs,unitToPreds,thrower,catcher);
        }
      }
    }
  }
class CFGEdge {
    Unit head;
    Unit tail;
    CFGEdge(    Unit head,    Unit tail){
      if (tail == null)       throw new RuntimeException(""String_Node_Str"" + head.toString() + ','+ tail.toString()+ ')');
      this.head=head;
      this.tail=tail;
    }
    public boolean equals(    Object rhs){
      if (rhs == this) {
        return true;
      }
      if (!(rhs instanceof CFGEdge)) {
        return false;
      }
      CFGEdge rhsEdge=(CFGEdge)rhs;
      return ((this.head == rhsEdge.head) && (this.tail == rhsEdge.tail));
    }
    public int hashCode(){
      int result=17;
      result=37 * result + this.head.hashCode();
      result=37 * result + this.tail.hashCode();
      return result;
    }
  }
  LinkedList workList=new LinkedList();
  for (Iterator trapIt=body.getTraps().iterator(); trapIt.hasNext(); ) {
    Trap trap=(Trap)trapIt.next();
    Unit handlerStart=trap.getHandlerUnit();
    if (mightThrowToIntraproceduralCatcher(handlerStart)) {
      List handlerPreds=getUnexceptionalPredsOf(handlerStart);
      for (Iterator it=handlerPreds.iterator(); it.hasNext(); ) {
        Unit pred=(Unit)it.next();
        workList.addLast(new CFGEdge(pred,handlerStart));
      }
      handlerPreds=getExceptionalPredsOf(handlerStart);
      for (Iterator it=handlerPreds.iterator(); it.hasNext(); ) {
        Unit pred=(Unit)it.next();
        workList.addLast(new CFGEdge(pred,handlerStart));
      }
      if (trapsThatAreHeads.contains(handlerStart)) {
        workList.addLast(new CFGEdge(null,handlerStart));
      }
    }
  }
  while (workList.size() > 0) {
    CFGEdge edgeToThrower=(CFGEdge)workList.removeFirst();
    Unit pred=edgeToThrower.head;
    Unit thrower=edgeToThrower.tail;
    Collection throwerDests=getExceptionDests(thrower);
    for (Iterator i=throwerDests.iterator(); i.hasNext(); ) {
      ExceptionDest dest=(ExceptionDest)i.next();
      if (dest.trap() != null) {
        Unit handlerStart=dest.trap().getHandlerUnit();
        boolean edgeAdded=false;
        if (pred == null) {
          if (!trapsThatAreHeads.contains(handlerStart)) {
            trapsThatAreHeads.add(handlerStart);
            edgeAdded=true;
          }
        }
 else {
          if (!getExceptionalSuccsOf(pred).contains(handlerStart)) {
            addEdge(unitToSuccs,unitToPreds,pred,handlerStart);
            edgeAdded=true;
          }
        }
        if (edgeAdded && mightThrowToIntraproceduralCatcher(handlerStart)) {
          workList.addLast(new CFGEdge(pred,handlerStart));
        }
      }
    }
  }
  return trapsThatAreHeads;
}"
88725,"void emitInst(Inst inst){
  inst.apply(new InstSwitch(){
    public void caseReturnVoidInst(    ReturnVoidInst i){
      emit(""String_Node_Str"");
    }
    public void caseReturnInst(    ReturnInst i){
      i.getOpType().apply(new TypeSwitch(){
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"" + t.toString());
        }
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"");
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"");
        }
        public void caseIntType(        IntType t){
          emit(""String_Node_Str"");
        }
        public void caseByteType(        ByteType t){
          emit(""String_Node_Str"");
        }
        public void caseShortType(        ShortType t){
          emit(""String_Node_Str"");
        }
        public void caseCharType(        CharType t){
          emit(""String_Node_Str"");
        }
        public void caseBooleanType(        BooleanType t){
          emit(""String_Node_Str"");
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"");
        }
        public void caseArrayType(        ArrayType t){
          emit(""String_Node_Str"");
        }
        public void caseRefType(        RefType t){
          emit(""String_Node_Str"");
        }
        public void caseNullType(        NullType t){
          emit(""String_Node_Str"");
        }
      }
);
    }
    public void caseNopInst(    NopInst i){
      emit(""String_Node_Str"");
    }
    public void caseEnterMonitorInst(    EnterMonitorInst i){
      emit(""String_Node_Str"");
    }
    public void casePopInst(    PopInst i){
      if (i.getWordCount() == 2) {
        emit(""String_Node_Str"");
      }
 else       emit(""String_Node_Str"");
    }
    public void caseExitMonitorInst(    ExitMonitorInst i){
      emit(""String_Node_Str"");
    }
    public void caseGotoInst(    GotoInst i){
      emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
    }
    public void casePushInst(    PushInst i){
      if (i.getConstant() instanceof IntConstant) {
        IntConstant v=(IntConstant)(i.getConstant());
        if (v.value == -1)         emit(""String_Node_Str"");
 else         if (v.value >= 0 && v.value <= 5)         emit(""String_Node_Str"" + v.value);
 else         if (v.value >= Byte.MIN_VALUE && v.value <= Byte.MAX_VALUE)         emit(""String_Node_Str"" + v.value);
 else         if (v.value >= Short.MIN_VALUE && v.value <= Short.MAX_VALUE)         emit(""String_Node_Str"" + v.value);
 else         emit(""String_Node_Str"" + v.toString());
      }
 else       if (i.getConstant() instanceof StringConstant) {
        emit(""String_Node_Str"" + i.getConstant().toString());
      }
 else       if (i.getConstant() instanceof DoubleConstant) {
        DoubleConstant v=(DoubleConstant)(i.getConstant());
        if (v.value == 0)         emit(""String_Node_Str"");
 else         if (v.value == 1)         emit(""String_Node_Str"");
 else {
          String s=v.toString();
          if (s.equals(""String_Node_Str""))           s=""String_Node_Str"";
          if (s.equals(""String_Node_Str""))           s=""String_Node_Str"";
          if (s.equals(""String_Node_Str""))           s=""String_Node_Str"";
          emit(""String_Node_Str"" + s);
        }
      }
 else       if (i.getConstant() instanceof FloatConstant) {
        FloatConstant v=(FloatConstant)(i.getConstant());
        if (v.value == 0)         emit(""String_Node_Str"");
 else         if (v.value == 1)         emit(""String_Node_Str"");
 else         if (v.value == 2)         emit(""String_Node_Str"");
 else {
          String s=v.toString();
          if (s.equals(""String_Node_Str""))           s=""String_Node_Str"";
          if (s.equals(""String_Node_Str""))           s=""String_Node_Str"";
          if (s.equals(""String_Node_Str""))           s=""String_Node_Str"";
          emit(""String_Node_Str"" + s);
        }
      }
 else       if (i.getConstant() instanceof LongConstant) {
        LongConstant v=(LongConstant)(i.getConstant());
        if (v.value == 0)         emit(""String_Node_Str"");
 else         if (v.value == 1)         emit(""String_Node_Str"");
 else         emit(""String_Node_Str"" + v.toString());
      }
 else       if (i.getConstant() instanceof NullConstant)       emit(""String_Node_Str"");
 else       throw new RuntimeException(""String_Node_Str"");
    }
    public void caseIdentityInst(    IdentityInst i){
      if (i.getRightOp() instanceof CaughtExceptionRef && i.getLeftOp() instanceof Local) {
        int slot=((Integer)localToSlot.get(i.getLeftOp())).intValue();
        if (slot >= 0 && slot <= 3)         emit(""String_Node_Str"" + slot);
 else         emit(""String_Node_Str"" + slot);
      }
    }
    public void caseStoreInst(    StoreInst i){
      final int slot=((Integer)localToSlot.get(i.getLocal())).intValue();
      i.getOpType().apply(new TypeSwitch(){
        public void caseArrayType(        ArrayType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseDoubleType(        DoubleType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseFloatType(        FloatType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseIntType(        IntType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseByteType(        ByteType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseShortType(        ShortType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseCharType(        CharType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseBooleanType(        BooleanType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseLongType(        LongType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseRefType(        RefType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseStmtAddressType(        StmtAddressType t){
          isNextGotoAJsr=true;
          returnAddressSlot=slot;
        }
        public void caseNullType(        NullType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"" + t);
        }
      }
);
    }
    public void caseLoadInst(    LoadInst i){
      final int slot=((Integer)localToSlot.get(i.getLocal())).intValue();
      i.getOpType().apply(new TypeSwitch(){
        public void caseArrayType(        ArrayType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"" + t);
        }
        public void caseDoubleType(        DoubleType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseFloatType(        FloatType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseIntType(        IntType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseByteType(        ByteType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseShortType(        ShortType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseCharType(        CharType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseBooleanType(        BooleanType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseLongType(        LongType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseRefType(        RefType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseNullType(        NullType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
      }
);
    }
    public void caseArrayWriteInst(    ArrayWriteInst i){
      i.getOpType().apply(new TypeSwitch(){
        public void caseArrayType(        ArrayType t){
          emit(""String_Node_Str"");
        }
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"");
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"");
        }
        public void caseIntType(        IntType t){
          emit(""String_Node_Str"");
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"");
        }
        public void caseRefType(        RefType t){
          emit(""String_Node_Str"");
        }
        public void caseByteType(        ByteType t){
          emit(""String_Node_Str"");
        }
        public void caseBooleanType(        BooleanType t){
          emit(""String_Node_Str"");
        }
        public void caseCharType(        CharType t){
          emit(""String_Node_Str"");
        }
        public void caseShortType(        ShortType t){
          emit(""String_Node_Str"");
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"" + t);
        }
      }
);
    }
    public void caseArrayReadInst(    ArrayReadInst i){
      i.getOpType().apply(new TypeSwitch(){
        public void caseArrayType(        ArrayType ty){
          emit(""String_Node_Str"");
        }
        public void caseBooleanType(        BooleanType ty){
          emit(""String_Node_Str"");
        }
        public void caseByteType(        ByteType ty){
          emit(""String_Node_Str"");
        }
        public void caseCharType(        CharType ty){
          emit(""String_Node_Str"");
        }
        public void defaultCase(        Type ty){
          throw new RuntimeException(""String_Node_Str"");
        }
        public void caseDoubleType(        DoubleType ty){
          emit(""String_Node_Str"");
        }
        public void caseFloatType(        FloatType ty){
          emit(""String_Node_Str"");
        }
        public void caseIntType(        IntType ty){
          emit(""String_Node_Str"");
        }
        public void caseLongType(        LongType ty){
          emit(""String_Node_Str"");
        }
        public void caseNullType(        NullType ty){
          emit(""String_Node_Str"");
        }
        public void caseRefType(        RefType ty){
          emit(""String_Node_Str"");
        }
        public void caseShortType(        ShortType ty){
          emit(""String_Node_Str"");
        }
      }
);
    }
    public void caseIfNullInst(    IfNullInst i){
      emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
    }
    public void caseIfNonNullInst(    IfNonNullInst i){
      emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
    }
    public void caseIfEqInst(    IfEqInst i){
      emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
    }
    public void caseIfNeInst(    IfNeInst i){
      emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
    }
    public void caseIfGtInst(    IfGtInst i){
      emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
    }
    public void caseIfGeInst(    IfGeInst i){
      emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
    }
    public void caseIfLtInst(    IfLtInst i){
      emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
    }
    public void caseIfLeInst(    IfLeInst i){
      emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
    }
    public void caseIfCmpEqInst(    final IfCmpEqInst i){
      i.getOpType().apply(new TypeSwitch(){
        public void caseIntType(        IntType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseBooleanType(        BooleanType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseShortType(        ShortType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseCharType(        CharType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseByteType(        ByteType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseArrayType(        ArrayType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseRefType(        RefType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseNullType(        NullType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseIfCmpNeInst(    final IfCmpNeInst i){
      i.getOpType().apply(new TypeSwitch(){
        public void caseIntType(        IntType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseBooleanType(        BooleanType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseShortType(        ShortType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseCharType(        CharType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseByteType(        ByteType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseArrayType(        ArrayType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseRefType(        RefType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseNullType(        NullType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseIfCmpGtInst(    final IfCmpGtInst i){
      i.getOpType().apply(new TypeSwitch(){
        public void caseIntType(        IntType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseBooleanType(        BooleanType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseShortType(        ShortType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseCharType(        CharType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseByteType(        ByteType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseArrayType(        ArrayType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseRefType(        RefType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseNullType(        NullType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseIfCmpGeInst(    final IfCmpGeInst i){
      i.getOpType().apply(new TypeSwitch(){
        public void caseIntType(        IntType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseBooleanType(        BooleanType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseShortType(        ShortType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseCharType(        CharType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseByteType(        ByteType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseArrayType(        ArrayType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseRefType(        RefType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseNullType(        NullType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseIfCmpLtInst(    final IfCmpLtInst i){
      i.getOpType().apply(new TypeSwitch(){
        public void caseIntType(        IntType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseBooleanType(        BooleanType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseShortType(        ShortType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseCharType(        CharType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseByteType(        ByteType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseArrayType(        ArrayType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseRefType(        RefType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseNullType(        NullType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseIfCmpLeInst(    final IfCmpLeInst i){
      i.getOpType().apply(new TypeSwitch(){
        public void caseIntType(        IntType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseBooleanType(        BooleanType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseShortType(        ShortType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseCharType(        CharType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseByteType(        ByteType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseArrayType(        ArrayType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseRefType(        RefType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseNullType(        NullType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseStaticGetInst(    StaticGetInst i){
      SootField field=i.getField();
      emit(""String_Node_Str"" + slashify(field.getDeclaringClass().getName()) + ""String_Node_Str""+ field.getName()+ ""String_Node_Str""+ jasminDescriptorOf(field.getType()));
    }
    public void caseStaticPutInst(    StaticPutInst i){
      emit(""String_Node_Str"" + slashify(i.getField().getDeclaringClass().getName()) + ""String_Node_Str""+ i.getField().getName()+ ""String_Node_Str""+ jasminDescriptorOf(i.getField().getType()));
    }
    public void caseFieldGetInst(    FieldGetInst i){
      emit(""String_Node_Str"" + slashify(i.getField().getDeclaringClass().getName()) + ""String_Node_Str""+ i.getField().getName()+ ""String_Node_Str""+ jasminDescriptorOf(i.getField().getType()));
    }
    public void caseFieldPutInst(    FieldPutInst i){
      emit(""String_Node_Str"" + slashify(i.getField().getDeclaringClass().getName()) + ""String_Node_Str""+ i.getField().getName()+ ""String_Node_Str""+ jasminDescriptorOf(i.getField().getType()));
    }
    public void caseInstanceCastInst(    InstanceCastInst i){
      Type castType=i.getCastType();
      if (castType instanceof RefType)       emit(""String_Node_Str"" + slashify(castType.toString()));
 else       if (castType instanceof ArrayType)       emit(""String_Node_Str"" + jasminDescriptorOf(castType));
    }
    public void caseInstanceOfInst(    InstanceOfInst i){
      Type checkType=i.getCheckType();
      if (checkType instanceof RefType)       emit(""String_Node_Str"" + slashify(checkType.toString()));
 else       if (checkType instanceof ArrayType)       emit(""String_Node_Str"" + jasminDescriptorOf(checkType));
    }
    public void caseNewInst(    NewInst i){
      emit(""String_Node_Str"" + slashify(i.getBaseType().toString()));
    }
    public void casePrimitiveCastInst(    PrimitiveCastInst i){
      emit(i.toString());
    }
    public void caseStaticInvokeInst(    StaticInvokeInst i){
      SootMethod m=i.getMethod();
      emit(""String_Node_Str"" + slashify(m.getDeclaringClass().getName()) + ""String_Node_Str""+ m.getName()+ jasminDescriptorOf(m));
    }
    public void caseVirtualInvokeInst(    VirtualInvokeInst i){
      SootMethod m=i.getMethod();
      emit(""String_Node_Str"" + slashify(m.getDeclaringClass().getName()) + ""String_Node_Str""+ m.getName()+ jasminDescriptorOf(m));
    }
    public void caseInterfaceInvokeInst(    InterfaceInvokeInst i){
      SootMethod m=i.getMethod();
      emit(""String_Node_Str"" + slashify(m.getDeclaringClass().getName()) + ""String_Node_Str""+ m.getName()+ jasminDescriptorOf(m)+ ""String_Node_Str""+ (argCountOf(m) + 1));
    }
    public void caseSpecialInvokeInst(    SpecialInvokeInst i){
      SootMethod m=i.getMethod();
      emit(""String_Node_Str"" + slashify(m.getDeclaringClass().getName()) + ""String_Node_Str""+ m.getName()+ jasminDescriptorOf(m));
    }
    public void caseThrowInst(    ThrowInst i){
      emit(""String_Node_Str"");
    }
    public void caseCmpInst(    CmpInst i){
      emit(""String_Node_Str"");
    }
    public void caseCmplInst(    CmplInst i){
      if (i.getOpType().equals(FloatType.v()))       emit(""String_Node_Str"");
 else       emit(""String_Node_Str"");
    }
    public void caseCmpgInst(    CmpgInst i){
      if (i.getOpType().equals(FloatType.v()))       emit(""String_Node_Str"");
 else       emit(""String_Node_Str"");
    }
    private void emitOpTypeInst(    final String s,    final OpTypeArgInst i){
      i.getOpType().apply(new TypeSwitch(){
        private void handleIntCase(){
          emit(""String_Node_Str"" + s);
        }
        public void caseIntType(        IntType t){
          handleIntCase();
        }
        public void caseBooleanType(        BooleanType t){
          handleIntCase();
        }
        public void caseShortType(        ShortType t){
          handleIntCase();
        }
        public void caseCharType(        CharType t){
          handleIntCase();
        }
        public void caseByteType(        ByteType t){
          handleIntCase();
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"" + s);
        }
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"" + s);
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"" + s);
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseAddInst(    AddInst i){
      emitOpTypeInst(""String_Node_Str"",i);
    }
    public void caseDivInst(    DivInst i){
      emitOpTypeInst(""String_Node_Str"",i);
    }
    public void caseSubInst(    SubInst i){
      emitOpTypeInst(""String_Node_Str"",i);
    }
    public void caseMulInst(    MulInst i){
      emitOpTypeInst(""String_Node_Str"",i);
    }
    public void caseRemInst(    RemInst i){
      emitOpTypeInst(""String_Node_Str"",i);
    }
    public void caseShlInst(    ShlInst i){
      emitOpTypeInst(""String_Node_Str"",i);
    }
    public void caseAndInst(    AndInst i){
      emitOpTypeInst(""String_Node_Str"",i);
    }
    public void caseOrInst(    OrInst i){
      emitOpTypeInst(""String_Node_Str"",i);
    }
    public void caseXorInst(    XorInst i){
      emitOpTypeInst(""String_Node_Str"",i);
    }
    public void caseShrInst(    ShrInst i){
      emitOpTypeInst(""String_Node_Str"",i);
    }
    public void caseUshrInst(    UshrInst i){
      emitOpTypeInst(""String_Node_Str"",i);
    }
    public void caseIncInst(    IncInst i){
      if (((ValueBox)i.getUseBoxes().get(0)).getValue() != ((ValueBox)i.getDefBoxes().get(0)).getValue())       throw new RuntimeException(""String_Node_Str"");
      emit(""String_Node_Str"" + ((Integer)localToSlot.get(i.getLocal())) + ""String_Node_Str""+ i.getConstant());
    }
    public void caseArrayLengthInst(    ArrayLengthInst i){
      emit(""String_Node_Str"");
    }
    public void caseNegInst(    NegInst i){
      emitOpTypeInst(""String_Node_Str"",i);
    }
    public void caseNewArrayInst(    NewArrayInst i){
      if (i.getBaseType() instanceof RefType)       emit(""String_Node_Str"" + slashify(i.getBaseType().toString()));
 else       if (i.getBaseType() instanceof ArrayType)       emit(""String_Node_Str"" + jasminDescriptorOf(i.getBaseType()));
 else       emit(""String_Node_Str"" + i.getBaseType().toString());
    }
    public void caseNewMultiArrayInst(    NewMultiArrayInst i){
      emit(""String_Node_Str"" + jasminDescriptorOf(i.getBaseType()) + ""String_Node_Str""+ i.getDimensionCount());
    }
    public void caseLookupSwitchInst(    LookupSwitchInst i){
      emit(""String_Node_Str"");
      List lookupValues=i.getLookupValues();
      List targets=i.getTargets();
      for (int j=0; j < lookupValues.size(); j++)       emit(""String_Node_Str"" + lookupValues.get(j) + ""String_Node_Str""+ instToLabel.get(targets.get(j)));
      emit(""String_Node_Str"" + instToLabel.get(i.getDefaultTarget()));
    }
    public void caseTableSwitchInst(    TableSwitchInst i){
      emit(""String_Node_Str"" + i.getLowIndex() + ""String_Node_Str""+ i.getHighIndex());
      List targets=i.getTargets();
      for (int j=0; j < targets.size(); j++)       emit(""String_Node_Str"" + instToLabel.get(targets.get(j)));
      emit(""String_Node_Str"" + instToLabel.get(i.getDefaultTarget()));
    }
    private boolean isDwordType(    Type t){
      return t instanceof LongType || t instanceof DoubleType || t instanceof DoubleWordType;
    }
    public void caseDup1Inst(    Dup1Inst i){
      Type firstOpType=i.getOp1Type();
      if (isDwordType(firstOpType))       emit(""String_Node_Str"");
 else       emit(""String_Node_Str"");
    }
    public void caseDup2Inst(    Dup2Inst i){
      Type firstOpType=i.getOp1Type();
      Type secondOpType=i.getOp2Type();
      if (isDwordType(firstOpType)) {
        emit(""String_Node_Str"");
        if (isDwordType(secondOpType)) {
          emit(""String_Node_Str"");
        }
 else         emit(""String_Node_Str"");
      }
 else       if (isDwordType(secondOpType)) {
        if (isDwordType(firstOpType)) {
          emit(""String_Node_Str"");
        }
 else         emit(""String_Node_Str"");
        emit(""String_Node_Str"");
      }
 else {
        G.v().out.println(""String_Node_Str"");
        emit(""String_Node_Str"");
      }
    }
    public void caseDup1_x1Inst(    Dup1_x1Inst i){
      Type opType=i.getOp1Type();
      Type underType=i.getUnder1Type();
      if (isDwordType(opType)) {
        if (isDwordType(underType)) {
          emit(""String_Node_Str"");
        }
 else         emit(""String_Node_Str"");
      }
 else {
        if (isDwordType(underType))         emit(""String_Node_Str"");
 else         emit(""String_Node_Str"");
      }
    }
    public void caseDup1_x2Inst(    Dup1_x2Inst i){
      Type opType=i.getOpType();
      Type under1Type=i.getUnder1Type();
      Type under2Type=i.getUnder2Type();
      if (isDwordType(opType)) {
        if (!isDwordType(under1Type) && !isDwordType(under2Type))         emit(""String_Node_Str"");
 else         throw new RuntimeException(""String_Node_Str"");
      }
 else {
        if (isDwordType(under1Type) || isDwordType(under2Type))         throw new RuntimeException(""String_Node_Str"");
      }
      emit(""String_Node_Str"");
    }
    public void caseDup2_x1Inst(    Dup2_x1Inst i){
      Type op1Type=i.getOp1Type();
      Type op2Type=i.getOp2Type();
      Type under1Type=i.getUnder1Type();
      if (isDwordType(under1Type)) {
        if (!isDwordType(op1Type) && !isDwordType(under2Type))         throw new RuntimeException(""String_Node_Str"");
 else         emit(""String_Node_Str"");
      }
 else {
        if (isDwordType(op1Type) || isDwordType(op2Type))         throw new RuntimeException(""String_Node_Str"");
      }
      emit(""String_Node_Str"");
    }
    public void caseDup2_x2Inst(    Dup2_x2Inst i){
      Type op1Type=i.getOp1Type();
      Type op2Type=i.getOp2Type();
      Type under1Type=i.getUnder1Type();
      Type under2Type=i.getUnder2Type();
      if (isDwordType(op1Type) || isDwordType(op2Type) || isDwordType(under1Type)|| isDwordType(under1Type))       throw new RuntimeException(""String_Node_Str"");
      emit(""String_Node_Str"");
    }
    public void caseSwapInst(    SwapInst i){
      emit(""String_Node_Str"");
    }
  }
);
}","void emitInst(Inst inst){
  inst.apply(new InstSwitch(){
    public void caseReturnVoidInst(    ReturnVoidInst i){
      emit(""String_Node_Str"");
    }
    public void caseReturnInst(    ReturnInst i){
      i.getOpType().apply(new TypeSwitch(){
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"" + t.toString());
        }
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"");
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"");
        }
        public void caseIntType(        IntType t){
          emit(""String_Node_Str"");
        }
        public void caseByteType(        ByteType t){
          emit(""String_Node_Str"");
        }
        public void caseShortType(        ShortType t){
          emit(""String_Node_Str"");
        }
        public void caseCharType(        CharType t){
          emit(""String_Node_Str"");
        }
        public void caseBooleanType(        BooleanType t){
          emit(""String_Node_Str"");
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"");
        }
        public void caseArrayType(        ArrayType t){
          emit(""String_Node_Str"");
        }
        public void caseRefType(        RefType t){
          emit(""String_Node_Str"");
        }
        public void caseNullType(        NullType t){
          emit(""String_Node_Str"");
        }
      }
);
    }
    public void caseNopInst(    NopInst i){
      emit(""String_Node_Str"");
    }
    public void caseEnterMonitorInst(    EnterMonitorInst i){
      emit(""String_Node_Str"");
    }
    public void casePopInst(    PopInst i){
      if (i.getWordCount() == 2) {
        emit(""String_Node_Str"");
      }
 else       emit(""String_Node_Str"");
    }
    public void caseExitMonitorInst(    ExitMonitorInst i){
      emit(""String_Node_Str"");
    }
    public void caseGotoInst(    GotoInst i){
      emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
    }
    public void casePushInst(    PushInst i){
      if (i.getConstant() instanceof IntConstant) {
        IntConstant v=(IntConstant)(i.getConstant());
        if (v.value == -1)         emit(""String_Node_Str"");
 else         if (v.value >= 0 && v.value <= 5)         emit(""String_Node_Str"" + v.value);
 else         if (v.value >= Byte.MIN_VALUE && v.value <= Byte.MAX_VALUE)         emit(""String_Node_Str"" + v.value);
 else         if (v.value >= Short.MIN_VALUE && v.value <= Short.MAX_VALUE)         emit(""String_Node_Str"" + v.value);
 else         emit(""String_Node_Str"" + v.toString());
      }
 else       if (i.getConstant() instanceof StringConstant) {
        emit(""String_Node_Str"" + i.getConstant().toString());
      }
 else       if (i.getConstant() instanceof DoubleConstant) {
        DoubleConstant v=(DoubleConstant)(i.getConstant());
        if (v.value == 0)         emit(""String_Node_Str"");
 else         if (v.value == 1)         emit(""String_Node_Str"");
 else {
          String s=v.toString();
          if (s.equals(""String_Node_Str""))           s=""String_Node_Str"";
          if (s.equals(""String_Node_Str""))           s=""String_Node_Str"";
          if (s.equals(""String_Node_Str""))           s=""String_Node_Str"";
          emit(""String_Node_Str"" + s);
        }
      }
 else       if (i.getConstant() instanceof FloatConstant) {
        FloatConstant v=(FloatConstant)(i.getConstant());
        if (v.value == 0)         emit(""String_Node_Str"");
 else         if (v.value == 1)         emit(""String_Node_Str"");
 else         if (v.value == 2)         emit(""String_Node_Str"");
 else {
          String s=v.toString();
          if (s.equals(""String_Node_Str""))           s=""String_Node_Str"";
          if (s.equals(""String_Node_Str""))           s=""String_Node_Str"";
          if (s.equals(""String_Node_Str""))           s=""String_Node_Str"";
          emit(""String_Node_Str"" + s);
        }
      }
 else       if (i.getConstant() instanceof LongConstant) {
        LongConstant v=(LongConstant)(i.getConstant());
        if (v.value == 0)         emit(""String_Node_Str"");
 else         if (v.value == 1)         emit(""String_Node_Str"");
 else         emit(""String_Node_Str"" + v.toString());
      }
 else       if (i.getConstant() instanceof NullConstant)       emit(""String_Node_Str"");
 else       throw new RuntimeException(""String_Node_Str"");
    }
    public void caseIdentityInst(    IdentityInst i){
      if (i.getRightOp() instanceof CaughtExceptionRef && i.getLeftOp() instanceof Local) {
        int slot=((Integer)localToSlot.get(i.getLeftOp())).intValue();
        if (slot >= 0 && slot <= 3)         emit(""String_Node_Str"" + slot);
 else         emit(""String_Node_Str"" + slot);
      }
    }
    public void caseStoreInst(    StoreInst i){
      final int slot=((Integer)localToSlot.get(i.getLocal())).intValue();
      i.getOpType().apply(new TypeSwitch(){
        public void caseArrayType(        ArrayType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseDoubleType(        DoubleType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseFloatType(        FloatType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseIntType(        IntType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseByteType(        ByteType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseShortType(        ShortType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseCharType(        CharType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseBooleanType(        BooleanType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseLongType(        LongType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseRefType(        RefType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseStmtAddressType(        StmtAddressType t){
          isNextGotoAJsr=true;
          returnAddressSlot=slot;
        }
        public void caseNullType(        NullType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"" + t);
        }
      }
);
    }
    public void caseLoadInst(    LoadInst i){
      final int slot=((Integer)localToSlot.get(i.getLocal())).intValue();
      i.getOpType().apply(new TypeSwitch(){
        public void caseArrayType(        ArrayType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"" + t);
        }
        public void caseDoubleType(        DoubleType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseFloatType(        FloatType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseIntType(        IntType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseByteType(        ByteType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseShortType(        ShortType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseCharType(        CharType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseBooleanType(        BooleanType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseLongType(        LongType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseRefType(        RefType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
        public void caseNullType(        NullType t){
          if (slot >= 0 && slot <= 3)           emit(""String_Node_Str"" + slot);
 else           emit(""String_Node_Str"" + slot);
        }
      }
);
    }
    public void caseArrayWriteInst(    ArrayWriteInst i){
      i.getOpType().apply(new TypeSwitch(){
        public void caseArrayType(        ArrayType t){
          emit(""String_Node_Str"");
        }
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"");
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"");
        }
        public void caseIntType(        IntType t){
          emit(""String_Node_Str"");
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"");
        }
        public void caseRefType(        RefType t){
          emit(""String_Node_Str"");
        }
        public void caseByteType(        ByteType t){
          emit(""String_Node_Str"");
        }
        public void caseBooleanType(        BooleanType t){
          emit(""String_Node_Str"");
        }
        public void caseCharType(        CharType t){
          emit(""String_Node_Str"");
        }
        public void caseShortType(        ShortType t){
          emit(""String_Node_Str"");
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"" + t);
        }
      }
);
    }
    public void caseArrayReadInst(    ArrayReadInst i){
      i.getOpType().apply(new TypeSwitch(){
        public void caseArrayType(        ArrayType ty){
          emit(""String_Node_Str"");
        }
        public void caseBooleanType(        BooleanType ty){
          emit(""String_Node_Str"");
        }
        public void caseByteType(        ByteType ty){
          emit(""String_Node_Str"");
        }
        public void caseCharType(        CharType ty){
          emit(""String_Node_Str"");
        }
        public void defaultCase(        Type ty){
          throw new RuntimeException(""String_Node_Str"");
        }
        public void caseDoubleType(        DoubleType ty){
          emit(""String_Node_Str"");
        }
        public void caseFloatType(        FloatType ty){
          emit(""String_Node_Str"");
        }
        public void caseIntType(        IntType ty){
          emit(""String_Node_Str"");
        }
        public void caseLongType(        LongType ty){
          emit(""String_Node_Str"");
        }
        public void caseNullType(        NullType ty){
          emit(""String_Node_Str"");
        }
        public void caseRefType(        RefType ty){
          emit(""String_Node_Str"");
        }
        public void caseShortType(        ShortType ty){
          emit(""String_Node_Str"");
        }
      }
);
    }
    public void caseIfNullInst(    IfNullInst i){
      emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
    }
    public void caseIfNonNullInst(    IfNonNullInst i){
      emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
    }
    public void caseIfEqInst(    IfEqInst i){
      emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
    }
    public void caseIfNeInst(    IfNeInst i){
      emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
    }
    public void caseIfGtInst(    IfGtInst i){
      emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
    }
    public void caseIfGeInst(    IfGeInst i){
      emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
    }
    public void caseIfLtInst(    IfLtInst i){
      emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
    }
    public void caseIfLeInst(    IfLeInst i){
      emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
    }
    public void caseIfCmpEqInst(    final IfCmpEqInst i){
      i.getOpType().apply(new TypeSwitch(){
        public void caseIntType(        IntType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseBooleanType(        BooleanType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseShortType(        ShortType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseCharType(        CharType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseByteType(        ByteType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseArrayType(        ArrayType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseRefType(        RefType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseNullType(        NullType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseIfCmpNeInst(    final IfCmpNeInst i){
      i.getOpType().apply(new TypeSwitch(){
        public void caseIntType(        IntType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseBooleanType(        BooleanType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseShortType(        ShortType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseCharType(        CharType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseByteType(        ByteType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseArrayType(        ArrayType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseRefType(        RefType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseNullType(        NullType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseIfCmpGtInst(    final IfCmpGtInst i){
      i.getOpType().apply(new TypeSwitch(){
        public void caseIntType(        IntType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseBooleanType(        BooleanType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseShortType(        ShortType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseCharType(        CharType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseByteType(        ByteType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseArrayType(        ArrayType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseRefType(        RefType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseNullType(        NullType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseIfCmpGeInst(    final IfCmpGeInst i){
      i.getOpType().apply(new TypeSwitch(){
        public void caseIntType(        IntType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseBooleanType(        BooleanType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseShortType(        ShortType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseCharType(        CharType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseByteType(        ByteType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseArrayType(        ArrayType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseRefType(        RefType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseNullType(        NullType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseIfCmpLtInst(    final IfCmpLtInst i){
      i.getOpType().apply(new TypeSwitch(){
        public void caseIntType(        IntType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseBooleanType(        BooleanType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseShortType(        ShortType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseCharType(        CharType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseByteType(        ByteType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseArrayType(        ArrayType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseRefType(        RefType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseNullType(        NullType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseIfCmpLeInst(    final IfCmpLeInst i){
      i.getOpType().apply(new TypeSwitch(){
        public void caseIntType(        IntType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseBooleanType(        BooleanType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseShortType(        ShortType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseCharType(        CharType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseByteType(        ByteType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"");
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseArrayType(        ArrayType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseRefType(        RefType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void caseNullType(        NullType t){
          emit(""String_Node_Str"" + instToLabel.get(i.getTarget()));
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseStaticGetInst(    StaticGetInst i){
      SootField field=i.getField();
      emit(""String_Node_Str"" + slashify(field.getDeclaringClass().getName()) + ""String_Node_Str""+ field.getName()+ ""String_Node_Str""+ jasminDescriptorOf(field.getType()));
    }
    public void caseStaticPutInst(    StaticPutInst i){
      emit(""String_Node_Str"" + slashify(i.getField().getDeclaringClass().getName()) + ""String_Node_Str""+ i.getField().getName()+ ""String_Node_Str""+ jasminDescriptorOf(i.getField().getType()));
    }
    public void caseFieldGetInst(    FieldGetInst i){
      emit(""String_Node_Str"" + slashify(i.getField().getDeclaringClass().getName()) + ""String_Node_Str""+ i.getField().getName()+ ""String_Node_Str""+ jasminDescriptorOf(i.getField().getType()));
    }
    public void caseFieldPutInst(    FieldPutInst i){
      emit(""String_Node_Str"" + slashify(i.getField().getDeclaringClass().getName()) + ""String_Node_Str""+ i.getField().getName()+ ""String_Node_Str""+ jasminDescriptorOf(i.getField().getType()));
    }
    public void caseInstanceCastInst(    InstanceCastInst i){
      Type castType=i.getCastType();
      if (castType instanceof RefType)       emit(""String_Node_Str"" + slashify(castType.toString()));
 else       if (castType instanceof ArrayType)       emit(""String_Node_Str"" + jasminDescriptorOf(castType));
    }
    public void caseInstanceOfInst(    InstanceOfInst i){
      Type checkType=i.getCheckType();
      if (checkType instanceof RefType)       emit(""String_Node_Str"" + slashify(checkType.toString()));
 else       if (checkType instanceof ArrayType)       emit(""String_Node_Str"" + jasminDescriptorOf(checkType));
    }
    public void caseNewInst(    NewInst i){
      emit(""String_Node_Str"" + slashify(i.getBaseType().toString()));
    }
    public void casePrimitiveCastInst(    PrimitiveCastInst i){
      emit(i.toString());
    }
    public void caseStaticInvokeInst(    StaticInvokeInst i){
      SootMethod m=i.getMethod();
      emit(""String_Node_Str"" + slashify(m.getDeclaringClass().getName()) + ""String_Node_Str""+ m.getName()+ jasminDescriptorOf(m));
    }
    public void caseVirtualInvokeInst(    VirtualInvokeInst i){
      SootMethod m=i.getMethod();
      emit(""String_Node_Str"" + slashify(m.getDeclaringClass().getName()) + ""String_Node_Str""+ m.getName()+ jasminDescriptorOf(m));
    }
    public void caseInterfaceInvokeInst(    InterfaceInvokeInst i){
      SootMethod m=i.getMethod();
      emit(""String_Node_Str"" + slashify(m.getDeclaringClass().getName()) + ""String_Node_Str""+ m.getName()+ jasminDescriptorOf(m)+ ""String_Node_Str""+ (argCountOf(m) + 1));
    }
    public void caseSpecialInvokeInst(    SpecialInvokeInst i){
      SootMethod m=i.getMethod();
      emit(""String_Node_Str"" + slashify(m.getDeclaringClass().getName()) + ""String_Node_Str""+ m.getName()+ jasminDescriptorOf(m));
    }
    public void caseThrowInst(    ThrowInst i){
      emit(""String_Node_Str"");
    }
    public void caseCmpInst(    CmpInst i){
      emit(""String_Node_Str"");
    }
    public void caseCmplInst(    CmplInst i){
      if (i.getOpType().equals(FloatType.v()))       emit(""String_Node_Str"");
 else       emit(""String_Node_Str"");
    }
    public void caseCmpgInst(    CmpgInst i){
      if (i.getOpType().equals(FloatType.v()))       emit(""String_Node_Str"");
 else       emit(""String_Node_Str"");
    }
    private void emitOpTypeInst(    final String s,    final OpTypeArgInst i){
      i.getOpType().apply(new TypeSwitch(){
        private void handleIntCase(){
          emit(""String_Node_Str"" + s);
        }
        public void caseIntType(        IntType t){
          handleIntCase();
        }
        public void caseBooleanType(        BooleanType t){
          handleIntCase();
        }
        public void caseShortType(        ShortType t){
          handleIntCase();
        }
        public void caseCharType(        CharType t){
          handleIntCase();
        }
        public void caseByteType(        ByteType t){
          handleIntCase();
        }
        public void caseLongType(        LongType t){
          emit(""String_Node_Str"" + s);
        }
        public void caseDoubleType(        DoubleType t){
          emit(""String_Node_Str"" + s);
        }
        public void caseFloatType(        FloatType t){
          emit(""String_Node_Str"" + s);
        }
        public void defaultCase(        Type t){
          throw new RuntimeException(""String_Node_Str"");
        }
      }
);
    }
    public void caseAddInst(    AddInst i){
      emitOpTypeInst(""String_Node_Str"",i);
    }
    public void caseDivInst(    DivInst i){
      emitOpTypeInst(""String_Node_Str"",i);
    }
    public void caseSubInst(    SubInst i){
      emitOpTypeInst(""String_Node_Str"",i);
    }
    public void caseMulInst(    MulInst i){
      emitOpTypeInst(""String_Node_Str"",i);
    }
    public void caseRemInst(    RemInst i){
      emitOpTypeInst(""String_Node_Str"",i);
    }
    public void caseShlInst(    ShlInst i){
      emitOpTypeInst(""String_Node_Str"",i);
    }
    public void caseAndInst(    AndInst i){
      emitOpTypeInst(""String_Node_Str"",i);
    }
    public void caseOrInst(    OrInst i){
      emitOpTypeInst(""String_Node_Str"",i);
    }
    public void caseXorInst(    XorInst i){
      emitOpTypeInst(""String_Node_Str"",i);
    }
    public void caseShrInst(    ShrInst i){
      emitOpTypeInst(""String_Node_Str"",i);
    }
    public void caseUshrInst(    UshrInst i){
      emitOpTypeInst(""String_Node_Str"",i);
    }
    public void caseIncInst(    IncInst i){
      if (((ValueBox)i.getUseBoxes().get(0)).getValue() != ((ValueBox)i.getDefBoxes().get(0)).getValue())       throw new RuntimeException(""String_Node_Str"");
      emit(""String_Node_Str"" + ((Integer)localToSlot.get(i.getLocal())) + ""String_Node_Str""+ i.getConstant());
    }
    public void caseArrayLengthInst(    ArrayLengthInst i){
      emit(""String_Node_Str"");
    }
    public void caseNegInst(    NegInst i){
      emitOpTypeInst(""String_Node_Str"",i);
    }
    public void caseNewArrayInst(    NewArrayInst i){
      if (i.getBaseType() instanceof RefType)       emit(""String_Node_Str"" + slashify(i.getBaseType().toString()));
 else       if (i.getBaseType() instanceof ArrayType)       emit(""String_Node_Str"" + jasminDescriptorOf(i.getBaseType()));
 else       emit(""String_Node_Str"" + i.getBaseType().toString());
    }
    public void caseNewMultiArrayInst(    NewMultiArrayInst i){
      emit(""String_Node_Str"" + jasminDescriptorOf(i.getBaseType()) + ""String_Node_Str""+ i.getDimensionCount());
    }
    public void caseLookupSwitchInst(    LookupSwitchInst i){
      emit(""String_Node_Str"");
      List lookupValues=i.getLookupValues();
      List targets=i.getTargets();
      for (int j=0; j < lookupValues.size(); j++)       emit(""String_Node_Str"" + lookupValues.get(j) + ""String_Node_Str""+ instToLabel.get(targets.get(j)));
      emit(""String_Node_Str"" + instToLabel.get(i.getDefaultTarget()));
    }
    public void caseTableSwitchInst(    TableSwitchInst i){
      emit(""String_Node_Str"" + i.getLowIndex() + ""String_Node_Str""+ i.getHighIndex());
      List targets=i.getTargets();
      for (int j=0; j < targets.size(); j++)       emit(""String_Node_Str"" + instToLabel.get(targets.get(j)));
      emit(""String_Node_Str"" + instToLabel.get(i.getDefaultTarget()));
    }
    private boolean isDwordType(    Type t){
      return t instanceof LongType || t instanceof DoubleType || t instanceof DoubleWordType;
    }
    public void caseDup1Inst(    Dup1Inst i){
      Type firstOpType=i.getOp1Type();
      if (isDwordType(firstOpType))       emit(""String_Node_Str"");
 else       emit(""String_Node_Str"");
    }
    public void caseDup2Inst(    Dup2Inst i){
      Type firstOpType=i.getOp1Type();
      Type secondOpType=i.getOp2Type();
      if (isDwordType(firstOpType)) {
        emit(""String_Node_Str"");
        if (isDwordType(secondOpType)) {
          emit(""String_Node_Str"");
        }
 else         emit(""String_Node_Str"");
      }
 else       if (isDwordType(secondOpType)) {
        if (isDwordType(firstOpType)) {
          emit(""String_Node_Str"");
        }
 else         emit(""String_Node_Str"");
        emit(""String_Node_Str"");
      }
 else {
        G.v().out.println(""String_Node_Str"");
        emit(""String_Node_Str"");
      }
    }
    public void caseDup1_x1Inst(    Dup1_x1Inst i){
      Type opType=i.getOp1Type();
      Type underType=i.getUnder1Type();
      if (isDwordType(opType)) {
        if (isDwordType(underType)) {
          emit(""String_Node_Str"");
        }
 else         emit(""String_Node_Str"");
      }
 else {
        if (isDwordType(underType))         emit(""String_Node_Str"");
 else         emit(""String_Node_Str"");
      }
    }
    public void caseDup1_x2Inst(    Dup1_x2Inst i){
      Type opType=i.getOp1Type();
      Type under1Type=i.getUnder1Type();
      Type under2Type=i.getUnder2Type();
      if (isDwordType(opType)) {
        if (!isDwordType(under1Type) && !isDwordType(under2Type))         emit(""String_Node_Str"");
 else         throw new RuntimeException(""String_Node_Str"");
      }
 else {
        if (isDwordType(under1Type) || isDwordType(under2Type))         throw new RuntimeException(""String_Node_Str"");
      }
      emit(""String_Node_Str"");
    }
    public void caseDup2_x1Inst(    Dup2_x1Inst i){
      Type op1Type=i.getOp1Type();
      Type op2Type=i.getOp2Type();
      Type under1Type=i.getUnder1Type();
      if (isDwordType(under1Type)) {
        if (!isDwordType(op1Type) && !isDwordType(op2Type))         throw new RuntimeException(""String_Node_Str"");
 else         emit(""String_Node_Str"");
      }
 else {
        if (isDwordType(op1Type) || isDwordType(op2Type))         throw new RuntimeException(""String_Node_Str"");
      }
      emit(""String_Node_Str"");
    }
    public void caseDup2_x2Inst(    Dup2_x2Inst i){
      Type op1Type=i.getOp1Type();
      Type op2Type=i.getOp2Type();
      Type under1Type=i.getUnder1Type();
      Type under2Type=i.getUnder2Type();
      if (isDwordType(op1Type) || isDwordType(op2Type) || isDwordType(under1Type)|| isDwordType(under1Type))       throw new RuntimeException(""String_Node_Str"");
      emit(""String_Node_Str"");
    }
    public void caseSwapInst(    SwapInst i){
      emit(""String_Node_Str"");
    }
  }
);
}"
88726,"public void caseDup1_x2Inst(Dup1_x2Inst i){
  Type opType=i.getOpType();
  Type under1Type=i.getUnder1Type();
  Type under2Type=i.getUnder2Type();
  if (isDwordType(opType)) {
    if (!isDwordType(under1Type) && !isDwordType(under2Type))     emit(""String_Node_Str"");
 else     throw new RuntimeException(""String_Node_Str"");
  }
 else {
    if (isDwordType(under1Type) || isDwordType(under2Type))     throw new RuntimeException(""String_Node_Str"");
  }
  emit(""String_Node_Str"");
}","public void caseDup1_x2Inst(Dup1_x2Inst i){
  Type opType=i.getOp1Type();
  Type under1Type=i.getUnder1Type();
  Type under2Type=i.getUnder2Type();
  if (isDwordType(opType)) {
    if (!isDwordType(under1Type) && !isDwordType(under2Type))     emit(""String_Node_Str"");
 else     throw new RuntimeException(""String_Node_Str"");
  }
 else {
    if (isDwordType(under1Type) || isDwordType(under2Type))     throw new RuntimeException(""String_Node_Str"");
  }
  emit(""String_Node_Str"");
}"
88727,"public void caseDup2_x1Inst(Dup2_x1Inst i){
  Type op1Type=i.getOp1Type();
  Type op2Type=i.getOp2Type();
  Type under1Type=i.getUnder1Type();
  if (isDwordType(under1Type)) {
    if (!isDwordType(op1Type) && !isDwordType(under2Type))     throw new RuntimeException(""String_Node_Str"");
 else     emit(""String_Node_Str"");
  }
 else {
    if (isDwordType(op1Type) || isDwordType(op2Type))     throw new RuntimeException(""String_Node_Str"");
  }
  emit(""String_Node_Str"");
}","public void caseDup2_x1Inst(Dup2_x1Inst i){
  Type op1Type=i.getOp1Type();
  Type op2Type=i.getOp2Type();
  Type under1Type=i.getUnder1Type();
  if (isDwordType(under1Type)) {
    if (!isDwordType(op1Type) && !isDwordType(op2Type))     throw new RuntimeException(""String_Node_Str"");
 else     emit(""String_Node_Str"");
  }
 else {
    if (isDwordType(op1Type) || isDwordType(op2Type))     throw new RuntimeException(""String_Node_Str"");
  }
  emit(""String_Node_Str"");
}"
88728,"protected String varNode(String dirPrefix,VarNode vv){
  StringBuffer ret=new StringBuffer();
  ret.append(""String_Node_Str"" + dirPrefix + ""String_Node_Str""+ vv.getNumber()+ ""String_Node_Str"");
  ret.append(""String_Node_Str"" + htmlify(vv.getVariable().toString()));
  ret.append(""String_Node_Str"");
  ret.append(""String_Node_Str"");
  ret.append(""String_Node_Str"" + (vv.context() == null ? ""String_Node_Str"" : htmlify(vv.context().toString())));
  ret.append(""String_Node_Str"");
  if (vv instanceof LocalVarNode) {
    LocalVarNode lvn=(LocalVarNode)vv;
    ret.append(""String_Node_Str"" + toFileName(lvn.getMethod().toString()) + ""String_Node_Str"");
    ret.append(htmlify(lvn.getMethod().toString()) + ""String_Node_Str"");
  }
  ret.append(htmlify(vv.getType().toString()) + ""String_Node_Str"");
  return ret.toString();
}","protected String varNode(String dirPrefix,VarNode vv){
  StringBuffer ret=new StringBuffer();
  ret.append(""String_Node_Str"" + dirPrefix + ""String_Node_Str""+ vv.getNumber()+ ""String_Node_Str"");
  ret.append(""String_Node_Str"" + htmlify(vv.getVariable().toString()));
  ret.append(""String_Node_Str"");
  ret.append(""String_Node_Str"");
  ret.append(""String_Node_Str"" + (vv.context() == null ? ""String_Node_Str"" : htmlify(vv.context().toString())));
  ret.append(""String_Node_Str"");
  if (vv instanceof LocalVarNode) {
    LocalVarNode lvn=(LocalVarNode)vv;
    SootMethod m=lvn.getMethod();
    if (m != null) {
      ret.append(""String_Node_Str"" + toFileName(m.toString()) + ""String_Node_Str"");
      ret.append(htmlify(m.toString()) + ""String_Node_Str"");
    }
  }
  ret.append(htmlify(vv.getType().toString()) + ""String_Node_Str"");
  return ret.toString();
}"
88729,"public void dump(){
  for (Iterator vIt=pag.getVarNodeNumberer().iterator(); vIt.hasNext(); ) {
    final VarNode v=(VarNode)vIt.next();
    mergedNodes.put(v.getReplacement(),v);
    if (v instanceof LocalVarNode) {
      methodToNodes.put(((LocalVarNode)v).getMethod(),v);
    }
  }
  try {
    JarOutputStream jarOut=new JarOutputStream(new FileOutputStream(new File(output_dir,""String_Node_Str"")));
    for (Iterator vIt=mergedNodes.keySet().iterator(); vIt.hasNext(); ) {
      final VarNode v=(VarNode)vIt.next();
      dumpVarNode(v,jarOut);
    }
    for (Iterator mIt=methodToNodes.keySet().iterator(); mIt.hasNext(); ) {
      final SootMethod m=(SootMethod)mIt.next();
      dumpMethod(m,jarOut);
    }
    addSymLinks(pag.getVarNodeNumberer().iterator(),jarOut);
    jarOut.close();
  }
 catch (  IOException e) {
    throw new RuntimeException(""String_Node_Str"" + e);
  }
}","public void dump(){
  for (Iterator vIt=pag.getVarNodeNumberer().iterator(); vIt.hasNext(); ) {
    final VarNode v=(VarNode)vIt.next();
    mergedNodes.put(v.getReplacement(),v);
    if (v instanceof LocalVarNode) {
      SootMethod m=((LocalVarNode)v).getMethod();
      if (m != null) {
        methodToNodes.put(m,v);
      }
    }
  }
  try {
    JarOutputStream jarOut=new JarOutputStream(new FileOutputStream(new File(output_dir,""String_Node_Str"")));
    for (Iterator vIt=mergedNodes.keySet().iterator(); vIt.hasNext(); ) {
      final VarNode v=(VarNode)vIt.next();
      dumpVarNode(v,jarOut);
    }
    for (Iterator mIt=methodToNodes.keySet().iterator(); mIt.hasNext(); ) {
      final SootMethod m=(SootMethod)mIt.next();
      dumpMethod(m,jarOut);
    }
    addSymLinks(pag.getVarNodeNumberer().iterator(),jarOut);
    jarOut.close();
  }
 catch (  IOException e) {
    throw new RuntimeException(""String_Node_Str"" + e);
  }
}"
88730,"private int addJimpleLnTags(int lnNum,SootMethod meth){
  meth.addTag(new JimpleLineNumberTag(lnNum));
  lnNum++;
  return lnNum;
}","private int addJimpleLnTags(int lnNum,SootField f){
  f.addTag(new JimpleLineNumberTag(lnNum));
  lnNum++;
  return lnNum;
}"
88731,"public void collectTags(SootClass sc){
  Iterator fit=sc.getFields().iterator();
  while (fit.hasNext()) {
    SootField sf=(SootField)fit.next();
    collectFieldTags(sf);
  }
  Iterator it=sc.getMethods().iterator();
  while (it.hasNext()) {
    SootMethod sm=(SootMethod)it.next();
    collectMethodTags(sm);
    Body b=sm.getActiveBody();
    collectBodyTags(b);
  }
}","public void collectTags(SootClass sc){
  Iterator fit=sc.getFields().iterator();
  while (fit.hasNext()) {
    SootField sf=(SootField)fit.next();
    collectFieldTags(sf);
  }
  Iterator it=sc.getMethods().iterator();
  while (it.hasNext()) {
    SootMethod sm=(SootMethod)it.next();
    collectMethodTags(sm);
    if (!sm.hasActiveBody())     continue;
    Body b=sm.getActiveBody();
    collectBodyTags(b);
  }
}"
88732,"private void clearPres(){
  if (getEditorPart() == null)   return;
  if (getEditorPart().getEditorInput() != null) {
    getDisplay().asyncExec(new Runnable(){
      public void run(){
        ((AbstractTextEditor)getEditorPart()).setInput(getEditorPart().getEditorInput());
      }
    }
);
  }
}","private void clearPres(){
  if (getEditorPart() == null)   return;
  if (getEditorPart().getEditorInput() != null) {
    getDisplay().syncExec(new Runnable(){
      public void run(){
        ((AbstractTextEditor)getEditorPart()).setInput(getEditorPart().getEditorInput());
      }
    }
);
  }
}"
88733,"public void runFinish(){
  getFileHandler().refreshFolder();
  getFileHandler().refreshAll(getSootSelection().getProject());
  SootPlugin.getDefault().getManager().updateSootRanFlag();
  IEditorPart activeEdPart=SootPlugin.getDefault().getWorkbench().getActiveWorkbenchWindow().getActivePage().getActiveEditor();
  SootPlugin.getDefault().getPartManager().updatePart(activeEdPart);
}","public void runFinish(){
  getFileHandler().refreshFolder();
  getFileHandler().refreshAll(getSootSelection().getProject());
  SootPlugin.getDefault().getManager().updateSootRanFlag();
  final IEditorPart activeEdPart=SootPlugin.getDefault().getWorkbench().getActiveWorkbenchWindow().getActivePage().getActiveEditor();
  SootPlugin.getDefault().getPartManager().updatePart(activeEdPart);
}"
88734,"public ArrayList toRunArray(){
  addEclipseDefsToArray();
  if (getRunArray() == null) {
    setRunArray(new ArrayList());
  }
  Iterator it=getSaveArray().iterator();
  String lastKey=""String_Node_Str"";
  while (it.hasNext()) {
    String test=(String)it.next();
    String spliter=""String_Node_Str"";
    if (test.indexOf(""String_Node_Str"") != -1) {
      spliter=""String_Node_Str"";
    }
 else     if (test.indexOf('\n') != -1) {
      spliter=""String_Node_Str"";
    }
    System.out.println(""String_Node_Str"" + test);
    if (test.equals(""String_Node_Str"")) {
    }
 else     if (test.indexOf(spliter) != -1) {
      System.out.println(""String_Node_Str"");
      String[] tokens=test.split(spliter);
      getRunArray().add(tokens[0]);
      System.out.println(""String_Node_Str"" + tokens[0]);
      for (int i=1; i < tokens.length; i++) {
        getRunArray().add(lastKey);
        getRunArray().add(tokens[i]);
        System.out.println(""String_Node_Str"" + tokens[i]);
      }
    }
 else {
      getRunArray().add(test);
    }
    lastKey=test;
  }
  return getRunArray();
}","public ArrayList toRunArray(){
  addEclipseDefsToArray();
  if (getRunArray() == null) {
    setRunArray(new ArrayList());
  }
  Iterator it=getSaveArray().iterator();
  String lastKey=""String_Node_Str"";
  while (it.hasNext()) {
    String test=(String)it.next();
    String spliter=""String_Node_Str"";
    if (test.indexOf(""String_Node_Str"") != -1) {
      spliter=""String_Node_Str"";
    }
 else     if (test.indexOf('\n') != -1) {
      spliter=""String_Node_Str"";
    }
    System.out.println(""String_Node_Str"" + test);
    if (test.equals(""String_Node_Str"")) {
    }
 else     if (test.equals(""String_Node_Str"")) {
      int index=getRunArray().size() - 1;
      getRunArray().remove(index);
    }
 else     if (test.indexOf(spliter) != -1) {
      System.out.println(""String_Node_Str"");
      String[] tokens=test.split(spliter);
      getRunArray().add(tokens[0]);
      System.out.println(""String_Node_Str"" + tokens[0]);
      for (int i=1; i < tokens.length; i++) {
        getRunArray().add(lastKey);
        getRunArray().add(tokens[i]);
        System.out.println(""String_Node_Str"" + tokens[i]);
      }
    }
 else {
      getRunArray().add(test);
    }
    lastKey=test;
  }
  return getRunArray();
}"
88735,"public ArrayList toSaveArray(){
  if (getSaveArray() == null) {
    setSaveArray(new ArrayList());
  }
  removeEclipseDefs();
  Iterator keysIt=getConfig().keySet().iterator();
  while (keysIt.hasNext()) {
    String key=(String)keysIt.next();
    StringTokenizer st=new StringTokenizer(key);
    Object val=getConfig().get(key);
switch (st.countTokens()) {
case 1:
{
        String aliasName=st.nextToken();
        if (aliasName.equals(""String_Node_Str""))         continue;
        System.out.println(""String_Node_Str"" + aliasName);
        getSaveArray().add(DASH + aliasName);
        if (val instanceof Boolean) {
          getSaveArray().add(val.toString());
        }
 else         if (val instanceof String) {
          String test=(String)val;
          String spliter=""String_Node_Str"";
          if (test.indexOf(""String_Node_Str"") != -1) {
            spliter=""String_Node_Str"";
          }
 else           if (test.indexOf('\n') != -1) {
            spliter=""String_Node_Str"";
          }
          System.out.println(""String_Node_Str"" + test);
          if (test.indexOf(spliter) != -1) {
            System.out.println(""String_Node_Str"");
            String[] tokens=test.split(spliter);
            getSaveArray().add(tokens[0]);
            for (int i=1; i < tokens.length; i++) {
              getSaveArray().add(DASH + aliasName);
              getSaveArray().add(tokens[i]);
              System.out.println(""String_Node_Str"" + tokens[i]);
            }
          }
 else {
            getSaveArray().add(val);
          }
        }
        break;
      }
case 3:
{
      getSaveArray().add(DASH + st.nextToken());
      getSaveArray().add(st.nextToken());
      String realVal=st.nextToken() + COLON;
      if (val instanceof Boolean) {
        realVal=realVal + val.toString();
      }
 else       if (val instanceof String) {
        realVal=realVal + val;
      }
      getSaveArray().add(realVal);
      break;
    }
default :
{
    break;
  }
}
}
return getSaveArray();
}","public ArrayList toSaveArray(){
  if (getSaveArray() == null) {
    setSaveArray(new ArrayList());
  }
  removeEclipseDefs();
  Iterator keysIt=getConfig().keySet().iterator();
  while (keysIt.hasNext()) {
    String key=(String)keysIt.next();
    StringTokenizer st=new StringTokenizer(key);
    Object val=getConfig().get(key);
    System.out.println(""String_Node_Str"" + val);
switch (st.countTokens()) {
case 1:
{
        String aliasName=st.nextToken();
        if (aliasName.equals(""String_Node_Str""))         continue;
        System.out.println(""String_Node_Str"" + aliasName);
        if (val instanceof String) {
          String test=(String)val;
          if ((test == null) | (test.length() == 0)) {
            System.out.println(""String_Node_Str"");
            continue;
          }
        }
        getSaveArray().add(DASH + aliasName);
        if (val instanceof Boolean) {
          getSaveArray().add(val.toString());
        }
 else         if (val instanceof String) {
          String test=(String)val;
          String spliter=""String_Node_Str"";
          if (test.indexOf(""String_Node_Str"") != -1) {
            spliter=""String_Node_Str"";
          }
 else           if (test.indexOf('\n') != -1) {
            spliter=""String_Node_Str"";
          }
          System.out.println(""String_Node_Str"" + test);
          if (test.indexOf(spliter) != -1) {
            System.out.println(""String_Node_Str"");
            String[] tokens=test.split(spliter);
            getSaveArray().add(tokens[0]);
            for (int i=1; i < tokens.length; i++) {
              getSaveArray().add(DASH + aliasName);
              getSaveArray().add(tokens[i]);
              System.out.println(""String_Node_Str"" + tokens[i]);
            }
          }
 else {
            System.out.println(""String_Node_Str"" + val);
            getSaveArray().add(val);
          }
        }
        break;
      }
case 3:
{
      getSaveArray().add(DASH + st.nextToken());
      getSaveArray().add(st.nextToken());
      String realVal=st.nextToken() + COLON;
      if (val instanceof Boolean) {
        realVal=realVal + val.toString();
      }
 else       if (val instanceof String) {
        realVal=realVal + val;
      }
      getSaveArray().add(realVal);
      break;
    }
default :
{
    break;
  }
}
}
return getSaveArray();
}"
88736,"void generateJimple(Instruction ins,TypeStack typeStack,TypeStack postTypeStack,cp_info constant_pool[],List statements,BasicBlock basicBlock){
  Value[] params;
  Value v1=null, v2=null, v3=null, v4=null;
  Local l1=null, l2=null, l3=null, l4=null;
  Expr e=null, rhs=null;
  BinopExpr b=null;
  ConditionExpr co=null;
  ArrayRef a=null;
  int args;
  Value rvalue;
  Stmt stmt=null;
  int x=((int)(ins.code)) & 0xff;
  Util.v().activeOriginalIndex=ins.originalIndex;
  Util.v().isLocalStore=false;
  Util.v().isWideLocalStore=false;
switch (x) {
case ByteCode.BIPUSH:
    rvalue=IntConstant.v(((Instruction_Bipush)ins).arg_b);
  stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rvalue);
break;
case ByteCode.SIPUSH:
rvalue=IntConstant.v(((Instruction_Sipush)ins).arg_i);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rvalue);
break;
case ByteCode.LDC1:
generateJimpleForCPEntry(constant_pool,((Instruction_Ldc1)ins).arg_b,typeStack,postTypeStack,jmethod,statements);
break;
case ByteCode.LDC2:
case ByteCode.LDC2W:
generateJimpleForCPEntry(constant_pool,((Instruction_intindex)ins).arg_i,typeStack,postTypeStack,jmethod,statements);
break;
case ByteCode.ACONST_NULL:
rvalue=NullConstant.v();
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rvalue);
break;
case ByteCode.ICONST_M1:
case ByteCode.ICONST_0:
case ByteCode.ICONST_1:
case ByteCode.ICONST_2:
case ByteCode.ICONST_3:
case ByteCode.ICONST_4:
case ByteCode.ICONST_5:
rvalue=IntConstant.v(x - ByteCode.ICONST_0);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rvalue);
break;
case ByteCode.LCONST_0:
case ByteCode.LCONST_1:
rvalue=LongConstant.v(x - ByteCode.LCONST_0);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rvalue);
break;
case ByteCode.FCONST_0:
case ByteCode.FCONST_1:
case ByteCode.FCONST_2:
rvalue=FloatConstant.v((float)(x - ByteCode.FCONST_0));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rvalue);
break;
case ByteCode.DCONST_0:
case ByteCode.DCONST_1:
rvalue=DoubleConstant.v((double)(x - ByteCode.DCONST_0));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rvalue);
break;
case ByteCode.ILOAD:
{
Local local=(Local)Util.v().getLocalForIndex(listBody,((Instruction_bytevar)ins).arg_b);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),local);
break;
}
case ByteCode.FLOAD:
{
Local local=(Local)Util.v().getLocalForIndex(listBody,((Instruction_bytevar)ins).arg_b);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),local);
break;
}
case ByteCode.ALOAD:
{
Local local=Util.v().getLocalForIndex(listBody,((Instruction_bytevar)ins).arg_b);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),local);
break;
}
case ByteCode.DLOAD:
{
Local local=Util.v().getLocalForIndex(listBody,((Instruction_bytevar)ins).arg_b);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),local);
break;
}
case ByteCode.LLOAD:
{
Local local=Util.v().getLocalForIndex(listBody,((Instruction_bytevar)ins).arg_b);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),local);
break;
}
case ByteCode.ILOAD_0:
case ByteCode.ILOAD_1:
case ByteCode.ILOAD_2:
case ByteCode.ILOAD_3:
{
Local local=Util.v().getLocalForIndex(listBody,(x - ByteCode.ILOAD_0));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),local);
break;
}
case ByteCode.FLOAD_0:
case ByteCode.FLOAD_1:
case ByteCode.FLOAD_2:
case ByteCode.FLOAD_3:
{
Local local=Util.v().getLocalForIndex(listBody,(x - ByteCode.FLOAD_0));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),local);
break;
}
case ByteCode.ALOAD_0:
case ByteCode.ALOAD_1:
case ByteCode.ALOAD_2:
case ByteCode.ALOAD_3:
{
Local local=Util.v().getLocalForIndex(listBody,(x - ByteCode.ALOAD_0));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),local);
break;
}
case ByteCode.LLOAD_0:
case ByteCode.LLOAD_1:
case ByteCode.LLOAD_2:
case ByteCode.LLOAD_3:
{
Local local=Util.v().getLocalForIndex(listBody,(x - ByteCode.LLOAD_0));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),local);
break;
}
case ByteCode.DLOAD_0:
case ByteCode.DLOAD_1:
case ByteCode.DLOAD_2:
case ByteCode.DLOAD_3:
{
Local local=Util.v().getLocalForIndex(listBody,(x - ByteCode.DLOAD_0));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),local);
break;
}
case ByteCode.ISTORE:
{
Util.v().isLocalStore=true;
Util.v().isWideLocalStore=true;
Local local=Util.v().getLocalForIndex(listBody,((Instruction_bytevar)ins).arg_b);
stmt=Jimple.v().newAssignStmt(local,Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
break;
}
case ByteCode.FSTORE:
{
Util.v().isLocalStore=true;
Util.v().isWideLocalStore=true;
Local local=Util.v().getLocalForIndex(listBody,((Instruction_bytevar)ins).arg_b);
stmt=Jimple.v().newAssignStmt(local,Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
break;
}
case ByteCode.ASTORE:
{
Util.v().isLocalStore=true;
Util.v().isWideLocalStore=true;
Local local=Util.v().getLocalForIndex(listBody,((Instruction_bytevar)ins).arg_b);
stmt=Jimple.v().newAssignStmt(local,Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
break;
}
case ByteCode.LSTORE:
{
Util.v().isLocalStore=true;
Util.v().isWideLocalStore=true;
Local local=Util.v().getLocalForIndex(listBody,((Instruction_bytevar)ins).arg_b);
stmt=Jimple.v().newAssignStmt(local,Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
break;
}
case ByteCode.DSTORE:
{
Util.v().isLocalStore=true;
Util.v().isWideLocalStore=true;
Local local=Util.v().getLocalForIndex(listBody,((Instruction_bytevar)ins).arg_b);
stmt=Jimple.v().newAssignStmt(local,Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
break;
}
case ByteCode.ISTORE_0:
case ByteCode.ISTORE_1:
case ByteCode.ISTORE_2:
case ByteCode.ISTORE_3:
{
Util.v().isLocalStore=true;
Local local=Util.v().getLocalForIndex(listBody,(x - ByteCode.ISTORE_0));
stmt=Jimple.v().newAssignStmt(local,Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
break;
}
case ByteCode.FSTORE_0:
case ByteCode.FSTORE_1:
case ByteCode.FSTORE_2:
case ByteCode.FSTORE_3:
{
Util.v().isLocalStore=true;
Local local=(Local)Util.v().getLocalForIndex(listBody,(x - ByteCode.FSTORE_0));
stmt=Jimple.v().newAssignStmt(local,Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
break;
}
case ByteCode.ASTORE_0:
case ByteCode.ASTORE_1:
case ByteCode.ASTORE_2:
case ByteCode.ASTORE_3:
{
Util.v().isLocalStore=true;
Local local=Util.v().getLocalForIndex(listBody,(x - ByteCode.ASTORE_0));
stmt=Jimple.v().newAssignStmt(local,Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
break;
}
case ByteCode.LSTORE_0:
case ByteCode.LSTORE_1:
case ByteCode.LSTORE_2:
case ByteCode.LSTORE_3:
{
Util.v().isLocalStore=true;
Local local=Util.v().getLocalForIndex(listBody,(x - ByteCode.LSTORE_0));
stmt=Jimple.v().newAssignStmt(local,Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
break;
}
case ByteCode.DSTORE_0:
case ByteCode.DSTORE_1:
case ByteCode.DSTORE_2:
case ByteCode.DSTORE_3:
{
Util.v().isLocalStore=true;
Local local=Util.v().getLocalForIndex(listBody,(x - ByteCode.DSTORE_0));
stmt=Jimple.v().newAssignStmt(local,Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
break;
}
case ByteCode.IINC:
{
Local local=Util.v().getLocalForIndex(listBody,((Instruction_Iinc)ins).arg_b);
int amt=(((Instruction_Iinc)ins).arg_c);
rhs=Jimple.v().newAddExpr(local,IntConstant.v(amt));
stmt=Jimple.v().newAssignStmt(local,rhs);
break;
}
case ByteCode.WIDE:
throw new RuntimeException(""String_Node_Str"");
case ByteCode.NEWARRAY:
{
Type baseType=(Type)jimpleTypeOfAtype(((Instruction_Newarray)ins).atype);
rhs=Jimple.v().newNewArrayExpr(baseType,Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
}
case ByteCode.ANEWARRAY:
{
String baseName=getClassName(constant_pool,((Instruction_Anewarray)ins).arg_i);
Type baseType;
if (baseName.startsWith(""String_Node_Str"")) baseType=Util.v().jimpleTypeOfFieldDescriptor(cm,getClassName(constant_pool,((Instruction_Anewarray)ins).arg_i));
 else baseType=RefType.v(baseName);
rhs=Jimple.v().newNewArrayExpr(baseType,Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
}
case ByteCode.MULTIANEWARRAY:
{
int bdims=(int)(((Instruction_Multianewarray)ins).dims);
List dims=new ArrayList();
for (int j=0; j < bdims; j++) dims.add(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - bdims + j + 1));
String mstype=constant_pool[((Instruction_Multianewarray)ins).arg_i].toString(constant_pool);
ArrayType jimpleType=(ArrayType)Util.v().jimpleTypeOfFieldDescriptor(cm,mstype);
rhs=Jimple.v().newNewMultiArrayExpr(jimpleType,dims);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
}
case ByteCode.ARRAYLENGTH:
rhs=Jimple.v().newLengthExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.IALOAD:
case ByteCode.BALOAD:
case ByteCode.CALOAD:
case ByteCode.SALOAD:
case ByteCode.FALOAD:
case ByteCode.LALOAD:
case ByteCode.DALOAD:
case ByteCode.AALOAD:
a=Jimple.v().newArrayRef(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),a);
break;
case ByteCode.IASTORE:
case ByteCode.FASTORE:
case ByteCode.AASTORE:
case ByteCode.BASTORE:
case ByteCode.CASTORE:
case ByteCode.SASTORE:
a=Jimple.v().newArrayRef(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 2),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1));
stmt=Jimple.v().newAssignStmt(a,Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
break;
case ByteCode.LASTORE:
case ByteCode.DASTORE:
a=Jimple.v().newArrayRef(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 3),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 2));
stmt=Jimple.v().newAssignStmt(a,Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
break;
case ByteCode.NOP:
stmt=Jimple.v().newNopStmt();
break;
case ByteCode.POP:
case ByteCode.POP2:
stmt=Jimple.v().newNopStmt();
break;
case ByteCode.DUP:
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
break;
case ByteCode.DUP2:
if (typeSize(typeStack.top()) == 2) {
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1));
}
 else {
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1));
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
statements.add(stmt);
stmt=null;
}
break;
case ByteCode.DUP_X1:
l1=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex());
l2=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),l1);
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 1),l2);
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 2),Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()));
statements.add(stmt);
stmt=null;
break;
case ByteCode.DUP_X2:
if (typeSize(typeStack.get(typeStack.topIndex() - 2)) == 2) {
l3=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 2);
l1=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex());
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 2),l3);
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 3),l1);
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),l1);
statements.add(stmt);
stmt=null;
}
 else {
l3=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 2);
l2=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1);
l1=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex());
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),l1);
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 1),l2);
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 2),l3);
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 3),Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()));
statements.add(stmt);
stmt=null;
}
break;
case ByteCode.DUP2_X1:
if (typeSize(typeStack.get(typeStack.topIndex() - 1)) == 2) {
l2=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1);
l3=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 2);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 1),l2);
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 2),l3);
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 4),Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 1));
statements.add(stmt);
stmt=null;
}
 else {
l3=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 2);
l2=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1);
l1=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex());
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),l1);
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 1),l2);
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 2),l3);
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 3),Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()));
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 4),Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 1));
statements.add(stmt);
stmt=null;
}
break;
case ByteCode.DUP2_X2:
if (typeSize(typeStack.get(typeStack.topIndex() - 1)) == 2) {
l2=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 1),l2);
statements.add(stmt);
}
 else {
l1=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex());
l2=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 1),l2);
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),l1);
statements.add(stmt);
}
if (typeSize(typeStack.get(typeStack.topIndex() - 3)) == 2) {
l4=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 3);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 3),l4);
statements.add(stmt);
}
 else {
l4=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 3);
l3=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 2);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 3),l4);
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 2),l3);
statements.add(stmt);
}
if (typeSize(typeStack.get(typeStack.topIndex() - 1)) == 2) {
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 5),Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 1));
statements.add(stmt);
}
 else {
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 5),Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 1));
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 4),Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()));
statements.add(stmt);
}
stmt=null;
break;
case ByteCode.SWAP:
{
Local first;
typeStack=typeStack.push(typeStack.top());
first=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex());
typeStack=typeStack.pop();
Local second=Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex());
Local third=Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 1);
stmt=Jimple.v().newAssignStmt(first,second);
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(second,third);
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(third,first);
statements.add(stmt);
stmt=null;
break;
}
case ByteCode.FADD:
case ByteCode.IADD:
rhs=Jimple.v().newAddExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.DADD:
case ByteCode.LADD:
rhs=Jimple.v().newAddExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 3),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.FSUB:
case ByteCode.ISUB:
rhs=Jimple.v().newSubExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.DSUB:
case ByteCode.LSUB:
rhs=Jimple.v().newSubExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 3),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.FMUL:
case ByteCode.IMUL:
rhs=Jimple.v().newMulExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.DMUL:
case ByteCode.LMUL:
rhs=Jimple.v().newMulExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 3),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.FDIV:
case ByteCode.IDIV:
rhs=Jimple.v().newDivExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.DDIV:
case ByteCode.LDIV:
rhs=Jimple.v().newDivExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 3),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.FREM:
case ByteCode.IREM:
rhs=Jimple.v().newRemExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.DREM:
case ByteCode.LREM:
rhs=Jimple.v().newRemExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 3),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.INEG:
case ByteCode.LNEG:
case ByteCode.FNEG:
case ByteCode.DNEG:
rhs=Jimple.v().newNegExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.ISHL:
rhs=Jimple.v().newShlExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.ISHR:
rhs=Jimple.v().newShrExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.IUSHR:
rhs=Jimple.v().newUshrExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.LSHL:
rhs=Jimple.v().newShlExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 2),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.LSHR:
rhs=Jimple.v().newShrExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 2),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.LUSHR:
rhs=Jimple.v().newUshrExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 2),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.IAND:
rhs=Jimple.v().newAndExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.LAND:
rhs=Jimple.v().newAndExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 3),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.IOR:
rhs=Jimple.v().newOrExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.LOR:
rhs=Jimple.v().newOrExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 3),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.IXOR:
rhs=Jimple.v().newXorExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.LXOR:
rhs=Jimple.v().newXorExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 3),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.D2L:
case ByteCode.F2L:
case ByteCode.I2L:
rhs=Jimple.v().newCastExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),LongType.v());
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.D2F:
case ByteCode.L2F:
case ByteCode.I2F:
rhs=Jimple.v().newCastExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),FloatType.v());
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.I2D:
case ByteCode.L2D:
case ByteCode.F2D:
rhs=Jimple.v().newCastExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),DoubleType.v());
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.L2I:
case ByteCode.F2I:
case ByteCode.D2I:
rhs=Jimple.v().newCastExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),IntType.v());
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.INT2BYTE:
rhs=Jimple.v().newCastExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),ByteType.v());
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.INT2CHAR:
rhs=Jimple.v().newCastExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),CharType.v());
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.INT2SHORT:
rhs=Jimple.v().newCastExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),ShortType.v());
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.IFEQ:
co=Jimple.v().newEqExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),IntConstant.v(0));
stmt=Jimple.v().newIfStmt(co,new FutureStmt());
break;
case ByteCode.IFNULL:
co=Jimple.v().newEqExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),NullConstant.v());
stmt=Jimple.v().newIfStmt(co,new FutureStmt());
break;
case ByteCode.IFLT:
co=Jimple.v().newLtExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),IntConstant.v(0));
stmt=Jimple.v().newIfStmt(co,new FutureStmt());
break;
case ByteCode.IFLE:
co=Jimple.v().newLeExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),IntConstant.v(0));
stmt=Jimple.v().newIfStmt(co,new FutureStmt());
break;
case ByteCode.IFNE:
co=Jimple.v().newNeExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),IntConstant.v(0));
stmt=Jimple.v().newIfStmt(co,new FutureStmt());
break;
case ByteCode.IFNONNULL:
co=Jimple.v().newNeExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),NullConstant.v());
stmt=Jimple.v().newIfStmt(co,new FutureStmt());
break;
case ByteCode.IFGT:
co=Jimple.v().newGtExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),IntConstant.v(0));
stmt=Jimple.v().newIfStmt(co,new FutureStmt());
break;
case ByteCode.IFGE:
co=Jimple.v().newGeExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),IntConstant.v(0));
stmt=Jimple.v().newIfStmt(co,new FutureStmt());
break;
case ByteCode.IF_ICMPEQ:
co=Jimple.v().newEqExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newIfStmt(co,new FutureStmt());
break;
case ByteCode.IF_ICMPLT:
co=Jimple.v().newLtExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newIfStmt(co,new FutureStmt());
break;
case ByteCode.IF_ICMPLE:
co=Jimple.v().newLeExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newIfStmt(co,new FutureStmt());
break;
case ByteCode.IF_ICMPNE:
co=Jimple.v().newNeExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newIfStmt(co,new FutureStmt());
break;
case ByteCode.IF_ICMPGT:
co=Jimple.v().newGtExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newIfStmt(co,new FutureStmt());
break;
case ByteCode.IF_ICMPGE:
co=Jimple.v().newGeExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newIfStmt(co,new FutureStmt());
break;
case ByteCode.LCMP:
rhs=Jimple.v().newCmpExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 3),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.FCMPL:
rhs=Jimple.v().newCmplExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.FCMPG:
rhs=Jimple.v().newCmpgExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.DCMPL:
rhs=Jimple.v().newCmplExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 3),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.DCMPG:
rhs=Jimple.v().newCmpgExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 3),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.IF_ACMPEQ:
co=Jimple.v().newEqExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newIfStmt(co,new FutureStmt());
break;
case ByteCode.IF_ACMPNE:
co=Jimple.v().newNeExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newIfStmt(co,new FutureStmt());
break;
case ByteCode.GOTO:
stmt=Jimple.v().newGotoStmt(new FutureStmt());
break;
case ByteCode.GOTO_W:
stmt=Jimple.v().newGotoStmt(new FutureStmt());
break;
case ByteCode.RET:
{
Local local=Util.v().getLocalForIndex(listBody,((Instruction_Ret)ins).arg_b);
stmt=Jimple.v().newRetStmt(local);
break;
}
case ByteCode.RET_W:
{
Local local=Util.v().getLocalForIndex(listBody,((Instruction_Ret_w)ins).arg_i);
stmt=Jimple.v().newRetStmt(local);
break;
}
case ByteCode.RETURN:
stmt=Jimple.v().newReturnVoidStmt();
break;
case ByteCode.LRETURN:
case ByteCode.DRETURN:
case ByteCode.IRETURN:
case ByteCode.FRETURN:
case ByteCode.ARETURN:
stmt=Jimple.v().newReturnStmt(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
break;
case ByteCode.BREAKPOINT:
stmt=Jimple.v().newBreakpointStmt();
break;
case ByteCode.TABLESWITCH:
{
int lowIndex=((Instruction_Tableswitch)ins).low, highIndex=((Instruction_Tableswitch)ins).high;
stmt=Jimple.v().newTableSwitchStmt(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),lowIndex,highIndex,Arrays.asList(new FutureStmt[highIndex - lowIndex + 1]),new FutureStmt());
break;
}
case ByteCode.LOOKUPSWITCH:
{
List matches=new ArrayList();
int npairs=((Instruction_Lookupswitch)ins).npairs;
for (int j=0; j < npairs; j++) matches.add(IntConstant.v(((Instruction_Lookupswitch)ins).match_offsets[j * 2]));
stmt=Jimple.v().newLookupSwitchStmt(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),matches,Arrays.asList(new FutureStmt[npairs]),new FutureStmt());
break;
}
case ByteCode.PUTFIELD:
{
CONSTANT_Fieldref_info fieldInfo=(CONSTANT_Fieldref_info)constant_pool[((Instruction_Putfield)ins).arg_i];
CONSTANT_Class_info c=(CONSTANT_Class_info)constant_pool[fieldInfo.class_index];
String className=((CONSTANT_Utf8_info)(constant_pool[c.name_index])).convert();
className=className.replace('/','.');
CONSTANT_NameAndType_info i=(CONSTANT_NameAndType_info)constant_pool[fieldInfo.name_and_type_index];
String fieldName=((CONSTANT_Utf8_info)(constant_pool[i.name_index])).convert();
String fieldDescriptor=((CONSTANT_Utf8_info)(constant_pool[i.descriptor_index])).convert();
Type fieldType=Util.v().jimpleTypeOfFieldDescriptor(cm,fieldDescriptor);
SootClass bclass=cm.getSootClass(className);
SootField field=bclass.getField(fieldName,fieldType);
InstanceFieldRef fr=Jimple.v().newInstanceFieldRef(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - typeSize(typeStack.top())),field);
rvalue=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex());
stmt=Jimple.v().newAssignStmt(fr,rvalue);
break;
}
case ByteCode.GETFIELD:
{
InstanceFieldRef fr=null;
CONSTANT_Fieldref_info fieldInfo=(CONSTANT_Fieldref_info)constant_pool[((Instruction_Getfield)ins).arg_i];
CONSTANT_Class_info c=(CONSTANT_Class_info)constant_pool[fieldInfo.class_index];
String className=((CONSTANT_Utf8_info)(constant_pool[c.name_index])).convert();
className=className.replace('/','.');
CONSTANT_NameAndType_info i=(CONSTANT_NameAndType_info)constant_pool[fieldInfo.name_and_type_index];
String fieldName=((CONSTANT_Utf8_info)(constant_pool[i.name_index])).convert();
String fieldDescriptor=((CONSTANT_Utf8_info)(constant_pool[i.descriptor_index])).convert();
SootClass bclass=cm.getSootClass(className);
Type fieldType=Util.v().jimpleTypeOfFieldDescriptor(cm,fieldDescriptor);
SootField field=bclass.getField(fieldName,fieldType);
fr=Jimple.v().newInstanceFieldRef(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),field);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),fr);
break;
}
case ByteCode.PUTSTATIC:
{
StaticFieldRef fr=null;
CONSTANT_Fieldref_info fieldInfo=(CONSTANT_Fieldref_info)constant_pool[((Instruction_Putstatic)ins).arg_i];
CONSTANT_Class_info c=(CONSTANT_Class_info)constant_pool[fieldInfo.class_index];
String className=((CONSTANT_Utf8_info)(constant_pool[c.name_index])).convert();
className=className.replace('/','.');
CONSTANT_NameAndType_info i=(CONSTANT_NameAndType_info)constant_pool[fieldInfo.name_and_type_index];
String fieldName=((CONSTANT_Utf8_info)(constant_pool[i.name_index])).convert();
String fieldDescriptor=((CONSTANT_Utf8_info)(constant_pool[i.descriptor_index])).convert();
Type fieldType=Util.v().jimpleTypeOfFieldDescriptor(cm,fieldDescriptor);
SootClass bclass=cm.getSootClass(className);
SootField field=bclass.getField(fieldName,fieldType);
fr=Jimple.v().newStaticFieldRef(field);
stmt=Jimple.v().newAssignStmt(fr,Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
break;
}
case ByteCode.GETSTATIC:
{
StaticFieldRef fr=null;
CONSTANT_Fieldref_info fieldInfo=(CONSTANT_Fieldref_info)constant_pool[((Instruction_Getstatic)ins).arg_i];
CONSTANT_Class_info c=(CONSTANT_Class_info)constant_pool[fieldInfo.class_index];
String className=((CONSTANT_Utf8_info)(constant_pool[c.name_index])).convert();
className=className.replace('/','.');
CONSTANT_NameAndType_info i=(CONSTANT_NameAndType_info)constant_pool[fieldInfo.name_and_type_index];
String fieldName=((CONSTANT_Utf8_info)(constant_pool[i.name_index])).convert();
String fieldDescriptor=((CONSTANT_Utf8_info)(constant_pool[i.descriptor_index])).convert();
Type fieldType=Util.v().jimpleTypeOfFieldDescriptor(cm,fieldDescriptor);
SootClass bclass=cm.getSootClass(className);
SootField field=bclass.getField(fieldName,fieldType);
fr=Jimple.v().newStaticFieldRef(field);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),fr);
break;
}
case ByteCode.INVOKEVIRTUAL:
{
Instruction_Invokevirtual iv=(Instruction_Invokevirtual)ins;
args=cp_info.countParams(constant_pool,iv.arg_i);
SootMethod method=null;
CONSTANT_Methodref_info methodInfo=(CONSTANT_Methodref_info)constant_pool[iv.arg_i];
CONSTANT_Class_info c=(CONSTANT_Class_info)constant_pool[methodInfo.class_index];
String className=((CONSTANT_Utf8_info)(constant_pool[c.name_index])).convert();
className=className.replace('/','.');
CONSTANT_NameAndType_info i=(CONSTANT_NameAndType_info)constant_pool[methodInfo.name_and_type_index];
String methodName=((CONSTANT_Utf8_info)(constant_pool[i.name_index])).convert();
String methodDescriptor=((CONSTANT_Utf8_info)(constant_pool[i.descriptor_index])).convert();
SootClass bclass=cm.getSootClass(className);
Local[] parameters;
List parameterTypes;
Type returnType;
{
Type[] types=Util.v().jimpleTypesOfFieldOrMethodDescriptor(cm,methodDescriptor);
parameterTypes=new ArrayList();
for (int k=0; k < types.length - 1; k++) {
parameterTypes.add(types[k]);
}
returnType=types[types.length - 1];
}
method=bclass.getMethod(methodName,parameterTypes,returnType);
params=new Value[args];
for (int j=args - 1; j >= 0; j--) {
params[j]=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex());
if (typeSize(typeStack.top()) == 2) {
typeStack=typeStack.pop();
typeStack=typeStack.pop();
}
 else typeStack=typeStack.pop();
}
rvalue=Jimple.v().newVirtualInvokeExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),method,Arrays.asList(params));
if (!returnType.equals(VoidType.v())) {
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rvalue);
}
 else stmt=Jimple.v().newInvokeStmt((InvokeExpr)rvalue);
break;
}
case ByteCode.INVOKENONVIRTUAL:
{
Instruction_Invokenonvirtual iv=(Instruction_Invokenonvirtual)ins;
args=cp_info.countParams(constant_pool,iv.arg_i);
SootMethod method=null;
CONSTANT_Methodref_info methodInfo=(CONSTANT_Methodref_info)constant_pool[iv.arg_i];
CONSTANT_Class_info c=(CONSTANT_Class_info)constant_pool[methodInfo.class_index];
String className=((CONSTANT_Utf8_info)(constant_pool[c.name_index])).convert();
className=className.replace('/','.');
CONSTANT_NameAndType_info i=(CONSTANT_NameAndType_info)constant_pool[methodInfo.name_and_type_index];
String methodName=((CONSTANT_Utf8_info)(constant_pool[i.name_index])).convert();
String methodDescriptor=((CONSTANT_Utf8_info)(constant_pool[i.descriptor_index])).convert();
SootClass bclass=cm.getSootClass(className);
Local[] parameters;
List parameterTypes;
Type returnType;
{
Type[] types=Util.v().jimpleTypesOfFieldOrMethodDescriptor(cm,methodDescriptor);
parameterTypes=new ArrayList();
for (int k=0; k < types.length - 1; k++) {
parameterTypes.add(types[k]);
}
returnType=types[types.length - 1];
}
method=bclass.getMethod(methodName,parameterTypes,returnType);
params=new Value[args];
for (int j=args - 1; j >= 0; j--) {
params[j]=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex());
if (typeSize(typeStack.top()) == 2) {
typeStack=typeStack.pop();
typeStack=typeStack.pop();
}
 else typeStack=typeStack.pop();
}
rvalue=Jimple.v().newSpecialInvokeExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),method,Arrays.asList(params));
if (!returnType.equals(VoidType.v())) {
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rvalue);
}
 else stmt=Jimple.v().newInvokeStmt((InvokeExpr)rvalue);
break;
}
case ByteCode.INVOKESTATIC:
{
Instruction_Invokestatic is=(Instruction_Invokestatic)ins;
args=cp_info.countParams(constant_pool,is.arg_i);
SootMethod method=null;
CONSTANT_Methodref_info methodInfo=(CONSTANT_Methodref_info)constant_pool[is.arg_i];
CONSTANT_Class_info c=(CONSTANT_Class_info)constant_pool[methodInfo.class_index];
String className=((CONSTANT_Utf8_info)(constant_pool[c.name_index])).convert();
className=className.replace('/','.');
CONSTANT_NameAndType_info i=(CONSTANT_NameAndType_info)constant_pool[methodInfo.name_and_type_index];
String methodName=((CONSTANT_Utf8_info)(constant_pool[i.name_index])).convert();
String methodDescriptor=((CONSTANT_Utf8_info)(constant_pool[i.descriptor_index])).convert();
SootClass bclass=cm.getSootClass(className);
Local[] parameters;
List parameterTypes;
Type returnType;
{
Type[] types=Util.v().jimpleTypesOfFieldOrMethodDescriptor(cm,methodDescriptor);
parameterTypes=new ArrayList();
for (int k=0; k < types.length - 1; k++) {
parameterTypes.add(types[k]);
}
returnType=types[types.length - 1];
}
method=bclass.getMethod(methodName,parameterTypes,returnType);
params=new Value[args];
for (int j=args - 1; j >= 0; j--) {
params[j]=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex());
if (typeSize(typeStack.top()) == 2) {
typeStack=typeStack.pop();
typeStack=typeStack.pop();
}
 else typeStack=typeStack.pop();
}
rvalue=Jimple.v().newStaticInvokeExpr(method,Arrays.asList(params));
if (!returnType.equals(VoidType.v())) {
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rvalue);
}
 else stmt=Jimple.v().newInvokeStmt((InvokeExpr)rvalue);
break;
}
case ByteCode.INVOKEINTERFACE:
{
Instruction_Invokeinterface ii=(Instruction_Invokeinterface)ins;
args=cp_info.countParams(constant_pool,ii.arg_i);
SootMethod method=null;
CONSTANT_InterfaceMethodref_info methodInfo=(CONSTANT_InterfaceMethodref_info)constant_pool[ii.arg_i];
CONSTANT_Class_info c=(CONSTANT_Class_info)constant_pool[methodInfo.class_index];
String className=((CONSTANT_Utf8_info)(constant_pool[c.name_index])).convert();
className=className.replace('/','.');
CONSTANT_NameAndType_info i=(CONSTANT_NameAndType_info)constant_pool[methodInfo.name_and_type_index];
String methodName=((CONSTANT_Utf8_info)(constant_pool[i.name_index])).convert();
String methodDescriptor=((CONSTANT_Utf8_info)(constant_pool[i.descriptor_index])).convert();
SootClass bclass=cm.getSootClass(className);
Local[] parameters;
List parameterTypes;
Type returnType;
{
Type[] types=Util.v().jimpleTypesOfFieldOrMethodDescriptor(cm,methodDescriptor);
parameterTypes=new ArrayList();
for (int k=0; k < types.length - 1; k++) {
parameterTypes.add(types[k]);
}
returnType=types[types.length - 1];
}
method=bclass.getMethod(methodName,parameterTypes,returnType);
params=new Value[args];
for (int j=args - 1; j >= 0; j--) {
params[j]=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex());
if (typeSize(typeStack.top()) == 2) {
typeStack=typeStack.pop();
typeStack=typeStack.pop();
}
 else typeStack=typeStack.pop();
}
rvalue=Jimple.v().newInterfaceInvokeExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),method,Arrays.asList(params));
if (!returnType.equals(VoidType.v())) {
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rvalue);
}
 else stmt=Jimple.v().newInvokeStmt((InvokeExpr)rvalue);
break;
}
case ByteCode.ATHROW:
stmt=Jimple.v().newThrowStmt(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
break;
case ByteCode.NEW:
{
SootClass bclass=cm.getSootClass(getClassName(constant_pool,((Instruction_New)ins).arg_i));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),Jimple.v().newNewExpr(RefType.v(bclass.getName())));
break;
}
case ByteCode.CHECKCAST:
{
String className=getClassName(constant_pool,((Instruction_Checkcast)ins).arg_i);
Type castType;
if (className.startsWith(""String_Node_Str"")) castType=Util.v().jimpleTypeOfFieldDescriptor(cm,getClassName(constant_pool,((Instruction_Checkcast)ins).arg_i));
 else castType=RefType.v(className);
rhs=Jimple.v().newCastExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),castType);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
}
case ByteCode.INSTANCEOF:
{
Type checkType;
String className=getClassName(constant_pool,((Instruction_Instanceof)ins).arg_i);
if (className.startsWith(""String_Node_Str"")) checkType=Util.v().jimpleTypeOfFieldDescriptor(cm,getClassName(constant_pool,((Instruction_Instanceof)ins).arg_i));
 else checkType=RefType.v(className);
rhs=Jimple.v().newInstanceOfExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),checkType);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
}
case ByteCode.MONITORENTER:
stmt=Jimple.v().newEnterMonitorStmt(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
break;
case ByteCode.MONITOREXIT:
stmt=Jimple.v().newExitMonitorStmt(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
break;
default :
throw new RuntimeException(""String_Node_Str"" + x);
}
if (stmt != null) {
if (Options.v().keep_offset()) {
stmt.addTag(new BytecodeOffsetTag(ins.label));
}
statements.add(stmt);
}
}","void generateJimple(Instruction ins,TypeStack typeStack,TypeStack postTypeStack,cp_info constant_pool[],List statements,BasicBlock basicBlock){
  Value[] params;
  Value v1=null, v2=null, v3=null, v4=null;
  Local l1=null, l2=null, l3=null, l4=null;
  Expr e=null, rhs=null;
  BinopExpr b=null;
  ConditionExpr co=null;
  ArrayRef a=null;
  int args;
  Value rvalue;
  Stmt stmt=null;
  int x=((int)(ins.code)) & 0xff;
  Util.v().activeOriginalIndex=ins.originalIndex;
  Util.v().isLocalStore=false;
  Util.v().isWideLocalStore=false;
switch (x) {
case ByteCode.BIPUSH:
    rvalue=IntConstant.v(((Instruction_Bipush)ins).arg_b);
  stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rvalue);
break;
case ByteCode.SIPUSH:
rvalue=IntConstant.v(((Instruction_Sipush)ins).arg_i);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rvalue);
break;
case ByteCode.LDC1:
generateJimpleForCPEntry(constant_pool,((Instruction_Ldc1)ins).arg_b,typeStack,postTypeStack,jmethod,statements);
break;
case ByteCode.LDC2:
case ByteCode.LDC2W:
generateJimpleForCPEntry(constant_pool,((Instruction_intindex)ins).arg_i,typeStack,postTypeStack,jmethod,statements);
break;
case ByteCode.ACONST_NULL:
rvalue=NullConstant.v();
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rvalue);
break;
case ByteCode.ICONST_M1:
case ByteCode.ICONST_0:
case ByteCode.ICONST_1:
case ByteCode.ICONST_2:
case ByteCode.ICONST_3:
case ByteCode.ICONST_4:
case ByteCode.ICONST_5:
rvalue=IntConstant.v(x - ByteCode.ICONST_0);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rvalue);
break;
case ByteCode.LCONST_0:
case ByteCode.LCONST_1:
rvalue=LongConstant.v(x - ByteCode.LCONST_0);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rvalue);
break;
case ByteCode.FCONST_0:
case ByteCode.FCONST_1:
case ByteCode.FCONST_2:
rvalue=FloatConstant.v((float)(x - ByteCode.FCONST_0));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rvalue);
break;
case ByteCode.DCONST_0:
case ByteCode.DCONST_1:
rvalue=DoubleConstant.v((double)(x - ByteCode.DCONST_0));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rvalue);
break;
case ByteCode.ILOAD:
{
Local local=(Local)Util.v().getLocalForIndex(listBody,((Instruction_bytevar)ins).arg_b);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),local);
break;
}
case ByteCode.FLOAD:
{
Local local=(Local)Util.v().getLocalForIndex(listBody,((Instruction_bytevar)ins).arg_b);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),local);
break;
}
case ByteCode.ALOAD:
{
Local local=Util.v().getLocalForIndex(listBody,((Instruction_bytevar)ins).arg_b);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),local);
break;
}
case ByteCode.DLOAD:
{
Local local=Util.v().getLocalForIndex(listBody,((Instruction_bytevar)ins).arg_b);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),local);
break;
}
case ByteCode.LLOAD:
{
Local local=Util.v().getLocalForIndex(listBody,((Instruction_bytevar)ins).arg_b);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),local);
break;
}
case ByteCode.ILOAD_0:
case ByteCode.ILOAD_1:
case ByteCode.ILOAD_2:
case ByteCode.ILOAD_3:
{
Local local=Util.v().getLocalForIndex(listBody,(x - ByteCode.ILOAD_0));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),local);
break;
}
case ByteCode.FLOAD_0:
case ByteCode.FLOAD_1:
case ByteCode.FLOAD_2:
case ByteCode.FLOAD_3:
{
Local local=Util.v().getLocalForIndex(listBody,(x - ByteCode.FLOAD_0));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),local);
break;
}
case ByteCode.ALOAD_0:
case ByteCode.ALOAD_1:
case ByteCode.ALOAD_2:
case ByteCode.ALOAD_3:
{
Local local=Util.v().getLocalForIndex(listBody,(x - ByteCode.ALOAD_0));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),local);
break;
}
case ByteCode.LLOAD_0:
case ByteCode.LLOAD_1:
case ByteCode.LLOAD_2:
case ByteCode.LLOAD_3:
{
Local local=Util.v().getLocalForIndex(listBody,(x - ByteCode.LLOAD_0));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),local);
break;
}
case ByteCode.DLOAD_0:
case ByteCode.DLOAD_1:
case ByteCode.DLOAD_2:
case ByteCode.DLOAD_3:
{
Local local=Util.v().getLocalForIndex(listBody,(x - ByteCode.DLOAD_0));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),local);
break;
}
case ByteCode.ISTORE:
{
Util.v().isLocalStore=true;
Util.v().isWideLocalStore=true;
Local local=Util.v().getLocalForIndex(listBody,((Instruction_bytevar)ins).arg_b);
stmt=Jimple.v().newAssignStmt(local,Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
break;
}
case ByteCode.FSTORE:
{
Util.v().isLocalStore=true;
Util.v().isWideLocalStore=true;
Local local=Util.v().getLocalForIndex(listBody,((Instruction_bytevar)ins).arg_b);
stmt=Jimple.v().newAssignStmt(local,Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
break;
}
case ByteCode.ASTORE:
{
Util.v().isLocalStore=true;
Util.v().isWideLocalStore=true;
Local local=Util.v().getLocalForIndex(listBody,((Instruction_bytevar)ins).arg_b);
stmt=Jimple.v().newAssignStmt(local,Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
break;
}
case ByteCode.LSTORE:
{
Util.v().isLocalStore=true;
Util.v().isWideLocalStore=true;
Local local=Util.v().getLocalForIndex(listBody,((Instruction_bytevar)ins).arg_b);
stmt=Jimple.v().newAssignStmt(local,Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
break;
}
case ByteCode.DSTORE:
{
Util.v().isLocalStore=true;
Util.v().isWideLocalStore=true;
Local local=Util.v().getLocalForIndex(listBody,((Instruction_bytevar)ins).arg_b);
stmt=Jimple.v().newAssignStmt(local,Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
break;
}
case ByteCode.ISTORE_0:
case ByteCode.ISTORE_1:
case ByteCode.ISTORE_2:
case ByteCode.ISTORE_3:
{
Util.v().isLocalStore=true;
Local local=Util.v().getLocalForIndex(listBody,(x - ByteCode.ISTORE_0));
stmt=Jimple.v().newAssignStmt(local,Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
break;
}
case ByteCode.FSTORE_0:
case ByteCode.FSTORE_1:
case ByteCode.FSTORE_2:
case ByteCode.FSTORE_3:
{
Util.v().isLocalStore=true;
Local local=(Local)Util.v().getLocalForIndex(listBody,(x - ByteCode.FSTORE_0));
stmt=Jimple.v().newAssignStmt(local,Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
break;
}
case ByteCode.ASTORE_0:
case ByteCode.ASTORE_1:
case ByteCode.ASTORE_2:
case ByteCode.ASTORE_3:
{
Util.v().isLocalStore=true;
Local local=Util.v().getLocalForIndex(listBody,(x - ByteCode.ASTORE_0));
stmt=Jimple.v().newAssignStmt(local,Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
break;
}
case ByteCode.LSTORE_0:
case ByteCode.LSTORE_1:
case ByteCode.LSTORE_2:
case ByteCode.LSTORE_3:
{
Util.v().isLocalStore=true;
Local local=Util.v().getLocalForIndex(listBody,(x - ByteCode.LSTORE_0));
stmt=Jimple.v().newAssignStmt(local,Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
break;
}
case ByteCode.DSTORE_0:
case ByteCode.DSTORE_1:
case ByteCode.DSTORE_2:
case ByteCode.DSTORE_3:
{
Util.v().isLocalStore=true;
Local local=Util.v().getLocalForIndex(listBody,(x - ByteCode.DSTORE_0));
stmt=Jimple.v().newAssignStmt(local,Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
break;
}
case ByteCode.IINC:
{
Local local=Util.v().getLocalForIndex(listBody,((Instruction_Iinc)ins).arg_b);
int amt=(((Instruction_Iinc)ins).arg_c);
rhs=Jimple.v().newAddExpr(local,IntConstant.v(amt));
stmt=Jimple.v().newAssignStmt(local,rhs);
break;
}
case ByteCode.WIDE:
throw new RuntimeException(""String_Node_Str"");
case ByteCode.NEWARRAY:
{
Type baseType=(Type)jimpleTypeOfAtype(((Instruction_Newarray)ins).atype);
rhs=Jimple.v().newNewArrayExpr(baseType,Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
}
case ByteCode.ANEWARRAY:
{
String baseName=getClassName(constant_pool,((Instruction_Anewarray)ins).arg_i);
Type baseType;
if (baseName.startsWith(""String_Node_Str"")) baseType=Util.v().jimpleTypeOfFieldDescriptor(cm,getClassName(constant_pool,((Instruction_Anewarray)ins).arg_i));
 else baseType=RefType.v(baseName);
rhs=Jimple.v().newNewArrayExpr(baseType,Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
}
case ByteCode.MULTIANEWARRAY:
{
int bdims=(int)(((Instruction_Multianewarray)ins).dims);
List dims=new ArrayList();
for (int j=0; j < bdims; j++) dims.add(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - bdims + j + 1));
String mstype=constant_pool[((Instruction_Multianewarray)ins).arg_i].toString(constant_pool);
ArrayType jimpleType=(ArrayType)Util.v().jimpleTypeOfFieldDescriptor(cm,mstype);
rhs=Jimple.v().newNewMultiArrayExpr(jimpleType,dims);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
}
case ByteCode.ARRAYLENGTH:
rhs=Jimple.v().newLengthExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.IALOAD:
case ByteCode.BALOAD:
case ByteCode.CALOAD:
case ByteCode.SALOAD:
case ByteCode.FALOAD:
case ByteCode.LALOAD:
case ByteCode.DALOAD:
case ByteCode.AALOAD:
a=Jimple.v().newArrayRef(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),a);
break;
case ByteCode.IASTORE:
case ByteCode.FASTORE:
case ByteCode.AASTORE:
case ByteCode.BASTORE:
case ByteCode.CASTORE:
case ByteCode.SASTORE:
a=Jimple.v().newArrayRef(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 2),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1));
stmt=Jimple.v().newAssignStmt(a,Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
break;
case ByteCode.LASTORE:
case ByteCode.DASTORE:
a=Jimple.v().newArrayRef(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 3),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 2));
stmt=Jimple.v().newAssignStmt(a,Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
break;
case ByteCode.NOP:
stmt=Jimple.v().newNopStmt();
break;
case ByteCode.POP:
case ByteCode.POP2:
stmt=Jimple.v().newNopStmt();
break;
case ByteCode.DUP:
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
break;
case ByteCode.DUP2:
if (typeSize(typeStack.top()) == 2) {
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1));
}
 else {
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1));
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
statements.add(stmt);
stmt=null;
}
break;
case ByteCode.DUP_X1:
l1=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex());
l2=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),l1);
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 1),l2);
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 2),Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()));
statements.add(stmt);
stmt=null;
break;
case ByteCode.DUP_X2:
if (typeSize(typeStack.get(typeStack.topIndex() - 2)) == 2) {
l3=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 2);
l1=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex());
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 2),l3);
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 3),l1);
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),l1);
statements.add(stmt);
stmt=null;
}
 else {
l3=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 2);
l2=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1);
l1=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex());
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),l1);
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 1),l2);
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 2),l3);
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 3),Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()));
statements.add(stmt);
stmt=null;
}
break;
case ByteCode.DUP2_X1:
if (typeSize(typeStack.get(typeStack.topIndex() - 1)) == 2) {
l2=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1);
l3=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 2);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 1),l2);
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 2),l3);
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 4),Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 1));
statements.add(stmt);
stmt=null;
}
 else {
l3=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 2);
l2=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1);
l1=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex());
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),l1);
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 1),l2);
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 2),l3);
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 3),Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()));
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 4),Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 1));
statements.add(stmt);
stmt=null;
}
break;
case ByteCode.DUP2_X2:
if (typeSize(typeStack.get(typeStack.topIndex() - 1)) == 2) {
l2=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 1),l2);
statements.add(stmt);
}
 else {
l1=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex());
l2=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 1),l2);
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),l1);
statements.add(stmt);
}
if (typeSize(typeStack.get(typeStack.topIndex() - 3)) == 2) {
l4=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 3);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 3),l4);
statements.add(stmt);
}
 else {
l4=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 3);
l3=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 2);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 3),l4);
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 2),l3);
statements.add(stmt);
}
if (typeSize(typeStack.get(typeStack.topIndex() - 1)) == 2) {
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 5),Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 1));
statements.add(stmt);
}
 else {
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 5),Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 1));
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 4),Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()));
statements.add(stmt);
}
stmt=null;
break;
case ByteCode.SWAP:
{
Local first;
typeStack=typeStack.push(typeStack.top());
first=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex());
typeStack=typeStack.pop();
Local second=Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex());
Local third=Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 1);
stmt=Jimple.v().newAssignStmt(first,second);
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(second,third);
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(third,first);
statements.add(stmt);
stmt=null;
break;
}
case ByteCode.FADD:
case ByteCode.IADD:
rhs=Jimple.v().newAddExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.DADD:
case ByteCode.LADD:
rhs=Jimple.v().newAddExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 3),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.FSUB:
case ByteCode.ISUB:
rhs=Jimple.v().newSubExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.DSUB:
case ByteCode.LSUB:
rhs=Jimple.v().newSubExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 3),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.FMUL:
case ByteCode.IMUL:
rhs=Jimple.v().newMulExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.DMUL:
case ByteCode.LMUL:
rhs=Jimple.v().newMulExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 3),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.FDIV:
case ByteCode.IDIV:
rhs=Jimple.v().newDivExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.DDIV:
case ByteCode.LDIV:
rhs=Jimple.v().newDivExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 3),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.FREM:
case ByteCode.IREM:
rhs=Jimple.v().newRemExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.DREM:
case ByteCode.LREM:
rhs=Jimple.v().newRemExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 3),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.INEG:
case ByteCode.LNEG:
case ByteCode.FNEG:
case ByteCode.DNEG:
rhs=Jimple.v().newNegExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.ISHL:
rhs=Jimple.v().newShlExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.ISHR:
rhs=Jimple.v().newShrExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.IUSHR:
rhs=Jimple.v().newUshrExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.LSHL:
rhs=Jimple.v().newShlExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 2),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.LSHR:
rhs=Jimple.v().newShrExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 2),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.LUSHR:
rhs=Jimple.v().newUshrExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 2),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.IAND:
rhs=Jimple.v().newAndExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.LAND:
rhs=Jimple.v().newAndExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 3),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.IOR:
rhs=Jimple.v().newOrExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.LOR:
rhs=Jimple.v().newOrExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 3),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.IXOR:
rhs=Jimple.v().newXorExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.LXOR:
rhs=Jimple.v().newXorExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 3),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.D2L:
case ByteCode.F2L:
case ByteCode.I2L:
rhs=Jimple.v().newCastExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),LongType.v());
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.D2F:
case ByteCode.L2F:
case ByteCode.I2F:
rhs=Jimple.v().newCastExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),FloatType.v());
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.I2D:
case ByteCode.L2D:
case ByteCode.F2D:
rhs=Jimple.v().newCastExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),DoubleType.v());
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.L2I:
case ByteCode.F2I:
case ByteCode.D2I:
rhs=Jimple.v().newCastExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),IntType.v());
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.INT2BYTE:
rhs=Jimple.v().newCastExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),ByteType.v());
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.INT2CHAR:
rhs=Jimple.v().newCastExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),CharType.v());
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.INT2SHORT:
rhs=Jimple.v().newCastExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),ShortType.v());
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.IFEQ:
co=Jimple.v().newEqExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),IntConstant.v(0));
stmt=Jimple.v().newIfStmt(co,new FutureStmt());
break;
case ByteCode.IFNULL:
co=Jimple.v().newEqExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),NullConstant.v());
stmt=Jimple.v().newIfStmt(co,new FutureStmt());
break;
case ByteCode.IFLT:
co=Jimple.v().newLtExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),IntConstant.v(0));
stmt=Jimple.v().newIfStmt(co,new FutureStmt());
break;
case ByteCode.IFLE:
co=Jimple.v().newLeExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),IntConstant.v(0));
stmt=Jimple.v().newIfStmt(co,new FutureStmt());
break;
case ByteCode.IFNE:
co=Jimple.v().newNeExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),IntConstant.v(0));
stmt=Jimple.v().newIfStmt(co,new FutureStmt());
break;
case ByteCode.IFNONNULL:
co=Jimple.v().newNeExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),NullConstant.v());
stmt=Jimple.v().newIfStmt(co,new FutureStmt());
break;
case ByteCode.IFGT:
co=Jimple.v().newGtExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),IntConstant.v(0));
stmt=Jimple.v().newIfStmt(co,new FutureStmt());
break;
case ByteCode.IFGE:
co=Jimple.v().newGeExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),IntConstant.v(0));
stmt=Jimple.v().newIfStmt(co,new FutureStmt());
break;
case ByteCode.IF_ICMPEQ:
co=Jimple.v().newEqExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newIfStmt(co,new FutureStmt());
break;
case ByteCode.IF_ICMPLT:
co=Jimple.v().newLtExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newIfStmt(co,new FutureStmt());
break;
case ByteCode.IF_ICMPLE:
co=Jimple.v().newLeExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newIfStmt(co,new FutureStmt());
break;
case ByteCode.IF_ICMPNE:
co=Jimple.v().newNeExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newIfStmt(co,new FutureStmt());
break;
case ByteCode.IF_ICMPGT:
co=Jimple.v().newGtExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newIfStmt(co,new FutureStmt());
break;
case ByteCode.IF_ICMPGE:
co=Jimple.v().newGeExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newIfStmt(co,new FutureStmt());
break;
case ByteCode.LCMP:
rhs=Jimple.v().newCmpExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 3),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.FCMPL:
rhs=Jimple.v().newCmplExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.FCMPG:
rhs=Jimple.v().newCmpgExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.DCMPL:
rhs=Jimple.v().newCmplExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 3),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.DCMPG:
rhs=Jimple.v().newCmpgExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 3),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.IF_ACMPEQ:
co=Jimple.v().newEqExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newIfStmt(co,new FutureStmt());
break;
case ByteCode.IF_ACMPNE:
co=Jimple.v().newNeExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newIfStmt(co,new FutureStmt());
break;
case ByteCode.GOTO:
stmt=Jimple.v().newGotoStmt(new FutureStmt());
break;
case ByteCode.GOTO_W:
stmt=Jimple.v().newGotoStmt(new FutureStmt());
break;
case ByteCode.RET:
{
Local local=Util.v().getLocalForIndex(listBody,((Instruction_Ret)ins).arg_b);
stmt=Jimple.v().newRetStmt(local);
break;
}
case ByteCode.RET_W:
{
Local local=Util.v().getLocalForIndex(listBody,((Instruction_Ret_w)ins).arg_i);
stmt=Jimple.v().newRetStmt(local);
break;
}
case ByteCode.RETURN:
stmt=Jimple.v().newReturnVoidStmt();
break;
case ByteCode.LRETURN:
case ByteCode.DRETURN:
case ByteCode.IRETURN:
case ByteCode.FRETURN:
case ByteCode.ARETURN:
stmt=Jimple.v().newReturnStmt(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
break;
case ByteCode.BREAKPOINT:
stmt=Jimple.v().newBreakpointStmt();
break;
case ByteCode.TABLESWITCH:
{
int lowIndex=((Instruction_Tableswitch)ins).low, highIndex=((Instruction_Tableswitch)ins).high;
stmt=Jimple.v().newTableSwitchStmt(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),lowIndex,highIndex,Arrays.asList(new FutureStmt[highIndex - lowIndex + 1]),new FutureStmt());
break;
}
case ByteCode.LOOKUPSWITCH:
{
List matches=new ArrayList();
int npairs=((Instruction_Lookupswitch)ins).npairs;
for (int j=0; j < npairs; j++) matches.add(IntConstant.v(((Instruction_Lookupswitch)ins).match_offsets[j * 2]));
stmt=Jimple.v().newLookupSwitchStmt(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),matches,Arrays.asList(new FutureStmt[npairs]),new FutureStmt());
break;
}
case ByteCode.PUTFIELD:
{
CONSTANT_Fieldref_info fieldInfo=(CONSTANT_Fieldref_info)constant_pool[((Instruction_Putfield)ins).arg_i];
CONSTANT_Class_info c=(CONSTANT_Class_info)constant_pool[fieldInfo.class_index];
String className=((CONSTANT_Utf8_info)(constant_pool[c.name_index])).convert();
className=className.replace('/','.');
CONSTANT_NameAndType_info i=(CONSTANT_NameAndType_info)constant_pool[fieldInfo.name_and_type_index];
String fieldName=((CONSTANT_Utf8_info)(constant_pool[i.name_index])).convert();
String fieldDescriptor=((CONSTANT_Utf8_info)(constant_pool[i.descriptor_index])).convert();
Type fieldType=Util.v().jimpleTypeOfFieldDescriptor(cm,fieldDescriptor);
SootClass bclass=cm.getSootClass(className);
SootField field=bclass.getField(fieldName,fieldType);
InstanceFieldRef fr=Jimple.v().newInstanceFieldRef(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - typeSize(typeStack.top())),field);
rvalue=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex());
stmt=Jimple.v().newAssignStmt(fr,rvalue);
break;
}
case ByteCode.GETFIELD:
{
InstanceFieldRef fr=null;
CONSTANT_Fieldref_info fieldInfo=(CONSTANT_Fieldref_info)constant_pool[((Instruction_Getfield)ins).arg_i];
CONSTANT_Class_info c=(CONSTANT_Class_info)constant_pool[fieldInfo.class_index];
String className=((CONSTANT_Utf8_info)(constant_pool[c.name_index])).convert();
className=className.replace('/','.');
CONSTANT_NameAndType_info i=(CONSTANT_NameAndType_info)constant_pool[fieldInfo.name_and_type_index];
String fieldName=((CONSTANT_Utf8_info)(constant_pool[i.name_index])).convert();
String fieldDescriptor=((CONSTANT_Utf8_info)(constant_pool[i.descriptor_index])).convert();
SootClass bclass=cm.getSootClass(className);
Type fieldType=Util.v().jimpleTypeOfFieldDescriptor(cm,fieldDescriptor);
SootField field=bclass.getField(fieldName,fieldType);
fr=Jimple.v().newInstanceFieldRef(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),field);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),fr);
break;
}
case ByteCode.PUTSTATIC:
{
StaticFieldRef fr=null;
CONSTANT_Fieldref_info fieldInfo=(CONSTANT_Fieldref_info)constant_pool[((Instruction_Putstatic)ins).arg_i];
CONSTANT_Class_info c=(CONSTANT_Class_info)constant_pool[fieldInfo.class_index];
String className=((CONSTANT_Utf8_info)(constant_pool[c.name_index])).convert();
className=className.replace('/','.');
CONSTANT_NameAndType_info i=(CONSTANT_NameAndType_info)constant_pool[fieldInfo.name_and_type_index];
String fieldName=((CONSTANT_Utf8_info)(constant_pool[i.name_index])).convert();
String fieldDescriptor=((CONSTANT_Utf8_info)(constant_pool[i.descriptor_index])).convert();
Type fieldType=Util.v().jimpleTypeOfFieldDescriptor(cm,fieldDescriptor);
SootClass bclass=cm.getSootClass(className);
SootField field=bclass.getField(fieldName,fieldType);
fr=Jimple.v().newStaticFieldRef(field);
stmt=Jimple.v().newAssignStmt(fr,Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
break;
}
case ByteCode.GETSTATIC:
{
StaticFieldRef fr=null;
CONSTANT_Fieldref_info fieldInfo=(CONSTANT_Fieldref_info)constant_pool[((Instruction_Getstatic)ins).arg_i];
CONSTANT_Class_info c=(CONSTANT_Class_info)constant_pool[fieldInfo.class_index];
String className=((CONSTANT_Utf8_info)(constant_pool[c.name_index])).convert();
className=className.replace('/','.');
CONSTANT_NameAndType_info i=(CONSTANT_NameAndType_info)constant_pool[fieldInfo.name_and_type_index];
String fieldName=((CONSTANT_Utf8_info)(constant_pool[i.name_index])).convert();
String fieldDescriptor=((CONSTANT_Utf8_info)(constant_pool[i.descriptor_index])).convert();
Type fieldType=Util.v().jimpleTypeOfFieldDescriptor(cm,fieldDescriptor);
SootClass bclass=cm.getSootClass(className);
SootField field=bclass.getField(fieldName,fieldType);
fr=Jimple.v().newStaticFieldRef(field);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),fr);
break;
}
case ByteCode.INVOKEVIRTUAL:
{
Instruction_Invokevirtual iv=(Instruction_Invokevirtual)ins;
args=cp_info.countParams(constant_pool,iv.arg_i);
SootMethod method=null;
CONSTANT_Methodref_info methodInfo=(CONSTANT_Methodref_info)constant_pool[iv.arg_i];
CONSTANT_Class_info c=(CONSTANT_Class_info)constant_pool[methodInfo.class_index];
String className=((CONSTANT_Utf8_info)(constant_pool[c.name_index])).convert();
className=className.replace('/','.');
CONSTANT_NameAndType_info i=(CONSTANT_NameAndType_info)constant_pool[methodInfo.name_and_type_index];
String methodName=((CONSTANT_Utf8_info)(constant_pool[i.name_index])).convert();
String methodDescriptor=((CONSTANT_Utf8_info)(constant_pool[i.descriptor_index])).convert();
if (className.charAt(0) == '[') className=""String_Node_Str"";
SootClass bclass=cm.getSootClass(className);
Local[] parameters;
List parameterTypes;
Type returnType;
{
Type[] types=Util.v().jimpleTypesOfFieldOrMethodDescriptor(cm,methodDescriptor);
parameterTypes=new ArrayList();
for (int k=0; k < types.length - 1; k++) {
parameterTypes.add(types[k]);
}
returnType=types[types.length - 1];
}
method=bclass.getMethod(methodName,parameterTypes,returnType);
params=new Value[args];
for (int j=args - 1; j >= 0; j--) {
params[j]=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex());
if (typeSize(typeStack.top()) == 2) {
typeStack=typeStack.pop();
typeStack=typeStack.pop();
}
 else typeStack=typeStack.pop();
}
rvalue=Jimple.v().newVirtualInvokeExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),method,Arrays.asList(params));
if (!returnType.equals(VoidType.v())) {
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rvalue);
}
 else stmt=Jimple.v().newInvokeStmt((InvokeExpr)rvalue);
break;
}
case ByteCode.INVOKENONVIRTUAL:
{
Instruction_Invokenonvirtual iv=(Instruction_Invokenonvirtual)ins;
args=cp_info.countParams(constant_pool,iv.arg_i);
SootMethod method=null;
CONSTANT_Methodref_info methodInfo=(CONSTANT_Methodref_info)constant_pool[iv.arg_i];
CONSTANT_Class_info c=(CONSTANT_Class_info)constant_pool[methodInfo.class_index];
String className=((CONSTANT_Utf8_info)(constant_pool[c.name_index])).convert();
className=className.replace('/','.');
CONSTANT_NameAndType_info i=(CONSTANT_NameAndType_info)constant_pool[methodInfo.name_and_type_index];
String methodName=((CONSTANT_Utf8_info)(constant_pool[i.name_index])).convert();
String methodDescriptor=((CONSTANT_Utf8_info)(constant_pool[i.descriptor_index])).convert();
SootClass bclass=cm.getSootClass(className);
Local[] parameters;
List parameterTypes;
Type returnType;
{
Type[] types=Util.v().jimpleTypesOfFieldOrMethodDescriptor(cm,methodDescriptor);
parameterTypes=new ArrayList();
for (int k=0; k < types.length - 1; k++) {
parameterTypes.add(types[k]);
}
returnType=types[types.length - 1];
}
method=bclass.getMethod(methodName,parameterTypes,returnType);
params=new Value[args];
for (int j=args - 1; j >= 0; j--) {
params[j]=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex());
if (typeSize(typeStack.top()) == 2) {
typeStack=typeStack.pop();
typeStack=typeStack.pop();
}
 else typeStack=typeStack.pop();
}
rvalue=Jimple.v().newSpecialInvokeExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),method,Arrays.asList(params));
if (!returnType.equals(VoidType.v())) {
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rvalue);
}
 else stmt=Jimple.v().newInvokeStmt((InvokeExpr)rvalue);
break;
}
case ByteCode.INVOKESTATIC:
{
Instruction_Invokestatic is=(Instruction_Invokestatic)ins;
args=cp_info.countParams(constant_pool,is.arg_i);
SootMethod method=null;
CONSTANT_Methodref_info methodInfo=(CONSTANT_Methodref_info)constant_pool[is.arg_i];
CONSTANT_Class_info c=(CONSTANT_Class_info)constant_pool[methodInfo.class_index];
String className=((CONSTANT_Utf8_info)(constant_pool[c.name_index])).convert();
className=className.replace('/','.');
CONSTANT_NameAndType_info i=(CONSTANT_NameAndType_info)constant_pool[methodInfo.name_and_type_index];
String methodName=((CONSTANT_Utf8_info)(constant_pool[i.name_index])).convert();
String methodDescriptor=((CONSTANT_Utf8_info)(constant_pool[i.descriptor_index])).convert();
SootClass bclass=cm.getSootClass(className);
Local[] parameters;
List parameterTypes;
Type returnType;
{
Type[] types=Util.v().jimpleTypesOfFieldOrMethodDescriptor(cm,methodDescriptor);
parameterTypes=new ArrayList();
for (int k=0; k < types.length - 1; k++) {
parameterTypes.add(types[k]);
}
returnType=types[types.length - 1];
}
method=bclass.getMethod(methodName,parameterTypes,returnType);
params=new Value[args];
for (int j=args - 1; j >= 0; j--) {
params[j]=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex());
if (typeSize(typeStack.top()) == 2) {
typeStack=typeStack.pop();
typeStack=typeStack.pop();
}
 else typeStack=typeStack.pop();
}
rvalue=Jimple.v().newStaticInvokeExpr(method,Arrays.asList(params));
if (!returnType.equals(VoidType.v())) {
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rvalue);
}
 else stmt=Jimple.v().newInvokeStmt((InvokeExpr)rvalue);
break;
}
case ByteCode.INVOKEINTERFACE:
{
Instruction_Invokeinterface ii=(Instruction_Invokeinterface)ins;
args=cp_info.countParams(constant_pool,ii.arg_i);
SootMethod method=null;
CONSTANT_InterfaceMethodref_info methodInfo=(CONSTANT_InterfaceMethodref_info)constant_pool[ii.arg_i];
CONSTANT_Class_info c=(CONSTANT_Class_info)constant_pool[methodInfo.class_index];
String className=((CONSTANT_Utf8_info)(constant_pool[c.name_index])).convert();
className=className.replace('/','.');
CONSTANT_NameAndType_info i=(CONSTANT_NameAndType_info)constant_pool[methodInfo.name_and_type_index];
String methodName=((CONSTANT_Utf8_info)(constant_pool[i.name_index])).convert();
String methodDescriptor=((CONSTANT_Utf8_info)(constant_pool[i.descriptor_index])).convert();
if (className.charAt(0) == '[') className=""String_Node_Str"";
SootClass bclass=cm.getSootClass(className);
Local[] parameters;
List parameterTypes;
Type returnType;
{
Type[] types=Util.v().jimpleTypesOfFieldOrMethodDescriptor(cm,methodDescriptor);
parameterTypes=new ArrayList();
for (int k=0; k < types.length - 1; k++) {
parameterTypes.add(types[k]);
}
returnType=types[types.length - 1];
}
method=bclass.getMethod(methodName,parameterTypes,returnType);
params=new Value[args];
for (int j=args - 1; j >= 0; j--) {
params[j]=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex());
if (typeSize(typeStack.top()) == 2) {
typeStack=typeStack.pop();
typeStack=typeStack.pop();
}
 else typeStack=typeStack.pop();
}
rvalue=Jimple.v().newInterfaceInvokeExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),method,Arrays.asList(params));
if (!returnType.equals(VoidType.v())) {
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rvalue);
}
 else stmt=Jimple.v().newInvokeStmt((InvokeExpr)rvalue);
break;
}
case ByteCode.ATHROW:
stmt=Jimple.v().newThrowStmt(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
break;
case ByteCode.NEW:
{
SootClass bclass=cm.getSootClass(getClassName(constant_pool,((Instruction_New)ins).arg_i));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),Jimple.v().newNewExpr(RefType.v(bclass.getName())));
break;
}
case ByteCode.CHECKCAST:
{
String className=getClassName(constant_pool,((Instruction_Checkcast)ins).arg_i);
Type castType;
if (className.startsWith(""String_Node_Str"")) castType=Util.v().jimpleTypeOfFieldDescriptor(cm,getClassName(constant_pool,((Instruction_Checkcast)ins).arg_i));
 else castType=RefType.v(className);
rhs=Jimple.v().newCastExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),castType);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
}
case ByteCode.INSTANCEOF:
{
Type checkType;
String className=getClassName(constant_pool,((Instruction_Instanceof)ins).arg_i);
if (className.startsWith(""String_Node_Str"")) checkType=Util.v().jimpleTypeOfFieldDescriptor(cm,getClassName(constant_pool,((Instruction_Instanceof)ins).arg_i));
 else checkType=RefType.v(className);
rhs=Jimple.v().newInstanceOfExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),checkType);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
}
case ByteCode.MONITORENTER:
stmt=Jimple.v().newEnterMonitorStmt(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
break;
case ByteCode.MONITOREXIT:
stmt=Jimple.v().newExitMonitorStmt(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
break;
default :
throw new RuntimeException(""String_Node_Str"" + x);
}
if (stmt != null) {
if (Options.v().keep_offset()) {
stmt.addTag(new BytecodeOffsetTag(ins.label));
}
statements.add(stmt);
}
}"
88737,"public BPrimitiveCastInst(Type fromType,Type toType){
  this.fromType=fromType;
  this.toType=toType;
}","public BPrimitiveCastInst(Type fromType,Type toType){
  if (fromType instanceof NullType)   throw new RuntimeException(""String_Node_Str"" + fromType);
  this.fromType=fromType;
  this.toType=toType;
}"
88738,"public void caseAssignStmt(AssignStmt stmt){
  Value l=stmt.getLeftOp();
  Value r=stmt.getRightOp();
  TypeNode left=null;
  if (l instanceof ArrayRef) {
    ArrayRef ref=(ArrayRef)l;
    TypeNode base=hierarchy.typeNode(((Local)ref.getBase()).getType());
    if (!base.hasElement()) {
      error(""String_Node_Str"");
    }
    left=base.element();
    Value index=ref.getIndex();
    if (index instanceof Local) {
      if (!hierarchy.typeNode(((Local)index).getType()).hasAncestorOrSelf(hierarchy.typeNode(IntType.v()))) {
        error(""String_Node_Str"");
      }
    }
  }
 else   if (l instanceof Local) {
    try {
      left=hierarchy.typeNode(((Local)l).getType());
    }
 catch (    InternalTypingException e) {
      G.v().out.println(""String_Node_Str"" + l);
      throw e;
    }
  }
 else   if (l instanceof InstanceFieldRef) {
    InstanceFieldRef ref=(InstanceFieldRef)l;
    TypeNode base=hierarchy.typeNode(((Local)ref.getBase()).getType());
    if (!base.hasAncestorOrSelf(hierarchy.typeNode(ref.getField().getDeclaringClass().getType()))) {
      if (fix) {
        ref.setBase(insertCast((Local)ref.getBase(),ref.getField().getDeclaringClass().getType(),stmt));
      }
 else {
        error(""String_Node_Str"");
      }
    }
    left=hierarchy.typeNode(ref.getField().getType());
  }
 else   if (l instanceof StaticFieldRef) {
    StaticFieldRef ref=(StaticFieldRef)l;
    left=hierarchy.typeNode(ref.getField().getType());
  }
 else {
    throw new RuntimeException(""String_Node_Str"" + l.getClass());
  }
  if (r instanceof ArrayRef) {
    ArrayRef ref=(ArrayRef)r;
    TypeNode base=hierarchy.typeNode(((Local)ref.getBase()).getType());
    if (!base.hasElement()) {
      if (base == hierarchy.NULL) {
        return;
      }
      error(""String_Node_Str"" + base + ""String_Node_Str"");
    }
    if (!left.hasDescendantOrSelf(base.element())) {
      if (fix) {
        Type lefttype=left.type();
        if (lefttype instanceof ArrayType) {
          ArrayType atype=(ArrayType)lefttype;
          ref.setBase(insertCast((Local)ref.getBase(),ArrayType.v(atype.baseType,atype.numDimensions + 1),stmt));
        }
 else {
          ref.setBase(insertCast((Local)ref.getBase(),ArrayType.v(lefttype,1),stmt));
        }
      }
 else {
        error(""String_Node_Str"");
      }
    }
    Value index=ref.getIndex();
    if (index instanceof Local) {
      if (!hierarchy.typeNode(((Local)index).getType()).hasAncestorOrSelf(hierarchy.typeNode(IntType.v()))) {
        error(""String_Node_Str"");
      }
    }
  }
 else   if (r instanceof DoubleConstant) {
    if (!left.hasDescendantOrSelf(hierarchy.typeNode(DoubleType.v()))) {
      error(""String_Node_Str"");
    }
  }
 else   if (r instanceof FloatConstant) {
    if (!left.hasDescendantOrSelf(hierarchy.typeNode(FloatType.v()))) {
      error(""String_Node_Str"");
    }
  }
 else   if (r instanceof IntConstant) {
    if (!left.hasDescendantOrSelf(hierarchy.typeNode(IntType.v()))) {
      error(""String_Node_Str"");
    }
  }
 else   if (r instanceof LongConstant) {
    if (!left.hasDescendantOrSelf(hierarchy.typeNode(LongType.v()))) {
      error(""String_Node_Str"");
    }
  }
 else   if (r instanceof NullConstant) {
    if (!left.hasDescendantOrSelf(hierarchy.typeNode(NullType.v()))) {
      error(""String_Node_Str"");
    }
  }
 else   if (r instanceof StringConstant) {
    if (!left.hasDescendantOrSelf(hierarchy.typeNode(RefType.v(""String_Node_Str"")))) {
      error(""String_Node_Str"");
    }
  }
 else   if (r instanceof BinopExpr) {
    BinopExpr be=(BinopExpr)r;
    Value lv=be.getOp1();
    Value rv=be.getOp2();
    TypeNode lop;
    TypeNode rop;
    if (lv instanceof Local) {
      lop=hierarchy.typeNode(((Local)lv).getType());
    }
 else     if (lv instanceof DoubleConstant) {
      lop=hierarchy.typeNode(DoubleType.v());
    }
 else     if (lv instanceof FloatConstant) {
      lop=hierarchy.typeNode(FloatType.v());
    }
 else     if (lv instanceof IntConstant) {
      lop=hierarchy.typeNode(IntType.v());
    }
 else     if (lv instanceof LongConstant) {
      lop=hierarchy.typeNode(LongType.v());
    }
 else     if (lv instanceof NullConstant) {
      lop=hierarchy.typeNode(NullType.v());
    }
 else     if (lv instanceof StringConstant) {
      lop=hierarchy.typeNode(RefType.v(""String_Node_Str""));
    }
 else {
      throw new RuntimeException(""String_Node_Str"" + lv.getClass());
    }
    if (rv instanceof Local) {
      rop=hierarchy.typeNode(((Local)rv).getType());
    }
 else     if (rv instanceof DoubleConstant) {
      rop=hierarchy.typeNode(DoubleType.v());
    }
 else     if (rv instanceof FloatConstant) {
      rop=hierarchy.typeNode(FloatType.v());
    }
 else     if (rv instanceof IntConstant) {
      rop=hierarchy.typeNode(IntType.v());
    }
 else     if (rv instanceof LongConstant) {
      rop=hierarchy.typeNode(LongType.v());
    }
 else     if (rv instanceof NullConstant) {
      rop=hierarchy.typeNode(NullType.v());
    }
 else     if (rv instanceof StringConstant) {
      rop=hierarchy.typeNode(RefType.v(""String_Node_Str""));
    }
 else {
      throw new RuntimeException(""String_Node_Str"" + rv.getClass());
    }
    if ((be instanceof AddExpr) || (be instanceof SubExpr) || (be instanceof MulExpr)|| (be instanceof DivExpr)|| (be instanceof RemExpr)|| (be instanceof AndExpr)|| (be instanceof OrExpr)|| (be instanceof XorExpr)) {
      if (!(left.hasDescendantOrSelf(lop) && left.hasDescendantOrSelf(rop))) {
        error(""String_Node_Str"");
      }
    }
 else     if ((be instanceof ShlExpr) || (be instanceof ShrExpr) || (be instanceof UshrExpr)) {
      if (!(left.hasDescendantOrSelf(lop) && hierarchy.typeNode(IntType.v()).hasAncestorOrSelf(rop))) {
        error(""String_Node_Str"");
      }
    }
 else     if ((be instanceof CmpExpr) || (be instanceof CmpgExpr) || (be instanceof CmplExpr)|| (be instanceof EqExpr)|| (be instanceof GeExpr)|| (be instanceof GtExpr)|| (be instanceof LeExpr)|| (be instanceof LtExpr)|| (be instanceof NeExpr)) {
      try {
        lop.lca(rop);
      }
 catch (      TypeException e) {
        error(e.getMessage());
      }
      if (!left.hasDescendantOrSelf(hierarchy.typeNode(IntType.v()))) {
        error(""String_Node_Str"");
      }
    }
 else {
      throw new RuntimeException(""String_Node_Str"" + be.getClass());
    }
  }
 else   if (r instanceof CastExpr) {
    CastExpr ce=(CastExpr)r;
    TypeNode cast=hierarchy.typeNode(ce.getCastType());
    if (ce.getOp() instanceof Local) {
      TypeNode op=hierarchy.typeNode(((Local)ce.getOp()).getType());
      try {
        if (cast.isClassOrInterface() || op.isClassOrInterface()) {
          cast.lca(op);
        }
      }
 catch (      TypeException e) {
        G.v().out.println(r + ""String_Node_Str"" + op+ ""String_Node_Str""+ cast+ ""String_Node_Str"");
        error(e.getMessage());
      }
    }
    if (!left.hasDescendantOrSelf(cast)) {
      error(""String_Node_Str"");
    }
  }
 else   if (r instanceof InstanceOfExpr) {
    InstanceOfExpr ioe=(InstanceOfExpr)r;
    TypeNode type=hierarchy.typeNode(ioe.getCheckType());
    TypeNode op=hierarchy.typeNode(((Local)ioe.getOp()).getType());
    try {
      op.lca(type);
    }
 catch (    TypeException e) {
      G.v().out.println(r + ""String_Node_Str"" + op+ ""String_Node_Str""+ type+ ""String_Node_Str"");
      error(e.getMessage());
    }
    if (!left.hasDescendantOrSelf(hierarchy.typeNode(IntType.v()))) {
      error(""String_Node_Str"");
    }
  }
 else   if (r instanceof InvokeExpr) {
    InvokeExpr ie=(InvokeExpr)r;
    handleInvokeExpr(ie,stmt);
    if (!left.hasDescendantOrSelf(hierarchy.typeNode(ie.getMethod().getReturnType()))) {
      error(""String_Node_Str"");
    }
  }
 else   if (r instanceof NewArrayExpr) {
    NewArrayExpr nae=(NewArrayExpr)r;
    Type baseType=nae.getBaseType();
    TypeNode right;
    if (baseType instanceof ArrayType) {
      right=hierarchy.typeNode(ArrayType.v(((ArrayType)baseType).baseType,((ArrayType)baseType).numDimensions + 1));
    }
 else {
      right=hierarchy.typeNode(ArrayType.v(baseType,1));
    }
    if (!left.hasDescendantOrSelf(right)) {
      error(""String_Node_Str"");
    }
    Value size=nae.getSize();
    if (size instanceof Local) {
      TypeNode var=hierarchy.typeNode(((Local)size).getType());
      if (!var.hasAncestorOrSelf(hierarchy.typeNode(IntType.v()))) {
        error(""String_Node_Str"");
      }
    }
  }
 else   if (r instanceof NewExpr) {
    NewExpr ne=(NewExpr)r;
    if (!left.hasDescendantOrSelf(hierarchy.typeNode(ne.getBaseType()))) {
      error(""String_Node_Str"");
    }
  }
 else   if (r instanceof NewMultiArrayExpr) {
    NewMultiArrayExpr nmae=(NewMultiArrayExpr)r;
    if (!left.hasDescendantOrSelf(hierarchy.typeNode(nmae.getBaseType()))) {
      error(""String_Node_Str"");
    }
    for (int i=0; i < nmae.getSizeCount(); i++) {
      Value size=nmae.getSize(i);
      if (size instanceof Local) {
        TypeNode var=hierarchy.typeNode(((Local)size).getType());
        if (!var.hasAncestorOrSelf(hierarchy.typeNode(IntType.v()))) {
          error(""String_Node_Str"");
        }
      }
    }
  }
 else   if (r instanceof LengthExpr) {
    LengthExpr le=(LengthExpr)r;
    if (!left.hasDescendantOrSelf(hierarchy.typeNode(IntType.v()))) {
      error(""String_Node_Str"");
    }
    if (le.getOp() instanceof Local) {
      if (!hierarchy.typeNode(((Local)le.getOp()).getType()).hasElement()) {
        error(""String_Node_Str"");
      }
    }
  }
 else   if (r instanceof NegExpr) {
    NegExpr ne=(NegExpr)r;
    TypeNode right;
    if (ne.getOp() instanceof Local) {
      right=hierarchy.typeNode(((Local)ne.getOp()).getType());
    }
 else     if (ne.getOp() instanceof DoubleConstant) {
      right=hierarchy.typeNode(DoubleType.v());
    }
 else     if (ne.getOp() instanceof FloatConstant) {
      right=hierarchy.typeNode(FloatType.v());
    }
 else     if (ne.getOp() instanceof IntConstant) {
      right=hierarchy.typeNode(IntType.v());
    }
 else     if (ne.getOp() instanceof LongConstant) {
      right=hierarchy.typeNode(LongType.v());
    }
 else {
      throw new RuntimeException(""String_Node_Str"" + ne.getOp().getClass());
    }
    if (!left.hasDescendantOrSelf(right)) {
      error(""String_Node_Str"");
    }
  }
 else   if (r instanceof Local) {
    if (!left.hasDescendantOrSelf(hierarchy.typeNode(((Local)r).getType()))) {
      if (fix) {
        stmt.setRightOp(insertCast((Local)r,left.type(),stmt));
      }
 else {
        error(""String_Node_Str"");
      }
    }
  }
 else   if (r instanceof InstanceFieldRef) {
    InstanceFieldRef ref=(InstanceFieldRef)r;
    TypeNode baseType=hierarchy.typeNode(((Local)ref.getBase()).getType());
    if (!baseType.hasAncestorOrSelf(hierarchy.typeNode(ref.getField().getDeclaringClass().getType()))) {
      if (fix) {
        ref.setBase(insertCast((Local)ref.getBase(),ref.getField().getDeclaringClass().getType(),stmt));
      }
 else {
        error(""String_Node_Str"");
      }
    }
    if (!left.hasDescendantOrSelf(hierarchy.typeNode(ref.getField().getType()))) {
      error(""String_Node_Str"");
    }
  }
 else   if (r instanceof StaticFieldRef) {
    StaticFieldRef ref=(StaticFieldRef)r;
    if (!left.hasDescendantOrSelf(hierarchy.typeNode(ref.getField().getType()))) {
      error(""String_Node_Str"");
    }
  }
 else {
    throw new RuntimeException(""String_Node_Str"" + r.getClass());
  }
}","public void caseAssignStmt(AssignStmt stmt){
  Value l=stmt.getLeftOp();
  Value r=stmt.getRightOp();
  TypeNode left=null;
  if (l instanceof ArrayRef) {
    ArrayRef ref=(ArrayRef)l;
    TypeNode base=hierarchy.typeNode(((Local)ref.getBase()).getType());
    if (!base.hasElement()) {
      error(""String_Node_Str"");
    }
    left=base.element();
    Value index=ref.getIndex();
    if (index instanceof Local) {
      if (!hierarchy.typeNode(((Local)index).getType()).hasAncestorOrSelf(hierarchy.typeNode(IntType.v()))) {
        error(""String_Node_Str"");
      }
    }
  }
 else   if (l instanceof Local) {
    try {
      left=hierarchy.typeNode(((Local)l).getType());
    }
 catch (    InternalTypingException e) {
      G.v().out.println(""String_Node_Str"" + l);
      throw e;
    }
  }
 else   if (l instanceof InstanceFieldRef) {
    InstanceFieldRef ref=(InstanceFieldRef)l;
    TypeNode base=hierarchy.typeNode(((Local)ref.getBase()).getType());
    if (!base.hasAncestorOrSelf(hierarchy.typeNode(ref.getField().getDeclaringClass().getType()))) {
      if (fix) {
        ref.setBase(insertCast((Local)ref.getBase(),ref.getField().getDeclaringClass().getType(),stmt));
      }
 else {
        error(""String_Node_Str"");
      }
    }
    left=hierarchy.typeNode(ref.getField().getType());
  }
 else   if (l instanceof StaticFieldRef) {
    StaticFieldRef ref=(StaticFieldRef)l;
    left=hierarchy.typeNode(ref.getField().getType());
  }
 else {
    throw new RuntimeException(""String_Node_Str"" + l.getClass());
  }
  if (r instanceof ArrayRef) {
    ArrayRef ref=(ArrayRef)r;
    TypeNode base=hierarchy.typeNode(((Local)ref.getBase()).getType());
    if (!base.hasElement()) {
      if (base == hierarchy.NULL) {
        return;
      }
      error(""String_Node_Str"" + base + ""String_Node_Str"");
    }
    if (!left.hasDescendantOrSelf(base.element())) {
      if (fix) {
        Type lefttype=left.type();
        if (lefttype instanceof ArrayType) {
          ArrayType atype=(ArrayType)lefttype;
          ref.setBase(insertCast((Local)ref.getBase(),ArrayType.v(atype.baseType,atype.numDimensions + 1),stmt));
        }
 else {
          ref.setBase(insertCast((Local)ref.getBase(),ArrayType.v(lefttype,1),stmt));
        }
      }
 else {
        error(""String_Node_Str"");
      }
    }
    Value index=ref.getIndex();
    if (index instanceof Local) {
      if (!hierarchy.typeNode(((Local)index).getType()).hasAncestorOrSelf(hierarchy.typeNode(IntType.v()))) {
        error(""String_Node_Str"");
      }
    }
  }
 else   if (r instanceof DoubleConstant) {
    if (!left.hasDescendantOrSelf(hierarchy.typeNode(DoubleType.v()))) {
      error(""String_Node_Str"");
    }
  }
 else   if (r instanceof FloatConstant) {
    if (!left.hasDescendantOrSelf(hierarchy.typeNode(FloatType.v()))) {
      error(""String_Node_Str"");
    }
  }
 else   if (r instanceof IntConstant) {
    if (!left.hasDescendantOrSelf(hierarchy.typeNode(IntType.v()))) {
      error(""String_Node_Str"");
    }
  }
 else   if (r instanceof LongConstant) {
    if (!left.hasDescendantOrSelf(hierarchy.typeNode(LongType.v()))) {
      error(""String_Node_Str"");
    }
  }
 else   if (r instanceof NullConstant) {
    if (!left.hasDescendantOrSelf(hierarchy.typeNode(NullType.v()))) {
      error(""String_Node_Str"");
    }
  }
 else   if (r instanceof StringConstant) {
    if (!left.hasDescendantOrSelf(hierarchy.typeNode(RefType.v(""String_Node_Str"")))) {
      error(""String_Node_Str"");
    }
  }
 else   if (r instanceof BinopExpr) {
    BinopExpr be=(BinopExpr)r;
    Value lv=be.getOp1();
    Value rv=be.getOp2();
    TypeNode lop;
    TypeNode rop;
    if (lv instanceof Local) {
      lop=hierarchy.typeNode(((Local)lv).getType());
    }
 else     if (lv instanceof DoubleConstant) {
      lop=hierarchy.typeNode(DoubleType.v());
    }
 else     if (lv instanceof FloatConstant) {
      lop=hierarchy.typeNode(FloatType.v());
    }
 else     if (lv instanceof IntConstant) {
      lop=hierarchy.typeNode(IntType.v());
    }
 else     if (lv instanceof LongConstant) {
      lop=hierarchy.typeNode(LongType.v());
    }
 else     if (lv instanceof NullConstant) {
      lop=hierarchy.typeNode(NullType.v());
    }
 else     if (lv instanceof StringConstant) {
      lop=hierarchy.typeNode(RefType.v(""String_Node_Str""));
    }
 else {
      throw new RuntimeException(""String_Node_Str"" + lv.getClass());
    }
    if (rv instanceof Local) {
      rop=hierarchy.typeNode(((Local)rv).getType());
    }
 else     if (rv instanceof DoubleConstant) {
      rop=hierarchy.typeNode(DoubleType.v());
    }
 else     if (rv instanceof FloatConstant) {
      rop=hierarchy.typeNode(FloatType.v());
    }
 else     if (rv instanceof IntConstant) {
      rop=hierarchy.typeNode(IntType.v());
    }
 else     if (rv instanceof LongConstant) {
      rop=hierarchy.typeNode(LongType.v());
    }
 else     if (rv instanceof NullConstant) {
      rop=hierarchy.typeNode(NullType.v());
    }
 else     if (rv instanceof StringConstant) {
      rop=hierarchy.typeNode(RefType.v(""String_Node_Str""));
    }
 else {
      throw new RuntimeException(""String_Node_Str"" + rv.getClass());
    }
    if ((be instanceof AddExpr) || (be instanceof SubExpr) || (be instanceof MulExpr)|| (be instanceof DivExpr)|| (be instanceof RemExpr)|| (be instanceof AndExpr)|| (be instanceof OrExpr)|| (be instanceof XorExpr)) {
      if (!(left.hasDescendantOrSelf(lop) && left.hasDescendantOrSelf(rop))) {
        error(""String_Node_Str"");
      }
    }
 else     if ((be instanceof ShlExpr) || (be instanceof ShrExpr) || (be instanceof UshrExpr)) {
      if (!(left.hasDescendantOrSelf(lop) && hierarchy.typeNode(IntType.v()).hasAncestorOrSelf(rop))) {
        error(""String_Node_Str"");
      }
    }
 else     if ((be instanceof CmpExpr) || (be instanceof CmpgExpr) || (be instanceof CmplExpr)|| (be instanceof EqExpr)|| (be instanceof GeExpr)|| (be instanceof GtExpr)|| (be instanceof LeExpr)|| (be instanceof LtExpr)|| (be instanceof NeExpr)) {
      try {
        lop.lca(rop);
      }
 catch (      TypeException e) {
        error(e.getMessage());
      }
      if (!left.hasDescendantOrSelf(hierarchy.typeNode(IntType.v()))) {
        error(""String_Node_Str"");
      }
    }
 else {
      throw new RuntimeException(""String_Node_Str"" + be.getClass());
    }
  }
 else   if (r instanceof CastExpr) {
    CastExpr ce=(CastExpr)r;
    TypeNode cast=hierarchy.typeNode(ce.getCastType());
    if (ce.getOp() instanceof Local) {
      TypeNode op=hierarchy.typeNode(((Local)ce.getOp()).getType());
      try {
        if (cast.isClassOrInterface() || op.isClassOrInterface()) {
          cast.lca(op);
        }
      }
 catch (      TypeException e) {
        G.v().out.println(r + ""String_Node_Str"" + op+ ""String_Node_Str""+ cast+ ""String_Node_Str"");
        error(e.getMessage());
      }
    }
    if (!left.hasDescendantOrSelf(cast)) {
      error(""String_Node_Str"");
    }
  }
 else   if (r instanceof InstanceOfExpr) {
    InstanceOfExpr ioe=(InstanceOfExpr)r;
    TypeNode type=hierarchy.typeNode(ioe.getCheckType());
    TypeNode op=hierarchy.typeNode(ioe.getOp().getType());
    try {
      op.lca(type);
    }
 catch (    TypeException e) {
      G.v().out.println(r + ""String_Node_Str"" + op+ ""String_Node_Str""+ type+ ""String_Node_Str"");
      error(e.getMessage());
    }
    if (!left.hasDescendantOrSelf(hierarchy.typeNode(IntType.v()))) {
      error(""String_Node_Str"");
    }
  }
 else   if (r instanceof InvokeExpr) {
    InvokeExpr ie=(InvokeExpr)r;
    handleInvokeExpr(ie,stmt);
    if (!left.hasDescendantOrSelf(hierarchy.typeNode(ie.getMethod().getReturnType()))) {
      error(""String_Node_Str"");
    }
  }
 else   if (r instanceof NewArrayExpr) {
    NewArrayExpr nae=(NewArrayExpr)r;
    Type baseType=nae.getBaseType();
    TypeNode right;
    if (baseType instanceof ArrayType) {
      right=hierarchy.typeNode(ArrayType.v(((ArrayType)baseType).baseType,((ArrayType)baseType).numDimensions + 1));
    }
 else {
      right=hierarchy.typeNode(ArrayType.v(baseType,1));
    }
    if (!left.hasDescendantOrSelf(right)) {
      error(""String_Node_Str"");
    }
    Value size=nae.getSize();
    if (size instanceof Local) {
      TypeNode var=hierarchy.typeNode(((Local)size).getType());
      if (!var.hasAncestorOrSelf(hierarchy.typeNode(IntType.v()))) {
        error(""String_Node_Str"");
      }
    }
  }
 else   if (r instanceof NewExpr) {
    NewExpr ne=(NewExpr)r;
    if (!left.hasDescendantOrSelf(hierarchy.typeNode(ne.getBaseType()))) {
      error(""String_Node_Str"");
    }
  }
 else   if (r instanceof NewMultiArrayExpr) {
    NewMultiArrayExpr nmae=(NewMultiArrayExpr)r;
    if (!left.hasDescendantOrSelf(hierarchy.typeNode(nmae.getBaseType()))) {
      error(""String_Node_Str"");
    }
    for (int i=0; i < nmae.getSizeCount(); i++) {
      Value size=nmae.getSize(i);
      if (size instanceof Local) {
        TypeNode var=hierarchy.typeNode(((Local)size).getType());
        if (!var.hasAncestorOrSelf(hierarchy.typeNode(IntType.v()))) {
          error(""String_Node_Str"");
        }
      }
    }
  }
 else   if (r instanceof LengthExpr) {
    LengthExpr le=(LengthExpr)r;
    if (!left.hasDescendantOrSelf(hierarchy.typeNode(IntType.v()))) {
      error(""String_Node_Str"");
    }
    if (le.getOp() instanceof Local) {
      if (!hierarchy.typeNode(((Local)le.getOp()).getType()).hasElement()) {
        error(""String_Node_Str"");
      }
    }
  }
 else   if (r instanceof NegExpr) {
    NegExpr ne=(NegExpr)r;
    TypeNode right;
    if (ne.getOp() instanceof Local) {
      right=hierarchy.typeNode(((Local)ne.getOp()).getType());
    }
 else     if (ne.getOp() instanceof DoubleConstant) {
      right=hierarchy.typeNode(DoubleType.v());
    }
 else     if (ne.getOp() instanceof FloatConstant) {
      right=hierarchy.typeNode(FloatType.v());
    }
 else     if (ne.getOp() instanceof IntConstant) {
      right=hierarchy.typeNode(IntType.v());
    }
 else     if (ne.getOp() instanceof LongConstant) {
      right=hierarchy.typeNode(LongType.v());
    }
 else {
      throw new RuntimeException(""String_Node_Str"" + ne.getOp().getClass());
    }
    if (!left.hasDescendantOrSelf(right)) {
      error(""String_Node_Str"");
    }
  }
 else   if (r instanceof Local) {
    if (!left.hasDescendantOrSelf(hierarchy.typeNode(((Local)r).getType()))) {
      if (fix) {
        stmt.setRightOp(insertCast((Local)r,left.type(),stmt));
      }
 else {
        error(""String_Node_Str"");
      }
    }
  }
 else   if (r instanceof InstanceFieldRef) {
    InstanceFieldRef ref=(InstanceFieldRef)r;
    TypeNode baseType=hierarchy.typeNode(((Local)ref.getBase()).getType());
    if (!baseType.hasAncestorOrSelf(hierarchy.typeNode(ref.getField().getDeclaringClass().getType()))) {
      if (fix) {
        ref.setBase(insertCast((Local)ref.getBase(),ref.getField().getDeclaringClass().getType(),stmt));
      }
 else {
        error(""String_Node_Str"");
      }
    }
    if (!left.hasDescendantOrSelf(hierarchy.typeNode(ref.getField().getType()))) {
      error(""String_Node_Str"");
    }
  }
 else   if (r instanceof StaticFieldRef) {
    StaticFieldRef ref=(StaticFieldRef)r;
    if (!left.hasDescendantOrSelf(hierarchy.typeNode(ref.getField().getType()))) {
      error(""String_Node_Str"");
    }
  }
 else {
    throw new RuntimeException(""String_Node_Str"" + r.getClass());
  }
}"
88739,"public void run(){
  for (int i=0; i < srs.length; i++) {
    try {
      System.out.println(""String_Node_Str"" + srs[i]);
      getViewer().getTextWidget().setStyleRange(srs[i]);
    }
 catch (    Exception e) {
      System.out.println(""String_Node_Str"" + e.getMessage());
    }
  }
}","public void run(){
  for (int i=0; i < srs.length; i++) {
    try {
      getViewer().getTextWidget().setStyleRange(srs[i]);
    }
 catch (    Exception e) {
      System.out.println(""String_Node_Str"" + e.getMessage());
    }
  }
}"
88740,"protected void changeStyles(){
  final StyleRange[] srs=new StyleRange[styleList.size()];
  styleList.toArray(srs);
  getDisplay().asyncExec(new Runnable(){
    public void run(){
      for (int i=0; i < srs.length; i++) {
        try {
          System.out.println(""String_Node_Str"" + srs[i]);
          getViewer().getTextWidget().setStyleRange(srs[i]);
        }
 catch (        Exception e) {
          System.out.println(""String_Node_Str"" + e.getMessage());
        }
      }
    }
  }
);
}","protected void changeStyles(){
  final StyleRange[] srs=new StyleRange[styleList.size()];
  styleList.toArray(srs);
  getDisplay().asyncExec(new Runnable(){
    public void run(){
      for (int i=0; i < srs.length; i++) {
        try {
          getViewer().getTextWidget().setStyleRange(srs[i]);
        }
 catch (        Exception e) {
          System.out.println(""String_Node_Str"" + e.getMessage());
        }
      }
    }
  }
);
}"
88741,"public Color getColor(RGB rgb){
  System.out.println(""String_Node_Str"" + rgb.red + ""String_Node_Str""+ rgb.green+ ""String_Node_Str""+ rgb.blue);
  Color color=(Color)fColorTable.get(rgb);
  if (color == null) {
    color=new Color(Display.getCurrent(),rgb);
    System.out.println(""String_Node_Str"");
    fColorTable.put(rgb,color);
  }
  return color;
}","public Color getColor(RGB rgb){
  Color color=(Color)fColorTable.get(rgb);
  if (color == null) {
    color=new Color(Display.getCurrent(),rgb);
    fColorTable.put(rgb,color);
  }
  return color;
}"
88742,"public void dispose(){
  System.out.println(""String_Node_Str"");
  if (fColorTable.values() == null)   return;
  Iterator e=fColorTable.values().iterator();
  while (e.hasNext())   ((Color)e.next()).dispose();
}","public void dispose(){
  if (fColorTable.values() == null)   return;
  Iterator e=fColorTable.values().iterator();
  while (e.hasNext())   ((Color)e.next()).dispose();
}"
88743,"public void updatePart(IEditorPart part){
  if (part == null)   return;
  if (part instanceof JimpleEditor) {
    AbstractAttributesComputer aac=new JimpleAttributesComputer();
    SootAttributesJimpleColorer sajc=new SootAttributesJimpleColorer();
    SootAttrJimpleIconGenerator saji=new SootAttrJimpleIconGenerator();
    SourceViewer viewer=(SourceViewer)((AbstractTextEditor)part).getAdapter(ITextOperationTarget.class);
    SootAttributesHandler handler=aac.getAttributesHandler((AbstractTextEditor)part);
    if (handler != null) {
      if (isUpdateForOpen() || handler.isUpdate()) {
        sajc.setEditorPart(part);
        sajc.setViewer(viewer);
        sajc.setHandler(handler);
        Thread cThread=new Thread(sajc);
        cThread.start();
        saji.setHandler(handler);
        saji.setRec((IFile)aac.getRec());
        Thread iThread=new Thread(saji);
        iThread.start();
      }
    }
  }
 else {
    IEditorInput input=((AbstractTextEditor)part).getEditorInput();
    IJavaElement jElem=(IJavaElement)((IAdaptable)input).getAdapter(IJavaElement.class);
    if (!(jElem instanceof ICompilationUnit))     return;
    AbstractAttributesComputer aac=new JavaAttributesComputer();
    SootAttributesJavaColorer sajc=new SootAttributesJavaColorer();
    SootAttrJavaIconGenerator saji=new SootAttrJavaIconGenerator();
    SourceViewer viewer=(SourceViewer)((AbstractTextEditor)part).getAdapter(ITextOperationTarget.class);
    SootAttributesHandler handler=aac.getAttributesHandler((AbstractTextEditor)part);
    if (handler != null) {
      if (isUpdateForOpen() || handler.isUpdate()) {
        sajc.setEditorPart(part);
        sajc.setViewer(viewer);
        sajc.setHandler(handler);
        Thread cThread=new Thread(sajc);
        cThread.start();
        saji.setHandler(handler);
        saji.setRec((IFile)aac.getRec());
        Thread iThread=new Thread(saji);
        iThread.start();
      }
    }
  }
  setUpdateForOpen(false);
}","public void updatePart(IEditorPart part){
  if (part == null)   return;
  if (part instanceof JimpleEditor) {
    AbstractAttributesComputer aac=new JimpleAttributesComputer();
    SootAttributesJimpleColorer sajc=new SootAttributesJimpleColorer();
    SootAttrJimpleIconGenerator saji=new SootAttrJimpleIconGenerator();
    SourceViewer viewer=(SourceViewer)((AbstractTextEditor)part).getAdapter(ITextOperationTarget.class);
    SootAttributesHandler handler=aac.getAttributesHandler((AbstractTextEditor)part);
    System.out.println(""String_Node_Str"" + handler);
    if (handler != null) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"" + isUpdateForOpen());
      System.out.println(""String_Node_Str"" + handler.isUpdate());
      if (isUpdateForOpen() || handler.isUpdate()) {
        sajc.setEditorPart(part);
        sajc.setViewer(viewer);
        sajc.setHandler(handler);
        Thread cThread=new Thread(sajc);
        cThread.start();
        saji.setHandler(handler);
        saji.setRec((IFile)aac.getRec());
        Thread iThread=new Thread(saji);
        iThread.start();
      }
    }
  }
 else {
    IEditorInput input=((AbstractTextEditor)part).getEditorInput();
    IJavaElement jElem=(IJavaElement)((IAdaptable)input).getAdapter(IJavaElement.class);
    if (!(jElem instanceof ICompilationUnit))     return;
    AbstractAttributesComputer aac=new JavaAttributesComputer();
    SootAttributesJavaColorer sajc=new SootAttributesJavaColorer();
    SootAttrJavaIconGenerator saji=new SootAttrJavaIconGenerator();
    SourceViewer viewer=(SourceViewer)((AbstractTextEditor)part).getAdapter(ITextOperationTarget.class);
    SootAttributesHandler handler=aac.getAttributesHandler((AbstractTextEditor)part);
    System.out.println(""String_Node_Str"" + handler);
    if (handler != null) {
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"" + isUpdateForOpen());
      System.out.println(""String_Node_Str"" + handler.isUpdate());
      if (isUpdateForOpen() || handler.isUpdate()) {
        sajc.setEditorPart(part);
        sajc.setViewer(viewer);
        sajc.setHandler(handler);
        Thread cThread=new Thread(sajc);
        cThread.start();
        saji.setHandler(handler);
        saji.setRec((IFile)aac.getRec());
        Thread iThread=new Thread(saji);
        iThread.start();
      }
    }
  }
  setUpdateForOpen(false);
}"
88744,"/** 
 * Applies the transformations corresponding to the given options. 
 */
private void applyPhaseOptions(JimpleBody b,Map opts){
  JBOptions options=new JBOptions(opts);
  if (options.use_original_names())   PhaseOptions.v().setPhaseOptionIfUnset(""String_Node_Str"",""String_Node_Str"");
  if (Options.v().time())   Timers.v().splitTimer.start();
  PackManager.v().getTransform(""String_Node_Str"").apply(b);
  if (Options.v().time())   Timers.v().splitTimer.end();
  PackManager.v().getTransform(""String_Node_Str"").apply(b);
  PackManager.v().getTransform(""String_Node_Str"").apply(b);
  if (Options.v().time())   Timers.v().assignTimer.start();
  PackManager.v().getTransform(""String_Node_Str"").apply(b);
  if (Options.v().time())   Timers.v().assignTimer.end();
  if (typingFailed(b))   throw new RuntimeException(""String_Node_Str"");
  if (options.use_original_names()) {
    PackManager.v().getTransform(""String_Node_Str"").apply(b);
  }
  PackManager.v().getTransform(""String_Node_Str"").apply(b);
  PackManager.v().getTransform(""String_Node_Str"").apply(b);
  PackManager.v().getTransform(""String_Node_Str"").apply(b);
  PackManager.v().getTransform(""String_Node_Str"").apply(b);
  PackManager.v().getTransform(""String_Node_Str"").apply(b);
  PackManager.v().getTransform(""String_Node_Str"").apply(b);
  PackManager.v().getTransform(""String_Node_Str"").apply(b);
  if (Options.v().time())   Timers.v().stmtCount+=b.getUnits().size();
}","/** 
 * Applies the transformations corresponding to the given options. 
 */
private void applyPhaseOptions(JimpleBody b,Map opts){
  JBOptions options=new JBOptions(opts);
  if (options.use_original_names())   PhaseOptions.v().setPhaseOptionIfUnset(""String_Node_Str"",""String_Node_Str"");
  if (Options.v().time())   Timers.v().splitTimer.start();
  PackManager.v().getTransform(""String_Node_Str"").apply(b);
  if (Options.v().time())   Timers.v().splitTimer.end();
  PackManager.v().getTransform(""String_Node_Str"").apply(b);
  PackManager.v().getTransform(""String_Node_Str"").apply(b);
  if (Options.v().time())   Timers.v().assignTimer.start();
  PackManager.v().getTransform(""String_Node_Str"").apply(b);
  if (Options.v().time())   Timers.v().assignTimer.end();
  if (options.use_original_names()) {
    PackManager.v().getTransform(""String_Node_Str"").apply(b);
  }
  PackManager.v().getTransform(""String_Node_Str"").apply(b);
  PackManager.v().getTransform(""String_Node_Str"").apply(b);
  PackManager.v().getTransform(""String_Node_Str"").apply(b);
  PackManager.v().getTransform(""String_Node_Str"").apply(b);
  PackManager.v().getTransform(""String_Node_Str"").apply(b);
  PackManager.v().getTransform(""String_Node_Str"").apply(b);
  PackManager.v().getTransform(""String_Node_Str"").apply(b);
  if (Options.v().time())   Timers.v().stmtCount+=b.getUnits().size();
}"
88745,"/** 
 * Assign types to local variables. 
 */
protected void internalTransform(Body b,String phaseName,Map options){
  if (b == null) {
    throw new NullPointerException();
  }
  Date start=new Date();
  if (Options.v().verbose())   G.v().out.println(""String_Node_Str"" + start);
  TypeResolver.resolve((JimpleBody)b,Scene.v());
  Date finish=new Date();
  if (Options.v().verbose()) {
    long runtime=finish.getTime() - start.getTime();
    long mins=runtime / 60000;
    long secs=(runtime % 60000) / 1000;
    G.v().out.println(""String_Node_Str"" + mins + ""String_Node_Str""+ secs+ ""String_Node_Str"");
  }
}","/** 
 * Assign types to local variables. 
 */
protected void internalTransform(Body b,String phaseName,Map options){
  if (b == null) {
    throw new NullPointerException();
  }
  Date start=new Date();
  if (Options.v().verbose())   G.v().out.println(""String_Node_Str"" + start);
  TypeResolver.resolve((JimpleBody)b,Scene.v());
  Date finish=new Date();
  if (Options.v().verbose()) {
    long runtime=finish.getTime() - start.getTime();
    long mins=runtime / 60000;
    long secs=(runtime % 60000) / 1000;
    G.v().out.println(""String_Node_Str"" + mins + ""String_Node_Str""+ secs+ ""String_Node_Str"");
  }
  if (typingFailed((JimpleBody)b))   throw new RuntimeException(""String_Node_Str"");
}"
88746,"private void setAttributeTextColor(TextPresentation tp,int sline,int eline,int start,int end,RGB colorKey,boolean fg){
  System.out.println(""String_Node_Str"" + sline + ""String_Node_Str""+ start+ ""String_Node_Str""+ end);
  Display display=getEditorPart().getSite().getShell().getDisplay();
  ColorManager colorManager=new ColorManager();
  int sLineOffset=0;
  int eLineOffset=0;
  try {
    sLineOffset=getViewer().getDocument().getLineOffset((sline - 1));
    eLineOffset=getViewer().getDocument().getLineOffset((eline - 1));
  }
 catch (  Exception e) {
  }
  final boolean foreground=fg;
  final int s=sLineOffset + start - 1;
  int e=eLineOffset + end - 1;
  final int l=e - s;
  final Color ck=colorManager.getColor(colorKey);
  final Color oldBgC=colorManager.getColor(IJimpleColorConstants.JIMPLE_DEFAULT);
  display.asyncExec(new Runnable(){
    public void run(){
      TextPresentation tp=new TextPresentation();
      StyleRange sr;
      if (l != 0) {
        if (foreground) {
          sr=new StyleRange(s,l,ck,getBgColor());
        }
 else {
          sr=new StyleRange(s,l,oldBgC,ck);
        }
        tp.addStyleRange(sr);
      }
      getViewer().changeTextPresentation(tp,true);
    }
  }
);
}","private void setAttributeTextColor(TextPresentation tp,int sline,int eline,int start,int end,RGB colorKey,boolean fg){
  System.out.println(""String_Node_Str"" + sline + ""String_Node_Str""+ start+ ""String_Node_Str""+ end);
  Display display=getEditorPart().getSite().getShell().getDisplay();
  ColorManager colorManager=new ColorManager();
  int sLineOffset=0;
  int eLineOffset=0;
  try {
    sLineOffset=getViewer().getDocument().getLineOffset((sline - 1));
    eLineOffset=getViewer().getDocument().getLineOffset((eline - 1));
  }
 catch (  Exception e) {
    return;
  }
  final boolean foreground=fg;
  final int s=sLineOffset + start - 1;
  int e=eLineOffset + end - 1;
  final int l=e - s;
  final Color ck=colorManager.getColor(colorKey);
  final Color oldBgC=colorManager.getColor(IJimpleColorConstants.JIMPLE_DEFAULT);
  display.asyncExec(new Runnable(){
    public void run(){
      TextPresentation tp=new TextPresentation();
      StyleRange sr;
      if (l != 0) {
        if (foreground) {
          sr=new StyleRange(s,l,ck,getBgColor());
        }
 else {
          sr=new StyleRange(s,l,oldBgC,ck);
        }
        tp.addStyleRange(sr);
      }
      getViewer().changeTextPresentation(tp,true);
    }
  }
);
}"
88747,"/** 
 * @see org.eclipse.jface.text.ITextHover#getHoverRegion(ITextViewer,int)
 */
public org.eclipse.jface.text.IRegion getHoverRegion(ITextViewer textViewer,int offset){
  try {
    setLineNum(textViewer.getDocument().getLineOfOffset(offset) + 1);
    System.out.println(""String_Node_Str"");
    setViewer(textViewer);
    setDocument(textViewer.getDocument());
    return textViewer.getDocument().getLineInformationOfOffset(offset);
  }
 catch (  BadLocationException e) {
    return null;
  }
}","/** 
 * @see org.eclipse.jface.text.ITextHover#getHoverRegion(ITextViewer,int)
 */
public org.eclipse.jface.text.IRegion getHoverRegion(ITextViewer textViewer,int offset){
  try {
    setLineNum(textViewer.getDocument().getLineOfOffset(offset) + 1);
    System.out.println(""String_Node_Str"");
    handleViewer(textViewer);
    setDocument(textViewer.getDocument());
    return textViewer.getDocument().getLineInformationOfOffset(offset);
  }
 catch (  BadLocationException e) {
    return null;
  }
}"
88748,"/** 
 * Method setEditor.
 * @param ed
 */
public void setEditor(IEditorPart ed){
  System.out.println(""String_Node_Str"");
  editor=ed;
}","/** 
 * Method setEditor.
 * @param ed
 */
public void setEditor(IEditorPart ed){
  System.out.println(""String_Node_Str"");
  editor=ed;
  formTextViewer(editor);
}"
88749,"private void processVBNode(PosColAttribute vbAttr,Node node){
  if (node.getNodeType() == Node.ELEMENT_NODE) {
    NodeList children=node.getChildNodes();
    for (int i=0; i < children.getLength(); i++) {
      processVBNode(vbAttr,children.item(i));
    }
  }
 else   if (node.getNodeType() == Node.TEXT_NODE) {
    String type=node.getParentNode().getNodeName();
    if (type.equals(""String_Node_Str"")) {
      vbAttr.setStartOffset((new Integer(node.getNodeValue()).intValue()));
    }
 else     if (type.equals(""String_Node_Str"")) {
      vbAttr.setEndOffset((new Integer(node.getNodeValue()).intValue()));
    }
 else     if (type.equals(""String_Node_Str"")) {
      vbAttr.setSourceStartOffset((new Integer(node.getNodeValue()).intValue()));
      System.out.println(""String_Node_Str"" + vbAttr.getSourceStartOffset());
    }
 else     if (type.equals(""String_Node_Str"")) {
      vbAttr.setSourceEndOffset((new Integer(node.getNodeValue()).intValue()));
      System.out.println(""String_Node_Str"" + vbAttr.getSourceEndOffset());
    }
 else     if (type.equals(""String_Node_Str"")) {
      vbAttr.setRed((new Integer(node.getNodeValue()).intValue()));
    }
 else     if (type.equals(""String_Node_Str"")) {
      vbAttr.setGreen((new Integer(node.getNodeValue()).intValue()));
    }
 else     if (type.equals(""String_Node_Str"")) {
      vbAttr.setBlue((new Integer(node.getNodeValue()).intValue()));
    }
 else     if (type.equals(""String_Node_Str"")) {
      vbAttr.setFg((new Integer(node.getNodeValue()).intValue()));
    }
  }
}","private void processVBNode(PosColAttribute vbAttr,Node node){
  if (node.getNodeType() == Node.ELEMENT_NODE) {
    NodeList children=node.getChildNodes();
    for (int i=0; i < children.getLength(); i++) {
      processVBNode(vbAttr,children.item(i));
    }
  }
 else   if (node.getNodeType() == Node.TEXT_NODE) {
    String type=node.getParentNode().getNodeName();
    if (type.equals(""String_Node_Str"")) {
      vbAttr.setStartOffset((new Integer(node.getNodeValue()).intValue()));
    }
 else     if (type.equals(""String_Node_Str"")) {
      vbAttr.setEndOffset((new Integer(node.getNodeValue()).intValue()));
    }
 else     if (type.equals(""String_Node_Str"")) {
      vbAttr.setSourceStartOffset((new Integer(node.getNodeValue()).intValue()));
    }
 else     if (type.equals(""String_Node_Str"")) {
      vbAttr.setSourceEndOffset((new Integer(node.getNodeValue()).intValue()));
    }
 else     if (type.equals(""String_Node_Str"")) {
      vbAttr.setRed((new Integer(node.getNodeValue()).intValue()));
    }
 else     if (type.equals(""String_Node_Str"")) {
      vbAttr.setGreen((new Integer(node.getNodeValue()).intValue()));
    }
 else     if (type.equals(""String_Node_Str"")) {
      vbAttr.setBlue((new Integer(node.getNodeValue()).intValue()));
    }
 else     if (type.equals(""String_Node_Str"")) {
      vbAttr.setFg((new Integer(node.getNodeValue()).intValue()));
    }
  }
}"
88750,"public boolean attrForJavaLn(int java_ln){
  System.out.println(""String_Node_Str"" + getJavaStartLn() + ""String_Node_Str""+ java_ln);
  if (getJavaStartLn() == java_ln)   return true;
 else   return false;
}","public boolean attrForJavaLn(int java_ln){
  if (getJavaStartLn() == java_ln)   return true;
 else   return false;
}"
88751,"public void run(){
  IAnnotationModel model=getEditor().getDocumentProvider().getAnnotationModel(getEditor().getEditorInput());
  if (model instanceof AbstractMarkerAnnotationModel) {
    setModel((AbstractMarkerAnnotationModel)model);
  }
  int markerLine=getRulerInfo().getLineOfLastMouseButtonActivity();
  IResource rec=getResource(getEditor());
  try {
    IMarker[] markers=rec.findMarkers(""String_Node_Str"",true,IResource.DEPTH_INFINITE);
    for (int i=0; i < markers.length; i++) {
      setLineNumber(getDocument().getLineOfOffset(getModel().getMarkerPosition(markers[i]).getOffset()));
      if (getLineNumber() == markerLine) {
        System.out.println(""String_Node_Str"");
        ArrayList links=getMarkerLinks();
        Iterator lit=links.iterator();
        while (lit.hasNext()) {
          System.out.println(""String_Node_Str"" + lit.next());
        }
        String[] list=getMarkerLabels(links);
        if ((list == null) || (list.length == 0)) {
          System.out.println(""String_Node_Str"");
        }
 else {
          IWorkbenchWindow window=SootPlugin.getDefault().getWorkbench().getActiveWorkbenchWindow().getActivePage().getWorkbenchWindow();
          if (window == null) {
            System.out.println(""String_Node_Str"");
          }
          PopupListSelector popup=new PopupListSelector(window.getShell());
          popup.setItems(list);
          if (getEditor() instanceof JimpleEditor) {
            int topIndex=((JimpleEditor)getEditor()).getViewer().getTopIndex();
            Rectangle rect=new Rectangle(400,(getLineNumber() + 1 - topIndex),650,45);
            popup.open(rect);
          }
 else {
            System.out.println(getEditor().getClass());
            System.out.println(""String_Node_Str"" + getModel().getMarkerPosition(markers[i]).getOffset());
            int pos=getModel().getMarkerPosition(markers[i]).getOffset();
            pos=pos / getLineNumber();
            Rectangle rect=new Rectangle(380,16,650,45);
            popup.open(rect);
          }
          handleSelection(popup.getSelected(),links);
        }
      }
    }
  }
 catch (  CoreException e) {
  }
catch (  BadLocationException e1) {
  }
}","public void run(){
  IAnnotationModel model=getEditor().getDocumentProvider().getAnnotationModel(getEditor().getEditorInput());
  if (model instanceof AbstractMarkerAnnotationModel) {
    setModel((AbstractMarkerAnnotationModel)model);
  }
  int markerLine=getRulerInfo().getLineOfLastMouseButtonActivity();
  IResource rec=getResource(getEditor());
  try {
    IMarker[] markers=rec.findMarkers(""String_Node_Str"",true,IResource.DEPTH_INFINITE);
    for (int i=0; i < markers.length; i++) {
      System.out.println(""String_Node_Str"" + getDocument());
      System.out.println(""String_Node_Str"" + getModel());
      System.out.println(""String_Node_Str"" + getModel().getMarkerPosition(markers[i]));
      if (getModel().getMarkerPosition(markers[i]) == null)       continue;
      setLineNumber(getDocument().getLineOfOffset(getModel().getMarkerPosition(markers[i]).getOffset()));
      if (getLineNumber() == markerLine) {
        System.out.println(""String_Node_Str"");
        ArrayList links=getMarkerLinks();
        Iterator lit=links.iterator();
        while (lit.hasNext()) {
          System.out.println(""String_Node_Str"" + lit.next());
        }
        String[] list=getMarkerLabels(links);
        if ((list == null) || (list.length == 0)) {
          System.out.println(""String_Node_Str"");
        }
 else {
          IWorkbenchWindow window=SootPlugin.getDefault().getWorkbench().getActiveWorkbenchWindow().getActivePage().getWorkbenchWindow();
          if (window == null) {
            System.out.println(""String_Node_Str"");
          }
          PopupListSelector popup=new PopupListSelector(window.getShell());
          popup.setItems(list);
          if (getEditor() instanceof JimpleEditor) {
            int topIndex=((JimpleEditor)getEditor()).getViewer().getTopIndex();
            Rectangle rect=new Rectangle(400,(getLineNumber() + 1 - topIndex),650,45);
            popup.open(rect);
          }
 else {
            System.out.println(getEditor().getClass());
            System.out.println(""String_Node_Str"" + getModel().getMarkerPosition(markers[i]).getOffset());
            int pos=getModel().getMarkerPosition(markers[i]).getOffset();
            pos=pos / getLineNumber();
            Rectangle rect=new Rectangle(380,16,650,45);
            popup.open(rect);
          }
          handleSelection(popup.getSelected(),links);
        }
      }
    }
  }
 catch (  CoreException e) {
  }
catch (  BadLocationException e1) {
  }
}"
88752,"public void findClass(String className){
  String resource=removeExt(getResource(getEditor()).getName());
  String ext=getResource(getEditor()).getFileExtension();
  if (!resource.equals(className)) {
    IContainer parent=getResource(getEditor()).getParent();
    IResource file=parent.findMember(className + ""String_Node_Str"" + ext);
    if (file == null) {
      setLinkToEditor(getEditor());
    }
 else {
      try {
        setLinkToEditor((AbstractTextEditor)SootPlugin.getDefault().getWorkbench().getActiveWorkbenchWindow().getActivePage().openEditor((IFile)file));
      }
 catch (      PartInitException e) {
      }
    }
  }
 else {
    setLinkToEditor(getEditor());
  }
}","public void findClass(String className){
  setLinkToEditor(getEditor());
  String resource=removeExt(getResource(getEditor()).getName());
  String ext=getResource(getEditor()).getFileExtension();
  IProject proj=getResource(getEditor()).getProject();
  System.out.println(""String_Node_Str"" + proj);
  String slashedClassName=className.replaceAll(""String_Node_Str"",System.getProperty(""String_Node_Str""));
  String classNameToFind=slashedClassName + ""String_Node_Str"" + ext;
  IJavaProject jProj=JavaCore.create(proj);
  try {
    IPackageFragmentRoot[] roots=jProj.getAllPackageFragmentRoots();
    for (int i=0; i < roots.length; i++) {
      System.out.println(roots[i].getResource());
      if (!(roots[i].getResource() instanceof IContainer))       continue;
      IResource fileToFind=((IContainer)roots[i].getResource()).findMember(classNameToFind);
      if (fileToFind == null)       continue;
      if (!fileToFind.equals(resource)) {
        try {
          setLinkToEditor((AbstractTextEditor)SootPlugin.getDefault().getWorkbench().getActiveWorkbenchWindow().getActivePage().openEditor((IFile)fileToFind));
        }
 catch (        PartInitException e) {
        }
      }
    }
  }
 catch (  JavaModelException e) {
    setLinkToEditor(getEditor());
  }
}"
88753,"private void setAttributeTextColor(int sline,int eline,int start,int end,RGB colorKey,boolean fg){
  System.out.println(""String_Node_Str"");
  Display display=getEditorPart().getSite().getShell().getDisplay();
  TextPresentation tp=new TextPresentation();
  if (getTextPresList() == null) {
    setTextPresList(new ArrayList());
  }
  getTextPresList().add(tp);
  ColorManager colorManager=new ColorManager();
  int sLineOffset=0;
  int eLineOffset=0;
  try {
    sLineOffset=getViewer().getDocument().getLineOffset((sline - 1));
    eLineOffset=getViewer().getDocument().getLineOffset((eline - 1));
    System.out.println(""String_Node_Str"" + sLineOffset);
  }
 catch (  Exception e) {
  }
  final boolean foreground=fg;
  final int s=sLineOffset + start - 1;
  System.out.println(""String_Node_Str"" + s);
  int e=eLineOffset + end - 1;
  System.out.println(""String_Node_Str"" + e);
  final int l=e - s;
  System.out.println(""String_Node_Str"" + l);
  final Color ck=colorManager.getColor(colorKey);
  final Color oldBgC=colorManager.getColor(IJimpleColorConstants.JIMPLE_DEFAULT);
  display.asyncExec(new Runnable(){
    public void run(){
      TextPresentation tp=new TextPresentation();
      StyleRange sr;
      if (foreground) {
        sr=new StyleRange(s,l,ck,getViewer().getTextWidget().getBackground());
      }
 else {
        sr=new StyleRange(s,l,oldBgC,ck);
      }
      tp.addStyleRange(sr);
      getViewer().changeTextPresentation(tp,true);
    }
  }
);
}","private void setAttributeTextColor(TextPresentation tp,int sline,int eline,int start,int end,RGB colorKey,boolean fg){
  System.out.println(""String_Node_Str"" + sline + ""String_Node_Str""+ start+ ""String_Node_Str""+ end);
  Display display=getEditorPart().getSite().getShell().getDisplay();
  ColorManager colorManager=new ColorManager();
  int sLineOffset=0;
  int eLineOffset=0;
  try {
    sLineOffset=getViewer().getDocument().getLineOffset((sline - 1));
    eLineOffset=getViewer().getDocument().getLineOffset((eline - 1));
  }
 catch (  Exception e) {
  }
  final boolean foreground=fg;
  final int s=sLineOffset + start - 1;
  int e=eLineOffset + end - 1;
  final int l=e - s;
  final Color ck=colorManager.getColor(colorKey);
  final Color oldBgC=colorManager.getColor(IJimpleColorConstants.JIMPLE_DEFAULT);
  display.asyncExec(new Runnable(){
    public void run(){
      TextPresentation tp=new TextPresentation();
      StyleRange sr;
      if (l != 0) {
        if (foreground) {
          sr=new StyleRange(s,l,ck,getBgColor());
        }
 else {
          sr=new StyleRange(s,l,oldBgC,ck);
        }
        tp.addStyleRange(sr);
      }
      getViewer().changeTextPresentation(tp,true);
    }
  }
);
}"
88754,"public void run(){
  TextPresentation tp=new TextPresentation();
  StyleRange sr;
  if (foreground) {
    sr=new StyleRange(s,l,ck,getViewer().getTextWidget().getBackground());
  }
 else {
    sr=new StyleRange(s,l,oldBgC,ck);
  }
  tp.addStyleRange(sr);
  getViewer().changeTextPresentation(tp,true);
}","public void run(){
  getViewer().changeTextPresentation(pres,true);
}"
88755,"public void computeColors(SootAttributesHandler handler,ITextViewer viewer,IEditorPart editorPart){
  setViewer(viewer);
  setEditorPart(editorPart);
  Iterator it=handler.getAttrList().iterator();
  while (it.hasNext()) {
    SootAttribute sa=(SootAttribute)it.next();
    if ((sa.getRed() == 0) && (sa.getGreen() == 0) && (sa.getBlue() == 0)) {
    }
 else {
      boolean fg=false;
      if (sa.getFg() == 1) {
        fg=true;
      }
      setAttributeTextColor(sa.getJavaStartLn(),sa.getJavaEndLn(),sa.getJavaOffsetStart() + 1,sa.getJavaOffsetEnd() + 1,sa.getRGBColor(),fg);
    }
    if (sa.getValueAttrs() != null) {
      Iterator valIt=sa.getValueAttrs().iterator();
      while (valIt.hasNext()) {
        PosColAttribute vba=(PosColAttribute)valIt.next();
        if ((vba.getRed() == 0) && (vba.getGreen() == 0) && (vba.getBlue() == 0)) {
        }
 else {
          boolean fg=false;
          if (vba.getFg() == 1) {
            fg=true;
          }
          setAttributeTextColor(sa.getJavaStartLn(),sa.getJavaEndLn(),vba.getSourceStartOffset() + 1,vba.getSourceEndOffset() + 1,vba.getRGBColor(),fg);
        }
      }
    }
  }
}","public void computeColors(SootAttributesHandler handler,ITextViewer viewer,IEditorPart editorPart){
  setViewer(viewer);
  setEditorPart(editorPart);
  if ((handler == null) || (handler.getAttrList() == null))   return;
  Iterator it=handler.getAttrList().iterator();
  TextPresentation tp=new TextPresentation();
  Display display=getEditorPart().getSite().getShell().getDisplay();
  display.asyncExec(new Runnable(){
    public void run(){
      Color bgColor=getViewer().getTextWidget().getBackground();
      setBgColor(bgColor);
    }
  }
);
  while (it.hasNext()) {
    SootAttribute sa=(SootAttribute)it.next();
    if ((sa.getRed() == 0) && (sa.getGreen() == 0) && (sa.getBlue() == 0)) {
    }
 else {
      boolean fg=false;
      if (sa.getFg() == 1) {
        fg=true;
      }
      setAttributeTextColor(tp,sa.getJavaStartLn(),sa.getJavaEndLn(),sa.getJavaOffsetStart() + 1,sa.getJavaOffsetEnd() + 1,sa.getRGBColor(),fg);
    }
    if (sa.getValueAttrs() != null) {
      Iterator valIt=sa.getValueAttrs().iterator();
      while (valIt.hasNext()) {
        PosColAttribute vba=(PosColAttribute)valIt.next();
        if ((vba.getRed() == 0) && (vba.getGreen() == 0) && (vba.getBlue() == 0)) {
        }
 else {
          boolean fg=false;
          if (vba.getFg() == 1) {
            fg=true;
          }
          setAttributeTextColor(tp,sa.getJavaStartLn(),sa.getJavaEndLn(),vba.getSourceStartOffset() + 1,vba.getSourceEndOffset() + 1,vba.getRGBColor(),fg);
        }
      }
    }
  }
}"
88756,"public ArrayList getMarkerLinks(){
  SootAttributesHandler handler=SootPlugin.getDefault().getManager().getAttributesHandlerForFile((IFile)getResource(getEditor()));
  if (handler == null)   System.out.println(""String_Node_Str"");
  ArrayList links=handler.getJavaLinks(getLineNumber() + 1);
  return links;
}","public ArrayList getMarkerLinks(){
  SootAttributesHandler handler=SootPlugin.getDefault().getManager().getAttributesHandlerForFile((IFile)getResource(getEditor()));
  if (handler == null)   System.out.println(""String_Node_Str"");
  ArrayList links=handler.getJavaLinks(getLineNumber() + 1);
  Iterator it=links.iterator();
  while (it.hasNext()) {
    System.out.println(""String_Node_Str"" + (getLineNumber() + 1) + ""String_Node_Str""+ it.next());
  }
  return links;
}"
88757,"public void findClass(String className){
  setLinkToEditor(getEditor());
  String resource=removeExt(getResource(getEditor()).getName());
  String ext=getResource(getEditor()).getFileExtension();
  IProject proj=getResource(getEditor()).getProject();
  System.out.println(""String_Node_Str"" + proj);
  String slashedClassName=className.replaceAll(""String_Node_Str"",System.getProperty(""String_Node_Str""));
  String classNameToFind=slashedClassName + ""String_Node_Str"" + ext;
  IJavaProject jProj=JavaCore.create(proj);
  try {
    IPackageFragmentRoot[] roots=jProj.getAllPackageFragmentRoots();
    for (int i=0; i < roots.length; i++) {
      System.out.println(roots[i].getResource());
      if (!(roots[i].getResource() instanceof IContainer))       continue;
      IResource fileToFind=((IContainer)roots[i].getResource()).findMember(classNameToFind);
      if (fileToFind == null)       continue;
      if (!fileToFind.equals(resource)) {
        try {
          setLinkToEditor((AbstractTextEditor)SootPlugin.getDefault().getWorkbench().getActiveWorkbenchWindow().getActivePage().openEditor((IFile)fileToFind));
        }
 catch (        PartInitException e) {
        }
      }
    }
  }
 catch (  JavaModelException e) {
    setLinkToEditor(getEditor());
  }
}",public abstract void findClass(String className);
88758,"public ArrayList getJavaLinks(int lnNum){
  Iterator it=getAttrList().iterator();
  ArrayList list=new ArrayList();
  while (it.hasNext()) {
    SootAttribute sa=(SootAttribute)it.next();
    System.out.println(""String_Node_Str"" + lnNum);
    if (sa.attrForJavaLn(lnNum)) {
      if (sa.getAllLinkAttrs() != null) {
        list=sa.getAllLinkAttrs();
      }
    }
  }
  return list;
}","public ArrayList getJavaLinks(int lnNum){
  Iterator it=getAttrList().iterator();
  ArrayList list=new ArrayList();
  while (it.hasNext()) {
    SootAttribute sa=(SootAttribute)it.next();
    System.out.println(""String_Node_Str"" + lnNum);
    if (sa.attrForJavaLn(lnNum)) {
      if (sa.getAllLinkAttrs() != null) {
        list.addAll(sa.getAllLinkAttrs());
      }
      System.out.println(""String_Node_Str"" + list.size());
    }
  }
  return list;
}"
88759,"protected void internalTransform(String phaseName,Map options){
  SparkOptions opts=new SparkOptions(options);
  final String output_dir=Options.v().output_dir();
  ContextInsensitiveBuilder b=new ContextInsensitiveBuilder();
  if (opts.pre_jimplify())   b.preJimplify();
  if (opts.force_gc())   doGC();
  Date startBuild=new Date();
  final PAG pag=(PAG)b.setup(opts);
  b.build();
  Date endBuild=new Date();
  reportTime(""String_Node_Str"",startBuild,endBuild);
  if (opts.force_gc())   doGC();
  Date startTM=new Date();
  pag.getTypeManager().makeTypeMask();
  Date endTM=new Date();
  reportTime(""String_Node_Str"",startTM,endTM);
  if (opts.force_gc())   doGC();
  if (opts.verbose()) {
    G.v().out.println(""String_Node_Str"" + pag.getVarNodeNumberer().size());
    G.v().out.println(""String_Node_Str"" + pag.getFieldRefNodeNumberer().size());
    G.v().out.println(""String_Node_Str"" + pag.getAllocNodeNumberer().size());
  }
  Date startSimplify=new Date();
  if ((opts.simplify_sccs() && !opts.on_fly_cg()) || opts.vta()) {
    new SCCCollapser(pag,opts.ignore_types_for_sccs()).collapse();
  }
  if (opts.simplify_offline() && !opts.on_fly_cg()) {
    new EBBCollapser(pag).collapse();
  }
  if (true || opts.simplify_sccs() || opts.vta()|| opts.simplify_offline()) {
    pag.cleanUpMerges();
  }
  Date endSimplify=new Date();
  reportTime(""String_Node_Str"",startSimplify,endSimplify);
  if (opts.force_gc())   doGC();
  PAGDumper dumper=null;
  if (opts.dump_pag() || opts.dump_solution()) {
    dumper=new PAGDumper(pag,output_dir);
  }
  if (opts.dump_pag())   dumper.dump();
  Date startProp=new Date();
  final Propagator[] propagator=new Propagator[1];
switch (opts.propagator()) {
case SparkOptions.propagator_iter:
    propagator[0]=new PropIter(pag);
  break;
case SparkOptions.propagator_worklist:
propagator[0]=new PropWorklist(pag);
break;
case SparkOptions.propagator_cycle:
propagator[0]=new PropCycle(pag);
break;
case SparkOptions.propagator_merge:
propagator[0]=new PropMerge(pag);
break;
case SparkOptions.propagator_alias:
propagator[0]=new PropAlias(pag);
break;
case SparkOptions.propagator_none:
break;
default :
throw new RuntimeException();
}
if (propagator[0] != null) propagator[0].propagate();
Date endProp=new Date();
reportTime(""String_Node_Str"",startProp,endProp);
reportTime(""String_Node_Str"",startSimplify,endProp);
if (opts.force_gc()) doGC();
if (!opts.on_fly_cg() || opts.vta()) {
CallGraphBuilder cgb=new CallGraphBuilder(pag);
cgb.build();
}
if (opts.verbose()) {
G.v().out.println(""String_Node_Str"" + Scene.v().getReachableMethods().size());
}
if (opts.set_mass()) findSetMass(pag);
if (opts.dump_answer()) new ReachingTypeDumper(pag,output_dir).dump();
if (opts.dump_solution()) dumper.dumpPointsToSets();
if (opts.dump_html()) new PAG2HTML(pag,output_dir).dump();
Scene.v().setPointsToAnalysis(pag);
if (opts.add_tags()) {
addTags(pag);
}
}","protected void internalTransform(String phaseName,Map options){
  SparkOptions opts=new SparkOptions(options);
  final String output_dir=SourceLocator.v().getOutputDir();
  ContextInsensitiveBuilder b=new ContextInsensitiveBuilder();
  if (opts.pre_jimplify())   b.preJimplify();
  if (opts.force_gc())   doGC();
  Date startBuild=new Date();
  final PAG pag=(PAG)b.setup(opts);
  b.build();
  Date endBuild=new Date();
  reportTime(""String_Node_Str"",startBuild,endBuild);
  if (opts.force_gc())   doGC();
  Date startTM=new Date();
  pag.getTypeManager().makeTypeMask();
  Date endTM=new Date();
  reportTime(""String_Node_Str"",startTM,endTM);
  if (opts.force_gc())   doGC();
  if (opts.verbose()) {
    G.v().out.println(""String_Node_Str"" + pag.getVarNodeNumberer().size());
    G.v().out.println(""String_Node_Str"" + pag.getFieldRefNodeNumberer().size());
    G.v().out.println(""String_Node_Str"" + pag.getAllocNodeNumberer().size());
  }
  Date startSimplify=new Date();
  if ((opts.simplify_sccs() && !opts.on_fly_cg()) || opts.vta()) {
    new SCCCollapser(pag,opts.ignore_types_for_sccs()).collapse();
  }
  if (opts.simplify_offline() && !opts.on_fly_cg()) {
    new EBBCollapser(pag).collapse();
  }
  if (true || opts.simplify_sccs() || opts.vta()|| opts.simplify_offline()) {
    pag.cleanUpMerges();
  }
  Date endSimplify=new Date();
  reportTime(""String_Node_Str"",startSimplify,endSimplify);
  if (opts.force_gc())   doGC();
  PAGDumper dumper=null;
  if (opts.dump_pag() || opts.dump_solution()) {
    dumper=new PAGDumper(pag,output_dir);
  }
  if (opts.dump_pag())   dumper.dump();
  Date startProp=new Date();
  final Propagator[] propagator=new Propagator[1];
switch (opts.propagator()) {
case SparkOptions.propagator_iter:
    propagator[0]=new PropIter(pag);
  break;
case SparkOptions.propagator_worklist:
propagator[0]=new PropWorklist(pag);
break;
case SparkOptions.propagator_cycle:
propagator[0]=new PropCycle(pag);
break;
case SparkOptions.propagator_merge:
propagator[0]=new PropMerge(pag);
break;
case SparkOptions.propagator_alias:
propagator[0]=new PropAlias(pag);
break;
case SparkOptions.propagator_none:
break;
default :
throw new RuntimeException();
}
if (propagator[0] != null) propagator[0].propagate();
Date endProp=new Date();
reportTime(""String_Node_Str"",startProp,endProp);
reportTime(""String_Node_Str"",startSimplify,endProp);
if (opts.force_gc()) doGC();
if (!opts.on_fly_cg() || opts.vta()) {
CallGraphBuilder cgb=new CallGraphBuilder(pag);
cgb.build();
}
if (opts.verbose()) {
G.v().out.println(""String_Node_Str"" + Scene.v().getReachableMethods().size());
}
if (opts.set_mass()) findSetMass(pag);
if (opts.dump_answer()) new ReachingTypeDumper(pag,output_dir).dump();
if (opts.dump_solution()) dumper.dumpPointsToSets();
if (opts.dump_html()) new PAG2HTML(pag,output_dir).dump();
Scene.v().setPointsToAnalysis(pag);
if (opts.add_tags()) {
addTags(pag);
}
}"
88760,"/** 
 * @see org.eclipse.jface.text.ITextHover#getHoverRegion(ITextViewer,int)
 */
public org.eclipse.jface.text.IRegion getHoverRegion(ITextViewer textViewer,int offset){
  try {
    setLineNum(textViewer.getDocument().getLineOfOffset(offset) + 1);
    setViewer(textViewer);
    setDocument(textViewer.getDocument());
    return textViewer.getDocument().getLineInformationOfOffset(offset);
  }
 catch (  BadLocationException e) {
    return null;
  }
}","/** 
 * @see org.eclipse.jface.text.ITextHover#getHoverRegion(ITextViewer,int)
 */
public org.eclipse.jface.text.IRegion getHoverRegion(ITextViewer textViewer,int offset){
  try {
    setLineNum(textViewer.getDocument().getLineOfOffset(offset) + 1);
    System.out.println(""String_Node_Str"");
    setViewer(textViewer);
    setDocument(textViewer.getDocument());
    return textViewer.getDocument().getLineInformationOfOffset(offset);
  }
 catch (  BadLocationException e) {
    return null;
  }
}"
88761,"/** 
 * Method setEditor.
 * @param ed
 */
public void setEditor(IEditorPart ed){
  editor=ed;
}","/** 
 * Method setEditor.
 * @param ed
 */
public void setEditor(IEditorPart ed){
  System.out.println(""String_Node_Str"");
  editor=ed;
}"
88762,"public String toString(){
  return (getOpBox().getValue()).toString() + ""String_Node_Str"";
}","public String toString(){
  StringBuffer b=new StringBuffer();
  if (PrecedenceTest.needsBrackets(getOpBox(),this))   b.append(""String_Node_Str"");
  b.append(getOpBox().getValue().toString());
  if (PrecedenceTest.needsBrackets(getOpBox(),this))   b.append(""String_Node_Str"");
  b.append(""String_Node_Str"");
  return b.toString();
}"
88763,"public static boolean needsBracketsRight(ValueBox subExprBox,Value expr){
  Value sub=subExprBox.getValue();
  if (!(sub instanceof Precedence))   return false;
  Precedence subP=(Precedence)sub;
  Precedence exprP=(Precedence)expr;
  if (subP.getPrecedence() < exprP.getPrecedence())   return true;
  if (subP.getPrecedence() == exprP.getPrecedence()) {
    if (exprP instanceof SubExpr)     return true;
    if (exprP instanceof DivExpr)     return true;
    if (exprP instanceof CmpExpr)     return true;
    if (exprP instanceof CmpgExpr)     return true;
    if (exprP instanceof CmplExpr)     return true;
  }
  return false;
}","public static boolean needsBracketsRight(ValueBox subExprBox,Value expr){
  Value sub=subExprBox.getValue();
  if (!(sub instanceof Precedence))   return false;
  Precedence subP=(Precedence)sub;
  Precedence exprP=(Precedence)expr;
  if (subP.getPrecedence() < exprP.getPrecedence())   return true;
  if (subP.getPrecedence() == exprP.getPrecedence()) {
    if (subP instanceof SubExpr)     return true;
    if (subP instanceof DivExpr)     return true;
    if (subP instanceof CmpExpr)     return true;
    if (subP instanceof CmpgExpr)     return true;
    if (subP instanceof CmplExpr)     return true;
  }
  return false;
}"
88764,"private void javafy_ref(ValueBox vb){
  Ref r=(Ref)vb.getValue();
  if (r instanceof StaticFieldRef)   vb.setValue(new DStaticFieldRef(((StaticFieldRef)r).getField(),getMethod().getDeclaringClass().getName()));
 else   if (r instanceof ArrayRef) {
    ArrayRef ar=(ArrayRef)r;
    javafy(ar.getBaseBox());
    javafy(ar.getIndexBox());
  }
 else   if (r instanceof InstanceFieldRef) {
    InstanceFieldRef ifr=(InstanceFieldRef)r;
    javafy(ifr.getBaseBox());
    vb.setValue(new DInstanceFieldRef(ifr.getBase(),ifr.getField(),thisLocals));
  }
 else   if (r instanceof ThisRef) {
    ThisRef tr=(ThisRef)r;
    vb.setValue(new DThisRef((RefType)tr.getType()));
  }
}","private void javafy_ref(ValueBox vb){
  Ref r=(Ref)vb.getValue();
  if (r instanceof StaticFieldRef) {
    SootField field=((StaticFieldRef)r).getField();
    addPackage(field.getDeclaringClass().getJavaPackageName());
    vb.setValue(new DStaticFieldRef(field,getMethod().getDeclaringClass().getName()));
  }
 else   if (r instanceof ArrayRef) {
    ArrayRef ar=(ArrayRef)r;
    javafy(ar.getBaseBox());
    javafy(ar.getIndexBox());
  }
 else   if (r instanceof InstanceFieldRef) {
    InstanceFieldRef ifr=(InstanceFieldRef)r;
    javafy(ifr.getBaseBox());
    vb.setValue(new DInstanceFieldRef(ifr.getBase(),ifr.getField(),thisLocals));
  }
 else   if (r instanceof ThisRef) {
    ThisRef tr=(ThisRef)r;
    vb.setValue(new DThisRef((RefType)tr.getType()));
  }
}"
88765,"private void javafy_invoke_expr(ValueBox vb){
  InvokeExpr ie=(InvokeExpr)vb.getValue();
  addPackage(ie.getMethod().getDeclaringClass().getJavaPackageName());
  for (int i=0; i < ie.getArgCount(); i++) {
    Value arg=ie.getArg(i);
    if (arg instanceof IntConstant)     ie.getArgBox(i).setValue(DIntConstant.v(((IntConstant)arg).value,ie.getMethod().getParameterType(i)));
 else     javafy(ie.getArgBox(i));
  }
  if (ie instanceof InstanceInvokeExpr) {
    javafy(((InstanceInvokeExpr)ie).getBaseBox());
    if (ie instanceof VirtualInvokeExpr) {
      VirtualInvokeExpr vie=(VirtualInvokeExpr)ie;
      vb.setValue(new DVirtualInvokeExpr(vie.getBase(),vie.getMethod(),vie.getArgs(),thisLocals));
    }
 else     if (ie instanceof SpecialInvokeExpr) {
      SpecialInvokeExpr sie=(SpecialInvokeExpr)ie;
      vb.setValue(new DSpecialInvokeExpr(sie.getBase(),sie.getMethod(),sie.getArgs()));
    }
 else     if (ie instanceof InterfaceInvokeExpr) {
      InterfaceInvokeExpr iie=(InterfaceInvokeExpr)ie;
      vb.setValue(new DInterfaceInvokeExpr(iie.getBase(),iie.getMethod(),iie.getArgs()));
    }
 else     throw new RuntimeException(""String_Node_Str"" + ie + ""String_Node_Str"");
  }
 else   if (ie instanceof StaticInvokeExpr) {
    StaticInvokeExpr sie=(StaticInvokeExpr)ie;
    if (sie instanceof NewInvokeExpr) {
      NewInvokeExpr nie=(NewInvokeExpr)sie;
      RefType rt=nie.getBaseType();
      addPackage(rt.getSootClass().getJavaPackageName());
      vb.setValue(new DNewInvokeExpr((RefType)nie.getType(),nie.getMethod(),nie.getArgs()));
    }
 else     vb.setValue(new DStaticInvokeExpr(sie.getMethod(),sie.getArgs()));
  }
 else   throw new RuntimeException(""String_Node_Str"" + ie + ""String_Node_Str"");
}","private void javafy_invoke_expr(ValueBox vb){
  InvokeExpr ie=(InvokeExpr)vb.getValue();
  addPackage(ie.getMethod().getDeclaringClass().getJavaPackageName());
  for (int i=0; i < ie.getArgCount(); i++) {
    Value arg=ie.getArg(i);
    if (arg instanceof IntConstant)     ie.getArgBox(i).setValue(DIntConstant.v(((IntConstant)arg).value,ie.getMethod().getParameterType(i)));
 else     javafy(ie.getArgBox(i));
  }
  if (ie instanceof InstanceInvokeExpr) {
    javafy(((InstanceInvokeExpr)ie).getBaseBox());
    if (ie instanceof VirtualInvokeExpr) {
      VirtualInvokeExpr vie=(VirtualInvokeExpr)ie;
      vb.setValue(new DVirtualInvokeExpr(vie.getBase(),vie.getMethod(),vie.getArgs(),thisLocals));
    }
 else     if (ie instanceof SpecialInvokeExpr) {
      SpecialInvokeExpr sie=(SpecialInvokeExpr)ie;
      vb.setValue(new DSpecialInvokeExpr(sie.getBase(),sie.getMethod(),sie.getArgs()));
    }
 else     if (ie instanceof InterfaceInvokeExpr) {
      InterfaceInvokeExpr iie=(InterfaceInvokeExpr)ie;
      vb.setValue(new DInterfaceInvokeExpr(iie.getBase(),iie.getMethod(),iie.getArgs()));
    }
 else     throw new RuntimeException(""String_Node_Str"" + ie + ""String_Node_Str"");
  }
 else   if (ie instanceof StaticInvokeExpr) {
    StaticInvokeExpr sie=(StaticInvokeExpr)ie;
    if (sie instanceof NewInvokeExpr) {
      NewInvokeExpr nie=(NewInvokeExpr)sie;
      RefType rt=nie.getBaseType();
      addPackage(rt.getSootClass().getJavaPackageName());
      vb.setValue(new DNewInvokeExpr((RefType)nie.getType(),nie.getMethod(),nie.getArgs()));
    }
 else {
      SootMethod method=sie.getMethod();
      addPackage(method.getDeclaringClass().getJavaPackageName());
      vb.setValue(new DStaticInvokeExpr(method,sie.getArgs()));
    }
  }
 else   throw new RuntimeException(""String_Node_Str"" + ie + ""String_Node_Str"");
}"
88766,"/** 
 * Draws a node.
 * @param name, the node to draw.
 * @return the {@link DotGraphNode} corresponding to the specified name.
 */
public DotGraphNode drawNode(String name){
  DotGraphNode node=(DotGraphNode)nodes.get(name);
  if (node == null) {
    node=new DotGraphNode(name);
    nodes.put(name,node);
    this.drawElements.add(node);
  }
  return node;
}","/** 
 * Draws a node.
 * @param name, the node to draw.
 * @return the {@link DotGraphNode} corresponding to the specified name.
 */
public DotGraphNode drawNode(String name){
  DotGraphNode node=getNode(name);
  if (node == null)   throw new RuntimeException(""String_Node_Str"");
  if (!this.drawElements.contains(node))   this.drawElements.add(node);
  return node;
}"
88767,"/** 
 * Gets the graph node by name.
 * @param name, unique name of the node.
 * @return the node with the specified name, or <code>null</code>if there is no such node.
 */
public DotGraphNode getNode(String name){
  return (DotGraphNode)nodes.get(name);
}","/** 
 * Gets the graph node by name.
 * @param name, unique name of the node.
 * @return the node with the specified name, or <code>null</code>if there is no such node.
 */
public DotGraphNode getNode(String name){
  DotGraphNode node=(DotGraphNode)nodes.get(name);
  if (node == null) {
    node=new DotGraphNode(name);
    nodes.put(name,node);
  }
  return node;
}"
88768,"final public void caseNewMultiArrayExpr(NewMultiArrayExpr nmae){
  ArrayType type=(ArrayType)nmae.getType();
  AllocNode prevAn=pag.makeAllocNode(new Pair(nmae,new Integer(type.numDimensions)),type,currentMethod);
  VarNode prevVn=pag.makeVarNode(prevAn,prevAn.getType(),currentMethod);
  setResult(prevAn);
  while (true) {
    Type t=type.getElementType();
    if (!(t instanceof ArrayType))     break;
    type=(ArrayType)t;
    AllocNode an=pag.makeAllocNode(new Pair(nmae,new Integer(type.numDimensions)),type,currentMethod);
    VarNode vn=pag.makeVarNode(an,an.getType(),currentMethod);
    addEdge(an,vn);
    addEdge(vn,pag.makeFieldRefNode(prevVn,ArrayElement.v()));
    prevAn=an;
    prevVn=vn;
  }
}","final public void caseNewMultiArrayExpr(NewMultiArrayExpr nmae){
  ArrayType type=(ArrayType)nmae.getType();
  AllocNode prevAn=pag.makeAllocNode(new Pair(nmae,new Integer(type.numDimensions)),type,currentMethod);
  VarNode prevVn=pag.makeVarNode(prevAn,prevAn.getType(),currentMethod);
  addEdge(prevAn,prevVn);
  setResult(prevAn);
  while (true) {
    Type t=type.getElementType();
    if (!(t instanceof ArrayType))     break;
    type=(ArrayType)t;
    AllocNode an=pag.makeAllocNode(new Pair(nmae,new Integer(type.numDimensions)),type,currentMethod);
    VarNode vn=pag.makeVarNode(an,an.getType(),currentMethod);
    addEdge(an,vn);
    addEdge(vn,pag.makeFieldRefNode(prevVn,ArrayElement.v()));
    prevAn=an;
    prevVn=vn;
  }
}"
88769,"public boolean passesParameters(){
  return isExplicit() || kind == THREAD || kind == EXIT || kind == FINALIZE || kind == PRIVILEGED;
}","public boolean passesParameters(){
  return isExplicit() || kind == THREAD || kind == EXIT || kind == FINALIZE || kind == PRIVILEGED || kind == NEWINSTANCE;
}"
88770,"private void initPaths(){
  sootClasspath.initialize();
  platform_location=Platform.getLocation().toOSString();
  external_jars_location=Platform.getLocation().removeLastSegments(2).toOSString();
  setOutputLocation(platform_location + getFileHandler().getSootOutputFolder().getFullPath().toOSString());
}","private void initPaths(){
  sootClasspath.initialize();
  platform_location=getSootSelection().getJavaProject().getProject().getLocation().toOSString();
  System.out.println(""String_Node_Str"" + platform_location);
  platform_location=platform_location.substring(0,platform_location.lastIndexOf(System.getProperty(""String_Node_Str"")));
  System.out.println(""String_Node_Str"" + platform_location);
  external_jars_location=Platform.getLocation().removeLastSegments(2).toOSString();
  setOutputLocation(platform_location + getFileHandler().getSootOutputFolder().getFullPath().toOSString());
}"
88771,"/** 
 * Computes this = this OR ((orset AND andset ) AND (NOT andnotset)) Returns true iff this is modified.
 * @param set a bit set.
 */
public boolean orAndAndNot(BitVector orset,BitVector andset,BitVector andnotset){
  boolean ret=false;
  long[] a=null, b=null, c=null, d=null, e=null;
  int al, bl, cl, dl, el;
  a=this.bits;
  al=a.length;
  if (orset == null) {
    bl=0;
  }
 else {
    b=orset.bits;
    bl=b.length;
  }
  if (andset == null) {
    cl=0;
  }
 else {
    c=andset.bits;
    cl=c.length;
  }
  if (andnotset == null) {
    dl=0;
  }
 else {
    d=andnotset.bits;
    dl=d.length;
  }
  if (al < bl) {
    e=new long[bl];
    System.arraycopy(a,0,e,0,al);
    this.bits=e;
  }
 else {
    e=a;
  }
  el=e.length;
  int i=0;
  long l;
  if (bl <= cl && bl <= dl) {
    while (i < bl) {
      l=b[i] & c[i] & ~d[i];
      if ((l & ~e[i]) != 0)       ret=true;
      e[i]|=l;
      i++;
    }
  }
 else   if (cl <= dl && dl <= bl) {
    while (i < cl) {
      l=b[i] & c[i] & ~d[i];
      if ((l & ~e[i]) != 0)       ret=true;
      e[i]|=l;
      i++;
    }
    while (i < dl) {
      l=b[i] & ~d[i];
      if ((l & ~e[i]) != 0)       ret=true;
      e[i]|=l;
      i++;
    }
    while (i < bl) {
      l=b[i];
      if ((l & ~e[i]) != 0)       ret=true;
      e[i]|=l;
      i++;
    }
  }
 else   if (dl <= cl && cl <= bl) {
    while (i < dl) {
      l=b[i] & c[i] & ~d[i];
      if ((l & ~e[i]) != 0)       ret=true;
      e[i]|=l;
      i++;
    }
    while (i < cl) {
      l=b[i] & c[i];
      if ((l & ~e[i]) != 0)       ret=true;
      e[i]|=l;
      i++;
    }
    while (i < bl) {
      l=b[i];
      if ((l & ~e[i]) != 0)       ret=true;
      e[i]|=l;
      i++;
    }
  }
 else   if (dl <= bl && bl <= cl) {
    while (i < dl) {
      l=b[i] & c[i] & ~d[i];
      if ((l & ~e[i]) != 0)       ret=true;
      e[i]|=l;
      i++;
    }
    while (i < bl) {
      l=b[i] & c[i];
      if ((l & ~e[i]) != 0)       ret=true;
      e[i]|=l;
      i++;
    }
  }
 else   if (cl <= bl && bl <= dl) {
    while (i < cl) {
      l=b[i] & c[i] & ~d[i];
      if ((l & ~e[i]) != 0)       ret=true;
      e[i]|=l;
      i++;
    }
    while (i < bl) {
      l=b[i] & ~d[i];
      if ((l & ~e[i]) != 0)       ret=true;
      e[i]|=l;
      i++;
    }
  }
 else   throw new RuntimeException(""String_Node_Str"" + bl + ""String_Node_Str""+ cl+ ""String_Node_Str""+ dl);
  return ret;
}","/** 
 * Computes this = this OR ((orset AND andset ) AND (NOT andnotset)) Returns true iff this is modified.
 * @param set a bit set.
 */
public boolean orAndAndNot(BitVector orset,BitVector andset,BitVector andnotset){
  boolean ret=false;
  long[] a=null, b=null, c=null, d=null, e=null;
  int al, bl, cl, dl, el;
  a=this.bits;
  al=a.length;
  if (orset == null) {
    bl=0;
  }
 else {
    b=orset.bits;
    bl=b.length;
  }
  if (andset == null) {
    cl=0;
  }
 else {
    c=andset.bits;
    cl=c.length;
  }
  if (andnotset == null) {
    dl=0;
  }
 else {
    d=andnotset.bits;
    dl=d.length;
  }
  if (al < bl) {
    e=new long[bl];
    System.arraycopy(a,0,e,0,al);
    this.bits=e;
  }
 else {
    e=a;
  }
  el=e.length;
  int i=0;
  long l;
  if (c == null) {
    if (dl <= bl) {
      while (i < dl) {
        l=b[i] & ~d[i];
        if ((l & ~e[i]) != 0)         ret=true;
        e[i]|=l;
        i++;
      }
      while (i < bl) {
        l=b[i];
        if ((l & ~e[i]) != 0)         ret=true;
        e[i]|=l;
        i++;
      }
    }
 else {
      while (i < bl) {
        l=b[i] & ~d[i];
        if ((l & ~e[i]) != 0)         ret=true;
        e[i]|=l;
        i++;
      }
    }
  }
 else   if (bl <= cl && bl <= dl) {
    while (i < bl) {
      l=b[i] & c[i] & ~d[i];
      if ((l & ~e[i]) != 0)       ret=true;
      e[i]|=l;
      i++;
    }
  }
 else   if (cl <= bl && cl <= dl) {
    while (i < cl) {
      l=b[i] & c[i] & ~d[i];
      if ((l & ~e[i]) != 0)       ret=true;
      e[i]|=l;
      i++;
    }
  }
 else {
    while (i < dl) {
      l=b[i] & c[i] & ~d[i];
      if ((l & ~e[i]) != 0)       ret=true;
      e[i]|=l;
      i++;
    }
    int shorter=cl;
    if (bl < shorter)     shorter=bl;
    while (i < shorter) {
      l=b[i] & c[i];
      if ((l & ~e[i]) != 0)       ret=true;
      e[i]|=l;
      i++;
    }
  }
  return ret;
}"
88772,"public int length(){
  int i;
  for (i=bits.length - 1; i >= 0; i++) {
    if (bits[i] != 0L)     break;
  }
  if (i < 0)   return 0;
  long j=bits[i];
  i++;
  i<<=6;
  for (long k=1L << 63; (k & j) == 0L; k>>=1, i--)   ;
  return i;
}","public int length(){
  int i;
  for (i=bits.length - 1; i >= 0; i--) {
    if (bits[i] != 0L)     break;
  }
  if (i < 0)   return 0;
  long j=bits[i];
  i++;
  i<<=6;
  for (long k=1L << 63; (k & j) == 0L; k>>=1, i--)   ;
  return i;
}"
88773,"public boolean equals(Object o){
  if (!(o instanceof BitVector))   return false;
  BitVector other=(BitVector)o;
  int min=bits.length;
  long[] longer=other.bits;
  if (other.bits.length < min) {
    min=other.bits.length;
    longer=bits;
  }
  int i;
  for (i=0; i < min; i++) {
    if (bits[i] != other.bits[i])     return false;
  }
  for (; i < longer.length; i++) {
    if (bits[i] != 0L)     return false;
  }
  return true;
}","public boolean equals(Object o){
  if (!(o instanceof BitVector))   return false;
  BitVector other=(BitVector)o;
  int min=bits.length;
  long[] longer=other.bits;
  if (other.bits.length < min) {
    min=other.bits.length;
    longer=bits;
  }
  int i;
  for (i=0; i < min; i++) {
    if (bits[i] != other.bits[i])     return false;
  }
  for (; i < longer.length; i++) {
    if (longer[i] != 0L)     return false;
  }
  return true;
}"
88774,"public String toString(){
  StringBuffer ret=new StringBuffer();
  ret.append('{');
  boolean start=false;
  BitSetIterator it=new BitSetIterator(bits);
  while (it.hasNext()) {
    int bit=it.next();
    if (!start)     ret.append(""String_Node_Str"");
    start=false;
    ret.append(bit);
  }
  ret.append('}');
  return ret.toString();
}","public String toString(){
  StringBuffer ret=new StringBuffer();
  ret.append('{');
  boolean start=true;
  BitSetIterator it=new BitSetIterator(bits);
  while (it.hasNext()) {
    int bit=it.next();
    if (!start)     ret.append(""String_Node_Str"");
    start=false;
    ret.append(bit);
  }
  ret.append('}');
  return ret.toString();
}"
88775,"public SootClass resolveClassAndSupportClasses(String className,Scene cm){
  soot.Timer timer=new soot.Timer(""String_Node_Str"");
  soot.Timer buildTimer=new soot.Timer(""String_Node_Str"");
  Timers.v().resolverTimer.start();
  setActiveClassManager(cm);
  classesToResolve=new LinkedList();
  markedClasses=new HashSet();
  SootClass newClass=getResolvedClass(className);
  while (!classesToResolve.isEmpty()) {
    SootClass bclass=(SootClass)classesToResolve.removeFirst();
    className=bclass.getName();
    timer.start();
    if (Options.v().verbose())     G.v().out.println(""String_Node_Str"" + className + ""String_Node_Str"");
    ClassFile coffiClass=new ClassFile(className);
{
      boolean success=coffiClass.loadClassFile();
      timer.end();
      if (!success) {
        if (!Scene.v().allowsPhantomRefs())         throw new RuntimeException(""String_Node_Str"" + bclass.getName());
 else {
          G.v().out.println(""String_Node_Str"" + className + ""String_Node_Str"");
          bclass.setPhantom(true);
          continue;
        }
      }
      buildTimer.start();
      CONSTANT_Class_info c=(CONSTANT_Class_info)coffiClass.constant_pool[coffiClass.this_class];
      String name=((CONSTANT_Utf8_info)(coffiClass.constant_pool[c.name_index])).convert();
      name=name.replace('/','.');
      if (!name.equals(bclass.getName())) {
        throw new RuntimeException(""String_Node_Str"" + name + ""String_Node_Str""+ bclass.getName()+ ""String_Node_Str"");
      }
    }
    bclass.setModifiers(coffiClass.access_flags & (~0x0020));
{
      if (coffiClass.super_class != 0) {
        CONSTANT_Class_info c=(CONSTANT_Class_info)coffiClass.constant_pool[coffiClass.super_class];
        String superName=((CONSTANT_Utf8_info)(coffiClass.constant_pool[c.name_index])).convert();
        superName=superName.replace('/','.');
        bclass.setSuperclass(getResolvedClass(superName));
      }
    }
{
      for (int i=0; i < coffiClass.interfaces_count; i++) {
        CONSTANT_Class_info c=(CONSTANT_Class_info)coffiClass.constant_pool[coffiClass.interfaces[i]];
        String interfaceName=((CONSTANT_Utf8_info)(coffiClass.constant_pool[c.name_index])).convert();
        interfaceName=interfaceName.replace('/','.');
        SootClass interfaceClass=getResolvedClass(interfaceName);
        bclass.addInterface(interfaceClass);
      }
    }
    for (int i=0; i < coffiClass.fields_count; i++) {
      field_info fieldInfo=coffiClass.fields[i];
      String fieldName=((CONSTANT_Utf8_info)(coffiClass.constant_pool[fieldInfo.name_index])).convert();
      String fieldDescriptor=((CONSTANT_Utf8_info)(coffiClass.constant_pool[fieldInfo.descriptor_index])).convert();
      int modifiers=fieldInfo.access_flags;
      Type fieldType=jimpleTypeOfFieldDescriptor(cm,fieldDescriptor);
      bclass.addField(new SootField(fieldName,fieldType,modifiers));
      assertResolvedClassForType(fieldType);
    }
    for (int i=0; i < coffiClass.methods_count; i++) {
      method_info methodInfo=coffiClass.methods[i];
      String methodName=((CONSTANT_Utf8_info)(coffiClass.constant_pool[methodInfo.name_index])).convert();
      String methodDescriptor=((CONSTANT_Utf8_info)(coffiClass.constant_pool[methodInfo.descriptor_index])).convert();
      List parameterTypes;
      Type returnType;
{
        Type[] types=jimpleTypesOfFieldOrMethodDescriptor(cm,methodDescriptor);
        parameterTypes=new ArrayList();
        for (int j=0; j < types.length - 1; j++) {
          assertResolvedClassForType(types[j]);
          parameterTypes.add(types[j]);
        }
        returnType=types[types.length - 1];
        assertResolvedClassForType(returnType);
      }
      int modifiers=methodInfo.access_flags;
      SootMethod method;
      method=new SootMethod(methodName,parameterTypes,returnType,modifiers);
      bclass.addMethod(method);
      methodInfo.jmethod=method;
{
        for (int j=0; j < methodInfo.attributes_count; j++)         if (methodInfo.attributes[j] instanceof Exception_attribute) {
          Exception_attribute exceptions=(Exception_attribute)methodInfo.attributes[j];
          for (int k=0; k < exceptions.number_of_exceptions; k++) {
            CONSTANT_Class_info c=(CONSTANT_Class_info)coffiClass.constant_pool[exceptions.exception_index_table[k]];
            String exceptionName=((CONSTANT_Utf8_info)(coffiClass.constant_pool[c.name_index])).convert();
            exceptionName=exceptionName.replace('/','.');
            method.addException(getResolvedClass(exceptionName));
          }
        }
      }
{
        for (int k=0; k < coffiClass.constant_pool_count; k++)         if (coffiClass.constant_pool[k] instanceof CONSTANT_Class_info) {
          CONSTANT_Class_info c=(CONSTANT_Class_info)coffiClass.constant_pool[k];
          String desc=((CONSTANT_Utf8_info)(coffiClass.constant_pool[c.name_index])).convert();
          String name=desc.replace('/','.');
          if (name.startsWith(""String_Node_Str""))           assertResolvedClassForType(jimpleTypeOfFieldDescriptor(cm,desc));
 else           assertResolvedClass(name);
        }
      }
    }
    for (int i=0; i < coffiClass.methods_count; i++) {
      method_info methodInfo=coffiClass.methods[i];
      methodInfo.jmethod.setSource(new CoffiMethodSource(coffiClass,methodInfo));
    }
    buildTimer.end();
  }
  Timers.v().resolverTimer.end();
  return newClass;
}","public SootClass resolveClassAndSupportClasses(String className,Scene cm){
  soot.Timer timer=new soot.Timer(""String_Node_Str"");
  soot.Timer buildTimer=new soot.Timer(""String_Node_Str"");
  Timers.v().resolverTimer.start();
  setActiveClassManager(cm);
  classesToResolve=new LinkedList();
  markedClasses=new HashSet();
  SootClass newClass=getResolvedClass(className);
  while (!classesToResolve.isEmpty()) {
    SootClass bclass=(SootClass)classesToResolve.removeFirst();
    className=bclass.getName();
    timer.start();
    if (Options.v().verbose())     G.v().out.println(""String_Node_Str"" + className + ""String_Node_Str"");
    ClassFile coffiClass=new ClassFile(className);
{
      boolean success=coffiClass.loadClassFile();
      timer.end();
      if (!success) {
        if (!Scene.v().allowsPhantomRefs())         throw new RuntimeException(""String_Node_Str"" + bclass.getName());
 else {
          G.v().out.println(""String_Node_Str"" + className + ""String_Node_Str"");
          bclass.setPhantom(true);
          continue;
        }
      }
      buildTimer.start();
      CONSTANT_Class_info c=(CONSTANT_Class_info)coffiClass.constant_pool[coffiClass.this_class];
      String name=((CONSTANT_Utf8_info)(coffiClass.constant_pool[c.name_index])).convert();
      name=name.replace('/','.');
      if (!name.equals(bclass.getName())) {
        throw new RuntimeException(""String_Node_Str"" + name + ""String_Node_Str""+ bclass.getName()+ ""String_Node_Str"");
      }
    }
    bclass.setModifiers(coffiClass.access_flags & (~0x0020));
{
      if (coffiClass.super_class != 0) {
        CONSTANT_Class_info c=(CONSTANT_Class_info)coffiClass.constant_pool[coffiClass.super_class];
        String superName=((CONSTANT_Utf8_info)(coffiClass.constant_pool[c.name_index])).convert();
        superName=superName.replace('/','.');
        bclass.setSuperclass(getResolvedClass(superName));
      }
    }
{
      for (int i=0; i < coffiClass.interfaces_count; i++) {
        CONSTANT_Class_info c=(CONSTANT_Class_info)coffiClass.constant_pool[coffiClass.interfaces[i]];
        String interfaceName=((CONSTANT_Utf8_info)(coffiClass.constant_pool[c.name_index])).convert();
        interfaceName=interfaceName.replace('/','.');
        SootClass interfaceClass=getResolvedClass(interfaceName);
        bclass.addInterface(interfaceClass);
      }
    }
    for (int i=0; i < coffiClass.fields_count; i++) {
      field_info fieldInfo=coffiClass.fields[i];
      String fieldName=((CONSTANT_Utf8_info)(coffiClass.constant_pool[fieldInfo.name_index])).convert();
      String fieldDescriptor=((CONSTANT_Utf8_info)(coffiClass.constant_pool[fieldInfo.descriptor_index])).convert();
      int modifiers=fieldInfo.access_flags;
      Type fieldType=jimpleTypeOfFieldDescriptor(cm,fieldDescriptor);
      bclass.addField(new SootField(fieldName,fieldType,modifiers));
      assertResolvedClassForType(fieldType);
    }
    for (int i=0; i < coffiClass.methods_count; i++) {
      method_info methodInfo=coffiClass.methods[i];
      String methodName=((CONSTANT_Utf8_info)(coffiClass.constant_pool[methodInfo.name_index])).convert();
      String methodDescriptor=((CONSTANT_Utf8_info)(coffiClass.constant_pool[methodInfo.descriptor_index])).convert();
      List parameterTypes;
      Type returnType;
{
        Type[] types=jimpleTypesOfFieldOrMethodDescriptor(cm,methodDescriptor);
        parameterTypes=new ArrayList();
        for (int j=0; j < types.length - 1; j++) {
          assertResolvedClassForType(types[j]);
          parameterTypes.add(types[j]);
        }
        returnType=types[types.length - 1];
        assertResolvedClassForType(returnType);
      }
      int modifiers=methodInfo.access_flags;
      SootMethod method;
      method=new SootMethod(methodName,parameterTypes,returnType,modifiers);
      bclass.addMethod(method);
      methodInfo.jmethod=method;
{
        for (int j=0; j < methodInfo.attributes_count; j++)         if (methodInfo.attributes[j] instanceof Exception_attribute) {
          Exception_attribute exceptions=(Exception_attribute)methodInfo.attributes[j];
          for (int k=0; k < exceptions.number_of_exceptions; k++) {
            CONSTANT_Class_info c=(CONSTANT_Class_info)coffiClass.constant_pool[exceptions.exception_index_table[k]];
            String exceptionName=((CONSTANT_Utf8_info)(coffiClass.constant_pool[c.name_index])).convert();
            exceptionName=exceptionName.replace('/','.');
            method.addExceptionIfAbsent(getResolvedClass(exceptionName));
          }
        }
      }
{
        for (int k=0; k < coffiClass.constant_pool_count; k++)         if (coffiClass.constant_pool[k] instanceof CONSTANT_Class_info) {
          CONSTANT_Class_info c=(CONSTANT_Class_info)coffiClass.constant_pool[k];
          String desc=((CONSTANT_Utf8_info)(coffiClass.constant_pool[c.name_index])).convert();
          String name=desc.replace('/','.');
          if (name.startsWith(""String_Node_Str""))           assertResolvedClassForType(jimpleTypeOfFieldDescriptor(cm,desc));
 else           assertResolvedClass(name);
        }
      }
    }
    for (int i=0; i < coffiClass.methods_count; i++) {
      method_info methodInfo=coffiClass.methods[i];
      methodInfo.jmethod.setSource(new CoffiMethodSource(coffiClass,methodInfo));
    }
    buildTimer.end();
  }
  Timers.v().resolverTimer.end();
  return newClass;
}"
88776,"public SootClass resolveClassAndSupportClasses2(String className,InputStream is){
  SootClass newClass=null;
  Scene cm=Scene.v();
  scene=cm;
  if (scene.containsClass(className))   newClass=scene.getSootClass(className);
 else {
    newClass=new SootClass(className);
    scene.addClass(newClass);
  }
  SootClass bclass=newClass;
  className=bclass.getName();
  if (Options.v().verbose())   G.v().out.println(""String_Node_Str"" + className + ""String_Node_Str"");
  ClassFile coffiClass=new ClassFile(className);
{
    boolean success=coffiClass.loadClassFile(is);
    if (!success) {
      if (!Scene.v().allowsPhantomRefs())       throw new RuntimeException(""String_Node_Str"" + bclass.getName());
 else {
        G.v().out.println(""String_Node_Str"" + className + ""String_Node_Str"");
        bclass.setPhantom(true);
        return newClass;
      }
    }
    CONSTANT_Class_info c=(CONSTANT_Class_info)coffiClass.constant_pool[coffiClass.this_class];
    String name=((CONSTANT_Utf8_info)(coffiClass.constant_pool[c.name_index])).convert();
    name=name.replace('/','.');
    if (!name.equals(bclass.getName())) {
      throw new RuntimeException(""String_Node_Str"" + name + ""String_Node_Str""+ bclass.getName()+ ""String_Node_Str"");
    }
  }
  bclass.setModifiers(coffiClass.access_flags & (~0x0020));
{
    if (coffiClass.super_class != 0) {
      CONSTANT_Class_info c=(CONSTANT_Class_info)coffiClass.constant_pool[coffiClass.super_class];
      String superName=((CONSTANT_Utf8_info)(coffiClass.constant_pool[c.name_index])).convert();
      superName=superName.replace('/','.');
      bclass.setSuperclass(getResolvedClass2(superName));
    }
  }
{
    for (int i=0; i < coffiClass.interfaces_count; i++) {
      CONSTANT_Class_info c=(CONSTANT_Class_info)coffiClass.constant_pool[coffiClass.interfaces[i]];
      String interfaceName=((CONSTANT_Utf8_info)(coffiClass.constant_pool[c.name_index])).convert();
      interfaceName=interfaceName.replace('/','.');
      SootClass interfaceClass=getResolvedClass2(interfaceName);
      bclass.addInterface(interfaceClass);
    }
  }
  for (int i=0; i < coffiClass.fields_count; i++) {
    field_info fieldInfo=coffiClass.fields[i];
    String fieldName=((CONSTANT_Utf8_info)(coffiClass.constant_pool[fieldInfo.name_index])).convert();
    String fieldDescriptor=((CONSTANT_Utf8_info)(coffiClass.constant_pool[fieldInfo.descriptor_index])).convert();
    int modifiers=fieldInfo.access_flags;
    Type fieldType=jimpleTypeOfFieldDescriptor(cm,fieldDescriptor);
    bclass.addField(new SootField(fieldName,fieldType,modifiers));
  }
  for (int i=0; i < coffiClass.methods_count; i++) {
    method_info methodInfo=coffiClass.methods[i];
    String methodName=((CONSTANT_Utf8_info)(coffiClass.constant_pool[methodInfo.name_index])).convert();
    String methodDescriptor=((CONSTANT_Utf8_info)(coffiClass.constant_pool[methodInfo.descriptor_index])).convert();
    List parameterTypes;
    Type returnType;
{
      Type[] types=jimpleTypesOfFieldOrMethodDescriptor(cm,methodDescriptor);
      parameterTypes=new ArrayList();
      for (int j=0; j < types.length - 1; j++) {
        parameterTypes.add(types[j]);
      }
      returnType=types[types.length - 1];
    }
    int modifiers=methodInfo.access_flags;
    SootMethod method;
    method=new SootMethod(methodName,parameterTypes,returnType,modifiers);
    bclass.addMethod(method);
    methodInfo.jmethod=method;
{
      for (int j=0; j < methodInfo.attributes_count; j++)       if (methodInfo.attributes[j] instanceof Exception_attribute) {
        Exception_attribute exceptions=(Exception_attribute)methodInfo.attributes[j];
        for (int k=0; k < exceptions.number_of_exceptions; k++) {
          CONSTANT_Class_info c=(CONSTANT_Class_info)coffiClass.constant_pool[exceptions.exception_index_table[k]];
          String exceptionName=((CONSTANT_Utf8_info)(coffiClass.constant_pool[c.name_index])).convert();
          exceptionName=exceptionName.replace('/','.');
          method.addException(getResolvedClass2(exceptionName));
        }
      }
    }
  }
  for (int i=0; i < coffiClass.methods_count; i++) {
    method_info methodInfo=coffiClass.methods[i];
    methodInfo.jmethod.setSource(new CoffiMethodSource(coffiClass,methodInfo));
  }
  return newClass;
}","public SootClass resolveClassAndSupportClasses2(String className,InputStream is){
  SootClass newClass=null;
  Scene cm=Scene.v();
  scene=cm;
  if (scene.containsClass(className))   newClass=scene.getSootClass(className);
 else {
    newClass=new SootClass(className);
    scene.addClass(newClass);
  }
  SootClass bclass=newClass;
  className=bclass.getName();
  if (Options.v().verbose())   G.v().out.println(""String_Node_Str"" + className + ""String_Node_Str"");
  ClassFile coffiClass=new ClassFile(className);
{
    boolean success=coffiClass.loadClassFile(is);
    if (!success) {
      if (!Scene.v().allowsPhantomRefs())       throw new RuntimeException(""String_Node_Str"" + bclass.getName());
 else {
        G.v().out.println(""String_Node_Str"" + className + ""String_Node_Str"");
        bclass.setPhantom(true);
        return newClass;
      }
    }
    CONSTANT_Class_info c=(CONSTANT_Class_info)coffiClass.constant_pool[coffiClass.this_class];
    String name=((CONSTANT_Utf8_info)(coffiClass.constant_pool[c.name_index])).convert();
    name=name.replace('/','.');
    if (!name.equals(bclass.getName())) {
      throw new RuntimeException(""String_Node_Str"" + name + ""String_Node_Str""+ bclass.getName()+ ""String_Node_Str"");
    }
  }
  bclass.setModifiers(coffiClass.access_flags & (~0x0020));
{
    if (coffiClass.super_class != 0) {
      CONSTANT_Class_info c=(CONSTANT_Class_info)coffiClass.constant_pool[coffiClass.super_class];
      String superName=((CONSTANT_Utf8_info)(coffiClass.constant_pool[c.name_index])).convert();
      superName=superName.replace('/','.');
      bclass.setSuperclass(getResolvedClass2(superName));
    }
  }
{
    for (int i=0; i < coffiClass.interfaces_count; i++) {
      CONSTANT_Class_info c=(CONSTANT_Class_info)coffiClass.constant_pool[coffiClass.interfaces[i]];
      String interfaceName=((CONSTANT_Utf8_info)(coffiClass.constant_pool[c.name_index])).convert();
      interfaceName=interfaceName.replace('/','.');
      SootClass interfaceClass=getResolvedClass2(interfaceName);
      bclass.addInterface(interfaceClass);
    }
  }
  for (int i=0; i < coffiClass.fields_count; i++) {
    field_info fieldInfo=coffiClass.fields[i];
    String fieldName=((CONSTANT_Utf8_info)(coffiClass.constant_pool[fieldInfo.name_index])).convert();
    String fieldDescriptor=((CONSTANT_Utf8_info)(coffiClass.constant_pool[fieldInfo.descriptor_index])).convert();
    int modifiers=fieldInfo.access_flags;
    Type fieldType=jimpleTypeOfFieldDescriptor(cm,fieldDescriptor);
    bclass.addField(new SootField(fieldName,fieldType,modifiers));
  }
  for (int i=0; i < coffiClass.methods_count; i++) {
    method_info methodInfo=coffiClass.methods[i];
    String methodName=((CONSTANT_Utf8_info)(coffiClass.constant_pool[methodInfo.name_index])).convert();
    String methodDescriptor=((CONSTANT_Utf8_info)(coffiClass.constant_pool[methodInfo.descriptor_index])).convert();
    List parameterTypes;
    Type returnType;
{
      Type[] types=jimpleTypesOfFieldOrMethodDescriptor(cm,methodDescriptor);
      parameterTypes=new ArrayList();
      for (int j=0; j < types.length - 1; j++) {
        parameterTypes.add(types[j]);
      }
      returnType=types[types.length - 1];
    }
    int modifiers=methodInfo.access_flags;
    SootMethod method;
    method=new SootMethod(methodName,parameterTypes,returnType,modifiers);
    bclass.addMethod(method);
    methodInfo.jmethod=method;
{
      for (int j=0; j < methodInfo.attributes_count; j++)       if (methodInfo.attributes[j] instanceof Exception_attribute) {
        Exception_attribute exceptions=(Exception_attribute)methodInfo.attributes[j];
        for (int k=0; k < exceptions.number_of_exceptions; k++) {
          CONSTANT_Class_info c=(CONSTANT_Class_info)coffiClass.constant_pool[exceptions.exception_index_table[k]];
          String exceptionName=((CONSTANT_Utf8_info)(coffiClass.constant_pool[c.name_index])).convert();
          exceptionName=exceptionName.replace('/','.');
          method.addExceptionIfAbsent(getResolvedClass2(exceptionName));
        }
      }
    }
  }
  for (int i=0; i < coffiClass.methods_count; i++) {
    method_info methodInfo=coffiClass.methods[i];
    methodInfo.jmethod.setSource(new CoffiMethodSource(coffiClass,methodInfo));
  }
  return newClass;
}"
88777,"public void resolveFromClassFile(SootClass aClass,InputStream is,soot.SootResolver sootResolver,Scene cm){
  SootClass bclass=aClass;
  String className=bclass.getName();
  setActiveClassManager(cm);
  ClassFile coffiClass=new ClassFile(className);
{
    boolean success=coffiClass.loadClassFile(is);
    if (!success) {
      if (!Scene.v().allowsPhantomRefs())       throw new RuntimeException(""String_Node_Str"" + bclass.getName());
 else {
        G.v().out.println(""String_Node_Str"" + className + ""String_Node_Str"");
        bclass.setPhantom(true);
        return;
      }
    }
    CONSTANT_Class_info c=(CONSTANT_Class_info)coffiClass.constant_pool[coffiClass.this_class];
    String name=((CONSTANT_Utf8_info)(coffiClass.constant_pool[c.name_index])).convert();
    name=name.replace('/','.');
    if (!name.equals(bclass.getName())) {
      throw new RuntimeException(""String_Node_Str"" + name + ""String_Node_Str""+ bclass.getName()+ ""String_Node_Str"");
    }
  }
  bclass.setModifiers(coffiClass.access_flags & (~0x0020));
{
    if (coffiClass.super_class != 0) {
      CONSTANT_Class_info c=(CONSTANT_Class_info)coffiClass.constant_pool[coffiClass.super_class];
      String superName=((CONSTANT_Utf8_info)(coffiClass.constant_pool[c.name_index])).convert();
      superName=superName.replace('/','.');
      bclass.setSuperclass(sootResolver.getResolvedClass(superName));
    }
  }
{
    for (int i=0; i < coffiClass.interfaces_count; i++) {
      CONSTANT_Class_info c=(CONSTANT_Class_info)coffiClass.constant_pool[coffiClass.interfaces[i]];
      String interfaceName=((CONSTANT_Utf8_info)(coffiClass.constant_pool[c.name_index])).convert();
      interfaceName=interfaceName.replace('/','.');
      SootClass interfaceClass=sootResolver.getResolvedClass(interfaceName);
      bclass.addInterface(interfaceClass);
    }
  }
  for (int i=0; i < coffiClass.fields_count; i++) {
    field_info fieldInfo=coffiClass.fields[i];
    String fieldName=((CONSTANT_Utf8_info)(coffiClass.constant_pool[fieldInfo.name_index])).convert();
    String fieldDescriptor=((CONSTANT_Utf8_info)(coffiClass.constant_pool[fieldInfo.descriptor_index])).convert();
    int modifiers=fieldInfo.access_flags;
    Type fieldType=jimpleTypeOfFieldDescriptor(cm,fieldDescriptor);
    bclass.addField(new SootField(fieldName,fieldType,modifiers));
    sootResolver.assertResolvedClassForType(fieldType);
  }
  for (int i=0; i < coffiClass.methods_count; i++) {
    method_info methodInfo=coffiClass.methods[i];
    if ((coffiClass.constant_pool[methodInfo.name_index]) == null) {
      G.v().out.println(""String_Node_Str"" + methodInfo.toName(coffiClass.constant_pool));
      throw new RuntimeException(""String_Node_Str"");
    }
    String methodName=((CONSTANT_Utf8_info)(coffiClass.constant_pool[methodInfo.name_index])).convert();
    String methodDescriptor=((CONSTANT_Utf8_info)(coffiClass.constant_pool[methodInfo.descriptor_index])).convert();
    List parameterTypes;
    Type returnType;
{
      Type[] types=jimpleTypesOfFieldOrMethodDescriptor(cm,methodDescriptor);
      parameterTypes=new ArrayList();
      for (int j=0; j < types.length - 1; j++) {
        sootResolver.assertResolvedClassForType(types[j]);
        parameterTypes.add(types[j]);
      }
      returnType=types[types.length - 1];
      sootResolver.assertResolvedClassForType(returnType);
    }
    int modifiers=methodInfo.access_flags;
    SootMethod method;
    method=new SootMethod(methodName,parameterTypes,returnType,modifiers);
    bclass.addMethod(method);
    methodInfo.jmethod=method;
{
      for (int j=0; j < methodInfo.attributes_count; j++)       if (methodInfo.attributes[j] instanceof Exception_attribute) {
        Exception_attribute exceptions=(Exception_attribute)methodInfo.attributes[j];
        for (int k=0; k < exceptions.number_of_exceptions; k++) {
          CONSTANT_Class_info c=(CONSTANT_Class_info)coffiClass.constant_pool[exceptions.exception_index_table[k]];
          String exceptionName=((CONSTANT_Utf8_info)(coffiClass.constant_pool[c.name_index])).convert();
          exceptionName=exceptionName.replace('/','.');
          method.addException(sootResolver.getResolvedClass(exceptionName));
        }
      }
    }
{
      for (int k=0; k < coffiClass.constant_pool_count; k++)       if (coffiClass.constant_pool[k] instanceof CONSTANT_Class_info) {
        CONSTANT_Class_info c=(CONSTANT_Class_info)coffiClass.constant_pool[k];
        String desc=((CONSTANT_Utf8_info)(coffiClass.constant_pool[c.name_index])).convert();
        String name=desc.replace('/','.');
        if (name.startsWith(""String_Node_Str""))         sootResolver.assertResolvedClassForType(jimpleTypeOfFieldDescriptor(cm,desc));
 else         sootResolver.assertResolvedClass(name);
      }
    }
  }
  for (int i=0; i < coffiClass.methods_count; i++) {
    method_info methodInfo=coffiClass.methods[i];
    methodInfo.jmethod.setSource(new CoffiMethodSource(coffiClass,methodInfo));
  }
}","public void resolveFromClassFile(SootClass aClass,InputStream is,soot.SootResolver sootResolver,Scene cm){
  SootClass bclass=aClass;
  String className=bclass.getName();
  setActiveClassManager(cm);
  ClassFile coffiClass=new ClassFile(className);
{
    boolean success=coffiClass.loadClassFile(is);
    if (!success) {
      if (!Scene.v().allowsPhantomRefs())       throw new RuntimeException(""String_Node_Str"" + bclass.getName());
 else {
        G.v().out.println(""String_Node_Str"" + className + ""String_Node_Str"");
        bclass.setPhantom(true);
        return;
      }
    }
    CONSTANT_Class_info c=(CONSTANT_Class_info)coffiClass.constant_pool[coffiClass.this_class];
    String name=((CONSTANT_Utf8_info)(coffiClass.constant_pool[c.name_index])).convert();
    name=name.replace('/','.');
    if (!name.equals(bclass.getName())) {
      throw new RuntimeException(""String_Node_Str"" + name + ""String_Node_Str""+ bclass.getName()+ ""String_Node_Str"");
    }
  }
  bclass.setModifiers(coffiClass.access_flags & (~0x0020));
{
    if (coffiClass.super_class != 0) {
      CONSTANT_Class_info c=(CONSTANT_Class_info)coffiClass.constant_pool[coffiClass.super_class];
      String superName=((CONSTANT_Utf8_info)(coffiClass.constant_pool[c.name_index])).convert();
      superName=superName.replace('/','.');
      bclass.setSuperclass(sootResolver.getResolvedClass(superName));
    }
  }
{
    for (int i=0; i < coffiClass.interfaces_count; i++) {
      CONSTANT_Class_info c=(CONSTANT_Class_info)coffiClass.constant_pool[coffiClass.interfaces[i]];
      String interfaceName=((CONSTANT_Utf8_info)(coffiClass.constant_pool[c.name_index])).convert();
      interfaceName=interfaceName.replace('/','.');
      SootClass interfaceClass=sootResolver.getResolvedClass(interfaceName);
      bclass.addInterface(interfaceClass);
    }
  }
  for (int i=0; i < coffiClass.fields_count; i++) {
    field_info fieldInfo=coffiClass.fields[i];
    String fieldName=((CONSTANT_Utf8_info)(coffiClass.constant_pool[fieldInfo.name_index])).convert();
    String fieldDescriptor=((CONSTANT_Utf8_info)(coffiClass.constant_pool[fieldInfo.descriptor_index])).convert();
    int modifiers=fieldInfo.access_flags;
    Type fieldType=jimpleTypeOfFieldDescriptor(cm,fieldDescriptor);
    bclass.addField(new SootField(fieldName,fieldType,modifiers));
    sootResolver.assertResolvedClassForType(fieldType);
  }
  for (int i=0; i < coffiClass.methods_count; i++) {
    method_info methodInfo=coffiClass.methods[i];
    if ((coffiClass.constant_pool[methodInfo.name_index]) == null) {
      G.v().out.println(""String_Node_Str"" + methodInfo.toName(coffiClass.constant_pool));
      throw new RuntimeException(""String_Node_Str"");
    }
    String methodName=((CONSTANT_Utf8_info)(coffiClass.constant_pool[methodInfo.name_index])).convert();
    String methodDescriptor=((CONSTANT_Utf8_info)(coffiClass.constant_pool[methodInfo.descriptor_index])).convert();
    List parameterTypes;
    Type returnType;
{
      Type[] types=jimpleTypesOfFieldOrMethodDescriptor(cm,methodDescriptor);
      parameterTypes=new ArrayList();
      for (int j=0; j < types.length - 1; j++) {
        sootResolver.assertResolvedClassForType(types[j]);
        parameterTypes.add(types[j]);
      }
      returnType=types[types.length - 1];
      sootResolver.assertResolvedClassForType(returnType);
    }
    int modifiers=methodInfo.access_flags;
    SootMethod method;
    method=new SootMethod(methodName,parameterTypes,returnType,modifiers);
    bclass.addMethod(method);
    methodInfo.jmethod=method;
{
      for (int j=0; j < methodInfo.attributes_count; j++)       if (methodInfo.attributes[j] instanceof Exception_attribute) {
        Exception_attribute exceptions=(Exception_attribute)methodInfo.attributes[j];
        for (int k=0; k < exceptions.number_of_exceptions; k++) {
          CONSTANT_Class_info c=(CONSTANT_Class_info)coffiClass.constant_pool[exceptions.exception_index_table[k]];
          String exceptionName=((CONSTANT_Utf8_info)(coffiClass.constant_pool[c.name_index])).convert();
          exceptionName=exceptionName.replace('/','.');
          method.addExceptionIfAbsent(sootResolver.getResolvedClass(exceptionName));
        }
      }
    }
{
      for (int k=0; k < coffiClass.constant_pool_count; k++)       if (coffiClass.constant_pool[k] instanceof CONSTANT_Class_info) {
        CONSTANT_Class_info c=(CONSTANT_Class_info)coffiClass.constant_pool[k];
        String desc=((CONSTANT_Utf8_info)(coffiClass.constant_pool[c.name_index])).convert();
        String name=desc.replace('/','.');
        if (name.startsWith(""String_Node_Str""))         sootResolver.assertResolvedClassForType(jimpleTypeOfFieldDescriptor(cm,desc));
 else         sootResolver.assertResolvedClass(name);
      }
    }
  }
  for (int i=0; i < coffiClass.methods_count; i++) {
    method_info methodInfo=coffiClass.methods[i];
    methodInfo.jmethod.setSource(new CoffiMethodSource(coffiClass,methodInfo));
  }
}"
88778,"void generateJimple(Instruction ins,TypeStack typeStack,TypeStack postTypeStack,cp_info constant_pool[],List statements,BasicBlock basicBlock){
  Value[] params;
  Value v1=null, v2=null, v3=null, v4=null;
  Local l1=null, l2=null, l3=null, l4=null;
  Expr e=null, rhs=null;
  BinopExpr b=null;
  ConditionExpr co=null;
  ArrayRef a=null;
  int args;
  Value rvalue;
  Stmt stmt=null;
  int x=((int)(ins.code)) & 0xff;
  Util.v().activeOriginalIndex=ins.originalIndex;
  Util.v().isLocalStore=false;
  Util.v().isWideLocalStore=false;
switch (x) {
case ByteCode.BIPUSH:
    rvalue=IntConstant.v(((Instruction_Bipush)ins).arg_b);
  stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rvalue);
break;
case ByteCode.SIPUSH:
rvalue=IntConstant.v(((Instruction_Sipush)ins).arg_i);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rvalue);
break;
case ByteCode.LDC1:
generateJimpleForCPEntry(constant_pool,((Instruction_Ldc1)ins).arg_b,typeStack,postTypeStack,jmethod,statements);
break;
case ByteCode.LDC2:
case ByteCode.LDC2W:
generateJimpleForCPEntry(constant_pool,((Instruction_intindex)ins).arg_i,typeStack,postTypeStack,jmethod,statements);
break;
case ByteCode.ACONST_NULL:
rvalue=NullConstant.v();
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rvalue);
break;
case ByteCode.ICONST_M1:
case ByteCode.ICONST_0:
case ByteCode.ICONST_1:
case ByteCode.ICONST_2:
case ByteCode.ICONST_3:
case ByteCode.ICONST_4:
case ByteCode.ICONST_5:
rvalue=IntConstant.v(x - ByteCode.ICONST_0);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rvalue);
break;
case ByteCode.LCONST_0:
case ByteCode.LCONST_1:
rvalue=LongConstant.v(x - ByteCode.LCONST_0);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rvalue);
break;
case ByteCode.FCONST_0:
case ByteCode.FCONST_1:
case ByteCode.FCONST_2:
rvalue=FloatConstant.v((float)(x - ByteCode.FCONST_0));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rvalue);
break;
case ByteCode.DCONST_0:
case ByteCode.DCONST_1:
rvalue=DoubleConstant.v((double)(x - ByteCode.DCONST_0));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rvalue);
break;
case ByteCode.ILOAD:
{
Local local=(Local)Util.v().getLocalForIndex(listBody,((Instruction_bytevar)ins).arg_b);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),local);
break;
}
case ByteCode.FLOAD:
{
Local local=(Local)Util.v().getLocalForIndex(listBody,((Instruction_bytevar)ins).arg_b);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),local);
break;
}
case ByteCode.ALOAD:
{
Local local=Util.v().getLocalForIndex(listBody,((Instruction_bytevar)ins).arg_b);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),local);
break;
}
case ByteCode.DLOAD:
{
Local local=Util.v().getLocalForIndex(listBody,((Instruction_bytevar)ins).arg_b);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),local);
break;
}
case ByteCode.LLOAD:
{
Local local=Util.v().getLocalForIndex(listBody,((Instruction_bytevar)ins).arg_b);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),local);
break;
}
case ByteCode.ILOAD_0:
case ByteCode.ILOAD_1:
case ByteCode.ILOAD_2:
case ByteCode.ILOAD_3:
{
Local local=Util.v().getLocalForIndex(listBody,(x - ByteCode.ILOAD_0));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),local);
break;
}
case ByteCode.FLOAD_0:
case ByteCode.FLOAD_1:
case ByteCode.FLOAD_2:
case ByteCode.FLOAD_3:
{
Local local=Util.v().getLocalForIndex(listBody,(x - ByteCode.FLOAD_0));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),local);
break;
}
case ByteCode.ALOAD_0:
case ByteCode.ALOAD_1:
case ByteCode.ALOAD_2:
case ByteCode.ALOAD_3:
{
Local local=Util.v().getLocalForIndex(listBody,(x - ByteCode.ALOAD_0));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),local);
break;
}
case ByteCode.LLOAD_0:
case ByteCode.LLOAD_1:
case ByteCode.LLOAD_2:
case ByteCode.LLOAD_3:
{
Local local=Util.v().getLocalForIndex(listBody,(x - ByteCode.LLOAD_0));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),local);
break;
}
case ByteCode.DLOAD_0:
case ByteCode.DLOAD_1:
case ByteCode.DLOAD_2:
case ByteCode.DLOAD_3:
{
Local local=Util.v().getLocalForIndex(listBody,(x - ByteCode.DLOAD_0));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),local);
break;
}
case ByteCode.ISTORE:
{
Util.v().isLocalStore=true;
Util.v().isWideLocalStore=true;
Local local=Util.v().getLocalForIndex(listBody,((Instruction_bytevar)ins).arg_b);
stmt=Jimple.v().newAssignStmt(local,Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
break;
}
case ByteCode.FSTORE:
{
Util.v().isLocalStore=true;
Util.v().isWideLocalStore=true;
Local local=Util.v().getLocalForIndex(listBody,((Instruction_bytevar)ins).arg_b);
stmt=Jimple.v().newAssignStmt(local,Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
break;
}
case ByteCode.ASTORE:
{
Util.v().isLocalStore=true;
Util.v().isWideLocalStore=true;
Local local=Util.v().getLocalForIndex(listBody,((Instruction_bytevar)ins).arg_b);
stmt=Jimple.v().newAssignStmt(local,Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
break;
}
case ByteCode.LSTORE:
{
Util.v().isLocalStore=true;
Util.v().isWideLocalStore=true;
Local local=Util.v().getLocalForIndex(listBody,((Instruction_bytevar)ins).arg_b);
stmt=Jimple.v().newAssignStmt(local,Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
break;
}
case ByteCode.DSTORE:
{
Util.v().isLocalStore=true;
Util.v().isWideLocalStore=true;
Local local=Util.v().getLocalForIndex(listBody,((Instruction_bytevar)ins).arg_b);
stmt=Jimple.v().newAssignStmt(local,Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
break;
}
case ByteCode.ISTORE_0:
case ByteCode.ISTORE_1:
case ByteCode.ISTORE_2:
case ByteCode.ISTORE_3:
{
Util.v().isLocalStore=true;
Local local=Util.v().getLocalForIndex(listBody,(x - ByteCode.ISTORE_0));
stmt=Jimple.v().newAssignStmt(local,Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
break;
}
case ByteCode.FSTORE_0:
case ByteCode.FSTORE_1:
case ByteCode.FSTORE_2:
case ByteCode.FSTORE_3:
{
Util.v().isLocalStore=true;
Local local=(Local)Util.v().getLocalForIndex(listBody,(x - ByteCode.FSTORE_0));
stmt=Jimple.v().newAssignStmt(local,Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
break;
}
case ByteCode.ASTORE_0:
case ByteCode.ASTORE_1:
case ByteCode.ASTORE_2:
case ByteCode.ASTORE_3:
{
Util.v().isLocalStore=true;
Local local=Util.v().getLocalForIndex(listBody,(x - ByteCode.ASTORE_0));
stmt=Jimple.v().newAssignStmt(local,Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
break;
}
case ByteCode.LSTORE_0:
case ByteCode.LSTORE_1:
case ByteCode.LSTORE_2:
case ByteCode.LSTORE_3:
{
Util.v().isLocalStore=true;
Local local=Util.v().getLocalForIndex(listBody,(x - ByteCode.LSTORE_0));
stmt=Jimple.v().newAssignStmt(local,Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
break;
}
case ByteCode.DSTORE_0:
case ByteCode.DSTORE_1:
case ByteCode.DSTORE_2:
case ByteCode.DSTORE_3:
{
Util.v().isLocalStore=true;
Local local=Util.v().getLocalForIndex(listBody,(x - ByteCode.DSTORE_0));
stmt=Jimple.v().newAssignStmt(local,Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
break;
}
case ByteCode.IINC:
{
Local local=Util.v().getLocalForIndex(listBody,((Instruction_Iinc)ins).arg_b);
int amt=(((Instruction_Iinc)ins).arg_c);
rhs=Jimple.v().newAddExpr(local,IntConstant.v(amt));
stmt=Jimple.v().newAssignStmt(local,rhs);
break;
}
case ByteCode.WIDE:
throw new RuntimeException(""String_Node_Str"");
case ByteCode.NEWARRAY:
{
Type baseType=(Type)jimpleTypeOfAtype(((Instruction_Newarray)ins).atype);
rhs=Jimple.v().newNewArrayExpr(baseType,Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
}
case ByteCode.ANEWARRAY:
{
String baseName=getClassName(constant_pool,((Instruction_Anewarray)ins).arg_i);
Type baseType;
if (baseName.startsWith(""String_Node_Str"")) baseType=Util.v().jimpleTypeOfFieldDescriptor(cm,getClassName(constant_pool,((Instruction_Anewarray)ins).arg_i));
 else baseType=RefType.v(baseName);
rhs=Jimple.v().newNewArrayExpr(baseType,Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
}
case ByteCode.MULTIANEWARRAY:
{
int bdims=(int)(((Instruction_Multianewarray)ins).dims);
List dims=new ArrayList();
for (int j=0; j < bdims; j++) dims.add(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - bdims + j + 1));
String mstype=constant_pool[((Instruction_Multianewarray)ins).arg_i].toString(constant_pool);
ArrayType jimpleType=(ArrayType)Util.v().jimpleTypeOfFieldDescriptor(cm,mstype);
rhs=Jimple.v().newNewMultiArrayExpr(jimpleType,dims);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
}
case ByteCode.ARRAYLENGTH:
rhs=Jimple.v().newLengthExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.IALOAD:
case ByteCode.BALOAD:
case ByteCode.CALOAD:
case ByteCode.SALOAD:
case ByteCode.FALOAD:
case ByteCode.LALOAD:
case ByteCode.DALOAD:
case ByteCode.AALOAD:
a=Jimple.v().newArrayRef(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),a);
break;
case ByteCode.IASTORE:
case ByteCode.FASTORE:
case ByteCode.AASTORE:
case ByteCode.BASTORE:
case ByteCode.CASTORE:
case ByteCode.SASTORE:
a=Jimple.v().newArrayRef(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 2),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1));
stmt=Jimple.v().newAssignStmt(a,Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
break;
case ByteCode.LASTORE:
case ByteCode.DASTORE:
a=Jimple.v().newArrayRef(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 3),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 2));
stmt=Jimple.v().newAssignStmt(a,Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
break;
case ByteCode.NOP:
stmt=Jimple.v().newNopStmt();
break;
case ByteCode.POP:
case ByteCode.POP2:
stmt=Jimple.v().newNopStmt();
break;
case ByteCode.DUP:
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
break;
case ByteCode.DUP2:
if (typeSize(typeStack.top()) == 2) {
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1));
}
 else {
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1));
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
statements.add(stmt);
stmt=null;
}
break;
case ByteCode.DUP_X1:
l1=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex());
l2=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),l1);
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 1),l2);
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 2),Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()));
statements.add(stmt);
stmt=null;
break;
case ByteCode.DUP_X2:
if (typeSize(typeStack.get(typeStack.topIndex() - 2)) == 2) {
l3=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 2);
l1=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex());
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 3),l1);
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 2),l3);
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),l1);
statements.add(stmt);
stmt=null;
}
 else {
l3=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 2);
l2=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1);
l1=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex());
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),l1);
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 1),l2);
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 2),l3);
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 3),Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()));
statements.add(stmt);
stmt=null;
}
break;
case ByteCode.DUP2_X1:
if (typeSize(typeStack.get(typeStack.topIndex() - 1)) == 2) {
l2=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1);
l3=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 2);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 1),l2);
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 2),l3);
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 4),Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 1));
statements.add(stmt);
stmt=null;
}
 else {
l3=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 2);
l2=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1);
l1=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex());
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),l1);
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 1),l2);
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 2),l3);
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 3),Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()));
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 4),Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 1));
statements.add(stmt);
stmt=null;
}
break;
case ByteCode.DUP2_X2:
if (typeSize(typeStack.get(typeStack.topIndex() - 1)) == 2) {
l2=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 1),l2);
statements.add(stmt);
}
 else {
l1=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex());
l2=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 1),l2);
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),l1);
statements.add(stmt);
}
if (typeSize(typeStack.get(typeStack.topIndex() - 3)) == 2) {
l4=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 3);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 3),l4);
statements.add(stmt);
}
 else {
l4=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 3);
l3=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 2);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 3),l4);
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 2),l3);
statements.add(stmt);
}
if (typeSize(typeStack.get(typeStack.topIndex() - 1)) == 2) {
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 5),Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 1));
statements.add(stmt);
}
 else {
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 5),Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 1));
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 4),Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()));
statements.add(stmt);
}
stmt=null;
break;
case ByteCode.SWAP:
{
Local first;
typeStack=typeStack.push(typeStack.top());
first=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex());
typeStack=typeStack.pop();
Local second=Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex());
Local third=Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 1);
stmt=Jimple.v().newAssignStmt(first,second);
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(second,third);
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(third,first);
statements.add(stmt);
stmt=null;
break;
}
case ByteCode.FADD:
case ByteCode.IADD:
rhs=Jimple.v().newAddExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.DADD:
case ByteCode.LADD:
rhs=Jimple.v().newAddExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 3),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.FSUB:
case ByteCode.ISUB:
rhs=Jimple.v().newSubExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.DSUB:
case ByteCode.LSUB:
rhs=Jimple.v().newSubExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 3),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.FMUL:
case ByteCode.IMUL:
rhs=Jimple.v().newMulExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.DMUL:
case ByteCode.LMUL:
rhs=Jimple.v().newMulExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 3),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.FDIV:
case ByteCode.IDIV:
rhs=Jimple.v().newDivExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.DDIV:
case ByteCode.LDIV:
rhs=Jimple.v().newDivExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 3),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.FREM:
case ByteCode.IREM:
rhs=Jimple.v().newRemExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.DREM:
case ByteCode.LREM:
rhs=Jimple.v().newRemExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 3),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.INEG:
case ByteCode.LNEG:
case ByteCode.FNEG:
case ByteCode.DNEG:
rhs=Jimple.v().newNegExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.ISHL:
rhs=Jimple.v().newShlExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.ISHR:
rhs=Jimple.v().newShrExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.IUSHR:
rhs=Jimple.v().newUshrExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.LSHL:
rhs=Jimple.v().newShlExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 2),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.LSHR:
rhs=Jimple.v().newShrExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 2),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.LUSHR:
rhs=Jimple.v().newUshrExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 2),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.IAND:
rhs=Jimple.v().newAndExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.LAND:
rhs=Jimple.v().newAndExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 3),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.IOR:
rhs=Jimple.v().newOrExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.LOR:
rhs=Jimple.v().newOrExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 3),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.IXOR:
rhs=Jimple.v().newXorExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.LXOR:
rhs=Jimple.v().newXorExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 3),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.D2L:
case ByteCode.F2L:
case ByteCode.I2L:
rhs=Jimple.v().newCastExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),LongType.v());
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.D2F:
case ByteCode.L2F:
case ByteCode.I2F:
rhs=Jimple.v().newCastExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),FloatType.v());
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.I2D:
case ByteCode.L2D:
case ByteCode.F2D:
rhs=Jimple.v().newCastExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),DoubleType.v());
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.L2I:
case ByteCode.F2I:
case ByteCode.D2I:
rhs=Jimple.v().newCastExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),IntType.v());
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.INT2BYTE:
rhs=Jimple.v().newCastExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),ByteType.v());
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.INT2CHAR:
rhs=Jimple.v().newCastExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),CharType.v());
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.INT2SHORT:
rhs=Jimple.v().newCastExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),ShortType.v());
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.IFEQ:
co=Jimple.v().newEqExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),IntConstant.v(0));
stmt=Jimple.v().newIfStmt(co,new FutureStmt());
break;
case ByteCode.IFNULL:
co=Jimple.v().newEqExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),NullConstant.v());
stmt=Jimple.v().newIfStmt(co,new FutureStmt());
break;
case ByteCode.IFLT:
co=Jimple.v().newLtExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),IntConstant.v(0));
stmt=Jimple.v().newIfStmt(co,new FutureStmt());
break;
case ByteCode.IFLE:
co=Jimple.v().newLeExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),IntConstant.v(0));
stmt=Jimple.v().newIfStmt(co,new FutureStmt());
break;
case ByteCode.IFNE:
co=Jimple.v().newNeExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),IntConstant.v(0));
stmt=Jimple.v().newIfStmt(co,new FutureStmt());
break;
case ByteCode.IFNONNULL:
co=Jimple.v().newNeExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),NullConstant.v());
stmt=Jimple.v().newIfStmt(co,new FutureStmt());
break;
case ByteCode.IFGT:
co=Jimple.v().newGtExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),IntConstant.v(0));
stmt=Jimple.v().newIfStmt(co,new FutureStmt());
break;
case ByteCode.IFGE:
co=Jimple.v().newGeExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),IntConstant.v(0));
stmt=Jimple.v().newIfStmt(co,new FutureStmt());
break;
case ByteCode.IF_ICMPEQ:
co=Jimple.v().newEqExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newIfStmt(co,new FutureStmt());
break;
case ByteCode.IF_ICMPLT:
co=Jimple.v().newLtExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newIfStmt(co,new FutureStmt());
break;
case ByteCode.IF_ICMPLE:
co=Jimple.v().newLeExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newIfStmt(co,new FutureStmt());
break;
case ByteCode.IF_ICMPNE:
co=Jimple.v().newNeExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newIfStmt(co,new FutureStmt());
break;
case ByteCode.IF_ICMPGT:
co=Jimple.v().newGtExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newIfStmt(co,new FutureStmt());
break;
case ByteCode.IF_ICMPGE:
co=Jimple.v().newGeExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newIfStmt(co,new FutureStmt());
break;
case ByteCode.LCMP:
rhs=Jimple.v().newCmpExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 3),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.FCMPL:
rhs=Jimple.v().newCmplExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.FCMPG:
rhs=Jimple.v().newCmpgExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.DCMPL:
rhs=Jimple.v().newCmplExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 3),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.DCMPG:
rhs=Jimple.v().newCmpgExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 3),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.IF_ACMPEQ:
co=Jimple.v().newEqExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newIfStmt(co,new FutureStmt());
break;
case ByteCode.IF_ACMPNE:
co=Jimple.v().newNeExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newIfStmt(co,new FutureStmt());
break;
case ByteCode.GOTO:
stmt=Jimple.v().newGotoStmt(new FutureStmt());
break;
case ByteCode.GOTO_W:
stmt=Jimple.v().newGotoStmt(new FutureStmt());
break;
case ByteCode.RET:
{
Local local=Util.v().getLocalForIndex(listBody,((Instruction_Ret)ins).arg_b);
stmt=Jimple.v().newRetStmt(local);
break;
}
case ByteCode.RET_W:
{
Local local=Util.v().getLocalForIndex(listBody,((Instruction_Ret_w)ins).arg_i);
stmt=Jimple.v().newRetStmt(local);
break;
}
case ByteCode.RETURN:
stmt=Jimple.v().newReturnVoidStmt();
break;
case ByteCode.LRETURN:
case ByteCode.DRETURN:
case ByteCode.IRETURN:
case ByteCode.FRETURN:
case ByteCode.ARETURN:
stmt=Jimple.v().newReturnStmt(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
break;
case ByteCode.BREAKPOINT:
stmt=Jimple.v().newBreakpointStmt();
break;
case ByteCode.TABLESWITCH:
{
int lowIndex=((Instruction_Tableswitch)ins).low, highIndex=((Instruction_Tableswitch)ins).high;
stmt=Jimple.v().newTableSwitchStmt(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),lowIndex,highIndex,Arrays.asList(new FutureStmt[highIndex - lowIndex + 1]),new FutureStmt());
break;
}
case ByteCode.LOOKUPSWITCH:
{
List matches=new ArrayList();
int npairs=((Instruction_Lookupswitch)ins).npairs;
for (int j=0; j < npairs; j++) matches.add(IntConstant.v(((Instruction_Lookupswitch)ins).match_offsets[j * 2]));
stmt=Jimple.v().newLookupSwitchStmt(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),matches,Arrays.asList(new FutureStmt[npairs]),new FutureStmt());
break;
}
case ByteCode.PUTFIELD:
{
CONSTANT_Fieldref_info fieldInfo=(CONSTANT_Fieldref_info)constant_pool[((Instruction_Putfield)ins).arg_i];
CONSTANT_Class_info c=(CONSTANT_Class_info)constant_pool[fieldInfo.class_index];
String className=((CONSTANT_Utf8_info)(constant_pool[c.name_index])).convert();
className=className.replace('/','.');
CONSTANT_NameAndType_info i=(CONSTANT_NameAndType_info)constant_pool[fieldInfo.name_and_type_index];
String fieldName=((CONSTANT_Utf8_info)(constant_pool[i.name_index])).convert();
String fieldDescriptor=((CONSTANT_Utf8_info)(constant_pool[i.descriptor_index])).convert();
Type fieldType=Util.v().jimpleTypeOfFieldDescriptor(cm,fieldDescriptor);
SootClass bclass=cm.getSootClass(className);
SootField field=bclass.getField(fieldName,fieldType);
InstanceFieldRef fr=Jimple.v().newInstanceFieldRef(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - typeSize(typeStack.top())),field);
rvalue=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex());
stmt=Jimple.v().newAssignStmt(fr,rvalue);
break;
}
case ByteCode.GETFIELD:
{
InstanceFieldRef fr=null;
CONSTANT_Fieldref_info fieldInfo=(CONSTANT_Fieldref_info)constant_pool[((Instruction_Getfield)ins).arg_i];
CONSTANT_Class_info c=(CONSTANT_Class_info)constant_pool[fieldInfo.class_index];
String className=((CONSTANT_Utf8_info)(constant_pool[c.name_index])).convert();
className=className.replace('/','.');
CONSTANT_NameAndType_info i=(CONSTANT_NameAndType_info)constant_pool[fieldInfo.name_and_type_index];
String fieldName=((CONSTANT_Utf8_info)(constant_pool[i.name_index])).convert();
String fieldDescriptor=((CONSTANT_Utf8_info)(constant_pool[i.descriptor_index])).convert();
SootClass bclass=cm.getSootClass(className);
Type fieldType=Util.v().jimpleTypeOfFieldDescriptor(cm,fieldDescriptor);
SootField field=bclass.getField(fieldName,fieldType);
fr=Jimple.v().newInstanceFieldRef(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),field);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),fr);
break;
}
case ByteCode.PUTSTATIC:
{
StaticFieldRef fr=null;
CONSTANT_Fieldref_info fieldInfo=(CONSTANT_Fieldref_info)constant_pool[((Instruction_Putstatic)ins).arg_i];
CONSTANT_Class_info c=(CONSTANT_Class_info)constant_pool[fieldInfo.class_index];
String className=((CONSTANT_Utf8_info)(constant_pool[c.name_index])).convert();
className=className.replace('/','.');
CONSTANT_NameAndType_info i=(CONSTANT_NameAndType_info)constant_pool[fieldInfo.name_and_type_index];
String fieldName=((CONSTANT_Utf8_info)(constant_pool[i.name_index])).convert();
String fieldDescriptor=((CONSTANT_Utf8_info)(constant_pool[i.descriptor_index])).convert();
Type fieldType=Util.v().jimpleTypeOfFieldDescriptor(cm,fieldDescriptor);
SootClass bclass=cm.getSootClass(className);
SootField field=bclass.getField(fieldName,fieldType);
fr=Jimple.v().newStaticFieldRef(field);
stmt=Jimple.v().newAssignStmt(fr,Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
break;
}
case ByteCode.GETSTATIC:
{
StaticFieldRef fr=null;
CONSTANT_Fieldref_info fieldInfo=(CONSTANT_Fieldref_info)constant_pool[((Instruction_Getstatic)ins).arg_i];
CONSTANT_Class_info c=(CONSTANT_Class_info)constant_pool[fieldInfo.class_index];
String className=((CONSTANT_Utf8_info)(constant_pool[c.name_index])).convert();
className=className.replace('/','.');
CONSTANT_NameAndType_info i=(CONSTANT_NameAndType_info)constant_pool[fieldInfo.name_and_type_index];
String fieldName=((CONSTANT_Utf8_info)(constant_pool[i.name_index])).convert();
String fieldDescriptor=((CONSTANT_Utf8_info)(constant_pool[i.descriptor_index])).convert();
Type fieldType=Util.v().jimpleTypeOfFieldDescriptor(cm,fieldDescriptor);
SootClass bclass=cm.getSootClass(className);
SootField field=bclass.getField(fieldName,fieldType);
fr=Jimple.v().newStaticFieldRef(field);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),fr);
break;
}
case ByteCode.INVOKEVIRTUAL:
{
Instruction_Invokevirtual iv=(Instruction_Invokevirtual)ins;
args=cp_info.countParams(constant_pool,iv.arg_i);
SootMethod method=null;
CONSTANT_Methodref_info methodInfo=(CONSTANT_Methodref_info)constant_pool[iv.arg_i];
CONSTANT_Class_info c=(CONSTANT_Class_info)constant_pool[methodInfo.class_index];
String className=((CONSTANT_Utf8_info)(constant_pool[c.name_index])).convert();
className=className.replace('/','.');
CONSTANT_NameAndType_info i=(CONSTANT_NameAndType_info)constant_pool[methodInfo.name_and_type_index];
String methodName=((CONSTANT_Utf8_info)(constant_pool[i.name_index])).convert();
String methodDescriptor=((CONSTANT_Utf8_info)(constant_pool[i.descriptor_index])).convert();
SootClass bclass=cm.getSootClass(className);
Local[] parameters;
List parameterTypes;
Type returnType;
{
Type[] types=Util.v().jimpleTypesOfFieldOrMethodDescriptor(cm,methodDescriptor);
parameterTypes=new ArrayList();
for (int k=0; k < types.length - 1; k++) {
parameterTypes.add(types[k]);
}
returnType=types[types.length - 1];
}
method=bclass.getMethod(methodName,parameterTypes,returnType);
params=new Value[args];
for (int j=args - 1; j >= 0; j--) {
params[j]=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex());
if (typeSize(typeStack.top()) == 2) {
typeStack=typeStack.pop();
typeStack=typeStack.pop();
}
 else typeStack=typeStack.pop();
}
rvalue=Jimple.v().newVirtualInvokeExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),method,Arrays.asList(params));
if (!returnType.equals(VoidType.v())) {
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rvalue);
}
 else stmt=Jimple.v().newInvokeStmt((InvokeExpr)rvalue);
break;
}
case ByteCode.INVOKENONVIRTUAL:
{
Instruction_Invokenonvirtual iv=(Instruction_Invokenonvirtual)ins;
args=cp_info.countParams(constant_pool,iv.arg_i);
SootMethod method=null;
CONSTANT_Methodref_info methodInfo=(CONSTANT_Methodref_info)constant_pool[iv.arg_i];
CONSTANT_Class_info c=(CONSTANT_Class_info)constant_pool[methodInfo.class_index];
String className=((CONSTANT_Utf8_info)(constant_pool[c.name_index])).convert();
className=className.replace('/','.');
CONSTANT_NameAndType_info i=(CONSTANT_NameAndType_info)constant_pool[methodInfo.name_and_type_index];
String methodName=((CONSTANT_Utf8_info)(constant_pool[i.name_index])).convert();
String methodDescriptor=((CONSTANT_Utf8_info)(constant_pool[i.descriptor_index])).convert();
SootClass bclass=cm.getSootClass(className);
Local[] parameters;
List parameterTypes;
Type returnType;
{
Type[] types=Util.v().jimpleTypesOfFieldOrMethodDescriptor(cm,methodDescriptor);
parameterTypes=new ArrayList();
for (int k=0; k < types.length - 1; k++) {
parameterTypes.add(types[k]);
}
returnType=types[types.length - 1];
}
method=bclass.getMethod(methodName,parameterTypes,returnType);
params=new Value[args];
for (int j=args - 1; j >= 0; j--) {
params[j]=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex());
if (typeSize(typeStack.top()) == 2) {
typeStack=typeStack.pop();
typeStack=typeStack.pop();
}
 else typeStack=typeStack.pop();
}
rvalue=Jimple.v().newSpecialInvokeExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),method,Arrays.asList(params));
if (!returnType.equals(VoidType.v())) {
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rvalue);
}
 else stmt=Jimple.v().newInvokeStmt((InvokeExpr)rvalue);
break;
}
case ByteCode.INVOKESTATIC:
{
Instruction_Invokestatic is=(Instruction_Invokestatic)ins;
args=cp_info.countParams(constant_pool,is.arg_i);
SootMethod method=null;
CONSTANT_Methodref_info methodInfo=(CONSTANT_Methodref_info)constant_pool[is.arg_i];
CONSTANT_Class_info c=(CONSTANT_Class_info)constant_pool[methodInfo.class_index];
String className=((CONSTANT_Utf8_info)(constant_pool[c.name_index])).convert();
className=className.replace('/','.');
CONSTANT_NameAndType_info i=(CONSTANT_NameAndType_info)constant_pool[methodInfo.name_and_type_index];
String methodName=((CONSTANT_Utf8_info)(constant_pool[i.name_index])).convert();
String methodDescriptor=((CONSTANT_Utf8_info)(constant_pool[i.descriptor_index])).convert();
SootClass bclass=cm.getSootClass(className);
Local[] parameters;
List parameterTypes;
Type returnType;
{
Type[] types=Util.v().jimpleTypesOfFieldOrMethodDescriptor(cm,methodDescriptor);
parameterTypes=new ArrayList();
for (int k=0; k < types.length - 1; k++) {
parameterTypes.add(types[k]);
}
returnType=types[types.length - 1];
}
method=bclass.getMethod(methodName,parameterTypes,returnType);
params=new Value[args];
for (int j=args - 1; j >= 0; j--) {
params[j]=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex());
if (typeSize(typeStack.top()) == 2) {
typeStack=typeStack.pop();
typeStack=typeStack.pop();
}
 else typeStack=typeStack.pop();
}
rvalue=Jimple.v().newStaticInvokeExpr(method,Arrays.asList(params));
if (!returnType.equals(VoidType.v())) {
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rvalue);
}
 else stmt=Jimple.v().newInvokeStmt((InvokeExpr)rvalue);
break;
}
case ByteCode.INVOKEINTERFACE:
{
Instruction_Invokeinterface ii=(Instruction_Invokeinterface)ins;
args=cp_info.countParams(constant_pool,ii.arg_i);
SootMethod method=null;
CONSTANT_InterfaceMethodref_info methodInfo=(CONSTANT_InterfaceMethodref_info)constant_pool[ii.arg_i];
CONSTANT_Class_info c=(CONSTANT_Class_info)constant_pool[methodInfo.class_index];
String className=((CONSTANT_Utf8_info)(constant_pool[c.name_index])).convert();
className=className.replace('/','.');
CONSTANT_NameAndType_info i=(CONSTANT_NameAndType_info)constant_pool[methodInfo.name_and_type_index];
String methodName=((CONSTANT_Utf8_info)(constant_pool[i.name_index])).convert();
String methodDescriptor=((CONSTANT_Utf8_info)(constant_pool[i.descriptor_index])).convert();
SootClass bclass=cm.getSootClass(className);
Local[] parameters;
List parameterTypes;
Type returnType;
{
Type[] types=Util.v().jimpleTypesOfFieldOrMethodDescriptor(cm,methodDescriptor);
parameterTypes=new ArrayList();
for (int k=0; k < types.length - 1; k++) {
parameterTypes.add(types[k]);
}
returnType=types[types.length - 1];
}
method=bclass.getMethod(methodName,parameterTypes,returnType);
params=new Value[args];
for (int j=args - 1; j >= 0; j--) {
params[j]=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex());
if (typeSize(typeStack.top()) == 2) {
typeStack=typeStack.pop();
typeStack=typeStack.pop();
}
 else typeStack=typeStack.pop();
}
rvalue=Jimple.v().newInterfaceInvokeExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),method,Arrays.asList(params));
if (!returnType.equals(VoidType.v())) {
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rvalue);
}
 else stmt=Jimple.v().newInvokeStmt((InvokeExpr)rvalue);
break;
}
case ByteCode.ATHROW:
stmt=Jimple.v().newThrowStmt(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
break;
case ByteCode.NEW:
{
SootClass bclass=cm.getSootClass(getClassName(constant_pool,((Instruction_New)ins).arg_i));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),Jimple.v().newNewExpr(RefType.v(bclass.getName())));
break;
}
case ByteCode.CHECKCAST:
{
String className=getClassName(constant_pool,((Instruction_Checkcast)ins).arg_i);
Type castType;
if (className.startsWith(""String_Node_Str"")) castType=Util.v().jimpleTypeOfFieldDescriptor(cm,getClassName(constant_pool,((Instruction_Checkcast)ins).arg_i));
 else castType=RefType.v(className);
rhs=Jimple.v().newCastExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),castType);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
}
case ByteCode.INSTANCEOF:
{
Type checkType;
String className=getClassName(constant_pool,((Instruction_Instanceof)ins).arg_i);
if (className.startsWith(""String_Node_Str"")) checkType=Util.v().jimpleTypeOfFieldDescriptor(cm,getClassName(constant_pool,((Instruction_Instanceof)ins).arg_i));
 else checkType=RefType.v(className);
rhs=Jimple.v().newInstanceOfExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),checkType);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
}
case ByteCode.MONITORENTER:
stmt=Jimple.v().newEnterMonitorStmt(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
break;
case ByteCode.MONITOREXIT:
stmt=Jimple.v().newExitMonitorStmt(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
break;
default :
throw new RuntimeException(""String_Node_Str"" + x);
}
if (stmt != null) {
if (Options.v().keep_offset()) {
stmt.addTag(new BytecodeOffsetTag(ins.label));
}
statements.add(stmt);
}
}","void generateJimple(Instruction ins,TypeStack typeStack,TypeStack postTypeStack,cp_info constant_pool[],List statements,BasicBlock basicBlock){
  Value[] params;
  Value v1=null, v2=null, v3=null, v4=null;
  Local l1=null, l2=null, l3=null, l4=null;
  Expr e=null, rhs=null;
  BinopExpr b=null;
  ConditionExpr co=null;
  ArrayRef a=null;
  int args;
  Value rvalue;
  Stmt stmt=null;
  int x=((int)(ins.code)) & 0xff;
  Util.v().activeOriginalIndex=ins.originalIndex;
  Util.v().isLocalStore=false;
  Util.v().isWideLocalStore=false;
switch (x) {
case ByteCode.BIPUSH:
    rvalue=IntConstant.v(((Instruction_Bipush)ins).arg_b);
  stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rvalue);
break;
case ByteCode.SIPUSH:
rvalue=IntConstant.v(((Instruction_Sipush)ins).arg_i);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rvalue);
break;
case ByteCode.LDC1:
generateJimpleForCPEntry(constant_pool,((Instruction_Ldc1)ins).arg_b,typeStack,postTypeStack,jmethod,statements);
break;
case ByteCode.LDC2:
case ByteCode.LDC2W:
generateJimpleForCPEntry(constant_pool,((Instruction_intindex)ins).arg_i,typeStack,postTypeStack,jmethod,statements);
break;
case ByteCode.ACONST_NULL:
rvalue=NullConstant.v();
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rvalue);
break;
case ByteCode.ICONST_M1:
case ByteCode.ICONST_0:
case ByteCode.ICONST_1:
case ByteCode.ICONST_2:
case ByteCode.ICONST_3:
case ByteCode.ICONST_4:
case ByteCode.ICONST_5:
rvalue=IntConstant.v(x - ByteCode.ICONST_0);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rvalue);
break;
case ByteCode.LCONST_0:
case ByteCode.LCONST_1:
rvalue=LongConstant.v(x - ByteCode.LCONST_0);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rvalue);
break;
case ByteCode.FCONST_0:
case ByteCode.FCONST_1:
case ByteCode.FCONST_2:
rvalue=FloatConstant.v((float)(x - ByteCode.FCONST_0));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rvalue);
break;
case ByteCode.DCONST_0:
case ByteCode.DCONST_1:
rvalue=DoubleConstant.v((double)(x - ByteCode.DCONST_0));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rvalue);
break;
case ByteCode.ILOAD:
{
Local local=(Local)Util.v().getLocalForIndex(listBody,((Instruction_bytevar)ins).arg_b);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),local);
break;
}
case ByteCode.FLOAD:
{
Local local=(Local)Util.v().getLocalForIndex(listBody,((Instruction_bytevar)ins).arg_b);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),local);
break;
}
case ByteCode.ALOAD:
{
Local local=Util.v().getLocalForIndex(listBody,((Instruction_bytevar)ins).arg_b);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),local);
break;
}
case ByteCode.DLOAD:
{
Local local=Util.v().getLocalForIndex(listBody,((Instruction_bytevar)ins).arg_b);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),local);
break;
}
case ByteCode.LLOAD:
{
Local local=Util.v().getLocalForIndex(listBody,((Instruction_bytevar)ins).arg_b);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),local);
break;
}
case ByteCode.ILOAD_0:
case ByteCode.ILOAD_1:
case ByteCode.ILOAD_2:
case ByteCode.ILOAD_3:
{
Local local=Util.v().getLocalForIndex(listBody,(x - ByteCode.ILOAD_0));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),local);
break;
}
case ByteCode.FLOAD_0:
case ByteCode.FLOAD_1:
case ByteCode.FLOAD_2:
case ByteCode.FLOAD_3:
{
Local local=Util.v().getLocalForIndex(listBody,(x - ByteCode.FLOAD_0));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),local);
break;
}
case ByteCode.ALOAD_0:
case ByteCode.ALOAD_1:
case ByteCode.ALOAD_2:
case ByteCode.ALOAD_3:
{
Local local=Util.v().getLocalForIndex(listBody,(x - ByteCode.ALOAD_0));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),local);
break;
}
case ByteCode.LLOAD_0:
case ByteCode.LLOAD_1:
case ByteCode.LLOAD_2:
case ByteCode.LLOAD_3:
{
Local local=Util.v().getLocalForIndex(listBody,(x - ByteCode.LLOAD_0));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),local);
break;
}
case ByteCode.DLOAD_0:
case ByteCode.DLOAD_1:
case ByteCode.DLOAD_2:
case ByteCode.DLOAD_3:
{
Local local=Util.v().getLocalForIndex(listBody,(x - ByteCode.DLOAD_0));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),local);
break;
}
case ByteCode.ISTORE:
{
Util.v().isLocalStore=true;
Util.v().isWideLocalStore=true;
Local local=Util.v().getLocalForIndex(listBody,((Instruction_bytevar)ins).arg_b);
stmt=Jimple.v().newAssignStmt(local,Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
break;
}
case ByteCode.FSTORE:
{
Util.v().isLocalStore=true;
Util.v().isWideLocalStore=true;
Local local=Util.v().getLocalForIndex(listBody,((Instruction_bytevar)ins).arg_b);
stmt=Jimple.v().newAssignStmt(local,Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
break;
}
case ByteCode.ASTORE:
{
Util.v().isLocalStore=true;
Util.v().isWideLocalStore=true;
Local local=Util.v().getLocalForIndex(listBody,((Instruction_bytevar)ins).arg_b);
stmt=Jimple.v().newAssignStmt(local,Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
break;
}
case ByteCode.LSTORE:
{
Util.v().isLocalStore=true;
Util.v().isWideLocalStore=true;
Local local=Util.v().getLocalForIndex(listBody,((Instruction_bytevar)ins).arg_b);
stmt=Jimple.v().newAssignStmt(local,Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
break;
}
case ByteCode.DSTORE:
{
Util.v().isLocalStore=true;
Util.v().isWideLocalStore=true;
Local local=Util.v().getLocalForIndex(listBody,((Instruction_bytevar)ins).arg_b);
stmt=Jimple.v().newAssignStmt(local,Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
break;
}
case ByteCode.ISTORE_0:
case ByteCode.ISTORE_1:
case ByteCode.ISTORE_2:
case ByteCode.ISTORE_3:
{
Util.v().isLocalStore=true;
Local local=Util.v().getLocalForIndex(listBody,(x - ByteCode.ISTORE_0));
stmt=Jimple.v().newAssignStmt(local,Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
break;
}
case ByteCode.FSTORE_0:
case ByteCode.FSTORE_1:
case ByteCode.FSTORE_2:
case ByteCode.FSTORE_3:
{
Util.v().isLocalStore=true;
Local local=(Local)Util.v().getLocalForIndex(listBody,(x - ByteCode.FSTORE_0));
stmt=Jimple.v().newAssignStmt(local,Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
break;
}
case ByteCode.ASTORE_0:
case ByteCode.ASTORE_1:
case ByteCode.ASTORE_2:
case ByteCode.ASTORE_3:
{
Util.v().isLocalStore=true;
Local local=Util.v().getLocalForIndex(listBody,(x - ByteCode.ASTORE_0));
stmt=Jimple.v().newAssignStmt(local,Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
break;
}
case ByteCode.LSTORE_0:
case ByteCode.LSTORE_1:
case ByteCode.LSTORE_2:
case ByteCode.LSTORE_3:
{
Util.v().isLocalStore=true;
Local local=Util.v().getLocalForIndex(listBody,(x - ByteCode.LSTORE_0));
stmt=Jimple.v().newAssignStmt(local,Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
break;
}
case ByteCode.DSTORE_0:
case ByteCode.DSTORE_1:
case ByteCode.DSTORE_2:
case ByteCode.DSTORE_3:
{
Util.v().isLocalStore=true;
Local local=Util.v().getLocalForIndex(listBody,(x - ByteCode.DSTORE_0));
stmt=Jimple.v().newAssignStmt(local,Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
break;
}
case ByteCode.IINC:
{
Local local=Util.v().getLocalForIndex(listBody,((Instruction_Iinc)ins).arg_b);
int amt=(((Instruction_Iinc)ins).arg_c);
rhs=Jimple.v().newAddExpr(local,IntConstant.v(amt));
stmt=Jimple.v().newAssignStmt(local,rhs);
break;
}
case ByteCode.WIDE:
throw new RuntimeException(""String_Node_Str"");
case ByteCode.NEWARRAY:
{
Type baseType=(Type)jimpleTypeOfAtype(((Instruction_Newarray)ins).atype);
rhs=Jimple.v().newNewArrayExpr(baseType,Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
}
case ByteCode.ANEWARRAY:
{
String baseName=getClassName(constant_pool,((Instruction_Anewarray)ins).arg_i);
Type baseType;
if (baseName.startsWith(""String_Node_Str"")) baseType=Util.v().jimpleTypeOfFieldDescriptor(cm,getClassName(constant_pool,((Instruction_Anewarray)ins).arg_i));
 else baseType=RefType.v(baseName);
rhs=Jimple.v().newNewArrayExpr(baseType,Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
}
case ByteCode.MULTIANEWARRAY:
{
int bdims=(int)(((Instruction_Multianewarray)ins).dims);
List dims=new ArrayList();
for (int j=0; j < bdims; j++) dims.add(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - bdims + j + 1));
String mstype=constant_pool[((Instruction_Multianewarray)ins).arg_i].toString(constant_pool);
ArrayType jimpleType=(ArrayType)Util.v().jimpleTypeOfFieldDescriptor(cm,mstype);
rhs=Jimple.v().newNewMultiArrayExpr(jimpleType,dims);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
}
case ByteCode.ARRAYLENGTH:
rhs=Jimple.v().newLengthExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.IALOAD:
case ByteCode.BALOAD:
case ByteCode.CALOAD:
case ByteCode.SALOAD:
case ByteCode.FALOAD:
case ByteCode.LALOAD:
case ByteCode.DALOAD:
case ByteCode.AALOAD:
a=Jimple.v().newArrayRef(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),a);
break;
case ByteCode.IASTORE:
case ByteCode.FASTORE:
case ByteCode.AASTORE:
case ByteCode.BASTORE:
case ByteCode.CASTORE:
case ByteCode.SASTORE:
a=Jimple.v().newArrayRef(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 2),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1));
stmt=Jimple.v().newAssignStmt(a,Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
break;
case ByteCode.LASTORE:
case ByteCode.DASTORE:
a=Jimple.v().newArrayRef(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 3),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 2));
stmt=Jimple.v().newAssignStmt(a,Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
break;
case ByteCode.NOP:
stmt=Jimple.v().newNopStmt();
break;
case ByteCode.POP:
case ByteCode.POP2:
stmt=Jimple.v().newNopStmt();
break;
case ByteCode.DUP:
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
break;
case ByteCode.DUP2:
if (typeSize(typeStack.top()) == 2) {
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1));
}
 else {
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1));
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
statements.add(stmt);
stmt=null;
}
break;
case ByteCode.DUP_X1:
l1=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex());
l2=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),l1);
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 1),l2);
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 2),Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()));
statements.add(stmt);
stmt=null;
break;
case ByteCode.DUP_X2:
if (typeSize(typeStack.get(typeStack.topIndex() - 2)) == 2) {
l3=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 2);
l1=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex());
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 2),l3);
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 3),l1);
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),l1);
statements.add(stmt);
stmt=null;
}
 else {
l3=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 2);
l2=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1);
l1=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex());
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),l1);
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 1),l2);
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 2),l3);
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 3),Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()));
statements.add(stmt);
stmt=null;
}
break;
case ByteCode.DUP2_X1:
if (typeSize(typeStack.get(typeStack.topIndex() - 1)) == 2) {
l2=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1);
l3=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 2);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 1),l2);
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 2),l3);
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 4),Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 1));
statements.add(stmt);
stmt=null;
}
 else {
l3=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 2);
l2=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1);
l1=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex());
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),l1);
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 1),l2);
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 2),l3);
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 3),Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()));
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 4),Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 1));
statements.add(stmt);
stmt=null;
}
break;
case ByteCode.DUP2_X2:
if (typeSize(typeStack.get(typeStack.topIndex() - 1)) == 2) {
l2=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 1),l2);
statements.add(stmt);
}
 else {
l1=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex());
l2=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 1),l2);
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),l1);
statements.add(stmt);
}
if (typeSize(typeStack.get(typeStack.topIndex() - 3)) == 2) {
l4=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 3);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 3),l4);
statements.add(stmt);
}
 else {
l4=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 3);
l3=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 2);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 3),l4);
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 2),l3);
statements.add(stmt);
}
if (typeSize(typeStack.get(typeStack.topIndex() - 1)) == 2) {
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 5),Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 1));
statements.add(stmt);
}
 else {
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 5),Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 1));
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 4),Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()));
statements.add(stmt);
}
stmt=null;
break;
case ByteCode.SWAP:
{
Local first;
typeStack=typeStack.push(typeStack.top());
first=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex());
typeStack=typeStack.pop();
Local second=Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex());
Local third=Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex() - 1);
stmt=Jimple.v().newAssignStmt(first,second);
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(second,third);
statements.add(stmt);
stmt=Jimple.v().newAssignStmt(third,first);
statements.add(stmt);
stmt=null;
break;
}
case ByteCode.FADD:
case ByteCode.IADD:
rhs=Jimple.v().newAddExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.DADD:
case ByteCode.LADD:
rhs=Jimple.v().newAddExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 3),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.FSUB:
case ByteCode.ISUB:
rhs=Jimple.v().newSubExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.DSUB:
case ByteCode.LSUB:
rhs=Jimple.v().newSubExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 3),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.FMUL:
case ByteCode.IMUL:
rhs=Jimple.v().newMulExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.DMUL:
case ByteCode.LMUL:
rhs=Jimple.v().newMulExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 3),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.FDIV:
case ByteCode.IDIV:
rhs=Jimple.v().newDivExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.DDIV:
case ByteCode.LDIV:
rhs=Jimple.v().newDivExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 3),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.FREM:
case ByteCode.IREM:
rhs=Jimple.v().newRemExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.DREM:
case ByteCode.LREM:
rhs=Jimple.v().newRemExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 3),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.INEG:
case ByteCode.LNEG:
case ByteCode.FNEG:
case ByteCode.DNEG:
rhs=Jimple.v().newNegExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.ISHL:
rhs=Jimple.v().newShlExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.ISHR:
rhs=Jimple.v().newShrExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.IUSHR:
rhs=Jimple.v().newUshrExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.LSHL:
rhs=Jimple.v().newShlExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 2),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.LSHR:
rhs=Jimple.v().newShrExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 2),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.LUSHR:
rhs=Jimple.v().newUshrExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 2),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.IAND:
rhs=Jimple.v().newAndExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.LAND:
rhs=Jimple.v().newAndExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 3),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.IOR:
rhs=Jimple.v().newOrExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.LOR:
rhs=Jimple.v().newOrExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 3),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.IXOR:
rhs=Jimple.v().newXorExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.LXOR:
rhs=Jimple.v().newXorExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 3),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.D2L:
case ByteCode.F2L:
case ByteCode.I2L:
rhs=Jimple.v().newCastExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),LongType.v());
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.D2F:
case ByteCode.L2F:
case ByteCode.I2F:
rhs=Jimple.v().newCastExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),FloatType.v());
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.I2D:
case ByteCode.L2D:
case ByteCode.F2D:
rhs=Jimple.v().newCastExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),DoubleType.v());
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.L2I:
case ByteCode.F2I:
case ByteCode.D2I:
rhs=Jimple.v().newCastExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),IntType.v());
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.INT2BYTE:
rhs=Jimple.v().newCastExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),ByteType.v());
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.INT2CHAR:
rhs=Jimple.v().newCastExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),CharType.v());
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.INT2SHORT:
rhs=Jimple.v().newCastExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),ShortType.v());
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.IFEQ:
co=Jimple.v().newEqExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),IntConstant.v(0));
stmt=Jimple.v().newIfStmt(co,new FutureStmt());
break;
case ByteCode.IFNULL:
co=Jimple.v().newEqExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),NullConstant.v());
stmt=Jimple.v().newIfStmt(co,new FutureStmt());
break;
case ByteCode.IFLT:
co=Jimple.v().newLtExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),IntConstant.v(0));
stmt=Jimple.v().newIfStmt(co,new FutureStmt());
break;
case ByteCode.IFLE:
co=Jimple.v().newLeExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),IntConstant.v(0));
stmt=Jimple.v().newIfStmt(co,new FutureStmt());
break;
case ByteCode.IFNE:
co=Jimple.v().newNeExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),IntConstant.v(0));
stmt=Jimple.v().newIfStmt(co,new FutureStmt());
break;
case ByteCode.IFNONNULL:
co=Jimple.v().newNeExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),NullConstant.v());
stmt=Jimple.v().newIfStmt(co,new FutureStmt());
break;
case ByteCode.IFGT:
co=Jimple.v().newGtExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),IntConstant.v(0));
stmt=Jimple.v().newIfStmt(co,new FutureStmt());
break;
case ByteCode.IFGE:
co=Jimple.v().newGeExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),IntConstant.v(0));
stmt=Jimple.v().newIfStmt(co,new FutureStmt());
break;
case ByteCode.IF_ICMPEQ:
co=Jimple.v().newEqExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newIfStmt(co,new FutureStmt());
break;
case ByteCode.IF_ICMPLT:
co=Jimple.v().newLtExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newIfStmt(co,new FutureStmt());
break;
case ByteCode.IF_ICMPLE:
co=Jimple.v().newLeExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newIfStmt(co,new FutureStmt());
break;
case ByteCode.IF_ICMPNE:
co=Jimple.v().newNeExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newIfStmt(co,new FutureStmt());
break;
case ByteCode.IF_ICMPGT:
co=Jimple.v().newGtExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newIfStmt(co,new FutureStmt());
break;
case ByteCode.IF_ICMPGE:
co=Jimple.v().newGeExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newIfStmt(co,new FutureStmt());
break;
case ByteCode.LCMP:
rhs=Jimple.v().newCmpExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 3),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.FCMPL:
rhs=Jimple.v().newCmplExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.FCMPG:
rhs=Jimple.v().newCmpgExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.DCMPL:
rhs=Jimple.v().newCmplExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 3),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.DCMPG:
rhs=Jimple.v().newCmpgExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 3),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
case ByteCode.IF_ACMPEQ:
co=Jimple.v().newEqExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newIfStmt(co,new FutureStmt());
break;
case ByteCode.IF_ACMPNE:
co=Jimple.v().newNeExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - 1),Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
stmt=Jimple.v().newIfStmt(co,new FutureStmt());
break;
case ByteCode.GOTO:
stmt=Jimple.v().newGotoStmt(new FutureStmt());
break;
case ByteCode.GOTO_W:
stmt=Jimple.v().newGotoStmt(new FutureStmt());
break;
case ByteCode.RET:
{
Local local=Util.v().getLocalForIndex(listBody,((Instruction_Ret)ins).arg_b);
stmt=Jimple.v().newRetStmt(local);
break;
}
case ByteCode.RET_W:
{
Local local=Util.v().getLocalForIndex(listBody,((Instruction_Ret_w)ins).arg_i);
stmt=Jimple.v().newRetStmt(local);
break;
}
case ByteCode.RETURN:
stmt=Jimple.v().newReturnVoidStmt();
break;
case ByteCode.LRETURN:
case ByteCode.DRETURN:
case ByteCode.IRETURN:
case ByteCode.FRETURN:
case ByteCode.ARETURN:
stmt=Jimple.v().newReturnStmt(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
break;
case ByteCode.BREAKPOINT:
stmt=Jimple.v().newBreakpointStmt();
break;
case ByteCode.TABLESWITCH:
{
int lowIndex=((Instruction_Tableswitch)ins).low, highIndex=((Instruction_Tableswitch)ins).high;
stmt=Jimple.v().newTableSwitchStmt(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),lowIndex,highIndex,Arrays.asList(new FutureStmt[highIndex - lowIndex + 1]),new FutureStmt());
break;
}
case ByteCode.LOOKUPSWITCH:
{
List matches=new ArrayList();
int npairs=((Instruction_Lookupswitch)ins).npairs;
for (int j=0; j < npairs; j++) matches.add(IntConstant.v(((Instruction_Lookupswitch)ins).match_offsets[j * 2]));
stmt=Jimple.v().newLookupSwitchStmt(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),matches,Arrays.asList(new FutureStmt[npairs]),new FutureStmt());
break;
}
case ByteCode.PUTFIELD:
{
CONSTANT_Fieldref_info fieldInfo=(CONSTANT_Fieldref_info)constant_pool[((Instruction_Putfield)ins).arg_i];
CONSTANT_Class_info c=(CONSTANT_Class_info)constant_pool[fieldInfo.class_index];
String className=((CONSTANT_Utf8_info)(constant_pool[c.name_index])).convert();
className=className.replace('/','.');
CONSTANT_NameAndType_info i=(CONSTANT_NameAndType_info)constant_pool[fieldInfo.name_and_type_index];
String fieldName=((CONSTANT_Utf8_info)(constant_pool[i.name_index])).convert();
String fieldDescriptor=((CONSTANT_Utf8_info)(constant_pool[i.descriptor_index])).convert();
Type fieldType=Util.v().jimpleTypeOfFieldDescriptor(cm,fieldDescriptor);
SootClass bclass=cm.getSootClass(className);
SootField field=bclass.getField(fieldName,fieldType);
InstanceFieldRef fr=Jimple.v().newInstanceFieldRef(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex() - typeSize(typeStack.top())),field);
rvalue=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex());
stmt=Jimple.v().newAssignStmt(fr,rvalue);
break;
}
case ByteCode.GETFIELD:
{
InstanceFieldRef fr=null;
CONSTANT_Fieldref_info fieldInfo=(CONSTANT_Fieldref_info)constant_pool[((Instruction_Getfield)ins).arg_i];
CONSTANT_Class_info c=(CONSTANT_Class_info)constant_pool[fieldInfo.class_index];
String className=((CONSTANT_Utf8_info)(constant_pool[c.name_index])).convert();
className=className.replace('/','.');
CONSTANT_NameAndType_info i=(CONSTANT_NameAndType_info)constant_pool[fieldInfo.name_and_type_index];
String fieldName=((CONSTANT_Utf8_info)(constant_pool[i.name_index])).convert();
String fieldDescriptor=((CONSTANT_Utf8_info)(constant_pool[i.descriptor_index])).convert();
SootClass bclass=cm.getSootClass(className);
Type fieldType=Util.v().jimpleTypeOfFieldDescriptor(cm,fieldDescriptor);
SootField field=bclass.getField(fieldName,fieldType);
fr=Jimple.v().newInstanceFieldRef(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),field);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),fr);
break;
}
case ByteCode.PUTSTATIC:
{
StaticFieldRef fr=null;
CONSTANT_Fieldref_info fieldInfo=(CONSTANT_Fieldref_info)constant_pool[((Instruction_Putstatic)ins).arg_i];
CONSTANT_Class_info c=(CONSTANT_Class_info)constant_pool[fieldInfo.class_index];
String className=((CONSTANT_Utf8_info)(constant_pool[c.name_index])).convert();
className=className.replace('/','.');
CONSTANT_NameAndType_info i=(CONSTANT_NameAndType_info)constant_pool[fieldInfo.name_and_type_index];
String fieldName=((CONSTANT_Utf8_info)(constant_pool[i.name_index])).convert();
String fieldDescriptor=((CONSTANT_Utf8_info)(constant_pool[i.descriptor_index])).convert();
Type fieldType=Util.v().jimpleTypeOfFieldDescriptor(cm,fieldDescriptor);
SootClass bclass=cm.getSootClass(className);
SootField field=bclass.getField(fieldName,fieldType);
fr=Jimple.v().newStaticFieldRef(field);
stmt=Jimple.v().newAssignStmt(fr,Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
break;
}
case ByteCode.GETSTATIC:
{
StaticFieldRef fr=null;
CONSTANT_Fieldref_info fieldInfo=(CONSTANT_Fieldref_info)constant_pool[((Instruction_Getstatic)ins).arg_i];
CONSTANT_Class_info c=(CONSTANT_Class_info)constant_pool[fieldInfo.class_index];
String className=((CONSTANT_Utf8_info)(constant_pool[c.name_index])).convert();
className=className.replace('/','.');
CONSTANT_NameAndType_info i=(CONSTANT_NameAndType_info)constant_pool[fieldInfo.name_and_type_index];
String fieldName=((CONSTANT_Utf8_info)(constant_pool[i.name_index])).convert();
String fieldDescriptor=((CONSTANT_Utf8_info)(constant_pool[i.descriptor_index])).convert();
Type fieldType=Util.v().jimpleTypeOfFieldDescriptor(cm,fieldDescriptor);
SootClass bclass=cm.getSootClass(className);
SootField field=bclass.getField(fieldName,fieldType);
fr=Jimple.v().newStaticFieldRef(field);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),fr);
break;
}
case ByteCode.INVOKEVIRTUAL:
{
Instruction_Invokevirtual iv=(Instruction_Invokevirtual)ins;
args=cp_info.countParams(constant_pool,iv.arg_i);
SootMethod method=null;
CONSTANT_Methodref_info methodInfo=(CONSTANT_Methodref_info)constant_pool[iv.arg_i];
CONSTANT_Class_info c=(CONSTANT_Class_info)constant_pool[methodInfo.class_index];
String className=((CONSTANT_Utf8_info)(constant_pool[c.name_index])).convert();
className=className.replace('/','.');
CONSTANT_NameAndType_info i=(CONSTANT_NameAndType_info)constant_pool[methodInfo.name_and_type_index];
String methodName=((CONSTANT_Utf8_info)(constant_pool[i.name_index])).convert();
String methodDescriptor=((CONSTANT_Utf8_info)(constant_pool[i.descriptor_index])).convert();
SootClass bclass=cm.getSootClass(className);
Local[] parameters;
List parameterTypes;
Type returnType;
{
Type[] types=Util.v().jimpleTypesOfFieldOrMethodDescriptor(cm,methodDescriptor);
parameterTypes=new ArrayList();
for (int k=0; k < types.length - 1; k++) {
parameterTypes.add(types[k]);
}
returnType=types[types.length - 1];
}
method=bclass.getMethod(methodName,parameterTypes,returnType);
params=new Value[args];
for (int j=args - 1; j >= 0; j--) {
params[j]=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex());
if (typeSize(typeStack.top()) == 2) {
typeStack=typeStack.pop();
typeStack=typeStack.pop();
}
 else typeStack=typeStack.pop();
}
rvalue=Jimple.v().newVirtualInvokeExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),method,Arrays.asList(params));
if (!returnType.equals(VoidType.v())) {
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rvalue);
}
 else stmt=Jimple.v().newInvokeStmt((InvokeExpr)rvalue);
break;
}
case ByteCode.INVOKENONVIRTUAL:
{
Instruction_Invokenonvirtual iv=(Instruction_Invokenonvirtual)ins;
args=cp_info.countParams(constant_pool,iv.arg_i);
SootMethod method=null;
CONSTANT_Methodref_info methodInfo=(CONSTANT_Methodref_info)constant_pool[iv.arg_i];
CONSTANT_Class_info c=(CONSTANT_Class_info)constant_pool[methodInfo.class_index];
String className=((CONSTANT_Utf8_info)(constant_pool[c.name_index])).convert();
className=className.replace('/','.');
CONSTANT_NameAndType_info i=(CONSTANT_NameAndType_info)constant_pool[methodInfo.name_and_type_index];
String methodName=((CONSTANT_Utf8_info)(constant_pool[i.name_index])).convert();
String methodDescriptor=((CONSTANT_Utf8_info)(constant_pool[i.descriptor_index])).convert();
SootClass bclass=cm.getSootClass(className);
Local[] parameters;
List parameterTypes;
Type returnType;
{
Type[] types=Util.v().jimpleTypesOfFieldOrMethodDescriptor(cm,methodDescriptor);
parameterTypes=new ArrayList();
for (int k=0; k < types.length - 1; k++) {
parameterTypes.add(types[k]);
}
returnType=types[types.length - 1];
}
method=bclass.getMethod(methodName,parameterTypes,returnType);
params=new Value[args];
for (int j=args - 1; j >= 0; j--) {
params[j]=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex());
if (typeSize(typeStack.top()) == 2) {
typeStack=typeStack.pop();
typeStack=typeStack.pop();
}
 else typeStack=typeStack.pop();
}
rvalue=Jimple.v().newSpecialInvokeExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),method,Arrays.asList(params));
if (!returnType.equals(VoidType.v())) {
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rvalue);
}
 else stmt=Jimple.v().newInvokeStmt((InvokeExpr)rvalue);
break;
}
case ByteCode.INVOKESTATIC:
{
Instruction_Invokestatic is=(Instruction_Invokestatic)ins;
args=cp_info.countParams(constant_pool,is.arg_i);
SootMethod method=null;
CONSTANT_Methodref_info methodInfo=(CONSTANT_Methodref_info)constant_pool[is.arg_i];
CONSTANT_Class_info c=(CONSTANT_Class_info)constant_pool[methodInfo.class_index];
String className=((CONSTANT_Utf8_info)(constant_pool[c.name_index])).convert();
className=className.replace('/','.');
CONSTANT_NameAndType_info i=(CONSTANT_NameAndType_info)constant_pool[methodInfo.name_and_type_index];
String methodName=((CONSTANT_Utf8_info)(constant_pool[i.name_index])).convert();
String methodDescriptor=((CONSTANT_Utf8_info)(constant_pool[i.descriptor_index])).convert();
SootClass bclass=cm.getSootClass(className);
Local[] parameters;
List parameterTypes;
Type returnType;
{
Type[] types=Util.v().jimpleTypesOfFieldOrMethodDescriptor(cm,methodDescriptor);
parameterTypes=new ArrayList();
for (int k=0; k < types.length - 1; k++) {
parameterTypes.add(types[k]);
}
returnType=types[types.length - 1];
}
method=bclass.getMethod(methodName,parameterTypes,returnType);
params=new Value[args];
for (int j=args - 1; j >= 0; j--) {
params[j]=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex());
if (typeSize(typeStack.top()) == 2) {
typeStack=typeStack.pop();
typeStack=typeStack.pop();
}
 else typeStack=typeStack.pop();
}
rvalue=Jimple.v().newStaticInvokeExpr(method,Arrays.asList(params));
if (!returnType.equals(VoidType.v())) {
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rvalue);
}
 else stmt=Jimple.v().newInvokeStmt((InvokeExpr)rvalue);
break;
}
case ByteCode.INVOKEINTERFACE:
{
Instruction_Invokeinterface ii=(Instruction_Invokeinterface)ins;
args=cp_info.countParams(constant_pool,ii.arg_i);
SootMethod method=null;
CONSTANT_InterfaceMethodref_info methodInfo=(CONSTANT_InterfaceMethodref_info)constant_pool[ii.arg_i];
CONSTANT_Class_info c=(CONSTANT_Class_info)constant_pool[methodInfo.class_index];
String className=((CONSTANT_Utf8_info)(constant_pool[c.name_index])).convert();
className=className.replace('/','.');
CONSTANT_NameAndType_info i=(CONSTANT_NameAndType_info)constant_pool[methodInfo.name_and_type_index];
String methodName=((CONSTANT_Utf8_info)(constant_pool[i.name_index])).convert();
String methodDescriptor=((CONSTANT_Utf8_info)(constant_pool[i.descriptor_index])).convert();
SootClass bclass=cm.getSootClass(className);
Local[] parameters;
List parameterTypes;
Type returnType;
{
Type[] types=Util.v().jimpleTypesOfFieldOrMethodDescriptor(cm,methodDescriptor);
parameterTypes=new ArrayList();
for (int k=0; k < types.length - 1; k++) {
parameterTypes.add(types[k]);
}
returnType=types[types.length - 1];
}
method=bclass.getMethod(methodName,parameterTypes,returnType);
params=new Value[args];
for (int j=args - 1; j >= 0; j--) {
params[j]=Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex());
if (typeSize(typeStack.top()) == 2) {
typeStack=typeStack.pop();
typeStack=typeStack.pop();
}
 else typeStack=typeStack.pop();
}
rvalue=Jimple.v().newInterfaceInvokeExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),method,Arrays.asList(params));
if (!returnType.equals(VoidType.v())) {
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rvalue);
}
 else stmt=Jimple.v().newInvokeStmt((InvokeExpr)rvalue);
break;
}
case ByteCode.ATHROW:
stmt=Jimple.v().newThrowStmt(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
break;
case ByteCode.NEW:
{
SootClass bclass=cm.getSootClass(getClassName(constant_pool,((Instruction_New)ins).arg_i));
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),Jimple.v().newNewExpr(RefType.v(bclass.getName())));
break;
}
case ByteCode.CHECKCAST:
{
String className=getClassName(constant_pool,((Instruction_Checkcast)ins).arg_i);
Type castType;
if (className.startsWith(""String_Node_Str"")) castType=Util.v().jimpleTypeOfFieldDescriptor(cm,getClassName(constant_pool,((Instruction_Checkcast)ins).arg_i));
 else castType=RefType.v(className);
rhs=Jimple.v().newCastExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),castType);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
}
case ByteCode.INSTANCEOF:
{
Type checkType;
String className=getClassName(constant_pool,((Instruction_Instanceof)ins).arg_i);
if (className.startsWith(""String_Node_Str"")) checkType=Util.v().jimpleTypeOfFieldDescriptor(cm,getClassName(constant_pool,((Instruction_Instanceof)ins).arg_i));
 else checkType=RefType.v(className);
rhs=Jimple.v().newInstanceOfExpr(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()),checkType);
stmt=Jimple.v().newAssignStmt(Util.v().getLocalForStackOp(listBody,postTypeStack,postTypeStack.topIndex()),rhs);
break;
}
case ByteCode.MONITORENTER:
stmt=Jimple.v().newEnterMonitorStmt(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
break;
case ByteCode.MONITOREXIT:
stmt=Jimple.v().newExitMonitorStmt(Util.v().getLocalForStackOp(listBody,typeStack,typeStack.topIndex()));
break;
default :
throw new RuntimeException(""String_Node_Str"" + x);
}
if (stmt != null) {
if (Options.v().keep_offset()) {
stmt.addTag(new BytecodeOffsetTag(ins.label));
}
statements.add(stmt);
}
}"
88779,"/** 
 * If a node has an empty in set, it is considered unreachable. Otherwise the node is examined and if any assumptions have to be corrected, a Pair containing the corrected assumptions is flowed to the reachable nodes.  If no assumptions have to be corrected then no information other than the in set is propagated to the reachable nodes. <p> Pair serves no other purpose than to keep the analysis flowing for as long as needed.  The final results are accumulated in the localToConstant map.
 */
protected void flowThrough(Object in,Unit s,List fallOut,List branchOuts){
  FlowSet fin=(FlowSet)((FlowSet)in).clone();
  if (fin.isEmpty())   return;
  Pair pair=processDefinitionStmt(s);
  if (pair != null)   fin.add(pair);
  if (!s.branches() && s.fallsThrough()) {
    Iterator fallOutIt=fallOut.iterator();
    while (fallOutIt.hasNext()) {
      FlowSet fallSet=(FlowSet)fallOutIt.next();
      fallSet.union(fin);
    }
    return;
  }
  boolean conservative=true;
  boolean fall=false;
  boolean branch=false;
  FlowSet oneBranch=null;
  IFSTMT: {
    if (s instanceof IfStmt) {
      IfStmt ifStmt=(IfStmt)s;
      Value cond=ifStmt.getCondition();
      Constant constant=SEvaluator.getFuzzyConstantValueOf(cond,localToConstant);
      if (constant instanceof BottomConstant)       break IFSTMT;
      if (constant instanceof TopConstant)       return;
      conservative=false;
      Constant trueC=IntConstant.v(1);
      Constant falseC=IntConstant.v(0);
      if (constant.equals(trueC)) {
        branch=true;
        GotoStmt gotoStmt=Jimple.v().newGotoStmt(ifStmt.getTargetBox());
        stmtToReplacement.put(ifStmt,gotoStmt);
      }
      if (constant.equals(falseC)) {
        fall=true;
        deadStmts.add(ifStmt);
      }
    }
  }
  TABLESWITCHSTMT: {
    if (s instanceof TableSwitchStmt) {
      TableSwitchStmt table=(TableSwitchStmt)s;
      Value keyV=table.getKey();
      Constant keyC=SEvaluator.getFuzzyConstantValueOf(keyV,localToConstant);
      if (keyC instanceof BottomConstant)       break TABLESWITCHSTMT;
      if (keyC instanceof TopConstant)       return;
      if (!(keyC instanceof IntConstant))       break TABLESWITCHSTMT;
      conservative=false;
      int key=((IntConstant)keyC).value;
      int low=table.getLowIndex();
      int high=table.getHighIndex();
      int index=key - low;
      UnitBox branchBox=null;
      if (index < 0 || index > high)       branchBox=table.getDefaultTargetBox();
 else       branchBox=table.getTargetBox(index);
      GotoStmt gotoStmt=Jimple.v().newGotoStmt(branchBox);
      stmtToReplacement.put(table,gotoStmt);
      List unitBoxes=table.getUnitBoxes();
      int setIndex=unitBoxes.indexOf(branchBox);
      oneBranch=(FlowSet)branchOuts.get(setIndex);
    }
  }
  LOOKUPSWITCHSTMT: {
    if (s instanceof LookupSwitchStmt) {
      LookupSwitchStmt lookup=(LookupSwitchStmt)s;
      Value keyV=lookup.getKey();
      Constant keyC=SEvaluator.getFuzzyConstantValueOf(keyV,localToConstant);
      if (keyC instanceof BottomConstant)       break LOOKUPSWITCHSTMT;
      if (keyC instanceof TopConstant)       return;
      if (!(keyC instanceof IntConstant))       break LOOKUPSWITCHSTMT;
      conservative=false;
      int index=lookup.getLookupValues().indexOf(keyC);
      UnitBox branchBox=null;
      if (index == -1)       branchBox=lookup.getDefaultTargetBox();
 else       branchBox=lookup.getTargetBox(index);
      GotoStmt gotoStmt=Jimple.v().newGotoStmt(branchBox);
      stmtToReplacement.put(lookup,gotoStmt);
      List unitBoxes=lookup.getUnitBoxes();
      int setIndex=unitBoxes.indexOf(branchBox);
      oneBranch=(FlowSet)branchOuts.get(setIndex);
    }
  }
  if (conservative) {
    fall=s.fallsThrough();
    branch=s.branches();
  }
  if (fall) {
    Iterator fallOutIt=fallOut.iterator();
    while (fallOutIt.hasNext()) {
      FlowSet fallSet=(FlowSet)fallOutIt.next();
      fallSet.union(fin);
    }
  }
  if (branch) {
    Iterator branchOutsIt=branchOuts.iterator();
    while (branchOutsIt.hasNext()) {
      FlowSet branchSet=(FlowSet)branchOutsIt.next();
      branchSet.union(fin);
    }
  }
  if (oneBranch != null) {
    oneBranch.union(fin);
  }
}","/** 
 * If a node has an empty in set, it is considered unreachable. Otherwise the node is examined and if any assumptions have to be corrected, a Pair containing the corrected assumptions is flowed to the reachable nodes.  If no assumptions have to be corrected then no information other than the in set is propagated to the reachable nodes. <p> Pair serves no other purpose than to keep the analysis flowing for as long as needed.  The final results are accumulated in the localToConstant map.
 */
protected void flowThrough(Object in,Unit s,List fallOut,List branchOuts){
  FlowSet fin=(FlowSet)((FlowSet)in).clone();
  if (fin.isEmpty())   return;
  Pair pair=processDefinitionStmt(s);
  if (pair != null)   fin.add(pair);
  if (!s.branches() && s.fallsThrough()) {
    Iterator fallOutIt=fallOut.iterator();
    while (fallOutIt.hasNext()) {
      FlowSet fallSet=(FlowSet)fallOutIt.next();
      fallSet.union(fin);
    }
    return;
  }
  boolean conservative=true;
  boolean fall=false;
  boolean branch=false;
  FlowSet oneBranch=null;
  IFSTMT: {
    if (s instanceof IfStmt) {
      IfStmt ifStmt=(IfStmt)s;
      Value cond=ifStmt.getCondition();
      Constant constant=SEvaluator.getFuzzyConstantValueOf(cond,localToConstant);
      if (constant instanceof BottomConstant) {
        deadStmts.remove(ifStmt);
        stmtToReplacement.remove(ifStmt);
        break IFSTMT;
      }
      if (constant instanceof TopConstant)       return;
      conservative=false;
      Constant trueC=IntConstant.v(1);
      Constant falseC=IntConstant.v(0);
      if (constant.equals(trueC)) {
        branch=true;
        GotoStmt gotoStmt=Jimple.v().newGotoStmt(ifStmt.getTargetBox());
        stmtToReplacement.put(ifStmt,gotoStmt);
      }
      if (constant.equals(falseC)) {
        fall=true;
        deadStmts.add(ifStmt);
      }
    }
  }
  TABLESWITCHSTMT: {
    if (s instanceof TableSwitchStmt) {
      TableSwitchStmt table=(TableSwitchStmt)s;
      Value keyV=table.getKey();
      Constant keyC=SEvaluator.getFuzzyConstantValueOf(keyV,localToConstant);
      if (keyC instanceof BottomConstant) {
        stmtToReplacement.remove(table);
        break TABLESWITCHSTMT;
      }
      if (keyC instanceof TopConstant)       return;
      if (!(keyC instanceof IntConstant))       break TABLESWITCHSTMT;
      conservative=false;
      int key=((IntConstant)keyC).value;
      int low=table.getLowIndex();
      int high=table.getHighIndex();
      int index=key - low;
      UnitBox branchBox=null;
      if (index < 0 || index > high)       branchBox=table.getDefaultTargetBox();
 else       branchBox=table.getTargetBox(index);
      GotoStmt gotoStmt=Jimple.v().newGotoStmt(branchBox);
      stmtToReplacement.put(table,gotoStmt);
      List unitBoxes=table.getUnitBoxes();
      int setIndex=unitBoxes.indexOf(branchBox);
      oneBranch=(FlowSet)branchOuts.get(setIndex);
    }
  }
  LOOKUPSWITCHSTMT: {
    if (s instanceof LookupSwitchStmt) {
      LookupSwitchStmt lookup=(LookupSwitchStmt)s;
      Value keyV=lookup.getKey();
      Constant keyC=SEvaluator.getFuzzyConstantValueOf(keyV,localToConstant);
      if (keyC instanceof BottomConstant) {
        stmtToReplacement.remove(lookup);
        break LOOKUPSWITCHSTMT;
      }
      if (keyC instanceof TopConstant)       return;
      if (!(keyC instanceof IntConstant))       break LOOKUPSWITCHSTMT;
      conservative=false;
      int index=lookup.getLookupValues().indexOf(keyC);
      UnitBox branchBox=null;
      if (index == -1)       branchBox=lookup.getDefaultTargetBox();
 else       branchBox=lookup.getTargetBox(index);
      GotoStmt gotoStmt=Jimple.v().newGotoStmt(branchBox);
      stmtToReplacement.put(lookup,gotoStmt);
      List unitBoxes=lookup.getUnitBoxes();
      int setIndex=unitBoxes.indexOf(branchBox);
      oneBranch=(FlowSet)branchOuts.get(setIndex);
    }
  }
  if (conservative) {
    fall=s.fallsThrough();
    branch=s.branches();
  }
  if (fall) {
    Iterator fallOutIt=fallOut.iterator();
    while (fallOutIt.hasNext()) {
      FlowSet fallSet=(FlowSet)fallOutIt.next();
      fallSet.union(fin);
    }
  }
  if (branch) {
    Iterator branchOutsIt=branchOuts.iterator();
    while (branchOutsIt.hasNext()) {
      FlowSet branchSet=(FlowSet)branchOutsIt.next();
      branchSet.union(fin);
    }
  }
  if (oneBranch != null) {
    oneBranch.union(fin);
  }
}"
88780,"public Object next(){
  return next;
}","public Object next(){
  Object ret=next;
  advance();
  return ret;
}"
88781,"/** 
 * Adds an edge to the graph, returning false if it was already there. 
 */
public boolean addEdge(Node from,Node to){
  FastHierarchy fh=typeManager.getFastHierarchy();
  boolean ret=false;
  if (from instanceof VarNode) {
    if (to instanceof VarNode) {
      boolean ret1=addToMap(simple,from,to);
      ret1=addToMap(simpleInv,to,from) | ret1;
      if (ret1) {
        edgeQueue.add(from);
        edgeQueue.add(to);
        ret=true;
      }
      if (opts.simple_edges_bidirectional()) {
        boolean ret2=addToMap(simple,to,from);
        ret2=addToMap(simpleInv,from,to) | ret2;
        if (ret2) {
          edgeQueue.add(to);
          edgeQueue.add(from);
          ret=true;
        }
      }
    }
 else {
      if (!(to instanceof FieldRefNode)) {
        throw new RuntimeException(""String_Node_Str"" + from + ""String_Node_Str""+ to);
      }
      if (!opts.rta()) {
        ret=addToMap(store,from,(FieldRefNode)to) | ret;
        ret=addToMap(storeInv,to,from) | ret;
        if (ret) {
          edgeQueue.add(from);
          edgeQueue.add(to);
        }
      }
    }
  }
 else   if (from instanceof FieldRefNode) {
    if (!opts.rta()) {
      if (!(to instanceof VarNode)) {
        throw new RuntimeException(""String_Node_Str"" + from + ""String_Node_Str""+ to);
      }
      ret=addToMap(load,from,to) | ret;
      ret=addToMap(loadInv,to,from) | ret;
      if (ret) {
        edgeQueue.add(from);
        edgeQueue.add(to);
      }
    }
  }
 else {
    if (!(from instanceof AllocNode) || !(to instanceof VarNode)) {
      throw new RuntimeException(""String_Node_Str"" + from + ""String_Node_Str""+ to);
    }
    if (fh == null || to.getType() == null || fh.canStoreType(from.getType(),to.getType())) {
      ret=addToMap(alloc,from,to) | ret;
      ret=addToMap(allocInv,to,from) | ret;
      if (ret) {
        edgeQueue.add(from);
        edgeQueue.add(to);
      }
    }
  }
  return ret;
}","/** 
 * Adds an edge to the graph, returning false if it was already there. 
 */
public boolean addEdge(Node from,Node to){
  FastHierarchy fh=typeManager.getFastHierarchy();
  boolean ret=false;
  from=from.getReplacement();
  to=to.getReplacement();
  if (from instanceof VarNode) {
    if (to instanceof VarNode) {
      boolean ret1=addToMap(simple,from,to);
      ret1=addToMap(simpleInv,to,from) | ret1;
      if (ret1) {
        edgeQueue.add(from);
        edgeQueue.add(to);
        ret=true;
      }
      if (opts.simple_edges_bidirectional()) {
        boolean ret2=addToMap(simple,to,from);
        ret2=addToMap(simpleInv,from,to) | ret2;
        if (ret2) {
          edgeQueue.add(to);
          edgeQueue.add(from);
          ret=true;
        }
      }
    }
 else {
      if (!(to instanceof FieldRefNode)) {
        throw new RuntimeException(""String_Node_Str"" + from + ""String_Node_Str""+ to);
      }
      if (!opts.rta()) {
        ret=addToMap(store,from,(FieldRefNode)to) | ret;
        ret=addToMap(storeInv,to,from) | ret;
        if (ret) {
          edgeQueue.add(from);
          edgeQueue.add(to);
        }
      }
    }
  }
 else   if (from instanceof FieldRefNode) {
    if (!opts.rta()) {
      if (!(to instanceof VarNode)) {
        throw new RuntimeException(""String_Node_Str"" + from + ""String_Node_Str""+ to);
      }
      ret=addToMap(load,from,to) | ret;
      ret=addToMap(loadInv,to,from) | ret;
      if (ret) {
        edgeQueue.add(from);
        edgeQueue.add(to);
      }
    }
  }
 else {
    if (!(from instanceof AllocNode) || !(to instanceof VarNode)) {
      throw new RuntimeException(""String_Node_Str"" + from + ""String_Node_Str""+ to);
    }
    if (fh == null || to.getType() == null || fh.canStoreType(from.getType(),to.getType())) {
      ret=addToMap(alloc,from,to) | ret;
      ret=addToMap(allocInv,to,from) | ret;
      if (ret) {
        edgeQueue.add(from);
        edgeQueue.add(to);
      }
    }
  }
  return ret;
}"
88782,"/** 
 * Propagates new points-to information of node src to all its successors. 
 */
protected final boolean handleVarNode(final VarNode src){
  boolean ret=false;
  if (src.getReplacement() != src)   throw new RuntimeException(""String_Node_Str"" + src + ""String_Node_Str""+ src.getReplacement());
  final PointsToSetInternal newP2Set=src.getP2Set().getNewSet();
  if (newP2Set.isEmpty())   return false;
  if (ofcg != null) {
    QueueReader addedEdges=pag.edgeReader();
    if (ofcg.wantReachingTypes(src)) {
      newP2Set.forall(new P2SetVisitor(){
        public final void visit(        Node n){
          ofcg.addReachingType(n.getType());
        }
      }
);
    }
    ofcg.doneReachingTypes();
    if (ofcg.wantStringConstants(src)) {
      Set constants=newP2Set.possibleStringConstants();
      if (constants == null) {
        ofcg.newStringConstant(src,null);
      }
 else {
        for (Iterator constantIt=constants.iterator(); constantIt.hasNext(); ) {
          final String constant=(String)constantIt.next();
          ofcg.newStringConstant(src,constant);
        }
      }
    }
    ofcg.doneStringConstants();
    while (true) {
      Node addedSrc=(Node)addedEdges.next();
      if (addedSrc == null)       break;
      Node addedTgt=(Node)addedEdges.next();
      ret=true;
      if (addedSrc instanceof VarNode) {
        if (addedTgt instanceof VarNode) {
          VarNode edgeSrc=(VarNode)addedSrc;
          VarNode edgeTgt=(VarNode)addedTgt;
          if (edgeTgt.makeP2Set().addAll(edgeSrc.getP2Set(),null))           varNodeWorkList.add(edgeTgt);
        }
      }
 else       if (addedSrc instanceof AllocNode) {
        AllocNode edgeSrc=(AllocNode)addedSrc;
        VarNode edgeTgt=(VarNode)addedTgt;
        if (edgeTgt.makeP2Set().add(edgeSrc))         varNodeWorkList.add(edgeTgt);
      }
    }
  }
  Node[] simpleTargets=pag.simpleLookup(src);
  for (int i=0; i < simpleTargets.length; i++) {
    if (simpleTargets[i].makeP2Set().addAll(newP2Set,null)) {
      varNodeWorkList.add((VarNode)simpleTargets[i]);
      ret=true;
    }
  }
  Node[] storeTargets=pag.storeLookup(src);
  for (int i=0; i < storeTargets.length; i++) {
    final FieldRefNode fr=(FieldRefNode)storeTargets[i];
    final SparkField f=fr.getField();
    ret=fr.getBase().getP2Set().forall(new P2SetVisitor(){
      public final void visit(      Node n){
        AllocDotField nDotF=pag.makeAllocDotField((AllocNode)n,f);
        if (nDotF.makeP2Set().addAll(newP2Set,null)) {
          returnValue=true;
        }
      }
    }
) | ret;
  }
  final HashSet storesToPropagate=new HashSet();
  final HashSet loadsToPropagate=new HashSet();
  Collection fieldRefs=src.getAllFieldRefs();
  for (Iterator frIt=fieldRefs.iterator(); frIt.hasNext(); ) {
    final FieldRefNode fr=(FieldRefNode)frIt.next();
    final SparkField field=fr.getField();
    final Node[] storeSources=pag.storeInvLookup(fr);
    if (storeSources.length > 0) {
      newP2Set.forall(new P2SetVisitor(){
        public final void visit(        Node n){
          AllocDotField nDotF=pag.makeAllocDotField((AllocNode)n,field);
          for (int i=0; i < storeSources.length; i++) {
            Node[] pair={storeSources[i],nDotF.getReplacement()};
            storesToPropagate.add(pair);
          }
        }
      }
);
    }
    final Node[] loadTargets=pag.loadLookup(fr);
    if (loadTargets.length > 0) {
      newP2Set.forall(new P2SetVisitor(){
        public final void visit(        Node n){
          AllocDotField nDotF=pag.findAllocDotField((AllocNode)n,field);
          if (nDotF != null) {
            for (int i=0; i < loadTargets.length; i++) {
              Node[] pair={nDotF.getReplacement(),loadTargets[i]};
              loadsToPropagate.add(pair);
            }
          }
        }
      }
);
    }
  }
  src.getP2Set().flushNew();
  for (Iterator pIt=storesToPropagate.iterator(); pIt.hasNext(); ) {
    final Node[] p=(Node[])pIt.next();
    VarNode storeSource=(VarNode)p[0];
    AllocDotField nDotF=(AllocDotField)p[1];
    if (nDotF.makeP2Set().addAll(storeSource.getP2Set(),null)) {
      ret=true;
    }
  }
  for (Iterator pIt=loadsToPropagate.iterator(); pIt.hasNext(); ) {
    final Node[] p=(Node[])pIt.next();
    AllocDotField nDotF=(AllocDotField)p[0];
    VarNode loadTarget=(VarNode)p[1];
    if (loadTarget.makeP2Set().addAll(nDotF.getP2Set(),null)) {
      varNodeWorkList.add(loadTarget);
      ret=true;
    }
  }
  return ret;
}","/** 
 * Propagates new points-to information of node src to all its successors. 
 */
protected final boolean handleVarNode(final VarNode src){
  boolean ret=false;
  if (src.getReplacement() != src)   throw new RuntimeException(""String_Node_Str"" + src + ""String_Node_Str""+ src.getReplacement());
  final PointsToSetInternal newP2Set=src.getP2Set().getNewSet();
  if (newP2Set.isEmpty())   return false;
  if (ofcg != null) {
    QueueReader addedEdges=pag.edgeReader();
    if (ofcg.wantReachingTypes(src)) {
      newP2Set.forall(new P2SetVisitor(){
        public final void visit(        Node n){
          ofcg.addReachingType(n.getType());
        }
      }
);
    }
    ofcg.doneReachingTypes();
    if (ofcg.wantStringConstants(src)) {
      Set constants=newP2Set.possibleStringConstants();
      if (constants == null) {
        ofcg.newStringConstant(src,null);
      }
 else {
        for (Iterator constantIt=constants.iterator(); constantIt.hasNext(); ) {
          final String constant=(String)constantIt.next();
          ofcg.newStringConstant(src,constant);
        }
      }
    }
    ofcg.doneStringConstants();
    while (true) {
      Node addedSrc=(Node)addedEdges.next();
      if (addedSrc == null)       break;
      Node addedTgt=(Node)addedEdges.next();
      ret=true;
      if (addedSrc instanceof VarNode) {
        if (addedTgt instanceof VarNode) {
          VarNode edgeSrc=(VarNode)addedSrc.getReplacement();
          VarNode edgeTgt=(VarNode)addedTgt.getReplacement();
          if (edgeTgt.makeP2Set().addAll(edgeSrc.getP2Set(),null))           varNodeWorkList.add(edgeTgt);
        }
      }
 else       if (addedSrc instanceof AllocNode) {
        AllocNode edgeSrc=(AllocNode)addedSrc;
        VarNode edgeTgt=(VarNode)addedTgt.getReplacement();
        if (edgeTgt.makeP2Set().add(edgeSrc))         varNodeWorkList.add(edgeTgt);
      }
    }
  }
  Node[] simpleTargets=pag.simpleLookup(src);
  for (int i=0; i < simpleTargets.length; i++) {
    if (simpleTargets[i].makeP2Set().addAll(newP2Set,null)) {
      varNodeWorkList.add((VarNode)simpleTargets[i]);
      ret=true;
    }
  }
  Node[] storeTargets=pag.storeLookup(src);
  for (int i=0; i < storeTargets.length; i++) {
    final FieldRefNode fr=(FieldRefNode)storeTargets[i];
    final SparkField f=fr.getField();
    ret=fr.getBase().getP2Set().forall(new P2SetVisitor(){
      public final void visit(      Node n){
        AllocDotField nDotF=pag.makeAllocDotField((AllocNode)n,f);
        if (nDotF.makeP2Set().addAll(newP2Set,null)) {
          returnValue=true;
        }
      }
    }
) | ret;
  }
  final HashSet storesToPropagate=new HashSet();
  final HashSet loadsToPropagate=new HashSet();
  Collection fieldRefs=src.getAllFieldRefs();
  for (Iterator frIt=fieldRefs.iterator(); frIt.hasNext(); ) {
    final FieldRefNode fr=(FieldRefNode)frIt.next();
    final SparkField field=fr.getField();
    final Node[] storeSources=pag.storeInvLookup(fr);
    if (storeSources.length > 0) {
      newP2Set.forall(new P2SetVisitor(){
        public final void visit(        Node n){
          AllocDotField nDotF=pag.makeAllocDotField((AllocNode)n,field);
          for (int i=0; i < storeSources.length; i++) {
            Node[] pair={storeSources[i],nDotF.getReplacement()};
            storesToPropagate.add(pair);
          }
        }
      }
);
    }
    final Node[] loadTargets=pag.loadLookup(fr);
    if (loadTargets.length > 0) {
      newP2Set.forall(new P2SetVisitor(){
        public final void visit(        Node n){
          AllocDotField nDotF=pag.findAllocDotField((AllocNode)n,field);
          if (nDotF != null) {
            for (int i=0; i < loadTargets.length; i++) {
              Node[] pair={nDotF.getReplacement(),loadTargets[i]};
              loadsToPropagate.add(pair);
            }
          }
        }
      }
);
    }
  }
  src.getP2Set().flushNew();
  for (Iterator pIt=storesToPropagate.iterator(); pIt.hasNext(); ) {
    final Node[] p=(Node[])pIt.next();
    VarNode storeSource=(VarNode)p[0];
    AllocDotField nDotF=(AllocDotField)p[1];
    if (nDotF.makeP2Set().addAll(storeSource.getP2Set(),null)) {
      ret=true;
    }
  }
  for (Iterator pIt=loadsToPropagate.iterator(); pIt.hasNext(); ) {
    final Node[] p=(Node[])pIt.next();
    AllocDotField nDotF=(AllocDotField)p[0];
    VarNode loadTarget=(VarNode)p[1];
    if (loadTarget.makeP2Set().addAll(nDotF.getP2Set(),null)) {
      varNodeWorkList.add(loadTarget);
      ret=true;
    }
  }
  return ret;
}"
88783,"/** 
 * Prints out the method corresponding to b Body, (declaration and body), in the textual format corresponding to the IR used to encode b body.
 * @param out a PrintWriter instance to print to.
 */
private void printTo(Body b,PrintWriter out){
  b.validate();
  String decl=b.getMethod().getDeclaration();
{
    out.println(""String_Node_Str"" + decl);
    for (Iterator tIt=b.getMethod().getTags().iterator(); tIt.hasNext(); ) {
      final Tag t=(Tag)tIt.next();
      out.println(t);
    }
    out.println(""String_Node_Str"");
    printLocalsInBody(b,out);
  }
  printStatementsInBody(b,out);
  out.println(""String_Node_Str"");
}","/** 
 * Prints out the method corresponding to b Body, (declaration and body), in the textual format corresponding to the IR used to encode b body.
 * @param out a PrintWriter instance to print to.
 */
private void printTo(Body b,PrintWriter out){
  b.validate();
  String decl=b.getMethod().getDavaDeclaration();
{
    out.println(""String_Node_Str"" + decl);
    for (Iterator tIt=b.getMethod().getTags().iterator(); tIt.hasNext(); ) {
      final Tag t=(Tag)tIt.next();
      out.println(t);
    }
    out.println(""String_Node_Str"");
    printLocalsInBody(b,out);
  }
  printStatementsInBody(b,out);
  out.println(""String_Node_Str"");
}"
88784,"public void run(IAction action){
  super.run(action);
  setDoNotContinue(false);
  if (getSootSelection().getType() == SootSelection.CLASSFILE_SELECTED_TYPE) {
    IClassFile cf=getSootSelection().getClassFile();
    IPackageFragmentRoot pfr=(IPackageFragmentRoot)cf.getAncestor(IJavaElement.PACKAGE_FRAGMENT_ROOT);
    IPackageFragment pf=(IPackageFragment)cf.getAncestor(IJavaElement.PACKAGE_FRAGMENT);
    setClasspathAppend(platform_location + pfr.getPath().toOSString());
    if (pf.isDefaultPackage()) {
      setToProcess(removeFileExt(cf.getElementName()));
    }
 else {
      setToProcess(pf.getElementName() + ""String_Node_Str"" + removeFileExt(cf.getElementName()));
    }
  }
 else   if (getSootSelection().getType() == SootSelection.FILE_SELECTED_TYPE) {
    IFile file=getSootSelection().getFile();
    if (file.getFileExtension().compareTo(""String_Node_Str"") == 0) {
      setClasspathAppend(platform_location + file.getParent().getFullPath().toOSString());
      setIsSrcPrec(true);
      setSrcPrec(LaunchCommands.JIMPLE_IN);
      setToProcess(removeFileExt(file.getName()));
    }
 else     if (file.getFileExtension().compareTo(""String_Node_Str"") == 0) {
      try {
        handleClassFile(file);
      }
 catch (      Exception e) {
        System.out.println(""String_Node_Str"");
      }
    }
  }
 else   if (getSootSelection().getType() == SootSelection.CU_SELECTED_TYPE) {
    ICompilationUnit cu=getSootSelection().getJavaFile();
    IPackageFragmentRoot pfr=(IPackageFragmentRoot)cu.getAncestor(IJavaElement.PACKAGE_FRAGMENT_ROOT);
    IPackageFragment pf=(IPackageFragment)cu.getAncestor(IJavaElement.PACKAGE_FRAGMENT);
    try {
      IProject proj=cu.getJavaProject().getProject();
      IFolder output=proj.getFolder(cu.getJavaProject().getOutputLocation().lastSegment());
      IPackageFragment pkf=(IPackageFragment)cu.getAncestor(IJavaElement.PACKAGE_FRAGMENT);
      IFile exists=null;
      if (pkf.isDefaultPackage()) {
        exists=output.getFile(removeFileExt(cu.getElementName()) + ""String_Node_Str"");
      }
 else {
        IFolder pkg=output.getFolder(pf.getElementName());
        exists=pkg.getFile(removeFileExt(cu.getElementName()) + ""String_Node_Str"");
      }
      if (!exists.exists()) {
        window=SootPlugin.getDefault().getWorkbench().getActiveWorkbenchWindow();
        MessageDialog noClassFound=new MessageDialog(window.getShell(),""String_Node_Str"",null,""String_Node_Str"",0,new String[]{""String_Node_Str""},0);
        noClassFound.open();
        setDoNotContinue(true);
      }
      setClasspathAppend(platform_location + cu.getJavaProject().getOutputLocation().toOSString());
    }
 catch (    CoreException e) {
    }
    if (pf.isDefaultPackage()) {
      setToProcess(removeFileExt(cu.getElementName()));
    }
 else {
      setToProcess(pf.getElementName() + ""String_Node_Str"" + removeFileExt(cu.getElementName()));
    }
  }
}","public void run(IAction action){
  super.run(action);
  setDoNotContinue(false);
  if (getSootSelection().getType() == SootSelection.CLASSFILE_SELECTED_TYPE) {
    IClassFile cf=getSootSelection().getClassFile();
    IPackageFragmentRoot pfr=(IPackageFragmentRoot)cf.getAncestor(IJavaElement.PACKAGE_FRAGMENT_ROOT);
    IPackageFragment pf=(IPackageFragment)cf.getAncestor(IJavaElement.PACKAGE_FRAGMENT);
    setClasspathAppend(platform_location + pfr.getPath().toOSString());
    if (pf.isDefaultPackage()) {
      setToProcess(removeFileExt(cf.getElementName()));
    }
 else {
      setToProcess(pf.getElementName() + ""String_Node_Str"" + removeFileExt(cf.getElementName()));
    }
  }
 else   if (getSootSelection().getType() == SootSelection.FILE_SELECTED_TYPE) {
    IFile file=getSootSelection().getFile();
    if (file.getFileExtension().compareTo(""String_Node_Str"") == 0) {
      setClasspathAppend(platform_location + file.getParent().getFullPath().toOSString());
      setIsSrcPrec(true);
      setSrcPrec(LaunchCommands.JIMPLE_IN);
      setToProcess(removeFileExt(file.getName()));
    }
 else     if (file.getFileExtension().compareTo(""String_Node_Str"") == 0) {
      try {
        handleClassFile(file);
      }
 catch (      Exception e) {
        System.out.println(""String_Node_Str"");
      }
    }
  }
 else   if (getSootSelection().getType() == SootSelection.CU_SELECTED_TYPE) {
    ICompilationUnit cu=getSootSelection().getJavaFile();
    IPackageFragmentRoot pfr=(IPackageFragmentRoot)cu.getAncestor(IJavaElement.PACKAGE_FRAGMENT_ROOT);
    IPackageFragment pf=(IPackageFragment)cu.getAncestor(IJavaElement.PACKAGE_FRAGMENT);
    try {
      IProject proj=cu.getJavaProject().getProject();
      IFolder output=proj.getFolder(cu.getJavaProject().getOutputLocation().lastSegment());
      IPackageFragment pkf=(IPackageFragment)cu.getAncestor(IJavaElement.PACKAGE_FRAGMENT);
      IFile exists=null;
      if (pkf.isDefaultPackage()) {
        exists=output.getFile(removeFileExt(cu.getElementName()) + ""String_Node_Str"");
        System.out.println(""String_Node_Str"" + exists.getLocation().toOSString());
      }
 else {
        IFolder pkg=output.getFolder(dotsToSlashes(pf.getElementName()));
        System.out.println(""String_Node_Str"" + pkg.getLocation().toOSString());
        System.out.println(""String_Node_Str"" + pf.getPath().toOSString());
        if (pkg.exists()) {
          System.out.println(""String_Node_Str"");
        }
        exists=pkg.getFile(removeFileExt(cu.getElementName()) + ""String_Node_Str"");
        System.out.println(""String_Node_Str"" + exists.getLocation().toOSString());
      }
      if (!exists.exists()) {
        window=SootPlugin.getDefault().getWorkbench().getActiveWorkbenchWindow();
        MessageDialog noClassFound=new MessageDialog(window.getShell(),""String_Node_Str"",null,""String_Node_Str"",0,new String[]{""String_Node_Str""},0);
        noClassFound.open();
        setDoNotContinue(true);
      }
      setClasspathAppend(platform_location + cu.getJavaProject().getOutputLocation().toOSString());
    }
 catch (    CoreException e) {
    }
    if (pf.isDefaultPackage()) {
      setToProcess(removeFileExt(cu.getElementName()));
    }
 else {
      setToProcess(pf.getElementName() + ""String_Node_Str"" + removeFileExt(cu.getElementName()));
    }
  }
}"
88785,"public void addType(Type t){
  for (Iterator vcsIt=currentvcss.iterator(); vcsIt.hasNext(); ) {
    final VirtualCallSite vcs=(VirtualCallSite)vcsIt.next();
    VirtualCalls.v().resolve(t,vcs.getInstanceInvokeExpr(),vcs.getContainer(),targetsQueue);
    while (true) {
      SootMethod target=(SootMethod)targets.next();
      if (target == null)       break;
      cg.addEdge(new Edge(vcs.getContainer(),vcs.getStmt(),target));
    }
    if (vcs.getInstanceInvokeExpr().getMethod().getNumberedSubSignature() == sigStart) {
      VirtualCalls.v().resolve(t,vcs.getInstanceInvokeExpr(),vcs.getContainer(),targetsQueue);
      while (true) {
        SootMethod target=(SootMethod)targets.next();
        if (target == null)         break;
        cg.addEdge(new Edge(vcs.getContainer(),vcs.getStmt(),target,Edge.THREAD));
      }
    }
  }
}","public void addType(Type t){
  for (Iterator vcsIt=currentvcss.iterator(); vcsIt.hasNext(); ) {
    final VirtualCallSite vcs=(VirtualCallSite)vcsIt.next();
    VirtualCalls.v().resolve(t,vcs.getInstanceInvokeExpr(),vcs.getContainer(),targetsQueue);
    while (true) {
      SootMethod target=(SootMethod)targets.next();
      if (target == null)       break;
      cg.addEdge(new Edge(vcs.getContainer(),vcs.getStmt(),target));
    }
    if (vcs.getInstanceInvokeExpr().getMethod().getNumberedSubSignature() == sigStart) {
      VirtualCalls.v().resolveThread(t,vcs.getInstanceInvokeExpr(),vcs.getContainer(),targetsQueue);
      while (true) {
        SootMethod target=(SootMethod)targets.next();
        if (target == null)         break;
        cg.addEdge(new Edge(vcs.getContainer(),vcs.getStmt(),target,Edge.THREAD));
      }
    }
  }
}"
88786,"private void initUnitSets(){
  int cap=graph.size() * 2 + 1;
  float load=0.7f;
  unitToGenerateSet=new HashMap(cap,load);
  unitToPreserveSet=new HashMap(cap,load);
  unitToAnalyzedChecksSet=new HashMap(cap,load);
  unitToArrayRefChecksSet=new HashMap(cap,load);
  unitToInstanceFieldRefChecksSet=new HashMap(cap,load);
  unitToInstanceInvokeExprChecksSet=new HashMap(cap,load);
  unitToLengthExprChecksSet=new HashMap(cap,load);
  Iterator unitIt=graph.iterator();
  while (unitIt.hasNext()) {
    Unit s=(Unit)unitIt.next();
    FlowSet genSet=(FlowSet)emptySet.clone();
    FlowSet preSet=(FlowSet)fullSet.clone();
    HashSet analyzedChecksSet=new HashSet(5,load);
    HashSet arrayRefChecksSet=new HashSet(5,load);
    HashSet instanceFieldRefChecksSet=new HashSet(5,load);
    HashSet instanceInvokeExprChecksSet=new HashSet(5,load);
    HashSet lengthExprChecksSet=new HashSet(5,load);
    if (careForMethodCalls && ((Stmt)s).containsInvokeExpr()) {
      uListAddTopToFlowSet(refTypeInstFields,genSet,preSet);
      uListAddTopToFlowSet(refTypeStaticFields,genSet,preSet);
    }
    if (careForAliases && (s instanceof AssignStmt)) {
      AssignStmt as=(AssignStmt)s;
      Value lhs=as.getLeftOp();
      if (refTypeInstFieldBases.contains(lhs)) {
        Iterator refTypeInstFieldsIt=refTypeInstFields.iterator();
        while (refTypeInstFieldsIt.hasNext()) {
          EquivalentValue eifr=(EquivalentValue)refTypeInstFieldsIt.next();
          InstanceFieldRef ifr=(InstanceFieldRef)eifr.getValue();
          if (ifr.getBase() == lhs) {
            uAddTopToFlowSet(eifr,genSet,preSet);
          }
        }
      }
      if (lhs instanceof InstanceFieldRef) {
        String lhsName=((InstanceFieldRef)lhs).getField().getName();
        Iterator refTypeInstFieldsIt=refTypeInstFields.iterator();
        while (refTypeInstFieldsIt.hasNext()) {
          EquivalentValue eifr=(EquivalentValue)refTypeInstFieldsIt.next();
          InstanceFieldRef ifr=(InstanceFieldRef)eifr.getValue();
          String name=ifr.getField().getName();
          if (name.equals(lhsName)) {
            uAddTopToFlowSet(eifr,genSet,preSet);
          }
        }
      }
    }
{
      Iterator boxIt=s.getDefBoxes().iterator();
      while (boxIt.hasNext()) {
        ValueBox box=(ValueBox)boxIt.next();
        Value boxValue=box.getValue();
        if (isAnalyzedRef(boxValue)) {
          uAddTopToFlowSet(boxValue,genSet,preSet);
        }
      }
    }
    if (s instanceof DefinitionStmt) {
      DefinitionStmt as=(DefinitionStmt)s;
      Value ro=as.getRightOp();
      Value lo=as.getLeftOp();
      if (ro instanceof CastExpr)       ro=((CastExpr)ro).getOp();
      if (isAnalyzedRef(lo)) {
        if (ro instanceof NewExpr || ro instanceof NewArrayExpr || ro instanceof NewMultiArrayExpr|| ro instanceof ThisRef|| ro instanceof CaughtExceptionRef) {
          uAddInfoToFlowSet(lo,kNonNull,genSet,preSet);
        }
 else         if (isAlwaysNull(ro)) {
          uAddInfoToFlowSet(lo,kNull,genSet,preSet);
        }
 else         if (isAlwaysTop(ro)) {
          uAddTopToFlowSet(lo,genSet,preSet);
        }
      }
    }
{
      Iterator boxIt;
      boxIt=s.getUseBoxes().iterator();
      while (boxIt.hasNext()) {
        Value boxValue=((ValueBox)boxIt.next()).getValue();
        Value base=null;
        if (boxValue instanceof InstanceFieldRef) {
          base=((InstanceFieldRef)(boxValue)).getBase();
          instanceFieldRefChecksSet.add(base);
        }
 else         if (boxValue instanceof ArrayRef) {
          base=((ArrayRef)(boxValue)).getBase();
          arrayRefChecksSet.add(base);
        }
 else         if (boxValue instanceof InstanceInvokeExpr) {
          base=((InstanceInvokeExpr)boxValue).getBase();
          instanceInvokeExprChecksSet.add(base);
        }
 else         if (boxValue instanceof LengthExpr) {
          base=((LengthExpr)boxValue).getOp();
          lengthExprChecksSet.add(base);
        }
 else         if (s instanceof ThrowStmt) {
          base=((ThrowStmt)s).getOp();
        }
 else         if (s instanceof MonitorStmt) {
          base=((MonitorStmt)s).getOp();
        }
        if (base != null && isAnalyzedRef(base)) {
          uAddInfoToFlowSet(base,kNonNull,genSet,preSet);
          analyzedChecksSet.add(base);
        }
      }
      boxIt=s.getDefBoxes().iterator();
      while (boxIt.hasNext()) {
        Value boxValue=((ValueBox)boxIt.next()).getValue();
        Value base=null;
        if (boxValue instanceof InstanceFieldRef) {
          base=((InstanceFieldRef)(boxValue)).getBase();
          instanceFieldRefChecksSet.add(base);
        }
 else         if (boxValue instanceof ArrayRef) {
          base=((ArrayRef)(boxValue)).getBase();
          arrayRefChecksSet.add(base);
        }
 else         if (boxValue instanceof InstanceInvokeExpr) {
          base=((InstanceInvokeExpr)boxValue).getBase();
          instanceInvokeExprChecksSet.add(base);
        }
 else         if (boxValue instanceof LengthExpr) {
          base=((LengthExpr)boxValue).getOp();
          lengthExprChecksSet.add(base);
        }
 else         if (s instanceof ThrowStmt) {
          base=((ThrowStmt)s).getOp();
        }
 else         if (s instanceof MonitorStmt) {
          base=((MonitorStmt)s).getOp();
        }
        if (base != null && isAnalyzedRef(base)) {
          uAddInfoToFlowSet(base,kNonNull,genSet,preSet);
          analyzedChecksSet.add(base);
        }
      }
    }
    unitToGenerateSet.put(s,genSet);
    unitToPreserveSet.put(s,preSet);
    unitToAnalyzedChecksSet.put(s,analyzedChecksSet);
    unitToArrayRefChecksSet.put(s,arrayRefChecksSet);
    unitToInstanceFieldRefChecksSet.put(s,instanceFieldRefChecksSet);
    unitToInstanceInvokeExprChecksSet.put(s,instanceInvokeExprChecksSet);
    unitToLengthExprChecksSet.put(s,lengthExprChecksSet);
  }
}","private void initUnitSets(){
  int cap=graph.size() * 2 + 1;
  float load=0.7f;
  unitToGenerateSet=new HashMap(cap,load);
  unitToPreserveSet=new HashMap(cap,load);
  unitToAnalyzedChecksSet=new HashMap(cap,load);
  unitToArrayRefChecksSet=new HashMap(cap,load);
  unitToInstanceFieldRefChecksSet=new HashMap(cap,load);
  unitToInstanceInvokeExprChecksSet=new HashMap(cap,load);
  unitToLengthExprChecksSet=new HashMap(cap,load);
  Iterator unitIt=graph.iterator();
  while (unitIt.hasNext()) {
    Unit s=(Unit)unitIt.next();
    FlowSet genSet=(FlowSet)emptySet.clone();
    FlowSet preSet=(FlowSet)fullSet.clone();
    HashSet analyzedChecksSet=new HashSet(5,load);
    HashSet arrayRefChecksSet=new HashSet(5,load);
    HashSet instanceFieldRefChecksSet=new HashSet(5,load);
    HashSet instanceInvokeExprChecksSet=new HashSet(5,load);
    HashSet lengthExprChecksSet=new HashSet(5,load);
    if (careForMethodCalls && ((Stmt)s).containsInvokeExpr()) {
      uListAddTopToFlowSet(refTypeInstFields,genSet,preSet);
      uListAddTopToFlowSet(refTypeStaticFields,genSet,preSet);
    }
    if (careForAliases && (s instanceof AssignStmt)) {
      AssignStmt as=(AssignStmt)s;
      Value lhs=as.getLeftOp();
      if (refTypeInstFieldBases.contains(lhs)) {
        Iterator refTypeInstFieldsIt=refTypeInstFields.iterator();
        while (refTypeInstFieldsIt.hasNext()) {
          EquivalentValue eifr=(EquivalentValue)refTypeInstFieldsIt.next();
          InstanceFieldRef ifr=(InstanceFieldRef)eifr.getValue();
          if (ifr.getBase() == lhs) {
            uAddTopToFlowSet(eifr,genSet,preSet);
          }
        }
      }
      if (lhs instanceof InstanceFieldRef) {
        String lhsName=((InstanceFieldRef)lhs).getField().getName();
        Iterator refTypeInstFieldsIt=refTypeInstFields.iterator();
        while (refTypeInstFieldsIt.hasNext()) {
          EquivalentValue eifr=(EquivalentValue)refTypeInstFieldsIt.next();
          InstanceFieldRef ifr=(InstanceFieldRef)eifr.getValue();
          String name=ifr.getField().getName();
          if (name.equals(lhsName)) {
            uAddTopToFlowSet(eifr,genSet,preSet);
          }
        }
      }
    }
{
      Iterator boxIt=s.getDefBoxes().iterator();
      while (boxIt.hasNext()) {
        ValueBox box=(ValueBox)boxIt.next();
        Value boxValue=box.getValue();
        if (isAnalyzedRef(boxValue)) {
          uAddTopToFlowSet(boxValue,genSet,preSet);
        }
      }
    }
    if (s instanceof DefinitionStmt) {
      DefinitionStmt as=(DefinitionStmt)s;
      Value ro=as.getRightOp();
      Value lo=as.getLeftOp();
      if (ro instanceof CastExpr)       ro=((CastExpr)ro).getOp();
      if (isAnalyzedRef(lo)) {
        if (isAlwaysNonNull(ro)) {
          uAddInfoToFlowSet(lo,kNonNull,genSet,preSet);
        }
 else         if (isAlwaysNull(ro)) {
          uAddInfoToFlowSet(lo,kNull,genSet,preSet);
        }
 else         if (isAlwaysTop(ro)) {
          uAddTopToFlowSet(lo,genSet,preSet);
        }
      }
    }
{
      Iterator boxIt;
      boxIt=s.getUseBoxes().iterator();
      while (boxIt.hasNext()) {
        Value boxValue=((ValueBox)boxIt.next()).getValue();
        Value base=null;
        if (boxValue instanceof InstanceFieldRef) {
          base=((InstanceFieldRef)(boxValue)).getBase();
          instanceFieldRefChecksSet.add(base);
        }
 else         if (boxValue instanceof ArrayRef) {
          base=((ArrayRef)(boxValue)).getBase();
          arrayRefChecksSet.add(base);
        }
 else         if (boxValue instanceof InstanceInvokeExpr) {
          base=((InstanceInvokeExpr)boxValue).getBase();
          instanceInvokeExprChecksSet.add(base);
        }
 else         if (boxValue instanceof LengthExpr) {
          base=((LengthExpr)boxValue).getOp();
          lengthExprChecksSet.add(base);
        }
 else         if (s instanceof ThrowStmt) {
          base=((ThrowStmt)s).getOp();
        }
 else         if (s instanceof MonitorStmt) {
          base=((MonitorStmt)s).getOp();
        }
        if (base != null && isAnalyzedRef(base)) {
          uAddInfoToFlowSet(base,kNonNull,genSet,preSet);
          analyzedChecksSet.add(base);
        }
      }
      boxIt=s.getDefBoxes().iterator();
      while (boxIt.hasNext()) {
        Value boxValue=((ValueBox)boxIt.next()).getValue();
        Value base=null;
        if (boxValue instanceof InstanceFieldRef) {
          base=((InstanceFieldRef)(boxValue)).getBase();
          instanceFieldRefChecksSet.add(base);
        }
 else         if (boxValue instanceof ArrayRef) {
          base=((ArrayRef)(boxValue)).getBase();
          arrayRefChecksSet.add(base);
        }
 else         if (boxValue instanceof InstanceInvokeExpr) {
          base=((InstanceInvokeExpr)boxValue).getBase();
          instanceInvokeExprChecksSet.add(base);
        }
 else         if (boxValue instanceof LengthExpr) {
          base=((LengthExpr)boxValue).getOp();
          lengthExprChecksSet.add(base);
        }
 else         if (s instanceof ThrowStmt) {
          base=((ThrowStmt)s).getOp();
        }
 else         if (s instanceof MonitorStmt) {
          base=((MonitorStmt)s).getOp();
        }
        if (base != null && isAnalyzedRef(base)) {
          uAddInfoToFlowSet(base,kNonNull,genSet,preSet);
          analyzedChecksSet.add(base);
        }
      }
    }
    unitToGenerateSet.put(s,genSet);
    unitToPreserveSet.put(s,preSet);
    unitToAnalyzedChecksSet.put(s,analyzedChecksSet);
    unitToArrayRefChecksSet.put(s,arrayRefChecksSet);
    unitToInstanceFieldRefChecksSet.put(s,instanceFieldRefChecksSet);
    unitToInstanceInvokeExprChecksSet.put(s,instanceInvokeExprChecksSet);
    unitToLengthExprChecksSet.put(s,lengthExprChecksSet);
  }
}"
88787,"protected final int anyRefInfo(Value r,FlowSet f){
  if (isAlwaysNull(r))   return kNull;
 else   if (isAlwaysTop(r))   return kTop;
 else   return refInfo(r,f);
}","protected final int anyRefInfo(Value r,FlowSet f){
  if (isAlwaysNull(r))   return kNull;
 else   if (isAlwaysTop(r))   return kTop;
 else   if (isAlwaysNonNull(r))   return kNonNull;
 else   return refInfo(r,f);
}"
88788,"/** 
 * Removes the edge e from the call graph. Returns true iff the edge was originally present in the call graph. 
 */
public boolean removeEdge(Edge e){
  if (!edges.remove(e))   return false;
  e.remove();
  return true;
}","/** 
 * Removes the edge e from the call graph. Returns true iff the edge was originally present in the call graph. 
 */
public boolean removeEdge(Edge e){
  if (!edges.remove(e))   return false;
  e.remove();
  if (srcMethodToEdge.get(e.src()) == e) {
    if (e.nextBySrc().src() == e.src()) {
      srcMethodToEdge.put(e.src(),e.nextBySrc());
    }
 else {
      srcMethodToEdge.put(e.src(),null);
    }
  }
  if (srcUnitToEdge.get(e.srcUnit()) == e) {
    if (e.nextBySrc().srcUnit() == e.srcUnit()) {
      srcUnitToEdge.put(e.srcUnit(),e.nextBySrc());
    }
 else {
      srcUnitToEdge.put(e.srcUnit(),null);
    }
  }
  if (tgtToEdge.get(e.tgt()) == e) {
    if (e.nextByTgt().tgt() == e.tgt()) {
      tgtToEdge.put(e.tgt(),e.nextByTgt());
    }
 else {
      tgtToEdge.put(e.tgt(),null);
    }
  }
  return true;
}"
88789,"public void run(){
  final String[] cmdFinal=getCmd();
  final PrintStream sootOutFinal=getSootOut();
  try {
    soot.G.v().reset();
    soot.G.v().out=sootOutFinal;
    Class toRun=Class.forName(getMainClass());
    Method[] meths=toRun.getDeclaredMethods();
    Object[] args=new Object[1];
    args[0]=cmdFinal;
    for (int i=0; i < meths.length; i++) {
      if (meths[i].getName().equals(""String_Node_Str"")) {
        Class[] fields=meths[i].getParameterTypes();
        meths[i].invoke(toRun,args);
      }
    }
  }
 catch (  Exception e) {
    e.printStackTrace(sootOutFinal);
  }
}","public void run(){
  final String[] cmdFinal=getCmd();
  final PrintStream sootOutFinal=getSootOut();
  try {
    soot.G.v().reset();
    soot.G.v().out=sootOutFinal;
    Class toRun=Class.forName(getMainClass());
    Method[] meths=toRun.getDeclaredMethods();
    Object[] args=new Object[1];
    args[0]=cmdFinal;
    for (int i=0; i < meths.length; i++) {
      if (meths[i].getName().equals(""String_Node_Str"")) {
        Class[] fields=meths[i].getParameterTypes();
        if (fields.length == 1) {
          meths[i].invoke(toRun,args);
        }
      }
    }
  }
 catch (  Exception e) {
    e.printStackTrace(sootOutFinal);
  }
}"
88790,"public void getImplicitTargets(SootMethod source){
  final SootClass scl=source.getDeclaringClass();
  if (source.isNative())   return;
  if (source.getSubSignature().indexOf(""String_Node_Str"") >= 0) {
    handleInit(source,scl);
  }
  Body b=source.retrieveActiveBody();
  boolean warnedAlready=false;
  for (Iterator sIt=b.getUnits().iterator(); sIt.hasNext(); ) {
    final Stmt s=(Stmt)sIt.next();
    if (s.containsInvokeExpr()) {
      InvokeExpr ie=(InvokeExpr)s.getInvokeExpr();
      if (ie.getMethod().getSignature().equals(""String_Node_Str"")) {
        if (!warnedAlready) {
          if (options.verbose()) {
            G.v().out.println(""String_Node_Str"" + ""String_Node_Str"" + source + ""String_Node_Str"");
          }
          warnedAlready=true;
        }
      }
      if (ie.getMethod().getNumberedSubSignature() == sigForName) {
        Value name=ie.getArg(0);
        if (name instanceof StringConstant) {
          String cls=((StringConstant)name).value;
          constantForName(cls,source,s);
        }
 else {
          if (options.safe_forname()) {
            for (Iterator tgtIt=EntryPoints.v().clinits().iterator(); tgtIt.hasNext(); ) {
              final SootMethod tgt=(SootMethod)tgtIt.next();
              cg.addEdge(new Edge(source,s,tgt,Edge.CLINIT));
            }
          }
 else {
            VirtualCallSite vcs=new VirtualCallSite(s,source);
            wantedStringConstants.put(name,vcs);
            Set names=pa.reachingObjects((Local)name).possibleStringConstants();
            if (names == null) {
              handleClassName(vcs,null);
              wantedStringConstants.remove(name);
            }
 else {
              for (Iterator nameStrIt=names.iterator(); nameStrIt.hasNext(); ) {
                final String nameStr=(String)nameStrIt.next();
                handleClassName(vcs,nameStr);
              }
            }
          }
        }
      }
      addEdge(source,s,ie.getMethod().getDeclaringClass(),sigClinit,Edge.CLINIT);
    }
    if (s.containsFieldRef()) {
      FieldRef fr=(FieldRef)s.getFieldRef();
      if (fr instanceof StaticFieldRef) {
        SootClass cl=fr.getField().getDeclaringClass();
        addEdge(source,s,cl,sigClinit,Edge.CLINIT);
      }
    }
    if (s instanceof AssignStmt) {
      Value rhs=((AssignStmt)s).getRightOp();
      if (rhs instanceof NewExpr) {
        NewExpr r=(NewExpr)rhs;
        addEdge(source,s,r.getBaseType().getSootClass(),sigClinit,Edge.CLINIT);
      }
 else       if (rhs instanceof NewArrayExpr || rhs instanceof NewMultiArrayExpr) {
        Type t=rhs.getType();
        if (t instanceof ArrayType)         t=((ArrayType)t).baseType;
        if (t instanceof RefType) {
          addEdge(source,s,((RefType)t).getSootClass(),sigClinit,Edge.CLINIT);
        }
      }
    }
  }
}","public void getImplicitTargets(SootMethod source){
  final SootClass scl=source.getDeclaringClass();
  if (source.isNative())   return;
  if (source.getSubSignature().indexOf(""String_Node_Str"") >= 0) {
    handleInit(source,scl);
  }
  Body b=source.retrieveActiveBody();
  boolean warnedAlready=false;
  for (Iterator sIt=b.getUnits().iterator(); sIt.hasNext(); ) {
    final Stmt s=(Stmt)sIt.next();
    if (s.containsInvokeExpr()) {
      InvokeExpr ie=(InvokeExpr)s.getInvokeExpr();
      if (ie.getMethod().getSignature().equals(""String_Node_Str"")) {
        if (!warnedAlready) {
          if (options.verbose()) {
            G.v().out.println(""String_Node_Str"" + ""String_Node_Str"" + source + ""String_Node_Str"");
          }
          warnedAlready=true;
        }
      }
      if (ie instanceof StaticInvokeExpr) {
        addEdge(source,s,ie.getMethod().getDeclaringClass(),sigClinit,Edge.CLINIT);
      }
      if (ie.getMethod().getNumberedSubSignature() == sigForName) {
        Value name=ie.getArg(0);
        if (name instanceof StringConstant) {
          String cls=((StringConstant)name).value;
          constantForName(cls,source,s);
        }
 else {
          if (options.safe_forname()) {
            for (Iterator tgtIt=EntryPoints.v().clinits().iterator(); tgtIt.hasNext(); ) {
              final SootMethod tgt=(SootMethod)tgtIt.next();
              cg.addEdge(new Edge(source,s,tgt,Edge.CLINIT));
            }
          }
 else {
            VirtualCallSite vcs=new VirtualCallSite(s,source);
            wantedStringConstants.put(name,vcs);
            Set names=pa.reachingObjects((Local)name).possibleStringConstants();
            if (names == null) {
              handleClassName(vcs,null);
              wantedStringConstants.remove(name);
            }
 else {
              for (Iterator nameStrIt=names.iterator(); nameStrIt.hasNext(); ) {
                final String nameStr=(String)nameStrIt.next();
                handleClassName(vcs,nameStr);
              }
            }
          }
        }
      }
    }
    if (s.containsFieldRef()) {
      FieldRef fr=(FieldRef)s.getFieldRef();
      if (fr instanceof StaticFieldRef) {
        SootClass cl=fr.getField().getDeclaringClass();
        addEdge(source,s,cl,sigClinit,Edge.CLINIT);
      }
    }
    if (s instanceof AssignStmt) {
      Value rhs=((AssignStmt)s).getRightOp();
      if (rhs instanceof NewExpr) {
        NewExpr r=(NewExpr)rhs;
        addEdge(source,s,r.getBaseType().getSootClass(),sigClinit,Edge.CLINIT);
      }
 else       if (rhs instanceof NewArrayExpr || rhs instanceof NewMultiArrayExpr) {
        Type t=rhs.getType();
        if (t instanceof ArrayType)         t=((ArrayType)t).baseType;
        if (t instanceof RefType) {
          addEdge(source,s,((RefType)t).getSootClass(),sigClinit,Edge.CLINIT);
        }
      }
    }
  }
}"
88791,"public boolean parse(String[] argv){
  for (int i=argv.length; i > 0; i--) {
    pushOptions(argv[i - 1]);
  }
  while (hasMoreOptions()) {
    String option=nextOption();
    if (option.charAt(0) != '-') {
      classes.add(option);
      continue;
    }
    while (option.charAt(0) == '-') {
      option=option.substring(1);
    }
    if (false)     ;
 else     if (false || option.equals(""String_Node_Str"") || option.equals(""String_Node_Str""))     help=true;
 else     if (false || option.equals(""String_Node_Str"") || option.equals(""String_Node_Str""))     phase_list=true;
 else     if (false || option.equals(""String_Node_Str"") || option.equals(""String_Node_Str"")) {
      if (!hasMoreOptions()) {
        G.v().out.println(""String_Node_Str"" + option);
        return false;
      }
      String value=nextOption();
      if (phase_help == null)       phase_help=new LinkedList();
      phase_help.add(value);
    }
 else     if (false || option.equals(""String_Node_Str""))     version=true;
 else     if (false || option.equals(""String_Node_Str"") || option.equals(""String_Node_Str""))     verbose=true;
 else     if (false || option.equals(""String_Node_Str""))     app=true;
 else     if (false || option.equals(""String_Node_Str"") || option.equals(""String_Node_Str""))     whole_program=true;
 else     if (false || option.equals(""String_Node_Str""))     debug=true;
 else     if (false || option.equals(""String_Node_Str"") || option.equals(""String_Node_Str"")|| option.equals(""String_Node_Str"")) {
      if (!hasMoreOptions()) {
        G.v().out.println(""String_Node_Str"" + option);
        return false;
      }
      String value=nextOption();
      if (soot_classpath.length() == 0)       soot_classpath=value;
 else {
        G.v().out.println(""String_Node_Str"" + soot_classpath + ""String_Node_Str""+ value+ ""String_Node_Str""+ option);
        return false;
      }
    }
 else     if (false || option.equals(""String_Node_Str"")) {
      if (!hasMoreOptions()) {
        G.v().out.println(""String_Node_Str"" + option);
        return false;
      }
      String value=nextOption();
      if (false)       ;
 else       if (false || value.equals(""String_Node_Str"") || value.equals(""String_Node_Str"")) {
        if (src_prec != 0 && src_prec != src_prec_class) {
          G.v().out.println(""String_Node_Str"" + option);
          return false;
        }
        src_prec=src_prec_class;
      }
 else       if (false || value.equals(""String_Node_Str"") || value.equals(""String_Node_Str"")) {
        if (src_prec != 0 && src_prec != src_prec_jimple) {
          G.v().out.println(""String_Node_Str"" + option);
          return false;
        }
        src_prec=src_prec_jimple;
      }
 else {
        G.v().out.println(""String_Node_Str"" + value + ""String_Node_Str""+ option);
        return false;
      }
    }
 else     if (false || option.equals(""String_Node_Str""))     allow_phantom_refs=true;
 else     if (false || option.equals(""String_Node_Str"") || option.equals(""String_Node_Str"")) {
      if (!hasMoreOptions()) {
        G.v().out.println(""String_Node_Str"" + option);
        return false;
      }
      String value=nextOption();
      if (output_dir.length() == 0)       output_dir=value;
 else {
        G.v().out.println(""String_Node_Str"" + output_dir + ""String_Node_Str""+ value+ ""String_Node_Str""+ option);
        return false;
      }
    }
 else     if (false || option.equals(""String_Node_Str"") || option.equals(""String_Node_Str"")) {
      if (!hasMoreOptions()) {
        G.v().out.println(""String_Node_Str"" + option);
        return false;
      }
      String value=nextOption();
      if (false)       ;
 else       if (false || value.equals(""String_Node_Str"") || value.equals(""String_Node_Str"")) {
        if (output_format != 0 && output_format != output_format_jimple) {
          G.v().out.println(""String_Node_Str"" + option);
          return false;
        }
        output_format=output_format_jimple;
      }
 else       if (false || value.equals(""String_Node_Str"") || value.equals(""String_Node_Str"")) {
        if (output_format != 0 && output_format != output_format_jimp) {
          G.v().out.println(""String_Node_Str"" + option);
          return false;
        }
        output_format=output_format_jimp;
      }
 else       if (false || value.equals(""String_Node_Str"") || value.equals(""String_Node_Str"")) {
        if (output_format != 0 && output_format != output_format_shimple) {
          G.v().out.println(""String_Node_Str"" + option);
          return false;
        }
        output_format=output_format_shimple;
      }
 else       if (false || value.equals(""String_Node_Str"") || value.equals(""String_Node_Str"")) {
        if (output_format != 0 && output_format != output_format_shimp) {
          G.v().out.println(""String_Node_Str"" + option);
          return false;
        }
        output_format=output_format_shimp;
      }
 else       if (false || value.equals(""String_Node_Str"") || value.equals(""String_Node_Str"")) {
        if (output_format != 0 && output_format != output_format_baf) {
          G.v().out.println(""String_Node_Str"" + option);
          return false;
        }
        output_format=output_format_baf;
      }
 else       if (false || value.equals(""String_Node_Str"")) {
        if (output_format != 0 && output_format != output_format_b) {
          G.v().out.println(""String_Node_Str"" + option);
          return false;
        }
        output_format=output_format_b;
      }
 else       if (false || value.equals(""String_Node_Str"") || value.equals(""String_Node_Str"")) {
        if (output_format != 0 && output_format != output_format_grimple) {
          G.v().out.println(""String_Node_Str"" + option);
          return false;
        }
        output_format=output_format_grimple;
      }
 else       if (false || value.equals(""String_Node_Str"") || value.equals(""String_Node_Str"")) {
        if (output_format != 0 && output_format != output_format_grimp) {
          G.v().out.println(""String_Node_Str"" + option);
          return false;
        }
        output_format=output_format_grimp;
      }
 else       if (false || value.equals(""String_Node_Str"") || value.equals(""String_Node_Str"")) {
        if (output_format != 0 && output_format != output_format_xml) {
          G.v().out.println(""String_Node_Str"" + option);
          return false;
        }
        output_format=output_format_xml;
      }
 else       if (false || value.equals(""String_Node_Str"") || value.equals(""String_Node_Str"")) {
        if (output_format != 0 && output_format != output_format_none) {
          G.v().out.println(""String_Node_Str"" + option);
          return false;
        }
        output_format=output_format_none;
      }
 else       if (false || value.equals(""String_Node_Str"")) {
        if (output_format != 0 && output_format != output_format_jasmin) {
          G.v().out.println(""String_Node_Str"" + option);
          return false;
        }
        output_format=output_format_jasmin;
      }
 else       if (false || value.equals(""String_Node_Str"") || value.equals(""String_Node_Str"")) {
        if (output_format != 0 && output_format != output_format_class) {
          G.v().out.println(""String_Node_Str"" + option);
          return false;
        }
        output_format=output_format_class;
      }
 else       if (false || value.equals(""String_Node_Str"") || value.equals(""String_Node_Str"")) {
        if (output_format != 0 && output_format != output_format_dava) {
          G.v().out.println(""String_Node_Str"" + option);
          return false;
        }
        output_format=output_format_dava;
      }
 else {
        G.v().out.println(""String_Node_Str"" + value + ""String_Node_Str""+ option);
        return false;
      }
    }
 else     if (false || option.equals(""String_Node_Str""))     via_grimp=true;
 else     if (false || option.equals(""String_Node_Str""))     xml_attributes=true;
 else     if (false || option.equals(""String_Node_Str"") || option.equals(""String_Node_Str"")) {
      if (!hasMoreOptions()) {
        G.v().out.println(""String_Node_Str"" + option);
        return false;
      }
      String phaseName=nextOption();
      if (!hasMoreOptions()) {
        G.v().out.println(""String_Node_Str"" + option + ""String_Node_Str""+ phaseName);
        return false;
      }
      String phaseOption=nextOption();
      if (!setPhaseOption(phaseName,phaseOption))       return false;
    }
 else     if (false || option.equals(""String_Node_Str"") || option.equals(""String_Node_Str"")) {
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
    }
 else     if (false || option.equals(""String_Node_Str"") || option.equals(""String_Node_Str"")) {
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
    }
 else     if (false || option.equals(""String_Node_Str""))     via_shimple=true;
 else     if (false || option.equals(""String_Node_Str"")) {
      if (!hasMoreOptions()) {
        G.v().out.println(""String_Node_Str"" + option);
        return false;
      }
      String value=nextOption();
      if (process_path == null)       process_path=new LinkedList();
      process_path.add(value);
    }
 else     if (false || option.equals(""String_Node_Str"") || option.equals(""String_Node_Str"")) {
      if (!hasMoreOptions()) {
        G.v().out.println(""String_Node_Str"" + option);
        return false;
      }
      String value=nextOption();
      if (include == null)       include=new LinkedList();
      include.add(value);
    }
 else     if (false || option.equals(""String_Node_Str"") || option.equals(""String_Node_Str"")) {
      if (!hasMoreOptions()) {
        G.v().out.println(""String_Node_Str"" + option);
        return false;
      }
      String value=nextOption();
      if (exclude == null)       exclude=new LinkedList();
      exclude.add(value);
    }
 else     if (false || option.equals(""String_Node_Str"")) {
      if (!hasMoreOptions()) {
        G.v().out.println(""String_Node_Str"" + option);
        return false;
      }
      String value=nextOption();
      if (dynamic_classes == null)       dynamic_classes=new LinkedList();
      dynamic_classes.add(value);
    }
 else     if (false || option.equals(""String_Node_Str"")) {
      if (!hasMoreOptions()) {
        G.v().out.println(""String_Node_Str"" + option);
        return false;
      }
      String value=nextOption();
      if (dynamic_path == null)       dynamic_path=new LinkedList();
      dynamic_path.add(value);
    }
 else     if (false || option.equals(""String_Node_Str"")) {
      if (!hasMoreOptions()) {
        G.v().out.println(""String_Node_Str"" + option);
        return false;
      }
      String value=nextOption();
      if (dynamic_package == null)       dynamic_package=new LinkedList();
      dynamic_package.add(value);
    }
 else     if (false || option.equals(""String_Node_Str""))     keep_line_number=true;
 else     if (false || option.equals(""String_Node_Str"") || option.equals(""String_Node_Str""))     keep_offset=true;
 else     if (false || option.equals(""String_Node_Str"")) {
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
    }
 else     if (false || option.equals(""String_Node_Str"")) {
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
    }
 else     if (false || option.equals(""String_Node_Str"")) {
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
    }
 else     if (false || option.equals(""String_Node_Str"")) {
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
    }
 else     if (false || option.equals(""String_Node_Str""))     time=true;
 else     if (false || option.equals(""String_Node_Str""))     subtract_gc=true;
 else {
      G.v().out.println(""String_Node_Str"" + option);
      return false;
    }
  }
  return true;
}","public boolean parse(String[] argv){
  LinkedList phaseOptions=new LinkedList();
  for (int i=argv.length; i > 0; i--) {
    pushOptions(argv[i - 1]);
  }
  while (hasMoreOptions()) {
    String option=nextOption();
    if (option.charAt(0) != '-') {
      classes.add(option);
      continue;
    }
    while (option.charAt(0) == '-') {
      option=option.substring(1);
    }
    if (false)     ;
 else     if (false || option.equals(""String_Node_Str"") || option.equals(""String_Node_Str""))     help=true;
 else     if (false || option.equals(""String_Node_Str"") || option.equals(""String_Node_Str""))     phase_list=true;
 else     if (false || option.equals(""String_Node_Str"") || option.equals(""String_Node_Str"")) {
      if (!hasMoreOptions()) {
        G.v().out.println(""String_Node_Str"" + option);
        return false;
      }
      String value=nextOption();
      if (phase_help == null)       phase_help=new LinkedList();
      phase_help.add(value);
    }
 else     if (false || option.equals(""String_Node_Str""))     version=true;
 else     if (false || option.equals(""String_Node_Str"") || option.equals(""String_Node_Str""))     verbose=true;
 else     if (false || option.equals(""String_Node_Str""))     app=true;
 else     if (false || option.equals(""String_Node_Str"") || option.equals(""String_Node_Str""))     whole_program=true;
 else     if (false || option.equals(""String_Node_Str""))     debug=true;
 else     if (false || option.equals(""String_Node_Str"") || option.equals(""String_Node_Str"")|| option.equals(""String_Node_Str"")) {
      if (!hasMoreOptions()) {
        G.v().out.println(""String_Node_Str"" + option);
        return false;
      }
      String value=nextOption();
      if (soot_classpath.length() == 0)       soot_classpath=value;
 else {
        G.v().out.println(""String_Node_Str"" + soot_classpath + ""String_Node_Str""+ value+ ""String_Node_Str""+ option);
        return false;
      }
    }
 else     if (false || option.equals(""String_Node_Str"")) {
      if (!hasMoreOptions()) {
        G.v().out.println(""String_Node_Str"" + option);
        return false;
      }
      String value=nextOption();
      if (false)       ;
 else       if (false || value.equals(""String_Node_Str"") || value.equals(""String_Node_Str"")) {
        if (src_prec != 0 && src_prec != src_prec_class) {
          G.v().out.println(""String_Node_Str"" + option);
          return false;
        }
        src_prec=src_prec_class;
      }
 else       if (false || value.equals(""String_Node_Str"") || value.equals(""String_Node_Str"")) {
        if (src_prec != 0 && src_prec != src_prec_jimple) {
          G.v().out.println(""String_Node_Str"" + option);
          return false;
        }
        src_prec=src_prec_jimple;
      }
 else {
        G.v().out.println(""String_Node_Str"" + value + ""String_Node_Str""+ option);
        return false;
      }
    }
 else     if (false || option.equals(""String_Node_Str""))     allow_phantom_refs=true;
 else     if (false || option.equals(""String_Node_Str"") || option.equals(""String_Node_Str"")) {
      if (!hasMoreOptions()) {
        G.v().out.println(""String_Node_Str"" + option);
        return false;
      }
      String value=nextOption();
      if (output_dir.length() == 0)       output_dir=value;
 else {
        G.v().out.println(""String_Node_Str"" + output_dir + ""String_Node_Str""+ value+ ""String_Node_Str""+ option);
        return false;
      }
    }
 else     if (false || option.equals(""String_Node_Str"") || option.equals(""String_Node_Str"")) {
      if (!hasMoreOptions()) {
        G.v().out.println(""String_Node_Str"" + option);
        return false;
      }
      String value=nextOption();
      if (false)       ;
 else       if (false || value.equals(""String_Node_Str"") || value.equals(""String_Node_Str"")) {
        if (output_format != 0 && output_format != output_format_jimple) {
          G.v().out.println(""String_Node_Str"" + option);
          return false;
        }
        output_format=output_format_jimple;
      }
 else       if (false || value.equals(""String_Node_Str"") || value.equals(""String_Node_Str"")) {
        if (output_format != 0 && output_format != output_format_jimp) {
          G.v().out.println(""String_Node_Str"" + option);
          return false;
        }
        output_format=output_format_jimp;
      }
 else       if (false || value.equals(""String_Node_Str"") || value.equals(""String_Node_Str"")) {
        if (output_format != 0 && output_format != output_format_shimple) {
          G.v().out.println(""String_Node_Str"" + option);
          return false;
        }
        output_format=output_format_shimple;
      }
 else       if (false || value.equals(""String_Node_Str"") || value.equals(""String_Node_Str"")) {
        if (output_format != 0 && output_format != output_format_shimp) {
          G.v().out.println(""String_Node_Str"" + option);
          return false;
        }
        output_format=output_format_shimp;
      }
 else       if (false || value.equals(""String_Node_Str"") || value.equals(""String_Node_Str"")) {
        if (output_format != 0 && output_format != output_format_baf) {
          G.v().out.println(""String_Node_Str"" + option);
          return false;
        }
        output_format=output_format_baf;
      }
 else       if (false || value.equals(""String_Node_Str"")) {
        if (output_format != 0 && output_format != output_format_b) {
          G.v().out.println(""String_Node_Str"" + option);
          return false;
        }
        output_format=output_format_b;
      }
 else       if (false || value.equals(""String_Node_Str"") || value.equals(""String_Node_Str"")) {
        if (output_format != 0 && output_format != output_format_grimple) {
          G.v().out.println(""String_Node_Str"" + option);
          return false;
        }
        output_format=output_format_grimple;
      }
 else       if (false || value.equals(""String_Node_Str"") || value.equals(""String_Node_Str"")) {
        if (output_format != 0 && output_format != output_format_grimp) {
          G.v().out.println(""String_Node_Str"" + option);
          return false;
        }
        output_format=output_format_grimp;
      }
 else       if (false || value.equals(""String_Node_Str"") || value.equals(""String_Node_Str"")) {
        if (output_format != 0 && output_format != output_format_xml) {
          G.v().out.println(""String_Node_Str"" + option);
          return false;
        }
        output_format=output_format_xml;
      }
 else       if (false || value.equals(""String_Node_Str"") || value.equals(""String_Node_Str"")) {
        if (output_format != 0 && output_format != output_format_none) {
          G.v().out.println(""String_Node_Str"" + option);
          return false;
        }
        output_format=output_format_none;
      }
 else       if (false || value.equals(""String_Node_Str"")) {
        if (output_format != 0 && output_format != output_format_jasmin) {
          G.v().out.println(""String_Node_Str"" + option);
          return false;
        }
        output_format=output_format_jasmin;
      }
 else       if (false || value.equals(""String_Node_Str"") || value.equals(""String_Node_Str"")) {
        if (output_format != 0 && output_format != output_format_class) {
          G.v().out.println(""String_Node_Str"" + option);
          return false;
        }
        output_format=output_format_class;
      }
 else       if (false || value.equals(""String_Node_Str"") || value.equals(""String_Node_Str"")) {
        if (output_format != 0 && output_format != output_format_dava) {
          G.v().out.println(""String_Node_Str"" + option);
          return false;
        }
        output_format=output_format_dava;
      }
 else {
        G.v().out.println(""String_Node_Str"" + value + ""String_Node_Str""+ option);
        return false;
      }
    }
 else     if (false || option.equals(""String_Node_Str""))     via_grimp=true;
 else     if (false || option.equals(""String_Node_Str""))     xml_attributes=true;
 else     if (false || option.equals(""String_Node_Str"") || option.equals(""String_Node_Str"")) {
      if (!hasMoreOptions()) {
        G.v().out.println(""String_Node_Str"" + option);
        return false;
      }
      String phaseName=nextOption();
      if (!hasMoreOptions()) {
        G.v().out.println(""String_Node_Str"" + option + ""String_Node_Str""+ phaseName);
        return false;
      }
      String phaseOption=nextOption();
      phaseOptions.add(phaseName);
      phaseOptions.add(phaseOption);
    }
 else     if (false || option.equals(""String_Node_Str"") || option.equals(""String_Node_Str"")) {
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
    }
 else     if (false || option.equals(""String_Node_Str"") || option.equals(""String_Node_Str"")) {
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
    }
 else     if (false || option.equals(""String_Node_Str""))     via_shimple=true;
 else     if (false || option.equals(""String_Node_Str"")) {
      if (!hasMoreOptions()) {
        G.v().out.println(""String_Node_Str"" + option);
        return false;
      }
      String value=nextOption();
      if (process_path == null)       process_path=new LinkedList();
      process_path.add(value);
    }
 else     if (false || option.equals(""String_Node_Str"") || option.equals(""String_Node_Str"")) {
      if (!hasMoreOptions()) {
        G.v().out.println(""String_Node_Str"" + option);
        return false;
      }
      String value=nextOption();
      if (include == null)       include=new LinkedList();
      include.add(value);
    }
 else     if (false || option.equals(""String_Node_Str"") || option.equals(""String_Node_Str"")) {
      if (!hasMoreOptions()) {
        G.v().out.println(""String_Node_Str"" + option);
        return false;
      }
      String value=nextOption();
      if (exclude == null)       exclude=new LinkedList();
      exclude.add(value);
    }
 else     if (false || option.equals(""String_Node_Str"")) {
      if (!hasMoreOptions()) {
        G.v().out.println(""String_Node_Str"" + option);
        return false;
      }
      String value=nextOption();
      if (dynamic_classes == null)       dynamic_classes=new LinkedList();
      dynamic_classes.add(value);
    }
 else     if (false || option.equals(""String_Node_Str"")) {
      if (!hasMoreOptions()) {
        G.v().out.println(""String_Node_Str"" + option);
        return false;
      }
      String value=nextOption();
      if (dynamic_path == null)       dynamic_path=new LinkedList();
      dynamic_path.add(value);
    }
 else     if (false || option.equals(""String_Node_Str"")) {
      if (!hasMoreOptions()) {
        G.v().out.println(""String_Node_Str"" + option);
        return false;
      }
      String value=nextOption();
      if (dynamic_package == null)       dynamic_package=new LinkedList();
      dynamic_package.add(value);
    }
 else     if (false || option.equals(""String_Node_Str""))     keep_line_number=true;
 else     if (false || option.equals(""String_Node_Str"") || option.equals(""String_Node_Str""))     keep_offset=true;
 else     if (false || option.equals(""String_Node_Str"")) {
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
    }
 else     if (false || option.equals(""String_Node_Str"")) {
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
    }
 else     if (false || option.equals(""String_Node_Str"")) {
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
    }
 else     if (false || option.equals(""String_Node_Str"")) {
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
    }
 else     if (false || option.equals(""String_Node_Str""))     time=true;
 else     if (false || option.equals(""String_Node_Str""))     subtract_gc=true;
 else {
      G.v().out.println(""String_Node_Str"" + option);
      return false;
    }
  }
  Iterator it=phaseOptions.iterator();
  while (it.hasNext()) {
    String phaseName=(String)it.next();
    String phaseOption=(String)it.next();
    if (!setPhaseOption(phaseName,""String_Node_Str""))     return false;
  }
  it=phaseOptions.iterator();
  while (it.hasNext()) {
    String phaseName=(String)it.next();
    String phaseOption=(String)it.next();
    if (!setPhaseOption(phaseName,phaseOption))     return false;
  }
  return true;
}"
88792,"public boolean setPhaseOption(String phase,String option){
  return PhaseOptions.v().processPhaseOptions(phase,""String_Node_Str"" + option);
}","public boolean setPhaseOption(String phase,String option){
  return PhaseOptions.v().processPhaseOptions(phase,option);
}"
88793,"private SootMethod resolveNonSpecial(RefType t,InstanceInvokeExpr iie,SootMethod container,NumberedString subSig){
  if (!Scene.v().getOrMakeFastHierarchy().canStoreType(t,iie.getBase().getType())) {
    return null;
  }
  SmallNumberedMap vtbl=(SmallNumberedMap)typeToVtbl.get(t);
  if (vtbl == null) {
    typeToVtbl.put(t,vtbl=new SmallNumberedMap(Scene.v().getMethodNumberer()));
  }
  SootMethod ret=(SootMethod)vtbl.get(subSig);
  if (ret != null)   return ret;
  SootClass cls=((RefType)t).getSootClass();
  if (cls.declaresMethod(subSig)) {
    SootMethod m=cls.getMethod(subSig);
    if (m.isConcrete() || m.isNative()) {
      ret=cls.getMethod(subSig);
    }
  }
 else {
    if (cls.hasSuperclass()) {
      ret=resolveNonSpecial(cls.getSuperclass().getType(),iie,container,subSig);
    }
  }
  vtbl.put(subSig,ret);
  return ret;
}","private SootMethod resolveNonSpecial(RefType t,InstanceInvokeExpr iie,SootMethod container,NumberedString subSig){
  SmallNumberedMap vtbl=(SmallNumberedMap)typeToVtbl.get(t);
  if (vtbl == null) {
    typeToVtbl.put(t,vtbl=new SmallNumberedMap(Scene.v().getMethodNumberer()));
  }
  SootMethod ret=(SootMethod)vtbl.get(subSig);
  if (ret != null)   return ret;
  SootClass cls=((RefType)t).getSootClass();
  if (cls.declaresMethod(subSig)) {
    SootMethod m=cls.getMethod(subSig);
    if (m.isConcrete() || m.isNative()) {
      ret=cls.getMethod(subSig);
    }
  }
 else {
    if (cls.hasSuperclass()) {
      ret=resolveNonSpecial(cls.getSuperclass().getType(),iie,container,subSig);
    }
  }
  vtbl.put(subSig,ret);
  return ret;
}"
88794,"public Object next(){
  return next();
}","public Object next(){
  return next;
}"
88795,"protected void internalTransform(String phaseName,Map options){
  if (Options.v().verbose())   G.v().out.println(""String_Node_Str"");
  boolean enableNullPointerCheckInsertion=PhaseOptions.getBoolean(options,""String_Node_Str"");
  boolean enableRedundantCastInsertion=PhaseOptions.getBoolean(options,""String_Node_Str"");
  String modifierOptions=PhaseOptions.getString(options,""String_Node_Str"");
  float expansionFactor=PhaseOptions.getFloat(options,""String_Node_Str"");
  int maxContainerSize=PhaseOptions.getInt(options,""String_Node_Str"");
  int maxInlineeSize=PhaseOptions.getInt(options,""String_Node_Str"");
  HashMap instanceToStaticMap=new HashMap();
  CallGraph cg=Scene.v().getCallGraph();
  Hierarchy hierarchy=Scene.v().getActiveHierarchy();
  ArrayList sitesToInline=new ArrayList();
  computeAverageMethodSizeAndSaveOriginalSizes();
{
    TopologicalOrderer orderer=new TopologicalOrderer(cg);
    orderer.go();
    List order=orderer.order();
    ListIterator it=order.listIterator(order.size());
    while (it.hasPrevious()) {
      SootMethod container=(SootMethod)it.previous();
      if (methodToOriginalSize.get(container) == null)       continue;
      if (!container.isConcrete())       continue;
      if (!cg.targetsOf(container).hasNext())       continue;
      JimpleBody b=(JimpleBody)container.retrieveActiveBody();
      List unitList=new ArrayList();
      unitList.addAll(b.getUnits());
      Iterator unitIt=unitList.iterator();
      while (unitIt.hasNext()) {
        Stmt s=(Stmt)unitIt.next();
        if (!s.containsInvokeExpr())         continue;
        Iterator targets=new Targets(cg.targetsOf(s));
        if (!targets.hasNext())         continue;
        SootMethod target=(SootMethod)targets.next();
        if (targets.hasNext())         continue;
        if (!target.getDeclaringClass().isApplicationClass() || !target.isConcrete())         continue;
        if (!InlinerSafetyManager.ensureInlinability(target,s,container,modifierOptions))         continue;
        List l=new ArrayList();
        l.add(target);
        l.add(s);
        l.add(container);
        sitesToInline.add(l);
      }
    }
  }
{
    Iterator sitesIt=sitesToInline.iterator();
    while (sitesIt.hasNext()) {
      List l=(List)sitesIt.next();
      SootMethod inlinee=(SootMethod)l.get(0);
      int inlineeSize=((JimpleBody)(inlinee.retrieveActiveBody())).getUnits().size();
      Stmt invokeStmt=(Stmt)l.get(1);
      SootMethod container=(SootMethod)l.get(2);
      int containerSize=((JimpleBody)(container.retrieveActiveBody())).getUnits().size();
      if (inlineeSize + containerSize > maxContainerSize)       continue;
      if (inlineeSize > maxInlineeSize)       continue;
      if (inlineeSize + containerSize > expansionFactor * ((Integer)methodToOriginalSize.get(container)).intValue())       continue;
      if (InlinerSafetyManager.ensureInlinability(inlinee,invokeStmt,container,modifierOptions)) {
        SiteInliner.inlineSite(inlinee,invokeStmt,container,options);
      }
    }
  }
}","protected void internalTransform(String phaseName,Map options){
  Filter explicitInvokesFilter=new Filter(new ExplicitEdgesPred());
  if (Options.v().verbose())   G.v().out.println(""String_Node_Str"");
  boolean enableNullPointerCheckInsertion=PhaseOptions.getBoolean(options,""String_Node_Str"");
  boolean enableRedundantCastInsertion=PhaseOptions.getBoolean(options,""String_Node_Str"");
  String modifierOptions=PhaseOptions.getString(options,""String_Node_Str"");
  float expansionFactor=PhaseOptions.getFloat(options,""String_Node_Str"");
  int maxContainerSize=PhaseOptions.getInt(options,""String_Node_Str"");
  int maxInlineeSize=PhaseOptions.getInt(options,""String_Node_Str"");
  HashMap instanceToStaticMap=new HashMap();
  CallGraph cg=Scene.v().getCallGraph();
  Hierarchy hierarchy=Scene.v().getActiveHierarchy();
  ArrayList sitesToInline=new ArrayList();
  computeAverageMethodSizeAndSaveOriginalSizes();
{
    TopologicalOrderer orderer=new TopologicalOrderer(cg);
    orderer.go();
    List order=orderer.order();
    ListIterator it=order.listIterator(order.size());
    while (it.hasPrevious()) {
      SootMethod container=(SootMethod)it.previous();
      if (methodToOriginalSize.get(container) == null)       continue;
      if (!container.isConcrete())       continue;
      if (!explicitInvokesFilter.wrap(cg.targetsOf(container)).hasNext())       continue;
      JimpleBody b=(JimpleBody)container.retrieveActiveBody();
      List unitList=new ArrayList();
      unitList.addAll(b.getUnits());
      Iterator unitIt=unitList.iterator();
      while (unitIt.hasNext()) {
        Stmt s=(Stmt)unitIt.next();
        if (!s.containsInvokeExpr())         continue;
        Iterator targets=new Targets(explicitInvokesFilter.wrap(cg.targetsOf(s)));
        if (!targets.hasNext())         continue;
        SootMethod target=(SootMethod)targets.next();
        if (targets.hasNext())         continue;
        if (!target.getDeclaringClass().isApplicationClass() || !target.isConcrete())         continue;
        if (!InlinerSafetyManager.ensureInlinability(target,s,container,modifierOptions))         continue;
        List l=new ArrayList();
        l.add(target);
        l.add(s);
        l.add(container);
        sitesToInline.add(l);
      }
    }
  }
{
    Iterator sitesIt=sitesToInline.iterator();
    while (sitesIt.hasNext()) {
      List l=(List)sitesIt.next();
      SootMethod inlinee=(SootMethod)l.get(0);
      int inlineeSize=((JimpleBody)(inlinee.retrieveActiveBody())).getUnits().size();
      Stmt invokeStmt=(Stmt)l.get(1);
      SootMethod container=(SootMethod)l.get(2);
      int containerSize=((JimpleBody)(container.retrieveActiveBody())).getUnits().size();
      if (inlineeSize + containerSize > maxContainerSize)       continue;
      if (inlineeSize > maxInlineeSize)       continue;
      if (inlineeSize + containerSize > expansionFactor * ((Integer)methodToOriginalSize.get(container)).intValue())       continue;
      if (InlinerSafetyManager.ensureInlinability(inlinee,invokeStmt,container,modifierOptions)) {
        SiteInliner.inlineSite(inlinee,invokeStmt,container,options);
      }
    }
  }
}"
88796,"protected void internalTransform(String phaseName,Map opts){
  SMBOptions options=new SMBOptions(opts);
  String modifierOptions=PhaseOptions.getString(opts,""String_Node_Str"");
  HashMap instanceToStaticMap=new HashMap();
  CallGraph cg=Scene.v().getCallGraph();
  Hierarchy hierarchy=Scene.v().getActiveHierarchy();
  Iterator classesIt=Scene.v().getApplicationClasses().iterator();
  while (classesIt.hasNext()) {
    SootClass c=(SootClass)classesIt.next();
    LinkedList methodsList=new LinkedList();
    for (Iterator it=c.methodIterator(); it.hasNext(); ) {
      methodsList.add(it.next());
    }
    while (!methodsList.isEmpty()) {
      SootMethod container=(SootMethod)methodsList.removeFirst();
      if (!container.isConcrete())       continue;
      if (!cg.targetsOf(container).hasNext())       continue;
      JimpleBody b=(JimpleBody)container.getActiveBody();
      List unitList=new ArrayList();
      unitList.addAll(b.getUnits());
      Iterator unitIt=unitList.iterator();
      while (unitIt.hasNext()) {
        Stmt s=(Stmt)unitIt.next();
        if (!s.containsInvokeExpr())         continue;
        InvokeExpr ie=(InvokeExpr)s.getInvokeExpr();
        if (ie instanceof StaticInvokeExpr || ie instanceof SpecialInvokeExpr)         continue;
        Iterator targets=new Targets(cg.targetsOf(s));
        if (!targets.hasNext())         continue;
        SootMethod target=(SootMethod)targets.next();
        if (targets.hasNext())         continue;
        if (!AccessManager.ensureAccess(container,target,modifierOptions))         continue;
        if (!target.getDeclaringClass().isApplicationClass() || !target.isConcrete())         continue;
        if (target.getDeclaringClass() == Scene.v().getSootClass(""String_Node_Str""))         continue;
        boolean targetUsesThis=true;
        if (!instanceToStaticMap.containsKey(target)) {
          List newParameterTypes=new ArrayList();
          if (targetUsesThis)           newParameterTypes.add(RefType.v(target.getDeclaringClass().getName()));
          newParameterTypes.addAll(target.getParameterTypes());
          String newName=target.getName() + ""String_Node_Str"";
          while (target.getDeclaringClass().declaresMethod(newName,newParameterTypes,target.getReturnType()))           newName=newName + ""String_Node_Str"";
          SootMethod ct=new SootMethod(newName,newParameterTypes,target.getReturnType(),target.getModifiers() | Modifier.STATIC,target.getExceptions());
          target.getDeclaringClass().addMethod(ct);
          methodsList.addLast(ct);
          ct.setActiveBody((Body)target.getActiveBody().clone());
{
            Iterator oldUnits=target.getActiveBody().getUnits().iterator();
            Iterator newUnits=ct.getActiveBody().getUnits().iterator();
            while (newUnits.hasNext()) {
              Stmt oldStmt, newStmt;
              oldStmt=(Stmt)oldUnits.next();
              newStmt=(Stmt)newUnits.next();
              Iterator edges=cg.targetsOf(oldStmt);
              while (edges.hasNext()) {
                Edge e=(Edge)edges.next();
                cg.addEdge(new Edge(ct,newStmt,e.tgt(),e.kind()));
                cg.removeEdge(e);
              }
            }
          }
{
            Body newBody=ct.getActiveBody();
            Chain units=newBody.getUnits();
            Iterator unitsIt=newBody.getUnits().snapshotIterator();
            while (unitsIt.hasNext()) {
              Stmt st=(Stmt)unitsIt.next();
              if (st instanceof IdentityStmt) {
                IdentityStmt is=(IdentityStmt)st;
                if (is.getRightOp() instanceof ThisRef) {
                  if (targetUsesThis)                   units.swapWith(st,Jimple.v().newIdentityStmt(is.getLeftOp(),Jimple.v().newParameterRef(is.getRightOp().getType(),0)));
 else {
                    units.remove(st);
                    break;
                  }
                }
 else                 if (targetUsesThis) {
                  if (is.getRightOp() instanceof ParameterRef) {
                    ParameterRef ro=(ParameterRef)is.getRightOp();
                    ro.setIndex(ro.getIndex() + 1);
                  }
                }
              }
            }
          }
          instanceToStaticMap.put(target,ct);
        }
        SootMethod clonedTarget=(SootMethod)instanceToStaticMap.get(target);
        Value thisToAdd=((InstanceInvokeExpr)ie).getBase();
        if (options.insert_redundant_casts() && targetUsesThis) {
          SootClass localType, parameterType;
          localType=((RefType)((InstanceInvokeExpr)ie).getBase().getType()).getSootClass();
          parameterType=target.getDeclaringClass();
          if (localType.isInterface() || hierarchy.isClassSuperclassOf(localType,parameterType)) {
            Local castee=Jimple.v().newLocal(""String_Node_Str"",parameterType.getType());
            b.getLocals().add(castee);
            b.getUnits().insertBefore(Jimple.v().newAssignStmt(castee,Jimple.v().newCastExpr(((InstanceInvokeExpr)ie).getBase(),parameterType.getType())),s);
            thisToAdd=castee;
          }
        }
{
          List newArgs=new ArrayList();
          if (targetUsesThis)           newArgs.add(thisToAdd);
          newArgs.addAll(ie.getArgs());
          StaticInvokeExpr sie=Jimple.v().newStaticInvokeExpr(clonedTarget,newArgs);
          ValueBox ieBox=s.getInvokeExprBox();
          ieBox.setValue(sie);
          cg.addEdge(new Edge(container,s,clonedTarget));
        }
        if (options.insert_null_checks()) {
          boolean caught=TrapManager.isExceptionCaughtAt(Scene.v().getSootClass(""String_Node_Str""),s,b);
          if (caught) {
            Stmt insertee=Jimple.v().newIfStmt(Jimple.v().newNeExpr(((InstanceInvokeExpr)ie).getBase(),NullConstant.v()),s);
            b.getUnits().insertBefore(insertee,s);
            ((IfStmt)insertee).setTarget(s);
            ThrowManager.addThrowAfter(b,insertee);
          }
 else {
            Stmt throwPoint=ThrowManager.getNullPointerExceptionThrower(b);
            b.getUnits().insertBefore(Jimple.v().newIfStmt(Jimple.v().newEqExpr(((InstanceInvokeExpr)ie).getBase(),NullConstant.v()),throwPoint),s);
          }
        }
{
          if (target.isSynchronized()) {
            clonedTarget.setModifiers(clonedTarget.getModifiers() & ~Modifier.SYNCHRONIZED);
            SynchronizerManager.v().synchronizeStmtOn(s,b,(Local)((InstanceInvokeExpr)ie).getBase());
          }
        }
        LocalNameStandardizer.v().transform(b,phaseName + ""String_Node_Str"");
      }
    }
  }
}","protected void internalTransform(String phaseName,Map opts){
  Filter instanceInvokesFilter=new Filter(new InstanceInvokeEdgesPred());
  SMBOptions options=new SMBOptions(opts);
  String modifierOptions=PhaseOptions.getString(opts,""String_Node_Str"");
  HashMap instanceToStaticMap=new HashMap();
  CallGraph cg=Scene.v().getCallGraph();
  Hierarchy hierarchy=Scene.v().getActiveHierarchy();
  Iterator classesIt=Scene.v().getApplicationClasses().iterator();
  while (classesIt.hasNext()) {
    SootClass c=(SootClass)classesIt.next();
    LinkedList methodsList=new LinkedList();
    for (Iterator it=c.methodIterator(); it.hasNext(); ) {
      methodsList.add(it.next());
    }
    while (!methodsList.isEmpty()) {
      SootMethod container=(SootMethod)methodsList.removeFirst();
      if (!container.isConcrete())       continue;
      if (!instanceInvokesFilter.wrap(cg.targetsOf(container)).hasNext())       continue;
      JimpleBody b=(JimpleBody)container.getActiveBody();
      List unitList=new ArrayList();
      unitList.addAll(b.getUnits());
      Iterator unitIt=unitList.iterator();
      while (unitIt.hasNext()) {
        Stmt s=(Stmt)unitIt.next();
        if (!s.containsInvokeExpr())         continue;
        InvokeExpr ie=(InvokeExpr)s.getInvokeExpr();
        if (ie instanceof StaticInvokeExpr || ie instanceof SpecialInvokeExpr)         continue;
        Iterator targets=new Targets(instanceInvokesFilter.wrap(cg.targetsOf(s)));
        if (!targets.hasNext())         continue;
        SootMethod target=(SootMethod)targets.next();
        if (targets.hasNext())         continue;
        if (!AccessManager.ensureAccess(container,target,modifierOptions))         continue;
        if (!target.getDeclaringClass().isApplicationClass() || !target.isConcrete())         continue;
        if (target.getDeclaringClass() == Scene.v().getSootClass(""String_Node_Str""))         continue;
        boolean targetUsesThis=true;
        if (!instanceToStaticMap.containsKey(target)) {
          List newParameterTypes=new ArrayList();
          if (targetUsesThis)           newParameterTypes.add(RefType.v(target.getDeclaringClass().getName()));
          newParameterTypes.addAll(target.getParameterTypes());
          String newName=target.getName() + ""String_Node_Str"";
          while (target.getDeclaringClass().declaresMethod(newName,newParameterTypes,target.getReturnType()))           newName=newName + ""String_Node_Str"";
          SootMethod ct=new SootMethod(newName,newParameterTypes,target.getReturnType(),target.getModifiers() | Modifier.STATIC,target.getExceptions());
          target.getDeclaringClass().addMethod(ct);
          methodsList.addLast(ct);
          ct.setActiveBody((Body)target.getActiveBody().clone());
{
            Iterator oldUnits=target.getActiveBody().getUnits().iterator();
            Iterator newUnits=ct.getActiveBody().getUnits().iterator();
            while (newUnits.hasNext()) {
              Stmt oldStmt, newStmt;
              oldStmt=(Stmt)oldUnits.next();
              newStmt=(Stmt)newUnits.next();
              Iterator edges=cg.targetsOf(oldStmt);
              while (edges.hasNext()) {
                Edge e=(Edge)edges.next();
                cg.addEdge(new Edge(ct,newStmt,e.tgt(),e.kind()));
                cg.removeEdge(e);
              }
            }
          }
{
            Body newBody=ct.getActiveBody();
            Chain units=newBody.getUnits();
            Iterator unitsIt=newBody.getUnits().snapshotIterator();
            while (unitsIt.hasNext()) {
              Stmt st=(Stmt)unitsIt.next();
              if (st instanceof IdentityStmt) {
                IdentityStmt is=(IdentityStmt)st;
                if (is.getRightOp() instanceof ThisRef) {
                  if (targetUsesThis)                   units.swapWith(st,Jimple.v().newIdentityStmt(is.getLeftOp(),Jimple.v().newParameterRef(is.getRightOp().getType(),0)));
 else {
                    units.remove(st);
                    break;
                  }
                }
 else                 if (targetUsesThis) {
                  if (is.getRightOp() instanceof ParameterRef) {
                    ParameterRef ro=(ParameterRef)is.getRightOp();
                    ro.setIndex(ro.getIndex() + 1);
                  }
                }
              }
            }
          }
          instanceToStaticMap.put(target,ct);
        }
        SootMethod clonedTarget=(SootMethod)instanceToStaticMap.get(target);
        Value thisToAdd=((InstanceInvokeExpr)ie).getBase();
        if (options.insert_redundant_casts() && targetUsesThis) {
          SootClass localType, parameterType;
          localType=((RefType)((InstanceInvokeExpr)ie).getBase().getType()).getSootClass();
          parameterType=target.getDeclaringClass();
          if (localType.isInterface() || hierarchy.isClassSuperclassOf(localType,parameterType)) {
            Local castee=Jimple.v().newLocal(""String_Node_Str"",parameterType.getType());
            b.getLocals().add(castee);
            b.getUnits().insertBefore(Jimple.v().newAssignStmt(castee,Jimple.v().newCastExpr(((InstanceInvokeExpr)ie).getBase(),parameterType.getType())),s);
            thisToAdd=castee;
          }
        }
{
          List newArgs=new ArrayList();
          if (targetUsesThis)           newArgs.add(thisToAdd);
          newArgs.addAll(ie.getArgs());
          StaticInvokeExpr sie=Jimple.v().newStaticInvokeExpr(clonedTarget,newArgs);
          ValueBox ieBox=s.getInvokeExprBox();
          ieBox.setValue(sie);
          cg.addEdge(new Edge(container,s,clonedTarget));
        }
        if (options.insert_null_checks()) {
          boolean caught=TrapManager.isExceptionCaughtAt(Scene.v().getSootClass(""String_Node_Str""),s,b);
          if (caught) {
            Stmt insertee=Jimple.v().newIfStmt(Jimple.v().newNeExpr(((InstanceInvokeExpr)ie).getBase(),NullConstant.v()),s);
            b.getUnits().insertBefore(insertee,s);
            ((IfStmt)insertee).setTarget(s);
            ThrowManager.addThrowAfter(b,insertee);
          }
 else {
            Stmt throwPoint=ThrowManager.getNullPointerExceptionThrower(b);
            b.getUnits().insertBefore(Jimple.v().newIfStmt(Jimple.v().newEqExpr(((InstanceInvokeExpr)ie).getBase(),NullConstant.v()),throwPoint),s);
          }
        }
{
          if (target.isSynchronized()) {
            clonedTarget.setModifiers(clonedTarget.getModifiers() & ~Modifier.SYNCHRONIZED);
            SynchronizerManager.v().synchronizeStmtOn(s,b,(Local)((InstanceInvokeExpr)ie).getBase());
          }
        }
        LocalNameStandardizer.v().transform(b,phaseName + ""String_Node_Str"");
      }
    }
  }
}"
88797,"/** 
 * @see org.eclipse.ui.IActionDelegate#run(IAction)
 */
public void run(IAction action){
  super.run(action);
  String cmd=getCmd();
  runSootAsProcess(cmd);
  runFinish();
}","/** 
 * @see org.eclipse.ui.IActionDelegate#run(IAction)
 */
public void run(IAction action){
  super.run(action);
  if (isDoNotContinue())   return;
  String cmd=getCmd();
  runSootAsProcess(cmd);
  runFinish();
}"
88798,"public void run(IAction action){
  super.run(action);
  String cmd=getCmd();
  runSootAsProcess(cmd);
  runFinish();
}","public void run(IAction action){
  super.run(action);
  if (isDoNotContinue())   return;
  String cmd=getCmd();
  runSootAsProcess(cmd);
  runFinish();
}"
88799,"public void run(IAction action){
  super.run(action);
  setDoNotContinue(false);
  if (getSootSelection().getType() == SootSelection.CLASSFILE_SELECTED_TYPE) {
    IClassFile cf=getSootSelection().getClassFile();
    IPackageFragmentRoot pfr=(IPackageFragmentRoot)cf.getAncestor(IJavaElement.PACKAGE_FRAGMENT_ROOT);
    IPackageFragment pf=(IPackageFragment)cf.getAncestor(IJavaElement.PACKAGE_FRAGMENT);
    setClasspathAppend(platform_location + pfr.getPath().toOSString());
    if (pf.isDefaultPackage()) {
      setToProcess(removeFileExt(cf.getElementName()));
    }
 else {
      setToProcess(pf.getElementName() + ""String_Node_Str"" + removeFileExt(cf.getElementName()));
    }
  }
 else   if (getSootSelection().getType() == SootSelection.FILE_SELECTED_TYPE) {
    IFile file=getSootSelection().getFile();
    if (file.getFileExtension().compareTo(""String_Node_Str"") == 0) {
      setClasspathAppend(platform_location + file.getParent().getFullPath().toOSString());
      setIsSrcPrec(true);
      setSrcPrec(LaunchCommands.JIMPLE_IN);
      setToProcess(removeFileExt(file.getName()));
    }
 else     if (file.getFileExtension().compareTo(""String_Node_Str"") == 0) {
      try {
        handleClassFile(file);
      }
 catch (      Exception e) {
        System.out.println(""String_Node_Str"");
      }
    }
  }
 else   if (getSootSelection().getType() == SootSelection.CU_SELECTED_TYPE) {
    ICompilationUnit cu=getSootSelection().getJavaFile();
    IPackageFragmentRoot pfr=(IPackageFragmentRoot)cu.getAncestor(IJavaElement.PACKAGE_FRAGMENT_ROOT);
    IPackageFragment pf=(IPackageFragment)cu.getAncestor(IJavaElement.PACKAGE_FRAGMENT);
    try {
      IProject proj=cu.getJavaProject().getProject();
      IFolder output=proj.getFolder(cu.getJavaProject().getOutputLocation().lastSegment());
      System.out.println(output.getLocation().toOSString());
      IPackageFragment pkf=(IPackageFragment)cu.getAncestor(IJavaElement.PACKAGE_FRAGMENT);
      IFile exists=null;
      if (pkf.isDefaultPackage()) {
        exists=output.getFile(removeFileExt(cu.getElementName()) + ""String_Node_Str"");
        System.out.println(""String_Node_Str"" + output);
        System.out.println(exists.getLocation().toOSString());
      }
 else {
        IFolder pkg=output.getFolder(pf.getElementName());
        exists=pkg.getFile(removeFileExt(cu.getElementName()) + ""String_Node_Str"");
        System.out.println(exists.getLocation().toOSString());
      }
      if (!exists.exists()) {
        System.out.println(""String_Node_Str"");
        window=SootPlugin.getDefault().getWorkbench().getActiveWorkbenchWindow();
        MessageDialog noClassFound=new MessageDialog(window.getShell(),""String_Node_Str"",null,""String_Node_Str"",0,new String[]{""String_Node_Str""},0);
        noClassFound.open();
        setDoNotContinue(true);
      }
      setClasspathAppend(platform_location + cu.getJavaProject().getOutputLocation().toOSString());
    }
 catch (    CoreException e) {
    }
    if (pf.isDefaultPackage()) {
      setToProcess(removeFileExt(cu.getElementName()));
    }
 else {
      setToProcess(pf.getElementName() + ""String_Node_Str"" + removeFileExt(cu.getElementName()));
    }
  }
}","public void run(IAction action){
  super.run(action);
  setDoNotContinue(false);
  if (getSootSelection().getType() == SootSelection.CLASSFILE_SELECTED_TYPE) {
    IClassFile cf=getSootSelection().getClassFile();
    IPackageFragmentRoot pfr=(IPackageFragmentRoot)cf.getAncestor(IJavaElement.PACKAGE_FRAGMENT_ROOT);
    IPackageFragment pf=(IPackageFragment)cf.getAncestor(IJavaElement.PACKAGE_FRAGMENT);
    setClasspathAppend(platform_location + pfr.getPath().toOSString());
    if (pf.isDefaultPackage()) {
      setToProcess(removeFileExt(cf.getElementName()));
    }
 else {
      setToProcess(pf.getElementName() + ""String_Node_Str"" + removeFileExt(cf.getElementName()));
    }
  }
 else   if (getSootSelection().getType() == SootSelection.FILE_SELECTED_TYPE) {
    IFile file=getSootSelection().getFile();
    if (file.getFileExtension().compareTo(""String_Node_Str"") == 0) {
      setClasspathAppend(platform_location + file.getParent().getFullPath().toOSString());
      setIsSrcPrec(true);
      setSrcPrec(LaunchCommands.JIMPLE_IN);
      setToProcess(removeFileExt(file.getName()));
    }
 else     if (file.getFileExtension().compareTo(""String_Node_Str"") == 0) {
      try {
        handleClassFile(file);
      }
 catch (      Exception e) {
        System.out.println(""String_Node_Str"");
      }
    }
  }
 else   if (getSootSelection().getType() == SootSelection.CU_SELECTED_TYPE) {
    ICompilationUnit cu=getSootSelection().getJavaFile();
    IPackageFragmentRoot pfr=(IPackageFragmentRoot)cu.getAncestor(IJavaElement.PACKAGE_FRAGMENT_ROOT);
    IPackageFragment pf=(IPackageFragment)cu.getAncestor(IJavaElement.PACKAGE_FRAGMENT);
    try {
      IProject proj=cu.getJavaProject().getProject();
      IFolder output=proj.getFolder(cu.getJavaProject().getOutputLocation().lastSegment());
      System.out.println(""String_Node_Str"" + output.getLocation().toOSString());
      IPackageFragment pkf=(IPackageFragment)cu.getAncestor(IJavaElement.PACKAGE_FRAGMENT);
      IFile exists=null;
      if (pkf.isDefaultPackage()) {
        exists=output.getFile(removeFileExt(cu.getElementName()) + ""String_Node_Str"");
        System.out.println(""String_Node_Str"" + output);
        System.out.println(exists.getLocation().toOSString());
      }
 else {
        IFolder pkg=output.getFolder(pf.getElementName());
        exists=pkg.getFile(removeFileExt(cu.getElementName()) + ""String_Node_Str"");
        System.out.println(exists.getLocation().toOSString());
      }
      if (!exists.exists()) {
        System.out.println(""String_Node_Str"");
        window=SootPlugin.getDefault().getWorkbench().getActiveWorkbenchWindow();
        MessageDialog noClassFound=new MessageDialog(window.getShell(),""String_Node_Str"",null,""String_Node_Str"",0,new String[]{""String_Node_Str""},0);
        noClassFound.open();
        setDoNotContinue(true);
      }
      setClasspathAppend(platform_location + cu.getJavaProject().getOutputLocation().toOSString());
    }
 catch (    CoreException e) {
    }
    if (pf.isDefaultPackage()) {
      setToProcess(removeFileExt(cu.getElementName()));
    }
 else {
      setToProcess(pf.getElementName() + ""String_Node_Str"" + removeFileExt(cu.getElementName()));
    }
  }
}"
88800,"public void run(IAction action){
  super.run(action);
  setCmd();
  runSootDirectly();
  runFinish();
}","public void run(IAction action){
  super.run(action);
  if (isDoNotContinue())   return;
  setCmd();
  runSootDirectly();
  runFinish();
}"
88801,"public void run(IAction action){
  super.run(action);
  setCmd();
  runSootDirectly();
  runFinish();
}","public void run(IAction action){
  super.run(action);
  if (isDoNotContinue())   return;
  setCmd();
  runSootDirectly();
  runFinish();
}"
88802,"protected void runSootDirectly(String mainClass){
  int length=getSootCommandList().getList().size();
  String temp[]=new String[length];
  getSootCommandList().getList().toArray(temp);
  final String[] cmdAsArray=temp;
  for (int i=0; i < temp.length; i++) {
    System.out.println(temp[i]);
  }
  System.out.println(""String_Node_Str"");
  IRunnableWithProgress op;
  try {
    newProcessStarting();
    op=new SootRunner(temp,Display.getCurrent(),mainClass);
    ModalContext.run(op,true,new NullProgressMonitor(),Display.getCurrent());
  }
 catch (  InvocationTargetException e1) {
    System.out.println(""String_Node_Str"" + e1.getMessage());
  }
catch (  InterruptedException e2) {
    System.out.println(""String_Node_Str"" + e2.getMessage());
  }
}","protected void runSootDirectly(String mainClass){
  int length=getSootCommandList().getList().size();
  String temp[]=new String[length];
  getSootCommandList().getList().toArray(temp);
  sendSootOutputEvent(mainClass);
  sendSootOutputEvent(""String_Node_Str"");
  final String[] cmdAsArray=temp;
  for (int i=0; i < temp.length; i++) {
    System.out.println(temp[i]);
    sendSootOutputEvent(temp[i]);
    sendSootOutputEvent(""String_Node_Str"");
  }
  sendSootOutputEvent(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  IRunnableWithProgress op;
  try {
    newProcessStarting();
    op=new SootRunner(temp,Display.getCurrent(),mainClass);
    ModalContext.run(op,true,new NullProgressMonitor(),Display.getCurrent());
  }
 catch (  InvocationTargetException e1) {
    System.out.println(""String_Node_Str"" + e1.getMessage());
  }
catch (  InterruptedException e2) {
    System.out.println(""String_Node_Str"" + e2.getMessage());
  }
}"
88803,"public void run(IAction action){
  setSootSelection(new SootSelection(structured));
  getSootSelection().initialize();
  setFileHandler(new SootOutputFilesHandler(window));
  getFileHandler().resetSootOutputFolder(getSootSelection().getProject());
  System.out.println(""String_Node_Str"");
  setDavaHandler(new DavaHandler());
  getDavaHandler().setSootOutputFolder(getFileHandler().getSootOutputFolder());
  getDavaHandler().handleBefore();
  initPaths();
  initCommandList();
}","public void run(){
  SootPlugin.getDefault().fireSootOutputEvent(sendFinal);
}"
88804,"public void endValueBox(ValueBox u){
  endOffset=output().length() - lastNewline;
  u.addTag(new PositionTag(((Integer)startOffsets.pop()).intValue(),endOffset));
}","public void endValueBox(ValueBox u){
  endOffset=output().length() - lastNewline;
  if (hasColorTag(u)) {
    u.addTag(new PositionTag(((Integer)startOffsets.pop()).intValue(),endOffset));
  }
}"
88805,"public void endUnit(Unit u){
  int endStmtOffset=output().length() - lastNewline;
  u.addTag(new JimpleLineNumberTag(startLn,currentLn));
  u.addTag(new PositionTag(startStmtOffset,endStmtOffset));
}","public void endUnit(Unit u){
  int endStmtOffset=output().length() - lastNewline;
  if (hasTag(u)) {
    u.addTag(new JimpleLineNumberTag(startLn,currentLn));
  }
  if (hasColorTag(u)) {
    u.addTag(new PositionTag(startStmtOffset,endStmtOffset));
  }
}"
88806,"public void printAttrs(SootClass c){
  int java_ln=0;
  int jimple_ln=0;
  Iterator it=c.getMethods().iterator();
  while (it.hasNext()) {
    SootMethod sm=(SootMethod)it.next();
    if (!sm.hasActiveBody()) {
      continue;
    }
    Iterator mTags=sm.getTags().iterator();
    startPrintAttribute();
    while (mTags.hasNext()) {
      Tag t=(Tag)mTags.next();
      printAttributeTag(t);
    }
    endPrintAttribute();
    Body b=sm.getActiveBody();
    Iterator itUnits=b.getUnits().iterator();
    while (itUnits.hasNext()) {
      Unit u=(Unit)itUnits.next();
      Iterator itTags=u.getTags().iterator();
      startPrintAttribute();
      while (itTags.hasNext()) {
        Tag t=(Tag)itTags.next();
        printAttributeTag(t);
      }
      Iterator valBoxIt=u.getUseAndDefBoxes().iterator();
      while (valBoxIt.hasNext()) {
        ValueBox vb=(ValueBox)valBoxIt.next();
        startPrintValBoxAttr();
        Iterator tagsIt=vb.getTags().iterator();
        while (tagsIt.hasNext()) {
          Tag t=(Tag)tagsIt.next();
          printAttributeTag(t);
        }
        endPrintValBoxAttr();
      }
      endPrintAttribute();
    }
  }
  finishFile();
}","public void printAttrs(SootClass c){
  int java_ln=0;
  int jimple_ln=0;
  Iterator it=c.getMethods().iterator();
  while (it.hasNext()) {
    SootMethod sm=(SootMethod)it.next();
    if (!sm.hasActiveBody()) {
      continue;
    }
    if (!sm.getTags().isEmpty()) {
      Iterator mTags=sm.getTags().iterator();
      startPrintAttribute();
      while (mTags.hasNext()) {
        Tag t=(Tag)mTags.next();
        printAttributeTag(t);
      }
      endPrintAttribute();
    }
    Body b=sm.getActiveBody();
    Iterator itUnits=b.getUnits().iterator();
    while (itUnits.hasNext()) {
      Unit u=(Unit)itUnits.next();
      Iterator itTags=u.getTags().iterator();
      startPrintAttribute();
      while (itTags.hasNext()) {
        Tag t=(Tag)itTags.next();
        printAttributeTag(t);
      }
      Iterator valBoxIt=u.getUseAndDefBoxes().iterator();
      while (valBoxIt.hasNext()) {
        ValueBox vb=(ValueBox)valBoxIt.next();
        if (!vb.getTags().isEmpty()) {
          startPrintValBoxAttr();
          Iterator tagsIt=vb.getTags().iterator();
          while (tagsIt.hasNext()) {
            Tag t=(Tag)tagsIt.next();
            printAttributeTag(t);
          }
          endPrintValBoxAttr();
        }
      }
      endPrintAttribute();
    }
  }
  finishFile();
}"
88807,"/** 
 * Constructs a PatchingChain from the given Chain. 
 */
public PatchingChain(Chain aChain,Body aBody){
  innerChain=aChain;
  body=body;
}","/** 
 * Constructs a PatchingChain from the given Chain. 
 */
public PatchingChain(Chain aChain,Body aBody){
  innerChain=aChain;
  body=aBody;
}"
88808,"public void findNTRWSets(SootMethod method){
  if (methodToNTReadSet.containsKey(method) && methodToNTWriteSet.containsKey(method))   return;
  MethodRWSet read=new MethodRWSet();
  MethodRWSet write=new MethodRWSet();
  for (Iterator sIt=method.retrieveActiveBody().getUnits().iterator(); sIt.hasNext(); ) {
    final Stmt s=(Stmt)sIt.next();
    if (!s.containsInvokeExpr()) {
      read.union(readSet(method,s));
      write.union(writeSet(method,s));
    }
  }
  methodToNTReadSet.put(method,read);
  methodToNTWriteSet.put(method,write);
  SootClass c=method.getDeclaringClass();
  if (!c.isApplicationClass()) {
    method.releaseActiveBody();
  }
}","public void findNTRWSets(SootMethod method){
  if (methodToNTReadSet.containsKey(method) && methodToNTWriteSet.containsKey(method))   return;
  MethodRWSet read=new MethodRWSet();
  MethodRWSet write=new MethodRWSet();
  for (Iterator sIt=method.retrieveActiveBody().getUnits().iterator(); sIt.hasNext(); ) {
    final Stmt s=(Stmt)sIt.next();
    read.union(ntReadSet(method,s));
    write.union(ntWriteSet(method,s));
  }
  methodToNTReadSet.put(method,read);
  methodToNTWriteSet.put(method,write);
  SootClass c=method.getDeclaringClass();
  if (!c.isApplicationClass()) {
    method.releaseActiveBody();
  }
}"
88809,"public SideEffectAnalysis(PointsToAnalysis pa,CallGraph cg){
  this.pa=pa;
  this.cg=cg;
}","public SideEffectAnalysis(PointsToAnalysis pa,CallGraph cg){
  this.pa=pa;
  this.cg=cg;
  this.tt=new TransitiveTargets(cg);
}"
88810,"public RWSet writeSet(SootMethod method,Stmt stmt){
  RWSet ret=null;
  Iterator targets=new Targets(cg.targetsOf(stmt));
  while (targets.hasNext()) {
    SootMethod target=(SootMethod)targets.next();
    if (target.isNative()) {
      if (ret == null)       ret=new SiteRWSet();
      ret.setCallsNative();
    }
 else     if (target.isConcrete()) {
      if (ret == null)       ret=new SiteRWSet();
      ret.union(nonTransitiveWriteSet(target));
    }
  }
  if (stmt instanceof AssignStmt) {
    AssignStmt a=(AssignStmt)stmt;
    Value l=a.getLeftOp();
    ret=addValue(l,method,stmt);
  }
  return ret;
}","public RWSet writeSet(SootMethod method,Stmt stmt){
  RWSet ret=null;
  Iterator targets=tt.iterator(stmt);
  while (targets.hasNext()) {
    SootMethod target=(SootMethod)targets.next();
    if (target.isNative()) {
      if (ret == null)       ret=new SiteRWSet();
      ret.setCallsNative();
    }
 else     if (target.isConcrete()) {
      if (ret == null)       ret=new SiteRWSet();
      ret.union(nonTransitiveWriteSet(target));
    }
  }
  if (ret == null)   return ntWriteSet(method,stmt);
  ret.union(ntWriteSet(method,stmt));
  return ret;
}"
88811,"public RWSet readSet(SootMethod method,Stmt stmt){
  RWSet ret=null;
  Iterator targets=new Targets(cg.targetsOf(stmt));
  while (targets.hasNext()) {
    SootMethod target=(SootMethod)targets.next();
    if (target.isNative()) {
      if (ret == null)       ret=new SiteRWSet();
      ret.setCallsNative();
    }
 else     if (target.isConcrete()) {
      if (ret == null)       ret=new SiteRWSet();
      ret.union(nonTransitiveReadSet(target));
    }
  }
  if (stmt instanceof AssignStmt) {
    AssignStmt a=(AssignStmt)stmt;
    Value r=a.getRightOp();
    ret=addValue(r,method,stmt);
  }
  return ret;
}","public RWSet readSet(SootMethod method,Stmt stmt){
  RWSet ret=null;
  Iterator targets=tt.iterator(stmt);
  while (targets.hasNext()) {
    SootMethod target=(SootMethod)targets.next();
    if (target.isNative()) {
      if (ret == null)       ret=new SiteRWSet();
      ret.setCallsNative();
    }
 else     if (target.isConcrete()) {
      if (ret == null)       ret=new SiteRWSet();
      ret.union(nonTransitiveReadSet(target));
    }
  }
  if (ret == null)   return ntReadSet(method,stmt);
  ret.union(ntReadSet(method,stmt));
  return ret;
}"
88812,"public String toString(){
  String[] types={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  return types[type] + ""String_Node_Str"" + srcUnit+ ""String_Node_Str""+ src+ ""String_Node_Str""+ tgt;
}","public String toString(){
  return types[type] + ""String_Node_Str"" + srcUnit+ ""String_Node_Str""+ src+ ""String_Node_Str""+ tgt;
}"
88813,"public void getImplicitTargets(SootMethod source){
  final SootClass scl=source.getDeclaringClass();
  if (source.isNative())   return;
  if (source.getSubSignature().indexOf(""String_Node_Str"") >= 0) {
    addEdge(source,null,scl,sigFinalize,Edge.FINALIZE);
    FastHierarchy fh=Scene.v().getOrMakeFastHierarchy();
    if (fh.canStoreType(scl.getType(),clPrivilegedAction) || fh.canStoreType(scl.getType(),clPrivilegedExceptionAction)) {
      addEdge(source,null,scl,sigObjRun,Edge.PRIVILEGED);
    }
    if (fh.canStoreType(scl.getType(),clRunnable)) {
      addEdge(source,null,scl,sigExit,Edge.EXIT);
    }
  }
  Body b=source.retrieveActiveBody();
  boolean warnedAlready=false;
  for (Iterator sIt=b.getUnits().iterator(); sIt.hasNext(); ) {
    final Stmt s=(Stmt)sIt.next();
    if (s.containsInvokeExpr()) {
      InvokeExpr ie=(InvokeExpr)s.getInvokeExpr();
      if (ie.getMethod().getSignature().equals(""String_Node_Str"")) {
        if (!warnedAlready) {
          G.v().out.println(""String_Node_Str"" + ""String_Node_Str"" + source + ""String_Node_Str"");
          warnedAlready=true;
        }
      }
      if (ie.getMethod().getNumberedSubSignature() == sigForName) {
        Value name=ie.getArg(0);
        if (name instanceof StringConstant) {
          String cls=((StringConstant)name).value;
          constantForName(cls,source,s);
        }
 else {
          if (options.safe_forname()) {
            for (Iterator tgtIt=EntryPoints.v().clinits().iterator(); tgtIt.hasNext(); ) {
              final SootMethod tgt=(SootMethod)tgtIt.next();
              cg.addEdge(new Edge(source,s,tgt,Edge.CLINIT));
            }
          }
 else {
            VirtualCallSite vcs=new VirtualCallSite(s,source);
            wantedStringConstants.put(name,vcs);
            Set names=pa.reachingObjects((Local)name).possibleStringConstants();
            if (names == null) {
              handleClassName(vcs,null);
              wantedStringConstants.remove(name);
            }
 else {
              for (Iterator nameStrIt=names.iterator(); nameStrIt.hasNext(); ) {
                final String nameStr=(String)nameStrIt.next();
                handleClassName(vcs,nameStr);
              }
            }
          }
        }
      }
      addEdge(source,s,ie.getMethod().getDeclaringClass(),sigClinit,Edge.CLINIT);
    }
    if (s.containsFieldRef()) {
      FieldRef fr=(FieldRef)s.getFieldRef();
      if (fr instanceof StaticFieldRef) {
        SootClass cl=fr.getField().getDeclaringClass();
        addEdge(source,s,cl,sigClinit,Edge.CLINIT);
      }
    }
    if (s instanceof AssignStmt) {
      Value rhs=((AssignStmt)s).getRightOp();
      if (rhs instanceof NewExpr) {
        NewExpr r=(NewExpr)rhs;
        addEdge(source,s,r.getBaseType().getSootClass(),sigClinit,Edge.CLINIT);
      }
 else       if (rhs instanceof NewArrayExpr || rhs instanceof NewMultiArrayExpr) {
        Type t=rhs.getType();
        if (t instanceof ArrayType)         t=((ArrayType)t).baseType;
        if (t instanceof RefType) {
          addEdge(source,s,((RefType)t).getSootClass(),sigClinit,Edge.CLINIT);
        }
      }
    }
  }
}","public void getImplicitTargets(SootMethod source){
  final SootClass scl=source.getDeclaringClass();
  if (source.isNative())   return;
  if (source.getSubSignature().indexOf(""String_Node_Str"") >= 0) {
    handleInit(source,scl);
  }
  Body b=source.retrieveActiveBody();
  boolean warnedAlready=false;
  for (Iterator sIt=b.getUnits().iterator(); sIt.hasNext(); ) {
    final Stmt s=(Stmt)sIt.next();
    if (s.containsInvokeExpr()) {
      InvokeExpr ie=(InvokeExpr)s.getInvokeExpr();
      if (ie.getMethod().getSignature().equals(""String_Node_Str"")) {
        if (!warnedAlready) {
          G.v().out.println(""String_Node_Str"" + ""String_Node_Str"" + source + ""String_Node_Str"");
          warnedAlready=true;
        }
      }
      if (ie.getMethod().getNumberedSubSignature() == sigForName) {
        Value name=ie.getArg(0);
        if (name instanceof StringConstant) {
          String cls=((StringConstant)name).value;
          constantForName(cls,source,s);
        }
 else {
          if (options.safe_forname()) {
            for (Iterator tgtIt=EntryPoints.v().clinits().iterator(); tgtIt.hasNext(); ) {
              final SootMethod tgt=(SootMethod)tgtIt.next();
              cg.addEdge(new Edge(source,s,tgt,Edge.CLINIT));
            }
          }
 else {
            VirtualCallSite vcs=new VirtualCallSite(s,source);
            wantedStringConstants.put(name,vcs);
            Set names=pa.reachingObjects((Local)name).possibleStringConstants();
            if (names == null) {
              handleClassName(vcs,null);
              wantedStringConstants.remove(name);
            }
 else {
              for (Iterator nameStrIt=names.iterator(); nameStrIt.hasNext(); ) {
                final String nameStr=(String)nameStrIt.next();
                handleClassName(vcs,nameStr);
              }
            }
          }
        }
      }
      addEdge(source,s,ie.getMethod().getDeclaringClass(),sigClinit,Edge.CLINIT);
    }
    if (s.containsFieldRef()) {
      FieldRef fr=(FieldRef)s.getFieldRef();
      if (fr instanceof StaticFieldRef) {
        SootClass cl=fr.getField().getDeclaringClass();
        addEdge(source,s,cl,sigClinit,Edge.CLINIT);
      }
    }
    if (s instanceof AssignStmt) {
      Value rhs=((AssignStmt)s).getRightOp();
      if (rhs instanceof NewExpr) {
        NewExpr r=(NewExpr)rhs;
        addEdge(source,s,r.getBaseType().getSootClass(),sigClinit,Edge.CLINIT);
      }
 else       if (rhs instanceof NewArrayExpr || rhs instanceof NewMultiArrayExpr) {
        Type t=rhs.getType();
        if (t instanceof ArrayType)         t=((ArrayType)t).baseType;
        if (t instanceof RefType) {
          addEdge(source,s,((RefType)t).getSootClass(),sigClinit,Edge.CLINIT);
        }
      }
    }
  }
}"
88814,"private void processNewMethod(SootMethod m){
  if (m.isNative()) {
    return;
  }
  Body b=m.retrieveActiveBody();
  HashSet receivers=new HashSet();
  getImplicitTargets(m);
  for (Iterator sIt=b.getUnits().iterator(); sIt.hasNext(); ) {
    final Stmt s=(Stmt)sIt.next();
    if (s.containsInvokeExpr()) {
      InvokeExpr ie=(InvokeExpr)s.getInvokeExpr();
      if (ie instanceof InstanceInvokeExpr) {
        VirtualCallSite vcs=new VirtualCallSite(s,m);
        invokeExprToVCS.put(ie,vcs);
        Local receiver=(Local)((InstanceInvokeExpr)ie).getBase();
        HashSet vcss=(HashSet)localToVCS.get(receiver);
        if (vcss == null) {
          localToVCS.put(receiver,vcss=new HashSet());
        }
        vcss.add(vcs);
        receivers.add(receiver);
      }
 else {
        SootMethod tgt=((StaticInvokeExpr)ie).getMethod();
        cg.addEdge(new Edge(m,s,tgt));
      }
    }
  }
  for (Iterator receiverIt=receivers.iterator(); receiverIt.hasNext(); ) {
    final Local receiver=(Local)receiverIt.next();
    Set types=pa.reachingObjects(receiver).possibleTypes();
    HashSet vcss=(HashSet)localToVCS.get(receiver);
    for (Iterator vcsIt=vcss.iterator(); vcsIt.hasNext(); ) {
      final VirtualCallSite vcs=(VirtualCallSite)vcsIt.next();
      for (Iterator tIt=types.iterator(); tIt.hasNext(); ) {
        final Type t=(Type)tIt.next();
        VirtualCalls.v().resolve(t,vcs.getInstanceInvokeExpr(),vcs.getContainer(),targetsQueue);
      }
      while (true) {
        SootMethod target=(SootMethod)targets.next();
        if (target == null)         break;
        cg.addEdge(new Edge(vcs.getContainer(),vcs.getStmt(),target));
      }
      if (vcs.getInstanceInvokeExpr().getMethod().getNumberedSubSignature() == sigStart) {
        for (Iterator tIt=types.iterator(); tIt.hasNext(); ) {
          final Type t=(Type)tIt.next();
          VirtualCalls.v().resolve(t,vcs.getInstanceInvokeExpr(),vcs.getContainer(),targetsQueue);
        }
        while (true) {
          SootMethod target=(SootMethod)targets.next();
          if (target == null)           break;
          cg.addEdge(new Edge(vcs.getContainer(),vcs.getStmt(),target,Edge.THREAD));
        }
      }
    }
  }
}","private void processNewMethod(SootMethod m){
  if (m.isNative()) {
    return;
  }
  Body b=m.retrieveActiveBody();
  HashSet receivers=new HashSet();
  getImplicitTargets(m);
  findReceivers(m,b,receivers);
  processReceivers(receivers);
}"
88815,"/** 
 * Returns the set of objects reaching variable l before stmt in method. 
 */
public PointsToSet reachingObjects(Local l){
  return FullObjectSet.v();
}","/** 
 * Returns the set of objects reaching variable l before stmt in method. 
 */
public PointsToSet reachingObjects(Local l){
  Type t=l.getType();
  if (t instanceof RefType)   return FullObjectSet.v((RefType)t);
  return FullObjectSet.v();
}"
88816,"public FullObjectSet(Singletons.Global g){
}","private FullObjectSet(RefType declaredType){
  AnySubType type=AnySubType.v(declaredType);
  types=Collections.singleton(type);
}"
88817,"public static FullObjectSet v(){
  return G.v().FullObjectSet();
}","public static FullObjectSet v(RefType t){
  if (t.getClassName().equals(""String_Node_Str"")) {
    return v();
  }
  return new FullObjectSet(t);
}"
88818,"public boolean parse(String[] argv){
  for (int i=argv.length; i > 0; i--) {
    pushOptions(argv[i - 1]);
  }
  while (hasMoreOptions()) {
    String option=nextOption();
    if (option.charAt(0) != '-') {
      classes.add(option);
      continue;
    }
    while (option.charAt(0) == '-') {
      option=option.substring(1);
    }
    if (false)     ;
 else     if (false || option.equals(""String_Node_Str"") || option.equals(""String_Node_Str""))     help=true;
 else     if (false || option.equals(""String_Node_Str""))     version=true;
 else     if (false || option.equals(""String_Node_Str"") || option.equals(""String_Node_Str""))     verbose=true;
 else     if (false || option.equals(""String_Node_Str""))     app=true;
 else     if (false || option.equals(""String_Node_Str"") || option.equals(""String_Node_Str""))     whole_program=true;
 else     if (false || option.equals(""String_Node_Str""))     debug=true;
 else     if (false || option.equals(""String_Node_Str"") || option.equals(""String_Node_Str"")) {
      if (!hasMoreOptions()) {
        G.v().out.println(""String_Node_Str"" + option);
        return false;
      }
      String value=nextOption();
      if (soot_classpath.length() == 0)       soot_classpath=value;
 else {
        G.v().out.println(""String_Node_Str"" + soot_classpath + ""String_Node_Str""+ value+ ""String_Node_Str""+ option);
        return false;
      }
    }
 else     if (false || option.equals(""String_Node_Str"")) {
      if (!hasMoreOptions()) {
        G.v().out.println(""String_Node_Str"" + option);
        return false;
      }
      String value=nextOption();
      if (false)       ;
 else       if (false || value.equals(""String_Node_Str"") || value.equals(""String_Node_Str"")) {
        if (src_prec != 0 && src_prec != src_prec_class) {
          G.v().out.println(""String_Node_Str"" + option);
          return false;
        }
        src_prec=src_prec_class;
      }
 else       if (false || value.equals(""String_Node_Str"") || value.equals(""String_Node_Str"")) {
        if (src_prec != 0 && src_prec != src_prec_jimple) {
          G.v().out.println(""String_Node_Str"" + option);
          return false;
        }
        src_prec=src_prec_jimple;
      }
 else {
        G.v().out.println(""String_Node_Str"" + value + ""String_Node_Str""+ option);
        return false;
      }
    }
 else     if (false || option.equals(""String_Node_Str""))     allow_phantom_refs=true;
 else     if (false || option.equals(""String_Node_Str"") || option.equals(""String_Node_Str"")) {
      if (!hasMoreOptions()) {
        G.v().out.println(""String_Node_Str"" + option);
        return false;
      }
      String value=nextOption();
      if (output_dir.length() == 0)       output_dir=value;
 else {
        G.v().out.println(""String_Node_Str"" + output_dir + ""String_Node_Str""+ value+ ""String_Node_Str""+ option);
        return false;
      }
    }
 else     if (false || option.equals(""String_Node_Str"") || option.equals(""String_Node_Str"")) {
      if (!hasMoreOptions()) {
        G.v().out.println(""String_Node_Str"" + option);
        return false;
      }
      String value=nextOption();
      if (false)       ;
 else       if (false || value.equals(""String_Node_Str"") || value.equals(""String_Node_Str"")) {
        if (output_format != 0 && output_format != output_format_jimp) {
          G.v().out.println(""String_Node_Str"" + option);
          return false;
        }
        output_format=output_format_jimp;
      }
 else       if (false || value.equals(""String_Node_Str"") || value.equals(""String_Node_Str"")) {
        if (output_format != 0 && output_format != output_format_jimple) {
          G.v().out.println(""String_Node_Str"" + option);
          return false;
        }
        output_format=output_format_jimple;
      }
 else       if (false || value.equals(""String_Node_Str"") || value.equals(""String_Node_Str"")) {
        if (output_format != 0 && output_format != output_format_baf) {
          G.v().out.println(""String_Node_Str"" + option);
          return false;
        }
        output_format=output_format_baf;
      }
 else       if (false || value.equals(""String_Node_Str"")) {
        if (output_format != 0 && output_format != output_format_b) {
          G.v().out.println(""String_Node_Str"" + option);
          return false;
        }
        output_format=output_format_b;
      }
 else       if (false || value.equals(""String_Node_Str"") || value.equals(""String_Node_Str"")) {
        if (output_format != 0 && output_format != output_format_grimp) {
          G.v().out.println(""String_Node_Str"" + option);
          return false;
        }
        output_format=output_format_grimp;
      }
 else       if (false || value.equals(""String_Node_Str"") || value.equals(""String_Node_Str"")) {
        if (output_format != 0 && output_format != output_format_grimple) {
          G.v().out.println(""String_Node_Str"" + option);
          return false;
        }
        output_format=output_format_grimple;
      }
 else       if (false || value.equals(""String_Node_Str"") || value.equals(""String_Node_Str"")) {
        if (output_format != 0 && output_format != output_format_xml) {
          G.v().out.println(""String_Node_Str"" + option);
          return false;
        }
        output_format=output_format_xml;
      }
 else       if (false || value.equals(""String_Node_Str"") || value.equals(""String_Node_Str"")) {
        if (output_format != 0 && output_format != output_format_none) {
          G.v().out.println(""String_Node_Str"" + option);
          return false;
        }
        output_format=output_format_none;
      }
 else       if (false || value.equals(""String_Node_Str"") || value.equals(""String_Node_Str"")) {
        if (output_format != 0 && output_format != output_format_jasmin) {
          G.v().out.println(""String_Node_Str"" + option);
          return false;
        }
        output_format=output_format_jasmin;
      }
 else       if (false || value.equals(""String_Node_Str"") || value.equals(""String_Node_Str"")) {
        if (output_format != 0 && output_format != output_format_class) {
          G.v().out.println(""String_Node_Str"" + option);
          return false;
        }
        output_format=output_format_class;
      }
 else       if (false || value.equals(""String_Node_Str"") || value.equals(""String_Node_Str"")) {
        if (output_format != 0 && output_format != output_format_dava) {
          G.v().out.println(""String_Node_Str"" + option);
          return false;
        }
        output_format=output_format_dava;
      }
 else {
        G.v().out.println(""String_Node_Str"" + value + ""String_Node_Str""+ option);
        return false;
      }
    }
 else     if (false || option.equals(""String_Node_Str""))     via_grimp=true;
 else     if (false || option.equals(""String_Node_Str""))     xml_attributes=true;
 else     if (false || option.equals(""String_Node_Str"") || option.equals(""String_Node_Str"")) {
      if (!hasMoreOptions()) {
        G.v().out.println(""String_Node_Str"" + option);
        return false;
      }
      String phaseName=nextOption();
      if (!hasMoreOptions()) {
        G.v().out.println(""String_Node_Str"" + option + ""String_Node_Str""+ phaseName);
        return false;
      }
      String phaseOption=nextOption();
      if (!setPhaseOption(phaseName,phaseOption))       return false;
    }
 else     if (false || option.equals(""String_Node_Str"") || option.equals(""String_Node_Str"")) {
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
    }
 else     if (false || option.equals(""String_Node_Str"") || option.equals(""String_Node_Str"")) {
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
    }
 else     if (false || option.equals(""String_Node_Str""))     via_shimple=true;
 else     if (false || option.equals(""String_Node_Str"")) {
      if (!hasMoreOptions()) {
        G.v().out.println(""String_Node_Str"" + option);
        return false;
      }
      String value=nextOption();
      if (process_path == null)       process_path=new LinkedList();
      process_path.add(value);
    }
 else     if (false || option.equals(""String_Node_Str"") || option.equals(""String_Node_Str"")) {
      if (!hasMoreOptions()) {
        G.v().out.println(""String_Node_Str"" + option);
        return false;
      }
      String value=nextOption();
      if (include == null)       include=new LinkedList();
      include.add(value);
    }
 else     if (false || option.equals(""String_Node_Str"") || option.equals(""String_Node_Str"")) {
      if (!hasMoreOptions()) {
        G.v().out.println(""String_Node_Str"" + option);
        return false;
      }
      String value=nextOption();
      if (exclude == null)       exclude=new LinkedList();
      exclude.add(value);
    }
 else     if (false || option.equals(""String_Node_Str"")) {
      if (!hasMoreOptions()) {
        G.v().out.println(""String_Node_Str"" + option);
        return false;
      }
      String value=nextOption();
      if (dynamic_classes == null)       dynamic_classes=new LinkedList();
      dynamic_classes.add(value);
    }
 else     if (false || option.equals(""String_Node_Str"")) {
      if (!hasMoreOptions()) {
        G.v().out.println(""String_Node_Str"" + option);
        return false;
      }
      String value=nextOption();
      if (dynamic_path == null)       dynamic_path=new LinkedList();
      dynamic_path.add(value);
    }
 else     if (false || option.equals(""String_Node_Str"")) {
      if (!hasMoreOptions()) {
        G.v().out.println(""String_Node_Str"" + option);
        return false;
      }
      String value=nextOption();
      if (dynamic_package == null)       dynamic_package=new LinkedList();
      dynamic_package.add(value);
    }
 else     if (false || option.equals(""String_Node_Str""))     keep_line_number=true;
 else     if (false || option.equals(""String_Node_Str"") || option.equals(""String_Node_Str""))     keep_offset=true;
 else     if (false || option.equals(""String_Node_Str"")) {
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
    }
 else     if (false || option.equals(""String_Node_Str"")) {
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
    }
 else     if (false || option.equals(""String_Node_Str"")) {
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
    }
 else     if (false || option.equals(""String_Node_Str"")) {
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
    }
 else     if (false || option.equals(""String_Node_Str""))     time=true;
 else     if (false || option.equals(""String_Node_Str""))     subtract_gc=true;
 else {
      G.v().out.println(""String_Node_Str"" + option);
      return false;
    }
  }
  return true;
}","public boolean parse(String[] argv){
  for (int i=argv.length; i > 0; i--) {
    pushOptions(argv[i - 1]);
  }
  while (hasMoreOptions()) {
    String option=nextOption();
    if (option.charAt(0) != '-') {
      classes.add(option);
      continue;
    }
    while (option.charAt(0) == '-') {
      option=option.substring(1);
    }
    if (false)     ;
 else     if (false || option.equals(""String_Node_Str"") || option.equals(""String_Node_Str""))     help=true;
 else     if (false || option.equals(""String_Node_Str""))     version=true;
 else     if (false || option.equals(""String_Node_Str"") || option.equals(""String_Node_Str""))     verbose=true;
 else     if (false || option.equals(""String_Node_Str""))     app=true;
 else     if (false || option.equals(""String_Node_Str"") || option.equals(""String_Node_Str""))     whole_program=true;
 else     if (false || option.equals(""String_Node_Str""))     debug=true;
 else     if (false || option.equals(""String_Node_Str"") || option.equals(""String_Node_Str"")|| option.equals(""String_Node_Str"")) {
      if (!hasMoreOptions()) {
        G.v().out.println(""String_Node_Str"" + option);
        return false;
      }
      String value=nextOption();
      if (soot_classpath.length() == 0)       soot_classpath=value;
 else {
        G.v().out.println(""String_Node_Str"" + soot_classpath + ""String_Node_Str""+ value+ ""String_Node_Str""+ option);
        return false;
      }
    }
 else     if (false || option.equals(""String_Node_Str"")) {
      if (!hasMoreOptions()) {
        G.v().out.println(""String_Node_Str"" + option);
        return false;
      }
      String value=nextOption();
      if (false)       ;
 else       if (false || value.equals(""String_Node_Str"") || value.equals(""String_Node_Str"")) {
        if (src_prec != 0 && src_prec != src_prec_class) {
          G.v().out.println(""String_Node_Str"" + option);
          return false;
        }
        src_prec=src_prec_class;
      }
 else       if (false || value.equals(""String_Node_Str"") || value.equals(""String_Node_Str"")) {
        if (src_prec != 0 && src_prec != src_prec_jimple) {
          G.v().out.println(""String_Node_Str"" + option);
          return false;
        }
        src_prec=src_prec_jimple;
      }
 else {
        G.v().out.println(""String_Node_Str"" + value + ""String_Node_Str""+ option);
        return false;
      }
    }
 else     if (false || option.equals(""String_Node_Str""))     allow_phantom_refs=true;
 else     if (false || option.equals(""String_Node_Str"") || option.equals(""String_Node_Str"")) {
      if (!hasMoreOptions()) {
        G.v().out.println(""String_Node_Str"" + option);
        return false;
      }
      String value=nextOption();
      if (output_dir.length() == 0)       output_dir=value;
 else {
        G.v().out.println(""String_Node_Str"" + output_dir + ""String_Node_Str""+ value+ ""String_Node_Str""+ option);
        return false;
      }
    }
 else     if (false || option.equals(""String_Node_Str"") || option.equals(""String_Node_Str"")) {
      if (!hasMoreOptions()) {
        G.v().out.println(""String_Node_Str"" + option);
        return false;
      }
      String value=nextOption();
      if (false)       ;
 else       if (false || value.equals(""String_Node_Str"") || value.equals(""String_Node_Str"")) {
        if (output_format != 0 && output_format != output_format_jimp) {
          G.v().out.println(""String_Node_Str"" + option);
          return false;
        }
        output_format=output_format_jimp;
      }
 else       if (false || value.equals(""String_Node_Str"") || value.equals(""String_Node_Str"")) {
        if (output_format != 0 && output_format != output_format_jimple) {
          G.v().out.println(""String_Node_Str"" + option);
          return false;
        }
        output_format=output_format_jimple;
      }
 else       if (false || value.equals(""String_Node_Str"") || value.equals(""String_Node_Str"")) {
        if (output_format != 0 && output_format != output_format_baf) {
          G.v().out.println(""String_Node_Str"" + option);
          return false;
        }
        output_format=output_format_baf;
      }
 else       if (false || value.equals(""String_Node_Str"")) {
        if (output_format != 0 && output_format != output_format_b) {
          G.v().out.println(""String_Node_Str"" + option);
          return false;
        }
        output_format=output_format_b;
      }
 else       if (false || value.equals(""String_Node_Str"") || value.equals(""String_Node_Str"")) {
        if (output_format != 0 && output_format != output_format_grimp) {
          G.v().out.println(""String_Node_Str"" + option);
          return false;
        }
        output_format=output_format_grimp;
      }
 else       if (false || value.equals(""String_Node_Str"") || value.equals(""String_Node_Str"")) {
        if (output_format != 0 && output_format != output_format_grimple) {
          G.v().out.println(""String_Node_Str"" + option);
          return false;
        }
        output_format=output_format_grimple;
      }
 else       if (false || value.equals(""String_Node_Str"") || value.equals(""String_Node_Str"")) {
        if (output_format != 0 && output_format != output_format_xml) {
          G.v().out.println(""String_Node_Str"" + option);
          return false;
        }
        output_format=output_format_xml;
      }
 else       if (false || value.equals(""String_Node_Str"") || value.equals(""String_Node_Str"")) {
        if (output_format != 0 && output_format != output_format_none) {
          G.v().out.println(""String_Node_Str"" + option);
          return false;
        }
        output_format=output_format_none;
      }
 else       if (false || value.equals(""String_Node_Str"") || value.equals(""String_Node_Str"")) {
        if (output_format != 0 && output_format != output_format_jasmin) {
          G.v().out.println(""String_Node_Str"" + option);
          return false;
        }
        output_format=output_format_jasmin;
      }
 else       if (false || value.equals(""String_Node_Str"") || value.equals(""String_Node_Str"")) {
        if (output_format != 0 && output_format != output_format_class) {
          G.v().out.println(""String_Node_Str"" + option);
          return false;
        }
        output_format=output_format_class;
      }
 else       if (false || value.equals(""String_Node_Str"") || value.equals(""String_Node_Str"")) {
        if (output_format != 0 && output_format != output_format_dava) {
          G.v().out.println(""String_Node_Str"" + option);
          return false;
        }
        output_format=output_format_dava;
      }
 else {
        G.v().out.println(""String_Node_Str"" + value + ""String_Node_Str""+ option);
        return false;
      }
    }
 else     if (false || option.equals(""String_Node_Str""))     via_grimp=true;
 else     if (false || option.equals(""String_Node_Str""))     xml_attributes=true;
 else     if (false || option.equals(""String_Node_Str"") || option.equals(""String_Node_Str"")) {
      if (!hasMoreOptions()) {
        G.v().out.println(""String_Node_Str"" + option);
        return false;
      }
      String phaseName=nextOption();
      if (!hasMoreOptions()) {
        G.v().out.println(""String_Node_Str"" + option + ""String_Node_Str""+ phaseName);
        return false;
      }
      String phaseOption=nextOption();
      if (!setPhaseOption(phaseName,phaseOption))       return false;
    }
 else     if (false || option.equals(""String_Node_Str"") || option.equals(""String_Node_Str"")) {
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
    }
 else     if (false || option.equals(""String_Node_Str"") || option.equals(""String_Node_Str"")) {
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
    }
 else     if (false || option.equals(""String_Node_Str""))     via_shimple=true;
 else     if (false || option.equals(""String_Node_Str"")) {
      if (!hasMoreOptions()) {
        G.v().out.println(""String_Node_Str"" + option);
        return false;
      }
      String value=nextOption();
      if (process_path == null)       process_path=new LinkedList();
      process_path.add(value);
    }
 else     if (false || option.equals(""String_Node_Str"") || option.equals(""String_Node_Str"")) {
      if (!hasMoreOptions()) {
        G.v().out.println(""String_Node_Str"" + option);
        return false;
      }
      String value=nextOption();
      if (include == null)       include=new LinkedList();
      include.add(value);
    }
 else     if (false || option.equals(""String_Node_Str"") || option.equals(""String_Node_Str"")) {
      if (!hasMoreOptions()) {
        G.v().out.println(""String_Node_Str"" + option);
        return false;
      }
      String value=nextOption();
      if (exclude == null)       exclude=new LinkedList();
      exclude.add(value);
    }
 else     if (false || option.equals(""String_Node_Str"")) {
      if (!hasMoreOptions()) {
        G.v().out.println(""String_Node_Str"" + option);
        return false;
      }
      String value=nextOption();
      if (dynamic_classes == null)       dynamic_classes=new LinkedList();
      dynamic_classes.add(value);
    }
 else     if (false || option.equals(""String_Node_Str"")) {
      if (!hasMoreOptions()) {
        G.v().out.println(""String_Node_Str"" + option);
        return false;
      }
      String value=nextOption();
      if (dynamic_path == null)       dynamic_path=new LinkedList();
      dynamic_path.add(value);
    }
 else     if (false || option.equals(""String_Node_Str"")) {
      if (!hasMoreOptions()) {
        G.v().out.println(""String_Node_Str"" + option);
        return false;
      }
      String value=nextOption();
      if (dynamic_package == null)       dynamic_package=new LinkedList();
      dynamic_package.add(value);
    }
 else     if (false || option.equals(""String_Node_Str""))     keep_line_number=true;
 else     if (false || option.equals(""String_Node_Str"") || option.equals(""String_Node_Str""))     keep_offset=true;
 else     if (false || option.equals(""String_Node_Str"")) {
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
    }
 else     if (false || option.equals(""String_Node_Str"")) {
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
    }
 else     if (false || option.equals(""String_Node_Str"")) {
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
    }
 else     if (false || option.equals(""String_Node_Str"")) {
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
      pushOptions(""String_Node_Str"");
    }
 else     if (false || option.equals(""String_Node_Str""))     time=true;
 else     if (false || option.equals(""String_Node_Str""))     subtract_gc=true;
 else {
      G.v().out.println(""String_Node_Str"" + option);
      return false;
    }
  }
  return true;
}"
88819,"protected void pushOptions(String s){
  StringTokenizer t=new StringTokenizer(s);
  while (t.hasMoreTokens())   options.addFirst(t.nextToken());
}","protected void pushOptions(String s){
  options.addFirst(s);
}"
88820,"/** 
 * Associates a value with a key. 
 */
public boolean put(Numberable key,Object value){
  int pos=findPosition(key);
  if (array[pos] == key)   return false;
  size++;
  if (size * 3 > array.length * 2)   doubleSize();
  pos=findPosition(key);
  array[pos]=key;
  values[pos]=value;
  return true;
}","/** 
 * Associates a value with a key. 
 */
public boolean put(Numberable key,Object value){
  int pos=findPosition(key);
  if (array[pos] == key) {
    if (values[pos] == value)     return false;
    values[pos]=value;
    return true;
  }
  size++;
  if (size * 3 > array.length * 2) {
    doubleSize();
    pos=findPosition(key);
  }
  array[pos]=key;
  values[pos]=value;
  return true;
}"
88821,"public void convertToBaf(final JimpleToBafContext context,final List out){
  final Value lvalue=this.getLeftOp();
  final Value rvalue=this.getRightOp();
  if (lvalue instanceof Local && (rvalue instanceof AddExpr || rvalue instanceof SubExpr)) {
    Local l=(Local)lvalue;
    BinopExpr expr=(BinopExpr)rvalue;
    Value op1=expr.getOp1();
    Value op2=expr.getOp2();
    if (l.getType().equals(IntType.v())) {
      boolean isValidCase=false;
      int x=0;
      if (op1 == l && op2 instanceof IntConstant) {
        x=((IntConstant)op2).value;
        isValidCase=true;
      }
 else       if (expr instanceof AddExpr && op2 == l && op1 instanceof IntConstant) {
        x=((IntConstant)op1).value;
        isValidCase=true;
      }
      if (isValidCase && x >= Short.MIN_VALUE && x <= Short.MAX_VALUE) {
        Unit u=Baf.v().newIncInst(context.getBafLocalOfJimpleLocal(l),IntConstant.v((expr instanceof AddExpr) ? x : -x));
        out.add(u);
        Iterator it=getTags().iterator();
        while (it.hasNext()) {
          u.addTag((Tag)it.next());
        }
        return;
      }
    }
  }
  context.setCurrentUnit(this);
  lvalue.apply(new AbstractJimpleValueSwitch(){
    public void caseArrayRef(    ArrayRef v){
      ((ConvertToBaf)(v.getBase())).convertToBaf(context,out);
      ((ConvertToBaf)(v.getIndex())).convertToBaf(context,out);
      ((ConvertToBaf)rvalue).convertToBaf(context,out);
      Unit u=Baf.v().newArrayWriteInst(v.getType());
      Iterator it=getTags().iterator();
      while (it.hasNext()) {
        u.addTag((Tag)it.next());
      }
      out.add(u);
    }
    public void defaultCase(    Value v){
      throw new RuntimeException(""String_Node_Str"" + v);
    }
    public void caseInstanceFieldRef(    InstanceFieldRef v){
      ((ConvertToBaf)(v.getBase())).convertToBaf(context,out);
      ((ConvertToBaf)rvalue).convertToBaf(context,out);
      Unit u=Baf.v().newFieldPutInst(v.getField());
      Iterator it=getTags().iterator();
      while (it.hasNext()) {
        u.addTag((Tag)it.next());
      }
      out.add(u);
    }
    public void caseLocal(    final Local v){
      ((ConvertToBaf)rvalue).convertToBaf(context,out);
      Unit u=(Unit)out.get(out.size() - 1);
      Iterator it=getTags().iterator();
      while (it.hasNext()) {
        u.addTag((Tag)it.next());
      }
      u=Baf.v().newStoreInst(v.getType(),context.getBafLocalOfJimpleLocal(v));
      out.add(u);
    }
    public void caseStaticFieldRef(    StaticFieldRef v){
      ((ConvertToBaf)rvalue).convertToBaf(context,out);
      Unit u=Baf.v().newStaticPutInst(v.getField());
      Iterator it=getTags().iterator();
      while (it.hasNext()) {
        u.addTag((Tag)it.next());
      }
      out.add(u);
    }
  }
);
}","public void convertToBaf(final JimpleToBafContext context,final List out){
  final Value lvalue=this.getLeftOp();
  final Value rvalue=this.getRightOp();
  if (lvalue instanceof Local && (rvalue instanceof AddExpr || rvalue instanceof SubExpr)) {
    Local l=(Local)lvalue;
    BinopExpr expr=(BinopExpr)rvalue;
    Value op1=expr.getOp1();
    Value op2=expr.getOp2();
    if (l.getType().equals(IntType.v())) {
      boolean isValidCase=false;
      int x=0;
      if (op1 == l && op2 instanceof IntConstant) {
        x=((IntConstant)op2).value;
        isValidCase=true;
      }
 else       if (expr instanceof AddExpr && op2 == l && op1 instanceof IntConstant) {
        x=((IntConstant)op1).value;
        isValidCase=true;
      }
      if (isValidCase && x >= Short.MIN_VALUE && x <= Short.MAX_VALUE) {
        Unit u=Baf.v().newIncInst(context.getBafLocalOfJimpleLocal(l),IntConstant.v((expr instanceof AddExpr) ? x : -x));
        out.add(u);
        Iterator it=getTags().iterator();
        while (it.hasNext()) {
          u.addTag((Tag)it.next());
        }
        return;
      }
    }
  }
  context.setCurrentUnit(this);
  lvalue.apply(new AbstractJimpleValueSwitch(){
    public void caseArrayRef(    ArrayRef v){
      ((ConvertToBaf)(v.getBase())).convertToBaf(context,out);
      ((ConvertToBaf)(v.getIndex())).convertToBaf(context,out);
      ((ConvertToBaf)rvalue).convertToBaf(context,out);
      Unit u=Baf.v().newArrayWriteInst(v.getType());
      Iterator it=getTags().iterator();
      while (it.hasNext()) {
        u.addTag((Tag)it.next());
      }
      out.add(u);
    }
    public void defaultCase(    Value v){
      throw new RuntimeException(""String_Node_Str"" + v);
    }
    public void caseInstanceFieldRef(    InstanceFieldRef v){
      ((ConvertToBaf)(v.getBase())).convertToBaf(context,out);
      ((ConvertToBaf)rvalue).convertToBaf(context,out);
      Unit u=Baf.v().newFieldPutInst(v.getField());
      Iterator it=getTags().iterator();
      while (it.hasNext()) {
        u.addTag((Tag)it.next());
      }
      out.add(u);
    }
    public void caseLocal(    final Local v){
      ((ConvertToBaf)rvalue).convertToBaf(context,out);
      Unit u=Baf.v().newStoreInst(v.getType(),context.getBafLocalOfJimpleLocal(v));
      Iterator it=getTags().iterator();
      while (it.hasNext()) {
        u.addTag((Tag)it.next());
      }
      out.add(u);
    }
    public void caseStaticFieldRef(    StaticFieldRef v){
      ((ConvertToBaf)rvalue).convertToBaf(context,out);
      Unit u=Baf.v().newStaticPutInst(v.getField());
      Iterator it=getTags().iterator();
      while (it.hasNext()) {
        u.addTag((Tag)it.next());
      }
      out.add(u);
    }
  }
);
}"
88822,"public void caseLocal(final Local v){
  ((ConvertToBaf)rvalue).convertToBaf(context,out);
  Unit u=(Unit)out.get(out.size() - 1);
  Iterator it=getTags().iterator();
  while (it.hasNext()) {
    u.addTag((Tag)it.next());
  }
  u=Baf.v().newStoreInst(v.getType(),context.getBafLocalOfJimpleLocal(v));
  out.add(u);
}","public void caseLocal(final Local v){
  ((ConvertToBaf)rvalue).convertToBaf(context,out);
  Unit u=Baf.v().newStoreInst(v.getType(),context.getBafLocalOfJimpleLocal(v));
  Iterator it=getTags().iterator();
  while (it.hasNext()) {
    u.addTag((Tag)it.next());
  }
  out.add(u);
}"
88823,"private void loadNecessaryClasses(){
  Iterator it=Options.v().classes().iterator();
  while (it.hasNext()) {
    String name=(String)it.next();
    SootClass c;
    c=Scene.v().loadClassAndSupport(name);
    if (mainClass == null) {
      mainClass=c;
      Scene.v().setMainClass(c);
    }
    c.setApplicationClass();
  }
  HashSet dynClasses=new HashSet();
  dynClasses.addAll(Options.v().dynamic_classes());
  for (Iterator pathIt=Options.v().dynamic_path().iterator(); pathIt.hasNext(); ) {
    final String path=(String)pathIt.next();
    dynClasses.addAll(getClassesUnder(path));
  }
  for (Iterator pkgIt=Options.v().dynamic_package().iterator(); pkgIt.hasNext(); ) {
    final String pkg=(String)pkgIt.next();
    dynClasses.addAll(classesInDynamicPackage(pkg));
  }
  while (it.hasNext()) {
    Object o=it.next();
    Scene.v().loadClassAndSupport((String)o);
  }
  for (Iterator pathIt=Options.v().process_path().iterator(); pathIt.hasNext(); ) {
    final String path=(String)pathIt.next();
    for (Iterator clIt=getClassesUnder(path).iterator(); clIt.hasNext(); ) {
      final String cl=(String)clIt.next();
      Scene.v().loadClassAndSupport(cl).setApplicationClass();
    }
  }
}","private void loadNecessaryClasses(){
  Iterator it=Options.v().classes().iterator();
  while (it.hasNext()) {
    String name=(String)it.next();
    SootClass c;
    c=Scene.v().loadClassAndSupport(name);
    if (mainClass == null) {
      mainClass=c;
      Scene.v().setMainClass(c);
    }
    c.setApplicationClass();
  }
  HashSet dynClasses=new HashSet();
  dynClasses.addAll(Options.v().dynamic_classes());
  for (Iterator pathIt=Options.v().dynamic_path().iterator(); pathIt.hasNext(); ) {
    final String path=(String)pathIt.next();
    dynClasses.addAll(getClassesUnder(path));
  }
  for (Iterator pkgIt=Options.v().dynamic_package().iterator(); pkgIt.hasNext(); ) {
    final String pkg=(String)pkgIt.next();
    dynClasses.addAll(classesInDynamicPackage(pkg));
  }
  for (Iterator classNameIt=dynClasses.iterator(); classNameIt.hasNext(); ) {
    final String className=(String)classNameIt.next();
    Scene.v().loadClassAndSupport(className);
  }
  for (Iterator pathIt=Options.v().process_path().iterator(); pathIt.hasNext(); ) {
    final String path=(String)pathIt.next();
    for (Iterator clIt=getClassesUnder(path).iterator(); clIt.hasNext(); ) {
      final String cl=(String)clIt.next();
      Scene.v().loadClassAndSupport(cl).setApplicationClass();
    }
  }
}"
88824,"protected void internalApply(){
  for (Iterator tIt=this.iterator(); tIt.hasNext(); ) {
    final Transform t=(Transform)tIt.next();
    t.apply();
  }
  LinkedList enableds=new LinkedList();
  for (Iterator tIt=this.iterator(); tIt.hasNext(); ) {
    final Transform t=(Transform)tIt.next();
    Map opts=PackManager.v().getPhaseOptions(t);
    if (PackManager.getBoolean(opts,""String_Node_Str""))     continue;
    enableds.add(t);
  }
  if (enableds.size() == 0) {
    Transform deflt=(Transform)iterator().next();
    PackManager.v().setPhaseOption(deflt.getPhaseName(),""String_Node_Str"");
    enableds.add(deflt);
  }
  if (enableds.size() > 1) {
    G.v().out.println(""String_Node_Str"" + getPhaseName() + ""String_Node_Str"");
    for (Iterator tIt=enableds.iterator(); tIt.hasNext(); ) {
      final Transform t=(Transform)tIt.next();
      G.v().out.println(""String_Node_Str"" + t.getPhaseName());
    }
    throw new CompilationDeathException(Main.COMPILATION_ABORTED);
  }
  for (Iterator tIt=enableds.iterator(); tIt.hasNext(); ) {
    final Transform t=(Transform)tIt.next();
    t.apply();
  }
}","protected void internalApply(){
  LinkedList enableds=new LinkedList();
  for (Iterator tIt=this.iterator(); tIt.hasNext(); ) {
    final Transform t=(Transform)tIt.next();
    Map opts=PackManager.v().getPhaseOptions(t);
    if (PackManager.getBoolean(opts,""String_Node_Str""))     continue;
    enableds.add(t);
  }
  if (enableds.size() == 0) {
    Transform deflt=(Transform)iterator().next();
    PackManager.v().setPhaseOption(deflt.getPhaseName(),""String_Node_Str"");
    enableds.add(deflt);
  }
  if (enableds.size() > 1) {
    G.v().out.println(""String_Node_Str"" + getPhaseName() + ""String_Node_Str"");
    for (Iterator tIt=enableds.iterator(); tIt.hasNext(); ) {
      final Transform t=(Transform)tIt.next();
      G.v().out.println(""String_Node_Str"" + t.getPhaseName());
    }
    throw new CompilationDeathException(Main.COMPILATION_ABORTED);
  }
  for (Iterator tIt=enableds.iterator(); tIt.hasNext(); ) {
    final Transform t=(Transform)tIt.next();
    t.apply();
  }
}"
88825,"public BafBody(Body body,Map options){
  super(body.getMethod());
  if (Options.v().verbose())   G.v().out.println(""String_Node_Str"" + getMethod().getName() + ""String_Node_Str"");
  JimpleBody jimpleBody;
  if (body instanceof JimpleBody)   jimpleBody=(JimpleBody)body;
 else   throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"");
  jimpleBody.validate();
  JimpleToBafContext context=new JimpleToBafContext(jimpleBody.getLocalCount());
{
    Iterator localIt=jimpleBody.getLocals().iterator();
    while (localIt.hasNext()) {
      Local l=(Local)localIt.next();
      Type t=l.getType();
      Local newLocal;
      newLocal=Baf.v().newLocal(l.getName(),UnknownType.v());
      if (t.equals(DoubleType.v()) || t.equals(LongType.v()))       newLocal.setType(DoubleWordType.v());
 else       newLocal.setType(WordType.v());
      context.setBafLocalOfJimpleLocal(l,newLocal);
      getLocals().add(newLocal);
    }
  }
  Map stmtToFirstInstruction=new HashMap();
{
    Iterator stmtIt=jimpleBody.getUnits().iterator();
    while (stmtIt.hasNext()) {
      Stmt s=(Stmt)stmtIt.next();
      List conversionList=new ArrayList();
      context.setCurrentUnit(s);
      ((ConvertToBaf)s).convertToBaf(context,conversionList);
      stmtToFirstInstruction.put(s,conversionList.get(0));
      getUnits().addAll(conversionList);
    }
  }
{
    Iterator boxIt=getUnitBoxes().iterator();
    while (boxIt.hasNext()) {
      UnitBox box=(UnitBox)boxIt.next();
      if (box.getUnit() instanceof PlaceholderInst) {
        Unit source=((PlaceholderInst)box.getUnit()).getSource();
        box.setUnit((Unit)stmtToFirstInstruction.get(source));
      }
    }
  }
{
    Iterator trapIt=jimpleBody.getTraps().iterator();
    while (trapIt.hasNext()) {
      Trap trap=(Trap)trapIt.next();
      getTraps().add(Baf.v().newTrap(trap.getException(),(Unit)stmtToFirstInstruction.get(trap.getBeginUnit()),(Unit)stmtToFirstInstruction.get(trap.getEndUnit()),(Unit)stmtToFirstInstruction.get(trap.getHandlerUnit())));
    }
  }
  PackManager.v().getPack(""String_Node_Str"").apply(this);
  PackManager.v().getPack(""String_Node_Str"").apply(this);
}","public BafBody(Body body,Map options){
  super(body.getMethod());
  if (Options.v().verbose())   G.v().out.println(""String_Node_Str"" + getMethod().getName() + ""String_Node_Str"");
  JimpleBody jimpleBody;
  if (body instanceof JimpleBody)   jimpleBody=(JimpleBody)body;
 else   throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"");
  jimpleBody.validate();
  JimpleToBafContext context=new JimpleToBafContext(jimpleBody.getLocalCount());
{
    Iterator localIt=jimpleBody.getLocals().iterator();
    while (localIt.hasNext()) {
      Local l=(Local)localIt.next();
      Type t=l.getType();
      Local newLocal;
      newLocal=Baf.v().newLocal(l.getName(),UnknownType.v());
      if (t.equals(DoubleType.v()) || t.equals(LongType.v()))       newLocal.setType(DoubleWordType.v());
 else       newLocal.setType(WordType.v());
      context.setBafLocalOfJimpleLocal(l,newLocal);
      getLocals().add(newLocal);
    }
  }
  Map stmtToFirstInstruction=new HashMap();
{
    Iterator stmtIt=jimpleBody.getUnits().iterator();
    while (stmtIt.hasNext()) {
      Stmt s=(Stmt)stmtIt.next();
      List conversionList=new ArrayList();
      context.setCurrentUnit(s);
      ((ConvertToBaf)s).convertToBaf(context,conversionList);
      stmtToFirstInstruction.put(s,conversionList.get(0));
      getUnits().addAll(conversionList);
    }
  }
{
    Iterator boxIt=getUnitBoxes().iterator();
    while (boxIt.hasNext()) {
      UnitBox box=(UnitBox)boxIt.next();
      if (box.getUnit() instanceof PlaceholderInst) {
        Unit source=((PlaceholderInst)box.getUnit()).getSource();
        box.setUnit((Unit)stmtToFirstInstruction.get(source));
      }
    }
  }
{
    Iterator trapIt=jimpleBody.getTraps().iterator();
    while (trapIt.hasNext()) {
      Trap trap=(Trap)trapIt.next();
      getTraps().add(Baf.v().newTrap(trap.getException(),(Unit)stmtToFirstInstruction.get(trap.getBeginUnit()),(Unit)stmtToFirstInstruction.get(trap.getEndUnit()),(Unit)stmtToFirstInstruction.get(trap.getHandlerUnit())));
    }
  }
  PackManager.v().getPack(""String_Node_Str"").apply(this);
}"
88826,"/** 
 * Decide whether this tag should be aggregated by this aggregator. Return the tag to be attached to this unit, or null if nothing should be attached. 
 */
public Tag wantTag(Tag t,Unit u){
  if (t instanceof DependenceTag)   return t;
  return null;
}","/** 
 * Decide whether this tag should be aggregated by this aggregator. Return the tag to be attached to this unit, or null if nothing should be attached. 
 */
public Tag wantTag(Tag t,Unit u){
  if (tags.size() > 0 && tags.getLast() == t) {
    units.removeLast();
    tags.removeLast();
  }
  if (t instanceof DependenceTag)   return t;
  return null;
}"
88827,"protected void internalTransform(Body body,String phaseName,Map options){
  initializationStuff(phaseName);
  SideEffectAnalysis sea=Scene.v().getActiveSideEffectAnalysis();
  optionNaive=PackManager.getBoolean(options,""String_Node_Str"");
  if (!optionNaive) {
    sea.findNTRWSets(body.getMethod());
  }
  HashMap stmtToReadSet=new HashMap();
  HashMap stmtToWriteSet=new HashMap();
  UniqueRWSets sets=new UniqueRWSets();
  boolean justDoTotallyConservativeThing=body.getMethod().getName().equals(""String_Node_Str"");
  for (Iterator stmtIt=body.getUnits().iterator(); stmtIt.hasNext(); ) {
    final Stmt stmt=(Stmt)stmtIt.next();
    if (justDoTotallyConservativeThing || (optionNaive && stmt.containsInvokeExpr())) {
      stmtToReadSet.put(stmt,sets.getUnique(new FullRWSet()));
      stmtToWriteSet.put(stmt,sets.getUnique(new FullRWSet()));
      continue;
    }
    Object key=keyFor(stmt);
    if (!stmtToReadSet.containsKey(key)) {
      stmtToReadSet.put(key,sets.getUnique(sea.readSet(body.getMethod(),stmt)));
      stmtToWriteSet.put(key,sets.getUnique(sea.writeSet(body.getMethod(),stmt)));
    }
  }
  DependenceGraph graph=new DependenceGraph();
  for (Iterator outerIt=sets.iterator(); outerIt.hasNext(); ) {
    final RWSet outer=(RWSet)outerIt.next();
    for (Iterator innerIt=sets.iterator(); innerIt.hasNext(); ) {
      final RWSet inner=(RWSet)innerIt.next();
      if (inner == outer)       break;
      if (outer.hasNonEmptyIntersection(inner)) {
        graph.addEdge(sets.indexOf(outer),sets.indexOf(inner));
      }
    }
  }
  for (Iterator stmtIt=body.getUnits().iterator(); stmtIt.hasNext(); ) {
    final Stmt stmt=(Stmt)stmtIt.next();
    Object key;
    if (optionNaive && stmt.containsInvokeExpr()) {
      key=stmt;
    }
 else {
      key=keyFor(stmt);
    }
    RWSet read=(RWSet)stmtToReadSet.get(key);
    RWSet write=(RWSet)stmtToWriteSet.get(key);
    if (read != null || write != null) {
      DependenceTag tag=new DependenceTag();
      if (read != null && read.getCallsNative()) {
        tag.setCallsNative();
        numNatives++;
      }
 else       if (write != null && write.getCallsNative()) {
        tag.setCallsNative();
        numNatives++;
      }
      tag.setRead(sets.indexOf(read));
      tag.setWrite(sets.indexOf(write));
      if (!justDoTotallyConservativeThing) {
        for (Iterator innerIt=body.getUnits().iterator(); innerIt.hasNext(); ) {
          final Stmt inner=(Stmt)innerIt.next();
          Object ikey;
          if (optionNaive && inner.containsInvokeExpr()) {
            ikey=inner;
          }
 else {
            ikey=keyFor(inner);
          }
          RWSet innerRead=(RWSet)stmtToReadSet.get(ikey);
          RWSet innerWrite=(RWSet)stmtToWriteSet.get(ikey);
          if (graph.areAdjacent(sets.indexOf(read),sets.indexOf(innerWrite)))           numRWs++;
          if (graph.areAdjacent(sets.indexOf(write),sets.indexOf(innerRead)))           numWRs++;
          if (inner == stmt)           continue;
          if (graph.areAdjacent(sets.indexOf(write),sets.indexOf(innerWrite)))           numWWs++;
          if (graph.areAdjacent(sets.indexOf(read),sets.indexOf(innerRead)))           numRRs++;
        }
      }
    }
  }
}","protected void internalTransform(Body body,String phaseName,Map options){
  initializationStuff(phaseName);
  SideEffectAnalysis sea=Scene.v().getActiveSideEffectAnalysis();
  optionNaive=PackManager.getBoolean(options,""String_Node_Str"");
  if (!optionNaive) {
    sea.findNTRWSets(body.getMethod());
  }
  HashMap stmtToReadSet=new HashMap();
  HashMap stmtToWriteSet=new HashMap();
  UniqueRWSets sets=new UniqueRWSets();
  boolean justDoTotallyConservativeThing=body.getMethod().getName().equals(""String_Node_Str"");
  for (Iterator stmtIt=body.getUnits().iterator(); stmtIt.hasNext(); ) {
    final Stmt stmt=(Stmt)stmtIt.next();
    if (justDoTotallyConservativeThing || (optionNaive && stmt.containsInvokeExpr())) {
      stmtToReadSet.put(stmt,sets.getUnique(new FullRWSet()));
      stmtToWriteSet.put(stmt,sets.getUnique(new FullRWSet()));
      continue;
    }
    Object key=keyFor(stmt);
    if (!stmtToReadSet.containsKey(key)) {
      stmtToReadSet.put(key,sets.getUnique(sea.readSet(body.getMethod(),stmt)));
      stmtToWriteSet.put(key,sets.getUnique(sea.writeSet(body.getMethod(),stmt)));
    }
  }
  DependenceGraph graph=new DependenceGraph();
  for (Iterator outerIt=sets.iterator(); outerIt.hasNext(); ) {
    final RWSet outer=(RWSet)outerIt.next();
    for (Iterator innerIt=sets.iterator(); innerIt.hasNext(); ) {
      final RWSet inner=(RWSet)innerIt.next();
      if (inner == outer)       break;
      if (outer.hasNonEmptyIntersection(inner)) {
        graph.addEdge(sets.indexOf(outer),sets.indexOf(inner));
      }
    }
  }
  body.getMethod().addTag(graph);
  for (Iterator stmtIt=body.getUnits().iterator(); stmtIt.hasNext(); ) {
    final Stmt stmt=(Stmt)stmtIt.next();
    Object key;
    if (optionNaive && stmt.containsInvokeExpr()) {
      key=stmt;
    }
 else {
      key=keyFor(stmt);
    }
    RWSet read=(RWSet)stmtToReadSet.get(key);
    RWSet write=(RWSet)stmtToWriteSet.get(key);
    if (read != null || write != null) {
      DependenceTag tag=new DependenceTag();
      if (read != null && read.getCallsNative()) {
        tag.setCallsNative();
        numNatives++;
      }
 else       if (write != null && write.getCallsNative()) {
        tag.setCallsNative();
        numNatives++;
      }
      tag.setRead(sets.indexOf(read));
      tag.setWrite(sets.indexOf(write));
      stmt.addTag(tag);
    }
  }
}"
88828,"public int getInMachineCount(){
  return 2;
}","public int getInMachineCount(){
  return 2 * JasminClass.sizeOfType(getOpType());
}"
88829,"public int getInMachineCount(){
  return 2;
}","public int getInMachineCount(){
  return 2 * JasminClass.sizeOfType(getOpType());
}"
88830,"public int getInMachineCount(){
  return 2;
}","public int getInMachineCount(){
  return 2 * JasminClass.sizeOfType(getOpType());
}"
88831,"public int getInMachineCount(){
  return 2;
}","public int getInMachineCount(){
  return 2 * JasminClass.sizeOfType(getOpType());
}"
88832,"public int getInMachineCount(){
  return 2;
}","public int getInMachineCount(){
  return 2 * JasminClass.sizeOfType(getOpType());
}"
88833,"public int getInMachineCount(){
  return 2;
}","public int getInMachineCount(){
  return 2 * JasminClass.sizeOfType(getOpType());
}"
88834,"public MonitorConverter(Singletons.Global g){
  SootClass davaMonitor=Scene.v().loadClassAndSupport(""String_Node_Str"");
  v=davaMonitor.getMethodByName(""String_Node_Str"");
  enter=davaMonitor.getMethodByName(""String_Node_Str"");
  exit=davaMonitor.getMethodByName(""String_Node_Str"");
}","public MonitorConverter(Singletons.Global g){
  SootClass davaMonitor=new SootClass(""String_Node_Str"",Modifier.PUBLIC);
  davaMonitor.setSuperclass(Scene.v().loadClassAndSupport(""String_Node_Str""));
  LinkedList objectSingleton=new LinkedList();
  objectSingleton.add(RefType.v(""String_Node_Str""));
  v=new SootMethod(""String_Node_Str"",new LinkedList(),RefType.v(""String_Node_Str""),Modifier.PUBLIC | Modifier.STATIC);
  enter=new SootMethod(""String_Node_Str"",objectSingleton,VoidType.v(),Modifier.PUBLIC | Modifier.SYNCHRONIZED);
  exit=new SootMethod(""String_Node_Str"",objectSingleton,VoidType.v(),Modifier.PUBLIC | Modifier.SYNCHRONIZED);
  davaMonitor.addMethod(v);
  davaMonitor.addMethod(enter);
  davaMonitor.addMethod(exit);
  Scene.v().addClass(davaMonitor);
}"
88835,"public boolean equivTo(Object o){
  if (o instanceof BafLocal) {
    return name.equals(((BafLocal)o).name) && type.equals(((BafLocal)o).type);
  }
  return false;
}","public boolean equivTo(Object o){
  return this.equals(o);
}"
88836,"/** 
 * Returns true if the given object is structurally equal to this one. 
 */
public boolean equivTo(Object o){
  if (o instanceof JimpleLocal) {
    return name.equals(((JimpleLocal)o).name) && type.equals(((JimpleLocal)o).type);
  }
  return false;
}","/** 
 * Returns true if the given object is structurally equal to this one. 
 */
public boolean equivTo(Object o){
  return this.equals(o);
}"
88837,"public void printJimpleStyleTo(SootClass cl,PrintWriter out){
  incJimpleLnNum();
{
    StringTokenizer st=new StringTokenizer(Modifier.toString(cl.getModifiers()));
    while (st.hasMoreTokens())     out.print(st.nextToken() + ""String_Node_Str"");
    String classPrefix=""String_Node_Str"";
    if (!cl.isInterface()) {
      classPrefix=classPrefix + ""String_Node_Str"";
      classPrefix=classPrefix.trim();
    }
    out.print(classPrefix + ""String_Node_Str"" + Scene.v().quotedNameOf(cl.getName())+ ""String_Node_Str"");
  }
{
    if (cl.hasSuperclass())     out.print(""String_Node_Str"" + Scene.v().quotedNameOf(cl.getSuperclass().getName()) + ""String_Node_Str"");
  }
{
    Iterator interfaceIt=cl.getInterfaces().iterator();
    if (interfaceIt.hasNext()) {
      out.print(""String_Node_Str"");
      out.print(""String_Node_Str"" + Scene.v().quotedNameOf(((SootClass)interfaceIt.next()).getName()) + ""String_Node_Str"");
      while (interfaceIt.hasNext()) {
        out.print(""String_Node_Str"");
        out.print(""String_Node_Str"" + Scene.v().quotedNameOf(((SootClass)interfaceIt.next()).getName()) + ""String_Node_Str"");
      }
    }
  }
  out.println();
  incJimpleLnNum();
  out.println(""String_Node_Str"");
  incJimpleLnNum();
{
    Iterator fieldIt=cl.getFields().iterator();
    if (fieldIt.hasNext()) {
      while (fieldIt.hasNext()) {
        SootField f=(SootField)fieldIt.next();
        if (f.isPhantom())         continue;
        out.println(""String_Node_Str"" + f.getDeclaration() + ""String_Node_Str"");
        incJimpleLnNum();
      }
    }
  }
{
    Iterator methodIt=cl.methodIterator();
    if (methodIt.hasNext()) {
      if (cl.getMethodCount() != 0) {
        out.println();
        incJimpleLnNum();
      }
      while (methodIt.hasNext()) {
        SootMethod method=(SootMethod)methodIt.next();
        if (method.isPhantom())         continue;
        if (!Modifier.isAbstract(method.getModifiers()) && !Modifier.isNative(method.getModifiers())) {
          if (!method.hasActiveBody())           throw new RuntimeException(""String_Node_Str"" + method.getName() + ""String_Node_Str"");
 else           printTo(method.getActiveBody(),out);
          if (methodIt.hasNext()) {
            out.println();
            incJimpleLnNum();
          }
        }
 else {
          out.print(""String_Node_Str"");
          out.print(method.getDeclaration());
          out.println(""String_Node_Str"");
          incJimpleLnNum();
          if (methodIt.hasNext()) {
            out.println();
            incJimpleLnNum();
          }
        }
      }
    }
  }
  out.println(""String_Node_Str"");
  incJimpleLnNum();
}","public void printJimpleStyleTo(SootClass cl,PrintWriter out){
  incJimpleLnNum();
{
    StringTokenizer st=new StringTokenizer(Modifier.toString(cl.getModifiers()));
    while (st.hasMoreTokens())     out.print(st.nextToken() + ""String_Node_Str"");
    String classPrefix=""String_Node_Str"";
    if (!cl.isInterface()) {
      classPrefix=classPrefix + ""String_Node_Str"";
      classPrefix=classPrefix.trim();
    }
    out.print(classPrefix + ""String_Node_Str"" + Scene.v().quotedNameOf(cl.getName())+ ""String_Node_Str"");
  }
{
    if (cl.hasSuperclass() && !cl.isInterface())     out.print(""String_Node_Str"" + Scene.v().quotedNameOf(cl.getSuperclass().getName()) + ""String_Node_Str"");
  }
{
    Iterator interfaceIt=cl.getInterfaces().iterator();
    if (interfaceIt.hasNext()) {
      out.print(cl.isInterface() ? ""String_Node_Str"" : ""String_Node_Str"");
      out.print(""String_Node_Str"" + Scene.v().quotedNameOf(((SootClass)interfaceIt.next()).getName()) + ""String_Node_Str"");
      while (interfaceIt.hasNext()) {
        out.print(""String_Node_Str"");
        out.print(""String_Node_Str"" + Scene.v().quotedNameOf(((SootClass)interfaceIt.next()).getName()) + ""String_Node_Str"");
      }
    }
  }
  out.println();
  incJimpleLnNum();
  out.println(""String_Node_Str"");
  incJimpleLnNum();
{
    Iterator fieldIt=cl.getFields().iterator();
    if (fieldIt.hasNext()) {
      while (fieldIt.hasNext()) {
        SootField f=(SootField)fieldIt.next();
        if (f.isPhantom())         continue;
        out.println(""String_Node_Str"" + f.getDeclaration() + ""String_Node_Str"");
        incJimpleLnNum();
      }
    }
  }
{
    Iterator methodIt=cl.methodIterator();
    if (methodIt.hasNext()) {
      if (cl.getMethodCount() != 0) {
        out.println();
        incJimpleLnNum();
      }
      while (methodIt.hasNext()) {
        SootMethod method=(SootMethod)methodIt.next();
        if (method.isPhantom())         continue;
        if (!Modifier.isAbstract(method.getModifiers()) && !Modifier.isNative(method.getModifiers())) {
          if (!method.hasActiveBody())           throw new RuntimeException(""String_Node_Str"" + method.getName() + ""String_Node_Str"");
 else           printTo(method.getActiveBody(),out);
          if (methodIt.hasNext()) {
            out.println();
            incJimpleLnNum();
          }
        }
 else {
          out.print(""String_Node_Str"");
          out.print(method.getDeclaration());
          out.println(""String_Node_Str"");
          incJimpleLnNum();
          if (methodIt.hasNext()) {
            out.println();
            incJimpleLnNum();
          }
        }
      }
    }
  }
  out.println(""String_Node_Str"");
  incJimpleLnNum();
}"
88838,"/** 
 * Applies the transformations corresponding to the given options. 
 */
public void applyPhaseOptions(JimpleBody b,Map opts){
  JBOptions options=new JBOptions(opts);
  if (options.verbatim())   return;
  if (options.use_original_names())   PackManager.v().setPhaseOptionIfUnset(""String_Node_Str"",""String_Node_Str"");
  if (!options.no_splitting()) {
    if (Main.v().opts.time())     Timers.v().splitTimer.start();
    PackManager.v().getTransform(""String_Node_Str"").apply(b);
    if (Main.v().opts.time())     Timers.v().splitTimer.end();
    if (!options.no_typing()) {
      if (options.aggregate_all_locals()) {
        PackManager.v().getTransform(""String_Node_Str"").apply(b);
        PackManager.v().getTransform(""String_Node_Str"").apply(b);
      }
 else       if (!options.no_aggregating()) {
        PackManager.v().getTransform(""String_Node_Str"").apply(b);
        PackManager.v().getTransform(""String_Node_Str"").apply(b);
      }
      if (Main.v().opts.time())       Timers.v().assignTimer.start();
      PackManager.v().getTransform(""String_Node_Str"").apply(b);
      if (Main.v().opts.time())       Timers.v().assignTimer.end();
      if (typingFailed(b))       throw new RuntimeException(""String_Node_Str"");
    }
  }
  if (options.aggregate_all_locals()) {
    PackManager.v().getTransform(""String_Node_Str"").apply(b);
    PackManager.v().getTransform(""String_Node_Str"").apply(b);
  }
 else   if (!options.no_aggregating()) {
    PackManager.v().getTransform(""String_Node_Str"").apply(b);
    PackManager.v().getTransform(""String_Node_Str"").apply(b);
  }
  if (!options.use_original_names())   PackManager.v().getTransform(""String_Node_Str"").apply(b);
 else {
    PackManager.v().getTransform(""String_Node_Str"").apply(b);
    PackManager.v().getTransform(""String_Node_Str"").apply(b);
  }
  if (!options.no_cp()) {
    PackManager.v().getTransform(""String_Node_Str"").apply(b);
    PackManager.v().getTransform(""String_Node_Str"").apply(b);
    PackManager.v().getTransform(""String_Node_Str"").apply(b);
  }
  if (options.pack_locals()) {
    PackManager.v().getTransform(""String_Node_Str"").apply(b);
  }
  if (!options.no_nop_elimination())   PackManager.v().getTransform(""String_Node_Str"").apply(b);
  if (!options.no_unreachable_code_elimination())   PackManager.v().getTransform(""String_Node_Str"").apply(b);
  if (soot.Main.v().opts.time())   Timers.v().stmtCount+=b.getUnits().size();
}","/** 
 * Applies the transformations corresponding to the given options. 
 */
private void applyPhaseOptions(JimpleBody b,Map opts){
  JBOptions options=new JBOptions(opts);
  if (options.verbatim())   return;
  if (options.use_original_names())   PackManager.v().setPhaseOptionIfUnset(""String_Node_Str"",""String_Node_Str"");
  if (!options.no_splitting()) {
    if (Main.v().opts.time())     Timers.v().splitTimer.start();
    PackManager.v().getTransform(""String_Node_Str"").apply(b);
    if (Main.v().opts.time())     Timers.v().splitTimer.end();
    if (!options.no_typing()) {
      if (options.aggregate_all_locals()) {
        PackManager.v().getTransform(""String_Node_Str"").apply(b);
        PackManager.v().getTransform(""String_Node_Str"").apply(b);
      }
 else       if (!options.no_aggregating()) {
        PackManager.v().getTransform(""String_Node_Str"").apply(b);
        PackManager.v().getTransform(""String_Node_Str"").apply(b);
      }
      if (Main.v().opts.time())       Timers.v().assignTimer.start();
      PackManager.v().getTransform(""String_Node_Str"").apply(b);
      if (Main.v().opts.time())       Timers.v().assignTimer.end();
      if (typingFailed(b))       throw new RuntimeException(""String_Node_Str"");
    }
  }
  if (options.aggregate_all_locals()) {
    PackManager.v().getTransform(""String_Node_Str"").apply(b);
    PackManager.v().getTransform(""String_Node_Str"").apply(b);
  }
 else   if (!options.no_aggregating()) {
    PackManager.v().getTransform(""String_Node_Str"").apply(b);
    PackManager.v().getTransform(""String_Node_Str"").apply(b);
  }
  if (!options.use_original_names())   PackManager.v().getTransform(""String_Node_Str"").apply(b);
 else {
    PackManager.v().getTransform(""String_Node_Str"").apply(b);
    PackManager.v().getTransform(""String_Node_Str"").apply(b);
  }
  if (!options.no_cp()) {
    PackManager.v().getTransform(""String_Node_Str"").apply(b);
    PackManager.v().getTransform(""String_Node_Str"").apply(b);
    PackManager.v().getTransform(""String_Node_Str"").apply(b);
  }
  if (options.pack_locals()) {
    PackManager.v().getTransform(""String_Node_Str"").apply(b);
  }
  if (!options.no_nop_elimination())   PackManager.v().getTransform(""String_Node_Str"").apply(b);
  if (!options.no_unreachable_code_elimination())   PackManager.v().getTransform(""String_Node_Str"").apply(b);
  if (soot.Main.v().opts.time())   Timers.v().stmtCount+=b.getUnits().size();
}"
88839,"public void apply(Body b){
  throw new RuntimeException(""String_Node_Str"");
}","public final void apply(Body b){
  Map options=PackManager.v().getPhaseOptions(this);
  if (PackManager.getBoolean(options,""String_Node_Str""))   return;
  internalApply(b);
}"
88840,"public PackManager(Singletons.Global g){
  Pack p;
  addPack(p=new JimpleBodyPack());
{
    p.add(new Transform(""String_Node_Str"",LocalSplitter.v()));
    p.add(new Transform(""String_Node_Str"",Aggregator.v()));
    p.add(new Transform(""String_Node_Str"",Aggregator.v()));
    p.add(new Transform(""String_Node_Str"",UnusedLocalEliminator.v()));
    p.add(new Transform(""String_Node_Str"",TypeAssigner.v()));
    p.add(new Transform(""String_Node_Str"",LocalNameStandardizer.v()));
    p.add(new Transform(""String_Node_Str"",LocalPacker.v()));
    p.add(new Transform(""String_Node_Str"",CopyPropagator.v()));
    p.add(new Transform(""String_Node_Str"",DeadAssignmentEliminator.v()));
    p.add(new Transform(""String_Node_Str"",UnusedLocalEliminator.v()));
    p.add(new Transform(""String_Node_Str"",LocalPacker.v()));
    p.add(new Transform(""String_Node_Str"",NopEliminator.v()));
    p.add(new Transform(""String_Node_Str"",UnreachableCodeEliminator.v()));
  }
  addPack(p=new BodyPack(""String_Node_Str""));
{
    p.add(new Transform(""String_Node_Str"",Aggregator.v()));
    p.add(new Transform(""String_Node_Str"",ConstructorFolder.v()));
    p.add(new Transform(""String_Node_Str"",Aggregator.v()));
    p.add(new Transform(""String_Node_Str"",UnusedLocalEliminator.v()));
  }
  addPack(p=new BodyPack(""String_Node_Str""));
{
    p.add(new Transform(""String_Node_Str"",LoadStoreOptimizer.v()));
    p.add(new Transform(""String_Node_Str"",PeepholeOptimizer.v()));
    p.add(new Transform(""String_Node_Str"",UnusedLocalEliminator.v()));
    p.add(new Transform(""String_Node_Str"",LocalPacker.v()));
  }
  addPack(p=new BodyPack(""String_Node_Str""));
  addPack(p=new BodyPack(""String_Node_Str""));
  addPack(p=new BodyPack(""String_Node_Str""));
  addPack(p=new BodyPack(""String_Node_Str""));
{
    p.add(new Transform(""String_Node_Str"",CommonSubexpressionEliminator.v()));
    p.add(new Transform(""String_Node_Str"",BusyCodeMotion.v()));
    p.add(new Transform(""String_Node_Str"",LazyCodeMotion.v()));
    p.add(new Transform(""String_Node_Str"",CopyPropagator.v()));
    p.add(new Transform(""String_Node_Str"",ConstantPropagatorAndFolder.v()));
    p.add(new Transform(""String_Node_Str"",ConditionalBranchFolder.v()));
    p.add(new Transform(""String_Node_Str"",DeadAssignmentEliminator.v()));
    p.add(new Transform(""String_Node_Str"",UnreachableCodeEliminator.v()));
    p.add(new Transform(""String_Node_Str"",UnconditionalBranchFolder.v()));
    p.add(new Transform(""String_Node_Str"",UnreachableCodeEliminator.v()));
    p.add(new Transform(""String_Node_Str"",UnconditionalBranchFolder.v()));
    p.add(new Transform(""String_Node_Str"",UnusedLocalEliminator.v()));
  }
  addPack(p=new BodyPack(""String_Node_Str""));
{
    p.add(new Transform(""String_Node_Str"",NullPointerChecker.v()));
    p.add(new Transform(""String_Node_Str"",ArrayBoundsChecker.v()));
    p.add(new Transform(""String_Node_Str"",ProfilingGenerator.v()));
    p.add(new Transform(""String_Node_Str"",SideEffectTagger.v()));
    p.add(new Transform(""String_Node_Str"",FieldTagger.v()));
  }
  addPack(p=new RadioScenePack(""String_Node_Str""));
{
    p.add(new Transform(""String_Node_Str"",OldCHATransformer.v()));
    p.add(new Transform(""String_Node_Str"",VTATransformer.v()));
    p.add(new Transform(""String_Node_Str"",CHATransformer.v()));
    p.add(new Transform(""String_Node_Str"",SparkTransformer.v()));
  }
  addPack(p=new ScenePack(""String_Node_Str""));
{
  }
  addPack(p=new ScenePack(""String_Node_Str""));
{
    p.add(new Transform(""String_Node_Str"",StaticMethodBinder.v()));
    p.add(new Transform(""String_Node_Str"",StaticInliner.v()));
  }
  addPack(p=new ScenePack(""String_Node_Str""));
  addPack(p=new ScenePack(""String_Node_Str""));
  addPack(p=new ScenePack(""String_Node_Str""));
{
    p.add(new Transform(""String_Node_Str"",RectangularArrayFinder.v()));
  }
  addPack(p=new BodyPack(""String_Node_Str""));
  addPack(p=new BodyPack(""String_Node_Str""));
  addPack(p=new BodyPack(""String_Node_Str""));
{
    p.add(new Transform(""String_Node_Str"",LineNumberTagAggregator.v()));
    p.add(new Transform(""String_Node_Str"",ArrayNullTagAggregator.v()));
    p.add(new Transform(""String_Node_Str"",DependenceTagAggregator.v()));
    p.add(new Transform(""String_Node_Str"",FieldTagAggregator.v()));
  }
}","public PackManager(Singletons.Global g){
  Pack p;
  addPack(p=new JimpleBodyPack());
{
    p.add(new Transform(""String_Node_Str"",LocalSplitter.v()));
    p.add(new Transform(""String_Node_Str"",Aggregator.v()));
    p.add(new Transform(""String_Node_Str"",Aggregator.v()));
    p.add(new Transform(""String_Node_Str"",UnusedLocalEliminator.v()));
    p.add(new Transform(""String_Node_Str"",TypeAssigner.v()));
    p.add(new Transform(""String_Node_Str"",LocalNameStandardizer.v()));
    p.add(new Transform(""String_Node_Str"",LocalPacker.v()));
    p.add(new Transform(""String_Node_Str"",CopyPropagator.v()));
    p.add(new Transform(""String_Node_Str"",DeadAssignmentEliminator.v()));
    p.add(new Transform(""String_Node_Str"",UnusedLocalEliminator.v()));
    p.add(new Transform(""String_Node_Str"",LocalPacker.v()));
    p.add(new Transform(""String_Node_Str"",NopEliminator.v()));
    p.add(new Transform(""String_Node_Str"",UnreachableCodeEliminator.v()));
  }
  addPack(p=new RadioScenePack(""String_Node_Str""));
{
    p.add(new Transform(""String_Node_Str"",OldCHATransformer.v()));
    p.add(new Transform(""String_Node_Str"",VTATransformer.v()));
    p.add(new Transform(""String_Node_Str"",CHATransformer.v()));
    p.add(new Transform(""String_Node_Str"",SparkTransformer.v()));
  }
  addPack(p=new ScenePack(""String_Node_Str""));
  addPack(p=new ScenePack(""String_Node_Str""));
  addPack(p=new ScenePack(""String_Node_Str""));
{
  }
  addPack(p=new ScenePack(""String_Node_Str""));
{
    p.add(new Transform(""String_Node_Str"",StaticMethodBinder.v()));
    p.add(new Transform(""String_Node_Str"",StaticInliner.v()));
  }
  addPack(p=new ScenePack(""String_Node_Str""));
{
    p.add(new Transform(""String_Node_Str"",RectangularArrayFinder.v()));
  }
  addPack(p=new BodyPack(""String_Node_Str""));
  addPack(p=new BodyPack(""String_Node_Str""));
  addPack(p=new BodyPack(""String_Node_Str""));
  addPack(p=new BodyPack(""String_Node_Str""));
{
    p.add(new Transform(""String_Node_Str"",CommonSubexpressionEliminator.v()));
    p.add(new Transform(""String_Node_Str"",BusyCodeMotion.v()));
    p.add(new Transform(""String_Node_Str"",LazyCodeMotion.v()));
    p.add(new Transform(""String_Node_Str"",CopyPropagator.v()));
    p.add(new Transform(""String_Node_Str"",ConstantPropagatorAndFolder.v()));
    p.add(new Transform(""String_Node_Str"",ConditionalBranchFolder.v()));
    p.add(new Transform(""String_Node_Str"",DeadAssignmentEliminator.v()));
    p.add(new Transform(""String_Node_Str"",UnreachableCodeEliminator.v()));
    p.add(new Transform(""String_Node_Str"",UnconditionalBranchFolder.v()));
    p.add(new Transform(""String_Node_Str"",UnreachableCodeEliminator.v()));
    p.add(new Transform(""String_Node_Str"",UnconditionalBranchFolder.v()));
    p.add(new Transform(""String_Node_Str"",UnusedLocalEliminator.v()));
  }
  addPack(p=new BodyPack(""String_Node_Str""));
{
    p.add(new Transform(""String_Node_Str"",NullPointerChecker.v()));
    p.add(new Transform(""String_Node_Str"",ArrayBoundsChecker.v()));
    p.add(new Transform(""String_Node_Str"",ProfilingGenerator.v()));
    p.add(new Transform(""String_Node_Str"",SideEffectTagger.v()));
    p.add(new Transform(""String_Node_Str"",FieldTagger.v()));
  }
  addPack(p=new BodyPack(""String_Node_Str""));
{
    p.add(new Transform(""String_Node_Str"",Aggregator.v()));
    p.add(new Transform(""String_Node_Str"",ConstructorFolder.v()));
    p.add(new Transform(""String_Node_Str"",Aggregator.v()));
    p.add(new Transform(""String_Node_Str"",UnusedLocalEliminator.v()));
  }
  addPack(p=new BodyPack(""String_Node_Str""));
  addPack(p=new BodyPack(""String_Node_Str""));
{
    p.add(new Transform(""String_Node_Str"",LoadStoreOptimizer.v()));
    p.add(new Transform(""String_Node_Str"",PeepholeOptimizer.v()));
    p.add(new Transform(""String_Node_Str"",UnusedLocalEliminator.v()));
    p.add(new Transform(""String_Node_Str"",LocalPacker.v()));
  }
  addPack(p=new BodyPack(""String_Node_Str""));
  addPack(p=new BodyPack(""String_Node_Str""));
{
    p.add(new Transform(""String_Node_Str"",LineNumberTagAggregator.v()));
    p.add(new Transform(""String_Node_Str"",ArrayNullTagAggregator.v()));
    p.add(new Transform(""String_Node_Str"",DependenceTagAggregator.v()));
    p.add(new Transform(""String_Node_Str"",FieldTagAggregator.v()));
  }
}"
88841,"/** 
 * Entry point to the soot's compilation process. Be sure to call setCmdLineArgs before invoking this method.
 * @see #setCmdLineArgs
 */
public void run(){
  start=new Date();
  try {
    processCmdLine(cmdLineArgs);
    Timers.v().totalTimer.start();
    G.v().out.println(""String_Node_Str"" + start);
    if (opts.soot_classpath().length() > 0) {
      Scene.v().setSootClassPath(opts.soot_classpath());
    }
    loadNecessaryClasses();
    prepareClasses();
    PackManager.v().getPack(""String_Node_Str"").apply();
    if (isOptimizingWhole)     PackManager.v().getPack(""String_Node_Str"").apply();
    PackManager.v().getPack(""String_Node_Str"").apply();
    preProcessDAVA();
    processClasses();
    postProcessDAVA();
    Timers.v().totalTimer.end();
    if (opts.time())     Timers.v().printProfilingInformation();
  }
 catch (  CompilationDeathException e) {
    Timers.v().totalTimer.end();
    exitCompilation(e.getStatus(),e.getMessage());
    return;
  }
  finish=new Date();
  G.v().out.println(""String_Node_Str"" + finish);
  long runtime=finish.getTime() - start.getTime();
  G.v().out.println(""String_Node_Str"" + (runtime / 60000) + ""String_Node_Str""+ ((runtime % 60000) / 1000)+ ""String_Node_Str"");
  exitCompilation(COMPILATION_SUCCEDED);
}","/** 
 * Entry point to the soot's compilation process. Be sure to call setCmdLineArgs before invoking this method.
 * @see #setCmdLineArgs
 */
public void run(){
  start=new Date();
  try {
    Timers.v().totalTimer.start();
    processCmdLine(cmdLineArgs);
    G.v().out.println(""String_Node_Str"" + start);
    if (opts.soot_classpath().length() > 0) {
      Scene.v().setSootClassPath(opts.soot_classpath());
    }
    loadNecessaryClasses();
    prepareClasses();
    PackManager.v().getPack(""String_Node_Str"").apply();
    if (isOptimizingWhole)     PackManager.v().getPack(""String_Node_Str"").apply();
    PackManager.v().getPack(""String_Node_Str"").apply();
    preProcessDAVA();
    processClasses();
    postProcessDAVA();
    Timers.v().totalTimer.end();
    if (opts.time())     Timers.v().printProfilingInformation();
  }
 catch (  CompilationDeathException e) {
    Timers.v().totalTimer.end();
    exitCompilation(e.getStatus(),e.getMessage());
    return;
  }
  finish=new Date();
  G.v().out.println(""String_Node_Str"" + finish);
  long runtime=finish.getTime() - start.getTime();
  G.v().out.println(""String_Node_Str"" + (runtime / 60000) + ""String_Node_Str""+ ((runtime % 60000) / 1000)+ ""String_Node_Str"");
  exitCompilation(COMPILATION_SUCCEDED);
}"
88842,"/** 
 * Starts the given timer. 
 */
public void start(){
  if (!G.v().Timer_isGarbageCollecting && Main.v().opts.subtract_gc() && ((G.v().Timer_count++ % 4) == 0)) {
    G.v().Timer_isGarbageCollecting=true;
    G.v().Timer_forcedGarbageCollectionTimer.start();
{
      Iterator timerIt=G.v().Timer_outstandingTimers.iterator();
      while (timerIt.hasNext()) {
        Timer t=(Timer)timerIt.next();
        t.end();
      }
    }
    System.gc();
{
      Iterator timerIt=G.v().Timer_outstandingTimers.iterator();
      while (timerIt.hasNext()) {
        Timer t=(Timer)timerIt.next();
        t.start();
      }
    }
    G.v().Timer_forcedGarbageCollectionTimer.end();
    G.v().Timer_isGarbageCollecting=false;
  }
  startTime=System.currentTimeMillis();
  if (hasStarted)   throw new RuntimeException(""String_Node_Str"" + name + ""String_Node_Str"");
 else   hasStarted=true;
  if (!G.v().Timer_isGarbageCollecting) {
    G.v().Timer_outstandingTimers.add(this);
  }
}","/** 
 * Starts the given timer. 
 */
public void start(){
  if (!G.v().Timer_isGarbageCollecting && Main.v().opts != null && Main.v().opts.subtract_gc() && ((G.v().Timer_count++ % 4) == 0)) {
    G.v().Timer_isGarbageCollecting=true;
    G.v().Timer_forcedGarbageCollectionTimer.start();
{
      Iterator timerIt=G.v().Timer_outstandingTimers.iterator();
      while (timerIt.hasNext()) {
        Timer t=(Timer)timerIt.next();
        t.end();
      }
    }
    System.gc();
{
      Iterator timerIt=G.v().Timer_outstandingTimers.iterator();
      while (timerIt.hasNext()) {
        Timer t=(Timer)timerIt.next();
        t.start();
      }
    }
    G.v().Timer_forcedGarbageCollectionTimer.end();
    G.v().Timer_isGarbageCollecting=false;
  }
  startTime=System.currentTimeMillis();
  if (hasStarted)   throw new RuntimeException(""String_Node_Str"" + name + ""String_Node_Str"");
 else   hasStarted=true;
  if (!G.v().Timer_isGarbageCollecting) {
    G.v().Timer_outstandingTimers.add(this);
  }
}"
88843,"private void drawAxisX(Graphics g){
  final int arrowSize=3;
  final int overlap=3;
  final int arrowOut=5;
  int x=(int)(chartRect.getMaxX() + overlap + arrowOut);
  int y=(int)chartRect.getMaxY();
  g.setColor(Color.BLACK);
  g.drawLine(x,y,(int)chartRect.getMinX(),y);
  g.drawLine(x,y,x - arrowSize,y - arrowSize);
  g.drawLine(x,y,x - arrowSize,y + arrowSize);
  x=(int)(chartRect.getMaxX() + overlap + arrowSize * 3);
  y=(int)(chartRect.getMaxY() + g.getFontMetrics().getAscent() - 1);
  g.drawString(horzDesc,x,y);
}","private void drawAxisX(Graphics g){
  final int arrowSize=3;
  final int overlap=3;
  final int arrowOut=5;
  int x=(int)(chartRect.getMaxX() + overlap + arrowOut);
  int y=(int)chartRect.getMaxY();
  g.setColor(Color.BLACK);
  g.drawLine(x,y,(int)chartRect.getMinX(),y);
  g.drawLine(x,y,x - arrowSize,y - arrowSize);
  g.drawLine(x,y,x - arrowSize,y + arrowSize);
  if (horzDesc == null)   return;
  x=(int)(chartRect.getMaxX() + overlap + arrowSize * 3);
  y=(int)(chartRect.getMaxY() + g.getFontMetrics().getAscent() - 1);
  g.drawString(horzDesc,x,y);
}"
88844,"private void drawAxisY(Graphics g){
  final int arrowSize=3;
  final int overlap=3;
  final int arrowOut=5;
  int x=(int)(chartRect.getMinX());
  int y=(int)(chartRect.getMinY() - overlap - arrowOut);
  g.setColor(Color.BLACK);
  g.drawLine(x,y,x,(int)chartRect.getMaxY());
  g.drawLine(x,y,x - arrowSize,y + arrowSize);
  g.drawLine(x,y,x + arrowSize,y + arrowSize);
  Rectangle2D descSize=g.getFontMetrics().getStringBounds(vertDesc,g);
  x=(int)(chartRect.getMinX() - descSize.getWidth() * 0.5);
  y=(int)(chartRect.getMinY() - overlap - arrowOut- 2 * arrowSize);
  g.drawString(vertDesc,x,y);
}","private void drawAxisY(Graphics g){
  final int arrowSize=3;
  final int overlap=3;
  final int arrowOut=5;
  int x=(int)(chartRect.getMinX());
  int y=(int)(chartRect.getMinY() - overlap - arrowOut);
  g.setColor(Color.BLACK);
  g.drawLine(x,y,x,(int)chartRect.getMaxY());
  g.drawLine(x,y,x - arrowSize,y + arrowSize);
  g.drawLine(x,y,x + arrowSize,y + arrowSize);
  if (vertDesc == null)   return;
  Rectangle2D descSize=g.getFontMetrics().getStringBounds(vertDesc,g);
  x=(int)(chartRect.getMinX() - descSize.getWidth() * 0.5);
  y=(int)(chartRect.getMinY() - overlap - arrowOut- 2 * arrowSize);
  g.drawString(vertDesc,x,y);
}"
88845,"/** 
 * @param pos the x position in screen pixel coordinates
 */
public void setMarker(int pos){
  markerPos=null;
  if (pos < chartRect.x)   return;
  if (pos > chartRect.x + chartRect.width)   return;
  double val=screenXToValueX(pos);
  markerPos=FindIndexOfValueX(val,0);
  repaint();
}","/** 
 * @param pos the x position in screen pixel coordinates
 */
public void setMarker(int pos){
  markerPos=-1;
  if (pos < chartRect.x)   return;
  if (pos > chartRect.x + chartRect.width)   return;
  double val=screenXToValueX(pos);
  markerPos=FindIndexOfValueX(val,0);
  repaint();
}"
88846,"private void drawMarker(Graphics g){
  if (markerPos == null)   return;
  int overlap=6;
  int yTop=(int)chartRect.getMinY() - overlap;
  int yBot=(int)chartRect.getMaxY() + overlap;
  g.setColor(Color.BLACK);
  List<Point2D> data=series.get(0);
  if (markerPos < data.size()) {
    double value=data.get(markerPos).getX();
    int x=(int)ValueXToScreenX(value);
    g.drawLine(x,yTop,x,yBot);
  }
}","private void drawMarker(Graphics g){
  if (markerPos < 0)   return;
  int overlap=6;
  int yTop=(int)chartRect.getMinY() - overlap;
  int yBot=(int)chartRect.getMaxY() + overlap;
  g.setColor(Color.BLACK);
  List<Point2D> data=series.get(0);
  if (markerPos < data.size()) {
    double value=data.get(markerPos).getX();
    int x=(int)ValueXToScreenX(value);
    g.drawLine(x,yTop,x,yBot);
  }
}"
88847,"private void drawMarker(Graphics g){
  if (markerPos == null)   return;
  int overlap=6;
  int yTop=(int)chartRect.getMinY() - overlap;
  int yBot=(int)chartRect.getMaxY() + overlap;
  g.setColor(Color.BLACK);
  double value=series.get(0).get(markerPos).getX();
  int x=(int)ValueXToScreenX(value);
  g.drawLine(x,yTop,x,yBot);
}","private void drawMarker(Graphics g){
  if (markerPos == null)   return;
  int overlap=6;
  int yTop=(int)chartRect.getMinY() - overlap;
  int yBot=(int)chartRect.getMaxY() + overlap;
  g.setColor(Color.BLACK);
  List<Point2D> data=series.get(0);
  if (markerPos < data.size()) {
    double value=data.get(markerPos).getX();
    int x=(int)ValueXToScreenX(value);
    g.drawLine(x,yTop,x,yBot);
  }
}"
88848,"private JTable createTable(final List<Track> tracks){
  TrackTableModel model=new TrackTableModel(tracks);
  JTable table=new JShadedTable(model);
  String[] labels=model.getColumnLabels();
  for (int i=0; i < model.getColumnCount(); i++) {
    table.getColumnModel().getColumn(i).setIdentifier(model.getColumnName(i));
    table.getColumnModel().getColumn(i).setHeaderValue(labels[i]);
  }
  FormatRenderer dateRenderer=new FormatRenderer(SimpleDateFormat.getDateTimeInstance(),SwingConstants.LEFT);
  FormatRenderer distanceRenderer=new FormatRenderer(new DistanceFormat());
  FormatRenderer speedRenderer=new FormatRenderer(new SpeedFormat());
  table.getColumn(""String_Node_Str"").setCellRenderer(dateRenderer);
  table.getColumn(""String_Node_Str"").setCellRenderer(distanceRenderer);
  table.getColumn(""String_Node_Str"").setCellRenderer(speedRenderer);
  TableRowSorter<TableModel> sorter=new TableRowSorter<TableModel>(table.getModel());
  table.setRowSorter(sorter);
  table.getSelectionModel().setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);
  table.getSelectionModel().addListSelectionListener(new ListMultiSelectionListener(){
    @Override public void valueChanged(    List<Integer> indices){
      List<Track> selTracks=new ArrayList<Track>();
      for (      Integer idx : indices) {
        selTracks.add(tracks.get(idx));
      }
      viewer.showRoute(selTracks);
      trackChart.setTracks(selTracks);
    }
  }
);
  return table;
}","private JTable createTable(final List<Track> tracks){
  TrackTableModel model=new TrackTableModel(tracks);
  final JTable table=new JShadedTable(model);
  String[] labels=model.getColumnLabels();
  for (int i=0; i < model.getColumnCount(); i++) {
    table.getColumnModel().getColumn(i).setIdentifier(model.getColumnName(i));
    table.getColumnModel().getColumn(i).setHeaderValue(labels[i]);
  }
  FormatRenderer dateRenderer=new FormatRenderer(SimpleDateFormat.getDateTimeInstance(),SwingConstants.LEFT);
  FormatRenderer distanceRenderer=new FormatRenderer(new DistanceFormat());
  FormatRenderer timeRenderer=new FormatRenderer(new TimeFormat());
  FormatRenderer speedRenderer=new FormatRenderer(new SpeedFormat());
  table.getColumn(""String_Node_Str"").setCellRenderer(dateRenderer);
  table.getColumn(""String_Node_Str"").setCellRenderer(distanceRenderer);
  table.getColumn(""String_Node_Str"").setCellRenderer(timeRenderer);
  table.getColumn(""String_Node_Str"").setCellRenderer(speedRenderer);
  TableRowSorter<TableModel> sorter=new TableRowSorter<TableModel>(table.getModel());
  table.setRowSorter(sorter);
  table.getSelectionModel().setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);
  table.getSelectionModel().addListSelectionListener(new ListMultiSelectionListener(){
    @Override public void valueChanged(    List<Integer> indices){
      List<Track> selTracks=new ArrayList<Track>();
      for (      Integer idx : indices) {
        idx=table.convertRowIndexToModel(idx);
        selTracks.add(tracks.get(idx));
      }
      viewer.showRoute(selTracks);
      trackChart.setTracks(selTracks);
    }
  }
);
  return table;
}"
88849,"@Override public void valueChanged(List<Integer> indices){
  List<Track> selTracks=new ArrayList<Track>();
  for (  Integer idx : indices) {
    selTracks.add(tracks.get(idx));
  }
  viewer.showRoute(selTracks);
  trackChart.setTracks(selTracks);
}","@Override public void valueChanged(List<Integer> indices){
  List<Track> selTracks=new ArrayList<Track>();
  for (  Integer idx : indices) {
    idx=table.convertRowIndexToModel(idx);
    selTracks.add(tracks.get(idx));
  }
  viewer.showRoute(selTracks);
  trackChart.setTracks(selTracks);
}"
88850,"private List<Track> readTracks(File folder){
  List<Track> tracks=new ArrayList<Track>();
  String[] files=folder.list(new FilenameFilter(){
    @Override public boolean accept(    File dir,    String name){
      return name.endsWith(""String_Node_Str"");
    }
  }
);
  TcxAdapter tcxAdapter=null;
  try {
    tcxAdapter=new TcxAdapter();
  }
 catch (  JAXBException e) {
    JOptionPane.showMessageDialog(null,e);
    return tracks;
  }
  for (  String fname : files) {
    FileInputStream fis=null;
    try {
      fis=new FileInputStream(new File(folder,fname));
      List<Track> read=tcxAdapter.read(fis);
      tracks.addAll(read);
      System.out.println(""String_Node_Str"" + fname);
    }
 catch (    IOException e) {
      JOptionPane.showMessageDialog(null,e);
    }
 finally {
      try {
        if (fis != null)         fis.close();
      }
 catch (      Exception e) {
      }
    }
  }
  for (  Track track : tracks) {
    TrackComputer.repairTrackData(track);
  }
  return tracks;
}","private List<Track> readTracks(File folder){
  List<Track> tracks=new ArrayList<Track>();
  String[] files=folder.list(new FilenameFilter(){
    @Override public boolean accept(    File dir,    String name){
      return name.endsWith(""String_Node_Str"");
    }
  }
);
  TcxAdapter tcxAdapter=null;
  try {
    tcxAdapter=new TcxAdapter();
  }
 catch (  JAXBException e) {
    JOptionPane.showMessageDialog(null,e);
    return tracks;
  }
  for (  String fname : files) {
    FileInputStream fis=null;
    try {
      fis=new FileInputStream(new File(folder,fname));
      List<Track> read=tcxAdapter.read(fis);
      for (      Track t : read) {
        if (!t.getPoints().isEmpty()) {
          tracks.add(t);
        }
      }
      System.out.println(""String_Node_Str"" + fname);
    }
 catch (    IOException e) {
      JOptionPane.showMessageDialog(null,e);
    }
 finally {
      try {
        if (fis != null)         fis.close();
      }
 catch (      Exception e) {
      }
    }
  }
  for (  Track track : tracks) {
    TrackComputer.repairTrackData(track);
  }
  return tracks;
}"
88851,"@Override public Object getValueAt(int row,int col){
  Track track=tracks.get(row);
switch (col) {
case 0:
    return track.getStartTime();
case 1:
  return track.getTotalDistance();
case 2:
return track.getAverageSpeed();
}
return track;
}","@Override public Object getValueAt(int row,int col){
  Track track=tracks.get(row);
switch (col) {
case 0:
    return track.getStartTime();
case 1:
  return track.getTotalDistance();
case 2:
return track.getTotalTime();
case 3:
return track.getAverageSpeed();
}
return track;
}"
88852,"/** 
 * @return the total distance of the track
 */
public double getTotalDistance(){
  if (points.isEmpty())   return 0;
  return points.get(points.size() - 1).getDistance();
}","/** 
 * @return the total distance of the track in meters
 */
public double getTotalDistance(){
  if (points.isEmpty())   return 0;
  return points.get(points.size() - 1).getDistance();
}"
88853,"/** 
 * Constructs a new instance
 */
public MainFrame(){
  super(""String_Node_Str"");
  File folder=new File(System.getProperty(""String_Node_Str"") + File.separator + ""String_Node_Str"");
  List<Track> tracks=readTracks(folder);
  viewer=new MapViewer();
  table=createTable(tracks);
  JScrollPane tablePane=new JScrollPane(table);
  table.setFillsViewportHeight(true);
  trackChart=new TrackChart();
  trackChart.addSelectionListener(new SelectionListener(){
    @Override public void selected(    int index){
      viewer.setMarker(index);
    }
  }
);
  JSplitPane chartSplitPane=new JSplitPane(JSplitPane.VERTICAL_SPLIT,viewer,trackChart);
  chartSplitPane.setDividerLocation(550);
  JSplitPane mainSplitPane=new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,tablePane,chartSplitPane);
  mainSplitPane.setDividerLocation(230);
  Dimension minimumSize=new Dimension(100,50);
  tablePane.setMinimumSize(minimumSize);
  chartSplitPane.setMinimumSize(minimumSize);
  add(createMenu(),BorderLayout.NORTH);
  add(mainSplitPane);
  table.getSelectionModel().setSelectionInterval(0,0);
}","/** 
 * Constructs a new instance
 */
public MainFrame(){
  super(""String_Node_Str"");
  File folder=new File(System.getProperty(""String_Node_Str"") + File.separator + ""String_Node_Str"");
  List<Track> tracks=readTracks(folder);
  viewer=new MapViewer();
  table=createTable(tracks);
  JScrollPane tablePane=new JScrollPane(table);
  table.setFillsViewportHeight(true);
  trackChart=new TrackChart();
  trackChart.addSelectionListener(new SelectionListener(){
    @Override public void selected(    int series,    int index){
      viewer.setMarker(series,index);
    }
  }
);
  JSplitPane chartSplitPane=new JSplitPane(JSplitPane.VERTICAL_SPLIT,viewer,trackChart);
  chartSplitPane.setDividerLocation(550);
  JSplitPane mainSplitPane=new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,tablePane,chartSplitPane);
  mainSplitPane.setDividerLocation(230);
  Dimension minimumSize=new Dimension(100,50);
  tablePane.setMinimumSize(minimumSize);
  chartSplitPane.setMinimumSize(minimumSize);
  add(createMenu(),BorderLayout.NORTH);
  add(mainSplitPane);
  table.getSelectionModel().setSelectionInterval(0,0);
}"
88854,"@Override public void selected(int index){
  viewer.setMarker(index);
}","@Override public void selected(int series,int index){
  viewer.setMarker(series,index);
}"
88855,"/** 
 * @param index
 */
public void setMarker(int index){
  for (  Painter<?> p : painter.getPainters()) {
    if (p instanceof MarkerPainter) {
      MarkerPainter mp=(MarkerPainter)p;
      mp.setMarker(index);
    }
  }
}","/** 
 * @param track the track index
 * @param index the index of the track point
 */
public void setMarker(int track,int index){
  MarkerPainter mp=markerPainters.get(track);
  mp.setMarker(index);
}"
88856,"/** 
 * Displays one or more track routes
 * @param tracks the list of track
 */
public void showRoute(List<Track> tracks){
  List<Painter<JXMapViewer>> painters=new ArrayList<Painter<JXMapViewer>>();
  int i=0;
  for (  Track track : tracks) {
    List<GeoPosition> route=track.getRoute();
    Color color=getRouteColor(i++);
    MarkerPainter markerPainter=new MarkerPainter(route,color);
    RoutePainter routePainter=new RoutePainter(route,color);
    painters.add(routePainter);
    painters.add(markerPainter);
  }
  painter.setPainters(painters);
}","/** 
 * Displays one or more track routes
 * @param tracks the list of track
 */
public void showRoute(List<Track> tracks){
  markerPainters.clear();
  routePainters.clear();
  List<Painter<JXMapViewer>> painters=new ArrayList<Painter<JXMapViewer>>();
  int i=0;
  for (  Track track : tracks) {
    List<GeoPosition> route=track.getRoute();
    Color color=getRouteColor(i++);
    MarkerPainter markerPainter=new MarkerPainter(route,color);
    RoutePainter routePainter=new RoutePainter(route,color);
    markerPainters.add(markerPainter);
    routePainters.add(routePainter);
    painters.add(routePainter);
    painters.add(markerPainter);
  }
  painter.setPainters(painters);
}"
88857,"public void setMarker(int index){
  if (index < 0 || index > track.size())   throw new IllegalArgumentException(""String_Node_Str"" + index + ""String_Node_Str"");
  markers.add(index);
  setDirty(true);
}","public void setMarker(int index){
  if (index < 0 || index > track.size())   throw new IllegalArgumentException(""String_Node_Str"" + index + ""String_Node_Str"");
  markers.clear();
  markers.add(index);
  setDirty(true);
}"
88858,public void selected(int index);,"public void selected(int series,int index);"
88859,"/** 
 * Creates a new instance
 */
public TrackChart(){
  chart=new JChart();
  chart.addMouseListener(new MouseAdapter(){
    @Override public void mouseClicked(    MouseEvent e){
      int idx=chart.getIndexAt(e.getX(),e.getY());
      for (      SelectionListener sl : selectionListeners) {
        sl.selected(idx);
      }
    }
  }
);
  JToolBar toolBar=new JToolBar(JToolBar.VERTICAL);
  toolBar.setFloatable(false);
  toolBar.setRollover(true);
  JToggleButton distanceButton=new JToggleButton(new ImageIcon(""String_Node_Str""));
  JToggleButton heightButton=new JToggleButton(new ImageIcon(""String_Node_Str""));
  JToggleButton speedButton=new JToggleButton(new ImageIcon(""String_Node_Str""));
  JToggleButton timeButton=new JToggleButton(new ImageIcon(""String_Node_Str""));
  ButtonGroup bgv=new ButtonGroup();
  bgv.add(distanceButton);
  bgv.add(timeButton);
  ButtonGroup bgh=new ButtonGroup();
  bgh.add(heightButton);
  bgh.add(speedButton);
  distanceButton.setToolTipText(""String_Node_Str"");
  heightButton.setToolTipText(""String_Node_Str"");
  speedButton.setToolTipText(""String_Node_Str"");
  timeButton.setToolTipText(""String_Node_Str"");
  distanceButton.getModel().setSelected(chartModeHorz == ChartModeHorz.Distance);
  timeButton.getModel().setSelected(chartModeHorz == ChartModeHorz.Time);
  heightButton.getModel().setSelected(chartModeVert == ChartModeVert.Height);
  speedButton.getModel().setSelected(chartModeVert == ChartModeVert.Speed);
  toolBar.add(distanceButton);
  toolBar.add(timeButton);
  toolBar.addSeparator();
  toolBar.add(heightButton);
  toolBar.add(speedButton);
  distanceButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      chartModeHorz=ChartModeHorz.Distance;
      reload();
    }
  }
);
  heightButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      chartModeVert=ChartModeVert.Height;
      reload();
    }
  }
);
  speedButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      chartModeVert=ChartModeVert.Speed;
      reload();
    }
  }
);
  timeButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      chartModeHorz=ChartModeHorz.Time;
      reload();
    }
  }
);
  setLayout(new BorderLayout());
  add(toolBar,BorderLayout.WEST);
  add(chart);
}","/** 
 * Creates a new instance
 */
public TrackChart(){
  chart=new JChart();
  chart.addMouseListener(new MouseAdapter(){
    @Override public void mouseClicked(    MouseEvent e){
      for (int i=0; i < chart.getData().size(); i++) {
        int idx=chart.getIndexAt(i,e.getX(),e.getY());
        for (        SelectionListener sl : selectionListeners) {
          sl.selected(i,idx);
        }
      }
    }
  }
);
  JToolBar toolBar=new JToolBar(JToolBar.VERTICAL);
  toolBar.setFloatable(false);
  toolBar.setRollover(true);
  JToggleButton distanceButton=new JToggleButton(new ImageIcon(""String_Node_Str""));
  JToggleButton heightButton=new JToggleButton(new ImageIcon(""String_Node_Str""));
  JToggleButton speedButton=new JToggleButton(new ImageIcon(""String_Node_Str""));
  JToggleButton timeButton=new JToggleButton(new ImageIcon(""String_Node_Str""));
  ButtonGroup bgv=new ButtonGroup();
  bgv.add(distanceButton);
  bgv.add(timeButton);
  ButtonGroup bgh=new ButtonGroup();
  bgh.add(heightButton);
  bgh.add(speedButton);
  distanceButton.setToolTipText(""String_Node_Str"");
  heightButton.setToolTipText(""String_Node_Str"");
  speedButton.setToolTipText(""String_Node_Str"");
  timeButton.setToolTipText(""String_Node_Str"");
  distanceButton.getModel().setSelected(chartModeHorz == ChartModeHorz.Distance);
  timeButton.getModel().setSelected(chartModeHorz == ChartModeHorz.Time);
  heightButton.getModel().setSelected(chartModeVert == ChartModeVert.Height);
  speedButton.getModel().setSelected(chartModeVert == ChartModeVert.Speed);
  toolBar.add(distanceButton);
  toolBar.add(timeButton);
  toolBar.addSeparator();
  toolBar.add(heightButton);
  toolBar.add(speedButton);
  distanceButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      chartModeHorz=ChartModeHorz.Distance;
      reload();
    }
  }
);
  heightButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      chartModeVert=ChartModeVert.Height;
      reload();
    }
  }
);
  speedButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      chartModeVert=ChartModeVert.Speed;
      reload();
    }
  }
);
  timeButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      chartModeHorz=ChartModeHorz.Time;
      reload();
    }
  }
);
  setLayout(new BorderLayout());
  add(toolBar,BorderLayout.WEST);
  add(chart);
}"
88860,"@Override public void mouseClicked(MouseEvent e){
  int idx=chart.getIndexAt(e.getX(),e.getY());
  for (  SelectionListener sl : selectionListeners) {
    sl.selected(idx);
  }
}","@Override public void mouseClicked(MouseEvent e){
  for (int i=0; i < chart.getData().size(); i++) {
    int idx=chart.getIndexAt(i,e.getX(),e.getY());
    for (    SelectionListener sl : selectionListeners) {
      sl.selected(i,idx);
    }
  }
}"
88861,"/** 
 * @param x the x-value in local screen coords
 * @param y the y-value in local screen coords
 * @return the index or -1 if not found
 */
public int getIndexAt(int x,int y){
  double vx=screenXToValueX(x);
  for (int i=0; i < series.size(); i++) {
    int idx=FindIndexOfValueX(vx,i);
    if (idx != -1)     return idx;
  }
  return -1;
}","/** 
 * @param serie the index of the series
 * @param x the x-value in local screen coords
 * @param y the y-value in local screen coords
 * @return the index or -1 if not found
 */
public int getIndexAt(int serie,int x,int y){
  double vx=screenXToValueX(x);
  return FindIndexOfValueX(vx,serie);
}"
88862,"public void removeSelectionListener(SelectionListener sl){
  selectionListeners.remove(sl);
}","/** 
 * @param sl the selection listener
 */
public void removeSelectionListener(SelectionListener sl){
  selectionListeners.remove(sl);
}"
88863,"public void addSelectionListener(SelectionListener sl){
  selectionListeners.add(sl);
}","/** 
 * @param sl the selection listener
 */
public void addSelectionListener(SelectionListener sl){
  selectionListeners.add(sl);
}"
88864,"/** 
 * Creates a new instance
 */
public TrackChart(){
  chart=new JChart();
  chart.addMouseListener(new MouseAdapter(){
    @Override public void mouseClicked(    MouseEvent e){
      for (int i=0; i < chart.getData().size(); i++) {
        int idx=chart.getIndexAt(i,e.getX(),e.getY());
        for (        SelectionListener sl : selectionListeners) {
          sl.selected(i,idx);
        }
      }
    }
  }
);
  JToolBar toolBar=new JToolBar(JToolBar.VERTICAL);
  toolBar.setFloatable(false);
  toolBar.setRollover(true);
  JToggleButton distanceButton=new JToggleButton(new ImageIcon(""String_Node_Str""));
  JToggleButton heightButton=new JToggleButton(new ImageIcon(""String_Node_Str""));
  JToggleButton speedButton=new JToggleButton(new ImageIcon(""String_Node_Str""));
  JToggleButton timeButton=new JToggleButton(new ImageIcon(""String_Node_Str""));
  ButtonGroup bgv=new ButtonGroup();
  bgv.add(distanceButton);
  bgv.add(timeButton);
  ButtonGroup bgh=new ButtonGroup();
  bgh.add(heightButton);
  bgh.add(speedButton);
  distanceButton.setToolTipText(""String_Node_Str"");
  heightButton.setToolTipText(""String_Node_Str"");
  speedButton.setToolTipText(""String_Node_Str"");
  timeButton.setToolTipText(""String_Node_Str"");
  distanceButton.getModel().setSelected(chartModeHorz == ChartModeHorz.Distance);
  timeButton.getModel().setSelected(chartModeHorz == ChartModeHorz.Time);
  heightButton.getModel().setSelected(chartModeVert == ChartModeVert.Height);
  speedButton.getModel().setSelected(chartModeVert == ChartModeVert.Speed);
  toolBar.add(distanceButton);
  toolBar.add(timeButton);
  toolBar.addSeparator();
  toolBar.add(heightButton);
  toolBar.add(speedButton);
  distanceButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      chartModeHorz=ChartModeHorz.Distance;
      reload();
    }
  }
);
  heightButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      chartModeVert=ChartModeVert.Height;
      reload();
    }
  }
);
  speedButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      chartModeVert=ChartModeVert.Speed;
      reload();
    }
  }
);
  timeButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      chartModeHorz=ChartModeHorz.Time;
      reload();
    }
  }
);
  setLayout(new BorderLayout());
  add(toolBar,BorderLayout.WEST);
  add(chart);
}","/** 
 * Creates a new instance
 */
public TrackChart(){
  chart=new JChart();
  chart.addMouseListener(new MouseAdapter(){
    @Override public void mouseClicked(    MouseEvent e){
      chart.setMarker(e.getX());
      for (int i=0; i < chart.getData().size(); i++) {
        int idx=chart.getIndexAt(i,e.getX(),e.getY());
        for (        SelectionListener sl : selectionListeners) {
          sl.selected(i,idx);
        }
      }
    }
  }
);
  JToolBar toolBar=new JToolBar(JToolBar.VERTICAL);
  toolBar.setFloatable(false);
  toolBar.setRollover(true);
  JToggleButton distanceButton=new JToggleButton(new ImageIcon(""String_Node_Str""));
  JToggleButton heightButton=new JToggleButton(new ImageIcon(""String_Node_Str""));
  JToggleButton speedButton=new JToggleButton(new ImageIcon(""String_Node_Str""));
  JToggleButton timeButton=new JToggleButton(new ImageIcon(""String_Node_Str""));
  ButtonGroup bgv=new ButtonGroup();
  bgv.add(distanceButton);
  bgv.add(timeButton);
  ButtonGroup bgh=new ButtonGroup();
  bgh.add(heightButton);
  bgh.add(speedButton);
  distanceButton.setToolTipText(""String_Node_Str"");
  heightButton.setToolTipText(""String_Node_Str"");
  speedButton.setToolTipText(""String_Node_Str"");
  timeButton.setToolTipText(""String_Node_Str"");
  distanceButton.getModel().setSelected(chartModeHorz == ChartModeHorz.Distance);
  timeButton.getModel().setSelected(chartModeHorz == ChartModeHorz.Time);
  heightButton.getModel().setSelected(chartModeVert == ChartModeVert.Height);
  speedButton.getModel().setSelected(chartModeVert == ChartModeVert.Speed);
  toolBar.add(distanceButton);
  toolBar.add(timeButton);
  toolBar.addSeparator();
  toolBar.add(heightButton);
  toolBar.add(speedButton);
  distanceButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      chartModeHorz=ChartModeHorz.Distance;
      reload();
    }
  }
);
  heightButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      chartModeVert=ChartModeVert.Height;
      reload();
    }
  }
);
  speedButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      chartModeVert=ChartModeVert.Speed;
      reload();
    }
  }
);
  timeButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      chartModeHorz=ChartModeHorz.Time;
      reload();
    }
  }
);
  setLayout(new BorderLayout());
  add(toolBar,BorderLayout.WEST);
  add(chart);
}"
88865,"@Override public void mouseClicked(MouseEvent e){
  for (int i=0; i < chart.getData().size(); i++) {
    int idx=chart.getIndexAt(i,e.getX(),e.getY());
    for (    SelectionListener sl : selectionListeners) {
      sl.selected(i,idx);
    }
  }
}","@Override public void mouseClicked(MouseEvent e){
  chart.setMarker(e.getX());
  for (int i=0; i < chart.getData().size(); i++) {
    int idx=chart.getIndexAt(i,e.getX(),e.getY());
    for (    SelectionListener sl : selectionListeners) {
      sl.selected(i,idx);
    }
  }
}"
88866,"/** 
 * @param pos the x position in screen pixel coordinates
 */
private void setMarker(int pos){
  markerPos=pos;
  repaint();
}","/** 
 * @param pos the x position in screen pixel coordinates
 */
public void setMarker(int pos){
  markerPos=null;
  if (pos < chartRect.x)   return;
  if (pos > chartRect.x + chartRect.width)   return;
  markerPos=Double.valueOf(screenXToValueX(pos));
  repaint();
}"
88867,"private void drawMarker(Graphics g){
  if (markerPos < chartRect.x)   return;
  if (markerPos > chartRect.x + chartRect.width)   return;
  int overlap=6;
  int yTop=(int)chartRect.getMinY() - overlap;
  int yBot=(int)chartRect.getMaxY() + overlap;
  g.setColor(Color.BLACK);
  g.drawLine(markerPos,yTop,markerPos,yBot);
}","private void drawMarker(Graphics g){
  if (markerPos == null)   return;
  int overlap=6;
  int yTop=(int)chartRect.getMinY() - overlap;
  int yBot=(int)chartRect.getMaxY() + overlap;
  g.setColor(Color.BLACK);
  int x=(int)ValueXToScreenX(markerPos);
  g.drawLine(x,yTop,x,yBot);
}"
88868,"/** 
 */
public JChart(){
  super();
  addMouseListener(new MouseAdapter(){
    @Override public void mouseClicked(    MouseEvent e){
      setMarker(e.getX());
    }
  }
);
}","/** 
 */
public JChart(){
  super();
}"
88869,"private String serveSelectRPC(Properties parms){
  if (parms.getProperty(""String_Node_Str"") != null && parms.getProperty(""String_Node_Str"") != null && parms.getProperty(""String_Node_Str"") != null && parms.getProperty(""String_Node_Str"") != null && parms.getProperty(""String_Node_Str"") != null && parms.getProperty(""String_Node_Str"") != null && parms.getProperty(""String_Node_Str"") != null) {
    try {
      int pool=Integer.parseInt(parms.getProperty(""String_Node_Str""));
      int tmo=Integer.parseInt(parms.getProperty(""String_Node_Str""));
      int server=BTCMiner.rpcCount;
      if (pool >= 0 && pool < server) {
        RPC rpc=BTCMiner.rpc[pool];
        rpc.name=parms.getProperty(""String_Node_Str"");
        rpc.url=parms.getProperty(""String_Node_Str"");
        rpc.host=parms.getProperty(""String_Node_Str"");
        rpc.usr=parms.getProperty(""String_Node_Str"");
        rpc.pwd=parms.getProperty(""String_Node_Str"");
        rpc.ioDisableMonitorTime=tmo;
        if (BTCMiner.newBlockMonitor != null) {
synchronized (BTCMiner.newBlockMonitor) {
            BTCMiner.disableLPTime=new Date().getTime() + 20000;
            BTCMiner.longPollURL=null;
            BTCMiner.longPollUser=""String_Node_Str"";
            BTCMiner.longPollPassw=""String_Node_Str"";
          }
        }
      }
    }
 catch (    NumberFormatException e) {
    }
  }
  return ""String_Node_Str"";
}","private String serveSelectRPC(Properties parms){
  if (parms.getProperty(""String_Node_Str"") != null && parms.getProperty(""String_Node_Str"") != null && parms.getProperty(""String_Node_Str"") != null && parms.getProperty(""String_Node_Str"") != null && parms.getProperty(""String_Node_Str"") != null && parms.getProperty(""String_Node_Str"") != null && parms.getProperty(""String_Node_Str"") != null) {
    try {
      int pool=Integer.parseInt(parms.getProperty(""String_Node_Str""));
      int iomon=Integer.parseInt(parms.getProperty(""String_Node_Str""));
      int server=BTCMiner.rpcCount;
      if (pool >= 0 && pool < server) {
        RPC rpc=BTCMiner.rpc[pool];
        rpc.name=parms.getProperty(""String_Node_Str"");
        rpc.url=parms.getProperty(""String_Node_Str"");
        rpc.host=parms.getProperty(""String_Node_Str"");
        rpc.usr=parms.getProperty(""String_Node_Str"");
        rpc.pwd=parms.getProperty(""String_Node_Str"");
        rpc.ioDisableMonitorTime=iomon;
        if (BTCMiner.newBlockMonitor != null) {
synchronized (BTCMiner.newBlockMonitor) {
            BTCMiner.disableLPTime=new Date().getTime() + 20000;
            BTCMiner.longPollURL=null;
            BTCMiner.longPollUser=""String_Node_Str"";
            BTCMiner.longPollPassw=""String_Node_Str"";
          }
        }
      }
    }
 catch (    NumberFormatException e) {
    }
  }
  return ""String_Node_Str"";
}"
88870,"public static String httpGet(MsgObj msgObj,String url,String user,String passw,String request) throws MalformedURLException, IOException {
  HttpURLConnection con=(HttpURLConnection)new URL(url).openConnection();
  con.setRequestMethod(""String_Node_Str"");
  con.setConnectTimeout((int)Math.round(2000.0 * BTCMiner.connectionEffort));
  con.setReadTimeout(url == longPollURL ? 1000000 : (int)Math.round(2000.0 * BTCMiner.connectionEffort));
  con.setRequestProperty(""String_Node_Str"",""String_Node_Str"" + encodeBase64(user + ""String_Node_Str"" + passw));
  con.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
  con.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
  con.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
  con.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
  con.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
  con.setRequestProperty(""String_Node_Str"",""String_Node_Str"" + request.length());
  con.setUseCaches(false);
  con.setDoInput(true);
  con.setDoOutput(true);
  OutputStreamWriter wr=new OutputStreamWriter(con.getOutputStream());
  wr.write(request);
  wr.flush();
  wr.close();
  String str=con.getHeaderField(""String_Node_Str"");
  if (str != null && !str.equals(""String_Node_Str"")) {
    msgObj.rejectReason(str);
  }
  str=con.getHeaderField(""String_Node_Str"");
  if (str != null && !str.equals(""String_Node_Str"") && longPollURL == null) {
synchronized (BTCMiner.newBlockMonitor) {
      long t=new Date().getTime();
      if (longPollURL == null && t > disableLPTime) {
        longPollURL=(str.length() > 7 && str.substring(0,4).equalsIgnoreCase(""String_Node_Str"")) ? str : url + str;
        msgObj.msg(""String_Node_Str"" + longPollURL);
        longPollUser=user;
        longPollPassw=passw;
      }
    }
  }
  InputStream is;
  if (con.getContentEncoding() == null) {
    is=con.getInputStream();
  }
 else   if (con.getContentEncoding().equalsIgnoreCase(""String_Node_Str"")) {
    is=new GZIPInputStream(con.getInputStream());
  }
 else   if (con.getContentEncoding().equalsIgnoreCase(""String_Node_Str"")) {
    is=new InflaterInputStream(con.getInputStream());
  }
 else {
    throw new IOException(""String_Node_Str"" + con.getContentEncoding());
  }
  byte[] buf=new byte[1024];
  StringBuffer response=new StringBuffer();
  int len;
  while ((len=is.read(buf)) > 0) {
    response.append(new String(buf,0,len));
  }
  is.close();
  con.disconnect();
  return response.toString();
}","public static String httpGet(MsgObj msgObj,String url,String user,String passw,String request) throws MalformedURLException, IOException {
  HttpURLConnection con=(HttpURLConnection)new URL(url).openConnection();
  con.setRequestMethod(""String_Node_Str"");
  con.setConnectTimeout((int)Math.round(2000.0 * BTCMiner.connectionEffort));
  con.setReadTimeout(url == longPollURL ? 1000000 : (int)Math.round(2000.0 * BTCMiner.connectionEffort));
  con.setRequestProperty(""String_Node_Str"",""String_Node_Str"" + encodeBase64(user + ""String_Node_Str"" + passw));
  con.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
  con.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
  con.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
  con.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
  con.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
  con.setRequestProperty(""String_Node_Str"",""String_Node_Str"" + request.length());
  con.setUseCaches(false);
  con.setDoInput(true);
  con.setDoOutput(true);
  OutputStreamWriter wr=new OutputStreamWriter(con.getOutputStream());
  wr.write(request);
  wr.flush();
  wr.close();
  String str=con.getHeaderField(""String_Node_Str"");
  if (str != null && !str.equals(""String_Node_Str"") && !str.equals(""String_Node_Str"") && !str.equals(""String_Node_Str"") && !str.equals(""String_Node_Str"")) {
    msgObj.rejectReason(str);
  }
  str=con.getHeaderField(""String_Node_Str"");
  if (str != null && !str.equals(""String_Node_Str"") && longPollURL == null) {
synchronized (BTCMiner.newBlockMonitor) {
      long t=new Date().getTime();
      if (longPollURL == null && t > disableLPTime) {
        longPollURL=(str.length() > 7 && str.substring(0,4).equalsIgnoreCase(""String_Node_Str"")) ? str : url + str;
        msgObj.msg(""String_Node_Str"" + longPollURL);
        longPollUser=user;
        longPollPassw=passw;
      }
    }
  }
  InputStream is;
  if (con.getContentEncoding() == null) {
    is=con.getInputStream();
  }
 else   if (con.getContentEncoding().equalsIgnoreCase(""String_Node_Str"")) {
    is=new GZIPInputStream(con.getInputStream());
  }
 else   if (con.getContentEncoding().equalsIgnoreCase(""String_Node_Str"")) {
    is=new InflaterInputStream(con.getInputStream());
  }
 else {
    throw new IOException(""String_Node_Str"" + con.getContentEncoding());
  }
  byte[] buf=new byte[1024];
  StringBuffer response=new StringBuffer();
  int len;
  while ((len=is.read(buf)) > 0) {
    response.append(new String(buf,0,len));
  }
  is.close();
  con.disconnect();
  return response.toString();
}"
88871,"public boolean getNonces() throws UsbException, MalformedURLException, IOException {
  if (!isRunning || disableTime[prevRpcNum] > new Date().getTime()) {
    return false;
  }
  rpcNum=prevRpcNum;
  getNoncesInt();
  if (ignoreErrorTime < new Date().getTime()) {
    errorCount[freqM]*=0.995;
    errorWeight[freqM]=errorWeight[freqM] * 0.995 + 1.0;
    for (int i=0; i < numNonces; i++) {
      if (!checkNonce(nonce[i],hash7[i])) {
        errorCount[freqM]+=1.0 / numNonces;
      }
    }
    errorRate[freqM]=errorCount[freqM] / errorWeight[freqM] * Math.min(1.0,errorWeight[freqM] * 0.01);
    if (errorRate[freqM] > maxErrorRate[freqM]) {
      maxErrorRate[freqM]=errorRate[freqM];
    }
    if (errorWeight[freqM] > 100) {
      maxHashRate=Math.max(maxHashRate,(freqM + 1.0) * (1 - errorRate[freqM]));
    }
  }
  boolean submitted=false;
  for (int i=0; i < numNonces * (1 + extraSolutions); i++) {
    int n=goldenNonce[i];
    if (n != -offsNonces) {
      if (getHash(n) == 0) {
        int j=0;
        while (j < lastGoldenNonces.length && lastGoldenNonces[j] != n) {
          j++;
        }
        if (j >= lastGoldenNonces.length) {
          if (!targetCheck || compareWithTarget(n,false)) {
            submitWork(n);
            submittedCount+=1;
            totalSubmittedCount+=difficulty;
            submitted=true;
          }
        }
      }
    }
  }
  return submitted;
}","public boolean getNonces() throws UsbException, MalformedURLException, IOException {
  if (!isRunning || disableTime[prevRpcNum] > new Date().getTime()) {
    return false;
  }
  rpcNum=prevRpcNum;
  getNoncesInt();
  if (ignoreErrorTime < new Date().getTime()) {
    errorCount[freqM]*=0.995;
    errorWeight[freqM]=errorWeight[freqM] * 0.995 + 1.0;
    for (int i=0; i < numNonces; i++) {
      if (!checkNonce(nonce[i],hash7[i])) {
        errorCount[freqM]+=1.0 / numNonces;
      }
    }
    errorRate[freqM]=errorCount[freqM] / errorWeight[freqM] * Math.min(1.0,errorWeight[freqM] * 0.01);
    if (errorRate[freqM] > maxErrorRate[freqM]) {
      maxErrorRate[freqM]=errorRate[freqM];
    }
    if (errorWeight[freqM] > 120) {
      maxHashRate=Math.max(maxHashRate,(freqM + 1.0) * (1 - errorRate[freqM]));
    }
  }
  boolean submitted=false;
  for (int i=0; i < numNonces * (1 + extraSolutions); i++) {
    int n=goldenNonce[i];
    if (n != -offsNonces) {
      if (getHash(n) == 0) {
        int j=0;
        while (j < lastGoldenNonces.length && lastGoldenNonces[j] != n) {
          j++;
        }
        if (j >= lastGoldenNonces.length) {
          if (!targetCheck || compareWithTarget(n,false)) {
            submitWork(n);
            submittedCount+=1;
            totalSubmittedCount+=difficulty;
            submitted=true;
          }
        }
      }
    }
  }
  return submitted;
}"
88872,"public boolean compareWithTarget(int n,boolean dolog) throws NumberFormatException {
  for (int i=31; i >= 0; i--) {
    if ((hashBuf[i] & 255) < (targetBuf[i] & 255)) {
      if (dolog) {
        dmsg(""String_Node_Str"" + intToHexStr(n) + ""String_Node_Str""+ dataToHexStr(dataBuf));
        dmsg(""String_Node_Str"" + intToHexStr(n) + ""String_Node_Str""+ dataToHexStr(targetBuf));
        dmsg(""String_Node_Str"" + intToHexStr(n) + ""String_Node_Str""+ dataToHexStr(hashBuf).substring(0,64)+ ""String_Node_Str"");
      }
      return true;
    }
    if ((hashBuf[i] & 255) > (targetBuf[i] & 255)) {
      if (dolog) {
        dmsg(""String_Node_Str"" + intToHexStr(n) + ""String_Node_Str""+ dataToHexStr(targetBuf));
        dmsg(""String_Node_Str"" + intToHexStr(n) + ""String_Node_Str""+ dataToHexStr(hashBuf).substring(0,64)+ ""String_Node_Str"");
      }
      return false;
    }
  }
  if (dolog) {
    dmsg(""String_Node_Str"" + intToHexStr(n) + ""String_Node_Str""+ dataToHexStr(targetBuf));
    dmsg(""String_Node_Str"" + intToHexStr(n) + ""String_Node_Str""+ dataToHexStr(hashBuf).substring(0,64)+ ""String_Node_Str"");
  }
  return true;
}","public boolean compareWithTarget(int n,boolean dolog) throws NumberFormatException {
  for (int i=0; i < 32; i++) {
    int j=i + 3 - 2 * (i % 4);
    if ((hashBuf[31 - j] & 255) < (targetBuf[31 - i] & 255)) {
      if (dolog) {
        dmsg(""String_Node_Str"" + intToHexStr(n) + ""String_Node_Str""+ dataToHexStr(dataBuf));
        dmsg(""String_Node_Str"" + intToHexStr(n) + ""String_Node_Str""+ dataToHexStr(targetBuf));
        dmsg(""String_Node_Str"" + intToHexStr(n) + ""String_Node_Str""+ dataToHexStr(hashBuf).substring(0,64)+ ""String_Node_Str"");
      }
      return true;
    }
    if ((hashBuf[31 - j] & 255) > (targetBuf[31 - i] & 255)) {
      if (dolog) {
        dmsg(""String_Node_Str"" + intToHexStr(n) + ""String_Node_Str""+ dataToHexStr(targetBuf));
        dmsg(""String_Node_Str"" + intToHexStr(n) + ""String_Node_Str""+ dataToHexStr(hashBuf).substring(0,64)+ ""String_Node_Str"");
      }
      return false;
    }
  }
  if (dolog) {
    dmsg(""String_Node_Str"" + intToHexStr(n) + ""String_Node_Str""+ dataToHexStr(targetBuf));
    dmsg(""String_Node_Str"" + intToHexStr(n) + ""String_Node_Str""+ dataToHexStr(hashBuf).substring(0,64)+ ""String_Node_Str"");
  }
  return true;
}"
88873,"private String serveSelectPool(Properties parms){
  if (parms.getProperty(""String_Node_Str"") != null) {
    boolean force=false;
    if (parms.getProperty(""String_Node_Str"") != null) {
      force=true;
    }
    if (hopping || force) {
      int newpool=Integer.parseInt(parms.getProperty(""String_Node_Str""));
      int server=BTCMiner.rpcCount;
      int backup1=BTCMiner.rpcFirstBackup;
      int backup=0;
      if (backup1 > 0) {
        backup=server - backup1;
      }
      if (newpool >= 0 && newpool < (server - backup)) {
        for (int i=0; i < (server - backup); i++) {
          if (i == newpool) {
            BTCMiner.rpc[i].state=true;
          }
        }
        for (int i=0; i < (server - backup); i++) {
          if (i != newpool) {
            BTCMiner.rpc[i].state=false;
          }
        }
        if (BTCMiner.newBlockMonitor != null) {
synchronized (BTCMiner.newBlockMonitor) {
            BTCMiner.disableLPTime=new Date().getTime() + 20000;
            BTCMiner.longPollURL=null;
            BTCMiner.longPollUser=""String_Node_Str"";
            BTCMiner.longPollPassw=""String_Node_Str"";
          }
        }
      }
    }
  }
  String msg;
  if (parms.getProperty(""String_Node_Str"") != null) {
    msg=""String_Node_Str"" + parms.getProperty(""String_Node_Str"") + ""String_Node_Str"";
  }
 else {
    msg=""String_Node_Str"";
  }
  return msg;
}","private String serveSelectPool(Properties parms){
  if (parms.getProperty(""String_Node_Str"") != null) {
    boolean force=false;
    if (parms.getProperty(""String_Node_Str"") != null) {
      force=true;
    }
    if (remoteSwitching || force) {
      int newpool=Integer.parseInt(parms.getProperty(""String_Node_Str""));
      int server=BTCMiner.rpcCount;
      int backup1=BTCMiner.rpcFirstBackup;
      int backup=0;
      if (backup1 > 0) {
        backup=server - backup1;
      }
      if (newpool >= 0 && newpool < (server - backup)) {
        for (int i=0; i < (server - backup); i++) {
          if (i == newpool) {
            BTCMiner.rpc[i].state=true;
          }
        }
        for (int i=0; i < (server - backup); i++) {
          if (i != newpool) {
            BTCMiner.rpc[i].state=false;
          }
        }
        if (BTCMiner.newBlockMonitor != null) {
synchronized (BTCMiner.newBlockMonitor) {
            BTCMiner.disableLPTime=new Date().getTime() + 20000;
            BTCMiner.longPollURL=null;
            BTCMiner.longPollUser=""String_Node_Str"";
            BTCMiner.longPollPassw=""String_Node_Str"";
          }
        }
      }
    }
  }
  String msg;
  if (parms.getProperty(""String_Node_Str"") != null) {
    msg=""String_Node_Str"" + parms.getProperty(""String_Node_Str"") + ""String_Node_Str"";
  }
 else {
    msg=""String_Node_Str"";
  }
  return msg;
}"
88874,"public static void main(String args[]){
  int devNum=-1;
  boolean workarounds=false;
  String firmwareFile=null, snString=null;
  boolean printBus=false;
  boolean verbose=false;
  boolean eraseFirmware=false;
  boolean noLog=false;
  String filterType=null;
  String logFileName=""String_Node_Str"";
  char mode='s';
  File wwwroot=new File(""String_Node_Str"").getAbsoluteFile();
  int httpdPortno=8080;
  upTime=new Date().getTime();
  try {
    LibusbJava.usb_init();
    for (int i=0; i < args.length; i++) {
      if (args[i].equals(""String_Node_Str"")) {
        i++;
        try {
          if (i >= args.length) {
            throw new Exception();
          }
          devNum=Integer.parseInt(args[i]);
        }
 catch (        Exception e) {
          throw new ParameterException(""String_Node_Str"");
        }
      }
 else       if (args[i].equals(""String_Node_Str"")) {
        i++;
        if (i >= args.length) {
          throw new ParameterException(""String_Node_Str"");
        }
        try {
          logFileName=args[i];
        }
 catch (        Exception e) {
          throw new ParameterException(""String_Node_Str"" + e.getLocalizedMessage());
        }
      }
 else       if (args[i].equals(""String_Node_Str"")) {
        i++;
        if (i >= args.length) {
          throw new ParameterException(""String_Node_Str"");
        }
        try {
          logFile2=new PrintStream(new FileOutputStream(args[i],true),true);
        }
 catch (        Exception e) {
          throw new ParameterException(""String_Node_Str"" + e.getLocalizedMessage());
        }
      }
 else       if (args[i].equals(""String_Node_Str"")) {
        i++;
        if (i >= args.length) {
          throw new ParameterException(""String_Node_Str"");
        }
        try {
          blkLogFile=new PrintStream(new FileOutputStream(args[i],true),true);
        }
 catch (        Exception e) {
          throw new ParameterException(""String_Node_Str"" + e.getLocalizedMessage());
        }
      }
 else       if (args[i].equals(""String_Node_Str"")) {
        i++;
        if (i >= args.length) {
          throw new ParameterException(""String_Node_Str"");
        }
        try {
          in2FileName=args[i];
          new Thread(){
            public void run(){
              try {
                in2=new FileInputStream(in2FileName);
              }
 catch (              Exception e) {
                System.err.println(""String_Node_Str"" + e.getLocalizedMessage());
              }
            }
          }
.start();
        }
 catch (        Exception e) {
          throw new ParameterException(""String_Node_Str"" + e.getLocalizedMessage());
        }
      }
 else       if (args[i].equals(""String_Node_Str"")) {
        if (rpcCount >= maxRpcCount) {
          throw new IndexOutOfBoundsException(""String_Node_Str"");
        }
        if (rpcFirstBackup > 0) {
          throw new ParameterException(""String_Node_Str"");
        }
        i+=5;
        try {
          if (i >= args.length) {
            throw new Exception();
          }
          boolean state=rpcCount == 0 ? true : false;
          rpc[rpcCount]=new RPC(args[i - 4],args[i - 3],args[i - 2],args[i - 1],args[i],state);
          rpcCount+=1;
        }
 catch (        Exception e) {
          throw new ParameterException(""String_Node_Str"");
        }
      }
 else       if (args[i].equals(""String_Node_Str"")) {
        if (rpcCount >= maxRpcCount) {
          throw new IndexOutOfBoundsException(""String_Node_Str"");
        }
        if (rpcCount == 0) {
          throw new ParameterException(""String_Node_Str"");
        }
        i+=5;
        try {
          if (i >= args.length) {
            throw new Exception();
          }
          rpc[rpcCount]=new RPC(args[i - 4],args[i - 3],args[i - 2],args[i - 1],args[i],true);
          if (rpcFirstBackup == 0) {
            rpcFirstBackup=rpcCount;
          }
          rpcCount+=1;
        }
 catch (        Exception e) {
          throw new ParameterException(""String_Node_Str"");
        }
      }
 else       if (args[i].equals(""String_Node_Str"")) {
        i+=3;
        try {
          if (i >= args.length) {
            throw new Exception();
          }
          longPollURL=args[i - 2];
          longPollUser=args[i - 1];
          longPollPassw=args[i];
        }
 catch (        Exception e) {
          throw new ParameterException(""String_Node_Str"");
        }
      }
 else       if (args[i].equals(""String_Node_Str"")) {
        i++;
        try {
          if (i >= args.length) {
            throw new Exception();
          }
          firmwareFile=args[i];
        }
 catch (        Exception e) {
          throw new ParameterException(""String_Node_Str"");
        }
      }
 else       if (args[i].equals(""String_Node_Str"")) {
        i++;
        try {
          if (i >= args.length) {
            throw new Exception();
          }
          filterType=args[i];
        }
 catch (        Exception e) {
          throw new ParameterException(""String_Node_Str"");
        }
      }
 else       if (args[i].equals(""String_Node_Str"")) {
        i++;
        try {
          if (i >= args.length) {
            throw new Exception();
          }
          filterSN=args[i];
        }
 catch (        Exception e) {
          throw new ParameterException(""String_Node_Str"");
        }
      }
 else       if (args[i].equals(""String_Node_Str"")) {
        i++;
        try {
          if (i >= args.length) {
            throw new Exception();
          }
          if (args[i].length() < 1) {
            throw new Exception();
          }
          mode=Character.toLowerCase(args[i].charAt(0));
          if (mode != 's' && mode != 't' && mode != 'p' && mode != 'c' && mode != 'h') {
            throw new Exception();
          }
        }
 catch (        Exception e) {
          throw new ParameterException(""String_Node_Str"");
        }
      }
 else       if (args[i].equals(""String_Node_Str"")) {
        i++;
        if (i >= args.length) {
          throw new ParameterException(""String_Node_Str"");
        }
        snString=checkSnString(args[i]);
      }
 else       if (args[i].equals(""String_Node_Str"")) {
        printBus=true;
      }
 else       if (args[i].equals(""String_Node_Str"")) {
        verbose=true;
        BTCMinerCluster.verbose=true;
      }
 else       if (args[i].equals(""String_Node_Str"")) {
        eraseFirmware=true;
      }
 else       if (args[i].equals(""String_Node_Str"")) {
        forceEP0Config=true;
      }
 else       if (args[i].equals(""String_Node_Str"")) {
        targetCheck=true;
      }
 else       if (args[i].equals(""String_Node_Str"")) {
        System.out.println(ParameterException.helpMsg);
        System.exit(0);
      }
 else       if (args[i].equals(""String_Node_Str"")) {
        i++;
        try {
          if (i >= args.length) {
            throw new Exception();
          }
          BTCMinerCluster.maxDevicesPerThread=Integer.parseInt(args[i]);
        }
 catch (        Exception e) {
          throw new ParameterException(""String_Node_Str"");
        }
      }
 else       if (args[i].equals(""String_Node_Str"")) {
        i++;
        try {
          if (i >= args.length) {
            throw new Exception();
          }
          overheatThreshold=Double.parseDouble(args[i]);
        }
 catch (        Exception e) {
          throw new ParameterException(""String_Node_Str"");
        }
      }
 else       if (args[i].equals(""String_Node_Str"")) {
        i++;
        try {
          if (i >= args.length) {
            throw new Exception();
          }
          tempLimit=Double.parseDouble(args[i]);
        }
 catch (        Exception e) {
          throw new ParameterException(""String_Node_Str"");
        }
      }
 else       if (args[i].equals(""String_Node_Str"")) {
        i++;
        try {
          if (i >= args.length) {
            throw new Exception();
          }
          double d=Double.parseDouble(args[i]);
          if (d < 0.0001) {
            d=0.0001;
          }
          if (d < maxMaxErrorRate) {
            maxMaxErrorRate=d;
          }
        }
 catch (        Exception e) {
          throw new ParameterException(""String_Node_Str"");
        }
      }
 else       if (args[i].equals(""String_Node_Str"")) {
        i++;
        try {
          if (i >= args.length) {
            throw new Exception();
          }
          long autoResetInterval=Long.parseLong(args[i]);
          if (autoResetInterval < 0) {
            throw new Exception();
          }
          BTCMinerCluster.autoResetInterval=autoResetInterval * 1000;
        }
 catch (        Exception e) {
          throw new ParameterException(""String_Node_Str"");
        }
      }
 else       if (args[i].equals(""String_Node_Str"")) {
        noLog=true;
      }
 else       if (args[i].equals(""String_Node_Str"")) {
        i++;
        try {
          if (i >= args.length) {
            throw new Exception();
          }
          clusterId=args[i];
        }
 catch (        Exception e) {
          throw new ParameterException(""String_Node_Str"");
        }
      }
 else       if (args[i].equals(""String_Node_Str"")) {
        i++;
        try {
          if (i >= args.length) {
            throw new Exception();
          }
          httpdPortno=Integer.parseInt(args[i]);
          if (httpdPortno <= 0 || httpdPortno >= 65536) {
            throw new Exception();
          }
        }
 catch (        Exception e) {
          throw new ParameterException(""String_Node_Str"");
        }
      }
 else {
        throw new ParameterException(""String_Node_Str"" + args[i]);
      }
    }
    if (noLog != true) {
      logFile=new PrintStream(new FileOutputStream(logFileName,true),true);
    }
    if (overheatThreshold > 0.1001) {
      System.err.println(""String_Node_Str"" + overheatThreshold + ""String_Node_Str"");
    }
    if (BTCMinerCluster.maxDevicesPerThread < 1) {
      BTCMinerCluster.maxDevicesPerThread=127;
    }
    if (mode != 'c' && mode != 'h' && filterSN != null) {
      filterSN=checkSnString(filterSN);
    }
    if (mode != 't' && mode != 'p') {
      if (rpcCount == 0) {
        throw new ParameterException(""String_Node_Str"");
      }
    }
    if (mode == 's' || mode == 't') {
      if (devNum < 0) {
        devNum=0;
      }
      ZtexScanBus1 bus=new ZtexScanBus1(ZtexDevice1.ztexVendorId,ZtexDevice1.ztexProductId,filterSN == null,false,1,filterSN,10,0,1,0);
      if (bus.numberOfDevices() <= 0) {
        System.err.println(""String_Node_Str"");
        System.exit(0);
      }
      if (printBus) {
        printBus(bus);
        System.exit(0);
      }
      BTCMiner miner=new BTCMiner(bus.device(devNum),firmwareFile,verbose);
      if (mode == 't') {
        miner.initWork(hexStrToData(""String_Node_Str""),hexStrToData(""String_Node_Str""));
        miner.sendData();
        for (int i=0; i < 200; i++) {
          try {
            Thread.sleep(250);
          }
 catch (          InterruptedException e) {
          }
          miner.getNoncesInt();
          for (int j=0; j < miner.numNonces; j++) {
            System.out.println(i + ""String_Node_Str"" + j+ ""String_Node_Str""+ intToHexStr(miner.nonce[j])+ ""String_Node_Str""+ miner.checkNonce(miner.nonce[j],miner.hash7[j])+ ""String_Node_Str""+ miner.overflowCount+ ""String_Node_Str""+ intToHexStr(miner.goldenNonce[j * (1 + miner.extraSolutions)])+ ""String_Node_Str""+ intToHexStr(miner.getHash(miner.goldenNonce[j])));
          }
        }
      }
 else {
        Vector<BTCMiner> v=new Vector<BTCMiner>();
        v.add(miner);
        for (int i=1; i < miner.numberOfFpgas(); i++) {
          v.add(new BTCMiner(miner.ztex(),miner.fpgaNum(i),verbose));
        }
        System.out.println(""String_Node_Str"");
        if (miner.ztex().numberOfFpgas() > 1) {
          System.out.println(""String_Node_Str"");
        }
        System.out.println(""String_Node_Str"");
        new PollLoop(v).run();
      }
    }
 else     if (mode == 'p') {
      if (eraseFirmware && filterType == null && filterSN == null) {
        throw new ParameterException(""String_Node_Str"");
      }
      ZtexScanBus1 bus=new ZtexScanBus1(ZtexDevice1.ztexVendorId,ZtexDevice1.ztexProductId,filterType == null && filterSN == null,false,1,null,10,0,0,0);
      if (bus.numberOfDevices() <= 0) {
        System.err.println(""String_Node_Str"");
        System.exit(0);
      }
      if (printBus) {
        printBus(bus);
        System.exit(0);
      }
      if (firmwareFile == null && !eraseFirmware) {
        throw new Exception(""String_Node_Str"");
      }
      int imin=0, imax=bus.numberOfDevices() - 1;
      if (devNum >= 0) {
        imin=devNum;
        imax=devNum;
      }
      ZtexIhxFile1 ihxFile=eraseFirmware ? null : new ZtexIhxFile1(firmwareFile);
      int j=0;
      for (int i=imin; i <= imax; i++) {
        ZtexDevice1 dev=bus.device(i);
        if ((filterSN == null || filterSN.equals(dev.snString())) && (filterType == null || ((dev.productId(2) == 1) && filterType.equals(getType(dev)))) && (filterType != null || filterSN != null || dev.productId(2) == 0)) {
          Ztex1v1 ztex=new Ztex1v1(dev);
          if (snString != null && ihxFile != null) {
            ihxFile.setSnString(snString);
          }
 else           if (ztex.valid() && ihxFile != null) {
            ihxFile.setSnString(dev.snString());
          }
          if (eraseFirmware) {
            ztex.eepromDisable();
            System.out.println(""String_Node_Str"" + ztex.toString());
          }
 else {
            System.out.println(""String_Node_Str"" + ztex.toString());
            System.out.println(""String_Node_Str"" + ztex.uploadFirmware(ihxFile,false) + ""String_Node_Str"");
            System.out.println(""String_Node_Str"" + ztex.eepromUpload(ihxFile,false) + ""String_Node_Str"");
            System.out.println(""String_Node_Str"" + ztex.toString());
          }
          j+=1;
        }
      }
      System.out.println(""String_Node_Str"" + j);
    }
 else     if (mode == 'c') {
      cluster=new BTCMinerCluster();
      cluster.run();
    }
 else     if (mode == 'h') {
      try {
        new BTCMinerHTTPD(httpdPortno,wwwroot);
      }
 catch (      IOException ioe) {
        System.err.println(""String_Node_Str"" + String.format(""String_Node_Str"",httpdPortno) + ""String_Node_Str""+ ioe);
        System.exit(-1);
      }
      System.out.println(""String_Node_Str"" + String.format(""String_Node_Str"",httpdPortno) + ""String_Node_Str"");
      cluster=new BTCMinerCluster();
      cluster.run();
    }
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"" + e.getLocalizedMessage());
  }
  if (BTCMiner.newBlockMonitor != null) {
    BTCMiner.newBlockMonitor.running=false;
    BTCMiner.newBlockMonitor.interrupt();
  }
  System.exit(0);
}","public static void main(String args[]){
  int devNum=-1;
  boolean workarounds=false;
  String firmwareFile=null, snString=null;
  boolean printBus=false;
  boolean verbose=false;
  boolean eraseFirmware=false;
  boolean noLog=false;
  String filterType=null;
  String logFileName=""String_Node_Str"";
  char mode='s';
  File wwwroot=new File(""String_Node_Str"").getAbsoluteFile();
  int httpdPortno=8080;
  upTime=new Date().getTime();
  try {
    LibusbJava.usb_init();
    for (int i=0; i < args.length; i++) {
      if (args[i].equals(""String_Node_Str"")) {
        i++;
        try {
          if (i >= args.length) {
            throw new Exception();
          }
          devNum=Integer.parseInt(args[i]);
        }
 catch (        Exception e) {
          throw new ParameterException(""String_Node_Str"");
        }
      }
 else       if (args[i].equals(""String_Node_Str"")) {
        i++;
        if (i >= args.length) {
          throw new ParameterException(""String_Node_Str"");
        }
        try {
          logFileName=args[i];
        }
 catch (        Exception e) {
          throw new ParameterException(""String_Node_Str"" + e.getLocalizedMessage());
        }
      }
 else       if (args[i].equals(""String_Node_Str"")) {
        i++;
        if (i >= args.length) {
          throw new ParameterException(""String_Node_Str"");
        }
        try {
          logFile2=new PrintStream(new FileOutputStream(args[i],true),true);
        }
 catch (        Exception e) {
          throw new ParameterException(""String_Node_Str"" + e.getLocalizedMessage());
        }
      }
 else       if (args[i].equals(""String_Node_Str"")) {
        i++;
        if (i >= args.length) {
          throw new ParameterException(""String_Node_Str"");
        }
        try {
          blkLogFile=new PrintStream(new FileOutputStream(args[i],true),true);
        }
 catch (        Exception e) {
          throw new ParameterException(""String_Node_Str"" + e.getLocalizedMessage());
        }
      }
 else       if (args[i].equals(""String_Node_Str"")) {
        i++;
        if (i >= args.length) {
          throw new ParameterException(""String_Node_Str"");
        }
        try {
          in2FileName=args[i];
          new Thread(){
            public void run(){
              try {
                in2=new FileInputStream(in2FileName);
              }
 catch (              Exception e) {
                System.err.println(""String_Node_Str"" + e.getLocalizedMessage());
              }
            }
          }
.start();
        }
 catch (        Exception e) {
          throw new ParameterException(""String_Node_Str"" + e.getLocalizedMessage());
        }
      }
 else       if (args[i].equals(""String_Node_Str"")) {
        if (rpcCount >= maxRpcCount) {
          throw new IndexOutOfBoundsException(""String_Node_Str"");
        }
        if (rpcFirstBackup > 0) {
          throw new ParameterException(""String_Node_Str"");
        }
        i+=5;
        try {
          if (i >= args.length) {
            throw new Exception();
          }
          boolean state=rpcCount == 2 ? true : false;
          rpc[rpcCount]=new RPC(args[i - 4],args[i - 3],args[i - 2],args[i - 1],args[i],state);
          rpcCount+=1;
        }
 catch (        Exception e) {
          throw new ParameterException(""String_Node_Str"");
        }
      }
 else       if (args[i].equals(""String_Node_Str"")) {
        if (rpcCount >= maxRpcCount) {
          throw new IndexOutOfBoundsException(""String_Node_Str"");
        }
        if (rpcCount == 0) {
          throw new ParameterException(""String_Node_Str"");
        }
        i+=5;
        try {
          if (i >= args.length) {
            throw new Exception();
          }
          rpc[rpcCount]=new RPC(args[i - 4],args[i - 3],args[i - 2],args[i - 1],args[i],true);
          if (rpcFirstBackup == 0) {
            rpcFirstBackup=rpcCount;
          }
          rpcCount+=1;
        }
 catch (        Exception e) {
          throw new ParameterException(""String_Node_Str"");
        }
      }
 else       if (args[i].equals(""String_Node_Str"")) {
        i+=3;
        try {
          if (i >= args.length) {
            throw new Exception();
          }
          longPollURL=args[i - 2];
          longPollUser=args[i - 1];
          longPollPassw=args[i];
        }
 catch (        Exception e) {
          throw new ParameterException(""String_Node_Str"");
        }
      }
 else       if (args[i].equals(""String_Node_Str"")) {
        i++;
        try {
          if (i >= args.length) {
            throw new Exception();
          }
          firmwareFile=args[i];
        }
 catch (        Exception e) {
          throw new ParameterException(""String_Node_Str"");
        }
      }
 else       if (args[i].equals(""String_Node_Str"")) {
        i++;
        try {
          if (i >= args.length) {
            throw new Exception();
          }
          filterType=args[i];
        }
 catch (        Exception e) {
          throw new ParameterException(""String_Node_Str"");
        }
      }
 else       if (args[i].equals(""String_Node_Str"")) {
        i++;
        try {
          if (i >= args.length) {
            throw new Exception();
          }
          filterSN=args[i];
        }
 catch (        Exception e) {
          throw new ParameterException(""String_Node_Str"");
        }
      }
 else       if (args[i].equals(""String_Node_Str"")) {
        i++;
        try {
          if (i >= args.length) {
            throw new Exception();
          }
          if (args[i].length() < 1) {
            throw new Exception();
          }
          mode=Character.toLowerCase(args[i].charAt(0));
          if (mode != 's' && mode != 't' && mode != 'p' && mode != 'c' && mode != 'h') {
            throw new Exception();
          }
        }
 catch (        Exception e) {
          throw new ParameterException(""String_Node_Str"");
        }
      }
 else       if (args[i].equals(""String_Node_Str"")) {
        i++;
        if (i >= args.length) {
          throw new ParameterException(""String_Node_Str"");
        }
        snString=checkSnString(args[i]);
      }
 else       if (args[i].equals(""String_Node_Str"")) {
        printBus=true;
      }
 else       if (args[i].equals(""String_Node_Str"")) {
        verbose=true;
        BTCMinerCluster.verbose=true;
      }
 else       if (args[i].equals(""String_Node_Str"")) {
        eraseFirmware=true;
      }
 else       if (args[i].equals(""String_Node_Str"")) {
        forceEP0Config=true;
      }
 else       if (args[i].equals(""String_Node_Str"")) {
        targetCheck=true;
      }
 else       if (args[i].equals(""String_Node_Str"")) {
        System.out.println(ParameterException.helpMsg);
        System.exit(0);
      }
 else       if (args[i].equals(""String_Node_Str"")) {
        i++;
        try {
          if (i >= args.length) {
            throw new Exception();
          }
          BTCMinerCluster.maxDevicesPerThread=Integer.parseInt(args[i]);
        }
 catch (        Exception e) {
          throw new ParameterException(""String_Node_Str"");
        }
      }
 else       if (args[i].equals(""String_Node_Str"")) {
        i++;
        try {
          if (i >= args.length) {
            throw new Exception();
          }
          overheatThreshold=Double.parseDouble(args[i]);
        }
 catch (        Exception e) {
          throw new ParameterException(""String_Node_Str"");
        }
      }
 else       if (args[i].equals(""String_Node_Str"")) {
        i++;
        try {
          if (i >= args.length) {
            throw new Exception();
          }
          tempLimit=Double.parseDouble(args[i]);
        }
 catch (        Exception e) {
          throw new ParameterException(""String_Node_Str"");
        }
      }
 else       if (args[i].equals(""String_Node_Str"")) {
        i++;
        try {
          if (i >= args.length) {
            throw new Exception();
          }
          double d=Double.parseDouble(args[i]);
          if (d < 0.0001) {
            d=0.0001;
          }
          if (d < maxMaxErrorRate) {
            maxMaxErrorRate=d;
          }
        }
 catch (        Exception e) {
          throw new ParameterException(""String_Node_Str"");
        }
      }
 else       if (args[i].equals(""String_Node_Str"")) {
        i++;
        try {
          if (i >= args.length) {
            throw new Exception();
          }
          long autoResetInterval=Long.parseLong(args[i]);
          if (autoResetInterval < 0) {
            throw new Exception();
          }
          BTCMinerCluster.autoResetInterval=autoResetInterval * 1000;
        }
 catch (        Exception e) {
          throw new ParameterException(""String_Node_Str"");
        }
      }
 else       if (args[i].equals(""String_Node_Str"")) {
        noLog=true;
      }
 else       if (args[i].equals(""String_Node_Str"")) {
        i++;
        try {
          if (i >= args.length) {
            throw new Exception();
          }
          clusterId=args[i];
        }
 catch (        Exception e) {
          throw new ParameterException(""String_Node_Str"");
        }
      }
 else       if (args[i].equals(""String_Node_Str"")) {
        i++;
        try {
          if (i >= args.length) {
            throw new Exception();
          }
          httpdPortno=Integer.parseInt(args[i]);
          if (httpdPortno <= 0 || httpdPortno >= 65536) {
            throw new Exception();
          }
        }
 catch (        Exception e) {
          throw new ParameterException(""String_Node_Str"");
        }
      }
 else {
        throw new ParameterException(""String_Node_Str"" + args[i]);
      }
    }
    if (noLog != true) {
      logFile=new PrintStream(new FileOutputStream(logFileName,true),true);
    }
    if (overheatThreshold > 0.1001) {
      System.err.println(""String_Node_Str"" + overheatThreshold + ""String_Node_Str"");
    }
    if (BTCMinerCluster.maxDevicesPerThread < 1) {
      BTCMinerCluster.maxDevicesPerThread=127;
    }
    if (mode != 'c' && mode != 'h' && filterSN != null) {
      filterSN=checkSnString(filterSN);
    }
    if (mode != 't' && mode != 'p') {
      if (rpcCount == 0) {
        throw new ParameterException(""String_Node_Str"");
      }
    }
    if (mode == 's' || mode == 't') {
      if (devNum < 0) {
        devNum=0;
      }
      ZtexScanBus1 bus=new ZtexScanBus1(ZtexDevice1.ztexVendorId,ZtexDevice1.ztexProductId,filterSN == null,false,1,filterSN,10,0,1,0);
      if (bus.numberOfDevices() <= 0) {
        System.err.println(""String_Node_Str"");
        System.exit(0);
      }
      if (printBus) {
        printBus(bus);
        System.exit(0);
      }
      BTCMiner miner=new BTCMiner(bus.device(devNum),firmwareFile,verbose);
      if (mode == 't') {
        miner.initWork(hexStrToData(""String_Node_Str""),hexStrToData(""String_Node_Str""));
        miner.sendData();
        for (int i=0; i < 200; i++) {
          try {
            Thread.sleep(250);
          }
 catch (          InterruptedException e) {
          }
          miner.getNoncesInt();
          for (int j=0; j < miner.numNonces; j++) {
            System.out.println(i + ""String_Node_Str"" + j+ ""String_Node_Str""+ intToHexStr(miner.nonce[j])+ ""String_Node_Str""+ miner.checkNonce(miner.nonce[j],miner.hash7[j])+ ""String_Node_Str""+ miner.overflowCount+ ""String_Node_Str""+ intToHexStr(miner.goldenNonce[j * (1 + miner.extraSolutions)])+ ""String_Node_Str""+ intToHexStr(miner.getHash(miner.goldenNonce[j])));
          }
        }
      }
 else {
        Vector<BTCMiner> v=new Vector<BTCMiner>();
        v.add(miner);
        for (int i=1; i < miner.numberOfFpgas(); i++) {
          v.add(new BTCMiner(miner.ztex(),miner.fpgaNum(i),verbose));
        }
        System.out.println(""String_Node_Str"");
        if (miner.ztex().numberOfFpgas() > 1) {
          System.out.println(""String_Node_Str"");
        }
        System.out.println(""String_Node_Str"");
        new PollLoop(v).run();
      }
    }
 else     if (mode == 'p') {
      if (eraseFirmware && filterType == null && filterSN == null) {
        throw new ParameterException(""String_Node_Str"");
      }
      ZtexScanBus1 bus=new ZtexScanBus1(ZtexDevice1.ztexVendorId,ZtexDevice1.ztexProductId,filterType == null && filterSN == null,false,1,null,10,0,0,0);
      if (bus.numberOfDevices() <= 0) {
        System.err.println(""String_Node_Str"");
        System.exit(0);
      }
      if (printBus) {
        printBus(bus);
        System.exit(0);
      }
      if (firmwareFile == null && !eraseFirmware) {
        throw new Exception(""String_Node_Str"");
      }
      int imin=0, imax=bus.numberOfDevices() - 1;
      if (devNum >= 0) {
        imin=devNum;
        imax=devNum;
      }
      ZtexIhxFile1 ihxFile=eraseFirmware ? null : new ZtexIhxFile1(firmwareFile);
      int j=0;
      for (int i=imin; i <= imax; i++) {
        ZtexDevice1 dev=bus.device(i);
        if ((filterSN == null || filterSN.equals(dev.snString())) && (filterType == null || ((dev.productId(2) == 1) && filterType.equals(getType(dev)))) && (filterType != null || filterSN != null || dev.productId(2) == 0)) {
          Ztex1v1 ztex=new Ztex1v1(dev);
          if (snString != null && ihxFile != null) {
            ihxFile.setSnString(snString);
          }
 else           if (ztex.valid() && ihxFile != null) {
            ihxFile.setSnString(dev.snString());
          }
          if (eraseFirmware) {
            ztex.eepromDisable();
            System.out.println(""String_Node_Str"" + ztex.toString());
          }
 else {
            System.out.println(""String_Node_Str"" + ztex.toString());
            System.out.println(""String_Node_Str"" + ztex.uploadFirmware(ihxFile,false) + ""String_Node_Str"");
            System.out.println(""String_Node_Str"" + ztex.eepromUpload(ihxFile,false) + ""String_Node_Str"");
            System.out.println(""String_Node_Str"" + ztex.toString());
          }
          j+=1;
        }
      }
      System.out.println(""String_Node_Str"" + j);
    }
 else     if (mode == 'c') {
      cluster=new BTCMinerCluster();
      cluster.run();
    }
 else     if (mode == 'h') {
      try {
        new BTCMinerHTTPD(httpdPortno,wwwroot);
      }
 catch (      IOException ioe) {
        System.err.println(""String_Node_Str"" + String.format(""String_Node_Str"",httpdPortno) + ""String_Node_Str""+ ioe);
        System.exit(-1);
      }
      System.out.println(""String_Node_Str"" + String.format(""String_Node_Str"",httpdPortno) + ""String_Node_Str"");
      cluster=new BTCMinerCluster();
      cluster.run();
    }
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"" + e.getLocalizedMessage());
  }
  if (BTCMiner.newBlockMonitor != null) {
    BTCMiner.newBlockMonitor.running=false;
    BTCMiner.newBlockMonitor.interrupt();
  }
  System.exit(0);
}"
88875,"public Response serve(String uri,String method,Properties header,Properties parms,Properties files){
  if (uri.equalsIgnoreCase(""String_Node_Str"")) {
    return new NanoHTTPD.Response(HTTP_OK,MIME_HTML,serveJson(uri,header));
  }
 else   if (uri.equalsIgnoreCase(""String_Node_Str"")) {
    return new NanoHTTPD.Response(HTTP_OK,MIME_HTML,serveSelectPool(parms));
  }
 else   if (uri.equalsIgnoreCase(""String_Node_Str"")) {
    return new NanoHTTPD.Response(HTTP_OK,MIME_HTML,serveSelectRefresh(parms));
  }
 else   if (uri.equalsIgnoreCase(""String_Node_Str"")) {
    return new NanoHTTPD.Response(HTTP_OK,MIME_HTML,serveSelectRPC(parms));
  }
 else   if (uri.equalsIgnoreCase(""String_Node_Str"")) {
    return new NanoHTTPD.Response(HTTP_OK,MIME_HTML,serveToggleHopping(parms));
  }
 else {
    return serveFile(uri,header,myRootDir,true);
  }
}","public Response serve(String uri,String method,Properties header,Properties parms,Properties files){
  Response rsp;
  if (uri.equalsIgnoreCase(""String_Node_Str"")) {
    rsp=new NanoHTTPD.Response(HTTP_OK,MIME_JSON,serveJson(uri,header));
    return rsp;
  }
 else   if (uri.equalsIgnoreCase(""String_Node_Str"")) {
    rsp=new NanoHTTPD.Response(HTTP_OK,MIME_HTML,serveSelectPool(parms));
    return rsp;
  }
 else   if (uri.equalsIgnoreCase(""String_Node_Str"")) {
    rsp=new NanoHTTPD.Response(HTTP_OK,MIME_HTML,serveSelectRefresh(parms));
    return rsp;
  }
 else   if (uri.equalsIgnoreCase(""String_Node_Str"")) {
    rsp=new NanoHTTPD.Response(HTTP_OK,MIME_HTML,serveSelectRPC(parms));
    return rsp;
  }
 else   if (uri.equalsIgnoreCase(""String_Node_Str"")) {
    rsp=new NanoHTTPD.Response(HTTP_OK,MIME_HTML,serveSetFlag(parms));
    return rsp;
  }
 else {
    rsp=serveFile(uri,header,myRootDir,true);
  }
  rsp.addHeader(""String_Node_Str"",""String_Node_Str"");
  rsp.addHeader(""String_Node_Str"",""String_Node_Str"");
  return rsp;
}"
88876,"private String serveJson(String uri,Properties header){
  StringBuffer sb=new StringBuffer(""String_Node_Str"" + BTCMiner.clusterId + ""String_Node_Str"");
  Date now=new Date();
  sb.append(""String_Node_Str"" + now.toString() + ""String_Node_Str"");
  long uptime=(now.getTime() - BTCMiner.upTime) / 1000;
  sb.append(""String_Node_Str"" + uptime + ""String_Node_Str"");
  if (header.getProperty(""String_Node_Str"") != null) {
    sb.append(""String_Node_Str"" + header.getProperty(""String_Node_Str"") + ""String_Node_Str"");
  }
  if (BTCMiner.cluster == null) {
    sb.append(""String_Node_Str"");
  }
 else {
    sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"" + refreshTmo + ""String_Node_Str"");
    if (BTCMiner.longPollURL != null) {
      sb.append(""String_Node_Str"" + BTCMiner.longPollURL + ""String_Node_Str"");
    }
 else {
      sb.append(""String_Node_Str"");
    }
    int server=BTCMiner.rpcCount;
    int backup1=BTCMiner.rpcFirstBackup;
    int backup=0;
    if (backup1 > 0) {
      backup=server - backup1;
    }
    if (server > 0) {
      sb.append(""String_Node_Str"" + (server - backup) + ""String_Node_Str"");
      sb.append(""String_Node_Str"");
      for (int i=0; i < (server - backup); i++) {
        RPC rpc=BTCMiner.rpc[i];
        if (i > 0) {
          sb.append(""String_Node_Str"");
        }
        String state;
        if (rpc.state) {
          state=""String_Node_Str"";
        }
 else {
          state=""String_Node_Str"";
        }
        sb.append(""String_Node_Str"" + i + ""String_Node_Str""+ state+ ""String_Node_Str""+ rpc.name+ ""String_Node_Str""+ rpc.url+ ""String_Node_Str""+ rpc.host+ ""String_Node_Str""+ rpc.usr+ ""String_Node_Str""+ rpc.pwd+ ""String_Node_Str""+ rpc.sharesGetwork+ ""String_Node_Str""+ rpc.sharesAccepted+ ""String_Node_Str""+ rpc.sharesRejected+ ""String_Node_Str""+ String.format(""String_Node_Str"",rpc.difficulty)+ ""String_Node_Str"");
      }
      sb.append(""String_Node_Str"");
    }
    if (backup > 0) {
      sb.append(""String_Node_Str"" + backup + ""String_Node_Str"");
      sb.append(""String_Node_Str"");
      for (int i=backup1; i < server; i++) {
        RPC rpc=BTCMiner.rpc[i];
        if (i > backup1) {
          sb.append(""String_Node_Str"");
        }
        sb.append(""String_Node_Str"" + i + ""String_Node_Str""+ rpc.name+ ""String_Node_Str""+ rpc.url+ ""String_Node_Str""+ rpc.host+ ""String_Node_Str""+ rpc.usr+ ""String_Node_Str""+ rpc.pwd+ ""String_Node_Str""+ rpc.sharesGetwork+ ""String_Node_Str""+ rpc.sharesAccepted+ ""String_Node_Str""+ rpc.sharesRejected+ ""String_Node_Str""+ String.format(""String_Node_Str"",rpc.difficulty)+ ""String_Node_Str"");
      }
      sb.append(""String_Node_Str"");
    }
    double hashrate_total=0.0;
    double hashrate_submitted=0.0;
    sb.append(""String_Node_Str"");
    for (int i=0; ; i++) {
      BTCMiner m=BTCMiner.cluster.getMiner(i);
      if (m == null) {
        break;
      }
      if (i > 0) {
        sb.append(""String_Node_Str"");
      }
      String state;
      if (!m.isRunning) {
        state=""String_Node_Str"";
      }
 else       if (m.fatalError != null) {
        state=m.fatalError;
      }
 else       if (m.suspended) {
        state=""String_Node_Str"";
      }
 else {
        state=""String_Node_Str"";
      }
      double fr=(m.freqM + 1) * m.freqM1;
      double er=m.errorRate[m.freqM];
      double hr=fr * (1 - er) * m.hashesPerClock;
      hashrate_total+=hr;
      double hs=m.submittedHashRate();
      hashrate_submitted+=hs;
      double lk=hs / hr + 0.0049;
      sb.append(""String_Node_Str"" + i + ""String_Node_Str""+ m.name+ ""String_Node_Str""+ state+ ""String_Node_Str""+ String.format(""String_Node_Str"",fr)+ ""String_Node_Str""+ String.format(""String_Node_Str"",hr)+ ""String_Node_Str""+ String.format(""String_Node_Str"",er * 100.0)+ ""String_Node_Str""+ String.format(""String_Node_Str"",m.maxErrorRate[m.freqM] * 100.0)+ ""String_Node_Str""+ m.submittedCount+ ""String_Node_Str""+ String.format(""String_Node_Str"",lk)+ ""String_Node_Str"");
    }
    sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"" + String.format(""String_Node_Str"",hashrate_total) + ""String_Node_Str"");
    sb.append(""String_Node_Str"" + String.format(""String_Node_Str"",hashrate_submitted) + ""String_Node_Str"");
  }
  sb.append(""String_Node_Str"");
  return sb.toString();
}","private String serveJson(String uri,Properties header){
  StringBuffer sb=new StringBuffer(""String_Node_Str"" + BTCMiner.clusterId + ""String_Node_Str"");
  Date now=new Date();
  sb.append(""String_Node_Str"" + now.toString() + ""String_Node_Str"");
  long uptime=(now.getTime() - BTCMiner.upTime) / 1000;
  sb.append(""String_Node_Str"" + uptime + ""String_Node_Str"");
  if (header.getProperty(""String_Node_Str"") != null) {
    sb.append(""String_Node_Str"" + header.getProperty(""String_Node_Str"") + ""String_Node_Str"");
  }
  if (BTCMiner.cluster == null) {
    sb.append(""String_Node_Str"");
  }
 else {
    sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"" + refreshTmo + ""String_Node_Str"");
    if (BTCMiner.longPollURL != null) {
      sb.append(""String_Node_Str"" + BTCMiner.longPollURL + ""String_Node_Str"");
    }
 else {
      sb.append(""String_Node_Str"");
    }
    int server=BTCMiner.rpcCount;
    int backup1=BTCMiner.rpcFirstBackup;
    int backup=0;
    if (backup1 > 0) {
      backup=server - backup1;
    }
    if (server > 0) {
      sb.append(""String_Node_Str"" + (server - backup) + ""String_Node_Str"");
      sb.append(""String_Node_Str"");
      for (int i=0; i < (server - backup); i++) {
        RPC rpc=BTCMiner.rpc[i];
        if (i > 0) {
          sb.append(""String_Node_Str"");
        }
        String state;
        if (rpc.state) {
          state=""String_Node_Str"";
        }
 else {
          state=""String_Node_Str"";
        }
        sb.append(""String_Node_Str"" + i + ""String_Node_Str""+ state+ ""String_Node_Str""+ rpc.name+ ""String_Node_Str""+ rpc.url+ ""String_Node_Str""+ rpc.host+ ""String_Node_Str""+ rpc.usr+ ""String_Node_Str""+ rpc.pwd+ ""String_Node_Str""+ rpc.sharesGetwork+ ""String_Node_Str""+ rpc.sharesAccepted+ ""String_Node_Str""+ rpc.sharesRejected+ ""String_Node_Str""+ String.format(""String_Node_Str"",rpc.difficulty)+ ""String_Node_Str"");
      }
      sb.append(""String_Node_Str"");
    }
    if (backup > 0) {
      sb.append(""String_Node_Str"" + backup + ""String_Node_Str"");
      sb.append(""String_Node_Str"");
      for (int i=backup1; i < server; i++) {
        RPC rpc=BTCMiner.rpc[i];
        if (i > backup1) {
          sb.append(""String_Node_Str"");
        }
        sb.append(""String_Node_Str"" + i + ""String_Node_Str""+ rpc.name+ ""String_Node_Str""+ rpc.url+ ""String_Node_Str""+ rpc.host+ ""String_Node_Str""+ rpc.usr+ ""String_Node_Str""+ rpc.pwd+ ""String_Node_Str""+ rpc.sharesGetwork+ ""String_Node_Str""+ rpc.sharesAccepted+ ""String_Node_Str""+ rpc.sharesRejected+ ""String_Node_Str""+ String.format(""String_Node_Str"",rpc.difficulty)+ ""String_Node_Str"");
      }
      sb.append(""String_Node_Str"");
    }
    double hashrate_total=0.0;
    double hashrate_submitted=0.0;
    sb.append(""String_Node_Str"");
    for (int i=0; ; i++) {
      BTCMiner m=BTCMiner.cluster.getMiner(i);
      if (m == null) {
        break;
      }
      if (i > 0) {
        sb.append(""String_Node_Str"");
      }
      String state;
      if (!m.isRunning) {
        state=""String_Node_Str"";
      }
 else       if (m.fatalError != null) {
        state=m.fatalError;
      }
 else       if (m.suspended) {
        state=""String_Node_Str"";
      }
 else {
        state=""String_Node_Str"";
      }
      double fr=(m.freqM + 1) * m.freqM1;
      double er=m.errorRate[m.freqM];
      double hr=fr * (1 - er) * m.hashesPerClock;
      hashrate_total+=hr;
      double hs=m.submittedHashRate();
      hashrate_submitted+=hs;
      double lk=hs / hr + 0.0049;
      sb.append(""String_Node_Str"" + i + ""String_Node_Str""+ m.name+ ""String_Node_Str""+ state+ ""String_Node_Str""+ String.format(""String_Node_Str"",fr)+ ""String_Node_Str""+ String.format(""String_Node_Str"",hr)+ ""String_Node_Str""+ String.format(""String_Node_Str"",er * 100.0)+ ""String_Node_Str""+ String.format(""String_Node_Str"",m.maxErrorRate[m.freqM] * 100.0)+ ""String_Node_Str""+ m.submittedCount+ ""String_Node_Str""+ String.format(""String_Node_Str"",lk)+ ""String_Node_Str"");
    }
    sb.append(""String_Node_Str"");
    sb.append(""String_Node_Str"" + String.format(""String_Node_Str"",hashrate_total) + ""String_Node_Str"");
    sb.append(""String_Node_Str"" + String.format(""String_Node_Str"",hashrate_submitted) + ""String_Node_Str"");
    if (remoteSwitching) {
      sb.append(""String_Node_Str"");
    }
 else {
      sb.append(""String_Node_Str"");
    }
    if (BTCMiner.getTargetCheck()) {
      sb.append(""String_Node_Str"");
    }
 else {
      sb.append(""String_Node_Str"");
    }
  }
  sb.append(""String_Node_Str"");
  return sb.toString();
}"
88877,"public void setCoupon(Coupon coupon){
  this.couponKeyString=coupon.getIdString();
}","public void setCoupon(Coupon coupon){
  if (coupon != null) {
    this.couponKeyString=coupon.getIdString();
  }
}"
88878,"private void addDefaultSticker(Order order){
  String imageUrl=getHostUrl() + ""String_Node_Str"";
  byte[] bytes=null;
  try {
    bytes=URLFetchServiceFactory.getURLFetchService().fetch(new URL(imageUrl)).getContent();
  }
 catch (  Exception e) {
    EmailSender.INSTANCE.sendToAdmin(e.getMessage(),""String_Node_Str"");
    e.printStackTrace();
  }
  if (bytes != null) {
    ByteArrayInputStream imageStream=new ByteArrayInputStream(bytes);
    order.addSticker(""String_Node_Str"",imageStream);
  }
 else {
    EmailSender.INSTANCE.sendToAdmin(""String_Node_Str"",""String_Node_Str"");
  }
}","private void addDefaultSticker(Order order){
  String imageUrl=ServerUtils.getAppspotHostUrl() + ""String_Node_Str"";
  byte[] bytes=null;
  try {
    bytes=URLFetchServiceFactory.getURLFetchService().fetch(new URL(imageUrl)).getContent();
  }
 catch (  Exception e) {
    EmailSender.INSTANCE.sendToAdmin(e.getMessage(),""String_Node_Str"");
    e.printStackTrace();
  }
  if (bytes != null) {
    ByteArrayInputStream imageStream=new ByteArrayInputStream(bytes);
    order.addSticker(""String_Node_Str"",imageStream);
  }
 else {
    EmailSender.INSTANCE.sendToAdmin(""String_Node_Str"",""String_Node_Str"");
  }
}"
88879,"private URL getUrlWithPath(String path){
  String hostUrl;
  String environment=System.getProperty(""String_Node_Str"");
  if (""String_Node_Str"".equals(environment)) {
    hostUrl=""String_Node_Str"";
  }
 else {
    hostUrl=""String_Node_Str"";
  }
  try {
    return new URL(hostUrl + path + getSecret()+ ""String_Node_Str""+ KeyFactory.keyToString(id));
  }
 catch (  MalformedURLException e) {
    throw new RuntimeException(e);
  }
}","private URL getUrlWithPath(String path){
  try {
    return new URL(ServerUtils.getCleanHostUrl() + path + getSecret()+ ""String_Node_Str""+ KeyFactory.keyToString(id));
  }
 catch (  MalformedURLException e) {
    throw new RuntimeException(e);
  }
}"
88880,"private URL getImageUrl(ImageSize size){
  String hostUrl;
  String environment=System.getProperty(""String_Node_Str"");
  if (""String_Node_Str"".equals(environment)) {
    String applicationId=System.getProperty(""String_Node_Str"");
    String version=System.getProperty(""String_Node_Str"");
    hostUrl=""String_Node_Str"" + version + ""String_Node_Str""+ applicationId+ ""String_Node_Str"";
  }
 else {
    hostUrl=""String_Node_Str"";
  }
  try {
    return new URL(hostUrl + ""String_Node_Str"" + (size == ImageSize.thumb ? ""String_Node_Str"" : ""String_Node_Str"")+ getSecret()+ ""String_Node_Str""+ KeyFactory.keyToString(id));
  }
 catch (  MalformedURLException e) {
    throw new RuntimeException(e);
  }
}","private URL getImageUrl(ImageSize size){
  String hostUrl=ServerUtils.getAppspotHostUrl();
  try {
    return new URL(hostUrl + ""String_Node_Str"" + (size == ImageSize.thumb ? ""String_Node_Str"" : ""String_Node_Str"")+ getSecret()+ ""String_Node_Str""+ KeyFactory.keyToString(id));
  }
 catch (  MalformedURLException e) {
    throw new RuntimeException(e);
  }
}"
88881,"@Override public IController getController(ICakePHPFile file){
switch (file.getCakePHPFileType()) {
case MODEL:
{
      return getController(file);
    }
case CONTROLLER:
{
    break;
  }
case VIEW:
{
  break;
}
case JSFILE:
{
break;
}
case ELEMENT:
{
break;
}
}
}","@Override public IController getController(ICakePHPFile file){
switch (file.getCakePHPFileType()) {
case MODEL:
{
      return getController(file);
    }
case CONTROLLER:
{
    break;
  }
case VIEW:
{
  break;
}
case JSFILE:
{
break;
}
case ELEMENT:
{
break;
}
}
return null;
}"
88882,"private HashMap<String,Object> parseToken(String jsonResponse){
  HashMap<String,Object> result=new HashMap<String,Object>();
  result=HttpConnection.parse(jsonResponse,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  if (result.get(""String_Node_Str"").equals(""String_Node_Str"")) {
    JSONArray friendsJson=(JSONArray)result.get(""String_Node_Str"");
    ArrayList<User> friends=new ArrayList<User>();
    for (int i=0; i < friendsJson.length(); i++) {
      JSONObject friend;
      try {
        friend=friendsJson.getJSONObject(i);
        String login=friend.getString(""String_Node_Str"");
        String firstName=friend.getString(""String_Node_Str"");
        String lastName=friend.getString(""String_Node_Str"");
        User u=new User(firstName,lastName,login);
        friends.add(u);
      }
 catch (      JSONException e) {
        e.printStackTrace();
      }
    }
    result.put(""String_Node_Str"",friends);
  }
  Log.i(""String_Node_Str"",result.toString());
  return result;
}","private HashMap<String,Object> parseToken(String jsonResponse){
  HashMap<String,Object> result=new HashMap<String,Object>();
  result=HttpConnection.parse(jsonResponse,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  if (result.get(""String_Node_Str"").equals(""String_Node_Str"")) {
    Log.i(""String_Node_Str"",result.toString());
    JSONArray friendsJson=(JSONArray)result.get(""String_Node_Str"");
    ArrayList<User> friends=new ArrayList<User>();
    for (int i=0; i < friendsJson.length(); i++) {
      JSONObject friend;
      try {
        friend=friendsJson.getJSONObject(i);
        String login=friend.getString(""String_Node_Str"");
        String firstName=friend.getString(""String_Node_Str"");
        String lastName=friend.getString(""String_Node_Str"");
        User u=new User(firstName,lastName,login);
        friends.add(u);
      }
 catch (      JSONException e) {
        e.printStackTrace();
      }
    }
    result.put(""String_Node_Str"",friends);
  }
  return result;
}"
88883,"private HashMap<String,Object> parseResponse(String responseBody){
  HashMap<String,Object> results=new HashMap<String,Object>();
  results=HttpConnection.parse(responseBody,""String_Node_Str"",""String_Node_Str"");
  ArrayList<User> users=null;
  if (results.get(""String_Node_Str"").equals(""String_Node_Str"")) {
    JSONArray usersJson=(JSONArray)results.get(""String_Node_Str"");
    users=new ArrayList<User>();
    for (int i=0; i < usersJson.length(); i++) {
      JSONObject friend;
      try {
        friend=usersJson.getJSONObject(i);
        String login=friend.getString(""String_Node_Str"");
        String firstName=friend.getString(""String_Node_Str"");
        String lastName=friend.getString(""String_Node_Str"");
        User u=new User(firstName,lastName,login);
        users.add(u);
      }
 catch (      JSONException e) {
        e.printStackTrace();
      }
    }
    results.put(""String_Node_Str"",users);
  }
  Log.i(""String_Node_Str"",responseBody.toString());
  return results;
}","private HashMap<String,Object> parseResponse(String responseBody){
  HashMap<String,Object> results=new HashMap<String,Object>();
  results=HttpConnection.parse(responseBody,""String_Node_Str"",""String_Node_Str"");
  ArrayList<User> users=null;
  if (results.get(""String_Node_Str"").equals(""String_Node_Str"")) {
    Log.i(""String_Node_Str"",responseBody.toString());
    JSONArray usersJson=(JSONArray)results.get(""String_Node_Str"");
    users=new ArrayList<User>();
    for (int i=0; i < usersJson.length(); i++) {
      JSONObject friend;
      try {
        friend=usersJson.getJSONObject(i);
        String login=friend.getString(""String_Node_Str"");
        String firstName=friend.getString(""String_Node_Str"");
        String lastName=friend.getString(""String_Node_Str"");
        User u=new User(firstName,lastName,login);
        users.add(u);
      }
 catch (      JSONException e) {
        e.printStackTrace();
      }
    }
    results.put(""String_Node_Str"",users);
  }
  return results;
}"
88884,"@Override protected String doInBackground(String... arg0){
  String auth_token=arg0[0];
  String receiver_login=arg0[1];
  String content=arg0[2];
  Integer priority=Integer.parseInt(arg0[3]);
  HashMap<String,Object> params=new HashMap<String,Object>();
  params.put(""String_Node_Str"",auth_token);
  params.put(""String_Node_Str"",receiver_login);
  params.put(""String_Node_Str"",content);
  params.put(""String_Node_Str"",priority);
  String response=HttpConnection.makeRequest(URL,params);
  HashMap<String,Object> results=HttpConnection.parse(response,""String_Node_Str"",""String_Node_Str"");
  Log.i(""String_Node_Str"",response.toString());
  return (String)results.get(""String_Node_Str"");
}","@Override protected String doInBackground(String... arg0){
  String auth_token=arg0[0];
  String receiver_login=arg0[1];
  String content=arg0[2];
  Integer priority=Integer.parseInt(arg0[3]);
  HashMap<String,Object> params=new HashMap<String,Object>();
  params.put(""String_Node_Str"",auth_token);
  params.put(""String_Node_Str"",receiver_login);
  params.put(""String_Node_Str"",content);
  params.put(""String_Node_Str"",priority);
  String response=HttpConnection.makeRequest(URL,params);
  HashMap<String,Object> results=HttpConnection.parse(response,""String_Node_Str"",""String_Node_Str"");
  return (String)results.get(""String_Node_Str"");
}"
88885,"public static HashMap<String,Object> parse(String json,String basic,String... keys){
  Log.i(""String_Node_Str"",json);
  HashMap<String,Object> results=new HashMap<String,Object>();
  if (json != null) {
    try {
      JSONObject main=new JSONObject(json).getJSONObject(basic);
      String error=main.getString(""String_Node_Str"");
      results.put(""String_Node_Str"",error);
      if (error.equals(""String_Node_Str"")) {
        for (int i=0; i < keys.length; i++) {
          if (main.has(keys[i]))           results.put(keys[i],main.get(keys[i]));
        }
      }
    }
 catch (    JSONException e) {
      Log.e(TAG,""String_Node_Str"");
      e.printStackTrace();
    }
  }
 else {
    results.put(""String_Node_Str"",""String_Node_Str"");
    Log.e(TAG,""String_Node_Str"");
  }
  return results;
}","public static HashMap<String,Object> parse(String json,String basic,String... keys){
  HashMap<String,Object> results=new HashMap<String,Object>();
  if (json != null && !json.equals(""String_Node_Str"")) {
    Log.i(""String_Node_Str"",json);
    try {
      JSONObject main=new JSONObject(json).getJSONObject(basic);
      String error=main.getString(""String_Node_Str"");
      results.put(""String_Node_Str"",error);
      if (error.equals(""String_Node_Str"")) {
        for (int i=0; i < keys.length; i++) {
          if (main.has(keys[i]))           results.put(keys[i],main.get(keys[i]));
        }
      }
    }
 catch (    JSONException e) {
      Log.e(TAG,""String_Node_Str"");
      e.printStackTrace();
    }
  }
 else {
    results.put(""String_Node_Str"",""String_Node_Str"");
    Log.e(TAG,""String_Node_Str"");
  }
  return results;
}"
88886,"public void Update(boolean refresh){
  if (_isVisible) {
    _textHandler.Update();
    _textHandler.Clear();
    if (refresh) {
      StringSquisher.Clear();
      StringSquisher.Squish(title);
      HashMap<Integer,GenericItem> items=_equipment.GetItems();
      for (      Integer item : items.keySet()) {
        StringSquisher.Squish(ItemSlot.Names[item].substring(0,1),sep,items.get(item).Name,newline);
      }
      display=StringSquisher.Flush();
    }
    _textHandler.WriteDefault(display,320,30,GetHudOrigin());
  }
}","public void Update(boolean refresh){
  if (_isVisible) {
    _textHandler.Update();
    _textHandler.Clear();
    if (refresh) {
      StringSquisher.Clear();
      StringSquisher.Squish(title);
      HashMap<Integer,GenericItem> items=_equipment.GetItems();
      for (      Integer item : items.keySet()) {
        StringSquisher.Squish(ItemSlot.Names[item].substring(0,1),sep,items.get(item).Name,newline);
      }
      display=StringSquisher.Flush();
    }
    _textHandler.WriteDefault(display,20,60,GetHudOrigin());
  }
}"
88887,"protected IHud(ICreature owner,int width,int height){
  _parent=owner;
  if (_menuBase == null) {
    _menuBase=XnaManager.GetMenuBaseAsset();
  }
  _dimensions=new Point2(width,height);
  playerHudPositions.add(new Point2(GameManager.SpriteWidth / 2,XnaManager.WindowHeight - _dimensions.Y / 2));
  playerHudPositions.add(new Point2(XnaManager.WindowWidth - _dimensions.X / 2,XnaManager.WindowHeight + _dimensions.Y / 2));
  playerHudPositions.add(new Point2(0,0));
  playerHudPositions.add(new Point2(XnaManager.WindowWidth - _dimensions.X / 2,0));
}","protected IHud(ICreature owner,int width,int height){
  _parent=owner;
  if (_menuBase == null) {
    _menuBase=XnaManager.GetMenuBaseAsset();
  }
  _dimensions=new Point2(width,height);
  playerHudPositions.add(new Point2(0,XnaManager.WindowHeight - _dimensions.Y));
  playerHudPositions.add(new Point2(XnaManager.WindowWidth - _dimensions.X,XnaManager.WindowHeight + _dimensions.Y));
  playerHudPositions.add(new Point2(0,0));
  playerHudPositions.add(new Point2(XnaManager.WindowWidth - _dimensions.X,0));
}"
88888,"public void Draw(){
  if (_isVisible) {
    XnaManager.Renderer.Draw(_menuBase,GetHudOrigin(),Depth.HudBG,Color.WHITE,(int)XnaManager.GetCenter().X,(int)XnaManager.GetCenter().Y);
    _textHandler.Draw();
    _deltas.Draw();
    _equipHud.Draw();
  }
}","public void Draw(){
  if (_isVisible) {
    XnaManager.Renderer.Draw(_menuBase,GetHudOrigin(),Depth.HudBG,Color.BLACK,(int)XnaManager.GetCenter().X,(int)XnaManager.GetCenter().Y);
    _textHandler.Draw();
    _deltas.Draw();
    _equipHud.Draw();
  }
}"
88889,"public void Draw(){
  if (!_isVisible) {
    return;
  }
  XnaManager.Renderer.Draw(_menuBase,GetHudOrigin(),Depth.HudBG,Color.GREEN,GameManager.SpriteWidth,CalculateHeight(StatType.HEALTH));
  XnaManager.Renderer.Draw(_menuBase,_manaPosition,Depth.HudBG,Color.BLUE,GameManager.SpriteWidth,CalculateHeight(StatType.MANA));
  XnaManager.Renderer.Draw(_menuBase,_costPosition,Depth.HudBG,Color.YELLOW,GameManager.SpriteWidth / 2,CostOfCurrentSkill());
  _textHandler.Draw();
}","public void Draw(){
  if (!_isVisible) {
    return;
  }
  XnaManager.Renderer.Draw(_menuBase,GetHudOrigin(),Depth.HudBG,Color.GREEN,GameManager.SpriteWidth,CalculateHeight(StatType.HEALTH));
  XnaManager.Renderer.Draw(_menuBase,_manaPosition,Depth.HudBG,Color.BLUE,GameManager.SpriteWidth,CalculateHeight(StatType.MANA));
  XnaManager.Renderer.Draw(_menuBase,_manaPosition,Depth.HudBG,Color.YELLOW,GameManager.SpriteWidth / 2,CostOfCurrentSkill());
  _textHandler.Draw();
}"
88890,"public SkillHud(ICreature owner){
  super(owner,GameManager.SpriteWidth,XnaManager.WindowHeight / 4);
  _manaPosition=new Point2(GetHudOrigin().X,GetHudOrigin().Y - XnaManager.WindowHeight / 4);
  _costPosition=new Point2(GetHudOrigin().X - GameManager.SpriteWidth / 4,GetHudOrigin().Y - XnaManager.WindowHeight / 4 + _dimensions.Y / 2 - GameManager.SpriteHeight / 4);
}","public SkillHud(ICreature owner){
  super(owner,GameManager.SpriteWidth,XnaManager.WindowHeight / 4);
  _manaPosition=new Point2(GetHudOrigin().X,GetHudOrigin().Y - XnaManager.WindowHeight / 4);
}"
88891,"public void Update(){
  if (_isVisible) {
    _textHandler.Update();
    _textHandler.Clear();
    _textHandler.WriteDefault(GetSkillStrings(),GameManager.SpriteWidth,0,GetHudOrigin());
  }
}","public void Update(){
  if (_isVisible) {
    _textHandler.Update();
    _textHandler.Clear();
    _textHandler.WriteDefault(GetSkillStrings(),(int)GetHudOrigin().X + GameManager.SpriteWidth,GameManager.SpriteHeight,null);
  }
}"
88892,"public void Draw(){
  if (!_isVisible) {
    return;
  }
  XnaManager.Renderer.Draw(_menuBase.getScaledCopy((int)CalculateHeight(StatType.HEALTH).PosX,(int)CalculateHeight(StatType.HEALTH).PosY),GetHudOrigin(),Depth.HudBG,Color.green);
  XnaManager.Renderer.Draw(_menuBase.getScaledCopy((int)CostOfCurrentSkill().PosX,(int)CostOfCurrentSkill().PosY),_manaPosition,Depth.HudBG,Color.yellow);
  XnaManager.Renderer.Draw(_menuBase.getScaledCopy((int)CalculateHeight(StatType.MANA).PosX,(int)CalculateHeight(StatType.MANA).PosY),_manaPosition,Depth.HudBG,Color.blue);
  _textHandler.Draw();
}","public void Draw(){
  if (!_isVisible) {
    return;
  }
  XnaManager.Renderer.Draw(_menuBase.getScaledCopy((int)_dimensions.X,CalculateHeight(StatType.HEALTH)),GetHudOrigin(),Depth.HudBG,Color.green);
  XnaManager.Renderer.Draw(_menuBase.getScaledCopy((int)_dimensions.X,CalculateHeight(StatType.MANA)),_manaPosition,Depth.HudBG,Color.blue);
  XnaManager.Renderer.Draw(_menuBase.getScaledCopy((int)(_dimensions.X * .5f),CostOfCurrentSkill()),_manaPosition,Depth.HudBG,Color.yellow);
  _textHandler.Draw();
}"
88893,"private Point2 CostOfCurrentSkill(){
  return new Point2(_dimensions.X * .5f,_parent.GetCurrentSkillCost() / _parent.GetMax(StatType.MANA) * _dimensions.Y);
}","private int CostOfCurrentSkill(){
  return (int)(_parent.GetCurrentSkillCost() / _parent.GetMax(StatType.MANA) * _dimensions.Y);
}"
88894,"private Point2 CalculateHeight(String statType){
  return new Point2(_dimensions.X,(_parent.Get(statType) / _parent.GetMax(statType)) * _dimensions.Y);
}","private int CalculateHeight(String statType){
  return (int)((_parent.Get(statType) / _parent.GetMax(statType)) * _dimensions.Y);
}"
88895,"private static AbstractCreature GenerateCreature(int actorType){
switch (actorType) {
case AigilasActorType.PEON:
    return new Peon();
case AigilasActorType.ZORB:
  return new Zorb();
case AigilasActorType.WRATH:
return new Wrath();
case AigilasActorType.HAND:
return new Hand();
case AigilasActorType.PRIDE:
return new Pride();
case AigilasActorType.ENVY:
return new Envy();
case AigilasActorType.GLUTTONY:
return new Gluttony();
case AigilasActorType.LUST:
return new Lust();
case AigilasActorType.SLOTH:
return new Sloth();
case AigilasActorType.GREED:
return new Greed();
case AigilasActorType.SERPENT:
return new Serpent();
case AigilasActorType.BREAKING_WHEEL:
return new BreakingWheel();
default :
try {
throw new Exception(""String_Node_Str"" + actorType);
}
 catch (Exception e) {
e.printStackTrace();
}
}
}","private static AbstractCreature GenerateCreature(int actorType){
switch (actorType) {
case AigilasActorType.PEON:
    return new Peon();
case AigilasActorType.ZORB:
  return new Zorb();
case AigilasActorType.WRATH:
return new Wrath();
case AigilasActorType.HAND:
return new Hand();
case AigilasActorType.PRIDE:
return new Pride();
case AigilasActorType.ENVY:
return new Envy();
case AigilasActorType.GLUTTONY:
return new Gluttony();
case AigilasActorType.LUST:
return new Lust();
case AigilasActorType.SLOTH:
return new Sloth();
case AigilasActorType.GREED:
return new Greed();
case AigilasActorType.SERPENT:
return new Serpent();
case AigilasActorType.BREAKING_WHEEL:
return new BreakingWheel();
default :
try {
throw new Exception(""String_Node_Str"" + actorType);
}
 catch (Exception e) {
e.printStackTrace();
}
return null;
}
}"
88896,"public void React(String skillId){
}","public void React(String skillId){
  if (_actorType == AigilasActorType.PLAYER && skillId != SkillId.FORGET_SKILL && _god.NameText == GodId.Names[GodId.GLUTTONY]) {
    if (_skills.Count() < _currentLevel) {
      _skills.Add(skillId);
    }
  }
}"
88897,"public ComboMarker(ICreature source,int elementId,int index){
}","public ComboMarker(ICreature source,int elementId,int index){
  Initialize(source.GetLocation(),SpriteType.COMBO_MARKER,com.aigilas.EntityType.COMBO_MARKER,com.aigilas.Depth.ComboMarker);
  _graphic.SetColor(Elements.Colors[elementId]);
  _graphic.SetAlpha(0);
  ParticleEngine.Emit(com.spx.particles.behaviors.RotateBehavior.GetInstance(),this,_graphic.GetColor());
  _parent=source;
  _index=index;
}"
88898,"private List<Class> resolveParameters(boolean required,Method method,List<Class> types){
  Type[] parameters=method.getGenericParameterTypes();
  for (  Type parameter : parameters) {
    CastUtil.ParamType resolvedType=CastUtil.resolveParamType(parameter);
    Class type=resolvedType.getType();
    if (!resolvedType.isOptional() && required) {
      types.add(type);
    }
 else     if (resolvedType.isOptional() && !required) {
      types.add(type);
    }
  }
  return types;
}","private void resolveParameters(boolean required,Method method,List<Class> types){
  Type[] parameters=method.getGenericParameterTypes();
  for (  Type parameter : parameters) {
    CastUtil.ParamType resolvedType=CastUtil.resolveParamType(parameter);
    Class type=resolvedType.getType();
    if (!resolvedType.isOptional() && required) {
      types.add(type);
    }
 else     if (resolvedType.isOptional() && !required) {
      types.add(type);
    }
  }
}"
88899,"@Override public void write(Collection<? extends Annotation> annotations){
  try {
    Map<Class,Annotation> bag=constructAnnotationBag(annotations);
    callWriteMethod(bag,this.writeMethod);
  }
 catch (  InvocationTargetException e) {
    e.printStackTrace();
  }
catch (  IllegalAccessException e) {
    e.printStackTrace();
  }
}","@Override public void write(Collection<? extends Annotation> annotations){
  try {
    Map<Class,Annotation> bag=constructAnnotationBag(annotations);
    callWriteMethod(bag,this.writeMethod);
  }
 catch (  InvocationTargetException e) {
    throw new RuntimeException(e);
  }
catch (  IllegalAccessException e) {
    throw new RuntimeException(e);
  }
}"
88900,"@Override public void setValidator(ValidatorWriter<? super C,? super W>... validatorWriters){
  for (  ValidatorWriter<? super C,? super W> validatorWriter : validatorWriters) {
    writers.add(validatorWriter);
  }
}","@Override public void setValidator(ValidatorWriter<? super C,? super W>... validatorWriters){
  Collections.addAll(writers,validatorWriters);
}"
88901,"@Override public void processModel(final Model model,ItemStatus status){
  LOG.trace(""String_Node_Str"",model.toString());
  String modelName=model.getName();
  if (getContext().getOutputMode() == OutputMode.JAVASCRIPT) {
    getWriter().write(modelName).writeKey(""String_Node_Str"").startFunctionCallBlock(BACKBONE_MODEL_EXTEND);
  }
 else {
    getWriter().writeKey(modelName).startBlock();
  }
  ItemProcessor.process(getModelProcessors()).with(new ItemHandler<ModelProcessor<JavaScriptContext,JavaScriptWriter>>(){
    @Override public void process(    ModelProcessor<JavaScriptContext,JavaScriptWriter> item,    ItemStatus status){
      writeSection(item.getName(),model,item,status);
    }
  }
);
  getWriter().indentBack();
  if (getContext().getOutputMode() == OutputMode.JAVASCRIPT) {
    getWriter().endFunctionCallBlock(status);
  }
 else {
    getWriter().endBlock(status);
  }
}","@Override public void processModel(final Model model,ItemStatus status){
  LOG.trace(""String_Node_Str"",model.toString());
  String modelName=model.getName();
  if (getContext().getOutputMode() == OutputMode.JAVASCRIPT) {
    getWriter().write(modelName).writeKey(""String_Node_Str"").startFunctionCallBlock(BACKBONE_MODEL_EXTEND);
  }
 else {
    getWriter().writeKey(modelName).startBlock();
  }
  ItemProcessor.process(getModelProcessors()).with(new ItemHandler<ModelProcessor<JavaScriptContext,JavaScriptWriter>>(){
    @Override public void process(    ModelProcessor<JavaScriptContext,JavaScriptWriter> item,    ItemStatus status){
      writeSection(item.getName(),model,item,status);
    }
  }
);
  if (getContext().getOutputMode() == OutputMode.JAVASCRIPT) {
    getWriter().endFunctionCallBlock(status);
  }
 else {
    getWriter().endBlock(status);
  }
}"
88902,"@Override @SuppressWarnings(""String_Node_Str"") public void endProcessing(ItemStatus status) throws IOException {
  getWriter().indentBack();
  if (getContext().getOutputMode() == OutputMode.JAVASCRIPT) {
    getWriter().endBlockStatement();
  }
 else {
    getWriter().endBlock(ItemStatuses.last());
  }
  LOG.trace(""String_Node_Str"");
}","@Override @SuppressWarnings(""String_Node_Str"") public void endProcessing(ItemStatus status) throws IOException {
  if (getContext().getOutputMode() == OutputMode.JAVASCRIPT) {
    getWriter().endBlockStatement();
  }
 else {
    getWriter().endBlock(ItemStatuses.last());
  }
  LOG.trace(""String_Node_Str"");
}"
88903,"@Override public void startProcessing(ItemStatus status) throws IOException {
  LOG.trace(""String_Node_Str"");
  if (getContext().getOutputMode() == OutputMode.JAVASCRIPT) {
    getWriter().writeComment(startComment);
    getWriter().writeVariable(namespaceName,""String_Node_Str"",JavaScriptWriter.VariableType.BLOCK);
  }
 else {
    getWriter().startBlock();
  }
  getWriter().indent();
}","@Override public void startProcessing(ItemStatus status) throws IOException {
  LOG.trace(""String_Node_Str"");
  if (getContext().getOutputMode() == OutputMode.JAVASCRIPT) {
    getWriter().writeComment(startComment);
    getWriter().writeVariable(namespaceName,""String_Node_Str"",JavaScriptWriter.VariableType.BLOCK);
    getWriter().indent();
  }
 else {
    getWriter().startBlock();
  }
}"
88904,"@Test public void testProcessFirstModel() throws Exception {
  ModelProcessor processor=createProcessor();
  Model model=mockModel();
  processor.doProcessModel(model,ItemStatuses.first());
  assertThat(writer.toString(),is(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""));
}","@Test public void testProcessFirstModel() throws Exception {
  ModelProcessor processor=createProcessor();
  Model model=mockModel();
  processor.doProcessModel(model,ItemStatuses.first());
  assertThat(writer.toString(),is(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""));
}"
88905,"@Test public void testProcessLastModel() throws Exception {
  ModelProcessor processor=createProcessor();
  Model model=mockModel();
  processor.doProcessModel(model,ItemStatuses.last());
  assertThat(writer.toString(),is(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""));
}","@Test public void testProcessLastModel() throws Exception {
  ModelProcessor processor=createProcessor();
  Model model=mockModel();
  processor.doProcessModel(model,ItemStatuses.last());
  assertThat(writer.toString(),is(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""));
}"
88906,"@Test public void testProcessMiddleModel() throws Exception {
  ModelProcessor processor=createProcessor();
  Model model=mockModel();
  processor.doProcessModel(model,ItemStatuses.notFirstNorLast());
  assertThat(writer.toString(),is(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""));
}","@Test public void testProcessMiddleModel() throws Exception {
  ModelProcessor processor=createProcessor();
  Model model=mockModel();
  processor.doProcessModel(model,ItemStatuses.notFirstNorLast());
  assertThat(writer.toString(),is(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""));
}"
88907,"@Test public void testProcessFirstModel() throws Exception {
  ModelProcessor processor=createProcessor();
  Model model=mockModel();
  processor.doProcessModel(model,ItemStatuses.first());
  assertThat(writer.toString(),is(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""));
}","@Test public void testProcessFirstModel() throws Exception {
  ModelProcessor processor=createProcessor();
  Model model=mockModel();
  processor.doProcessModel(model,ItemStatuses.first());
  assertThat(writer.toString(),is(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""));
}"
88908,"@Test public void testProcessLastModel() throws Exception {
  ModelProcessor processor=createProcessor();
  Model model=mockModel();
  processor.doProcessModel(model,ItemStatuses.last());
  assertThat(writer.toString(),is(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""));
}","@Test public void testProcessLastModel() throws Exception {
  ModelProcessor processor=createProcessor();
  Model model=mockModel();
  processor.doProcessModel(model,ItemStatuses.last());
  assertThat(writer.toString(),is(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""));
}"
88909,"@Test public void testProcessMiddleModel() throws Exception {
  ModelProcessor processor=createProcessor();
  Model model=mockModel();
  processor.doProcessModel(model,ItemStatuses.notFirstNorLast());
  assertThat(writer.toString(),is(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""));
}","@Test public void testProcessMiddleModel() throws Exception {
  ModelProcessor processor=createProcessor();
  Model model=mockModel();
  processor.doProcessModel(model,ItemStatuses.notFirstNorLast());
  assertThat(writer.toString(),is(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""));
}"
88910,"@Before public void init(){
  writer=new StringBufferWriter();
  jsWriter=new JavaScriptWriter(writer);
  context=new JavaScriptContext(jsWriter,getMode());
  MockitoAnnotations.initMocks(this);
  when(validatorProcessor.getName()).thenReturn(""String_Node_Str"");
  when(valueProcessor.getName()).thenReturn(""String_Node_Str"");
  Answer<Object> writeEmptyBlock=new Answer<Object>(){
    @Override public Object answer(    InvocationOnMock invocation) throws Throwable {
      ItemStatus status=(ItemStatus)invocation.getArguments()[1];
      if (status.isNotLastItem()) {
        writer.write(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
      }
 else {
        writer.write(""String_Node_Str"" + ""String_Node_Str"");
      }
      return null;
    }
  }
;
  doAnswer(writeEmptyBlock).when(validatorProcessor).doProcessModel(any(Model.class),any(ItemStatus.class));
  doAnswer(writeEmptyBlock).when(valueProcessor).doProcessModel(any(Model.class),any(ItemStatus.class));
}","@Before public void init(){
  writer=new StringBufferWriter();
  jsWriter=new JavaScriptWriter(writer);
  context=new JavaScriptContext(jsWriter,getMode());
  MockitoAnnotations.initMocks(this);
  when(validatorProcessor.getName()).thenReturn(""String_Node_Str"");
  when(valueProcessor.getName()).thenReturn(""String_Node_Str"");
  Answer<Object> writeEmptyBlock=new Answer<Object>(){
    @Override public Object answer(    InvocationOnMock invocation) throws Throwable {
      ItemStatus status=(ItemStatus)invocation.getArguments()[1];
      if (status.isNotLastItem()) {
        writer.write(""String_Node_Str"");
      }
 else {
        writer.write(""String_Node_Str"");
      }
      return null;
    }
  }
;
  doAnswer(writeEmptyBlock).when(validatorProcessor).doProcessModel(any(Model.class),any(ItemStatus.class));
  doAnswer(writeEmptyBlock).when(valueProcessor).doProcessModel(any(Model.class),any(ItemStatus.class));
}"
88911,"@Override public Object answer(InvocationOnMock invocation) throws Throwable {
  ItemStatus status=(ItemStatus)invocation.getArguments()[1];
  if (status.isNotLastItem()) {
    writer.write(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
 else {
    writer.write(""String_Node_Str"" + ""String_Node_Str"");
  }
  return null;
}","@Override public Object answer(InvocationOnMock invocation) throws Throwable {
  ItemStatus status=(ItemStatus)invocation.getArguments()[1];
  if (status.isNotLastItem()) {
    writer.write(""String_Node_Str"");
  }
 else {
    writer.write(""String_Node_Str"");
  }
  return null;
}"
88912,"private void generateModelAndAddToCache(String internalModelName){
  Model model=modelsByName.get(internalModelName);
  modelGenerator.process(model);
  String modelData=getLanguageContext().getWriter().toString();
  generatedModelsByName.put(internalModelName,modelData);
  getLanguageContext().getWriter().clear();
}","private synchronized void generateModelAndAddToCache(String internalModelName){
  Model model=modelsByName.get(internalModelName);
  modelGenerator.process(model);
  String modelData=getLanguageContext().getWriter().toString();
  generatedModelsByName.put(internalModelName,modelData);
  getLanguageContext().getWriter().clear();
}"
88913,"@Override public void setLanguageContext(LanguageContext<W> context){
  this.context=context;
  modelProcessor.setLanguageContext(context);
}","@Override public void setLanguageContext(LanguageContext<W> context){
  modelProcessor.setLanguageContext(context);
}"
88914,"public static final DummyDataWriter getInstance(){
  return DUMMY_DATA_WRITER;
}","public static DummyDataWriter getInstance(){
  return DUMMY_DATA_WRITER;
}"
88915,"/** 
 * Constructs a combined validator factory. It requires at least one  {@link ValidatorFactory}.
 * @param validatorFactory Required validator factory
 * @param additionalFactories Additional validator factories
 */
public CombinedValidatorFactory(ValidatorFactory validatorFactory,ValidatorFactory... additionalFactories){
  validatorFactories.add(validatorFactory);
  for (  ValidatorFactory additionalFactory : additionalFactories) {
    validatorFactories.add(additionalFactory);
  }
}","/** 
 * Constructs a combined validator factory. It requires at least one  {@link ValidatorFactory}.
 * @param validatorFactory Required validator factory
 * @param additionalFactories Additional validator factories
 */
public CombinedValidatorFactory(ValidatorFactory validatorFactory,ValidatorFactory... additionalFactories){
  validatorFactories.add(validatorFactory);
  Collections.addAll(validatorFactories,additionalFactories);
}"
88916,"private List<Class> breakDownGenericGroupsToLeaves(Collection<Class> requiredGroups){
  final List<Class> groupTreeLeaves=new ArrayList<Class>();
  for (  Class group : requiredGroups) {
    addLeavesToList((Class)group,(List)groupTreeLeaves);
  }
  return groupTreeLeaves;
}","private List<Class> breakDownGenericGroupsToLeaves(Collection<Class> requiredGroups){
  final List<Class> groupTreeLeaves=new ArrayList<Class>();
  for (  Class group : requiredGroups) {
    addLeavesToList(group,(List)groupTreeLeaves);
  }
  return groupTreeLeaves;
}"
88917,"private List<Class> breakDownClassesGroupTreeLeaves(Class[] groupsGiven){
  final List<Class> groupsToCheck=new ArrayList<Class>();
  if (groupsGiven.length > 0) {
    for (    Class groupGiven : groupsGiven) {
      addLeavesToList((Class)groupGiven,groupsToCheck);
    }
  }
  return groupsToCheck;
}","private List<Class> breakDownClassesGroupTreeLeaves(Class[] groupsGiven){
  final List<Class> groupsToCheck=new ArrayList<Class>();
  if (groupsGiven.length > 0) {
    for (    Class groupGiven : groupsGiven) {
      addLeavesToList(groupGiven,groupsToCheck);
    }
  }
  return groupsToCheck;
}"
88918,"/** 
 * Update the processing
 * @param itemIndex 0 based index.
 */
final private void updateInternal(int itemIndex){
  firstItem=itemIndex == 0;
  lastItem=itemIndex == (numberOfItems - 1);
}","/** 
 * Update the processing
 * @param itemIndex 0 based index.
 */
private void updateInternal(int itemIndex){
  firstItem=itemIndex == 0;
  lastItem=itemIndex == (numberOfItems - 1);
}"
88919,"protected void flush(){
  try {
    this.writer.flush();
  }
 catch (  IOException e) {
  }
}","protected void flush(){
  try {
    this.writer.flush();
  }
 catch (  IOException e) {
    LOG.error(""String_Node_Str"",e);
  }
}"
88920,"/** 
 * Manager requires an implemented DataWriter, TestWriter. TestValidatorWriter also uses this same TestWriter
 */
@Test public void testWithImplementedDataWriter(){
class TestWriter extends StreamDataWriter {
  }
class TestValidator extends BaseValidator {
    @Override public void init(    AnnotationBag annotationBag){
    }
  }
class TestValidatorWriter extends BaseValidatorWriter<TestValidator,LanguageContext<TestWriter>,TestWriter> {
    @Override protected void write(    LanguageContext<TestWriter> languageContext,    TestValidator validator,    ItemStatus status){
    }
  }
  ValidatorWriterSet manager=new ValidatorWriterSet(Arrays.asList(new TestValidatorWriter()));
}","/** 
 * Manager requires an implemented DataWriter, TestWriter. TestValidatorWriter also uses this same TestWriter
 */
@Test public void testWithImplementedDataWriter(){
class TestWriter extends StreamDataWriter {
  }
class TestValidator extends BaseValidator {
    @Override public void init(    AnnotationBag annotationBag){
    }
  }
class TestValidatorWriter extends BaseValidatorWriter<TestValidator,LanguageContext<TestWriter>,TestWriter> {
    @Override protected void write(    LanguageContext<TestWriter> languageContext,    TestValidator validator,    ItemStatus status){
    }
  }
  new ValidatorWriterSet(Arrays.asList(new TestValidatorWriter()));
}"
88921,"/** 
 * Every class uses plain DataWriter interface
 */
@Test public void testWithPlainDataWriterInterface(){
class TestValidator extends BaseValidator {
    @Override public void init(    AnnotationBag annotationBag){
    }
  }
class TestValidatorWriter extends BaseValidatorWriter<TestValidator,LanguageContext<DataWriter>,DataWriter> {
    @Override protected void write(    LanguageContext<DataWriter> languageContext,    TestValidator validator,    ItemStatus status){
    }
  }
  ValidatorWriterSet manager=new ValidatorWriterSet(Arrays.asList(new TestValidatorWriter()));
}","/** 
 * Every class uses plain DataWriter interface
 */
@Test public void testWithPlainDataWriterInterface(){
class TestValidator extends BaseValidator {
    @Override public void init(    AnnotationBag annotationBag){
    }
  }
class TestValidatorWriter extends BaseValidatorWriter<TestValidator,LanguageContext<DataWriter>,DataWriter> {
    @Override protected void write(    LanguageContext<DataWriter> languageContext,    TestValidator validator,    ItemStatus status){
    }
  }
  new ValidatorWriterSet(Arrays.asList(new TestValidatorWriter()));
}"
88922,"@Test public void testConstructModelNoFields() throws Exception {
class TestModelClass {
  }
  ;
  Collection<ModelField> modelFields=Collections.emptyList();
  Model model=new Model(TestModelClass.class,""String_Node_Str"",modelFields);
  assertEquals(""String_Node_Str"",model.getName());
  assertEquals(TestModelClass.class,model.getModelClass());
  assertTrue(model.getFields().isEmpty());
  assertFalse(model.hasValidations());
}","@Test public void testConstructModelNoFields() throws Exception {
class TestModelClass {
  }
  Collection<ModelField> modelFields=Collections.emptyList();
  Model model=new Model(TestModelClass.class,""String_Node_Str"",modelFields);
  assertEquals(""String_Node_Str"",model.getName());
  assertEquals(TestModelClass.class,model.getModelClass());
  assertTrue(model.getFields().isEmpty());
  assertFalse(model.hasValidations());
}"
88923,"@Test public void testConstructModelValidations() throws Exception {
class TestModelClass {
  }
  ;
  ModelField fieldWithoutValidation=mock(ModelField.class);
  when(fieldWithoutValidation.hasValidators()).thenReturn(false);
  ModelField fieldWithValidation=mock(ModelField.class);
  when(fieldWithoutValidation.hasValidators()).thenReturn(true);
  Model model=new Model(TestModelClass.class,""String_Node_Str"",TestUtil.collectionFromObjects(fieldWithoutValidation,fieldWithValidation));
  assertEquals(""String_Node_Str"",model.getName());
  assertEquals(TestModelClass.class,model.getModelClass());
  assertEquals(2,model.getFields().size());
  assertTrue(model.hasValidations());
}","@Test public void testConstructModelValidations() throws Exception {
class TestModelClass {
  }
  ModelField fieldWithoutValidation=mock(ModelField.class);
  when(fieldWithoutValidation.hasValidators()).thenReturn(false);
  ModelField fieldWithValidation=mock(ModelField.class);
  when(fieldWithoutValidation.hasValidators()).thenReturn(true);
  Model model=new Model(TestModelClass.class,""String_Node_Str"",TestUtil.collectionFromObjects(fieldWithoutValidation,fieldWithValidation));
  assertEquals(""String_Node_Str"",model.getName());
  assertEquals(TestModelClass.class,model.getModelClass());
  assertEquals(2,model.getFields().size());
  assertTrue(model.hasValidations());
}"
88924,"@Test public void testConstructModelNoValidations() throws Exception {
class TestModelClass {
  }
  ;
  ModelField fieldWithoutValidation1=mock(ModelField.class);
  when(fieldWithoutValidation1.hasValidators()).thenReturn(false);
  ModelField fieldWithoutValidation2=mock(ModelField.class);
  when(fieldWithoutValidation1.hasValidators()).thenReturn(false);
  Model model=new Model(TestModelClass.class,""String_Node_Str"",TestUtil.collectionFromObjects(fieldWithoutValidation1,fieldWithoutValidation2));
  assertEquals(""String_Node_Str"",model.getName());
  assertEquals(TestModelClass.class,model.getModelClass());
  assertEquals(2,model.getFields().size());
  assertFalse(model.hasValidations());
}","@Test public void testConstructModelNoValidations() throws Exception {
class TestModelClass {
  }
  ModelField fieldWithoutValidation1=mock(ModelField.class);
  when(fieldWithoutValidation1.hasValidators()).thenReturn(false);
  ModelField fieldWithoutValidation2=mock(ModelField.class);
  when(fieldWithoutValidation1.hasValidators()).thenReturn(false);
  Model model=new Model(TestModelClass.class,""String_Node_Str"",TestUtil.collectionFromObjects(fieldWithoutValidation1,fieldWithoutValidation2));
  assertEquals(""String_Node_Str"",model.getName());
  assertEquals(TestModelClass.class,model.getModelClass());
  assertEquals(2,model.getFields().size());
  assertFalse(model.hasValidations());
}"
88925,"@Test public void testOneItemInArray(){
  StringBuilder sb=new StringBuilder();
  LastItemCaller lic=new LastItemCaller();
  ItemHandler<String> itemProcessor=getItemProcessor(sb,lic);
  ItemProcessor.process(itemProcessor,new String[]{""String_Node_Str""});
  assertEquals(""String_Node_Str"",sb.toString());
  assertEquals(1,lic.calledWithLastTrue);
  assertEquals(0,lic.calledWithLastFalse);
}","@Test public void testOneItemInArray(){
  StringBuilder sb=new StringBuilder();
  LastItemCaller lic=new LastItemCaller();
  ItemHandler<String> itemProcessor=getItemProcessor(sb,lic);
  ItemProcessor.process(itemProcessor,""String_Node_Str"");
  assertEquals(""String_Node_Str"",sb.toString());
  assertEquals(1,lic.calledWithLastTrue);
  assertEquals(0,lic.calledWithLastFalse);
}"
88926,"@Test public void testMultipleItemsInArray(){
  StringBuilder sb=new StringBuilder();
  LastItemCaller lic=new LastItemCaller();
  ItemHandler<String> itemProcessor=getItemProcessor(sb,lic);
  ItemProcessor.process(itemProcessor,new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  assertEquals(""String_Node_Str"",sb.toString());
  assertEquals(1,lic.calledWithLastTrue);
  assertEquals(3,lic.calledWithLastFalse);
}","@Test public void testMultipleItemsInArray(){
  StringBuilder sb=new StringBuilder();
  LastItemCaller lic=new LastItemCaller();
  ItemHandler<String> itemProcessor=getItemProcessor(sb,lic);
  ItemProcessor.process(itemProcessor,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",sb.toString());
  assertEquals(1,lic.calledWithLastTrue);
  assertEquals(3,lic.calledWithLastFalse);
}"
88927,"/** 
 * Generates a List from the given objects
 * @param objects Object to include in the list
 * @param < T > Type of list
 * @return List containing the given objects. Empty list if no objects given.
 */
public static <T>List<T> listFromObjects(T... objects){
  List<T> arrayList=new ArrayList<T>(objects.length);
  for (  T t : objects) {
    arrayList.add(t);
  }
  return arrayList;
}","/** 
 * Generates a List from the given objects
 * @param objects Object to include in the list
 * @param < T > Type of list
 * @return List containing the given objects. Empty list if no objects given.
 */
public static <T>List<T> listFromObjects(T... objects){
  List<T> arrayList=new ArrayList<T>(objects.length);
  Collections.addAll(arrayList,objects);
  return arrayList;
}"
88928,"/** 
 * Generates a List from the given objects
 * @param objects Object to include in the list
 * @param < T > Type of list
 * @return List containing the given objects. Empty list if no objects given.
 */
public static <T>Collection<T> collectionFromObjects(T... objects){
  Collection<T> arrayList=new ArrayList<T>(objects.length);
  for (  T t : objects) {
    arrayList.add(t);
  }
  return arrayList;
}","/** 
 * Generates a List from the given objects
 * @param objects Object to include in the list
 * @param < T > Type of list
 * @return List containing the given objects. Empty list if no objects given.
 */
public static <T>Collection<T> collectionFromObjects(T... objects){
  Collection<T> arrayList=new ArrayList<T>(objects.length);
  Collections.addAll(arrayList,objects);
  return arrayList;
}"
88929,"@Test(expected=AssertionError.class) public void testPatternAnnotationProcessorNullFlags(){
  Pattern.Flag[] flags=null;
  String result=JavaToJSPatternConverter.convertFromJava(""String_Node_Str"",flags);
}","@Test(expected=AssertionError.class) public void testPatternAnnotationProcessorNullFlags(){
  Pattern.Flag[] flags=null;
  JavaToJSPatternConverter.convertFromJava(""String_Node_Str"",flags);
}"
88930,"@Test(expected=AssertionError.class) public void testPatternAnnotationProcessorNull(){
  String result=JavaToJSPatternConverter.convertFromJava(null);
}","@Test(expected=AssertionError.class) public void testPatternAnnotationProcessorNull(){
  JavaToJSPatternConverter.convertFromJava(null);
}"
88931,"@Test(expected=AssertionError.class) public void testPatternAnnotationProcessorNull_JSON(){
  String result=JavaToJSPatternConverter.convertFromJavaToJSON(null);
}","@Test(expected=AssertionError.class) public void testPatternAnnotationProcessorNull_JSON(){
  JavaToJSPatternConverter.convertFromJavaToJSON(null);
}"
88932,"public static void main(String[] args) throws IOException, InterruptedException {
  ModelFactory factory=JMobsterFactory.getModelFactoryBuilder().setFieldScanMode(FieldScanMode.DIRECT_FIELD_ACCESS).setFieldGroups(GroupMode.ANY_OF_REQUIRED).setValidatorGroups(GroupMode.ANY_OF_REQUIRED,String.class,Integer.class).setValidatorFactory(new JSR303ValidatorFactory()).build();
  System.out.println(""String_Node_Str"");
  final int n=1000;
  Collection<Class> classesToConvert=new ArrayList<Class>(n);
  for (int i=0; i < n; ++i) {
    if (i % 2 == 0) {
      classesToConvert.add(DemoClasses.BeanPropertyDemo.class);
    }
 else {
      classesToConvert.add(DemoClasses.MyModelDto.class);
    }
  }
  System.out.print(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  Collection<Model> models=factory.createAll(classesToConvert);
  DataWriter modelWriter=new StringBufferWriter();
  CachedModelProvider provider1=new CachedModelProvider(CachedModelProvider.WriteMode.PRETTY,modelWriter);
  JavaScriptWriter javaScriptWriter=new JavaScriptWriter(provider1.getDataWriter());
  FieldValueConverter converter=new JavaToJSValueConverter(ConverterMode.NULL_AS_DEFAULT,EnumConverter.EnumMode.STRING,JavaToJSValueConverter.ISO_8601_DATE_TIME_TZ_PATTERN);
  BackboneModelProcessor backboneModelProcessor=new BackboneModelProcessor.Builder(javaScriptWriter,OutputMode.JSON).setValueConverter(converter).setModelProcessors(new DefaultValueProcessor.Builder().build(),new ValidatorProcessor.Builder().build()).build();
  ModelGenerator generator=JMobsterFactory.getModelGenerator(backboneModelProcessor);
  System.out.print(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  generator.processAll(models);
  System.out.println(modelWriter.toString());
  System.out.println(""String_Node_Str"");
}","public static void main(String[] args) throws IOException, InterruptedException {
  ModelFactory factory=JMobsterFactory.getModelFactoryBuilder().setFieldScanMode(FieldScanMode.DIRECT_FIELD_ACCESS).setFieldGroups(GroupMode.ANY_OF_REQUIRED).setValidatorGroups(GroupMode.ANY_OF_REQUIRED,String.class,Integer.class).setValidatorFactory(new JSR303ValidatorFactory()).build();
  System.out.println(""String_Node_Str"");
  final int n=1;
  Collection<Class> classesToConvert=new ArrayList<Class>(n);
  for (int i=0; i < n; ++i) {
    if (i % 2 == 0) {
      classesToConvert.add(DemoClasses.BeanPropertyDemo.class);
    }
 else {
      classesToConvert.add(DemoClasses.MyModelDto.class);
    }
  }
  System.out.print(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  Collection<Model> models=factory.createAll(classesToConvert);
  DataWriter modelWriter=new StringBufferWriter();
  CachedModelProvider provider1=new CachedModelProvider(CachedModelProvider.WriteMode.PRETTY,modelWriter);
  JavaScriptWriter javaScriptWriter=new JavaScriptWriter(provider1.getDataWriter());
  FieldValueConverter converter=new JavaToJSValueConverter(ConverterMode.NULL_AS_DEFAULT,EnumConverter.EnumMode.STRING,JavaToJSValueConverter.ISO_8601_DATE_TIME_TZ_PATTERN);
  BackboneModelProcessor backboneModelProcessor=new BackboneModelProcessor.Builder(javaScriptWriter,OutputMode.JSON).setValueConverter(converter).setModelProcessors(new DefaultValueProcessor.Builder().build(),new ValidatorProcessor.Builder().build()).build();
  ModelGenerator generator=JMobsterFactory.getModelGenerator(backboneModelProcessor);
  System.out.print(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  generator.processAll(models);
  System.out.println(modelWriter.toString());
  System.out.println(""String_Node_Str"");
}"
88933,"/** 
 * Writes function arguments and starts block
 * @param arguments Function arguments
 * @return Writer itself for chaining writes
 */
private JavaScriptWriter writeFunctionArgsAndStartBlock(String name,String... arguments){
  startFunctionCall(name);
  ItemHandler<String> argumentProcessor=new ItemHandler<String>(){
    @Override public void process(    String argument,    ItemStatus status){
      write(argument,LIST_SEPARATOR + space,status.isNotLastItem());
    }
  }
;
  ItemProcessor.process(argumentProcessor,arguments);
  endFunctionCall().writeSpace();
  return startBlock();
}","/** 
 * Writes function arguments and starts block
 * @param arguments Function arguments
 * @return Writer itself for chaining writes
 */
private JavaScriptWriter writeFunctionArgsAndStartBlock(String name,String... arguments){
  ++functionsOpen;
  startFunctionCall(name);
  ItemHandler<String> argumentProcessor=new ItemHandler<String>(){
    @Override public void process(    String argument,    ItemStatus status){
      write(argument,LIST_SEPARATOR + space,status.isNotLastItem());
    }
  }
;
  ItemProcessor.process(argumentProcessor,arguments);
  endFunctionCall().writeSpace();
  return startBlock();
}"
88934,"@Override public void processModel(final Model model,ItemStatus status){
  LOG.trace(""String_Node_Str"",model.toString());
  String modelName=model.getName();
  if (mode == Mode.FULL) {
    getWriter().write(modelName).writeLine(MODEL_EXTEND_START).indent();
  }
 else {
    getWriter().write(modelName).write(""String_Node_Str"").writeLine(BLOCK_START).indent();
  }
  ItemProcessor.process(modelProcessors).with(new ItemHandler<ModelProcessor<JavaScriptWriter>>(){
    @Override public void process(    ModelProcessor<JavaScriptWriter> item,    ItemStatus status){
      writeSection(item.getName(),model,item,status);
    }
  }
);
  getWriter().indentBack();
  if (mode == Mode.FULL) {
    getWriter().writeLine(MODEL_EXTEND_END,""String_Node_Str"",status.isNotLastItem());
  }
 else {
    getWriter().writeLine(BLOCK_END,""String_Node_Str"",status.isNotLastItem());
  }
}","@Override public void processModel(final Model model,ItemStatus status){
  LOG.trace(""String_Node_Str"",model.toString());
  String modelName=model.getName();
  if (mode == Mode.FULL) {
    getWriter().write(modelName).writeLine(MODEL_EXTEND_START).indent();
  }
 else {
    getWriter().writeKey(modelName).writeLine(BLOCK_START).indent();
  }
  ItemProcessor.process(modelProcessors).with(new ItemHandler<ModelProcessor<JavaScriptWriter>>(){
    @Override public void process(    ModelProcessor<JavaScriptWriter> item,    ItemStatus status){
      writeSection(item.getName(),model,item,status);
    }
  }
);
  getWriter().indentBack();
  if (mode == Mode.FULL) {
    getWriter().writeLine(MODEL_EXTEND_END,""String_Node_Str"",status.isNotLastItem());
  }
 else {
    getWriter().writeLine(BLOCK_END,""String_Node_Str"",status.isNotLastItem());
  }
}"
88935,"private void initRest(List<ModelProcessor<JavaScriptWriter>> validatorProcessor,Mode mode){
  this.startComment=DEFAULT_START_COMMENT;
  this.namespaceName=DEFAULT_NAMESPACE;
  this.modelProcessors.addAll(validatorProcessor);
  this.mode=mode;
  for (  ModelProcessor<JavaScriptWriter> processor : validatorProcessor) {
    processor.setWriter(getWriter());
  }
}","private void initRest(List<ModelProcessor<JavaScriptWriter>> validatorProcessor,Mode mode){
  this.startComment=DEFAULT_START_COMMENT;
  this.namespaceName=DEFAULT_NAMESPACE;
  this.modelProcessors.addAll(validatorProcessor);
  this.mode=mode;
  for (  ModelProcessor<JavaScriptWriter> processor : validatorProcessor) {
    processor.setWriter(getWriter());
  }
  if (mode == Mode.JSON) {
    getWriter().setJSONmode(true);
  }
}"
88936,"/** 
 * Writes object key (also the separator, default "":"")
 * @param key Key name
 * @return Writer itself for chaining writes
 */
public JavaScriptWriter writeKey(String key){
  return write(key).write(KEY_VALUE_SEPARATOR);
}","/** 
 * Writes object key (also the separator, default "":"")
 * @param key Key name
 * @return Writer itself for chaining writes
 */
public JavaScriptWriter writeKey(String key){
  return write(""String_Node_Str"",""String_Node_Str"",JSONmode).write(key,""String_Node_Str"",JSONmode).write(KEY_VALUE_SEPARATOR);
}"
88937,"/** 
 * Constructs and initializes the validator
 * @param annotationBag Annotations to give to the init method
 * @return Initialized validator
 * @throws InstantiationException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 * @throws NoSuchMethodException
 */
private Validator constructAndInitValidator(AnnotationBag annotationBag) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException, InstantiationException {
  final Validator validatorInstance=(Validator)validatorClass.getConstructor().newInstance();
  validatorInstance.init(annotationBag);
  return validatorInstance;
}","/** 
 * Constructs and initializes the validator
 * @param annotationBag Annotations to give to the init method
 * @return Initialized validator
 * @throws InstantiationException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 * @throws NoSuchMethodException
 */
private Validator constructAndInitValidator(AnnotationBag annotationBag) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException, InstantiationException {
  final BaseValidator validatorInstance=(BaseValidator)validatorClass.getConstructor().newInstance();
  validatorInstance.init(annotationBag);
  return validatorInstance;
}"
88938,"@Override public void init(AnnotationBag annotationBag){
  if (annotationBag.hasAnnotation(Min.class)) {
    hasMin=true;
    min=annotationBag.getAnnotation(Min.class).value();
  }
  if (annotationBag.hasAnnotation(Max.class)) {
    hasMax=true;
    max=annotationBag.getAnnotation(Max.class).value();
  }
}","@InitMethod public void init(Max max){
  hasMax=true;
  this.max=max.value();
}"
88939,"@Override public void init(AnnotationBag annotationBag){
  Pattern pattern=annotationBag.getAnnotation(Pattern.class);
  this.flags=pattern.flags();
  if (annotationBag.hasAnnotation(OverridePattern.class)) {
    OverridePattern overriddenPattern=annotationBag.getAnnotation(OverridePattern.class);
    regexp=overriddenPattern.regexp();
  }
 else {
    regexp=pattern.regexp();
  }
}","@InitMethod public void init(OverridePattern overridePattern){
  this.regexp=overridePattern.regexp();
}"
88940,"@Override public void init(AnnotationBag annotationBag){
  Size size=annotationBag.getAnnotation(Size.class);
  this.min=size.min();
  this.max=size.max();
  this.hasMin=min >= 0;
  this.hasMax=max < Integer.MAX_VALUE;
}","@InitMethod public void init(Size size){
  this.min=size.min();
  this.max=size.max();
  this.hasMin=min >= 0;
  this.hasMax=max < Integer.MAX_VALUE;
}"
88941,"/** 
 * Scans the given class for model fields. Accesses field directly via member variables.
 * @param clazz Class to scan
 * @return List of model fields. Empty list if nothing found.
 * @throws CannotAccessDefaultConstructorError If the default constructor exists but cannot be accessed
 * @throws DefaultConstructorMissingError If the given model does not have a default constructor
 */
private List<ModelField> getFieldsByDirectFieldAccess(Class clazz){
  List<ModelField> fields=new ArrayList<ModelField>();
  for (  Field field : clazz.getDeclaredFields()) {
    final boolean wasAccessible=field.isAccessible();
    field.setAccessible(true);
    if (shouldAddField(field)) {
      ModelField modelField=new ModelField(field,validatorScanner.getValidators(field));
      fields.add(modelField);
    }
 else {
      LOG.warn(""String_Node_Str"",field.getName());
    }
    field.setAccessible(wasAccessible);
  }
  return fields;
}","/** 
 * Scans the given class for model fields. Accesses field directly via member variables.
 * @param clazz Class to scan
 * @return List of model fields. Empty list if nothing found.
 * @throws CannotAccessDefaultConstructorError If the default constructor exists but cannot be accessed
 * @throws DefaultConstructorMissingError If the given model does not have a default constructor
 */
private List<ModelField> getFieldsByDirectFieldAccess(Class clazz){
  List<ModelField> fields=new ArrayList<ModelField>();
  for (  Field field : clazz.getDeclaredFields()) {
    final boolean wasAccessible=field.isAccessible();
    field.setAccessible(true);
    if (shouldAddField(field)) {
      ModelField modelField=new ModelField(field,validatorScanner.getValidators(field));
      fields.add(modelField);
    }
 else {
      LOG.warn(""String_Node_Str"",field.getName());
    }
    field.setAccessible(wasAccessible);
  }
  if (clazz.getSuperclass() != null && !clazz.getSuperclass().equals(Object.class)) {
    fields.addAll(getFieldsByDirectFieldAccess(clazz.getSuperclass()));
  }
  return fields;
}"
88942,"/** 
 * Scans the given class for model fields. Accesses bean properties (getter methods).
 * @param clazz Class to scan
 * @return List of model fields. Empty list if nothing found.
 * @throws CannotAccessDefaultConstructorError If the default constructor exists but cannot be accessed
 * @throws DefaultConstructorMissingError If the given model does not have a default constructor
 */
private List<ModelField> getFieldsByGetters(Class clazz){
  List<ModelField> fields=new ArrayList<ModelField>();
  try {
    final BeanInfo beanInfo=Introspector.getBeanInfo(clazz);
    for (    PropertyDescriptor property : beanInfo.getPropertyDescriptors()) {
      if (shouldAddField(property)) {
        final String name=property.getName();
        if (name.equals(""String_Node_Str"")) {
          continue;
        }
        final ModelField field=new ModelField(property,validatorScanner.getValidators(property));
        fields.add(field);
      }
    }
  }
 catch (  IntrospectionException e) {
    LOG.error(""String_Node_Str"",e);
    throw new IllegalArgumentException(""String_Node_Str"",e);
  }
  return fields;
}","/** 
 * Scans the given class for model fields. Accesses bean properties (getter methods).
 * @param clazz Class to scan
 * @return List of model fields. Empty list if nothing found.
 * @throws CannotAccessDefaultConstructorError If the default constructor exists but cannot be accessed
 * @throws DefaultConstructorMissingError If the given model does not have a default constructor
 */
private List<ModelField> getFieldsByGetters(Class clazz){
  List<ModelField> fields=new ArrayList<ModelField>();
  try {
    final BeanInfo beanInfo=Introspector.getBeanInfo(clazz,Introspector.USE_ALL_BEANINFO);
    for (    PropertyDescriptor property : beanInfo.getPropertyDescriptors()) {
      if (shouldAddField(property)) {
        final String name=property.getName();
        if (name.equals(""String_Node_Str"")) {
          continue;
        }
        final ModelField field=new ModelField(property,validatorScanner.getValidators(property));
        fields.add(field);
      }
    }
  }
 catch (  IntrospectionException e) {
    LOG.error(""String_Node_Str"",e);
    throw new IllegalArgumentException(""String_Node_Str"",e);
  }
  return fields;
}"
88943,"@Test public void testStaticFinalMember(){
  DefaultModelFieldFactory fs=getFieldScanner(FieldScanMode.DIRECT_FIELD_ACCESS);
  List<ModelField> models=fs.getFields(TestClassWithStaticMember.class);
  assertFieldFound(models,""String_Node_Str"");
  assertFieldFound(models,""String_Node_Str"");
  assertFieldFound(models,""String_Node_Str"");
  assertFieldNotFound(models,""String_Node_Str"");
}","@Test public void testStaticFinalMember(){
  DefaultModelFieldFactory fs=getFieldScanner(FieldScanMode.DIRECT_FIELD_ACCESS);
  List<ModelField> models=fs.getFields(TestClassWithStaticFinalMember.class);
  assertFieldFoundOnce(models,""String_Node_Str"");
  assertFieldFoundOnce(models,""String_Node_Str"");
  assertFieldFoundOnce(models,""String_Node_Str"");
  assertFieldNotFound(models,""String_Node_Str"");
}"
88944,"@Test public void testGetterAnnotation(){
  DefaultModelFieldFactory fs=getFieldScanner(FieldScanMode.BEAN_PROPERTY);
  List<ModelField> models=fs.getFields(SimpleTestGetterClass.class);
  int i=assertFieldFound(models,""String_Node_Str"");
  assertEquals(1,models.get(i).getValidators().size());
}","@Test public void testGetterAnnotation(){
  DefaultModelFieldFactory fs=getFieldScanner(FieldScanMode.BEAN_PROPERTY);
  List<ModelField> models=fs.getFields(SimpleTestGetterClass.class);
  int i=assertFieldFoundOnce(models,""String_Node_Str"");
  assertEquals(1,models.get(i).getValidators().size());
}"
88945,"@Test public void testAllowFinalMember(){
  DefaultModelFieldFactory fs=getFieldScanner(FieldScanMode.DIRECT_FIELD_ACCESS);
  fs.setAllowFinalFields(true);
  List<ModelField> models=fs.getFields(TestClassWithStaticMember.class);
  assertFieldFound(models,""String_Node_Str"");
  assertFieldFound(models,""String_Node_Str"");
  assertFieldFound(models,""String_Node_Str"");
  assertFieldNotFound(models,""String_Node_Str"");
  assertFieldFound(models,""String_Node_Str"");
}","@Test public void testAllowFinalMember(){
  DefaultModelFieldFactory fs=getFieldScanner(FieldScanMode.DIRECT_FIELD_ACCESS);
  fs.setAllowFinalFields(true);
  List<ModelField> models=fs.getFields(TestClassWithStaticMember.class);
  assertFieldFoundOnce(models,""String_Node_Str"");
  assertFieldFoundOnce(models,""String_Node_Str"");
  assertFieldFoundOnce(models,""String_Node_Str"");
  assertFieldNotFound(models,""String_Node_Str"");
  assertFieldFoundOnce(models,""String_Node_Str"");
}"
88946,"@Test public void testIgnoreField(){
  DefaultModelFieldFactory fs=getFieldScanner(FieldScanMode.DIRECT_FIELD_ACCESS);
  List<ModelField> models=fs.getFields(SimpleIgnoreTestClass.class);
  assertFieldNotFound(models,""String_Node_Str"");
  assertFieldFound(models,""String_Node_Str"");
  assertFieldFound(models,""String_Node_Str"");
}","@Test public void testIgnoreField(){
  DefaultModelFieldFactory fs=getFieldScanner(FieldScanMode.DIRECT_FIELD_ACCESS);
  List<ModelField> models=fs.getFields(SimpleIgnoreTestClass.class);
  assertFieldNotFound(models,""String_Node_Str"");
  assertFieldFoundOnce(models,""String_Node_Str"");
  assertFieldFoundOnce(models,""String_Node_Str"");
}"
88947,"@Test public void testBeanExtraOptionsAllowAll(){
  DefaultModelFieldFactory fs=getFieldScanner(FieldScanMode.BEAN_PROPERTY);
  fs.setAllowFinalFields(true);
  fs.setAllowStaticFields(true);
  List<ModelField> models=fs.getFields(BeanWithStaticAndFinalProperties.class);
  assertFieldFound(models,""String_Node_Str"");
  assertFieldNotFound(models,""String_Node_Str"");
  assertFieldFound(models,""String_Node_Str"");
  assertFieldNotFound(models,""String_Node_Str"");
}","@Test public void testBeanExtraOptionsAllowAll(){
  DefaultModelFieldFactory fs=getFieldScanner(FieldScanMode.BEAN_PROPERTY);
  fs.setAllowFinalFields(true);
  fs.setAllowStaticFields(true);
  List<ModelField> models=fs.getFields(BeanWithStaticAndFinalProperties.class);
  assertFieldFoundOnce(models,""String_Node_Str"");
  assertFieldNotFound(models,""String_Node_Str"");
  assertFieldFoundOnce(models,""String_Node_Str"");
  assertFieldNotFound(models,""String_Node_Str"");
}"
88948,"@Test public void testBeanVisibility(){
  DefaultModelFieldFactory fs=getFieldScanner(FieldScanMode.BEAN_PROPERTY);
  List<ModelField> models=fs.getFields(VisibilityTestGetterClass.class);
  assertFieldNotFound(models,""String_Node_Str"");
  assertFieldNotFound(models,""String_Node_Str"");
  assertFieldFound(models,""String_Node_Str"");
}","@Test public void testBeanVisibility(){
  DefaultModelFieldFactory fs=getFieldScanner(FieldScanMode.BEAN_PROPERTY);
  List<ModelField> models=fs.getFields(VisibilityTestGetterClass.class);
  assertFieldNotFound(models,""String_Node_Str"");
  assertFieldNotFound(models,""String_Node_Str"");
  assertFieldFoundOnce(models,""String_Node_Str"");
}"
88949,"@Test public void testAllowStaticFinalMember(){
  DefaultModelFieldFactory fs=getFieldScanner(FieldScanMode.DIRECT_FIELD_ACCESS);
  fs.setAllowFinalFields(true);
  fs.setAllowStaticFields(true);
  List<ModelField> models=fs.getFields(TestClassWithStaticMember.class);
  assertFieldFound(models,""String_Node_Str"");
  assertFieldFound(models,""String_Node_Str"");
  assertFieldFound(models,""String_Node_Str"");
  assertFieldFound(models,""String_Node_Str"");
}","@Test public void testAllowStaticFinalMember(){
  DefaultModelFieldFactory fs=getFieldScanner(FieldScanMode.DIRECT_FIELD_ACCESS);
  fs.setAllowFinalFields(true);
  fs.setAllowStaticFields(true);
  List<ModelField> models=fs.getFields(TestClassWithStaticMember.class);
  assertFieldFoundOnce(models,""String_Node_Str"");
  assertFieldFoundOnce(models,""String_Node_Str"");
  assertFieldFoundOnce(models,""String_Node_Str"");
  assertFieldFoundOnce(models,""String_Node_Str"");
}"
88950,"@Test public void testAllowStaticMember(){
  DefaultModelFieldFactory fs=getFieldScanner(FieldScanMode.DIRECT_FIELD_ACCESS);
  fs.setAllowFinalFields(false);
  fs.setAllowStaticFields(true);
  List<ModelField> models=fs.getFields(TestClassWithStaticMember.class);
  assertFieldFound(models,""String_Node_Str"");
  assertFieldFound(models,""String_Node_Str"");
  assertFieldFound(models,""String_Node_Str"");
  assertFieldFound(models,""String_Node_Str"");
}","@Test public void testAllowStaticMember(){
  DefaultModelFieldFactory fs=getFieldScanner(FieldScanMode.DIRECT_FIELD_ACCESS);
  fs.setAllowFinalFields(false);
  fs.setAllowStaticFields(true);
  List<ModelField> models=fs.getFields(TestClassWithStaticMember.class);
  assertFieldFoundOnce(models,""String_Node_Str"");
  assertFieldFoundOnce(models,""String_Node_Str"");
  assertFieldFoundOnce(models,""String_Node_Str"");
  assertFieldFoundOnce(models,""String_Node_Str"");
}"
88951,"@Test public void testDontAllowFinalMember(){
  DefaultModelFieldFactory fs=getFieldScanner(FieldScanMode.DIRECT_FIELD_ACCESS);
  fs.setAllowFinalFields(false);
  List<ModelField> models=fs.getFields(TestClassWithStaticMember.class);
  assertFieldFound(models,""String_Node_Str"");
  assertFieldFound(models,""String_Node_Str"");
  assertFieldFound(models,""String_Node_Str"");
  assertFieldNotFound(models,""String_Node_Str"");
  assertFieldNotFound(models,""String_Node_Str"");
}","@Test public void testDontAllowFinalMember(){
  DefaultModelFieldFactory fs=getFieldScanner(FieldScanMode.DIRECT_FIELD_ACCESS);
  fs.setAllowFinalFields(false);
  List<ModelField> models=fs.getFields(TestClassWithStaticMember.class);
  assertFieldFoundOnce(models,""String_Node_Str"");
  assertFieldFoundOnce(models,""String_Node_Str"");
  assertFieldFoundOnce(models,""String_Node_Str"");
  assertFieldNotFound(models,""String_Node_Str"");
  assertFieldNotFound(models,""String_Node_Str"");
}"
88952,"@Test public void testFieldWithValidation(){
  DefaultModelFieldFactory fs=getFieldScanner(FieldScanMode.DIRECT_FIELD_ACCESS);
  List<ModelField> models=fs.getFields(TestClassWithValidation.class);
  assertFieldFound(models,""String_Node_Str"");
  int fieldIndexWithAnnotations=assertFieldFound(models,""String_Node_Str"");
  assertFieldFound(models,""String_Node_Str"");
  ModelField fieldWithAnnotations=models.get(fieldIndexWithAnnotations);
  assertEquals(1,fieldWithAnnotations.getValidators().size());
}","@Test public void testFieldWithValidation(){
  DefaultModelFieldFactory fs=getFieldScanner(FieldScanMode.DIRECT_FIELD_ACCESS);
  List<ModelField> models=fs.getFields(TestClassWithValidation.class);
  assertFieldFoundOnce(models,""String_Node_Str"");
  int fieldIndexWithAnnotations=assertFieldFoundOnce(models,""String_Node_Str"");
  assertFieldFoundOnce(models,""String_Node_Str"");
  ModelField fieldWithAnnotations=models.get(fieldIndexWithAnnotations);
  assertEquals(1,fieldWithAnnotations.getValidators().size());
}"
88953,"@Test public void testIgnoreBeanProperty(){
  DefaultModelFieldFactory fs=getFieldScanner(FieldScanMode.BEAN_PROPERTY);
  List<ModelField> models=fs.getFields(IgnoreBeanPropertyClass.class);
  assertFieldNotFound(models,""String_Node_Str"");
  assertFieldFound(models,""String_Node_Str"");
}","@Test public void testIgnoreBeanProperty(){
  DefaultModelFieldFactory fs=getFieldScanner(FieldScanMode.BEAN_PROPERTY);
  List<ModelField> models=fs.getFields(IgnoreBeanPropertyClass.class);
  assertFieldNotFound(models,""String_Node_Str"");
  assertFieldFoundOnce(models,""String_Node_Str"");
}"
88954,"@Test public void testStaticAndFinalMember(){
  DefaultModelFieldFactory fs=getFieldScanner(FieldScanMode.DIRECT_FIELD_ACCESS);
  List<ModelField> models=fs.getFields(TestClassWithStaticMember.class);
  assertFieldFound(models,""String_Node_Str"");
  assertFieldFound(models,""String_Node_Str"");
  assertFieldFound(models,""String_Node_Str"");
  assertFieldNotFound(models,""String_Node_Str"");
  assertFieldFound(models,""String_Node_Str"");
}","@Test public void testStaticAndFinalMember(){
  DefaultModelFieldFactory fs=getFieldScanner(FieldScanMode.DIRECT_FIELD_ACCESS);
  List<ModelField> models=fs.getFields(TestClassWithStaticMember.class);
  assertFieldFoundOnce(models,""String_Node_Str"");
  assertFieldFoundOnce(models,""String_Node_Str"");
  assertFieldFoundOnce(models,""String_Node_Str"");
  assertFieldNotFound(models,""String_Node_Str"");
  assertFieldFoundOnce(models,""String_Node_Str"");
}"
88955,"@Test public void testGetFields(){
  DefaultModelFieldFactory fs=getFieldScanner(FieldScanMode.DIRECT_FIELD_ACCESS);
  List<ModelField> models=fs.getFields(SimpleTestClass.class);
  assertFieldFound(models,""String_Node_Str"");
  assertFieldFound(models,""String_Node_Str"");
  assertFieldFound(models,""String_Node_Str"");
}","@Test public void testGetFields(){
  DefaultModelFieldFactory fs=getFieldScanner(FieldScanMode.DIRECT_FIELD_ACCESS);
  List<ModelField> models=fs.getFields(SimpleTestClass.class);
  assertFieldFoundOnce(models,""String_Node_Str"");
  assertFieldFoundOnce(models,""String_Node_Str"");
  assertFieldFoundOnce(models,""String_Node_Str"");
}"
88956,"@Test public void testBeanExtraOptionsDefault(){
  DefaultModelFieldFactory fs=getFieldScanner(FieldScanMode.BEAN_PROPERTY);
  List<ModelField> models=fs.getFields(BeanWithStaticAndFinalProperties.class);
  assertFieldFound(models,""String_Node_Str"");
  assertFieldNotFound(models,""String_Node_Str"");
  assertFieldFound(models,""String_Node_Str"");
  assertFieldNotFound(models,""String_Node_Str"");
}","@Test public void testBeanExtraOptionsDefault(){
  DefaultModelFieldFactory fs=getFieldScanner(FieldScanMode.BEAN_PROPERTY);
  List<ModelField> models=fs.getFields(BeanWithStaticAndFinalProperties.class);
  assertFieldFoundOnce(models,""String_Node_Str"");
  assertFieldNotFound(models,""String_Node_Str"");
  assertFieldFoundOnce(models,""String_Node_Str"");
  assertFieldNotFound(models,""String_Node_Str"");
}"
88957,"/** 
 * Converts the given value using a suitable converter class
 * @param value Value to convert
 * @param clazz Value's class
 * @return Converted value depending on settings
 */
private String convertByClass(Object value,Class clazz){
  ValueConverter converter=getConverterByClass(clazz);
  if (converter == null) {
    LOG.debug(value.getClass().getCanonicalName());
  }
  return converter.convertValue(value);
}","/** 
 * Converts the given value using a suitable converter class
 * @param value Value to convert
 * @param clazz Value's class
 * @return Converted value depending on settings
 */
private String convertByClass(Object value,Class clazz){
  ValueConverter converter=getConverterByClass(clazz);
  if (converter == null) {
    LOG.debug(value.getClass().getCanonicalName());
    return nullValue;
  }
  return converter.convertValue(value);
}"
88958,"@Override protected String getTypeDefaultValue(){
  Date defaultDate=null;
  if (defaultTime == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
switch (defaultTime) {
case NOW:
    defaultDate=new Date();
  break;
case EPOCH_0:
defaultDate=new Date(0);
break;
default :
throw new RuntimeException(""String_Node_Str"");
}
return super.getValueAsString(dateFormat.format(defaultDate));
}","@Override protected String getTypeDefaultValue(){
  if (defaultTime == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  Date defaultDate;
switch (defaultTime) {
case NOW:
    defaultDate=new Date();
  break;
case EPOCH_0:
defaultDate=new Date(0);
break;
default :
throw new RuntimeException(""String_Node_Str"");
}
return super.getValueAsString(dateFormat.format(defaultDate));
}"
88959,"private Class[] extractGroupsFromAnnotation(Annotation annotation){
  try {
    final Method groupsMethod=annotation.getClass().getMethod(GROUPS_METHOD_NAME);
    final Object result=groupsMethod.invoke(annotation);
    final Class[] annotationGroups=(Class[])result;
    return annotationGroups;
  }
 catch (  NoSuchMethodException e) {
    LOG.warn(""String_Node_Str"",annotation.getClass().getName());
  }
catch (  InvocationTargetException e) {
    LOG.error(""String_Node_Str"",e);
  }
catch (  IllegalAccessException e) {
    LOG.error(""String_Node_Str"",e);
  }
  return new Class[0];
}","private Class[] extractGroupsFromAnnotation(Annotation annotation){
  try {
    final Method groupsMethod=annotation.getClass().getMethod(GROUPS_METHOD_NAME);
    final Object result=groupsMethod.invoke(annotation);
    return (Class[])result;
  }
 catch (  NoSuchMethodException e) {
    LOG.warn(""String_Node_Str"",annotation.getClass().getName());
  }
catch (  InvocationTargetException e) {
    LOG.error(""String_Node_Str"",e);
  }
catch (  IllegalAccessException e) {
    LOG.error(""String_Node_Str"",e);
  }
  return new Class[0];
}"
88960,"private boolean checkAtLeastRequiredGroups(T[] groupsGiven){
  final Set<T> configuredGroups=new HashSet<T>(groups.size());
  for (  T group : groups) {
    configuredGroups.add(group);
  }
  final int groupsNeededCount=configuredGroups.size();
  final Set<T> givenGroups=new HashSet<T>(groupsGiven.length);
  for (  T group : groupsGiven) {
    givenGroups.add(group);
  }
  final int groupsGivenCount=givenGroups.size();
  if (groupsGivenCount < groupsNeededCount) {
    return false;
  }
  int groupsFoundCount=0;
  for (  T givenGroup : givenGroups) {
    if (configuredGroups.contains(givenGroup)) {
      ++groupsFoundCount;
    }
  }
  return groupsFoundCount == groupsNeededCount;
}","private boolean checkAtLeastRequiredGroups(T[] groupsGiven){
  final Set<T> configuredGroups=new HashSet<T>(groups.size());
  for (  T group : groups) {
    configuredGroups.add(group);
  }
  final int groupsNeededCount=configuredGroups.size();
  final Set<T> givenGroups=new HashSet<T>(groupsGiven.length);
  Collections.addAll(givenGroups,groupsGiven);
  final int groupsGivenCount=givenGroups.size();
  if (groupsGivenCount < groupsNeededCount) {
    return false;
  }
  int groupsFoundCount=0;
  for (  T givenGroup : givenGroups) {
    if (configuredGroups.contains(givenGroup)) {
      ++groupsFoundCount;
    }
  }
  return groupsFoundCount == groupsNeededCount;
}"
88961,"@Override public void addAnnotationProcessor(ValidationAnnotationProcessor annotationProcessor){
  annotationProcessors.add(annotationProcessor);
  if (annotationProcessor.isBaseValidator()) {
    baseAnnotationProcessors.put(annotationProcessor.getBaseValidatorForClass(),annotationProcessor);
  }
}","@Override public final void addAnnotationProcessor(ValidationAnnotationProcessor annotationProcessor){
  annotationProcessors.add(annotationProcessor);
  if (annotationProcessor.isBaseValidator()) {
    baseAnnotationProcessors.put(annotationProcessor.getBaseValidatorForClass(),annotationProcessor);
  }
}"
88962,"/** 
 * Sets the class for which this processor acts as a base validator. Once this method is called, the class will act as a base validator and the  {@link fi.vincit.jmobster.processor.defaults.BaseValidationAnnotationProcessor#isBaseValidator()}method will return true.
 * @param baseValidatorForClass Class for which the processor should act as base validator
 */
protected void setBaseValidatorForClass(Class baseValidatorForClass){
  this.baseValidatorForClass=baseValidatorForClass;
}","/** 
 * Sets the class for which this processor acts as a base validator. Once this method is called, the class will act as a base validator and the  {@link fi.vincit.jmobster.processor.defaults.BaseValidationAnnotationProcessor#isBaseValidator()}method will return true.
 * @param baseValidatorForClass Class for which the processor should act as base validator
 */
protected final void setBaseValidatorForClass(Class baseValidatorForClass){
  this.baseValidatorForClass=baseValidatorForClass;
}"
88963,"@Override public Class[] getGroups(Annotation annotation){
  Class[] groups=getGroupsInternal(annotation);
  return groups != null ? groups : new Class[0];
}","@Override public Class[] getGroups(Annotation annotation){
  Class[] groups=getGroupsInternal(annotation);
  return groups != null ? groups : EMPTY_GROUPS;
}"
88964,"/** 
 * Sets writer to use
 * @param writer Model writer
 */
public void setWriter(ModelWriter writer){
  this.writer=new JavaScriptWriter(writer);
}","/** 
 * Sets writer to use
 * @param writer Model writer
 */
public final void setWriter(ModelWriter writer){
  this.writer=new JavaScriptWriter(writer);
}"
88965,"/** 
 * Sets default model writer
 * @param writer Model writer
 */
public void setWriter(ModelWriter writer){
  this.writer=new JavaScriptWriter(writer);
}","/** 
 * Sets default model writer
 * @param writer Model writer
 */
public final void setWriter(ModelWriter writer){
  this.writer=new JavaScriptWriter(writer);
}"
88966,"/** 
 * Constructs manager with required and optional types.
 * @param requiredTypes Required types
 * @param optionalTypes Optional types
 */
public CombinationManager(RequiredTypes requiredTypes,OptionalTypes optionalTypes){
  this.requiredTypes=requiredTypes;
  this.optionalTypes=optionalTypes;
  this.requiredClasses=new HashMap<Class,Class>();
  for (  Class c : this.requiredTypes.getTypes()) {
    requiredClasses.put(c,c);
  }
  this.optionalClasses=new HashMap<Class,Class>();
  for (  Class c : this.optionalTypes.getTypes()) {
    optionalClasses.put(c,c);
  }
}","/** 
 * Constructs manager with required and optional types.
 * @param requiredTypes Required types
 * @param optionalTypes Optional types
 */
public CombinationManager(RequiredTypes requiredTypes,OptionalTypes optionalTypes){
  this.requiredClasses=new HashMap<Class,Class>();
  for (  Class c : requiredTypes.getTypes()) {
    requiredClasses.put(c,c);
  }
  this.optionalClasses=new HashMap<Class,Class>();
  for (  Class c : optionalTypes.getTypes()) {
    optionalClasses.put(c,c);
  }
}"
88967,"/** 
 * Write the given string and start new line. If writeSeparator is set to true, also writes the separator right after the modelString. Line change will be performed after modelString and if separator is written, it will be performed after separator.
 * @param modelStringLine String to write
 * @param separator Optional separator to write
 * @param writeSeparator Should separator be written. Set true if should, set false if not.
 * @return
 */
ModelWriter writeLine(String modelStringLine,String separator,boolean writeSeparator);","/** 
 * Write the given string and start new line. If writeSeparator is set to true, also writes the separator right after the modelString. Line change will be performed after modelString and if separator is written, it will be performed after separator.
 * @param modelStringLine String to write
 * @param separator Optional separator to write
 * @param writeSeparator Should separator be written. Set true if should, set false if not.
 * @return Writer for chaining calls.
 */
ModelWriter writeLine(String modelStringLine,String separator,boolean writeSeparator);"
88968,"public T[] getTypes(){
  if (types != null) {
    return types;
  }
 else {
    return (T[])Array.newInstance(types.getClass(),0);
  }
}","public T[] getTypes(){
  return types;
}"
88969,"@Test public void testProcessNoValidators() throws Exception {
  ModelWriter writer=mockWriter();
  AnnotationProcessor annotationProcessor=mock(AnnotationProcessor.class);
  ModelNamingStrategy modelNamingStrategy=mock(ModelNamingStrategy.class);
  BackboneValueSectionWriter backboneValueSectionWriter=mock(BackboneValueSectionWriter.class);
  BackboneValidationSectionWriter backboneValidationSectionWriter=mock(BackboneValidationSectionWriter.class);
  BackboneModelProcessor bmp=new BackboneModelProcessor(writer,""String_Node_Str"",annotationProcessor,modelNamingStrategy,""String_Node_Str"",""String_Node_Str"",backboneValueSectionWriter,backboneValidationSectionWriter);
  final List<ModelField> fields=new ArrayList<ModelField>();
  final Model testModel=new Model(String.class,fields);
  testModel.setValidations(false);
  bmp.startProcessing();
  bmp.processModel(testModel,false);
  bmp.endProcessing();
  InOrder order=inOrder(writer,annotationProcessor,modelNamingStrategy,backboneValueSectionWriter,backboneValidationSectionWriter);
  order.verify(modelNamingStrategy).getName(testModel);
  order.verify(backboneValueSectionWriter).writeDefaultValues(fields,false);
  order.verify(backboneValidationSectionWriter,times(0)).writeValidators(any(List.class));
}","@Test public void testProcessNoValidators() throws Exception {
  ModelWriter writer=mockWriter();
  AnnotationProcessor annotationProcessor=mock(AnnotationProcessor.class);
  ModelNamingStrategy modelNamingStrategy=mock(ModelNamingStrategy.class);
  BackboneValueSectionWriter backboneValueSectionWriter=mock(BackboneValueSectionWriter.class);
  BackboneValidationSectionWriter backboneValidationSectionWriter=mock(BackboneValidationSectionWriter.class);
  BackboneModelProcessor bmp=new BackboneModelProcessor(writer,annotationProcessor,modelNamingStrategy,""String_Node_Str"",""String_Node_Str"",backboneValueSectionWriter,backboneValidationSectionWriter);
  final List<ModelField> fields=new ArrayList<ModelField>();
  final Model testModel=new Model(String.class,fields);
  testModel.setValidations(false);
  bmp.startProcessing();
  bmp.processModel(testModel,false);
  bmp.endProcessing();
  InOrder order=inOrder(writer,annotationProcessor,modelNamingStrategy,backboneValueSectionWriter,backboneValidationSectionWriter);
  order.verify(modelNamingStrategy).getName(testModel);
  order.verify(backboneValueSectionWriter).writeDefaultValues(fields,false);
  order.verify(backboneValidationSectionWriter,times(0)).writeValidators(any(List.class));
}"
88970,"@Test public void testProcessWithValidators() throws Exception {
  ModelWriter writer=mockWriter();
  AnnotationProcessor annotationProcessor=mock(AnnotationProcessor.class);
  ModelNamingStrategy modelNamingStrategy=mock(ModelNamingStrategy.class);
  BackboneValueSectionWriter backboneValueSectionWriter=mock(BackboneValueSectionWriter.class);
  BackboneValidationSectionWriter backboneValidationSectionWriter=mock(BackboneValidationSectionWriter.class);
  BackboneModelProcessor bmp=new BackboneModelProcessor(writer,""String_Node_Str"",annotationProcessor,modelNamingStrategy,""String_Node_Str"",""String_Node_Str"",backboneValueSectionWriter,backboneValidationSectionWriter);
  final List<ModelField> fields=new ArrayList<ModelField>();
  final Model testModel=new Model(String.class,fields);
  testModel.setValidations(true);
  bmp.startProcessing();
  bmp.processModel(testModel,true);
  bmp.endProcessing();
  InOrder order=inOrder(writer,annotationProcessor,modelNamingStrategy,backboneValueSectionWriter,backboneValidationSectionWriter);
  order.verify(modelNamingStrategy).getName(testModel);
  order.verify(backboneValueSectionWriter).writeDefaultValues(fields,true);
  order.verify(backboneValidationSectionWriter).writeValidators(fields);
}","@Test public void testProcessWithValidators() throws Exception {
  ModelWriter writer=mockWriter();
  AnnotationProcessor annotationProcessor=mock(AnnotationProcessor.class);
  ModelNamingStrategy modelNamingStrategy=mock(ModelNamingStrategy.class);
  BackboneValueSectionWriter backboneValueSectionWriter=mock(BackboneValueSectionWriter.class);
  BackboneValidationSectionWriter backboneValidationSectionWriter=mock(BackboneValidationSectionWriter.class);
  BackboneModelProcessor bmp=new BackboneModelProcessor(writer,annotationProcessor,modelNamingStrategy,""String_Node_Str"",""String_Node_Str"",backboneValueSectionWriter,backboneValidationSectionWriter);
  final List<ModelField> fields=new ArrayList<ModelField>();
  final Model testModel=new Model(String.class,fields);
  testModel.setValidations(true);
  bmp.startProcessing();
  bmp.processModel(testModel,true);
  bmp.endProcessing();
  InOrder order=inOrder(writer,annotationProcessor,modelNamingStrategy,backboneValueSectionWriter,backboneValidationSectionWriter);
  order.verify(modelNamingStrategy).getName(testModel);
  order.verify(backboneValueSectionWriter).writeDefaultValues(fields,true);
  order.verify(backboneValidationSectionWriter).writeValidators(fields);
}"
88971,"/** 
 * Adds annotation processor to provider.
 * @param annotationProcessor Processor to add
 */
protected void addAnnotationProcessor(ValidationAnnotationProcessor annotationProcessor){
  annotationProcessors.add(annotationProcessor);
  if (annotationProcessor.isBaseValidator()) {
    baseAnnotationProcessors.put(annotationProcessor.getBaseValidatorForClass(),annotationProcessor);
  }
}","@Override public void addAnnotationProcessor(ValidationAnnotationProcessor annotationProcessor){
  annotationProcessors.add(annotationProcessor);
  if (annotationProcessor.isBaseValidator()) {
    baseAnnotationProcessors.put(annotationProcessor.getBaseValidatorForClass(),annotationProcessor);
  }
}"
88972,"/** 
 * Prepares the processor for writing. Initializes the annotations the processor uses so that they can be found via  {@link BaseValidationAnnotationProcessor#findAnnotation(Class)}.
 * @param annotations Annotations for a field.
 */
private void prepareForWrite(List<Annotation> annotations){
  annotationBag=new HashMap<Class,Annotation>();
  for (  Annotation a : annotations) {
    if (combinationManager.containsClass(a.annotationType())) {
      annotationBag.put(a.annotationType(),a);
    }
  }
}","/** 
 * Prepares the processor for writing. Initializes the annotations the processor uses so that they can be found via  {@link BaseValidationAnnotationProcessor#findAnnotation(Class)}.
 * @param annotations Annotations for a field.
 */
private void prepareForWrite(List<Annotation> annotations){
  annotationBag=new HashMap<Class,Annotation>();
  for (  Annotation annotation : annotations) {
    if (combinationManager.containsClass(annotation.annotationType())) {
      annotationBag.put(annotation.annotationType(),annotation);
    }
  }
}"
88973,"/** 
 * Constructor for processor required annotations and optional annotations but no type information.
 * @param requiredAnnotation Required annotations
 * @param optionalAnnotations Optional annotations
 */
protected BaseValidationAnnotationProcessor(RequiredTypes requiredAnnotation,OptionalTypes optionalAnnotations){
  this.combinationManager=new CombinationManager(requiredAnnotation,optionalAnnotations);
}","/** 
 * Constructor for processor required annotations and optional annotations but no type information.
 * @param requiredAnnotation Required annotations
 * @param optionalAnnotations Optional annotations
 */
protected BaseValidationAnnotationProcessor(RequiredTypes requiredAnnotation,OptionalTypes optionalAnnotations){
  this.requiredType=null;
  this.combinationManager=new CombinationManager(requiredAnnotation,optionalAnnotations);
}"
88974,"public BackboneModelProcessor(ModelWriter writer){
  this((String)null,GroupMode.ANY_OF_REQUIRED);
  this.writer=writer;
}","public BackboneModelProcessor(ModelWriter writer,FieldAnnotationWriter fieldAnnotationWriter){
  this((String)null,GroupMode.ANY_OF_REQUIRED,fieldAnnotationWriter);
  this.writer=writer;
}"
88975,"/** 
 * Checks whether the managers combination matches the given classes combination. The combination matches if and only if the all of the given classes are same set (same classes and count is same).
 * @param classes Classes to check
 * @return True if given classes match required classes, otherwise false.
 */
public boolean matches(List<Annotation> classes){
  int matchesFound=0;
  for (  Annotation c : classes) {
    if (requiredClasses.containsKey(c.annotationType())) {
      ++matchesFound;
    }
  }
  return matchesFound >= requiredClasses.size();
}","/** 
 * Checks whether the managers combination matches the given classes combination. The combination matches if and only if the all of the given classes are same set (same classes and count is same).
 * @param classes Classes to check
 * @return True if given classes match required classes, otherwise false.
 */
public boolean matches(List<Annotation> classes){
  if (requiredClasses.isEmpty() && optionalClasses.isEmpty()) {
    return false;
  }
  int matchesFound=0;
  for (  Annotation c : classes) {
    if (requiredClasses.containsKey(c.annotationType())) {
      ++matchesFound;
    }
  }
  return matchesFound >= requiredClasses.size();
}"
88976,"@Test public void testSimpleClass(){
  FieldAnnotationWriter app=new BackboneFieldAnnotationWriter();
  DefaultModelGenerator mg=new DefaultModelGenerator(new BackboneModelProcessor(modelWriter),new JavaToJSValueConverter(ConverterMode.ALLOW_NULL),app);
  mg.process(TestModel.class);
  String referenceModel=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  assertEquals(referenceModel,os.toString());
}","@Test public void testSimpleClass(){
  FieldAnnotationWriter app=new BackboneFieldAnnotationWriter();
  app.addAnnotationProcessor(new NonBaseAnnotationProcessor());
  DefaultModelGenerator mg=new DefaultModelGenerator(new BackboneModelProcessor(modelWriter,app),new JavaToJSValueConverter(ConverterMode.ALLOW_NULL),app);
  mg.process(TestModel.class);
  String referenceModel=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  assertEquals(referenceModel,os.toString());
}"
88977,"@Test public void testNoValidationsClass(){
  FieldAnnotationWriter app=new BackboneFieldAnnotationWriter();
  DefaultModelGenerator mg=new DefaultModelGenerator(new BackboneModelProcessor(modelWriter),new JavaToJSValueConverter(ConverterMode.ALLOW_NULL),app);
  mg.process(NoValidationsClass.class);
  String referenceModel=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  assertEquals(referenceModel,os.toString());
}","@Test public void testNoValidationsClass(){
  FieldAnnotationWriter app=new BackboneFieldAnnotationWriter();
  DefaultModelGenerator mg=new DefaultModelGenerator(new BackboneModelProcessor(modelWriter,app),new JavaToJSValueConverter(ConverterMode.ALLOW_NULL),app);
  mg.process(NoValidationsClass.class);
  String referenceModel=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  assertEquals(referenceModel,os.toString());
}"
88978,"public CachedModelProvider(Mode mode){
  this.bos=new ByteOutputStream();
  this.modelWriter=new StreamModelWriter(bos);
switch (mode) {
case COMPACT:
    configureCompactMode(modelWriter);
  break;
case PRETTY:
configurePrettyMode(modelWriter);
break;
}
}","public CachedModelProvider(Mode mode){
  this.bos=new ByteArrayOutputStream();
  this.modelWriter=new StreamModelWriter(bos);
switch (mode) {
case COMPACT:
    configureCompactMode(modelWriter);
  break;
case PRETTY:
configurePrettyMode(modelWriter);
break;
}
}"
88979,"@Override public void process(Class... classes){
  List<Model> models=getModels(classes);
  try {
    modelProcessor.startProcessing();
    for (int i=0; i < models.size(); ++i) {
      Model model=models.get(i);
      boolean isLastModel=i == models.size() - 1;
      modelProcessor.processModel(model,isLastModel);
    }
    modelProcessor.endProcessing();
  }
 catch (  IOException e) {
    LOG.error(""String_Node_Str"",e);
  }
}","@Override protected void process(Model model,boolean isLastModel){
  modelProcessor.processModel(model,isLastModel);
}"
88980,"@Before public void initTest(){
  os=new ByteOutputStream();
  mw=new StreamModelWriter(os);
  writer=new JavaScriptWriter(mw);
}","@Before public void initTest(){
  os=new ByteArrayOutputStream();
  mw=new StreamModelWriter(os);
  writer=new JavaScriptWriter(mw);
}"
88981,"@Override protected void process(Annotation annotation,boolean isLast){
  ValidationAnnotationProcessor annotationProcessor=annotationProcessorProvider.getValidator(annotation);
  if (annotationProcessor != null) {
    if (annotationProcessor.requiresType()) {
      appendType(hasPropertyTypeSet,writer,annotationProcessor.requiredType());
      hasPropertyTypeSet=true;
    }
    annotationProcessor.writeValidatorsToStream(annotation,writer);
  }
 else {
    LOG.debug(""String_Node_Str"");
  }
  writer.writeLine(""String_Node_Str"",""String_Node_Str"",!isLast);
}","@Override protected void process(Annotation annotation,boolean isLast){
  ValidationAnnotationProcessor annotationProcessor=annotationProcessorProvider.getValidator(annotation);
  if (annotationProcessor != null) {
    if (annotationProcessor.requiresType()) {
      appendType(hasPropertyTypeSet,writer,annotationProcessor.requiredType());
      hasPropertyTypeSet=true;
    }
    annotationProcessor.writeValidatorsToStream(annotation,writer);
    writer.writeLine(""String_Node_Str"",""String_Node_Str"",!isLast);
  }
 else {
    LOG.debug(""String_Node_Str"");
  }
}"
88982,"@Override public void writeValidation(List<Annotation> validationAnnotations,final ModelWriter writer){
  ItemProcessor<Annotation> annotationItemProcessor=new ItemProcessor<Annotation>(){
    boolean hasPropertyTypeSet=false;
    @Override protected void process(    Annotation annotation,    boolean isLast){
      ValidationAnnotationProcessor annotationProcessor=annotationProcessorProvider.getValidator(annotation);
      if (annotationProcessor != null) {
        if (annotationProcessor.requiresType()) {
          appendType(hasPropertyTypeSet,writer,annotationProcessor.requiredType());
          hasPropertyTypeSet=true;
        }
        annotationProcessor.writeValidatorsToStream(annotation,writer);
      }
 else {
        LOG.debug(""String_Node_Str"");
      }
      writer.writeLine(""String_Node_Str"",""String_Node_Str"",!isLast);
    }
  }
;
  annotationItemProcessor.process(validationAnnotations);
}","@Override public void writeValidation(List<Annotation> validationAnnotations,final ModelWriter writer){
  ItemProcessor<Annotation> annotationItemProcessor=new ItemProcessor<Annotation>(){
    boolean hasPropertyTypeSet=false;
    @Override protected void process(    Annotation annotation,    boolean isLast){
      ValidationAnnotationProcessor annotationProcessor=annotationProcessorProvider.getValidator(annotation);
      if (annotationProcessor != null) {
        if (annotationProcessor.requiresType()) {
          appendType(hasPropertyTypeSet,writer,annotationProcessor.requiredType());
          hasPropertyTypeSet=true;
        }
        annotationProcessor.writeValidatorsToStream(annotation,writer);
        writer.writeLine(""String_Node_Str"",""String_Node_Str"",!isLast);
      }
 else {
        LOG.debug(""String_Node_Str"");
      }
    }
  }
;
  annotationItemProcessor.process(validationAnnotations);
}"
88983,"@Override public void processModel(Model model,boolean isLastModel){
  String modelName=modelNamingStrategy.getName(model);
  writer.write(modelName).writeLine(MODEL_EXTEND_START).indent();
  DefaultValueSectionWriter defaultValueSectionWriter=new DefaultValueSectionWriter(writer);
  defaultValueSectionWriter.writeDefaultValues(model.getFields(),model.hasValidations());
  ValidationSectionWriter validationSectionWriter=new ValidationSectionWriter(writer,annotationProcessor);
  validationSectionWriter.writeValidators(model.getFields());
  writer.indentBack();
  writer.writeLine(MODEL_EXTEND_END,""String_Node_Str"",!isLastModel);
}","@Override public void processModel(Model model,boolean isLastModel){
  String modelName=modelNamingStrategy.getName(model);
  writer.write(modelName).writeLine(MODEL_EXTEND_START).indent();
  DefaultValueSectionWriter defaultValueSectionWriter=new DefaultValueSectionWriter(writer);
  defaultValueSectionWriter.writeDefaultValues(model.getFields(),model.hasValidations());
  if (model.hasValidations()) {
    ValidationSectionWriter validationSectionWriter=new ValidationSectionWriter(writer,annotationProcessor);
    validationSectionWriter.writeValidators(model.getFields());
  }
  writer.indentBack();
  writer.writeLine(MODEL_EXTEND_END,""String_Node_Str"",!isLastModel);
}"
88984,"@Test public void testSimpleClass(){
  DefaultModelGenerator mg=new DefaultModelGenerator(new BackboneModelProcessor(modelWriter),new JavaToJSValueConverter(ConverterMode.ALLOW_NULL));
  mg.process(TestModel.class);
  String referenceModel=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  assertEquals(referenceModel,os.toString());
}","@Test public void testSimpleClass(){
  DefaultModelGenerator mg=new DefaultModelGenerator(new BackboneModelProcessor(modelWriter),new JavaToJSValueConverter(ConverterMode.ALLOW_NULL));
  mg.process(TestModel.class);
  String referenceModel=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  assertEquals(referenceModel,os.toString());
}"
88985,"public BackboneModelProcessor(ModelWriter writer){
  this((String)null);
  this.writer=writer;
}","public BackboneModelProcessor(ModelWriter writer){
  this((String)null,GroupMode.ANY_OF_REQUIRED);
  this.writer=writer;
}"
88986,"public DefaultAnnotationProcessor(AnnotationProcessorProvider annotationProcessorProvider){
  this.annotationProcessorProvider=annotationProcessorProvider;
}","public DefaultAnnotationProcessor(AnnotationProcessorProvider annotationProcessorProvider,GroupMode groupMode,Class... groups){
  this.annotationProcessorProvider=annotationProcessorProvider;
  this.groups=groups;
  this.groupMode=groupMode;
  this.includeValidationsWithoutGroup=false;
}"
88987,"@Override public void writeValidation(List<Annotation> validationAnnotations,final JavaScriptWriter writer){
  ItemProcessor<Annotation> annotationItemProcessor=new ItemProcessor<Annotation>(){
    boolean hasPropertyTypeSet=false;
    @Override protected void process(    Annotation annotation,    boolean isLast){
      ValidationAnnotationProcessor annotationProcessor=annotationProcessorProvider.getValidator(annotation);
      if (annotationProcessor != null) {
        if (annotationProcessor.requiresType()) {
          appendType(hasPropertyTypeSet,writer,annotationProcessor.requiredType());
          hasPropertyTypeSet=true;
        }
        annotationProcessor.writeValidatorsToStream(annotation,writer);
        writer.writeLine(""String_Node_Str"",""String_Node_Str"",!isLast);
      }
 else {
        LOG.debug(""String_Node_Str"");
      }
    }
  }
;
  annotationItemProcessor.process(validationAnnotations);
}","@Override public void writeValidation(List<Annotation> validationAnnotations,final JavaScriptWriter writer){
  ItemProcessor<Annotation> annotationItemProcessor=new ItemProcessor<Annotation>(){
    boolean hasPropertyTypeSet=false;
    @Override protected void process(    Annotation annotation,    boolean isLast){
      ValidationAnnotationProcessor annotationProcessor=annotationProcessorProvider.getValidator(annotation);
      if (annotationProcessor != null) {
        if (annotationProcessor.requiresType()) {
          appendType(hasPropertyTypeSet,writer,annotationProcessor.requiredType());
          hasPropertyTypeSet=true;
        }
        annotationProcessor.writeValidatorsToStream(annotation,writer);
        writer.writeLine(""String_Node_Str"",""String_Node_Str"",!isLast);
      }
 else {
        LOG.debug(""String_Node_Str"");
      }
    }
  }
;
  List<Annotation> filteredAnnotations=filterByGroupRules(validationAnnotations);
  annotationItemProcessor.process(filteredAnnotations);
}"
88988,"@Test public void testMultipleItems(){
}","@Test public void testMultipleItems(){
  List<String> list=new ArrayList<String>();
  list.add(""String_Node_Str"");
  list.add(""String_Node_Str"");
  list.add(""String_Node_Str"");
  list.add(""String_Node_Str"");
  StringBuilder sb=new StringBuilder();
  LastItemCaller lic=new LastItemCaller();
  ItemProcessor<String> itemProcessor=getItemProcessor(sb,lic);
  itemProcessor.process(list);
  assertEquals(""String_Node_Str"",sb.toString());
  assertEquals(1,lic.calledWithLastTrue);
  assertEquals(3,lic.calledWithLastFalse);
}"
88989,"@Test public void testOneItem(){
}","@Test public void testOneItem(){
  List<String> list=new ArrayList<String>();
  list.add(""String_Node_Str"");
  StringBuilder sb=new StringBuilder();
  LastItemCaller lic=new LastItemCaller();
  ItemProcessor<String> itemProcessor=getItemProcessor(sb,lic);
  itemProcessor.process(list);
  assertEquals(""String_Node_Str"",sb.toString());
  assertEquals(1,lic.calledWithLastTrue);
  assertEquals(0,lic.calledWithLastFalse);
}"
88990,"@Test public void testNullItems(){
}","@Test public void testNullItems(){
  List<String> list=null;
  StringBuilder sb=new StringBuilder();
  LastItemCaller lic=new LastItemCaller();
  ItemProcessor<String> itemProcessor=getItemProcessor(sb,lic);
  itemProcessor.process(list);
  assertEquals(""String_Node_Str"",sb.toString());
  assertEquals(0,lic.calledWithLastTrue);
  assertEquals(0,lic.calledWithLastFalse);
}"
88991,"@Test public void testNoItems(){
}","@Test public void testNoItems(){
  List<String> list=new ArrayList<String>();
  StringBuilder sb=new StringBuilder();
  LastItemCaller lic=new LastItemCaller();
  ItemProcessor<String> itemProcessor=getItemProcessor(sb,lic);
  itemProcessor.process(list);
  assertEquals(""String_Node_Str"",sb.toString());
  assertEquals(0,lic.calledWithLastTrue);
  assertEquals(0,lic.calledWithLastFalse);
}"
88992,"/** 
 * Checks if the field be added to model fields.
 * @param field Field to checks
 * @return True if the field should be included in model fields. Otherwise false.
 */
private boolean shouldAddField(Field field){
  return !field.isAnnotationPresent(IgnoreField.class);
}","/** 
 * Checks if the field be added to model fields.
 * @param field Field to checks
 * @return True if the field should be included in model fields. Otherwise false.
 */
private boolean shouldAddField(Field field){
  return !field.isAnnotationPresent(IgnoreField.class) && (allowStaticFields || !Modifier.isStatic(field.getModifiers())) && (allowFinalFields || !Modifier.isFinal(field.getModifiers()));
}"
88993,"/** 
 * Creates new field scanner
 * @param fieldDefaultValueProcessor Field default value processor
 * @param annotationProcessorProvider Annotation processor provider
 */
public FieldScanner(FieldValueConverter fieldDefaultValueProcessor,AnnotationProcessorProvider annotationProcessorProvider){
  this.fieldDefaultValueProcessor=fieldDefaultValueProcessor;
  this.annotationProcessorProvider=annotationProcessorProvider;
}","/** 
 * Creates new field scanner
 * @param fieldDefaultValueProcessor Field default value processor
 * @param annotationProcessorProvider Annotation processor provider
 */
public FieldScanner(FieldValueConverter fieldDefaultValueProcessor,AnnotationProcessorProvider annotationProcessorProvider){
  this.fieldDefaultValueProcessor=fieldDefaultValueProcessor;
  this.annotationProcessorProvider=annotationProcessorProvider;
  allowStaticFields=false;
  allowFinalFields=false;
}"
88994,"private void checkAndSetValidationState(Model model){
  for (  ModelField modelField : model.getFields()) {
    if (modelField.hasValidations()) {
      model.setValidations(true);
      break;
    }
  }
}","/** 
 * Checks and sets the validation state for the given model. If the given model has at least one field that requires validation the model property validations will be set to true. If the model doesn't have any validation requirements the property will be set to false.
 * @param model Model to check
 */
private void checkAndSetValidationState(Model model){
  for (  ModelField modelField : model.getFields()) {
    if (modelField.hasValidations()) {
      model.setValidations(true);
      return;
    }
  }
  model.setValidations(false);
}"
88995,"public InvalidType(String s,Throwable throwable,boolean b,boolean b1){
  super(s,throwable,b,b1);
}","public InvalidType(Throwable throwable){
  super(throwable);
}"
88996,"public UnsupportedFramework(String s,Throwable throwable,boolean b,boolean b1){
  super(s,throwable,b,b1);
}","public UnsupportedFramework(Throwable throwable){
  super(throwable);
}"
88997,"public TestModel(){
  longList.add(1L);
  longList.add(100L);
}","public TestModel(){
  longList.add(1L);
  longList.add(100L);
  intStringMap.put(1,""String_Node_Str"");
  intStringMap.put(2,""String_Node_Str"");
  intStringMap.put(100,""String_Node_Str"");
}"
88998,"@Override public String convertValue(Object value){
  return convertArrayFromObject(value);
}","@Override public String convertValue(Object values){
  if (values == null) {
    return getTypeDefaultValue();
  }
  return convertArrayFromObject(values);
}"
88999,"@Override public String convertValue(Object values){
  Collection collectionObject=(Collection)values;
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"");
  final int size=collectionObject.size();
  int i=0;
  for (  Object value : collectionObject) {
    String convertedValue=javaToJSValueConverter.convert(value.getClass(),value);
    sb.append(convertedValue);
    if (i != size - 1) {
      sb.append(""String_Node_Str"");
    }
    ++i;
  }
  sb.append(""String_Node_Str"");
  return sb.toString();
}","@Override public String convertValue(Object values){
  if (values == null) {
    return getTypeDefaultValue();
  }
  Collection collectionObject=(Collection)values;
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"");
  final int size=collectionObject.size();
  int i=0;
  for (  Object value : collectionObject) {
    String convertedValue=javaToJSValueConverter.convert(value.getClass(),value);
    sb.append(convertedValue);
    if (i != size - 1) {
      sb.append(""String_Node_Str"");
    }
    ++i;
  }
  sb.append(""String_Node_Str"");
  return sb.toString();
}"
89000,"@Override public String convertValue(Object values){
  Map<Object,Object> map=(Map)values;
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"");
  final int size=map.size();
  int i=0;
  for (  Map.Entry<Object,Object> entry : map.entrySet()) {
    Object key=entry.getKey();
    Object value=entry.getValue();
    String convertedKey=javaToJSValueConverter.convert(key.getClass(),key);
    String convertedValue=getEntryValue(value);
    sb.append(convertedKey).append(""String_Node_Str"");
    sb.append(convertedValue);
    if (i != size - 1) {
      sb.append(""String_Node_Str"");
    }
    ++i;
  }
  sb.append(""String_Node_Str"");
  return sb.toString();
}","@Override public String convertValue(Object values){
  if (values == null) {
    return getTypeDefaultValue();
  }
  Map<Object,Object> map=(Map)values;
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"");
  final int size=map.size();
  int i=0;
  for (  Map.Entry<Object,Object> entry : map.entrySet()) {
    Object key=entry.getKey();
    Object value=entry.getValue();
    String convertedKey=javaToJSValueConverter.convert(key.getClass(),key);
    String convertedValue=getEntryValue(value);
    sb.append(convertedKey).append(""String_Node_Str"");
    sb.append(convertedValue);
    if (i != size - 1) {
      sb.append(""String_Node_Str"");
    }
    ++i;
  }
  sb.append(""String_Node_Str"");
  return sb.toString();
}"
